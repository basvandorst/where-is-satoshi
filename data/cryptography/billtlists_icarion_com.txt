
@_date: 2003-12-04 22:32:32
@_author: Bill Tompkins 
@_subject: Open Source Embedded SSL - (License and Memory) 
I can't speak to how common it is, but there are applications that
require crypto, and that require some sort of negotiation protocol, that
don't use TCP or Ethernet.  For example- wireless apps, or various
non-ethernet multi-drop wired interfaces.  While these applications do
require some sort of communications stack, it might be less
sophisticated than what you're used to seeing with TCP/IP (and might be
mostly implemented in off-CPU hardware).
For systems like this, there's probably no requirement to use SSL
(unless it is talking through a gateway to some TCP device), but there
is a requirement for the underlying crypto library, and some protocol
that uses it.  As you've mentioned here before, designing a protocol
that is as secure as SSL is hard, and there's no sense re-inventing the
wheel, so why not use SSL?
Certainly, any system big enough to use SSL could have a simple block
allocator.  My complaint is with the non-determinancy (and implied error
checking/handling) that accompany variably-sized allocations and
reallocations.  As John Gilmore pointed out to me in an email, if the
library were simple enough to use static buffers, but did use memory
allocation, then the user could pre-determine the sizes and times of
memory allocation and write a simple block allocator to suit the
requirements of the library.  In this case, the behavior of the library
would again be deterministic.
I don't mean to be making a big deal about the memory allocation issue;
it's probably more a pet peeve of mine than an industry-wide concern. But it is something that would concern me if I was trying to do some
formal analysis to certify an embedded device (although I'm certainly no
expert on such things), or make a device that was simply never allowed
to fail or reset.

@_date: 2003-11-25 20:54:55
@_author: Bill Tompkins 
@_subject: Open Source Embedded SSL - Export Questions 
is the US Dept of Commerce site that has the regulations
has the details about what letter you send where for "Publicly
Available" source code.  You'll want to read the regulations to verify
that the code does qualify as "publicly available", etc...
No, I'm not a lawyer, and no, this was not legal advice.
I am, however, an embedded software developer, and am looking forward to
seeing the code :)  I'm guessing the details of the software and license
are already set, but just in case they aren't, I've got a couple of
1) Not GPL or LPGL, please.  I'm a fan of the GPL for most things, but
for embedded software, especially in the security domain, it's a
killer.  I'm supposed to allow users to modify the software that runs on
their secure token?  And on a small platform where there won't be such
things as loadable modules, or even process separation, the (L)GPL
really does become viral.  This is, I think, why Red Hat releases eCos
under a non-GPL (but still open source) license.
2) Make it functional on systems without memory allocation.  Did I
mention that I work on (very) small embedded systems?  Having fixed
spaces for variables is useful when you want something to run
deterministically for a long time with no resets, and I have yet to find
a free bignum library that didn't want to use malloc all the time.
Thanks in advance for the code release,
