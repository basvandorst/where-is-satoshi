
@_date: 2015-11-12 14:41:34
@_author: allen@bearbonds.org 
@_subject: [Cryptography] Bear Bonds - a new crytpocurrency 
I'm involved in a project to create a new cryptocurrency called Bear  One of the notable cryptographic features of Bear Bonds is that is  uses zero knowledge proofs to achieve privacy.  It uses a construction  similar to that proposed by Ben-Sasson, et. al., in [BCTV14a] with the  soundness correction proposed by Parno in [P15].  This is also similar  to the construction proposed for [Zerocash] that never came to  fruition (I believe because of its impractical processor time and  memory requirements).
In order to achieve acceptable speeds, Bear Bonds uses a novel hash  algorithm that involves three knapsacks and a Diophantine polynomial  all computed in the prime field.  The details are given in the "Bear  Bonds Transaction Protocol" paper that can be found on our website at   (at the bottom of the "Technology" tab).   We also have a pre-release version of our software that can be found  under the "Software" tab (binaries only--the source code has not yet  been released but we would be willing to provide it for research or  security auditing purposes).
The time required to create a proof on a midrange laptop is roughly 4  seconds per input, with a modest memory requirement of 85 KB per input.
We of course welcome comments and questions.
Thank you,
[BCTV14a] Succinct Non-Interactive Zero Knowledge for a von Neumann
Architecture, Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, Madars Virza,
[P15] A Note on the Unsoundness of vnTinyRAM's SNARK, Bryan Parno,
[Zerocash] Zerocash: Decentralized Anonymous Payments from Bitcoin, Eli Ben-
Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,  Eran Tromer,
Madars Virza,

@_date: 2015-11-14 18:20:41
@_author: allen@bearbonds.org 
@_subject: [Cryptography] Bear Bonds - a new crytpocurrency 
The hash algorithm is not used for mining, it is used in the zero  knowledge proof.
The creator of a transaction has to include a proof that the values in  the transaction satisfy the transaction constraints.  The most time  consuming constraint is to prove membership in the Merkle tree.  This  requires from 48 to 64 hashes (depending on the capacity of the tree).
The hash we use consists of two knapsacks mixed together by a  Diophantine polynomial of order 256 computed in the prime field, and  then finished by another knapsack.  These computations are much more  efficient to verify in a zero knowledge constraint system than the  bit-oriented operations in SHA-256 and all other commonly used hash  algorithms.  Using SHA-256 would require at least 10 times the  processing time.  For example, on a midrange laptop, our algorithm  requires about 8 seconds to prove a transaction with 2 inputs and 2  outputs.  Using SHA-256 would take at least 80 seconds.
We believe our hash algorithm is just as secure (i.e., one-way and  collision resistant) as any other hash with a 256 bit output, and we  invite anyone to analyze it to confirm this.  The details of the  algorithm can be found in the "Transaction Protocol" document posted  on our website at  under the "Technology" tab.
Existing hash algorithms are not designed for efficient verification  by a zero knowledge proof, and that is why we created a new one.  We  believe it is well-suited for that purpose, and just as secure.
