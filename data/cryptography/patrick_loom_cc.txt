
@_date: 2002-11-07 19:36:41
@_author: Patrick Chkoreff 
@_subject: Did you *really* zeroize that key? 
Thanks for the reminder about "volatile."  It is an ancient and valuable feature of C and I suppose it's implemented correctly under gcc and some of the Windoze compilers even with high optimization options like -O2.
Everybody probably also knows about the gnupg trick, where they define a recursive routine called "burn_stack":
static void
burn_stack (int bytes)
     char buf[64];
     memset (buf, 0, sizeof buf);
     bytes -= sizeof buf;
     if (bytes > 0)
         burn_stack (bytes);
Then there's the vararg technique discussed in Michael Welschenbach's book "Cryptography in C and C++":
static void purgevars_l (int noofvars, ...)
   va_list ap;
   size_t size;
   va_start (ap, noofvars);
   for (; noofvars > 0; --noofvars)
     {
       switch (size = va_arg (ap, size_t))
         {
           case 1:  *va_arg (ap, char *) = 0;
                    break;
           case 2:  *va_arg (ap, short *) = 0;
                    break;
           case 4:  *va_arg (ap, long *) = 0;
                    break;
           default:
                    memset (va_arg(ap, char *), 0, size);
         }
     }
   va_end (ap);
Here's an example of how you might call the routine:
   purgevars_l(2, sizeof (la), &la,
                    sizeof (lb), &lb);
But hey, if "volatile" keyword works then so much the better.  I would recommend examining the assembly language output of your compiler to verify that it honours "volatile."

@_date: 2002-11-07 19:54:57
@_author: Patrick Chkoreff 
@_subject: Did you *really* zeroize that key? 
Oops, I missed your real point, which is that "volatile" ought to suffice as a compiler guide and there is no need for an additional pragma.  By declaring a variable as volatile, the compiler would also leave untouched any code which refers to that variable.
Too bad that volatile is not guaranteed to work in all major ANSI-compliant compilers.  Oh well.  I wonder how gcc does with it?
[Moderator's note: I've quoted chapter and verse -- if it follows the
current standards, it is required to honor "volatile". It isn't
compliant by definition if it does not. gcc does indeed honor
"volatile", as do almost all other C compilers I have access to. --Perry]
I guess we should stick with either the recursive routine trick or the var-arg trick.
