
@_date: 2017-04-02 21:50:18
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Removal of spaces in NIST Draft SP-800-63B 
password-reset --> E-mail temporary password to user:
Ick.  E-mail doesn't always arrive in < 15-20 minutes!  Sometimes a
mail-relay machine has a temporary error condition and mail gets queued
for a while.  Or a message gets caught in a greylisting queue (and hence
waits 4-24 hours before being retransmitted and delivered).  Or some
"helpful" software on the user's computer decides that this is a good
time to install updates.
And, *humans* don't always sit at an E-mail-capable device 24/7.  Even
humans who are expecting an important E-mail sometimes still engage in
non-internet-connected activities, returning later to catch up on their
FWIW, the shortest expiration time I've ever personally seen for a
"please confirm your message to the FOO mailing list" token was 48 hours,
with 3-7 days being more common.

@_date: 2017-04-04 00:18:39
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Removal of spaces in NIST Draft SP-800-63B 
I don't usually do "me to", but this is so important it deserves
I tend to do more like
  dd if=/dev/arandom bs=50 count=1|alphanumeric.encode
(in another window, on an OS where /dev/arandom is a high-quality
cryptographic random-number generator) and cut-n-paste 15-20 characters
from the output of that command into my "password-manager" and into the
offending web form.  Even if the website internally mono-cases the
password (as, e.g., one of my utility-bill-payment sites does),
that still gives > 5 bits of entropy/character.
Some web forms then complain that I must have (e.g.) >= 1 digit,
 >= 1 punctuation character (often without telling me the allowed set
of punctuation characters), >= 1 lower-case letter, and >= 1 upper-case
letter.  Since I already have plenty of entropy I just change one or two
of the characters to punctuation marks by hand, not bothering to use a
full cryptographic-random-number generator for those.
But the final entry into the web form is always by cut-n-paste if
it's allowed.  Disabling pasting into the webform is the (yet another)
mark of a clueless website.

@_date: 2017-04-08 16:07:06
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Removal of spaces in NIST Draft SP-800-63B 
alphanumeric.encode is a quick-n-dirty perl program I wrote to convert
random binary data into random characters from [a-zA-Z0-9] or [a-z0-9]:
[[I don't know if (short) code is appropriate for the cryptography mailing
list -- if our Esteemed Moderator wants to reject this that's fine, and
I'll mail the code privately to anyone who wants it.]]
 -w
use strict;
use Getopt::Long;
my $false = 0;
my $true  = 1;
my $help_msg = <<'EOF';
   dd if=/dev/arandom bs=100 count=1 | alphanumeric.encode
   dd if=/dev/arandom bs=100 count=1 | alphanumeric.encode  --lower-case
By default, this program encodes standard input binary-data into mixed-case
alphanumeric characgers ([a-zA-Z0-9]).
If the --lower-case option is specified, then this program encodes into
lower-case alphanumeric characters ([a-z0-9]).
# At present we do the encoding "by hand".
# FIXME: It would probably be better to not reinvent the wheel here,
#        and instead use an existing Perl module such as Math::Int2Base
#        or Math::Base::Convert.
# Mixed-case:
#   Since 2*26+10 = 62, and 62**3 = 14776336 = less than 256**3 = 16777216,
#   we can encode 3 chars (24 bits) of binary input into 4 base62 output
#   characters.  If we get an "unencodable" input 3-tuple we just discard
#   it and try again with the next input 3-tuple.
# Lower-case
#   Since 26+10 = 36, and 36**3 = 46656 = less than 256**2 = 65536,
#   we can encode 2 chars (16 bits) of binary input into 3 base36 output
#   characters.  If we get an "unencodable" input 2-tuple we just discard
#   it and try again with the next input 2-tuple.
my $debug           = 0;
my $help_flag       = $false;
my $lower_case_flag = $false;
  'debug=i'    => \$debug,
  'help'       => \$help_flag,
  'lower-case' => \$lower_case_flag,
if ($help_flag)
my $N_in     = $lower_case_flag ? 2 : 3;
my $in_base  = 256;
my $in_limit = $in_base ** $N_in;
my $N_out        = $lower_case_flag ? 3 : 4;
my  = $lower_case_flag ? (0..9, 'a'..'z')
my $out_base     = scalar(
my $out_limit    = $out_base ** $N_out;
if ($debug > 0)
my $count_on_line = 0;
my $buffer;

@_date: 2017-12-14 17:06:11
@_author: Jonathan Thornburg 
@_subject: [Cryptography] High volume thermal entropy from an iPhone 
Doing SecureCryptoHash(dark frame) is the easy part.
The hard part is convincing yourself that that "dark frame" (which you
just got from some  ReadRawImage API is really "the dark signal" and
hasn't been processed either "helpfully" (i.e., in ways which would be
"helpful" for a typical phone picture) or maliciously.
We're doing crypto, so we have to assume malicious adversaries about.
(After all, if there weren't malicious adversaries about, we could
just take AES(key=counter++, data=0xdeadbeef) for randomness.)  That
means we need to worry about all the layers of software & firmware
that lie between our crypto code and the bare hardware.

@_date: 2017-02-28 10:19:51
@_author: Jonathan Thornburg 
@_subject: [Cryptography] jammers, nor not 
Unless your entire home is wrapped in aluminum foil (including
rf-blocking coatings on all windows (permanently closed!)), it's hard
to *use* a {printer, refrigerator, washing mashine, coffee maker, ...}
while said object is wrapped in aluminum foil. :)

@_date: 2017-07-18 18:23:13
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Raspberry Pi-like FPGA ?? 
I found this tutorial on some of the "nuts and bolts" to be very nice:

@_date: 2017-07-26 06:49:38
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Encrypted flash drives: Secure? 
Using this means trusting the hardware manufacturer to get crypto right.
Past history is not encouraging:
    AES is all well and good, but is it in ECB mode?  Are expanded keys
stashed somewhere accessible?  Software is already hard to audit, but
closed-source firmware/hardware is even worse.  And if this system is
really good, you have to worry about various countries' spy agencies
"persuading" the manufacturer to put in backdoors.  Ick.

@_date: 2017-03-08 11:53:43
@_author: Jonathan Thornburg 
@_subject: [Cryptography] encrypting bcrypt hashes 
What about salting the hash?
More generally, what's the threat model?
(Online attacks?  Offline attacks after someone steals the database of
hashed PINs?  Something else?)

@_date: 2017-11-12 21:15:59
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Is ASN.1 still the thing? 
No for YAML.
Causes of non-uniqueness for YAML include
* Booleans have multiple representations (
* floating-point values can have extra trailing zeros, and/or could be
  non-normalized (e.g., 1.23e6 and 12.3e5 are two distinct string
  representations of the same floating-point number)
* arrays/lists have two different allowed representations in YAML

@_date: 2017-11-22 17:03:54
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Intel Management Engine pwnd (was: How to find 
Hardware is just as vulnerable to security bugs as software/firmware. :(
Looking at the errata for a modern high-end microprocessor can be quite
ciao, -- Jonathan

@_date: 2017-09-24 18:08:50
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Crypto basic income 
The only safe solutions are
(1) don't use biometrics, or
(2) assume as part of the basic system design that all biometrics are
    non-secret, i.e.,
    (2a) the biometric will sooner or later be leaked/stolen/compromised
         (with, as you noted, "biometric rollover" usually impossible),
         and/or
    (2b) the biometric is inherently broadcast to the owner's immediate
         surroundings and can be surreptitiously recorded without the
         owner's knowledge (e.g., facial appearence, iris patterns,
         voiceprints, fingerprints).
This implies that biometrics can at most prove identity, or more
precisely continuity-of-identity from time-of-enrollment to time-of-use.

@_date: 2017-09-25 17:44:52
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Crypto basic income 
This would imply that users might well be effectively forced to provide
DNA samples in various places.  (E.g., if a government were to require
a DNA sample before issuing a driver's license or passport.)  This in
itself might be ok *if* one were to trust an elected government -- and
all future governments -- not to misuse or mission-creep-use the sample
for unrelated things.
But once that database exists, history shows that mission creep is very
likely, including nonconsentual or forced-"consentual" commercial uses.
The classic example is an insurance company buying (enough of a government
to allow) access to the database and then using it to deny life insurance
coverage to anyone with a high-risk-of-disease DNA profile.  (This is
already an issue with medical records, where it's essentially impossible
to buy individual life insurance in the US or Canada without "consenting"
to the Medical Information Bureau
  searching one's medical records.)
The underlying problem is that knowing someone's DNA sequence reveals
a lot of other information about a person apart from their identity,
This isn't the case for most other good biometrics (e.g., fingerprints
or iris patterns).

@_date: 2018-08-14 21:32:51
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Throwing dice for "random" numbers 
If one has (and is willing to trust) a computer, random alphanumeric
passwords can be generated by
  % dd if=/dev/random bs=50 count=1|alphanumeric.encode where the following script should be somewhere in your search path:
 -w
use strict;
use Getopt::Long;
my $false = 0;
my $true  = 1;
my $help_msg = <<'EOF';
   dd if=/dev/arandom bs=100 count=1| alphanumeric.encode
   dd if=/dev/arandom bs=100 count=1| alphanumeric.encode  --lower-case
By default, this program encodes standard input binary-data into mixed-case
alphanumeric characgers ([a-zA-Z0-9]).
If the --lower-case option is specified, then this program encodes into
lower-case alphanumeric characters ([a-z0-9]).
# At present we do the encoding "by hand".
# FIXME: It would probably be better to not reinvent the wheel here,
#        and instead use an existing Perl module such as Math::Int2Base
#        or Math::Base::Convert.
# Mixed-case:
#   Since 2*26+10 = 62, and 62**4 = 14776336 = less than 256**3 = 16777216,
#   we can encode 3 chars (24 bits) of binary input into 4 base62 output
#   characters.  If we get an "unencodable" input 3-tuple we just discard
#   it and try again with the next input 3-tuple.
# Lower-case
#   Since 26+10 = 36, and 36**3 = 46656 = less than 256**2 = 65536,
#   we can encode 2 chars (16 bits) of binary input into 3 base36 output
#   characters.  If we get an "unencodable" input 2-tuple we just discard
#   it and try again with the next input 2-tuple.
my $debug           = 0;
my $help_flag       = $false;
my $lower_case_flag = $false;
  'debug=i'    => \$debug,
  'help'       => \$help_flag,
  'lower-case' => \$lower_case_flag,
if ($help_flag)
my $N_in     = $lower_case_flag ? 2 : 3;
my $in_base  = 256;
my $in_limit = $in_base ** $N_in;
my $N_out        = $lower_case_flag ? 3 : 4;
my  = $lower_case_flag ? (0..9, 'a'..'z')
my $out_base     = scalar(
my $out_limit    = $out_base ** $N_out;
if ($debug > 0)
my $count_on_line = 0;
my $buffer;

@_date: 2018-12-30 11:03:50
@_author: Jonathan Thornburg 
@_subject: [Cryptography] blake2b 160 
What's your threat model?
If your thread model is truly "no one" and "ever", this is going to be
very, very hard.
Ok, so let's relax the thread model to say that (as an approximation to
"no one" and "ever") you want resistance to (say) the sort of effort the
NSA might mount against a major Rusian or Chinese cryptosystem, i.e.,
several hundred PhD-level researchers, a budget measured in billions of
dollars, and a decade of effort.  And you don't care about the CPU/memory
cost of computing the hash function.
So now you probably want to think very carefully before using the word
"overkill" in your system design.
Are there any constraints on the colliding data blocks?  I.e., does the
attacker have complete freedom to choose *any* data blocks in trying to
construct a collision?
Can you combine multiple "good" hash functions in a way that makes the
combination much harder to break than any individual one?  What sort of
breaks are now known against (say) MD5 (a "good" hash function from a
while back, which is now rather broken), and how can you combine multiple
(todays-state-of-the-art) hash functions in a way which would defeat
those breaks?
Can you inject nonces in key places?
As a non-crypto-guru, I would think along the lines of
  # random constants have lengths which makes the different hash fn's
  # blocks straddle each other
  H1 = hash_fn1(data)
  H2 = hash_fn2(H1, 0xarandomconstant, data)
  H3 = hash_fn3(H1, 0xsomerandomconstant, H2, 0xanotherrandomconstant, data)
  final_hash = H1 || H2 || H3
or even
  # nonces also have varying lengths chosen to make hash fn block straddle
  H1 = hash_fn1(nonce1, data, nonce2)
  H2 = hash_fn2(nonce3, H1, nonce4, data, nonce5)
  H3 = hash_fn3(nonce6, H1, nonce7, H2, nonce8, data, nonce9)
  final_hash = H1 || H2 || H3
  final_nonce = nonce1 || nonce2 || nonce3 || nonce4
 nonce5 || nonce6 || nonce7 || nonce8 || nonce9

@_date: 2019-08-26 09:29:41
@_author: Jonathan Thornburg 
@_subject: [Cryptography] The best TRNG architecture, comming soon? 
[[ring oscillator with an even number of inversions in the loop,
and two NAND gates at opposite points in the loop]]
Problem: what if the layout (& hence 0->1 and 1->0 propagation times)
is such that (say) inverter  in the loop is a lot slower than the
others *and* has asymmetric rise/fall?  The result could well be that
when the first edge reaches inverter  it's slow to propagate, so
the second edge catches up with it right there (inverter  resulting
in the "TRNG" outputting a stream of constant values.  :(
The only way I can see to rule out my scenario is very careful layout
and analog design/simulation/verification.

@_date: 2019-02-16 20:56:19
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Questions of taste on UDF presentation 
Using this requires that I (a potential user) scan lots of QR codes.
In the real world, that's not a very prudent thing to do:
* What if one of these QR codes pwns my phone?
* What if one of these QR codes signs me up for even more spam?
* What if one of these QR codes takes me to a nasty website while
  I'm in a country with a "one strike" law?
The basic problem is that there's no easy way to tell what a QR code
is going to do without doing "it".  And trusting a random crumpled
receipt that says "Starbucks" and has the Starbucks logo on it,
doesn't seem a lot safer than trusting a random website that says
"Starbucks" and has the Starbucks logo on it.
As Jerry Leichter wrote on 2014-09-12 in this mailing list
(message-id )

@_date: 2019-01-05 11:29:05
@_author: Jonathan Thornburg 
@_subject: [Cryptography] blake2b 160 
Would the following method provide a practical-for-the-NSA attack?
Parallel hash collision search by Rho method with distinguished points
  Brian Weber, Xiaowen Zhang
  Published 2018 in 2018 IEEE Long Island Systems, Applications and...
In this paper, we realized a memory efficient general parallel
Pollard's rho method for collision search on hash functions introduced
by Van Oorschot and Wiener in 1996. This utilizes the principles
of the birthday paradox to greatly increase the probability of a
finding a collision, while using significantly less memory than the
classic birthday attack, and allowing a larger portion of the subject
hash function to be searched before running out of memory by saving
only a few select digests called distinguished points. Using our
implementation, we are able to find an average of 50 MD5 half
collisions in the first hour of searching using a distributed memory
high performance computing system called Penzias (one of CUNY HPC
systems) on 32 processors. We then extend the technique with Cyrillic
character replacement to search for meaningful MD5 half collisions.
Next we analyze and measure how the performance of our implementation
scales with different processor counts. Finally, we experiment with
how the rarity of distinguished points affects the rate at which
collisions are found at varying numbers of processors. LESS
full paper (paywalled) at

@_date: 2019-10-18 19:20:50
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Very best practice for RSA key generation 
This produces a very non-uniform choice of primes (p,q): a prime which
immediately follows a long sequence of non-primes will be chosen much
more often than a similarly-sized prime which has another prime just
slightly smaller than it.
That is, for any prime k, let gap(k) = k - (the largest prime < k).
Then the quoted algorithm will choose k with probability roughly
proportional to gap(k).
For example, using small numbers for convenience, a few consecutive
primes slightly bigger than a million are
   1004797
   1004873
   1004903
Therefore any p0 in the range 1004797 <= p0 < 1004873 would yield p=1004873,
while any p0 in the range 1004873 <= p0 < 1004903 would yield p=1004903.
Since there are 106 numbers in the first range, but only 8 numbers in
the second range, p=1004873 is roughly 13 times more likely to be
chosen than p=1004903.  The same argument obviously applies to q0.

@_date: 2019-09-16 20:21:22
@_author: Jonathan Thornburg 
@_subject: [Cryptography] "Exclusive: Russia carried out a 'stunning' 
Hmm, this looks all too relevant:
   Sandy Clark, Travis Goodspeed, Perry Metzger, Zachary Wasserman,
   Kevin Xu, and Matt Blaze
   "Why (Special Agent) Johnny (Still) Can't Encrypt:
    A Security Analysis of the APCO Project 25 Two-Way Radio System"
   Proceedings of the 20th Usenix Security Symposium, August 10-12, 2011
   The paper states that this (P25) radio system "has recently enjoyed
particularly widespread adoption by the federal government for the
tactical radios used for surveillance and other confidential
operations by Federal law enforcement agencies such as the DEA, FBI,
the Secret Service, ICE, and so on."
"We found a number of protocol, implementation, and user interface
weaknesses that routinely leak information to a passive eavesdropper
or that permit highly efficient and difficult to detect active attacks."

@_date: 2020-01-02 11:39:42
@_author: Jonathan Thornburg 
@_subject: [Cryptography] IEEE Spectrum: The Crazy Story of How Soviet 
There's a fascinating (now-declassified) NSA history of this project,
  Sharon A. Maneki
  "Learning from the Enemy: The GUNMAN Project"
  Center for Cryptologic History
  National Security Agency
  2012
Your favorite search engine should find the pdf online at the NSA website,
as well as cached copies at various sites.

@_date: 2020-10-01 17:15:48
@_author: Jonathan Thornburg 
@_subject: [Cryptography] Exotic Operations in Primitive Construction 
Another example: the Digital J-11 (a PDP-11 implementation used in
the PDP-11/73 and PDP-11/83 systems) had a microcode bug in the
arithmetic-shift instructions which caused a "left-shift by 31 bits"
instruction to actually execute a right-shift.  See
  for details.
