
@_date: 2005-12-04 06:18:25
@_author: Greg Black 
@_subject: [Clips] Banks Seek Better Online-Security Tools 
I've been using it for me and my wife with 3 banks since they
first offered it; I use it every week to pay all our bills and
would not be without it.  The benefits I have gained from not
having to waste time doing things the old way have proved to be
substantial and I get to notice and resolve the occasional error
(always in the form of fraudulent debits to credit cards) much
faster than in the old days when I had to wait for the monthly
It's probably not related to my use of online banking, but it
has also been noticeable that fraudulent debits to our credit
cards have dropped from about 5 per card per year five years ago
to one such debit to the 6 cards we use in the past two years.
I detest banks and have had many battles with them over various
issues over the years, but I remain confident that my careful
practices, meticulous record keeping and careful management of
passwords will continue to give me the edge in any dispute with
them.  And the cost to me of any such disputes seems unlikely to
be anything like the benefits I have gained from online banking.

@_date: 2005-09-18 07:30:29
@_author: Greg Black 
@_subject: Clearing sensitive in-memory data in perl 
It (the creation of such a library) has been done many times;
admittedly, widespread adoption has not happened at all.
Only for people who find it easier to use a huge clunky tool
they will never fully know than a clean simple language which
can be used to write completely reliable software.  Of course,
C's simplicity is its danger:  any idiot who can spend a few
hours with a C for Dummies kind of book can imagine that he's
competent to write in C.  As with any sharp tool, careful use is
mandatory to avoid nasty cuts; thorough understanding is needed
to ensure safe handling.
We don't expect people to fly commercial aircraft without taking
the time to become suitably skilled.  We don't expect people to
start doing brain surgery without having appropriate training.
Software is complex stuff; it takes time to acquire skills with
it.  For those with the skills, C is an excellent tool.  It's
not perfect, but it's the best thing we have and it's well able
to do the things we ask of it.  The problem is bad programmers.
Agreed, the STL (and C++) is no answer.
While you make some valid points in that article, I take issue
with much of it.  For instance, you cite "[a] large body of code
that provides bad examples" as one of the big faults with C.
This is just not a valid argument.  (Yes it's true: there is
such a body of code, but it's not an argument.)
The classic book of examples of bad programming, "The Elements
of Programming Style" by Kernighan and Plauger, dates back to
the days before C.  Its examples are in Fortran and PL/1.  It is
full of the same kind of blunders we are talking about here.
It's not the language, it's the programmers who are at fault.
The only reason that we see much in C is that, for the past 25
years, most widely-seen software has been written in C.
I haven't followed any news about that.  Anything that comes out
of Microsoft won't be worth considering -- nothing from there
has been good in the past, so there's no reason to think that
might change.  More to the point, it takes many years before
stuff like that becomes widely available (and therefore
usable).  We don't need new tools; we just to learn to use the
ones we have effectively.
The comments you make about seat belt and air bags don't make
much sense either.  Their purpose is to save our lives after we
have made a potentially fatal mistake.  After all, there's a big
mess to clean up when those things are used, so it's not like we
want them to play an active part.
This is also a question of culture.  Everybody thinks they have
the right to drive but no responsibility to learn how to do it
well.  So, since bad driving causes so many deaths, governments
mandate all sorts of after-the-accident safety gadgets.  If they
mandated proper skill and attitude training before allowing
people to drive, we'd save a lot more lives.  Equally, if the
software community started to expect suitable training and
skills in programmers, we'd solve most of our current problems.
To return to the original point.  Every serious C programmer who
cares about his work has known forever that the C standard
library serves only as a basic low-level building block for use
in creation of real libraries that suit the project at hand.  It
also contains a few simple functions, like gets() and the other
maligned string-handling functions, that serve as quick and
dirty gadgets for programmers to use when writing a quick bit of
test code for their own use where security and safety are not at
all important, but checking something else quickly is the goal.
I have written C code that has been running daily in commercial
environments for over 20 years that has never had a failure, as
a result of buffer overflows or any other bugs.  I'm not unique.
But I do see lots of people writing C who seem to think that
they have the right to do it as badly as they like, even though
they know you have to be properly qualified to work in other

@_date: 2005-09-19 07:02:51
@_author: Greg Black 
@_subject: Clearing sensitive in-memory data in perl 
K & R did not write C, they wrote a book about C.  R was the
creator of the language, with some inspiration and collaboration
from some others Labs, mainly Ken Thompson.  For the
history, see DMR's paper "The Development of the C Language" at
Re the book, BWK wrote the descriptive part and DMR wrote the
appendix that described the language.  Not surprisingly, BWK's
part has most of the real errors (as distinct from typos).
Dennis wrote C for Ken (and for his own amusement).  It was
adopted by other people at Bell when they saw how useful it was
and escaped for the same reason.
Indeed it's not.  In particular, our world has bad guys and
cheap, powerful hardware with no constraints on memory or
particular needs for efficiency.
If somebody like Ritchie sat down today to write a new language
to replace C, then it would indeed be different and people with
real work to do might even switch to it.  But not one language
that has appeared since C is as useful and every language that
has appeared since then has had significant disadvantages in
comparison.  The only languages that strike me as being in any
way comparable are the Lisp family -- but they are useless for
system programming, and so people like me tend to stick to C
since it can do everything.  (Of course, I use other languages
as well; but C is the basis of everything I do.)
One is never /forced/ to use C.  One chooses the tools to best
do the job.  One day, I'll package up my string library, which
would then be my recommendation.  As it is now, it's used in
quite a few places where I have consulted (since working with
software teams almost always involves teaching them to use C
effectively).  The only string library that I'm aware of that's
freely available is Dan Bernstein's stralloc[1] library and its
array library[2] successor:
  [1]   [2] These both have disadvantages common to all DJB code: weird
licensing, unreadable style, and somewhat fanatic admiration of
his own work in preference to all other work.  However, for
somebody wanting some ideas for implementation of their own
library, these might make a useful starting point.
Bear in mind that, even though we are not all Ritchies, those of
us who work with software can learn to use sharp tools if we
take the time to do it and put in the work required.  If that's
really too much, then there are always buses that need drivers.

@_date: 2005-09-21 10:38:41
@_author: Greg Black 
@_subject: Java: Helping the world build bigger idiots 
No, we got here because we didn't know basic C usage.  Come on
people, please stop creating these fake illustrations.
A real C programmer would have known that, if i == lim, there
was no match.  This is so trivial it beggars belief that it
needs to be pointed out in a forum like this.
It only draws gasps from people who don't know C.  The goto that
is famously considered harmful is not spelled "goto" in C, but
rather "longjmp"; it's not used all that often and does need
careful handling.  The C goto statement is purely a local goto
and scares nobody who has grown up.

@_date: 2006-02-25 08:56:52
@_author: Greg Black 
@_subject: NPR : E-Mail Encryption Rare in Everyday Use 
That's at least partly because too many mailing lists either
reject signed messages out of hand or, worse, have subscribers
who use providers that reject signed messages and then spam you
with their idiotic bounce messages.  Keeping track of which
lists allow signed email and which don't is impractical if you
subscribe to hundreds of lists, so the simple thing is to tick
the "don't sign" box on list messages.
In this case, since Peter's message was signed, I know this list
allows signatures.  So I'll sign this message.
But the signature will be of limited utility, as not one of the
several email addresses on my signature is a match for the email
address I am sending this from.  Again, lists being what they
are, I use a different address for most lists and my PGP key
would become absurd if I added several hundred addresses to it.
I personally would prefer to sign every email I send.  I'd also
prefer to encrypt all non-public messages.  I am fully competent
in the use of the current technology, but it turns out to be not
practical to use.

@_date: 2006-09-29 09:15:18
@_author: Greg Black 
@_subject: A note on vendor reaction speed to the e=3 problem 
This is incorrect.  Hundreds of people have developed such tools
and use them regularly.  I've never bothered to look for any
published versions, because my own tool works for me, but I'd be
surprised if there weren't any out there in the wild.

@_date: 2007-04-23 09:39:10
@_author: Greg Black 
@_subject: More info in my AES128-CBC question 
Not at all.  That would be smart.  Blind deference to experts, in any
field, is just plain stupid.
Asking the professionals to make a clear case is not the same as freely
ignoring them.  But blindly following those who speak with authority
leads to all sorts of nonsensical outcomes.
If we are consulting an expert, it behoves us to examine the expert's
reasoning.  If we are the experts, we should expect to have to explain
ourselves to those who rely on us -- and we should volunteer those
explanations rather than making people drag them out of us.
Cheers, Greg

@_date: 2008-06-03 12:42:43
@_author: Greg Black 
@_subject: Fwd: Protection mail at rest 
Not to rain on your parade, but 1,000 messages is *not* a large inbox
and 2 to 4 minutes is a very long time to wait.  You'd need to make this
two orders of magnitude faster before it would have a hope of being
interesting.  (And for me, it would have to be at least four orders of
magnitude faster before I could consider it to be useful.)
