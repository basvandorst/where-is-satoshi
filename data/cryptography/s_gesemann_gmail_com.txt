
@_date: 2015-08-09 16:08:35
@_author: Sebastian Gesemann 
@_subject: [Cryptography] SHA-3 FIPS-202: no SHAKE512 but SHAKE128; 
That's not their security. Their security is 112 up to 256. We don't
use 512 bits of output because we need a preimage resistance of 2^512.
We use 512 bits of output because they are necessary for collision
resistance of 2^256.
128 and 256 are the "standard security levels" we know from AES already.
Even in the quantum computer context, 256 is perfectly fine and 512
rather meaningless.
The SHAKEs can be used as a DRBG (deterministic random bit generator)
or an MGF (mask generation function, something you use in RSA-OAEP and
RSA-PSS, for example).
You can also use them if you need a faster hash. Just pick the desired
security level (s=128 or s=256), an appropriate digest length d and
use SHAKE-s with d bits of output. If you care about collision
resistance use d=2s, otherwise d=s should be fine. So, with the SHAKEs
you are pretty flexible in that you can choose the security level s
and output length d independently for a better security/speed
trade-off. Given SHAKE-s with d bits of output you get a 1st and 2nd
preimage resistance of 2^min(s, d) and a collision resistance of
2^min(s, d/2).
In the quantum computer context (using Grover's algorithm) this should
drop down to preimage resistance of 2^min(2s/3, d/2) and a collision
resistance of 2^min(2s/3, d/3) I believe.

@_date: 2015-07-24 13:46:42
@_author: Sebastian Gesemann 
@_subject: [Cryptography] Fwd:  Whitening Algorithm 
Oops, I mistakenly sent my response as PM and not to the list.
I see I'm one of three people that likes cryptographic sponges. :)
---------- Forwarded message ----------
What you do is basically a convolution in a 256-element Galois field.
It's a linear filter with the following difference equation:
    out[n] = in[n] + in[n-1] + in[n-4] + in[n-5]   (+ means XOR)
This filter is easily invertible. Sure, it might fool the statistical
tests but this wouldn't mean you magically created some entropy out of
nothing. You didn't. The entropy is still below 1.
Depending on what your goal is, you might want the entropy per output
bit to be 1. This *requires* a reduction in the output rate.
If you're interested in a high output rate and are fine with "entropy
stretching" (eg. faking entropy in a "cryptographically secure" way)
you *can* do whitening and entropy stretching in one go. But it takes
more than just 3 XORs. I've grown quite fond of cryptographic
sponge-like constructions. They can "absort" bits and if you "squeeze"
them, they produce bits. Here's a pseudo code example:
   S = 0^512;  # state vector initialized to 512 zero bits
   e = 0.1;    # entropy estimate for input per bit
   r = 3;      # output rate relative to input rate
   nin  = ceil(256/max(1,r));  # no more than 256 bits at a time
   nout = floor(256*min(1,r)); # no more than 256 bits at a time
   # Fill the state with "enough" entropy before outputting anything
   for k in range(ceil(1/e)):
       S(0:256) = fetch_biased_bits(256); # overwrite first 256 bits
       S = P(S); # apply bijection P on the whole 512 bit state
   while True:
       S(0:nin) = fetch_biased_bits(nin); # overwrite first nin bits
       S = P(S); # apply bijection P on the whole 512 bit state
       write(S(0:nout)); # output nout bits
Here, P is some "pseudo-random" bijection. The asymptotic entropy per
output bit should be max(1, e/r). And if e/r<1 this is whitening +
entropy stretching. if e/r>=1 you just do whitening. In the case e/r<1
P should be chosen to be "cryptographically good", for example 8
rounds of ChaCha20's round function which conveniently happens to map
512 bits to 512 bits. But this function might be overkill for the case

@_date: 2015-07-24 14:04:57
@_author: Sebastian Gesemann 
@_subject: [Cryptography] Whitening Algorithm 
Ok, 1600 = b = r + c. What's your choice of r and c for rate and
capacity? What's a typical entropy estimate for your input bits? And
do you use the full 24 rounds of Keccak-F[1600]?
