
@_date: 2002-10-22 15:05:46
@_author: Wei Dai 
@_subject: Why is RMAC resistant to birthday attacks? 
Call the Jan 21 document x, and the Sept 30 document y. Now Bob knows
MAC_Alice(x | z) = MAC_Alice(y | z) for all z, because the internal states
of the MAC after processing x and y are the same and therefore will remain
equal given identical suffixes. So he can get a MAC on x | z and
it's also a valid MAC for y | z, which Alice didn't sign.  This applies
for CBC-MAC, DMAC, HMAC, and any another MAC that is not randomized or
maintains state (for example a counter) from message to message.

@_date: 2002-10-22 16:21:54
@_author: Wei Dai 
@_subject: Why is RMAC resistant to birthday attacks? 
I can't seem to find your earlier comment. It probably hasn't gone through the mailing list yet.
I don't see how the attack is avoided if only a substring of the MAC tag
is used. (I assume you mean substring above instead of subset.) The
attacker just needs to find messages x and y such that the truncated MAC
tags of x|0, x|1, ..., x|n, matches those of y|0, y|1, ..., y|n, and this will tell him that there is an internal collision between x and y. n only
has to be large enough so that the total length of the truncated MAC tags
is greater than the size of the internal state of the MAC.
No I don't think that works either. The attacker can try to find messages
x and y such that MAC(x|0^n) = MAC(y|0^n) (where 0^n denotes enough zeros
to pad the messages up to the fixed length).  Then there is a good
chance that the internal collision occured before the 0's and so
MAC(x|z)  = MAC(y|z) for all z of length n.

@_date: 2002-10-23 15:37:07
@_author: Wei Dai 
@_subject: Why is RMAC resistant to birthday attacks? 
I'm not sure what you're talking about. What's an example of a MAC algorithm that is not sequentially linear?
It would be nice to have more internal state, but I'm not aware
of any efficient (by which I mean as fast as the underlying block cipher)  MAC construction based on block ciphers that have more internal state than
the size of the cipher block, unless it is either randomized or carries
state from message to message.
If the algorithm has only N bits of internal state, then it does not
improve security to reveal less than N bits in the MAC tag. I already
explained why in a reply to Ed Gerck, but perhaps did so poorly. So again,
suppose that an attacker finds two messages X and Y such that MAC(X|0) =
MAC(Y|0), MAC(X|1) = MAC(Y|1), up to MAC(X|n) = MAC(Y|n). There are two
possibilities: either there is a collision in the internal state after
processing X and Y, or the internal states are different and all those MAC
tags match up through seperate coincidences.  The probability that all
those MAC tags are equal when there is no collision in the internal state
can be made much smaller than the probability that there is a collision,
by increasing n. So the attacker can always determine with high
probability when an internal collision has occured.

@_date: 2002-10-23 20:35:15
@_author: Wei Dai 
@_subject: Why is RMAC resistant to birthday attacks? 
No matter how good the MAC design is, it's internal collision probability
is bounded by the inverse of the size of its internal state space. The
point is that you can't prevent an attacker from learning about an
internal collision, once it happens, by hiding some of the state from the
MAC tag.  The only way to prevent internal collision attacks is to
decrease the internal collision probability, which unless the MAC is badly
designed to begin with, requires increasing the size of the internal state
I'm sorry but I don't know how to explain this any better. I've tried to
do it three different ways, and I hope someone else will do a better job
if you still are not convinced.
Those techniques may be useful when the attack requires knowing the internal state, but they are not useful when the attack only requires detecting collisions in the internal state. The literature you mention must be about the former case.

@_date: 2003-09-05 18:02:10
@_author: Wei Dai 
@_subject: OpenSSL *source* to get FIPS 140-2 Level 1 certification 
Thanks! Also thanks to Groove Networks (the company I work for) for spending the money to do the validation.
If OpenSSL source code gets validated, I'm going to be very surprised. NIST told us in no uncertain terms that only compiled executable code could be validated. In fact they wouldn't even validate Crypto++ as a static library despite an earlier verbal agreement that a static library was ok. It had to be turned into a DLL at the last moment (i.e. during the review phase).
(We wanted to avoid making a DLL from Crypto++ since it has so many algorithms. With a static library the linker would only bring in the algorithms you use, but a DLL has to contain a pre-selected set of algorithms. I ended up putting only FIPS Approved algorithms in the DLL, and made a second static library that contains only non-Approved algorithms, so that both could be used together.)

@_date: 2003-09-06 15:33:44
@_author: Wei Dai 
@_subject: OpenSSL *source* to get FIPS 140-2 Level 1 certification 
Do you have *written* guidance from NIST/CSE that your approach is ok?
(Not the testing lab, what they say don't really count in the end, and
neither does what NIST/CSE say verbally.) If so can you please post that
written guidance?
If NIST/CSE is really allowing OpenSSL source code and static libraries to
be validated, I should go back to them and demand the same treatment for
Crypto++. Who have you been working with on the government's side?

@_date: 2003-09-15 12:57:55
@_author: Wei Dai 
@_subject: OpenSSL *source* to get FIPS 140-2 Level 1 certification 
I think I may have found such a written guidance myself. It's guidance G.5, dated 8/6/2003, in the latest "Implementation Guidance for FIPS 140-2" on NIST's web site:  This section seems especially relevant:
For level 1 Operational Environment, the software cryptographic module will remain compliant with the FIPS 140-2 validation when operating on any general purpose computer (GPC) provided that: a. the GPC uses the specified single user operating system/mode specified on the validation certificate, or another compatible single user operating system, and b. the source code of the software cryptographic module does not require modification prior to recompilation to allow porting to another compatible single user operating system.
(end quote)
The key word here must be "recompilation". The language in an earlier version of the same guidance was this:
b. the software of the cryptographic module does not require modification when ported (platform specific configuration modifications are excluded).
which left the source code issue ambiguous, but in practice NIST/CSE
did not validate any source code and told everyone verbally that source
code could not be validated. I'd love to know how the OpenSSL team got
NIST/CSE to change their mind.
