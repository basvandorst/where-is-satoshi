
@_date: 2015-12-16 11:16:01
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] Photon beam splitters for "true" random number 
Stephen Wood said:
Stephen, since you’re bringing it up: I’d like to hear a few opinions from the group on that H/W TRNG from WaywardGeek, the one made by hand ( My cynical gut feeling fires up all kinds of flashing red lights, but I might be missing something. -—

@_date: 2015-11-04 17:09:45
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] Literature on reusing same key for AES / HMAC? 
as long as I have HMAC-SHA signed AES-XXX encrypted messages, Iâve made sure to carry two, separate, keys dedicated to the AES operation and to the HMAC operation. That is Iâm bringing one voice to the âI havenât looked but it canât be goodâ line of answers. For credentials (i.e. not just that random French dude trolling on metzdowd), this has been in the context of the Netflix control protocol, and before that in the context of the iTunes Store content security protocols. -â

@_date: 2015-10-22 23:17:26
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] How programming language design can help us 
I’m not buying it. I’ve just spent over an hour poring over the C99 standard, and the best I could find is this:
"6.3.1.3 Signed and unsigned integers
• 1  When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.
• 2  Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.49)
• 3  Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.”
That, along with:
"6.5.6 Additive operators
• 4  If both operands have arithmetic type, the usual arithmetic conversions are performed on them.
• 5  The result of the binary + operator is the sum of the operands.”
This seems to indicate that in case of overflow of signed integers, _assigned back into a signed integer_, then there is an implementation-defined result or an implementation-defined signal raised.
For that matter, I have the following program:
$ cat test.c    int main(void) {
    int x = INT_MAX - 1;
    int y = INT_MAX - 2;
    int z;
    if (x < 0 || y < 0 ) exit(1);
    z = x + y;    /* undefined in case of overflow */
    if (z < 0){
        printf("overflow at line %d\n", __LINE__);
        exit(1);
    }
    printf("positive result is %d\n", z);
    return 0;
Which is yours, but in an actually compilable form.
Compilation with pedantic warnings is silent:
$ gcc -Wall -pedantic test.c -o test
And behavior is as could be expected:
$ ./test overflow at line 13
For reference this is on current Debian with its latest gcc:
$ gcc --version
gcc (Debian 4.9.2-10) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
All this to say: I’ve seen a lot of high claims in this thread about how gcc is bent on shooting your foot for you, with the full might of the language standard behind it, but I’m not seeing it. To those who’ve put these claims out, I would say it’s time to put up: standard says undefined behavior? Chapter and verse, please! In communist Russia, gcc shoots you in the foot? Actual output from a run, along with gcc version, please!
Let’s be clear (and on topic): I do recognize all of the potential hand-wringing around reproducible builds and how the C _language_ does not readily support secure implementations (as in secure against the local system). I’ll even readily recognize that this is largely due to its emphasis on speed.
I would like to note, however, that it is entirely conceivable that a compiler that would exhibit the proper security behaviors in compiled output, that such a compiler is entirely compatible with the requirements (and more importantly leeways) of the C language standard. In other words, your (generic your, not just you, Ray) beef is not with the language, but with the toolchains you happen to have at your disposal.
-—

@_date: 2015-10-24 21:42:09
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] [FORGED] How programming language design can 
$ cat test.c    int main(int argc, char **argv) {
    int x = INT_MAX - argc - 1;
    int y = INT_MAX - argc - 2;
    int z;
    if (x < 0 || y < 0 ) exit(1);
    z = x + y;    /* undefined in case of overflow */
    if (z < 0){
        printf("overflow at line %d\n", __LINE__);
        exit(1);
    }
    printf("positive result is %d\n", z);
    return 0;
(notice the subtle difference, bringing back Peter’s original anti-optimization measure)
$ gcc --version
gcc (Debian 4.9.2-10) 4.9.2
Copyright (C) 2014 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
$ gcc -O3 -Wall -pedantic test.c -o test
$ ./test positive result is -7
I stand corrected.
(my main issue earlier was not running -O3)
Also, thanks Nemo for the explanation about where in the standard this is coming from. Frankly I’m still not quite getting it, but I also see how this is not a relevant discussion for this list, so I’ll just let it be.
-—

@_date: 2017-02-19 16:46:52
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] Lower bound for the size of an RSA key's private 
On a recent project, I found myself having to serialize the private exponent of an RSA key by myself (as opposed to it being an opaque value inside, say, a standard PKCS container). As I was toying with it, I came to the (new for me!) understanding that the relationship between the size of that private exponent and that of the key was more tenuous than I had anticipated.
So, looking into it, it is pretty clear that the exponent is going to be no larger than the Carmichael totient of the modulus (being that it satisfies a relationship modulo that totient). It can also be as small as (roughly, worst case) that same totient value over the public exponent, which is by convention the 17 bit value 65537. So, I guess my question becomes: what are the upper and lower bounds of the Carmichael totient value of a modulus of size n bits? Upper value is slightly smaller than the modulus, but potentially still n bits. Lower bound, though, I'm not sure.

@_date: 2017-02-27 22:13:25
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] Lower bound for the size of an RSA key's private 
Jon and Ron,
thank you for keeping this thread going. You are both literally addressing my question, and yet not quite addressing it: yes, there is a computable lower bound for the Carmichael function for arbitrary values. But when creating an RSA key, the modulus value is not arbitrary. Rather, it is the product of two large primes.
So the question really is not “What is the lower bound of the Carmichael function over all integers?", but “What is the lower bound for the Carmichael function over the values represented on exactly n bits (the modulus size) *and* that are the product of two large primes?".
Similarly, yes, you could contrive that you’d use the private exponent as the public value and vice-versa. By doing so, however, you’d ruin the security properties of RSA, a use case I am not interested in. Rather, the question is “For a non-compromised key generator, attempting its damn best to produce an RSA key of size n, what is the lower bound on the Carmichael totient of the produced modulus?"
I guess this veers into quality of implementation territory a little, too. Are p and q actually primes? Or are they statistically likely to be prime, depending on the algorithm used to generate them. Are certain relationships between p and q enforced. Wikipedia ( mentions that “p and q […] should be similar in magnitude but 'differ in length by a few digits’”, citing the 1978 RSA whitepaper. This is rather vague. I can conceive than from an implementation to the other, different decisions as to what “a few digits” constitute will be made, and that might in turn impact the answer to my question.
With these constraints in mind (but violating the p and q length relationship constraint), I can contrive an example where the totient length is half that of the modulus (explicitly: by imposing p == q). I know this is not a realistic case, and I want to imagine that the actual answer is much larger than half the size of the modulus.
I can spend a few hundred/thousand dollars worth of EC2 time and generate a couple million RSA keys with my implementation of choice and get an experimental reading of some value. But before I do so, I was wondering if there exists theoretical research on the topic that can provide the start of an answer to the question.
For what it’s worth, I’ve spent a weekend’s worth of my home server’s CPU time, and generated about 60,000 2048-bit keypairs. I found that the private exponent size varied from 2033 bits to 2048 bits. About 1/3rd of the generated private exponents had a length of exactly 2048 bits. Another 1/3rd had a length of exactly 2047 bits. The rest of the lengths seemed, on this small data set, to exhibit a geometric progression, halving at every step as the bit length went down.
So, back to the theoretical question: any takers? Any hints? Any known research on the topic that I was unable to uncover myself?
-—

@_date: 2017-03-13 12:47:53
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] USB firewall/condom HW/SW 
Ah, yes. Without even having to look at the details of the product, the self-targeting irony of their marketing is striking… Do I know who developed the USG’s firmware? No. Has the USG firmware been audited for backdoors and malicious functionality? I have no idea. Can I confirm that the firmware running on the USG has not been maliciously modified during or after manufacture? Certainly not.
Do I see any benefit in plugging that one random device into my computer over any other random USB device? Afraid not.
-—

@_date: 2017-03-28 09:49:04
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] "Perpetual Encryption" 
Well… I get to “SUPER ENCRYPT” my data! ‘nuff said.
It’s backed by pretty solid research, too:
"5 References
[1] C. Shannon, “Communication Theory of secrecy systems.” Bell Systems Technical Journal, 28(4), 656-715 (1949).”
Wow. So many citations.
-—

@_date: 2017-09-05 11:40:22
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] Anti-counterfeiting microchip 
having worked on similar technology (sans blockchain) in my past, I will bite: what does any of what you are proposing bring over a simple unique ID NFC tag? If you can uniquely identify the item (via unique ID) and the vendor has infrastructure in place to tie the unique ID to an inventory entry, then what you are proposing is achieved.
As a matter of fact, I have posted here ( a picture of a Canon camera, which, back in mid-2014, was tagged with an uncloneable RFID chip which you could read with the appropriate Android app, which would then tie it to the manufacturer’s inventory and give you, the customer, assurances that the camera was in fact _not_ counterfeit.
There were many challenges and shortcomings with the solution. I can assure you that missing public key cryptography or integration with a blockchain were not part of them.
In other words, and the risk of raining on your parade: what you described looks like a solution in search of a problem, and anti-counterfeiting is not the problem for your solution.
-—

@_date: 2018-02-27 12:57:24
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] Bitcoins and lobbyists 
I’m not sure I understand the implied relationship between mining and tracing money flows? Henry, can you clarify what you mean?
-—

@_date: 2018-02-27 13:27:10
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] Paid SMTP (PSMTP) 
Ersin, a few thoughts, although it seems hardly fair to burden the Crypto mailing list with what is essentially a spam fighting discussion (moderators will decide):
a) can I ever get to a point where I can outright reject non-paid email, as a receiver, and not miss out on potentially desired mail? If not, this solution suffers from one of the FUSSP issues whereby it needs to be fully deployed to be of value.
 In fairness, you do acknowledge this problem (even though you are not providing a solution to it)
b) does being a sender require a TEE? If so, this is a major impediment, because deployment of the solution is effectively akin to deployment of new hardware.
c) if I don’t require a TEE, then I’m subject to theft of the sender payment, which is a strong counterincentive to deploying the solution in the first place: as a sender, I would not want to take on the potential liability of a spam run executed by stealing my payment credentials.
d) how are both the recipient and "the IETF” getting paid in this scheme?
Finally, and even though you seem to be of good faith in your presentation of PSMTP, I would refer you to the following couple of “You might be” entries:
While they are writing in the acerbic tone of a battle-weary spam fighter, there is sound advice behind them and I would like to encourage you to ponder their wisdom.
-—

@_date: 2018-11-21 14:08:59
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] Hohha quantum resistant end-to-end encryption 
I disagree that “online key exchange” and “fancy/sexy” schemes “goes below” what PSK offer. As an example, let me refer you to MSL ( and specifically the Authenticated Diffie-Hellman key exchange section thereof (
The high level point: Authenticated Diffie-Hellman builds on top of a PSK use case, where both the (Netflix) device and the backend endpoint share the same key. We recognize though, that, with perfect forward secrecy in mind, it is not a particularly good idea to protect any on the wire message with the shared keys, and instead we proceed with a Diffie-Hellman key exchange, followed by further derivation of key material from the computed shared secret, with one of the shared keys.
Should the shared set of keys ever be broken, captured past on-the-wire messages would not be decryptable by an attacked, because the attacker could not know the shared secret or anything deriving therefrom.
In other words, reusing some of your vocabulary, we start from a PSK situation, but the Authenticated Diffie Hellman scheme allows us to go up from there to add PFS properties.
-—

@_date: 2019-12-07 16:59:17
@_author: Bertrand Mollinier Toublet 
@_subject: [Cryptography] US - PUBLIC SYSTEM 
Arkitech, here is one question: if you are serious about pushing a new scheme, then? why do you serve it over a Tor hidden service? Aren?t you losing 90% of potential interest that way?
-?
