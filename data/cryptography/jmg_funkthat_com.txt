
@_date: 2015-08-10 17:31:34
@_author: John-Mark Gurney 
@_subject: [Cryptography] Threatwatch:  CIN - Corruptor-Injector Network 
ianG wrote this message on Sun, Aug 09, 2015 at 16:26 +0100:
Considering they state:
"However, it's notable that the connection does not appear to represent an EV-class certificate. In other words, there's no 'green lock' as we see in any of google's other services. For example:'
And then proceed to provide a snapshot of mozilla.org which does
present an EV cert...  Never a shot of a Google site presenting an EV
They failed at even the most basic level..  The implied that Google
uses EV certs, which AGL (in the other thread) says Google does not..

@_date: 2015-08-10 17:38:16
@_author: John-Mark Gurney 
@_subject: [Cryptography] Threatwatch: CIN - Corruptor-Injector Network 
Tom Mitchell wrote this message on Mon, Aug 10, 2015 at 14:11 -0700:
There are lots of these projects out there...  Might want to look at:
And Chrome already does this for their own properties:
Chromium has Google's certs preloaded and pinned to prevent invalid
certificates from being used...

@_date: 2015-12-27 09:43:22
@_author: John-Mark Gurney 
@_subject: [Cryptography] Photon beam splitters for "true" random number 
Arnold Reinhold wrote this message on Thu, Dec 17, 2015 at 13:50 -0500:
I recently added this to my cron tab:
3       *       *       *       *       root    sleep $(jot -r 1 120 1); dd if=/dev/dsp bs=512 count=5 2>/dev/null | sha512 > /dev/random
I don't have a microphone or anything plugged in, but I do have the
mixer values turned way up to catch the low bit noise...
Yes, if someone is near by, they could influence it, but then there
are other nastier things they could do.

@_date: 2015-12-31 12:37:47
@_author: John-Mark Gurney 
@_subject: [Cryptography] Nu supr unbrakable cripto 
Bill Cox wrote this message on Thu, Dec 31, 2015 at 10:01 -0800:
This is also known as a Feistel cipher to help people look up literature
on this, such as the original Luby-Rackoff paper...  I believe that the
key in each round needs to be independant for it to be secure...
The wikipedia article on Feistel cipher has more info:
And says that 3 rounds is required to make it a PRP, and 4 rounds to
make it strong...

@_date: 2015-11-01 22:53:48
@_author: John-Mark Gurney 
@_subject: [Cryptography] [FORGED] Re: How programming language design can 
Peter Gutmann wrote this message on Sat, Oct 31, 2015 at 01:29 +0000:
This states that it checks calls to the function, such as:
  extern void *
my_memcpy(void *dest, const void *src, size_t len)
extern void *a;
extern void *b;
extern size_t l;
And it states clearly what it does when it figures out that it's NULL,
but it also doesn't state what it does if it cannot determine if the
argument is NULL, so it's assume that it does nothing...
and if you compile w/ gcc:
$gcc -Wnonnull -c a.c
a.c:15:22: warning: null passed to a callee that requires a non-null argument
      [-Wnonnull]
        my_memcpy(NULL, b, l);
                  ~~~~      ^
1 warning generated.
Which shows that it works as designed...
This says that when compiling the function, it will make assumptions
that the arguments will not be NULL...  It obviously can't peer through
other functions though:
  extern void *
my_memcpy(void *dest, const void *src, size_t len)
extern void *b;
extern size_t l;
afun(void *a)
compiles with out warning w/ -Wnonnull...  And unsurprisingly you have
now violated your contract w/ the compiler...
I disagree, the auther annotated the function that the pointer(s) will
be non-NULL, so by definition a pointer == NULL check will always be
false, and the optimizer is allowed to remove the code...
The root of the problem as someone else pointed out, is that it's
incorrect to write code check for a NULL pointer when you've already
said it is non-NULL...
That's like complaining that the compiler optimizes out my if (0) code!

@_date: 2015-11-08 09:29:44
@_author: John-Mark Gurney 
@_subject: [Cryptography] Literature on reusing same key for AES / HMAC? 
Krisztin Pintr wrote this message on Sat, Nov 07, 2015 at 21:56 +0100:
This is Mac then encrypt which is recommended NOT to be used.  The
reason being that if M is large, then cipher text is large, and you
can perform a side channel attack on the AES decryption.  If you
instead do:
C = AES(Ke, M)
C || HMAC-SHA256(Ka, C)
Then an attacker would have to break the authentication step before
getting to the easier AES step.  This does have the disadvantage
that you have to fully process the cipher text before you start
decrypting, which for some applications could be a problem.
The reason the AES step is easier is that you are performing many AES
block en/decryptions w/ the same key, which gives you significantly
more data to perform a DPA (Differential power analysis)[1] attack.
In some cases, when you're encrypting a multi megabyte file, one or
two decryption attempts could be enough data to successfully perform a
DPA attack to retrieve the key.
So, if you used the same key for both encryption and authentication
as you suggested, then the attacker once a successful attack was
completed on the decryption would now be able to forge the
authentication token for any message they wanted.  If different or
derived keys were used, then this would not be possible.
[1]

@_date: 2015-11-09 12:16:55
@_author: John-Mark Gurney 
@_subject: [Cryptography] Literature on reusing same key for AES / HMAC? 
Krisztin Pintr wrote this message on Sun, Nov 08, 2015 at 18:43 +0100:
Yes, if implemented correctly, AtE can be secure, but as attacks like
the CBC Padding oracle attack shows, mistakes are made, and
implementations are never 100% perfect.
In my book, if changing to EtA fixes a whole class of problems, it's
a good thing, and should be recommended.
Having learned the EtA rule from a cryptographer, I'd disagree that
crytographers don't know the EtA rule...
The fact that TLS is switching away from AtE (see RFC7366) speaks

@_date: 2015-11-16 15:39:09
@_author: John-Mark Gurney 
@_subject: [Cryptography] ratcheting DH strengths over time 
Ryan Carboni wrote this message on Mon, Nov 16, 2015 at 14:02 -0800:
A padding oracle attack is one major problem that CBC has had:

@_date: 2015-11-16 15:45:24
@_author: John-Mark Gurney 
@_subject: [Cryptography] Long-term security (was Re: ratcheting DH 
Perry E. Metzger wrote this message on Mon, Nov 16, 2015 at 13:05 -0500:
A number of years ago when I was building a small embeded device, 64k
flash, 8k ram w/ ethernet port, I thought about what I wanted to do for
Put a password on it?  it can be brute forced.. Push ssh on it?  didn't
want to try.
Then I thought about it, putting any type of security on it gave the
user of the device a false sense of security.  There is no way that I
could properly secure the device from a remote attacker, so I decided
that no security was the best security...  This would hopefully require
the user to use a bastion host to access the device..
Though I like this thought, I'm not revisiting it due to all the ICS
that are accessed via VPN, but I haven't thought of a better way...
Though getting lower power, inexpensive devices that are more powerful
is a lot easier today then when I was working on the project...  Still,
having to only upgrade one single bastion host's security than 10's or
100's of devices does seem nice...

@_date: 2015-11-16 23:32:59
@_author: John-Mark Gurney 
@_subject: [Cryptography] Long-term security (was Re: ratcheting DH 
Peter Gutmann wrote this message on Tue, Nov 17, 2015 at 04:22 +0000:
Only changes your attack surface...  Most of the ones mentioned will
easily fall to passive listening...  What happens when it's well known
that a device needs to be port knocked to get into?  Then some attacker
will just passively listen in to the knock sequence...  If you say make
it cryptographicly secure, w/ challenge, then we're back to implementing
crypto...  Easier than ssh, but still complicated, and even then, if
someone MitM's while you're connected, you've lost the ability to
authenticate the communications...
Either you implement full crypto to get security, or you're vulnerable
to any number of attacks...  Some of those attacks may fall outside
you're threat model, but won't for others..

@_date: 2015-11-17 09:52:49
@_author: John-Mark Gurney 
@_subject: [Cryptography] Sadly predictable: Terrorism used as excuse to 
Perry E. Metzger wrote this message on Tue, Nov 17, 2015 at 11:12 -0500:
Just last month, I was talking to an artist who isn't tech savvy... I
explained to him how 20 years ago most communications on the internet
were unencrypted...  He was surprised, and I didn't have to explain
encryption to him...
I think the normal person has been trained that since we protect things
like online transactions w/ encryption, that other things are encrypted
too, and if the normal person realized how much someone can read by
sitting in a coffee shop, they'd be scared...
Too bad coffee shops don't come w/ a Wall of Sheep:
Including domains visited (unencrypted).  Roll that out.  Educate.

@_date: 2015-11-17 09:35:46
@_author: John-Mark Gurney 
@_subject: [Cryptography] Long-term security (was Re: ratcheting DH 
Peter Gutmann wrote this message on Tue, Nov 17, 2015 at 08:34 +0000:
But if you access the machine, say, from your vacation in Fiji back to
the US, there are lots of passive listeners along the way that can sniff
it out... What about rouge access points (fake xfinity ones), coffee
shops, etc?  If you're targeted, it'd be easy to do any of these...
If one day I found I could do my work w/o the corporate VPN, that keeps
crashing my system, why wouldn't I stop using the VPN?  Even though
company policy says to use the VPN?  Saves my machine from crashing and
I still get my work done...
Remember, you have to think like a normal user that doesn't take
security seriously...
True, if someone lifts the key/auth creds, then all if lost, but
crypto does provide authentication and confidentiality to those w/ the

@_date: 2015-10-16 15:35:07
@_author: John-Mark Gurney 
@_subject: [Cryptography] Fwd: freedom-to-tinker.com: How is NSA breaking 
Ray Dillinger wrote this message on Fri, Oct 16, 2015 at 13:39 -0700:
Please go run openssl dhparam 1024 (or for more fun, 2048), and tell
me if doing that on every connection, https session, etc, is doable?
For everyone else, it's about a second, but can take >5 seconds to
generate a 1024 bit dh parameter...  2048 can take >47 second and this
is on a 2.5GHz Core i7...

@_date: 2015-10-16 17:47:09
@_author: John-Mark Gurney 
@_subject: [Cryptography] freedom-to-tinker.com: How is NSA breaking so 
Louis Kowolowski wrote this message on Fri, Oct 16, 2015 at 17:24 -0700:
I was replying to the comment that it should be done on every connection.
I did think about doing something like that before, but you have to
realize that changing generated DH params can leak information.  If
an OS vendor changes it per release, it's easy to figure out what
release they are running..  If you change it per boot, then you'll
figure out when they patch/upgrade...
Changing it on a regular basis, like every night/week/month would be
best, though most applications don't know how to refresh the dh params
while running which means you'll suffer an interruption when restarting
the service...
IMO, just going to 2048 bit DH params makes the most sense.

@_date: 2015-10-20 17:05:18
@_author: John-Mark Gurney 
@_subject: [Cryptography] Other obvious issues being ignored? 
Arnold Reinhold wrote this message on Tue, Oct 20, 2015 at 14:48 -0400:
The problem is the C standard and has nothing to do w/ the C
compilers.  The standard allows the compilers to do these
optimizations, so they are perfectly legal and correct.  As far as
I'm concerted, you cannot write secure code in C.  The C standard
needs to add some additional keywords to mark data that needs to be
treated specially.
Don't forget that even if you do manage to get a compiler that
doesn't omit your zeroing of data, it doesn't mean that you managed
to zero all the locations that the data was.  The compiler is free
to leave parts of that data in registers (which could end up in kernel
memory on task switch when saving registers), or even other parts of
the stack when it copied/moved data around.
The other issue is constant time operations.  The classic example is
bcmp.  One version is:
timingsafe_bcmp(const void *b1, const void *b2, size_t n)
        const unsigned char *p1 = b1, *p2 = b2;
        int ret = 0;
        for (; n > 0; n--)
                ret |= *p1++ ^ *p2++;
        return (ret != 0);
The problem is that even though current compilers compile this to a
constant loop, there is NOTHING in the C standard that prevents a
compiler from realizing that once ret is non-zero that there is no
need to continue through the loop, and can break out early, defeating
the point of the function.
Until the C standard adopts something to address these issues, it just
isn't possible to write secure code in C today.

@_date: 2015-10-21 11:54:58
@_author: John-Mark Gurney 
@_subject: [Cryptography] Other obvious issues being ignored? 
Arnold Reinhold wrote this message on Wed, Oct 21, 2015 at 08:55 -0400:
I want the compiler writers to produce faster code...  That's good
for everyone...  We've just his a bad point where the compiler writers
have gotten ahead of the standards in this regard...
Well, when the overflow test is written incorrectly, the compiler has
every right to remove the test...  The problem is there are corners
of the C standard that even the most experienced C coder does not know...
The fact that signed overflow in C is undefined behavior is now well
known, but has been undefined for over 15 years, if not longer...
The same thing happened w/ aliasing...  Now that compilers are getting
smarter, they are looking at the standard to see how they can exploit
it to improve code performance...
Hope they got that right in their C code, or what ever language they
used got it right in their C code.. :)

@_date: 2015-10-21 14:13:13
@_author: John-Mark Gurney 
@_subject: [Cryptography] Other obvious issues being ignored? 
Bill Frantz wrote this message on Wed, Oct 21, 2015 at 07:26 -0700:
I really don't want to do register allocation by hand, and you can't
use inline assembly in C, because clang is known to look into inline
assembly and optimize it...
That's one minor aspect, and assumes that the C function doesn't
do odd things w/ the data...
Having looked at the SHA-256 (SSE4) or AES-GCM (AES-NI) implementions
in assembly, they are not simple at all...  nasm/yasm helps a bit
with this, but still, not nearly that easy...

@_date: 2015-10-23 14:36:21
@_author: John-Mark Gurney 
@_subject: [Cryptography] Other obvious issues being ignored? 
John Gilmore wrote this message on Thu, Oct 22, 2015 at 02:32 -0700:
Why volatile can't be used:
The key part:
The C standard states that accesses to volatile objects are part of the
unalterable observable behaviour -- but it says nothing about accesses
via lvalue expressions with volatile types.
Looks like C11 has memset_s now, which is good.
Colin has a follow on blog post about this:

@_date: 2015-10-23 14:55:25
@_author: John-Mark Gurney 
@_subject: [Cryptography] Other obvious issues being ignored? 
Philipp Ghring wrote this message on Thu, Oct 22, 2015 at 21:15 +0200:
Sorry, this is not a valid issue...  Once a CSPRNG has enough entropy,
say 256bits, it can never be depleted.  It just happens that there are
bad implementations out there that think that it is possible.
djb has a good post on this:
You may be refering to the Debian rng bug here.  I'm not an expert on
the Debian bug, but I don't believe that was the case.
Anyways, modern Unix systems do a very good job to ensure that there
is NO entropy in uninitialized memory, so there should never be a need
to read uninitialized memory for a CSPRNG...

@_date: 2015-10-23 15:01:14
@_author: John-Mark Gurney 
@_subject: [Cryptography] "We need crypto code training" and other 
ianG wrote this message on Fri, Oct 23, 2015 at 16:18 +0100:
One BIG issue in crypto code is side channel attacks, and no matter
how good a programmer you are, you aren't going to code for side
channel attacks because it intentionally makes your program slower...
GCM for example will leak like a sieve if you use an 8bit lookup
table, which is the best/fastest way to implement it on modern
This aspect alone puts the crypto at minimum 10-20%.  Yes, it isn't
complex, but is absolutely manditory.

@_date: 2015-10-24 12:56:13
@_author: John-Mark Gurney 
@_subject: [Cryptography] "We need crypto code training" and other 
Jerry Leichter wrote this message on Sat, Oct 24, 2015 at 15:06 -0400:
This is very correct that side channels do not just apply to crypto...
It's also easier to demonstrate side channel issues on crypto as the
tight repetive calculations on sensitive data (keys)..
Side channels are a long known issues (long before SPA/DPA was
"discovered") with leaking data between protection domains on secure
Yeh, but I have a friend who does DPA, you can zero in on any transistor
you want if you have you're selection functions correct...

@_date: 2015-09-10 11:53:39
@_author: John-Mark Gurney 
@_subject: [Cryptography] Apple?s iMessage Defense Against Spying Has One 
Jerry Leichter wrote this message on Thu, Sep 10, 2015 at 09:56 -0400:
Not really...  Say Alice is sending her key to Bob, Alice uses her
current device key to sign a list of public keys aka devices, and
sends that sgned list to Bob, this can easily work...  Then Bob has a
list of approved devices which are trusted to be Alice's, and future
changes to the list of approved devices/keys can be automated by any
of those verified devices...
If a Apple were to add a key that Alice didn't know about, hopefully
she would recognize that she doesn't have a second iPad, and not sign
the new set of keys including the bogus one...
This would require Alice to "approve" the new device from one of her
existing devices instead of simply authenticating to Apple before Bob
would trust it, but IMO that is a minor issue..  (or does Apple already
require you to access a previously auth'd device before adding a new

@_date: 2015-09-10 14:36:57
@_author: John-Mark Gurney 
@_subject: [Cryptography] Apple?s iMessage Defense Against Spying Has One 
Jerry Leichter wrote this message on Thu, Sep 10, 2015 at 15:49 -0400:
I'll reinsert the missing paragraph that I was replying to:
You deleted the part about how it's supposedly hard to check/verify
all the keys, and I disagree w/ that assertion...  The statement assumes
there is a way to check/verify a key and it would be difficult to
verify all the other keys in the set, and I disagree w/ that statement
and provided a method that would work..
We're talking about steps initiated by Alice to verify her devices to
Bob...  so, she can sign and send the set via iMessage to Bob for OOB
verification, via QR code or some other mechanism...  Even in iMessage
this is safe, since you're verifying the signature, and it's assumed any
tampering would invalidate the signature...
The issue w/ an absolutely new device w/ zero access to the old one is
not solvable by my solution, and is impossible to solve w/ any solution...
There are many different issues why this is the case...  One is that
there is limited software deployed to interoperate...  A second is
that (until recently) it wasn't easy to bring two private keys together
like it is today w/ smartphones, and because of that, no one has spent
the time/research to make it easier...
Though most people wouldn't trust putting their GPG private key on
their smartphone, but luckily, we weren't talking about GPG, but about
messaging apps on the phone....
I recently talked w/ Trevor Perrin about this, and I do believe that
now that we have smartphones, that key verification (for smartphone
based keys) will become easier...  We have things like speakers/mics and
camera/qr codes that can make things much easier than we had in the
GPG days..
Yeh, considering Skype supported video calls, just a few minutes of a
Skype video call would cover many people for a few years..
I'm not saying Apple shouldn't do encryption, but they should make
verification possible for the people that care... TextSecure/Signal has
done this, and usability hasn't changed because of it...  They are
looking at better ways for verification...

@_date: 2015-09-26 10:05:33
@_author: John-Mark Gurney 
@_subject: [Cryptography] VW/EPA tests as crypto protocols ? 
dj at deadhat.com wrote this message on Sat, Sep 26, 2015 at 06:59 -0000:
They did do something different.  Standard government testing has testing
stations plug into the OBD conntector to figrue out what the engine is
The researches didn't plug in, but instead put the sensor in the trunk,
and drove the car around, as opposed to being put on a dyno...   It looks
like testing in some locals don't require the dyno:
As others have pointed out, the measurement was attacked because it wasn't
a real world measure, just a simulated one...

@_date: 2016-04-10 13:40:56
@_author: John-Mark Gurney 
@_subject: [Cryptography] Text of Burr-Feinstein encryption backdoor bill 
Donald Eastlake wrote this message on Fri, Apr 08, 2016 at 16:26 -0400:
The law doesn't prevent the gov't from requiring someone to develope a
backdoor in the client (that can exfiltrate all data) and forcing the
company/owner/publisher from giving it to all in order to get the data

@_date: 2016-08-16 12:00:42
@_author: John-Mark Gurney 
@_subject: [Cryptography] Generating random values in a particular range 
John Levine wrote this message on Sat, Aug 06, 2016 at 15:08 -0000:
This looks very close to the way RFC 2631 specifies how to generate
DH parameters.
Only difference there is that they just say an arbitrary bit string,
instead of seeding from random.

@_date: 2016-02-09 10:15:39
@_author: John-Mark Gurney 
@_subject: [Cryptography] DH non-prime kills "socat" command security 
Ray Dillinger wrote this message on Tue, Feb 09, 2016 at 09:06 -0800:
I'll point out that RFC2631 provides and algorithm to generate DH params
from seeds, and when provided the seeds, you can verify that they were
generated sanely...
I have python code that implements RFC2631 for generating DH
params...  It's in vke.py, part of my pyfp program:

@_date: 2016-01-21 11:35:55
@_author: John-Mark Gurney 
@_subject: [Cryptography] TRNG related review: rngd and /dev/random 
Bill Cox wrote this message on Tue, Jan 19, 2016 at 17:37 -0800:
This depends upon the assumption that either the attacker has root, or
that the system designer is incompetent (which happens too often)...
Anyone who deploys systems needs to understand the deploying/cloning
systems w/o replacing the entropy pool (or having a hardware TRNG)
means an insecure system..  So, you have to start w/ an assumption that
the pool has >=256 bits of entropy...
The assumption that once you have a secure pool, that you can deplete
it's entropy is complete BS and it's sad that Linux continues to suffer
from this misconception...  There are a number of places that talk about
this, one being:
As stated above, this is just simply making sure your system starts w/
a good source of entropy...
This is entirely a problem w/ Linux...
There are well known and published entropy pool algorithms, like Fortuna
that are much better in this way...
[Fortuna] [lots of Linux issues deleted]
Wow, that's pretty bad that it doesn't even round robin...
If you have a system w/ a user on console, then it's very easy to generate
randomness...  Just have the user mash the keyboard for 80+ characters,
timing each keypress, and you'll have enough entropy...  The real issue is
off-line and embedded systems that don't have it...
The real solution is for Linux to not be broken...  You just can't simply
deplete a large entropy pool ever!  If someone ever figures out how to
take 2^64 bytes of some CSPRNG (say AES in counter mode, or hash) and
extract the key, then the underlying cryptographic primitive will be
considered broken, and it'll be replaced.

@_date: 2016-03-06 15:25:50
@_author: John-Mark Gurney 
@_subject: [Cryptography] DROWN attack on SSLv2 enabled servers 
Viktor Dukhovni wrote this message on Sun, Mar 06, 2016 at 17:49 -0500:
Except when it doesn't...
Protocol negotiation is STILL broken in TLS after years of known
attacks and multiple versions of TLS...  TLS client/servers don't have
a clean way to ensure that the otherside is not being down graded by
a MitM attack...
People are hacking the civer suite value to be the protocol downgrade
prevention (less than a year ago):
  "The fallback SCSV defined in this document is not a suitable
   substitute for proper TLS version negotiation.  TLS implementations
   need to properly handle TLS version negotiation and extensibility
   mechanisms to avoid the security issues and connection delays
   associated with fallback retries."

@_date: 2016-03-06 14:44:27
@_author: John-Mark Gurney 
@_subject: [Cryptography] EFF amicus brief in support of Apple 
Perry E. Metzger wrote this message on Sun, Mar 06, 2016 at 10:33 -0500:
The more interesting thing here is reproducable builds... If you get
people you trust to replicate the exact build you've received, you
can build trust that the build hasn't been compromised, but it still
is difficult..

@_date: 2016-05-06 16:06:51
@_author: John-Mark Gurney 
@_subject: [Cryptography] Pragmatic, 
Jaycevee wrote this message on Wed, Apr 27, 2016 at 11:48 -0700:
How searchable do you need it to be?  If you just need equality, use
SIV[1] and you don't have the issue w/ unsalted hashes.
[1]

@_date: 2016-10-28 23:59:48
@_author: John-Mark Gurney 
@_subject: [Cryptography] "Google teaches ???AIs??? to invent their own 
Jerry Leichter wrote this message on Fri, Oct 28, 2016 at 18:02 -0400:
You know. designing an algorithm to best Eve when Eve shares w/ you
how well she is doing is pretty easy/nice.
I wish the NSA/[insert another attacker here] would be so kind.

@_date: 2017-03-13 23:21:14
@_author: John-Mark Gurney 
@_subject: [Cryptography] USB firewall/condom HW/SW 
Jerry Leichter wrote this message on Mon, Mar 13, 2017 at 18:20 -0400:
I'd imagine it'd be easy to add a slider switch that you can set to
select what type of device, or auto for making things quick and easy..
That way you can force the thumb drive to only be a mass storage
device, and not be a HID...

@_date: 2017-03-17 15:59:20
@_author: John-Mark Gurney 
@_subject: [Cryptography] Crypto best practices 
Ralf Senderek wrote this message on Wed, Mar 15, 2017 at 19:43 +0100:
I'll point out that chacha20-poly1305 is also a stream cipher and
suffers similar isues.
What are the patent free, AEAD ciphers that are recommended then?

@_date: 2017-03-19 10:26:04
@_author: John-Mark Gurney 
@_subject: [Cryptography] Crypto best practices 
Peter Gutmann wrote this message on Sun, Mar 19, 2017 at 03:33 +0000:
It seems odd that people are looking so hard for new crypto modes, when
something like XEX could be used to replace the counter mode in GCM...
Doesn't solve same nonce (tweak) + same plaintext == same cipher text,
but should solve the same nonce leaks plaintext difference, but still
results in blocks of plaintext == same cipher text...
P.S. I'm not a cryptographer, but have implemented crypto under the
guidance of cryptographers...

@_date: 2017-11-01 09:45:25
@_author: John-Mark Gurney 
@_subject: [Cryptography] How Google's Physical Keys Will Protect Your 
John Levine wrote this message on Wed, Nov 01, 2017 at 08:07 -0000:
Most phones support USBOTG, so you can get a cable to turn a USB micro-B
into a USB-A allowing keyboards and mice to just work..

@_date: 2017-11-12 21:32:14
@_author: John-Mark Gurney 
@_subject: [Cryptography] Is ASN.1 still the thing? 
James A. Donald wrote this message on Mon, Nov 13, 2017 at 13:11 +1000:
JSON does not have a formal encoding that allows it, but there is
JCS (JSON Cleartext Signature) that has a well defined encoding.
I have not looked at YAML or protobuff.
DER encoding, not just ASN.1.
P.S. Don't reply to a random email.  It causes weird threading, and people
may mark an entire thread as read, and miss your message this was.

@_date: 2017-11-24 23:36:32
@_author: John-Mark Gurney 
@_subject: [Cryptography] Is ASN.1 still the thing? 
Ron Garret wrote this message on Mon, Nov 13, 2017 at 18:11 -0800:
My feedback:
Please don't advertise this.
The reason being that it will just muddy the waters of an already
confusing landscape, and doesn't have types needed for modern data
interchange like datetime, floating point, or arbitrary key-value
dictionaries (yes, you have classes, but no, they aren't arbitrary)..

@_date: 2017-11-24 23:52:55
@_author: John-Mark Gurney 
@_subject: [Cryptography] Is ASN.1 still the thing? 
Peter Gutmann wrote this message on Fri, Nov 17, 2017 at 10:17 +0000:
I really hope that's not the case, because if it doesn't fully parse
all the leading data, you are now open to a packet-in-packet style attack.

@_date: 2017-10-22 10:07:37
@_author: John-Mark Gurney 
@_subject: [Cryptography] Severe flaw in all generality : key or nonce 
Jerry Leichter wrote this message on Thu, Oct 19, 2017 at 09:43 -0400:
I'll point out that TLS blocks data down to make encryption managable
(16KB).  AACS blocks encryption down to managable chunks (for multi GB
video streams).  Most blocking has a cost of .1% or less, so arguing
against things because of GB streams is not helpful in promoting

@_date: 2017-09-15 17:39:07
@_author: John-Mark Gurney 
@_subject: [Cryptography] letsencrypt.org 
Jason Cooper wrote this message on Wed, Sep 13, 2017 at 21:44 +0000:
BTW, IMO, even 90 days is too long.  Moving to automation means that
short time frames aren't a problem, and shorter time frames means that
for all the devices that don't handle revokation won't trust the cert
as long.
Made sense years ago, not any more...

@_date: 2018-12-02 10:13:21
@_author: John-Mark Gurney 
@_subject: [Cryptography] What if Responsible Encryption Back-Doors Were 
Ondrej Mikle wrote this message on Sat, Dec 01, 2018 at 00:11 +0100:
A warrant is required and it is expected that the judge that signs the
warrant ensures that it is not unreasonable.
The people obtaining the warrant have to say what they expect to find,
and why they expect to find it...

@_date: 2018-07-05 08:57:19
@_author: John-Mark Gurney 
@_subject: [Cryptography] Fast-key-erasure RNG and fork()ing 
Yann Ylavic wrote this message on Fri, Jun 29, 2018 at 00:46 +0200:
Entirely depends upon the system...  All the BSD's I believe provide
good entropy on /dev/urandom, so you should take this into account
for your portability...
Yeah, another Linux'ism...
Don't forget about getentropy (originally OpenBSD) and related syscalls.

@_date: 2018-06-25 16:15:53
@_author: John-Mark Gurney 
@_subject: [Cryptography] Fast-key-erasure RNG and fork()ing 
Yann Ylavic wrote this message on Mon, Jun 25, 2018 at 00:11 +0200:
The closes platform independant method is pthread_atfork, but I don't
know how well that works across various platforms...  But you can use
that to trigger reseeds...
A great solution is the flag to zero a page on fork...
OpenBSD, and now FreeBSD, has a flag to zero a page when the process
forks...  This way you store the seed in the page, and check to make
sure it's not zero, if it is, then you reseed...  This has the best
protection as you will never leak seed material...
See INHERIT_ZERO in:
If your child processes are so short lived that a call to the system
RNG is expensive, then you're likely having a larger overhead of forking
than doing real work...  I'd just reseed from the system RNG, and it
has the advantage that the parent cannot know what the child's data
How do you detect that the fork happened?

@_date: 2018-09-01 10:40:05
@_author: John-Mark Gurney 
@_subject: [Cryptography] WireGuard 
Howard Chu wrote this message on Thu, Aug 30, 2018 at 16:56 +0100:
AES has been going strong for almost 20 years now, and if you use
256-bit, it's probably good for another few yeas...
As for upgrades, the server deploys both old and new protocols on
different ports, or different machines, and clients upgrade as needed...
The good thing about eliminating algorithm agility is that you don't
have the problem with downgrade attacks...  TLS 1.2 STILL has downgrade
attacks, and it was decided that the down grade attacks weren't "bad"
enough to force an immediate fix to it...

@_date: 2018-09-02 16:46:53
@_author: John-Mark Gurney 
@_subject: [Cryptography] WireGuard 
Peter Gutmann wrote this message on Sat, Sep 01, 2018 at 13:58 +0000:
That's because they've been trying to keep backwards compatibility.
If you have a protocol designed from the start, it's not at all hard.
You simply integrate all protocol messages into your key generation,
that way if any messages are modified in transit, the two ends don't
derive the same key, and communications cannot happen.  Looks like
Noise does it slightly differently, see link below.
The issues w/ TLS is that previous versions did not integrate
all protocol messages into the key agreement, and that the client would
have to "self downgrade" to allow broken servers to negotiate a
functional channel...
I don't know if there's a paper on the above, but Noise talked about
this and it's prologue data:

@_date: 2018-09-03 11:37:21
@_author: John-Mark Gurney 
@_subject: [Cryptography] WireGuard 
Peter Gutmann wrote this message on Mon, Sep 03, 2018 at 14:48 +0000:
Only if you have a client and/or server that requires it.  You cannot
have a client that requires it of all servers, and you cannot have a
server that requires it of all clients if you need to support older
This means that the client has to know which servers support it and
enforce it, meaning that it cannot be deployed on standard websites
for years...
So, yes, TLS CAN be made to be in some cases, but the protocol as
currently deployed cannot be...  If this or a similar mechanism had
been included in TLS 1.2, the world would be in a much better place
Is there an HTTP header like HSTS to require it on future negotiations?
It'd be interesting to have a required since X date on HSTS and other
headers like it.  If the web browser eventually gets that, but notices
that you've visited the site before w/o receiving the header, warn the
user that their pass communications have been compromised.

@_date: 2018-09-03 20:24:13
@_author: John-Mark Gurney 
@_subject: [Cryptography] WireGuard 
Peter Gutmann wrote this message on Mon, Sep 03, 2018 at 20:05 +0000:
Just for everyone's reference, OpenSSL v1.1.0 was the first version to
support Extended Master Secret.  1.0.2 does not have this support.

@_date: 2019-08-25 21:58:53
@_author: John-Mark Gurney 
@_subject: [Cryptography] "Entropy as a Service: A New Resource for Secure 
Jerry Leichter wrote this message on Sat, Aug 24, 2019 at 20:50 -0400:
talks to, to gether the entropy.  It does look like there might be some
that are taking already existing HSM/smartcards and repackagine them...
These aren't needed for VM's, as there's alread a virt io standard for
And that has the advantage of coming from the hyper visor that already
has to be trusted by the VM...
Network entropy is extermely limited in usefulness, as you don't have
enough entropy to setup a secure session, or it's passed in clear text,
and then it's minimally useful, as anyone snooping on it can see it...
If you have 256bits of entropy, you can never exhaust it's entropy...
Either use virtio entropy, or a TRNG via USB/smartcard, or your
processor entropy...  Don't be fooled by some SOCs that supposedly
have an entropy source on them, as some of them have to be seeded by
the OS, so your OS still needs a secure source...

@_date: 2019-08-26 21:08:45
@_author: John-Mark Gurney 
@_subject: [Cryptography] The best TRNG architecture, comming soon? 
Jonathan Thornburg wrote this message on Mon, Aug 26, 2019 at 09:29 -0700:
This is part of the health check of your TRNG, and should catch this
and providing rng.  Also, any TRNG needs to have a whitener after it..
I don't know of any TRNG that gives you raw data w/o whitening it,
because most [all] TRNG's are biased, even slightly, and for crypto,
you need an unbiased RNG source...

@_date: 2019-12-10 13:44:05
@_author: John-Mark Gurney 
@_subject: [Cryptography] "[CVE-2019-14899] Inferring and hijacking 
Jerry Leichter wrote this message on Mon, Dec 09, 2019 at 12:24 -0500:
I'd argue that even for low power devices, you don't need to save every
bit.  Adding a few extra bytes isn't a problem, and if you're properly
encrypting packet lengths, you can just append noise, or add random
noise packets that won't be decrypted to save the energy of encrypting
the padding.
The ideal protocol will look like random noise from start to finish.
There is no banner announcing the service, there are no unencrypted
Getting the timing side of things will always be difficult, but this
came up again recently, but is old news:
There was the recent NetCAT bug:
That used Intel's DDIO to peak into what characters are pressed in the
ssh session.
But doing simple metering, where 100 times a second you release the
packets, or some other fixed interval can be a useful and simple
mitigation attack.
Simply adding a random delay is not enough in some cases, as using
averaging can reduce any noise introduced.

@_date: 2019-11-19 11:50:21
@_author: John-Mark Gurney 
@_subject: [Cryptography] How can poor/bad/compromised random number 
Ken McCall via cryptography wrote this message on Mon, Nov 18, 2019 at 22:09 +0000:
An example of this is the Debian ssh key issue:
They had a buggy RNG that would only generate a possibly 32,768 different
private keys.  This means it would be trivial to generate all the possible
different private keys (there is a list of the private keys for this).
Now this is an overtly bad RNG, and doubtful to be a problem, but even
a weak RNG that can only produce 2^64 different outputs is not good,
as a rainbow table can be generated to be able to lookup a private key
that matches w/ a public key allowing an attacker to easily and quickly
steal another person's bitcoins.

@_date: 2019-11-25 14:47:18
@_author: John-Mark Gurney 
@_subject: [Cryptography] Mention of Joe Biden in "Puzzle Palace" 
Dave Horsfall wrote this message on Tue, Nov 26, 2019 at 07:16 +1100:
Don't see any other senator's w/ the name Biden on:
So, it's highly likely is, though he was a very young senator at the time,
as the list shows he started serving in 1973.

@_date: 2019-10-20 16:12:16
@_author: John-Mark Gurney 
@_subject: [Cryptography] Very best practice for RSA key generation 
Phillip Hallam-Baker wrote this message on Sun, Oct 20, 2019 at 18:51 -0400:
Would want to fix the last bit to 1 (or it on) so you don't run the KDF
extra times, eliminating the even numbers.

@_date: 2019-09-02 11:41:47
@_author: John-Mark Gurney 
@_subject: [Cryptography] "Entropy as a Service: A New Resource for Secure 
jamesd at echeque.com wrote this message on Sun, Sep 01, 2019 at 06:32 +0800:
Heck, even a floating open mic input generates a few bits of noise.  I have:
5       */3     *       *       *       root    dd if=/dev/dsp bs=4096 count=1 2>/dev/null | sha512 > /dev/random
in the /etc/crontab on one of my servers.

@_date: 2019-09-23 22:17:51
@_author: John-Mark Gurney 
@_subject: [Cryptography] "How Long Will Unbreakable Commercial Encryption 
Tom Mitchell wrote this message on Sun, Sep 22, 2019 at 20:36 -0700:
If suddenly someone forced 1024 bit RSA, then it's pretty obvious WHY
they are trying to do it...  I don't have to run fast, I just have to
have longer keys than all my friends...
There isn't anything that a 56-bit quantum computer can't solve..

@_date: 2020-04-01 14:37:33
@_author: John-Mark Gurney 
@_subject: [Cryptography] Open hardware RNG design: Hector, Cryptech, 
Ondrej Mikle wrote this message on Wed, Apr 01, 2020 at 18:23 +0200:
An LFSR is not an acceptable entropy source... it's actually pretty
useless since it's entirely predictable, and if the state of the LSFR
is observed, all future values will be known...
Though, as it says:
This IP block provides an entropy source that is part of a larger
solution to generate true random numbers (a TRNG mechanism).
And it also says:
This is a pseudo-random type of entropy source, as opposed to a truly random entropy source.
It does look like they know that this isn't an acceptable TRNG, and
likely it's just a placeholder block to enable development, but that
they even attempt to call it a entropy source is just wrong.  It should
be clearly labeled as not a usable entropy source.
They really need to find someone who knows TRNGs before they get much farther.

@_date: 2020-04-08 15:10:45
@_author: John-Mark Gurney 
@_subject: [Cryptography] Jitsi versus Zoom 
Marc via cryptography wrote this message on Tue, Apr 07, 2020 at 20:36 +0000:
Jitsi doesn't use e2e encryption in the group mode.  They just use DTLS.
They do direct DTLS between clients, but the devs haven't explained how
to verify the keys used by the clients.  If you use Meet, the server
does full decryption and reencryption to all the clients for group chat.
So, the best thing about Jitsi is that you can self host to ensure the
security of the server.

@_date: 2020-04-08 21:44:34
@_author: John-Mark Gurney 
@_subject: [Cryptography] Jitsi versus Zoom 
Jeremy Stanley wrote this message on Wed, Apr 08, 2020 at 23:45 +0000:
You mean all the auditing that doesn't happen w/ open source software?
See the recent package distribution bugs in OpenWrt[1], or on Debian's
apt that failed to handle redirects properly[2]...
Or the [in]ability of OSS authors to distribute software securely?
Hell, in trying to get OpenWrt installed on a router, I find that if
you follow OpenWrt docs to the letter, your initial install can still
be MitM'd, even after the recent CVE, and so an attacker could put their
own package key and repo in:
Or that dnsmasq is distributed in an unauthenticated manner.  Yes,
the author signs his repo, but there isn't a link to his PGP key
anywhere, and so, if I just fetch "his" key that is from the repo
off a random key server, that isn't secure, because an attacker could
upload their own key that they signed the repo w/ that contains his
email address and look totally legit.
You mean that OSS?
We aren't even talking about complicated parts of software, the
simple distribution can't even be handled in a secure manner, and
people expect them to get more complicated parts correct?
I don't have the time or money to pay for even a half assed audit of
There's something to be said to have a company that has people who
are paid to distribute and keep software secure.
[1] [2]

@_date: 2020-04-09 17:47:41
@_author: John-Mark Gurney 
@_subject: [Cryptography] Jitsi versus Zoom 
Jeremy Stanley wrote this message on Thu, Apr 09, 2020 at 06:11 +0000:
No.  You totally misunderstood my point.  My point was that there isn't
any guarantee that the source that the OSS author publishes is what the
end user uses/audits because the authors don't ensure secure code
It had nothing to do with source availability, but that everyone gets
the same source.
Just like you're argument that because source is open, it's inheriently
more secure, "because many people can audit the code".
Same problem w/ OSS as well.  I've pointed out security issues in OSS
software that has been ignored plenty of times as well...  Commerical
products don't have a lock on hiding and sweeping issues under the
rug...  The number of OSS software packages that refused to fix an
issue until there's a PoC is too many.

@_date: 2020-04-09 17:52:32
@_author: John-Mark Gurney 
@_subject: [Cryptography] "Zoom's end-to-end encryption isn't 
Bill Frantz wrote this message on Tue, Apr 07, 2020 at 22:50 -0400:
Have you looked at how JPEG/MPEG compression works?  How webcams have
noise in them and now that interplays with compression?
I welcome your paper describing how you managed to do this in the
coming weeks.
Simple thing to do is to run an entropy analysis on a Zoom stream...
Take all the 128bit blocks, and check to see if any repeat...  If
you notice a repetition, then investigate that.  I have a feeling
you'll see a lot repetition than you think you will.

@_date: 2020-02-22 15:55:51
@_author: John-Mark Gurney 
@_subject: [Cryptography] Apple's 13-month certificate policy 
Patrick Chkoreff wrote this message on Sat, Feb 22, 2020 at 18:23 -0500:
Or at least force other CA's to adaopt the ACME api to issue certs.
Overall, it's a good thing, and IMO, even 90 days is a bit long.  With
automated renewal, 7-30 days is more than long enough.

@_date: 2020-02-22 23:00:35
@_author: John-Mark Gurney 
@_subject: [Cryptography] Apple's 13-month certificate policy 
Raymond Burkholder wrote this message on Sat, Feb 22, 2020 at 18:50 -0700:
Don't need to be sitting on the same server for DNS challenges.  w/
TSIG plus dns auth rules, you can configure the dns server to only
allow that specific server access to the TXT records for challenges..
nsupdate works great, and I've migrated all my LE certs over to using
DNS TXT records.

@_date: 2020-02-22 23:04:30
@_author: John-Mark Gurney 
@_subject: [Cryptography] Apple's 13-month certificate policy 
Raymond Burkholder wrote this message on Sat, Feb 22, 2020 at 23:43 -0700:
That's when you use DNS TXT records.  No need to open a web port for the
Automating the uploading of a cert to an ILOM or something else that
isn't designed for automation is a problem, but hopefully this change
will help make those vendors make it possible.

@_date: 2020-01-12 15:30:31
@_author: John-Mark Gurney 
@_subject: [Cryptography] improved identification of non-targets 
John Denker via cryptography wrote this message on Sat, Jan 11, 2020 at 23:13 -0700:
This already exists.
Most of the cases (all?) of the civilian airliners that have
been shot down in the last 30 years or so have had functional
IFF systems, the problem is the systems around the missiles
(including humans) that are the problem.
Flight 655 had properly squawked a civilian aircraft from the
existing IFF system.
Only when people are more careful and do their jobs.  Example, after
flight 655, war ships were finally given the equipment to be able to
monior civilian frequencies.  Also, the computer didn't have the
commercial airline schedules, though in the case of 655, it was 27
minutes late leaving, but still might have helped.

@_date: 2020-01-30 12:13:09
@_author: John-Mark Gurney 
@_subject: [Cryptography] Proper Entropy Source 
John Denker via cryptography wrote this message on Wed, Jan 29, 2020 at 12:14 -0700:
Nothing a $7-10 USB audio dongle can't fix + a line in crontab:
5       */3     *       *       *       root    dd if=/dev/dsp bs=4096 count=1 2>/dev/null | sha512 > /dev/random

@_date: 2020-11-05 16:21:23
@_author: John-Mark Gurney 
@_subject: [Cryptography] Exotic Operations in Primitive Construction 
Christian Huitema wrote this message on Thu, Oct 01, 2020 at 08:49 -0700:
Only since the introduction of AES-NI.  Before very few cpus supported
GF multiple natively.  GF multiply is relatively cheap to implement in
hardware, but still requires a lot of space...
But it definitely wasn't cheap to implement 20+ years ago.  This is part
of the reason why AES-GCM didn't really take off till hardware
acceleration helped it out.

@_date: 2020-11-30 14:14:14
@_author: John-Mark Gurney 
@_subject: [Cryptography] A Scheme for Verifiable Lottery 
Yunxiang Li wrote this message on Wed, Nov 25, 2020 at 11:31 +0800:
Seems to me that a better way is similar to the coin flip implemented
by keybase: This way, each lottery entrant has some input into the random number
system that ends up picking the winner.  This helps ensure that even
the last entrant has influence, and prevents any possibility that the
winner is known till the last entrant has entered their ticket...
This can be further protected by each entrant committing to a secret,
but then not reveiling the secret till the lottery is closed...  Biggest
issue w/ this step is that everyone must send in their secret after
the lottery closes, and that could take quite a bit of time...

@_date: 2020-11-30 17:04:03
@_author: John-Mark Gurney 
@_subject: [Cryptography] A Scheme for Verifiable Lottery 
Yunxiang Li wrote this message on Tue, Dec 01, 2020 at 00:36 +0000:
No, the easier way to do this is have everyone generate a 128-bit value.
The organizer XOR's everyone's contribution together, then using HMAC
to extract the final selection/results of the lottery.  This could be
a simple, select out of n algorithm where n is the number of participants.
As for the list of participants, the name doesn't need to be identifiable,
it can be a UUID or another anonymous identifier, allowing each
participant to ensure that their contribution was used in the results.
