
@_date: 2013-10-17 23:27:48
@_author: Patrick Pelletier 
@_subject: [Cryptography] OpenSSL not using /dev/random (was: Re: /dev/random 
Are you on a machine with the RdRand instruction?  OpenSSL ships with a built-in RdRand ENGINE which just uses RdRand and doesn't use OpenSSL's random number generator at all.  (And thus needs no entropy.)  Although whether this ENGINE gets enabled is a bit tricky, and depends exactly on how OpenSSL was initialized.  (A group of us who contribute to the OpenSSL wiki have recently been debating the proper sequence of functions to call to initialize OpenSSL, and it's not as clear-cut as it seems like it ought to be.)
But if it's not using RdRand and not reading /dev/[u]random either, then this does sound scary indeed.

@_date: 2013-09-21 17:07:02
@_author: Patrick Pelletier 
@_subject: [Cryptography] RSA equivalent key length/strength 
I'm inclined to agree with you, but you might be interested/horrified in the "1024 bits is enough for anyone" debate currently unfolding on the TLS list:
and there was a similar discussion on the OpenSSL list recently, with GnuTLS getting "blamed" for using the ECRYPT recommendations rather than  at openssl.org/msg71899.html

@_date: 2014-04-02 21:19:15
@_author: Patrick Pelletier 
@_subject: [Cryptography] TLS/DTLS Use Cases 
Don't forget XMPP.  Which could be generalized to "instant messaging" and/or to "message-oriented middleware."

@_date: 2016-09-08 22:53:16
@_author: Patrick Pelletier 
@_subject: [Cryptography] Secure erasure in C. 
If you're writing a program which is single-threaded, and which you know is always going to be single-threaded, that works.  But if you're writing a library, chances are that someone will want to use it in a multithreaded program someday.
As others have pointed out, virtual memory is completely orthogonal to what the compiler is doing, and volatile will in no way prevent swapping.  You'd need to lock the pages, using OS-specific calls, to avoid swapping.
I think the problem is that deleter is static, therefore it only takes analysis of a single compilation unit to know that it won't change.  If you make deleter non-static, then its value could always be changed from another compilation unit, and the compiler can't make assumptions about its value.  (You might need to remove the "const" as well; I'm not sure.)
Even with whole-program optimization, the optimizer can't know that some dynamically loaded library won't change the value of deleter. I suppose that if your program is 100% statically linked, and you use a whole program optimizer, then maybe it could still outsmart you.  But you've still raised the bar substantially over the "static" version.

@_date: 2016-09-09 12:58:03
@_author: Patrick Pelletier 
@_subject: [Cryptography] Secure erasure in C. 
Sure, not to mention that the garbage collector could make copies of just about anything.
The original question was about C, though, so I think it's pretty safe.  If you're really paranoid, you could do something like this in main:
if (argc == -1)
   deleter = abort;
(And probably need a cast on the function pointer type.)

@_date: 2016-09-10 14:10:12
@_author: Patrick Pelletier 
@_subject: [Cryptography] Secure erasure 
I would argue the opposite: the most likely threat comes from a Heartbleed-style vulnerability, where your own process gets tricked into revealing the contents of its own memory.  In that sort of a threat model, the hardware doesn't matter, swap doesn't matter, caches don't matter.  All that matters is what's visible in the process's address space.  This is the sort of threat that the original question in this thread can defend against, by zeroing memory.
