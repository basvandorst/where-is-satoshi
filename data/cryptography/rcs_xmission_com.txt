
@_date: 2015-03-27 12:32:18
@_author: rcs@xmission.com 
@_subject: [Cryptography] D-Wave, RSA, and DLP 
56153 is in an easy-to-factor class of numbers.
Method:  Examine the square numbers S^2 that are slightly larger
than your target T, and see if S^2 - T is also a square number, D^2.
When you get lucky this way,  T = S^2 - D^2 = (S-D)*(S+D).
56153 falls to the first trial S.
Begin with S = ceiling(sqrt(56153)) = 237.
Then S^2 = 56169, and S^2 - T = 16, which is 4^2.
So 56153 = 237^2 - 4^2 = (237-4) * (237+4) = 233 * 241.
One of the exclusion rules for choosing RSA keys is that your
primes P and Q should not be too close together.  If the difference
trials of S.  There are some number theory tricks to exclude most S;
so K < 10^8 is attackable from a desktop computer.
The likelihood of this happening with random independently chosen
primes P and Q is negligible.
Rich Schroeppel
are sea ess at eks em eye ess ess aye oh en dot see owe em
Quoting Mattias Aabmets :

@_date: 2016-03-16 14:42:07
@_author: rcs@xmission.com 
@_subject: [Cryptography] Trust & randomness in computer systems 
Keeping the spirit of Henry's approach, a rework,
but avoiding the cost of completely starting over:
One advantage of a multi-engine plane is that one
engine may fail, but the plane can keep flying,
albeit at reduced performance.
If we designed our systems with multiple, swapable,
parts, we could swap out obsolete pieces without
disabling the whole structure.
Triple-DES functions as an enhanced-security cipher,
built from the less secure DES.  Suppose we used
a triple cipher with three different pieces: maybe
DES + Blowfish + IDEA.  When DES is weakened by
Moore's Law or crypto advances, we can slot in RC5
as a replacement for the part without crashing the
plane.  The upgrade can be scheduled, and phased in,
rather than being an emergency do-it-now patch.
Similarly for hashing: The full hash of a file is now
a side-by-side triple, MD5 + SHA1 + RIPEMD.  When
MD5 looks weak, we replace it with SHA2 or KECCAK.
Similar notions should work for asymmetric ciphers,
signatures, key agreement, etc.
It's unclear how to extend this to protocols, which
are more complex than ciphering.  It's also only
slightly helpful for defending against side-channels,
with their peek-inside capabilities.  But it would
help with smoother upgrading of crypto primitives.
Rich Schroeppel
Quoting Henry Baker :

@_date: 2016-09-10 18:25:27
@_author: rcs@xmission.com 
@_subject: [Cryptography] Finding the least significant bit of RSA 
In normal usage, both the encryption (E) and decryption (D) exponent for RSA
are odd numbers.  Suppose the RSA modulus is M = P*Q, with P and Q prime.
The product D*E must be congruent to 1 modulo GCD(P-1,Q-1).
This implies that P-1 divides D*E-1.  Assuming P>2, then P-1 is even,
so D*E-1 must be even.  Then D*E is odd, and so are D and E.
So the low bit of D is 1.
D can be masked by adding a random multiple of GCD(P-1,Q-1), but the
masked D is still an odd number (since the GCD is even).
Rich Schroeppel
Quoting Ray Dillinger :

@_date: 2017-07-10 10:38:02
@_author: rcs@xmission.com 
@_subject: [Cryptography] A software for combining text files to 
In English, in normal Ascii, the vowels are odd.
With your encoding, vowels are even -- the low bit is 0.
Vowels are pretty common, around 50% of typical text.
This will spoil the statistics of your random bits.
Rich Schroeppel
rcs at xmission.com
Quoting mok-kong shen :
