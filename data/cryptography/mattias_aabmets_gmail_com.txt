
@_date: 2015-04-04 20:43:42
@_author: Mattias Aabmets 
@_subject: [Cryptography] how to put a password in an evidence bag? 
2015-04-04 1:40 GMT+03:00 ianG :
Its possible to literally put passwords in an evidence bag, if they are
stored on a smart card.
This, however, requires a lot higher technical skill from the criminal to
implement, since he would
have to know how to write a JavaCard OS to a chip, how to program the
necessary java app, and
how to create and update the public keys in a secure manner on the card.
Or, the criminal could choose to implement a HSM, which can also be
literally put in an evidence bag.

@_date: 2015-04-14 23:00:00
@_author: Mattias Aabmets 
@_subject: [Cryptography] Feedback requested: ECC anonymous signatures 
2015-04-14 16:04 GMT+03:00 Natanael :
    / - - - /  * ( Further contents omitted for brevity's sake, please
Why are you making it so complicated?
1) Have a message *m* for which you want to create a temporal anonymous
2) Create your Personal Identifier String, which contains your name,
birthday, etc.
3) Create an *n* character length password and hash it.
4) Use the hash of your password as an AES key with which to encrypt your
Personal Identifier String.
5) Concatenate your *PIS* to the end of the message *m*.
6) ECCDSA the whole thing.
7) Append the public key of the ECCDSA signature to the end of the whole
8) Done.
Result: you have provided encrypted personal information with the data.
Adversary is unable to alter the data or the encrypted *PIS* without
invalidating the ECCDSA signature.
If the user wishes to reveal himself as the author of the said message, he
only needs to provide the password which was used to create the AES key.
*Of course, this version of the implementation is vulnerable to identity
theft.* An adversary is able to put anybodies personal info into the *PIS*.
This version fixes the ID theft issue:
1) Have a nation-wide PKI system (Based on RSA) implemented, like the ID
card in Estonia.
2) Have a message *m* for which you want to create a temporal anonymous
3) Create your Personal Identifier String, which contains your name and
your government-assigned personal identification code.
4) Sign your *PIS* with the private auth key on your ID card. CA provides
an OCSP signed timestamp, which validates your signature.
5) Create an *n* character length password and hash it.
6) Use the hash of your password as an AES key with which to encrypt your
7) Concatenate your encrypted *PIS* to the end of the message *m*.
8) ECCDSA the whole thing.
9) Append the public key of the ECCDSA signature to the end of the whole
10) Done.
Result: you have provided encrypted and authenticated personal information
with the data.
Adversary is unable to alter the data or the encrypted *PIS *without
invalidating the ECCDSA signature.
If the user wishes to reveal himself as the author of the said message, he
needs to provide the AES password and his auth public key cert.
How to verify the claimed identity of a message:
1) Verify the integrity of the ECCDSA signature.
2) If the sig is correct, proceed to step 3. Else, abort.
3) Decrypt *PIS* with provided password.
4) Verify RSA public key cert by making an OCSP request to CA. If valid,
proceed to step 5. Else, abort.
5) Recover the *PIS* by decrypting it with provided public key.
6) If the contents of the *PIS* match the contents of the public key cert
(it contains the persons name and personal identification code), the author
of the message has been validated. Else, abort.
7) Done.
Of course, this implementation does not fulfill your bonus features
requirements, but it is a lot simpler and is based on already-proven math
which enable one to reason about the security of the said implementation in
a more effective manner.

@_date: 2015-03-27 12:59:25
@_author: Mattias Aabmets 
@_subject: [Cryptography] D-Wave, RSA, and DLP 
I just stumbled on an article from phys.org
 and it
got me thinking.
If they managed to factor 56 153 with adiabatic quantum computations, i.e.
optimisation, using only 4 qbits,
then it follows that D-Wave, which is designed to solve optimization
problems and has 512 bits, is capable of
factoring 512 bit long composite numbers.
Furthermore, since Shor's algorithm can be applied to the discrete
logarithm problem
, it
follows that anything which
uses DLP as an underlying security function, like DHKE, ElGamal, or ECC, is
insecure with key lengths less than 512 bits.
In addition, also take into consideration that the square-root attacks on
the DLP, which halve the security margin, make even 1024 bit ECC keys
As of the moment, 256 bit ECC keys seem to be the standard.
Even more complicated is the issue with the RSA plaintext encryption, which
is essentially a transformed DLP.
Considering the square root attacks and the RSA encryption function, it can
be proven that any RSA ciphertext with
less than 1024 bits modulus is vulnerable to quantum computations carried
out by the 512 bit D-Wave computer.
With best regards,
Mattias Aabmets
