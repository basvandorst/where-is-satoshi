
@_date: 2014-04-07 14:53:06
@_author: Edwin Chu 
@_subject: [Cryptography] The Heartbleed Bug is a serious vulnerability in 
A latest story for OpenSSL
The Heartbleed Bug is a serious vulnerability in the popular OpenSSL
cryptographic software library. This weakness allows stealing the
information protected, under normal conditions, by the SSL/TLS encryption
used to secure the Internet. SSL/TLS provides communication security and
privacy over the Internet for applications such as web, email, instant
messaging (IM) and some virtual private networks (VPNs).
The Heartbleed bug allows anyone on the Internet to read the memory of the
systems protected by the vulnerable versions of the OpenSSL software. This
compromises the secret keys used to identify the service providers and to
encrypt the traffic, the names and passwords of the users and the actual
content. This allows attackers to eavesdrop communications, steal data
directly from the services and users and to impersonate services and users.

@_date: 2017-11-15 09:27:04
@_author: Chu Ka-cheong 
@_subject: [Cryptography] [FORGED] Re: Is ASN.1 still the thing? 
When protobuf first released, it's main feature is the
interoperability between different iterations of the same protocol.
Consider you have a message like this at the beginning?
struct People {
  name: String
  address: String
With ASN.1 you would probably encode it as a SEQUENCE. However, how
would you specify it if you know you will likely add new fields to it
in a V2 release maybe a week later?
struct People {
  name: String
  address: String
  first_name: String
  last_name: String
If the fields are added to the SEQUENCE, V1 and V2 of the same program
will not be able to talk to each other. You may define a new message
type and use tagging and union type to allow them to coexist, but what
if you need to do it frequently in a 2 weeks release cycle?
Why bother if protobuf can handle it without boilerplate?
message People
  string name = 1;
  string address = 2;
You just need to new fields to the message with unique id. V2 will
still be able to read message from V1 without manual conversion.
Some may say the protocol should be well designed and it shouldn't be
changed arbitrarily. It may be true for a internet protocol, but it is
not the case for the communications between different systems within
the same company, which is the primary use case for protobuf and those
newer encoding schemes.
