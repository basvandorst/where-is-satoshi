
@_date: 2003-11-13 10:34:41
@_author: Enzo Michelangeli 
@_subject: Are there... 
...one-way encryption algorithms guaranteed to be injective (i.e.,
deterministically collision-free)? Or are there theoretical reasons
against their existence?
I'm looking for algorithms where every piece of code and data is public,
thus excluding conventional enciphering with a secret key.

@_date: 2003-11-17 11:54:10
@_author: Enzo Michelangeli 
@_subject: Are there...one-way encryption algorithms 
Amir and others,
First, I'd like to thank all who have taken time to reply, either on- or
All suggestions so far are related to public-key algorithms; I had myself
thought about simply raising a generator g to the plaintext, or to a
suitable injective function of the plaintext, in a GF(p): that doesn't
even require a key to throw away. One drawback is that, with the possible
exception of ECC-based methods, the minimum size of the cryptotext becomes
larger than I'd like.
Anyway, the intended use is for primary keys in transaction databases, in
replacement of the PAN (a.k.a. credit card number). Using secure hashes is
the usual way of doing such things, but the slight risk of collision,
although practically negligible, is a bit irksome (especially considering
that the plaintext is of fixed size, and therefore injectivity is not a
priori impossible), and I was wondering if something better can be done.
----- Original Message ----- Sent: Sunday, November 16, 2003 10:44 PM

@_date: 2003-11-19 15:59:17
@_author: Enzo Michelangeli 
@_subject: Are there...one-way encryption algorithms 
Ah sure, that's why I said "irksome" and not "worrying" :-) It was more a
curiosity of theoretical nature than a practical concern.
----- Original Message ----- Sent: Tuesday, November 18, 2003 3:48 PM

@_date: 2003-11-27 18:06:55
@_author: Enzo Michelangeli 
@_subject: Problems with GPG El Gamal signing keys? 
Sent: Thursday, November 27, 2003 7:24 AM
There is an official announcement:

@_date: 2003-10-04 09:50:14
@_author: Enzo Michelangeli 
@_subject: Choosing an implementation language 
Sent: Saturday, October 04, 2003 4:31 AM
I'd like to see an implementation written in a language that is
memory-safe (I'm really sick of bugs related to buffer overflows) but
easily embeddable in C applications, such as Ocaml or SmartEiffel. They
seems to be also quite fast and memory-efficient, especially Ocaml (see
e.g.  ).

@_date: 2004-04-29 20:01:57
@_author: Enzo Michelangeli 
@_subject: Can Skype be wiretapped by the authorities? 
Sent: Wednesday, April 28, 2004 4:49 AM
What do you mean with "operator"? AFAIK, the system is fully peer-to-peer
( ).
Regarding the crypto, at  they
 What type of encryption is used?
 Skype uses AES (Advanced Encryption Standard) - also known as Rijndel
 - which is also used by U.S. Government organizations to protect
 sensitive, information. Skype uses 256-bit encryption, which has a
 total of 1.1 x 1077 possible keys, in order to actively encrypt the
 data in each Skype call or instant message. Skype uses 1536 to 2048
 bit RSA to negotiate symmetric AES keys. User public keys are
 certified by Skype server at login.
OK, so "Rijndael" is misspelled and the RSA-based key exchange does not
provide forward secrecy, but apart from that it doesn't smell like snake
oil. Not too bad, at least.
BUT, unfortunately, the implementation is closed source, so there are no
guarantees that the software is not GAKked. And yes, definitely an
opensource (and multiplatform) alternative would be a cool thing to have.
A message I posted a while ago to the list p2p-hackers was reposted by
Eugene Leitl to cypherpunks
( at minder.net/msg81814.html ) but
the couple of followups it elicited didn't seem to center the issues I
raised. I didn't reply then because I'm not a subscriber of cypherpunks
any longer, so I'd like to take this occasion for doing it here now:
Major Variola (ret) commented (indented lines, followed by my comment):
 >Skype claims to use RSA-based key exchange, which is good for
 >multi-party conferencing but does not preserve forward secrecy.
 >Maybe some variant of ephemeral D-H authenticated by RSA
 >signatures, with transparent renegotiation every time someone
 >joins the conference, could do the job better.
 RSA (ie persistant keys) may be an option but MUST NOT be
 required, for secrecy reasons as mentioned.  (At worst RSA keys
 can be used once, then discarded.  Lots of primes out there :-)
Well, I don't see why RSA signatures (only for authentication of the key
exchange) could endanger forward secrecy.
 Also, this is *voice*, ie biometric auth,
 so public-key-web-o-trust verislime scam is
 unnecessary at best.
It's not only voice, it's also IM-style text chat. And even with voice,
biometric authentication becomes awkward to use with conference calls.
 >One could always implement a brand new
 >network, using Distributed Hash Table algorithms such as Chord or
 >Kademlia,
 We don't give a flying fuck as to which shiny new algorithm you use,
 although were we a graph theory wonk, we might care.
The issue here is that DHT algorithms allow to implement a fully
distributed directory, which means one much more resistant to attacks
(especially from institutional attackers) than implementations based on
centralized servers (see, in a related fild, the different destinies of
Napster and its distributed successors such as Overnet or the less
efficient Gnutella). Still, a full search takes O(log(n)) steps, making
them practical for implementing directory/presence services.
 >but it would be much easier to rely from the very beginning upon
 >a large number of nodes (at least for directory and presence
 >functionality, if not for the reflectors which require specific
 >UDP code).
 What the NAT world (yawn) needs is free registry services
 exploitable by any protocol.  Those NAT-users with RSA-clue can
 sign their registry entry.
Not only that: NATted agents cannot be "called" unless they first register
with some reflector on the open Internet. And centralized reflectors are,
again, easy to attack, and also expensive to operate, as the bandwidth
requirements are substantial (all the traffic flows through them): see
e.g. John Walker's analysis of the reasons that led him to abandon
SpeakFreely at  .
Thomas Shaddack suggested to leverage on Jabber, but:
1. Jabber uses TCP as transport, and therefore can't be efficiently used
as transport for telephony, i.e. using encapsulation of the voice packets
in the Jabber protocol in order to traverse NAT devices.
2. Jabber is based on a client-server paradigm similar to e-mail. Running
a Jabber server requires an always-on machine with its own domain name;
and, although dynamic DNS can help, the model again tend to be
hierarchical, easy to attack etc. That pretty much rules it out also for
session initiation, directory/presence etc.
The beauty of Skype, encryption aside, is that it's based on an overlay
network solely based on P2P servents, relies (if their FAQ tells the
truth) upon NO central registry for presence and directory services, and
each client that runs non-NATted can transparently act as reflector
supporting NATted users. Plus, all this (including, besides voice,
text-based instant messaging) works with zero configuration with an
idiotproof UI.

@_date: 2004-07-18 18:20:27
@_author: Enzo Michelangeli 
@_subject: Using crypto against Phishing, Spoofing and Spamming... 
Can someone explain me how the "phishermen" escape identification and
prosecution? Gaining online access to someone's account allows, at most,
to execute wire transfers to other bank accounts: but in these days
anonymous accounts are not exactly easy to get in any country, and anyway
any bank large enough to be part of the SWIFT network would cooperate in
the resolution of obviously criminal cases.
----- Original Message ----- Sent: Sunday, July 18, 2004 1:51 AM
majordomo at metzdowd.com

@_date: 2004-05-09 16:37:06
@_author: Enzo Michelangeli 
@_subject: Can Skype be wiretapped by the authorities? 
Sent: Sunday, May 09, 2004 12:44 PM
Or, not exploits we're aware of...
Right, that's precisely my point. Skype is showing us the way to go,
although the security of the product may not be good enough (and being
closed source, it's automatically untrusted).
That's understandable considering their business model. But I see Skype as
a proof of feasibility for the "real thing": an opensource application
built on sound bases.
I've read that Skype uses an iLBC codec implemented by Global IP Sound.
There is also an opensource implementation of it (
although its license contains weaselspeak clauses that I don't like very
much:  .
choice, and is totally unencumbered.
I believe that we are finally close to the point where all the bits and
pieces for a secure, multiplatform, decentralized, opensource Internet
phone + text IM are available, and it would only take some coding effort
to put them to work together:
- Codec: Speex (
- Portable audio interface layer: Portaudio (
- Bulk encryption and authentication: SRTP, now a standard-track protocol
(RFC3711) and with an opensource reference implementation available at
srtp.sourceforge.net .
- Key exchange: authenticated D-H (how to perform the authentication, as I
said, should be discussed: biometric is not viable if only the text chat
feature is used, and multy-party conferencing calls for suitable
extensions to the basic D-H scheme)
- Directory and presence: any good P2P content-addressable scheme.
Preserving some sort of interoperability with file-sharing applications
would solve the bootstrapping problem (hundreds of thousands of nodes are
already up and running), but the most popular networks (eMule, Overnet and
ReverseConnect) are based on Kademlia, which is a Distributed Hash Table
algorithm and therefore doesn't allow sorted access (useful, e.g., to
locate the reflector with the largest available bandwidth). I recently
discovered a few tree-based distributed algorithms which would allow just
SkipGraphs: P-Grid:

@_date: 2004-11-05 16:10:56
@_author: Enzo Michelangeli 
@_subject: Your source code, for sale 
Sent: Friday, November 05, 2004 7:01 AM
In the world of international trade, where mutual distrust between buyer
and seller is often the rule and there is no central authority to enforce
the law, this is traditionally achieved by interposing not less than three
trusted third parties: the shipping line, the opening bank and the
negotiating bank. First, the buyer asks his bank to open an irrevocable
letter of credit (L/C), which is a letter sent to the seller's bank
instructing it to pay the seller once the latter presents a given set of
documents: these usually include the "bill of lading" (B/L), issued by the
shipping line to declare that the desired cargo was indeed loaded on
board. The seller gets the letter of gredit from his bank and is now sure
that he will be paid by the latter (which he trusts); so he purchases or
manufactures the goods, delivers them to the shipping line getting the
B/L, passes it together with the other documents to his bank, and draws
the payment. The seller's bank sends by mail the documents to the buyer's
bank (which it trusts due to long-standing business relationships),
knowing that it will eventually receive the settlement money. The buyer's
bank receives the documents, debits the buyer's account, remits the monies
to the seller's bank, and delivers the documents to the buyer. When the
ship arrives to the buye's seaport, the buyer goes to the shipping line,
presents to it the B/L and in exchange gets the cargo (in sea shipments,
the B/L represents title to the goods).
That's way trickier because there are no trusted third parties, not even
e-gold Ltd. / G&SR, Inc. The trust chain with the L/C works well because
delegation of trust is unnecessary: every link in the chain bears
responsibility only to its adjacent links.
Interestingly, with L/C's this problem is addressed by involving yet
another third party: an internationally-recognized inspection company
(e.g., the Swiss SGS) that issues a document certifying that the cargo is
indeed what the buyer expects and not, i.e., bricks. Banks and shipping
lines don't want to get involved in these issues; the seller's bank will
only check all the documents requested by the L/C (possibly including the
inspection certificate).
But it's hard to assess the value of partially-released code. If the
gradual transfer bits-against-cents is aborted, what is left to the buyer
is likely to be unusable, whereas the partial payment still represents
good value.
A more general issue is that source code is not a commodity, and
intellectual property is not "real" property: so the traditional "cash on
delivery" paradigm just doesn't work, and looking for protocols
implementing it kind of moot. If the code is treated as trade secret,
rather than licensed, an anonymous buyer may make copies and resell them
on the black market more than recovering his initial cost, at the same
time undercutting your legitimate sales (see e.g. the cases of RC4 and
RC2). This can cause losses order of magnitude larger than refusing to pay
for his copy.

@_date: 2004-11-07 19:46:20
@_author: Enzo Michelangeli 
@_subject: Your source code, for sale 
Sent: Sunday, November 07, 2004 11:21 AM
Actually, seeing issuance and acceptance of L/C's only as a money-lending
activity is not 100% accurate. "Letter of credit" is a misnomer: an L/C
_may_ be used by the seller to obtain credit, but if the documents are
"sent for collection" rather than "negotiated", the payment to the seller
is delayed until the opening bank will have debited the buyer's account
and remitted the due amount to the negotiating bank. To be precise: when
the documents are submitted to the negotiating bank by the seller, the
latter also draws under the terms of the L/C a "bill of exchange" to be
accepted by the buyer; that instrument, just like any draft, may be either
sent for collection or negotiated immediately, subject, of course, to
final settlement. Also, depending on the agreements between the seller and
his bank, the received L/C may be considered as collateral to get further
allocation of credit, e.g. to open a "back-to-back L/C" to a seller of raw
However, if the documents and the draft are sent for collection, and no
other extension of credit are obtained by the buyer, the only advantage of
an L/C for the seller is the certainty of being paid by _his_
(negotiating) bank, which he trusts not to collude with the buyer to claim
fictitious discrepancies between the actual documents submitted and what
the L/C was requesting. (And even in case such discrepancies will turn out
to be real, the opening bank will not surrender the Bill of Lading, and
therefore the cargo, to the buyer until the latter will have accepted all
the discrepancies: so in the worst case the cargo will remain under the
seller's control, to be shipped back and/or sold to some other buyer.
If it acted differently, the opening bank would go against the standard
practice defined in the UCP ICC 500
( and its reputation would be
badly damaged). So, the L/C mechanism, independently from allocation of
credit, _does_ provide a way out of the dilemma "which one should come
first, payment or delivery?"; and this is achieved by leveraging on the
reputation of parties separately trusted by the endpoints of the
Generally speaking, it is debatable whether "doing banking" only means
"accepting deposits and providing credit" or also "handling payments for a
fee": surely banks routinely do both, although they do not usually enjoy a
_regulatory franchise_ on payments because failures in that field are not
usually argued to be capable of snowballing into systemic failures.
(Austrian economists argue that that's also the case with provision of
credit, but it's a much more controversial issue). In the US, as we know,
Greenspan's FED decided several years ago against heavy regulation of the
payments business, and most industrialized countries chose to follow suit.
That would probably end up attracting unwelcome attention by the
regulators. Besides, wouldn't that require some sort of fractional
banking, resulting in a money supply multiple of the monetary base by an
unstable multiplier, and ultimately bringing back the disadvantages of
fiat currencies?

@_date: 2005-02-07 09:07:46
@_author: Enzo Michelangeli 
@_subject: Simson Garfinkel analyses Skype - Open Society Institute 
Sent: Saturday, January 29, 2005 1:48 AM
Actually it's not that bad: using SIP, the RTP packets can be protected by
SRTP (RFC3711, with an opensource implementation from Cisco at
 ) and the SIP signalling, as per RFC2246, can
go over TLS. It's more an issue of deployment than standards, possibly due
to CALEA-related pressures on service providers, but some manufacturers of
hardware do support VoIP security: see e.g. what is claimed at
 .

@_date: 2005-01-05 08:49:36
@_author: Enzo Michelangeli 
@_subject: SSL/TLS passive sniffing 
Sent: Saturday, December 25, 2004 4:56 AM
This "entropy depletion" issue keeps coming up every now and then, but I
still don't understand how it is supposed to happen. If the PRNG uses a
really non-invertible algorithm (or one invertible only with intractable
complexity), its output gives no insight whatsoever on its internal state.
As entropy is a measure of the information we don't have about the
internal state of a system, it seems to me that in a good PRNGD its value
cannot be reduced just by extracting output bits. If there is an entropy
estimator based on the number of bits extracted, that estimator must be

@_date: 2005-01-06 16:35:05
@_author: Enzo Michelangeli 
@_subject: entropy depletion (was: SSL/TLS passive sniffing) 
Sent: Thursday, January 06, 2005 3:06 AM
Yes, but those are implementation flaws. Also a true RNG could present
weaknesses and be attacked (e.g., with strong EM fields overcoming the
noise of its sound card; not to mention vulnerabilities induced by the
quirks you discuss at
Anyway, I was not saying "RNG's are useless because PRNG's are more than
enough": the scope of my question was much narrower, and concerned the
concept of "entropy depletion".
Sure, I don't disagree with that.
By how much exactly? I'd say, _under the hypothesis that the one-way
function can't be broken and other attacks fail_, exactly zero; in the
real world, maybe a little more. But in
function, directly called by the exported kernel interface
get_random_bytes(), states:
        if (r->entropy_count / 8 >= nbytes)
                r->entropy_count -= nbytes*8;
        else
                r->entropy_count = 0;
...which appears to assume that the pool's entropy (the upper bound of
which is POOLBITS, defined equal to 4096) drops by a figure equal to the
number of bits that are extracted (nbytes*8). This would only make sense
if those bits weren't passed through one-way hashing. Perhaps, a great
deal of blockage problems when using /dev/random would go away with a more
realistic estimate.

@_date: 2005-01-08 10:46:17
@_author: Enzo Michelangeli 
@_subject: entropy depletion (was: SSL/TLS passive sniffing) 
Sent: Friday, January 07, 2005 9:30 AM
But that was precisely my initial position: that the insight on the
internal state (which I saw, by definition, as the loss of entropy by the
generator) that we gain from one bit of output is much smaller than one
full bit. However, I've been convinced by the argument broght by John and
others - thanks guys - that we should not mix the concept of "entropy"
with issues of computational hardness.
That said, however, I wonder if we shouldn't focus more, for practical
purposes, on the replacement concept offered by John of "usable
randomness", with a formal definition allowing its calculation in concrete
cases (so that we may assess the risk deriving from using a seeded PRNG
rather than a pure RNG in a more quantitative way). The paper you mention
appears to go in that direction.

@_date: 2005-07-14 22:08:03
@_author: Enzo Michelangeli 
@_subject: EMV 
AFAIK, the cards are still the same (Sony FeliCa:
 I never changed mine since I got it
several years ago. The same card was also adopted in 2002 by EZ-Link in
Singapore ( ).
----- Original Message ----- ; "'Florian Weimer'" ; "'David
Alexander Molnar'" ; "'? Schmidt'"
; Sent: Wednesday, July 13, 2005 8:55 AM
majordomo at metzdowd.com

@_date: 2005-03-15 09:26:06
@_author: Enzo Michelangeli 
@_subject: I'll show you mine if you show me, er, mine 
Sent: Wednesday, March 09, 2005 4:25 AM
SRP ? It's patented, but available under a royalty-free BSD-style license:
 .
