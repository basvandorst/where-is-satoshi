
@_date: 2013-08-28 14:56:02
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] Why human-readable IDs (was Re: Email and IM are 
<521CE337.6030706
What do you think of namecoin?
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? Truth comes as conqueror only to those who have lost the art of receiving it
as friend. ? Tagore

@_date: 2013-08-28 20:04:34
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] Separating concerns 
<521CE337.6030706
I agree with Perry and Phill that email experience should be
essentially undisturbed in the normal case, though it's OK to add an
additional authorization step.
One thing that irks me, though, is the problem of the robust, secure
terminal: if everything is encrypted, how does one survive the
loss/theft/destruction of a computer or harddrive? I'm no ignoramus,
yet I have, several times, lost data I cared about due to hardware
failure or theft combined with improper backup. How is a total newbie
to do?
Most newbies rely on things surviving despite their lack of explicit
caution. Currently, they do it by basically trusting Google or some
other company with their mail. Whichever way you do things to make
them responsible for keys will lead to either (1) failure because it's
technically too hard, and/or (2) automated attacks on the weak point
that handles things for them.
For instance, you have a program that automatically recovers keys from
the escrow modulo a few questions. Then, either few questions are too
hard and he actually looses the keys, or they are easy enough that the
attacker can find answers and recover the key.
Or, you have standardized key management and backup policies. Then the
attacker can look at the standardized location for the precious keys,
and modulo extraction of some master key, can automatically steal
everyone's wallet.
And then, to prevent automatic extraction of security data, you find
that you need not just an appropriate distributed infrastructure
(which is more painful to fund if you can't sell the data and require
an explicit transaction from the user), but also secure terminals ?
which implies a secure OS, and hardware that you actually control,
rather than big corporations that bend over for big governments.
That's a lot of yak to shave to provide end-users (or even average
geeks) with seemless secure email.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? Being generous is inborn; being altruistic is a learned perversity.
No resemblance ?
? Robert Heinlein, "Time Enough For Love"

@_date: 2013-11-20 00:53:20
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] Moving forward on improving HTTP's security 
I don't think we're there yet, but eventually we will be.
Trustable computing is computing that possesses an auditable bootstrap
path from trustable sources. That is why efforts like those of Alan
Kay, Ian Piumarta, etc., or the DARPA CRASH-SAFE program, matter.
Of course, in the next step of the trust war, to avoid overly easy
pattern recognition and subversion of the initial bootstrap elements,
you need not just a fixed schematics, but a random generator of
schematics that are equivalent at a high-level, but hard to recognize
and latch on at a low-level, thereby making a recognizer hard to hide
in the lower-level substrate that you're building upon. Happily, we're
not that far along the arms race yet.
The race has no end.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? Be who you are and say what you feel, because those who mind don't matter
and those who matter don't mind.  ? Dr. Seuss

@_date: 2013-10-07 10:32:23
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] AES-256- More NIST-y? paranoia 
Wait, am I misunderstanding, or is the NSA recommending that people
"checksum" by leaving behind the key encrypted with a backdoor the NSA
and the NSA only can read? Wow.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? Few facts are more revealing than the direction people travel
when they vote with their feet. ? Don Boudreaux

@_date: 2013-10-28 17:33:30
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] BitMessage? 
Indeed. Proof of work is supposed to alleviate these issues, but can
only do so much.
This can be fixed, if it hasn't been yet: your proof of work needs to
incorporate recent bitmessage chain state in its salt, so you can't
precompute long in advance.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? It may be bad manners to talk with your mouth full, but it isn't too
good either if you speak when your head is empty.

@_date: 2013-09-02 03:00:42
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] Thoughts about keys 
Once again, what do you think of namecoin?
A bitcoin-like consensual database based on proof of work.
If you also require proof-of-key via signature from the recipient,
majority attacks make DoS easy, but identity stealing is still
dependent on highly visible unsigned revocation certificates.
The cookie better not be a a value that the organization can
skew with its own "random" source, but be based on a digest of
consensual data, such as the date (with sufficiently coarse resolution),
the top of the consensual database (if any),
public weather measurements from previous day, etc.
Then, each user can just broadcast his signature
of the previously unpredictable consensual data,
and various timestamping organizations can sign messages that say
"yes, I saw that at this time",
maybe charging some tiny usage fee in the process.
If a handshake is required (and in this case, it looks like it is),
at least, prevent the organization from personalizing the cookie too much,
by requiring it to have personal cookies be based on a digest of
a common salt for all addresses, and
data consensually associatable to the destination address.
After a deadline, the organization publishes
the definitive merkle tree digest of who was seen on time,
together with the common salt.
Assuming a namecoin like system where every server has ALL the keys,
your query could be of the form: "give me all keys k such that
digest(k&mask)==digest(k0&mask)" with mask wide enough that
you get say ~1000 keys, and computed in a deterministic/non-deterministic
enough way that you don't leak too much information.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? Reevaluate your ends periodically ? if some of them or in contradiction with
reality or with each other, abandon or amend them without mercy ? and those
you keep, pursue without any apology.

@_date: 2013-09-02 19:53:03
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] Thoughts about keys 
In my scheme, no one can predict it, everyone can postdict it,
*after* the "trusted" organization published its salt, at which point
it's too late to send it signed confirmations.
Therefore, neither side can cheat.
In particular, the "trusted" organization has precious little power
to extract information by handing users carefully crafted cookies.
For even less power, the organization can publish digests of its salts
years in advance.
You can't broadcast the signed token unless you have the user's key.
And sure, you can claim that you saw the signed token before the deadline,
but unless you got a tree the hash of which was published as an ad
in a reputable print institution, what value has your word?
So, to cheat, you need both the user's key and the trusted organization's
complicity. Or to have broken the digest, of course.
Interchange is expensive.
Hopefully, you only need to reply to a handful of them every so many months.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? The most exciting phrase to hear in science, the one that heralds new
discoveries, is not "Eureka!" (I found it!) but "That's funny ..."
                ? Isaac Asimov

@_date: 2013-09-03 12:45:00
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] A strategy to circumvent patents? 
Don't write the code. Write a reasonably general software solver that
finds a program that fulfill given specifications, given a minimum
number of hints. Then write a specification for the problem (e.g.
finding a nice elliptic curve with interesting properties) and let the
solver find them.
You didn't explicitly write the solution. Now, the patent troll has to
argue that the problem itself, not the solution, is covered by the
patent ? which I believe is not supported by patent law. Or he has to
argue that the solution isn't obvious to someone versed in the arts,
which it is, since a trivial automated program could find the
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? *EULA: By reading or responding to this message you agree that all my stated
or unstated opinions are correct.* "EULA" ? patent pending.

@_date: 2013-09-03 15:16:14
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] FIPS, NIST and ITAR questions 
Can't you trivially transform a hash into a PRNG, a PRNG into a
cypher, and vice versa?
hash->PRNG: append blocks that are digest (seed ++ counter ++ seed)
PRNG->cypher: XOR with data from PRNG
cypher->hash: encrypt(data, constant_key)
Of course, that might not be the best way to construct the most
efficient and most robust versions of the respective functions, but
that might do a decent enough job, and make export restrictions
Or once again, maybe a general problem solver given the specification
of some cryptographic function satisfying some properties could
automatically find a robust enough algorithm, and then it's impossible
to either restrict its export or patent. Now, if each time your solver
is itself run with a different PRNG and seed, it needs to send a copy
of its output to the NSA, things become "interesting".
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? The ultimate result of shielding men from the effects of folly is
to fill the world with fools. ? Herbert Spencer

@_date: 2013-09-04 10:45:24
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] FIPS, NIST and ITAR questions 
Just because it's trivial to produce bogus crypto doesn't mean it's
non-trivial to produce good crypto, given a few universal recipes.
IIUC, there are already good known ways to go from stream cipher to
PRNG, or the other way around, and from a hash to a PRNG, and the
other way around.
e.g HMAC-DRBG goes hash to prng, the usual construct goes prng to
stream cipher, and there's quite possibly a secure transform from
cipher to hash, though I don't think the topic has been studied
All that to say, if digests are not subject to export, then it's easy
to export crypto. Or conversely, if crypto is controlled, then it's
easy for the thugs with badges to claim that digests are controlled,
if they hate you.
These techniques could also be used to produce cryptosystems that fit
in very small source code and/or are the result of an automated
search, so they may in practice defeat export restrictions and/or
patent claims: just get the user to download it, libdvdcss style.
That said, the missing piece currently seems to be good public key encryption.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? A child of five would understand this. Send someone to fetch a child of five.
        ? Groucho Marx

@_date: 2013-09-04 12:59:08
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] FIPS, NIST and ITAR questions 
Jerry, if you have good reasons to believe that either HMAC-DRBG or
the standard stream cipher construct are insecure, you should be
publishing a paper, not flaming a nobody.
That said, I readily admit that the cipher to hash transformation
hasn't been widely studied enough, though there are real-world
(enough) systems that use variants of such transformations, e.g.
My main point was that for the sake of circumventing attempts to ban
crypto, either through regulations or patents, you can bootstrap a
pretty secure system out of a good hash function and simple
transforms, that can probably all fit on a t-shirt together, either as
APL or Perl gibberish or as a QR code. Good luck banning that.
While this construct might not give you a best-of-breed system,
especially with respect of performance or interoperability, it is good
enough for Perry's purpose of bootstrapping a secure messaging system,
and using such a system, can trivially bootstrap the best-of-breed
system by downloading the missing bits. Now the thugs have to go sue
millions of users.
Sorry for repeating myself. I won't write on this topic anymore.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? Anarchism is founded on the observation that since few men are wise enough
to rule themselves, even fewer are wise enough to rule others. ? Edward Abbey

@_date: 2013-09-08 12:19:53
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] Trapdoor symmetric key 
Then it's not a symmetric key algorithm with a trapdoor, it's just a
broken algorithm.
I suppose the idea is that by using the same trapdoor algorithm or
algorithm family
and doubling the key size (e.g. 3DES style), you get a 256-bit
symmetric key system
that can be broken in 2^128 attempts by someone with the system's private key
but 2^256 by someone without. If in your message you then communicate 128 bits
of information about your symmetric key, the guy with the private key
can easily crack your symmetric key, whereas others just can't.
Therefore that's a great public key cryptography system.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? Theists think all gods but theirs are false. Atheists simply don't make an
exception for the last one.

@_date: 2013-09-09 19:51:25
@_author: =?ISO-8859-1?Q?Far=E9?= 
@_subject: [Cryptography] Some protection against replay attacks 
Reading about several attacks based on partial message replay, I was
wondering if the following idea had any worth, or maybe was already
widely used (sorry, I'm way behind in the literature):
"the actual symmetric key to be used to encrypt the payload is the
hash of the shared secret, the time, and other public data."
Optionally, "other public data" can include information identifying
the two parties, to make active attacks harder, as well as nonces sent
by either or both parties, and sequential numbers preventing reuse
within the window, etc.
This means that protocol attacks are now restricted to a smaller
window (say, TCP timeout of 5 minute), in either the time range that
active attacks can be conducted, or that the passive data can be
decrypted. i.e. that's automated rekeying, in a way that almost
guarantees the same key is never used twice.
Depending on the protocol, the server can be trusted to broadcast and
communicate its time with some coarse grain, and the client just uses
its NTP time as a guess. The server can accept the proposed client's
time if within an acceptable window, or override it with its time,
that the client can deny if in paranoid mode ? in which case there is
a DoS attack possible if NTP is subverted.
??? ? Fran?ois-Ren? ?VB Rideau ?Reflection&Cybernethics? Reason isn't about not having prejudices,
it's about having (appropriate) postjudices. ? Far?
