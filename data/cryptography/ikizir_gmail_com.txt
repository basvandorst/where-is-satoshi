
@_date: 2015-11-18 23:15:09
@_author: Ismail Kizir 
@_subject: [Cryptography] A new, fast and "unbreakable" encryption algorithm 
I've developed a new encryption algorithm, which dynamically changes
the key according to plaintext and practically impossible to break. I
also opened to public with MIT&GPL dual License.
It is also quite fast; ~80% faster than the fastest mode of AES
without cpu instruction set support.
I will present a paper on Turkish National Inet-tr 2015 Symposium on 3 December.
It is a very simple and yet efficient logic. Anyone who looks at the
self documented(in English) C code at
 may understand why and how it is unbreakable.
I simply use the key as a jump table and, with every encrypted byte, I
change the jump table(the key) as a result of 3-4 parameters including
the last plaintext byte itself. Briefly, I encypt the plaintext with
the key and also dynamically encrypt the key with the plaintext.
The code is self documented in English.
On Linux simply
gcc HohhaDynamicXOR.c -O2 -Wall
will make integrity checks and print benchmarks. It is production ready.
I know that a lot of people thinks that there is a "new amateur in
town claiming having invented an unbreakable encryption" :)
That's why, I am trying to explain all my logic, publicly to professionals.
It's not rocket science. You will "just understand" when you read:
Until today, we were looking from the "wrong side" I guess.
We were all thinking that we must have a "fixed" key which must never change!
I begun to ask that question: "Why the key must be fixed?" and changed
the paradigm.
And I decided to dynamically update the key in encyption and decryption process.
The essential logic of the algorithm is using the key as a "jump
table" which is dynamically updated with every "jump" we make.
To understand better how it functions, suppose that we don't have a
complex function.
Given the key body length(L) is a power of 2, and M is an integer to
tell us where we are in the "key body":
We just take the byte at position M of the key body, we XOR that byte
with the byte to be encrypted(X).
We increase the byte at position M and "jump to" (M+X)%L
So, every time we encrypt a byte, we also change the key. It's a bit
more complicated than this. But essentially this is the base logic. In
real function, we do more complex operations with more variables like
the salt(or nonce) value, the last byte we encrypted, the key
checksum(against related key attacks) etc.
Briefly, to decypher a ciphertext, a cracker needs to find out the
key, and, to find out the key, cracker needs to find out the
plaintext, because the key is dynamically updated according to
plaintext during encryption process: Impossible!
I just want Linux uses a "strong encryption algorithm" to prevent
States, besides inalphabet kids, from reading your files :)
I believe this algorithm is the future of the encryption.
Source code: I will be glad to see my algorithm included in your products.
Please feel free to ask if you have any questions.
Ismail Kizir
CTO, Hohha Internet Services Ltd.

@_date: 2015-11-19 02:06:01
@_author: Ismail Kizir 
@_subject: [Cryptography] A new, 
Sorry Natanael,
But your mail is a good example of "speaking without thinking"!
You just took the example I gave to explain the "base" of the algorithm.
Do you really think that I went to public without taking precautions
against "wannabee cryptoanalysts"? And I don't claim that's perfect.
There is always a room for optimization and better security. But ... :
There are 2 factors which influences security:
1. Key length L
2. Number of jumps J
Every byte to be encrypted, has "( L!(LâJ)!) " possibilities to choose
for "each jump". So, which mean ( L!(LâJ)!)^J possibilities for all
jumps. For each jump we make an XOR with a different element of the
key body. The first jump step is the last plaintext byte and the
following jump steps are key body bytes.
Every byte used for a jump is incremented by a factor of last
plaintext byte. So, the impossibility borns from that question: "Which
key?"; because the key at the first byte encyrpted is very different
from the key of the encryption.
I repeat: I think you speak without thinking too much.
I copy here the hand optimized function for 2 jumps:
uint64_t xorEncryptHOP2(uint8_t *K, uint8_t *Salt, uint8_t
KeyCheckSum, size_t InOutDataLen, uint8_t *InOutBuf)
{ // Encrypts or decrypts message and returns checksum of the InOutBuf
BEFORE encyption
  // SaltData is a 4 bytes uint8 array! IT IS NOT READ ONLY! IT WILL
BE MANIPULATED BY THE FUNCTION!
  register uint32_t M;
  register size_t t;
  register uint8_t XORVal, LastVal = 0,TmpVal; // Last PLAINTEXT byte
processed. It will be an input parameter for the next encrytpion
  register uint64_t Checksum=0;
  register uint32_t BodyMask = GetBodyLen(K); // +1 because we will
use this "Mersenne number" for & operation instead of modulus
  uint8_t Body[MAX_BODY_SIZE];
  memcpy(Body,K+SP_BODY,BodyMask);
  BodyMask--;
  Salt[0] ^= KeyCheckSum;
  Salt[1] ^= KeyCheckSum;
  Salt[2] ^= KeyCheckSum;
  Salt[3] ^= KeyCheckSum;
  // Initial position of the pointer is dependent on actual salt value
  M = BodyMask & Salt[0];
  //printf("xorEncrypt BodyLen: %u KeyCheckSum: %u Salt:
%u\n",BodyLen, KeyCheckSum,Salt);

@_date: 2015-11-19 02:25:51
@_author: Ismail Kizir 
@_subject: [Cryptography] A new, 
And another important point to mention:
If you look at the code, you will see that the "first jump position",
is dependent of the salt(or nonce) value actually used!
If you examine well the code, you will see that there are plenty of
carefully taken precautions against cryptoanalysis.
And as a last statement, I will give you various options for better
security/speed ratios for your taste:
Just change one line:
Body[M] = ROL32_1(Body[M]);
As you see, there is room for better "scrambling" and "optimizations"
The base of the algorithm is very very very strong. You will admit it
if you carefully examine it.

@_date: 2015-11-19 04:07:27
@_author: Ismail Kizir 
@_subject: [Cryptography] A new, 
First, I really want to thank you, because you are giving your
precious time to criticise my work. I really appreciate it.
But, again, you are doing the same mistake at many points: This time,
you speak "without reading" :)
My algorithm is "fundamentally different" from all of those, because,
it dynamically "encrypts" the key itself "during a single
You see? You haven't read what I wrote.
"My Salt value" is a randomly choosen 4 bytes for every "transaction".
My "salt" is neither salt,  nor IV nor "salt in hashing", nor "nonce"
in cryptology, but a combination of all them.
The first jump position, depends on the salt value. Changing the
initial position of the encryption gives a "completely different
output"! This is a precaution against, chosen ciphertext attacks.
Not finished!
I XOR all bytes of salt value with 8Bit CRC, which give me a
"completely different output" for a small change in key, as I am using
those salt values for every byte to be encrypted. This is a precaution
against "related key attacks"
Changing the "salt value"(or call it nonce value if you prefer) of the
algorithm doesn't just a multiplication of possibilities by 255^4; it
"completely" changes the result. Because, it "completely" changes the
jump path!
The algorithm is safe against: Cryptoanalysis like : Index of
coincidence, Kasiski, Vigenere Cypher. Because, there is no "pattern".
For example the most frequent letter "A", of Turkish alphabet will be
encrpyted as different values each time.
Most importantly; during a single transaction, the plaintext is
encrypted with the key, meanwhile, the key itself is encrypted with
the plaintext. This avoids "chosen ciphertext" attack, "ciphertext
only attack" or  differential cryptoanalysis.
Even if salting is not used, the algorithm guarantees us that it is
impossible to find out the key even if we have the cyphertext and
plaintext. Because, "there will be a lack of information". Let's take
the trivial example: We do at least 2 jumps. So, we XOR the plaintext
byte with at least 2 numbers. In this case, even if we have the
plaintext and the cyphertext, we may just obtain the XOR result of 2
unknown values.
I will keep you writing. But, for the moment, I am sure, if you read
carefully, you will understand that you missed some points about my
algorithm before writing me those lines.
Again, I want to thank you to give me your precious time. Please keep
criticising. Me too, I will think about what you write and give you my
Sorry about my English. My reading is OK but writing is terrible :)
Ismail Kizir

@_date: 2016-04-05 20:21:58
@_author: Ismail Kizir 
@_subject: [Cryptography] A humble recommendation 
For a long time, I have been following the discussions on the list.
I have a political sciences education, which makes it more interesting for me.
In my personal opinion, we are living one of the rare moments, the
great constitution of founding fathers is not enough!
European constitutions(except U.K, which is also a Anglo-Saxon
country) are usually very vey long constitutional texts. And we
criticize this very much.
As students, we were telling to our professors that we love short
constitutions. And they were replying: "Everybody loves short
constituions. But it has a potential danger: Juristocracy. Short
constitutions need to be 'interpreted' by the 'judges' and/or by the
administrators, and, in case they have bad intentions, the character of
the regime may change to oligarchy".
This is one of the rare moments of having a long constitution is better:
For example, 22th article of Turkish
simply tells:"Everyone has the freedom of communication. Privacy of
communication is fundamental....". The judges has still very strong
rights, but limited!
Unfortunately, the actual American political system can't be
identified as a democracy. And it's very far from Founding Fathers's
It's simply an oligarchy.
Bi-partist system, which doesn't give any hope to "really" change
anything(proof: Low turnout rates for national elections)
Elitism ...
Networks(free-masons, clubs, regional networks, ethnic networks etc.)
A governmental system which "destroys the citizen against the government"
I humbly want to recommend to everybody in this group, to read Wright
Mills's extraordinary book called "Power Elite".
This book, is the "masterpiece" of political science studies in the
domain of "elite theory". It's an academic book, but, everybody
interested in politics can easily read and understand it. You will
feel like reading
a very high quality novel. It's about United States!
I gave my graduate thesis on "political elites". Mills's "work" is so
good that, I decided to not to become an academician, because, I have
nothing to tell more than he told on that book. It gives examples from
his own country, United States, of 1950's, but he's really telling us
Turkey of 2016 :)
In Europe, American Intellectualism is usually underestimated due to
its pragmatist characteristics and lack of theoretical background.
But I know very well that there are very good American intellectuals
with theoretical background(as Wright Mills).
And this list refreshes my hopes for American intellectualism.
And again, my humble opinion as a political scientist is that, United
States needs "theoretical intellectual discussions about its political
system and personal freedoms"! And only intellectual can do it. It's
very important, because the rest of the world also depends on it.
Thank you
Ismail Kizir

@_date: 2016-04-26 03:03:43
@_author: Ismail Kizir 
@_subject: [Cryptography] WhatsApp: Why asymmetric key instead of symmetric 
I am not sure, but as I understand from what I read on Internet,
WhatsApp exchanges asymmetric keys, even when two user are
face-to-face and they scan each others qr-code.
Isn't it a "bad logic"?
When two users are physically together and they can scan each other's
symmetric keys via optic qr-codes, without the risk of compromise, why
they still insist to use asymmetric keys?
For one year, I've been working on a similar project, and I have both
asymmetric key and symmetric key exchange protocols. And I am sure
WhatsApp could(should) do the same thing.
Am I wrong? Or did I misunderstand their key exchange protocols?
Ismail Kizir

@_date: 2016-04-26 09:06:11
@_author: Ismail Kizir 
@_subject: [Cryptography] WhatsApp: Why asymmetric key instead of 
Thank you for your quick Answer Tony,
But I meant, "why not both"?
It's not difficult to design a protocol which also supports pre shared keys.

@_date: 2016-04-28 06:18:00
@_author: Ismail Kizir 
@_subject: [Cryptography] WhatsApp: Why asymmetric key instead of 
I also thought about using curve25519.
I downloaded it. Tested it. It is really simple to use.
But only 256 bits key space??
You are developing a "new" algorithm in 2016; and you are using a
fixed 256 bit key space.
It's surely enough for %99 percent of attackers. But, I am not sure
about resourceful attackers in long term.
Personal privacy is a very important subject.
A lot of people think about criminal cases.
I think about mass surveillance, storage and future decryption.
One day, one of our children will be the president and other one's
will be prime minister. It will be be in 20-30 years later.
I don't want when that day comes, someone resourceful who stored all
"most private" information about our children deciphers all those
information and use it against our children.
Every detail; from the first innocent love declaration to most
intimate secrets are transmitted via messaging  applications nowadays.
Maybe, I am ignorant, or paranoid. Maybe.
But I always prefer using strong symmetrical algorithms with enough
large key space whenever possible.

@_date: 2016-04-29 06:53:57
@_author: Ismail Kizir 
@_subject: [Cryptography] WhatsApp: Why asymmetric key instead of 
I haven't tested Curve 448 yet.
This is one the things I am concerned about.
And NSA itself, proves it. From 128, 256, 512s bits to 2048 ... Now,
they say below 2048 bit is not considered secure. I am using 4096 bits
on my system for asymmetric encryption. But it is really very slow,
and, as you've told, breaking 2048 is just a matter of time.   Above
4096 is not feasible.
I think we all agree RSA served well in its lifetime and it's time to
migrate to another algorithm.
For the moment, I am going to enjoy "abusing" processor power of
client phones and keep using RSA 4096 for asymmetric key operations,
and use 2048 bits PSKs whenever possible.
I don't want to lie to my clients. I am going to tell them all the
risks of using my software without PSKs, and that, even with PSKs
nothing is sure.
Personal privacy is a constitutional right. My goal is just to avoid
mass surveillance and protection of the communication channel. About
the concerns of terrorism or any other illegal activities, I've found
a moderate way: I don't make any encryption and or any special data
wiping on clients phone. If any legal entity has doubts about one of
the users, they can confiscate the phone with an official court order
and access all the data.
On Thu, Apr 28, 2016 at 6:08 PM, Phillip Hallam-Baker

@_date: 2016-04-29 15:41:44
@_author: Ismail Kizir 
@_subject: [Cryptography] WhatsApp: Why asymmetric key instead of 
Look, I never wanted to tell my personal issues here. But after your
"lessons", I guess, it's unavoidable to mention a few things.
I have been the owner of one top global 10,000 sites of internet.
The largest turkish news archive in the world: tumgazeteler.com.
With more than 5 millions of unique visitors per month according to
Google & comScore.
comScore researches showed it was the 5th and 6th most visited news
site of Turkey two consecutive years.
It was a site similar to Google News site.
With a good search engine, web server and all other technologies
developed by myself.
You know what?
I've been accused for every single article on the site.
For more than 6,000,000 of articles.
I've forgotten the number of cases I've been accused.
I've never been condemned.
But going to tribunals every time, was already very annoying.
Then, government started to give monetary sentences. With very stupid reasons.
They sentenced me to pay ~25,000 USD because "I published an article
about the price of cigarette".
It was an article of  National Official News Agency: Anatolian Agency.
And thousands of other news site published that article at the same
But only a few site were condemned to pay administrational monetary
penalty, including me.
After all those cases and finally monetary penalty, I finally
understood they wanted  to destroy me.
But which group? I still don't know.
I tried to be honest and stay away from influence groups.
It didn't work!
Without being part of an influence group,  having an independant
media, my dream, was impossible. Believe me, not just in Turkey, but
everywhere in the world.
Six years ago, I stopped publishing my site. Without any legal reason.
I just wanted to not to be called by the police or the prosecutor
every 15 days.
You know what?
After 6 years, this year, I've been called by the tribunals for 2
different cases.
The ex prime minister's ex consultant, the ex chief of a very
important public financial institution, appealed to high court, and
high court ordered second level court to "judge me again"!
You want the reason they want to judge me again?
This part is really funny!
6 years ago, government published a law.
According to that  law, all media-related cases has been stopped for 3
years. If you don't repeat the same "crime" for 3 years, the case
Second level court, didn't apply that law.
It judged me and obviously I haven't been found guilty. Because, it's
not my article. A national news site has published it. My crawlers
archived it and published on my site! I don't know the person who
charges me. I don't know anything about the article. How may I know?
My crawlers were collecting more than 6000 articles every day!
The high court ordered to judge me again, because, "The second level
court didn't apply the law and "forgave me" :)
Like a joke right?
In fact, it is not "forgiving".
It is shutting up my mouth for at least 3 more years :)
And in the other case, I am charged to "insult" to a judge.
It's also funny!
The article is published by a national newspaper close to current government.
It's about "love affair of one judge with his secretary"! :)
I don't know who that judge is.
I know nothing about the article!
I am already found innocent. As far as I remember, high court
confirmed that decision. But I don't know how, the case is re-opened.
I couldn't learn about the details yet. It's very recent: 27 April. I
just saw on e-government site that the case is re-opened.
Believe me, I have many many stories to tell, about freedom. About
organizations, about groups, about politics.
This year, my old partner came back from France, after many years.
He has been teaching in Sorbonne.
In our first meeting, he asked me:"Why? They obviously annoying you.
You are trying to fight back?"
I really don't know if I am fighting back. I really even don't know
what I am doing wrong.
I just wanted to be independent intellectual. Really. Only this. Nothing more.
I tried to defend freedom, rights; but I wanted to do this in "my own
way", independently.
It didn't work.
I've been "bad" for all political and social groups.
I understood that, the masses, even so-called intellectuals hate the truth.
Nobody wants a mirror. They want Cindirella movies.
They read newspapers from their side, they read  to "learn what they must do".
If they read newspapers from oppositions, they read to learn what to defend!
I haven't mentioned: I wrote articles too. Not more than 40-50. Read
by a lot of people. Usually about international or national politics.
Some of them were very strong.
I have never been charged for my own articles :) It's another interesting point.
About your opinions of "tyrannie", "oppression", "defending by force".
I don't want to "defend someone against another".
I don't want to be for this against that.
I had enough "enemies" I never met.
I am just trying to be "human", and to defend "evebody's rights". Not
specifically against anyone or any group.
I've even created a new symmetric encryption algorithm and opened to public.
Not perfect maybe. But I am trying.

@_date: 2016-05-01 10:58:59
@_author: Ismail Kizir 
@_subject: [Cryptography] WhatsApp, Curve25519 workspace etc. 
I want to state my thought more clearly.
Curve25519 has 2^128 workspace for brute force attacks. Correct me if
I am wrong please.
Also, as far as I remember, -I don't remember where I read-, a
supercomputer today, is able to break 56 bit DES encryption ~400
This is still brute-force.
I am certain, there may be room for eliminating some possibilities, or
even break it completely, as Bill Cox has pointed out.
Moreover, the symmetric keys used are derived from this asymmetric
key, which may be another source of vulnerability and another source
of elimination of possibilities.
Moreover, more important: WhatsApp uses AES 256 in CBC mode, which is
excluded from TLS 1.3 draft. And there are some articles about it:
I want to repeat my question again: Isn't it highly suspicious to take
so many risks, instead of simply using a larger key space?
Curve25519, especially when used in combination with AES CBC, looks
highly suspicious to me.
Ismail Kizir

@_date: 2016-05-03 07:33:00
@_author: Ismail Kizir 
@_subject: [Cryptography] WhatsApp, Curve25519 workspace etc. 
That's the point: I didn't mean, there is any vulnerability in 56 bit
DES encryption.
A supercomputer tries all possibilities and breaks it via brute force
in 399 seconds!
In fact, concentrating solely on brute-force attack scenarios, you
confirm my concerns:
You speak as there is no possibility to reduce workspace, e.g.
via protocol codes, via exif data, via mathematical properties etc.
Especially considering we're talking about 10-20 years future, my
humble opinion, 128 bit workspace is "highly suspicious".
I respect also to your opinion. But that's what I think.
Thank you
Ismail Kizir

@_date: 2016-05-31 14:31:59
@_author: Ismail Kizir 
@_subject: [Cryptography] Wi-fi spyware injection 
Today, 3 Turkish National Police Officers are taken into custody
because for "Injecting malware and or spyware to Turkish National
Police Intelligence IT Systems".
It's interesting.
It seems, they were using Galileo.
Wikileaks has published some e-mails on bargain of price of the
system, ~400,000 USD.
And since there are inner power struggles between groups in police
intelligence service, those crazies uploaded the malware to their own
Then I've read many things about Galileo.
Even their source code has been exposed on GitHub.
But one thing is very dangerous:
They can could inject the malware to any phone via wi-fi hacks:
Does someone knows about this?
Any protection methods etc?
Ismail Kizir

@_date: 2016-11-21 09:04:53
@_author: Ismail Kizir 
@_subject: [Cryptography] RFC for a websocket extension concerning also 
Hello everybody,
I don't know if this may be considered as off-topic.
But it concern a security issue.
So, I wanted to write here before submitting in order to
collaboratively discuss the subject.
We, all have custom protocols for our in-house applications and
servers. So I have.
But I also like standards. Websocket protocol is easily extendible.
WebSockets, described in RFC 6455
( is a robust, extensible
and widely accepted standard.
So, I converted all my existing protocol to work on top of websocket
protocol, as extensions.
But I noticed some unnecessary performance and data overhead with 4
bytes XOR masking value:
Section 5.2 defines the XOR masking and Section 5.3 mandates use of
XOR masking from client to server.
I don't want to discuss here, the reasons for XOR masking from client
to server. They say, with some older proxies or with some malicious
intermediaries, it is possible to realize some attacks.
But, usually, such protocols work on Intranets, not Internet. For
example, all my BigTable server impelentation communication is on my
private Internet. I am sure of it when I connect it. It is my own
private intranet and I know absolutely there is not any kind of proxy
I am sure many other developers will think the same: Why paying the
cost of extra 4 bytes data overhead and extra cpu cycles to
mask/unmask data?
So, I created a new websocket extension:
On handshake, I sent one extra header from client to server:
Sec-WebSocket-Extensions: NoXorMask
And server checks the connection and decides what to do: If it is an
internet ip(which, in my case is impossible, since intranet is
protected by a firewall),  it accepts the offer sends back:
Sec-WebSocket-Extensions: NoXorMask
Then, the communication continues without mask bits set. No
unnecessary XOR mask data overhead and no wasted CPU cycles.
I want to submit this is an RFC proposal.
But the main RFC document 6455 mandates the use of XOR masking in Section 5.3.
I haven't a previous experience in writing RFC submissions.
Such a contradiction with main standart may be allowed in extensions
written for that RFC?
Is it a good idea to submit this extension as an RFC?
May there be any security holes that I couldn't realize?
Any comment, help, suggestion, English grammar/sentence
corrections/reorganisations are wellcome :)
Ismail Kizir

@_date: 2016-11-21 15:56:40
@_author: Ismail Kizir 
@_subject: [Cryptography] RFC proposal draft text 
Below, I wrote proposal draft text about the subject I've previously mentioned.
My English is poor.
And I don't know much about RFC submission style.
I will appreciate any comments, critics, new ideas and help.
I will continously update this text in my blog until I submit it to
IETF at: Thanks in advance
Ismail Kizir

@_date: 2016-11-23 07:23:38
@_author: Ismail Kizir 
@_subject: [Cryptography] RFC for a websocket extension concerning also 
Hello Bertrand,
Thank you for your contribution.
The link I am reading the copy of RFC 6455 is:
At the end of page 31, it states:
"5.3.  Client-to-Server Masking
   A masked frame MUST have the field frame-masked set to 1, as defined
   in Section 5.2."
And at page 28, it states:
"... Mask: 1 bit
      Defines whether the "Payload data" is masked.  If set to 1, a
      masking key is present in masking-key, and this is used to unmask
      the "Payload data" as per Section 5.3.  All frames sent from
      client to server have this bit set to 1."
At page 50, Section 10.3 states the reason of masking and related attacks
One thing is interesting: I am nearly sure that I've read a more rigid
version of websocket RFC stating: "When server receives a non-masked
frame, it must immediately close the connection etc.etc."
I am nearly sure, because, I took that line as a comment in my code. I
was closing connection as per RFC.
And then, I've decided to write this extension.
But now, in current RFC, I can't see such a rigid statement. Maybe, it
was on drafts. If true, this may also be the proof of author's
intention to leave room for extensions like the one I am proposing.
On Wed, Nov 23, 2016 at 6:52 AM, Bertrand Mollinier Toublet

@_date: 2017-12-29 03:53:34
@_author: Ismail Kizir 
@_subject: [Cryptography] Fast handling of IP Address changes for HTTPS 
Hello Paul,
I don't know much about your case.
But, if your site will be used by phone application, you can embed
X25519 keys and create your own DH Key exchange.
This will also prevent any kind of MITM attack.
I am actually working on a similar solution for my messenger application.
Me too, I am using LetsEncrypt certificates.
Previously, I have been using 4096 bit embedded RSA keys but X25519
are simpler and don't require additional binary modules. A simple
plain javascript solves the problem.
I am combining X25519 with my own symmetric encryption, but there are
much easier solutions like:
You don't need to write much code. There are libraries for both client
& server sides.
I hope it helps.
Ismail Kizir

@_date: 2017-12-30 21:18:28
@_author: Ismail Kizir 
@_subject: [Cryptography] Hashgraph 
I wish a happy new year for everyone.
And I want to ask:
I haven't read anyone mentioning about Hashgraph on the list:
It's a very fast and promising technology. Better than blockchain, it seems.
The only weakness, as far as  I could understand so far, is that they
need the consensus of 2/3 of the nodes.
Ismail Kizir

@_date: 2017-11-08 01:21:47
@_author: Ismail Kizir 
@_subject: [Cryptography] One Bitcoin Transaction Now Uses as Much Energy 
For years, I've been following bitcoin and discussions on this group.
I think, bitcoin, has a very good goal: "Decentralisation of money".
(and every kind of trust transaction for blockchain in general)
But, with this level of energy consumption, both blockchain and bitcoin,
seem to be impractical to fulfill goals.
Defending any kind of intermediaries like banks, central agencies or
brokers against these
critics, is, unfortunately, admitting the failure of bitcoin:It's
simply against its reason of existance!
I think, current blockchain technology may be called trojan horse of
the system. Because, it promotes itself as liberator and
decentralizer; but in truth, because of some "minor" practical reasons
like incredible high energy consumption, the only practical way we
will have to use central systems: Traditional intermediaries like
banks, brokers etc.
We need another technology to achieve those goals.
Ismail Kizir

@_date: 2017-11-08 05:33:05
@_author: Ismail Kizir 
@_subject: [Cryptography] One Bitcoin Transaction Now Uses as Much Energy 
I think, I must clarify what I mean by decentralization after your comment:
By decentralization, I mean, "not being in control of any authority".
Cash, is a strictly centralized payment system.
Cash is solely created by national(USA, Turkey etc.) or
supra-national(European Union) authorities.
Credits are created by banks (more decentralized, but still not in
individual basis)
Here, our discussion may go much deeper:
Because, we must try to understand
  * Why there is a need for a totally decentralized money.
  * What is money in reality?
  * Must money based on a real value(gold, infrastructure)
  * Or money is just a psychological estimation?(in god/gun we trust?)
Lots of books can be written about it.
We can discuss all those later, if necessary.
But I want repeat what I wrote in my previous post and tell my
solution for the problem:
Bitcoin is a good starting point. But it is a "trojan horse".
Because, it promises us a money which is not under control of any
authority, but, in fact, it will just remove governments from the game
and will help banks to replace governments. It just helps to increase
number of authorities.
The most important design deficiency of Bitcoin is not being based on
a real value.
I think a cryptocurrency must:
  * Not be under control of any authority than individuals
  * Be based on a real value(gold, infrastructure)
  * Be based easy to apply, feasible and energy efficient technology
I think a separate network infrastructure may combine 2 of these requirements.
Being part of this new, independent network must be the "mining part"
of that cryptocurrency: If someone installs some fiber optic cables
for example, he/she will have win some money in the system.
System must also have its uncontrollable & uncensored DNS system.
(Likewise, if someone operates DNS servers for the system, it will
win(mine) some money)
Ismail Kizir

@_date: 2017-11-25 15:46:21
@_author: Ismail Kizir 
@_subject: [Cryptography] Is ASN.1 still the thing? 
I've been following this discussion for a while.
For years, I've used every solution mentioned here:
I've used JSON, protobuf, msgpack, my own string encodings ...
For a long time, I thought that protobuf was the best solution,
especially, for multi-language projects, like mines, with C backend,
javascript frontend.
But on C side, protobuf is not elegant.
I hate C++.
15 years ago, I was writing all my projects with C++ but for debugging
complexities and readibility, I've migrated to C.
I am writing object oriented C via my own typedef's, old style, very
long, informative names and code is crystal clear for me.
The same thing is valid for protobuf.
I thought it could decrease code readability, but, for my case, it increased!
First, you must use different tools and external libraries. It adds complexity.
For simple structures, it is good.
But for nested, multi level structures it's a pain in the .ss
There is no(wasn't) good protobuf parser for C for nested/iterated structures
Original protobuf library was in C++
After, so many trials, I've decided to develop my simple protocol and
data encoding.
In the heart, there is one function, also used by protobuf:
VarInt and VarUInt encoding.
VarInt encoding is based on VarUInt encoding.
VarUInt encoding is simple:
Every byte is in range 0..127 if highest bit (128) is set, then a new
byte must follow.
The whole javascript code, is very easy to implement. I can even send
you all here:
Here is the whole code including test function, in javascript.
C counterpart is not much different.
It lacks floating point support for the moment. I don't use floating
point in my projects.
It's in public domain if you want to use.
Simple is elegant!
Ismail Kizir
var TMemBuf = function(InitialSizeOrObj)
  if (typeof(InitialSizeOrObj) === "number")
  {
    this.Buf = new Uint8Array(InitialSizeOrObj);
    // Our writing position on the buffer
    // This is also the actual size of written data to buffer so far
    this.WPos = 0;
  }
  else if (InitialSizeOrObj instanceof Uint8Array)
  {
    this.Buf = InitialSizeOrObj;
    // Our writing position on the buffer
    // This is also the actual size of written data to buffer so far
    this.WPos = InitialSizeOrObj.length;
  }
  this.RPos = 0; // Our reading position on the buffer
TMemBuf.prototype.SetReadingPos = function(N)
  this.RPos = N;
 * Resize resizes the buffer to hold at least EnoughForBytes
 *  EnoughFor There will be least EnoughFor bytes of space on return
 *   0 on error, non-zero if succesful
 */
TMemBuf.prototype.Resize = function(EnoughFor)
  var NewSize = this.Buf.length << 1;
  if (NewSize < EnoughFor)
    NewSize = EnoughFor + 128;
  var NewBuf = new Uint8Array(NewSize);
  NewBuf.set(this.Buf, 0); // Copy oldbuf to newbuf from pos 0
  this.Buf = NewBuf;
 * MakeRoomFor function ensures that we can write HowMany more bytes
from current buffer position, without resizing it
 *  HowMany : HowMany more bytes from current buffer position,
without resizing it
 */
TMemBuf.prototype.MakeRoomFor = function(HowMany)
  if (this.WPos + HowMany > this.Buf.length)
    this.Resize(this.Buf.length + HowMany);
 * WriteByte writes a single byte to our buffer from current writing position
 *  B {number [0..255]}
 *  {undefined}
 */
TMemBuf.prototype.WriteByte = function(B) {
  this.MakeRoomFor(1);
  this.Buf[this.WPos++] = B;
TMemBuf.prototype.ReadByte = function() {
  return this.Buf[this.RPos++];
 * WriteBuf writes contents of Uint8Arr to our buffer from current
writing position
 *  {type} Uint8Arr Array to be written to our buffer from
current position
 *  {len} Optional length to write. If omitted, Uint8Arr.length
will be used
 *  {undefined}
 */
TMemBuf.prototype.WriteBuf = function(Uint8Arr, Len)
  if (Len)
  {
    this.MakeRoomFor(Len);
    this.Buf.set(Uint8Arr.slice(0, Len), this.WPos); // Copy oldbuf to
newbuf from current writing pos
    this.WPos += Len;
  }
  else {
    this.MakeRoomFor(Uint8Arr.length);
    this.Buf.set(Uint8Arr, this.WPos); // Copy oldbuf to newbuf from
current writing pos
    this.WPos += Uint8Arr.length;
  }
 * WriteBufAndItsLen writes :
 *   1. The length of array as a 32 bit VarInt from current writing position
 *   2. Contents of Uint8Arr to our buffer just next to VarInt32 encoded length
 *  {Uint8Arr} Uint8Arr Array to be written to our buffer from
current position
 *  {number} Optional number of bytes to write. If not set, or
set to 0, array length bytes will be copied
 *  {undefined}
 */
TMemBuf.prototype.WriteBufAndItsLen = function(Uint8Arr, Len)
  var L = (Len ? Len : Uint8Arr.length);
  this.WriteVarUInt32(L);
  this.WriteBuf(Uint8Arr, L);
TMemBuf.prototype.WriteMemBuf = function(mb)
  this.WriteBuf(mb.GetBuf(), mb.WPos);
TMemBuf.prototype.WriteMemBufAndItsLen = function(mb)
  this.WriteBufAndItsLen(mb.Buf, mb.WPos);
 * ReadBufAndItsLen reads a buffer previously written by WriteBufAndItsLen
 * It returns a Uint8Array
 *  {type} mb
 *  A new(sliced from this original array) Uint8Array containing data
 */
TMemBuf.prototype.ReadBuf = function()
  var L = this.ReadVarUInt32(), Rv=null;
  if (L && this.RPos + L <= this.WPos)
  {
    Rv = this.Buf.slice(this.RPos, this.RPos + L);
    this.RPos += L;
  }
  return Rv;
 * ReadMemBuf reads a TMemBuf previously written by WriteBufAndItsLen
 *  {type} mb
 *  A new(sliced from this original array) TMemBuf containing
data or null
 */
TMemBuf.prototype.ReadMemBuf = function()
  var N = this.ReadBuf();
  if (N)
    return new TMemBuf(N);
  return null;
TMemBuf.prototype.Clear = function() { this.WPos = 0; };
 * WriteVarUInt32 encodes a 32 bit unsigned integer value in a
portable variable length buffer
 * The method of encoding is MOST SIGNIFICANT BIT encoding
 * Don't confuse this with most significant byte encoding.
 * Simply, we use only 7 bit of every byte.
 * We set the most significant bit to indicate there is more data in the buffer
 *  Val Value to be Encoded. Since we use bit shifting, it may
only be a 32 bit unsigned int.
 */
TMemBuf.prototype.WriteVarUInt32 = function(Val)
  var V = Val;
  this.MakeRoomFor(6); // We can write max. 6 chars
  while (V > 127)
  {
    // By OR'in with 128, we indicate there is more bytes to read
    this.Buf[this.WPos++] = (V & 127) | 128;
    V >>>= 7;
  }
  this.Buf[this.WPos++] = V;
TMemBuf.prototype.CanRead = function(NumBytes)
  return ((this.RPos + NumBytes) <= this.WPos);
TMemBuf.prototype.ReadVarUInt32 = function()
  var R=0, ShiftCount=0, B;
  while (this.RPos < this.WPos)
  {
    B = this.Buf[this.RPos++];
    R |= (B & 127) << ShiftCount;
    if ((B & 128) === 0)
      break;
    ShiftCount += 7;
  }
  return R;
 * WriteVarUInt64 encodes a 64 bit unsigned integer value in a
portable variable length buffer
 * The method of encoding is MOST SIGNIFICANT BIT encoding
 * Don't confuse this with most significant byte encoding.
 * Simply, we use only 7 bit of every byte.
 * We set the most significant bit to indicate there is more data in the buffer
 *  Val Value to be Encoded.
 */
TMemBuf.prototype.WriteVarUInt64 = function(Val)
  var V = Val;
  this.MakeRoomFor(11); // We can write max. 11 chars
  while (V > 127)
  {
    // By OR'in with 128, we indicate there is more bytes to read
    this.Buf[this.WPos++] = 128 + (V % 128);
    V = V / 128;
  }
  this.Buf[this.WPos++] = V;
TMemBuf.prototype.ReadVarUInt64 = function()
  var R=0, Multiplier=1, B;
  while (this.RPos < this.WPos)
  {
    B = this.Buf[this.RPos++];
    R += (B & 127) * Multiplier;
    if ((B & 128) === 0)
      break;
    Multiplier *= 128;
  }
  return R;
 * WriteVarInt32 encodes a signed integer value of any size in a
portable variable length buffer
 * We write the first byte as a sign byte. If it's 1, it means the
following unsigned varint encoded number will be negative. Else
 *  Val Value to be Encoded. Since we use bit shifting, it may
only be a 32 bit unsigned int.
 */
TMemBuf.prototype.WriteVarInt64 = function(Val)
  if (Val < 0)
  {
    this.WriteByte(1);
    this.WriteVarUInt64(Val * -1);
  }
  else {
    this.WriteByte(0);
    this.WriteVarUInt64(Val);
  }
TMemBuf.prototype.ReadVarInt64 = function()
  var Sign=this.ReadByte();
  var N = this.ReadVarUInt64();
  console.log("ReadVarInt64: N="+N);
  return (Sign ? -1*N : N);
 * WriteStr encodes a javascript string as a UTF-8 encoded Uint8Array
and writes this array to our buffer
 *  {type} sDOMStr Any javascript string
 *  NONE
 */
 TMemBuf.prototype.WriteStr = function(sDOMStr)
  this.WriteBuf(StrToUTF8Arr(sDOMStr));
 * WriteStr encodes a javascript string as a UTF-8 encoded Uint8Array and :
 *   1. UTF8 encoded length of this string as a 32bit VarInt
 *   2. utf-8 encoded string as uint8array
 *  {type} sDOMStr Any javascript string
 *  NONE
 */
TMemBuf.prototype.WriteStr = function(sDOMStr)
  this.WriteBufAndItsLen(StrToUTF8Arr(sDOMStr));
 * ReadStr reads a string encoded with WriteStr function
 *   1. It first reads VarInt length of encoded binary data
 *   2. Then, it converts this utf8 encoded data to a javascript dom string
 *  DOM string or NULL if data is encoded incorrectly
 */
TMemBuf.prototype.ReadStr = function()
  var L = this.ReadVarUInt32();
  if (L && this.RPos + L <= this.WPos)
  {
    var Str = UTF8ArrToStrWithStartPosEndPos(this.Buf, this.RPos,
this.RPos + L);
    this.RPos += L;
    return Str;
  }
  return "";
 * GetBuf returns a view of the buffer as uint8array having length
exactly equal to WPos
 * Before this operation, this.WPos and Buf.length are usually different
 * But this function, returns a buffer containing only the data we've
written to our buffer so far
 *  {unresolved}
 */
TMemBuf.prototype.GetBuf = function()
  return this.Buf.subarray(0, this.WPos);
function TestMemBuf()
  var mb = new TMemBuf(8);
  var FirstNum = 128000, SecondNum=8989, ThirdNum=200000000991,
S1=-128, S2=-200000000991, S3=98989;
  var Str1 = "Selamlar İsmail KİZİR. Nasılsın?";
  var N;
  mb.WriteVarUInt32(FirstNum);
  mb.WriteVarUInt64(SecondNum);
  mb.WriteStr(Str1);
  mb.WriteVarUInt64(ThirdNum);
  mb.WriteVarInt64(S1);
  mb.WriteVarInt64(S2);
  mb.WriteVarInt64(S3);
  N = mb.ReadVarUInt32();
  if (N === FirstNum)
    console.log(FirstNum+" successfully read from MemBuf!");
  else console.log("ERROR: "+FirstNum+" COULD NOT BE READ! We got: "+N);
  if (mb.ReadVarUInt64() === SecondNum)
    console.log(SecondNum+" successfully read from MemBuf!");
  else console.log("ERROR: "+SecondNum+" COULD NOT BE READ!");
  var S = mb.ReadStr();
  if (S === Str1)
    console.log(Str1+" successfully read from MemBuf!");
  else console.log("ERROR: "+Str1+" COULD NOT BE READ! We Got: "+S);
  if (mb.ReadVarUInt64() === ThirdNum)
    console.log(ThirdNum+" successfully read from MemBuf!");
  else console.log("ERROR: "+ThirdNum+" COULD NOT BE READ!");
  if (mb.ReadVarInt64() === S1)
    console.log(S1+" successfully read from MemBuf!");
  else console.log("ERROR: "+S1+" COULD NOT BE READ!");
  if (mb.ReadVarInt64() === S2)
    console.log(S2+" successfully read from MemBuf!");
  else console.log("ERROR: "+S2+" COULD NOT BE READ!");
  if (mb.ReadVarInt64() === S3)
    console.log(S3+" successfully read from MemBuf!");
  else console.log("ERROR: "+S3+" COULD NOT BE READ!");

@_date: 2018-08-18 15:52:50
@_author: Ismail Kizir 
@_subject: [Cryptography] Rescuing Encrypt-then-Sig 
Please take a look on my Hohha Encryption V2 Ray.
I am doing exactly what you're mentioning. And even more:
I also encrypt verification data and even nonce values with the same key.
Only one function call  is enough to encrypt&sign.
And one function for decrypt&verify.
I keep a unique Nonce1 value in the key itself.
And I encrypt individual Nonce values & veritifcation data(signature)
with this key&Nonce1.
It also has its own padding mechanism.
As I told you previously.
I am not good in cryptoanalysing.
But I worked hard to put defense mechanisms against every kind of
attack I could imagine myself.
I hope, with your support, Hohha, can be the best open-sourced
symmetric algorithm.
Patent free. Dual licence. Reasonably fast.
I don't expect anything.
Just take a look.
Ismail Kizir

@_date: 2018-08-20 15:26:02
@_author: Ismail Kizir 
@_subject: [Cryptography] Rescuing Encrypt-then-Sig 
My method is even easier & faster.
Because, the encryption & signing is nearly the same thing.
I just keep 16 byte state of some encryption variables as signature.
At the end of decryption, I just compare the state of same variables
with previously saved states during encryption.
As I told:
I invite everybody to take a look on my symmetric encryption algorithm at:
Ismail Kizir

@_date: 2018-08-28 23:45:17
@_author: Ismail Kizir 
@_subject: [Cryptography] Is "perfect forward secrecy" the biggest fraud of 
IBM warns of instant breaking of encryption by quantum computers:
'Move your data today':
I think that the concept of "perfect forward secrecy" used in Signal
based applications forced us to rely solely on asymmetric algorithms,
which, will reveal all our secrecy in a few years!
Am I wrong?
Because, the designers of Signal and similar protocols knew that
quantum computer revolution was already imminent!
Ismail Kizir

@_date: 2018-08-30 21:57:17
@_author: Ismail Kizir 
@_subject: [Cryptography] Is "perfect forward secrecy" the biggest fraud 
I am not targeting here the real technical meanimg of forward secrecy
nor perfect forward secrecy..
Rather, I am offending them as "marketing slogans".
Masses don't understand real meaning of forward secrecy or perfect
forward secrecy.
They rather  think:
"OK! They use ephemeral keys. And ephemeral keys are deleted just
after negotiation and I am safe".
Or even worse: An ordinary computer user just thinks: "OK. I've read
on techno-page of my newspaper(which is expecting a big ad revenue of
Facebook of course) that WhatsApp uses Signal, which is considered as
secure by professionals. My messages are encrypted and I am safe".
I am nearly sure that more than 99% of  WhatsApp or Signal users don't
know that all their conversations may(will) be decrypted in next 5-10
years, despite the fact that all security professional are aware of
this fact.
Nobody told them this truth. But all media, made publicity of
"end-to-end encryption" with a lot of technical terms masses don't
A false feeling of security is much more dangerous than lack of security.
If people is aware of the fact that all their
WhatsApp/Signal/Telegram,FB, whatever... messages will be decrypted in
very near future, I believe they prefer to be much more prudent!
They don't!
But, Signal Protocol has no Pre-shared symmetric key  support either.
As I already wrote several times here: PSK is the preferred method of
armies. And they are the creator of encryption.
About half of my chat contacts, are my real life friends and I have
possibility to see them physically in real life.
A simple face-to-face symmetric key exchange(by optical ways, via a qr
code, barcode etc.) would be enough in applications, if it was defined
in the protocol!
Consequently, Signal, enforces everybody to use weaker(asymmetric)
encryption where stronger(symmetric) encryption can be used!
And everybody knows that asymmetric encryption will surely be broken!
And it has been so popular nearly every instant messenger application
just adopts it.
This is horrible: This is a long term blackmail/profiling data in
mid-term! All our children are using messaging applications. And when
they will be in political/administrational positions in any country
... I am sure you can imagine the possibilities.
There are more things I can write about Signal protocol and messaging
But I just wanted to answer your questions in order to clarify why I
targeted forward secrecy.
Ismail Kizir

@_date: 2018-12-04 03:22:26
@_author: Ismail Kizir 
@_subject: [Cryptography] Hohha quantum resistant end-to-end encryption 
PSK or DH doesn't matter for groups.
Group messages are encrypted and sent individually to every member,
with previously established symmetric key.
It may be a result of PSK or DH.
If no symmetric key has been set between two users, then, a new DH key
exchange starts.
The fact that a user joins to a group or a user leaves a group hasn't
any side effect on security, since, there isn't any common encryption
key for a group.
The side effect of this security gain, is the cpu and bandwidth
overhead, as you mentioned: If a user is sending a message to a group
of 100 persons, he must encrypt 100 times that message with different
Group attachments have a separate key and nonce: When Alice sends a
group message to Bob, group message text and group message attachment
key is encrypted with symmetric key and then sent to Bob.
When Bob receives that group message, he decrypts both message text
and attachment key with their actual common symmetric key, then
downloads the attachment and then decrypts the attachment with
attachment key.
Consequently, attachments are encrypted only once.
I think group message encryption method is enough secure and I don't
want to make any modification about this part.
For very large groups, in future, for our messenger, we may  implement
 one-to-many plaintext message concept called "Channels". Channel
messages will not be encrypted.
After all discussions on this group, I've been convinced to add
forward secrecy to protocol.
I've sent privately to some members a week ago, but I didn't want to
send to group before having updated Whitepaper accordingly.
Protocol now imposes HKDF  described in RFC 5869
And it provides forward secrecy.
I updated Whitepaper accordingly and gave credit to group
members(including you), who convinced me to add forward secrecy to
Thanks again to all group members who contributed to forward secrecy discussions
Ismail Kizir

@_date: 2018-12-05 13:51:32
@_author: Ismail Kizir 
@_subject: [Cryptography] Hohha quantum resistant end-to-end encryption 
Apparently, you have a P2P messenger on your mind and you're forcing
my project to that way.
MITM countermeasure works: The user can see anytime *permanently* if
there had been an MITM attack or not!
The user is warned every time a key exchange happens.
And yes! It will use dedicated servers. It will not support only PSK.
It will also support DH as mentioned.
And Hohha Dynamic XOR algorithm will stay as it is. It will be tested.
The default encryption mode is hybrid  Hohha Dynamic XOR + D.J.
Bernstein's XSalsa20 + Poly1305.
I haven't anything to discuss anymore about those 5 points you mentioned.
I thank you and all other group members for their contributions
Ismail Kizir

@_date: 2018-02-12 22:23:50
@_author: Ismail Kizir 
@_subject: [Cryptography] Proof of Work is the worst way to do a BlockChain 
You tell that you trust in State and Banks. And you tell that there
are good parts of it.
Of course, there are good parts of State. And we need it.
But, let me emphasize some facts about State:
Modern Democracies are based on Montesqieue's "Separation of powers" ideas:
The base of modern state is, simply "lack of trust".
That's why, we have separation of powers.
That's why, for example, in Turkey, actually, we are converting our
parlementary system, which is more based on trust(soft separation of
powers) to  a Presidential system, as in United States, which have a
more rigid separation of powers(Legislation, Execution, Jurisdiction).
Consequently, even actual modern state concept is based on "untrust".
The State doesn't trust itself. How can we trust it?
Even though it was a lie, last 30 years Western World Slogan is
minimizing the State! (But they did the same mistake i am trying to
elaborate and made peoples slaves of global finance capital and
empowered States physically, more police and security officers, more
cameras, larger armies, more weapons and wars! But this is another
I think, decentralized monetary system is the natural consequence of
history and logic.
But here, the biggest danger is to be trapped by global
finance-captial instead of States.
I dream of a world where
  No power, State or Finance capital can use my own money against me.
  No power can control how i will spend my money.
  No power can confiscate my money.
  No power can enslave me with my own money.
Now, we have an opportunity for, at least, eliminating all kinds of
This is what I think.
Ismail Kizir

@_date: 2018-02-14 01:40:37
@_author: Ismail Kizir 
@_subject: [Cryptography] Proof of Work is the worst way to do a BlockChain 
It's a really interesting story and I am waiting for your paper
without patience my friend.
And I promise I will visit you in your office in Istanbul :)
Meanwhile, I just want to give another interesting detail I've read in
Wikipedia several years ago:
Did you know that in years 1900s, nearly whole New York Taxi Fleet was
consisted of electric cars?
"Something" happened and for two decades, we polluted nature and we made wars!
And today, we are talking about electric cars as it's new, brilliant
idea and technology!!
Believe me: The discussion we're actually making here is the same
thing, even much more important than the example of electric cars!
I am addressing here to all members of this group:
I know that you're all distinguished professionals from many different
countries. Elites of your nations.
Let's not repeat history again.
This time, let's try to protect rights of ordinary American, Frenchs,
Turkish, Brit etc., on their behalf.
Ismail Kizir

@_date: 2018-01-01 21:23:36
@_author: Ismail Kizir 
@_subject: [Cryptography] Hashgraph 
You're right Paul.
The patent is a very boring issue.
They ask to download their Java SDK and they want to "discuss the
pricing privately".
On Mon, Jan 1, 2018 at 7:44 PM, Phillip Hallam-Baker
About the "consensus of 2/3", I mean, they can provide the security up
to 1/3 malicious nodes.
in this specific case; they talk about quantity of coins)
"... The system will be secure if no attacker can obtain 1/3 of the
total StakeCoin owned by all the participating members put together.
The ledger swirld will continue to function as long as 2/3 of the
StakeCoin is owned by members who participate and are honest."
I watched a video of their creators on youtube.
They claim that: "By having 1/3 malicious nodes, anyone can corrupt
any system, including Blockchain" but, they didn't give any reference
for their claims.
I am not advocating them. I just wanted to learn the ideas of group
members about that technology.
I think that, Blockchain was a good start, but I consider it as a
"Trojan horse of the banking system".
Because of its need of very high resources(both computational power,
storage and network), Blockchain will condemn us to central
authorities and this is contradictory to its reason of creation.
That's why, I am excited about "more democratic", "more decentralized"
As far as I understand, at least for the moment, Hashgraph can't give
us what it is promising to give. (Patent issue and (maybe also)
reliability issue).
Ismail Kizir

@_date: 2018-01-04 23:02:35
@_author: Ismail Kizir 
@_subject: [Cryptography] Hashgraph 
It "seems" to work.
But, transaction times are horribly slow and time consuming.
There are other peoples, who have more knowledge about Blockchain
But as far as I know, one bitcoin transaction may be completed in HOURS!!
It need lots of CPU power and storage requirement.
The only way to keep using Blockchain technology as a monetary system
will be using "Central authorities"!
Our transactions will be kept on those authorities and only
transactions between those authorities will be logged on "more central
and probably private" blockchain network.
So, blockchain doesn't work as "it promised us to work" on its creation.
It doesn't give us freedom of transaction "without intermediaries".
With actual monetary system, you need governments and banks.
With Bitcoin, you still need some authorities:
 1. You will need banks. That's sure! They will probably call them
with different names. But they will be banks!
 2. Governments want also take their share from the pie. And they will
probably take it.
There have been a struggle for a very long time between governments
and finance capital; for centuries:
  "Who will pass behind ordinary people and exploit it?"
With current situation, Bitcoin is the best weapon of International
finance-capital against governments in history.
With current Blockchain technology, we will be slaves of banks and
International finance-capital and governments will be more weak!
As ordinary people, in actual situation, thanks to Blockchain
technology, we are just pawns and slaves of this war:
We're just helping our future "master" who will enslave us!
What we need and want, as ordinary people, is, not to need any
intermediary nor any central authority!
To finalize:
Current blockchain technology and Bitcoin works!
But it works "only" on behalf on International finance capital!
Not for us! Not even for our governments!
Bitcoin is the biggest trojan horse ever seen during world history!
Ismail Kizir

@_date: 2018-11-15 16:10:13
@_author: Ismail Kizir 
@_subject: [Cryptography] Hohha quantum resistant end-to-end encryption 
Hohha Protocol is a quantum safe communication protocol.
This is the techinal whitepaper draft of our Hohha Messenger which
we'll publish soon with a MIT Licence.
Any contribution and or comment will be appreciated.
Link is a sharable link of a Google Docs document.

@_date: 2018-11-24 01:34:59
@_author: Ismail Kizir 
@_subject: [Cryptography] Hohha Protocol : 1. Key renewal review 
Dear Colleagues,
When I've sent here Hohha Protocol Draft, was to find the best
protocol with your helps.
And I am glad to see that it works.
I thank you everybody who cared and gave new ideas.
Including Peter.
Peter: If you tell what you want to tell in a more professional
manner, you can be very useful for me.
It will be an open-sourced project. So, it will be useful for everybody.
I am not a cryptologist. But I am an experienced programmer. And I am
trying to implement every good idea immediately.
I have no complexes.
If there is a better idea, I want to implement. And I will also be
glad to refer to your names.
My aim, is to create the best messenger I can.
So, let's go step by step.
When I read critics, I decided to find out the easiest and best way
for key renewal.
I wanted to start a new thread specifically about this subject.
When we find the best solution, we can pass to next issue.
I didn't want to use key derivation methods in previous drafts.
Because, it is deterministic.
But, "forward secrecy" has a magical effect on crypto world.
And my very simple and raw method has been criticized much.
So, I decided to replace key renewal with a deterministic method.
I thought, the following method may be a good idea.
I also shared it privately with Ersin, yesterday, when I read his messages.
During optical key exchange or DH key exchange, I want to create two
keys, instead of one!
K1 and K2
When both parties have K1 and K2, they will not use directly as they are.
Every time they need common shared secret K:
They will first calculate which week of year we're in(Greenwich time)
Then, they append 4 digit year
For example, we are actually week  of 2018
We will obtain 472018
And then, we  append K2 at the end of this buffer.
Then, take SHA512 hash of resulting buffer.
Then xor first 32 bytes half of resulting sha512 with last 32 bytes.
for (unsigned t=0; t<32; t++)
  sha512res[t] ^=  sha512res[t+32];
then, they will xor first 32 bytes of sha512res with K1 to obtain
actual 32 bytes shared key
for (t=0; t<32; t++)
  ActualSharedSecret[t] =  sha512res[t] ^ K1[t];
This method doesn't require key renewal.
And it also provides forward secrecy.
What do you think?
Is it a reliable, acceptable solution?
I would like to know your comments.
Ismail Kizir

@_date: 2018-11-25 18:08:51
@_author: Ismail Kizir 
@_subject: [Cryptography] Hohha Protocol : 1. Key renewal review 
If an attacker obtains somehow you initial raw key material and if it
records whole communication, it can also decrypt all of your messages.
What you are suggesting is just a more complicated and less secure
method of what I am suggesting.
Am I wrong?
Or am I missing something?
Ismail Kizir

@_date: 2018-11-25 18:52:04
@_author: Ismail Kizir 
@_subject: [Cryptography] Hohha Protocol : 1. Key renewal review 
Yes Jerry.
You're right.
If we assume that the raw key material has been compromised, my method
doesn't provide forward secrecy.
But I think, it hides well raw key material.
Even one of temporary keys has been compromised, they can't decrypt
past nor future communications nor raw key material.
And you are also right: I can use day number instead of week number.
But I still don't see a better method better than the one I am
suggesting, for the moment.
It doesn't provide forward secrecy.
If initial key material has been compromised, whole communication can
be decrypted.
You may also be right. It can also be called doubling the key size and
then reducing it with a KDF to half size again.
But it can also be considered as using 2 different keys in order to
derive temporary keys.
The point here:
I am using two distinct and hidden 256 bits in order to derive temporary keys.
I understand here the concerns about forward secrecy:
In a military grade security, forward secrecy may be vital:
A soldier captured with his phone may be a huge security leak by
letting enemy to decrypt whole communication.
I don't want to create a military grade messenger nor to protect criminals.
If the phone is obtained somehow, all communication can be seen.
My aim is to try to create a messenger for everybody, which is secure
for "mass surveillance".
If security services or legal authorities target someone specifically,
I never want to put obstacles for them.
I am just trying to play on the legal side:
Protecting the communication channel.
Putting as much solid mechanisms as possible for mass surveillance.
Simply, protecting constitutional rights for the privacy of
communication, as described in article 22 our(Turkish) Constitution.
I am also trying to protect curious government agencies from
themselves, as, Turkish Penal Code Article number 132 specifically
describes crime of violation of this right, by a punishment of up to 3
years in jail!
Let's think about my project again:
1. Is my method enough to provide my users what I am promising?
2. Do I really need forward secrecy?
3. Can someone here describe me a better method, which is not too much
complicated, to provide  forward secrecy?
    I am open to every suggestion. But I haven't seen here, anyone,
who could explicitly provide us a method, which is not possible to
reveal whole communication when initial keys have been compromised.
Note that, my philosophy is also based on using PSK whenever possible.
Ismail Kizir

@_date: 2018-09-03 00:45:11
@_author: Ismail Kizir 
@_subject: [Cryptography] Is "perfect forward secrecy" the biggest fraud 
Thank you for your good question Ersin.
Our job, is not chasing after conspiracy theories.
And we must prove everything we tell.
So, it's better to speak with language of mathematics. So, I prefer
the word "probability" :)
1. As everybody knows: Symmetric encryption is "enormously"(sometimes
even 2^128 times or more!) harder to break than asymmetric encryption.
2. It's "possible" that WhatsApp, Signal, Facebook and others are
"actually" reading all our messages by MITM attack.
Signal protocol's threat model is based on "external attackers".
Nothing prevents them from making MITM attacks themselves.
I must also underline that without external certificates(trusted third
part involvement), OR PSK usage, "insider MITM attacks" are always
possible for every messaging application!
And there is a method for the end user to understand(not to prevent!!)
there had been an MITM attack, by checking something like public key
signatures etc. But it's not automatically enabled either!
3. I can't tell exactly if they do such attacks or not.
But one thing is sure: "It is possible for Facebook, WhatsApp, Signal
etc. to read our messages whenever they wish"!
There others who share my opinion, including MIT academicians and students.
Here is a Whatsapp security analysis report from MIT for example:
4. PSK is also the  "unique definitive solution" for "insider MITM attacks" :)
Because, in the case third parties are involved for certificate and/or
identity verification, attack surface will grow up. And we'll have to
suspect of other attack types.
I am not claiming anything.
I am just enumerating which attacks could be avoided if PSK option was
available :)
Ismail Kizir

@_date: 2019-03-24 21:00:10
@_author: Ismail Kizir 
@_subject: [Cryptography] Best/simplest document encryption 
Hello Henry,
I am actually writing the frontend / backend code for Hohha Messenger.
It completely conforms to Hohha Whitepaper i've previously published in :
Frontend runs anywhere javascript runs. (javascript for
communication&screen logic, C -> webassembly for encryption).
I separated screen logic from encryption&communication logic . (It's
easy to write chatbots with node.js on any platform)
I want the frontend to be completely open source. But I still couldn't
figure out how to make commercial profit with it.(I have some ideas,
but for the moment i concentrate only on messaging system. Not
commercial part / ads etc.)
I designed the frontend to work solely with my backend. A special protocol.
The backend is extremely scalable. Written in C.
Backend purpose is just mailboxing&signalling.It forwards packets to
receiver as soon as he/she is online.
Users may be completely anonymous. No e-mail or phone number is
required IF user wants to be completely anonymous.
I am still coding. It's 90% completed on both backend & frontend.
And I am looking for business partners/investors from all around the world.
Because of its distributed nature, some people may operate a Startup
in USA for clients from USA, with servers residing in USA, others in
France, others in Turkey etc. But all users from different countries
will communicate to each other as a single entity.
I can also customize it for different needs, for other commercial purposes.
It will be ready for production until 15 May. Meanwhile, I am open for
different types of collaborations.
I will be glad if we can find a common ground for collaboration/partnership.
Ismail Kizir

@_date: 2019-05-06 07:16:09
@_author: Ismail Kizir 
@_subject: [Cryptography] NIST announced Round 1 candidates for 
But Bernstein's NTRU Prime is also one of NIST candidates James:

@_date: 2020-12-29 22:16:44
@_author: Ismail Kizir 
@_subject: [Cryptography] Bitcoin is a disaster. 
I totally agree.
Internet also became a disaster.
We're very far from original ideas: Uncensored, decentralized ideals are
I remember, in the beginning, governments were really afraid of people's
reactions, even to make small regulations.
Today, we don't even discuss before accepting any regulation about
Infrastructure is almost completely controlled/owned by governments or
cartels. To dig ground for your own fiber-obtic infrastructure is nearly
impossible, even for big cartels, in Turkey for example. (I even don't
mention about ordinary people/small scale companies)
ICANN fees are very high. Anonymity is almost impossible.
We even need "permission" to publish sites: We need "broadcasting"
licenses. Youtube publishing is considered same as "National TV
broadcasting" and requires licences!
They degenerated the idea of "privacy" and now, GDPR(Europe), or
KVVK(Turkey) and similars are used as censoring and contolling mechanisms:
If you want to start to publish a site, you need a "base country".
Theoretically, it may be possible. But in reality, it's almost impossible
to move your site from a country to another, because of GDPR rules! You
need to have a physical place. And of course, you are under total control
of one government and local elites!
We forgot our initial ideas.
I think, we need a "new kid on the block", which will revive old ideals by
unifying those two ideas: Internet and cryptocoin.
I don't know exactly how we can do. But I have at least one base idea:
"Contributing to infrastructure will also mean mining".
Roof networks are not very promising as a large scale internet backbone.
But I have hope from this list. If anyone, has a project based on "original
ideals of Internet and cryptocoins", I am ready to contribute.
Ismail Kizir

@_date: 2020-11-10 23:00:40
@_author: Ismail Kizir 
@_subject: [Cryptography] EU pushes for backdoored encryption 
been defending for many years) is NOT encryption backdoor.
It's simply, "hardware or operating system level backdoors". And we also
know that those backdoors exist for a very very long time.
So, there isn't any problem for accessing "targeted" access to any kind of
private data.
They just need to "legalize" a "de facto" truth: Asking hardware and/or
operating system level  backdoors passwords by a legitimate court order in
case of strong suspicion(In fact, they are actually and legally doing this
for regular phone calls, with court orders. They must just pass a new law
for operating system/hardware level access to devices).
They make cheap demagogy!
Ismail Kizir

@_date: 2020-11-11 00:54:18
@_author: Ismail Kizir 
@_subject: [Cryptography] EU pushes for backdoored encryption 
Many modern constitutions, at least Continental European Constitutions, are
based on "*Convention for the Protection of Human Rights and Fundamental
Freedoms"*, drafted in 1950, and signed by European States, according to
which, "Right of privacy" and "right of communication" is an essential
human right and "Essential rights can only be restricted by law, for a well
determined duration".
So, this kind of, "access", requires absolutely a law, in any modern law
And, in many countries, it already exist such laws, for traditional ways of
communication: GSM operators must provide ways to legal authorities to
"listen an individual, clearly stated communication", for a "specified
time", by a "judge decision or court order".
Easy way is to find a "central source" of communication and to hold that
entity responsible to "provide required ways".
The solution for legal, "targeted" access to private data(which I have been
defending for many years) is NOT encryption backdoor.
It's simply, "hardware or operating system level backdoors". And we also
know that those backdoors exist for a very very long time: Check Wikileaks
documents in order to learn about a few. Ask Google for very old Intel Chip
"undocumented opcodes" etc.
So, there isn't any problem for "targeted" access to any kind of private
There are device and/or OS specific backdoors & malwares used also by
governments for many years(also see Wikileaks and many other sources for
more info).
They just need to "legalize" a "de facto" truth: Asking hardware and/or
operating system level  backdoors passwords by a legitimate court order in
case of strong suspicion(In fact, they are actually and legally doing this
for regular phone calls, with court orders. They must just pass a new law
for operating system/hardware level access to devices).
Regarding all those "facts", still insisting on "encryption backdoor" is a
cheap demagogy in order to cover their appetite for "mass surveillance"
And Mrs. Cannoy, I don't think you have right to "silently discard" my
messages without any reason. Please don't do that anymore.
Ismail Kizir

@_date: 2020-11-11 02:45:40
@_author: Ismail Kizir 
@_subject: [Cryptography] EU pushes for backdoored encryption 
Many modern constitutions, at least Continental European Constitutions, are
based on "*Convention for the Protection of Human Rights and Fundamental
Freedoms"*, drafted in 1950, and signed by European States, according to
which, "Right of privacy" and "right of communication" is an essential
human right and "Essential rights can only be restricted by law, for a well
determined duration".
So, this kind of, "access", requires absolutely a law, in any modern law
And, in many countries, it already exist such laws, for traditional ways of
communication: GSM operators must provide ways to legal authorities to
"listen an individual, clearly stated communication", for a "specified
time", by a "judge decision or court order".
Easy way is to find a "central source" of communication and to hold that
entity responsible to "provide required ways".
The solution for legal, "targeted" access to private data(which I have been
defending for many years) is NOT encryption backdoor.
It's simply, "hardware or operating system level backdoors". And we also
know that those backdoors exist for a very very long time: Check Wikileaks
documents in order to learn about a few. Ask Google for very old Intel Chip
"undocumented opcodes" etc.
So, there isn't any problem for "targeted" access to any kind of private
There are device and/or OS specific backdoors & malwares used also by
governments for many years(also see Wikileaks and many other sources for
more info).
They just need to "legalize" a "de facto" truth: Asking hardware and/or
operating system level  backdoor passwords/codes by a legitimate court
order in case of strong suspicion(In fact, they are actually and legally
doing this for regular phone calls, with court orders. They must just pass
a new law for operating system/hardware level access to devices).
Regarding all those "facts", still insisting on "encryption backdoor" is a
cheap demagogy in order to cover their appetite for "mass surveillance".
Ismail Kizir
