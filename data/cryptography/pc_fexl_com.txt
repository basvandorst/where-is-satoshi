
@_date: 2018-08-01 07:05:45
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Krugman blockchain currency skepticism 
And to those for whom freedom IS derp, consider the case of an "activist
group" whose payment processor is suddenly shut down.  A "peer-to-peer
electronic cash system" as Satoshi calls it might be just the thing.
Krugman asks "What problem does it solve?  I have yet to see a clear
answer to that question."  That's because he hasn't read this email yet.

@_date: 2018-08-02 06:16:37
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Krugman blockchain currency skepticism 
Krugman did a good job of enumerating the costs of Bitcoin.  He also did
a good job of enumerating the benefits of alternatives to Bitcoin.
However, he was incapable or unwilling to identify even a single
possible benefit of Bitcoin, and therefore could not discuss whether any
benefits might exceed the cost for certain people at certain times.  But
at least he asked.

@_date: 2018-08-04 11:08:26
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Krugman blockchain currency skepticism 
Except that a Chaumian e-cash issue would be hosted on an individual
server (or group thereof), and state actors could interfere with access
to that server.  Also a Chaumian e-cash issue would presumably be
redeemable for assets on demand, and the vaulted assets would be
vulnerable to seizure.
I tend to think the future is in individually issued real bills of
exchange, redeemable for assets, with invoices signed by the payee and
those signed invoices further signed by the payer, and exchanges cleared
by the issuer.  Bills of exchange by different issuers could be traded
on a market floor to allow price discovery based on issuer reputation
and asset value.
In this system, each individual issuer would in effect be a "central
server," but the proliferation of issuers and exchangers would afford a
level of decentralization.

@_date: 2018-08-05 11:59:34
@_author: Patrick Chkoreff 
@_subject: [Cryptography] threat models, 
I never said they were all wrong.  Paypal is a perfectly fine
alternative as long as they don't cut you off.  Then you can use Bitcoin
instead.  Recall that my original point was to answer Krugman's question
"what problem does it [bitcoin] solve?"
The threat model is that a payment processor cuts off your service
because somebody doesn't like you.
No.  Some issuers will use double-entry bookkeeping just like Paypal.
Others may use blinded tokens.
I will trust some issuers and payment platforms more than others.  Other
people will make a different assessment.  That's what makes a market.
I am less concerned about accepting an issue which I trust less if I can
trade it for an issue which I trust more.  It may well be that the
person on the other side of the trade has exactly the opposite position
of trust with respect to the two issues -- or at least has a more
pressing need for the one I have versus the one he has.
 someone's doing the mining or equivalent.)  If an issuer doesn't
It depends on the contract and the jurisdiction.
Yes, though not everyone will find traction in a wide market.  Some may
only trade within cliques, or networks of cliques.
You could.  However there are many examples of issuers/payment
processors with a long track record of not doing such things.
The concerns you raise regarding trust in central servers/issuers and
trust in redeemable assets serve as excellent points in favor of Bitcoin.
With Bitcoin, you don't have to ask "Why should I trust Issuer X to
clear my payments, and why should I trust Issuer X to redeem my digital
tokens for real assets like gold or $100 bills?"  The answers are "there
is no Issuer X" and "there are no real assets."  Real assets are so 18th
Century anyway.

@_date: 2018-08-06 10:55:50
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Krugman blockchain currency skepticism 
Yes, the revelation of double spenders is an excellent feature.
If you were to establish a Chaumian e-cash issue today, what would be
the underlying assets for that issue?  I assume you would not issue
tokens by fiat, but rather in response to bailment events.  If your
answer to this question is "bank deposits," I would maintain that you
do indeed deploy "vaulted" "assets" in your system.  I would also
maintain that you are in a precarious legal position, on top of the
risk of the bank simply closing your account.  If your answer is Swiss
1000-franc banknotes, then you literally have a vault full of the
barbaric relic of paper.
And if YOU don't establish a Chaumian e-cash issue, who will?  So far
the answer is nobody.  Even early gold issuers such as Goldmoney
(still around), e-gold, and Pecunix never attempted it, though in some
cases that might have been due to patent issues.  I am virtually
certain Goldmoney will never do it because the founder is
philosophically opposed to anonymity in principle.  Even if he
weren't, his hand is forced by KYC.
If you want high efficiency and a well-defined security model, it's
hard to compete with blinded tokens.  But if you want something that
exists, you'll have to look elsewhere.

@_date: 2018-08-07 09:30:07
@_author: Patrick Chkoreff 
@_subject: [Cryptography] threat models, 
That is true.  E-cash (blinded token) does prevent shutting down a
specific user, and that was the original threat model I posed here.
The only problem with e-cash is that it does not exist.  It does not
exist because it is too risky to implement.
I believe you just made the best argument in favor of Bitcoin.  That is,
the only way to shut it down entirely is to implement North Korean
levels of authoritarian control over the Internet.  That is expensive
and difficult, with benefits that lower-level authoritarian
personalities might see as Pyrrhic.
In contrast, shutting down E-cash requires only a couple of
well-targeted and inexpensive "Mueller Attacks," which have the desired
intimidation effect without killing the golden goose of traditionally
controlled economic activity.  (For example, the single attack on E-gold
in 2007 killed an entire industry in the crib without no ill effects to
the wider economy.)
That is certainly true.  The only relevant question is whether the the
benefit of the attack exceeds the cost.  Lowering the benefit or raising
the cost are the only ways to tip that scale.  In the case of Bitcoin,
the cost of shutting down the entire system appears to be quite high.

@_date: 2018-08-08 13:13:48
@_author: Patrick Chkoreff 
@_subject: [Cryptography] threat models, 
I'll go ahead and answer that first, even though you do bring up some
valid objections to reputation markets below.
Assume that both you (William) and I (Patrick) have each issued a signed
note pledging to pay $100.00 to the bearer on demand.
Now someone out there wishes to be paid $100.00 in digital notes.  He
happens to be a friend of William.  He will naturally prefer the
William-note over the Patrick-note.
However, he *might* be willing to accept the Patrick-note instead.  Why?
 Because he sees a bid offering $102.00 in William-notes in exchange for
a single $100.00 Patrick-note.  Why would someone offer that?  Because
the bidder has done business with Patrick for a long time and has no
particular history with William.  Why did he accept William-notes in the
first place?  Long story:  market forces, turtles all the way down.
The friend-of-William and the friend-of-Patrick place different
subjective values on the notes (a la Carl Menger), and "that's what
makes a market."
It's a good point.  You (William) might simply default on your signed
obligations to redeem your notes.  In which case your friends and
colleagues who hold your notes may approach you and give you a hard time
about it.  People who hold your notes but have no way of getting in
touch with you will simply take a loss, possibly with no recourse.
Perhaps they should have diversified into Patrick-notes, but that's
another discussion.
Meanwhile you (William) simply abscond to Peru, create a new ECC key,
and start signing new notes.  However, that new key has zero reputation,
so your notes might only trade with your new friends in Peru.  After a
few months you will repeat your scam and they too will suffer losses --
and then you'll move on to fleece some new victims.
(Nothing personal here, I'm not accusing you of being a thief, just
using you for rhetorical effect.)
Eventually someone may catch up with you, but the valid point you make
is that trading notes at discount based on reputation is NOT fool-proof.
 It is most likely not even possible in principle to insure against
"fat-tail" Black-Swan defaults like that.  Diversification may be the
only remedy.  People then take their occasional losses and move on with
their lives, assuming no enforcement is possible.  Who knows, those
losses may even compare favorably to the inexorable loss of purchasing
power people suffer routinely today.  I can only decide that for myself.
Well, the "great" thing about a "peer-to-peer electronic cash system"
such as Bitcoin is that there are no real assets to worry about.  That
does not make devotees of the Mises Regression Theorem happy, but
meanwhile people continue to use Bitcoin in spite of the Theorem.
Evidently Satoshi managed to speak value into existence, /ex-nihilo/.
Precisely.  Once William defaults on even a single note, the value of
all his outstanding notes on the market will soon plummet to zero.  Or
maybe your friends buy them up at $0.05 each and have an intervention.
Maybe you possess some of THEIR notes and you can sign them back over to
them to settle the score.  But yes, in general most everyone gets screwed.
The same kind of thing can happen with bank defaults.  Yeah there's FDIC
but they're undercapitalized too.
(Perhaps certain large issuers COULD find someone willing to insure
their notes, given sufficient collateral which they could reliably seize
or keep.)
Well, John Levine remarked that notes redeemable for real assets "worked
OK in the 1700s, but there's probably good reasons we've moved beyond
it."  I assume from his comment that he regards a note redeemable for a
crisp $100 bill as a sort of a retro throw-back to a less enlightened
time, when people actually expected to *redeem* an asset-substitute for
an actual asset -- but now we have things like Bitcoin where the
benighted concept of redemption no longer applies in Current Year.  I
may have caricatured his intent but I can't yet guess what else he might
have meant.
If you default on the William-notes, you might want to declare your
gains on your tax return.  That is not tax advice, so as always please
consult your tax professional.

@_date: 2018-08-08 16:54:24
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Crowd Supply announces Infinite Noise TRNG 
Crowd Supply announces the availability of the Infinite Noise TRNG, for
the low-low price of $35:
(Includes slick video.)
Someone's been listening to the Wayward Geek Bill Cox, who may soon be
scoping out real estate in Deer Valley!

@_date: 2018-08-24 14:17:26
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Next steps in the Mesh 
I am following the Mesh project with great interest.  The quality of
your explanations indicates that you're doing beautiful work.  This
could be very valuable to a lot of people.

@_date: 2018-07-30 11:40:31
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Maybe those million-bit-key cryptosystems have 
I like the vision but I can't get past this key point:
  "key bits must be shared by the parties"
Certainly two parties could "dial up" the security all the way to
perfect by using a one-time pad, and that would in fact drive the
algorithmic complexity all the way down to XOR.  Problem is, that key is
toast once it's used up, and now the parties have to share a brand new
key.  It is mathematically impossible to use a one-time pad to
communicate the next one-time pad of the same size -- unless your
message size is zero in which case there is no communication at all.  So
now what?
The good thing about a shared 128-bit AES key is that you can use it to
encrypt a virtually unlimited amount of future information.  It never
"runs out."  But even the sharing of THAT key begs the question:  how do
you share it?  Aside from meeting in person and exchanging a slip of
paper, the only way I can think is to rely on mathematical "tricks" such
as discrete log and factoring, and now you're right back to high levels
of algorithmic complexity, and the possibility of someone finding a way
to break the scheme forever.
I can't help but think that his vision cannot in principle be achieved,
but I can't imagine how to prove that.  It is only a gut feeling brought
on by the simple fact that you can't use a one-time pad to communicate
both a message AND the next one-time pad of the same size.  However,
perhaps it can be demonstrated that with some minimal degree of
mathematical complexity a bit higher than XOR, it might be achievable.
I haven't looked at BitFlip so I don't know if that's a candidate.

@_date: 2018-05-14 15:49:42
@_author: Patrick Chkoreff 
@_subject: [Cryptography]  
=?utf-8?q?_encrypted_emails=E2=80=94_=3Funinstall_now=3F?=
Erik wrote on 05/14/2018 01:55 PM:
Based on my quick skim of  here is my current hypothesis.
It does not matter whether the decryption is "automatic" or not --
whatever that may mean.  The problem occurs when your email client loads
embedded images.  I recommend disabling the automatic loading of images.
 That's been my setting for a long time.
If you do that, then you can decrypt an email with no problems.
However, if your browser displays the button to load embedded images, DO
NOT CLICK THAT BUTTON.
If you follow that rule, you are not vulnerable.
WARNING:  That hypothesis could be wrong, but that's how I understand
the problem at the moment.  Do not bet your life or money on it.

@_date: 2018-11-21 11:57:23
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Buffer Overflows & Spectre 
The CPU produces the correct results for a given program as efficiently
as its designers could think to make it.  That's what customers were
paying for.  Even a speculative out-of-bounds array reference did not
violate that particular contract.
As we now know, the speculation can leak the contents of memory to other
processes running on the same machine.  Live and learn.  Someone will
have to devise new CPUs that are reasonably efficient but without side
channels.  It's easy to say now that "they should have known!" but that
doesn't make much sense because it's still not entirely clear what to do.
In the meantime:
"Don't allow malicious, attacker-controlled code to run on the same
CPU/CPU cluster as your precious secret-containing code" (Peter Gutmann)
On the other hand:
"If you’re running servers (etc.) then clients can spy on each other."
(Jon Callas)
"If you’re running client software (oh, like a web browser running
Javascript), then you have to be careful that the JS doesn’t manage to
get a covert channel on other things." (Jon Callas)
I'm not too concerned about the server case because I can typically
control how clients behave.  The Javascript case is a little scary
though.  What happens if I visit cutekittens.ru while running gpg-agent?

@_date: 2018-11-26 10:36:09
@_author: Patrick Chkoreff 
@_subject: [Cryptography] On the use of TweetNaCl as a standard cryptography 
I've been working with TweetNaCl lately, in particular embedding its
functions into my functional programming language Fexl.  I like its
authenticated encryption routines, which I have embedded as:
  (crypto_box_seal plain_text nonce key)   # Encrypt the plain text.
  (crypto_box_open crypt_text nonce key)   # Decrypt the crypt text.
(Note that Daniel Bernstein has designed these functions to guarantee
repudiability, while still protecting the sender and receiver against
The "key" argument to those functions is derived differently by the
sender and receiver, using this function:
  (crypto_box_prepare public_key secret_key)
  # Combine the 32-byte public and secret keys into a 32-byte composite
  # key which is used with crypto_box_seal and crypto_box_open.
  #
  # When sending, use the recipient's public key and the sender's secret
  # key.  When receiving, use the sender's public key and the
  # recipient's secret key.
A secret key is an arbitrary string of 32 bytes, which I read directly
from /dev/urandom using:
  random_secret_key  # Returns a string of 32 random bytes.
A public key is derived as a deterministic function of a secret key with
this function:
  (crypto_box_public secret_key)
  # Map the 32-byte secret_key into the corresponding 32-byte public
  # box key.
A nonce is an arbitrary string of 24 bytes, which I read directly from
  random_nonce  # Returns a string of 24 random bytes.
(In addition, for plain signatures, there is a similar set of functions
crypto_sign_public, crypto_sign_seal, and crypto_sign_open.  However
these are not needed for ordinary authenticated communication.)
I regard this cryptographic protocol as a sort of "ultimate" toolbox, at
least until the fabled quantum computers come along.  The TweetNaCl
library is very efficient, and I trust that Bernstein has made it
extremely secure -- as much as I can trust *anyone* working in this space.
However, I must ask, is my appraisal justified?  Are there problems with
the protocol, or its specific implementation in TweetNaCl?  Does the
library fail to address any issues which arise in practical
applications?  In an ideal world, if "everyone" standardized on this
library, what problems might arise, including vulnerabilities,
inefficiencies, or missing features?  In other words, why isn't this
"the last word" on cryptographic protocols, given our current
understanding, and discounting quantum computers?  It's an open-ended
question, and I'm not married to any particular answer.

@_date: 2018-10-27 10:45:33
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Question about crypto_sign_open (in tweetnacl.c) 
I noticed an intriguing technique used in crypto_sign_open in
tweetnacl.c.  On line 790 we have:
  FOR(i,n) m[i] = sm[i];
That's straightforward.  After that loop, m consists of the 64 byte
signature followed by the (64-n) byte message that was signed.  But then
watch this on line 791:
  FOR(i,32) m[i+32] = pk[i];
That loop overwrites the last 16 bytes of the signature with the first
16 bytes of the public key, and overwrites the first 16 bytes of the
message with the last 16 bytes of the public key.
I'm thinking that the overwriting on line 791 is done simply for the
purpose of "mixing it up" a bit prior to the call to crypto_hash on line
792, which computes the SHA-512 hash of m.  But knowing DJB's mindset as
I do, it's probably not arbitrary, and most likely protects against some
known possible weakness.  Can anyone elaborate on that?
Note of course that it obviously has to be done because of the gyrations
which occur in crypto_sign, otherwise the signature wouldn't verify.
But I'm wondering what sort of weakness is being guarded against here.

@_date: 2018-10-27 10:55:33
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Question about crypto_sign_open (in tweetnacl.c) 
Sorry, I misinterpreted that loop.  It overwrites the last 32 bytes of
the 64-byte signature with the contents of the 32-byte public key,
period.  It does not overwrite the message at all.

@_date: 2018-10-28 18:01:07
@_author: Patrick Chkoreff 
@_subject: [Cryptography]  Question about crypto_sign_open (in tweetnacl.c) 
Here's a response I got on the curvecp list:
See Ed25519 paper, page 10:
"the use of [public key in hashing] is an inexpensive way to alleviate
concerns that several
public keys could be attacked simultaneously”
Dmitry Chestnykh

@_date: 2019-08-12 22:50:00
@_author: Patrick Chkoreff 
@_subject: [Cryptography] generated passphrases 
My code is written in Fexl, but you might find it helpful as pseudocode.
I based my code on this word list:
Here is the module which defines the random_passphrase function:
It has a parameter which is the strength in bits, and it automatically
calculates the correct number of random words to use based on the size
of the word list.  For example if you use a strength of 62 bits, it will
give you a 6-word passphrase.
That module uses a function called random_double, which if you're
interested is defined here:
That streams 7 bytes directly off /dev/urandom and converts them to a
double value.
Finally, here is the word list expressed in Fexl:

@_date: 2019-08-12 22:53:06
@_author: Patrick Chkoreff 
@_subject: [Cryptography] generated passphrases 
Sorry I missed your point there before my last post.  You're wanting a
random English sentence generator based on a simple English grammar, and
I don't have that handy.

@_date: 2019-08-14 22:41:23
@_author: Patrick Chkoreff 
@_subject: [Cryptography] generated passphrases 
I don't have any problem remembering 128 bit passphrases composed of
words selected from something like Diceware.  The mnemonic technique of
stringing the words together into a bizarre mental story works well.
Of course, I also write down passphrases in various ways and keep those
documents physically secure, in case I have a really bad "senior moment"
one day.
For a login passphrase, or a passphrase that unlocks a local private
key, you might only need 4 or 5 words, with a strength of 40 to 65 bits.
 Anyone capable of handling digital currency should be also be capable
of remembering such a passphrase and writing it down reliably.

@_date: 2019-01-04 09:12:48
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Blockchain without proof of work 
Ooh, I've tagged this email as "Later" so I can go back to that.  How
will I go about verifying those when the secrets are divulged?  (Pardon
me if I haven't been paying attention in class here.)
That's the spirit.  I doubt anyone will do it better than you anyway. ;)
 Seriously though maybe take a look at HashGraph and see if there's
anything there ready for adoption and use, and get back to us.

@_date: 2019-01-13 08:54:06
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Blockchain without proof of work 
That I don't understand.  If taking the first 128 bits of SHA-512 is
less collision-resistant than some other 128 bit hash, wouldn't that
indicate a serious flaw in SHA-512?

@_date: 2019-07-12 21:04:16
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Our leader opines on cryptocurrencies 
Those are the standard arguments that many people, and almost all
politicians, have been making for about 10 years.  I am happy to hear
that you are now looking askance at them.

@_date: 2019-06-14 08:39:51
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Minimal secure boot 
Might you save some code space, and gain some efficiency, by using DJB's
Curve25519-based signatures?  The keys are small but give you high
security.  You might also avoid issues such as choice of exponent in RSA.
Here are some links to code that I adapted from Daniel J. Bernstein's
1. The nacl_sign_seal routine creates a signature:
2. The nacl_sign_open routine verifies a signature:
3. Those routines rely on SHA512, defined here:
Turns out SHA512 is actually *faster* than SHA256 due to its use of a
full 64-bit word instead of 32-bit.
4. The secret key for signing (or encryption) is an arbitrary string of
32 random bytes (256 bits).  There is a deterministic routine which maps
a secret key to its corresponding public key:
5. The nacl_sign_seal and nacl_sign_open routines have certain padding
protocols, which I have captured in a module which wraps the core Nacl
routines inside a "string" data type (i.e. pointer to fixed length + data):
5a. The nacl_sign_seal routine is called with a buffer that has an extra
64 bytes at the front for the signature:
5b. The nacl_sign_open routine requires two buffers:
NOTE:  It occurs to me that the TweetNacl routines as currently written
take in a pointer to an arbitrarily long message, which it then hashes
itself with SHA512.  Perhaps they could be refactored to take in ONLY a
pointer to a fixed 64 byte hash, which is computed outside the "seal"
and "open" routines, as a separate pre-computation.  That would make the
calling interface entirely fixed-size, and avoid the need for copying
messages and allocating separate dynamically sized buffers.
I would like to see if I could do that while preserving the test output

@_date: 2019-05-06 19:05:17
@_author: Patrick Chkoreff 
@_subject: [Cryptography] NIST announced Round 1 candidates for 
I've been using TweetNaCl  quite a bit.  I
often wonder if that library would be sufficient for all crypto
purposes, assuming one was starting an application from scratch and
didn't need things like RSA just for legacy purposes.  If not
sufficient, what is missing?

@_date: 2019-05-08 17:54:18
@_author: Patrick Chkoreff 
@_subject: [Cryptography] NIST announced Round 1 candidates for 
I started with TweetNaCL because it had a lot of basic functions in one
C source file.  However, the first thing I did was eliminate the ghastly
macros in the .h file, which included horrors such as forward
definitions.  I ended up with something flat and obvious, no cruft:
I also eliminated the external call to the unspecified "randombytes"
function for generating a key pair.  Instead I implemented a
deterministic function which maps an arbitrary secret key to the
corresponding public key, in the "crypto_box_public" function here:
That way the random bytes are gathered outside the library and passed in.
I'm not yet familiar with Ristretto255 or why I'd need it, but thanks.

@_date: 2019-05-09 16:01:51
@_author: Patrick Chkoreff 
@_subject: [Cryptography] peering through NAT 
I've often wondered about that.  A few years ago a networking expert
showed me a technique where the client program running on your own
computer sends OUT a packet which lingers on the outside of your network
interface, awaiting a response.  A remote server can reply to it, and
your client program sees the response.  It's kind of a dummy packet too,
with no actual content.  At that point I suppose your client program
sees the remote IP and can initiate a direct connection to it.
With this technique, your grandpa doesn't have to configure iptables.
I don't know the specifics, and it has been a while since I looked at it.

@_date: 2019-10-04 16:35:43
@_author: Patrick Chkoreff 
@_subject: [Cryptography] AG Barr: USG Seeks Front Door to Encryption Not 
Translation:  "We" think "our" tech sector just needs to nerd harder.

@_date: 2020-04-05 11:33:48
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Dumb Question about Pair-Wise Authentication 
Is there any chance you could use TweetNaCl?  Even there, his extensive use of nested macros, even multi-hop
forward-referencing macros, made my head hurt, so I refactored the
living daylights out of it and arrived here:
Then, the requirement for "just so" padding and fixed-length buffers
made my head hurt again, so I wrapped it with a dynamic "string" type
and arrived here:
(Then, I made bindings for my language Fexl, which is not especially
relevant here.)
Then, I created a bunch of test cases, since I couldn't find anything
I'm not saying it would be a super-easy slam-dunk, but once you got
everything hooked up you'd have a pretty powerful toolset, with built-in
authenticated encryption.
It sounds awesome, but I'll leave it to others to pounce on any weaknesses.
In your scheme, you'd be sharing a single symmetric encryption key.  Now
with TweetNaCl, you could use two separate public keys -- but you could
also just share a single private key if you preferred.  So what's really
the point of using TweetNacl, if you do that?  I guess the only possible
advantage would be using a fully established existing protocol for
authenticated encryption.  It may be complete overkill, if you already
have the ready tools to implement your scheme.

@_date: 2020-02-18 17:52:21
@_author: Patrick Chkoreff 
@_subject: [Cryptography] With an e2e network, 
We already have a problem with metadata.  Would Alfie's e2e suggestion
make that problem worse?

@_date: 2020-02-19 09:26:12
@_author: Patrick Chkoreff 
@_subject: [Cryptography] With an e2e network, 
Got it.  I incorrectly interpreted your "Metadata" response (nice video
clip by the way) as an argument against deploying e2e over untrusting
equipment.  Your response was actually an answer to Alfie's question of
why U.S officials don't recommend that to other countries.  It takes
U.S. officials out of the metadata loop.
I recently heard an interview with Huawei's head of security (an
American guy).  He said that independent testers in Europe are doing
extensive tests on Huawei equipment to find vulnerabilities and/or back
doors.  I wonder though if they would be able to a back door that's
triggered by some specific magic 128-bit sequence coming in on the
interface.  There would probably need to be some complex circuitry or
weird microcode to recognize it, and that might be a tip-off.
In any case it looks like the Europeans are faced with a simple choice:
 who do they want to grab their metadata, and possibly even their data

@_date: 2020-02-22 18:23:03
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Apple's 13-month certificate policy 
Yes, the auto-renewal works beautifully and eliminates a world of
headaches.  I suspect that Apple's move will accelerate the adoption of
Let's Encrypt, now that everyone will have to renew more often.

@_date: 2020-01-23 13:01:24
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Proper Entropy Source 
I'm not entirely clear why seeding is portrayed as so difficult.  Please
bear with me here.
I just rolled a sixteen-sided die to get a "truly random" hexadecimal
digit, which I'll call $digit here so as not to disclose this vital
secret.  Then I ran:
$ echo $digit >/dev/random
I'm pretty sure I just made the state of my PRNG 16 times more difficult
to guess.  I could continue with more dice rolls to make it fiendishly
Is the alleged difficulty of seeding a PRNG based on the problem of how
to do it automatically?  If so, why is that difficult?  Isn't the
sequence of key strokes, mouse movements, internal interrupts, etc.
enough to inject sufficient entropy?
Or, is the alleged difficulty of seeding a PRNG mostly confined to the
problem of how to do it on a fresh machine upon first starting up --
e.g. spinning up a new virtual machine?  And why is so much importance
attached to the need to generate ssh keys immediately upon spinning up a
brand new machine?  I guess I'm not in the business of running large
server farms.  Is it too much to ask to seed a new machine somewhat
manually from some outside source when it first starts up?

@_date: 2020-07-30 10:14:59
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Cryptographically securing a two-phase commit 
Getting the the size of the blob up front, along with the identity of
the sender, sounds crucial.
If the sender is known good, you might be fine with a 200 MB blob.  If
they subsequently send you junk, that's one strike against them.  If
they try to send you 1000 MB, that's one strike as well, and you cut the
connection after receiving the 200 MB.  Too many strikes, and the
identity goes to status bad.
If the sender is unknown, treat them the same as good except with a 5 MB
size limit up front.
If the sender is known bad, you cut the connection immediately.
Also, as others have indicated, collect all the raw data first and do as
little work as possible as it's coming in.  Only
hash/decrypt/authenticate that first header block announcing the
intended size and sender identity.
They can still DoS you by creating new sender identities, but they're
only wasting 5 MB of your time.  If that's an issue, you may need a more
rigorous process of registering new identities, possibly requiring
payment or proof of work on the sender's computer.

@_date: 2020-03-05 09:34:47
@_author: Patrick Chkoreff 
@_subject: [Cryptography] Ex-CIA Joshua Schulte Describes His Data/Crypto 
You could buy a set of 16-sided dice.  After running the dd command,
roll those dice to generate 32 random hex digits (128 bits).  Then echo
those into /dev/random.  Now they know nothing about the state of your
random number generator.

@_date: 2020-09-23 21:49:50
@_author: Patrick Chkoreff 
@_subject: [Cryptography] A naming and key distribution infrastructure for 
Yes, as I was driving around thinking about Phillip's post, I thought
that I'd want my name to be 10 random digits, like a phone number, e.g.
  Then my friends would just map "Patrick" to that in
their contact lists.
