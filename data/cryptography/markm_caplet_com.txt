
@_date: 2002-04-29 09:46:40
@_author: Mark S. Miller 
@_subject: Is There a Quantum Mechanic in the House? (was: Lucky's 
Hi Enzo!
Disclaimer: I am not a quantum mechanic, and I find the whole subject, including quantum computation, deeply confusing.  Also, the article I refer to -- an article in Science by the guy who came up with the original factoring result -- is an article that I haven't read, and wouldn't understand if I had.  (Neither do I happen to know enough to give a proper citation.)  Perhaps someone on this list can fill in some of these gaps, or let us know that I've badly misinterpreted the situation, which is quite All that said, my understanding is that the plausible worst case news from quantum computing would probably not require us to give up PK crypto.  My understanding is that the article I'd like to cite states something like the 1) Factoring is special because it's all pervasively about periodicities.  The author's original factoring proposal took advantage of this in an essential way in order to show a potential exponential speedup.
2) For NP problems in general, since they are search trees with only polynomial depth to an answer but exponential fanout of choices, by using superposition, quantum computation may indeed be able to give an exponential speedup on the first phase of the search -- finding the answer.
3) The problem then is reporting the answer out.  The superposition that found the answer co-exists with an exponential number of superpositions that don't.  My understanding is that the paper is postulating an upper bound for search problems without peculiar special properties (like the periodicities of factoring) -- the most we can get is an order-of-square-root speedup on the problem as a whole.
If the above description is approximately right, then the remaining question for PK is, can one design a PK system now whose trapdoor depends on a search problem that we can be confident cannot be transformed into one with the enabling peculiar properties?  AFAIK, this question has not been examined.
Btw, out of fear that quantum computation might destroy PK but not single-key, I worried about whether one could do cryptographic capabilities in such a world.   is a protocol sketch of a distributed capability protocol that depends only on single-key cryptography.  But I hope it will never be necessary.
Text by me above is hereby placed in the public domain
        Cheers,
        --MarkM

@_date: 2002-07-04 10:39:57
@_author: Mark S. Miller 
@_subject: MS DRMOS Palladium -- The Trojan Horse OS 
That seems like a complete non-sequitur.  Why won't others build secure OSes?  MS didn't patent security (not that I've heard anyway).  For example, how is EROS  threatened by these MS patents?
Text by me above is hereby placed in the public domain
        Cheers,
        --MarkM

@_date: 2002-07-20 15:05:55
@_author: Mark S. Miller 
@_subject: It's Time to Abandon Insecure Languages 
Thank you.  It's been working well for us.  Most of the brilliant concepts in E aren't ours, but are thirty years or so old.  In particular, Hewitt's Actors had both distributed lambda-based capability security and deadlock-free event-loop concurrency.  See  for more on the history of influences on E.
"catch probs"?
Correct, and very perceptive.  We refer to this as Data Lock.  However, the different guise causes an importantly different effect.
E does not enable one to fully avoid making Data Lock bugs, but does make
such bugs amazingly rare, as explained at  .  See also  .  During the six years of use of E and its ancestor Original-E (which used the same paradigms), I can only recall one occurrence of an accidental Data Lock bug. Although the explanations at those URLs helps explain why, I remain mystified why there were so *many* fewer Data Locks than there would have been DeadLocks.
Reliably?  No.  More reliably?  Yes.
Since we've only had one genuine occurrence of a Data Lock, we have no meaningful statistics.  You are also correct that Data Locks can be non-deterministic and so throw you into non-reproducible debugging hell.  However, in a non-deterministic system, all bugs may be non-reproducible, because the computation can diverge before that point in the computation is reached.  Classic Deadlock bugs are more non-reproducible than that, because they are inherently provoked by a race condition.  In E, Data Locks are no more non-reproducible than any other kind of bug in a non-deterministic system.  Further, E's non-determinism is very constrained (what we call "loggable non-determinism"), leading to less non-reproducibility in general.
Text by me above is hereby placed in the public domain
        Cheers,
        --MarkM

@_date: 2002-10-31 15:41:26
@_author: Mark Miller 
@_subject: Windows 2000 declared secure 
What it means: Text by me above is hereby placed in the public domain
        Cheers,
        --MarkM

@_date: 2002-09-04 14:48:40
@_author: Mark S. Miller 
@_subject: [e-lang] Constructing "capability" URLs 
Please read  .  The quotes below are from that page.
 From what you say later, it looks like the purpose of this last string is to be an unguessable randomly chosen number, though I don't understand the purpose of the other info you're mixing in.  We call an unguessable randomly chosen number used for this purpose a SwissNumber "since it has the knowledge-is-authority logic loosely attributed to Swiss bank accounts".
In any case, a stringified cryptographic capability needs three parts.  The first is routing hint information to help find an object to talk to that allegedly corresponds to the object designated by that capability. This routing info has no security properties beyond denial-of-connectivity issues.  The other two parts provide the security: "A capability is an arrow, and an arrow has two ends. There is an impostor problem in both directions. The VatID [fingerpring of public key of designated object's host] ensures that the entity that Bob is speaking to is the one that Alice meant to introduce him to. The Swiss number ensures that the entity allowed to speak to Carol is the one that Alice chose to enable to do so."
If your " above is intended to provide authentication info as well as routing, then you indeed have something analogous to all three parts. At  Tyler Close pioneered this approach to using https URLs as cryptographic capabilities, which has since also been prototyped by Kevin Lacobie for Lotus Notes. The big advantage of this approach is that regular browsers can participate in the world of distributed capabilities, as the Waterken software amply demonstrates.
The disadvantage is that the capability authenticity problem, ensuring that "the entity that Bob is speaking to is the one that Alice meant to introduce him to" no longer depends on just Alice Bob and Carol, but also on VeriSign or other such external CA hierarchies.  This is a rather massive expansion of vulnerabilities.  Worse, it concentrates vulnerabilities in a small number of massive third parties, leading to a centralization of power.
I don't understand what point you're making.
Are you happy to have your capability URLs expire when the key does?  Do you have some refresh scheme in mind so that a holder of an old URL can, prior to expiration, get a fresh one? What threat (that you care about) does this expiration protect you from?
Text by me above is hereby placed in the public domain
        Cheers,
        --MarkM

@_date: 2003-12-03 20:43:41
@_author: Mark S. Miller 
@_subject: Call for Papers: Workshop on Electronic Contracting  
(Btw, Alan Karp, Ian Grigg, and I are on the program committee. Once others have confirmed, the PC will be on the web page.)
 From  :
The First IEEE International Workshop
on Electronic Contracting (WEC)
Real world commerce is largely built on a fabric of contracts. Considered abstractly, a contract is an agreed framework of rules used by separately interested parties to coordinate their plans in order to realize cooperative opportunities, while simultaneously limiting their risk from each other's misbehavior. Electronic commerce is encouraging the growth of contract-like mechanisms whose terms are partially machine understandable and enforceable.
The First IEEE International Workshop on Electronic Contracting (WEC) is the forum to discuss innovative ideas at the interface between business, legal, and formal notions of contracts. The target audiences will be researchers, scientists, software architects, contract lawyers, economists, and industry professionals who need to be acquainted with the state of the art technologies and the future trends in electronic contracting. The event will take place in San Diego, California, USA on July 6 2004. IEEE SIEC 2004 will be held in conjunction with The International Conference on Electronic Commerce (IEEE CEC 2004).
* Topics of interest include but are not limited to the following: * Contract languages and user interfaces * Computer aided contract design, construction, and composition * Computer aided approaches to contract negotiation * "Smart Contracts" * "Ricardian Contracts" * Electronic rights languages * Electronic rights management and transfer * Contracts and derived rights * Relationship of electronic and legal enforcement mechanisms * Electronic vs legal concepts of non-repudiation * The interface between automatable terms and human judgement * Kinds of recourse, including deterrence and rollback * Monitoring compliance * What is and is not electronically enforceable? * Trans-jurisdictional commerce & contracting * Shared dynamic ontologies for use in contracts * Dynamic authorization * Decentralized access control * Security and dynamism in Supply Chain Management * Extending "Types as Contracts" to mutual suspicion * Contracts as trusted intermediaries * Anonymous and pseudonymous contracting * Privacy vs reputation and recourse * Instant settlement and counter-party risk Submissions and Important Dates:
Full papers must not exceed 20 pages printed using at least 11-point type and single spacing. All papers should be in Adobe portable document format (PDF) format. The paper should have a cover page, which includes a 200-word abstract, a list of keywords, and author's e-mail address on a separate page. Authors should submit a full paper via electronic submission to boualem at cse.unsw.edu.au. All papers selected for this conference are peer-reviewed. The best papers presented in the conference will be selected for special issues of a related computer science journal. Submissions must be received no later than January 10, 2004. Authors will be notified of their submissions status by March 2, 2004 Camera-Ready versions must be received by April 2, 2004 Organizing Committee and Workshop Officers
General Chair
Ming-Chien Shan, Hewlett-Packard, USA, shan at hpl.hp.com
Program Co-Chairs
Boualem Benatallah, University of New South Wales, Sydney, Australia
Claude Godart, INRIA-LORIA, Nancy, France, Claude.Godart at loria.fr
Text by me above is hereby placed in the public domain
        Cheers,
        --MarkM

@_date: 2003-07-16 00:06:09
@_author: Mark S. Miller 
@_subject: Announcing httpsy://, a YURL scheme 
This is exactly backwards. Use of CAs are vulnerable to MITM attack by prior arrangement -- by enabling the CA to mount such an attack. Both the CA and the introducer are equally able to place themselves (or an agent of themselves) in the middle, but when an introducer does it, *by definition* it isn't a MITM attack.
By definition? A CA certifies to Bob that the key K corresponds to some entity (Carol) that Bob might know by the name N. (In PGP, N is allegedly Carol's email address.) Unaddressed and assumed away is the issue of how Bob came to know name N. In actuality, someone (Alice) who already knew Bob and Carol told Bob about Carol as part of a message. This message gives semantic context to the introduction, so that Bob may choose how to regard Carol based on his relationship with Alice, and based on what Alice said in her introduction message. This account is equally valid among objects in a pure object programming system, and among people as described by Granovetter.
In the absence of someone like Alice performing such an introduction, how did Bob come to know about Carol's existence? How did Bob come to regard Carol with any prior properties (i.e., properties not derived purely by interaction with Carol)? The Y property follows simply from the observation that authenticity of initial introduction is simply for Bob to know that the Carol he's talking to is the Carol Alice meant to introduce him to; and that the introduction message as received is that which was sent

@_date: 2003-07-16 09:04:17
@_author: Mark S. Miller 
@_subject: Announcing httpsy://, a YURL scheme 
In order for the Carol that Alice introduces Bob to to be inauthentic, there must be some prior notion of *who* Alice was supposed to introduce Bob to. CAs do their introductions (lookup name, get key) in a context where there is such a prior notion, exactly because the CA introduction comes after some other initial introduction informing Bob about Carol's identity in the first place. I am speaking here of the initial introduction. If Bob has no prior notion of Carol, what can it mean for Alice to introduce him to the wrong one?
Or do you mean something else by a non-authentic party?
Of course, Alice may misinform Bob about Carol's properties (non-"who" issues), but I already covered that as a distinct case in the paragraph on Alice's misbehavior.
Text by me above is hereby placed in the public domain
        Cheers,
        --MarkM

@_date: 2003-10-05 18:10:20
@_author: Mark S. Miller 
@_subject: [e-lang] Re: Protocol implementation errors 
Peter's statement was:
If I understand Peter's statement, the answer is yes for Doc, S-Expressions, Term trees, XML, Java serialization streams, and many other formats; both textual and binary. As for Corba IIOP and the CapIDL serialization format, only if the interface definition is included. Otherwise, I don't think these are self-describing in the sense Peter means.
Text by me above is hereby placed in the public domain
        Cheers,
        --MarkM
