
@_date: 2006-03-14 20:17:57
@_author: Joachim Strombergson 
@_subject: ISO rejects WAPI (for now) 
I don't know if you have seen this, but ISO rejected the WAPI standard proposal, opting instead for 802.11i/WPA2.
How terrible, AES instead of the secret sauce-cipher. ,-)

@_date: 2006-03-16 08:00:20
@_author: Joachim Strombergson 
@_subject: ISO rejects WAPI (for now) 
Great, now could anybody please decipher the Chinese-encrypted description? ;-)
On a more serious note, has anybody done any analysis of SMS4 yet? The only thing I could find when Googling was this ISO document related to the fast track-effort. The actual text about SMS4 is rather brief:

@_date: 2006-03-31 07:31:08
@_author: Joachim Strombergson 
@_subject: Your secrets are safe with quasar encryption 
And you better hope the telescope does not point at a pulsar instead:
Or is it perhaps season 54 of the ET version of I Love Lucy?

@_date: 2006-05-04 04:31:23
@_author: Joachim Strombergson 
@_subject: Status of attacks on AES? 
Just out of curiosity I tried to Google around for recent papers on attacks against AES/Rijndael. I found the usual suspects with XLS attacks and DJBs timing attack. But what is the current status of attacks, anything new and exciting?

@_date: 2006-05-04 04:34:53
@_author: Joachim Strombergson 
@_subject: fyi: Deniable File System - Rubberhose 
What you want instead is Truecrypt:
Does what Rubberhose does/did and more. And yes, actively maintained - the latest version was released April 17, 2006.

@_date: 2007-08-14 15:58:09
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: =?UTF-8?B?QU1EcyBuZXcgaW5zdHJ1Y3Rpb25zIGZvciBwYXJhbGxlbGlzbSBhbmQ=?= 
I just saw om EE Times that AMD will start to extend their x86 CPUs with instructions to support/help developers take advantage of the increasing (potential) parallelism in their processors. First out are two instructions that allows the developer to get info about instruction completion as well as cache misses.
Considering the article by . about analysis of protection mechanism against cache based timing attacks for AES [1] one could assume that these instructions should be useful for writing side-channel resistant But, do you think that the opppsite is also possible, that these instructions might be a possible source for information leackage and vector for side-channel attacks, at least local, inter process attacks? I get a weird goodie-badie feeling when reading about these instructions...
[1] Johannes Bl?mer and Volker Krummel. Analysis of countermeasures against access driven cache attacks on AES

@_date: 2007-08-14 22:13:25
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: =?UTF-8?B?UmU6IEFNRHMgbmV3IGluc3RydWN0aW9ucyBmb3IgcGFyYWxsZWxpc20=?= 
Joachim Str?mbergson skrev:
Just wanted to add a reference with info about the AMD announcement of their x86 extensions for parallelism:

@_date: 2007-02-17 14:46:18
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: DESCHALL Classic Client Source Code Released 
Matt Curtin skrev:
Very cool, but the webserver seems to be down.

@_date: 2007-10-11 09:09:07
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: 307 digit number factored 
Nate Lawson skrev:
IANAL but IMHO this is only partially true. Try doing an efficient implementation in HW of ECC and not stepping on Certicom patent toes. SW implementations are probably ok though.

@_date: 2007-09-15 21:12:05
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: using SRAM state as a source of randomness 
Udhay Shankar N skrev:
IMHO a very interesting paper.
But I have a few questions about practical aspects of this (and the paper).
First off I don't see any info in the paper about the time between power cycling and reading the memory. Shouldn't the RNG generated by the memory be affected by remanence problems if the power cycle is to short? I.e if the power off state is to short, the bit pattern from one read operation will contain more of the bit pattern from previous power on (2) How would one go about extracting the fingerprint/ID? As I see it you would either have to do numerous read operations (with power cycling in between) and then extract the fixed bits on a host. That is, the host reads the whole memory (just like in the paper) and from that extract the ID. This means that the RFID-unit will not know it's own ID.
The other way to do it (as I see it), is to do the multiple reads during manufacturing (post production test/configuration), extract the fixed bits and then stor the index to these bits within the RFID chip. This would allow the RFID to assemble the bits and know it's own ID, but then the idea (as presented in the paper) to not have to do post manufacturing work to set the ID is gone.
(3) in the opposite situation to (2), how should the RFID unit avoid the fixed bits when generating a key based on the random bits? Would it be ok to simply run the power on memory state through a cryptographic hash function, ignoring the fixed bits?

@_date: 2007-09-16 17:22:04
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: using SRAM state as a source of randomness 
Peter Gutmann skrev:
One could add test functionality that checks the randomness of the initial SRAM state after power on. But somehow I don't think a good test suite and extremely low cost devices (for example RFID chips) are very compatible concepts.

@_date: 2007-09-24 17:12:39
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: using SRAM state as a source of randomness 
Peter Gutmann skrev:
Ok, apart from the problems with reliable entropy generation. I'm I right when I get a bad feeling when I think about the implications of how the device ID is established.
As I understand it, the device itself doesn't know it's ID. Instead you repeatedly send over mem dumps to the reader which then extracts what it (to some estimated degree) consider to be the correct ID.
Wouldn't a "simple" thing like a challenge response and become much more complicated - and insecure?
Basically the device goes from saying: "I'm ID XYZ and to prove it by providing the following response to your challange", to "I'm an amnesiac device and here are my mem dump", please calculate my ID (please remember to power-cycle me x times) and then I'll send a response."
Also, wouldn't the ID-scheme presented in the paper take a very long time. Transferring 256 Bytes * x times + hamming calc (by the host) vs reading 64 bits (or similar ID length)?
I give the paper plus marks for novelty, but can't see how to use this in a secure, practical and cost efficient way.

@_date: 2007-09-25 08:40:52
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: using SRAM state as a source of randomness 
Leichter, Jerry skrev:
Yes, that is one way to do it - but its not the way they do it in the paper. Doing it your way, that is writing the bit locations for the ID and RNG sources into an index mem on chip, goes against the purpose of the presented scheme. As they write in the paper:
The non-volatile approach involves programming an identity into a tag at the time of manufacture using EPROM, EEPROM, flash, fuse, or more exotic strategies. While non-volatile identities are static and fully reliable, they have drawbacks in terms of the process cost and the area cost of supporting circuitry. Even if only a small amount of non-volatile storage is used, the process cost must be paid across the entire chip area.
One could also argue that if you add the functionality (the non volatile storage) and take the post-production time (and cost) to write down the locations, you could just as well write down a normal ID. (You have the same conclusion futher down in your mail.)
If you do it the way they do it in the paper - communicate the SRAM mem state to an extrnal source to have your ID extracted for you - doesn't that change the ID and authentication protocol?
Nope, again the paper is (pretty) clear that the external reader receives the mem dump and then extracts the ID fingerprint using hamming distance to match the mem dump with a DB of known IDs. This also means that your Class 2 bits (the RNG sources) will be communicated, something that I see as a security problem.
Finally. I have been in contact with the authors regarding their view on rememanence problemns and they simply wait "long enough" to allow remanence effects to be nullified.
But as I see it the device have no way of knowing that "long enough" time have passed. And if it hasn't, communicating the SRAM state might lead to appication information leakage. Correct?
As Peter Gutmann stated earlier in this thread: "RAM state is entropy chicken soup, you may as well use it because it can't make things any worse, but I wouldn't trust it as the sole source of entropy."
Device aging, changes is the manufacturing process, electrical and environmental changes (accidental or deliberately) will all affect the RNG, and there is no easy way for the (low cost) device to know how good or bad quality of the RNG is.

@_date: 2008-12-15 20:28:22
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: CPRNGs are still an issue. 
That is a very good observation. I would bet loads of GM stocks that
very few people realise that moving from 0ld sk00l HDD to SSD would
affect their entropy sources. Does anybode have any idea if this has
been discussed among OS Dev groups?
One could probably do a similar comparison to the increasingly popular
idea of building virtual LANs to connect your virtualized server running
on the same physical host. Ethernet frame reception time variance as
well as other real physical events should take a hit when moving into
the virtualization domain. After all, replacing physical stuff with SW
is the whole point of virtualization.
Does anybody know what VMware, Parallels etc do to support entropy for
sources like this, or is it basically a forgotten/skipped/ignored feature?
Med v?nlig h?lsning, Yours
Joachim Str?mbergson - Alltid i harmonisk sv?ngning.
Kryptoblog - IT-s?kerhet p? svenska

@_date: 2009-02-24 15:22:44
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: SHA-3 Round 1: Buffer Overflows 
I would like to humbly disagree. In case of MD6 the fix meant that a
bugger had to be doubled in size (according to the Fortify blog). This
means that the memory footprint and thus its applicability for embedded
platforms was (somewhat) effected.
That is, secure implementations might have different requirements than
what mighty have been stated, and we want to select an algorithm based
on the requirements for a secure implementation, right?
Med v?nlig h?lsning, Yours
Joachim Str?mbergson - Alltid i harmonisk sv?ngning.
Kryptoblog - IT-s?kerhet p? svenska

@_date: 2010-05-07 23:33:02
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: Attempts at finding a new TCP sequence generator for uIP 
uIP [1] is a very compact TCP/IP stack for small, networked connected,
embedded devices. (The code size for uIP including TCP and ICMP on the
AVR processor is about 5 kBytes.)
Unfortunately, the TCP sequence number generator in uIP is a bit
simplistic - basically a monotonically increasing number. In order to
reduce the opportunities for TCP Spoofing (like this nice one [2]) we
are trying to implement a new TCP sequence number generator.
What we want to find is an algorithm that generates a good (secure) TCP
seq numbers, but use very little resources (on 8-bit computing devices).
We have done some preliminary investigations, have some rough ideas and
would really appreciate comments and suggestions from the enlightened
minds on this list.
As we see it, the two main problems to solve are:
(1) Find a secure PRNG algorithm that have as low implementation
complexity as possible.
(2) Add as little system/application requirements on entropy source and
persistent storage as possible.
Looking at TinyRNG [3] for example, it seems that a block cipher in CTR
mode (or OFB mode) should be sufficient. The question then is what block
cipher to use? The XTEA block cipher [4] is very compact, but would it
be a wise choice from a security perspective?
But what to feed the PRNG with? Looking again at TinyRNG, it uses a
simplistic version of the entropy accumulator from the Fortuna PRNG [5],
but with fewer and smaller pools. The pools are processed using a
CBC-MAC built around the same block cipher as used in the PRNG.
The combined storage for the pools as well as CBC-MAC state would
probably be acceptable for uIP. The question is if the pool feeding
operation as such adds operational requirements on uIP that makes it
harder to integrate?
A simpler scheme could be to feed the PRNG (CTR-mode) with entropy
used as part of Key and IV, that is not use a pool mechanism at all
and leave it to user application to provide entropy words when
performing a reseed. The Key (and IV?) would also consists of a
counter that is monotonically increased.
The problem with this (we guess) is that in order to ensure that KEY+IV
is never reused is to keep at least part of KEY or IV as a counter that
is stored in persistent memory and increased once (and stored) every
time reseed (or boot) is performed. (How bad from a security perspective
would this be? Compared to other TCP sequence generators?)
The current version of uIP places few (basically no) demands on the
system/application regarding physical resources (besides mem for code
and data) and does not use any persistent storage besides code memory.
It seems that any good sequence generator that are driven by physical
entropy and tries to avoid sequence repetition need to place additional
demands on the system. No?
This is basically as far as we have taken this. More or less a bit of
Googling, reading and attempts at thinking. The ambition is not to
invent something new and unproven but to adapt existing tech and ideas
that seem to work. But get it to work with the size, performance and API
constraints of uIP.
Any thoughts, comments, suggestions and pointers would be very greatly
Thank you!
Joachim Str?mbergson
[1] A. Dunkels. uIP TCP/IP stack.
    [1] R. Lawshae. Picking Electronic Locks Using TCP Sequence Prediction
[3] A. Francillon, C. Castelluccia. TinyRNG: A Cryptographic Random
    Number Generator for Wireless Sensors Network Nodes
[4] R. M. Needham, D. J. Wheeler. Tea extensions.
    [5] Wikipedia. Fortuna PRNG.

@_date: 2013-12-04 09:30:00
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] useful data on PFS 
Hash: SHA1
(if it hasn't been mentioned) Qualys SSL Pulse also tracks PFS support:

@_date: 2013-12-21 14:28:29
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] [cryptography] NIST Randomness Beacon 
Hash: SHA1
Or the NIST Randomness Beacon. Anybody tested it with Dieharder yet - or
is it too much of a dead duck anyway to not waste time on it.

@_date: 2013-12-21 14:42:46
@_author: =?windows-1252?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] Chinese Cryptography 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
The Chinese stream cipher ZUC has been accepted by 3GPP as the basis for
the confidentiality and integrity algorithms 28-EEA3 and 128-EIA3 in
LTE. The algorithm was approved by SAGE.
Note that there are constants in the spec for which no real traceability
exists. The amount of info about ZUC is quite meager and quite a few
links are broken.

@_date: 2013-09-05 11:26:22
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] NSA and cryptanalysis 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
(Slightly tangential but on topic I hope)
Am I the only surprised that the NSA designed block ciphers SIMON and
SPECK is vulnerable to differential attacks?
If I understand the history correctly NSA supported the development of
DES as well as SHA-0/SHA-1 and their contributions shows knowledge about
differential attacks at least as far back as 1977.

@_date: 2013-09-05 11:44:10
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] Hashes into Ciphers (was Re: FIPS, 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Isn't this whole discussion basically the gist of DJB vs USA?
And today we have Salsa20 as a PRNG/stream cipher in eSTREAM.
The Salsa family of functions including ChaCha are compression functions
in counter mode to generate a keystream.

@_date: 2013-09-10 12:36:18
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] Seed values for NIST curves 
Hash: SHA1
So, the question is then - how do we fix this?
I (naively) see two approaches:
1. We as a community create a list of curves that we agree on are good.
The list is placed in a document, for example an RFC that clearly states
what criteria has been used, what the sources for the curves are and how
they has been generated. This allows any user to check the validity and
the provenance.
2. Create tools to easily create randomly generated curves including
some tool to assess the goodness/quality.
Either method should (I believe) be possisble to be integrated into TLS
as part of the parameter exchange and negotiation.
If I understand DJB correctly EC as such is sound and provides clear
benefits compared to RSA. We just need curves that have completely
open, traceable and varifiable specifications.

@_date: 2013-09-16 14:16:51
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: [Cryptography] real random numbers 
Hash: SHA1
What Kent is probably referring to is the Fortuna RNG which is a
successor to Yarrow. One difference between Yarrow and Fortuna is the
lack of the estimator in Fortuna.
As Bruce and Ferguson states in chapter 10.3 of Practical Cryptography
(where Fortuna is described in good detail) [1]:
"Fortuna solves the problem of having to define entropy estimators by
getting rid of them."
[1]

@_date: 2013-09-19 09:06:26
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] [cryptography] RSA equivalent key length/strength 
Hash: SHA1
Can't help out with that. But I think that the ECRYPY Yearly Reports on
keylengths and algorithms are a great source for these kinds of
questions. The latest (from 2012) can be found here:
Unfortunately ECRYPY II has come to an end and I'm not certain the
report will be updated anymore. Would be a loss since having updated
estimates on keys and what algorithms to use is really helpful (IMHO).

@_date: 2014-04-07 09:41:09
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: [Cryptography] Statements from ANSI and ISO on Dual_EC_DRBG? 
Hash: SHA256
Has anybody seen any official comments from ANSI and ISO on
Dual_EC_DRBG? Since NIST announced on September 9, 2013 that they
strongly recommended against using Dual_EC_DRBG it would be interesting
to see the reaction and recommendations from ANSI and ISO.
ANSI standardized Dual_EC_DRBG in ANS X9.82. The latest version seems to
be from 2007.
 (paywall)
ISO standardized Dual_EC_DRBG in ISO/IEC 18031. The latest version seems
to be from 2011.
 (paywall)
Standards and paywalls...

@_date: 2014-04-09 15:15:59
@_author: =?windows-1252?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] Preliminary review of the other Applied 
Hash: SHA256
And if we are into the "books in the same field with confusingly similar
names" discourse, Peter Gutmann is working on his big, big, big book
"Engineering Security":
The link points to the latest draft (I think) from April 2013.
The book is made available by PeterG: "This copy is made available to
solicit feedback and help improve the text. I?m particularly interested
in more examples and case studies to use to illustrate points made in
the text, if you have anything to add please get in touch"
Not that the book lacks examples, far from it. The multi page tour de
force of all CA and cert problems through the years is a scary reading.
I guess the next version will include Heartbleed. And he really doesn't
like DNSSEC.

@_date: 2014-04-15 10:13:00
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] Heartbleed and fundamental crypto programming 
Hash: SHA256
I haven't seen anyone in the thread mentioning the Cryptography Coding
Standard effort started by Jean-Philippe Aumasson of Blake, Siphash fame:
Might be a good starting point and probably appreciates comments and

@_date: 2014-02-05 11:24:06
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] Random numbers only once 
Hash: SHA256
A pretty good writeup, thanks! A couple of comments though
 - (nitpick) Dark blue links on black background are _really_ hard to read.
 - In the mixer section you write about push vs pull, i.e. how entropy
enters the mixer. But you don't write anything about how the mixing is
actually done. concatenation, XOR-ing, some sort of hashing etc are
possible methods. Some better than others.
- - Also when talking about mixing entropy from multiple sources you might
want to write something about how to handle entropy from sources with
wildly different capacities. Mixing entropy from RdRand with keyboard or
mouse actions for example.

@_date: 2014-02-07 11:36:01
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] who cares about actual randomness? 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
issue is not if the entropy sources fails and thus the reliability
from random breakdown, The issue is if they have really good, pretty
good or half crappy quality. And if the reduction in quality for a given
source can be caused by an attacker - locally or remotely.
Having multiple and different sources makes it harder for an attacker to
reduce the quality of the overall collected entropy because it requires
the attacker to use several methods of manipulation at the same time.

@_date: 2014-02-07 13:37:45
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: [Cryptography] RAM memories as one source of entropy 
Hash: SHA256
I'm currently involved as pricipal HW designer in a project called
Crypytech, a project that aims of providing a platform for building open
HSMs. Platform in this case includes FPGA hardware design, SW design,
tools, documentation, test framework, guidelines etc.
Using Cryptech anybody should be able to assemble a HSM that they can
trust with high confidence.
One of the key issues is of course the RNG. My very loose ideas for the
architecture of the RNG follows the general multiple entropy sources
with collector, mixer and finally a CSPRNG that is reseeded with data
from the mixer. Something pretty close to what IanG describes here:
The platform should support two or more, different entropy sources and
our example implementation will use two (that is at least what I think
right now).
I would like to be able to have one purely internal entropy source, and
there has been some quite interesting research presented at CHES etc on
entropy sources within FPGAs. But this might not be feasible in a robust
way (too much reliance on layout which would require a lot of testing
for a given FPGA platform.)
For external entropy source PN avalanche noise is a solution. The one
problem I see with this source is that it requires analog circuitry as
well as A/D conversion to achieve the desired effect. This is harder to
build and needs to be tuned to work properly.
The question is then if there are other external sources that could be
used. One wild idea is to use decay effects in DRAM or initial state in
powered up SRAM memories as source of entropy. There has been some
research into this:
[1] [2] [3] As can be seen in the articles, DRAM decay is slower and more sensitive
to device temperature than the SRAM initial condition behaviour. There
are also cells that due to process variance will strongly bias towards a
given state. This is why there are some abilities to extract a
fingerprint for a given physical device by averaging over multiple
readings of the initial state from SRAM memory. But judging by the
papers there seem to be real entropy that could be harvested.
The benefits of using a RAM based source is that the device and
interface is digital making it easy to integrate and would not require
any tuning. Also the device can be compact and cheap. As an example, it
might be possible to use a small, serial connected SRAM memory such as
this sub 1 USD memory:
Reading the contents of the whole memory takes less than 5 us. Gating
the power supply (to switch it on and off) can be achieved for any
number of cycles between readout. The data extracted would the be hashed
using a suitable hash function and the result used as entropy from the
Is using this solution as one of several entropy sources a crazy and bad
idea or somewhat sane? What would be the big caveats and gotchas? If it
is crazy, why is it so?
I'm assuming that the HSM will have active tamper protection and ability
to check its ambient temperature and detect if it has been put in a
freezer. And the SRAM memory used as entropy source would be dedicated
to entropy generation and not used for anything else.
Oh, and how about taking the some output and (possibly via a hash
function) write a random patterns into the memory before powering off,
this eliminate problems of residue patterns between power off-on-cycles.
Bad idea?

@_date: 2014-02-10 11:12:42
@_author: =?ISO-8859-1?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] RAM memories as one source of entropy 
Hash: SHA256
No, there seems to be quite a lot of problems. Esp with remanence and
temperature. Even though the cited papers shows some promise, there are
quite a lot of others that shows other problems. There are actually real
issues with using RAM memories that we will have to consider and design
mitigation solutions to in our Cryptech design.
The paper "Data remanence in semiconductor devices" from 2001 by Peter
Gutmann is a very good and relevant paper. He describes the remanence
effects and specifically points to the problem of having keys in SRAM
memories at fixed positions. This is something we probably should plan
to handle.
Sergei P. Skorobogatov has written several papers on remanence effects
and points to the need to detect that the ambient temperature for the
system to not be lower than a given level. If that happens keys should
be destroyed. This applies for all memories: "Semi-invasive attacks -- A
new approach to hardware security analysis" from 2005 is a good paper:
But Skorobogatov also shows that just temperature detection is enough.
We really should do active zeroisation of memories when a relevant event
has been reached (temperature, breach of tamper protection, unplanned
movement of unit etc.) And external SRAM power supply connection should
be automatically shorted to ground whenever the power is off. Floating
VCC seems to drastically increase remanence.
The paper "Data Remanence Effects on Memory Based Entropy Collection for
RFID Systems" from 2011 by Nitesh Saxena and Jonathan Voris is probably
the most relevant for the discussion of using SRAM as basis for entropy.
The papers shows that the remanence effects are bad enough to make it
impractical to use in RFID tags in which the memory is also used for
other processing. The extraction of enough entropy simply takes too long
time. Esp. when the temperature drops. A good paper.
Finally there are at least some design work being done to implement SRAM
cells with remanence protection. The paper "Security strategy of
powered-off SRAM for resisting physical attack to data remanence" from
2009 describes modified SRAM cells that reduces remanence effects. This
is not very applicable to Cryptech though since we will not be building
ASICs (though someone might use the Cryptech design to do so):
Remanence can even be used as a clock the TARDIS protocol uses decay
memory decay as part of a secure protocol for embedded devices. Really
cool research!

@_date: 2015-10-21 06:58:55
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: [Cryptography] A Riddle Wrapped in an Enigma - Elliptic curves, 
Koblitz and Menezes have posted a very interesting paper to the
Cryptology ePrint Archive.
Abstract: In August 2015 the U.S. National Security Agency (NSA)
released a major policy statement on the need for post-quantum
cryptography (PQC). This announcement will be a great stimulus to the
development, standardization, and commercialization of new quantum-safe
algorithms. However, certain peculiarities in the wording and timing of
the statement have puzzled many people and given rise to much
speculation concerning the NSA, elliptic curve cryptography (ECC), and
quantum-safe cryptography. Our purpose is to attempt to evaluate some of
the theories that have been proposed.

@_date: 2015-09-16 10:30:40
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: [Cryptography] Microsoft's new, free, 
Hash: SHA256
license for the library is a MIT license no less:
Copyright (c) Microsoft Corporation
All rights reserved.
MIT License
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
""Software""), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

@_date: 2017-06-29 11:43:42
@_author: =?windows-1252?Q?Joachim_Str=F6mbergson?= 
@_subject: [Cryptography] OpenSSL CSPRNG work 
Unless FIPS compliance is a hard requirement I would look at ChaCha as
the CSPRNG. (fwiw, we use it in the Cryptech HSM as CSPRNG).
Since ChaCha20 will appear due to TLS 1.3, reuse the same function makes
sense to me. ChaCha provides really good cycles/byte, allow jumping in
the stream, can be parallelized both at quarterround_level and by having
multiple CSPRNGs generating different keystream blocks in the same
If one would like to increase performance on modern 64-bit architctures,
the version of ChaCha by Aumasson called BlaBla might be something to
look at. Very much less analyzed and tested though I assume.
I like the suggestion to have different streams for different processes.
But not sure how much it adds protections compared to the cost of doing
it in terms of context switching.
One thing we have looked at in Cryptech is to reseed with some output
from the CSPRNG. The idea is to extract some values from the csprng and
then keep them until new seed is to be created. The values are mixed
with the entropy from the entropy source (sources). This will make the
new seed depend on values extracted, created at different times. This
makes it much harder for an attacker to cause an expected effect on the
seed by attacking the entropy source prior to reseeding.
Just a thought.

@_date: 2018-05-17 12:26:20
@_author: =?UTF-8?B?Sm9hY2hpbSBTdHLDtm1iZXJnc29u?= 
@_subject: [Cryptography] Vulnerability found in badly broken email apps 
Unfortunately, it seems Postbox users (a version of Thunderbird) no
longer supports 3rd party add-ons. Thus users are stuck with Enigmail 1.2.
I guess I should take that as a sign to switch mail program.

@_date: 2019-01-11 09:03:36
@_author: =?UTF-8?Q?Joachim_Str=c3=b6mbergson?= 
@_subject: [Cryptography] Government shutdown: TLS certificates not 
Also, not due to TLS certificate issues, but the shutdown itself, access
to things like standards and publications by NIST are unavailable. For
example SP 800-38B (CMAC):

@_date: 2019-09-12 09:54:31
@_author: =?UTF-8?Q?Joachim_Str=c3=b6mbergson?= 
@_subject: [Cryptography] TRNGs as open source design semiconductors 
The Cryptech project includes totally open designs for two separate
entropy sources (TRNGs) as well as a complete random number generator
that is driven by the entropy sources.
The first entropy source is a classic avalanche noise based source
implemented using simple, discrete components. There are PCB designs for
a version on a separate module (which was used on the Novena), as well
as a version integrated onto the Cryptech Alpha board.
The second entropy source is based on digital ring oscillators similar
to what has been discussed here previously. This entropy source is
intended to be implemented in FPGAs and ASICs. The entropy source
contains 32 free running digital oscillators which are sampled and
combined after a number of cycles (currently 256, if I remember
correctly). The design also includes support for whitening/conditioning.
The second source has been tested in several different FPGAs from
Altera/Intel, Xilinx and Lattice.
The complete random number generator extracts entropy from both sources
to update a seed generator based on SHA-512. The generated seeds are in
turn used to initialize the ChaCha based DRBG.
The entropy sources as well as the whole chain has been extensively
tested by the Cryptech project as well as third parties. And since the
design is totally open, others can do at will too.
I'm happy to answer any questions about the generator as well as the
Cryptech project.

@_date: 2020-04-02 08:02:09
@_author: =?UTF-8?Q?Joachim_Str=c3=b6mbergson?= 
@_subject: [Cryptography] Open hardware RNG design: Hector, Cryptech, 
(Joachim from the Cryptech core team here.)
Cryptech uses two entropy sources in parallel. One outside of the FPGA
is based on avalanche noise. The second inside the FPGA is based on
jitter between 32 free running digital oscillators. The specific core
for the rosc can be found here:
Entropy collected from the two sources are mixed using SHA-512 to create
seeds for a CSPRNG based on ChaCha.
All cores used in Cryptech, including the whole RNG chain is open under
BSD license. If I may take the opportunity, the new Modexpng cores for
example provides state of the art RSA acceleration, allowing the
Cryptech Alpha to match and exceed performance provided by commercial HSMs.
Sure you can, and it should be quite easy. The avalanche_noise design
has been copied over to other designs without any problems. There are
KiCAD designs for the complete Cryptech Alpha including the noise
source. There are also a separate design by Fredrik Thulin for a board
with a STM32 and the noise source.
I'm happy to try and answer any questions regarding the Cryptech design.

@_date: 2020-04-02 08:12:10
@_author: =?UTF-8?Q?Joachim_Str=c3=b6mbergson?= 
@_subject: [Cryptography] Open hardware RNG design: Hector, Cryptech, 
Building TRNG, random generators that you connect via USB seems quite
popular. Here are a few more open designs

@_date: 2020-02-17 20:51:25
@_author: =?UTF-8?Q?Joachim_Str=c3=b6mbergson?= 
@_subject: [Cryptography] 'The intelligence coup of the century' 
The Tempest for Eliza from just around the millennium is a great tempest
I haven't tested it for many years, would be interesting to know if it
works with more modern screens.

@_date: 2020-03-03 10:53:39
@_author: =?UTF-8?Q?Joachim_Str=c3=b6mbergson?= 
@_subject: [Cryptography] Ex-CIA Joshua Schulte Describes His Data/Crypto 
Since quite a few years HDDs have platters made out of glass
manufactured similar to ingots, with tightly controlled crystal structures.
If stuck by a hard point (for example a ball pen hammer) they usually
turn into glass powder. The big risk is probably inhaling the remnants
of the disc. Data recovery less of a problem.
SSDs are of course a whole other can of worms.
