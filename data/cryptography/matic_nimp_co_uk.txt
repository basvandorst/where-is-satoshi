
@_date: 2015-09-01 10:50:18
@_author: matic@nimp.co.uk 
@_subject: [Cryptography] mode of operation for file encryption 
I need an operation mode for AES with the following properties:
1. secure (ie. not ECB)
2. allow to do both encryption and decryption on blocks taken in a random order (ie. not CBC, CFB, OFB, PCBC)
3. not involving a nonce (ie. not CTR)
4. fast, especially when done in software running on PC / smartphone kind of platform:
  a. ideally a single AES per data block
  b. ideally always using the same key to save the key schedule effort (that is a saver at least on intel CPUs)
... kind of demanding!
On the bright side:
- a fix amount of data can be attached to the Cipher text if that can - no specific requirement with regards to error propagation or authentication (well, for the time being)
- don't mind to have extra key material (without going to the extreme of things like one time pad...)
So far the best thing I can think of is a kind of extended ECB which I would call "ECB with xor" or ECBX:
C = Ek(P xor IV xor BlockIndex)
P = IV xor BlockIndex xor Dk(C)
P is a block in the Plain text
C is a block in the Cipher text
IV is a 128 bit number attached to the Cipher text
BlockIndex is the index of P in the Plain text or C in the Cipher text, coded on 64 bits
Ek is AES128 encryption with the key "k"
Dk is AES128 decryption with the key "k"
The application is file encryption done on the fly in a virtual file system (the encrypted files are backed up in the cloud, the files are decrypted only locally on the end user machine). The bad guys have access to the Cipher texts only, they may be able to submit chosen plain text but in any case the IV is not under their control and would be chosen at random each time a file is created or overwritten completely.
Any alternative, reference to published stuff or criticism would be highly appreciated.
I could go for XEX, but I would like to have a good motivation to justify the additional GCM operation.

@_date: 2016-09-18 21:55:50
@_author: sebastien riou 
@_subject: [Cryptography] True RNG: elementary particle noise sensed with 
"Shrinking entropy sources comes from (a) better circuits and (b) better
extractor theory"
Could you point to some litterature ?

@_date: 2018-01-04 22:00:41
@_author: sebastien riou 
@_subject: [Cryptography] Is LMDPL method against DPA attacks patented? 
Many companies design DPA resistant AES cores: NXP, Infineon, Samsung, ST,
and many more.
Few companies sell DPA resistant AES cores as standalone IPs, just visit
- soft IPs (IPs delivered as RTL) are NOT a desirable delivery, you are
much better off if you get a synthesized netlist generated by the provider.
The best is to get a hard macro.
- typically you need side channel protection all the way from key storage
to the AES. So a secure AES is not enough...
Finally some companies sell entire "secure element" IP: something which
manage and protect the secret keys, compute AES and optionally other crypto
algorithms. If that's of interest you can contact web-contact at tiempo-
secure.com (disclosure: I am working there).
If you think about making "gate level masking" yourself, consider the
- Merely using random bits in an AES is usually enough for CRI (Rambus) to
call and say that you potentially infringe several of their zillion patents.
- It is a huge effort if you are targeting ASIC, you are almost certainly
better off buying an IP.
- If you target an FPGA, you will probably succeed... after many iterations
and learning the details of the FPGA fabric inside out. Definitly a fun
Best regards,

@_date: 2018-01-10 12:32:26
@_author: sebastien riou 
@_subject: [Cryptography] Propagating Cipher Block Chaining (PCBC) 
Wikipedia mention a weakness of the Propagating Cipher Block Chaining
(PCBC): "On a message encrypted in PCBC mode, if two adjacent ciphertext
blocks are exchanged, this does not affect the decryption of subsequent
I would like to know if there is any other known weakness:
- weakness on the confidentiality property
- weakness on the error propagating property

@_date: 2018-06-30 21:19:27
@_author: sebastien riou 
@_subject: [Cryptography] attacks on public keys 
============================== START ==============================
Literature on fault attacks on signature generation to recover private keys
is plentiful. When it comes to fault attacks targeting signature
verification, literature is scarce and rather old:
- RSA public key: - DSA/ElGamal, "Fault Attacks on Public Key Elements: Application to
DLP-based Schemes"
( available here:
For RSA, the 2005 attack is practical it may be as good as it gets. Besides
generic fault attack countermeasures, is there any good countermeasure
against this ?
For DSA, the authors conclude that attacks exist but not practical as is.
This was 10 years ago, is anyone aware of some progress ?

@_date: 2019-04-18 18:41:15
@_author: sebastien riou 
@_subject: [Cryptography] NIST announced Round 1 candidates for lightweight 
Any feedback on "*DryGASCON"* and its outrageous security claims would be
greatly appreciated.

@_date: 2019-06-09 22:57:25
@_author: sebastien riou 
@_subject: [Cryptography] Minimal secure boot 
I am looking for a minimal secure boot scheme, with 128 bit security level.
The target device has a 16bit CPU, RAM in the KBytes range and the code
size is critical (this is supposed to go in ROM and its already full...).
What I am considering so far:
- Generate an RSA2048 key pair
   - d: private exponent
   - n: modulus
   - e: public exponent
- store n and e in the ROM
- at build time:
   - digest = sha256 over the code
   - sig = mod_exp(digest,d,n)
   - append sig to code
- at boot:
   - get code and sig
   - digest = sha256 over code
   - expectetd = mod_exp(sig,e,n)
   - launch code only if digest == expected
Any issue with that ?
Now I am wondering if I need:
   - e larger than 3 ? if yes what is the sensible minimum ? I am inclined
to set e=11 to get (digest power e) > n but I do not have really clear
argument for that.
   - padding the digest before the mod_exp
I will be the only one knowing the private key and I won't sign any third
party code, so chosen plaintext attacks are not a worry.
I am not concerned by attacks where the same thing is signed by multiple
keys either.

@_date: 2019-06-11 21:31:46
@_author: sebastien riou 
@_subject: [Cryptography] Minimal secure boot 
Thanks for the advices. This is going to a ROM code, this is not general
purpose nor updated carelessly by random guys, so I am willing "to take
care" if that saves few bytes in my code and/or improves performance.
I like e=3 very much, with that I could hardcode the main loop to do 2
identical iterations, saving both code size and execution time.
On the padding I don't like OAEP because of the increased complexity which
will increase code size.
For now I settled for PKCS1_1v5 following
 (with padding hardcoded for SHA256). Of
course I will switch immediatly to OAEP if there is a compelling reason to
do that, but my understanding is that PKCS1_1v5 is good enough for my
So my question can be reformulated as follow: what I would have to ensure
to be safe with e=3 and PKCS1_1v5 ?
- I can take care of not signing the same plaintext with two different keys.
- I can take care of not signing anything coming from a third party.
Is there something else to take of ?

@_date: 2019-06-13 00:34:36
@_author: sebastien riou 
@_subject: [Cryptography] Minimal secure boot 
That's precisely what I am trying to find out
If you came to us and explained that you were going to use exponent 3,
That's what I intended to do but apparently I failed :-( I try again below.
Thanks for the long answer, it is very much appreciated.
The scheme:
- a RSA2048 single key pair is generated, with 5 as public exponent.
- The public key is written in the ROM code of a microcontroller product.
- At boot, the microcontroller get software image via UART and use RSA with
PKCS v1.5 and SHA256 to verify its authenticity.
- Secret key is used exclusively to sign software images
- Any given software image is signed exclusively with this secret key
- software images are generated exclusively by us, there is no "malicious"
software image that ever get signed
Some notation used in the rational:
- Generate an RSA2048 key pair
   - d: private exponent
   - n: modulus
   - e: public exponent, fixed to 5
- store n and e in the ROM
- at build time:
   - digest = sha256 over the software image
   - c = PKCS1_15_pad(digest)
   - sig = mod_exp(c,d,n)
   - append sig to code
- at boot:
   - get code and sig
   - digest = sha256 over software image
   - expected = mod_exp(sig,e,n)
   - launch execution of software image only if PKCS1_15_pad(digest) ==
The rational:
- Use 2048 bit key and SHA256 to achieve 128 bit security level.
- public exponent e=5:
   - as indicated by Jon, 3 leads sometimes to weak keys, 5 does not have
this problem
   - "Coppersmith attack" is not a worry since we sign an image only with
one key
   - "Franklin-Reiter Related Message Attack" is not applicable since the
"message" here is sig and its values for different software images are
completely unrelated due to SHA256.
   - Not sure if the "Coppersmith's Short Pad Attack" is applicable,
considering digest as the "short pad" (not clear if the pad value is
recovered by the attack). Even if it does, it would not work because digest
length is 256bits, so longer than len(n)/(e power 2).
   - "partial key exposure attack" is not a problem, the secret key is not
in the device and kept in a HSM in a secure room
   - since we use padding method, we always have "sig power e" greater than
the modulus n.
- static padding scheme:
   - "Bleichenbacher attack" (
does not apply as it is a chosen cipher text attack.
   - "Coron and al attacks" (
 do not apply as
they are chosen plain text attacks.
Any pointer to other potential attacks would be appreciated. Incorrectness
in all things above even more so.

@_date: 2019-05-09 21:16:36
@_author: sebastien riou 
@_subject: [Cryptography] What is missing today, 
No matter if one trust NIST or not, one has to admit the following point:
As of today there isn't a well reviewed AEAD+hash primitive optimised for
IoT edge devices
By IoT edge devices I mean:
- RAM in the single digit KBytes
- exposed to the threats of physical attacks (EM side channels, glitch or
laser fault attacks...)
libsodium does not solve the issue: chacha is ARX, ARX is costly to secure
against side channel attacks (not talking about trivial timing/cache
attacks here, EM side channel attacks is the problem. Bertoni and al. wrote
something about it ( Having worked
on the issue for more than a decade, I very much confirm this fact.
Basically AES is hard to secure against EM side channel and anything ARX is
harder.(hard here is short for "large area, high power consumption, low
It is somewhat ironic that all crypto standardized so far is mostly
optimized for running on servers conveniently protected against physical
attacks and that ressource constrained devices, which are far more cost
sensitive and numerous, have to follow.
NIST finally recognized this and did the right thing: launch an open
competition which takes into account the contraints of the low end, most
exposed devices.
Crucially, unlike the CAESAR competition, they will take into account:
- the possibility to get AEAD and hash from the same primitive
- the ease to protect against physical attacks
CAESAR competition also have another limitation: it selected 7 winners
instead of 1 like AES or SHA-3 competitions. Selecting a single winner is
crucial for adoption, the 7 winners of CAESAR are never going to end up in
a hardware accelerator, implementing 7 small primitive instead of AES
defeats the point (and implementers don't choose a winner nor the customers
who just know they want "security" without accepting any additional price
In short, this competition is good news for anyone careing about security
outside the cloud and secure rooms.
Most submissions to this competition are most likely completly independant
from NIST/NSA/KGB and friends (at least that's the case for DryGASCON and I
trust it is also the case for ASCON and ISAP).
