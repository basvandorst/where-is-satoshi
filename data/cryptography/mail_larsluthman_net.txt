
@_date: 2013-12-11 21:42:24
@_author: Lars Luthman 
@_subject: [Cryptography] Size of the PGP userbase? 
It depends on what you mean by userbase, of course. There are plenty of
people who use it every time they install software upgrades if they use
Debian or some other operating system that signs and verifies packages
using GPG, but most of them are probably not even aware of that.
This page has some numbers on the strong set of PGP keys, i.e. the
largest set of keys where every pair is connected by a path of valid
signatures:  . Right now the strong set is a
bit over 50,000 keys. But this will include a lot of keys that are
abandoned or never used, and exclude everyone who either don't publish
their keys on the keyservers, don't publish the signatures they collect,
or simply don't bother with signatures at all but just verify keys

@_date: 2013-12-23 19:10:26
@_author: Lars Luthman 
@_subject: [Cryptography] Passwords are dying - get over it 
But how much key stretching do you want? Even with a billion rounds you
don't add more than ~30 bits of work, which is less than what you get by
adding three more words to a Diceware-like passphrase using a dictionary
with 2000 words.

@_date: 2013-10-11 02:30:30
@_author: Lars Luthman 
@_subject: [Cryptography] prism-proof email in the degenerate case 
This is starting to sound a lot like Bitmessage, doesn't it? A central
message stream that is split into a tree of streams when it gets too
busy and everyone tries to decrypt every message in their stream to see
if they are the recipient. In the case of BM the stream is distributed
in a P2P network, the stream of an address is found by walking the tree,
and you need a hash collision proof-of-work in order for other peers to
accept your sent messages. The P2P aspect and the proof-of-work
(according to the whitepaper[1] it should represent 4 minutes of work on
an "average computer") probably makes it less attractive for mobile
devices though.
[1]

@_date: 2014-05-17 21:40:37
@_author: Lars Luthman 
@_subject: [Cryptography] Are there other anonymous key exchange 
Any public key encryption algorithm can be used for key exchange, the
trivial generic method is to have each party generate a random bit
string, encrypt it to the other party's key, send it, receive the other
encrypted bit string, decrypt it, and compute the master secret as a
hash of the XOR of both bit strings. Forward secrecy simply means that
you generate a new keypair for every exchange.

@_date: 2015-01-30 19:46:59
@_author: Lars Luthman 
@_subject: [Cryptography] Wrong uses of filesystem encryption 
Well, yes - if someone can guess your login password, and your
filesystem is mounted automatically when you login using some PAM-like
mechanism, then they get access to your encrypted files if they have
access to the unencrypted storage. That doesn't make it useless since it
still protects you against anyone who _can't_ guess your login password,
which is hopefully a pretty large group of people.
And if you trust the password management of the filesystem encryption
software more than you trust the one in your operating system, then the
obvious choice is to use full disk encryption and autologin instead of
manual login and automatic mounting. You still only type one password
when you start the computer.

@_date: 2015-05-06 23:06:30
@_author: Lars Luthman 
@_subject: [Cryptography] Is there a good algorithm providing both 
Wouldn't such an algorithm suffer from the same problem as using a block
cipher in ECB mode? That is, an attacker would be able to infer parts of
the structure of the plaintext by looking at repeated symbols in the
output (in this case compressed_text).
Assuming that different references in compressed_text to the same word
in compression_dictionary are recognisable as referring to the same word
for someone without access to the plaintext compression_dictionary, of
course. But if you are reasonably sure that they aren't you have
essentially encrypted compressed_text as well.
