
@_date: 2015-09-23 00:11:01
@_author: Davy Durham 
@_subject: [Cryptography] Non-Authenticated Key Agreement 
Okay, so I've lurked on this list for a couple of weeks and wasn't sure if it was a safe place to propose crypto ideas, but given the recent threads, and the plethora of friendly discuss, I feel that I can do this :)  And, I agree with Rule  of crypto, namely not to invent your own.  But I think the unstated rest of that thought is "... and then to put it into practice without gobs of scrutiny". Since I'm not doing that, here I'm no crypto expert.  I've dabbled, used libraries, read a bit and taken an online course or two (Dan Boneh is awesome!).  But the following occurred to me, and I'm initially just curious if it has been described before, does it have a name.  And if its original, and if truly has the properties I believe it has, the next question is what value it might have in practice.  I've googled around quite a bit and haven't seen it described.
It's so simple, it's either been thought of and discarded out of hand (for reasons I don't yet realize) or else perhaps the 'big brains of crypto' were just too distracted by more advanced topics to notice it.
Consider the following for a non-authenticated key agreement mechanism that does not involve any complex math (beyond a [P]RNG) and requires no previous knowledge between the parties...  Further, I believe it has all of the good qualities of DH and the same number of steps in a ladder diagram, but remains much simpler in concept and implementation.
Given an encrypt (and decrypt, for that matter) function based the one-time pad idea:
     E(d, k) = d xor k
     Where:
         - d is data given to encrypt
         - k is the one-time pad key to encrypt with
             - k is at least as long as d.
             - k is ephemeral, i.e. it is picked at random each time the algorithm is used
Notice the obvious property of E:
     E(E(d, k1), k2)   is bit-equivalent to   E(E(d, k2, k1)
Alice wishes to send Bob a piece of information d.  Alice and Bob have not exchanged any information previously.
Alice makes up a random key, ka, and Bob makes up a random key, kb.
The following sequence diagram allows Alice to send d to Bob while the d remains protected from eavesdropping in between.
        Alice Bob
    d = data
    ka = random bits
    d' = E(d, ka)
                              d'
           ---------------------------------------->
                                                   kb = random bits
                                                   d'' = E(d', kb)
                              d''
           <----------------------------------------
    d''' = E(d'', ka)
                              d'''
           ---------------------------------------->
                                                   d = E(d''', kb)
At this point, by having taken advantage of the property of E pointed out above, Bob now has the value of d that Alice originally wanted Bob to know.
Considering that d could be a symmetric key, Alice and bob could continue a conversation using standard methods.
Assuming it hasn't been proposed before, is it useful?
The method described above is protected against eavesdropping, but it is vulnerable to an active man-in-the-middle.  As a middle party, Mallory, could insert herself in the insecure communications channel and Alice wouldn't know that she initially communicated with Mallory instead of Bob.
It appears to have the same security properties as Diffie-Hellman, and would seem to have some value in practice anywhere DH is used (e.g. in combination with other methods for authentication like ECDHE uses DH or STS uses DH).  However, this method's computation would appear to be less expensive than DH (if generating the random bits for the keys is cheaper than computing the DH parameters) and is conceptually as easy to understand as the one-time pad.  And DH is only as strong as the the computation is difficult to reverse but this method uses the perfect secrecy property of the one-time pad and is thus as good as the keys, ka and kb, were random (assuming MiM is prevented by its use in combination with other things)
Your thoughts?

@_date: 2015-09-23 22:36:23
@_author: Davy Durham 
@_subject: [Cryptography] Non-Authenticated Key Agreement 
Yep.  Thanks [all you] guys. I knew I was probably missing something.  None of my offline friends caught it either.  :)

@_date: 2016-01-27 00:24:30
@_author: Davy Durham 
@_subject: [Cryptography] cms with multiple signatures 
Hopefully, this won't be terribly off topic, and maybe those playing with the standards have run into the same problem in the past...  I have searched high and low for some open source tool (running on linux here) that can generate cms/smime/pkcs7 messages with multiple signatures, but without much success.
1) *OpenSSL*'s smime/cms documentation says it supports it, but the same page says it's not allowed (just search for "multiple" in the docs for either of the cms or smime commands).  I have managed to get it to sign a file and the signature contains multiple certs (either by using -resign or -sign with two -signer args), but when I dump the signature data it seems to be missing some parts of either chain.    Maybe that's fine, but openssl fails to validate the signed content with either cert used to sign it (It gives a 'self signed certificate' error (and the two certs I'm experimenting with are) even though I can sign and verify with either of the two certs when not trying to sign with both at the same time.. but I've seen other errors too when using a chain instead of a 2) *gpgsm* (gog's smime variant) from what I can tell should support it, but I've yet to find a system (tried several now) where it can even generate a key without complaining about some error.  Or when trying to import certs & keys, it keeps saying it's importing the private keys successfully, but they don't show up with --list-secret-keys.  That's just one of the problems.  And when searching on the interwebs for help, I find other's with the same problem but no one ever seems to answer the questions.  Also I'm finding that some of the docs are missing information on what it can really do. I get the feeling that it's been neglected as a project.
3) *nss*'s cmsutil doesn't seem to support multiple signatures (from looking at the code), and when I try to use its signver utility to verify the file that I did manage to get openssl to generate, it just hangs.
Assuming I'm actually using these tools at intended, but that they're buggy, are there other lesser known options out there that anyone can speak to?  AFAICT using the openssl or nss libs and writing my own command line tool might be the only option I have.  I was hoping someone had done that already.  But then again I'm not sure how good the support in either of these libraries is.
I also scanned through github projects without seeing anything promising.
I've yet to attempt to explore  java options.
Any pointers would be appreciated.

@_date: 2016-01-28 09:21:28
@_author: Davy Durham 
@_subject: [Cryptography] cms with multiple signatures 
Update: So I had an assumption which was wrong when I was testing OpenSSL.  I can get openssl to add multiple signatures (however it strangely includes the whole chain (with 3 elements in chain) for one sig but leaves out the root in the second one ???), I was assuming that when I did the verify that it should verify if any of the signatures were valid, but it apparently checks that they are /all/ valid.  That is, when I verified I was only giving it the root of one of the signatures and not both.  When I gave it both root certs in the -CAfile argument it passed.
So that raises the question: Is that correct?   I checked RFC 5752 (around section 4.6 and following) but it wasn't clear to me exactly how it should work.  And it sounded like there might be a variety of possibilities many of which openssl cms doesn't do.    And in another place it sound like it might ought to be application specific.
I was hoping that it was possible to sign in such a way that any of the signatures being valid was considered successful (not nesting signatures here, but signing independently, in parallel).  If that's what I need then I'm guessing I need to do multiple detached signatures and just verify them as I need.
Thanks for the info.
As for -resign: Running "openssl cms -sign" once given two -signer and -inkey args, and running "openssl cms -sign" followed by "openssl cms -resign" both produce files which verify (only when given both roots), they produce slightly different output.  The only difference I can spot in the asn1 (other than some reordering) is that the former has a single signing time field.  I guess that makes sense.
