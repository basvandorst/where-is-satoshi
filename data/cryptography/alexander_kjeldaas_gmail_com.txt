
@_date: 2014-12-06 10:35:48
@_author: Alexander Kjeldaas 
@_subject: [Cryptography] Fwd: Underhanded Crypto 
To me this is pretty simple if you think in terms of types.  Yes, sometimes
you want to invoke undefined behavior, unusual behavior or poke beneath the
common abstractions.  That in itself is not the problem. When you do so,
you use an interface so you can inform the compiler, the programmer, the
reader, tools like Purify, valgrind etc. about what you are doing.
Thus Purify, valgrind etc are correct in flagging this as evil.  They have
a more advanced type system in certain cases than what C has.
A programmer or a reader can be informed using a comment, but the other
tools typically use functions and types as the way to build interfaces.
Thus reading from uninitialized memory is a two step process.  First you
invoke a function that coerces the uninitialized memory into initialized
memory.  It could be something like, say  "void *treat_as_initialized(void
In the Purify or valgrind type system, this will read as   "void
initialized *treat_as_initialized(void *)".  I'm making up the syntax, but
this is fundamentally about types and types are what gives assurance,
security, and what makes it possible to analyze software.
Thinking about it this way makes it obvious that just invoking undefined
behavior inside of a function is really bad systems design, both from a
theoretical perspective and for maintainance.  Likewise if the software
fiddles behind the GC curtain, fiddles with the bytecode interpreter,
updates the CPU microcode in the middle of a function etc.  Properties
should be expressed as types, and if the language does not support
expressing those properties as types, express them as functions /

@_date: 2014-10-27 12:51:06
@_author: Alexander Kjeldaas 
@_subject: [Cryptography] SPHINCS: practical hash-based digital signatures 
TLS can re-use sessions, and re-use cached information, so this overhead
can be negligible.  Large signatures will just adjust the trade-off,
favoring session re-use and caching. Even without session-reuse, 2 of the
certificate chain hashes described above can be cached indefinitely on the
client, which means the number of DNS requests is an absolute upper bound
on this traffic.
For example  could
be used.
Btw, the same approach makes sense for the transfer of the SCT in your CT
Further, for HTTP/2.0 the web will get longer sessions, so handshake
overhead should means less.
Re-sending static information in the TLS handshake is inefficient and makes
no sense, and designing with that as a fundamental limit to the design
space is simply not necessary.
Having a signature scheme that is hard to implement incorrectly and that is
quantum-computer secure seems like an obvious win.

@_date: 2016-05-01 20:40:51
@_author: Alexander Kjeldaas 
@_subject: [Cryptography] sha1sum speed 
Yes, it's actually significantly slower than Blake 2b, in Javascript, in

@_date: 2016-11-25 08:55:57
@_author: Alexander Kjeldaas 
@_subject: [Cryptography] Use of RDRAND in Haskell's TLS RNG? 
RDRAND is a marker that indicates which registers should be tagged,
followed, and later modified by malicious circuits.
So while using OS sources might add attack surface, so does having RDRAND
being the last source to mix.
Does extractor theory deal with this threat model?

@_date: 2017-01-20 23:45:59
@_author: Alexander Kjeldaas 
@_subject: [Cryptography] Cryptocurrency Exchange without a trusted third 
The reputation capital can also be audited, so the calculation for whether
it makes sense for the TTP to cash in is open.
Thus there might be times when the TTP cannot be trusted, like in
fractional banking if the fraction is too small.
Of course in reality, the TTP will be entrenched like in banking, so it
wouldn't work.  But in theory..

@_date: 2017-09-25 08:01:41
@_author: Alexander Kjeldaas 
@_subject: [Cryptography] After Equifax pwning, 
Maybe I'm misunderstanding, but isn't this fairly easy?  Just invent a fine
for companies that use SSN as an authentication mechanism.  Or any
identifier that is knowingly public, including having been made public by a
security breach.
If I used the public corporate registration number for Apple as
authentication trying to get a loan I'd get laughed out of the room.  But
not if I used someone's SSN ¯\_(ツ)_/¯

@_date: 2020-12-20 10:33:31
@_author: Alexander Kjeldaas 
@_subject: [Cryptography] Am I missing something about CBDC ? 
The point is to have money with no counter party risk.  If you can have
that,  then we can get rid of government insuring deposits of commercial
banks.  Then we can let banks fail more easily.
Banks can still do payments, but need to settle MY money once a day like
they do with each other.
