
@_date: 2004-07-28 11:15:16
@_author: Michael_Heyman@McAfee.com 
@_subject: dual-use digital signature vulnerabilityastiglic@okiok.com 
Replies to this talked about business cases to have control of the
private key not only under the identity upheld by the certificate.
I would like to point out that whether or not a CA actually has the
private key is largely immaterial because it always _can_ have the
private key - a CA can always create a certificate for Alice whether or
not Alice provided a public key.
Whether or not Alice has complete control over her private key makes no
difference to Bob. If the CA works properly, Bob and Alice can have a
authenticated and private communications. If the CA is compromised (or
inherently malicious), Bob will think he is having authenticated and
private communications with Alice but will actually have it with an
agent of the CA's choosing. This is the way the system was designed. Bob
trusts the CA to provide for authenticated and private communications
with Alice.
<2 cents>In the business cases pointed out where it is good that the
multiple parties hold the private key, I feel the certificate should
indicate that there are multiple parties so that Bob can realize he is
having authenticated and private communications with Alice _and_ Alice's
employer. X.509 does not provide a standard way to encode multiple
-Michael Heyman

@_date: 2004-11-05 07:20:24
@_author: Michael_Heyman@McAfee.com 
@_subject: Your source code, for sale 
Quick fix for seller incentive: the seller rips some amount of their own
cash in such a way that they cannot recover it unless the buyer provides
the remainder of the buyer's ripped cash.
-Michael Heyman

@_date: 2005-02-22 14:58:06
@_author: Michael_Heyman@McAfee.com 
@_subject: Adi Shamir "timing attack" quote 
In the "Gates not his cocky self at RSA conference" Roger Smith article,
the author says:   [Adi Shamir] cautioned that many of the current generation of   Intel processors that use multi-threading and multi-core   technology seem to be vulnerable to timing attacks that can   use unprivileged threads to find keys stored in their caches.
I hadn't known that one process could read the memory of a second
process running on a different hyper-thread or a different core through
a cleverly timed cache hits (which is what I think this sentence says).
Does anyone have further information on this or mitigation strategies?
-Michael Heyman

@_date: 2005-01-06 20:30:59
@_author: Michael_Heyman@McAfee.com 
@_subject: entropy depletion (was: SSL/TLS passive sniffing) 
I see much misunderstanding of entropy depletion and many misstatements
because of it.
It is true you don't know what the internal state is but the number of
possible internal states tends to reduce with every update of the
internal state. See "Random Mapping Statistics" by Philippe Flajolet and
Andrew M. Odlyzko (Proceedings of the workshop on the theory and
application of cryptographic techniques on Advances in cryptology,
Houthalen, Belgium, Pages: 329 - 354, year 1990) for a thorough
discussion. The jist is that a well behaved state update function for a PRNG will
have one very long cycle. This cycle will be shorter than the number of
possible values that the state can hold. States not on the cycle are on
branches of states that eventually land on the cycle. Flajolet and
Odlyzko go on to show that the expected cycle length for a 1000 bit
state will be around 2^500 iterations.
So, you start your PRNG by filling the state with 1000 bits of real
entropy. You have 2^1000 possible states. You use your PRNG and update
the state. Now, there are a certain number of states that the PRNG
cannot be in. After one state update, the PRNG cannot be in the states
at the ends of the chains of states branched off from the aforementioned
cycle. This means that, after one state update, you have slightly less
than 1000 bits of entropy. When you update the state again, you now have
more states that the PRNG cannot be in, thus reducing your entropy
again. Every time you use your PRNG, you reduce your entropy in this way
and you keep on doing so in an asymptotic way until, after many many
iterations, you are close enough to 500 bits that you don't care
In the real world, our PRNG state update functions are complex enough
that we don't know if they are well behaved. Nobody knows how many
cycles exist in a PRNG state update function using, for example, SHA-1.
You run your PRNG long enough and you may actually hit a state that,
when updated, maps onto itself. When this occurs your PRNG will start
producing the same bits over and over again. It would be worse if you
hit a cycle of 10,000 or so because you may never realize it.
I don't know of any work on how not-so well behaved PRNG state update
function lose entropy. I figure the state update functions we as a
community use in what we consider to be well designed PRNGs probably
have multiple long cycles and maybe a few scary short cycles that are so
unlikely that nobody has hit them. I don't even know what multiple
cycles means for entropy.
Because of the lack of knowledge, cryptographic PRNGs have more state
than they probably need just to assure enough entropy - at least that is
one thing I look for when looking at cryptographic PRNGs.
-Michael Heyman
