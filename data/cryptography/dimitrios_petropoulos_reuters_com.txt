
@_date: 2001-07-03 15:17:24
@_author: Dimitrios.Petropoulos@reuters.com 
@_subject: Sender and receiver non-repudiation 
The problem you are referring to is known as 'selective receipt' (where a party acknowledges only messages it wishes) and generally there are two ways to overcome it:
a. make use of an incremental disclosure protocol over many rounds where in each round some knowledge about the message and the receipt acknowledgement are transmitted. If any party aborts the execution of the transaction prior to completion then both parties have comparable information (one party has an incomplete message and the other an incomplete receipt acknowledgement). This method however suffers from the fact that requires many rounds and also assumes the two parties have equal computational power.
b. make use of a TTP that is somehow involved in the message exchange and guarantees the production of evidence about the actions that have taken place. Such TTPs can be:
- inline, where all communications between the two parties go through the TTP
- online, where production of evidence requires the TTP to be online for the duration of the transaction, but communication between parties does not take place via the TTP
- offline, where the TTP does not need to be present during the execution of the transaction but is otherwise somehow involved, e.g. a Certification Authority
You might want to take a look at the following (by no means an exhaustive list):
1. ISO/IEC 10181-4. Information technology - open systems interconnection - security frameworks for open systems, Part 4: Non-repudiation framework, 1997.
2. ISO/IEC 13888-1. Information technology - Security techniques - Non-repudiation - Part 1: General, 1997.
3. ISO/IEC 13888-2. Information technology - Security techniques - Non-repudiation - Part 2: Mechanisms using symmetric techniques, 1998.
4. ISO/IEC 13888-3. Information technology - Security techniques - Non-repudiation - Part 3: Mechanisms using asymmetric techniques, 1997.
5. J. Zhou and D. Gollmann. Evidence and non-repudiation. Journal of Network and Computer Applications, 1997.
6. J. Zhou and D. Gollmann. A fair non-repudiation protocol. Proceedings of 1996 IEEE Symposium on Research in Security & Privacy, 1996
7. J. Zhou and D. Gollmann. Observations on non-repudiation. Advances in Cryptology - Asiacrypt 96, 1996.
8. J. Zhou and D. Gollmann. An Efficient Non-repudiation Protocol. 10th Computer Security Foundations Workshop, IEEE Computer Society Press, 1997.
9. T. Coffey and P. Saidha. Non-Repudiation with Mandatory Proof of Receipt. ACM Computer Communication Review, 26(1), 1996.
Dimitrios Petropoulos
        Visit our Internet site at Any views expressed in this message are those of  the  individual
sender,  except  where  the sender specifically states them to be
the views of Reuters Ltd.

@_date: 2001-06-25 10:33:30
@_author: Dimitrios.Petropoulos@reuters.com 
@_subject: Zero Knowledge Identity Proofs 
I think this is a case for additional protective mechanisms to extend the protocol semantics (there is nothing in the protocol prohibiting the verifier to perform a verification on behalf of a third party, which is the vulnerability exploited in the Mafia Fraud attack). This 'challenge-relay' can easily be defeated if the verifier (in the Mafia Fraud case that's Bob and Dave) is required to digitally sign their challenges. If challenges are signed then Alice will only proceed with the rest of the protocol run if the challenge indeed comes from Bob; Carol can still pass Dave's challenges to Bob but Alice will refuse to perform the protocol run having noticed that the challenges do not come from Bob. The optimised versions of the Feige-Fiat-Shamir and Guillou-Quisquater protocols make signing easier since they employ a vector of challenges to perform multiple accreditations- in order to avoid multiple messages.
Dimitrios Petropoulos
        Visit our Internet site at Any views expressed in this message are those of  the  individual
sender,  except  where  the sender specifically states them to be
the views of Reuters Ltd.

@_date: 2001-06-26 10:45:17
@_author: Dimitrios.Petropoulos@reuters.com 
@_subject: Zero Knowledge Identity Proofs 
Interestingly enough, I don't think this is the case because the objective is to prevent Alice from acting on  Dave's challenges. The confusion may also have arisen because of my use of terms. In this email I'll use 'signing' to mean creation of proof of origin (and classic digital signature algorithms like RSA will suffice). When an entity is trying to prove their identity I'll refer to it as 'acting on' or 'transforming' a challenge. I'll try to clarify:
Alice does not need to 'sign' any challenge since she is the 'prover', i.e. the entity that needs to prove the truthfulness and genuineness of her identity to Bob, who is the 'verifier' and therefore the entity producing the challenges. In the course of proving her identity to Bob using a zero knowledge proof of identity, Alice will accept a number of challenges from Bob (the number of which Bob has to decide depending on his perception of risk; each iteration reduces the likelihood of successful impersonation by half), perform some transformations and return the result to Bob who will verify the transformations.
In this scheme, Alice can fall victim to Bob and Carol working together to defraud both Alice and Dave (the Mafia Fraud example), whereby Carol masquerades as Alice to Dave and relays Dave's challenges -through Bob- to Alice, who will perform the transformations believing she is proving her identity to Bob (when in fact she is proving it to Dave).
Digital signatures (e.g. RSA) on the challenge vectors (along with sensible additional information like prover & verifier identities, timestamps/nonces, etc. to prevent other attacks on the message semantics) would prevent the Mafia Fraud attack since -in this example- Alice would only perform the protocol run if the challenge vector is signed by Bob, whereas Dave will send challenge vectors carrying his signature to Carol (which can no longer relay them to Alice).
I cannot see why Alice would have to transform both the challenge and the signature on it (this, incidentally, would mean that you cannot use signatures with message recovery). Apologies if there's something in Marc's email that I have misunderstood; grateful if I could have it pointed out to me.
Dimitrios Petropoulos
        Visit our Internet site at Any views expressed in this message are those of  the  individual
sender,  except  where  the sender specifically states them to be
the views of Reuters Ltd.

@_date: 2001-06-26 11:17:50
@_author: Dimitrios.Petropoulos@reuters.com 
@_subject: Zero Knowledge Identity Proofs 
Following up on my previous post (netiquette? what's that?) one further clarification (and summary of my thoughts): the heart of the Mafia Fraud attack lies -I think- in that the challenge messages provide no proof of origin (who created them) nor of intended recipient (who were they intended for). A simple extension of the challenge message to include this information, protected with a simple digital signature scheme, is -in my opinion- enough to overcome the problem.
Dimitrios Petropoulos
        Visit our Internet site at Any views expressed in this message are those of  the  individual
sender,  except  where  the sender specifically states them to be
the views of Reuters Ltd.

@_date: 2001-06-28 10:41:25
@_author: Dimitrios.Petropoulos@reuters.com 
@_subject: Zero Knowledge Identity Proofs 
I now strongly believe that Marc and I are actually talking about the same thing, only we're doing it using different words: Marc talks about Alice providing evidence that she has seen Dave's signature on the challenge whereas I talk about the challenge vector being accompanied by information identifying the originator and the intended recipient, bound/protected via a classical digital signature... In both cases the ultimate goal is the same: Alice is provided with guarantees that the challenge was intended for her and was produced by the person she thinks she is proving her identity to.
Essentially in any challenge-response based entity authentication protocol the following must always hold:
Consider an authentication protocol where two entities, A and B, exchange the following messages:
A -> B    (M1)
A <- B    (M2)
A -> B    (M3)
A <- B    (M4)
In the above diagram A starts the protocol by sending message M1 to B. B replies by sending message M2 to A, etc. It is assumed that each party sends message Mi only after having successfully received (and verified wherever the protocol makes possible) message Mi-1.
After completion of the protocol A would like to be sure that :
1. M2, M4, etc. were indeed sent by B
2. M2, M4, etc. were 'fresh' messages, i.e. not replays of older messages
3. M2, M4, etc. were intended for A and not for any other recipient
4. M2, M4, etc. were sent by B as a response to A's M1, M3, etc.
(the above protect respectively against masquerading, replay, reflection and interleaving attacks)
Similarly for B:
1. M1, M3, etc. were indeed sent by A
2. M1, M3, etc. were 'fresh' messages, i.e. not replays of older messages
3. M1, M3, etc. were intended for B and not for any other recipient
4. M3, M5, etc. were sent by A as a response to B's M2, M4, etc.
When developing authentication protocols the above requirements are usually fulfilled as follows:
(1) via the use of secrets,
(2) via the use of time-variant parameters
(3) by using originator or intended recipient identifiers
(4) by including in Mi information that could only have originated from Mi-1.
The zero knowledge identity proofs can be considered, in my opinion, as low level primitives on top of which strong entity authentication protocols can be built. On their own (without the extensions discussed above) they will always be vulnerable to a number of attacks.
Regarding whether the uniqueness of the challenge vector can protect against replay attacks, I guess this depends on the length of the challenge vector. If 10 bits are used this makes the likelihood of successful impersonation by an imposter quite small (2^-10, i.e. 0.00098) but also the number of different vectors is quite small (2^10, i.e. 1024), therefore after 1024 protocol runs you cannot tell whether the responder is sending a fresh reply or whether they are replaying something they intercepted earlier... In such cases maybe other freshness methods should be used (e.g. timestamps, nonces, etc.).
Dimitrios Petropoulos
        Visit our Internet site at Any views expressed in this message are those of  the  individual
sender,  except  where  the sender specifically states them to be
the views of Reuters Ltd.
