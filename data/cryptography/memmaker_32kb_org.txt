
@_date: 2013-11-05 14:54:46
@_author: Felix Ruzzoli 
@_subject: [Cryptography] Asynchronous forward secrecy encryption 
Hi Michael,
I am not sure if you consider mobile clients, and I am speaking primarily
about smartphones and tablets, with a fragile network connection
to be part of DTN (Delay-tolerant Network?). But I believe the connection
issues in that case can be overcome by good coding practices;
at least in most instances.
About number 6 - Key Exhaustion attacks:
Well those can only occur if the receiver is offline. While online, the
server would alert a client whose key pool is near extinction. One simple
method to lower the attack surface, which is also currently implemented
in my system, is to only allow message sending between known (and trusted)
contacts. This way an adversary would have to gain control over the device of
a trusted contact before being able to launch a key exhaustion attack.
Actually I wouldn't know how to do better than this. This disables key
exhaustion for anyone but a trusted communication partner. Obviously
it is impossible to detect an attack without introducing artificial at this point.
Any thoughts?
Am 05.11.2013 14:26, schrieb Michael Rogers:

@_date: 2013-10-29 18:49:33
@_author: Felix Ruzzoli 
@_subject: [Cryptography] Asynchronous forward secrecy encryption 
I believe that the memory on current smartphones running android is stable enough for the purpose.
I have a setup where the server stores some pre-generated DH keys in memory only. Clients would query for a key for every message they want to send in order to complete the DH agreement and send the encrypted message plus the public key needed for the other party's part of the protocol.
So obviously there is a small gap. If the process has been killed in between, the private key for decrypting that last message is lost. The best we can do in that case is to tell the other party that we could not decrypt that last message and they'd have to resend with a fresh key we just sent along.
Apart from the problem stated in the last paragraph, that would enable PFS with asynchronous messages with a relatively simple protocol. Or am I missing something here?

@_date: 2014-04-20 09:34:06
@_author: Felix Ruzzoli 
@_subject: [Cryptography] Alternative to C and C++ for crypto programming? 
I'd like to mention a Programming Language which was built with some of the problems you mentioned in mind.
The Philosophy is to have a safety-first semantics and with a bit of additional work, one can disable the additional safety-overhead, e.g. for Bounds-Checking.
Also the language in question compiles to native machine code and doesn't need any kind of VM. It has C style syntax and a high-level class library which accompanies it.
I am, of course, talking about D. The better C++, imho.. (OK, Flame on..;)
Have a look for yourself:
I am currently working on porting my instant messaging server from Python Twisted to D for added performance and education.

@_date: 2014-03-24 10:08:22
@_author: Felix Ruzzoli 
@_subject: [Cryptography] On mobile passwordless logins and established 
Hey List,
I am wondering. Most people seem to agree that the vast amount of online services accounts accompanying passwords for authentication are creating a constant hassle for the end-user and / or security issues because of weak or reused passwords.
I had a look at OAuth and OpenID and while in theory the idea seems to be a good one; in practice the technology is not adopted by enough services to make a difference. Furthermore the original design seems to require a Web based login which has to be recreated as a Webview on mobile devices; a more than awkward solution.
I am wondering why people don't employ client-side SSL certificates for simple ID checking purposes? Someone please tell if I am wrong here..
By just generating client certificates for each user of a (mobile) application on-the-fly and using them for ID checking we achieve passwordless logins with a good degree of security. Of course as long as the secret key is stored unencrypted on the device, the device acts like an ID token. Thus if the phone gets stolen the ID is too.
Of course backups of the ID could easily be done by encrypting the private key to a secret password. But at this point there seem to be no alternatives to letting the user input a secret.
I claim this a feasible solution for your run-of-the-mill low security application which just needs a reliable way to differentiate between users and make sure it is not too easy to impersonate another user or break into his account.
What are your thoughts on this?
