
@_date: 2004-12-08 16:35:27
@_author: Ondrej Mikle 
@_subject: Some notes to "MD5 To Be Considered Harmful Someday" - practical uses, additional attacks 
I've read the paper. What is stunning, that I've written similar paper
named "Practical Attacks on Digital Signatures Using MD5 Message
Digest" using very similar techniques only recently. It was submitted
to Cryptology ePrint Archive ( a week ago, on
December 2nd. They will probably publish it in a day or two (I guess),
they are processing december papers right now.
The difference is that I've focused mainly on practical attacks in
software distribution channel (there is an attack scenario depicted).
The attack scenario is based on talks with a couple of
developers/packagers on how the software packaging and distribution
The paper describes an example of pair of executables and data files
which have same MD5 sum, but extract different contracts. Then, there
is the idea and practical demonstration of a tool that creates custom
(self-)extract packages which can contain arbitrary files, again both
with identical MD5 sums, each extracting another one. Lastly, there is
notion how it could be made even more effective when the algorithm to
find MD5 collisions for any initialization vector is published.
Most Windows software is distributed as self-extract (self-install)
executables. In Linux world, self-extract executables are not so
common. Formats tar.gz, tar.bz2, zip and various packages (rpm, deb,
etc.) prevail. After submitting the paper we've been inspecting if
similar attack could be made on these formats. Well, definitely yes
for zip, tar.bz2 and tar.gz. The only problem was to find concurrent
collision in MD5 and CRC32, which is not that hard after all
(estimated time is approx. 320 hours using a single PC like the one on
your table, or less than one day on 16 PCs). For rpm, deb packages,
the trick is to put the colliding block somewhere in the header, where
it is not checked internally by the package manager for any checksum.
The paper, source codes, examples and attacks on zip/gzip/.../rpm/...
formats can be found at:
We think that these attacks could be used even today, but they are not
so hard to spot when people are aware of them.

@_date: 2004-12-14 17:08:15
@_author: Ondrej Mikle 
@_subject: The Pointlessness of the MD5 "attacks" 
There are many ways to obfuscate code so tha it will seem innocent,
see for example International Obfuscated C Code Contest
( It can be based on variable
modification using buffer overflows, integer overflows, strange side
effects of expression evaluation, etc.
Another possibility for an attacker is the use of deliberate and very
rare race conditions, which only attacker knows how to trigger. Race
conditions are very difficult to discover. Cf. Linux ptrace race
condition (
It's been there in kernels 2.2.0 - 2.2.19 and 2.4.0 to 2.4.9. It
allowed for local privilege escalation. Took quite a long time to
discover it, even though it was open source code. Quite a long time
for opportunity, if we assumed an attacker would do similar attack
That's true in theory, but it's different in real world. Take
Microsoft software as an example. Many banks use their software (and
sometimes even military). I don't think that all of them reviewed
Microsoft's source code (I guess only a few, if any at all). There was
an incident of a worm attacking ATMs.
Another example, Enigma was being sold after WW 2, but the Allies knew
it could be broken. The purchasers did not. Same as when US army sold
some radio communications that used frequency hopping to Iraq during
1980's. US knew that it could be broken ("just in case...").
Ondrej Mikle

@_date: 2004-12-16 14:22:10
@_author: Ondrej Mikle 
@_subject: The Pointlessness of the MD5 "attacks" 
Yes, malware can be distributed without any use of any hash function.
I try to demonstrate on an example, what the MD5 collision provides
and how to make it 'innocent'. You don't have to put malicious code in
the program. For example, telnet is not secure, but there are uses of
it which don't need encryption/authentication. Similarly, HTTP is
widely used, but HTTPS can be used when needed. Take a bank as an
example. Some transactions require secure connection, but not every
page on the bank server has to be transmitted using a secure
connection. If an attacker would cause the software to switch from
HTTPS to HTTP in the "right" moment, it could lead to disaster.
Most of data (file) formats have some sort of header. An attacker can
do this: He will say that the colliding block is a header, with first
four bytes being the 'magic bytes' as you know from many formats (e.g.
exe has MZ, bmp has BM, elf executables have ELF). Next, he will
proclaim that the rest of the 1024 bits are some data, e.g. some
counts of something and the differing bits/bytes will be some flags.
The point is to use the bits in some calculation that is legitimate.
That means, it "moves the question of trust" onto the data package. A
person doing inspection would not find anything wrong, since the
person receives correct executable and the "good" data package. That
is the difference between use and non-use of MD5 collision. An
obfuscated malicious code can be discovered, even though it may be
difficult. When you use collision, it may not be discovered, since
there is no "evil" action in the code. The "evil" is created as a race
condition using the "evil" colliding package.
Now, I try an example (I know it's not the best one, but I hope it
makes the point clear):
Suppose an attacker is packager in a company and his role is to take
software, pack it up and create installation scripts. The package is
still reviewed after his packaging. Let's suppose the company is
working on some server-bundle-software which installs http server, IDS
and optionally SSH and Telnet. By default, Telnet is disabled.
Telnet's role may be for example so that anyone could telnet to the
machine and have e.g. statistics of server usage or some non-sensitive
information or computation. That's the justification of having the
telnet there in the software. If one wanted to use it, he would enable
it and configure it correctly so that anonymous users can't do any
harm or get to sensitive information.
Well, there is the flag in the header (=the colliding block) saying if
it should be installed or not. After packaging is complete, it is
inspected once more and if no flaw is found, it is put on company's
ftp/web server for distribution along with MD5 sums published on
multiple places. Then the attacker (as an insider) swaps the two
packages. Anyone believing the MD5 sums would install the software and
wouldn't realize that telnet is installed and not configured
(documentation says something different). That could open a way for
anyone in.
To sum it up, the MD5 collision allows:
-have code and data, that do not do anything unwanted (can be proven
by inspecting the code)
-the other colliding package does the same, but it creates some
unnecesary service/action that is dangerous in given context. The
presence of the service is justified, though. In default installation
it is disabled. So says the manual. But that's not true. So the MD5
collision itself does not do much, but with additional trickery it
could be used.
If the flaw would be discovered in the software, who would be held
responsible in the company? The testers, inspectors of code. Not the
packager. He could sell the knowledge of the security hole to
spammers, virus writers, etc. I'm not saying the MD5 collision allows
for a highly practical attack (at least the example involves an
insider), but when we know it's possible, why should we continue using
Ondrej Mikle

@_date: 2005-06-13 22:35:28
@_author: Ondrej Mikle 
@_subject: Collisions for hash functions: how to exlain them to your boss 
Well, it's partially true.
It is possible to create a program that does exactly the same without
the need of collisions
A program creating similar effect without the use of collisions must
use some external data to make decision. Therefore, it is possible to
prove that it may (under some circumstances) behave in a different
way. If you have a program that has all the data hard-coded (i.e.
static, internal), it will behave provably only in the prescribed way.
(Of course some strange 'if' may cause suspicion).
That's where the collision comes in. For one version of the PostScript
document, it can be proven that it will always display the same thing
(no matter what date or what user, provided that it is interpreted
with an interpreter compliant to postscript specification). The
problem arises when a person believes that by signing the program, it
will be the same code (which was proven to do exactly one thing) that
matches the signature next time the signature will be checked. Which
it won't, because of collisions. You can't accomplish this without use
of collisions.
There is also a psychical point of view - most people don't know that
postscript files are actually code. So are PDFs. Strength of
post-script part of language was cut down, but there is javascript,
however not many viewers except Adobe reader support it. Other
'code/data' formats are e.g. MS Excel, MS Word, OpenOffice Writer
files, in fact almost any complex file format.
This is something you can't do on paper (well, except for some tricks
like invisible inks that become visible after some time).
I've had a talk on this a few months ago with a couple of other
cryptographers. The result was that there is no such thing as 'unique
representation of document' like it is for a plain old sheet of paper.
It depends on viewer application.
You don't even need conditionals. For one conference I've created an a
pair of Excel spreadsheets that used a simple sum over a couple of
fields. I picked Excel, because it is widely known application. Both
files had identical md5 hash, but different result. There was no need
for scripting.
It works like this: you put some believable numbers on the sheet, then
create a region colored white letters on white background ;-)
You create a collision in the region, so the nonsense numbers are not
visible. On the next row, you are 'behind' the collision (in terms of
position in the file data stream). So you put anything you want in
both files in the next rows, it only has to be the same for both
colliding files. So create another region with white on white, put
some 'bulgarian constants' (*) in there and put a SUM or some
unsuspicious operation as one of the visible items.
Now both xls's have the same md5 hash, but each displays something
else even without the use of VisualBasic scripts.
Sure, you can create white on white document without the use of
collisions, but then either
a) you have to use scripting with external-data-based conditionals or
b) you can't make their hashes equal without use of collisions
(*) def. 'bulgarian constant' - a number you add to your result if it
doesn't match the expected result :-)
Most document formats cannot be viewed without a viewer application
(unless you make an effort to decode it by hand, which most people
won't or can't).
Ondrej Mikle

@_date: 2005-06-13 23:36:54
@_author: Ondrej Mikle 
@_subject: expanding a password into many keys 
I guess you should use some scheme like PKCS  PBKDF2 scheme
(password based key derivation function). The only difference between
your idea and PBKDF2 is that the latter does a lot of hash rounds and
is salted (I guess you pick key name to be static and not random, so
they are not used as salts).
Salting helps a bit against static precomputed hashes and techniques
like rainbow tables.
Ondrej Mikle

@_date: 2006-08-22 13:53:41
@_author: Ondrej Mikle 
@_subject: A security bug in PGP products? 
It seemed a bit obscure to me at first, but it says basically:
PGPdisk does not use key derived from passphrase, just does simply this:
if (somehash(entered_password) == stored_password_hashed) then That's the REPE CMPS chain instruction (string comparison). The check can be simply skipped using debugger by interrupting the program, changing CS:EIP (i.e. the place of execution) to resume after "successful" check. The text probably implies that the key is stored somewhere in the PGPdisk file and key's successful extraction does not depend on knowledge of the passphrase.
So if you change passphrase, the disk won't get re-encrypted, just by copy&pasting the old bytes you will revert to the old passphrase or you can create another disk with passphrase chosen by you and use copy&pasting method to decrypt other PGPdisk protected with passphrase.
I haven't checked myself if their claim is true, but it's possible.
Hope that helped
   O. Mikle

@_date: 2006-08-24 04:05:57
@_author: Ondrej Mikle 
@_subject: Hypothesis: PGP backdoor (was: A security bug in PGP products?) 
We discussed with V. Klima about the "recent" bug in PGPdisk that allowed extraction of key and data without the knowledge of passphrase. The result is a *very*wild*hypothesis*.
Cf. Question 1: why haven't anybody noticed in three months? Why has not there been a serious notice about it?
According to the paper, both "standard" .pgd and self-extracting SDA (self-decrypting archives) are affected. Systematic backdoor maybe?
1) it is a hoax. Though with very low probability. The text seems to include a lot of work and makes perfect sense (REPE CMPS, all the assembly), i.e. we suppose it is highly improbable that somebody would make such hoax. This can be either proven or disproven simply by checking the Win program using hex editor/debugger (using an already downloaded copy). I haven't had the time to check it yet (no Win).
2) AFAIK, Zimmerman is no longer in control of the company making PGP. AFAIK the company (NAI) has been bought by another group couple of years  says:
2002/03/08 - NAI drops PGP Desktop
2001/10/15 - NAI to sell PGP division
It may be therefore quite possible that NSA/CIA/FBI/etc. couldn't force Zimmerman to compromise his own product directly, so they have bought the company. The backdoor might have been introduced in the latest releases (e.g. 8.x, 9.x).
3) there was a lazy programmer, or a programmer-infiltrator from the ranks of intelligence services. What does one do when a cryptosystem seems unbreakable? He circumvents it. AFAIK the code has been checked many times in NAI, until some point in time.
As you all probably know, there has been a lot of mischief around Zimmerman and PGP in the '90-ties. We don't think NSA/CIA/FBI/etc would "just give up without fight". You know, the "three-line PERL RSA implementations on T-shirts" and so on.
Code of PGPdisk 9.x looks like this according to the paper: when the passphrase is changed, the key itself remains untouched. If at least the encryption key has been encrypted by a symmetric key generated e.g. by PBDFK2 from the passphrase.
Conclusion: it seems that NSA/CIA/FBI/etc. haven't called truce. Thought, very clever solution. Nevertheless, nothing we haven't had already seen in 1st/2nd world war tactics.
What do you think? Your input is welcome.
P.S. sorry for any misspellings of names

@_date: 2006-08-26 20:17:23
@_author: Ondrej Mikle 
@_subject: Provably secure cryptosystem 
I humbly say that I *might* have devised a provably secure cryptosystem that actually *might* work in reality. It provides secure authentication and possibly might be extended to something else. Sounds too good to be true? Well, you're right. In reality it's a bit more complicated.
I'm risking again making fool of myself, but what the heck ;-) At least I think it's something you all know, at least to some extent.
I have searched for some other provably secure schemas for MACs/signatures/etc., they use many similar assumptions (e.g. random oracle assumption, strong one-way hash function with uniform distribution assumption) and some similar techniques.
In the system I can prove there *is* a random oracle (this is also not so entirely true, but...you'll see).
OK, the point:
In complexity theory with random oracle, NP != P (cf. Shoup 1997: Lower Bounds for Discrete Logarithms and related problems, Baker-Gill-Solovay 1975). The trick is based on this fact.
Keys in the cryptosystem are not *data*, but *programs*, i.e. (partially) recursive functions. The trick is to simulate random oracle by a program, each program is the key describing a random permutation on some subset of natural numbers.
The cryptosystem is based on the following observation (extension of halting problem):
Given a program L as an input that takes 1..n as input, L stops exactly for one 1<=j <=n.
If we give this program to a DTM (deterministic Turing machine), no finite algorithm can decide for all possible input programs L and numbers n, for which j the input program L will stop in polynomial time.
In another words, no finite program can detect every virus (virus is defined to be a self-replicating program) or check if other program will draw prescribed picture for a given input, etc. in polynomial time.
So, the paper can be found here (alpha-draft, by no means complete, some parts such as related work and references, acks are not complete):
Be warned, it may be at least *partially* false, because I *deliberately* left out one proof ("protecting the keyspace", though it's security by obscurity). Well, hopefully there are no more serious glitches ;-]
The system as whole is secure, but every single instance can be of course broken by man (stealing the key, guessing the key, cryptanalysis). Integer factorization problem, (generalized) discrete logarithm problem are also elements of the system (it is a set).
At least I hope you'll have some fun.

@_date: 2006-08-28 12:41:03
@_author: Ondrej Mikle 
@_subject: Hypothesis: PGP backdoor 
OK, thanks for answering. I had only very limited view of the background behind PGP (i.e. stuff about NAI/PGP corp).
One last question: what about the PGPdisk SDA (self-decrypting archives, i.e. executables)? There has been a claim that SDA archives can be decrypted using a debugger. Is it true or false? See the section "Two Ways to bypass PGP SDA Authentication and EXTRACT with success" in the "advisory"  Is the guy confused again? ;-)
   OM

@_date: 2006-08-28 16:29:51
@_author: Ondrej Mikle 
@_subject: Debunking the PGP backdoor myth for good. [was RE: Hypothesis: PGP backdoor (was: A security bug in PGP products?)] 
Thanks, sorry for the hassle, me (and others) should've checked it
before asking.
Ad. compression algorithm: I conjecture there exists an algorithm (not
necessarily *finite*) that can compress large numbers
(strings/files/...) into "small" space, more precisely, it can
compress number that is N bytes long into O(P(log N)) bytes, for some
polynomial P. Here's a lead:
Take as an example group of Z_p* with p prime (in another words: DLP).
The triplet (Z, p, generator g) is a compression of a string of p-1
numbers, each number about log2(p) bits.
(legend: DTM - deterministic Turing machine, NTM - nondeterministic
Turing machine)
There exists a way (not necessarily fast/polynomial with DTM) that a
lot of strings can be compressed into the mentioned triplets. There
are \phi(p-1) different strings that can be compressed with these
triplets. Exact number of course depends on factorization of p-1.
Decompression is simple: take generator g and compute g, g^2, g^3,
g^4, ... in Z_p*
I conjecture that for every permutation on 1..N there exists a
function that compresses the permutation into a "short"
representation. It is possible that only NTM, possibly with infinite
algorithm (e.g. a human) can do it in some "short finite time". Again,
I could've/should've proven or disproven the conjecture, I just don't
want to do it - yet ;-)
  OM

@_date: 2006-08-28 18:12:12
@_author: Ondrej Mikle 
@_subject: Impossible compression still not possible. [was RE: Debunking the PGP backdoor myth for good. [was RE: Hypothesis: PGP backdoor (was: A security bug in PGP products?)]] 
We are both talking about the same thing :-)
I am not saying there is a finite deterministic algorithm to compress
every string into "small space", there isn't. BTW, thanks for "There
is ***NO*** way round the counting theory." :-)
All I wanted to say is:
For a specific structure (e.g. movie, picture, sound) there is some
"good" compression algorithm.
E.g.: if you take a GIF 65536x65536, all white, with just one pixel
black, it can be compressed into 35 bytes, see here:
If you wanted to compress the same picture using JPEG (i.e. discrete
cosine transform), then two things would happen:
The compressed jpeg file would be a) much bigger b) decompressed image
would have "artifacts", because Fourier transform of a pulse is sync
(infinitely many frequencies). Sure, JPEG is a lossy compression, but
good enough for photos and images that don't have a lot of high
  OM

@_date: 2006-08-28 22:04:16
@_author: Ondrej Mikle 
@_subject: Impossible compression still not possible. [was RE: Debunking 
OK, according to Shannon's definition of entropy, how much information is there in \pi or e or other transcendent number? AFAIK all finite strings are in fractional expansion of \pi (take positive integer base other than 10 if you want). Sure, the numbers are correlated, because we can express \pi or e as infinite series, though only couple of bytes is But: if you take any finite string, there exists a finite natural number as index where the string can be found in \pi. So are there any "random strings" at all? What if I can express the digits starting at 2^(2^k)-th index analytically in a short, fast algorithm? In case no other can, then I have perfect one-time pad, at least for some time, because conventional computers will not reach the place in some reasonable time (yes, I know, there may be other correlations). The point I am trying to make: if I take e.g. a transcendent number and can analytically express a part of its fractional expansion, I *might* have a strong key.
The point for this: I am researching an authenticating scheme where keys are *programs*, not data. It means that key can change itself over time, for example. The strongest keys would therefore be somewhat recursive polymorphic code, that enumerates all possible permutations on some finite set in some deterministic, though seemingly random order.
I know that there are "short" descriptions for lots of infinite structures, the mentioned transcendent numbers, then take Mandelbrot set, various IFSs (iterated function systems), quaternions, unmeasurable sets, there are lots of possibilities. What I know for sure is that for many mathematical structures short descriptions (programs or (partially) recursive functions) exist. What I conjecture is that for each finite ordered set a short "compression function" exists. The whole trick is that it is almost impossible (meaning computationally infeasible) to look for the compression functions using a finite deterministic algorithm. Though a human can do it.
It will yet take some time until I have some more results about the categories of key programs.
   OM

@_date: 2006-07-09 21:21:41
@_author: Ondrej Mikle 
@_subject: Factorization polynomially reducible to discrete log - known fact 
I believe I have the proof that factorization of N=p*q (p, q prime) is polynomially reducible to discrete logarithm problem. Is it a known fact or not? I searched for such proof, but only found that the two problems are believed to be equivalent (i.e. no proof).
I still might have some error in the proof, so it needs to be checked by someone yet. I'd like to know if it is already known (in that case there would be no reason to bother with it).
   O. Mikle

@_date: 2006-07-11 14:24:14
@_author: Ondrej Mikle 
@_subject: Factorization polynomially reducible to discrete log - known 
OK, I had the proof checked. I put it here: Warning: it may be not what you'd expect.
First of all, it reduces the factorization to a discrete log in a group of unknown order (or put in another words: you'd need to factorize to learn the group order). It has been proven by V. Shoup that when group operation and the inverse are the only operations that can be done with group elements, then the best algorithm can be O(sqrt(n)), where n is the number of elements. I guess then the group of Z_N* (where N=pq) of unknown order qualifies for this if we don't want to use factorization (actually you can't compute inverse group operation here). In the light of this fact, is this proof of any use?
Even if the proof is not useful, is the "generator picking lemma" (lemma 2) anything new? It states basically this:
In any cyclic group of order n there is at least 1/log2(n) probability of picking a generator randomly and thus generator can be found in polynomial time with overwhelming probability of success.
The only facts close to this lemma I found were:
1) Product phi(p_i)/p_i for consecutive primes p_i approaches zero as more and factors are added to the product (phi is Euler phi function). The lemma states a lower bound for the product.
2) "If the generalized Riemann hypothesis is true, then for every prime number p, there exists a primitive root modulo p that is less than 70 (ln(p))^2." (
Thanks for answering my second question which I have not asked yet :-) (the reduction in opposite direction). I'm also working on the opposite reduction, but I'm at best halfway through (and not sure if I am able to finish it).
Last question:
Joseph Ashwood mentioned someone who claimed to have algorithm for factorization and had only the reduction to DLP. Anyone knows where I could find the algorithm? Or maybe name of the person, so I could search the web.
   O. Mikle

@_date: 2006-07-12 16:34:06
@_author: Ondrej Mikle 
@_subject: hashes in p2p, was Re: switching from SHA-1 to Tiger ? 
RIAA uses only very basic cryptanalytic attacks. Specifically, Kazaa (FastTrack protocol) uses very stupid UUHash algorithm, which works like this: first 300kB are hashed with MD5, then 300 kB at 1MB boundary is added to hash, then 300 kB at 2MB boundary, then 300kB at each 2^n MB boundary. It is clear that it is very easy to generate collisions for For other networks, mostly sybil attacks are used (spawning a lot of fake nodes and fake files with the same name so that search turns them up).
An example how to handle this might be aMule and eMule clients. The basic ed2k protocol only uses MD4 hashes (it is hash list, the hash in magnet link is the MD4 hash of MD4 hashes of file blocks). These two clients add protocol extension called AICH algorithm (basically it is Merkle tree of SHA-1 hashes). The root hash might be a part of magnet link, but does not have to be (since it is not part of the original If the root hash is part of the magnet link, then the received tree can be checked. If it is not part of the magnet link, then the client attempts to retrieve it from clients that support AICH. If at least 10 clients send the same root hash and if that is at least 92% of all received root hashes, such root hash is considered trusted for the current session. It is definitely not 100% secure, but the more clients support AICH, the more often you will find the root hash in magnet link (thus being able to check the received tree). Even in the absence of root hash in magnet link, the attacker needs to control significant portion of network to be able to spoof the root hash with some high A simple concept that would allow replacing the hash functions would be adding optional parameters to protocol specification. Then users can switch clients "continuosly", i.e. users with old clients will not be cut off of the network each time hash function changes.

@_date: 2006-07-12 20:02:43
@_author: Ondrej Mikle 
@_subject: Factorization polynomially reducible to discrete log - known 
Actually, you can never get a generator of Z_N^* unless p=q, because when p != q, it is not a cyclic group (this error was in my proof, too). Though with great probability you get an element of high order. It is enough doing lcm() to get the phi(N) and it will run in polynomial time.
I noted the fact IFP(N) to DLOG in Z_N^* is really mentioned in Handbook of Applied Crypto, but without proof or algorithm, just two lines (I guess that's why I missed/didn't remember it).

@_date: 2017-07-11 00:44:00
@_author: Ondrej Mikle 
@_subject: [Cryptography] OpenSSL CSPRNG work 
I've tackled this for Turris and Turris Omnia routers. We added RNG for ~ $1
(and it was not that great of a RNG). The point being, if your shitty router has
nowhere to get entropy from, there's no help. You either provide some seed at
factory or rely on on RNG that is onboard.

@_date: 2017-07-19 11:10:05
@_author: Ondrej Mikle 
@_subject: [Cryptography] Raspberry Pi-like FPGA ?? 
I used the Papilio Board (some seems to still be on stock at
gadgetfactory.net, though the smallest cheapest ones are sold out).
This is a good book to start with if you know nothing about programming
(it's actually for the Papilio Board). It teaches VHDL, but once you
understand the core concepts it's not a problem to learn Verilog. Be
prepared that doing crypto with this will be a lot of pain (I know because
I learned writing pipelined parallelized multicore DES cracker that does 1
key try/1 clock at max possible clock speed and DES is pretty simple).
There is AFAIK only one option for completely open-source toolchain: for
Lattice boards. All others need the respective vendors' tools to generate
bitstream. Two major vendors are Xilinx and Altera and IDEs from both are
pain (though I found equivalent of internal compiler error only in Altera's
Quartus). Furthermore, the IDEs are not always free. For small FPGAs (e.g.
up to 75k LUTs on Spartan 6), Xilinx ISE is free with webpack license. If
you wanted to program a bigger FPGA (e.g. reuse the Ztex 1.15y boards that
were used for bitcoin mining some years ago, you'd need a paid license).

@_date: 2017-10-12 21:27:55
@_author: Ondrej Mikle 
@_subject: [Cryptography] ? recommendations for secure communications 
You can delete conversations. But I don't think it can be set up to be
automated, though.
I've seen this, which is supposed to make it easier for non-tech users (do the
setup part) :
There was a talk at Hacker's Congress in Prague on it, but I don't think there's
But from my own experience with Enigmail and other things made to work on top of
email: I wouldn't recommend it to non-tech users. It's really easy to screw it
up even if you know what you are doing.
  OM

@_date: 2017-10-24 16:41:55
@_author: Ondrej Mikle 
@_subject: [Cryptography] Response to weak RNGs in Taiwanese and Estonian 
there was similar case with Taiwanese cards in 2013 (batch GCD+Coppersmith
-  However I can't
seem to find how they handled it eventually. There was recent news that
they will replace the ID cards for some unspecified reason -
Same goes for Estonian cards - no idea what mitigation or response was
announced. It also seems that the news broke for Estonian cards one month
sooner than for Slovak eID cards (source, but in Slovak:
Slovakia finally announced shutting down all e-government services and
that's it for now. Not sure whether they plan on reissuing/repgramming the
  OM

@_date: 2017-10-26 23:49:12
@_author: Ondrej Mikle 
@_subject: [Cryptography] [FORGED] Response to weak RNGs in Taiwanese and 
As far as I know the RNG in the Infineon cards of Slovak and Estonian IDs is
different that the ANSI X9.31 generator described in Matthew Green's article.
Can't be yet 100% sure since the paper will appear in November.
Also I am not sure if similar mass RNG failure first appeared in routers that
was cracked with batch GCD (
Then the Taiwanese RNG fault was published (also batch GCD, then Coppersmith).
The attack on Slovak and Estonian IDs I think only uses Coppersmith, although
one of their test sites on their page does the GCD against known factors - but
that tast marked tested all keys I tested as secure - whereas the test by the
ROCA's authors marked them as insecure.
Can a RNG fault of this type be tested beforehand? Here we currently miss how
they know the algorithm that was used in the Infineon RNG, which will probably
provide the answer.

@_date: 2017-10-30 22:23:29
@_author: Ondrej Mikle 
@_subject: [Cryptography] Response to weak RNGs in Taiwanese and Estonian 
The PDF of ROCA is finally available and the RNG in question is on page 3 of the
pdf. Does not look like the ANSI RNGs, though it's unlike any RNG I've seen so far.
Link: Direct to pdf:

@_date: 2017-10-31 18:12:27
@_author: Ondrej Mikle 
@_subject: [Cryptography] Response to weak RNGs in Taiwanese and Estonian 
Ah, you're right. But do I understand correctly that the design of the keygen is
the reason the keys have low entropy which can be exploited with Coppersmith's
On a side note, the current response both in SK and EE is replacing they keys
and corresponding certificates.
EE article:
In SK they are sending SMS telling owners to go to a office to replace they key.

@_date: 2018-02-13 00:38:11
@_author: Ondrej Mikle 
@_subject: [Cryptography] Existence of point of order 4 in a Montgomery curve 
I was reading the original paper on Twisted Edwards Curves
( and there is one thing that does not seem
right to me or I don't understand it.
Theorem 3.5 states in the proof, that exactly one of Montgomery curve or its
nontrivial quadratic twist over field k with  mod 4 contains a point of
order 4 and the other doesn't.
However in the proof, it mentions that both the curve and its twist have
subgroup that is isomorphic to Z/2Z x Z/2Z.
But a property of group isomorphism states that:
"If (G, *) is a group that is isomorphic to (H, .) [where f is the isomorphism],
then if a belongs to G and has order n, then so does f(a)"
Shouldn't it mean that either both curve and its twist contain a point of order
4, or at least one doesn't have a subgroup isomorphic to Z/2Z x Z/2Z?
 O. Mikle

@_date: 2018-02-13 15:25:03
@_author: Ondrej Mikle 
@_subject: [Cryptography] Existence of point of order 4 in a Montgomery 
OK, nevermind, I see now that Z/2Z x Z/2Z doesn't have a point of order 4.
  O. Mikle

@_date: 2018-02-24 23:44:12
@_author: Ondrej Mikle 
@_subject: [Cryptography] Anyone read and understood the proofs in "Ouroboros: 
I tried to assess the Ouroboros protocol and its proofs in
 but it seems rather unreadable.
Anyone has a better insight into it?

@_date: 2018-07-17 02:18:20
@_author: Ondrej Mikle 
@_subject: [Cryptography] storage encryption 
Does it have FUSE implemented yet or not? Can't tell if it's just in roadmap or

@_date: 2018-03-19 01:42:18
@_author: Ondrej Mikle 
@_subject: [Cryptography] Avoiding PGP 
I think the only perfect use is in package managers in linux that do the
signature checking for you.
Currently, Enigmail Thunderbird plugin kind of works. By "kind of" I mean it's
still easy to make mistakes like sending unencrypted emails or saving
unencrypted draft if you don't have the settings correct.
However, we have had a few success stories in teaching non-tech people (e.g.
medicine professionals) to use it correctly.
Yes, web-of-trust is a failed concept. What I usually do if I can't get a
fingerprint from other channel, is to google for it and check google cache
whether a person put it on their webpage (then check whois, etc). Keybase.io is
a tool that can make this work, but it's not as well known.
Usability of PGP/GPG for emails/personal communication is definitely a UI
problem (and also the reason PKI exists at all in the first place). That is the
reason why people suggest applications like Signal that make communication
encrypted by default.
Signal uses TOFU + GSM checking, but that has two vulnerabilities:
- if your target does not use Signal, you can impersonate him by exploiting SS7
or similar hack (however, SS7 manipulation is not exactly easy)
- changing of phone without restoring the original key means a warning that the
key has changed, so you now have to do the fingerprint checking again
Bottom line: GPG works well when it has been provisioned with keys for you, like
package managers in Linux. Not so well for personal email.
  O. Mikle

@_date: 2018-03-31 03:27:03
@_author: Ondrej Mikle 
@_subject: [Cryptography] Low-order points on secp256r1? 
I'm reading the following paper: In appendix A (page 14), it states, there is a point of order 5 on secp256r1.
How is that possible when secp256r1 curve group has prime order and the cofactor
is 1?
  O. Mikle

@_date: 2018-05-19 02:44:36
@_author: Ondrej Mikle 
@_subject: [Cryptography] Vulnerability found in badly broken email apps 
Thanks for this explanation/clarification, there was a lot of misinformation
about it.
I have one note about piping the output of GnuPG decryption to anything. I think
a lot of people don't realize that piping and authenticated encryption are
incompatible unless you have a lot of RAM (for large files).
I tried to think about a way to handle this case the best, but I am not sure if
warning or documentation is enough.
BTW does anyone know what would happen if you "curl  |
bash" if the stream was large and output (deliberately) corrupted? (I am not
saying that it is a good idea to use curl to pipe to bash, but a lot of people
got used to thinking that since it's https, it's OK - but I don't know what
actually happens when the integrity check fails).
  O. Mikle

@_date: 2018-11-23 00:00:40
@_author: Ondrej Mikle 
@_subject: [Cryptography] Buffer Overflows & Spectre 
This is perfect summation of current "state of computation", especially accross
the web. Is any of the 50 injected javascripts from various ad systems abusing
Rowhammer or Spectre? Likely not. Works in papers, but not so useful in real
attacks. But there's a decent chance they will inject some miner from an ad
system, along with the "legit" tracking code.
Most people don't know since they don't usually run even simple app/widget to
monitor CPU usage. It's quite common to see that once you allow javascript on
page via NoScript, it will eat one whole CPU core. Most people will only notice
it through fan spinning or battery drain. Simple pages having few paragraphs of
text with a few images, where basic HTML would suffice.
Ondrej Mikle

@_date: 2018-12-01 00:11:33
@_author: Ondrej Mikle 
@_subject: [Cryptography] What if Responsible Encryption Back-Doors Were 
Sorry for piggy-backing on this, but I have one question that I have never had
answered (US, EU jurisdictions mainly):
How is it possible or what is the reason/judicature/excuse for law enforcement
to try to get into your phone/notebook to get all your data just for anything
you might be accused of? It kind of feels like unreasonable search.
I.e. for law enforcement to use all kinds of vendors to exploit a bug on your
phone to get all of your the data, generally not even related to the case.
  Ondrej.

@_date: 2019-12-23 04:12:21
@_author: Ondrej Mikle 
@_subject: [Cryptography] NYT: Total Surveillance Is Not What America 
I would like to comment on the article linked in the article above
If you have a Google account, the company may already have saved a trove of
location data tied to your devices. You can prevent Google from collecting this
information by going to your account?s location activity controls and turning
off location sharing.
This is not true, turning off location tracking in settings does not actually
turn it off completely, that's why there is a joint EU lawsuit:
AFAIK there was no resolution of the lawsuit so far.
A good test of this when you come to Chaos Communications Congress, even with
wifi turned off, Android by design does automatic wifi wakeup sometimes to get
location based on nearby APs and location-based apps send you to London,
Helsinki or other random city. (Not sure if it also reports the location if you
have saved the wifi config/passwords)
  O. Mikle

@_date: 2019-11-03 21:43:02
@_author: Ondrej Mikle 
@_subject: [Cryptography]  
=?utf-8?q?websites_are_=E2=80=98fingerprinting=E2=80=99_you=2E?=
I think uBlock Origin has been vetted pretty well. There are fake clones in the
store, so just stay away from those (every popular app store is such minefied
nowadays, so I have had to resort to reading the extensions' source now. Such
I often add extra rules to my uBlock Origin config in addition to subscription
lists which is mostly fairly easy with the select element tool (you block whole
CSS class in general with visual aids to help you see what elements the rule
will block).
I personally think NoScript is one of the best addons to add into the mix,
however the web is more awful everyday. Every site needs 15 extra CDNs, even to
display 3 paragraphs of text and 1 image (why ffs?) I add every ad network into
"untrusted" category so that it will never load. Sometimes NoScript may be too
much hassle, though.
My personal favorite antipattern are sites that do work witout javascript once
you remove the overlay blocking all of the site (Behind the Overlay addon).
Firefox Containers are very good touch, easy to use and you can separate
identities (cookies, local storage, etc.) by having each tab either in a
specific container or generic container.
Then there is Privacy Badger, but you need to be a bit careful about that since
it sometimes likes to block even the useful CDNs. It's easily configurable in
the addon dialog, but might strike you odd if you didn't know it was why the
site was not working.
Last one is a cosmetical fix for all the annoying sticky/fixed elements - Sticky
Ducky. It seems the 90s have fallen back through a closed timelike curve and now
instead of browser bars you have these annoying fixed elements stealing space
from your screen that IIRC I used once in my life.
  Ondrej

@_date: 2019-10-18 23:06:07
@_author: Ondrej Mikle 
@_subject: [Cryptography] Current state of tools for making parallelized 
I remembered COPACOBANA and similar bruteforce-crackers that employed FPGAs.
Writing the code in VHDL/Verilog, synchronization and task distribution meant a
lot of work.
Does anyone know what the state is now?
Let's say I have few Spartan 6 LX150 with Cypress EZUSB interface lying around.
I tried writing parallelized and pipelined DES cracker some 6 years ago when
there were very few tools like migen and other abstractions from HDL languages,
fewer opensource place&route tools, etc. Took quite a while.
Can anyone estimate how much easier would it be to do the same task with newer
tools (like migen)?
On the top-level, it just means "put as many IP cores computing this function
there", then make connections that tell those cores the input ranges and wait if
any of them returns positively.
Of the most interest are easily-bruteforced ciphers, password hash attacks and
maybe some cracking where we know the key generation was biased due to bad RNG.
  O. Mikle

@_date: 2019-09-22 22:30:03
@_author: Ondrej Mikle 
@_subject: [Cryptography] Presentation for affiliated events from Crypto2019 - 
I was waiting for Crypto2019 conference page to add presentations from
affiliated events (
Are they available anywhere? E.g. I'd be interested in "Candy Machines,
Electronic Cash, and Human Rights", "Continuous VDFs and Applicatios" and
"Keynote: Flexible Byzatine Fault Tolerance".
  O. mikle

@_date: 2020-04-01 18:23:09
@_author: Ondrej Mikle 
@_subject: [Cryptography] Open hardware RNG design: Hector, Cryptech, OpenTitan, 
Let's say you have to implement RNG in your hardware (core/SoC).
I know about two that are older and had more peer review:
-  (based on PLL jitter)
-  (based on avalanche breakdown on diode)
There is a new project, OpenTitan, but its backing looks solid:
- So far the OpenTitan's ENTROPY_SRC is just LFSR PRNG design without the analog
noise part.
Any opinions comparison of these projects?
What I liked especially about Hector project is that it seemed really thorough
on researching the alternatives. Also it focused on one important question -
"how do I know the analog noise source will not fail/skew?" and actually had a
reasonable answer.
The OpenTitan feels more geared towards creating IP cores to be used in designs
than research-geared goal. I am wondering if you could use e.g. the Cyptech's
NoisyDiode to feed OpenTitan's ENTROPY_SRC and how much straightforward it is
(since RNG design is not exactly simple).
  O. Mikle
