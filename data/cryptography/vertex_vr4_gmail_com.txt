
@_date: 2014-04-30 17:07:37
@_author: John B 
@_subject: [Cryptography] New slogan for the NSA 
This was my favourite:
"The NSA - the only part of government that actually listens"
Link: Image

@_date: 2014-08-20 11:43:50
@_author: John B 
@_subject: [Cryptography] CSPRNG for password salt 
Hi all,
Some research on the interwebs turned up the recommendation that a password
hash's salt should only be generated with a cryptographically secure PRNG.
Some sources specifically mention *not* using rand() and friends.
What are the reasons for this? Specifically:
a) What is the attack on a password hash generated with non-CSPRNG salt
such as a rand() call?
b) How realistic/plausible is such an attack?
So that the responses don't 'wander', I'd like to state that I am already
aware of:
a) The point of a salt
b) The fact that the salts need to be of an appropriate length
c) Bcrypt, scypt and PBKDF2 are the appropriate types for password hashes

@_date: 2014-08-20 14:23:32
@_author: John B 
@_subject: [Cryptography] CSPRNG for password salt 
Hi Jerry,
Thank you for a well considered response.
FWIW I agree with your bogus expansion theory. I also can't see any
realistic attack but it's often better to be cautious and ask.
In answer to your question - "Where did you see this?" here are the top 2
(As pertaining to salt) *"Use cryptographically-strong random [*3] data;"*
*Salt should be generated using a Cryptographically Secure Pseudo-Random
Number Generator (CSPRNG). CSPRNGs are very different than ordinary
pseudo-random number generators, like the "C" language's rand() function.*

@_date: 2014-08-20 18:08:34
@_author: John B 
@_subject: [Cryptography] CSPRNG for password salt 
b) Now a salt is not an IV, so even with a collision, no keystream is
Hi Stephan,
Really appreciate your input.
It got me to pondering this argument for CSPRNGs:
Say we were using rand() - if the attacker can submit his/her own password
AND obtain their own hash back, they could then bruteforce the seed (say
because srand(time_now)) and now would presumably know the list of salts
used for all of the subsequent password hashes. They can then pre-compute
the tables necessary for an 'improved' offline attack on those passwords.
Does this sound plausible?
Thanks again for your time and quality analysis.

@_date: 2014-02-21 18:13:01
@_author: John B 
@_subject: [Cryptography] Plenty random for everyone 
Hi All,
Long time lurker - first time posting. Please be nice...
I've been pondering Ted's comments here:
So my question is, assuming using /dev/random as a seed for a userspace
CSPRNG is the 'right' way to go about the business of getting random
numbers, should (/could) we perform this action on the applications behalf?
As an example, a process with PID 2 (init was already using 1 :-)) does a
read of /dev/random. Kernel side creates a slab of mem for holding the
state of a CSPRNG for that specific PID which is then seeded by the 'real'
used as more data is requested by the app. The state will be periodically
seeded as and when needed.
Similarly, PID 3, 4 etc would get their own independent slab/RNG state.
As I understand it the benefits would be that:
a) One particular app can't DOS the system (not sure about that?)
b) Craziness like "dd if=/dev/random of=/dev/sda" should work 'better'
c) Attacks where a malicious actor attempts to manipulate the state of the
entropy pool by writing data to /dev/random should be mitigated as the
attacker can only manipulate the state of PIDs they own.*
d) Apps designers don't really need to worry about if they should be using
e) No more blocking on /dev/random
Some drawbacks:
a) it may somehow affect backward compatibility (?)
b) some people may insist on getting 'true' randomness and not just CS
randomness** (?)
c) It requires some more memory kernel side
d) point e, f and g where I have overlooked something obvious and in all
likely-hood show stopping...
* I've not read *anything* that leads me to believe an attack like this is
actually plausible - but it may help address those ongoing concerns I've
seen on this mailing list.
** Tongue in cheek comment. Flame at will.
