
@_date: 2004-12-23 13:21:17
@_author: Ariel Waissbein 
@_subject: Cryptography Research wants piracy speed bump on HD DVDs 
Is the watermarking system robust? Is it public? And how long ago has it been published?
If they are only modifying some bits (in the standard representation), then one might probably
be able to alter them. Also notice, that this may harm the quality of the image. Intuitively, one
is expected to have a low quality of image if lots of bits are used for watermarking, and a low
security if a few bits are used for watermarking.
Regarding blacklists, where are they stored? If they are included in every new DVD, then one
doesn't need to buy a new DVD but simply simulate an ID (which is not in the blacklist)
for the DVD. So this opens another place where designers may screw up. Another attack
is to attempt to delete this blacklist from the DVD.
In another respect, closed p2p communities that exchange movies through secure channels
would never get into this revocations lists. So here is another inconvenience for this DRM
Regards and (almost) merry christmas,

@_date: 2005-11-18 13:44:20
@_author: Ariel Waissbein 
@_subject: solving, simplification and factorization of boolean equations 
Dear Travis,
simplification can be reduced to elimination, which is indeed
intractable in the general case (for real-sized problems). (I am
assuming that you need to simplify a "big" system; however if you only
want to simplify a small SBox, then brute forcing might do.). The
standard citation on itnractability is [E. Mayr and A. Meyer. The
complexity of the word problem for commutative semigroups. Adv. in
Math., 46:305?329, 1982.] or Philippon et al.'s article. A more
comprehensive approach can be found in [D. Castro, M. Giusti, J. Heintz,
G. Matera, L.M. Pardo. "The hardness of polynomial equation solving".
Found. Comput. Math.  3  (2003).]; see also the citations in their
Intro). The intractability of elimination is well known at least since
Grete Hermann ( and most
probably since the end of the 19th century.
In my opinion "simplification" is a "means" and not an end, and indeed a
very intractable mean. On the other hand, form your email I gather that
your end is to solve these equations.
In polynomial equation solving, special cases are what counts. There is
a lot of debate on what are good options for elimination, today there
are different approaches presenting families of algorithms that are
efficient on certain "problem instances". Briefly I would classify the
options as:
1-rewriting techniques (ie Groebner bases),
2-path-following techniques (e.g., [L. Blum, F. Cucker, M. Shub, S.
Smale, Complexity and Real Computation, Springer, New York Berlin
Heidelberg, 1998.], [B. Huber, B. Sturmfels, A polyhedral method for
solving sparse polynomial systems, Mathematics of Computation 64 (112)
3-numeric techniques (e.g., [W. Rheinboldt, Methods for solving systems
of nonlinear equations, vol. 70 of CBMS-NSF Regional Conf. Series in
Appl. Math., SIAM, Philadelphia, 1998.),
4-an algorithms family based on flat deformations (e.g., [M. Giusti, K.
Haegele, J. Heintz, J.E. Morais, J.L. Monta~na, L.M. Pardo, Lower bounds
for Diophantine approximation, J. Pure Appl. Algebra 117,118 (1997)] and
its predecessors; see There are also many ad hoc constructions (e.g., in crypto) that can be
used on very specific problems. I think this is all. I might be
unwittingly omitting some other option. Im sorry if I am.
I can only speak for the latter technique (4), in which I have
contributed; in fact, together with other coauthors we will be releasing
a paper which attacks the problem of polynomial equation solving as
applied to public-key schemes based on polynomial equations. I have not
analyzed block ciphers, which yeild higher degree equations (as compared
to the quadratic equations of typical public-key schemes).
I hope that this helps, and feel free to mail me on any other questions.
majordomo at metzdowd.com

@_date: 2006-04-19 12:08:55
@_author: Ariel Waissbein 
@_subject: MD5 trick 
Hi Vlastimil and group,
Gera Richarte has done some interesting work with executable files that
have the same MD5 hash. Take a look at
to see his talk at PacSec `05 and "Two executable files with the same
MD5 hash, crc32, checksum32 and checksum16".

@_date: 2006-08-07 11:31:15
@_author: Ariel Waissbein 
@_subject: [IP] more on  Can you be compelled to give a password? 
Please notice that a second "distress" password becomes useless if the
would-be user of this password has access to the binaries (that is, the
encrypted data), e.g., because he will copy them before inserting the
password and might even try to reverse-engineer the decryption software
before typing anything. So I'm not sure what is the setting here.

@_date: 2006-08-14 11:53:08
@_author: Ariel Waissbein 
@_subject: Solving systems of multivariate polynomials modulo 2^32 
Hi Danilo,
Maybe you should use some other function in Mathematica. Symbolic
solving polynomial equations is a very difficult task (e.g.,
doubly-exponential worst case time complexity). But in this case it
shouldn't take that much time.
Let me notice that Z_{2^32} is not the same as F_{2^32} the field of
2^32 elements. I presume that you mean the former, which is not a field!
If you mean the latter, then you are using the wrong domain
specification in Reduce.
If you meant the field of 2^32 elements, then you should check how to
specify this in Mathematica.
For option Z_{2^32} you could try to solve the system (with elimination)
over the rationals, and once you eliminated variables "look at
everything in the integers" (multiplying by the LCM of the denominators)
and then simply take modulo 2^32 over all the solutions! If the system
of 3 polynomials in 3 variables is generic-enough it should have only
finite solutions.
If you want to continue using Mathematica, you can try your luck with
functions such as Solve or GroebnerBasis. There exist alternatives to
Groebner basis which I prefer personally, such as the Kronecker solver
( which comes as a
Magma package.
I hope this helps.

@_date: 2006-08-17 11:38:27
@_author: Ariel Waissbein 
@_subject: WEP's dead-er: The Final Nail in =?windows-1252?Q?WEP=92s_Coff?= 
IMHO, an interesting read:
The Final Nail in WEP?s Coffin
Bittau, A.   Handley, M.   Lackey, J.
University College London;
This paper appears in: Security and Privacy, 2006 IEEE Symposium on
Publication Date: 21-24 May 2006
On page(s): 386- 400
Authors present an attack that allows you to send arbitrary
data on a WEP network after having eavesdropped a
single data packet!! Next, communicate with every host in the router's
LAN. And finally decrypt packets in real-time.

@_date: 2006-08-17 17:26:12
@_author: Ariel Waissbein 
@_subject: Solving systems of multivariate polynomials modulo 2^32 
Hi Danilo,
the information you can extract from the system relies largely in the
hypoteses. If you don't bound the degree then the polynomials can define
the zero function, while they are not the zero polynomial. Say, the
univariate 2^{31}X(X+1) defines the zero function in Z_{232}. Also
notice that it is the zero polynomial in Z_{2^i} for i<32.
I don't know of any bound that will work in Z_{232}. Most bounds are
good over algebraically closed fields (some over the reals), but
bounding solutions in the complex numbers (which contains Z) will not
include points (x_1,x_2,x_3) that are mapped to P_i(x_1,x_2,x_3) that is
an integer multiple of 232.
A root that you lift using Hensel to Z_{p^n} looks like a_0 + a_1 p +
a_2 p2 +... +a_n p^n where a_i is in Z_p. What will happen in your case
is that at first, in (Z_2)3 you can have at most 8 roots, once you lift
to Z_{22} some of these roots can be "split" into more roots (if p=2
and n=3, then at most 8 roots). A root at step i-1 will split at step i
depending on whether your approximation at the step i-1 annhilates the
jacobian determinant of P1,P2,P3.
Good luck.
majordomo at metzdowd.com

@_date: 2008-05-05 12:03:36
@_author: Ariel Waissbein 
@_subject: New result in predicate encryption: disjunction support 
[Moderator's note: Again, top posting is discouraged, and not editing
quoted material is also discouraged. --Perry]
Hi list,
Interesting. Great work! I had been looking *generic* predicate
encryption for some time. Encryption over specific predicates is much
older. Malware (e.g., virus) and software protection schemes have been
using some sort of "predicate encryption" or "trigger" for over two
decades in order to obfuscate code. For example, an old virus used to
scan hard drives looking for a BBS configuration files in a similar
manner and some software protection schemes have encrypted pieces of
code that are decrypted only if some integrity checks (predicates) over
other pieces of the program are passed.
Triggers/predicates are very promising. Yet, they are only useful in
certain applications, since eavesdropping one decryption is enough to
recover the keys and plaintext.
I co-authored a paper were we used this same concept in a software
protection application ([1]) and later we formalized this concept, that
we called secure triggers, in a paper eventually publised at TISSEC
([2]). We were only able to construct triggers for very specific
predicate families, e.g.,
  - p(x)=1 iff x=I for some I in {0,1}^k
  - q(x,y,z,...)=1 iff x=I_1, y=I_2, z=I_3,...; and finally
  - r(x)=1 iff x_{j_1}=b_1,...,x_{j_k}=b_k for some b_1,...,b_k in {0,1}
    and indexes i_1,...,i_k (|x|>=k).
While these predicates do not cover arbitrary large possibilities, they
are implemented by efficient algorithms and require assuming only the
existence of IND-CPA secure symmetric ciphers. In [2] we came up with
more applications other than sofprot;)
[1] Diego Bendersky, Ariel Futoransky, Luciano Notarfrancesco, Carlos
Sarraute and Ariel Waissbein. "Advanced Software Protection Now". Core
Security Technologies Tech report.
[2] Ariel Futoransky, Emiliano Kargieman, Carlos Sarraute, Ariel
Waissbein. Foundations and applications for secure triggers. ACM TISSEC,
Vol 9(1) (February 2006).

@_date: 2008-05-06 10:59:40
@_author: Ariel Waissbein 
@_subject: New result in predicate encryption: disjunction support 
Hi Jonathan,
and thanks for taking your time to answer. I had already read the
Introduction and had a quick --i admit-- read over the paper before
posting to the list. I think that the main difference are the
applications we are looking at (and I know Sahai's earlier work in
obfuscation). Take a look at the first three sentences of our article:
Of course, the main difference is that one must hold SK (and f) in order
to decrypt messages according to the predicate encryption scheme. Note
that if the adversary is given the algorithm i\mapsto SK_{f_i} then
predicate encryption turns out to be similar to generic secure triggers.
However, we didn't cover predicates evaluating inner product so that's
what caught my interest, why I want to analyze how your work applies to
other problems (and why I think that the schemes are similar).
