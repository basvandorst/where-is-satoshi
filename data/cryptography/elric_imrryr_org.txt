
@_date: 2003-05-12 14:46:39
@_author: Roland Dowdeswell 
@_subject: New Hampshire's WiFi bill  
This is untrue.  A lot of people provide free access to their
802.11b base stations and there is no way for me to tell whether
any random base station without a WEP key is authorized or not.
So, the NH law is just stating what constitutes consent in a
reasonable way.  It is not like it takes any effort to set up a
WEP key.
You could make the same argument about my web site.  You are
accessing my computer in an unauthorised fashion by looking at my
web pages that I allow everyone to look at.  The argument here
obviously doesn't hold any water, mainly because it is obvious that
by putting up the website I am intending to allow any one access
to it.  But how do we know?  All NH is doing is providing a means
for people to know whether accessing 802.11b is authorised.
In fact, if you cannot assume that unWEPed 802.11b is a public
service then it is much more difficult for people to set up freely
available 802.11b access since you can't determine if you are
allowed to connect to it before you do in most cases.
The ``front door'' analogy made in the article is obviously a bit
of a stretch, since passing a few packets around on a radio network
isn't exactly like inviting yourself in and drinking all the beer.
    Roland Dowdeswell

@_date: 2004-04-08 00:01:10
@_author: Roland C. Dowdeswell 
@_subject: Firm invites experts to punch holes in ballot software  
I'd be slightly uncomfortable with this since the authorities should
not have a mechanism by which they can discover for whom I voted.
    Roland Dowdeswell

@_date: 2005-03-06 14:39:50
@_author: Roland Dowdeswell 
@_subject: comments wanted on gbde  
I have started writing up a bit of an analysis of GBDE, which I
would like to have people comment on before I continue with it.
I.e. am I onto something here or not? I wrote this up very quickly
over a few sleepless nights while trying to get my normal work done
before I left on vacation, so please bear with me.  The explanations
are rather empirical.  I am planning to put some mathematics in
there eventually.  At least after I return from my vacation.
I think that I have demonstrated that there are weak master keys
which can be used to construct an attack in < 2^128 steps on
individual sectors.  I also discuss dictionary attacks and construct
another attack which is more difficult than brute forcing each
sector, but a little less time consuming than GBDE's author claims
it should be.
The URL is:
    Roland Dowdeswell

@_date: 2007-01-15 20:49:23
@_author: Roland Dowdeswell 
@_subject: analysis and implementation of LRW 
In the last couple of days I have been considering implementing an
LRW mode for CGD ( (CryptoGraphic
Disk), but I haven't really seen a lot of cryptanalysis of it or
found the canonical implementation.
Has anyone here done the research?  And if it is generally accepted
as secure, is there a recommendation of an implementation that is
BSD (or similar) licensed?
    Roland Dowdeswell

@_date: 2008-12-01 13:26:39
@_author: Roland Dowdeswell 
@_subject: CPRNGs are still an issue.  
They failed to also mention that GBDE uses arc4random(9) to generate
the keys which is uses to write data.  So, any data written in the
first five minutes after a boot may also be weakly keyed.
    Roland Dowdeswell

@_date: 2009-05-11 14:16:45
@_author: Roland Dowdeswell 
@_subject: Warning! New cryptographic modes!  
I'm not convinced that a stream cipher is appropriate here because
if you change the data then you'll reveal the plaintext.
    Roland Dowdeswell

@_date: 2009-05-27 10:31:01
@_author: Roland Dowdeswell 
@_subject: consulting question....  
I have noticed in my years as a security practitioner, that in my
experience non-security people seem to assume that a system is
perfectly secure until it is demonstrated that it is not with an
example of an exploit.  Until an exploit is generated, any discussion
of insecurity is filed in their minds as ``academic'', ``theoretical''
or ``not real world''.  This of course makes it quite difficult to
cause various issues to be fixed in practice as it is generally
more time consuming to construct and explain an exploit than to
simply fix the bug that has been discovered.
The next refrain that one is likely to hear even after demonstrating
that a security issue exists is ``How many people know how to do
that?''  I've actually heard that in some rather amusing circumstances
such as ``Well, how many people actually know how to read or edit
XML?''  It is a tricky conversation to explain to people that XML
is not in fact an encryption mechanism---especially if they have
seen any machine produced XML recently.  Of course, this is one of
the more amusing examples but others abound.
I'm interested in asking people what rhetorical techniques they
use to overcome such difficulties in practice?
    Roland Dowdeswell

@_date: 2013-12-17 12:26:00
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] Fwd: [IP] 'We cannot trust' Intel and Via's 
It's probably sufficient to just have RDRAND output a predictable
value XORed with all of the registers.  Given that the only
unpredictable value in any of the registers is going to be the
output of the OS RNG, this would likely be enough.  No need to
check if there's an upcoming XOR, the worst case is that the
scheme doesn't work.
    Roland Dowdeswell

@_date: 2014-04-11 20:13:44
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] Heartbleed and fundamental crypto programming 
This is probably too complicated.  If you don't trust volatile and
whatnot, all you need to do is pass the pointer to a function that
the optimiser doesn't understand.  At this point, no assumption
can be made that the writes are superflous.  Granted, the optimiser
may become more sophisticated over time but you can probably trust
that optimising over, say, .o or library boundaries is unlikely.
If the function that you call actually tests the string to ensure
that it is all zeros and aborts on failure, then you would even be
using the data which would make the compiler substantially less
likely to be able to optimise it away---and it would provide a sort
of test that it is working.
The key point, though, is if you confuse the optimiser then it
can't remove the writes.  I.e.:
Should confuse a majority of optimisers as I would assume that not
many of them have logic that knows that the sum of a list of even
numbers must also be even.  This is a little slower than simply
zeroing the memory but it illustrates the point.
    Roland Dowdeswell

@_date: 2014-06-02 15:24:18
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] What is going on with TrueCrypt? 
Not only would they need to give up their anonymity but they would
then also need to prove that they are the authors which if they
have done a good job of staying anonymous might prove to be rather
difficult.  Unless they foresaw the need to do so and took the
right steps.
    Roland Dowdeswell

@_date: 2014-11-21 16:20:09
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] IAB Statement on Internet Confidentiality 
Depending on your goal, it might be sufficient to simply add a field
to the Received: line that each MTA adds containing a secret obtained
from the TLS exchange used in STARTTLS.
To make it concrete, rather than just adding:
Received: from green.metzdowd.com (green.metzdowd.com [166.84.7.15])
one could add:
Received: from green.metzdowd.com (green.metzdowd.com [166.84.7.15])
where the ``tls-hash'' would be derived from the session key using
SSL_export_keying_material which implements IETF RFC 5705.
By itself, this does not offer any protection as the end-user would
be unlikely to check it.  What it does do, however, is greatly
increase the risk associated with MITMing the STARTTLS because it
becomes possible to check via logs and whatnot to detect that it
With a bit of imagination, one could likely tie the hashes together
in a reasonable way if the client of an SMTP session would prepend
a Transmitted: header which contains a signature (using the senders
published DANE keys) of the tls-hash that the receiver would
independently generate.  This would be a revival of draft-fanf-dane-smtp-01
Section 4 which looks like it was dropped.
For extra credit, one could propose an MTA extension that would
encode the resultant chains in replies so that both parties would
be likely to notice if anything went awry.
    Roland Dowdeswell

@_date: 2015-01-09 14:22:42
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] Compression before encryption? 
You need to be careful as compression can expose certain kinds of
"chosen plaintext" attacks.  Basically, if you can insert chosen
plaintext early in the compressed stream then it affects the size
of the resultant compressed stream in predictable ways that give
you insight into what the rest of the stream contains.
This is demonstrated in the exploit CRIME (Compression Ratio
Info-leak Made Easy)     Roland Dowdeswell

@_date: 2015-11-16 12:59:47
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] ratcheting DH strengths over time 
A strategy that I have used in the past in the similar problem of
choosing a PCKS PBKDF2 iteration count was to benchmark the
current machine and use it to calibrate the cost on the current
hardware.  This approach more or less naturally increases the key
size based on the improvements in hardware.  Of course, it doesn't
address people running old machines in some sense (security) but
it does in another (cost of computation.)
Maybe a similar strategy could be used for these key sizes?  That
is:  use the largest key size which can be reasonably computed on
the current machine as measured by the software with a specified
cost.  The specified cost should be set low enough that if you
calibrate on the most modern cutting edge machine, the cost on a
five year old box is unlikely to be onerous.
    Roland Dowdeswell

@_date: 2016-02-11 23:06:53
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] Justify the sequence of operations in CTR mode. 
It's much worse than this.  CTR mode in its simplest form can't be
used for full disk encryption.  The contents of disks have a lot
of predictable bits in them, superblocks, inodes, etc.  And the
disk blocks get rewritten.  Once a block is rewritten with the same
keys, you can easily start breaking it.  Basically, XOR the old
and new ciphertext and you end up with the old and new plaintext
XORed which should give you real information.
If you want to avoid re-use of the same CTR output then you will
need to have a counter which is not mapped exactly one to one to
the ciphertext location of the disk.  But this would mean that
would have to maintain a separate table which maps the counters to
the disk locations and it becomes difficult to do atomic writes
These days, XTS mode is, I think what people are using for full
disk encryption.  It is a better starting point for this analysis.
This would be vulnerable to chosen plaintext and watermarking
attacks.  For example, if I could give you a file which you write
to the disk, it would be trivial for me to organise the file to
have only a small number of possible ciphertext blocks output by
choosing my plaintext to undo the XOR with the counter.
    Roland Dowdeswell

@_date: 2016-02-23 13:32:17
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] [Crypto-practicum] Justify the sequence of 
Right, this is what I was getting at in my prior e-mail.  And
there's also the cost of RMW cycles if you cause writes to be on
non-sector aligned boundaries which have a dramatic negative impact
on performance.
If you want to have authenticity of the data, then the best place
to do it assuming current hardware and software limitations is in
the file system layer not the block device layer.  Once you are at
the fs layer, you can make all sorts of simplifications that solve
these atomicity and RMW cycle issues.
    Roland Dowdeswell

@_date: 2016-10-05 10:36:14
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] Debunking the "SMTP TLS "s a mess" myth. 
To provide the risk of being caught, you don't really need an
infrastructure so much as the possibility of one.  I mentioned this
in a prior e-mail to this list: it would raise the bar significantly
to simply log hashes generated from the negotiate DH in STARTTLS
on both sides using the session key using SSL_export_keying_material
which implements IETF RFC 5705.
Now, you have the possibility of checking the postfix logs on both
sides to detect a MITM quite easily.
You could easily extend this to adding the hash to the received headers
which would make it so that end-users could test their connectivity to
their MTA easily.
And you could further extend it s.t. MUA's take the hashes from
the received headers and encode them into headers in their reply
so that the original sender could validate at least the first
hop---although this could be changed if the chain was MITMed on
the way back.  This, however, raises the bar a bit because to MITM
on the way there you will want to be convinced that you will be
able to MITM on the way back which may very well be quite some time
later and may go through a different path.
    Roland Dowdeswell

@_date: 2018-05-10 11:29:52
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] secure authentication ... as opposed to passwords 
provide much of the UI with which users actually interact.  They
are mostly libraries which are loaded into existing applications.
Currently, it is certainly possible for an application to understand
that a user may have multiple identities and select which one to
use in different circumstances.
In most installations, realms are mapped directly to DNS domains.
Realms provide a layer of indirection that allows administrators
to group subdomains into a single Kerberos realm to ease management.
Kerberos is actually much more similar to and aligned with DNS in
most installations than most other authentication solutions.  Cross
realm trust is by default hierarchical and follows the same patterns
as DNS delegation.
There is a standard for using Kerberos in HTTP and it is widely
implemented and used.
You have to work hard to enable DES support.  It is disabled by
default in both Heimdal and MIT Kerberos.  I don't recall that
there are any vulnerabilities with an HMAC which uses sha1.  sha2
is also supported.  Yes, 3des and rc4 are still supported for
compatibility with previous releases but no one is required to use
    Roland C. Dowdeswell

@_date: 2020-11-27 10:46:57
@_author: Roland C. Dowdeswell 
@_subject: [Cryptography] A Scheme for Verifiable Lottery 
A quite traditional way to do this sort of thing is to choose a
future event or set of events measured at an exact time which the
participants are unlikely to be able to influence in any meaningful
way and then feed a hash of said data into an appropriately secure
PRF used to choose the winner(s).
The difficulty is in choosing the inputs.  For small scale lotteries,
you can just use the results of a larger lottery on a particular
day as your input, e.g.
The key is to ensure that what you would need to influence to change
the results will cost more to influence than you could win in your
lottery.  And also, obviously, what you pick has to be unpredictable
enough to the participants that they can't game the system.
For a large scale lottery, you might be able to use something like
the closing price of a series of stock exchanges on a particular
day.  That would certainly meet the criteria that it is more
expensive to influence the results than you'd make from any given
lottery.  I'm not quite so sure about the unpredictability.  But,
then, you could make it harder to predict by, say, hasing every
single transaction on a series of stock exchanges over a two week
period or something.
    Roland C. Dowdeswell
