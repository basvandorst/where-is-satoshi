
@_date: 2017-12-14 15:58:05
@_author: Matt Palmer 
@_subject: [Cryptography] High volume thermal entropy from an iPhone 
I think if you replace "null" with "known" it's still the same issue: the
bitstream is predictable, which is a Bad Thing, even though it *looks*,
from the outside, like a stream of high quality random bits.
- Matt

@_date: 2017-12-20 11:22:10
@_author: Matt Palmer 
@_subject: [Cryptography] Rubber-hose resistance? 
One freshly generated key, which accesses an otherwise "clean" account (on a
DO droplet or whatever) that contains an encrypted (with a suitable
passphrase) bundle of temporary keypairs to anything I might *need* to
access.  Anything that I can get away with not being able to access for the
duration of the trip I just don't have access to.  Nuke all the temporary
keys at the end of the trip.  $DEITY-bless configuration management.
- Matt

@_date: 2017-12-20 16:05:10
@_author: Matt Palmer 
@_subject: [Cryptography] Rubber-hose resistance? 
Do you take into account the possibility of MitM attacks post-border
crossing, by making a record of the remote host key?  And if so, how?  Or is
your threat model focused on the border itself, and you don't have to worry
so much about on-going attacks thereafter?
- Matt

@_date: 2017-12-21 10:31:58
@_author: Matt Palmer 
@_subject: [Cryptography] Rubber-hose resistance? 
If your threat model is purely disclosure at the (immigration) border, this
works fine.  If you also need to protect against disclosure at the
(network) border once you're in-country, well, they'll figure out where
you're connecting to quickly enough...
And, of course, as was pointed out, if your threat model includes physical
modification of the device at the border, all bets are off.
- Matt

@_date: 2019-12-23 13:05:29
@_author: Matt Palmer 
@_subject: [Cryptography] OpenSSL: rsa_builtin_keygen: key size too small 
Based on a quick grovel through the openssl source, it looks like this limit
is hard-coded, and requires a rebuild of openssl to set the value smaller.
- Matt

@_date: 2019-12-23 20:34:19
@_author: Matt Palmer 
@_subject: [Cryptography] OpenSSL: rsa_builtin_keygen: key size too small 
LibreSSL != OpenSSL (the hint is in the different names).
- Matt

@_date: 2019-05-13 09:34:43
@_author: Matt Palmer 
@_subject: [Cryptography] peering through NAT 
It is not hard to find *someone* in support of any position.  It does not,
however, make it correct.  CGNAT is no better than per-CPE NAT, from a
privacy/anonymity perspective.
Common CGNAT equipment, for legal reasons, constrains each customer to a
fixed range of source ports on a single public IP, because it's a lot easier
and cheaper to log "customer X is on 192.0.2.42 ports 2000-2050" than it is
to log every outgoing connection's (IP, port, customer) tuple.
IPv6 is no better, of course, but it is also no worse.  Use random IPv6
addresses within the /64 assigned to your LAN, chosen for every single
outgoing connection if you really want it.  The first RFC specifying a
standard algorithm for assigning privacy addresses (RFC3041) is now old
enough to drink in civilized jurisdictions, so nobody who claims to be
knowledgeable in this area should be surprised by its existence.
With randomised IPv6 addresses, you get the same benefits as IPv4 NAT (CG-
or otherwise).  You can be associated with other connections from the same
ISP account in all cases.  There's always an ISP-assigned identifier --
whether that be an IP+port range, public IP, or /64 prefix -- that doesn't
change, but device-level associations have to be done a layer higher than
that of network addressing.
- Matt

@_date: 2019-05-17 16:17:52
@_author: Matt Palmer 
@_subject: [Cryptography] A two key file/program 
The *concept* you're looking for, I suspect, is Shamir Secret Sharing.  I
don't know of any implementations specifically for Windows (not really my
thing), but I'm sure with that keyword and a little bit of DDG-fu you'd dig
something up fairly quickly.
- Matt

@_date: 2019-09-09 13:28:50
@_author: Matt Palmer 
@_subject: [Cryptography]  
=?utf-8?q?tch_to_McEliece=3F?=
No, because trust anchors use public keys, not certificates.
- Matt

@_date: 2020-02-07 10:12:05
@_author: Matt Palmer 
@_subject: [Cryptography] SSL Certificates are expiring... 
When all you have is a hammer, everything looks like a thumb.
- Matt

@_date: 2020-06-06 20:51:03
@_author: Matt Palmer 
@_subject: [Cryptography] Cubbit 
I think they might have described it poorly.  There wouldn't be 36 full
"copies" of the data floating around if they're using Reed-Solomon; it would
be 36 chunks of data, each much smaller than the original block of data,
which, if you mash any 24 of them together, you can get back said original
block of data.  If I'm remembering my RS theory correctly, the overhead of
any (n, k) RS code is `k / n`, so in this case there's a 50% overhead in
storage, (but with N+12 redundancy, effectively).
I still wouldn't want to trust it with my data, because I don't like the
idea of the wrong twelve randos turning off their Cubbits causing all my
data to disappear, but the idea, in principle, isn't *quite* as bad as it
might have originally sounded.
- Matt

@_date: 2020-03-04 09:54:38
@_author: Matt Palmer 
@_subject: [Cryptography] Ex-CIA Joshua Schulte Describes His Data/Crypto 
I have several acres, and I can borrow the local fire truck.  Might be a bit
of a trip for y'all to get here.  If you send the drives and the thermite,
though, I'll post the videos.
- Matt

@_date: 2020-11-09 11:37:35
@_author: Matt Palmer 
@_subject: [Cryptography] reliable broadcast channel 
Doesn't "Reaching Agreement in the Presence of Faults" prove that if a
majority of participants are defecting, you *can't* reach consensus? Alternately, if over half the participants are coordinating, what's to say
their version of reality isn't the "correct" one, even if the other
participants disagree?
- Matt
