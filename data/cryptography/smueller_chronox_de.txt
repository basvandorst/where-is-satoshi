
@_date: 2013-12-01 13:27:03
@_author: Stephan Mueller 
@_subject: [Cryptography] Something weird about FIPS 140-2 
Am Freitag, 29. November 2013, 20:31:17 schrieb Watson Ladd:
Hi Watson,
The single operator requirement implies that the module is intended for a single purpose only. It has NOTHING to do with the single user mode of a Unix/Linux system.
For example, if you have, say, a system with a webserver that uses OpenSSL that itself hosts multiple users, you are in line with that FIPS requirement, because you only have one single user (read: purpose) of the lib and that is to serve that web server.
The reason for that requirement is that FIPS at level 1 does not place any requirement on the underlying environment. I.e. you could use something like DOS to host your system. As there is no requirement for process/memory separation, there is the requirement that the entire system is to be used for one dedicated purpose only.
Not sure what you are asking here.
This is FUD.

@_date: 2013-12-19 18:04:43
@_author: Stephan Mueller 
@_subject: [Cryptography] Fwd: [IP] 'We cannot trust' Intel and 
Am Donnerstag, 19. Dezember 2013, 07:56:36 schrieb Arnold Reinhold:
Hi Arnold,
There are various implementations of RNGs that use CPU execution timing variations as noise source. That phenomenon is available right from the start of the CPU. In fact, the patch in my Jitter RNG [4] for the Linux at system boot time, early in the boot cycle. This could be done for a Yarrow as well. I guess the other RNGs could be used in a similar So, there are noise sources which do not depend on some black box.
[1] [2] [3] [4]

@_date: 2013-12-22 23:16:45
@_author: Stephan Mueller 
@_subject: [Cryptography] Fwd: [IP] 'We cannot trust' Intel and Via's 
Am Freitag, 20. Dezember 2013, 15:46:32 schrieb Arnold Reinhold:
Hi Arnold,
Entropy can only exist if the process that shall produce it is non-
deterministic for the observer. That means that if you can audit the source of randomness to fully understand the full nature of the noise source, the noise source, by definition, does not produces entropy for you.
Also, considering that entropy is relative for every observer, all an entropy source can deliver is that any attacker is as unable to understand the true entropy source as you are.
Therefore, any audit can only have the goal to demonstrate that still nobody has full control or knowledge over the basic noise source.
That said, I am yet working on testing the CPU execution timing varations with my bare metal tester to develop some understanding why the variations occur. My current hunch which is not yet conclusive points to the timing variations of the CPu clock and the memory (including L2/L3) clock cycles which requires the CPU to introduce wait states to fetch/store data from/to memory.

@_date: 2013-10-18 15:09:08
@_author: Stephan Mueller 
@_subject: [Cryptography] /dev/random has issues 
Hi Ted,
There is one more strain on the entropy: ASLR. I provided a patch once ( that would have covered some aspects, but that was shot down with a link to a different patch -- see that thread.
Unfortunately, there is no fix for this issue as of now. Andrew mentioned an easy patch, which I think is not appropriate -- but Ted and Andrew think it is good.a
Ted, maybe it may be helpful to push either Andrew's or my the patch again, because that issue is a real strain.

@_date: 2013-10-24 17:06:58
@_author: Stephan Mueller 
@_subject: [Cryptography] /dev/random is not robust 
Am Donnerstag, 24. Oktober 2013, 05:06:16 schrieb Alon Ziv:
Hi Alon, Ted,
This issue is larger than SSHD, it covers dm_crypt too. Especially dm_crypt is vulnerable to this problem in case it is configured for full disk encryption. In this case, the installer generates the volume key as one of the first things during the initial installation. As this volume key cannot be changed for the lifetime of the system, it is highly important to have that generated properly (read: with good entropy).
Of course, you can say: well, installers have a graphical UI and therefore there is lots of mouse movements, etc. for /dev/random. But this is not always the case. Almost all distros allow an automated installation (anaconda allows that, the Debian/Ubuntu installer allows that, YaST too, ...), you can define automated installations with full disk encryption which only interrupt at the time when you have to provide the passphrase to protect the key. At that time, the key is already generated by libcryptsetup. But there was no real user interaction, no hard disk interaction and only limited interrupts to add entropy to /dev/random.
Using console-based installers is a bit better, but the user only needs to hit some keys before the volume key is to be created.
Now, you can say that is the responsibility of the Distros to catch that (e.g. require the user to hit a number of keys before generating the key), but I guess that approach is fragile.
I guess you can find many more examples of the issue where we need entropy at the time the current /dev/random code cannot provide that. I guess the only solution is to open up new entropy sources for that.

@_date: 2013-10-28 15:38:49
@_author: Stephan Mueller 
@_subject: [Cryptography] provisioning a seed for /dev/urandom 
Am Samstag, 26. Oktober 2013, 03:49:15 schrieb David Mercer:
Hi David,
But you have a CPU and a high-resolution timer. Thus, the CPU Jitter is measurable and thus usable from within a virtual machine. It would be great if Ted could pick it up for inclusion into /dev/random as another seed source.

@_date: 2013-10-28 16:27:07
@_author: Stephan Mueller 
@_subject: [Cryptography] [RNG] /dev/random initialisation 
Hi Sandy,
Thank you for summarizing that issue.
I do not think that this is helpful as any attacker is able to obtain such information as well. Thus, the information has zero entropy and can only be used to stir the pool more. If you stir in the time stamp when you invoke the commands, you may get entropy from that time stamp.
Furthermore, random.c is initialized so early in the boot cycle that neither the kernel nor user space has any ability to inject meaningful data to mix the initial state.
I would like to see the measurement they reference. However, I expect that 4 bits or more are based on the timer resolution being so high that no attacker can determine the precise device attachment time with a precision of more than 4 bits (e.g. 2**4 ns).
If we have such a high resolution timer, the CPU Jitter RNG will work as well. Thus, I took your suggestion and updated the CPU Jitter RNG patch to stir the entropy pools of random.c when they are initialized in My tests show that the jitter is all present at that time and can well be used to stir the pool. Please see  file That patch is such that at the time of init_std_data, 32 bytes (i.e. 256 bits) of entropy from the jitter is added to the entropy pool which is enough to already generate keys with sufficient strength.

@_date: 2013-10-28 17:41:44
@_author: Stephan Mueller 
@_subject: [Cryptography] [RNG] /dev/random initialisation 
Am Montag, 28. Oktober 2013, 12:35:29 schrieb Sandy Harris:
Hi Sandy,
You are right, I only considered scenarios where adversaries can log on. In your considered situation, I concur that the information does indeed add entropy.
Right. Also see the answer from the Debian developer on LKML today who says that on Debian the kernel log or similar is injected into Right. But I meant the time stamp as follows:
ifconfig > /dev/random
clock_gettime(CLOCK_REALTIME) > /dev/random
netstat > /dev/random
clock_gettime(CLOCK_REALTIME) > /dev/random
I fully concur.

@_date: 2013-10-30 19:11:53
@_author: Stephan Mueller 
@_subject: [Cryptography] FIPS 140 testing hurting secure random bit 
Am Mittwoch, 30. Oktober 2013, 07:20:11 schrieb Paul Hoffman:
Hi Paul,
Being a FIPS tester, I am called by NIST to enforce such or similarly strange requirements that at best do not help cryptography. Deviations are not an option...

@_date: 2013-10-30 19:14:32
@_author: Stephan Mueller 
@_subject: [Cryptography] My comments regarding using CPU jitter for 
Am Mittwoch, 30. Oktober 2013, 19:22:19 schrieb James A. Donald:
Hi James,
A fast clock on my design is important, but it accuracy is not. In fact, the less accurate the clock is, the better.
But do you have an idea how inaccurate that clock is?
Well, that only applies if the inaccuracy is more than one tick.

@_date: 2014-11-09 02:18:28
@_author: Stephan Mueller 
@_subject: [Cryptography] libkcapi: First release of kernel crypto API 
The Linux kernel exports a Netlink interface of type AF_ALG to allow user
space to utilize the kernel crypto API.
libkcapi uses this Netlink interface and exports easy to use APIs so that
a developer does not need to consider the low-level Netlink interface handling. Its first release is available at [1].
The library does not implement any cipher algorithms. All consumer requests
are sent to the kernel for processing. Results from the kernel crypto API
are returned to the consumer via the library API.
The kernel interface and therefore this library can be used by unprivileged
processes. As the library is small, it may even be included directly into a consuming application instead of using it as a shared library.
The library together with the kernel allows the use of symmetric ciphers as well as message digests and keyed message digests. Patches are prepared for submission to LKML to allow AEAD ciphers and RNGs to be used from userspace.
[1]

@_date: 2014-10-27 04:44:13
@_author: Stephan Mueller 
@_subject: [Cryptography] Auditable logs? 
Am Sonntag, 26. Oktober 2014, 20:28:13 schrieb Sandy Harris:
Hi Sandy,
What about using git as a log backend? Logically it is a chronological tracker based on a good cryptographic hash.

@_date: 2014-10-27 04:47:42
@_author: Stephan Mueller 
@_subject: [Cryptography] A TRNG review per day: RDRAND and the right TRNG 
Am Freitag, 24. Oktober 2014, 05:31:51 schrieb Bill Cox:
Hi Bill,
Another one: it is designed to cause a VM exit trap. I have a 10-line patch against KVM demonstrating this "nice" feature.

@_date: 2016-08-04 14:22:08
@_author: Stephan Mueller 
@_subject: [Cryptography] ChaCha20 DRNG 
As part of the development of my "Linux Random Number Generator -- a new approach to the Linux /dev/random" project, I implemented a DRNG based on This DRNG is now extracted into a standalone code base and is provided at [1]. The DRNG is completely standalone in the sense that it does not require services from any library other than libc. This implies that it implements all cryptographic aspects itself.
The implementation is very small with some 400 lines of code. The implementation draws ideas from SP800-90A, AIS 20/31 and Peter Gutmann's work:
* the DRNG seeds itself
* the DRNG reseeds itself when reaching a time-based or volume-based threshold
* the DRNG performs a continuous reseeding using a high-resolution time stamp
* the DRNG implements enhanced backward secrecy
A complete documentation, including its API is given at [1].
[1]

@_date: 2016-08-04 18:02:42
@_author: Stephan Mueller 
@_subject: [Cryptography] ChaCha20 DRNG 
Am Donnerstag, 4. August 2016, 15:48:30 CEST schrieb Jason Cooper:
Hi Jason,
I am all for it. I would be waiting for your patches. The only think I would like to add is the version functions as discussed below.
I am using signed git tags. But the tag numbers are derived from the macros. That is how I commonly maintain version numbers to allow compile and runtime access to such version information. I do that for a long time in my libkcapi But you are absolutely right, I should namespace them.
Right, I should copy that code from my libkcapi library. I have those void kcapi_versionstring(char *buf, uint32_t buflen)
        snprintf(buf, buflen, "libkcapi %d.%d.%d", MAJVERSION, MINVERSION,
                 PATCHLEVEL);
uint32_t kcapi_version(void)
        uint32_t version = 0;
        version =  MAJVERSION * 1000000;
        version += MINVERSION * 10000;
        version += PATCHLEVEL * 100;
        return version;
Ok, but I thought it is much easier to integrate one file into other code. But if you think that is the way to go, I will make it so.
Sure, but my plan was to have a full standalone implementation :-)
If you have a patch, let us discuss that.
Well, that is an interesting point: the internal seed sources are more and more en vogue, see SP800-90A for example. The caller should simply not think about that topic.
The code structure however is such, that you can easily add a seed source at compile time (just add 3 function calls). Thus, I am not in favor of a runtime-setable seed source
Let us discuss your patch :-)
Thank you for the review.

@_date: 2016-08-05 09:16:25
@_author: Stephan Mueller 
@_subject: [Cryptography] ChaCha20 DRNG 
Am Donnerstag, 4. August 2016, 22:38:51 CEST schrieb Patrick:
Hi Patrick,
Absolutely, this should be similar to the read(/dev/random) case:
syscall(__NR_getrandom, (buf + len), (buflen - len), 0);
Thanks for the bug report.
See getrandom(2) - there is a man page but no libc stub. It can break with EINTR and ERESTART.

@_date: 2016-08-06 11:59:48
@_author: Stephan Mueller 
@_subject: [Cryptography] [patch chacha20_drng 0/4] Small cleanups for 
Am Freitag, 5. August 2016, 19:21:51 CEST schrieb Jason Cooper:
Hi Jason,
Thank you very much for the changes. All have been applied and pushed to the github repo.
I have not released a new version, but bumped the version number in the C file to 1.2.0 already to indicate the change in your patch 4/4.
Do you plan to add more changes?

@_date: 2016-11-28 09:09:54
@_author: Stephan =?ISO-8859-1?Q?M=FCller?= 
@_subject: [Cryptography] Use of RDRAND in Haskell's TLS RNG? 
Am Sonntag, 27. November 2016, 22:06:02 CET schrieb John Gilmore:
Hi John,
Using a 6-line patch against KVM which traps RDRAND/RDSEED and returns 0 to a guest when the guest uses RDRAND/RDSEED, the VM-exit functionality is
