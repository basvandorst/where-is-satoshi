
@_date: 2002-08-05 16:44:28
@_author: Jack Lloyd 
@_subject: An authentication question 
In the second version, any random user (or script) could upload very large
files, wasting your bandwidth, and also CPU time when you check the sig. Or
lots and lots of really small files, which would swamp your CPU(s) trying
to check 500 sigs a second (makes for a good DDOS).
I don't see a difference from the standpoint of what ends up being stored
in the server, though. The second version is (mostly) safe from password
guessing, which is good. The first is easier for most users to figure out,
which is also good.
  -Jack

@_date: 2002-08-05 17:34:12
@_author: Jack Lloyd 
@_subject: An authentication question 
My point was that I can grind a big ass server running on a leased line to
a halt using my (hypothetical) 56K modem by sending out a bunch of tiny
files and random sigs for the big box to try to verify. A DDOS isn't really
needed, except to get around IP filtering (and there are other ways to do
that). I really don't know why I brought up a DDOS, actually. Just
rambling, I guess.
I wasn't considering bandwidth costs in my previous statement. I don't
think it's that important, which others can feel free to disagree with. The
actual denial of service, ie real users can't use the service and if
they're paying for it they could get quite upset, seems more important to

@_date: 2002-08-13 08:01:20
@_author: Jack Lloyd 
@_subject: P.G. Comba's paper on exponentiation 
Does anyone know where I can find P.G. Comba's paper "Exponentiation
Cryptosystems on the IBM PC", published in IBM Sys Journal vol 29? I have
looked everywhere and come up dry; a reference here and there, and that's
about it.
Was it republished somewhere under a different title, perhaps?
 Jack

@_date: 2002-07-19 14:03:07
@_author: Jack Lloyd 
@_subject: It's Time to Abandon Insecure Languages 
C++ gets this somewhat more right, it has a built-in string type that
handles allocation for you, so on and so forth. It's not perfect but it
does make a lot of things a lot safer (concatenation and string<->numerical
conversions in particular). Of course this depends on the C++ libraries
doing it right (IIRC just recently a buffer overflow was fixed in GCC's C++
A language that seems applicable to this discussion is E
( I haven't touched it but other people I work with
have, and we've been considering embedding it into a system being done

@_date: 2002-07-23 14:23:02
@_author: Jack Lloyd 
@_subject: building a true RNG (was: Quantum Computing ...) 
Perhaps they were refering to something like what is done in the
scheme whose exact details (or name) escapes me at the moment. This is
basically because it's called during interupts, and you might not want to
be calling out to something expensive like SHA-1 right then. Then when
someone reads from the device the output is derived from the internal pool
using SHA-1.
 Jack

@_date: 2002-07-29 16:24:36
@_author: Jack Lloyd 
@_subject: building a true RNG 
Somewhat related to that, are there any block cipher->hash function methods
that are actually secure? Every one I've ever read about seems to have been
  Jack

@_date: 2002-10-23 12:37:47
@_author: Jack Lloyd 
@_subject: comparing RMAC to AES+CBC-MAC or XCBC (Re: Why is RMAC resistant 
Which isn't even a new idea (it's done in ANSI X9.19, for example).
 -Jack

@_date: 2003-01-20 17:20:43
@_author: Jack Lloyd 
@_subject: Key Pair Agreement? 
A minor nit: G can be any random thing. While the generation of P and Q is
controlled entirely by the seed, G is not (though of course, IF you use the
method in FIPS 186, it will depend on P and Q, but will not be
deterministic). The value of H (see the FIPS) can be entirely random. Of
course you can mandate that in this protocol H be the smallest integer that
generates a working G, or something like that.
Another nit: Alice could, if she wanted, choose the same x every time.
Since P and Q would (presumably) change, this would change the public key
of course.
Actually, that makes me wonder. Given:
   y_i = (g_i^x) mod p_i for i 0...n
can you find x easier than you would with just y=g^x mod p? Obviously it
couldn't be any harder, but I wonder if there is any practical advantage
for an attacker there.
Are you asking this question because you want do actually do this, or
because you are interested in the problem? Practically speaking, having
Scott choose among a pool of N primes and sending one to Alice (who
generates a key pair using that prime) seems 'good enough', but doesn't
quite meet the requirements you specify.
The only idea that occurs to me for speeding this up is that maybe using
ECC would lead to a faster key generation step.

@_date: 2003-01-20 17:54:22
@_author: Jack Lloyd 
@_subject: Key Pair Agreement? 
STRING = LOW_64(SHA-1(SEED_FROM_SCOTT || SEED_FROM_ALICE))
seems simple enough.
However there is no way to be sure the RSA key is actually at all safe in
this case. For example, Alice could choose a 950 bit prime, and then
whenever she needed a new key, just choose a small (50 or 100 bit) prime as
the other factor. All in all the DSA case seems easier because there are
fewer things which an observer cannot verify.
Doing something like this for the DSA case (with y) might be nice, since
that would force Alice to choose a new x each time as well as new p,q,g.

@_date: 2003-01-24 15:02:15
@_author: Jack Lloyd 
@_subject: Shamir paper on fast factoring hardware 
I've put it up at  for any
interested parties who didn't just get a 200K email; it won't stay there
indefinitely but it will be around for at least a few weeks. Based on the
quote from Dr. Shamir I'm assuming this is OK with him.

@_date: 2003-03-06 10:32:27
@_author: Jack Lloyd 
@_subject: Proven Primes 
I believe the IPSec primes had been proven. All are SG primes with a g=2
Check RFC 2412, draft-ietf-ipsec-ikev2-05.txt, and
However, I don't seen any primality proof certificates included in the
