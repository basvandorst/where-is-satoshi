
@_date: 2006-10-26 13:23:06
@_author: Alfonso De Gregorio 
@_subject: Applications of target collisions: Pre or post-dating MD5-based RFC 
Hi All,
On 3rd march 2005, in a follow up to the announcement by Benne de Weger,
Xiaoyun Wang and Arjen Lenstra [LWdW], I wrote a note explaining how it
is possible to apply their method also for the construction of pairs of
colliding RFC 3161 [3161] time-stamp  tokens - my original note is
available at: However that construction based on random collisions do not posed a
significant  threat to RFC 3161 players, as all the opponent was able to
do was to show that  the target Time Stamping Authority not complied
with section 2.4.2 of the  standard.
In the time-stamping setting, a severe attack is an attack that allows
the opponent to obtain assertions of proof, signed by a target TSA, that
a datum  - possibly never processed by the time-stamping unit - existed
at a moment in time chosen at will.
Using the recent method by Marc Stevens to construct MD5 target
collisions  starting from two arbitrary IHVs [MS], and moving on the
construction of colliding  X.509 certificates for different identities
by by M. Stevens A. Lenstra and  B. de Weger [SLdW], it is possible to
construct two MD5 based time-stamp tokens with  different genTime,
serialNumber and messageImprint fields. These fields contain
respectively the time at which the token has been created by the TSA,
the  integer assigned by the TSA to each time-stamp token, the hash of
the time-stamped datum. Hence this allows also the pre-dating and
post-dating of  tokens and can have a severe negative impact on RFC 3161
based applications  that need to build a strong evidence of temporal
ordering of events  (e.g., RFC 3126, intellectual property protection).
In this email I'll not provide the construction details and an actual
pair of such colliding tokens, just a short outline.
The scenario consist in an opponent trying to generate simultaneously
two colliding time-stamp tokens, where the genTime field (or
messageImprint, or serialNumber) is different. The opponent can interact
with the target time-stamping unit, requesting it to issue time-stamps
for selected  messages.
In order to succeed in the attack, the following requirements need to be
1. the opponent need to hide random looking data in the target tokens;
2. the signed-data of time-stamp tokens need to have equal bitlength to
accommodate the Merkle-Damgard strengthening;
3. the opponent need to predict all fields appearing before the chosen
random looking strings.
Looking at the TSTInfo data structure (see the standard for more
details [3161]) and to the current implementations of RFC3161, it is
easy to see how all these  conditions can be dealt with by the opponent:
TSTInfo ::= SEQUENCE  {
   version                      INTEGER  { v1(1) },
   policy                       TSAPolicyId,
   messageImprint               MessageImprint,
     -- MUST have the same value as the similar field in
     -- TimeStampReq
   serialNumber                 INTEGER,
    -- Time-Stamping users MUST be ready to accommodate integers
    -- up to 160 bits.
   genTime                      GeneralizedTime,
   accuracy                     Accuracy                 OPTIONAL,
   ordering                     BOOLEAN             DEFAULT FALSE,
   nonce                        INTEGER                  OPTIONAL,
     -- MUST be present if the similar field was present
     -- in TimeStampReq.  In that case it MUST have the same value.
   tsa                          [0] GeneralName          OPTIONAL,
   extensions                   [1] IMPLICIT Extensions   OPTIONAL  }
(1) The opponent will use the nonce field to hide random looking data.
It is worth to note how the ASN.1 SEQUENCE provides an ordered series of
elements and the nonce field, if set, will appear in the DER encoded
data always after the genTime and before the tsa general-name.
More specifically, the opponent, using the method developed by M.
Stevens [MS], will construct two bit-strings that, when appended to the
two targeted messages, will turn them  into MD5 collisions. Here the
target messages chosen by the attacker contain, among others, the
genTime, serialNumber and messageImprint fields. This leads to the
aforementioned abuse scenario.
Though this may appear a bit overdone, the nonce field can contain huge
integers. The standards do not specify any additional size constraint on
nonces, hence  the maximum and minimum values for these ASN.1 integers
are those imposed by  the specific encoding rules (i.e.; DER).
(2) For any selected algorithm suite, the signed-data will have a
bitlength known a priori by the opponent. The fields that precedes the
nonce will have a bitlength known as well.
(3) With regard to guessing the signed values:
version: Constant value;
policy: Known for any given time-stamping unit;
messageImprint: Chosen by the attacker;
serialNumber: In several implementations, the serial number is
guessable, since it's a monotonically increasing number or a quantity
derived from the system time;
genTime: The value at which the genTime field will be set by the TSA
can be guessed depending on the accuracy of the clock (i.e.,the time
deviation around the UTC time contained in genTime) and the time
required  to send and consume the time-stamping request message (e.g.,
the half  round-trip latency plus the processing time);
accuracy: The accuracy is a public information and is typically equal
to  one second, or lesser values;
ordering: Known for any given time-stamping unit.
The detailed construction builds on the above considerations and the
resulting  time-stamp tokens will be syntactically well-formed and
obviously valid also  by a cryptographic standpoint, since their digital
signature can be successfully  verified by the relying parties.

@_date: 2006-10-27 08:09:20
@_author: Alfonso De Gregorio 
@_subject: [Cfrg] Applications of target collisions: Pre or post-dating 
Hi Steven, hi Benne,
Yes, this is a sweet and sour truth. We are not getting closer to
preimage attacks. We are getting more far away from considering preimage
and second-preimage resistance sufficient hash-function requirements for
the real-world security of some protocols.

@_date: 2010-04-20 15:35:59
@_author: Alfonso De Gregorio 
@_subject: Watermarking... 
Ciao Massimiliano,
You might be interesting in checking out the deliverables of BOWS contests at:
 and  From a cursory look at bookmarks...
- Peter Meerwald's implementation of digital image watermarking algorithms.
- Microsoft Audio Watermarking Tool

@_date: 2010-07-20 22:45:59
@_author: Alfonso De Gregorio 
@_subject: A Fault Attack Construction Based On Rijmen's Chosen-Text 
Quoting Jonathan Katz :
Dear Jonathan,
Thanks for your email. It is the only comment received so far and is  greatly appreciated!
I've been off the net for a much needed holiday and unable to reply  within the time I would have liked to. I'm sorry.
I can't speak for him, of course. Only Rijmen can tell and I'm adding  his address in cc.
Yet, I believe his emphasis was on the existence of zero-query attacks  on a symmetric encryption primitives -- he says the attack to be  zero-query as the adversary does not need to observe the ciphertext  the encryption oracle would output.
Now, I expect the unusual nature of the attack model might stir up a  lively discussion. My post was soliciting comments in this regard.
Still, I would like to respectfully disagree wrt the objectives given  to the paper, as to me the chosen-text relations model of analysis  appears to be interesting and relevant. There are two scenario worth  to be investigated:
Zero query
The first one is the plausibility and power of the chosen-text
relations model of analysis as presented in his paper. I believe
there might be applications endangered by zero-query attacks.
I claim this might be the case of white-box implementations; and I  could be wrong.
No roll back
The second scenario arise when we consider the avenues of
analysis provided by chosen-text relations if we revoke the
adversary ability to roll back the encryption. If we do that, we
restore the analysis model to a variant of the DFA, where the
attacker can query both oracles. So, no zero-query but still
chosen-text relations to be exploited.
In the fault attacks setting, we expect from encryption primitives  secure under related-key attacks resistance to attempts to recover the  secret key by attackers tampering with the stored secret and observing  the outputs of cryptographic primitive under the modified key  (interesting in this regard the paper by Bellare and Cash to the  upcoming Crypto on PRFs and PRPs providing RKA-security).
In a similar way, it would be fascinating to have symmetric encryption  primitives secure under related plaintext attacks (RPA). They would  provide resistance to attackers tampering with interim data, observing  faulty ciphertext and querying the decryption oracle, before engaging  in the key extraction step. (Of course, from the implementation side,  fault tolerance techniques could be employed to protect crypto modules  from attacks exploiting chosen-text relations.)
Thanks again.

@_date: 2010-06-14 16:40:03
@_author: Alfonso De Gregorio 
@_subject: A Fault Attack Construction Based On Rijmen's Chosen-Text 
The last Thursday, Vincent Rijmen announced a new clever attack on AES  (and KASUMI) in a report posted to the Cryptology ePrint Archive:  Practical-Titled Attack on AES-128 Using Chosen-Text Relations,  I believe the related-subkey model is an interesting model to look at  and, with this email, I would like to solicit comments from the  community about chosen-text relations attacks and their implications.
For example, this model might be pretty relevant while attacking  white-box implementations of the target encryption algorithm with  embedded secret key, assuming the ability to tamper with at least 1bit  of the round output (debugging...).
A Fault Attack
In order to further solicit comments, I would like to contribute a  fault attack construction based on chosen-text relations attack.
First, it is worth to note how the zero-query attack provided by  chosen-text-relations-in-the-middle can be transformed into an attack  with a single-query to both the encryption and decryption oracles. It  is possible to do so by resuming the interrupted encryption after  applying the specific difference delta to the state (ie, no rollback  anymore) and querying the decryption oracle.
More specifically:
- halt the computer in the middle of execution of an encryption routine;
- apply the specific difference delta to the state;
- resume the encryption and output the ciphertext c*;
- query the decryption oracle with c* and retrieve the modified plaintext p*---------------------------------------------------------------------
The Cryptography Mailing List
Unsubscribe by sending "unsubscribe cryptography" to majordomo at metzdowd.com

@_date: 2014-04-20 09:32:34
@_author: Alfonso De Gregorio 
@_subject: [Cryptography] Alternative to C and C++ for crypto programming? 
As nobody has mentioned it yet, I will. Cryptol [1].
Cryptol is a purely functional domain specific language, developed
over the past three lustra by Galois for the NSA, for the design,
implementation and verification of cryptographic algorithms. As
announced by Galois [2], Cryptol allows a cryptographer to:
- Create a reference specification and associated formal model.
- Quickly refine the specification, in Cryptol, to one or more
implementations, trading off space, time, and other performance
- Compile the implementation for multiple targets, including: C/C++,
Haskell, and VHDL/Verilog.
- Equivalence check an implementation against the reference
specification, including implementations not produced by Cryptol.
[1] [2]
