
@_date: 2001-08-14 22:10:55
@_author: Pawel Krawczyk 
@_subject: South Africa moves to increase Net-surveillance, limit crypto 
This is very similiar to the requirement that appeared
in Polish Internet surveillance law, described at Cryptome
( This requirement is targeted at
ISP that provide encryption facility for customer either as outsorcing
or included in PVC subscription etc.
Although I don't like the law and it would have catastrophical effect
on Polish Internet services market, this seems to be a quite logical
requirement. Its state is still unknown and probably won't be known
before the September Parliament election. And probably after that those
guys will have more serious problems to solve than surveillance, with
current predicions for budget deficit...

@_date: 2001-12-17 11:45:02
@_author: Pawel Krawczyk 
@_subject: Russian Duma Adopts Law On Digital Signatures 
Interesting how laws are passed in the part of world, as Polish digital
signature law was also passed with lots of private businesses being
done in both Parliament and Senate, against advice of the expert
comission created by the Parliament itself (sic!)  and agains the EU
recommendations. So we have the law enacted, but everyone is expecting
that to be changed soon to become usable, and definitely to make it
compliant with EU law.

@_date: 2001-09-17 20:57:16
@_author: Pawel Krawczyk 
@_subject: chip-level randomness? 
It works almost out of box, kernel detects the chip and if you have the
necessary device file created (character 10,183 AFAIK) you can use it to
read random data streams. It blocks sometimes when you read long blocks,
but it's quite obvious and it returns as soon as it collects enough data
to satisfy your request. What is important, it *doesn't* feed the built-in
Linux kernel PRNG available in /dev/urandom and /dev/random, so you have
either to only use the hardware generator or feed /dev/urandom yourself.

@_date: 2001-09-18 12:03:47
@_author: Pawel Krawczyk 
@_subject: chip-level randomness? 
It's not that stupid, as feeding the PRNG from i810_rng at the kernel
level would be resource intensive, not necessary in general case and
would require to invent some defaults without any reasonable arguments
to rely on. Like how often to feed the PRNG, with how much data etc.
On the other hand, the authors provide a `rngd' daemon, running in
userland, that reads the i810_rng device and feeds the data into kernel
PRNG. It seems to be reasonably written, with all the possible caveats
in mind, and you can control the feeding interval, block size and other
URI:

@_date: 2001-09-19 20:40:37
@_author: Pawel Krawczyk 
@_subject: chip-level randomness? 
Here I meant exactly what you said about /dev/random religion. On the
other hand feeding the /dev/random with i810 during normal system
operation is not bad idea, as /dev/random is not a PRNG but pool,
that can be emptied if not feed enough from other semi-random events
(interrupts, keyboard).
Ok, I get your point now. I'm not sure if reading a blocking device
(i810) from kernel is a very good idea, however. That's sort of things
that is very good suited for userland, when the system goes multiuser
and multiprocess.
Actually, it would be a quite good idea for the Linux distribution
vendors to add a "dd if=/dev/intel_rng of=/dev/random bs=1k count=1" to
the PRNG initialization scripts. If it fails, then you probably don't
have i810 and everything works the old way... Maybe it's even already
done, as the author of i810 daemon seems to be from MandrakeSoft.

@_date: 2001-09-20 09:28:54
@_author: Pawel Krawczyk 
@_subject: chip-level randomness? 
The rngd daemon by Philipp Rumpf I mentioned in previous posts does almost
exactly that. It runs a loop, that first reads 2500 bytes from i810,
then runs several FIPS 140-1 tests on the data and if it returns success,
it uses RNDADDENTROPY ioct to add this data to the kernel pool. Then it
checks current state of the pool with RNDGETPOOL and either sleeps for
some time or repeats the process. Seems to be reasonable both from the
security and performance perspective...
