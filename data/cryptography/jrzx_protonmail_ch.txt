
@_date: 2020-11-14 21:39:55
@_author: jrzx 
@_subject: [Cryptography] Lightning network 
For the lightning network to change from a single consistent state of who owns what part of each gateway unspent transaction output to another single consistent state is equivalent to the well known hard problems of a reliable broadcast channel, the Byzantine generals problem, the two generals problem, and acid transactions on a distributed database.
So when I looked at the lightning documents for a lightning layer on top of bitcoin I expected to see discussion of smart contracts on the bitcoin layer or lightning network protocols on the lightning layer for resolving these hard problems and eventually reaching a resolution. Not seeing them.
Instead what I do see is that the lightning network is safe because "misconduct" will result in you losing your bitcoins.
It will? Who do you lose them to? How is *misconduct* defined? Who decides *misconduct*? The guy who gets your bitcoins? Do we have a central banker of the lightning network somewhere?
A gateway does a unilateral transaction between the parties on the lightning layer controlling the gateway unspent transaction output by generating a new transaction on the bitcoin layer breaking up the gateway between the parties, and the parties refrain from committing that transaction to the blockchain, and instead endless generate new transactions, which do not get played either, thereby changing what part of the gateway is owned by each party to the gateway.
Well, what happens if someone commits an out of date transaction to the blockchain?
Suppose Alice's gateway to Bob is blocked because she now owns the whole of that gateway unspent transaction output, and her gateway to Frankie is blocked because Frankie owns all of that gateway.
So she organizes a transaction that moves bitcoin from the Ann/Bob gateway to the Ann/Frankie gateway. So what Alice intends is that Alice pays Bob, Bob pays Carol, Carol pays Dan, Dan pays Erin, Erin pays Frank, and Frank pays Alice. Except that in the middle the transaction Carol and Erin ungracefully disconnect from the network, so that either Ann generated a bitcoin layer transaction giving bitcoin to Bob, but Frankie did not generate a bitcoin layer transaction to Ann, or the other way around.
What happens then?
Does the central banker decide that Carol and Erin were engaged in misconduct and confiscate their bitcoin?

@_date: 2020-11-17 20:47:05
@_author: jrzx 
@_subject: [Cryptography] IPsec DH parameters, other flaws 
Presumably because TCPng would give them an edge.
TCP was designed in more trusting times, when the name system consisted of a widely shared hosts file, and everyone trusted everyone.
Over the years people have piled warts on top of TCP and warts on top of warts to fix one problem after another, and every fix results in additional round trips
Thus "Cloudfare is checking your browser, you will be redirected shortly"
Every additional round trip before a web page comes up results in a significant loss of viewers.
TCP is a major problem, which is slowing down the internet. DDOS protection and the certificate mess are warts growing on top of warts.
If TCPng fixes those warts, you get more views.
TCPng needs to reply with a proof of work request when a client requests a connection, as the second phase of the four phase handshake, where the work demanded goes up as the server load increases, thus fixing the horrors of DDOS protection.
Key agreement needs to be part of the TCPng handshake, rather than a layer on top, to reduce round tripping.
The name system needs to be integrated with the key system, so that you get the key when when you get the network address associated with the name, and the key/name pairing needs to be blockchain secured, so you don't have one thousand certificate authorities each with the authority to mount a man in the middle attack.
The TCPng handshake needs to be a four phase handshake.
Client->Server:  Give me a connection, here are my parameters, here is my session key.
Server->Client:  Here is a proof of work request, my parameters, and a keyed hash of your and my parameters.  Ask again with proof of work, the same parameters, and the keyed hash.
Server then throws away the request, allocating no memory.
Client->Server:  OK, here I am again, with all that stuff you asked for.
Server checks the keyed hash to ensure that this is a real client reply to a real and recent server reply.  Then it checks the proof of work.
If the proof of work passes, Server allocates memory, generates and stores a session key, and stores connection parameters, the client and server session keys among them.
Server->Client:  OK, here is my session key, authenticated but not signed by my permanent key, and stuff, now you can start sending actual data.
Thus we can integrate TCP handshake and encryption hand shake and the innumerable DDOS protection handshakes  "Cloudfare is checking your browser, oops, your browser did not pass, here is a captcha" at the cost of one single additional trip, half a round trip.
Instead of the person establishing the connection fuming while round trip after round trip goes through, we get all that stuff at the cost of one additional half round trip.
To authenticate but not sign a session key, the connection symmetric encryption key has to depend on a shared secret established by the client session key and server session key, and also on the client session key and the (server session plus permanent key)
If the server session secret key is _server_, the server durable key is $server_identifier$, the client session key is $client$, and the corresponding public keys are $Server$, $Server_Identifier$, and $Client$, then the shared secret used for symmetric encryption depends on the following private secrets:
$client * Server$ and $client * (Server + Server_Identifier)$
Which are equal to:
$Client * server$ and $Client * (server + server_Identifier)$
The operation of deriving a third elliptic point from two elliptic points is represented as addition, and the public elliptic points are distinguished from their corresponding secret scalars by capitalization.
This procedure gives perfect forward secrecy (since the session keys only live in volatile memory and are erased when a session ends) and deniable authentication.  The client can prove to himself that a message came from the party that knows the durable secret key $server_identifier$, but cannot prove it to anyone else.

@_date: 2020-11-23 08:00:30
@_author: jrzx 
@_subject: [Cryptography] IPsec DH parameters, other flaws 
Does your implementation use OpenSSL, or Google's fork of OpenSSL?
Where is your implementation?
