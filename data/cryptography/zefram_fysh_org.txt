
@_date: 2002-12-13 20:01:36
@_author: Zefram 
@_subject: snake oil alert: "Polymorphic Encryption Method"? 
This lacks a lot of the usual snake oil signs.  There is actually
a paper there that describes the design of the new cipher, there is
little invented crypto terminology, the standard terminology is used
mostly correctly.  The author is clear that what he has isn't a one-time
pad.  On the down side, the paper describes a method of cipher design,
rather than a specific cipher, the analysis is very inadequate, and the
description is tied to a particular machine architecture.  On the whole I
get the impression of someone who genuinely thinks he's had a good idea,
and has tried to do the right thing (by publishing his idea), but has
made a couple of basic mistakes, starting with his expectation that he
can do better than any of the major published ciphers.
The basic idea of the "polymorphic cipher" is to be to combine simple
elements in a key-dependent arrangement.  The author seems to be using
this technique in much the same way that Schneier uses key-dependent
S-boxes in Twofish, to frustrate analysis.  The problem is that in the
case of the polymorphic cipher this is the *only* source of strength in
the algorithm.  Of course, this makes analysis of the security of the
algorithm extremely difficult.  To the author's credit, he does point
out this difficulty, but he seems largely oblivious to the uselessness
of an unanalysable cipher.
The paper's analysis of the cipher's vulnerability to DPA is particularly
amusing.  The structure of the cipher naturally leads to key-dependent
code paths, which of course make it unusually vulnerable to DPA, timing
analysis, and other forms of side channel cryptanalysis.  Yet the
author considers only the code segment that *selects* which code path
to follow; he claims to show that that part can be made to execute in
constant time, and on that basis states that the entire cipher can be
made resistant to DPA.  His claim even for that small code segment is
fundamentally flawed.  My impression here matches the impression I get
from the rest of the paper: he's heard of side-channel cryptanalysis,
but not really understood how it works.

@_date: 2002-02-16 22:15:02
@_author: Zefram 
@_subject: theory: unconditional security 
I've been looking at cryptographic protocols that give unconditional
security -- I'm interested in some of the possibilities that go beyond
what a simple one-time-pad can achieve -- and I'm having difficulty
in finding published papers on the subject.  Applied Cryptography only
describes the classical one-time-pad, noting "a one-time-pad provides
no authenticity", and doesn't go any further.
I've found a description of a construction of a MAC giving unconditional
integrity: if we have a message M where 0<=M<p (p prime), and a key
K=(a,b) where 0<=a,b<p, then we can calculate a MAC m_K(M) = a + bM
(mod p).  That source suggested sending (M, m_K(M)) as a message which a
man in the middle cannot successfully fake (because he can't generate the
MAC); it suggested that to get secrecy as well one should have another
key k, 0<=k<p, and send (M+k mod p, m_K(M)), which is a one-time-pad
encrypted message plus MAC.
However, that MAC system misses the possibility that, if we add the
constraint b!=0, the message M can be recovered from m_K(M) by the
recipient (who knows K).  So it's actually possible to have unconditional
secrecy and integrity with the key only twice as long as the message,
transmitting only m_K(M) = a + bM (mod p), if one can detect a fake
message by it being nonsensical.  (Any modification to the transmitted
m_K(M) will cause the decryption process to generate garbage over which
the attacker has no influence, which seems a reasonable definition of
unconditional integrity.  One can make the chance of a successful spoof
arbitrarily small by making the message space arbitrarily sparse --
e.g., require that the message be a multiple of 2^42 -- and so this
is more flexible in the level of integrity it can provide than the
message-plus-MAC scheme is.)
I've not been able to find any paper that describes the use of this
algorithm to give unconditional secrecy and integrity at once.
Nor have I found any paper describing doing this (as MAC or as
secrecy-plus-integrity) in GF(2^n), which makes it convenient to operate
on bit strings.  This seems so stunningly useful that I'm surprised it's
not mentioned in AC.
Can anyone point me at references that I'm missing?

@_date: 2003-12-08 13:53:44
@_author: Zefram 
@_subject: yahoo to use public key technology for anti-spam 
It seems to still exist -- draft-danisch-dns-rr-smtp-03 is dated 2003-10

@_date: 2004-04-06 10:33:54
@_author: Zefram 
@_subject: [Mac_crypto] Apple should use SHA! (or stronger) to authenticate software releases 
This disucssion suggests a simple countermeasure: put something at the
beginning of the package that depends on all the significant content
of the package.  For example, the first file in the archive could be
a list of digests of individual files.  This means an attacker has to
either process the entire archive in searching for a collision or find
tweakable space not covered by the leading checksum file.
Having such dead space (not trivially checksummed) is quite likely in
an uncompressed archive.  For example, tar pads each file to an integral
multiple of its block size.  However, compression of the entire archive
will make such space more difficult to arrange.
A more extreme approach that removes that risk entirely is to take
the digest of two concatenated copies of the package.  Precalculation
can still be used to speed up the search for a collision, but the
unoptimisable tail is now guaranteed to be at least as long as the
entire package.  I see a couple of potentially useful variations on this:
Are these approaches sound?  I'm a crypto-plumber, not a cryptographer.
I'm wondering whether we can define a new type of cryptographic primitive
here: the non-precomputable message digest.  The interesting feature of
an NPCMD would be that computing the digests of two related messages
cannot be optimised to take any less time than the computation of the
digests of two unrelated messages of the same sizes.  The suggestions
I made above are clearly not NPCMDs, but if one does
with Digest being a good conventional message digest, then this appears to
approach a NPCMD as n approaches infinity.  Of course, computation time
for this construction is linear in n (for a particular message size),
so this is not a practical way to achieve this goal.  Can a NPCMD be
done in a more reasonable time?  I imagine structures that might lead
to O(l*log(l)) time, where l is the message length, but that's just
my speculation.
