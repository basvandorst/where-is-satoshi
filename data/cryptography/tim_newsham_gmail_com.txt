
@_date: 2013-10-08 18:44:00
@_author: Tim Newsham 
@_subject: [Cryptography] Iran and murder 
The same could be (and has been) said about offensive cyber warfare.

@_date: 2013-09-07 19:42:33
@_author: Tim Newsham 
@_subject: [Cryptography] MITM source patching [was Schneier got spooked] 
Jumping in to this a little late, but:
perhaps, but they would risk being noticed. Some people check file hashes
when downloading code. FreeBSD's port system even does it for you and
I'm sure other package systems do, too.   If this was going on en masse,
it would get picked up pretty quickly...  If targeted, on the other hand, it
would work well enough...

@_date: 2013-09-08 07:47:37
@_author: Tim Newsham 
@_subject: [Cryptography] MITM source patching [was Schneier got spooked] 
Git already supports signed comments. See the "-S" option to "git commit.
If you're paranoid, though, that still leaves someone getting on your
dev box and slipping in a small patch into code you're about to commit, or
just using your pgp keys themselves...
Next problems -- getting the right key to verify against.  Knowing what sets
of keys are allowed to sign for a particular project.

@_date: 2013-09-16 11:54:13
@_author: Tim Newsham 
@_subject: [Cryptography] AES [was NSA and cryptanalysis] 
John Kelsey discusses several attacks that might fit this
profile but one he did not consider was:
- A backdoor that leaks cryptographic secrets
consider for example applications using an intel chip with
hardware-assist for AES. You're feeding your AES keys
directly into the cpu. Any attacker controlling the cpu has
direct access and doesn't have to do any fancy pattern matching
to discover the keys. Now if that CPU had a way to export
some or all of the bits through some channel that would also
be passively observable, the attacker could pull off an offline
passive attack.
What about RNG output? What if some bits were redundantly
encoded in some of the RNG output bits which where then
used directly for tcp initial sequence numbers?
Such a backdoor would be feasible.

@_date: 2013-09-19 22:42:59
@_author: Tim Newsham 
@_subject: [Cryptography] The Case for Formal Verification 
With all due respect, most of the points you make are ridiculous.
For example, you point out that the certified C compiler will not
make any guarantees about code that relies on undefined behavior.
Well, of course! Being certified doesn't magically fix your specification!
Certified just says the implementation matches the specification!
And to suggest that such a project is misguided because it places
blind trust in coq (and because it is written in ocaml?!) shows a
misunderstanding of the proof tools. There is a very small core of
trust that you need to have faith in and it is backed by solid theory
and is a much more solid foundation for building on than just about
any other software we have in computer science. I don't see how in
any way you can compare the f2c translator to this effort.

@_date: 2013-09-20 09:36:55
@_author: Tim Newsham 
@_subject: [Cryptography] The Case for Formal Verification 
I don't find it misleading at all and I think perhaps the
confusion is your notion of what formally verified means.
What I am saying is that you do not need to trust the coq code.
There is actually very little of the coq tool that you do need to
trust. That is the part of coq that performs type checking. The
type checker is what verifies proofs.  It is a small part of coq and
most of coq is not trusted and generates terms that still must
pass the type checker. Neither do you need to put a lot of faith
in the ocaml compiler, the cpu or spend a lot of time worrying about
cosmic rays flipping the bits during computation.  Yes, some flaw
could potentially lead to an incorrect computation on a certain cpu
or a certain memory bit in a certain machine during a certain computation.
But the coq type checker has been compiled on many machines and
with many versions of the ocaml library and the odds of a random error
behaving in a way that just happens to validate an invalid proof term
more miniscule (as in, I would be more worried about your spontaneously
tunneling into my livingroom due to quantum effects to resume the rest
of this conversation).
There is a small part of coq that you DO have to trust. If this part
is incorrect it could invalidate all of the proofs. However, this part
of coq is backed by strong theory and has had many eyes on it.
And while it is possible that an error here could lead to a bad proof,
it is by no means assured.
