
@_date: 2014-04-18 21:41:08
@_author: Jason Cooper 
@_subject: [Cryptography] Open Source developer employment agreements, 
It would be great if we could get an organization such as the EFF to
sponsor writing some template contracts.  A guide to negotiating such
percentages, and recommended brackets based on experience would be
a big step forward.
I think this would be beneficial not just to core developers, but also
to hobbyists, small projects, etc.  It would just affect the negotiated
This is critical to folks who are increasing their presence in the open
source community as well.  They start out as hackers, scratching an
itch, gain experience, then get hired (a net loss for the community).
Something like the program mentioned above would help protect the
community's time investment in newer contributors.  It would also give
those same developers the most precious resource they need to grow into
core developers: time.
I also think this extends well beyond code cleanup.  Virtually every
open source developer I've ever spoken with has a (lengthy) list of
improvements, features, projects, and cleanups they simply don't have
time for.  I know I do [1], [2]...
[1] [2]

@_date: 2014-04-28 09:58:04
@_author: Jason Cooper 
@_subject: [Cryptography] paper code review, was: Re:  bounded pointers in C 
I've found a magnetic whiteboard and a bunch of business card sized
refrigerator magnets works great.  It's much easier than a table.

@_date: 2014-02-03 14:59:47
@_author: Jason Cooper 
@_subject: [Cryptography] The crypto behind the blackphone 
It'd be a shame if we had to wait for an open, secure baseband in order
to trust our phones.
There are things which can be done today to mitigate a lot of concerns
without needing the full monty of open source baseband.  Unfortunately,
the economic incentives aren't there for most phone manufacturers to do
Traditionally, on the board, the BP has been king.  It is the first
thing to light up and has read/write access to all of flash/RAM.  Hence
the problem. :)  Instead, one could design a phone more like a laptop
system with a USB broadband card.
iow, the AP would be king, and the BP would be just a peripheral with no
privileged access to anything other than it's own resources.  When the
user puts the phone into airplane mode, the OS could actually toggle a
GPIO regulator controlling power to the BP.
Instead, I know many people, including myself, that frequently enable
the pin on the SIM card.  Then reboot without typing in the correct pin.
Alternatively, one can physically remove the SIM.  It'd be nice if
airplane mode did what people think it does/should do.
The are many peripherals on embedded ARM which already use out-of-band
signalling like this, typically they're wifi/bt chips attached via
sd/mmc.  So this isn't anything new.
For the highly security-conscious, the AP could have read access to the
BP's flash.  A user (or startup script) could cryptographically sign the
image when they first turn on the phone.  From then on, it would be
checked before allowing the BP to load and execute.  Not perfect, and no
replacement for a full audit.  But at least you would know when your
baseband has been changed.

@_date: 2014-09-13 15:08:36
@_author: Jason Cooper 
@_subject: [Cryptography] RFC possible changes for Linux random device 
+ Ted Ts'o, H. Peter Anvin
This is easy to say, but difficult to confirm.  ;-) See my trailing
This has been discussed before, and I don't believe anyone is directly
opposed to it.
Here's my recommendation:  Follow the instructions below to generate a
patch against the current, mainline kernel tree.  Then post the patch to
lkml with Ted Ts'o, and H. Peter Anvin on the Cc.
We need to see a diff against the mainline tree because it allows us to
more easily review your idea(s).
Before submitting, there are a few quick and easy things you can clean
up before submitting the first version.  You could review
./Documentation/SubmittingPatches, or just run ./scripts/checkpatch.pl on
your patch.  I wouldn't worry about removing _all_ warnings, just clean
up all the big ones.  At any rate, give this a whirl:
*If you already know git, then this is just a post for posterity  ;-)
--- Begin ---
# pull down a copy of Linus' tree
$ cd
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
$ cd linux
# tell git who the developer is
$ git config --add user.name "Sandy Harris"
$ git config --add user.email "preferred_email_in_git_history"
# create a branch for your changes, based on a mainline tag
$ git checkout -b random_aes128 v3.17-rc1
# copy your code in
$ cp .../path/to/random.c ./drivers/char/random.c
# take a look at the diff, are there
#  - unnecessary whitespace changes?
#  - needless renamings?
#  - unnecessary function re-ordering?
$ git diff
# cleanup as necessary
$ $EDITOR drivers/char/random.c
# run checkpatch
$ git diff | ./scripts/checkpatch.pl -
# build test
$ make defconfig
$ make -j9 -q bzImage
# repeat the last three steps until the errors are gone and the
# checkpatch warnings are few / debatable (remember, it's a tool, not a
# human)
# commit the result
#   NOTE: '-s' adds the 'Signed-off-by: Name ' to the commit
#   Please read the Developer's Certificate of Origin:
#     #   And *only* add '-s' if you agree to the DCoO.
$ git commit -a -s
# in the editor
E> random: Convert to aes128-gcm for mixing.
E>   patch solves it, and include any relevant metrics validating the
E>  claim>
E> Signed-off-by: Sandy Harris # create a patch file
$ git format-patch --no-thread --no-cover-letter -N v3.17-rc1..random_aes128
# And send it
$ git send-email --to="Theodore Ts\'o " \
Please look at 'git send-email --help' for the smtp options you'll need.
--- End ---
I wrote this from memory, so there's probably a typo or three. :)  If
you get stuck, shoot me an email and I'll be happy to assist.
A fair head's up:  You're going to get a lot of warnings on comment
style.  Single-line comments are '/* ... */' and multi-line are:
Yes, there are many ways to do it, but I always try to conform to the
style of a given project so it's consistent within that tree.

@_date: 2014-09-13 15:51:35
@_author: Jason Cooper 
@_subject: [Cryptography] RFC possible changes for Linux random device 
Right, I'm a big advocate of involving everyone early in the process.
Adding 'RFC' to the patch submission (which I forgot to mention) lets
kernel folks know that the code isn't ready for inclusion.
There's no reason you couldn't cross-post to both lists.  Ted Ts'o
previously asked if conversations regarding implementations (patches,
etc) were welcome on the cryptography list and he received no
I've seen bigger :)  As long as each patch contains one logical change,
and the code still builds after each patch, we'll figure out a way to
handle it.
I would highly suggest trying out the git workflow I posted.  Using 'git
diff' alone will show you exactly what you've changed and then you'll
have less work to do later.  I know workflows are highly-specific to
the developer, so whatever works for you is fine.

@_date: 2014-09-14 01:05:27
@_author: Jason Cooper 
@_subject: [Cryptography] Validating large code cleanups using git and objdiff, 
That's why I wrote ./scripts/objdiff.  I wanted to add skein/threefish
to the kernel, starting with an established code base.  Huge whitespace
changes were necessary to convert it to the kernel coding style.  I sent
it through the staging tree since it's for drivers requiring a lot of
You can see the series with (newest on top):
$ git log --oneline -- drivers/staging/skein/
df37d1ac58d9 staging: skein: fix sparse warning for static arrays
7eb843aa5050 staging: skein: fix sparse warning for static declarations
007dfe5ad6d0 staging/skein: variable/member name cleanup
a82100e78cdf staging/skein: comment typos
0109ce7304af staging/skein: move all threefish block functions to one file
85dfd522f885 staging/skein: rename files and clean up directory structure
0264b7b7fb44 staging: crypto: skein: rename macros
9435d3ace68a staging: crypto: skein: rename enums
3201b7f25e3b staging: crypto: skein: rename skein1024_ctx to skein_1024_ctx
95f1840a7e76 staging: crypto: skein: rename camelcase vars
68ace624a6cd staging: crypto: skein: rename camelcase functions
6559e221a187 staging: crypto: skein: depend upon CRYPTO
c5ace7bf7a4d staging: crypto: skein: add TODO file
fc9824747c20 staging: crypto: skein: remove unnecessary line continuation
7584a878712c staging: crypto: skein: remove braces from single-statement block
906b492e770d staging: crypto: skein: remove externs from .c files
522e358d2d4f staging: crypto: skein: wrap multi-line macros in do-while loops
161a2afdf50a staging: crypto: skein: fix brace placement errors
51cc00fd1eb0 staging: crypto: skein: fix do/while brace formatting
60eb817520c9 staging: crypto: skein: cleanup >80 character lines
06a620f09ec4 staging: crypto: skein: remove trailing whitespace
39bd42b0855f staging: crypto: skein: fix leading whitespace
e6d336f5c68c staging: crypto: skein: dos2unix, remove executable perms
a0d5dd843235 staging: crypto: skein: cleanup whitespace around operators/punc.
cd4811a64cbb staging: crypto: skein: fixup pointer whitespace
b9761ccb553a staging: crypto: skein: use u8, u64 vice uint*_t
11d9ffb2caec staging: crypto: skein: remove all typedef {struct, enum}
2ab31bba2d7c staging: crypto: skein: remove unneeded typedefs
8eee37872e84 staging: crypto: skein: remove __cplusplus and an unneeded stddef.h
da13dfd7e6e7 staging: crypto: skein: remove skein_port.h
5057bbbe74a0 staging: crypto: skein: remove brg_*.h includes
c2c7426bfcf2 staging: crypto: skein: allow building statically
449bb8125e3f staging: crypto: skein: import code from Skein3Fish.git
To verify the series:
  1) checkout the first one (449bb8125e3f) and verify the sha256sums
     listed in the commit message
  2) checkout the second commit (c2c7426bfcf2) that allows building
     within the tree, and audit the commit by hand
  3) follow the instructions in the comments of objdiff to validate the
     series doesn't change the generated object code.  You'll start with
     the second commit (c2c7426bfcf2) and work your way up to my last
     commit, 0264b7b7fb44.
In the future, I'm looking at enhancing radare2's [1] rdiff tool to
output a normal looking diff (red=remove,green=add) with the enhancement
that identical object code with different addresses be in yellow.  Then
I'll add recording the object file itself to objdiff.  This should allow
an auditor to validate code changes even when linking order or renames
occur (85dfd522f885, 0109ce7304af above).
As for skein/threefish, it's still a work-in-progress, as time permits
:-P  Patches welcome.
Caution: Some toolnames NSFW :)
[1]

@_date: 2014-09-14 01:05:52
@_author: Jason Cooper 
@_subject: [Cryptography] RFC possible changes for Linux random device 
Here's the 101st:
  - have existing /etc/init.d/urandom scripts also dd 512 bytes into
    /boot/random-seed
  - on boot, bootloader reads /boot/random-seed into memory and hands
    the address/size to the kernel.
  - optionally, if the user trusts the SoCs hwrng, the bootloader could
    read 512 bytes from it into memory instead.  Or, mix it with
    random-seed.
The kernel decompressor can use some for initializing KASLR, and the
rest can be used when the entropy pools are initialized.
This doesn't solve the problem of first-boot, which is unfortunately
when some long-term keys are generated.  It does facilitate solving the
problem, though.  System implementers who care can provision the
random-seed from an established entropy source at the same time they
provision the board mac addresses (I'm referring to embedded systems
which store their mac addresses in the bootloader's environment)

@_date: 2015-01-05 08:33:32
@_author: Jason Cooper 
@_subject: [Cryptography] 
I would be interested in taking a look, if you wouldn't mind digging it

@_date: 2015-03-17 18:42:27
@_author: Jason Cooper 
@_subject: [Cryptography] Kali Linux security is a joke! 
You can do further verification here:
  Which includes instructions for retrieving their PGP key, and verifying the
sha1sums of the isos.
Kali is based upon debian.  Debian relies on package signing with PGP keys.
There's still a valid argument for not advertising *which* packages you are
installing/updating (some may be illegal in some regions).  But short of a repo
key compromise, an http-MITM isn't going to succeed.

@_date: 2016-08-04 15:48:30
@_author: Jason Cooper 
@_subject: [Cryptography] ChaCha20 DRNG 
Hi Stephan,
I took a quick look.  Small, concise, clean. :)  If you don't mind, I'd
like to send some patches for you to review.  I have a couple of things
in mind:
 - namespace the version number macros, or use signed git tags [1]
    - add version number call to the API
 - split the different seed sources out to separate files
 - Allow other chacha20 implementations (e.g. libsodium)
 - work towards baremetal
    - replace/remove printfs (add a log() cb?)
    - tolerate no internal seed sources / set a cb
    - add seed save/restore cbs.
    - other items I don't recall off the top of my head
[1]      I have a better version locally, does latex and raw version number
     output.

@_date: 2016-08-05 15:39:13
@_author: Jason Cooper 
@_subject: [Cryptography] ChaCha20 DRNG 
Good spot.  :)
If he's taking care to avoid assignments within conditionals:
  if (0 < ret)
and he bothered to account for short writes, then I presume he would
want to do that accounting correctly.

@_date: 2016-08-05 16:17:32
@_author: Jason Cooper 
@_subject: [Cryptography] ChaCha20 DRNG 
Hi Stephan,
Sure, I'll break out that one for comment and give an explanation for why I
like it.
Yes, this is better, then you can remove the macros from the public API.
Well, I completely agree with making it easy to use the code.  But I'd
also like to make other configurations doable.  A good example is
SQLite.  It's repo is multi-file, with the ability to merge it into one
file for those that chose to do so.  Also, shared and static libs work
Sure.  On small systems, there's no need to waste space by having a
chacha20 implementation here as well as in another lib.  So we can make
the default to use INTERNAL_CHACHA20.  Easy for the common case,
configurable for others.
We agree.  I'm thinking of baremetal/zephyr/rtos.  I'd like to make it
possible to build in your own for your HW.
It's in the "user shouldn't have to think too much" vein.  Set the
callbacks, and the lib occasionally saves a seed to disk for reading
after reboot.  Similar to /etc/init.d/urandom in Linux userspace.
Understanding that it takes a while to gather sufficient entropy on
embedded systems (with or without Linux), A tapering off series of
writes would be very advantageous, modulo flash wear.  Especially on
systems where the shutdown sequence amounts to power being removed.

@_date: 2016-08-05 19:21:51
@_author: Jason Cooper 
@_subject: [Cryptography] [patch chacha20_drng 0/4] Small cleanups for 
Hi Stephan,
I've run out of time today, so I'm sending what I have so far.  Mostly
cleanups.  There are two API changes you should review carefully.  I think it's
best to make them now before people start actually using them and depending on
For those who prefer to pull via git:
  git://git.infradead.org/users/jcooper/chacha20_drng.git jason/changes
Jason Cooper (4):
  Add .gitignore file
  doc: Update license block to match source code
  API: Remove version macros
  API: Make _versionstring return snprintf() errors
 .gitignore             |   5 +
 COPYING                |  33 +++++
 COPYING.bsd            |  26 ++++
 COPYING.gplv2          | 340 +++++++++++++++++++++++++++++++++++++++++++++++++
 Makefile               |   6 +-
 chacha20_drng.c        |  26 +++-
 chacha20_drng.h        |  23 ++--
 doc/drng_chacha20.tmpl |  25 +++-
 8 files changed, 455 insertions(+), 29 deletions(-)
 create mode 100644 .gitignore
 create mode 100644 COPYING
 create mode 100644 COPYING.bsd
 create mode 100644 COPYING.gplv2

@_date: 2016-08-05 19:21:52
@_author: Jason Cooper 
@_subject: [Cryptography] [patch chacha20_drng 1/4] Add .gitignore file 
Covers vim temp files and generated binaries.
Signed-off-by: Jason Cooper  .gitignore | 5 +++++
 1 file changed, 5 insertions(+)
 create mode 100644 .gitignore
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 000000000000..e353b6a6c1a1
--- /dev/null
+++ b/.gitignore
 -0,0 +1,5

@_date: 2016-08-05 19:21:53
@_author: Jason Cooper 
@_subject: [Cryptography] [patch chacha20_drng 2/4] doc: Update license block 
The source file chacha20_drng.c clearly states that this code is
dual-licensed.  3-clause BSD, -OR- GPLv2.  Update the documentation to
match it.
COPYING.bsd retrieved from openconnect.git/COPYING.mbsd
COPYING.gplv2 retrieved from linux.git/COPYING, edited to remove Linus'
comment at the top as it pertains specifically to the kernel.
COPYING is word-for-word from chacha20_drng.c.
Signed-off-by: Jason Cooper  COPYING                |  33 +++++
 COPYING.bsd            |  26 ++++
 COPYING.gplv2          | 340 +++++++++++++++++++++++++++++++++++++++++++++++++
 doc/drng_chacha20.tmpl |  25 +++-
 4 files changed, 419 insertions(+), 5 deletions(-)
 create mode 100644 COPYING
 create mode 100644 COPYING.bsd
 create mode 100644 COPYING.gplv2
diff --git a/COPYING b/COPYING
new file mode 100644
index 000000000000..e0c57ecaf45e
--- /dev/null
+++ b/COPYING
 -0,0 +1,33 +Copyright (C) 2016, Stephan Mueller +Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, and the entire permission notice in its entirety,
+   including the disclaimer of warranties.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote
+   products derived from this software without specific prior
+   written permission.
+ALTERNATIVELY, this product may be distributed under the terms of
+the GNU General Public License, in which case the provisions of the GPL2
+are required INSTEAD OF the above restrictions.  (This clause is
+necessary due to a potential bad interaction between the GPL and
+the restrictions contained in a BSD-style copyright.)
+THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
diff --git a/COPYING.bsd b/COPYING.bsd
new file mode 100644
index 000000000000..8a704271906c
--- /dev/null
+++ b/COPYING.bsd
 -0,0 +1,26 +Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    1. Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+    2. Redistributions in binary form must reproduce the above
+       copyright notice, this list of conditions and the following
+       disclaimer in the documentation and/or other materials provided
+       with the distribution.
+    3. The name of the author may not be used to endorse or promote
+       products derived from this software without specific prior
+       written permission.
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
diff --git a/COPYING.gplv2 b/COPYING.gplv2
new file mode 100644
index 000000000000..3912109b5cd6
--- /dev/null
+++ b/COPYING.gplv2
 -0,0 +1,340 +		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+			    Preamble
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+			    NO WARRANTY
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+    +    Copyright (C)  +    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+Also add information on how to contact you by electronic and paper mail.
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+  , 1 April 1989
+  Ty Coon, President of Vice
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/doc/drng_chacha20.tmpl b/doc/drng_chacha20.tmpl
index 45aba9e6724e..4101301807f6 100644
--- a/doc/drng_chacha20.tmpl
+++ b/doc/drng_chacha20.tmpl
 -28,11 +28,26 -     This documentation is free software; you can redistribute
-     it and/or modify it under the terms of the GNU General Public
-     License as published by the Free Software Foundation; either
-     version 2 of the License, or (at your option) any later
-     version.
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+     1. Redistributions of source code must retain the above copyright
+        notice, and the entire permission notice in its entirety,
+        including the disclaimer of warranties.
+     2. Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+     3. The name of the author may not be used to endorse or promote
+        products derived from this software without specific prior
+        written permission.
+   +   +     ALTERNATIVELY, this product may be distributed under the terms of
+     the GNU General Public License, in which case the provisions of the GPL2
+     are required INSTEAD OF the above restrictions.  (This clause is
+     necessary due to a potential bad interaction between the GPL and
+     the restrictions contained in a BSD-style copyright.)

@_date: 2016-08-05 19:21:54
@_author: Jason Cooper 
@_subject: [Cryptography] [patch chacha20_drng 3/4] API: Remove version macros 
It's no fun maintaining and supporting more than one way to do the same
thing.  Let's head this off before it bites us.  Users should be using
_versionstring and _version to retrieve this information.
While updating the Makefile for this change, simplify it.
Signed-off-by: Jason Cooper  Makefile        |  6 +++---
 chacha20_drng.c | 22 ++++++++++++++++++----
 chacha20_drng.h | 14 --------------
 3 files changed, 21 insertions(+), 21 deletions(-)
diff --git a/Makefile b/Makefile
index 8cf17ce49001..0624df589408 100644
--- a/Makefile
+++ b/Makefile
 -14,9 +14,9  PREFIX := /usr/local
 LIBDIR := lib
 NAME := chacha20_drng
-LIBMAJOR=$(shell cat chacha20_drng.h | grep define | grep MAJVERSION | awk '{print $$3}')
-LIBMINOR=$(shell cat chacha20_drng.h | grep define | grep MINVERSION | awk '{print $$3}')
-LIBPATCH=$(shell cat chacha20_drng.h | grep define | grep PATCHLEVEL | awk '{print $$3}')
+LIBMAJOR=$(shell grep '^\ \t]*MAJVERSION' chacha20_drng.c | awk '{print $$3}')
+LIBMINOR=$(shell grep '^\ \t]*MINVERSION' chacha20_drng.c | awk '{print $$3}')
+LIBPATCH=$(shell grep '^\ \t]*PATCHLEVEL' chacha20_drng.c | awk '{print $$3}')
 LIBVERSION := $(LIBMAJOR).$(LIBMINOR).$(LIBPATCH)
 C_SRCS := chacha20_drng.c
 JENT_OBJS:=
diff --git a/chacha20_drng.c b/chacha20_drng.c
index 0b3b1230bd4f..468909042abb 100644
--- a/chacha20_drng.c
+++ b/chacha20_drng.c
 -46,6 +46,20   "chacha20_drng.h"
+ MAJVERSION 1   /* API / ABI incompatible changes,
+			* functional changes that require consumer
+			* to be updated (as long as this number is
+			* zero, the API is not considered stable
+			* and can change without a bump of the
+			* major version). */
+ MINVERSION 1   /* API compatible, ABI may change,
+			* functional enhancements only, consumer
+			* can be left unchanged if enhancements are
+			* not considered. */
+ PATCHLEVEL 0   /* API / ABI compatible, no functional
+			* changes, no enhancements, bug fixes
+			* only. */
  CHACHA20_DRNG_ALIGNMENT	8	/* allow u8 to u32 conversions */
 /*********************************** Helper ***********************************/
 -591,16 +605,16  int drng_chacha20_get(struct chacha20_drng *drng, uint8_t *outbuf,
 void drng_chacha20_versionstring(char *buf, uint32_t buflen)
 {
 	snprintf(buf, buflen, "ChaCha20 DRNG %d.%d.%d",
-		 DRNG_CHACHA20_MAJVERSION, DRNG_CHACHA20_MINVERSION, DRNG_CHACHA20_PATCHLEVEL);
+		 MAJVERSION, MINVERSION, PATCHLEVEL);
 }
 uint32_t drng_chacha20_version(void)
 {
 	uint32_t version = 0;
-	version =  DRNG_CHACHA20_MAJVERSION * 1000000;
-	version += DRNG_CHACHA20_MINVERSION * 10000;
-	version += DRNG_CHACHA20_PATCHLEVEL * 100;
+	version =  MAJVERSION * 1000000;
+	version += MINVERSION * 10000;
+	version += PATCHLEVEL * 100;
 	return version;
 }
diff --git a/chacha20_drng.h b/chacha20_drng.h
index 275cbdb47110..3116731339af 100644
--- a/chacha20_drng.h
+++ b/chacha20_drng.h
 -44,20 +44,6  extern "C"
  - DRNG_CHACHA20_MAJVERSION 1  /* API / ABI incompatible changes,
-				     * functional changes that require consumer
-				     * to be updated (as long as this number is
-				     * zero, the API is not considered stable
-				     * and can change without a bump of the
-				     * major version). */
- DRNG_CHACHA20_MINVERSION 1  /* API compatible, ABI may change,
-				     * functional enhancements only, consumer
-				     * can be left unchanged if enhancements are
-				     * not considered. */
- DRNG_CHACHA20_PATCHLEVEL 0  /* API / ABI compatible, no functional
-				     * changes, no enhancements, bug fixes
-				     * only. */
  __GNUC__ >= 4
 # define DSO_PUBLIC __attribute__ ((visibility ("default")))

@_date: 2016-08-05 19:21:55
@_author: Jason Cooper 
@_subject: [Cryptography] [patch chacha20_drng 4/4] API: Make _versionstring 
snprintf() can fail or truncate when the user supplied data is incorrect
or insufficient.  We really should let the caller know when that
Signed-off-by: Jason Cooper  chacha20_drng.c | 4 ++--
 chacha20_drng.h | 9 ++++++++-
 2 files changed, 10 insertions(+), 3 deletions(-)
diff --git a/chacha20_drng.c b/chacha20_drng.c
index 468909042abb..971317448fc2 100644
--- a/chacha20_drng.c
+++ b/chacha20_drng.c
 -602,9 +602,9  int drng_chacha20_get(struct chacha20_drng *drng, uint8_t *outbuf,
 	return 0;
 }
-void drng_chacha20_versionstring(char *buf, uint32_t buflen)
+int drng_chacha20_versionstring(char *buf, uint32_t buflen)
 {
-	snprintf(buf, buflen, "ChaCha20 DRNG %d.%d.%d",
+	return snprintf(buf, buflen, "ChaCha20 DRNG %d.%d.%d",
 		 MAJVERSION, MINVERSION, PATCHLEVEL);
 }
diff --git a/chacha20_drng.h b/chacha20_drng.h
index 3116731339af..2f05aad5e3ea 100644
--- a/chacha20_drng.h
+++ b/chacha20_drng.h
 -147,9 +147,16  int drng_chacha20_reseed(struct chacha20_drng *drng, const uint8_t *inbuf,
  *
  *  [out] buffer to place version string into
  *  [in] length of buffer
+ *
+ *  is filled with a string of the form "chacha20 DRNG X.Y.Z".  Care
+ * should be taken to provide a large enough buffer taking in to account that
+ * X, Y, and/or Z may be multiple characters.
+ *
+ *  status of snprintf(3).  < 0 on error, otherwise length of written
+ * string.  See snprintf(3) for details on truncation.
  */
 DSO_PUBLIC
-void drng_chacha20_versionstring(char *buf, uint32_t buflen);
+int drng_chacha20_versionstring(char *buf, uint32_t buflen);
 /**
  * drng_chacha20_version() - return machine-usable version number of ChaCha20

@_date: 2016-08-08 17:52:55
@_author: Jason Cooper 
@_subject: [Cryptography] [patch chacha20_drng 0/4] Small cleanups for 
Hi Stephan,
I do, but I have a few other fires to put out before I can circle back
to this.
If you want to do a release, don't wait on me.  I'll coordinate with you
when I start working on the more involved changes.

@_date: 2016-12-02 16:52:56
@_author: Jason Cooper 
@_subject: [Cryptography] OpenSSL and random 
I hate to be pedantic, but how about not creating the /dev/[u]random
nodes until sufficient entropy is achieved?

@_date: 2016-12-04 14:47:44
@_author: Jason Cooper 
@_subject: [Cryptography] OpenSSL and random 
It's worth noting here that this will work for individual users with a
simple threat model.  However, this is *not* an acceptable solution for
an OS to ship.
Primarily because there is no current mechanism for putting a
fixed_secret into each download of an OS image.  Which means it will get
dropped, or left the same for everybody for that OS release.

@_date: 2016-12-05 13:50:09
@_author: Jason Cooper 
@_subject: [Cryptography] OpenSSL and random 
Hi Peter,
mm, SCADA devices usually run for very long periods of time without
reboot (years).  Getting the uptime in that case would be catastrophic
for your scenario.
For scada systems in particular, the most likely attack vector is
through the (typically) ethernet network connecting the HMIs to the
scada devices.  So the current IP address and MAC address are easily
I presume you're thinking of putting ssh or TLS around the traditional
TCP/modbus connection?  Because that's where the real weakness is.
There's no need to try to exploit anything if the protocol includes a
"force_{out,in}put_to" that the ladder logic then can't override.  :-)
Perhaps a better option is to include a "Cert Generation and
Installation" step for the scada system rollout.  After all, rolling out
a scada network is an activity conducted over several weeks (at least)
by trained engineers.  It's not like you buy one at
$home_improvement_store and plug it in.
If random numbers are still needed for DHE or other purposes, you could
always pull some bits from the ADCs.

@_date: 2016-12-27 14:33:27
@_author: Jason Cooper 
@_subject: [Cryptography] where shall we put the random-seed? 
Hi John!
Almost.  The exception is encrypted disks.  In that scenario, grub can't
read the /var/lib/*/random-seed until after the kernel and init are
My proposal [1] has been to store it in /boot, since random-seed is at
least as sensitive as the kernel and initrd images.  Then, the
bootloader has access to it *before* kernel load.  This allows us to
load random-seed into RAM and pass the addr,size to the kernel.  That
should be sufficiently simple enough for the decompressor to leverage
when setting up KASLR.  Once random.c initializes, it can consume the
remainder of the seed for the normal entropy pools (non-credit).
I've also been looking at how to do this on embedded systems (no grub,
devicetree, etc).  It's pretty easy, but for the currently deployed
systems out there with legacy bootloaders (don't understand devicetree),
we need to make sure we don't require a bootloader upgrade.  It's
easiest to have the bootloader scripts read random-seed into a
pre-determined address and size, then set those parameters once in the
devicetree.  On these legacy systems, the devicetree blob is appended
to the kernel image, so we can boot modern kernels on older hardware.
Newer embedded systems could read data from the hwrng as well and
provide it as a separate seed passed via the devicetree.
I have a proposal [2] to fix this problem (read: make it suck less).
As you have discovered, getting a *unique* random seed onto each CD-ROM
or other install medium is rather byzantine.  At best, it will be
difficult to maintain.
My idea is to leverage the fact that on boot up, the Installer OS
creates many TLS connections to the distros package servers.  Iff those
TLS connections were DHE or ECDHE, then there is an opportunity to
gather some randomness.
Basically, take the (EC)DHE shared secret, run it through an hkdf with
some data from /dev/urandom, and use the output to do a no-credit seed
of /dev/urandom.  The first connection or two will still have crappy
entropy, but after a few connections, the kernel entropy pools will be
in a significantly stronger state.
The difficulty is that it's impossible to quantify.  We don't know how
strong the peer's DHE random key is.  We hope it's strong, but shouldn't
assume a strength.
The shared secret is a) ephemeral, b) short lived, and c) known to only
two devices.  We could trust the peer, but it makes sense to mix in some
crappy data from /dev/urandom so that even the peer doesn't know the
output of the hkdf.  This assumes that the Installer OS was able to
gather a *little* bit of randomness during boot up.  Which isn't too
unreasonable.  A few interrupts, mac addresses, pci config spaces, etc
means there is at least greater than zero once TLS connections start
opening up.
The reason that I like this approach is that there are no changes to
make to the peers.  No changes to the TLS protocol.  The client just
needs a little extra code to accomplish the task.
Once the installer has done it's job, it can just read 512 bytes from
It should also be noted that this idea would be helpful on embedded
systems where the kernel typically takes 400 to 600 seconds before it
has 128 bits of entropy.  By that point, many TLS connections have been
VMs would benefit as well from the non-deterministic stirring.
Here's a hitherto un-addressed problem.  Currently, system init scripts
read 512 bytes from /dev/urandom and write it to random-seed during
_startup_.  This is in case of a hard shutdown.  Iff there is a clean
shutdown, then the shutdown script reads 512 bytes from /dev/urandom and
writes it to random-seed.
Unfortunately, in the embedded world, clean shutdowns rarely happen.
And, as is well established, the entropy pool sucks at boot time.  This
means that the random-seed used at the next boot up was most likely
sampled at the worst possible time. :-(
It would be great, while taking into account flash wear, to have a
process doing a series of samples.  e.g. one per minute for the first 10
minutes, 1 per hour for the next ten hours, then exit cleanly.
This way, the quality of the random-seed used at each subsequent boot
has a much higher chance of being strong.
[1] "Increase Early Randomness for Deployed Embedded Devices" proposal
submitted to the Linux Foundation's Core Infrastructure Initiative.
Status: On ice.  I owe them a response, but day job work has rapidly
overwhelmed me. :-/
[2] "Entropy Pool Stirring with Ephemeral Diffie-Hellman Key Exchanges"
proposal submitted to the Linux Foundation's Core Infrastructure
Initiative.  Status: On Ice.  Same as [1].

@_date: 2016-02-26 16:53:36
@_author: Jason Cooper 
@_subject: [Cryptography] Response to "I don't have anything to hide" 
Hi Mattias,
Sorry for the long email.  I usually strive for brevity in responses.
But, ask an open-ended question... :)
The first thing I do is to try to put myself in their shoes.  *Everyone*
has a threat model.  Based on the statement, it doesn't include USG.
But the same person will get creeped out if someone looks over their
shoulder while they're trolling FB in $coffee_shop.
Privacy is relative and means different things to different people.
Teenagers don't care about USG/FBI/NSA, but they *do* care about
parents/teachers/school admins.
Non-technical folks get physical privacy.  Don't look over my shoulder,
don't ask how much something costs, etc.
And, there are some folks who genuinely don't care.  The open books.
They'll share their password for a piece of candy.  It's not that
they're dumb, they simply trust anyone.  I like to think they are so
fortunate to never have had their trust violated.
If the person is an 'open book', I smile and move on.  No point wasting
All the others are where I focus my energy.  Once I figure out what
their threat model is, I frame the problem in their terms.  At this
point, it gets very specific, so I'll just give some examples:
Web Browsing
Ask about their favorite website.  Open a normal, non-locked down
browser.  Go to an adult website, or a singles hookup site.  Close the
browser.  Open back up and go to $favorite_site.  Why is there an ad for
Adult Friend Finder? or similar?
Install NoScript.  Reload the page, you may have to allow scripts for
the main page.  Now show the *long* list of advertisers wanting to run
scripts in your browser.  Why are they there?  Did you think 47 people
were here in the room with you while you read that page?  Not just
watching you, but recording it and selling it.
Open other pages to show how the same advertisers are present across the
Solution: Ad blocker of choice, lock down browser config.
Login Passwords and Data
Take a brand new thumbdrive or SD card.  Ask the user to put some photos
on it and eject the drive.  Then, ask them to plug the drive back in and
delete the photos.  Last, ask them to eject the drive and hand it to
Install PhotoRec or similar recovery tool.  Scan the drive.  Show them
the photos.
Stress that this isn't just a problem on thumbdrives, works on hard
drives, and applies to websites also (different reasons).  If it comes
up, I dig up the FB subpoena posted online which shows all 'deleted
posts' and 'deleted photos'.
Solution: Secure erase tool, free space wipe, and/or whole disk encrypt.
Don't post shit on the net you'll regret.  Period.
WiFi Broadcasts
Typically, the above scenarios have been performed while the user is on
a wifi network I own.  With their consent, I've been recording since the
beginning with tcpdump on the gateway, or wireshark/kismet/airmon on
wifi.  tcpdump gives better results.  But wireshark/kismet/airmon better
demonstrates that *anybody* near them can do this.
Show the list of the SSIDs their computer is probing for.  Filter for
the list of DNS requests (I add a column to wireshark showing the time
delta between displayed packets, helps show what the user initiated).
Show how that alone reveals a *ton* of info on their browsing habits.
Look for unencrypted traffic (thankfully, there's much less these
days), extract some pictures.  If possible (typically ISP email
servers), show email syncing connections that are in the clear.
Locate email password if possible.  Show advertiser unique identifiers
and other cookie-type data.  Also any location data or personal data you
may come across.
For some balance, show https connections to google and other sites.
That's what everyone is *supposed* to be doing.  iow, wireshark and
kismet aren't the problem, they're simply a tool.  The problem is
failure to encrypt at all times.
Solution: Delete old wifi networks, install httpsEverywhere.  Possibly
Tor, depending on the user.  Rename home wifi to something generic.
The most important thing I tell them is that these tools are just that,
free tools.  *Anybody* can do what I've demonstrated.  Hell, these
aren't even hacking tools.  The only thing preventing random joe from
doing this is knowledge.  Last I checked, attempts to limit knowledge
fail miserably.
I also tell them that technology providers need to do a better job
protecting users.  They'll only do that if a significant portion of
users demand it.  Which users will only do if they understand the
problems.  Hence, the solution is education.
So, I guess the shorter answer is to demo the vulnerabilities with their
own gear.  :-)
Hope this helps,

@_date: 2016-01-20 14:01:59
@_author: Jason Cooper 
@_subject: [Cryptography] TRNG related review: rngd and /dev/random 
This is a great addition to your previous analysis.  I'll keep it to two
comments, below:
This isn't a realistic scenario.  An attacker "who knows the initial
state of the entropy pool (which is a file on disk)" either has physical
access to the system or root.  In either case, it's game over, she can
just read the keys.
No.  This is not OS-specific.  Nor kernel-specific.  In order to gather
entropy from the environment, you need a high-res timer.  ARM doesn't
provide that on all SoCs.  Ted has been asking for this for years.
Perhaps he's had progress recently?

@_date: 2016-01-20 17:36:52
@_author: Jason Cooper 
@_subject: [Cryptography] TRNG related review: rngd and /dev/random 
Hey Bill,
Why?  What is the target of the attacker?  If it's the longterm keys,
then she reads them.  Damage is done.  Again we need to presume she has
root access.
If the goal is longterm access, then she lays a backdoor that survives
If the goal is to passively decrypt traffic originating from the box
*without* future access to the box, then there might be something to
this scenario.
  - she reads random_seed
  - wait for reboot
  - attempt to decrypt traffic she captures
I'm going to say that in most situations, this will fail.  The first
reason is that environmental entropy (interrupt/timer derived) will stir
the pool enough that by the time the known random_seed is added, the
pool state is unguessable to the attacker.
The second is that /etc/init.d/urandom overwrites random_seed on clean
*shutdown* as well.  The known random_seed would never be used in this
The third is that in modern systems (containing RDRAND), random.c mixes
in data from RDRAND, see drivers/char/random.c:894
        /*
         * If we have architectural seed generator, produce a seed and
         * add it to the pool.  For the sake of paranoia don't let the
         * architectural seed generator dominate the input from the
         * interrupt noise.
         */
        if (arch_get_random_seed_long(&seed)) {
                __mix_pool_bytes(r, &seed, sizeof(seed));
                credit = 1;
        }
Wether you choose to trust RDRAND or not, mixing it with /other/ sources
of entropy makes for a much more un-guessable pool state.
I think the addition of arch_get_random_seed_long() thwarts this
scenario.  But please take a closer look to see if I've made a bad
Note: in the scenario above, she /could/ hard reboot the box, since she
has root access.  But I'm pretty sure someone would notice that.  Then
there's the rabbit hole of "well, she could re-write the urandom init
script", or "... favorite root access change ...".  It all boils down to
physical access/root access trumps all.

@_date: 2016-05-23 19:52:07
@_author: Jason Cooper 
@_subject: [Cryptography] Entropy Needed for SSH Keys? 
Hi Ray,
The caveat here is kernel ASLR.  The address space is setup when the
decompressor is run.  It either needs an architecture-specific function
like RDRAND/RDSEED, or to be handed a seed by the bootloader.
There's also the whole suite of kernel self-protection mechanisms like
stack canaries and so on.

@_date: 2016-11-16 16:18:21
@_author: Jason Cooper 
@_subject: [Cryptography] Qubes 
Hi John,
Hmm, iirc, it's been around for at least 2 to 3 years.
Yes, Joanna Rutkowska was the one who originally discovered Blue Pill
I would say that's task-dependent.  It will certainly consume more RAM,
even sitting idle.  Modern processors are adept at reducing the burden
introduced by virtualization.  The only exception to this is heavy
amounts of compiling.
The way they design it, the performance-critical pieces of hardware are
passed-through to the relevant VMs.  So the wifi card is not
virtualized.  The VM handling it uses the actual driver for that card
and directly controls it.  IOMMU/Vt-d prevents it from becoming an
escape vector.
All-in-all, I like the concept, but I've not tried it recently.
[0]

@_date: 2016-11-23 14:39:17
@_author: Jason Cooper 
@_subject: [Cryptography] combining lots of lousy RNGs ... or not 
Hi John,
The difference between the two approaches is that one is sound
engineering with finite resources and little control over the hardware
The other is sound engineering when creating a product from the ground up
with full control of the manufacturing and design process.
Ted's example should really be, with no control of the hardware executed
    H(squish_NSA | squish_KGB | squish_MSS | squish_IRQ | squish_ADC)
Once a system gets at least 128 bits from IRQ or ADC, the feasibility of
any attack vector, even with knowledge of other attack vectors, goes
drastically down.
If we're designing the whole product, John's approach is the only
correct one.  If we have no control of the hardware we are executing on,
then Ted's is strictly better than using any available individual source

@_date: 2016-09-29 14:30:06
@_author: Jason Cooper 
@_subject: [Cryptography] Use Linux for its security 
Hi Jerry,
Please don't mindlessly pile on after a poorly researched,
sensationalist article. :-(
Kees (the speaker giving the referenced talk) is leading the Kernel
Self-Protection Project.  He's not saying "Linux sucks" as the headline
implies, he's clearly defining the problem in order to justify the
project's purpose.
  Not that you could gather that from the article. :-/
And Kees has recently started doing blog posts about the features that
have been merged into mainline:
  v4.3   v4.4   v4.5 For reference, v4.8 is most likely going to be released this Sunday, and
the average time between releases is 72 days.  So, this clearly isn't
something new, nor is it unaddressed.  It's a well supported
You can find the mailing list here:

@_date: 2017-04-27 17:15:54
@_author: Jason Cooper 
@_subject: [Cryptography] 
=?utf-8?q?_AES_Counter_Mode=E2=80=A6?=
Hey Jon,
And what I really like about AEZ is the concept of variable length
authentication tokens.  You can seriously consider per-packet AEAD
constructions with minimal size overhead as long as you have an
orthogonal method of preventing replays.

@_date: 2017-12-04 18:54:58
@_author: Jason Cooper 
@_subject: [Cryptography] XChaCha20 standardized? 
While digging into libsodium [1] (An ISC licensed chacha20-poly1305 AEAD
crypto library), I found they recently added support for
chacha20-poly1305-ietf and xchacha20-poly1305-ietf.  The difference
between the original and these two new ones being nonce size.
The original libsodium chacha20-poly1305 AEAD construction used a 64bit
nonce.  When chacha20-poly1305 AEAD was formally specified in RFC 7539
[2], they used a 96bit nonce.  libsodium calls this
A 2008 paper by DJB, "Extending the Salsa20 nonce", described XSalsa20
with a 192bit nonce [3].  libsodium apparently applied this concept to
ChaCha20 to create XChaCha20 [4].  This seems attractive, but I'm
reluctant to deploy anything without a formal specification.  So,
1) Has anyone seen a formal specification of XChaCha20 anywhere?
2) Has anyone seen a formal security analysis of XChaCha20, akin to
   DJB's analysis in the XSalsa20 paper?
3) If neither the specification or the analysis exist, would it be worth
   the effort to draft up an RFC?
Regardless, I'm a bit confused since libsodium chose to name it
xchacha20-poly1305-ietf.  Which, to me, implies that it has been
specified by the IETF somewhere and at least formally reviewed...
[1] [2] [3] [4]

@_date: 2017-12-04 20:46:47
@_author: Jason Cooper 
@_subject: [Cryptography] XChaCha20 standardized? 
To put a more refined point on it:
In [3], under the "Definition of HSalsa20", DJB states "The indices 0,
5, 10, 15, 6, 7, 8, 9 here were not chosen arbitrarily; the choice is
important for the security proof later in this paper."
Those output indices are then used as the key for the next double-round.
Looking at the libsodium implementation of HChaCha20 in:
  src/libsodium/crypto_core/hchacha20/core_hchacha20.c:17
it finishes with:
    STORE32_LE(out +  0, x0);
    STORE32_LE(out +  4, x1);
    STORE32_LE(out +  8, x2);
    STORE32_LE(out + 12, x3);
    STORE32_LE(out + 16, x12);
    STORE32_LE(out + 20, x13);
    STORE32_LE(out + 24, x14);
    STORE32_LE(out + 28, x15);
This *appears* to be in line with intent XSalsa20's output choices.  The
indexes output for both XSalsa20 and XChaCha20 correspond to the
original positions of the constants and the nonce (blockcounter & nonce
in ChaCha20's case) in both cases.
But I'd feel a whole lot more comfortable with it if I could locate some
definitive specification and analysis.

@_date: 2017-12-08 21:45:04
@_author: Jason Cooper 
@_subject: [Cryptography] XChaCha20 standardized? 
Hi Tony,
mmm, I think 'hash' is a strong word that may be used incorrectly here.
In the XSalsa20 paper, DJB states:
"The indices 0, 5, 10, 15, 6, 7, 8, 9 here were not chosen arbitrarily;
the choice is important for the security proof later in this paper."
If it were the output of a secure hash function, one could just use the
first 32 bytes of output (indices 0 - 7 inclusive).
However, I'm not a mathematician, so parsing the proof is proving (ha!)
Agreed, which is what I'd like to do.  But I'd prefer to avoid deploying
something only to have to support it after a slightly different version
achieved standardization. :-/
Ok, glad I didn't miss something.

@_date: 2017-02-21 15:42:10
@_author: Jason Cooper 
@_subject: [Cryptography] Security proofs prove non-failproof 
Hi Perry, Jon,
In a small attempt to address Jon's quoted point, I'd like to add two
terms.  "Security of the Primitive" and "Security of the System".  As
you say, Perry, formal proofs are very helpful in determining that a
given primitive has a property you need.  What I think Jon is
highlighting, and I'd like to as well, is that adding that primitive to
a system doesn't necessarily extend the property proof to the system.
As formal proofs improve, I'd like to see some work on building systems
from verified components; then deducing formal proofs of security
attributes for the *system*.
This would be very threat-model and environment dependent, but it would
be a start.  As an example, take the case of a nailed up VPN connection
between two physically secure facilities.  The connection goes over the
untrusted Internet.  The symmetric cipher, ephemeral session key
exchange, key signing, and session key derivation all have formal proofs
for their individual features.  Keeping it simple, let's say the KEX is
signed by static keys.  Is there a method to build on those individual
proofs to say something concrete about the system in a given environment
against a stated threat model?
Note that "environment" in this context includes the form, rate, and
patterns of the content carried within the encrypted connection.

@_date: 2017-02-24 02:56:28
@_author: Jason Cooper 
@_subject: [Cryptography] SHA1 collisions make Git vulnerable to attakcs 
Hi Peter,
As you mentioned in your follow-on, tree objects are ripe for this
abuse.  I'd suggest folks interested in this read over Git From the
Bottom Up[1], and the git-manual section on object construction[2].
A few other points to mention here to avoid the "sky is falling" cries.
 * git is distributed by nature.  Once a sufficient number of people
   have cloned the repo, you have some defense/discovery method
   available.  Albeit non-cryptographic. "Hey Bob, Alice here.  I did a
   fresh clone today and my binaries are comming out differently.  Can
   you send me a sha2-384 hash of path/to/object/in/question?"
 * Adjoining the first point, the only poor sod who gets the malicious
   commit are the ones cloning the tree as opposed to updating (those
   who don't have the hash of interest and need to downloaded it).
   Ergo, targets of interest are the most frequently cloned from:
   kernel.org, github.com, gitlab, etc.
Just to be clear, this is now a *real* problem.  How long it takes from
spotting an object of interest to creating a replacement object is the
critical variable here.  The longer it takes to create, the more
time people have to get a legit copy of the object before the malicious
one can be injected.  Large projects with a plethora of objects (Linux
Kernel) need to start the timer now.  Although, that's tempered by the
fact that the juiciest targets are the new objects that no one has.
[1] [2] [3] Probably CCS, Crusty Config Syndrome.  e.g. a stale filter rule from
the last time I was subscribed.

@_date: 2017-02-24 16:27:24
@_author: Jason Cooper 
@_subject: [Cryptography] SHA1 collisions make Git vulnerable to attakcs 
One final note:
After reading through the git ml thread that Ted already pointed to, the
key piece I was missing last night is that this isn't a chosen-image
attack.  e.g. you can't take $valid_commit, modify it, insert/append
some mutate-able garbage, and get $bad_commit where
  sha1($valid_commit) == sha1($bad_commit)
is true.  Well, not yet.  Not with this new attack.  But it's much
closer.  I'm glad the object_id conversion is already underway. :-)

@_date: 2017-01-02 20:05:03
@_author: Jason Cooper 
@_subject: [Cryptography] where shall we put the random-seed? 
Hi Natanael,
A backbone monitor doesn't see your local connections.  Even a couple of
those would throw them off.
Also, perhaps I wasn't explicit, but this proposal was never intended to
be a *sole* source of randomness.  Rather, to augment existing sources,
especially when they are slow or lean (embedded systems, VMs).
How is that different from the same situation without my proposal?
Given an environment with multiple slow, non-ideal sources of entropy,
why not include a free one that's just sitting there?  It makes the
system stronger with minimal hassle.
Is it non-ideal?  Sure.  Just as you outlined.  But it doesn't make the
situation any worse, and will quite often help.
Additionally, if this were deployed on a LiveCD, I wouldn't feel the
need to 'ssh hostA "dd if=/dev/urandom count=1" | dd of=/dev/urandom' to
several hosts on my local network running baremetal with long uptimes
before creating disk keys, random-seed, etc.  Instead, I would just
count the number of DHE connections (local and remote) before continuing
with the install.

@_date: 2017-01-02 20:21:16
@_author: Jason Cooper 
@_subject: [Cryptography] where shall we put the random-seed? 
Hi Ted,
Mmm, yes, I didn't write that very clearly, but we agree on the current
state of things.
dd if=/etc/shadow of=/dev/urandom
Well, I disagree.  I'd prefer not to give up just because the rest of it
is crappy.  It may not always be that way.  We should fix what we have
the power to fix as soon as we can.  Especially with the long deployment
cycles of embedded systems.
Those devices are typically wireless, so there are A/D converters.
Microphones and cameras as well.  So, even without dedicated hw-rngs,
and no user input, there is still wiggle room.  And TLS connections :-P

@_date: 2017-01-04 19:26:51
@_author: Jason Cooper 
@_subject: [Cryptography] where shall we put the random-seed? 
Hi Ted,
Ok, I see what you were after.  The random-seed may be no-credit, but
once it's been saved with entropy pool >128 bits, then the system is no
longer in a bad state.  I can buy that.
While pondering this, I hit on a slightly different idea.  Right now,
the init scripts save the seed at boot up regardless of amount of
entropy gathered.  This is in case of unclean shutdown.
Why not trigger a KOBJ_UEVENT_CHANGE when the entropy crosses a given
threshold?  Userspace can save to random-seed then.
With that in place, we wouldn't have to rely on clean shutdowns nearly
as much.  We also wouldn't be guessing (as in my original proposal)
about when to grab a new seed.
One could even argue about only collecting the seed at bootup if there
was a previous seed read in.  In that scenario, the existence of the
seed implies it was collected when entropy level >$threshold.

@_date: 2017-01-05 11:50:27
@_author: Jason Cooper 
@_subject: [Cryptography] where shall we put the random-seed? 
Hi Ted,
$ sudo grep "random: non" /var/log/messages*
$ uname -r
$ cat /proc/device-tree/compatible | tr '\00' '\n'

@_date: 2017-05-02 20:25:42
@_author: Jason Cooper 
@_subject: [Cryptography] Big ugly security problem in post-2008 Intel 
Hi John,
Please read:
  for a more pragmatic review of the issue.
tl;dr most Intel chips don't ship with AMT.  Those that do, it's
disabled by default out of the box.

@_date: 2017-11-13 13:57:57
@_author: Jason Cooper 
@_subject: [Cryptography] Is ASN.1 still the thing? 
Hi James,
To answer the question in the subject line, yes, ASN.1 is unfortunately
still a thing.  As long as one must interact with x509, you get the
ASN.1 baggage for free. :-P
I presume what you're getting at: Does it have a strict binary
representation?  Any format that permits arbitrary whitespace will fail
that test.  Although, you could specify the reduced form prior to
They do?  That seems odd.  I really hope ASN.1 isn't being chosen for
the reasons you've outlined.  Above and beyond the complexities of
parsing it, there's also the difficulty of parsing it on embedded
systems.  From my experience, it's extraordinarily difficult to parse as
a stream.
For the record, we've had quite a bit of success with msgpack.  It's
extremely efficient, both in line format, code size, and ram usage.  And
further your question, it's a strict, binary representation wrt word
size and endianess.
Also, as a "C enthusiast", I think protobuf is just an abomination.  If
you've spent any amount of time reading hex dumps of serial protocols
like ADS-B, one look at protobuf makes you think "Why the f*ck would you
create a binary form of XML?" It was clearly never intended to be a
serious line protocol format, but rather a universal (from a high-level
programmer view) data pack/unpacker.  And even then, I try to avoid code
generators. ;-)
Well, you're crossing use cases here.  There is data storage (x509
attributes), configuration files (/etc/* in *nix), and line protocols.
All of which have different requirements.  To the best of my knowledge,
the only reason ASN.1 still exists in mainstream usage is because of
x509.  And I really hope both of those die a horrible death in a flaming
Yugo off of a 500 ft cliff into ice-cold seas and jagged rocks.
Not that I have an opinion about it or anything.  :-))

@_date: 2017-11-13 19:40:29
@_author: Jason Cooper 
@_subject: [Cryptography] Is ASN.1 still the thing? 
Hi Howard,
So I see it's a part of the OpenLDAP repo at:
  Under libraries/liblber/ .
Would you consider breaking that out into a separate repository?  I and
a few others would be willing to assist with the effort if you are.

@_date: 2017-11-14 15:49:41
@_author: Jason Cooper 
@_subject: [Cryptography] [FORGED] Re:  Is ASN.1 still the thing? 
Hi Peter,
in.  We found one attempt at decoding while streaming:
  So, in blunt terms, a "hack".
Thanks to Howard, we now have a second example, liblber which has a long
history, plenty of use, and is open source.  So we'll see how that
But the fact is, DER was never intended for stream parsing/encoding.

@_date: 2017-11-15 14:16:07
@_author: Jason Cooper 
@_subject: [Cryptography] [FORGED] Re: Is ASN.1 still the thing? 
Hi Howard,
No, that's the similar problem we encountered on the net.  We're happy
with serial decode and, asynchronously, serial encode.

@_date: 2017-11-15 16:28:44
@_author: Jason Cooper 
@_subject: [Cryptography] Is ASN.1 still the thing? 
Hi Peter,
Yes, I misspoke.  "_x509_ with binary attributes, and hence DER, isn't
designed to be parsed while streaming."  Which, for our usecase, makes
it very difficult to a) stream decode on constrained devices, and b)
stream decode efficiently on server-side.
Now, the read-as-BER hack permits stream decoding of x509 in both cases.
Encoding, on the other hand, still requires assembling the whole DER in
memory to encode.  Which doesn't work for constrained devices, and is
inefficient for servers.

@_date: 2017-09-13 21:44:13
@_author: Jason Cooper 
@_subject: [Cryptography] letsencrypt.org 
Hi Bayuk,
It's extremely useful, with the caveat that certificates are only valid
for 90 days (by design), and require admin privileges to install.
To maximize it's usefulness, it's worth the time investment to set up a
cron job to automatically renew the certs.  Note that this must run as
root (admin).
The good folks over in BSD-land created a nice, privilege-separated tool
for this task, acme-client [1].  I've been using for quite a while
(before it was renamed from letskencrypt), and been really happy.
Good luck,
[1]

@_date: 2017-09-14 16:26:18
@_author: Jason Cooper 
@_subject: [Cryptography] letsencrypt.org 
Hi Robin,
So the certificate and keys are readable and writable by this
low-privilege user?

@_date: 2017-09-19 12:02:12
@_author: Jason Cooper 
@_subject: [Cryptography] letsencrypt.org 
Hi John,
Oh, I wasn't asking as a critique of LE.  As I said, I've been using it
happily for quite a while.  I'm more interested in the specific client
choices that security-minded people are making.
Based on the responses to date, the only thing I see concerning (other
than unnecessary use of scripting[0]) is that the process with network
access is the same process/user as has access to the keys.
This is why I chose acme-client [1] (not the PHP acme-client, nor the
ruby acme-client, but the C one from BSD).  It is deliberately designed
from day one to protect the private keys.  Even in the event of
compromise via the connections to the acme servers.  From their website:
  You don't want the private key processes interacting with anybody else
  (acctproc.c, keyproc.c). You don't want network-touching processes
  interacting with the file-system (dnsproc.c and netproc.c). You don't
  want the process parsing (revokeproc.c) your certificate  which comes
  down the pipe and might be rigged to blow  to touch your file-system or
  the network. Same goes with the process converting the downloaded
  certificates to the format usable by your web server (certproc.c).
  Moreover, you don't want the process scribbling in your webroot to
  scribble elsewhere (chngproc.c). Same goes with the process scribbling
  in your public certificate directory (fileproc.c). I'm not advocating for one client over the other.  But I am saying that
individuals deploying clients, especially with automated updating, need
to set minimum criteria for security.  Then disregard clients that don't
meet that.  Personally, acme-client works for me, but ymmv.
[0] "scripting" = "bailing wire and duct tape" :-)
[1]

@_date: 2018-07-02 16:09:42
@_author: Jason Cooper 
@_subject: [Cryptography] Non-deterministic PRF as a MAC-and-Nonce for 
Hi Alfie,
Good.  ;-)
Very true.
mmm.  That's a bit of a leap.  I'd say there's a lot of "roll-your-own"
for two primary reasons: 1) hobbyists are tinkering and learning,
hanging the result on github or whatever.  And 2) small shops have a
need to secure product(s) and do it in a less-than-advisable manner.
Nothing can be done about (1), other than avoid projects that don't have
an active community, established security bug handling procedures, and
multiple developers contributing / maintaining code.
(2) seems to occur for two main reasons.  The first is cost / speed.  An
established product suddenly needs to "add security", the cheapest /
fastest way to do so is to have the existing dev team do it.  And that
wasn't what they were hired for or experienced in.  The second reason
unfortunately seems to be arrogance.
There's also a third, which is just flat-out mistakes.  The PS3 DSA
nonce is a good example of that (I've never met the engineers who made
the mistake, so I'll presume mistake over arrogance ;-) ).
Well, sure.  But that's a protocol design decision.  Do you really want
the developer who needs to have their hand held regarding nonce
generation to be designing cryptographic protocols?
Regarding your example, it's much better if the nonce is pre-pended.
This way, you can do an early check for duplicated messages (use the
nonce as a unique message ID) and drop it before even trying to
decrypt/auth it if you already received it.  This is especially helpful
when an encrypted message spans multiple MTUs.
Yeah, that's the problem with interface abstraction.  Just because it
looks nice doesn't mean it's genuinely useful or helpful.  This
interface sucks because you've made a decision for me regarding
placement of the nonce in the message.  It also sucks for your target
audience because they still have to design a good protocol *with* the
bad placement of the nonce.
The unfortunate side effect of an api like the above is that a junior
developer is then never exposed to nonce handling, but now thinks they
know how to design cryptographic protocols.  That's dangerous.
A better solution (not applicable here, but same class of problem) is
Apple's recently announced Network.framework [1].  We can debate the
efficacy of the userspace network stack, but it puts the abstraction
right where it should be, at a very high level.  The developer is under
*no* pretense that they are "designing" or "implementing" TLS, bonjour,
DTLS, etc.  They are merely *using* those protocols.
And that helps us see where libsodium and friends (openssl, mbedTLS,
etc) fit in.  They are convenience libraries for _protocol
implementers_, not junior developers.
[1] Video:     Slides:     Example (C):

@_date: 2018-07-31 14:33:42
@_author: Jason Cooper 
@_subject: [Cryptography] Signal double-ratchet vs. future breaks in ECC? 
Here's a generic scenario to help bring the point home:
Note: this is an engineering overview, not a rigorous mathematical
example.  :)
Let say Eve sniffs the wire and receives two ECDH(E) public keys P_a,
and P_b which belong to Alice and Bob, respectively.  Those public keys
are paired with the private keys, K_a and K_b.
Shared secret S_ab is calculated by Alice:
and Bob does:
The first session key may be derived by both Alice and Bob as follows:
Alice  may then encrypt a message by:
Bob has S_1, and so is able to decrypt E_1 to recover the plaintext.
Eve can sniff E_1, but doesn't have access to K_a nor K_b, so isn't able
to calculate S_ab, nor S_1.
However, if Eve has a sufficiently large QC, she can use P_a to recover
K_a.  Now, Eve can calculate S_ab from
And according to the specification of the target protocol, Eve will be
able to derive any key from S_ab that she needs.  And that's the Abyss
part, she obtained the lynch pin without physical or network attack.

@_date: 2018-06-04 13:43:04
@_author: Jason Cooper 
@_subject: [Cryptography] Non-deterministic PRF as a MAC-and-Nonce for 
Hi Alfie,
Honestly, if the coder doesn't know to ask a cryptographer, or security
engineer when they encounter nonce generation for an API, that's an
education / experience problem.  A good manager should ensure the junior
coder is either a) not going near crypto, or b) is closely supervised by
an experienced crypto/security engineer when touching crypto.
I originally had written my response as a proposal for a thin
abstraction layer that handles nonce generation for the coder.  But this
is ultimately a security fail.  nonce generation is highly dependent on
the environment (entropy, counters, etc) and the use case.  There's
simply no secure way to abstract it away for all usecases.
In past cases where I've used AEADs, I've used either the output of HKDF
or some randomness as the first nonce, and then just incremented it for
each subsequent encryption call.  (chacha20-poly1305-ietf permits
counter-type nonces [1])
With regards to your proposal, I stand by my original response.  The
nonce is an *input*, the MAC is an *output*.  There's simply no way to
use the MAC as a nonce.
And, honestly, if you do figure out a way to implement this "Subliminal
Channal", it would introduce very serious security concerns.  The kind
of concerns that would only be alleviated by specifying the process
formally, publishing, and have cryptographers pound on it for five to
ten years.  I don't think the gains are worth the hassle.
The best / easiest solution to your problem isn't technical,
unfortunately.  It's human.  There's no substitute for experienced
developers mentoring junior developers while working in crypto and
[1]   "The most important security consideration in implementing this
   document is the uniqueness of the nonce used in ChaCha20.  Counters
   and LFSRs are both acceptable ways of generating unique nonces, as is
   encrypting a counter using a 64-bit cipher such as DES.  Note that it
   is not acceptable to use a truncation of a counter encrypted with a
   128-bit or 256-bit cipher, because such a truncation may repeat after
   a short time."

@_date: 2018-03-15 19:51:19
@_author: Jason Cooper 
@_subject: [Cryptography] Avoiding PGP 
Hi Carlos,
Well, having worked at several companies that have required all internal
email communication to be encrypted, there are really only two
options (In commercial / business sector).  PGP/GPG, and S/MIME.
I've used both systems for at least a year each.  PGP suffers from two
problems.  Symantec (Intel) deviated from the PGP specification, and
their apps generally suck unless you mindlessly sit at desk using
Windows as IT configured it for you.  Even then it falls over
frequently.  The deviation from the spec has resulted in a staring
contest between PGP Universal and GPG implementers.  PGP doesn't care,
and GPG folks refuse to add compatibility shims to make it "just work".
And even if the impasse weren't there, users have to think *way* too
much.  So the second bullet is that the cognitive burden is simply too
high.  Personally, I only use GPG to sign an occasional email, or to
sign a git tag for a pull request.
S/MIME, however, works dang near everywhere.  If you politely ignore the
fact that IT hands you your .p12 and the password for it.  This includes
the private key.  Ergo, most deployments implement key escrow.  You
don't *have* to, users could create keys on-device, and submit CSRs
(remember, internal email only, corporate devices, add private CA).
The problem with S/MIME, though, no one, outside of business, uses it.
But for business it works fairly well.
In either case, remember to keep your old keys when you rotate to new
ones.  Otherwise you won't be able to read old archived messages.
But yeah, seriously, you're looking at a tremendous maintenance and
admin burden for either one.  Just use signal.  :-)

@_date: 2018-05-14 19:04:43
@_author: Jason Cooper 
@_subject: [Cryptography] Vulnerability found in PGP. 
Best assessment I've seen to date:
  "Instead of disabling PGP/SMIME, you should make sure your email client
has (s/hast/has/ - jac) remote/external content disabled -- that's a
huge privacy violation even without this bug."
Based on the above, it's not PGP or S/MIME (other than the convenience
feature of keeping keys decrypted for a period of time to reduce PW
typing), but rather MUA's stupid auto-rendering of HTML.

@_date: 2018-05-21 12:37:13
@_author: Jason Cooper 
@_subject: [Cryptography] Non-deterministic PRF as a MAC-and-Nonce for 
Hi Alfie,
It'd help if you define "safe" and "AEAD" ;-)
iiuc, which I'm pretty sure I don't, you're asking for a
non-deterministic PRF to *deterministically* create a nonce...-EPARSE
It's also possible that you're asking if the traditional MAC of an AEAD
could also be used as the nonce for the AEAD (perhaps to save space on
the wire?).  In short, no.  The nonce is an input value to the
encryption function, the MAC is an output (regardless how it's created).
Perhaps you could give us the scenario you have and the constraints
you're dealing with?
fwiw, Take a look at XSalsa20 and XChacha20.  These two ciphers are
capable of taking a purely random nonce under the same key.  In short,
the nonce is large enough, that the chance of randomly selecting the
same nonce while under the same key is sufficiently small.
Is that what you're after?  If so, you might be interested in
libsodium's xchacha20poly1305 AEAD.
