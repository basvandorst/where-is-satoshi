
@_date: 2005-03-22 12:34:23
@_author: Michael Silk 
@_subject: Propping up SHA-1 (or MD5) 
If it's just HMAC with K = h(m) then it's currently (or just recently)
been discussed on cfrg:  starting here:

@_date: 2006-08-14 12:23:03
@_author: mikeiscool 
@_subject: Hamiltonian path as protection against DOS. 
But you're imaging an attack with a distributed bot net DDoS'ing you,
correct? Couldn't they then also use their botnet to process the
messages faster then normally? They already have the computering
power. Just a minor addon to the bot client app.
Or if it is many requests from one or thousands of clients, can you
not, per host, ask them to use a cached version? Per X timeout.
Of course, you can't do this with SSL, though.

@_date: 2006-08-16 14:28:59
@_author: mikeiscool 
@_subject: Hamiltonian path as protection against DOS. 
Could this sort of system be something that is implemented way before
a HTTP connection even starts?
Say, implemented by OS vendors or API vendors of sockets. That is to
say, when you open a socket connection for the first time, for certain
protocols, you need to pay this fee. The socket lib would be adjusted
to do it, and then you are good to go.
It would mean that other services get the benefit of protection. But
is there legimate need to connect to many, or one, host many thousands
of times? I'd guess there is.
Take the discussed handshakes. Could something be incorporated there?
Maybe there could be a new low level protocol, kind of like SSL, but
less cost involved ... then you could tell your server to operate in
that mode only...

@_date: 2007-12-11 11:02:27
@_author: silky 
@_subject: PlayStation 3 predicts next US president 
Work has actually been done on this exact topic.
One link is here: I think there may be more; I'm not sure.

@_date: 2007-11-13 10:45:01
@_author: silky 
@_subject: Fwd: [funsec] "Loophole in Windows Random Number Generator" (slashdot) 
"A security loophole in the pseudo-random number generator used by Windows was
recently detailed in a paper presented by researchers at the University of
Haifa. The team found a way to decipher how the number generator works, and
thus compute previous and future encryption keys used by the computer, and
eavesdrop on private communication. Their conclusion is that Microsoft needs
to improve the way it encodes information. They recommend that Microsoft
publish the code of their random number generators as well as of other
elements of the Windows security system to enable computer security experts
outside Microsoft to evaluate their effectiveness. Although they only checked
Windows 2000, they assume that XP and Vista use similar random number
generators and may also be vulnerable. The full text of the paper is available
in PDF format."
Fun and Misc security discussion for OT posts.
Note: funsec is a public and open mailing list.

@_date: 2007-10-30 13:32:47
@_author: silky 
@_subject: password strengthening: salt vs. IVs 
well what you're describing is quite classically a salt, imho.
well no. i mean to xor it (or probably what you mean: to otp it)
you'll need to have a "salt" who's length is equal to the input. that
would then mean that short inputs would result in short salts. i.e. a
password of "a" may result in the "salt" of "x". hash("a" ^ "x") is
hardly secure against a rainbow table.
so you're better off maintaining the salt in a separate location
(after all, the threat model is that someone takes the db and has a
list of all the hashes, and then calculates out the passwords) and
still prepend it on before the main passphase.
you may consider, however, that if this "salt" is as long as one block
of the input to the hash algorithm, it effectively becomes a new iv.
but what that has to do with anything; i don't know ...

@_date: 2009-02-24 06:48:03
@_author: silky 
@_subject: Solving password problems one at a time, Re: The password-reset  
Well, this is an old plan and useless. Because any rogue server can
just submit the 'usercode' to the real server, and get the three
letters. Common implementations of this use pictures (cats dogs family
user-uploaded, whatever).
And FWIW, renaming "password" to "usercode" doesn't make it more secure.
I have no idea what you're referring to here. It doesn't seem to make
sense in the context of the rest of your email. Are you saying your
system is useless given SSL? (Aside from the fact that it's useless
anyway ...)
Wrong again, see above.
Disregarding all of the above, consider that it may not be random, and
given that you can generate them on signup there is the potential to
know or learn the RNG a given site is using.
Doesn't really matter given it prevents nothing. Sites may as well
just ask for two passwords.
Eh? So what data was used to do the digital certificate calculation?
That's still around.
Sorry, you've solved nothing.
Stop spamming?

@_date: 2009-02-24 09:43:10
@_author: silky 
@_subject: Solving password problems one at a time, Re: The password-reset  
This is meaningless. What attack is the 'usercode' trying to prevent?
You said it's trying to authorise the site to the user. It doesn't do
this, because a 3rd party site can take the usercode and send it to
the 'real' site.
Eh? This still doesn't make any particular amount of sense.
Anything you do can be simulated by an evil site. Sending a key to a
phone is a good idea, but still, in the end, useless, because the evil
site can simulate it by passing whatever requested the user did to
that site.
No, it isn't.
*shrug* make one of them autogenerated. Doesn't matter. You're just
adding complexity for no real benefit.
Well I'm sorry but you don't understand your own system then.
Obviously it must have information to 'attack' a given account,
because you used it to generate something. The function you used did
something, so you can repeat it if you have all the inputs.

@_date: 2009-02-24 12:44:28
@_author: silky 
@_subject: Solving password problems one at a time, Re: The password-reset  
What you're missing is that it doesn't matter. The user enters the
usercode! So they enter it into the phishing site which passes the
call along.

@_date: 2009-07-02 09:29:30
@_author: silky 
@_subject: What will happen to your crypto keys when you die? 
A potentially amusing/silly solution would be to have one strong key
that you change monthly, and then, encrypt *that* key, with a method
that will be brute-forceable in 2 months and make it public. As long
as you are constantly changing your key, no-one will decrypt it in
time, but assuming you do die, they can potentially decrypt it while
arranging your funeral :)

@_date: 2009-07-04 19:00:46
@_author: silky 
@_subject: What will happen to your crypto keys when you die? 
Indeed, hence the reason I suggested encrypting only your "real" key
with this method. By the time you're done decrypting that, you've only
gotten a stale key. Of course the approach isn't really practical in
principle, it's only cute.

@_date: 2009-05-12 10:46:36
@_author: silky 
@_subject: Warning! New cryptographic modes! 
I'm thinking an SVN-style backup system. When you're done with all
your editing, you just commit the changes to go into the backup. As
part of the commit operation, it decides on the amount of changes
you've done and whether it warrants an entire re-encrypt and upload,
or whether a segment can be done.
As discussed in my original post, the base is reset when the changes
are greater then 50% of the size of the original file.
In that specific case, say and MS Access lock file, it can obviously
be ignored by the entire backup process.
No reason for 50%, it can (and should) be configurable. The point was
to set the time at which the base file would be reset.
The cost of not transferring a entirely new encrypted file just
because of a minor change.

@_date: 2009-05-12 09:06:09
@_author: silky 
@_subject: Warning! New cryptographic modes! 
How about this.
When you modify a file, the backup system attempts to see if it can
summarise your modifications into a file that is, say, less then 50%
of the file size.
So if you modify a 10kb text file and change only the first word, it
will encrypt that component (the word you changed) on it's own, and
upload that seperate to the file. On the other end, it will have a
system to merging these changes when a file is "decrypted". It will
actually be prepared and decrypted (so all operations of this nature
must be done *within* the system).
Then, when it reaches a critical point in file changes, it can just
upload the entire file new again, and replace it's "base" copy and all
the "parts".
Slightly more difficult with binary files where the changes are spread
out over the file, but if these changes can still be "summarised"
relatively trivially, it should work.

@_date: 2009-05-12 10:27:25
@_author: silky 
@_subject: Warning! New cryptographic modes! 
The local version needs access to the last committed file (to compare
the changes) and the server version only keeps the 'base' file and the
'changes' subsets.
So yes, it does increase the amount of space required locally (not a
lot though, unless you are changing often and not committing), and
will also increase the amount of space required on the server by 50%,
but you need pay the cost somewhere, and I think disk space is surely
the cheapest cost to pay.
I think this is resolved by saving only the last committed.

@_date: 2009-10-06 10:15:00
@_author: silky 
@_subject: Trusted timestamping 
I have no useful comments other than to point you to a timestamping
service you may or may not have seen (I didn't see you mention it:
 form what I've
noticed (just in passing) this seems to be the most popular stamping

@_date: 2010-04-21 17:48:09
@_author: silky 
@_subject: Quantum Key Distribution: the bad idea that won't die... 
Useless now maybe, but it's preparing for a world where RSA is broken
(i.e. quantum computers) and it doesn't require quantum computers; so
it's quite practical, in that sense.

@_date: 2010-04-22 08:05:23
@_author: silky 
@_subject: Quantum Key Distribution: the bad idea that won't die... 
First of all, I'm sure you know more about this than me, but allow me
to reply ...
I didn't say AES, I said RSA. Specifically I was referring to Shors
factoring algorithm on quantum computers :
Sure, now. That's the point of research though; to find more efficient
ways of doing things. If you stopped working on anything that seemed
initially too hard or unpractical I don't think we'd get anywhere.
I agree this is an issue, and from my reading it doesn't seem
completely resolved, but again I think it's reasonable to continue
researching into solutions. Importantly, however, is that if a
classical system is used to do authentication, then the resulting QKD
stream is *stronger* than the classically-encrypted scheme.
I disagree.

@_date: 2010-04-22 10:58:40
@_author: silky 
@_subject: Quantum Key Distribution: the bad idea that won't die... 
What do you mean "intermediate nodes"? It's possible to extend the
length of QKD depending on the underlying QKD protocol used. I.e. in
the EPR-based QKD, extension is possible.
I don't think you can legitimately speak for the entire community as
to what or not they may be doing. It's interesting to me that some
arguably unrelated fields of research (i.e. quantum repeaters) may be
No, it's not only as strong as the classical; it gets stronger if the
classical component works. Quoting from:
 - The Case for Quantum Key
"If authentication is unbroken during the first round of QKD, even if
it is only computationally
secure, then subsequent rounds of QKD will be information-theoretically secure."

@_date: 2010-04-22 12:25:38
@_author: silky 
@_subject: Quantum Key Distribution: the bad idea that won't die... 
But QKD is more about Physics than computer security. Anyway, it seems
there is little purpose in continuing the discussion.
Yes, I never stated the opposite (quote tree left intact). You were
saying that it is only as "strong" as the classical system. It is
clearly shown that the security of a QKD system *after* authentication
is *stronger* than classical, due to the OTP.
If what you meant to say was "it is broken if authentication is
broken" then the answer is obviously "yes". But the strength, in
cryptographic terms, is clearly better.

@_date: 2010-10-07 10:37:09
@_author: silky 
@_subject: English 19-year-old jailed for refusal to disclose decryption key 
It's interesting to think about the possibilities some sort of
homomorphic cryptosystem would offer here. I.e. it would be arguably
useful (from one point of view) if they were able to search the data
for specific items, and failing finding items of those types, *then*
the fallback is this sentence, otherwise it seems like a pretty
trivial way out for anyone wishing to hide bad activity.
