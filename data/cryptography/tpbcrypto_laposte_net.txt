
@_date: 2014-04-02 18:25:40
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Fwd: [messaging] Announcing the EFF Crypto 
Two months is kind of too short a time to make and test something of this magnitude ... will the prize be given in 2015 too?

@_date: 2014-04-02 23:15:16
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] ideas for (long) Nothing up my sleeve numbers 
How about this. You open ten threads to compute ten constants (square root of 2, pi, e, ...), these threads are opened in random order (ask the system a random number and use the last digit to choose which thread to fire up each iteration).
Let them compute for say 5 seconds, then ask the system random number for one sample, take the last digit of that sample and stop the thread that corresponds to that digit.
Now you use the last digit of this first calculated constant to stop the next thread, and on, and on, until you have finished stopping all threads.
Then you take digits of the calculated constants of your choice near the end of each constant (size and position could be randomly selected too) and mix them together to make a seed for a good pseudo-random routine.
Once it is fed into the pseudo-random routine it is thrown away so it can't be found in the system there after.
You can store the computations done by the threads, so the next time you call the constant generation routines they will continue from where they have stopped.
Does it sound like some good routine for random number generation, at least not depending so much in the outside world, except the order the threads are created and the stopping of the first thread?
Suggestions about which pseudo-random algorithms could be used with it? Couldn't we start one pseudo-random routine and then feed it into another?

@_date: 2014-04-06 16:40:55
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] [cryptography] Github Pages now supports SSL 
I agree that putting https everywhere is great, but Cloudflare's founders are tightly linked with the US-intelligence community. That fact alone kind of kills any claims they make about data security within their service.

@_date: 2014-04-08 21:18:52
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] The Heartbleed Bug is a serious vulnerability in 
So, let's wait until another 40 million credit cards are stolen, then we prove this method was used exactly, then we will try to fix it in all deployments ... yeah, seems reasonable.

@_date: 2014-04-08 22:02:24
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] The Heartbleed Bug is a serious vulnerability in 
Your first advice is extremely dangerous and preposterous, I was being sardonic in my comment, but let's get this straight.
You said you control a quite famous bug list. I should not ask this here, but considering the situation we found ourselves regarding encryption infrastructure abuse from the part of US government ... I'm just curious and can't resist it.
How much are you being paid to give such dangerous and preposterous advice? Or, who are your handlers?

@_date: 2014-04-08 22:35:46
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] The Heartbleed Bug is a serious vulnerability in 
Interesting way to try avoid answering about the subject directly. You should know that bad advice is noticed and sooner than you may think, your reputation falls between your fingers like sand and nobody will pay attention to your crazy rants anymore.
Which is a good payout for someone that sells his soul for so little.
Regarding automated exploit tools that will be used to cause enormous damage related to this bug, well they are already being devised and are in their earliest stages, but perfectly workable:

@_date: 2014-04-09 21:46:19
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Preliminary review of the other 
Most of us can relate with that, the "SEC" in DNSSEC is kind of misleading to put it mildly. Of "SEC", DNSSEC has nothing. People were expecting some form of encryption to the standard when it was first announced and after a so long wait it came out still working in plaintext and worse, forcing people to expose their infrastructure to use it. What is the SEC in that really? SECurely allowing yourself to be snooped and spoofed? SECure to whom?
Maybe some lover of this standard can come forward to its defense.

@_date: 2014-04-11 01:41:27
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Preliminary review of the other 
That was exactly my point ... we waited 20 years to receive back such a shoddy standard. When the SEC part came out, well the definition of SEC has long changed already.
Considering that you give in that the idea of SEC has changed over time, let's throw away the political part and consider the technical solution.
Politics over time only complicated things and brought in inevitable corruption in the standards bodies and service providers. Anything that politics meddles in becomes bloody corrupt and thus doesn't serve the technical purposes anymore.
It won't be long before a clever P2P DNS system pops out and kills everything related to the domain name and x509 system which clearly doesn't serve us anymore and whose abandonment is long overdue.

@_date: 2014-04-12 06:09:59
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Preliminary review of the other 
Although namecoin is a cool idea it lacks one thing ... why don't it carry the cryptographic keys to access the domains it offers, securely? Couldn't the public keys be embedded in its blockchain?
Namecoin could carry more than a mere naming system ... don't you think?

@_date: 2014-04-12 23:36:57
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] cryptography Digest, Vol 12, Issue 9 
How about this event?
Private keys retrieved and messages signed. If that's not enough, do you need 40 million credit card numbers spilled to take action? lol

@_date: 2014-04-13 14:32:13
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] cryptography Digest, Vol 12, Issue 9 
More like proof of the low cost for the attacker. Private keys retrieved, after that since the NSA own the backbones, it is just a matter of quantum inserting whatever they want.

@_date: 2014-04-14 22:17:17
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Preliminary review of the 
Experience proves that is not doable, even more if one has to consider a protocol like DNSSEC, I think it is offensive to do that amount of work and insert that amount of complexity for the "security" it provides, let's leave it like that, in quotes.

@_date: 2014-04-15 22:52:58
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Heartbleed and fundamental crypto programming 
Well, depends on what kind of attack you want to avoid, you may use -O3 if you want to reduce the chances against the recent attack on OpenSSL's ECDSA in some Intel chips' cache.

@_date: 2014-04-16 06:38:30
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Heartbleed and fundamental crypto programming 
And that's why so called safer languages, aka java, php or python seem great to program secure software because they don't allow buffer overflows, yet they are not, because you cannot control your program against other attacks, like cache snooping. Something that is doable in C.

@_date: 2014-04-21 15:29:19
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Open Source developer employment agreements, 
Creating a jedi order for programmers seems to be the way. Stallman's organization has that idea already, but they don't sustain their members yet with food and clothing and public buildings, neither do they demand total dedication.
How much would cost to do a step in that direction?

@_date: 2014-04-21 16:34:38
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Apple and OpenSSL 
Apple executives think that any help they give to the open source community will help their competitors to get an edge over Apple. Yet Apple executives don't have qualms to get the competitors' collaborative work and put in their products.
Much like it happened in the 80's, now the only way Apple will go is down.
In an environment where collaboration is fundamental, free riders will inevitably be left alone to die.

@_date: 2014-04-22 06:43:00
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Open Source developer employment agreements, 
Aren't there professors in the humanities that give points if their pupils steer debate to this or that PC direction?
Something like that could be applied to code. Professors of compilers, networking, databases and other subjects could give points based on correction commits (not new features) done by their students.

@_date: 2014-04-22 06:49:55
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] It's all K&R's fault 
Me and a few friends tried to create a JavaOS a few years ago and it was awful. Too many abstraction layers.
Brace yourself for decades of OSes made in C ahead.
Maybe someone will dare making something with C++. But we are no longer in the early 90's that a kid in college could jumpstart an OS and have it adopted by the masses. The amount of devices and platforms and services and protocols to support is mind boggling.
People once were content with a terminal, now you got retina displays, sound cards with stereo surround 5.1 7.1, dozens of optical formats, hundreds of usb devices, digital cameras, ... it is an undertaking requiring lots of money and a daring entrepreneur.

@_date: 2014-04-22 21:55:34
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] 
=?utf-8?q?ters_in_C=29?=
The problem of a clean slate is that we have thousands of programs which depend on OpenSSL's API the way it is.
The goal of LibreSSL is to create a library that is compatible with OpenSSL minus the bad code.
According to Theo after 90000 lines of code removed so far all OpenBSD programs that depend on it continue compiling.

@_date: 2014-04-22 22:15:54
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Apple and OpenSSL 
LLVM is still a drop in the ocean and was created to compete with other popular open source solutions. How about Apple funding projects? Putting a few employees to it is not the only thing that makes Open Source prosper.
Why does Apple puts its "money" on an Open Source project that offers much less cross-platform compatibility than other Open Source alternatives? I'm sure FSF would love some Apple money to pay devs for GCC ... but that is used by Apple competitors too. That is a no, no, no to Apple.
How many donations Apple offered to keep FreeBSD - which it sucked whole to create its MacOS?

@_date: 2014-04-22 22:45:08
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] It's all K&R's fault 
By dedicating 6 months of your life, two hours a day will be enough to understand most concepts, there is no way of untangling this for you out of the blue like you request.
Best of all, once you understood one Unix, all others are similar and have been for decades.
Consider it a time well invested, like learning to pedal a bicycle will help you pedal all bicycles.

@_date: 2014-04-23 12:02:16
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] 
=?utf-8?q?ters_in_C=29?=
The fact that you could even consider such absurd, means you don't know the work of the guys who are doing it.
I suggest you subscribe to their mailing list for details.

@_date: 2014-04-23 12:18:14
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Open Source developer employment agreements, 
To achieve what you want we have two hurdles to overcome:
- Education: most of us code-monkeys are good at math and numbers, not language. When language becomes mandatory inside a system, ie. writing missives about our code, we slow down and lose a lot of time to do it. We ain't no Mark Twain, we more like Sir Isaac Newton, sorry;
- Time: we are trained to spit out code and solve issues and create features as fast as possible so our bosses can put things for sale before competition catches up, our survival depends on that speed. A demand which is compounded by the first issue about the fact that we are slow at language;
Once we have learned enough to code well, we also have learned to do it fast enough for survival. People won't change that until their professional survival is no longer at stake, that is our modus operandi.
The only way out of it seems to be the creation of a jedi order of sorts that would code very important software, like encryption, networking and storage systems for peanuts, but whose survival would be guaranteed by the larger community. By training a small number of very good coders in human language and giving them enough time, you can achieve all documentation dreams.

@_date: 2014-04-23 23:25:52
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Apple and OpenSSL 
The objective of FreeBSD is to make a free system for all, those that benefit most should give back, that is the logic on which such foundations operate, if they don't ... where goes Apple's social responsibility really? For a hipster company that claims to care about others, it does anything but.

@_date: 2014-04-23 23:32:06
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] swap needed, or not 
That was a recurrent problem with kernels 2.2 and below. Try to enable swap now and open a lot of Firefox tabs and other things ... the system and the programs will keep up, very slow but nothing will crash.
Except of course if you consume all swap. That can happen with a few crazy programs that keep allocating memory forever and after thrashing the HD a long time will be kicked out of the system.

@_date: 2014-04-25 14:43:03
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Apple and OpenSSL 
Helloooo! Apple lost that position to Android by years already, if it ever had that position, because when Apple claimed to be dominant in mobile it was only smartphones, at that time Nokia dumb phones were still the bulk of mobile.
Anyway, for the rest of your arguments, a million dollars donation wouldn't make a dent to Apple's baseline but would have made all the difference to the FreeBSD folks. Apple receives hate for it and that is very deserved.

@_date: 2014-04-25 15:19:40
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Apple and OpenSSL 
Hello agaaaain! Apple was never, ever dominant in the laptop market, you are making a joke of yourself by insisting in such argumentation.
It is not for you to choose, the fact that Apple is receiving hate and it increases as time goes by only invalidates your argument.
When there's a catch-22 you think about what is morally right, and being stingy seems to be not exactly something that will give love to Apple. The firm is not struggling to survival.
What can happen if people get fed up enough is that like you say, BSD/Mozilla Open Source will disappear and only GNU Licenses will remain, good luck for Apple surviving the long term without having such generous tits to suck from. But its evil has to end.

@_date: 2014-06-03 23:12:26
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Fork of TrueCrypt 
It is not a bad thing if they cash in, as long as they do a good job. Because they are rookies, maybe they can confuse things up, as an older guy you could guide them to a good outcome.

@_date: 2014-06-03 23:15:40
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] GeekCrypt: A Secure Fork of TrueCrypt 
It would be good if you included at least one non-us-citizen in your team to blow the whistle in case of NSL.

@_date: 2014-06-05 22:47:09
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] What has Bitcoin achieved? 
Numbers 1 and 4 are tightly coupled, it is cheap exactly because it is irreversible. If you don't have the cost of executing reversions, neither the infrastructure to do it, that makes Bitcoin-like systems as a whole cheaper.
I dare say we would be better off without transaction reversions, because in the end reversions give people a false sense of security that makes them irresponsible and demands a huge infrastructure to deal with it. The only ones gaining from it are those charging to execute the service itself.

@_date: 2014-06-06 18:00:17
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] What has Bitcoin achieved? 
Maybe you are referring to the act of executing the reversion, but it implies lots of responsibilities and infrastructural cost, those things ain't easy.
I do, in my country don't use plastic money much, but we aren't parameter to the rest of the world, either.
Quite the contrary, I think Bitcoin is very successful exactly because of a few things like cheap transactions. When people start to demand reversibility, cheap transactions disappear.
I hope Bitcoin will not be transformed in another credit card system. So, people that want reversibility use one, people that want cheap transactions use the other. There is a place for everyone in this world, as long as banks and government don't push too hard to kill digital currencies.
In that case it will be a war much bigger than paypal takedowns, SOPA or anything that you have seen from the internet until now.

@_date: 2014-06-06 18:34:33
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Is it mathematically provably impossible to 
The people in power in Brazil right now are murderers themselves and they wanted to install a bloody dictatorship in Brazil too, just not the dictatorship flavor that existed at the time.
It is interesting to note that as long as they kept "democracy", Brazilians kept voting for them to stay in power. But as they move more in the direction they want, which is to impose a Cuban-Venezuelan-style government, people start to revolt.

@_date: 2014-06-07 17:54:51
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Back door competition for TrueCrypt fork? 
Your idea is interesting for a second moment, right now we need to detect prior inserted backdoors and bugs, deal with them, then thing about practicing backdoor creation and detection.

@_date: 2014-06-15 18:36:12
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] What has Bitcoin achieved? 
After Bitcoin is put under governmental control, they can do anything they want without ever being limited or curtailed by us. An example of that is FISA courts and special congressional commissions, that do their jobs without any scrutiny at all.
The consequence is the NSA behavior we see today.
There is no way the ledger will be kept public if the government puts their paws into it, it will be visible to them but not to anybody else, that's the first thing government will do, to cloak it to the best extent possible and force everyone to accept it. They will want that power and control over Bitcoin like they have today over banking transactions and there is not way to stop them if you allow them to control Bitcoin-like systems.
At that point we don't have cryptocurrencies anymore, but only a credit card replacement and nothing great has happened and nothing better has come out of it.
90% of people that would make transactions enforceable by law can continue using credit card, they don't have to wait one hour to confirm their transactions and they can keep paying the fees that guarantee transaction reversibility.

@_date: 2014-03-10 19:06:08
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] RC4 again (actual security, 
They will agree if you can accept a "trusted proxy", lol.
We ought to make something out of the standards bodies, they were hijacked years ago. What's the state of quantum-proof crypto, fellas?
Hello guys, I'm new to the list, pleasure to meet you,

@_date: 2014-03-19 00:01:22
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] We need a new encryption algorithm competition. 
New crypto systems cannot come from the guys that create standards, they have shown time and again that they cannot be trusted. What is that new invention called "trusted proxy"? Are they serious that we will think about adopting a "standard" like that? (sorry, I can't resist the "scare quotes")
New and good crypto systems will come from people that make and eat their own food as usual. I'm writing a very long e-mail with a proposal about it. I code and you guys tell me where I'm doing something wrong.
But I won't send the proposal before it is well researched and finished, neither will I use this e-mail address for it. I'm still searching an e-mail service that I can trust.

@_date: 2014-03-19 00:06:04
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] We need a new encryption algorithm competition. 
Ok, something more interesting than having a device that does crypto in and crypto out, would be a device we can program to do our crypto on hardware and it would be even better if such device came embedded in a motherboard.
Anybody knows of a such a motherboard that is a generic computer but comes with an FPGA built in? Not fancy, expensive kits for experimentation, just a motherboard with an FPGA to that interacts with the CPU to have fun. Anybody?

@_date: 2014-03-19 01:03:07
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Use process ID in mixing? 
then look at current->pid. Probably there is something
I run this at boot time:
if [ `ps -ef | grep 'tcpdump' | grep -v 'grep tcpdump' | wc -l` -eq 0 ]; then
ifconfig | egrep "^[a-z]{1,}" | egrep -v '^lo|^tun|^tap|^eth0:' | tr -s "[:blank:]" ' ' | cut -d ' ' -f 1 | while read interface; do
tcpdump -i ${interface} -K -n -N -q -t | sed "s/^IP [0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\.//g" | sed "s/ > [0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\.//g" | sed "s/: UDP, length \|: tcp //g" | uniq | openssl enc -des-ede3-ofb -k `echo ${RANDOM}${RANDOM}${RANDOM}${RANDOM}${RANDOM}` > /dev/urandom&
This code snippet takes what my system gets in the network interfaces, encrypts it with openssl and push it into /dev/urandom.
It is worth mentioning that I keep at least three p2p networks up all the time, one of them with an average of 200 connections that change every few seconds.
Is that code snippet good for the purpose of seeding /dev/urandom?

@_date: 2014-03-19 16:34:41
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] We need a new encryption algorithm competition. 
Very nice, since I arrived it late, I'm looking for ways to buy one of these. It is way less complicated than making one of those FPGA laptops by ourselves from scratch.

@_date: 2014-03-19 20:56:45
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] We need a new encryption algorithm competition. 
Suggestions for solutions? Todo list? We could use some P2P network that implements a tcp stack (like i2p) to test new tcp features and make it at least a bit more manageable.

@_date: 2014-03-24 16:16:34
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] BLAKE2: "Harder, Better, Faster, 
Some of my customers demand such solutions, shouldn't we develop a protocol for piggy-backing crypto over crypto? It would be a cool thing.

@_date: 2014-03-25 23:08:30
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] BLAKE2: "Harder, Better, Faster, 
Since I'm merely a code monkey and not a cryptographer, all that I can do is encrypt a stream and then apply another level of encryption over it by using a different algorithm.
I know you guys don't like this approach, yet I have got no references on how to make it better. All I know is that if the first layer is broke, the would-be attacker will get another jumbled stream and will have to start all over again.
The idea of my question is, can we do that in a proper manner? What proper manner is that, exactly?

@_date: 2014-03-25 23:33:04
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] The role of the IETF in security of the 
the net?
Security will not be improved with "trusted proxies" that is for sure. But it seems such ideas are making their way into the protocol while being pushed by the monarch.

@_date: 2014-03-25 23:42:00
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] BLAKE2: "Harder, Better, Faster, 
Thank you, your ideas are much appreciated.
Since "using a best cipher is better than using two good ones Xored", I think the approach of using two supposedly best ciphers not broken into until now and Xored seems to be good, then.
Using your approach seems good to encrypt the first layer with tls 1.3 and deliver by port 443 to the client, then above it to use the stream ciphers. It will look like some big download over SSL but in fact it is another thing. Maybe I should add another layer under the streams ...

@_date: 2014-03-25 23:48:12
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Dark Mail Alliance specs? 
Postfix and Exim4 support TLS 1.3 for server-to-server mail delivery through SMTP port 25.
You can just generated the key and activate that feature. If available, both daemons will communicate through it and nobody will easily snoop it.
Even better, they support 16k bit RSA keys, which will resist common computer decryption techniques (except shor) for decades to come.
Test it and you will see how good it is. We just have to enable it in our servers and the first step towards completely encrypted e-mail transport is done.

@_date: 2014-03-26 01:28:52
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Dark Mail Alliance specs? 
Thanks for the clarifications, I'm not a sysadmin, lol.
How about a process that remotely checks the key signature every few minutes from different countries to see if it is being spoofed and then shut closed the SMTP port if a problem like that is detected?
Wouldn't that make the GCHQ quantum-attack less practical?

@_date: 2014-03-29 01:09:42
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] The ultimate physical limits of privacy 
Can you please elaborate on the paper's contents? At least the abstract?

@_date: 2014-04-01 00:33:36
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Dark Mail Alliance specs? 
If you run VMs as root, that is the first security problem you got to solve. Just sayin'.

@_date: 2014-05-09 01:56:40
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] How to lock registers with GCC? 
I've been tinkering a while with GCC while trying to follow programming best practices for security, as some of you guys advocate.
While making an encryption routine I stumbled upon the possibility of using a register to keep the key, while erasing it from memory.
By using assembly it is possible to keep that register unchanged and use others to do stuff. That would make easy to build routines, if not by the bare metal programming part, lol.
But it becomes quite complicated to try write more useful programs, because you know, assembly.
Finally, my question is:
Is it possible to give a directive to GCC while compiling and/or does it support some macro/routine/directive/library/whatever, that would allow to load values into processor registers and then lock one or two registers, which would become unchangeable? Performance notwithstanding.
I know methods like using certain Intel Nehalem's registers that are normally not used (debug registers) for storing stuff, but that is too specific for that family of processors. How about something that is at least cross-processor-families, if not cross-platform?
Does something like that exists and/or is it possible to build it?

@_date: 2014-05-15 19:15:57
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] How to lock registers with GCC? 
Your message was very helpful, I've written a very long missive about the ideas that are floating in my head and it may be very boring to you guys.
This is a tl;dr version of the long missive for you guys that do not have patience for walls of text written by foreigners, but wish to collaborate anyway:
I need to pick your guys brains on a few other issues, if you help me maybe this thing can become a reality in one year or so:
- Can we use numactl against all processors? How much universal is this thing? Ripping it apart to put it into an OpenBSD is a no-no because of its GPL license. Other suggestions besides begging the original goder for an exception?
- Are there GCC routines to determine how many cores a system has and how many registers of all types are available? Is there a library for that? Can we ask the OS itself at boot time? Because this critter would run in OS boot time, it creates a problem shell commands cannot solve for us, which is to identify what are the resources we messing with at the startup moment.
- Do you guys know any symmetric encryption routine that is quantum-breaking-proof and is compatible with OpenBSD license and offers good protection from as little as 96 bit keys or even less?
- What can we do with the libraries that weren't compiled to exclude a certain CPU core and registers? Is the OS process scheduler good enough to keep all programs from poking into that core? More suggestions to protect that core, please? Can we sandbox the entire kernel? lol
- Can you guys suggest a simple process scheduler routine to put in a single CPU core that is fast and battle-tested and compatible with OpenBSD license? My goal is to make it run as a one single process to use that core and slice it in threads. It must run at 100% if the pseudorandom is necessary like in servers, or just do its little job when called in cellphones, then it goes to sleep again.
- What common barebones multicore hardware should I buy (arm, mips, sparc, etc)? That are cheap enough for a poor coder to buy for peanuts, but are good enough to run OpenBSD to test this thing? I wanna make it multi-platform to the biggest possible measure.
Proprietary systems be damned, but if they want to implement it after we created the standard, good for them. The standard is not mine either, you guys will be invited to collaborate at the right moment, meanwhile we are merely working out together the possible technical barriers.
For the next two weeks I still have to work on a project that uses a cellphone to shutdown a laptop when the two are taken far enough away from each other by means of bluetooth parity, it is my priority at this moment.
So, my answering e-mails will be sloppy at best for the next two weeks, cause my brain is old and uses preemptive tasking schedule.
I'm also sorry for the sloppy English because I'm not a native speaker and this wall of text beat my entire vocabulary to a bloody pulp.
Thank you,

@_date: 2014-05-15 19:20:07
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] How to lock registers with GCC? 
I know it is against the rules to write very long messages, but I'm merely reposting the messages you have pre-approved in order to answer them in bulk and keep things organized in this thread. So, it is one answer to all messages instead of one answer per message, which would be messy in this topic. Please, let us make an exception for this.
Below all messages, is my answer to them separated with this line:
I very much appreciated your support, you saved me many hours of research which I can dedicate to coding instead.
No, I don't think that to mess with GCC you gotta be hardcore. But I'm commemorating 20 years of my first Hello World, so I wanted to take the rust away from my C skills and make something out of my +10 thousand hours of coding. Or what is the use of so many hours of coding when the world needs so much a rehaul in its basic routines?
No, I'm not a goder (a god-coder), I make many mistakes too because I can't deal with everything, all the time, get drunk, and still make things perfect. Maybe brain implants will help in the next ten years or so, but we need this stuff now.
To reach that goal of upgrading my internal routines, I started by researching about which books could make the top 20 most important books about crypto and good C coding to read them. I bought half-a-dozen already and I'm digesting their contents as of now.
What could be done to clean an inch of coding rust while helping the world:
- A simple proof-of-work routine to give the world a new toy. Another toy?
- Create a p2p network to compete with tor, i2p, retroshare, etc. Another p2p?
- Create a basic routine for crypto that could be useful to everyone to embed in the OS itself.
Although the third option exists (openssl modules for linux?) it is not a routine to rule them all, it is not a standard by a long shot.
I'm a fan of standards like Unix, Bitcoin and Bittorrent, which came out of necessity and were done to solve problems. Not to satisfy "stakeholders", like W3C pushing DRM to us right now and Mozilla falling for it, because "stakeholders".
Although respecting people and following academic standards is a good thing, we gotta go hands-on, we don't have time for stakeholders shit.
So, how about coding routines to propose a practical standard crypto for Operating Systems?
Thank you, that is a step in the right direction. Developing further the idea I discovered that practically all generic processors made in the last decade have debug registers. Some assembly is necessary no doubt, but if it is simple and can be done once for entire families of processors, we are good to go for a year long project which we can call multi-platform.
I disagree with Mr. M?ller on making it for Android though, because Android has got backdoors in its proprietary side-of-things already. It is interesting from a technical point of view, but uninteresting in practice (maybe that routine can roll in a cyanogen or Firefox OS? that would make it much interesting in practice).
My goal is to make something that is not easy to side-channel attack. Metaphorically, it doesn't matter how good is your crypto if one of your friends is a loose tongue. So, you can have the best crypto in the world, but what is it useful if you got a loose BIOS?
I'm a fan of simple things, instead of demanding my friends and family use the strongest crypto for e-mail or stuff like that, I created and offered to them one simple cool free e-mail service and jabber (paid by me) on which they all connect. We cut out the e-mails that we exchange from travelling through third party's networks and the server only sends e-mails to other starttls compatible third-party systems. If one email doesn't get to an incompatible host, tough luck. Problem solved for grandma and my nieces.
However, I still use another free service to talk with you guys because I wanna keep my real name out of this crypto mess, at least for now. I fear for my life while implementing something like this, some people will not be happy with it, at all.
The idea is to apply a similar principle from the e-mail experience, to the small scale of a motherboard. To kill most side-channels in one swift struck.
You nailed it, now the toy programs and the p2p networks got a killall in my system. So, no matter how awkward, it is possible indeed to create a CPU-only encryption routine.
To help us, both ARM and MIPS have gone multicore. If somebody wants good crypto, sacrificing one core has become the possible price - and a cheap one - for the benefits it may entail.
So, with the info you guys got, we can theoretically now:
- Reserve one core for encryption routines in the OS level;
- Use debug registers to store the key, the key can use more than one register. This will allow us to exploit all the other registers still available to the core, thus not hitting performance issues. MIPS got three debug registers, that would give us 96 bit keys for the lowest-strenght symmetric routine that would work in all other processors;
- Use that core to encrypt the keys in memory for other routines by means of an optional new system call, thus helping to protect the entire system from things like heartbleed giving away private RSA keys;
- Use the idle time in that core to run a thread for a cryptographically secure pseudorandom number generator, like Fortuna and feed it to the OS. This would require a process scheduler exclusively for that core;
- The routine must be small enough to be entirely crammed into the CPU core cache, so it runs fast and you guys like fast stuff that I know. This would also reduce any memory leakage, side-channels and all the shebang;
- Use an open-source OS to create a kernel. Although I love Linux and have more experience coding for it, OpenBSD seems to be a project that would show much more receptivity to something like this. And when things are adopted by the OpenBSD team, everyone else follows because those guys are good. I hope they would catch my mistakes as a bonus;
I need to pick your guys brains on a few other issues, if you help me maybe this thing can become a reality in one year or so:
- Can we use numactl against all processors? How much universal is this thing? Ripping it apart to put it into an OpenBSD is a no-no because of its GPL license. Other suggestions besides begging the original goder for an exception?
- Are there GCC routines to determine how many cores a system has and how many registers of all types are available? Is there a library for that? Can we ask the OS itself at boot time? Because this critter would run in OS boot time, it creates a problem shell commands cannot solve for us, which is to identify what are the resources we messing with at the startup moment.
- Do you guys know any symmetric encryption routine that is quantum-breaking-proof and is compatible with OpenBSD license and offers good protection from as little as 96 bit keys or even less?
- What can we do with the libraries that weren't compiled to exclude a certain CPU core and registers? Is the OS process scheduler good enough to keep all programs from poking into that core? More suggestions to protect that core, please? Can we sandbox the entire kernel? lol
- Can you guys suggest a simple process scheduler routine to put in a single CPU core that is fast and battle-tested and compatible with OpenBSD license? My goal is to make it run as a one single process to use that core and slice it in threads. It must run at 100% if the pseudorandom is necessary like in servers, or just do its little job when called in cellphones, then it goes to sleep again.
- What common barebones multicore hardware should I buy (arm, mips, sparc, etc)? That are cheap enough for a poor coder to buy for peanuts, but are good enough to run OpenBSD to test this thing? I wanna make it multi-platform to the biggest possible measure.
Proprietary systems be damned, but if they want to implement it after we created the standard, good for them. The standard is not mine either, you guys will be invited to collaborate at the right moment, meanwhile we are merely working out together the possible technical barriers.
For the next two weeks I still have to work on a project that uses a cellphone to shutdown a laptop when the two are taken far enough away from each other by means of bluetooth parity, it is my priority at this moment.
So, my answering e-mails will be sloppy at best for the next two weeks, cause my brain is old and uses preemptive tasking schedule.
I'm also sorry for the sloppy English because I'm not a native speaker and this wall of text beat my entire vocabulary to a bloody pulp.
Thank you,

@_date: 2014-05-18 02:45:03
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Are there other anonymous key exchange 
McEliece? Niederreiter? HFE? QUAD? UOV? NTRU?
Pick your choice, there's plenty of such algorithms, none is a defined standard, however. McEliece is the most studied so far and NTRU is the smallest and fastest.

@_date: 2014-05-19 23:00:23
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] [cryptography] Is it time for a revolution to 
Considering that now all browsers support some widely available DRM, the only other thing missing is a deposit account to pay a few cents for each and all the videos we see. I'm sure the copyright cartel and the banking cartel are finally now reaching the point they can offer this "service" for us all.

@_date: 2014-05-19 23:21:36
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] [cryptography] Is it time for a revolution to 
Well, it is a known fact that all of us use four letters in our nicks like you and all php systems we use know the nicks before-hand, so they can cache one page for each of us to have all blocks measured in advance for efficient delivery.
That also includes this e-mail, whose length was pre-determined and prophesied for length and contents so it can be cached both here where I submit it only once and where everybody else will receive the message to see it.
Accidentally, this e-mail will be submitted through the java language and not php, but because of all our prophetic algorithms and virtuous programmers, all blocks will be measured up before delivery because we are still in the 80's and gopher has no forms.
Maybe in the gopher-era something like perfect block measure could have existed, as of now please get back to the real world.

@_date: 2014-05-20 02:39:32
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] How to lock registers with GCC? 
I think I may have bored many of you with my last message in this thread. lol
Regardless of answers, I've kept looking for resources, one fact I found interesting is that MIPS has more registers than ARM, maybe then that would offset the need for debug registers. See this comparative regarding the MIPS-3000 architecture performance by register allocation, page 90, table 1:
By that comparative, we don't need to use small keys and we could use twofish. Yet for each extra register used to store the key, more operations will be necessary to encrypto/decrypt stuff, thus knocking performance down.
Coming back to the small keys issue. I found this paper that promises good crypto for small keys:
Can you crypto-nerds make an evaluation of that? How much of a compromise in security would we get if we reduced the 112 bit keys to 96 bit keys?
This would be done for MIPS machines, which are the lowest of the low on which we could apply something like a crypto-core. Other architectures would work with other solutions, ie. most ARM 7 CPUs have 6 or more registers that could be used.
Of course we could make things for the latest processors, 64 bits, run twofish and forget it. But then only a fraction of people would benefit from having a crypto-core in their CPUs. Our goal is to make a crypto-core that runs in most machines, even more so in unattended routers and cellphones than servers (which already have options to encrypt memory portions and can run serious PRNGs at little processor cost).

@_date: 2014-05-20 19:47:58
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] How to lock registers with GCC? 
Thank you for the suggestions.
I found this link: And this comment below the post: {"The aim of SIMON and SPECK is to fill the need for secure, flexible, and analyzable lightweight block ciphers." - the interesting in that is "analyzable"...}
It is worth keeping the quotes in it just for fun.
Now answering your question, I really trust the NSA. My trust on them is the trust that you give to a thief, he will rob you sooner or later, that's for sure and that is something you can trust, right? Trust in the negative sense is also a form of trust in our world of smoke, mirrors and doublespeak.
Meanwhile as we keep scratching our heads, I found this intredasting table:
While Schneier and a few others put their work immediately under public domain, the good thing about the DES-improved paper that I posted earlier and some of these alternatives is that we would be free to choose which license the code could be placed under, if we make it ourselves.
Anybody knows if at least one of those cipher proposals can be trusted, outside AES?
Now more details of our situation:
Most ARM processors starting with version 6 - with the exception of M family - have the possibility to allocate registers for other functions out of running raw code. They all have 16 registers. Allocating 6 of them as in one of their operating modes seems doable albeit at some obvious performance penalty because we know by experience that 10 registers is kind of too little even for RISC machines.
So that allocation mode guarantees us that other programs won't poke in the registers even if they can override the compiler limitations, this could even be applied to a monocore processor, then. There are ARM processors with more registers, but they are more the exception than the rule, so we will stick to the rule.
MIPS 3000 is already a pretty old standard, I don't know how many older MIPS exist out there. But if we consider only the 3000 and up, then we have 32 registers or more and according to the link I posted regarding processing performance. We could use up to 16 registers without hurting the processing power too much by means of GCC reservation of registers.
MIPS would thus allow us better encryption with even the possibility of storing 128 bit public/private keys inside the processor. If I remember correctly there are a few public key systems that could use such small keys, like NTRU. A very interesting possibility, but NTRU is locked in GPL landscape and sometimes it eats your data.
Pentium IV has 128 registers and that number grows in newer models, so we don't really need to use the debug registers for storing keys if the compiler guarantees us the privacy of the reserved registers. However I have no idea how this will impact performance because we are talking about a CISC machine here.

@_date: 2014-05-20 20:06:41
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] Facebook on the state of STARTTLS 
That's simple, according to how the protocol is implemented it doesn't matter which CA signed your certificate, if it is signed, then it is valid.
It only takes one NSL from US agents (or hacking the CA) to force a CA authority to give away its private key, thus allowing to create an infinite number of trusted, signed, fake keys.
There are two solutions for this:
- Monitor your own servers through remote connections trying an OpenSSL handshake and see which signature is shown, if it is fake you send a command through another channel to close the port or shutdown your system;
- Use plugins like Certificate Patrol that will alert you of any certificate changes;

@_date: 2014-05-20 20:23:54
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] The Trust Problem 
You can always get a bogus update to grab your key, even if you run open source. I wonder if the Debian team didn't receive an NSL demanding they give the private key they use to sign updates.
And I fear that is precisely the big revelation Greenwald is talking about so much.
It is a long time already the Chinese says our open source as a whole is compromised ... make your bets.

@_date: 2014-05-22 18:49:07
@_author: tpb-crypto@laposte.net 
@_subject: [Cryptography] The Trust Problem 
My home town has a McDonalds and a few years ago the sanitary department ticketed them a heavy fine, demanded they close for a week and clean the mess, because they found all kids of critters in their deposit and kitchen.
Two days after it reopened I went there for a snack and started to call my friends while eating. Their reactions ran from funny to scared, but one thing I told them stuck to this day: "Wasn't the place cleaned yesterday? So what could be a better day than after the cleaning to have some snack free from roach wings?"
I found people use a similar approach to most things. Namely, if RSA was caught red-handed they must be working to amend themselves right now, so it is time to help and buy from them.
Yet, having a third party (the sanitary department) give a green-light regarding a clean kitchen is very different from a company promising to do better and still sell you some very complex and big pieces of software a few days later. One can bet his pinkie they haven't revised crap and are just preying you don't ask too many questions ...
... but regarding Skype, most everyone that I know ceased to use it since the Microsoft takeover.
RSA and Skype are too different cats to put in the same bag.
