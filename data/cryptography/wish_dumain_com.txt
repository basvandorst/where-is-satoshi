
@_date: 2014-04-30 21:44:59
@_author: wish@dumain.com 
@_subject: [Cryptography] GCC bug 30475 (was Re: bounded pointers in C) 
Thus Spake Arnold Reinhold :
Because one wants an optimising compiler that replaces expressions that evaluate
to constants with those constants and eliminates dead code.  What expressions
evaluate to might be different on different platforms so the code may be portable
rather than nonsense.  You do have a real choice as to what compiler to use and with which optimisation
and warning flags.  Spotting this sort of thing isn't the job of the compiler but for lint and it's descendants.  If we're talking about horses that have left barns I think it is too late
to make 'C' into a language safe against common programming mistakes.
You would need to break a lot of well defined features that all those
programs depend on.  Given that 'C' can't be made safe and still be 'C'
why cripple the optimiser trying?  I further suspect the popularity of 'C'
is, at least in part due to it not trying to protect you from yourself.
Having assert make the compiler look for undefined behavior is a good idea.
What original program?  We have the source code and a compiler that
can be tuned to trade off various things such as memory usage, compile
time and speed of execution of the code output.  It chooses an object
code representation that best suits the requirements and conforms to
the standard.  There is no reference implementation against which its behavior can be compared.
I think in this context undefined means undefined by the standard and
therefore available for the implementation to define.  I doubt there is
any way for an implementation to avoid defining 'undefined behavior' as
it has to do something when confronted by it.  The optimising compiler
is the implementation in this case so it gets to define what the output
should be.
Imagine an architecture  where the compiler that does its 32 bit integer
maths in 64 bit registers and only worries about whether the result fits
into a 32 bit int when assigning the result to a variable or passing it
as a parameter.  Your pet assert would fail with such an implementation
without an optimiser in sight.  I believe such an implementation would
still be correct according to the standard as it should produce the
same result in all cases where the output is not left as undefined by
the standard.

@_date: 2014-05-02 10:20:02
@_author: wish@dumain.com 
@_subject: [Cryptography] GCC bug 30475 (was Re: bounded pointers in C) 
Thus Spake Bear :
If you want widespread adoption highly visible slowdown is more
imporant than largely invisible until it bites you in the ass safety.
Of course you only really need to optimise your language for x86(_64)
and ARM(64).  'C' is designed for the 'give the programmer enough rope to hang himself'
crowd who want to trade safety for speed on the assumption that the
programmer knows what they are doing.  I think trying to convert 'C' to a
different philosophy is unlikely to succeed as a lot of people buy into
it.  It would be more productive to switch to a language which has more
of a safety orientation in the first place and add whatever is needed.
Ada with the Ravenscar profile seems fairly close, has free,portable
compilers and AFAICT can be called from other languages fairly easily.
You could use a conservative 'C' to Ada translator to switch existing
code.  Anything that can't be trivially translated probably needs attention anyway.
