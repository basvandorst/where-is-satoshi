
@_date: 2003-10-01 22:20:53
@_author: Guus Sliepen 
@_subject: Monoculture 
You clearly formulated what we are doing! We want to keep our crypto as
simple and to the point as necessary for tinc. We also want to
understand it ourselves. Implementing our own authentication protocol
helps us do all that.
Uhm, before getting flamed again: by "our own", I don't mean we think we
necessarily have to implement something different from all the existing
protocols. We just want to understand it so well and want to be so
comfortable with it that we can implement it ourselves.

@_date: 2003-10-01 22:11:04
@_author: Guus Sliepen 
@_subject: Monoculture 
I agree with that. First of all, even foolishly childish application
builders like me know that cryptography is hard to get right (that's
what we say up front in the README and manpage of tinc). And we also
know there is a group of people specialised in security, who know much
more than we can learn without spending a large amount of time.
Furthermore, the reactions of those people to our products is not very
encouraging most of the time. So yes, it looks like there is a kind of
crypto cabal or guild.
I noticed both kinds of people exist :)
And, in the case of building free software, the builder cannot afford to
spend much resources (like time and money) to improve his knowledge of
crypto. In our (tinc's) case, we do it just for fun.
Well we do try to put decent crypto in there... but sometimes we don't
know when it's decent enough.
Personally I'm not so scared by the barrier, but I did feel there was
I guess that's unavoidable.
That's also what I feel. But then again, I can imagine that for someone
who has spent years in this field that "newcomers" or "amateurs" like us
should listen to them and stop their silly attempts at crypto.

@_date: 2003-10-01 23:28:00
@_author: Guus Sliepen 
@_subject: Monoculture 
We don't want to program another TLS library, we want to create a VPN
daemon. If you read our response, you'd have seen that we plan to make packet
encapsulation in tinc work just like ESP, but optionally allow (parts
of) the IV and HMAC to be omitted.
[...rehash of arguments against doing it yourself...]
We are going to do it ourselves anyway, and maybe (or maybe not) it will
end up as being a simple and clean implementation of one of the
existing, widely peer-reviewed and accepted protocols you mentioned.

@_date: 2003-10-02 18:09:55
@_author: Guus Sliepen 
@_subject: Monoculture 
Writing a C++ library almost certainly means your application has to be
written in C++ as well. I think it is easier to create a C++ wrapper for
a C library than a C wrapper for a C++ library (especially if you use
all the OO features, although nothing prevents you from following the OO
paradigm in C). Because of that, I think you reach more application
builders with a C library.
As a programmer I'd like to see something that allows you to:
a) specify credentials
b) do TLS_start()
c) have a TLS_read() and TLS_write() function which work EXACTLY the
   same as the read() and write() functions
d) TLS_stop()
Each of those steps can return a fatal error, but I'd rather not have to
deal with warnings and other stuff that needs intervention of the
application itself, and I also don't want to write callback functions if
it's not really necessary.
I'd say LGPL or BSD, without any funny clauses.
By the way, also have a look at GnuTLS and libgcrypt:
- -

@_date: 2003-10-03 19:45:58
@_author: Guus Sliepen 
@_subject: Simple SSL/TLS - Some Questions 
If the applications have to interact with legacy systems, then they'd
need SSL...
OpenSSL is very large, and although the API is pretty consistent and
easy to work with, the SSL part of it looks complicated anyway. Another
thing that is very annoying about OpenSSL is its license (and this has
probably been an incentive to create GnuTLS).
Well as long as your library has a decent C interface, I wouldn't mind
if it was written in C, C++, Haskell or something even stranger.

@_date: 2003-10-09 16:26:45
@_author: Guus Sliepen 
@_subject: Open Source (was Simple SSL/TLS - Some Questions) 
If you run your VPN over TCP, and the VPN daemon therefore knows that
every packet it sends to the other side of the connection will arrive
anyway, you can do proxy-ACK, which essentially means you automatically
do port-forwarding for all TCP sessions on the virtual network
Still, not only is TCP-over-TCP a problem, anything realtime over TCP
(like VoIP, games, streaming video) suffers from it.
SCTP (RFC 2960) looks like a solution, although I don't know of NATs
that support it, and although some platforms already have some support
for it in their kernels, I don't think it's possible to write a user
space application using SCTP yet.

@_date: 2003-09-26 12:12:03
@_author: Guus Sliepen 
@_subject: Tinc's response to "Linux's answer to MS-PPTP" 
Hello Peter Gutmann and others,
Because of its appearance on this mailing list and the Slashdot posting
about "Linux's answer to MS-PPTP", and in the tinc users' interest, we
have created a section about the current security issues in tinc, which
currently contains a response to Peter Gutmann's writeup:
I want to emphasize for the cryptography community here that certain
tradeoffs have been made between security and efficiency in tinc. So
please read the response as "why we think we need to do/used to do it
this way" instead of "why we think tinc is still as secure as anything
else". Comments are welcome.

@_date: 2003-09-27 13:10:28
@_author: Guus Sliepen 
@_subject: Tinc's response to "Linux's answer to MS-PPTP" 
There is a "Contact" link left of it. You could've replied to me as
It is not the delay that matters, it is the bandwidth that is reduced.
And by enlarging the packets, the chance that they will be fragmented is
greater, which is also bad for performance. Some people want less
overhead instead of more security, silly as that may sound to you.
For those who can't even spare the computation time, tinc allows you to
disable HMAC completely.
Ok, I guess you can read that sentence in that way. But what you cut out
with the output of a PRNG which is seeded
And I meant "that PRNG which is seeded using ..." with RAND_bytes(). And
by seeding it with real random data I mean seeding using /dev/random.
Your assumption that the connection initiator sets all the keys in tinc
is wrong.
Finally, some constructive arguments. We are indeed considering the
things you mention. We might even switch to TLS for the TCP connections.
You can only provide so much ciphertext as an attacker before the
connection is closed. I do not see how this is different from, say,
SSL. What information can be obtained from our alledged oracle (apart
from being a timing oracle)?
I'm afraid we have totally different views of a VPN here. Anyway,
tunneling traffic over SSH or an SSL connection would give us the awful
performance of TCP-over-TCP, which we want to avoid.
When our response says "Will be fixed in 2.0" multiple times, does that
sound like we don't think Peter Gutmann has valid points and that we won't
fix things?
About half a year I guess. But, we didn't design the current protocol as
a replacement of SSL. In fact we replaced something that was worse than
the current protocol.

@_date: 2003-09-28 11:05:18
@_author: Guus Sliepen 
@_subject: Tinc's response to "Linux's answer to MS-PPTP" 
That would not work either. It would have the same problems as a packet
that has been split into 5 fragments: if one of the fragments gets lost,
the whole packet will be discarded. Fragment reassembly is also
something that is not completely trivial, in the past there have been
some simple DoS attacks for various operating systems that did not
implement IP fragment reassembly correctly.
Each UDP packet must stand on its own, just like the network packet that has
been encapsulated within it.
I think I prefer the Diffie-Hellman key exchange; the Needham Schroeder
public key protocol needs more round trips and one more RSA
encryption/decryption step.
Those are the first encouraging words I've heard since Peter Gutmann's
writeup was posted on Slashdot, thank you! We do plan to get rid of all
the weaknesses, and once we know what we want and we have a draft, I'll
post it in this mailing list.

@_date: 2003-09-29 14:07:04
@_author: Guus Sliepen 
@_subject: New authentication protocol, was Re: Tinc's response to "Linux's answer to MS-PPTP" 
I've been comparing tinc's current authentication protocol with the TLS
handshake protocol as described in draft-ietf-tls-rfc2246-bis-05.txt.
The basic structure is mostly the same: the ID messages in tinc are
TLS's Hello messages, the METAKEY message in tinc is similar to TLS's
RSA encrypted premaster secret message, the ChangeCipherSpec is implicit
in tinc, and tinc's CHALLENGE/RESPONSE messages serve the same purpose
as TLS's finished message (which contains verify_data).
TLS makes a distinction between a client and a server. If possible I
wish to avoid making that distinction. If possible, I would also like to
continue to be able to use an RSA public/private keypair. This made me
*sketch* the following _authentication_ protocol:
Step 1:
Exchange ID messages. An ID message contains the name of the tinc daemon
which sends it, the protocol version it uses, and various options (like
which cipher and digest algorithm it wants to use).
Step 2:
Exchange METAKEY messages. The METAKEY message contains the public part
of a key used in a Diffie-Hellman key exchange.  This message is
encrypted using RSA with OAEP padding, using the public key of the
intended recipient.
After this step, both sides use Diffie-Hellman to compute the shared
secret key. From this master key, keys and IVs for symmetric ciphers and
digest algorithms will be derived, as well as verification data. From
this point on all messages will be encrypted.
Step 3:
Exchange VERIFY messages. The VERIFY message contains verification data
extracted from the master key, so each recipient can verify that the key
exchange went well.
Step 4:
Exchange ACK messages. This will signal each side that the other side
acknowledges the authentication. The ACK message will contain some more
data which has nothing to do with authentication.
I currently think this has none of the problems the current protocol
has, and also makes sure we have perfect forward security (if keys are
renewed using Diffie-Hellman periodically).
Some questions:
- Some people keep saying that "you shouldn't send the same kinds of
  messages". TLS sends different kinds of messages depending on its role
  (client or server). Is there a reason behind this?
- Would it be nice to move all the cryptographic parameters exchanged in
  step 1 into the encrypted message in step 2? That way an attacker
  cannot see which encryption and digest algorithms will be used, which
  might make an attack less feasible.
- Did I miss something?

@_date: 2003-09-29 17:57:46
@_author: Guus Sliepen 
@_subject: New authentication protocol, was Re: Tinc's response to "Linux's answer to MS-PPTP" 
Several reasons. Because it's fun, because we learn more from doing it
ourselves (we learn from our mistakes too), because we want something
that fits our needs. We could've just grabbed one from the shelf, but
then we could also have grabbed IPsec or PPP-over-SSH from the shelf,
instead of writing our own VPN daemon. However, we wanted something
If you mean station-to-station protocol, then actually that is pretty
much what we are doing now, except for encrypting instead of signing
using RSA.
And I just ripped TLS from the list.
Several people on this list have already demonstrated that they are very
willing to analyse new protocols. Also, I don't *expect* you to do so,
if you don't want to ignore me.
If we use RSA encryption, then both sides know their message can only be
received by the intended recipient. If we use RSA signing, then we both
sides know the message they receive can only come from the assumed
sender. For the purpose of tinc's authentication protocol, I don't see
the difference, but...
I think you mean it is equal to 1 (X^0 is always 1). This is the first
time I've heard of this, I've never thought of this myself. In that case
I see the point of signing instead of encrypting.

@_date: 2003-09-29 21:10:36
@_author: Guus Sliepen 
@_subject: New authentication protocol, was Re: Tinc's response to "Linux's answer to MS-PPTP" 
Compared with JFK:  section 2.2
shows a lot of keys, IDs, derivatives of keys, random numbers and hashes
of various combinations of the previous, 3 public key encryptions and 2
symmetric cipher encryptions and HMACs. I do not consider that simple.
Compared with the entire TLS protocol it is much simpler, compared with
just the handshake protocol it is about as simple and probably just as
efficient, but as I said earlier, I want to get rid of the client/server
I will not repeat our motiviations again. Please don't bother arguing
about this.

@_date: 2003-09-29 20:10:44
@_author: Guus Sliepen 
@_subject: New authentication protocol, was Re: Tinc's response to 'Linux's answer to MS-PPTP' 
No, identification information. But still, it's just a name, not a
public key or certificate. It is only used by the receiver to choose
which public key (or certificate etc) to use in Step 2. This information
does not have to be encrypted, it has just as much meaning as the IP
address the sender has.
With tinc, public keys are never exchanged during authentication, they
are known beforehand. And again, there is no distinction between a
client and a server, it is peer to peer.

@_date: 2003-09-29 18:59:46
@_author: Guus Sliepen 
@_subject: New authentication protocol, was Re: Tinc's response to "Linux's answer to MS-PPTP" 
Well all existing authentication schemes do what they are supposed do,
that's not the problem. We just want one that is as simple as possible
(so we can understand it better and implement it more easily), and which
is efficient (both speed and bandwidth).
Used as a skeleton. Don't ask me to define that as well.
True. I've already heard Peter Gutmann's writeup being described as
"drive-by shooting" :).
True, but we can learn even from the bullet holes.
We're trying to find that out. If we figure out it doesn't, we'll use
one of the standard protocols. We also do not know every existing
protocol, maybe we'll find one we are happy with. I'm currently decoding
RFC 2409 and trying to look if one of IKE's modes of operation does what
we want.

@_date: 2003-09-30 18:09:59
@_author: Guus Sliepen 
@_subject: New authentication protocol, was Re: Tinc's response to "Linux's answer to MS-PPTP" 
After comments and reading up on suggested key exchange schemes, I think
this step should be changed to send the Diffie-Hellman public key in
plaintext, along with a nonce (large random number) to prevent replays
and the effects of bad DH public keys. Instead of encrypting both with
RSA, they should instead be signed using the private key of the sender
(the DH public key and nonce wouldn't fit in a single RSA message
anyway). IKEv2 (as described in draft-ietf-ipsec-ikev2-10.txt) does almost the
same. However, IKEv2 does not send the signature directly, but first
computes the shared key, and uses that to encrypt (using a symmetric
cipher) the signature. I do not see why they do it that way; the
signature has to be checked anyway, if it can be done before computing
the shared key it saves CPU time. Encrypting it does not prevent a man
in the middle from reading or altering it, since a MITM can first
exchange his own DH public key with both sides (and hence he can know
the shared keys). So actually, I don't see the point in encrypting
message 3 and 4 as described at page 8 of that draft at all.

@_date: 2004-05-31 00:31:06
@_author: Guus Sliepen 
@_subject: The future of security 
PGP keys are used extensively in the Debian community; new developers
are only accepted if their PGP key has been signed by another Debian
developer, so that their always is a trust path from one developer to
any other. Some important things, like the upload of new packages or
submitting votes, will only be accepted by the automated services if
everything is properly signed.
There is a strong incentive in this community to have a signed PGP key;
if you didn't have one you couldn't do anything. In other areas there
just is no incentive for having such a thing... like email; it works
even if you don't sign it.
I think that's because the tools are lacking. GnuPG can determine trust
paths, but you have to manually assign trust levels to certain keys
and update the trustdb (which takes an awfully long time). If it would
just work a bit faster and determine and show trust paths out of the
box, I think PGP's web of trust model would be used a lot more.

@_date: 2006-01-12 18:26:16
@_author: Guus Sliepen 
@_subject: long-term GPG signing key 
By default, GPG creates a signing key and an encryption key. The signing
key is used both for signing other keys (including self-signing your own
keys), and for signing documents (like emails). However, it is possible
to "split" the signing key into a master key that you only use to sign
other keys, and a key dedicated to signing documents. You can revoke the
latter key and create a new one whenever you want, the master key is
still valid. Also, when people sign your key, they sign your master key,
not the subkeys. The signatures you accumulated will also still be
valid. You can also keep the master key safely tucked away on an old
laptop that you keep in a safe, and only export the subkeys to your
workstation. That way the master key is very safe.
About keys being tied to "email addresses" (uids): you can create a uid
with just your name, no email address, and if you like a comment with
your birthday or passport number in it. Let people sign that uid.

@_date: 2006-01-14 22:50:35
@_author: Guus Sliepen 
@_subject: long-term GPG signing key 
It depends on how it is used. For example, when I sent this email, I
typed in the passphrase of my PGP key, authorising GnuPG to create a
signature for this email. This comes very close to "human signing". I
read, understood, approve etc. with the contents of this email.
If assymetric cryptography is used to automatically sign a credit card
transaction without the user having to do more than click a button, then
I agree that in that situation, the digital signature is not the same as
a human signature.
I don't equate private keys with that. I do equate signatures made with
those keys with that.
That is probably true, but in the mean time Travis still wants to know
how to create a PGP key with the properties he wishes for.

@_date: 2007-02-16 18:19:02
@_author: Guus Sliepen 
@_subject: BETA solution, Re: Failure of PKI in messaging 
Where are the usercode, password and keys stored then?
secures the website) then yes, this is functionality not offered by SMTP
and PGP or S/MIME. But I don't see this replacing PGP or S/MIME. I also
still don't see how this improves the trust model.

@_date: 2007-09-02 14:48:31
@_author: Guus Sliepen 
@_subject: World's most powerful supercomputer goes online 
Another interesting use may be data hiding. The botnet software could
store information in RAM (never on disk), and replicate it to other
nodes. If one node goes down, other nodes will still have the
information. If one node detects that virusscanners or forensic tools
are being used, it can easily wipe the information from RAM or just
reboot the machine without fear that the information would really be
Experience with tinc (a VPN daemon with peer-to-peer like architecture,
which replicates certain information to all daemons in a single VPN),
showed that even in a network with only 20 nodes, it is extremely hard
to get rid of information.  You either need to shut down all daemons at
the same time to make sure all state is lost, or modify the software to
allow explicit deletion of certain information. With more that 1 million
nodes it will be even harder to delete data.
