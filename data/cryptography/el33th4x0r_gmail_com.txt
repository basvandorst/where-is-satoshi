
@_date: 2015-02-17 18:23:41
@_author: =?UTF-8?Q?Emin_G=C3=BCn_Sirer?= 
@_subject: [Cryptography] self-MITMing my own TLS connection ... 
This sounds like a great counterpart to Virtual Notary (
 the online witness and attestor to digital
factoids that we have been running for a few years now. Combining tlsnotary
with VN, to be able to attest to non-public factoids, sounds like an
interesting project.
- egs

@_date: 2015-03-01 09:02:25
@_author: =?UTF-8?Q?Emin_G=C3=BCn_Sirer?= 
@_subject: [Cryptography] Cheap forensic recorder 
The TPM (and similar technologies) gives you attestation to binary images,
which in turn ensures that the images you think you're running are indeed
the images your CPU is executing.
For instance, if the OS on which you prepared the Raspberry image was
compromised, your tools could be storing an adulterated OS image and
reporting a different hash, and you'd be none the wiser. Reading Ken
Thompson's "Trusting Trust" paper might be a good idea for anyone involved
in systems that stand up to forensic scrutiny. Your current setup is not
very secure: the TCB is very large because you transitively trust countless
systems; the integrity of your findings depends on the provenance and
integrity of every single system that went into preparing the final boot
image. The TPM, and similar hardware measures, can enable you to perform an
end-to-end check, rooted in the hardware root of trust provided by the
- egs

@_date: 2015-03-01 10:06:22
@_author: =?UTF-8?Q?Emin_G=C3=BCn_Sirer?= 
@_subject: [Cryptography] Cheap forensic recorder 
I'm sorry about your experience but we're not talking about that right now
nor was I involved in it in any way. We all agree that this particular
application requires auditability. Your proposed technique does not provide
bullet-proof auditability. Surely, you've followed the recent revelations
about how agencies are hacking disk firmware even as we speak. Your
proposed scheme fails in the presence of such an adversary.
I don't know what you can and cannot explain to counsel, but many simple
things that are easy to explain are also easily broken. Do you try to
explain the operation of the CPU to counsel? Or other trusted
hardware/software, like device firmware?
Sure, you're trusting the foundry and the silicon, but the TCB profile is
vastly different: the attackers now have to have hacked a silicon foundry
to launch an attack on you, instead of just hacking the machine where you
prepared the raspbian OS.
Look, if you're happy with your approach in court, power to you. It's
probably sufficient for whatever you're doing; I'd trust your gut call that
it's the optimal tradeoff between being simple enough to explain and secure
enough for your purpose (which you didn't quite describe, so you can't get
upset if people assume a higher value case or a stronger attacker than what
you have in mind). But you asked how the process could be improved, and I
mentioned the state of the art. Feel free to ignore it as being "academic"

@_date: 2015-03-01 11:19:42
@_author: =?UTF-8?Q?Emin_G=C3=BCn_Sirer?= 
@_subject: [Cryptography] Cheap forensic recorder 
I now see what was unclear in my earlier email, so let me try again: Your
TCB includes the machine on which you prepared the OS image on the SD card.
It's entirely possible that you thought you were writing a Raspbian OS
image on, say, a Windows box. But it could well be that your Windows box
has been hacked, and it writes a modified OS image behind the scenes. A
rooted Windows box can easily intercept all calls to pretend that the hash
is good, but when your Pi boots from the card, it boots from the modified
binary. You can't trust the hash of the SD card taken on the Pi -- it's too
downstream and the hacker may own it. You may or may not be able to trust
the hash of the SD card taken on your Windows box -- it depends on whether
your Windows box is indeed "good" (i.e. not owned by the attacker). But how
can you tell if your Windows image is good? That problem is identical to
the problem of figuring out if your Raspbian image is good. You can see
that the problem extends transitively.
 The only way to know what precise binary the machine booted (modulo
attacks on TPM foundries), is to acquire a hash of the actual bits that are
executed with the help of some specialized hardware. TPM is one such
What I could do to improve the scheme would be to move the checking of the
You are using "entirely offline" as being synonymous with "trustworthy" or
"provides assurance of its integrity". This is an error. The problem of
"what exact OS is this machine running" recursively repeats itself on every
platform, until you use a box with a hardware root of trust.
Great, that goes counter to your assertion that you'd have to explain how a
TPM works. Counsel won't care to know the specifics of how it works, beyond
its function (assuring integrity) and the assumptions that go into
providing that function securely.
I gently suggest that you reconsider a hardware root of trust. It does
indeed solve a problem that just making a host "offline" does not solve.
Hope this helps,
- egs

@_date: 2015-03-02 22:59:49
@_author: =?UTF-8?Q?Emin_G=C3=BCn_Sirer?= 
@_subject: [Cryptography] Cheap forensic recorder 
You can buy that today. Here's the specs for that chip seated in resin:
2) We set up a notary log infrastructure. Let N(t) be the output at time t.
Someone did that, too. That someone is me:
There are better ways, but this is fine.
4) We calculate hash values etc. over the encrypted data.
A TPM is a single device that can do both of these activities.
I guess one of your goals is to make sure to not read up on the state of
the art. This has been a very amusing thread. Best of luck with your
- egs

@_date: 2015-03-02 22:33:33
@_author: =?UTF-8?Q?Emin_G=C3=BCn_Sirer?= 
@_subject: [Cryptography] Cheap forensic recorder 
hardware is to move down in complexity, not up. I?d like to see a series of
small security devices based on minimalist processors. We?ve talked about
HRNGs in the past. How about a small device that did nothing but compute
the hash of the contents of an SD card?
Ironically, you're describing a TPM platform.

@_date: 2015-03-07 17:37:28
@_author: =?UTF-8?Q?Emin_G=C3=BCn_Sirer?= 
@_subject: [Cryptography] Cheap forensic recorder 
This discussion brought up a few points worth clarifying:
1. A TPM is just a hardware component. It is not an end-all solution, in
fact, it's not even a solution by itself. Soldering one onto a board does
not confer any magic capabilities. The integration of the TPM onto the rest
of the hardware and software (i.e. the "platform"), the way it is used by
the software, and many other factors, play a role in how well the resulting
statements from the platform can be trusted.
such as ensuring that private keys generated on the device can't be
exported or become visible to a program that might export them.
2. TPMs can perform additional functionality that goes beyond that. In
particular, they can perform attestation, i.e. the process of issuing a
statement about the state of a computation, where the verity of these
statements rests on clearly-specifiable assumptions.
3. TPMs and trusted boot are indeed different things, and in fact,
attestation is itself different from trusted boot. Attestation can be used
to implement trusted boot, but can also be used for other, more general
functionality, such as attesting to the state of a dynamic computation, not
just its boot-time hash.
subverted by the NSA and then called "TPM".
There are three errors here:
4. It's critical to separate abstract ideas from their implementation. A
TPM is a generic name given to a class of devices. An Atmel TPM, for
instance, is a specific instance. An agency may have subverted a particular
instance at a given time, or perhaps every instance, in the worst case. We
seem to be going through a particularly bad time where intelligence
agencies seem to have compromised quite a few of manufacturers' processes.
But these considerations of which instances are trustworthy is at a
separate level of abstraction, unless you're willing to make the claim that
*all* secure hardware coprocessors are untrustworthy for all time. Not only
is the latter a tall claim, but that set of assumptions (that no hardware
canbe trusted) is difficult to work into a coherent worldview.
5. TPM doesn't parse as (Trusted) (Platform Module). It parses as (Trusted
Platform) (Module). It's just a module used in building platforms one may
be able to trust.
6. Trusted != trustworthy.
At the end of the day, every machine entrusted with a function entails a
particular set of trust assumptions. It's possible to homebrew a device
that operates as a tamper-evident, attested box, using epoxy resin and a
lot of assumptions about software provenance, e.g. what was running on the
machine that prepared the images for the homebrew device, and what was
running on the machine that prepared that machine, and so forth. It's also
possible to use a hardware root of trust to replace a large number of
assumptions about software with a smaller number of assumptions about
hardware. As always, it's a game of finding a set of assumptions that match
the task.
Overall, this discussion would have been better informed if the assumptions
and requirements were stated up front. As with most real-world security
discussions, they trickled out piecemeal.
- egs
