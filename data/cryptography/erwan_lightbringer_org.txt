
@_date: 2014-08-20 10:56:47
@_author: Erwan Legrand 
@_subject: [Cryptography] CSPRNG for password salt 
How about this? Suppose there is a flaw in some widely deployed
software which allows easy retrieval of the password file.  Now,
thanks to Google
( I
might have access to 100,000,000 password files which I can merge and
feed to my password cracker. A very predictable salt (such as a
counter or rand() with a fixed seed) would drastically reduce the cost
of attacking passwords.
Note that there is a big difference between discussing implementation
details on this list and giving advice to the public at large (well,
to web application developpers). Advice needs to be simple: use this
and that. Also, the cost of requiring a few bytes from a CSPRNG per
account created is unlikely to induce any noticeable overhead.

@_date: 2014-08-20 11:57:42
@_author: Erwan Legrand 
@_subject: [Cryptography] CSPRNG for password salt 
One more thing: using a CSPRNG to generate removes a possible cause of
failure. It is very easy to get counters or rand() wrong. For example,
think of a multi-process program such as Apache HTTP: all processes
inherit the same seed or initial counter value. Many users end up
having the salt.
So even if using a CSPRNG to generate salts does not make sense from a
theory point of view, it may make sense from en engineering best
practice point of view. (Although engineering best practice should
first recommend using an existing password hashing library if

@_date: 2014-08-20 12:14:22
@_author: Erwan Legrand 
@_subject: [Cryptography] CSPRNG for password salt 
Here's another real life example, this time of a problem encountered
with rand(). Calling some third party library function resulted in the
seed being set to 0. I seem to remember that libxml2 does this.

@_date: 2014-08-20 13:12:00
@_author: Erwan Legrand 
@_subject: [Cryptography] CSPRNG for password salt 
Le 20 ao?t 2014 12:23, "Jerry Leichter"  a ?crit :
that's quite difficult to build correctly, as we've seen from many
discussions on this list - with something as simple as "remember the last
one and add one to get the next".  We've had predictable "CSPRNG's" in the
software that guarantees that won't happen is a very minor problem.
Arguing for CSPRNG's *on the basis that solving that problem is a likely
source of weakness*, when there are *so* many much more complex things to
get right, makes no sense to me.
As I said, the target audience is web application developpers. These do not
write CSPRNG's. Yet many of them write authentication code using a crypto
Does this make sense now?

@_date: 2014-02-05 23:23:11
@_author: Erwan Legrand 
@_subject: [Cryptography] who cares about actual randomness? 
The issue lies in the protocol you suggest. Let's use Blum's coin
flipping by telephone to generate a non-random stream of bits that
neither you nor I can predict.

@_date: 2015-01-27 18:42:29
@_author: Erwan Legrand 
@_subject: [Cryptography] CVE-2015-0205 anyone? 
Can anyone make sense of the announcement for CVE-2015-0205, an
alleged security flaw in OpenSSL?
Here is what the announcement says:
It seems to me that accepting DH certificates from the client without
a Certificate Verify message is expected, since DH certificates have
no signing capability. A quick search in any of the TLS RFC's or in
the SSLv3 spec appears to confirm this.
I had a look at the fix for this vulnerability and it appears to add a
requirement for a Certificate Verify message even if the client cert
is a DH cert which as I see it is a violation of the SSLv3 spec and
all TLS RFCs and insures that DH certs can no longer be used by
clients connecting to OpenSSL servers from now on.
Did I miss something?
PS: I do realize that probably nobody cares because nobody uses DH certs.
