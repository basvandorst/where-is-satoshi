
@_date: 2001-06-21 14:24:43
@_author: Ian Goldberg 
@_subject: septillion operations per second 
In article <4.2.0.58.20010620115736.00b3ddb0 at pop.xs4all.nl>,
Work it out. A computer that could do a septillion ops per second.
Let's be generous, and suppose it could actually try a key in a single
operation.  To try 2^128 keys would take
2^128 / 1000000000000000000000000 seconds, or about
10790283 years.  To try 2^256 keys of course would take
2^256 / 1000000000000000000000000 seconds, or about
3671743063080802746815416825491118336290905145 years.
I'm not worried.  The question about RSA is harder, since we don't
actually have a good idea of the real complexity of that problem.
For all we know, the NSA already has better algorithms than we do.
Our current algorithms are limited more by memory than by computrons.
   - Ian

@_date: 2001-06-21 14:58:08
@_author: Ian Goldberg 
@_subject: septillion operations per second 
In article <200106202050.f5KKoqE10754 at valis.black-ice.org>,
Actually, his explanation (which involves the energy required to erase
bits) isn't correct; look up "reversible computing", which is a way
to do computations at lower energy than the limit he proposes.
   - Ian

@_date: 2001-09-14 14:24:24
@_author: Ian Goldberg 
@_subject: Rijndael in Assembler for x86? 
In article <87d74urezs.fsf at snark.piermont.com>,
Are you sure?  For general code, that certainly hasn't been true in a
long time; optimizing compilers nowadays can often do *better* then
hand-coded assembler.  However, for encryption code in particular,
I can imagine the C primitives (which usually lack rotate, etc.
instructions) may be suboptimal.
That being said, back when I wrote the 40-bit RC5 breaker for the RSA
challenge, I thought the same thing.  I figured I would first write a C
version, and then tune the resulting assembler.  When I looked at what
gcc had output, it had already done all the tricks I had in mind.
I would severely doubt a slowdown of "many times".  I'm more likely to
believe a few percent, and would not be surprised if the compiler's
optimizer is smarter than most people's.
   - Ian
[Moderator's note: The best DES implementations for i386s in assembler
are several times faster than the best in C. I'm not sure about AES
but I'd prefer to try and see. Perhaps it's a feature of DES's odd bit
manipulation patterns, perhaps not. I have yet to see GCC produce code
for almost anything that was just as fast as hand tuned assembler,
though. --Perry]

@_date: 2002-04-07 21:22:58
@_author: Ian Goldberg 
@_subject: Cryptographic & Steganographic File Systems for Linux 
In article <20020406093954.6956530706 at lion.ninthwonder.com>,
I use loop-aes, and it's just what you describe: an external module that
you compile separately ("make") from your kernel.  The kernel should
automagically load the module for you when needed, even.
I've used it on RH 6.2 on both 2.2.x and 2.4.x kernels, with no
   - Ian

@_date: 2002-02-04 17:30:52
@_author: Ian Goldberg 
@_subject: CFS vs. loopback encryption (was Re: [open-source] File encryption) 
In article <56A53A20-175F-11D6-9052-000393471DA8 at pobox.com>,
I use loopback encryption on Linux (loop-aes.sourceforge.net).
I'm very happy with it.  I have it encrypting data with a passphrase
and swap with a random key.
   - Ian
