
@_date: 2016-09-16 23:42:00
@_author: =?UTF-8?B?xLF1b8qO?= 
@_subject: [Cryptography] Recommendations for short AES passphrases 
Though I've been following this list for a while my understanding of
cryptography is very basic.
So forgive me if I hope I haven't mixed any terms or got anything horrobly
I recently came by a service that uses dangerously short passphrases for
The current implementation using a 6 chars from BASE 36 encoded string.
The KDF is just one round of salted md5 (as defaults by openssl).
I think the main reason for selecting short passwords was that they could
be easily shared/written and that might be a requirement of the software.
Now though the information is somewhat sensitive it is not intended to be
secure against any advance adversary.
I would assume that any attack that will cost more then 100$ per key is
probably way more valuable then the
actual information. But as it stands now cracking the encryption is too
trivial (I did it on my ageing  laptop in couple of days)
So I was trying to think how to increase the security while still keeping
the passphrase relatively short.
I thought of suggesting using 8 chars BASE 58 using random salt and PBKDF2
with 1000 iterations
This is not very high number of iterations but on my system it takes a bit
less then a second to calculate and
since this is a runs on the clients which might be less powerful I don't
think they would be willing to compromise much more time.
So how feasible is this solution.
Can a 8 char passphrase be relatively secure or can it be bruted relatively
easily even with the increased rounds.
Is there any better solution to have ~ strongly encrypted data with
relatively short and easy to share key ?
Any comments or helpful suggestions would be appreciated

@_date: 2016-09-17 20:01:43
@_author: =?UTF-8?B?xLF1b8qO?= 
@_subject: [Cryptography] Recommendations for short AES passphrases 
I just noticed my reply was not sent to the list so I'm forwarding it  -
Thanks Jon and John For your reply.
I guess I wasn't very clear so let me try and give some more
information about the situation.
it's not a system I'm responsible for It's just some online service I
became aware of.
Since it's currently extremely broken, I don't want to reveal too much
information to identify the actual service. I'm also not 100% sure
about the reasoning for using a weak passphrase in the first place.
But lets assume you have an online Pokemon location sharing service.
So users can jump to your site share the location of the Pokemon they
just found.
When they do that a random salt and key is generated on their device
and the data is encrypted only the data and salt is sent to the server
so the server can't access the Pokemon location.
the user receive a link she can exchange with other Pokemon hunters.
The URL has a text representation of the key in the hash part (after
so its never sent to the server but allows to decrypt the data to who
ever has the full URL.
As you can see sharing the key is part of the requirements I don't
think there is any way around it or that PBK encryption will be a good
match here. The key is unique and not controlled or has to be
memorised by the user. But I think it has to be short and simple
enough so it can be typed on a mobile phone or dictated to someone.
The Pokemon location is only good for a week since after that the
Pokemon will probably be in a completely different location.
So if an attacker can't break the encryption in a week it is not worth trying.
Value wise the data is probably more valuable than Pokemon location
but not much.
As I mentioned I can assume 100$ per share is probably a very high
assumption but I doubt its actually worth more than 10$ remember this
is data the user intended to share with strangers any how, but we
still don't want to make it public.
So I know for any powerful adversary a 8 chars BASE58 will be probably
easy enough to crack, If I did the math properly there should be ~125
Trillion possibilities for the passphrase.  If I assumed a medium
adversary can try a Million keys a second it would still take longer
than 3 years to go over the entire key space.
So if I use a slower KDF like (1000 rounds of PBKDF2) that will be 3,000 years.
When I cracked the original encryption (that only used md5 for KDF) I
got ~ 10,000 attempts per sec (KDF and FULL AES decryption), so I hope
the numbers here are secure enough to represent medium adversary
(which has at least 100 times more computing power than I have).
Of course we can always increase the KDF rounds but I think 1000 is
probably the limit performance wise, they might be willing to go 2000
rounds but having 2 seconds extra lag on loading time is probably a
bit too much (remember KDF is running on the client which might be a
mobile phone with a weak cpu)
Looking at the cold math It feels like 8 chars are secure enough for
the mentioned requirements, for me it still feel quite too short.
So is it actually secure enough or am I missing something.
Is there any better way to generate short key that will still be
somewhat secure.
I can assume there might be some gpu resistant hashing algorithms that
might be a better candidate for the hash (maybe scrypt?) that might be
an option but I knwo there current crypto lib (there using CryptoJS
which I'm not sure is very good one) supports PBKDF2 so if that's good
enough I think its easy switch for them.
I also have some wonders about the PRNG being used but that's probably
on another topic once I'll get the base key length sorted.

@_date: 2016-09-19 11:41:05
@_author: =?UTF-8?B?xLF1b8qO?= 
@_subject: [Cryptography] Recommendations for short AES passphrases 
So from this benchmark it seems like 26156.2 kH/s of PBKDF2-HMAC-SHA1
at 1000 rounds.
which means it can find a single key in less than 2 months.
and I can only assume a cost of ~ 2000$ per key.
this is probably way more secure than the implementation need to be,
but I can see why it feels a bit weak.
Any way I notified the service owner about the issues with the current keys.
I offered him to have default mode where long keys and urls endpoints
are generated and only
use shorter ones if the user explicitly chooses to.
I offered him to have 12 chars passphrase for the short length mode
As for the PRNG that actually chooses the password.
The current implementation used Math.random() which is not
cryptographically secure.
The best option would probably be to use the browser Crypto API
getRandomValues but that might not be available on all browsers
and I couldn't actually find what the actual implementation so I hope
we can trust the browser vendors on this one.
Since the encryption is using CryptoJS I thought he might be able to
use its PRNG but when I looked at the implementation it seems like
there using `Donald Knuth's linear congruential PRNG` which from what
I could find online is also not cryptographically secure.
I find it a bit weird that a crypto lib PRNG wont be cryptographically
secure so maybe I got it wrong.
