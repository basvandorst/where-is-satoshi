
@_date: 2020-08-20 18:51:02
@_author: Sid Spry 
@_subject: [Cryptography] any reviews of flowcrypt PGP for gmail? 
Well, I see a few problems, most of them unrelated to the actual implementation:
1. Updates pushed from Chrome app store. Updates that compromise the encryption
could be pushed to targeted users.
2. The plugin runs in the browser and could likely side channel message info via
analytics/tracking APIs, etc.
As I'm sure you know this good for getting people to actually use it. I think Telegram
or Signal fare better, but are not suitable for all conversations perhaps.

@_date: 2020-12-20 22:24:04
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?s_are_such_a_mess?=
Digital attestation for document signatures is the point. There are other
governments which do it, off the top of my head Germany is one?
The alternative is just putting an image of a signature on a box, which is
popular in the US.

@_date: 2020-07-01 22:27:32
@_author: Sid Spry 
@_subject: [Cryptography] Stream Cipher over Unreliable Transport 
Hello list,
I'm assuming the title has been done before. I am having some trouble turning up good examples of an implementation. Most stream ciphers I can find discussed assume transport integrity.
My algorithm agnostic design is:
1[sequence number] | 2[ 3[signature] 4[sequence number] 5[data] ]
Though this is still packetized. Estimated acceptable packet size is 1024 bytes or less, ~256 bytes preferred.
The first block is a sequence number directly encoding stream cipher state so that messages may be missed. The second block is the encrypted payload which contains a signature for authenticity followed by a sequence number which must match to avoid replay attacks, followed by the data. (Or, alternatively, the internal sequence number can correspond to the external one by some secret relation.) The cipher will be set up by a separate, slower but reliable transport so the stream cipher initialization can be exchanged as well as the signing key.
Is this sound? Is there something already in existence? The best I remember but cannot re-find is a disk encryption block mode that allows for missing blocks that I could repurpose. My imagined selection is one of ChaCha20, AES-CTR block mode, or something based on the Mersenne twister, if any of those aren't patent encumbered.
I've also found  the evolution of an earlier stream cipher with built-in MAC. However this looks to also assume transport integrity.

@_date: 2020-07-02 16:13:37
@_author: Sid Spry 
@_subject: [Cryptography] Stream Cipher over Unreliable Transport 
Well, it's not. As I point out I looked at disk encryption block modes.
This seems intractable as if I am understanding your statement
you would need to store another disk of key material, which
defeats the point?
Yeah. I was tired when I wrote this, I wanted to get it in before bed
so I had a response or two to look forward to the next day. My
original obsession with stream ciphers was their typically easier
implementation on an MCU. I've since decided to not use one,
so I may as well just use a block cipher. A big problem on a
typical MCU today also is there's no way to easily add a MAC.
But I am still interested if there ARE any usable stream ciphers
for my stated purpose.
As it is my "design" is more or less just a block cipher based
design already. So, will just use that.

@_date: 2020-07-02 16:24:19
@_author: Sid Spry 
@_subject: [Cryptography] Stream Cipher over Unreliable Transport 
This is a good design that I think fulfills my literal question, thanks.
I will probably just use a block-based design similar to TLS now that
I am not on a resource constrained system.

@_date: 2020-07-02 19:40:11
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?_P=2E=2C_Barr_on_Introduction_of_Lawful_Access_Bill_in_Senate?=
I'm unable to provide a direct citation but his outline of the wording is correct,
they are disallowed because they are effective encryption. If you published the
keys close to the time you began transmitting you *might* be able to try to skirt
by on a technicality but the intent of the law would be against you.
But you *can* transmit some attestation of message integrity.
The rationale he gives may or may not be right -- from memory it's not explained in
the text of the law.

@_date: 2020-07-06 23:17:04
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?_P=2E_Barr_on_Introduction_of_Lawful_Access_Bill_in_Senate?=
Tangential perhaps but a good example of this is the signed
bootloaders that restrict freedom and are ostensibly to prevent
However in the Asian markets you can find chipsets doing things
they were never advertised to do, implying some local companies
have the signing keys and are reprogramming the chipsets.
If you weren't aware typically everything in those economies is for
sale and it's typical that you take your old employer's IP with you
when you go. So, organized crime the world over likely has signing
keys for chipset level exploits. But you have no ability to sign your
own board firmware as a preventative measure :^)

@_date: 2020-07-10 09:26:48
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?dled_with_known_flaws_and_run_ancient=2C_unpatched_Linux=22?=
If the complaint is about malicious or unmaintained hardware why do
you expect your switch to listen to you if your router won't?

@_date: 2020-07-10 09:33:58
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?dled_with_known_flaws_and_run_ancient=2C_unpatched_Linux=22?=
Your PCEngine is "open source" in the same exact way the RPi is. Compare
and contrast coreboot with libreboot. A bunch of immutable static config is
pushed to your hardware that you can't change.
(I don't know the specifics of that part, but keep in mind libreboot had to
abandon all devices post 2013.)

@_date: 2020-11-02 23:41:02
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?ows_security?=
The core of Windows is actually VMS based and very Unix-like. There's even a whole /sys-like tree in \\.\, the "real" root. The drive letter based roots you see are emulated for backwards compatibility along with many other things.

@_date: 2020-11-08 21:32:31
@_author: Sid Spry 
@_subject: [Cryptography] reliable broadcast channel 
It's democracy if I like it, tyranny of the majority if I don't.
I can see warning a user if there is an irregularity in the way Monero
tends to do, but what actionable information does this give the user?
The situation has become degenerate, you may just need to stop
doing whatever it was you were doing.
The example of check kiting is a bad one -- the solution is probably
to view the "unauthorized credit" (double spend) as either
inconsequential or impossible.
The two general's is insoluble. If your communication link is faulty then
you will not be able to provably reach consensus.

@_date: 2020-11-15 22:09:49
@_author: Sid Spry 
@_subject: [Cryptography] FIPS 140 validated crypto module on Android? 
Bouncy castle seems exactly what you want. FIPS 140-2 level 1 certified, Java or C
Both languages see major use on Android.
As an aside, I'd suggest avoiding doing native code work on Android. It is possible
but the platform was not meant for it.

@_date: 2020-11-17 09:01:25
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?s_are_such_a_mess?=
Unfortunately, people seem to have problems remembering passwords
over 8 characters. I think they chose this number by studying passwords
that people were likely to come up with in the absence of any criteria.
This sounds expensive -- help desk time for password resets can be a
nontrivial percentage of all support calls.
The latter two seem to help the most. People who might not be able to
remember a >8 char password can remember a nonsense babble
Along with proper hashing, this is likely the best change that can be done
with no user involvement. Long-ish delays decrease the chance someone
will walk in and guess the password, and give an IDS ample time to see
the attempts.
Difficult. Most implementations require the user to transfer a file around.
It might be best to have a key padding scheme, but for mnemonic passwords.
Maybe make it available as an app.
Realizing this can be okay is good, but can be remedied by choosing shorter
passwords. An actionable threat model is someone walking into the office
and touching a computer. Many businesses fail this, including banks. The
passwords are either nonexistent(!) or on the machine..

@_date: 2020-11-19 15:44:32
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?s_are_such_a_mess?=
It does use dictionary files, they're created by collecting leaked password
databases. This serves two purposes: login attempts can be done from the
dictionary file with some chance of success, and reversing a properly salted
password database is only feasible with such a dictionary.
Brute force in the strictest sense isn't usually tractable.

@_date: 2020-11-20 16:53:51
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?s_=09are_such_a_mess?=
Point: NTLM is particularly weak compared to modern constructions and
as you are aware JtR is using dictionaries and pattern based searches gleaned
from analyzing plaintext and reversed user databases.
That's not really brute force, you're guiding the search. But thankfully(?)
most people choose bad password.

@_date: 2020-11-27 01:40:20
@_author: Sid Spry 
@_subject: [Cryptography] A Scheme for Verifiable Lottery 
How do you select the lucky number to MAC?
Problem is that the security seems to be achieved first by relying on
the organizer to be fair, and then secondly by consensus of the participants.
First is easy, how do you pick the lucky number? Second is also easy,
the participants agreed on a scheme.
Relying on something like a personality handle is interesting. It is long-
lived and hard to change. But these qualities also preclude it from being
secret, so you're back to the organizer selecting a random number.

@_date: 2020-10-02 20:38:54
@_author: Sid Spry 
@_subject: [Cryptography] Exotic Operations in Primitive Construction 
Generally as follows. For simplicity's sake I've removed the container
type you need to store an arbitrary sized number. You should see the
size of the type as a potential parameter.
uint16_t reverse(uint16_t v) {
To know the best way to do this efficiently you'd have to know why you are
doing it. You could generalize the algorithm above in a way compatible with
how GNU's BigNum library works, but you could potentially store the
information you are representing with the bits as something else entirely.
This is exactly why I asked the question. I had begun to wonder if rotation
was an operation that could be analyzed in an algebraic way, especially
for other digit systems. Perhaps I should have asked that explicitly, but I
also wanted to ask about other hard to generalize operations.
Reversing the representation of a number seems like a good one. I'm going
to speak to more replies, but I'm trying to figure out what I meant to ask.

@_date: 2020-09-24 00:05:14
@_author: Sid Spry 
@_subject: [Cryptography]  
=?utf-8?q?cture_for_the_Mesh?=
Federated systems would solve this. It'd work kind of like email addresses,
but you need a more robust technology like XMPP. Users could be globally
addressable with their fully qualified federated name, e.g. alice at wonderland,
or their local name within the node.
What makes this better than email addresses is that the user would have a
closer relationship with their federated node.
There's still problems, but it seems like a good start. In practice fully P2P
systems don't seem to scale well.

@_date: 2020-09-28 23:50:23
@_author: Sid Spry 
@_subject: [Cryptography] Exotic Operations in Primitive Construction 
I noticed the other day that bit shifts and rotates are very popular in
primitive construction. Why is this the case? Intuitively it seems to me like
these operations are some of the most irregular that a computer has to offer.
Bit shifting is related to division, but bit rotation does not seem closely
related to any other easy to analyze operation. But I have no explanation for
why it feels this way.
Perhaps the only more irregular operation I can think of is a lookup.
Are any operations particularly hard to analyze? I realize some of this is
irrelevant, lots of attacks operate on the statistical properties of the output
and the input. But it is still important.
