
@_date: 2013-12-21 18:07:45
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] Why don't we protect passwords properly? 
An ASIC is always faster. It's only a problem if the algorithm is widely
used and the public doesn't have access to hardware implementations. For
something like AES, this isn't true.
The main principle behind password-based KDFs like scrypt is to make
building ASICs to efficiently crack a digest database prohibitively
I'm really positively surprised to read this sentence. I would have never
expected cryptocurrencies to be a reason people started talking about using
expensive KDFs for something like password authentication.
It's hard to believe there was a conspiracy. Too many people who have no
relation to each other would have to be involved
It's much more likely that forcing an adversary to require more die area,
and thus pay more for an ASIC to break something, is a plainly unsexy
concept to most developers; that it's more of a failure of marketing than
anything else. (That applies at the other end of the scale, too: Most
professional cryptographers consider this a solved problem, so very few
work on it.)
There are people who really should know better: IETF WG members, for
example, who to this day submit drafts with password authentication
mechanisms that amount to two iterations of SHA-256(salt+pwd.) That is
inexcusable ignorance. But for the majority of developers, it's probably
just that most don't know that there is a better way, and since there is no
de facto library available to handle this stuff, they're forced to invent
their own. (The closest to a standard has probably been bcrypt, which owes
its success, at least in my opinion, to its extremely accessible API.)
The most popular argument against something like scrypt seems to be that
using an expensive function makes you susceptible to DDoS attacks. This is
true, but it's also completely beside the point. Think about it: everything
you do--database queries, template rendering, etc.--incurs overhead, so the
solution isn't to make your password digest database weaker, but to prevent
malicious users from doing those things over and over. (And if your
application is really so big that *legitimate* logins are a DDoS concern,
then you should be able to handle it without compromising user security by
adding more hardware.)
Unfortunately, there are many programmers that share your attitude that
crypto is way cool, but *don't* spend anywhere near enough time actually
studying it before making the next big privacy-preserving social
application with "military-grade AES 256-bit security." If they did, I
think we'd see a lot more scrypt, bcrypt, PBKDF2, SRP, etc., and much fewer
homegrown, ineffective contraptions.
Similarly, the people who do know better owe it to the average consumer to
be advocates for things like KDFs in password authentication constructions,
even if they are old and unsexy concepts.

@_date: 2013-12-22 00:16:49
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] Why don't we protect passwords properly? 
The biggest reason has been that web services can't expect clients to run
something like scrypt in JavaScript. If it's e.g. a native application,
there is no reason why you shouldn't offload this to the client.
There is some hope: PBKDF2 made it into the WebCrypto API spec, so you will
at least be able to run e.g. PBKDF2-SHA256 in browsers as native code.
There are also asm.js implementations of scrypt which seem reasonably fast.
As far as "simply replacing with scrypt" goes, I think it's unfortunate
that most packages that implement it do so very confusingly, either with
misleading terms such as "Password encryption", or solely as a KDF, with no
instructions or API available to do something similar to bcrypt, which
retains the parameter configuration in the digests it produces. The
Password Hashing Competition ( will hopefully
choose something with a simple API.
But yes -- you're singing my song, and probably that of many people on this
list. It's a messy situation, and there's no good reason for it.
If the TrueCrypt authors were paid off to not implement something stronger,
which I think is unlikely but can't reject is a possibility, there are
other projects to support--FreeOTFE for example. But you're right that it
seems awareness needs to be raised across the board.

@_date: 2013-12-22 02:40:25
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] Why don't we protect passwords properly? 
Why do you think they should know any better?  Just curious...
Point well taken.
3.  The amount of stuff to learn to defeat the aggressive knowledgeable
Indeed, in light of recent events, it's easy to think that almost anything
a single person or a small team does is futile against a well-equipped
adversary. (I dare say one guy, given any amount of training, would still
be bested by the tendency of any human to make mistakes.) That puts an even
greater emphasis on the need for large groups composed of people with such
diverse strengths to work for the public good.
The best a single person can do is to use whatever is presented to them. If
they're never presented with anything, or don't understand the "why" (and
they actually tried to,) you can't really blame them for messing up
something important.
I certainly don't mean to loudly criticize developers who choose a poor
construction. or make their own, even if it might put many users at risk.
If we know what works, but people continue to do something completely
different after more than a decade of md5crypt and bcrypt, the failure is
on us being... well, poor teachers. (Sorry, I couldn't resist.)
I tend to be the loudest in my criticism when people actively argue
*against* anything but a few iterations of SHA-256 with arguments that
outright dismiss user security without even providing a usability benefit.
When you're having trouble reaching a bigger crowd, misinformation
certainly doesn't help.

@_date: 2013-12-22 18:17:45
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] RSA is dead. 
But how will we do crypto then? :)
Open source can certainly help, but it's far from a panacea. Even huge
projects like Ruby on Rails, PHP, even Linux, still have huge security
holes (code execution, privilege escalation) that have been there for years
and were *not* obscured. You're assuming that, not only will anyone look at
your code at all, they will have training in cryptography, know to be
looking for something bad, and spend a large amount of time on finding it.
All very big "if's."
I am not suggesting that closed source provides much more than obscurity
and a simpler route to profits, but the act of open sourcing your software
accomplishes nothing if nobody qualified actually reads it (apart from
giving you the PR benefit of being able to say "we're open source.")
History has shown countless times that open sourcing alone doesn't fix bad
code practices; it's not likely to more readily fix malicious ones.

@_date: 2013-12-24 21:37:40
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] Why don't we protect passwords properly? 
I agree that these are good reasons to look for improvements. (In fact, the
memory access concern with scrypt was one of the main reasons the Password
Hashing Competition was started.) I wholeheartedly disagree that they're
good reasons to use PBKDF2 over scrypt (which coincidentally uses PBKDF2
itself,) since scrypt is still far superior at the main goal: Making a
wholesale offline attack against all of the passwords in a user database
prohibitively expensive.

@_date: 2013-11-11 19:18:02
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] HTTP should be deprecated. 
I don't disagree with you, but it's important to note that thousands of
companies are getting this kind of information whether the sites you're
browsing are delivered via HTTPS or not. It's virtually impossible to find
a major website that doesn't employ some kind of third-party tracking,
including sites like webmd.com. This is not to mention the difficulty of
finding out what information these companies are actually collecting and
what they're using it for.
I do think that MITMs (e.g. NSA) being able to identify your interests,
health issues, etc. is a concern, but that uncontrolled tracking is a much
bigger one. After all, the NSA can just compel one of those tracking
companies, or a site itself, to give up all their information--then SSL
won't have helped you.

@_date: 2013-11-11 20:03:15
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] HTTP should be deprecated. 
I think you missed John's point, which was that, while the information may
be something that is readily accessible to all, the fact that YOU are
accessing it is interesting information. And that's true, but somebody is
going to get that information whether or not the channel is encrypted.
Which? It's very easy to cache stuff when HTTPS is used, either server-side
or client-side (Cache-Control header.) It's just a transport.
The fact that the CA model is a mess and browsers depend on it is a much
bigger disadvantage.

@_date: 2014-08-20 14:11:41
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] CSPRNG for password salt 
There are several software packages that exist solely to coordinate
incrementing values like ID columns in a distributed database. If your
system isn't distributed, you may not have this problem at all, and it may
indeed be easy.
This counter vs. CSPRNG debate is analogous to the choice between using an
incrementing ID vs. using an UUIDv4 in any other kind of database. With
UUIDv4 you risk a few collisions, but it is significantly easier to manage
because no coordination is necessary. There is no need for nodes to speak
to each other to make sure an ID (or salt) isn't taken--as long as you can
live with the small risk of occasional collisions--nor is there a need to
store and manage access to the associated bookkeeping state.
Is CSPRNG output necessary for a salt? Clearly not. But it does remove a
lot of potential pitfalls, and regular developers should not be expected to
understand all the implications for either approach (although they probably
shouldn't be generating salts by themselves either.)
Besides, this is already settled in practice: Pick most any general-purpose
password authentication library, and chances are it generates salts using
urandom (or similar) under the covers. It's just easier that way.

@_date: 2014-12-24 18:01:47
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] Tribler also means you're an exit node? 
Why torrent files the normal way when you can become anonymous by
torrenting small chunks of huge numbers of files instead? I'm sure ISPs and
prosecutors will understand!
Even if they start mentioning this little detail, their implementation
would still be horribly broken: ECB mode without authentication, no RSA
padding, poor random numbers, and code like this:
    try:
        raise ImportError()
        from Crypto.Random.random import StrongRandom
    except ImportError:
        from random import Random as StrongRandom
The list goes on:
Tribler is the Telegram of torrent clients. Stay far away from it.

@_date: 2015-04-30 15:23:27
@_author: Patrick Mylund Nielsen 
@_subject: [Cryptography] [cryptography] Matt Blaze Testimony on Encrytion 
Highly recommend watching the video (it gets good at around 28 minutes in,
and don't worry about the length--a big chunk of the video is just a "We'll
be back momentarily" banner.)
Very sobering to see sanity almost across the board, and I at least was
surprised that there are people with computer science degrees in Congress!
