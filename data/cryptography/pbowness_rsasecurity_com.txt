
@_date: 2006-02-01 09:46:59
@_author: Bowness, Piers 
@_subject: Unforgeable dialog. 
This is concept is surprisingly complex. Once the attacker sees the
"secure" dialog, what prevents them from using the same techniques
and/or code to create a visually identical spoof? There have been
several OS-level designs to create hardware-supported secure dialogs.
Needless to say, these schemes became exceedingly complex and had a
variety of implementation issues (i.e. special graphics hardware,
drivers, TCMs, etc.)
I don't see your proposals as providing 'secure' data viewing or data
entry solutions. IMHO, the best bet is currently provided by layered
security software where each component monitors and reports on the
others. Even this approach is temporary at best as we're now seeing with
malware that attacks by first disabling the currently available
protection layers (e.g., anti-virus, firewalls).
Piers Bowness
"I know what I believe, and I believe what I believe is right." - G.W.

@_date: 2007-06-11 09:28:02
@_author: Bowness, Piers 
@_subject: Why self describing data formats: 
But what is does help is allowing a protocol to be expanded and enhanced
while maintaining backward compatibility for both client and server.
Provided care is taken to have the protocol contain the previously
required items, consumers (clients) can examine the version information
and continue based on a minimum required version (i.e., The client
*must* be receive version X.Y or higher.) Clients can safely ignore new,
unrecognized protocol elements while greatly simplifying server code
(which just emits the high-version protocol).
I would generally reserve the term "protocol" for wire transmissions
(where presumably client and server could negotiate an appropriate
version). Many of the self-describing "protocols" you mention become
static file formats.
This can have its drawbacks. An interesting workaround to this is the
use of "critical" key usage extensions in X.509 (forcing the client to
reject the certificate if there are key usage restrictions that a
specific client cannot recognize). There are also overhead issues
(especially for XML).

@_date: 2007-05-29 08:48:56
@_author: Bowness, Piers 
@_subject: A crazy thought? 
No. Usually the signer's certificate is included with the message so you
don't go anywhere to get Alice's certificate, but you verify it against
a trusted root. CA list. If you can get the recipient to accept a new root, the forgery
is pretty simple. If the end-user fails to validate the Trusted Root CA
list and examine the certificate signature chain, then any trusted root
CA could issue a cert with any "Subject" making any claim. And yes,
being in the security business, I do check the certificate chain for my
bank's on-line service before logging on. (I've also complained to them
when they re-used a certificate from one host for another.)
To some extent, CA's are all about policy. What steps were required to
obtain a certificate? These vary from "I had control of an e-mail
account at the time of certificate issuance." to "I've had my lawyer
present a notarized copy of my letters of incorporation and 2 years of
public financial statements". To me it's simple: Don't trust the root CA
if you don't trust them to enforce their policies. Verisign has built a
small business on this premise.
