
@_date: 2002-09-24 17:48:04
@_author: Bodo Moeller 
@_subject: Sun donates elliptic curve code to OpenSSL? 
Here's a longer explanation.  The Sun code in OpenSSL 0.9.8-dev is
available under the OpenSSL license; additionally, you have the
*option* to accept the covenant:
     The ECC Code is licensed pursuant to the OpenSSL open source
     license provided below.
     In addition, Sun covenants to all licensees who provide a reciprocal
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     covenant with respect to their own patents if any, not to sue under
     ^^^^^^^^
     current and future patent claims necessarily infringed by the making,
     using, practicing, selling, offering for sale and/or otherwise
     disposing of the ECC Code as delivered hereunder (or portions thereof),
     provided that such covenant shall not apply: [...]
That's a defining relative clause.  If you are not willing to provide
a reciprocal covenant, this has nothing to do with you.  You just
can't use the stuff patented by Sun, but it's not compiled in by
default anyway for exactly this reason.

@_date: 2002-09-25 13:41:36
@_author: Bodo Moeller 
@_subject: Sun donates elliptic curve code to OpenSSL? 
It's not a modified license, the OpenSSL license still applies.  But
as for IDEA and RC5, the software license is not the only thing you
have to take into account, you also have to consider patents.  Unlike
for IDEA and RC5, there's an offer by Sun that says you can use their
patents pertaining to that source code if you are willing to accept
certain conditions.  If you accept their conditions, you may compile
OpenSSL with preprocessor symbol OPENSSL_SUN_GF2M_DIV defined, which
enables a patented algorithm.  The default configuration does not
require you to accept Sun's conditions.
Something else that is disabled in the default configuration is point
compression for elliptic curves over binary fields; in this case it's
because of a Certicom patent.  I wouldn't mind if Certicom made a
similar offer as Sun, but I'm afraid they won't.

@_date: 2002-09-25 17:08:21
@_author: Bodo Moeller 
@_subject: Sun donates elliptic curve code to OpenSSL? 
The Sun copyright notice does not contain any additional clauses that
you are bound by.  The additional clauses apply only to those who
provide a reciprocal covenant.  You don't have to do this if you
compile the library in the default configuration.
*If* you accept the conditions, then you should fgrep for 'Sun
covenants' to find all files containing some of 'the ECC Code' covered
by the covenant.  Assume that you have a patent on some algorithm in
crypto/ec/ec2_smpl.c.  Sun lets you use their patented algorithm in
crypto/bn/bn_gf2m.c (not compiled in by default!) only if you let them
use your algorihtm in crypto/ec/ec2_smpl.c.

@_date: 2003-02-25 13:12:35
@_author: Bodo Moeller 
@_subject: [Bodo Moeller <bodo@openssl.org>] OpenSSL Security Advisory: Timing-based attacks on SSL/TLS with CBC encryption  
Anton Stiglic :
Actually there are three choices:
     Pad-then-encrypt-then-MAC
     Pad-then-MAC-then-encrypt
     MAC-then-pad-then-encrypt
It's true that pad-then-encrypt-then-MAC appears to be the safest
approach in general, but pad-then-MAC-then-encrypt would also have
avoided these attacks.  Unfortunately, SSL 3.0 and TLS 1.0 use
In a sense it is: as the block cipher padding is not to be included in
the MAC computation, you don't really know what bytes to compute a MAC
on before you have looked at the padding.  If the adversary can count
exactly how many input blocks are fed to HMAC, then you have a problem
that you cannot easily work around.  The attack demonstrated by
Vaudenay et al. users a less subtle timing difference (the difference
between a MAC on about 256 SHA-1 input blocks and no MAC at all), but
switching to Pad-then-MAC-then-encrypt should be considered for TLS 1.1.

@_date: 2003-02-25 16:55:46
@_author: Bodo Moeller 
@_subject: [Bodo Moeller <bodo@openssl.org>] OpenSSL Security Advisory: Timing-based attacks on SSL/TLS with CBC encryption 
The former.
Yes, I meant that implementations should proceed like this for
pad-then-MAC-then-encrypt.  For such a scheme it is the more natural
way anyway to first decrypt, then verify the MAC, then look at the
padding.  (In the case of MAC-then-pad-then-encrypt, on the other
hand, you can't verify the MAC before having handled the padding.)
For CBC (with explicit IVs, which we don't yet have in SSL 3.0 and
TLS 1.0) and for stream ciphers, both variants achieve probable
security.  The reason to prefer pad-then-MAC-then-encrypt is just
compatibility -- more specifically, ease of implementation (having
an improved protocol is much more useful if it makes it into many
actual products).

@_date: 2003-06-04 15:48:30
@_author: Bodo Moeller 
@_subject: Maybe It's Snake Oil All the Way Down 
pgut001 at cs.auckland.ac.nz (Peter Gutmann):
Using an explicit state machine helps to get code suitable for
multiplexing within a single thread various connections using
non-blocking I/O.

@_date: 2003-06-05 12:49:40
@_author: Bodo Moeller 
@_subject: Maybe It's Snake Oil All the Way Down 
I don't mind working with threads, but there's a lot of software out
there that uses single-threaded multiplexing, and adding SSL/TLS to
such software becomes much easier if the SSL/TLS library supports this
multiplexing paradigm.  (Not that it would be impossible otherwise --
another option, for Unix anway, is to fork off a processes that
handles a SSL/TLS connection and communicates with the main process
via a pipe.)

@_date: 2003-11-20 06:42:11
@_author: Bodo Moeller 
@_subject: Are there...one-way encryption algorithms 
The Pohlig-Hellman cipher is the modular scheme that you describe, but
observe there is a connection to the protocol above: that protocol
works only if encryption and decryption has a certain commutativity
property (decrypting  B(A(M))  with key  A   must leave  B(M),  not
just some  A^-1(B(A(M)))  that might look entirely different), and
the Pohlig-Hellman cipher has this property.

@_date: 2003-10-17 14:09:30
@_author: Bodo Moeller 
@_subject: anonymous DH & MITM 
Tim Dierks :
it is an RSA issue:
When using self-signed certificates, nothing stops you from creating a
new key and certificate every now and then.  The only slight problem
is that key generation for RSA is quite slow, compared with key
generation for logarithm-based cryptosystems; you probably wouldn't
want to create an RSA key for every incoming connection.  But, on
typical server hardware, it is no problem at all to create an RSA key
every couple of minutes or so.
While generally among the RSA-based TLS ciphersuites, only the
RSA_EXPORT ones provide forward secrecy (thanks to an ephemeral
512-bit RSA key), in the case of self-signed certificates the
distinction between export-restricted and other RSA ciphercuites is
not an issue as far as forward secrecy is concerned.
[Even when using "proper" certificates from some CA, you could provide
forward secrecy for RSA ciphersuites: Instead of obtaining an
end-entity certificate and directly using it on the TLS cipher, obtain
a CA certificate with nameConstraints appropriately limited.  Then the
server can sign its own end-entity certificates without resorting to
"self-signed certificates" in the usual sense.  This allows the server
to use newly created keys whenever it feels like it.]
