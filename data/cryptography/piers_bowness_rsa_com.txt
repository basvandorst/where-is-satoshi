
@_date: 2008-08-07 13:50:27
@_author: piers.bowness@rsa.com 
@_subject: security questions 
why find The answer is "Help Desk Call Avoidance"; allow the end-user to fix
their own account without having to get someone on the phone. This is
simply an available mechanism in the spectrum between easy-to-use and
rock-solid security.
and Your theory is incorrect. There is considerable analysis on what
constitute good security questions based on the anticipated entropy of
the responses. This is why, for example, no good security question has a
yes/no answer (i.e., 1-bit). Aren't security questions just an
automation of what happens once you get a customer service
representative on the phone? In some regards they may be more secure as
they're less subject to social manipulation (i.e., if I mention a few
possible answers to a customer support person, I can probably get them
to confirm an answer for me).
Piers Bowness
RSA - The Security Division of EMC

@_date: 2009-10-05 11:09:04
@_author: piers.bowness@rsa.com 
@_subject: Trusted timestamping 
I think there are two factors. 1) This is complex problem and 2) Where
it might have really been required (i.e. the courts) it has not; the
courts accept unsigned, text log files as reasonable evidence.
services provided by NIST ( Even
their "authenticated" offerings appear to be very limited, and use
static, symmetric keys (which can only be obtained by snail-mail!)
I've always liked the saying: "A man with two watches never knows what
time it is."  As long as there is more than one accepted internet time
source and the courts accept uncertified timestamps in log files, I
don't see any clear solution to (or reason to pursue) obtaining "signed
Piers Bowness
RSA - The Security Division of EMC

@_date: 2014-04-15 18:19:20
@_author: Bowness, Piers 
@_subject: [Cryptography] I  don't get it. 
> I am no expert in bugs, but it seems to me that about 99% of the The ability to detect these types of issues is beyond a typical compiler's job; it cannot
infer intent from the code being converted from language to machine code.
Static analysis tools, OTOH, probably would have pointed out the problem that a field
retrieved directly from the network was used to allocate storage without being compared
or filtered. These tools can only do so by looking at the entire code structure (across call
boundaries) and exercising data path analysis from 'source' to 'sink'.

@_date: 2014-04-17 10:32:36
@_author: Bowness, Piers 
@_subject: [Cryptography] I don't get it. 
That's exactly what modern static analysis tools are, "lint(1)'s descendants". No number of compilers or special options are going to analyze your application's flow like these new class of tools. 1977 is calling and wants its lint back.
Yes. Integrating a modern static analysis tool into your continuous integration environment will provide the most benefit. They also provide interfaces to triage and record issue analysis between multiple developers. Disclaimer: I do not sell or develop static analysis tools, but consider them an integral part of our secure development methodologies.

@_date: 2014-12-01 10:54:49
@_author: Bowness, Piers 
@_subject: [Cryptography] Toxic Combination 
Although not the best solution, this is commonly mitigated by the use of a
separate screens for user name and password entry. The secondary (SSL-protected)
password screen contains a user-selected image and phrase. If either is incorrect
or missing, the user is supposed to decline to enter their password. The assumption
is that capturing the image and phrase would be difficult for a malicious party to
This is used in addition to being able to verify the bank's PKI and trusted CA. -Piers Bowness

@_date: 2014-03-04 11:32:59
@_author: Bowness, Piers 
@_subject: [Cryptography] The GOTO Squirrel! [was GOTO Considered Harmful] 
Can we return to a subjects that relate to cryptography instead of a pointless argument on C coding styles?
Thanks, -Piers
