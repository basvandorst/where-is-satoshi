
@_date: 2005-10-17 03:10:48
@_author: Bodo Moeller 
@_subject: ECC patents? 
US patent 6,141,420 (Vanstone - Mullin - Agnew) was filed on
January 29, 1997, but
    This is a continuation of PCT/CA95/00452, filed on Jul. 31, 1995,
    which is a continuation-in-part of Ser. No. 08/282,263, filed on
    Jul. 29, 1994, now abandoned.
so possibly the July 1994 filing date is the one that counts.  By the
US one-year grace period for filing patents after publication, this
means that relevant publications before July 1993 can serve as prior
art to invalidate the patent claim.
The idea that you can do ECDH with x-coordinates only already appears
in one of the two original papers first suggesting elliptic curve
cryptosystems (Victor Miller, CRYPTO '85).  The idea to use one bit to
compress a specific y-coordinate is newer -- it appears in Harper,
Menezes, Vanstone, "Public-Key Cryptosystems with Very Small Key
Lengths", EUROCRYPT '92 (LNCS 658).  The technique for the GF(p) case
is described here.  The printed proceedings for this conference (held
in May 1992) were published by Springer-Verlag in February 1993, so
this case is quite clear.
For the GF(2^m) case, however, I am not aware of prior art.  Hence,
point compression for binary curves is not available in standard
compilations of OpenSSL.

@_date: 2007-12-17 12:48:27
@_author: Bodo Moeller 
@_subject: More on in-memory zeroisation 
Actually this problem was discussed five years ago (October 2002) on
the vuln-dev mailing list:
        If the problem also was discussed here on the cryptography list a year
or two ago, I am afraid that my memory of this either has been zeroized,
or has been detected not to serve any purpose.

@_date: 2008-01-22 21:50:24
@_author: Bodo Moeller 
@_subject: SSL/TLS and port 587 
You don't take into account the many users these days who use wireless
Internet access from their laptop computers, typically essentially
broadcasting all network data to whoever is sufficiently close and
sufficiently nosy.  Of course using SSL/TLS for e-mail security does
not *solve* the problem of e-mail eavesdropping (unless special care
is taken within a closed group of users), but it certainly plays an
important role in countering eavesdropping in some relevant scenarios.

@_date: 2008-05-23 11:50:16
@_author: Bodo Moeller 
@_subject: The perils of security tools 
I've used this idea before, although in the form of using the private
key as part of the PRNG seed -- which isn't of much use if the PRNG
ignores its seeding as in this case.  However, even the form
    k = hash (x, rng())
isn't good enough if the PRNG is sufficiently broken.  The Debian code
generated an output that was not merely predictable, but also prone to
repetition if you run a binary multiple times.  With typically just
2^15 different byte streams from the PRNG, by the birthday paradox
you'd have to expect to have been reusing some k after around 2^8
iterations or so.  So your DSA key would still be at risk!
You could also make k message-dependant -- i.e., feed both x and k
into the hash function:
    k = hash (x, rng(), m)
This avoids that problem, and is likely to remain unbreakable even if
rng() returns just some constant.  However, then you lose one
advantage of DSA, namely being able to do most of the computation in
advance, before you've even seen the message to be signed: If you've
obtained k and done the DSA exponentiation beforehand, you can create
signatures almost instantaneously; but this won't work if k depends on
the message.

@_date: 2009-01-19 10:45:55
@_author: Bodo Moeller 
@_subject: MD5 considered harmful today, SHA-1 considered harmful tomorrow 
The RFC does exit (TLS 1.2 in RFC 5246 from August 2008 makes SHA-256
mandatory), so you can send a SHA-256 certificate to clients that
indicate they support TLS 1.2 or later.  You'd still need some other
certificate for interoperability with clients that don't support
SHA-256, of course, and you'd be sending that one to clients that do
support SHA-256 but not TLS 1.2.  (So you'd fall back to SHA-1, which
is not really a problem when CAs make sure to use the hash algorithm
in a way that doesn't rely on hash collisions being hard to find,
which probably is a good idea for *any* hash algorithm.)
