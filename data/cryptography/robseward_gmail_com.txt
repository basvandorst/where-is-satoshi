
@_date: 2014-02-18 13:36:50
@_author: Rob Seward 
@_subject: [Cryptography] Improving Random Seeds in Ubuntu 14.04 LTS Cloud 
There's a new feature in Ubuntu that enables PRNG seeding from an entropy
server for new cloud instances:
Q: And what is Ubuntu's solution?

@_date: 2015-07-22 22:50:03
@_author: Rob Seward 
@_subject: [Cryptography] Whitening Algorithm 
Hi,
Iâm trying to whiten a random noise source (a reverse biased transistor)
with a low-powered microprocessor. I figured out a technique that seems to
work well, and I want to know if there is anything insecure or subpar about
(Earlier, I had heard that XORing a random stream with alternating 0s and
1s could remove bias. However, this strikes me as very insecure, because an
attacker could reverse the mask by XORing the mixed stream with the same 01
mask. Also, I had used the Von Neumann algorithm
but this slows output significantly.)
The algorithm mixes new bytes derived from the noise source with previous
ones in an overlapping manner. Below is the source code, and a link to an
illustration of the process.
Iâve done some testing, and it appears to transform data that shows as much
as 5% bias to ~0% while passing ent chi-square. Some less rigorous testing
with NIST also had positive results.
Hereâs an illustration of what the algorithm is doing:
void loop(){
  currentByte = readByteFromSource()
    mixedByte1 = currentByte ^ previousByte;
  mixedByte2 = mixedByte1 ^ previousMixedByte1;
  mixedByte3 = mixedByte2 ^ previousMixedByte2;
  mixedByte4 = mixedByte3 ^ previousMixedByte3;
  outByte = mixedByte4 ^ previousMixedByte4;
  Serial.write(outByte);
  previousByte = currentByte;
  previousMixedByte1 = mixedByte1;
  previousMixedByte2 = mixedByte2;
  previousMixedByte3 = mixedByte3;
  previousMixedByte4 = mixedByte4;

@_date: 2015-07-26 13:53:30
@_author: Rob Seward 
@_subject: [Cryptography] Whitening Algorithm 
Wow, thereâs so much useful feedback here. Thank you, everyone!
Iâd like to respond with the following: 1) Some background on the project.
2) A reiteration of what Iâve gleaned from the conversation. 3) Next steps.
1) Background:
Iâm building an Arduino shield mainly for educational purposes. Iâm trying
to keep it as simple as possible so that its internal workings can be
easily understood. While Iâm not creating something for serious
cryptographic use, the project is less compelling if it cannot create
cryptographic-quality output.
2) What Iâve learned:
2a) My algorithm isnât doing what I think itâs doing.
I algebraically expanded the steps of the algorithm and saw that a lot of
the XOR operations were canceling each other out, confirming in my own mind
what a lot of others caught on to quickly here.
Bill showed that the algorithm can be reversed by guessing bytes that are
hidden, which can be used to decrypt the whole stream.
2b) One solution is to encrypt or hash the output
This will result in a decrease in throughput and add complexity to the
project. Options include AES-CBC-MAC, Cha-cha, Blake, etc.
2c) Another option is to seed a CSPRNG, generate a pseudo random stream,
and if I like, mix it with the raw stream from the diode. This would keep
the throughput up, but add complexity.
2d) Avalanche noise from transistors is subject to failure.
Correct me if Iâm wrong, but it looks like without a health check, both
approaches (2b and 2c) will produce random output even if the transistor
fails and outputs all 0s. One thing I liked about my (flawed) algorithm is
that it would pass statistical tests if the noise source was healthy, and
produce poor, detectable results if the noise source failed.
With the above architectures, it seems some kind of internal health check
would be needed. Running the stream through a Von Neumann filter might
achieve this. Would a simple monobit test be a good (read: cheap) litmus
test for the noise sourceâs health, or is something more sophisticated
needed? Bill mentioned doing health checks on a host machine. Would this
involve switching modes on the device? That is, stream unwhitened noise
periodically to the host to check for health, and then switch back to
encrypted output?
Iâve diagrammed two approaches  here to
help me understand.
3) Next Steps
Rhys Weatherly has implemented a lot of these cryptographic algorithms for
Arduino  and measured
their performance. Iâm going to try to implement one of the above
architectures. Hopefully I can find something that the Arduino can handle
that can be abstracted to such a degree that the code is easy to read.
Thanks again everyone!
