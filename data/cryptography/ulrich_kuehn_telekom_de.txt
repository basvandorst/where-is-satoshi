
@_date: 2005-08-02 08:40:24
@_author: Kuehn, Ulrich 
@_subject: AW: Possibly new result on truncating hashes 
Hmm, wouldn't you expect a lot of partial collisions among all those 2^96 collision pairs? That is, after
2^80 runs of the algorithm you would obtain your first partial collision in collision pairs, don't you?
For 2^96 that's roughly 2^32 such pairs of pairs. Those might help you to speed up your search.
Am I missing something here?

@_date: 2005-12-07 14:23:15
@_author: Kuehn, Ulrich 
@_subject: AW: [Clips] Banks Seek Better Online-Security Tools 
In 2000 someone here in Germany already demonstrated how to attack smart card based HBCI transactions. Those transactions are authorized by an RSA signature done by the card. The attack demonstration used a trojan (I think it was something like back orifice) to remote control the victim's PC with the attached smart card reader, so that the PIN entered on the PC key board(!) could be sniffed and subsequently the PC including reader and smart card be used as a sort of remote signature generation device, authorizing any transaction of the attacker's choice. So under some circumstances even signature-based authorization does not work as advertised.
The attack relyed on the card reader not having a separate keyboard for PIN entry. Interestingly, I wonder what would happen if a reader with display and keyboard is used in an online attack, i.e. the adversary sneaks in a fraudulent transaction when the hash for the signature is computed. I do not know from the top of my head what is supposed to be displayed in the reader's display, so I do not know what impact such an attempt would have. Any suggestions?

@_date: 2005-10-31 16:14:26
@_author: Kuehn, Ulrich 
@_subject: AW: [smb@cs.columbia.edu: Skype security evaluation] 
There are results available on this issue: First, a paper by Boneh, Joux, and Nguyen "Why Textbook ElGamal and RSA Encryption are Insecure", showing that you can essentially half the number of bits in the message, i.e. in this case the symmetric key transmitted. Second, it turns out that the tricky part is the implementation of the decryption side, where the straight-forward way -- ignoring the padding with 0s "They are zeroes, aren't they?" -- gives you a system that might be attacked in a chosen plaintext scenario very efficiently, obtaining the symmetric key. See my paper "Side-Channel Attacks on Textbook RSA and ElGamal Encryption" at PKC2003 for Hope this answers your question.

@_date: 2006-02-06 09:33:20
@_author: Kuehn, Ulrich 
@_subject: AW: methods of filling encrypted disks 
[...] What about using /dev/zero to fill the drive? Assuming that you configure dm-crypt to use a secure cipher and a reasonably good mode of operation, of course. Maybe use a key different from that you will use finally for the device.
However, make sure that you do that before mkfs, otherwise all the
non-user-writeable parts of the device (inode tables etc) will not
be filled.
Are there any problems with this? I would assume that when the crypto is good enough for my data, it should also hide all-zeroes,
shouldn't it?

@_date: 2006-05-05 09:06:19
@_author: Kuehn, Ulrich 
@_subject: Linux RNG paper 
That sounds like they are applying sha256 to the passphrase, and not for adding redundancy to the data. The big problem with disk encryption is to achieve nondeterministic encryption and authenticated encryption.
Nondeterminism requires a new IV each time you encrypt a sector (I am talking here of sectors, to avoid confusion with blocks of a block cipher) for disk storage. The reason for nondeterminism is that otherwise at least common prefixes of the old and new contents show up in the ciphertext. Authenticated encryption basically prevents tampering with ciphertext going unnoticed. However, some while ago I read a paper somewhere pointing out that the lower block layer at least in linux is not capable of dealing with data errors due to authentication failure. If interest is, I could try to dig out the reference.
Nevertheless, if you want to add extra IVs (not determined deterministically from the block number) and authentication tag, you could store them in extra sectors which do not show up in the plaintext-device. Caching should be not too difficult. However, if the authentication tags / IVs cannot be read anymore due to an oops-up in the code, disk failure etc. you might run into serious problems, as now multiple sectors are affected.
Maybe there are other solutions?

@_date: 2006-05-17 09:54:29
@_author: Kuehn, Ulrich 
@_subject: the meaning of linearity, was Re: picking a hash function to  
I am not sure this will add to the security of the whole thing. My reasoning behind that is:
The combining function needs to be invertible (we want to recover the plaintext, don't we?), so we have an 8-bit block cipher with an 8-bit key (supplied by the key stream generator). Given known plaintext and corresponding ciphertext, there should not be too many keys that map the plaintext to the ciphertext. I don't have the probability at hand how many such 'collisions' you would expect from 256 random permutations, but intuitively I would not expect too many. However, I could be wrong here and would like to be corrected in this case.

@_date: 2006-11-09 10:44:31
@_author: Kuehn, Ulrich 
@_subject: Why the exponent 3 error happened: 
Unfortunately, this code _is_ used! It took me quite a while to understand under what circumstances, but here is the result. The problem is fixed as of version 1.5.0.8 (out now). Interestingly, the mozilla people fixed it by themselves in the 2.0 version (and any public beta I could find), but for the 1.5 version it took my bug report...
So here is how the code is used and some hints (I am reluctant to give out the details right now, given that there are still many vulnerable systems out there. However, I am sure you can easily work out the details):
Whenever a SSL or TLS server send a ServerKeyExchange message, the key contained in there is signed with a fresh nonce. This signature is checked using RSA_CheckSign(). Faking a signature for a key with a small exponent like 3 is easy. This can be used to break the SSL/TLS authentication.
Better upgrade asap...

@_date: 2006-10-09 10:34:03
@_author: Kuehn, Ulrich 
@_subject: TPM & disk crypto 
However, this is the big problem with the TPM according to the TCG spec. While you can remotely verify that the system came up according to what you installed there, you have no means to force it to either come up the way you want, or to be in a clear error state. That is the huge difference between the verifiable booting the TPM provides and secure booting, which would run only predetermined software.
I assume that the TCG chose not to implement the latter due to fear of public bashing...

@_date: 2006-10-10 18:28:46
@_author: Kuehn, Ulrich 
@_subject: TPM & disk crypto 
Who is "we"? In the case of my own system I payed for (so speaking for myself) I would like to have such a mechanism to have the system prove to me before login that it is not tampered with. The TCG approach does not provide this. Oh, and predetermined means that the machine admin can declare to which known state the system is going to boot. Here the TCG approach would also be helpful as the remote attestation against a central server (or a number of them) can help. And for the RIAA guys, they have no business on the machine I did pay for (!), as long as I do not infringe their copyright. Assumed innocent until proven guilty! On the other hand, there has been an infamous record company that miserably failed  to ensure their components on consumers' computers are _not_ a security risk.

@_date: 2006-10-13 16:19:55
@_author: Kuehn, Ulrich 
@_subject: TPM & disk crypto 
Well, reliably obtaining the end of a hash chain would do, but it would be very inconvenient to compare that manually (visually) to a hash written on a piece of paper in my wallet. That is not user-friendly. However, if the system provided a possibility to reliably stop the boot process when something is changed, that would do.
With reliably stopping the boot process I mean the following: Given that stage i of the process is running, it takes the hash of the next stage, compares that to an expected value. If they match, the current stage extends the TPM register (when also running the TCG stuff), and executes the next stage. If the computed and expected hashes do not match, the machine goes into a predetermined halt state. Predetermined means that the system administrator (on behalf of the system owner) can determine the expected hash value. I hope this makes it clear what I meant in the text quoted above. To implement this the TCG-preBIOS would need to implement this halt state, possibly along with some other additional features like where to store the expected hashes etc.

@_date: 2006-09-13 12:41:12
@_author: Kuehn, Ulrich 
@_subject: IGE mode is broken (Re: IGE mode in OpenSSL) 
Do I understand correctly? You do want that nobody is able to authenticate a message, however, it shall not be intelligible if manipulated with? Or do you want that the authentication test fails if the message has been tampered with?
I you want authentication, then authenticate. Use something with known security properties. So instead of running over the plaintext twice like with forward/backward IGE, try something like EAX, which is essentially counter mode with CBC-MAC for explicit authentication. Comes with proofs of security.
But then, maybe I did not understand your problem (see above).

@_date: 2006-09-13 14:22:58
@_author: Kuehn, Ulrich 
@_subject: IGE mode is broken (Re: IGE mode in OpenSSL) 
Looks interesting! Have you looked at Ron Rivest's Chaffing and Winnowing?

@_date: 2006-09-18 12:17:37
@_author: Kuehn, Ulrich 
@_subject: Why the exponent 3 error happened: 
I noticed the exact same code being present in the mozilla 1.7.13 source ... I wonder what the correct consequence would be? Have us crypto people proof-read all relevant source code? Better educate developers?
Interestingly the attacker's playground between the 0, 1, 0 and the hash gets bigger with larger key sizes, so I wonder if attacks get easier for longer keys...

@_date: 2006-09-20 15:10:05
@_author: Kuehn, Ulrich 
@_subject: [cryptography] Re: Why the exponent 3 error happened: 
I tried to parse and verify this certificate using openssl's asn1parse command. However, I get an error:
Error in encoding
7469:error:0D07207B:asn1 encoding routines:ASN1_get_object:header too long:asn1_lib.c:150:
I am using openssl version 0.9.8c as of Sep 05, 2006 (Linux/Debian system).
Any ideas what I am doing wrong?

@_date: 2006-09-21 09:55:08
@_author: Kuehn, Ulrich 
@_subject: Exponent 3 damage spreads... 
Actually, this part is about _encryption_, we are talking here about signature padding. But the PKCS spec talks about building up the complete padded signature input at the verifier, and then comparing it. However, there is a note saying that alternatively one could parse the padding without saying how this would be done. The reason to use such a thing is given as saving intermediate memory. Oh well!
So in fact what a lot of implementors do, parsing the padding, is not specified in sufficient detail to get it right. I would consider this buggy implementation resulting from buggy specification.

@_date: 2006-09-21 11:55:01
@_author: Kuehn, Ulrich 
@_subject: Exponent 3 damage spreads... 
Peter, It might have helped if you indicated that the citation was from the PKCS standard version 1.5 (?).
Interestingly, I find there (version 1.5) also
Here, any trailing garbage would be included in data D. But does an ASN.1 value allow such a thing? I am asking this independently of our discussion here.
Anyway, I think we agree on the point that the spec (even version 2.1) is in some point unprecise which should be considered a bug, as it can lead to implementation flaws. And yes, given what we know, e=3 is a good candidate for elimination :)

@_date: 2006-09-27 11:58:49
@_author: Kuehn, Ulrich 
@_subject: Exponent 3 damage spreads... 
While the patch for Firefox obviously fixed the bugs in security/nss/lib/cryptohi/,
There is another pkcs check in security/nss/lib/softtoken/rsawrapr.c, see function
RSA_CheckSign() and RSA_CheckSignRecover(). Does anybody know what these functions are used for?
I tried to find that out, but did not get very far... (Hal Finney also noted these functions some days ago).
It seems to be another creative bug:
    /*
     * check the padding that was used
     */
    if (buffer[0] != 0 || buffer[1] != 1)     	goto loser;
    for (i = 2; i < modulus_len - hash_len - 1; i++) {
    }
    /*
     * make sure we get the same results
     */
    if (PORT_Memcmp(buffer + modulus_len - hash_len, hash, hash_len) != 0)
So it would accept a padding ( 00 || 01 || 00 || garbage || hash ), which is not exactly what pkcs says :)
The same loop is used in RSA_CheckSignRecover(), but I did not succeed in finding out what it is exactly used for and if that is a safe application of the rather wrong code.
