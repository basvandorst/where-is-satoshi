
@_date: 2019-08-04 01:35:48
@_author: Daniel Hong 
@_subject: [Cryptography] Software proposal for verifiable stateless 
We rely on the fundamental fact that for a generalized parameter a, b and function f(x), g(x), if a=b and f(x)=g(x), statements f(a)=g(b) and f(b)=g(a) will be both true when honestly computed.
Because all functions are cryptographically tied together and signed, and they do not change (unless the developer explicitly updates it), it is relatively easy to maintain verify the integrity of a bare codex (which holds all the function bytecode).
To verify the parameters and return values (state chain blocks), the same computation task is simply ran on a small, randomized portion of the computation pool. Because an AST and an empty callstack graph is given with the bare codex, when the resulting callstack graph's hashed state root does not match for a particular execution session, we can say that at least one of the devices are faulty.
In such a case, we can either: (i) trust the majority, or (ii) run a recursive tree search on the resulting callstack graph itself. In the case of (ii), because the call-and-return relationships between functions are already given, it would be easy to detect the faulty device and remove its key from the keychain - as all state chain blocks should be signed by a unique device key.
This approach does not guarantee the level of state integrity and liveness as those of a blockchain, but enough for performance-demanding commercial level applications. Also, there are lots of blockchains out there that are already good at those - so periodically submitting state proofs in a batch to a blockchain with a Smart Contract should also guarantee additional state integrity.
Daniel Hong
shhong at unifiedh.com

@_date: 2019-07-27 10:07:08
@_author: Daniel Hong 
@_subject: [Cryptography] Software proposal for verifiable stateless computing 
I am developing a verifiable stateless environment builder solution that may be able to execute application code in a trust-less fashion, with little to no performance penalty.
A brief summary of the proposal:
 - No concept of "world state": very BitTorrent-like, just dynamic instead of sharing static data
 - Uses a pre-defined set of stateless bytecode modules tied together. This represents the call-and-return relationships between modules, that may be used for code integrity verification. They can run in parallel on different devices as long as their parent execution branch is finalized.
 - Records all passing parameters and committed state data to the corresponding module & ties them in the form of a chain. This is like a blockchain (Bitcoin, Ethereum etc), but this "state chain" may be flushed as long as all previous parameters and states can be verified in a public way (e.g. using an external blockchain to periodically submit state proofs).
 - Run a recursive tree search in case of a parameter and/or state mismatch. Re-execute every leaf module under an affected (malicious) state record.
 - Device specific public keys sign corresponding state chain blocks. This is used to encourage honest work & penalize malicious devices.
Unlike a blockchain, state chains are not intended to be publicly verifiable. This approach decreases the computation work required to "finalize" every state transition on a linear blockchain. We can always rely on an external chain when we need it, such as proving the identity of an application or using token contracts.
Currently working on a very simple proof-of-concept to demonstrate the whole idea (source code will be available once it's working).
The paper for this proposal is available at:  I will be revising and updating the paper as development progresses (this is a very early working draft and not finalized yet).
Any feedback will be greatly appreciated. Thanks.
Daniel Hong
shhong at unifiedh.com
