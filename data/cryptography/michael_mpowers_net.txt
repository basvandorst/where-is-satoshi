
@_date: 2014-03-15 13:36:15
@_author: Michael Powers 
@_subject: [Cryptography] Encryption in Trsst 
We're starting some early field testing of the Trsst Project, and while we're still in need of a security review and models and documentation to support it, I wanted to get some feedback on the encryption piece.
Background: Trsst is a convention for using Atom and the Atom Publishing Protocol with XML-Signatures and XML-Encryption as a foundation for building interoperable microblogging services (think: open replacements for Twitter/Facebook) that support decentralized account creation (just generate a keypair), and signed and optionally encrypted public entries.  FAQ is here:  For a private message, we generate a random 256-bit key and encrypt with AES.  Then for each recipient, we use a hash of the shared ECDH secret and the message-id to encrypt the key and append it to the message.  All public keys are static, and all public and private messages are viewable by anyone.  Specific questions:
(1) An account is permanently associated with one EC keypair for signing, and another optional keypair for encryption which can changed but probably not often if ever.  How much of a problem would it be to use the same permanent keypair for both signing and encryption?  Moving/copying your content to a new account is the recourse for a lost or compromised key, and isn't terribly costly.
(2) Private messages are not always addressed outside the encryption envelope.  If unaddressed, you have to try each of the keys on a message to see if it is intended for you, which is why we hash the key.  Could the pattern of first half of the encrypted data always being a random key and the second half always being a hash of that key be exploited?  (3) To ensure you can decrypt your own message, you encode one of the keys for yourself.  Might your private key be compromised when used with your own public key moreso than someone else's public key?
The relevant implementation in Java using Bouncy Castle is below.  The rest of the source is at: Many thanks for pointing out issues and errors, glaring or otherwise.
  - Michael
 * Takes the specified 32 bytes, appends its sha-256 digest, and xor
 * encrypts those 64 bytes with the sha-512 hash of the ECDH shared secret
 * and the entry id.
 *  *  input 32 byte key to be encrypted
 *  publicKey
 *  privateKey
 *  *  SecurityException if unexpected error
 */
public static byte[] encryptKeyWithECDH(byte[] input, long entryId,
 * Takes the specified 64 byte encoded input and xor decrypts it with the
 * sha-512 hash of the ECDH shared secret and the entry id. Then checks to
 * see if the last 32 bytes is the sha-256 hash of the first 32 bytes. If
 * so, returns the first 32 bytes of the decrypted content. Otherwise, then
 * this key was not intended for us, and returns null.
 *  *  input 64 byte input to be decrypted
 *  publicKey
 *  privateKey
 *  the original 32 byte input, or null if unintended recipient.
 *  SecurityException if unexpected error
 */
public static byte[] decryptKeyWithECDH(byte[] input, long entryId,
public static byte[] generateAESKey() {
public static byte[] encryptAES(byte[] input, byte[] key)
public static byte[] decryptAES(byte[] input, byte[] key)
private static byte[] _cryptBytesAES(byte[] input, byte[] key,
private static byte[] process(byte[] input,

@_date: 2014-03-16 17:33:58
@_author: Michael Powers 
@_subject: [Cryptography] How to build trust in crypto (was:recommending 
is what we're trying to achieve with the Trsst Project. If I could take this moment to bump my request from yesterday (Subject "Encryption in Trsst") for an initial review of at least the encryption part I posted, I'd really appreciate any course correction or validation.  Much obliged.
