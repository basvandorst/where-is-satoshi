
@_date: 2015-05-06 10:15:02
@_author: Francois BERENGER 
@_subject: [Cryptography] Is there a good algorithm providing both compression 
Dear list,
While programming an open source distributed system, I discovered
it could be interesting for the system to use a well established algorithm
that can do these two things at the same time (for performance reasons).
I was thinking about something along those lines:
compression(clear_text) = (compression_dictionary, compressed_text)
then, instead of encrypting the whole resulting pair (to save some time),
we would send over the wire
(symmetric_encrypt(compression_dictionary, secret_key), compressed_text)
Of course, I would like that the compressed_text cannot be uncompressed
by someone who doesn't have access to the compression dictionary.
I would be interested in scientific articles or any interesting pointer.
Thanks a lot,

@_date: 2015-05-09 13:58:34
@_author: Francois BERENGER 
@_subject: [Cryptography] Is there a good algorithm providing both 
For performance reasons, I think I will use a block cypher in counter mode.
I need an encryption mode that can parallelize.

@_date: 2015-05-09 14:01:54
@_author: Francois BERENGER 
@_subject: [Cryptography] Is there a good algorithm providing both 
If such method exists, I can measure how fast it is compared
to compressing then encrypting the whole output of compression.
I guess it will matter on large data, which my system is supposed to handle

@_date: 2015-05-10 21:10:44
@_author: Francois BERENGER 
@_subject: [Cryptography] Is there a good algorithm providing both 
Thanks for all the answers and pointers.
I would like to add some further remarks to my initial question, based on
the feedback I got.
I - Design priorities of the system, by decreasing order of importance:
1) simplicity (the system is minimalist)
2) speed (the system should be high performance, despite being data
3) security (if a user choose to encrypt his data, we won't leak them out)
Interesting article I could find before asking to the list:
"On Breaking a Huffman Code"
So, I was wondering if people did further work in the opposite direction:
design a generic compressor that makes it extremely hard to recover
the data if you don't have access to the Huffman tree (for example).
II - Compatibility between executables of the system:
there won't be bits in message headers to change the protocol.
I plan to enforce at compile time that the executables of the system
speak a compatible protocol.
The protocol will be:
- either you speak plain text
- either you speak compressed text
  but because of the speed constraint I will support some specific
compression algorithms
  like LZ4 or snappy, not bzip2 or xz
- optionally you can sign your message before sending it
- optionally you can encrypt your message before sending it (in that order)
I plan the signing key and the encryption key to be two different keys
(they are secrets
shared by all members of the distributed system).
If I don't find an established algorithm providing both compression and
at high speed on general data (there is no assumption on what users will
then I won't provide one in the system.
I will encrypt the full output of compression (if compression is enabled).
I don't care so much about traffic analyzis or message lengths being
I just want the user data to be safe, if he chose so.
I won't send dummy traffic, for example, because of the high performance
I expect the users will be computational scientists.
Before publication, it is nice to not disclose your data, so I should
the functionality of encryption.
