
@_date: 2004-04-30 13:38:40
@_author: Christian Paquin 
@_subject: Credentica (Re: Is there a Brands certificate reference implementation?) 
Hello Steve,
 > Fwd: cryptography at metzdowd.com, e$
I am one of the lead developers of Credentica, which is Stefan Brands'
latest venture after his amicable departure from ZKS quite some time
ago. We are exclusively focused on the development of identity and
access management technology based on Stefan's Digital Credential work.
Following our closing of investment from Nokia earlier this year, we
started with the design and implementation of a Software Development
Toolkit for Digital Credentials. We are exploring the idea of releasing
parts of it under an open-source license, and intend to post updates
here from time to time on our progress. More information will be
available on our upcoming Web site, which should be up soon.
Meanwhile, if you are interested in getting a glimpse of what we are doing, check out Stefan's keynote materials at a recent NIST PKI workshop, which you can find here: Kind regards,
Christian Paquin
Cryptographic Developer

@_date: 2005-07-13 14:19:30
@_author: Christian Paquin 
@_subject: Attack on Brands blind signature 
The claim that Brands' signature scheme is linkable is incorrect (I haven't checked the other claims in the paper). The attack checks that a^{c'c^{-1}}.g^{s'-c'c^{-1}s} = a' for a signature {m', z', c', s'} and a view {m, r, z, a, b, c, s}.
The above equation reduces to
  = g^s' a^{c'c^{-1}} g^{-c'c^{-1}s}
  = g^s' (a g^{-s})^{c'c^{-1}}
  = g^s' (g^s y^{-c} g^-s)^{c'c^{-1}}
  = g^s' y^{-c'}
which is the normal signature validation term. If fact, you can see that the attack will match _any_ signature with _any_ view. Therefore, it provides no information to the attacker.
  - Christian
Christian Paquin
Security Architect

@_date: 2006-04-05 13:06:18
@_author: Christian Paquin 
@_subject: Unforgeable Blinded Credentials 
In Brands' system, multiple uses of a n-show credential are not linkable to the issuing (i.e. they are untraceable), but they are indeed linkable if presented to the same party: the verifier will recognize the credential when re-used. This is useful for limited pseudonymous access   to accounts or resources. If you want showing unlinkability, better get n one-show credentials (simpler and more efficient).
The protection you get, as pointed out by Adam, is that when a n-show credential is presented n+1 times (to the same or different verifiers, as long as the audit data is collected centrally) all attributes drop out (*). In cases where you had to authenticate to get those credentials (paid by credit card to get e-coins, had a "gold" account to get discount coupons, etc.), the issuer usually embeds an invisible and always hidden identifier into the credential so it can recognize you and take application-specific measures against the fraud (revoke your account (**), charge money on your credit card, etc.)
  - Christian
(*) For those who wonder how this works, imagine the credential private key and attributes being the (secret) slope of a line. At every showing, the verifier challenges the user to disclose one (random) point on the line. For a one-use credential, re-using it reveals two points which is all you need to compute the slope. If it's only used once, it's infeasible for the verifier (even in collusion with the issuer) to figure out on which line the point belongs to (and therefore break the untraceability property).
(**) Note that there is also a nice revocation technique where an issuer publishes a blacklist containing the revoked user's "secret" identifiers. When a multi-use fraud is detected and that the malicious user's identity drops out, it can be added to the blacklist. Users can prove that the identifier in their credential is not equal to any blacklisted values without revealing it. This can be used, e.g., to effectively revoked a bunch of anonymous and unlinkable e-coins (containing the same secret id) if the owner double-spend any one of them.

@_date: 2007-02-27 11:22:22
@_author: Christian Paquin 
@_subject: U-Prove features (Re: announce: credlib library with brands and chaum 
It may be difficult to understand what's implemented in U-Prove by
reading the press release and data sheet, so here it is in more
technical terms.
U-Prove implements what we call ID Tokens: a credential with three
attributes. The goal of these credentials is to act, as the name
implies, as identity tokens.
ID Tokens have three fields. The first field contains public token
attributes, which are always disclosed (e.g., an expiry date, token
usage info, semantics of the other fields, etc.). The second field can
contain any data and can be selectively disclosed; not disclosing the
field gives _no_ information about its value to a verifier. The third
field contains data committed by the user at issuance time but unseen by
the issuer (e.g., contact information, an encryption key).
ID Tokens are untraceable and unlinkable among themselves. Care must of
course be taken when encoding data into them. Traceability of the tokens
depends only on the encoded data. Reuse of a same token allows you to
build a pseudonymous relation with a verifier (like a random Presentation of an ID Token results in a user-authenticated transcript
suitable for audit logs. Furthermore, verifiers can censor the
information relative to the disclosure of the selectively-disclosable
token field; auditors do not learn if the user disclosed the second
field and if so, its value.
Each ID Token specifies a unique identifier (hash of the token contents
+ other protocol data). This identifier is not under the control of any
party and is therefore suitable to index user accounts (a rogue issuer
could not generate an ID Token with the same identifier as another token
issued by another issuer).
ID Tokens can be revoked individually by their identifiers (? la X.509).
The SDK offers a more powerful revocation technique. A user can prove
that the value of the second field is not on a blacklist without
disclosing the field's value. By encoding a user identifier in this field, an issuer could revoke all of a user's unlinkable tokens.
ID Tokens can be issued as one-use. Reuse of such tokens allows an
auditor to compute the token's private key including the attributes. If
identifying data (e.g. an account number) is encoded in the
never-disclosed field, the auditor learning this value can trace the
malicious user. This value can then be blacklisted to prevent the user
from using any of her tokens.
ID Tokens may be protected by a "device" (a smart card, a Trusted
Computing chip, a remote server, etc.) Devices hold part of the token's
private key and must collaborate with the user in the presentation
protocol in order for the token to be usable. The secret in the device
can be shared by an unlimited number of tokens. The device's computation
is very efficient (no modexp at presentation time). Useful to protect the user against local malware or to enforce the issuer's security policies.
As you mentioned, Brands's credential system has a lot of features. We
did not implement everything for one good reason. This stuff is still
quite esoteric, even for the crypto community, and we wanted the SDK to
be identity-centric, with clear use cases. The SDK abstracts all the
crypto so it should be simple for security developers to use it.
Some use cases documented in the SDK include:
  * strong user authentication (privacy-friendly PKI)
  * digital signatures
  * protecting attribute assertions (e.g., I'm over 18, I live in
    Quebec). Could be integrated in frameworks such as SAML, WS-Trust,
    Liberty ID-WSF)
  * one-use e-tickets, these may contain attributes (similar to e-coins)
  - Christian
Christian Paquin
Chief Security Engineer @ Credentica
1010 Sherbrooke West Suite 1800
Montreal, QC, Canada H3A 2R7
Tel: +1 (514) 866.6000

@_date: 2007-11-21 15:23:53
@_author: Christian Paquin 
@_subject: fyi: Adi Shamir's microprocessor bug attack 
Does somebody know if, in case of a discrete log scheme, this would result in an attack using one chosen message (like for RSA), or would the attack be similar to the one described by Boneh, DeMillo and Lipton for Schnorr's identification protocol and require O(n log n) executions?
  - Christian
