
@_date: 2003-02-21 14:31:52
@_author: Xunhua (Steve Wang 
@_subject: one question about RC4 
I have a question about RC4. Assume key k1 and k2 are 128 bits and let
E(k, m) denote the RC4 encryption of m by k, is there a key, k3, of RC4
satisfying that E(k2, E(k1, m)) = E(k3, m) and if yes, how can we find
such k3?

@_date: 2003-11-12 14:26:11
@_author: Steve Wang 
@_subject: Protection against offline dictionary attack on static files 
Check PKCS  -----Original Message-----
[mailto:owner-cryptography at metzdowd.com] On Behalf Of Arcane Jill
Sent: Thursday, October 23, 2003 3:21 AM
It's possible I may be reinventing the wheel here, so my apologies if that's so, but it occurs to me that there's a defence against an offline
dictionary attack on an encrypted file. Here's what I mean: Say you have
a file, and you want to keep it secret. What do you do? Obviously you either encrypt it directly, or you store it in an encrytped volume (thereby encrypting it indirectly). Problem? Maybe an attacker can somehow get hold of the encrypted file or volume ... maybe your laptop gets stolen .... maybe other people have access to your machine. In principle, you're protected by your passphrase, but if an attacker can get hold of the file, they can try an offline dictionary attack to guess
your passphrase, so unless you're very good at inventing high entropy passphrases /and remembering them without writing them down/, there may still be a risk.
Here's the defence:
To encrypt a file:
    Generate a random number R between 0 and M-1 (for some fixed M, a power of 256)
    Type in your passphrase P
    Let S = R || P (where || stands for concatenation)
    Let K = hash(S)
K is now your encryption key. R is to be thrown away.
To decrypt the same file:
    Generate a random number r between 0 and M-1
    Type in your passphrase P
    for (int i=r; ; i=(i+1)%M)
    {
        Let S = I || P
        Let K = hash(S)
        Try to decrypt using key K
    }
This places a computational burden on your PC at decrypt-time. The larger you choose M, the more CPU time it will take to figure out K. So,
you choose M such that it takes your PC about one second to find K, then
your attacker will experience the same burden - but multiplied a squillionfold (a "squillion" being the entropy of your passphrase). This
means that even if your passphrase consists of just two words from a dictionary, /and/ your attacker suspects this, it will still take him or
her over a hundred and fifty years to decrypt (assuming your attacker has a PC of equivalent power). Even if your attacker has a faster PC than you, it will still be relatively easy to pick a strong-yet-memorable passphrase, since better tech can only ease the attacker's problem, not remove it. All of a sudden, weak passphrases turn into strong ones, and strong passphrases turn into computationally infeasible ones.
Is this useful?
Has anyone come up with it before? (Someone must have ... but I don't recall seeing the technique used in applications)

@_date: 2003-10-03 13:45:26
@_author: Xunhua Wang 
@_subject: DH with shared secret 
Your scheme might work for a long random secret. However, if the shared
secret is a short one (say a password), depending on how the key
confirmation is performed, it would still be vulnerable to off-line
dictionary attacks. More related information can be found at
 Steve
-----Original Message-----
[mailto:owner-cryptography at metzdowd.com] On Behalf Of Jack Lloyd
Sent: Friday, October 03, 2003 5:14 AM
This was just something that popped into my head a while back, and I was
wondering if this works like I think it does. And who came up with it
before me, because it's was too obvious. It's just that I've never heard
something alone these lines before.
Basically, you share some secret with someone else (call it S).  Then
do a standard issue DH exchange, but instead of the shared key being
g^(xy), it's g^(xyS)
My impression is that, unless you know S, you can't do a succesfull MITM
attack on the exchange. Additionaly, AFAICT, it provides PFS, since if someone later recovers S, there's still that nasty DH exchange to deal with. Of course after S is known MITM becomes possible.
Given the recent climate around here, I'll add that I'm not planning on
using this for anything (I only use TLS, I swear! :P), I just thought it
was an semi-interesting idea.
