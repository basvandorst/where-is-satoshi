
@_date: 2013-12-17 09:55:05
@_author: Guido Witmond 
@_subject: [Cryptography] The next generation secure email solution 
You can use an untrusted CA to bootstrap. I show how it can be done at:
Regards, Guido.

@_date: 2013-12-17 21:42:51
@_author: Guido Witmond 
@_subject: [Cryptography] The next generation secure email solution 
Hi Ralf,
There is more to it than just a user agent.
Although, that user agent (and the web-site doing certificate signing)
is sufficient to create client certificates at that site if you are only
interacting with that site, for example a shopping site.
For email replacement you need to validate that there is no man in the
middle. The user agent cannot do that alone. It needs a global list of
certificates signed by each site. I call that the 'Global Registry of
Dishonesty' as it will show any attempts at a MitM.
When that is in place, user agents can verify there is no MitM after the
first roundtrip of messages. And when one endpoint detects a MitM, it
reports it at that registry for the world to know. After that the
certificates are validated. From this point on, the the end points (end
users) can bootstrap other communication channels, such as ZRTP, etc.
Regards, Guido.

@_date: 2013-12-18 11:25:30
@_author: Guido Witmond 
@_subject: [Cryptography] The next generation secure email solution 
The Registry is needed in only a few cases.
1. When you sign up for a site (and get a certificate) you submit it to
the Registry and check to see that your CN is unique. To make sure the
site is not MitMing you.
2. When you want to write *the first* encrypted message to someone else,
verify that their CN is unique. To detect if the site is MitMing them.
3. When you receive your first response to an encrypted message you've
send out, you validate your CN-uniqueness. To detect a MitM against you
by the site.
At any point, when you detect multiple certificate for the same CN, it's
a violation of the protocol. Submit it to the Registry to protect the
other side. And blog about it on reddit: The site's CA has become
dishonest. The registry contains the proof. Hence the name.
After the first round, the certificate has proven to be unique. IE: it
is authenticated to belong to 1 person: your communication partner. You
store that certificate in your address book in the agent. There is no
need to check the registry anymore.
Now you can use that certificate to bootstrap other independent
channels, for example a ZRTP connection. It can use PFS, authenticated
by the validated certificate. All without the user having to deal with
any cryptography at all. It's all done by the software.
At no point does a user have to *trust* a third party. It's all based
upon verification that the third parties are not engaging in a MitM. If
one does, it will be detected and brought out in public for every one.
There could be a step 0 in the above list:
0. Before signing up for a certificate, the agent checks the registry
for the amount of duplicate certificates for any given CN. If there are
duplicates, warn the user that the site is lax with operational
security, or active hostile, or taken over.
I envision something like Perspectives or Certificate Transparency, ie a
Merkle tree of hashes for implementing the Registry to make sure it
cannot lie about a submission. Best if it could be set up in a
distributed way.
I hope that this addresses your concerns.

@_date: 2013-12-19 11:49:21
@_author: Guido Witmond 
@_subject: [Cryptography] The next generation secure email solution 
I was thinking of the other way around. I already have the local CA and
a demo that uses it. :-)
The beauty of the eccentric protocol is that *only* the site's CA can
sign certificates for its domain. Spammers do not have the site's CA
private key. Spammers cannot create fake duplicates. So if there is a
duplicate certifcate for a certain CN that is signed by the local CA, it
is proof of 'problems' (either malicious or erroneous).
The protocol does not allow CN's to be signed by other CA's. These
certificate will be ignored, dropped.
The 'Registry of Dishonesty' forms that ground truth. It allows to
verify that a certain CN is used in only *one* certificate. When you
have that proof-of-uniqueness after the first message-roundtrip, you've
established an authenticated channel between the two of you.
This verification must be done for each *new* person/certificate you
encounter. However, people can send CN's to others, giving a certificate
a local meaning. For example, when dealing with a business I get a
reply: "You can deal with these issues with our xxx-department. Contact
them at abc
I can look up that CN at the registry, verify it's uniqueness and I
*trust* the sender that it is the correct address of their xxx-department.
Regards, Gudio.

@_date: 2013-12-22 23:34:10
@_author: Guido Witmond 
@_subject: [Cryptography] The next generation secure email solution 
In fact, the user is better of to create a different (account) name at
each site. As the site name is part of the account name (SEI) these are
already disjunct. Eg. me at gmail.com is disjunct from me at hotmail.com.
The user is free to set passwords/fingerprints/iris-scan/swipe patterns
to protect the private keys on their computer. The agent creates a new
key pair for each account at each site. Important keys can have more
protection than throwaway accounts that a site demanded just to post a
As DNS(SEC) domain names are unique and each account name is unique,
hence SEI are globally unique.
It dents the reputation of the site. However, not all is lost. Any
previously validated SEI's in the users address book stay valid. If
people have created separate channels between them, these stay valid
too. The site can die, the users' validations stay. It is encouraged
that people set up extra indenendent channels as a precaution against an
untrustworthy/hacked/coerced site. It also protects against metadata
Any message delivery via the site will get logged for life. Independent
channels can be anonymous if set up like a alt.messages.anonymous newsgroup.
The protocol automates all these parts. It can be 1 click. "Create an
account at this site".
There are several ways to get to know the SEI of someone.
1. You communicate with people on the blog site. The site acts as
introducer to strangers;
2. You receive the SEI from someone on a business card; or read it from
a printed letterhead; or read it at a newpaper-colophon.
3. You receive it from someone you trust, family, friend. You wouldn't
accept it from a stranger on the street.
No need for quantum computers. If the attacker coerces the
DNSSEC-registrar to sign a duplicate for the fake site, it will be
detected by the Registry that notices a new CA for a known site as soon
as you submit your certificate for inclusion.
This has been foreseen. The Registry validates the submissions to see if
the certificate chain ends in the DANE-specified site-CA. It drops any
certificate that does not match. Eliminating this attack.
The site operator has an incentive to choose a good registrar. And throw
out bad ones.
The endpoint opsec is the weak link. These problems are real. But they
are equally problematic for password. Any malware that goes after
private keys can go after password managers and keylogging the master
password. Any improvement in opsec for passwords is also an improvement
for private key storage. Proper sandboxing, microkernels, process
isolation are important techniques to make client certificates more
safe. We need these techniques urgently anyway, whether we deploy
passwords or certificates. If only to keep my bitcoin wallet safe.
That can be a good thing or a bad thing. Depending on your view.

@_date: 2013-12-23 22:26:21
@_author: Guido Witmond 
@_subject: [Cryptography] Passwords are dying - get over it 
If get people to deploy software on their devices, please let them use
anonymous client certificates. All the benefits of passwords, none of
the downsides.
Make sure you have a different private key for each site.
It even can help to solve the MitM problem that passwords cannot.
Regards, Guido.
PS. I call it eccentric-authentication.org.

@_date: 2013-11-04 11:14:58
@_author: Guido Witmond 
@_subject: [Cryptography] DNSSEC = completely unnecessary? 
I think these quotes are misleading. DNSSEC is designed to prevent
DNS-related attacks, reducing cache poisoning to a DoS-attack.
I guess what this quote means is that two-way authenticated sessions, ie
client and server *remember* each others public keys, don't need any
third party to recognize them at later connections. The problem is to
authenticate if you only know a domain name.
Not at all a waste. I think, it is the next best thing since sliced bread.
DNSSEC specifies the *intent* of the domain owner. A validated lookup
tells you which of the 160 CAs is the chosen one. It's the domain
owners' responsibility to run a monitoring script to detect rogue
DNS-registrars that send out wrong data, and publicly sentence those to
the internet death penalty.
If you don't trust your chosen CA, ie, it might be coerced to sign a
fake cert by an 'authority', create your own Root Key (on a smart card)
and use that for your server certificate.
The thing that is important is that the browsers must NOT look at the
'trusted' CA-list anymore!

@_date: 2013-11-04 19:10:36
@_author: Guido Witmond 
@_subject: [Cryptography] DNSSEC = completely unnecessary? 
You could try a GPG-card if the standard x509 cards from the big vendors
might not have your approval.
There is also the option of a hsm module, by some other big vendors.
Or you could use a cheap laptop from some generations ago and use it as
your root CA. Make sure you open the case and disable the wifi,
bluetooth and microphone :-)
At least with DNSSEC and DANE, we have the choice of options back to the
domain owner.
Regards, Guido.

@_date: 2013-11-04 21:17:38
@_author: Guido Witmond 
@_subject: [Cryptography] HTTP should be deprecated. 
Key management should be automated to the point that the *end user*
doesn't see it anymore.
I've got the ideas how to do it in a very backwards compatible way
on the current internet. It requires a user agent at the client and some
server side software to generate certificates.
See Now If I got some funding to make it a Firefox plug-in, it would also be
easy to install.
Regards, Guido.

@_date: 2013-11-04 21:40:21
@_author: Guido Witmond 
@_subject: [Cryptography] DNSSEC = completely unnecessary? 
Sorry for the confusion, I meant that DNSSEC + DANE specifies the
intent. Thanks for clearing it up.
Frankly, imho, DNSSEC without DANE is not worth the hassle. It's that
DNSSEC paves the way for DANE that makes it worthwhile.
Agreed. It's not easy. I hope there will be some parties that will offer
these services for a modest fee to the site-operator. My DNS-registrar
already offers managed DNSSEC. They take care of all the key-stuff. And
if they mess up, there might be others. I have the choice. See it as a
market opportunity for hosting providers.
With my eccentric-authentication protocol, I fail hard. But as the
protocol requires the user agents to remember the public key (or
fingerprint) of the site, it can survive transient errors in
DNSSEC/DANE. It makes it less brittle for the price of some storage space.
That's the big problem: How to get these browser vendors along DANE.
There is a prototype DNSSEC/DANE validator plugin for Firefox.
However, it's not in their interest. I more or less expect Google to go
into the CA business and offer to pin your site certificate into Chrome.
DANE with self generated Root-certs won't bring them revenue.
How do we get the message across that most browsers are written by
companies that want to spy on the user. And that other major one is
sponsored for 90% by an advertiser. Let's pray that Greenwald has some
nice slides :-)
Yes, that's why browsers must ignore the coerced 'trust' that this
CA-list requires.
Regards, Guido.

@_date: 2013-11-12 12:09:05
@_author: Guido Witmond 
@_subject: [Cryptography] randomness +- entropy 
My AVM Fritzbox DSL modem has IPsec VPN capabilities in it. I'm sure it
fits the requirement for a good random source.
However, it needs a Windows box to run a program to create a
configuration file. And it creates a new https certificate at each boot.
Regards, Guido.

@_date: 2013-11-12 22:37:40
@_author: Guido Witmond 
@_subject: [Cryptography] HTTP should be deprecated. 
With British Telecom promoting PHORM, that trust has eroded.
The era of ISP-operated caches is past.
With Netflix and other movie streaming sites reaching 50% traffic mark,
that's out of the league for ISP's. Both Netflix and Youtube (Google)
offer free (or cheap) caches for their contents to ISPs.
The rest of the web out there is so full of advertisements that those
operators don't want caches as it diminishes their 'tracking' abilities.
In fact, the content of the page can be cached, the advertisement
require a new connection each time. I'd say that the advertisements are
more costly (in network resources) than the content.
The problem is that the current http-infrastructure is not good at
specifying what can be cached and what not.
Examples: compare:  and
Bad example :-) both are not worth caching, but you get the point. :-)
But I agree that the unencrypted transmissions should be eradicated.
Regards, Guido.

@_date: 2013-11-24 11:29:42
@_author: Guido Witmond 
@_subject: [Cryptography] Dark Mail Alliance specs? 
Yes, there is a way. Instead of using javascript with its eternal
validation problems, use a browser plugin to do the key handling and
message signing.
Using anounymous client certificates and a GPG-keyserver model (reached
via Tor) you can create a key distrubution mechanism that solves these
issues. You also need to remember the certificates in your address book.
Don't throw away the result of your validation actions, remember them!
That's something I've also conquered. My agent module does the
encryption and decryption.
In fact, you can try it out: download the proxy[1], configure your
browser to use it and browse to http :// dating.wtmnd.nl:10443/ (the
proxy does the https to the server).
Create an acccount and send a message to guidow
When you use Tor, my server can't even learn your IP-address.
Regards, Guido Witmond
1:

@_date: 2013-11-26 10:42:20
@_author: Guido Witmond 
@_subject: [Cryptography] Explaining PK to grandma 
We have to take cryptography out of the brain-loop of Granny.
The common requirement for people:
1  Don?t think, just click.
2  Someone else must protect me.
3  For free.
On 1: Users don?t want to be bothered with anything that stands in the
way of what they want to do. It won?t work.
On 2: Users assume that their computer keeps them safe from all harm. Or
their virus scanner. Or their ISP, or faceboogle, or their government.
But at the same time, these appointed chaperones must respect the
privacy of their entrusted appointees.
On 3: Of course, users don?t want to pay for anything.
One might call it unfair of these users, however, I don?t blame them.
It?s what has been promised time after time, albeit never delivered.
It?s time we are going to deliver that: /No-Brain Security and Privacy./
Notice the first point in 'On 2', they expect their computer to protect
them. Besides, they have already paid heavily for their new computer.
Here is my take on how to make it:
1  User learns about a site, perhaps via a search engine;
2  User browses site, reads a bit on it; decides to sign up;
3  User directs the agent to request a client certificate with a user
   chosen nickname (a different nickname for each site); it sounds
   complicated but is just a single click;
4  Site signs the certificate. The certificate bears the chosen
   nickname and the sitename.
The trust decision happens in step 2. It?s a typical users? decision: ?I
like it, and want to sign up.?
The system has to keep the user secure, protect their privacy, fight
against phishers, malware, MitM, BGP-rerouting.
Now let's build it.
Regards, Guido.
 Or just use mine:

@_date: 2013-09-09 14:08:58
@_author: Guido Witmond 
@_subject: [Cryptography] Thoughts about keys 
Hi Perry,
I just came across your message [0] on retrieving the correct key for a
name. I believe that's called Squaring Zooko's Triangle.
I've come up with my ideas and protocol to address this need.
I call it eccentric-authentication. [1,2]
With Regards, Guido.
0:

@_date: 2013-09-10 11:00:24
@_author: Guido Witmond 
@_subject: [Cryptography] Thoughts about keys 
Hi Peter,
We really have different designs. I'll comment inline.
If I read it correctly, each participant has one *single identity*?
Eccentric does it the other way around, with ecca, you have one or more
different identities at *each* site. At least one. But if you want to
blog different topics under different id's, no problem. Create another
I think there are good reasons for having multiple *independent*
identities. For example, if your writings get too hot for the blog site
owner and they close one account, it doesn't affect the other accounts.
If you want, you can destroy the private key so there is nothing that
traces you to that account.
Or if you want, you can post a proof of ownership of the private key of
the account, to show that the site censured a really good post. They
closed the account but can't invalidate your key. Again, other accounts
are still unaffected.
[Taken out technical description]
As you and I have never met, I can't validate your photo, neither half
your claimed penis size. ;-)
How do I know it's not a Man in the Middle using your picture?
Regards, Guido.

@_date: 2013-09-10 21:01:49
@_author: Guido Witmond 
@_subject: [Cryptography] Thoughts about keys 
So what you have is a scheme that allows people who meet *in real life*
to exchange keys. Why can't they just exchange an email address and
shared password? Or the fingerprint of a GPG-key, it's shorter and must
match the email address. Or hand out business cards with your public key
in a qr-code.
If you meet in person, you've already eliminated all MitM attacks.
My scheme does the opposite. It allows *total strangers* to exchange
keys securely over the internet.
The scheme uses a common interest website where people write signed
messages. The site is the *introducer* of the strangers. The technical
design with DNSSEC and a Certificate Transparency service detect MitM
attacks by a hostile site. (it can't prevent it).
*One* secure message is enough to create new channels. Once you have
exchanged the key with a stranger, you can create other secure channels.
Either direct messaging, chat, voice and video. You name it.
So far, the channels are only between two people. But once introduced
via a web site, people will exchange other peoples identities between
friends, relatives, coworkers. Creating a web of connections, all
encrypted with the TLS version du jour.
The beauty: the names are readable, human friendly, easy to give out and
verify. The protocol does all the certificate validation.
Each web site that adopts this scheme works as an introducer. There is
no central point to attack. So if the feds would block one site, you
don't lose your already validated keys. You won't even lose the
connections to other people if you have already established an
independent message channel with most of them.
Regards, Guido Witmond.

@_date: 2013-09-11 19:32:04
@_author: Guido Witmond 
@_subject: [Cryptography] Introducing strangers. Was: Thoughts about keys 
How do you meet people outside your circle of friends?
How do you stay anonymous? With FOAF, you have a single identity for it
to work. I offer people many different identities. But all of them are
protected, and all communication encrypted.
That's what my protocol addresses. To introduce new people to one
another, securely. You might not know the person but you are sure that
your private message is encrypted and can only be read by that person.
Of course, as it's a stranger, you don't trust them with your secrets.
For example, to let people from this mailing list send encrypted mail to
each other, without worrying about the keys. The protocol has already
taken care of that. No fingerprint checking. No web of trust validation.
I don't just want to encrypt the bulk, I want to encrypt everything, all
the time. It makes Tor traffic much more hidden.
There is more
The local CA (one for each website) signs both the server and client
certificates. The client only identifies itself to the server after it
has recognized the server certificate. This blocks phishing attempts to
web sites (only a small TOFU risk remains). And that can be mitigated
with a proper dose of Certificate Transparency.
Kind regards, Guido Witmond,
Please see the site for more details:

@_date: 2013-09-12 00:04:14
@_author: Guido Witmond 
@_subject: [Cryptography] Squaring Zooko's triangle 
Hi Paul,
Reading your blog, you've came up with a way to encode a public key into
a much more memorable string of words. Although the user is not free to
choose the name. I go a bit furhter in that direction.
In Eccentric Authentication, the usernames (nicknames) are composed of a
domain name and an account name. Just like email addresses. The domain
name is given by the site, the account name is your choice. As long as
it is unique for the site. (There can be a foo at google, a foo at
gmail, a foo at yahoo). Just as people expect email addresses to be
unique too.
To create a full name, the user chooses a site and opens an account
there. The account name is free to choose by the user (subject to
availabilty and site rules). If the requested account name is not yet
given, the sites' local CA signs the name (and the users' public key)
into a client certificate.
You can use this certificate to log in at the site, but also to encrypt
and sign messages.
To make names Zooko-proof, you need to make sure that once a name is
given (bound to a value), it cannot be changed anymore.
For that I use a form of Certificate Registry for logging. Once you've
acquired a client certificate, you send it to the registry. It stores
the certificate keyed by it's full name. Ie, anyone can lookup the name
at the registry and retrieve your certificate.
This registry protects against man in the middle attacks. When you
encounter a signed message somewhere, you lookup the certificate in the
registry. You should expect a single answer, namely, the certificate
that matches the signature on the message.
If you receive the matching certificate, it is proof that the full name
is unique and that the public key in the certificate can be used.
If you receive a single answer with a different certificate, you know
that someone is trying a mitm between you and the other party.
You submit the one that you've discovered to the registry so it will be
there for everyone to see.
If there are multiple certificates (bearing that same full name) signed
by the same CA, it's them who became dishonest. The protocol explicitly
calls the site Dishonest.
If there are multiple entries bearing the same name but from different
CA's, there has been a DNSSEC registry hack. The site should change
DNSSEC-registrar. And the key is useless.
In general, every once in a while you check that your name is still
unique, just to make sure that the site keeps its requirement to hand
out each name only once.
You also check out the names of new communication partners, just before
and slightly longer after first contact. When you still only find your
and their names with the expected nickname, there has been no mitm and
you have validated that persons public key. (As described in my blog
"The Holy Grail of Cryptography" [0]. You can keep using this persons
public key, even if the site gets compromised later. Just add it in your
address book.
I hope it has become clear how I square the triangle. Feel free to point
out omissions, request clarifications.
With kind regards, Guido Witmond
0:

@_date: 2013-09-12 23:32:29
@_author: Guido Witmond 
@_subject: [Cryptography] Perfection versus Forward Secrecy 
Perhaps of (little) comfort:
By the time that quantum computer has been built, it will become clear
that by breaking the PFS crypto, you also break the non-repudiation.
In other words: No one can claim in a (decent) court that a certain
message has been sent by you, when the quantum computer can break both
the PFS and the merkle-tree hashes that are supposed to prove the
In the mean time, remember Scott Mc Nealy: "Privacy online is dead."

@_date: 2014-04-06 22:53:41
@_author: Guido Witmond 
@_subject: [Cryptography] Verifying X.509 Verification - how about an 
Quoting: "PKITS version 1.0.1 was posted on April 14, 2011."
It's not so old at all. :-)

@_date: 2014-04-10 11:30:27
@_author: Guido Witmond 
@_subject: [Cryptography] In defense of DNSSEC was :Preliminary review of the 
I'll climb on my soap box.
DNSSEC, as prof. Gutmann describes breaks the current expectations that
DNS works, even in the presence of errors, misconfigurations etc. The
goal of DNS has been that whatever happens, the end user must get
connected to a site, whether it's the bank, or the phisher.
DNSSEC protects against DNS-tampering at the price of
a) a lot of complexity, and
b) hard errors. Fail fast is a feature, not a bug.
That is a steep price.
*The killer app for DNSSEC is DANE*
DANE is DNSSEC Authenticated Naming of Entities. It lets a site owner
publish their server certificate or root certificate in DNS.
This solves the *DigiNotar*-problem! For the first time in history,
browsers can validate *which* is the expected certificate of a site.
DANE specifies the *expectations*, the browser with help of global
certificate registries, such as Perspectives, Certificate Patrol verify
the actual observed certificates, raising an alarm if the expected
certificate is not found.
To me, that's worth the price of learning how to deal with DNSSEC and
it's complexity. Something best outsourced to a competent dns-registry.
(Don't go for the bottom of the barrel, but hey, that's your choice).
With regards,
DNSSEC+DANE lover, Guido Witmond.

@_date: 2014-04-11 14:06:58
@_author: Guido Witmond 
@_subject: [Cryptography] Preliminary review of the other 
Given the time that people cling to XP, it will take 20 years to mature
and get used ubiquitously. Don't get me wrong, please design and build
that P2P DNS system now. In 20 years we will really need it.
In the mean time, we have DNSSEC to protect us as best as it can. I
don't want to wait for the perfect solution, I want incremental improvement.
Now, how do we get browser vendors to do dnssec/dane validation by default?
regards, Guido.

@_date: 2014-04-12 20:16:50
@_author: Guido Witmond 
@_subject: [Cryptography] Preliminary review Gutmann's Security Engineering 
I'm reading through his draft and came upon this gem.
on page 40 Gutmann writes on user conditioning:
That reminds me of the 'problems' of road-safety. The more
safety-features there are in a car, the less safety-aware people drive
in it (in general).
At the same time doctors are complaining about lack of sufficient organ
donors due to increased road safety.
Regards, Guido.

@_date: 2014-04-14 12:02:46
@_author: Guido Witmond 
@_subject: [Cryptography] Preliminary review of the other 
I wonder how big a problem this is, most of the jet-set already have
VPN-tunnels to their corporate back office. Or they tether using their
smart phone, routing around the broken portal.
In my limited hotel-hopping experience, the more expensive the hotel,
the more likely to see crappy portals. Cheap hotels just give you their
guest password.
Don't wait until the theoretical roadblocks are gone, other people will
take those out when they experience them.
All the more reason to push browser vendors to implement
DNSSEC-validation into their Products. This will show that those portals
are 'defective'.
This last-mile problem will solve itself.
Regards, Guido Witmond

@_date: 2014-04-16 21:23:07
@_author: Guido Witmond 
@_subject: [Cryptography] I  don't get it. 
Sounds like every other software project on this planet...
It happens all the time, only the severity differs.
As for probable causes:
- underfunding;
- ever-changing requirements, as the users will imagine new
possibilities as the project matures;
- managers/customers thinking that software *development* is a sort of
conveyorbelt, just replace a programmer with the next and the work will
- ie, all the classic software management errors.

@_date: 2014-04-17 14:56:36
@_author: Guido Witmond 
@_subject: [Cryptography] Simpler programs? 
If I may ask, what is your opinion on Genode.org's design, would that be
a worthy successor to Eros/Capros?
With regards, Guido Witmond.

@_date: 2014-04-18 09:44:52
@_author: Guido Witmond 
@_subject: [Cryptography] Simpler programs? 
Genode has a browser in their demo.
Their old (2011) demo downloads a linux-kernel and small userland over
the net and runs it in a protected domain, inside the browser. Of
course, it was as trusted as the network it downloaded from. (ie, not at
all) but it only had access to itself, the os protected itself and the
other applications against a misbehaving download.
The new releases will contain an ever improving port of Virtualbox,
making compatibility soar.
I do hope that the current climate about spying and lack of security
will change the tide. I guess it will when the banks hold end users
responsible for their systems and *enforce* that. IE, people need to
lose money before they do something about it.... (regrettably).
I'm very sure the unix model is not the correct model as hostile code
can run inside a trusted environment.
In unix the maximum security-level (for each user-id) is that of the
lowest security level of all of the programs that that user can run.
Each program has access to everything that is important to the user,
their files.
Polaris [1] had it right for Windows. Too bad it wasn't available in
open source for linux. Is Polaris still for sale?
Regards, Guido.
1:

@_date: 2014-04-18 10:08:14
@_author: Guido Witmond 
@_subject: [Cryptography] Something that's bothering me about the 
I fully agree!
However, we need to go even further. Every parser (that reads data from
outside) needs to run in their own protection domain.
That's what microkernels allow us to do. However, in the past a certain
mr Torvalds chose the monolithic kernel because it was faster, and
backwards compatible with other unices.
Now we have virtualisation. Instead of one computer to manage, we need
to manage a lot more. Talking about going backwards.
However, the cloud has a silver lining. This time literally.
Check out the MirageOS [1] project. "Mirage is a unikernel for
constructing secure, high-performance network applications across a
variety of cloud computing and mobile platforms. Code can be developed
on a normal OS such as Linux or MacOS X, and then compiled into a
fully-standalone, specialised kernel that runs under the Xen hypervisor."
There is no operating system anymore! So no backwards compatibility at
that level.
The price is steep, one would have to rewrite every application, darn.
Regards, Guido.

@_date: 2014-04-18 19:22:46
@_author: Guido Witmond 
@_subject: [Cryptography] I  don't get it. 
Well, I'm to blame.
20 years ago, I added a check to the gcc parser that whenever it
encountered a strlen or strcpy token, it would give a warning.
When I got into compiling my brand new linux 0.x and userland the amount
of warnings was so huge that I quickly disabled my checks. Besides, most
of the code worked, so why bother.
I got a rude awakening at the OHM-2013 hacker festival when someone gave
a presentation on stack smashing. His example function, gets().
Most of the code worked, so I assumed someone else would.
It's the bystander effect. That's to blame. And me for being one among many.
Regards, Guido.
PS, read Gutmanns new book "Security Engineering", that's where I got
this wisdom from.

@_date: 2014-04-19 11:11:20
@_author: Guido Witmond 
@_subject: [Cryptography] Simpler programs? 
I'll give it a try:
Temporary file space: at start-up each process is handed a
file-descriptor to a file in /tmp. The process is free to use it as it
sees fit, for example, the process can run a simple filesystem in it, or
use it as a key/value store. The kernel hands the file and reclaims it
at process exit. With an an in-process fs-driver-library, it saves on
kernel overhead at access. These savings might outweigh the cost of
startup and teardown of the tmp-file.
Spool files: Files that need to be preserved after process exit should
be stored in a spool-directory. This is to be set up at program install
time, according to a FHS.
Windows: each process is handed a file descriptor to the Wayland
process. The parent process can ask Wayland (not X) for a fd, set some
limits to size and position. The parent is responsible for closing.
Libraries: who cares what libraries the process can access. If there is
a remote code execution bug, the attacker can upload anything they like.
Protection should not come from withholding code, it should come from
withholding access to resources and the users' data.
Network access: Parent process gets asked for a network socket. Parent
verifies request and opens the connection. It hands a fd to the child.
But at this point, it's no longer a unix. I understand where the pain
comes from. There is only so much POLA to be retrofitted at unix.
Regards, Guido.

@_date: 2014-08-17 10:09:31
@_author: Guido Witmond 
@_subject: [Cryptography] Cost of remembering a password 
The current design - where people type in passwords - is also considered
a trusted system. It's trusted not to leak the passwords when these are
typed in. The amount of keyloggers show that this trust is not warranted.
Then there is the issue that people do not validate which is the
expected CA that signed a sites' server certificate, turning a  TLS into
a trusted system too. What price should we put on that?
Or the price of clicking the "I don't understand, I just have to click
yes to proceed" button. What price should we put on that?
Cheers, Guido.

@_date: 2014-08-25 21:10:51
@_author: Guido Witmond 
@_subject: [Cryptography] Encryption opinion 
It doesn't have to be.
Yes it can!
1. Take the user out of the validation path.
2. Let the computer decide who is genuine and who's LLB (Looking like Bob).
Here's my attempt:
Cheers, Guido Witmond.

@_date: 2014-12-02 00:01:20
@_author: Guido Witmond 
@_subject: [Cryptography] Toxic Combination 
Dear members of the list,
Thanks you for the responses. I'm replying in a single message...
On DNSSEC:
DNSSEC and DANE are quite a hurdle to set up. However, PGP has shown
that shifting the burden from users to the site owners is justified. The
site owner can outsource, the end user has no such option.
On using zero knowledge proofs:
A zero knowledge proof for passwords has existed for years in browsers.
Digest Authentication suffers from the problem that there is no
logout-button on the browser chrome. Closing the browser was the only
way. That's why every site uses session management under server control.
On PAKE, password authenticated key agreement:
It requires users to come up with passwords. The wetware is very bad at
that. Suggesting a password manager is defeating the one good thing
about passwords: they don't live inside the user's computer. When that
benefit is gone, certificates are a perfect fit. We need to get a proper
key exchange.
On CA's:
Diginotar has shown that EV certificates have been falsified.
On stealing passwords from the server:
Eliminating passwords and replacing these with client certificates
eliminates that problem.
On managing risk:
Why manage risk of scammers faking EV-certificates if it can be eliminated.
I'm offering a protocol that performs a proper authenticated key
exchange between a site and a user's agent. It makes life easy for the
end user, at a higher price for the site owner, who can outsource.
The details are in the paper.
With high regards, Guido Witmond.

@_date: 2014-12-03 22:33:05
@_author: Guido Witmond 
@_subject: [Cryptography] Toxic Combination 
Dear mr Laurie,
I humbly believe I've came a long way towards a system that fits all of
these requirements:
ad a) the user agent (yes: browser) manages the cryptographic operations
and verifications for the user. The user has to decide:
 - whether to create an account;
 - when to log in;
 - when to log out;
 - whether to trust the site with his private information or not. Until
then, the user is anonymous (except for ip-addresses, cookies etc)
ad b) the site operator has a few extra steps to take:
 - set up their own CA;
 - sign server certificates;
 - setup the DNSSEC and DANE records;
 - sign client certificates;
These steps can be automated into a single system that adheres to the
protocol. It could be delivered as debian/ubuntu/redhat packages, a
boxed solution or as an outsourced service. Most web hosting providers
should be able to set up this service for their customers. I imagine
that companies that know how to charge money for certificates might be
interested in providing this service. They have the expertise in
operating a HSM properly...
Most web servers already know how to deal with client certificates. The
benefits are: no hassles with password recovery, easier session
management, lower state to maintain at servers as the TLS-layer provides
the authentication.
ad c) The eccentric protocol is using existing web infrastructure. It
requires some changes at the browser and the server but in a backwards
compatible way. One site at a time can convert. The protocol does not
forbid to user password authentication next to client certificates. The
latter have benefits over the former. Transition can be gruadually.
ad d) In the basic version of the protocol -- where clients authenticate
with site-CA-signed client certificates -- there is no incentive for a
site to MitM themselves. But this is limited to user-to-site and
site-to-user communication. When there is a need for user-to-user
communication where the site cannot MitM the endpoints a need for a
verificate service arises. I call that the Registry of Dishonesty[0].
In every case, there is end-to-end key exchange where there is no chance
of a MitM going undetected. There might be a small chance that a site
operator might turn rogue but that is detected almost immediately and
published for the world to know.
I sincerely believe that my protocol raises the bar towards your goals
tremendously. Please spend some time to investigate the ideas[1] behind
it  and let me know what you think is missing before you would fight for it.
Respectfully yours,
Guido Witmond.
1:

@_date: 2014-12-04 16:10:31
@_author: Guido Witmond 
@_subject: [Cryptography] Toxic Combination 
Gentlemen, there's no need to argue. I claim this requirement can be met
(and without magic).
Just as there is a Certificate Transparency project for server
certificates we need a similar thing for client certificates. I call it
the Registry of Dishonesty. [0] [1]
And there is a demo too:
download: install: libunbound2 and perhaps libsqlite3
run it  ./ecca-proxy
then configure your browser to use 127.0.0.1:8000 as http proxy.
browse to: or:        Happy hacking.
Regards, Guido Witmond.

@_date: 2014-12-06 00:09:14
@_author: Guido Witmond 
@_subject: [Cryptography] Toxic Combination 
There is no need to authenticate at the application level. There are two
1. Tor.
2. TLS renegotiation. First a secure session gets established. The
client's user agent verifies the authenticity of the server. Clients are
anonymous. When the server indicates it need client authenticate, they
start a TLS-renegotiation (over the secure link) so adversaries won't
learn any identities, just IP-addresses. (see point 1).
Regards, Guido.

@_date: 2014-12-06 00:15:25
@_author: Guido Witmond 
@_subject: [Cryptography] Toxic Combination 
How does one get a secure authentication with this IDP? How to signup?
What about strangers that you want offer a secure connection and yet be
able to recognize at later visits. That's why Eccentric uses DNSSEC and
The protocol solves problems that current protocol leave to the end
user: proper authenticating a site.
Quiz: who is the CA of your bank?
With regards, Guido Witmond.

@_date: 2014-12-18 00:24:49
@_author: Guido Witmond 
@_subject: [Cryptography] Any opinions on keybase.io? 
"Only web browsers" is impossible, as these lack a good way to manage
identities. But with a trusted (binary) user agent that follows a well
known protocol, it can offer private key management for the user.
The key is to never ask the user to override a security decision. The
agent can either confirm that the cryptography is correct and let the
connection go through or it block with an error.
I've designed a protocol that lets people manage their identities
easily. I call it Eccentric Authentication [1].
Indeed, security should be at the bottom layers, being there for the
user at all times. The site admins have to set up some stuff in advance
but that's it.
Regards, Guido Witmond.
[1]:

@_date: 2014-12-18 12:25:04
@_author: Guido Witmond 
@_subject: [Cryptography] Google E2E (was: Any opinions on keybase.io?) 
I've came up with a protocol that lets the user agents detect if their
key-directory is MitMing them.
It takes a round trip of one message each and sufficient time to
propagate the certificates though the out-of-bound
certificate--uniqueness-validation-service. I've called it the registry
of dishonesty....
The beauty of validation service is this:
The agents need to validate this MitM-status only at the moment the two
users want to communicate. After it is clear that there is no MitM, the
agents record that fact and remember it. The agents make sure to always
use the proven certificate to encrypt messages to the other. There is no
way for the key-server-annex-email-provider to MitM these two endpoints
Here's the requirements for such a validation service:
With regards, Guido Witmond

@_date: 2014-12-21 18:25:58
@_author: Guido Witmond 
@_subject: [Cryptography] Certificates and PKI 
By promoting DANE support in the browsers. Install every DANE-validator
plugin and enable the browser to spy on your plugin-list.
Or forget browsers and go the App-way:
Create DANE-validating libraries for Android/iOS/Windows-phone and get
them adopted for their stronger security-properties, ultimately leaving
browsers behind as untrustworthy technology.
Oh, and apply every other verification mechanism out there too. The more
available the more expensive it becomes to mess with the system.
We shouldn't fight about security mechanisms, we should apply them all.
Don't let the bad guys play 'divide and conquer'.
There is no panacea but every mechanism counts.
Does this answer your question?
Regards, Guido Witmond

@_date: 2014-12-22 16:47:57
@_author: Guido Witmond 
@_subject: [Cryptography] Certificates and PKI 
I'm not sure I understand this. How would DANE put registrars into the
role of a CA or RA?
Is your concern that a registrar is able to modify each of the A, AAAA
and TLSA-records of any entrusted domain? Either voluntarily or coerced?
It's up to the domain owner to monitor the registrar. Using
decentralised tools such as the IETF's Atlas network or tor to prevent
the registrar from detecting your monitoring and get a good overview of
worldwide perspectives.
If we think CAs are not a good solution, how is it the
The missing ingredient is a way for the end user to identify when a
site's TLSA-records gets compromised.
For that, each site needs to run their own CA, sign their server
certificate with it and publish their own CA-cert in DANE.
The user agent (browser) can pin the domain name and CA-cert together at
first contact. It's Trust-on-First-use, agreed. But for that we have CT
to provide a historic view, reducing the amount of trust at first.
If running your own CA is too difficult, outsource it to someone who
knows how to operate a HSM.
Not magical, hopefully practical.
With regards, Guido Witmond.

@_date: 2014-12-23 11:23:29
@_author: Guido Witmond 
@_subject: [Cryptography] GHCQ Penetration of Belgacom 
I remember a story that early time computers were so unreliable that
programmers did a multiplication directly after a division to verify the
Voting on results is a common technique in aircraft and other
environments with low tolerance to failure due to wear, electrical
glitches, cosmic radiation, etc.
Crypto could be seen as low tolerance to failure. However, verification
appears to be impossible: proof that there is no leak of key material...
Regards, Guido.

@_date: 2014-12-24 20:01:46
@_author: Guido Witmond 
@_subject: [Cryptography] Certificates and PKI 
There are some possible failures:
1: a site owner accidentally destroys their private CA key. They have to
go the public route via the news, as Bear described in his example on
Amazon. The user needs to reset their pinning. It must be clear to users
that it is an emergency measure, unlike current errors/warnings about
2: the private key of the private CA of a site leaks and the thieves use
it to sign a server certificate for their fake bank site. They try to
lure victims to their fake site. Browser rejects based upon mismatch
with pinned version and a missing entry in CT. If thieves submit their
server cert to CT, it will get detected.
3. A service provider provides key storage for private CAs private keys
and does certificate signing for its customers. This provider gets
hacked and it comes to light. This provider gets known as Diginotar.
Only the site owner (who owns the site's private CA) can sign valid
certificates. Just rate limit to a low number of certs per domain.
See a). I thing that coming up with a protocol to do automatically
handle the bad stuff is giving criminals/governments the mechanisms to
abuse. I hope that someone can prove me wrong.
Regards, Guido Witmond.

@_date: 2014-12-24 22:24:53
@_author: Guido Witmond 
@_subject: [Cryptography] Certificates and PKI 
The challenge is to make that domain take-over event detectable by the
visitors of your site.
Here's my solution:
Each domain owner deploys a private CA. It signs the server certificate
for the site. The certificate of the private CA is specified in DANE.
Visitors (browsers) verify the TLSA-record against the server's
certificate at first contact. They remember the TLSA-record and verify
nothing has changed at later visits.
A "hostile" takeover by the parent domain will result in a mismatch. The
browser must refuse to proceed.
We can improve upon this scheme:
Each visitor signs up with a client certificate that is signed by a
sub-CA of the site's private CA. Notice that both the server and the
client certificates are signed by the same private CA.
At subsequent visits, the browser offers the user to log using the
client certificates that match the CA that signed the server they've
connected to.
If the current domain name gets hijacked by the parent domain, the site
owner creates a new domain name, signs it with his private CA and gets
the news sites to advertise the new domain: "piratebay.org is down, go
to piratebay.com". Or even piratebay.onion, no need to set up TLSA.
The browser recognises the same CA and offers the user to log in using
the client certificate.
Not only can we detect domain hijacking, we made it trivial to circumvent.
That's what I call Regards, Guido Witmond.
PS. Cypherpunks that like running code:

@_date: 2014-12-28 14:12:20
@_author: Guido Witmond 
@_subject: [Cryptography] Certificates and PKI - Eccentric version 
Please bear in mind that I describe the Eccentric-Authentication
protocol, not traditional PKI...
I ignore All DNS-records in the protocol except for TLSA, all others are
free to change. The TLSA record points to the true source (in
Eccentric-Authentication) *by definition*.
The TLSA-record points to the Private CA of the domain. The CA signs the
server and client certificates.
Assume a user has a client certificate signed by the private CA of that
domain. (The correct owner). As long as the private key of the private
CA remains secure, the browser can detect TLSA manipulations by third
parties (i.e. Registrars/governments/...)
What remains is a TOFU-situation: How to increase the chance of a user
detecting the correct site for a given domain name at First Contact.
That's where CT/certpartol/perspectives comes in. It records the history
of the values of the TLSA-record for a domain.
The 'price' is that one cannot change their TLSA-records. In
eccentric-authentication, the Private CA is the *Identity* of the site,
not the domain name.
As long as the domain owner (registrant) keeps its private CA private
key secret, it is protected against hostile registrars. The private key
lives at the right place: at the end, not in the middle.
To make it easy to keep that key secret, the domain owner creates a
SubCA, uses that to sign client certificates and keeps the Root key on a
HSM (usb-stick, smart card, etc) in a safe. Once in a while the domain
owner creates a new SubCA private key and destroys the old one. This
step can be done offline using a dedecated computer, only to be used for
this purpose.
To summarize: The tradition PKI designates the *domain name* to be the
*identifier*. With Eccentric-Authentication, I designate the Private CA
Public Key to be the identity, independent of domain name.
Traditional PKI offers the option to change public keys at any time, the
price is that end users have to trust that the infrastructure is honest.
And end users have no way of detecting that.
In Eccentric-Authentication, the protocol offers true end-to-end
validation of public keys between sites and users. End users' browsers
detect it when the infrastructure is dishonest. To manipulate
undetected, one has to obtain the private CA Root key. A much harder
target. And a higher price to pay if the CA Root key gets destroyed or
Regards, Guido Witmond.

@_date: 2014-02-14 10:15:55
@_author: Guido Witmond 
@_subject: [Cryptography] BitCoin bug reported 
A few misunderstandings...
Please don't conflate cost and value.
The cost increases, the value is dependent on market forces. Currently a
speculation thing.
Personally, I see the transparency of the ledger as a good thing. Money
is power. Power corrupts, thus money needs to be checked. I believe some
big problems in society are due to unchecked power in combination with
I guess that's why the powers that be don't like Bitcoin, they don't
like to be accounted, held responsible.
Regards, Guido Witmond.

@_date: 2014-02-14 10:36:20
@_author: Guido Witmond 
@_subject: [Cryptography] Another Bitcoin issue (maybe) 
Your fear can become reality if bitcoin is only used for speculation.
Currently the transaction fees are so low because everyone is hoarding
bitcoins. When there is sufficient transactions (for goods and services)
taking place, the fees will outweigh the mining-bonus making your
scenario less likely.
But it ultimately depends on Moore's Law. When there is no more increase
in efficiency in mining-hardware that obsoletes the old tech, the world
will be flooded with mining rigs, making your scenario possible again.
But still, I prefer to take the risk of your scenario over the eternal
growth fallacy of current economic belief.
Regards, Guido Witmond

@_date: 2014-01-07 21:07:55
@_author: Guido Witmond 
@_subject: [Cryptography] defaults, black boxes, APIs, 
Not every OS.
There is a group of people working on fine-grained authorities inside a
general purpose operating system.
They call themselves Genode.org.
If you can't wait and really need to open potential hostile .doc and
.pdf files, install Qubes-os.org and run these in a throw-away zone.
Regrettable, these are not mainstream yet. Please give these projects a
try and spread the word.
Regards, Guido Witmond.

@_date: 2014-06-18 22:10:06
@_author: Guido Witmond 
@_subject: [Cryptography] Help please, 
My shillings:
How many identities would each person have? One? Or as many as the like?
Can people wield one identity at one site and another at a different
site? Can sites collude to link these together?
What are your ideas on this?
Regards, Guido.

@_date: 2014-03-16 20:56:05
@_author: Guido Witmond 
@_subject: [Cryptography] Client certificates as a defense against MITM 
Fail fast, no questions asked, no user overrides. Let's not make that
old mistake again.
With DNSSEC and DANE, an attacker needs to impersonate ICANN's DNSSEC
Root key as well. This certainly limits the number of players that can
impersonate your site to two: NSA, NSA's friends.
Again, DNSSEC and DANE do identify the server.
For client, the site can set up their own client certificate signer for
their own use.
Just improve browser support a bit, but that's left as an excersi.....
Regards, Guido.

@_date: 2014-03-17 00:42:24
@_author: Guido Witmond 
@_subject: [Cryptography] How to build trust in crypto (was:recommending 
Ralf, I'll pick up the gauntlet. I think I've come up with a worthy
contestant to your challenge.
Not only, I'll show how someone can have a secure online communication
with someone else. I'll create a secure channel between two people who
have never met before.
Here's how:
1. We create a web site, say a blog site.
Before anyone can sign up we do these:
2. Create an RSA Root CA, with our own private key.
2a sign our server certificate with it;
2b publish the Root-CA public key in DNSSEC/DANE;
3. we create a subCA private key and sign its public key using our RootCA.
3a. we use this subCA to sign client certificates for our blog.
3b. we configure our blog site to accept only our subCA.
4. people sign up for our blog, they create a nick name and request a
client certificate at our blog's subCA.
4a. people create the nick name themselves;
4b. their user agent creates a new private/public keypair for each account;
4c. the subCA makes sure the (nick name @ sitename) is unique
4d. it signs (nick name @ sitename, pubkey) using the subCA privkey.
5. User A signs up, requests and get a certificate bearing CN: A @ site.
5a. A writes a blog entry,
5b. A signs it with her private key and
5c. publishes (message, sig(message)) on our site.
6. User B reads the message of A
6a. B signs up likewise.
6b. B writes a comment on A's blog.
6c. B signs it using his private key;
6d. B publishes the (comment, sig(comment)) on our site.
7. A want to talk to B over VOIP.
7a A creates a voip endpoint on her computer: IP: x, port y.
7b A configures it to accept only connections identified by B's public key.
7c. A writes a private message to B, specifying IP x, port y, pubkey B.
7c'. This is encrypted using B's public key. only B can decrypt it.
7d. A waits until B connects
8. B receives the private message, decrypts using his private key.
8a. He connects to IP x, port y;
8b. sets up a Diffie-Helman key exchange;
8c. signs the key with their own private key;
8d. validate the others' key against their signature;
8e. and if matches, lets the voip session go on.
8f. on failure to match, disconnect and explain.
8g. both strangers have an authenticated connection with the person they
expect it to be. (whomever it may be)
9. Two strangers, who have never met before have successfully created a
secure channel between them.
How it works:
A. DNSSEC and DANE let any site publish their own Certificate Signer
A1. Only ICANN and agencies that copied their keys (NSA) can impersonate
a site
B. Our blog site doesn't care about the true identity of the people. It
requires that the CN of each user is unique. Ie, the nick name is unique.
B1. This uniqueness makes CN a substitute key for the pubkey, the real
C. Every blog entry or comment is either totally anonymous, or it is
signed with the authors public key.
D. Reading a blog comment requires verifying the message signature
against the public key. When verification succeeds, the pubkey proves
ownership of the message.
D1. When verification succeeds, you have effectively validated the
pubkey of the author. Only the corresponding private key can have
created that signature.
E. By responding to a blog entry, with a message signd using your
private ke, you have transmitted your public key to those who have
validated your message, including the blog author (A);
E1. Effectively, you have exchanged public keys between each other.
F. One more thing to do: verify that the CN of the other party is unique
at teh global registry. It makes sure there is no Man-in-the-Middle,
making the CN truly a substitute key for the pubkey.
G. These public keys are used to identify the other party in the
Voip-call. Only the owner of the private key can connect.
That's the essence of Eccentric Authentication, my protcol to implement
all of this.
or start at the home page.
Heck, I think it appeals to John Doe. It just works. And when there is a
duplicate signed CN, the user agent complains loudly and the nerds of
the world will investigate. (side effect of the global registry of
All it needs is support from the browsers and some easy to use server
side software.
Feel free to take shots at my approach. I'd like to get feedback on how
far I get with this competition.
Regards, Guido Witmond.
PS. check out my Alien Dating Site. Here is the walk-through:

@_date: 2014-03-17 01:12:04
@_author: Guido Witmond 
@_subject: [Cryptography] Client certificates as a defense against MITM 
Viktor, you are ahead of me.
With my Eccentric-Authentication, I haven't reached the state of
rekeying yet.
I still try to drum up support for the idea that total strangers can
connect securely.
When two people connnect, they don't need rekeying of their original key
anymore, they have established an independent channel. To keep it going
throughout the years, rekeying of their private keys might be necessary.
However, that's out of my scope. At least for now.
Remember that when two people need to rekey their channel, there is no
need for domain names. Each party knows the other purely by their public
key. That's the identifier that's important.
Regards, Guido Witmond.

@_date: 2014-03-17 12:51:59
@_author: Guido Witmond 
@_subject: [Cryptography] Client certificates as a defense against MITM 
I assume you mean threat, not sentence of imprisonment? Otherwise it's
easy, just do it.
Here it goes for two, still free men:
A gay rights organisation sets up a free dating site, hosted somewhere
safe, say Amsterdam. They create their own Root CA and set up DNSSEC and
DANE. It uses a subCA of their Root to create client certificates. The
site only accepts their certificates, signed using their own subCA.
The men use only Tor to connect, preferable within Tails. They do need
to store a private key for a while, for that they use a usb-stick.
Man A connects. He verifies the server cert against the DNSSEC/DANE
entries. He creates a nick name (not his real name) and his user agent
requests a client certificate that will be signed by the site with a
SubCA of the gay rights org's Root CA.
A publishes his certificate at the global registry, a an append-only log
of each certificate signed. The registry can be queried with the tuple
(nickname, site) and returns all certificates bearing that name. Think
Certificate-transparency.org with some extra querying.
A posts a message on the site that he's in the market. The message is
signed using A's private key. The signature and A's certificate are
published alongside the message.
B connects to the site without logging in, finds A's offer interesting.
B verifies the message signature and validates the public key against
the site's certificate chain (subCA -> RootCA -> DNSSEC/DANE record,
DNSSEC-chain to the ICANN-root.)
B then queries the Registry, there must be only one certificate
returned, it must be the one from A's message. If it differs it means
that A has fallen victim to a MitM attack by the Site. B submits the
certificate from the message to the Registry for A to find it later.
B might also contact some journalists to point it out that the gay
rights org's server is hacked, subverted or otherwise untrustworthy. The
proof is the two certificates bearing the same nick.
When all is well, B creates an account for himself and sends a private
message, signed with his private key, encrypted using A's public key. B
hands it to the site for delivery to A.
A retrieves the message, performs all the same verification and
validations on B's certificate. If A detects a different certificate at
the registry than what's used at the message, he posts the certificate
at the Registry for B to find. A bails out, and might contact journalists.
A now queries his own nick at the registry. He expects only his own
certificate to be returned. If he sees two certificates, it means that
the one that's not his, is one that the site has created. The site
performed a Man-in-the-middle attack. Something even gays would object to.
A writes a new message, suggesting a date and place and a pass phrase
that he will use to identify himself to A. It should be innocuous that
it can be said in normal conversation but not too out of place. Think
movie-style pass phrases.
B upon receiving this message, queries the registry for his nick,
expecting only one. If there are more, it would be the one that A has
detected and published at the registry.
Now, after both message round trips, they've established that there is
no MitM.
B confirms the date and place and his pass phrase.
Both take a big leap of faith that the other is not a investigator. To
protect themselves, both men delete their private key and all traces of
their communication with the dating site. Best to wipeout the usb-stick
that contained the Tails software too. Better, destroy the stick.
They go out to the agreed meeting place, and if they trust the
situation, mention the passphrase in casual conversation where one thing
may lead to another....
In case one of the men is an investigator to apprehend the other, there
is no proof other than the circumstance that a man is at the right place
at the right time and utters the right pass phrase. If he deleted the
private key, there is no hard evidence. But that little evidence might
already be enough. There is no technological solution to make people honest.
This dating site already exists. I've designed it in a less politically
tense theme of aliens of the extra terrestial kind sending Vogon Poems
to each other. Something even Ugandan ministers of health can accept.
The software is here:
It does all the key management mentioned above. I need to write the
registry part.
Best run it in a VM, if you don't trust my binary.
With Regards,
Guido Witmond.

@_date: 2014-03-17 13:58:39
@_author: Guido Witmond 
@_subject: [Cryptography] How to build trust in crypto (was:recommending 
Hi Natanael,
The eccentric-authentication protocol requires nick names to be unique
for each site.
That requirement is what makes the CN a human memorable identifier. A
substitute for the true identity, the public key.
Only the site's own Client Certificate Signer can sign certificates for
the site, so it is responsible not to sign the same name twice.
The registry is there to validate that the site's Signer adheres to that.
The registry verifies that a certificate is signed by a subCA of the
Root that is specified in the DNSSEC/DANE entry for the site.
The site's Root CA public key is the *identity* of the site. DANE is
used to give it a human memorable name. DNSSEC is used to make it
verifiable unique. (Again, with help from the registry).
This is how Eccentric-authentication squares Zooko's triangle.
Namecoin has a cost, so people would not easily want to create throwaway
In a different thread [1] on this list, I just wrote a use case about
two Ugandan gays who want to meet without their government finding out.
They mustn't be tempted to keep their keys or reuse identities. Nor
should there be a trace back to their namecoin or bitcoin address either.
In future, Namecoins might be used as a replacement for DNS, DNSSEC and
DANE in the eccentric authentic protocol. It needs support at the
TLS-connection level to lookup the data in the Namecoin chain instead of
With Regards,
Guido Witmond.
1: Client certificates as a defense against MITM attacks. At 12:52 UTC+1
(Amsterdam time), waiting for approval....

@_date: 2014-03-17 23:10:03
@_author: Guido Witmond 
@_subject: [Cryptography] How to build trust in crypto 
Indeed, without context, a key is just meaningless, it's all about what
people do.
And that is exactly the way I envision it. Active communities where
people learn of each other, interact, gain trust in each other, gain and
lose reputations. Reputations based upon pseudonyms. Easy to shed off by
deleting a private key. Ready to start over, without long lasting effects.
The anonymity/pseudonymity is very important for me. It allows people to
participate in a community while hiding their true identities.
People cannot be free when there is a group that monitors every aspect
of your life, connecting dots that you want to keep separated.
In [1], I describe a use case of Ugandan gays who want to meet without
getting to jail for it.
In [2], I describe how this protocol can be used by journalists, a world
where Snowden would not had to have to teach Greenwald how to use
cryptography. There I give it context.
I guess, in the past, I didn't make that context clear enough.
Regards, Guido Witmond.
1:

@_date: 2014-03-18 14:09:32
@_author: Guido Witmond 
@_subject: [Cryptography] How to build trust in crypto (was:recommending 
Hi Jerry,
D-H creates a secure channel against passive eavesdropping. D-H does not
protect against active MitM attacks.
On the contrary, the premise of eccentric authentication is that there
is already a common interest, ie, a blogger and a commenter. They've
never met anywhere except at the blog site where they read each others'
writings. That's the context that Ralf was referring to in a previous
Eccentric provides the protocol to make that the private channel setup
transparent, completely automated, and secure against passive and active
attacks, while providing anonymity to both end-points. Ie, they have a
secure channel but neither party, nor the site, learns anything else
about the other. Not even IP-addresses when using Tor.
When the blogger and commenter set up a private connection, they
consider a MitM a threat-scenario they want to avoid.
Agreed. You never know what the other party does with the information
you hand them. Act accordingly.
Indeed, on the internet, nobody knows you're a dog. At least, give me
the tools to get back to the same dog I met last time. I believe that to
be a requirement in Ralfs challenge.
With kind regards,
Guido Witmond.
PS, Check here what two people can do once they have a secure channel
via a web site:

@_date: 2014-03-18 20:44:36
@_author: Guido Witmond 
@_subject: [Cryptography] How to build trust in crypto (was:recommending 
Hi Ralf,
I'm not going to disappoint you :-) What you describe is called: Trust.
 "belief that someone or
something is reliable, good, honest, effective, etc"
Bruce doesn't offer any mechanisms so people can validate that the key
posted on his site is most likely his key. The GPG-key bears no
signatures from fellow sercurity researches. The website bears a Domain
Validated TLS-certificate. There are no DNSSEC/DANE records to specify
the CA he chose for that certificate.
Bruce also did not sign his reply to an email I had send. I read his
crypto-grams on the web, but I guess these are sent unsigned in the
mail. So trust is all that's left. The question is: How much?
Had Bruce used any of these methods above, the level of trust that the
key on the website actually belongs to him increases with use. Signing
each Crypto-gram issue with the key really does wonders.
That's what I'm trying to achieve with Eccentric. Distribute keys along
messages, so one can gain trust in the author. Private messages sent can
only be read by the owner of the private key. Whether they are called
Bruce, or 'Captain Kitten'.
One should not have to trust the key, One should verify it. Preferably
automatic by an agent on one's own computer.
Regards, Guido.

@_date: 2014-03-19 10:16:39
@_author: Guido Witmond 
@_subject: [Cryptography] Client certificates as a defense against MITM 
Hi Peter,
What if a user agent could do all that crypto-nerd stuff so the only
actions for the gays would be:
- Sign up;
- Post message;
- Reply message;
- Send a few more if the original date and place are not suitable;
- Delete usb-stick;
- meet up.
All those [Pages of text] that you took out are for fellow crypto-nerds
to shoot holes in it.
Guido Witmond.

@_date: 2014-03-19 14:16:55
@_author: Guido Witmond 
@_subject: [Cryptography] Client certificates as a defense against MITM 
I've got a write-up about that on my plain old - non encrypted - blog site:
That page describes how the simplified user interfaces works from the
end-user perspective, ie, creating an account, logging in and out,
selecting among multiple accounts. It goes into private messages between
clients (although with the site as delivery vehicle).
We can separate identity from transport, Ie, we use the accounts at this
dating site to authenticate a ZRTP stream between two people directly.
How that works, I describe at:
Please let me know if things are still hazy.
Regards, Guido Witmond.

@_date: 2014-03-25 21:56:53
@_author: Guido Witmond 
@_subject: [Cryptography] On mobile passwordless logins and established 
Agreed. :-)
I assume that the private key is the ID, and that is is only used for
recognizing recurring visitors.
Private keys and client certificates might be overkill for
differentiating recurring vistors to a server. A signed cookie suffices.
Would you create a peer-to-peer communication protocol (for example
in-app communications between two participants), the private keys allow
for encrypted communication that your server could not decrypt.
But then you are in the land of message signatures, key validation and
all other nasty details of cryptography.
Would be cool if every app would do that, though!
Regards, Guido Witmond.

@_date: 2014-03-26 09:53:02
@_author: Guido Witmond 
@_subject: [Cryptography] The role of the IETF in security of the 
the net?
Hi Stephen,
I have this crazy idea about using client certificates to create
authenticated yet anonymous/pseudonymous accounts, making cryptography
transparent to the end users. (Site builders, operators and hosters do
have some work to do).
I would love to write my ideas in a draft.
My fear is that the barons and kings of this world won't like it as they
lose much of their surveillance capabilities. With many members of the
IETF being henchmen of the barons, they will outvote me any time.
Or have the times changed since the Revelations of a Contractor and is
there a genuine wish at the barons and kings levels to make privacy a
Is that fear justified? Or is it paranoia? What are the experiences on this?
Regards, Guido.

@_date: 2014-05-27 10:53:38
@_author: Guido Witmond 
@_subject: [Cryptography] client certificates ... as opposed to password 
I'll play that child:
I have build a prototype that shows that it can be done. Instead of a
browser plug-in, I use a client side proxy. The browser connects with
http to the proxy, the proxy does all the certificate handling with the
sites. It can be built into a browser plug-in quite easily.
It needs a little change at the server side too. However, replacing
passwords with certificates makes server software easier too.
I'll be speaking about exactly these issues at the ICANN meeting in
London on June 25th. In short: the combination of DNSSEC, DANE and
client certificates solves the MITM-problem.
Please see the walkthrough at [1]. The demo [2] is down at the moment,
will bring it up again tonight/tomorrow.
Regards, Guido Witmond.
PS. I'm looking for sponsors to make the browser plugin and the server
side certificate handling into easy to use packages.

@_date: 2014-05-28 17:22:21
@_author: Guido Witmond 
@_subject: [Cryptography] client certificates / client-side proxy 
Don't worry, it's just a prototype. The proxy is to get a clean slate in
crypto and key management, independent of the browser. In fact, if it
works well, it could be implemented in a browser plug in as well as a
stand-alone library for mobile apps.
The goal is to show how it can solve the problems we currently face in
internet security, such as password management, phishing, privacy,
Regards, Guido Witmond.

@_date: 2014-11-30 22:55:31
@_author: Guido Witmond 
@_subject: [Cryptography] Toxic Combination 
Dear list members,
I'm starting to consider the combination of current best practice with
server certificates and password to be a Toxic Combination.
The general issue is twofold:
    People need to validate the authenticity of a site before typing in
their password;
    The password gets transmitted to the other party.
Most people assume that if it looks like their bank and the address bar
is green then it should be safe. Regrettably, it?s not. Criminals obtain
valid certificates using stolen creditcards and passports. The true
method for authenticating a site requires verification of server
certificate fingerprints. And if you don?t know what that means, you
have to spot the spelling errors, the differences in layout and other
mistakes to detect the scammers. Good luck!
The second part is just as problematic: The password must remain secret,
yet it must be transmitted to the other side to log in.
This is the Toxic Combination. One failure to detect a scammer?s site
and the password is compromised. The scammers can do everything that you
can do with the password.
For more information, please see:
Regards, Guido Witmond.

@_date: 2015-04-21 23:45:10
@_author: Guido Witmond 
@_subject: [Cryptography] fighting designs in habituation since 1883 
Whether you scan people or dead fish, the problem remains. It's that we
force end-users to make a security decision that they are unable to
answer: Is it safe to continue or not?
Users have learned to click 'continue' at every roadblock, whether it's
safe or not. This study proofs that.
Now if we had systems that were able to correctly verify if a certain
certificate was expected or not _and_ refuse connection when not without
override options, then we would see some improvements in both security
and usability.
[objDisclaimer: I claim to design protocols that do just that.]
Regards, Guido Witmond.

@_date: 2015-05-03 20:01:43
@_author: Guido Witmond 
@_subject: [Cryptography] "Trust in digital certificate ecosystem eroding" 
For enlightenment value, ask colleagues, friends etc, who work in
IT-security if they can name the CA of their bank.
Answer: Most people don't know it, even though they know they should.
Here is the clue for the solution. We need to take the human out of the
Solutions like CT, Perspectives, Certificate Patrol work from the
premise that we can monitor changes and determine which changes are good
and which are bad changes in measurements. The assumption is that there
is only 1 certificate per domain name.
With DNSSEC and DANE, the site-owner *specifies* which CA is the correct
one *for their own site*.
If the browser requires a DANE record, and a valid chain of delegation
from ICANN's Root key downwards, then the browser has enough data to
determine if a certificate matches a domain name.
The end user does not get false warnings, it either matches and the user
gets connected or there's an error and the broweser refuses connection.
Don't allow overrides!
It doesn't solve typosquatting, there are other solutions for that. [1]

@_date: 2015-05-04 20:42:57
@_author: Guido Witmond 
@_subject: [Cryptography] "Trust in digital certificate ecosystem eroding" 
If someone has control over your endpoint, it's game over.
It's the ultimate form of Balkanization: spying on your own people *AND*
blocking nosy foreigners who don't have the tinpot-RootKey installed.
Why this is a real possibility, it's not a silent attack like having a
root CA certificate in the current browser trust stores.
Still, I think it is an improvement.
Because with the eccentric authentication protocol built upon DNSSEC and
DANE (and some more [1]), people inside the dictatorship still can
communicate securely with each other. So the dictator has to forbid that
Regards, Guido.

@_date: 2015-05-04 21:19:00
@_author: Guido Witmond 
@_subject: [Cryptography] "Trust in digital certificate ecosystem eroding" 
I believe there is a difference between CA/RA's and the DNS(SEC) registrars:
In the CA/RA world, *every* CA can create valid (looking) certificates
for your site and it's up to the receiver (the end user who gets
MitM'ed) to detect it before trusting the connection with their private
data. This is the responsibility of the end user.
In the DNS(SEC) registrar world, there's only a small subset that can
manipulate your certificates: the ones on the chain from the root (*)
towards your chosen registrar. This is something that the domain owner
can hold the registrar responsible for. If the registrar gets it wrong
(or coerced), shame them, drop them, claim your money back for breach of
contract and go to another. This is the responsibility of the site
operator/domain owner.
That's a huge difference to me, shifting the responsibility *from the
end users to the site operators*.
If these coercions happen just a few times too many, we create a global
monitoring system that permanently checks for coercions and register
these in a CT-like log for posterity.
Regards, Guido.
* (And only if they also replaced your ICANN-Root (pinned in your
browser) beforehand).

@_date: 2015-05-06 08:02:41
@_author: Guido Witmond 
@_subject: [Cryptography] replacing the whole sodding lot 
There is no reason to assume there is *only one* way to set up a
We all know the flaws of the current setup, however, as I try to show
with Eccentric Authentication, that setup can be replaced with something
different! With different security properties.
Regards, Guido.

@_date: 2016-11-19 12:38:28
@_author: Guido Witmond 
@_subject: [Cryptography] On the internet, 
Hi Ray,
I've asked myself these questions too and I came up with what I call
Eccentric Authentication, a protocol to make it possible to mutually
authenticate a stranger and a well known identity.
Classic cryptography assumes there are two (or more) parties (Alice and
Bob) that know each other and need secure communication trough an
non-secure network. The meet upfront and agree on a protocol and
exchange keys.
That model doesn't work on the internet, as *there is only Alice*.
On the internet, there are a well known entities and lots of strangers
who want a secure connection with some well knowns. The strangers need
to be able to authenticate at a well known site, the site needs to be
able to recognize (authenticate) recurring visitors reliably.
See my blog:
My protocol implements the well known entities by using a private CA for
each site. It signs the server certificates and client certificates. The
Root certificate goes in a DANE-record. The CA is the identitiy for the
site, user know sites by domain name.
The user runs a user agent (a browser?) that verifies the DANE-record
against the server certificate at connection time.
When the site requires a user to log in, it points to the site's CA
where to get a client certificate. Users can get one - for free - when
offering public key and a nickname. The CA signs a certificate with the
nickname and returns it in a single https
request/response. Now the user can log in.
The protocol describes a verification service that detects sites who
cheat by signing mitm-certifcates for their users.
Given this protocol, the private CA, the verification service and the
user agent, it's getting much easier for the users:
- easy signup;
- users remain anonymous; ( a new key pair and different nickname per site)
- sites that post signed messages from users become key echanges;
- that leads to end-to-end *authenticated* private messages;
- that leads to independent private channels through Tor, invisible for
the site.
- these channels remain, untouchable by anyone except the two participants.
On local hardware reliability:
As Thierry Moreau mentioned:
To solve this, I forsee that we need to get rid of the Unix-model of
ambient authority and move towards explicit authority, such as
Genode.org provides. That makes it easy to run untrusted software in a
sandbox without any risk to the keys to the kingdom.
It's all on my site: eccentric-authentication.
Try the demo:
With regards, Guido Witmond.

@_date: 2016-11-27 23:45:49
@_author: Guido Witmond 
@_subject: [Cryptography] On the internet, there is only Alice. 
[Now as a separate threat where this belongs....]
Dear List,
Classic cryptography assumes there are two (or more) parties (Alice and
Bob) that know each other and need secure communication trough an
non-secure network. The meet upfront and agree on a protocol and
exchange keys.
For example, if I want to open a bank account, I visit a branch office,
show my government issued ID and get accepted (or not). I create a
password, receive a TAN-generator and go home, ready to do internet banking.
However, that doesn't work with online banks. There is no branch office
to visit. So I need to make sure I connect to the correct server, ie. I
need to be able to authenticate the bank, tell it apart from the other
banks and criminals.
The classic model doesn't work online, as *on the internet there is only
On the internet, there are a well known entities and lots of strangers
who want a secure connection with some well knowns. The strangers need
to be able to authenticate at a well known site, the site needs to be
able to recognize (authenticate) recurring visitors reliably.
See my blog:
My protocol implements the well known entities by using a private CA for
each site. It signs the server certificates and client certificates. The
Root certificate goes in a DANE-record. The CA is the identitiy for the
site, user know sites by domain name.
The user runs a user agent (a browser?) that verifies the DANE-record
against the server certificate at connection time.
When the site requires a user to log in, it points to the site's CA
where to get a client certificate. Users can get one - for free - when
offering public key and a nickname. The CA signs a certificate with the
nickname and returns it in a single https
request/response. Now the user can log in.
The protocol describes a verification service that detects sites who
cheat by signing mitm-certifcates for their users.
Given this protocol with the private CA per site, the verification
service and the user agent, it's getting much easier for the users:
- easy signup;
- users remain anonymous; ( a new key pair and different nickname per site)
- sites that post signed messages from users become key echanges;
- that leads to end-to-end *authenticated* private messages;
- that leads to independent private channels through Tor, invisible for
the site.
- these channels remain, untouchable by anyone except the two participants.
Guido Witmond.
