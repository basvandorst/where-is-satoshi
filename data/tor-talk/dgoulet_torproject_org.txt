
@_date: 2018-04-16 09:51:28
@_author: David Goulet 
@_subject: [tor-talk] V3 censorship ? 
And I would also be very interested in learning if your tor process was under
a lot of load once your v3 got public?
Do you usually have a lot of users going to these v3 once public? That is, are
you expecting many users or it is mostly for yourself? We could have a
reachability bug for a v3 under load like George pointed out.
Logs would be great for us to learn more :).

@_date: 2018-02-12 11:08:41
@_author: David Goulet 
@_subject: [tor-talk] torified nodejs: server crashes 
On 16.04, "torsocks" package is 2.1.0 which old so first thing you might want
to do is try the latest that is torsocks 2.2.0. Building it from source is
probably what you'll need to do (see the README.md in the tarball):
Sig: Difficult to say. What I would do is open a ticket on trac.torproject.org
under the "Core Tor/Torsocks" component if possible. If not, you can always
email here some more details about the segfault.
If you could do a couple of things and put those on the ticket or here.
1) Try this:
$ TORSOCKS_LOG_LEVEL=5 TORSOCKS_LOG_FILE_PATH=/tmp/torsocks.log torsocks nodejs [...]
2) I have no idea what are the implication of using gdb with nodejs but you
can try to use it and see where the segfaults happen:
    $ gdb nodejs
    set follow-fork-mode child
    set environment LD_PRELOAD /path/to/libtorsocks.so
      ["libtorsocks.so" is usually in "/usr/lib/torsocks/libtorsocks.so" or if
        you built it from source, will be in
        "/usr/local/lib/torsocks/libtorsocks.so"]
    run
Then once you hit the segfault, use "bt full" to get a stack trace and put it
on the ticket.
3) Finally, you could also use strace to see if it is within a syscall that
torsocks hijacks that exploded:
$ strace -f -o /tmp/strace-torsocks.log torsocks nodejs [...]
Hope this help! Just a quick note, making the full nodejs work with torsocks
could end up being quite complicated. You should also consider a way to use
nodejs SOCKS proxy option (if any) instead and make your application use Tor
socks port.

@_date: 2018-11-19 10:55:49
@_author: David Goulet 
@_subject: [tor-talk] [RELEASE] Torsocks 2.3.0 
Hello everyone!
Been a long time since a torsocks release! Many fixes went into this new
version which all came from volunteers so huge thanks to you all for this
work! ChangeLog below for this version.
Please, let me know about any issues! I can't build on all systems so anyone
testing this on Mac or/and BSD* would be great! We'll do a 2.3.1 release if
anything comes up.
2018-11-19 torsocks 2.3.0
  * Fix a bunch of stuff in the wrapper script,   * gethostbyaddr_r: always assign result
  * log: Remove log line when logging is stopped
  * gethostbyaddr_r: Don't put garbage in data->hostname
  * gethostbyaddr_r: Populate h_addrtype field
  * log: Avoid crash or file corruption when closing logs
  * connect: Always pass .onion IP cookie to connection object
  * Merge remote-tracking branch 'yawning/bug23715'
  * Make torsocks always connect to the configured Tor port
  * test: Make getpeername test connect to moria1
  * socks5: Always use ATYP 0x03 for CONNECT command
  * Merge remote-tracking branch 'upstream/master'
  * doc: Clarify the libc limitation in README
  * accept4: Initialize libc symbol early
  * Bug 23715: Support memfd_create(2).
  * test: Detect if tor is running in test_fd_passing
  * No tab in the README
  * Merge remote-tracking branch 'debian/bugfix/typo-subsytem'
  * Merge remote-tracking branch 'debian/bugfix/typo-catched'
  * Merge remote-tracking branch 'debian/bugfix/typo-conect'
  * doc: Add autogen.sh step to README
  * Add a -q/--quiet to torsocks
  * tests: Add a check for a running Tor
  * Make cpp conditional for definition of handle_mmap match use
  * utils: Add useful function for later use
  * man: Some words were missing
  * Remove clang warnings
  * Add missing quotes to variable in torsocks.in
  * Fix check_addr() to return either 0 or 1
  * Ignore stderr for getcap command
  * syscall: Add seccomp, gettimeofday, clock_gettime, fork
  * Fix typo: conect → connect.
  * Fix typo: subsytem → subsystem.
  * Fix typo: catched → caught.
Git: Tarball: (sig:

@_date: 2018-09-17 11:46:33
@_author: David Goulet 
@_subject: [tor-talk] bug in tor 0.3.4.8? 
Hello Udo,
I've opened  with this
Quickly like that, I can't tell you why this is happening or any workaround
you could do so keep an eye on the ticket. If this is an 0.3.4.x regression,
we'll find it quickly.

@_date: 2019-12-16 08:28:02
@_author: David Goulet 
@_subject: [tor-talk] Dos defense .0.4.2.5 
These options need to be *under* the "HiddenServiceDir" since they are
specific per HS.
If it still fails, maybe providing the output of the error?

@_date: 2019-10-16 11:20:50
@_author: David Goulet 
@_subject: [tor-talk] more '8443+443' relays; MS3c relays; 
Bad relay team has asked the dirauths to reject these relays from the network.

@_date: 2020-01-06 09:17:30
@_author: David Goulet 
@_subject: [tor-talk] Help setting up tor dos defense 
The above looks fine. I will expand on these defenses since it has been a
recurrent theme lately:
There is unfortunately a catch with these HS DoS defenses and it has to do
because of a safety issue namely the "partition problem".
Tor relays supporting the HS DoS defense (intro points) at this point in time
are not in majority. Basically >= 0.4.2.1-alpha relays do support it which
currently represents ~36% in bandwidth weight so roughly 1/3 of the network.
If a service enables the defenses (like you did above), it will NOT
specifically pick intro points supporting the defenses but will normally pick
intro points as it did before and _if_ they happen to support the HS defenses
(via protocol version "HSIntro=5"), then they are used. Yes, I agree, not
ideal but there is a valid reason.
This is in part to prevent partitionning onion services using the HS defenses
to a specific set of relays (those who support it). Bottom line is: if the set
of relays that can only be used by an onion service is reduced, attack surface
gets bigger.
As the relay in the network upgrades to latest stables, the network naturally
move towards supporting these defenses in majority. This is another
_extremely_ important reason why relay operators should stay up to date with
their tor application so the network can be more agile in deploying defenses
and improvements.
Now onto "what this defense really does for your onion service?" question:
Lets assume the attack here is a client DDoS meaning there are a gazillion
clients trying to reach your service. Unfortuantely, this can bring down a
service as it will be unable to cope with the amount of requests due to a
number of factors that I will not cover with this email. More importantly, his
has an immense toll on the network itself that is affecting everyone.
What this defense does it to limit the number of client request that can
*reach* the service by imposing a rate limitation at the intro point layer.
In other words, this is primarly a defense to protect the _network_ which
soaks in the extraneous client requests at the "edges" of the network (in this
case more at the "edges of the onion service").
The main benefit for the service is that it will not be under heavy load and
thus will still be usable/reachable for some definitions of "reachable".
Because bad vs good client requests are basically indistinguishable at the
intro point, legitimate clients get caught in this rate limitation resulting
in them having a hard time to reach the service that is under attack.
But, if your service happens to be under attack on a single .onion address but
is configured with many more .onion, then these defenses makes it that through
the other .onion addresses, it will be reachable without any problem which
wasn't the case before.
All in all, the network pressure is massively reduced due to this defense
which overall is critical to the anonymity and stability properties of the
Onion service reachability under DDoS is a hard problem and being researched:
Hope this help!

@_date: 2020-01-14 07:55:02
@_author: David Goulet 
@_subject: [tor-talk] Help setting up tor dos defense 
Correct. A burst or rate that is 0 or crossing the upper limit, the intro
point will disable the defenses because the parameters received are unusable,
it does not fallback to the defaults.
The good news is that the torrc config parser should prevent you from putting
insane values but at the protocol level, it is still possible of course.
Just setting "HiddenServiceEnableIntroDoSDefense 0" is enough to disable the
defense even if the consensus set it to 1.
The intro point always use what the service specifies. If nothing present,
then the consensus param is used.
So for the case that the service sets "HiddenServiceEnableIntroDoSDefense 0",
then that value is sent to the intro point indicating to disable the defense.
Hope this answer your question
