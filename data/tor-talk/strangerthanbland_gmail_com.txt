
@_date: 2016-01-31 18:21:37
@_author: Michael 
@_subject: [tor-talk] Scripted installer of Tor and more being worked on 
I'll happily aid in testing and coding a Python translated version
if we can find an easy way of adding it to a custom build of BusyBox
or installing from source onto Android without chroot. My biggest
concern is portability and compatibility with as many devices as
possible because I plan to make a "BadUSB" and "ADB" wrapper. I've begun documenting the configurations that the current
version outputs into a project Wiki to help anyone that wants to
help get a jump on translating to any other languages while I continue
to add the remaining features ~
~ and here's a link that may turn some of those frowns ya mentioned upside down, as it documents the custom set of
Bash functions that where written to make things a bit easier
to maintain. ~
~ Even if the current project moves to another language the above
should give frowners a reason to grin when they understand how
this can be used for "niche circumstances" on other projects ;-)
for the most part this script pack is a just a very simple set of `if`,
`for` and `case` statements so translation should be a trivial task.
The "haters" are more than welcome to, so long as the emotion
can be channelled towards building something constructive with
this project I've no reason to dissuade them from their feelings.
Truth be told if I didn't already know that Java would have received
more push back than Bash I would have tried to express this in ~ because it offers a more visual way of showing scripted logic.
But I've seen how people cringe at I2P's use of Java so I went to
what I knew to be pretty universally understood so that we can have
the logics and configurations mapped out without confusion and suspicions getting in the way.
Thanks David, I may need much in the way of luck in the future.
The "cross pollination" of education is exactly what I was hoping
for and from checking out what others have started or "stared"
I've already seen a few things I want to add as options for installation from this project such as ~
- for some hardcore filtering rules
- and this looks to be an amazing delivery system that "whistle blowers" could use for initial publishing of information.
- And one of the best BTC+GitHub combos I've seen, which I may use
for this project in the future so code maintainers get something for their
contributions automatically.
~ in short I'm learning a great deal from you all and am very
thankful for it.
For all readers I've a few Q's that could use some A's,
I've been working on the firewall scripted portion of this project ~
~ so far as I know Tor nodes use only TCP protocol (even for DNS?)
so I'll be adding each node's various ports via ~
` _tcp_ports="${ _tcp_ports},${_some_tor_port1},${_some_tor_port2}"`
~ and then have the `for` loop in ~
~ and it's in/output counterparts for IPv6 to parse which
ports will be opened and or forwarded through the firewall.
My biggest questions are with forwarding chains and where to
place jumps to these filtering chains from the default iptables forward
chain for best performance. For example should `in_tcp` be used on `preroute` or `forward` chain?
And should the `out_tcp` be used on `postroute` or somewhere else?
Having an answer to these questions will allow me to push forward
with having a "proof of concept" version completed for not just
Tor and related software but also allow for "jailing" various packages
from one another on their own bridged network interfaces to keep
security breaches a bit more contained.
My last question (for now) has to do with Fail2Ban and hidden services.
My question is would you all prefer that separate jail.local configuration
blocks be written for each Tor service port individually, ei failing one port
doesn't ban from a possible second hidden service port, or is a fail one
ban'em all sufficient?
I see that the first option would make it harder for an attacker to be 100%
sure that two hidden services lead to two ports on one physical machine.
But would allow for repeated attacks on all available ports before all filters
ban their interactions.
And I see that the second option would limit attack surface but would also
allow for leakage of info as to what hidden services might be running on the same device. A tough call so I'm all ears on how we should proceed.

@_date: 2016-01-31 19:00:05
@_author: Michael 
@_subject: [tor-talk] Not able to download Tor to droid 
The Android apps I can suggest is "Orbot" ~
~ use the links or search on Android's Market or on GitHub for source
on Orbot and Android's Market or "f-droid" for Orfox ~
Orbot is a well maintained port of Tor and Polipo and is easy to configure via app's GUI.
For those that like `vi` or `nano` the torrc files are under ~
~ there are torrc, torrc.custom and torpolipo.conf files that maybe configured manually.
Orfox is a port of Firefox that comes preconfigured to auto-start Orbot :-) supper easy.
Just go to `about:config` in Orfox's address bar and search for "socks" and "proxy"
with the on page's search bar to configure Orfox to use custom ports if needed.
Bonus app for those that don't play with iptables custom chains much ~
~ this and a few apps like it can make your life much easier for building a solid
firewall configuration for Tor browsing without a whole lot of typing or technical knowledge.

@_date: 2016-02-05 19:31:10
@_author: Michael 
@_subject: [tor-talk] Scripted installer of Tor and more being worked on 
Cool, I'll be setting some of that up in the next few pushes for fail2ban configurations, likely after fleshing out the firewall scripting more as they'll use similar matching statements for ports. I'll be setting a default of 10 minuets (600 seconds) for ban times and have commented lines printed under each configuration block for easy modifying after script run time.
I looked into Python and some of the steps to go through on translation to another language, there doesn't seem to be an effective way of translating case/switch statements; lots of discussion and workarounds. Ruby is looking to be a simpler switch and I may pursue this as an alternative. Either way I'll be sharing notes on how I'd translate portions in the Wiki as I find good examples. For Python
it looks like a lot of rewriting case statements into if/elif
but for Ruby it looks like a few syntax changes and the
use of `put` or `printf` in place of `echo` for reading out info to the user.
I've also been looking further into encrypted partitions for chroot jails via `dm-crypt` but have yet to find a solid way of setting the first passphrase through a script (unless piping an echo of it is acceptable); everything else is well documented enough to script though and I'm already working on how best to scrub the `/${USER?}/home/.bash_history` and other logs of script runtime information that is sensitive.
I could use suggestions as to whether or not encrypting a chroot jail fully or just specific directories would be preferred; ie just a user's home directory or a web server's jail? Either way I'll also have to leave notes in the logs on how to resize encrypted partitions &/or write a wrapper for doing the task within the main script pack; looks like the difference between `>` and `>>` on whether or not a partition is overwritten or appended to when expanding. If there are suggestions on `dm-crypt` options, ie algorithms, partition size defaults, whether or not to use `/dev/random` or `/dev/urandom`..., that should be default behavior I'm all ears before I get into drafting this part up.

@_date: 2016-01-19 14:29:48
@_author: Michael 
@_subject: [tor-talk] Scripted installer of Tor and more being worked on at 
Salutations Tor,
I've something special to share with you all; regardless of if you're a node operator, hidden service provider, client or completely new to Tor installation and configurations... in short... a script pack aimed to install and configure the previously listed node types and then a little more.
But because this script pack may not work just yet, I've also posted a quick guide at the following link for how to take useful bits of the source code and rewrite variable assignments to positional arguments for specific node requirements.
~ Note the above linked code only covers in detail how to setup a trans-proxied bridge for a Whonix related question but the steps should be similar if an exit node or hidden service is wanted instead. Everything so far is written such that those familiar with 'bash' scripting should be able to read scripted logic without to much effort, and those not so familiar with this scripting language may, with documentation, be able to understand with moderate effort. My hope in contacting you all is that we can start a dialog as to where this script pack should head in future developments and what can be improved upon with the current version.
Readers of this message have permission to take what they wish and make of it what they will so long as links to the repo and relevant [~/info/program_name] links to original code author's documentation are included in your source code as well; because it's polite to the original authors of guides resourced and I've make it easy to copy and past it all. I'm publishing this on GitHub, and other open forums, such that this code maybe taken over if my health again takes my hands away from being a creative force. Nearly every resource used to write this script pack can be found within the repo's [~/info/] directory, nearly every file contains only one function that has clear documentation bellow (commented out with ' marks) describing what that bit of code is intended to do, what variables are used, and how they are assigned. The configurations and installations for packages are found under directories with the same name, for example Tor installation and configurations are under
[~/functions/tor] and the same for Polipo or Privoxy. And for those wondering where some of the magic is hidden, look no further than [~/functions/shared/] directory as the functions there read things about your distribution and networking; non of which is shared by the way unless you post it somewhere your own self.
The list of things left to do is long for this to be considered finished, this list will be updated as feature requests and bugs are submitted, and hosted within the main [ReadMe.md] file. Anyone who wishes to fork the code's branch may also submit pull requests, I'll happily accept some help, but it'll be up to editors and authors to add themselves to the list of credits in the [~/info/] directory; that is if they wish to make it easy to track contributions.
Note those of you that are browsing the code now while reading this my come across directories and files that are not currently called by the main script, such as [~/functions/whonix/] directory and a few others, these are script parts that have yet to be incorporated and serve as a reminder to myself of where to pick up on each application when coming back to it to make more additions. Some are more fleshed out than others but most are not functional just yet. Additionally there's a directory in the root of the repo named [/scriptlets/] the scripts contained here are for the most part functional but not really needed in the main script runtime.
Here are some example commands to get everyone started;
bash Sandcastle.sh -h=Install_Apt
- Print help documentation on function named "Install_Apt" and exit. Additionally multiple functions maybe inspected before exit via
bash Sandcastle.sh -h=Install_Apt,Arg_checker
~ or via
bash Sandcastle.sh -h='Install_Apt Arg_checker'
~ note the [-h=some_function] is the same as [--help=some_function], all the options written so far support long or short hand ways of asgning values, and most have the ability to parse through lists of values and a few have sub options within.
bash Sandcastle.sh -vf=client_torinstall_vars.sh
- Tor client with DNS server to aid in preventing DNS leaks via variable/configuration file. Note more than one file maybe loaded if you wish to keep things organized that way, just separate files like so [-vf=variable_file_one.sh,variable_file_two.sh,variable_file_three.sh]. The above is much like the following but with less commands to process.
bash Sandcastle.sh -A=tor,privoxy,squid,bind -C=8 -T=client -I=aptget
bash Sandcastle.sh -A=tor,privoxy,squid,bind -C=8 -T=client,service -TST=auth:ssh -I=aptget
-Tor a client plus hidden ssh server that also has Tor auth-tocken required to prevent script bots from easily achieving a connection; will configure two start/stop scripts, one for your client connections [/etc/init.d/tor_client] and one for your ssh server [/etc/init.d/tor_auth_ssh]. You'll end up with start/stop scripts for Tor named [tor_client] and [tor_auth_ssh] under [/etc/init.d/] directory and for Privoxy, Squid and Bind the start/stop scripts' names will be unchanged, however, if previously installed these files will be backed up prior to overwriting.
bash Sandcastle.sh -A=tor,privoxy,squid,bind -C=8 -T=client -OSP=22 -SHN=hidden_ssh_server -SHD=domain.onion -HAC='hidden_auth_token with quotes if spaces are present' -I=aptget
- Tor client plus hidden ssh client to hidden Tor authenticated ssh server made above. Note [-HAC=...] is only required if connecting to an ssh server using Tor and authorization tokens, additionally this may be used to connect to non-[.onion] domains too. Not only will you have a shiny new [tor_client] start/stop script under [/etc/init.d/] directory, you'll also have a custom [ssh_config] made under [/home/${USER}/.ssh/] directory (the user variable is set by [ : ${USER?} ] quarry near the beginning of script run time) and as always original files if present will be backed up.
bash Sandcastle.sh -A=tor,polipo -T=bridge -TBT=private -Lipv4=192.168.1.5 -B=Bridge_nickname -I=aptget
- Tor bridge for local NAT, trans-proxy hotspot, or in Whonix terms "gateway" on separate hardware. Note I'm still working out how best to implement internal NAT routing for assigning client IP addresses, in other words "some assembly required" to get this part working.
bash Sandcastle.sh -A=tor -T=bridge -TBT=public,authoritative -Eipv4=1.2.3.4 -B=Bridge_nickname -I=aptget
- Tor bridge for public use plus authoritative mirror for network traffic queries. Note if you do not supply [-Eipv4=...] and it is needed you will be prompted for it, and if you leave that prompt blank then OpenDNS will be queried for the needed information. Additionally I'm working on IP version 6 options such that [-Eipv6=...] maybe recognized in future revisions.
bash Sandcastle.sh -A=tor -T=exit -ipv6=yes -Eipv4=1.2.3.4 -Eipv6=f:8:::9:1 -E=Exit_nickname -I=aptget
- Tor exit (restrictive policies) with IP version 6 enabled. Note this is where things are even less finished and I'll be fixing on the next series of code pushes. Mostly you'll want to have already installed and hardened the web server used to push exit notices to the quizzical that connect back to your exit's IP address; ie sysadmins wondering why you seem so interested in their IP address.
Notable features and how to find their related code blocks;
- Already detects if running within chroot Linux inside Android but not all required permissions may have been set for the [aid_inet] user/group. To find how this is done refer to the function within [~/functions/shared/check_host_enviroment.sh] for Android chroot detection and [~/functions/shared/fix_android_inet.sh] for Android permissions additions. I've tested this with two methods of running Linux on root enabled Android but more testing of other apps would be helpful in assuring it works across all devices and chroot/shroot methods.
- Already detects if arguments have been passed via [--var-file=/some/configs.sh] or [--arg1=option1] and both may be mixed, see [~/functions/shared/parse_varfile_load.sh] for where script expects to find configuration files and see [~/functions/shared/arg_checker.sh] for how arguments are processed in general, however the order in which you pass arguments vs. config files does matter if using both.
- Reports and log errors if any as well as print related help documentation for the section that errors where encountered, see [~/functions/shared/parse_help.sh] for how help docs are auto-pulled from erroring function and [~/functions/shared/error_generator.sh] for how error logs are written. - Does not touch currently configured torrc files or any configuration file without first backing up the original, additionally for Tor specifically do to the installation methods used to activate the various options, this script shouldn't have to touch your default files if you've already installed and configured Tor; see [-/functions/shared/overwrite_config_checker.sh] and [~/functions/shared/overwrite_init_checker.sh] for how configurations are preserved and for Tor specifically see [~/functions/tor/lib_activations/activate_torrc_nonclient.sh] and [~/functions/tor/lib_activations/activate_torrc_client.sh] for how installation process is manipulated to be nondestructive to previously installed Tor services. Other packages that require it will have a similar directory and script naming convention in their related package directories. This means that care should be taken to not run Tor over Tor and that the default Tor start/stop script should be deactivated if enabled on user login
or system boot if the new configurations are preferred.
- Upon successful installation the variables used will be output to a custom configuration file such that once a user figures out their own perfect settings this custom configuration file can be used to quickly rebuild the same or very similar configurations on another device, see [~/functions/shared/output_variables_file.sh] for where these are saved by default. Additionally these configuration files, if scrubbed of personal info, maybe shared with others such that they can replicate the same kind of node setup.
- Additional features such as adding your own functions from outside the script's working directory is also permitted as well as loading available functions without calling them right away. The [arg_checker.sh] function and main function within [Sandcastle.sh] file handle how this is preformed and is enabled so that future editors may load modifications or new features, for initial tests, without having to save these mods inside the script's working directory. In other words "plugins" are allowed from the first commit on GitHub; this also allows for authors of new features to keep their code separate from the main project, for example privet GitHub repos if so desired.
Thank all you for your time and attention, I know this was long to read but hopefully after checking out what I've shared you'll see it as time well spent. Feel free to ask questions, I've attempted to cover most of the foreseeable ones, and I'll get back to you as time and health allows. I will be testing and debugging this on various VPS instances and physical devices that I've at my disposal over the coming days and look forward to your responses.

@_date: 2016-01-20 16:26:51
@_author: Michael 
@_subject: [tor-talk] Scripted installer of Tor and more being worked on 
Coderman, most welcome. To answer your question on port binding; that's a bit tricky, and depends on what types of Tor nodes are chosen. Oh and the most up to date documentation for variables and script arguments can be found in the [ ~/variables/ blank_torinstall_vars.sh ] file, I'll have to rename it and/or split it up by package name latter (much like the default variables files) as well as do more edits to ensure that it nulls all variables on exit.
 - for bridge torrc files this is assigned within the `case` statement and only if "public" subtype was selected; sets to port "0" by default to keep public out of your bridge's socks. I'll have to read up a little more on security issues/mitigation for bridge nodes in relation to socks port. More than likely the "privet" bridge option will be making use of Polipo so I'll be sure to at least add a bridge socks port option soon.
- for client torrc files this is assigned within the `for` loop starting at port 10010 on line 11 for SocksPort, ie [ SocksPort 100${_tor_count}0 ] and counting up to the number given via [-C=4] command which also maybe assigned with [ _connection_count =4 ]  within a configuration file passed with [ -vf=some_config.sh ] command. This same value is also used by Privoxy so I'll have to write a few sanity checks and edits before adding a client socks port prefix option. For [ SocksBindAddress ] and listen and accept policies I'll be adding two new options [ -TSBA ] and [ -TSLA ] for binding and listening and then use some scripted logic for acceptance lines... oh well that wasn't to hard :-D next code push now includes these last two options.
- for exit torrc files this like public bridges is set to "0" as well as setting the socks acceptance policy to reject by default. Note next code push will now include variable [ ${_tor_dir_port:-9030} ] set by [ -TDP=9030 ] for assigning torrc's DirPort. Additionally I've added some checks for binding to the external and local IP:Port or Port alone (makes Tor guess) for config lines like [ OutboundBindAddress ], and the [ -TOP=9001 ] or [ ${_tor_or_port:-9001} ] has been corrected for assigning the ORPort. I still have to add a `for` loop for IPv4/v6 [ ExitPolicy accept ... ] to allow for adding more ports than just the restrictive policy list currently coded for.
- for hidden service torrc files socks ports and addresses have not even been set yet but it may be best to disable it completely.
If you happen to know which versions are incompatible with Tor port binding configuration or where I can find this info I can add another set of checks based on Tor version where needed.
Thanks for taking the dive into the code Coderman, more eyes are defiantly better when dealing with this many lines of configurations.

@_date: 2016-01-21 00:17:25
@_author: Michael 
@_subject: [tor-talk] Scripted installer of Tor and more being worked on 
Hey David, thank you for the link to the Ansible project; I'll be reading up on how they suggest setting up relays and perhaps add in an option for using their code instead if dependences are found to be met on the host system. I may not know the language that they're using but the syntax isn't incomprehensible either.
To answer your question as to why I'm using `bash` for this script's logic is kinda multi-parted but boils down to minimal dependencies, easy of readability and stealability. Oh and `bash`ing sandcastles is a bit more fun than other ways of starting a script; I'd have to think of something clever for a new script name.
- It is a goal of mine to have the list of dependencies for running this script pack down to a working BuysBox provided `bash` shell because my devices range from fully capable Linux desktops down to Android devices with very restrictive permissions.
- For readability, most Linux users are familiar with the command line interface, and even if not they've at least had a guide or two that they've had to copy and past from to get things done. This script pack is designed such that nearly any individual line maybe pulled out (and so long as variables where preassigned) and inspected for what they really do. For example if we inspect the [ Install_Apt ] function's way of recognising if an application is already installed we can check various bits of logic from the command line; such as part way down into these checks ~
if [ -f $(which $_app) ]; then echo "Application [$_app] is installed."
~ this can be re-expressed in a "one-liner" too ~
if [ -f $(which $_app) ]; then echo "Application [$_app] is installed."; fi
~ and so long as a value was assigned to [$_app] then either version will print if the application is already installed. From there it's not to hard to then see that if the application was not detected it is then added to the list of ones that should be installed further down via `apt-get` command.
- And for stealability, the individual functions are designed such that with very little modification they maybe repurposed into other script writer's projects. The link shared in initial email explains the methods that maybe used to rewrite for specific Tor node types, here it is again for anyone that doesn't want to have to track it down again.
~ I don't assume every person is going to want the whole kit nor do I presume to believe that those that want it wont just take it regardless of how easy it is to rewrite; so I prepared as many was as I could think of to make this easy to take and or add to.
- Lastly `bash` is the "scripting" language (I know some don't see it as a real scripting language) that I understand best. To keep myself from frustration on learning another language and debugging it when it does thing's that I didn't intend I've kept myself to writing in `bash` in such a way that shell version shouldn't matter to much.
For complete automation I'm leaning towards writing in some custom modules into Metasploit and BEeF such that I can have a WiFi hotspot that "upgrades" devices that connect to it (think of it as a "privacy party"), as well as the "BadUSB" auto-exploiting device, featured in the following link's kit
~ for automatically installing Tor and related software off a USB drive without even touching keyboard or mouse... pen-testers who have been encouraging their clients to disable USB ports are likely to enjoy that once this is completed :-D demonstrating a reverse ssh terminal to a ~.onion domain from inside the corporate network should prove to be very, motivational, towards better physical security practices. However, I don't see much defence against a LanTurtle properly setup, that would require the corporate network to monitor very closely what types of traffic flows normally but even then defence could not be 100% as these devices could assume an already known address on the network (MiTM style) and only use either unpublished bridges or a VPN for the first hop. While it may seem dangerous to pack Metasploit with Tor I don't have qualms with using tools for... unanticipated problem solving... that and some of those I know could be trusted to have the correct mind set about
utilizing the Tor network (ie not downloading or clicking without thought and not using clear net based accounts) but I don't think would be comfortable with setting up their own client nodes without a nagging perinoa of having missed something. Having a USB key for setting up nodes would allow for more time kicking-it and less time spent plunking away at their sticky keys.
I did take a quick look into `bcfg2` and unfortunately the CPU architectures that they list don't seem to include ARMel or ARMhf, here's the compatibility list I found ~
~ and that's a bit prohibitive when I do a lot of development on unsupported hardware. But that is not to say that you or someone else couldn't write a parser for translating what has already been written in `bash` to be instead be written in `bcfg2` form. The general format of the `bash` scripts wont change much so a translating script would allow for updating your branch's code much quicker than line by line manual translation of scripting languages.

@_date: 2016-01-21 17:16:09
@_author: Michael 
@_subject: [tor-talk] Scripted installer of Tor and more being worked on 
Apologies David, I often am to long wended but will endeavor to be a bit more to the point in the future but I may fail as words are an not always the most efficient form of communication.
Indeed Bash is what I use because it's what I know. While I've studied a bit of Python (enough to read and mod pre existing code) I've not become savvy enough to write fully fleshed out code with it; had to become familiar with other languages up to this point too but rarely have to pursue it further to get a task done. Totally valid points in favor for Python, or really any real programming language, both have been challenges that I've had to bodge solutions for while writing in Bash. Error handling currently is spread across three separate functions and uses `||` redirection to detect failures (which it does an okay job at but can still be defeated) because like you've already stated `set -e` really doesn't count and unit tests are no contest in favor of another language as the current methods of testing one logic train individually would require a code rewrite or pulling just the required shared functions out and rewriting the installer script a bit. While I've attempted to
mitigate for what Bash lacks through the use of custom functions and loading only what is needed for each task; I know full well that it ain't pretty nor ideal, but as I haven't seen anyone else tackle it in a comprehensive manor on all fronts it seemed like a good idea to take a shot at it.
Heh, ok I've reclassified that memory "I read it online somewhere..." :-D instead of true and will look into bcfg2 further. It seems like Python wouldn't be to big a jump but it will increase the script's dependencies beyond base Linux or BusyBox depends that I aim for... but then again just a Bash written installer for Python and having the rest of the code in that language may allow for easer future modifications. I'll help maintain the code if it is translated but if ya wait on me to rewrite it'll be awhile as there's still almost an equivalent amount of data as the current script trapped in notes form waiting to be scripted for Fail2ban, Apache, and two other privacy centric networks.
Yeah that would be part of the solution that Tor's network brings to the table, the other would be that for those on the penetrated network it would be more difficult to figure out to whom that box was reporting to or where or what information it is reporting. Definitely take a look into Metasploit's reverse ssh and other payloads, they use IPs or domains but ~.onion or ~.i2p options currently are not supported.
Danger I see is, as with any tool, when with mal intent. Currently, well as far as I have been able to read, Metasploit doesn't have a payload available that installs Tor onto a target device; ya have to have a static IP or regular domain to point the remote and local host values to. While there are tricks to get around this , ie VPN chaining, they require a much larger scope of knowledge to setup correctly and seems to me a waist of time and resources when there's a network already available for routing. I'm not encouraging anyone to go out and do harm with either set of tools but I will encourage that everyone have a healthy paranoia of these tools being used for ill; encourage it to the point of trying to make it a bit easier to test your own networks against such things before someone does it for ya. That is the more dangerous application of such a combination that I could think of but I come from a background of using exploits on my own devices in order to obtain more
functionality; for example I happily root all my past upgrades (phones) such that they can be used for various local network monitoring among some even run as good security cameras that can be checked up on when away from home without divulging to a secondary ISP (such as Motel WiFI) of where or what I'm checking up on. Metasploit seems to me would pair well with Tor because it would allow for "upgrading" routers among many other consumer products remotely as well as providing resources for testing the results. The over all goal is to have my nodes testing their own vulnerabilities and reporting types of behaviours back so that various monitoring tools can have profiles updated for what to look out for, I know this will be impossible to fully mitigate but certainly improvements can be found through throw testing. Tripwire is a good candidate that I've found for reporting after the a break-in and Selinux as well as Apparmor I keep finding and taking notes on for further limiting
damage as well as reporting (I'm very open to suggestions for other tools). Tools such as these are the next set of pieces that I'll be working on. For example if I'm running a specific browser within a sandbox (Firejail seemed like a good candidate for this but there's issues I'm still debugging for ARMhf) in addition to other mentioned tools and I then run Metasploit+BEef against it I want to be able to profile the damage that can be done when each layer is complete and have a set of reports that can be shared with developers. The reference to clearnet vers non would be that the information or puzzle peaces used to put this together are all there published online and unhidden by anonymouzing networks, ie literacy plus time and a browser and the same can be put together for a specific purpose.
On the subject of injection attacks; I'm all ears on how best to add mitigation or protection against local and remote attacks. For some of the local networking I've been trying to monitor for "good-by" packets from "routers" I've setup to assume the same MAC & BSSID but without doing some auto-magics with rotating these identifiers on both router and attached clients I don't see an easier way of preventing local/drive-by MiTM attacks. For the remote attacks I've no direction of research just yet opened other than being cautious about browsing and clicking as well as using a few plugins for not loading content from the same domain kinds of things. Some of the options I've come across for local proxy filtering looks promising but only against known malware venders, much like running a custom hosts file.

@_date: 2016-10-26 01:17:13
@_author: Michael 
@_subject: [tor-talk] A way to reduce service impersonation 
Well I took a look into the code, not my primary language but readable, and have some concerns and some suggestions...
# Concerns
Opening signing up to an API is a very bad idea especially if the server administrator is using keys vulnerable to "known word" attacks, below is a link to the severity and key types effected.
While sub key use may mitigate this; the whole concept of clients sending data for servers to process is fraught with danger... I will confess that I didn't read deep enough into the servers' side to inspect if the received strings where being scrubbed, nor do I have the expertise to know what that would look like in Python but I've enough knowledge to know that it's though no matter the language.
# Suggestions
- Instead of clients sending a block to be signed have them ask for a signed block and have the server make up some sudo-random string to sign.
Here's how I'd do it in bash for one off blocks of junk data
    for _count in $(seq 1 3); do echo "$(base64 /dev/urandom | td -cd 'a-zA-Z0-9' | head -c32)"; done
However, be warned against allowing clients to bombard servers with request to build random blocks because this could rob the server of needed entropy.
- Instead of the whole public key being presented consider using the "long format" key fingerprint IDs because then clients may have more choices in where to download a copy for validating the signed blob. This last suggestion does pose more risk to clients' key downloading behavior being linked like a DNS-leak but as you're targeting users already making use of Tor they should be relatively safe in downloading keys though those channels.
# Alternative options
Have you heard of  yet, or their file system? I've a few invites reserved for developers so let me know if it's interesting enough to warrant testing. It maybe possible to run with all web pages being signed and verified with a little hackery to how it connects clients.
Another option  seems to be a sweet of tools for allowing clients to posted signed data , no user accounts required. Turned the other way round and it's the clients allowing servers to post signed data to their local cached version of the web page.
These are suggested only to aid you in furthering your own project because I see that if used correctly your project could open up options for content delivery servers to become more of an option for web designers on the Tor network as well as an alternative to trying to find SSL cert exchange that's friendly to hidden services.

@_date: 2016-10-26 03:27:04
@_author: Michael 
@_subject: [tor-talk] A way to reduce service impersonation 
No worries, I'm long winded when I've a subject sufficiently researched. Read at your leisure. Good to know we where on the same page with some of the client to server interactions.
Feature suggestions for browser plugin
Perhaps consider color coding mixed page content within the browser plugin and/or allow users to block unsigned/signed with unknown keys kinda like NoScript on Firefox
Future issues for browsers
One issue I for see on client side validating is whether the whole page is signed, source and all, or if there's mixed signed page content, or if there's content signed by some trusted keys along with data that is signed with unknown keys.
These types of pages will happen, especially for forums, and depending on the clients' plugin it may crash the browser or only validate the first signature check. If you check my projects helper scripts you'll find that I've begun to work around this last issue of only the first gpg block in a file being recognized and handled when in a list of gpg encoded blocks. Required some loops and even then it's not purity or cost effective.
Well met and sleep well.
It depends on the server but my dirty hack for Apache would be a vhost redirect to the keybase file system mount point,
    /keybase/public/s0ands0
...instead of...
    /var/www
...but permissions would likely need modifying to prevent client writes. Another option would be to "share" the web host files to a specific keybase account only set up to read/serve shared files. This second option is what I would try first if I couldn't figure out what ports where being used for kbfs, if those ports can be Tor'ified then I'd try serving up the shared directory as a hidden service for the web hosting keybase account and not even bother with third party web server options.
A client side verification alternative maybe supplied via a Java plugin that uses the following as a library/backend
I'll have to check the link out in a few days, got some kennel hacking to finish and post about before crawling domains for more material. But in the interest in sharing notes here's a link to resources I've used to build my own GnuPG related project. It's designed for sysadmins that wanted "one way" encryption of their logs, hint find my postings on stackoverflow related domains for my necromancy on related questions.
Warnings for above linked project
- the above linked project as a whole is unrelated to the goals of this email chain but the 'Gnupg_' prefixed titled documents in the above are general enough for any projects use. You'll also want to check the '.travis-ci/' directory for easy automation tricks with GnuPG.
- it's functional and maybe used for bulk signing or decryption via one or two command line option changes. However, is only a prof of concept because it's all written in Bash scripting language.
- it maybe very insecure or very secure, no live stress tests have been completed as of yet.
- So enjoy'em but let's not derail what's happening here within the current chain topic.
On the subject of further hackery of previously mentioned tools the mnfst GitHub Repo has client, server and API options so I'd have to dig deeper into build setup to recommend it further as an alternative. However, it does look to be a tool that is complimentary to the one proposed here. So consider it as a way of "closing the loop" by allowing clients to send signed post data where as this project kinda aims the reverse. Combined and we'd have pgp signing on both sides of communication.
Stay safe y'all
