
@_date: 2011-04-27 01:05:08
@_author: George Kadianakis 
@_subject: [tor-talk] GSoC Student Introduction - Pluggable Transports 
I'm a Tor GSoC student and I'll be working on pluggable transports
this summer.
What are these so called pluggable transports you might be wondering...
Well, imagine a user in an under-censorship country who wants to
communicate with the rest of the world. Imagine him trying to use the
Tor network with a bridge. Imagine his Tor traffic getting detected by
the government; essentially not only blocking his communication
attempts but also marking him as a Tor user (and of course identifying
the bridge).
Tor traffic detection is not an alien thing, it happened in Iran - for
example - when Tor was using a not-so-usual DH prime for it's TLS [1].
It has happened before and will probably happen again.
Censorship and censorship resistance is a rat race.
This is where pluggable transports come into play.
Now imagine a "pluggable transports *proxy*" sitting on the censored
user's computer and a "pluggable transports *server*" sitting on the
bridge side. If you can't imagine it, _maybe_ this will help you:
          +-----------+      C      +------------+
      ----|   Proxy   |-------------|   Server   |----
   A  |   +-----------+             +------------+   |  B
                                              |
+------------+                                +--------------+
+------------+                                +--------------+
Now imagine that the "pluggable transports *proxy*" can alter Tor's
traffic and that the "pluggable transports *server*" can decode it
appropriately. This means that Tor traffic can be disguised as HTTP
traffic, or can be obfuscated, or even multiple encrypted with an
off-band shared key between the user and the bridge operator. [2][3]
And that's what pluggable transports are about.
What I'm gonna be doing during the summer is implementing the
pluggable transports specification [4] and maybe even writing a
protocol or two.
In any case, I hope that the pluggable transports system after the
summer will be welcoming and mature enough so that anyone can
implement their own protocol.
I'll be keeping a GSoC diary here:
I'm also lurking in  with the nickname "asn", feel free to
poke me there.
[1]: [2]: Now maybe you can understand what the A, B and C spots are in my
     image:
     In A and B one can see Tor traffic on the wire.
     In C one will see something - probably - innocent, like let's
     say BitTorrent traffic, when in reality it will be Tor traffic.
[3]:      [3]:

@_date: 2011-11-04 00:08:05
@_author: George Kadianakis 
@_subject: [tor-talk] Tor client pushing large amounts of data? 
tl;dr Did you by any chance compile tor with bufferevents enabled
Let's see the path of the sent bytes string:
The heartbeat code (src/or/status.c) receives the bytes sent in
log_heartbeat() using 'uint64_t get_bytes_written(void)' and stores it
into a uint64_t.
Then it passes it to 'static char *bytes_to_usage(uint64_t bytes)'
which has an 'if' statement checking the number of bytes so that it
can return a meaningful string.
In this case we got into the 'else' part of the 'if' which is
activated iff '(bytes >= (1<<30))', which means more or equals to a
Then 'bytes', a uint64_t, is casted into a double and printed into a
The only problem I can see here is if 'bytes' is bigger than what the
"mantissa" part of double can represent, in which case we start losing
The "mantissa" part is usually? 53-bits which can represent 9~
petabytes; so it's gonna take a while and is probably irrelevant with
this thread's problem.
I don't see an integer overflow or underflow happening anywhere
value around 48.08*(2^30).
Did you by any chance compile tor with bufferevents enabled?

@_date: 2011-11-04 16:58:01
@_author: George Kadianakis 
@_subject: [tor-talk] Tor client pushing large amounts of data? 
I see.
We've noticed this issue some months ago with bufferevents enabled,
but it's not easy to reproduce or track down [0].
I left a note on the bug report pointing to your original mail. Thanks for reporting the bug!
[0]:
