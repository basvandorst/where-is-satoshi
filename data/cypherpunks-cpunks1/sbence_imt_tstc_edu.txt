
@_date: 1994-01-20 07:19:15
@_author: Scott Bence 
@_subject: AI code speed up !!!! 
I have done a lot of optimization work on Mac and PC - Fractal generations & ray tracing both in C.
1.) Don't use SANE unless accuracy becomes a major issue. 2.) CHANGE ALL FLOATS TO DOUBLE!!!! Better speed & better     accuracy!!!!! (MOST IMPORTANT due to Motorola design!)
3.) Think & MPW both can create FPU code as well '030 code. Use em.
4.) Fall back from system 7.x to newest 6.x with no multitasking.
    Then try to structure your object code size to fit in the cache of     680x0.    5.) Use register variables where needed.
6.) Don't re-code in assembler - the gain usually isn't worth it.
7.) If there is alot of screen updating - stop it until the     final/desired result is achieved.
8.) Don't make System Task calls inside critical loops like Apple     says to do, it slows down completion time, it will invalidate your     code in the cache (see     There is alot more stuff but this should speed you up by a     significant factor.
9.) Mac's are wonderfull but for number crunching '486/66 can smoke     the mac due to 256k cache(secondary) and 8K cache (internal     -Primary). Don't know your budget but the POWER PC looks sweet. I     don't know when the compilers will opimize for this chip but look     for mega mega mega increase in performance.
Yup, but it's s...l...o....w.......
Hope this helps. Write back and let me know.

@_date: 1994-01-20 11:39:53
@_author: Scott Bence 
@_subject: AI code speed up !!!! 
I don't know what (if) I read this in any books or mags.  I would recommend MacTutor(name may have changed)  I had read it all through college and worshiped it.  You can find it at *the Book Stop* if you know where on is.  You can benchmark you routines fairly easy. Before you call your function get the ticks off the clock then again afterwards, then get the difference.
   ...
   start=GetTicks();   /* I think this was call, check the toolbox */
   foobar();
   total_time=GetTicks()-start;
   ...
One more thing, I left out another optimization kludge.  Try to reduce the number of calls outside your function by moving the code it is calling to inside the function.  This reduces the associated overhead of jumping (jsr $xxxx).
Also, if you have to go through the "toolbox" check into the
function GetTrapAddress(). Do this for Moveto(x,y) and then you can bypass the entry point of the toolbox and go directly to the routine in ROM.  This should shave off 5%-15% on the execution of toolbox calls.  DO NOT HARD CODE THE ADDRESS IN YOUR PROGRAM!  YOUR PROGRAM WILL DIE A HORRIBLE DEATH ON ANY OTHER MODEL! Use GetTrapAddress().
Hope all this helps. Let me know how things work for you.
