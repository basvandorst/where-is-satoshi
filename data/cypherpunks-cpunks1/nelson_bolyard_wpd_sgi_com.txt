
@_date: 1994-05-19 01:14:12
@_author: Nelson Bolyard 
@_subject: On Encrypted rlogin sessions 
Encrypting sessions of the Berkeley rlogin protocol is trickier than one
might imagine.  There's a "feature" of BSD sockets that can cause data to
be delivered in a different order than was intended.  The straightforward
approach used in the Kerberos IV implementation of encrypted rlogin,
krlogin -x, didn't address this problem, which is why krlogin sessions are
sometimes terminated, suddenly and unexpectedly.
This paper, which I wrote and submitted to the MIT kerberos bug list
several years ago, explains the problem, and one solution that I
implemented successfully in an encrypted rsh/rcp/rlogin product that was
never marketed.  I submit it here, for your edification and amusement.
This paper is approximately 4 printed pages long.
In my spare time, I'm trying to prepare a version of the protocol design
documentation for that old product that can be released for publication.
BSD sockets provides a feature known as "Out Of Band" (OOB) data
transmission.  It provides a way to send one byte of data in the TCP data
stream that is separated from the data stream by the receiver and made
available to the receiving program ahead of the rest of the received (and
queued) data previously received.  The OOB feature is implemented using a
feature of the TCP protocol called the "urgent pointer", which was never
intended for this use, and which doesn't always work as anticipated for
this purpose.  When OOB data is received, a signal (SIGURG) is sent to the
receiver to let it know that "urgent" OOB data has been received.
- - - - - (the old paper follows) - - - - -
THE PROBLEM:
The "Out Of Band" feature of BSD sockets, used by the rlogin programs,
has a nasty and little-known behavior which I call "OOB creep-in".  Normally, an OOB byte is sent, marked with the TCP urgent pointer, and is extracted from the incoming data stream when received at the destination
system.  However, under some somewhat-rare circumstances, an OOB byte can
be received without being marked by the urgent pointer, and consequently
the "out of Band" byte is delivered to the receiving program "in band",
indistinguishable from the ordinary data stream.  The OOB byte "creeps in"
to the "in band" data stream.
This behavior is documented (er, mentioned) in the BSD 4.3 tcp source code
in "tcp_input.c":
There are several ways this can happen, but the simplest scenario is this:
1. Sender sends a byte of OOB data.
2. A TCP segment with OOB data (urgent pointer) is sent.  Call this segment A.
3. Sender sends more normal in-band data (this is optional).
4. Segment A is not received, due to CRC error, or dropped by gateway.
5. Sender sends another byte of OOB data. 6. A new TCP segment (segment B) with the new OOB data (new urgent pointer)    is sent.  Sender socket's urgent pointer now points at latest OOB byte,    not the earlier one.
7. Sender's TCP retransmit timer fires, causing all sent but unacknowledged
   data (including all of segments A & B) to be retransmitted in a new
   segment, called segment C.
In segment C, the urgent pointer points to the newest byte of urgent data,
not to the OOB byte of segment A.  So both the old and new bytes of OOB
data are delivered but the urgent pointer only points to the latter one of them, the earlier OOB byte is not detected as being urgent or "out of The rlogin daemon uses OOB data to convey commands to the rlogin client,
such as "enable XON-XOFF", "disable XON-XOFF", "return current window size"
and "flush all received data".  When an OOB byte "creeps in" (in an
unencrypted rlogin session) it appears as a funny character on the rlogin
user's screen.  Some terminals display these as blanks, and very often
these go unnoticed by users.  When noticed, the user typically takes some
trivial action to correct it; such as redoing the "ls" command, or typing
"^L" to redraw the screen in vi.
Unfortunately, for users of Kerberos krlogin -x, which encrypts the
entire in-band data stream, the consequences of OOB creep-in are very
noticeable, confusing (except to those who understand this phenomenon),
and usually require the rlogin session to be restarted to correct the
The protocol used by "krlogin -x" sends all in-band data in blocks that
look like this:
    Length     | encrypted data ...
where Length is a 32-bit integer sent in Network Byte Order, unencrypted,
and is followed by roundup(length,8) [that's the smallest multiple of 8
that is no smaller than length] bytes of encrypted data.
A view of an rlogin session would show a series of these blocks:
OOB bytes are inserted in the data stream by TCP after (or before) a block
and are normally removed before being received by the client.  The actual
TCP data stream, with OOB data shown, might look like:
If such a data stream were to experience creep-in, the rlogin client,
would actually receive:
Instead of receiving a legitimate length LLLL, the receiver gets an
incorrect length BLLL.  The receiver becomes "out of sync" with the sender.
When this occurs, B is generally non-zero, and krlogin detects this
condition because the resultant value of the 4-byte length field is out of
range (too large).  This error is reported by krlogin code (incorrectly) as End-Of-File on the TCP socket.  This causes the "reader" process to
terminate.  The krlogin user experiences an unexpected termination of the
There are other problems with OOB as it is used in rlogin.  For example,
even in "normal operation" (e.g. no retransmission of data) loss of OOB
data occurs when the reader's system is slow and cannot process the first
OOB byte before the second byte is received.  That is, BSD code keeps only
one byte of received OOB at a time, and if the first byte is not consumed
by the receiving process before a second OOB byte arrives, the first byte
is lost, overwritten by the second.
Several solutions to the creep-in problem exist.  One solution, which (I
am told) has been implemented in another UNIX workstation vendor's kernel, prevents creep in by preventing the transmission of a second OOB byte until
the receipt of the first OOB byte has been acknowledged by the receiver.
Thus two OOB bytes are prevented from being sent in the same TCP segment.
This solution is not in general use, and I ruled it out for the code I was
developing because I was looking for a solution that would run on a wide
range of 4.3-based platforms, and not only on those featuring this fix.
Also, this solution does not prevent loss of OOB data.
Another potential solution completely eliminates the use of OOB in krlogin,
using an in-band mechanism to send commands.  For example, one could use
the most significant byte of the length field to send the command bytes,
instead of using OOB.  Without the SIGURG signal however, the "flushwrite"
function becomes rather untimely and useless.
The solution I chose uses OOB for the benefit of the SIGURG signal, and the
timely processing of flushes that it brings, but processes ALL the OOB data
in-band, so none is ever lost.  That solution was succesfully implemented in
the code I developed.  My programs did not suffer from creep-in; that is, users of my encyrypted rlogin program experienced the exact same behavior as experienced by users of ordinary rlogin.  No loss of synchronization is caused by creep-in.
Although the code in the product I developed is proprietary to SGI, I can
outline the elements of the solution.  If you're interested in this
solution (or some variant) for Version 5 of Kerberos, much more detail can
probably be supplied.
1.  Use socket option SO_OOBINLINE.  With this option, received OOB data
    generates a SIGURG, but is NOT removed from the data stream (remains
    in-band).
2.  The entire data stream is encrypted, both in-band and OOB data.
3.  Send the encrypted data exactly as done in unencrypted rlogin.  That     is, no length or padding data is added.  The protocol is identical to
    unencrypted rlogin (after key exchange is performed), except that the
    data is all encrypted.
4.  Use 64-bit Cipher Feedback (CFB) {en,de}cryption (see FIPS pub 81)     instead of CBC or PCBC.  The CFB method has several advantages:
Disadvantages of this scheme: All received data must be buffered and
decrypted, even that which is to be immediately flushed.
The routines reader() and oob() are completely rewritten.  Instead of a
single buffer which is alternately read, then written; reader reads data
into buffers which are put on a chain of buffers-to-be-written (to the
tty).  Reader reads data into these buffers until no more data is available
to be read.  Then it writes data from the chain of buffers-to-be-written
until the chain is exhausted or until SIGURG occurs.  Then it goes back to
OOB data is processed immediately as it is read.  A command to flush data
causes the chain of buffers-to-be-written to be freed.
The oob() routine merely counts the OOB received, and causes writing (to
the tty) to stop and reading (from the socket) to begin again.  No reading
and no longjmps are done in oob().
While this solution is too large a change to be considered a "bug fix" or
"patch" to kerberos version 4, perhaps it can be considered as a new
krlogin protocol for version 5.  [It wasn't]
Your feedback is solicited.  Nelson Bolyard       Multimedia Server Division      Silicon Graphics, Inc.
nelson at sgi.COM       Phone: 415-390-1919             Fax: 415-967-8496
Disclaimer: I do not speak for Silicon Graphics.

@_date: 1994-05-19 17:38:07
@_author: Nelson Bolyard 
@_subject: D-H key exchange - how does it work? 
Perry E. Metzger wrote, describing Diffie_Hellman key exchange:
Some of us may not have seen an explanation of DH before.
Perry's explanation was good.  For the sake of completeness for those who're new to DH, I'd like to offer some additional
information and considerations, here.
The prime p wants to be chosen with a little care, and the "random" numbers a and b may want to be "selected" to eliminate certain undesirable values.  I'll explain below.
Within the field Z_p (the set of integers 0..p-1) where p is prime,
there are elements whose successive powers make up all the elements of
the field Z_p.  These numbers are called "primitive" elements or
"generators" of the field Z_p.  That is, if g is a generator of the field Z_p, then the successive powers g, g^2, g^3, ...  g^(p-2), g^(p-1) mod p include all the p-1 non-zero elements of Z_p.
The set of unique numbers produced by taking succesive powers mod p of an
element m of Z_p is a group, the "multiplicative span" of m, which is a subgroup of Z_p.  The number of elements in the group generated by m
is called the "order" of m.  Primitive elements of Z_p have order p-1.
Not all of the elements of Z_p are primitive.  Some elements of Z_p have very small orders.  At least one element will have order 2.
Given that p is prime, the orders of the elements of Z_p will all have
values that are products of some or all of the prime factors of p-1.
Since p is prime (and p=2 is not interesting ;-), p-1 will contain the
factor 2.
An small example may make this point clear.  Let p == 11.
The prime factors of p-1 are 2 and 5.  Hence we expect the orders of the elements of Z_11 to be 2, 5, or 10.  By enumerating the groups of the elements of Z_11 we see this is so (for Z_11).  E.g.
Element	Ring				Order
------	-----------------------------	-----
  1	1				 1
  2	2, 4, 8, 5, 10, 9, 7, 3, 6, 1	10
  3	3, 9, 5, 4, 1			 5
  4	4, 5, 9, 3, 1			 5
  5	5, 3, 4, 9, 1			 5
  6	6, 3, 7, 9, 10, 5, 8, 4, 2, 1	10
  7	7, 5, 2, 3, 10, 4, 6, 9, 8, 1	10
  8	8, 9, 6, 4, 10, 3, 2, 5, 7, 1	10
  9	9, 4, 3, 5, 1			 5
 10    10, 1				 2
There are 4 primitive elements in Z_11,  2, 6, 7, & 8.
The orders of all the elements are as predicted by Euler.
Now, let us imagine that Alice and Bob have chosen 11 as their prime
and 7 as "g", their generator.
Following the steps outlined above:
Except that the interceptor, evil Eve, took g^a and g^b and tested them
for short order, and found that one of them, g^b, had a very short order
indeed.  So, without knowing a or b, Eve knows that g^(ab) is one of a
very few numbers, the elements of the group of g^b.  She can now try the
elements of that group until, by exhaustion, she finds the value that
reveals the key g^(ab).
And Eve, too.
Some primes produce lots and lots of elements with small orders.
For example, Z_37 has 12 primitives, 6 elements of order 18, and all
the rest have order 9 or less.
So, is DH all wet (insecure)?
No.  There are some simple steps to prevent this problem.  First, pick p to minimize the number of elements with small order.
This means that we need to know the factorization of p-1.  Of course,
factoring large numbers is a hard problem, but there are several
ways to pick p with known factorization of p-1.
The simplest seems to be to pick p such that (p-1)/2 is prime; that is,
such that p-1 has two factors, 2 and (p-1)/2.  Now, all the elements of
Z_p will have orders of either 2, or (p-1)/2, or p-1.  There are other
methods, that permit other small orders, but we won't explore them here.
Second, after "randomly" choosing a, and computing g^a, Alice takes the
additional step of making sure that the order of g^a is not small (i.e.
is more than 2).  If g^a is of small order, she picks another random a,
and repeats the process.  This is trivial indeed.  Bob does likewise for
his numbers b and g^b.
Since Alice and Bob have eliminated the small groups, Eve will never
encounter a g^a or g^b number whose order is less than (p-1)/2, and
given that (p-1)/2 is a _very_ large prime number, Eve won't live long
enough to try all of the elements of groups of that order.
I haven't checked to see if the RSAREF code takes these precautions.
Well, there are published descriptions of D-H that refer to the publicly
exchanged values, g^a and g^b, as "public keys", and by that definition,
yes, both sides exchange "public keys."  But as you can see, these aren't
public keys in the same sense that RSA public keys are.
Nelson Bolyard       Multimedia Server Division      Silicon Graphics, Inc.
nelson at sgi.COM       Phone: 415-390-1919             Fax: 415-967-8496
Disclaimer: I do not speak for Silicon Graphics.
