
@_date: 1994-02-17 21:00:55
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEANS 
This is my first post to this list, so please don't flame me if I make
some trivial mistake. %->
IDEA Re: making random noise files "undetectable"...
~~~~~~~  On many machines the file system allows users to "delete" files
         without actually deleting them.  This is usually accomplished by
         simply marking the disk blocks that make up the file as free.
         Thus it should be possible to write an encrypted (noise) file on          to disk, pad the rest of the disk with more noise and "delete" the
         whole thing, making the disk look blank to all casual observers.
PROBLEM: If the above idea is implemented, one could not write on to the
~~~~~~~  the disk for fear of accidentaly overwriting the "free" disk blocks.
SOLUTION: Knowing the _exact_ location and size of the file, one could write ~~~~~~~~  directly to those block which are _really_ free.
2nd PROBLEM: In order to decrypt the file, one needs to know it's ~~~~~~~~~~~  _exact_ location and size (or use some undelete util)...
             Which brings me to the...
3rd PROBLEM: An undelete utility could make recovering the encrypted
~~~~~~~~~~~  file trivial for _anyone_.
SOLUTION: Make the file undetectable to udelete utilitys by modifying
~~~~~~~~  the FAT table, or equivalent.  One would, of course, have to keep
          track of the file in some other, non-standard, way.
FINAL(?) PROBLEM: Implementing the above idea is trivial for the average
~~~~~~~~~~~~~~~~  user.  Making and recovering truely undetectable files                   may not be.
                                 All feedback welcome,
                                     Sergey

@_date: 1994-02-18 01:15:32
@_author: Sergey Goldgaber 
@_subject: Mimicry 
Actually, in it's simplest form, it is much easier to hide files by deleting them than by implementing an alternative file system.  Theoretically, the former method should be enough for most of those concerned with having telltale "noise" files on their disks.  Using an alternative file system might, for them, be almost as revealing as having "noise" files.
We can assume that the legitimate user would be aware of this drawback, and would take measures not to write over the files he has hidden.
I see no absolute _need_ to modify the filesystem.  A simple utility that can write files to specific disk locations is all that is required.
This is only a problem if you modify the filesystem.  The standard filesystem will simply write over the deleted files; or, if one is using the above mentioned utility, one would write onto a truely free portion of the disk.  We can assume that the only an intruder would unknowingly write a file onto the disk without using the special utility (thus overwriting the hidden encrypted file, and doing the legitimate user a favor by destroying the evidence).

@_date: 1994-02-23 16:00:26
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEANS 
This is my first post to this list, so please don't flame me if I make
some trivial mistake. %->
IDEA Re: making random noise files "undetectable"...
~~~~~~~  On many machines the file system allows users to "delete" files
         without actually deleting them.  This is usually accomplished by
         simply marking the disk blocks that make up the file as free.
         Thus it should be possible to write an encrypted (noise) file on          to disk, pad the rest of the disk with more noise and "delete" the
         whole thing, making the disk look blank to all casual observers.
PROBLEM: If the above idea is implemented, one could not write on to the
~~~~~~~  the disk for fear of accidentaly overwriting the "free" disk blocks.
SOLUTION: Knowing the _exact_ location and size of the file, one could write ~~~~~~~~  directly to those block which are _really_ free.
2nd PROBLEM: In order to decrypt the file, one needs to know it's ~~~~~~~~~~~  _exact_ location and size (or use some undelete util)...
             Which brings me to the...
3rd PROBLEM: An undelete utility could make recovering the encrypted
~~~~~~~~~~~  file trivial for _anyone_.
SOLUTION: Make the file undetectable to udelete utilitys by modifying
~~~~~~~~  the FAT table, or equivalent.  One would, of course, have to keep
          track of the file in some other, non-standard, way.
FINAL(?) PROBLEM: Implementing the above idea is trivial for the average
~~~~~~~~~~~~~~~~  user.  Making and recovering truely undetectable files                   may not be.
                                 All feedback welcome,
                                     Sergey
    ------------------------------------------------------------------
    *                                                                *
    * This is a repost of a message I posted on this list on Feb. 18 *
    * I am reposting in hope of further feedback fromm other readers *
    *                                                                *
    ------------------------------------------------------------------

@_date: 1994-02-23 16:26:05
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEANS 
This is my first post to this list, so please don't flame me if I make
some trivial mistake. %->
IDEA Re: making random noise files "undetectable"...
~~~~~~~  On many machines the file system allows users to "delete" files
         without actually deleting them.  This is usually accomplished by
         simply marking the disk blocks that make up the file as free.
         Thus it should be possible to write an encrypted (noise) file on          to disk, pad the rest of the disk with more noise and "delete" the
         whole thing, making the disk look blank to all casual observers.
PROBLEM: If the above idea is implemented, one could not write on to the
~~~~~~~  the disk for fear of accidentaly overwriting the "free" disk blocks.
SOLUTION: Knowing the _exact_ location and size of the file, one could write ~~~~~~~~  directly to those block which are _really_ free.
2nd PROBLEM: In order to decrypt the file, one needs to know it's ~~~~~~~~~~~  _exact_ location and size (or use some undelete util)...
             Which brings me to the...
3rd PROBLEM: An undelete utility could make recovering the encrypted
~~~~~~~~~~~  file trivial for _anyone_.
SOLUTION: Make the file undetectable to udelete utilitys by modifying
~~~~~~~~  the FAT table, or equivalent.  One would, of course, have to keep
          track of the file in some other, non-standard, way.
FINAL(?) PROBLEM: Implementing the above idea is trivial for the average
~~~~~~~~~~~~~~~~  user.  Making and recovering truely undetectable files                   may not be.
                                 All feedback welcome,
                                     Sergey
PS:  I originally posted this message on Feb. 18, '94
        I am now reposting in hope of recieving more feedback from other         readers.
PPS:  Please forgive me for my previous repost.  I just realized it is
          illegible to anyone without MIME.

@_date: 1994-02-23 18:57:04
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEANS 
Yes, I must have.  Thank you for mailing it to me!
It would be alright if someone checks the deleted sectors.  They would indeed
find your "noise" file; but, it would be embedded in rest of the noise
surrounding it (which would be provided by the other deleted files on the Thus, the original problem (ie. how to keep "noise" files inconspicuous) is
They would.  But, combined with "Stealth PGP" (ie. encryption without telltale headers) searching through all the deleted noise (which could be legitimate for all they know) would be futile.
Simple.  You would take note of the starting address of the file.  And, the length of the file.
This problem is solved by simply using a utility that writes directly to the
disk (exactly in the specified sectors, in the specified order), instead of letting DOS fragment your disk.
I am not familiar with the blank track you speak of; but, of course, if everyone keeps hiding their data in the same location it will not remain
hidden for long.
Thanks for sharing your thoughts, Matt!

@_date: 1994-02-23 20:22:35
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEANS 
No, no.  The function of Stealth PGP is, as I understand it, to simply encrypt plaintext into something that is virtually indistinguishable
from noise.  Deleting those "noise" files is a seperate issue.
What telltale TSR?  A program that can read and write directly to disk?
If I am not mistaken, such programs are common enough not to be
evidence of anything.  Having PGP on you is another matter, however.
With a standard direct disk read/write utility.
Disable authorization.  Most DOSs allow direct writes without authorization anyway.
This is not necessary.  In fact, as I noted, hiding your files in the same place everytime lessens security.  The alternative is a simple one.
Hide your files in different places, and keep track of them.  For example, a file that was encrypted on 02-23-94 could be written to disk starting with sector 022394.  All you have to do is remember the date and length of the file to retrieve it successfully.
Again, the program would be a standard utility that can write/read to/from
the disk.  One has to tell the program what tracks/sectors to read/write.  Having the program without the corresponding file address/length is useless.
You need _not_ have a TSR with the location.  If you keep track of the address/length yourself, the problem is eliminated.  The whole
automated (TSR) idea is only usefull if you are frequently accessing your disk.  In that case, saving your encrypted files to RAM temporarily might be a more elegant solution.  Otherwise, store your "noise" files sequentially, on a floppy that you use only for storing encrypted data.  Guard their respective addresses/lengths as dearly as you would your secret key and it's corresponding password.
I'm sorry, this paragraph just went over my head.  Could you restate it in another way, so I can attempt to comment?
Absolutely!  I have anticipated this problem; and, have been awaiting an
opportunity to address it.
Steps must be taken to keep the deleted portion of your disk from looking too random.  In order to implement this additional level of security (through obscurity ;) one could:
 1 split the "noise" file into smaller parts which would be interspersed    randomly among the other deleted grabage.  This would make for a less    conspicuous disk; as, there are, normally, truely random sections of    the disk along with the not-so-random sections.  Your bits of noise-file
   will fit right in!
 2 use a steganorgraphy utility to embed the "noise" file in a section
   of the other not-so-random garbage (as some people currently use those
   same utilities to embed their PGP files in GIFs), and then delete it.
   (Owning a stegonagraphy utility would, of course, be as conspicuous
    as owning PGP.  So the same precautions would have to be applied.)
These options are very similar.  I prefer the former.  Relying on a stego utility seems to be as unreasonable as relying on a TSR to keep track of the location of your deleted "noise" files.  I would split and hide the "noise" file by hand, and keep track of its location by hand as well, to ensure maximum security.
Alternatively, one could use a "Mimic" function with a "DOS garbage" grammar.
This is effectivaly the same as option 2.
Thanks for your input, once again, Matt!

@_date: 1994-02-23 22:28:38
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEANS 
Again, no TSRs are necessary.  Having a simple, common utility on hand is all that is needed.
Sure!  Norton's Disk Editor!  I think that it may be limited to doing
everything manually, one sector at a time, though.  I'm not a big MSDOS user,
so I can't direct you to a more convenient utility, but I'm sure they're out there.
You don't keep anything off limits.  If an intruder uses the standard OS (instead of the proper utility) to write to your disk, he might erase your data.  That is not a problem!  He's doing you a favor by destroying the evidence.
You, on the other hand, know better.  Thus, you will always use the utility to write to the free sectors of the disk.  You will have no problem, assuming you keep track of where your data is.
You use a floppy disk that is only accessed by your utility, which bypasses DOS (and Windows, which is DOS based).  You keep your disk write-protected at all other times.
That's correct.  But this is only the case when you are letting DOS write to disk for you.  If you use _direct_ (ie. _not_ DOS) disk writes, you can
specify which sectors you write to!
I disagree.  I do admit that the more security you want, the more complicated
the issue gets.  At the simplest level, all you have to do is delete your
"noise" file.  This is a solution to hiding "noise" files that is available to everyone.  Problems crop up only when your opponent is determined, knowledgable, and capable.  Although more effort will be required, I believe that the system I've outlined will prevent even the most determined opponent from finding evidence even of the existence of your
"noise" files.
All the protection that is neccessary is that of your keeping track of
the location of your files.  Just don't write back to those sectors again, unless you want to overwrite your data.
Once again, NO TSR IS NECESSARY!  In fact, it is detrimental, for the reasons
that I have outlined in my previous messages.
Only if you use standard DOS disk writes.  Bypass DOS and your problem is Are you forgetting the floppy+direct-disk-writes solution?  Choice 2 makes
Moving all the data to the end of the disk was not a suggestion made by me.
I agree that it would be rather silly.
Two choices:
 Space sacrificed for security.   Or, security sacrificed for space.
I understand.  However, your objection doesn't make sense in light of the above conclusions.
Thanks for your prompt replies, though!  Keep 'em coming!

@_date: 1994-02-24 01:15:15
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEANS 
I am proposing this as a practical solution that can be implemented effectively mainly on floppies.  Hard-drives might have to be dedicated to stegonagraphy (As Matt points out below).
So it seems.  However, I am wary of the possibility that there are drawbacks to the scheme that I haven't even considered yet.  I'm hoping that other astute readers such as yourself may be able to point them out; as, practical stegonagraphy may become a necessity in the near future.
My original post only outlined the basic premises.  I had not, at that point, realized that floppy use would be a virtual necessity.
Thanks for your insights and neverfailing tenacity, Matt.

@_date: 1994-02-24 04:10:55
@_author: Sergey Goldgaber 
@_subject: Stealth PGP and Stegonagraphy (LONG) 
Making Stealth PGP (random noise) Files "Undetectable"
         INITIAL PROBLEM:
         The following ideas were developed in response to the concern          over the future legal implications of possessing encrypted files.
         If non-Clipper encryption becomes illegal, even the mere
         possession of possible non-Clipper-encrypted files may be
         grounds for a search warrant, confiscation of equipment, and
         miscellaneous court sanctions.
         PRACTICAL OBJECTIVE:
         The possession of encrypted files must be made virtually
         undetectable, even to the most determined and best          informed opponent.
         BASIC PREMISE:
         On many machines the file system allows users to "delete" files
         without actually erasing them.  This is usually accomplished by
         simply marking the disk blocks that make up the file as free.
         Thus it is possible to write an encrypted (noise) file on          to disk, pad the rest of the disk with more noise and "delete" the
         whole thing, making the disk look blank to all casual observers.
         CHALLENGES:
         I   - Miscellaneous disk writes, such as those performed routinely
               by DOS, can overwrite the "deleted" files.
         II  - Certain security measures on the part of the user may make                recovery of the hidden file non-trivial.  Ideally, the file                will not have an "End Of File" marker, a file name, nor an                entry in the File Allocation Table.
         III - Upon examination of the deleted segment of a disk, the
               aware opponent will notice the discrepancy between a large,
               highly-random noise-segment and the "structured garbage"
               that will make up most of the rest of the deleted portion                of the disk.
         PROPOSED SOLUTIONS:
         I   - To ensure the integrity of the hidden data, all disk                writes must be directly controlled by the user, not DOS.
                A  - Use of a floppy disk is recommended; as, controlling
                     each individual disk-write operation on a harddrive
                     becomes infeasible due to the large amount of                      said operations.
                B  - The user should specify and keep track of the exact
                     address and length of the encrypted file when                      writing it to disk.  The file's location/length
                     should be guarded as dearly as one's secret key
                     and corresponding password,  for similar reasons.
         II  - Keeping track of the exact address and length of the                hidden file will allow easy file recovery, without need for an                EOF marker, a file name, nor a FAT entry.
         III - In order to make one's file deleted file virtually                indistinguishable from the rest of the deleted portion of the                disk, the implementation of one of the following measures                is recommended.
                A  - Split the noise file into small individual files and
                     scatter them throughout the "structured garbage" that is
                     already on the disk.  It should blend in with the other
                     little pieces of highly random noise that are naturally
                     interspersed in the deleted portion of the disk.
                     Recovery would, of course, require one to keep track
                     of the addresses, lengths, and order of the                      component files.
                B  - Use a stegonagraphy utility to hide one's file in a
                     segment of "structured garbage".  A Mimic function
                     with a "structured garbage" grammar would be highly
                     usefull for this.
         DISCUSSION:
         All of the above speculation relies on the use of Stealth PGP, or a
         similar program that encrypts plaintext into a format indistinguishable
         from random noise.  Unless this stegonagraphic function is implemented
         detection of the encrypted file, even when hidden among megabytes of
         other "deleted" files, will be trivial; as, PGP has a distinct header.
         The success of the above method also relies on the use of non-standard
         locations for the hidden files.  For, if this method becomes popular,          _and_ everyone starts hiding their files in the last few sectors of the
         disk, for example, a significant portion of the method's effectiveness          may be compromised.
         It should be noted that as long as the user is writing directly to and          reading directly from the disk (bypassing DOS), "deletion" of the file          is no longer necessary.  It is necessary to keep the blocks one writes
         to marked as "FREE", "BAD" or "DELETED" (take your pick!).  Some
         modification of the FAT or equivalent may be required here.
         SUMMARY:
         In order to hide a Stealth PGP (or equivalent) encrypted "noise" file
         effectively one may follow the steps outlined below:
                           1    Embed it in "structured garbage" such as is
                                present normally on the deleted portions of the
                                disk.  This can be accomplished by using a                                 stegonagraphy program or by splitting the file
                                into small segments and scattering them among
                                "structured garbage".
                           2    Write the resulting "structured garbage"/noise
                                combination directly to disk.  This can be
                                accomplished by using a normal disk-sector                                 editor utility.
                           3    Keep track of the exact location and size of the
                                file if you want to retrieve it later.  Keep
                                this information secure.
                           4    Modify the FAT (or equivalent) to mark the
                                sectors you've written to as "FREE", "BAD", or
                                "DELETED" (if necessary).
         In order to retrieve and reconstruct one's file simply reverse
         steps 2 and 1.
         THANKS:
         I wish I could thanks everyone who has commented on this thread          individually.  Unfortunately, I am rather new to this.  Next time,          I'll know to keep track of each response/address/name instead of          simply replying to your mail/posts.  You know who you are.  Thank you!
         Keep you comments flowing!
                                 All feedback welcome,
                                     Sergey

@_date: 1994-02-24 04:12:45
@_author: Sergey Goldgaber 
@_subject: Stealth PGP and Stegonagraphy (Summary) 
In order to hide a Stealth PGP (or equivalent) encrypted "noise" file
         effectively one may follow the steps outlined below:
                           1    Embed it in "structured garbage" such as is
                                present normally on the deleted portions of the
                                disk.  This can be accomplished by using a                                 stegonagraphy program or by splitting the file
                                into small segments and scattering them among
                                "structured garbage".
                           2    Write the resulting "structured garbage"/noise
                                combination directly to disk.  This can be
                                accomplished by using a normal disk-sector                                 editor utility.
                           3    Keep track of the exact location and size of the
                                file if you want to retrieve it later.  Keep
                                this information secure.
                           4    Modify the FAT (or equivalent) to mark the
                                sectors you've written to as "FREE", "BAD", or
                                "DELETED" (if necessary).
         In order to retrieve and reconstruct one's file simply reverse
         steps 2 and 1.
For a more detailed discussion of the above method, see the associated message, entitled "Stealth PGP and Stegonagraphy (LONG)".

@_date: 1994-02-24 04:20:49
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEANS (fwd) 
I am proposing this as a practical solution that can be implemented effectively mainly on floppies.  Hard-drives might have to be dedicated to stegonagraphy (As Matt points out below).
So it seems.  However, I am wary of the possibility that there are drawbacks to the scheme that I haven't even considered yet.  I'm hoping that other astute readers such as yourself may be able to point them out; as, practical stegonagraphy may become a necessity in the near future.
My original post only outlined the basic premises.  I had not, at that point, realized that floppy use would be a virtual necessity.
Thanks for your insights and neverfailing tenacity, Matt.

@_date: 1994-02-24 10:01:19
@_author: Sergey Goldgaber 
@_subject: STEALTH OCEAN 
This is a possibility, but one would have to make sure that the resulting
file is indistinguishable from a normal file if one hopes to elude any but the most casual observers.  Having a noise block at the beginning of the program is definately a telltale sign that something is amiss.  An simple dissasembly of the program is all it would take to be sure that the strange
looking noise block doesn't belong.  And, if the moethod you've suggested becomes popular, a standard scan of .COM or .EXE files could be implemented
by your opponent(s).
However, this solution might be effected provided that one somehow makes the "noise" block look like a legitimate part of the program it has parasitized.  It must also pass the dissasembly test.
Another idea might be to make one's "noise" file look like a legitimate
Clipper encrypted file.  Imagine the frustration that would be felt by your opponent when even the seemingly appropriate escroe key that he has spent months aquiring is of no avail in decrypting the file!  Of course, your efforts are going to be for naught when he realizes that your Clipper file is nothing of the sort.  :(  Back to square 1.

@_date: 1994-02-25 09:38:09
@_author: Sergey Goldgaber 
@_subject: Stealth PGP and Stegonagraphy (Summary) 
Not portable in what ways?  This method of hiding files is valid on many
No weird drivers or TSRs are neccessary.  You need rely only on a
commod disk-editor.  The "Bad Guys" will notice nothing out of the ordinary. How will virus-checking software notice anything?
They'll notice the stegonagraphy program, though.
Norton UnErase won't help if you leave no traces in the FAT, have no file name and especially if you've used a stegonagraphic function to embed
your file in garbage of the sort that is already lying around in the deleted portion of the disk, or if you've split your file into many small pieces and scattered them around the disk.
Yes fractals are a good place to hide info, as opposed to regular pictures.
If you deem it wise to further hide the fractal file in the deleted portion of your disk, you'd gain an even further layer of security.
Absolutely, that's what was noted in the discussion section of the original (Long) message.

@_date: 1994-02-25 10:02:44
@_author: Sergey Goldgaber 
@_subject: WE WANT SELF DECRYPTING STENOGRAPHY NOW! 
If you hide your files in different locations in the image every time, your
opponent will have no way of knowing which location you've chosen.  And, if the file has no tell-tale headers, than this method provides adequate security.  Mere fractal images are evidence of nothing.

@_date: 1994-02-25 10:07:16
@_author: Sergey Goldgaber 
@_subject: your mail 
There might be a problem in that Ida would have to phrase the answer
_exactly_ in the way that the sender has anticipated it would be phrased.
For example, Fred might ask:
"Where were we when we first kissed?"
Ida may answer:
"In the back of a dumpster truck"
Although correct, Fred may have anticipaded:
"In a dumpster truck"
There has to be a provision for unambiguous wording.  Even a question as
simple as:
"How old are you?"
may be answered in more than one way
"ninety-nine and one half"
Knowing the answer yet having the program reject the "correct" answer time after time may frustrate your PGP-Self-Decrypt unaware user.
Why use PGP?  As I understand it, the virtue of PGP lies in it's handling of public and secret keys.  Any semi-secure algorythm may be used with a self-decrypt program.

@_date: 1994-02-25 10:09:15
@_author: Sergey Goldgaber 
@_subject: WE WANT SELF DECRYPTING STENOGRAPHY NOW! 
Hide your file in random locations in the image every time.  The image will be useless to your opponent, unless the hidden file has a standard header.
That would be nice.  Clipper may be widespread sooner, though.
Not at all!  Lets say hiding data in multi-megabyte core files becomes fasionable.  Your opponent suspects stegonagraphy.  What part of that core file are they going to analyze?  Assuming that no standard as to the location, size, or header of the file hidden within the core file exists your opponent has nothing to go on.  EFFECTIVE STEGONAGRAPHY!
It may not be possible for long.
"Clipper is coming!
 The geese are getting fat!
 Please put a penny in they cypherpunks hat!"

@_date: 1994-02-27 18:43:42
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
What about this as a standard?:
Have the offset default to the checksum-value of the reciever's public key!  The sending program could have the user specify the reciever, look his key
up in the public-keyring and offset the message accordingly.  While, the recieving program would automatically scan the file starting at the appropriate offset based on the same public key checksum-value.
No secure channels would be necessary for dissemating offset values.  And, one's opponents wouldn't know where to look unless they knew:
  1 - That there may be a message hidden in the file.
  2 - That it is hidden with this particular stego standard in mind.
  3 - The reciever's public key.
Adopting this as a standard would, in my oppinion, offer a great advantage
over simply using a constant offset.
Of course, as it has been pointed out, there should always be the option
of providing a custom (non-standard) offset in the intrest of greater                         All feedback welcome,
                               Sergey
PS:  This could also be implemented using any combination of the      checksum-value(s) of the sender's and/or the reciever's      public/private keys.  However, this will have very different
     implications from the suggested method.

@_date: 1994-02-27 20:34:58
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
The hidden message need may be a stripped PGP encrypted file.  It need not
specify who its addressed to!  The intended recipient will be able to retrieve the file regardless.  His program should automatically revive the file starting from _his_ public-key checksum-value offset (which both the sender and the reciever already know, without the need for any telltale headers in the file).  Even if the opponent tries all possible offsets and filelengths he/she will always get noise, never anything pointing to the reciever.
It wasn't me!  ;)

@_date: 1994-02-27 21:39:16
@_author: Sergey Goldgaber 
@_subject: standard for steganography? 
This tool would be as much an obvious sign as would the aforementioned

@_date: 1994-02-27 22:11:45
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
If you're using one-time pads, why use PGP?  _Public_ Key Cryptography...?

@_date: 1994-02-28 12:09:36
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
Didn't you mention something along the lines of hiding "---BEGIN PGP" headers
by using one-time pad encryption?  Or did I wildly misinterpret you?

@_date: 1994-02-28 15:32:45
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
^^^^^^^^^
You were originally referring to PGP in particular, were you not?
Yes, I understand that your proposal is compatible with a variety of other schemes.  However, as you note below, this provides very limited security, unless the key is _non_standardized.
"Pseudo-Stego" can be relatively secure as long as a large number of different hiding schemes/standards are used by the public.  An effective means of ensuring this would be to use the reciever's public-key checksum-value as the standard offset for stego.  The large number of public-keys available make it rather infeasable for one's opponents to try them all.  This, I believe, provides pretty adequate security (assuming one strips any telltale headers off the hidden file beforehand).

@_date: 1994-02-28 19:36:20
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
In that case, I retract my statements.  Sorry, I was under the impression that you were.
In your message you made a proposal to the effect of implementing a stegonagraphy standard whereby a standard header is encrypted.  I thought you were implying that the key should be constant for that stegonagraphy program.  I simply noted that security would be limited if this were the case.  Using a new key every time one encrypted would be an example of what I meant by a "non-standardized" key.
Of course.  Most everything computer related is limited by those same I disagree.  If a great number of methods are available, using one will provide some measure of security, regardless whether or not it is public.
Only in the case where the _exact_ (public) method and _exact_ (public) key one has used is known to one's opponents that there is some loss of security.  Knowing a hundred different methods and tens of thousands of different keys doesn't get one's opponents anywhere.
Yes.  And, the great variety of different offsets made available through the use of public-key checksum-values provide the increase in security.  Of course, for the greatest security no standard whatsoever should be used.
Wasted bandwidth does not a poor method make!
The method I outlined does indeed require a public-key.  Using the method is, as you have pointed out, not necessary.  You have not, however, shown why you believe the method doesn't work.  You have simply outlined what you _don't_like_ about the method.
Ah!  This is where we don't see eye to eye.  I believe that the purpose of stegonagraphy is to hide data.  Having "a quick means to determine whether data has been modulated into the medium, and if it has by what particular item of software" is a detriment to that effect.
We were speaking of standards, however.  Thus my proposal to offset data by the checksum-value of the reciever's public-key.  If one must use a standard of any kind this one would, I believe, provides enough variation for moderate security.  Please note that this standard, and the one you've presented are not mutually exclusive.
I simply believe that a standard stego-function which hides the data in a constant location makes for a poor stego-function.  That's where my proposal comes in.
If the information that informs one that something is hidden in the media is itself hidden, how can it be a means to determine if something is hidden?  How would you determine if there is information that informs one that something is hidden in the media, hidden in the media?  See the problem?  Your whole purpose is cancelled out by your method.
Fortunately, there is no need for this convention.  One would have determined that there is at least a possibility of data having been hidden in the medium before one attempted to use a de-steg function anyway.
As long as you're proposing header encryption via IDEA, why not consider doing the same to the whole file?  It would increase security.  There are objections to be levied against any non-public-key system, however. That it would require either:
  1 - A standard password (SEE ABOVE).
  2 - Dissemation of the password through secure channels.
So that this question may be asked: if you have secure channels, why do you need encryption?
It would be even easier to get the same picture and run it through your stego software which would look at your public-key and extract the file automatically.  This would be pretty secure, easy to use, and require no secure channels!

@_date: 1994-02-28 20:25:16
@_author: Sergey Goldgaber 
@_subject: standard for stegonography?????!!!!?? 
That is correct.  The standard should be to have no standard!  :)
But, if you must have a standard, some variability would help.  I outlined
a "variable standard" in another recent message in this thread.
A fictional example of a legitimate need for standardization and a possible solution follows:
  Feb. 1998
  Jack and Jill are both readers of cypherpunks and long-time users of PGP.
"Stealth PGP" and "Stego+" have become very popular.  Unfortunately, Clipper is a legal necessity for all computer communication.    Jack wants to send Jill a _truely_ private message.  Using only Clipper is not an option; neither is "Stealth PGP", on its own; as, meerly owning non-Clipper encrypted files has recently been successfully used as grounds for search warrants, equipment confiscations, and miscellaneous court   Luckily, it has become particularly popular to use "Stealth PGP" in combination with "Stego+" to hide messages in PictureCD files.  Knowledgeable users regularly scan alt.videos.binaries.misc for messages.  Although Jack would like additional security that he would obtain from using a non-standard stegonagraphy program, this is his first message to Jill.  He can not simply send plain-text email to Jill telling her to use the new "SuperStego", for obvious reasons.
  Jack therefore uses the standard, relatively secure, method and sends the message via "Stealth PGP" & "Stego+" in TEST.CD on alt.videos.binaries.misc; thereby evading the ClipperCops.

@_date: 1994-02-28 21:56:34
@_author: Sergey Goldgaber 
@_subject: standard for steganography? 
Yes, pure white noise would be anamalous.  I have suggested that one use a Mimic function with a "garbage grammar".  Implemented correctly, it should
withstand statistical analysis.
What is an AD converter?  And what are the techniques you speak of that mimic those AD converters?

@_date: 1994-02-28 22:52:06
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
Good question!  Anyone out there know what the practical/secure limit is?

@_date: 1994-03-01 01:07:59
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
I dissagree.  You may waste a few bytes, or maybe several Kb, but it would be worth it.
As I said in an earlier post:  you can either sacrifice space for security; or,
sacrifice security for space!
Now that I think about it, one wouldn't have to sacrifice any bandwidth whatsoever!  As, the stego program could be made to do wrap-around encoding.  Meaning that, as the end of the file is reached, encoding continues from the beginning until the appropriate offset is reached.
This would loose none of the additional security offered by the original On a related note, someone has mentioned that fractals have a great ammount of potential for stego.  Their noise-threshold is much higher.  You may want to look into that if you're concerned with conserving space.
It _should_ look like harmless information!  It would be _nice_ to be able
to know which files have been stegg'ed; but, that would either have the potential to tip off one's opponent as well or, it would require secure channels to propagate header keys (see previous message in thread for comments to this effect).
I do not advocate stego'ing data with telltale headers.  That combination is self defeating.  It must be noted that encrypted headers, as per your advice, would allow one to know that decription was successful, without sacrificing security.
You would have to decrypt it to find out.  The only problem may lie in figuring out the file-length.  Possible solutions are:
  1 - Put in some kind of EOF marker.  Scatter a some more through the file
      just in case, as well.  You may thus be required to make several
      attempts at decryption.   2 - Have a standard file length.  Break the original file into standard
      length packets.  Pad with noise, if neccessary.  Then send it through
      via multiple successive files.
This is much clearer, thank you.  However, I'm sure you realize that
if the key used to encrypt the header is standardized, and it's location of the header is standardized as well, much security is lost.  If its not standardized, secure channels must exist for its propagation (ie: no need for stego).
Yes, stego is all but invalidated if you try and hide patterned information.
That is why I recommend using "Stealth PGP" and/or a Mimic-function in combination with the standard stego we've been discussing.
You need not give up the offset-method to do this.  They should work together for additional security.
This is a good idea.  It will save you time you would have otherwise used
to try and decrypt the whole file.  However, this should only be used if the header fits in uniformly with the rest of the file.  Otherwise, the file will stand out as encrypted.  Of course, the data should be uniformly encrypted with Stealth PGP or its equivalent, as well.
The function of Stealth PGP, as I understand it, is not only to encrypt without information as to the intended reciever, but to leave no trace of encryption whatsoever.  Thus the need for a seperate, encrypted, header.
I think your modified proposal should work just fine.
If the desteg program automatically checks for encrypted, hidden fileheaders via un-stealth-pgp, it may be as simple as you've pointed out, anyway.
Your idea will save time at no loss to security, if the header is encrypted.
I see a problem only if the header is:
   1 - unencrypted
   2 - encrypted with a non-public key
   3 - encrypted but anamalous
If its encrypted with a public-key and blends in with the rest of the data and the rest of the file it should be fine.

@_date: 1994-03-03 09:36:21
@_author: Sergey Goldgaber 
@_subject: standard for stegonography? 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Will this be reversible?  Will a plain-text header be neccessary for the
intended recipient to how to reverse the function?
Haven't you heard?  Everything mathematical is under restriction now!

@_date: 1994-03-03 15:25:56
@_author: Sergey Goldgaber 
@_subject: Standard for Stenography? 
I think this "silence" has a good side.  I've only read this list
for a short time, but I already respect the oppinions of a few regulars.
I don't expect every idea I post to the list to be completely new (quite the opposite, usually).  The few replies I, and most other newbies, get are usually not very thought out, and have as many holes in them as the original suggestion.  We debate back and forth for a short while, but seem to be generally ignored.  The 'elders' on the list stay silent.
Its when those respected few regulars speak that my ears prick up.  I, for
one, haven't read all the literature on the subject.  So the oppinions of
someone who has are greatly valued.  If genuine intrest is shown in
something you've proposed it tells you that you're on the right track.
Input coming from the 'elders' is doubly important.
It would be nice if constructive, intelligent criticism was offered on
every post.  Unfortuantely, newbies tend to get flamed more often than
praised.  In that regard, I believe that the "silence" from those who know better is usually good.
If I recieved the sort of annoyed response that Gary Jeffers got from you
on one of my first post, I don't think I would have stuck around for long.
Perhaps some of the senior cypherpunks would prefer a moderated list
where all newbie discussion is nipped in the bud.  In that case, I suggest that they form the "eLyTe-cYpHeRpUnKs" list, and distribute it privately among themselves.  I believe that fresh blood is essential for the development of the "cypherpunks"; so, this route is not recommended.

@_date: 1994-03-03 16:02:44
@_author: Sergey Goldgaber 
@_subject: Standard for Stenography? 
I never thought it was.  Thank you for joining in the discussion, BTW.
I welcome any and all of Bill Stewart's comments on this issue.
I have, since the beginning, noticed a distinct dislike of "security-through-obscurity" among the senior members of this and other similar lists/newsgroups.  Many people preach this dislike.  Most don't seem to understand its foundations fully; neverthelless, they consider it a closed issue and usually don't bother to explain why.
I am glad that you are offering your insight on this, Hal.
This is the most elegant solution,  I agree.
That would be ideal, I agree.
I do not trust my encryption to be foolproof.  If I believed that adding
noise at the front of the file would help, I would do it.  I still wouldn't
trust it, but I would feel safer with every new security-through-obscurity
This is my defense of security-through-obscurity:
Security-through-obscurity adds layers upon layers of potential effort needed by one's opponents to get at whatever it is that you are obscuring.
A good analogy would be the length of one's secret key.  A one bit key, you
would agree, is not very effective.  The bits in the key, the more effort
your opponent would have to expend in brute-force analysis.  Similarly, the more layers of obscurity one has, the more effort your opponent would have to expend in bypassing/guessing your methods.
I have often heard it said that one should always assume that one's opponent knows everything except one's secret key.  To me, this makes no sense!  If your opponent is good enough and determined enough to get by all the layers of obscurity you may have put up, than its just one more step to getting your secret key.
You have stated that my oppinion is naive.  Please enlighten me.
So the views of these naive new members should be "vigorously refuted" (ie. flamed) in the intrest of other naive new members?  Have you considered
changing that to "constructively criticised"?
That it is!
I dissagree.  In a perfect world, with perfect encryption and perfect
steganography "random offsets" may be superfluous.  As it stands now, we
need all the obscurity we can get.

@_date: 1994-03-03 18:25:03
@_author: Sergey Goldgaber 
@_subject: Newbies on the List 
Flaming is no solution to this "problem".  In fact, this "problem" can, with proper guidance, lead to an enriching growing experience (forgive me for sounding camp).  Most very "naive" newbies usually get responses that are anything but helpfull; unless their queries are phrased in a submissive, almost servile tone.  At the very least, a certain humility is expected.  This pattern is by no means limited to
this list, or even the whole Internet.
It is the "presumptuous" _and_ "naive" newbies that get flamed the most.
They are the safest targets.  It may be wise to realize that even the
_most_ presumptuous and _most_ naive newbie has potential for enriching the group tremendously.
In these cases, flaming usually turns out to be even more naive than
whatever it was the newbie has/hasn't done to deserve the flame.  The
senior, as many have pointed out, should know better.
A great pity.  I suspect that some the contents of the archive may be far more educational than even the fabled "Applied Cryptography".  :)
Thank you for pointing that out.  However, it was not my intention to imply
age differences with the terms "newbie", "elder", or "senior".  Nor was it my intention to put anyone on the defensive.
For some, actual "live" conversations hold more in the way of being educational than any textbook, no matter how well written.  Your suggestion is well taken, nonetheless.
It would be ideal if every "newbie" had the time/energy to do all these before posting.  It may minimize the chances of "reinventing the wheel".
Luckily, I believe the "cypherpunks" list is a fine way to learn a little about cryptography.  Not only by reading, but by participating as well.  It may not be as effective as actually managing to read and understand a 400+ page reference book on cryptography.  Nor would I urge any prospective cryptographers to to take this as their only route of study.
But it may be a good (dare I say "fun"?) introduction.
That is a problem.  There aren't enough!  700 dabbling cypherbabies and maybe a dozen serious cypherpunks are less than a handfull.  Perhaps the list needs to be subdivided (or renamed to something more boring :)  But I don't think we need to worry about there being too many of us.
I do not seriously expect a constructive, intelligent reply to every post.  I was meerly listing it as another ideal.  Constructive replys need not be public, BTW.  Especially if the topic(s) has been thoroughly covered previously.
Yes.  And, names would be comparatively mild to trashing his account (something which many readers are very capable if not willing to do).
And that would be mild compared to sending him a mail bomb.  In any case, the responses he recieved were mostly less than helpfull.  I certainly expected more from certain senior members of this list.
Flaming them(us) does not usually "get them up to speed".
I hope I'll have the time to become a serious contributor (seriously :).
I certainly have the intrest.

@_date: 1994-03-03 19:01:22
@_author: Sergey Goldgaber 
@_subject: Standard for Stenography? 
I have never heard a serious, reputable claim about the unbreakablity of an algorithm.  Any newbie that dares to pretend otherwise is promptly referred to the example of the NSA.  The biggest single purchaser of computer hardware, and employer of mathematicians.  Dozens of years ahead of public research and all classified.
The point is, that in the real world, we'll never know if our algorithms are "good enough to withstand an opponent who has full documentation of your algorithms and methods lots of funds, and everything except your keys."
This opponent need not be the NSA, per se, BTW.  With "lots of funds" they may have access to at least some of the NSA's findings.  And, who knows, the NSA may regularly hire its services out to the highest bidder.
You may trust your encryption alone, but if it ever comes to that, I'll hide any sensitive information I may have every way I can.  I still don't see why.
It certainly lookss like it takes a lot!  The Mimic function seems, to me, to be the only effective practical steganography application.  Most of the rest of the informed members of this group seem to be debating the relative visibility/invisibility of their respective systems.
Here's to somebody elese's problems!

@_date: 1994-03-03 19:14:29
@_author: Sergey Goldgaber 
@_subject: Standard for Steganography 
Sorry to have to bring this up, but...
As some of the newbies have pointed out, in previous messages on this thread:
The length field, or any standard-length header scattered (standardly :) through the beginning of the file will cost one no loss in security if it is encrypted.
The encryption could easily be standardized via a public-key based algorithm like PGP.
The stego-program could be kept simple by meerly having it call PGP to do the header-encryption work.

@_date: 1994-03-04 01:48:29
@_author: Sergey Goldgaber 
@_subject: Security through Obscurity 
Thank you for a very enlightening post, Hal.  Just a couple of comments:
If I have understood you correctly, there is nothing wrong with equating
obscurity with a practical, albeit temporary, increase in security.
Equating obscurity with ultimate security is a mistake.  As is equating a
"strong" algorithm with ultimate security.
I would like to propose that there is a goal, in addition to those you have revealed, for the opponent as well as the legitimate user of steganography.  The opponent would, ideally, wish to not only determine that there is a message within the data; in addition, he would prefer to be able to extract that message for analysis.  Therefore, I believe that it would be to the advantage of the stego-user to not only hide the existence of his message, but to do so in such a way that the cost of successfully extracting that message, by his opponent, is maximized.
If one accepts the additional goal proposed above, the value of an extra test is obvious.  This test may consist of an attempt at message extraction, as per your guidelines.
I have to take exception with the assertions made in this paragraph.  Using the principles of public-key systems, the steganography key itself does not have to be kept secret.  The sender, reciever, and indeed the opponent would all have access to this key without compromising the security of the system.  The challenge, for the opponent, lies in figuring
out which public-key the sender has used.  I have no statistics on exactly how difficult this challenge would prove; but, considering the number of public-keys currently availiable and projecting several years into the future, the challenge may be a very significant one.
The benefits of using offsets, in general, are clear (assuming one accepts the additional (and essential, I believe) function of steganagraphy programs, outlined above).
The method I proposed for calculating the default offset from the checksum-value of the reciever's public-key was intended to provide a practical increase in security over defaulting to no offset (or a constant offset). For maximum security, a completely non-standard offset is called for.
Thanks for your input yet again, Hal.

@_date: 1994-03-04 22:22:00
@_author: Sergey Goldgaber 
@_subject: Standard for Stenography? 
know = 100% objective certainty
How can you tell that you've been compromised if you stick to non-security-by-obscurity methods?
That would be difficult.  But, lack of objective measures does not mean that security-through-obscurity is innefective.  BTW, there may be some statistics on the effectiveness of StO, somewhere.  (Anyone out there heard of any?)
I am not trying to convince everyone hide their data in the same place I am hiding it.  Simply consider hiding it, rather than leaving it out in the open!  That's not too crazy a proposition, is it?
Take your encrypted data.  Stick it in a file, using a variable offset.
That's all there is to it.

@_date: 1994-03-04 23:45:18
@_author: Sergey Goldgaber 
@_subject: Security through Obscurity 
I agree.  Your cost assesments will, however, be different for each individual StO method.  I was generalizing.
Well, if we adopt the method of comparing the cost of implementing a given steganography method to the cost of breaking it as a valid measure of its effectiveness; then, it would make sense to "maximize" the cost of breaking it as a means of making the method more effective (ie. making the method more obscure would make it more effective).
The more difficult it is for one's opponent to extract the message, the more effective the method is.  Thus, "maximizing his difficulty" is a valid goal.  As I see it, this is a goal of most encryption systems.  To make decryption as difficult as possible, if not impossible (ie. maximum I am well aware of this.  I was not proposing the above goal as a
substitute, but an addition to the one you pointed out.
I am assuming that it will cost the opponent effort.  I have no statistics to show exactly how much effort it would cost him; as I believe it would be different in every individual case.  However, it is clear that the effort needed would increase.
I do not think you have understood _my_ essay.  My proposal was for a default, variable offset in certain steganography applications.  The benefit of this is obvious:  having no offset or a non-variable offset would make for generally poorer security; as, the effort required in figuring out where one's file is located is nonexistant.  Effort increases when a variable offset is implemented.
This need only be the case if the recipient keeps his recieved files (which were sent using the _default_ settings) in their original format.
Any compromise in security can be avoided if he resets the offset to a custom value.
Regularly encrypted files can be searched against random secret keys.
The effort involved in both is greater than not having to search at all.
If no offset, or a non-variable offset, is used than one's opponent wouldn't even have to try to recover the file!  That is why I only proposed a default offset, while pointing out that maximum security can only be achieved through custom offsets!
In my original post I made it clear that my proposal was an addition to, not a subsitition for, the goal you set.  Therefore, the ideal steganography program would make it impossible to guess that there is a message _as_well_as_ make it impossible to tell where the message is located.  These functions are not mutually exclusive.
You proposed that a successful steganography program should hide the message in a file in such a way that one's opponent would have to guess about the existance of a message in that file.  I do not dispute that goal.  I simply offer an additional one.  Let me give an example:
Steganography Program A hides data at no offset, with a 49% probability of hostile recognition.  This program would pass your proposed test.  Because it offers no offset, successfull extraction of the data requires only X ammount of effort from one's opponent.
Steganography Program B hides data at a variable offset, with a 49% probability of hostile recognition.  This program would also pass your proposed test.  Because it offers a variable offset, successfull extraction of the data requires X+Y ammount of effort from one's opponent.
User C hides data in all 100 of his GIF files using Steganography Program A.
User D hides data in all 100 of his GIF files using Steganography Program B.
Opponent E searches through every GIF file of both user C and D.
He guesses that there is data in 49 files belonging to user C, and 49 belonging to user D.  He successfully extracts the data from all 49 of user C's files, expending X ammount of effort.  Successfull extraction of user D's data, however, costs him X+Y effort.
As this is a hypothetical example, we may subsitute $1 for X ammount of effort, and $1 for Y ammount.  Successfull extraction of C's data would cost his opponent $1, while D's data would cost $2.  More realistically, substiture $10,000 for both X and Y; or $100,000; or $1,000,000.  Now, would you rather use?  Program A or B?
I, for one, would rather use B, realizing that both X and Y are unknown.

@_date: 1994-03-05 00:03:32
@_author: Sergey Goldgaber 
@_subject: more steganography talk 
Such is the function of Mimic, available at ftp.cs.cornell.edu
in /pub/wayner/Mimic
It holds the most promise for steganography, in my oppinion.  Unfortunately,
it may be difficult to implement, initially.

@_date: 1994-03-05 00:22:13
@_author: Sergey Goldgaber 
@_subject: Standard for SteGAnography 
Newbie questions:  What is OTP?  What about probabilistic encryption
                   vs quantum cryptography?
How do they give one 100% certainty that they can't be broken?
100% objective certainty of the scheme's invulnerability.
Sergey :)

@_date: 1994-03-07 00:41:15
@_author: Sergey Goldgaber 
@_subject: Standard for SteGAnography 
My original response was concerning an algorithm "good enough to withstand an opponent who has full documentation of your algorithms and methods lots of funds, and everything except your keys."
That opponent may, concievably, be the NSA or another person/organisation with access to similar resources.  The consensus seems to point to such an opponent as being one who could mount the "strongest possible attack".
It may not be practical to consider such a general danger when designing particular encryption schemes; but, it is likewise impractical to make sweeping generalizations concerning a given scheme's invulnerability.

@_date: 1994-03-08 10:58:36
@_author: Sergey Goldgaber 
@_subject: more steganography talk 
I find it fascinating how complimentary cryptography and AI are!
I wonder if anyone has actually gone to all the trouble of developing some kind of binary CFG?  It should be easier to design than an equally effective human-language Turing-complete CFG.
What kinds of "incomplete" attacks could possibly work against
Mimic functions implementing Turing-complete CFGs?
Can't you simply use a Turing-complete CFG, and meta-CFG?
Do such things exist on computer media?
Why not just ask an AI?  :)
Do you know if anyone has ported either of those over to anything
other than the Mac?
Good to have you join the discussion, BTW...
