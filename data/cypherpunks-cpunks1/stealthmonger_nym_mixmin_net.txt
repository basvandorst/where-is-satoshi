
@_date: 2009-12-10 16:48:54
@_author: StealthMonger 
@_subject: schneier on schmidt 
Hash: SHA1
Eugen, thank you generally for your postings to this forum.
But thank you especially for bringing these vital words from Schneier
to our attention at this time.  For example:

@_date: 2009-11-06 03:29:31
@_author: StealthMonger 
@_subject: managing and protecting nyms... 
Hash: SHA1
Are you suggesting that you're not using a nym server [3] for your
What's your threat model again?
A worthy but difficult thing to do.
[3]  -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite at nym.mixmin.net
Finger for key.

@_date: 2009-11-06 09:30:00
@_author: StealthMonger 
@_subject: managing and protecting nyms... 
Hash: SHA1
Please explain other ways to be practically untraceable.
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite at nym.mixmin.net
Finger for key.

@_date: 2009-11-10 10:04:01
@_author: StealthMonger 
@_subject: managing and protecting nyms... 
Hash: SHA1
Tor is not practically untraceable.  The Tor documentation itself
asserts the contrary:
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
In contrast, the "obfuscation" attained with a nym server is
attributable precisely to the high random latency and traffic mixing
of the anonymizing remailers through which the nym is operated.
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite at nym.mixmin.net
Finger for key.

@_date: 2009-11-10 10:18:58
@_author: StealthMonger 
@_subject: managing and protecting nyms... 
Hash: SHA1
Tor is not practically untraceable.  The Tor documentation asserts:
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
Use of a nym server is practically untraceable because of the high
random latency and mixing with other traffic provided by the
anonymizing remailers through which a nym server is controlled.
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite at nym.mixmin.net
Finger for key.

@_date: 2009-11-10 10:49:41
@_author: StealthMonger 
@_subject: managing and protecting nyms.... 
Hash: SHA1
Tor is not practically untraceable.  The Tor documentation asserts:
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
Use of a nym server is practically untraceable because of the high
random latency and mixing with other traffic provided by the
anonymizing remailers through which a nym server is controlled.
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite at nym.mixmin.net
Finger for key.

@_date: 2009-10-30 05:57:35
@_author: StealthMonger 
@_subject: [Fwd: [p2p-research] Slashdot | Federal Judge Says E-mail 
Hash: SHA1
Or people who just take incoming mail straight to their site by SMTP.
It's not even necessary to "be an ISP".
Or who encrypt the mail.
Where should the rock be thrown?
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite at nym.mixmin.net
Finger for key.

@_date: 2010-08-03 05:48:51
@_author: StealthMonger 
@_subject: Microsoft Quashed Effort to Boost Online Privacy - WSJ.com 
Hash: SHA1
Microsoft Quashed Effort to Boost Online Privacy - WSJ.com
By NICK WINGFIELD
   The online habits of most people who use the world's dominant Web
   browser are an open book to advertisers.  That wasn't the plan at
   first.
   In early 2008, Microsoft Corp.'s product planners for the Internet
   Explorer 8.0 browser intended to give users a simple, effective way
   to avoid being tracked online.  They wanted to design the software
   to automatically thwart common tracking tools, unless a user
   deliberately switched to settings affording less privacy.
   That triggered heated debate inside Microsoft.  As the leading
   maker of Web browsers, the gateway software to the Internet,
   Microsoft must balance conflicting interests: helping people surf
   the Web with its browser to keep their mouse clicks private, and
   helping advertisers who want to see those clicks.
   In the end, the product planners lost a key part of the debate.
   The winners: executives who argued that giving automatic privacy to
   consumers would make it tougher for Microsoft to profit from
   selling online ads.  Microsoft built its browser so that users must
   deliberately turn on privacy settings every time they start up the
   software.

@_date: 2010-12-02 00:12:03
@_author: StealthMonger 
@_subject: any moment now ... 
Hash: SHA1
Earlier he wrote
So, what can be done with that Tor node once it's set up?  It can't be
used interactively (i.e. with low latency) because that "permanent
record of all of your transactions in Internet-space" can be used
today or tomorrow or "next year or next decade or ..." to correlate
packet timings and destroy whatever anonymity the Tor node might
otherwise have had.  And if the Tor node is configured to respond to
instructions anonymized by a remailer network, the remailer network
might as well have by used by itself in the first place, without the
Tor node in the picture at all.
 -- StealthMonger     Long, random latency is part of the price of Internet anonymity.
   uinmyn: Is this anonymous surfing, or what?
      stealthmail: Hide whether you're doing email, or when, or with whom.
   mailto:stealthsuite at nym.mixmin.net?subject=send%20index.html
Key: mailto:stealthsuite at nym.mixmin.net?subject=send%20stealthmonger-key

@_date: 2010-07-08 13:56:34
@_author: StealthMonger 
@_subject: uinmyn 0.02 
Hash: SHA1
     _   _|_|_ __  _ __  __ __  __ _ __   /  _ \/  _ \|___ \  | | | | '_ \| '_ \'_ \\ \/ /| '_ \  | | | | | | | __) |
 |_| | | | | | | | | | |\  / | | | | | |_| | |_| |/ __/
    \__,|_|_|_| |_|_| |_| |_|/ /  |_| |_| \____(_)___/|_____|
Change log
   Add a script to enter gotten pages into a local browser-accessible
   cache.
   Improvements to the documentation.
The url at is-not-my.name Internet page fetcher [1] allows an individual
to read Internet content with strong anonymity.  Content is returned
encrypted in Usenet newsgroup alt.anonymous.messages.  No one, not
even the is-not-my.name administrator, is able to link content being
fetched with any particular individual, or with other requests.
Here are some scripts to facilitate use of url at is-not-my.name.
There are two main scripts:
   uinmyn-fetch-body.py
      -- code URLs into a request and save the key
   uinmyn-do-aam-article.py
      -- extract pages from returned a.a.m. articles
Given a (short) list of URLs, uinmyn-fetch-body.py generates a random
key for the encryption and hsub of the reply, saves the key in a local
database, and constructs the body of the request, encrypted and ready
to send through a remailer chain.
Each message from a.a.m. is then fed to uinmyn-do-aam-article.py.  If
the message matches a key in the database, the key is removed from the
database, the decrypted message is saved for further processing, and
the script returns with a positive code.  Otherwise, the script gives
a negative code.  The script is therefore useful for procmail, which
might be checking the same message for other hits.  The following
.procmailrc clause sequence will send the decrypted "inner posting" to
   :0fW
 uinmyn-do-aam-article.py /path/to/uinmyn_pending_requests_db
   :0a
   ! local-recipient
The net effect, if all goes well, is that the pages addressed by URLs
submitted to uinmyn-fetch-body.py show up, after privacy-protecting
remailer random latencies.  No record leaves your site of who accessed
the pages.
Also provided here is are minor support scripts to list the URLs in a
given reply, and to insert page content into the browser-accessible
cache provided by wwwoffle [2].
Out of respect for your privacy, uinmyn does not require you to access
any web site for its installation or use (though you may if you wish:
mailto:stealthsuite at nym.mixmin.net).  Everything is right here in this
ABOUT THE CODE
Succinctness and readability are given priority here over efficiency.
If efficiency becomes an issue, there are lots of opportunities here
for speedup.
These scripts are meant mainly as hints for you to adapt to the needs
of your particular case.  But they could be used verbatim if you like
the way they are structured.
   Have python, gnupg, and mixmaster installed.
   Have the send at is-not-my.name public key on your gnupg keyring.
   Copy the scripts from below to somewhere on your executables path.
Of course, you are taking a full feed of a.a.m at all times without
interruption, separating wheat from chaff only after it's all behind
closed doors.  Otherwise, the world is informed about which articles
you find interesting.
Remember, long random latency is part of the price of untraceability.
It can't be done with TOR or any other low-latency method.
   uinmyn-fetch-body.py db | mixmaster url at is-not-my.name
      ^D
will send a request for   The key is added
to db, which need not have existed beforehand.  (It's plain ASCII, so
you can look at it to better understand what's happening.)
Later, in a directory full of fresh a.a.m articles, the command
   for f in *; do uinmyn-do-aam-article.py db < $f >> mbox; done
will append the requested content to mbox if it has arrived.
[1] [2] World Wide Web OFFline Explorer    Use PIPE for the gpg stdin in uinmyn-do-aam-article.py.
   Encryption/hsub keys are exposed briefly during a.a.m. processing.
Here are the scripts.
 /usr/bin/python
# SYNOPSIS
#   uinmyn-fetch-body.py # DESCRIPTION
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   url at is-not-my.name, and writes it to standard output.
from os import urandom
from base64 import standard_b64encode
import sys, os
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
# same key for both encryption and hsub:
key  = standard_b64encode(urandom(15))
gpgproc = Popen('gpg -e -a -r send at is-not-my.name --trust-model always --no-emit-version --batch', shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY " + key + '\n')
urls = []
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE ' + line.rstrip() + '\n')
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
uinmyn_pending_requests[key] = urls
new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
new_upr_fd.write('uinmyn_pending_requests =\\\n')
 /usr/bin/python
# SYNOPSIS
#   uinmyn-do-aam-article.py # DESCRIPTION
#   Reads an article from standard input.  If its Subject: might be an
#   hsub, check it against each key in pending-requests-dict in turn.
#   If a hit is found, decrypt the inner posting and write it to
#   standard output.
import sys, os
from hashlib import sha256
import email
import pprint
from subprocess import Popen
UINMYN_PENDING_REQUESTS = sys.argv[1]
posting = email.message_from_file(sys.stdin)
subject = posting.get('Subject')
    iv = subject[:16].decode('hex')
except TypeError:
    sys.exit(1)
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
for key, urls in uinmyn_pending_requests.iteritems():
    if subject == (iv+sha256(iv+key).digest()).encode('hex')[:48]:
        # Doing part of the job in shell:
        gpgproc = Popen('mkfifo $HOME/passwdf ; (echo ' + key + ' > $HOME/passwdf &); echo "' + posting.get_payload() + '" | gpg --passphrase-fd 3 3<$HOME/passwdf --trust-model always --batch 2>/dev/null ; rm $HOME/passwdf', shell=True)
        # Other processing that could be done here:
        #  Deal with discrepancies between requested and obtained URL lists.
        #  Save the used key in an archive, rather than losing it forever.
        del uinmyn_pending_requests[key]
        new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
        new_upr_fd.write('uinmyn_pending_requests =\\\n')
        pprint.pprint(uinmyn_pending_requests,stream=new_upr_fd)
        sys.exit(0)
 /usr/bin/python
# SYNOPSIS
#   uinmyn-list-gotten-urls.py
# DESCRIPTION
#   List the URLs in the url at is-not-my.name "inner mail" on standard
#   input together with the sizes of the fetched pages.
import sys, email
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    print(page.get('Content-Description') + ', size = ' + repr(len(page.get_payload())))
 /usr/bin/python
# SYNOPSIS
#   uinmyn-to-wwwoffle-cache.py
# DESCRIPTION
#   Given a (decrypted) url at is-not-my.name "inner posting", enter each
#   page that it contains into the wwwoffle cache, overlaying any
#   previous content having matching URLs.
import sys, os, email
from subprocess import Popen, PIPE
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    p = Popen('wwwoffle-write ' + page.get('Content-Description'), stdin=PIPE, shell=True)
    p.stdin.write('HTTP/1.0 200 OK\n')
    p.stdin.write('Content-Type: ' + page.get('Content-Type') + '\n\n')
    p.stdin.write(page.get_payload())
    p.stdin.close()
    p.wait()
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite at nym.mixmin.net
Finger for key.

@_date: 2010-07-26 17:33:23
@_author: StealthMonger 
@_subject: uinmyn 0.05 
Hash: SHA1
           _                               ____  ____  ____
     _   _|_|_ __  _ __  __ __  __ _ __   /  _ \/  _ \| ___|
 | | | | '_ \| '_ \'_ \\ \/ /| '_ \  | | | | | | |__ \
 |_| | | | | | | | | | |\  / | | | | | |_| | |_| |__) |
    \__,|_|_|_| |_|_| |_| |_|/ /  |_| |_| \____(_)___/|___/
                            /_/
           _________________________________________
                                         |
                                         |
   IS THIS ANONYMOUS SURFING, OR WHAT?!  |
                                         |
The url at is-not-my.name Internet page fetcher [1] allows one to read
Internet content with strong anonymity.  Content is returned encrypted
in Usenet newsgroup alt.anonymous.messages.  No one, not even the
is-not-my.name administrator, is able to link content being fetched
with any particular user, or with other requests.
Here are some scripts to facilitate use of url at is-not-my.name.
There are two main scripts:
   uinmyn-fetch-body.py
      -- code URLs into a request and save the key
   uinmyn-do-aam-article.py
      -- extract pages from returned a.a.m. articles
Given a (short) list of URLs, uinmyn-fetch-body.py generates a random
key for the encryption and hsub of the reply, saves the key in a local
database, and constructs the body of the request, encrypted and ready
to send through a remailer chain.
Each message from a.a.m. is then fed to uinmyn-do-aam-article.py.  If
the message matches a key in the database, the key is removed from the
database, the decrypted message is saved for further processing, and
the script returns with a positive code.  Otherwise, the script gives
a negative code.
The net effect, if all goes well, is that the pages addressed by URLs
submitted to uinmyn-fetch-body.py show up, after privacy-protecting
remailer random latencies.  No record leaves your site of who accessed
the pages.
Also provided here are minor support scripts to list the URLs in a
given reply, and to insert page content into the browser-accessible
cache provided by wwwoffle [2].
Return codes from uinmyn-do-aam-article.py are useful for procmail,
which might be checking the same message for other hits.  The
following .procmailrc clause sequence will send the decrypted "inner
posting" to local-recipient.
   :0fW
 uinmyn-do-aam-article.py /path/to/uinmyn_pending_requests_db
   :0a
   ! local-recipient
Out of respect for your privacy, uinmyn does not require you to access
any web site for its installation or use (though you may if you wish:
mailto:stealthsuite at nym.mixmin.net).  Everything is right here in this
ABOUT THE CODE
Succinctness and readability are given priority here over efficiency.
If efficiency becomes an issue, there are lots of opportunities here
for speedup.
These scripts are meant mainly as hints for you to adapt to the needs
of your particular case.  But they could be used verbatim if you like.
   Have python, gnupg, and mixmaster installed.
   Have the send at is-not-my.name public key on your gnupg keyring.
   Copy the scripts from below to somewhere on your executables path.
Of course, you are taking a full feed of a.a.m at all times without
interruption, separating wheat from chaff only after it's all behind
closed doors.  Otherwise, the world is informed about which articles
you find interesting.
Remember, long random latency is part of the price of anonymity.  It
can't be done with TOR or any other low-latency method.
   uinmyn-fetch-body.py db | mixmaster url at is-not-my.name
      ^D
will send a request for   The key is
added to db, which need not have existed beforehand.  (It's plain
ASCII, so you can look at it to better understand what's happening.)
Later, in a directory full of fresh a.a.m articles, the command
   for f in *; do uinmyn-do-aam-article.py db < $f >> mbox; done
will append the requested content to mbox if it has arrived.
[1] [2] World Wide Web OFFline Explorer    Encryption/hsub keys are exposed briefly during a.a.m. processing.
CHANGE LOG
   Quote URL in uinmyn-do-aam-article.py against shell interpretation.
   0.04
   Did TODO item:
   Use PIPE for the gpg stdin in uinmyn-do-aam-article.py.
   (eliminating previous stupid size limit).
   0.03
   Add "decode=True" in uinmyn-to-wwwoffle-cache.py to capture coded
   files, such as .pdfs.
   Change the  reference to    0.02
   Add a script to enter gotten pages into a local browser-accessible
   cache.
   Improvements to the documentation.
Here are the scripts.
 /usr/bin/python
# SYNOPSIS
#   uinmyn-fetch-body.py # DESCRIPTION
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   url at is-not-my.name, and writes it to standard output.
from os import urandom
from base64 import standard_b64encode
import sys, os
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
# same key for both encryption and hsub:
key  = standard_b64encode(urandom(15))
gpgproc = Popen('gpg -e -a -r send at is-not-my.name --trust-model always --no-emit-version --batch', shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY " + key + '\n')
urls = []
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE ' + line.rstrip() + '\n')
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
uinmyn_pending_requests[key] = urls
new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
new_upr_fd.write('uinmyn_pending_requests =\\\n')
 /usr/bin/python
# SYNOPSIS
#   uinmyn-do-aam-article.py # DESCRIPTION
#   Reads an article from standard input.  If its Subject: might be an
#   hsub, check it against each key in pending-requests-dict in turn.
#   If a hit is found, decrypt the inner posting and write it to
#   standard output.
import sys, os
from hashlib import sha256
import email
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
posting = email.message_from_file(sys.stdin)
subject = posting.get('Subject')
    iv = subject[:16].decode('hex')
except TypeError:
    sys.exit(1)
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
for key, urls in uinmyn_pending_requests.iteritems():
    if subject == (iv+sha256(iv+key).digest()).encode('hex')[:48]:
        # Doing part of the job in shell:
        gpgproc = Popen('mkfifo $HOME/passwdf ; (echo ' + key + ' > $HOME/passwdf &); gpg --passphrase-fd 3 3<$HOME/passwdf --trust-model always --batch 2>/dev/null ; rm $HOME/passwdf', stdin=PIPE, shell=True)
        gpgproc.stdin.write(posting.get_payload())
        # Other processing that could be done here:
        #  Deal with discrepancies between requested and obtained URL lists.
        #  Save the used key in an archive, rather than losing it forever.
        del uinmyn_pending_requests[key]
        new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
        new_upr_fd.write('uinmyn_pending_requests =\\\n')
        pprint.pprint(uinmyn_pending_requests,stream=new_upr_fd)
        sys.exit(0)
 /usr/bin/python
# SYNOPSIS
#   uinmyn-list-gotten-urls.py
# DESCRIPTION
#   List the URLs in the url at is-not-my.name "inner mail" on standard
#   input together with the sizes of the fetched pages.
import sys, email
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    print(page.get('Content-Description') + ', size = ' + repr(len(page.get_payload())))
 /usr/bin/python
# SYNOPSIS
#   uinmyn-to-wwwoffle-cache.py
# DESCRIPTION
#   Given a (decrypted) url at is-not-my.name "inner posting", enter each
#   page that it contains into the wwwoffle cache, overlaying any
#   previous content having matching URLs.
import sys, os, email
from subprocess import Popen, PIPE
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    p = Popen('wwwoffle-write \'' + page.get('Content-Description') + '\'', stdin=PIPE, shell=True)
    p.stdin.write('HTTP/1.0 200 OK\n')
    p.stdin.write('Content-Type: ' + page.get('Content-Type') + '\n\n')
    p.stdin.write(page.get_payload(decode=True))
    p.stdin.close()
    p.wait()
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite at nym.mixmin.net
Finger for key.

@_date: 2010-05-01 23:28:58
@_author: StealthMonger 
@_subject: Facebook is spooking me - privacy concerns 
Hash: SHA1
What expectation of privacy do you have, using facebook?
As far as I know, facebook can only be accessed through a plain-text
real time connection.  These emissions from your site, along with all
the others, are subject to being archived by your adversary.  Being
plain-text, they can later be used to assemble a dossier on you.
Privacy is lost.

@_date: 2010-05-15 11:44:21
@_author: StealthMonger 
@_subject: hawala in the news again 
Hash: SHA1
Hawala has been discussed in this forum [1] in connection with the
design of digital money systems.  Now hawala is in the news (again).
[1] For example:
   Message-Id:    Date: Mon, 13 Jan 2003 08:21:27 -0500
   To: Digital Bearer Settlement List ,cypherpunks at lne.com
   From: rah at shipwright.com ("R. A. Hettinga")
   Subject: Money laundering regulations
   Sender: owner-cypherpunks at Algebra.COM
Why FBI is following the money in Times Square bomb case
   Three Pakistani men arrested Thursday in Massachusetts and Maine may have used an
   informal network known as hawala to channel funds to alleged Times Square bomber
   Faisal Shahzad, officials say.  Counterterrorism efforts have made it increasingly
   difficult to transfer money by traditional means.
   By Peter Grier, Staff writer / May 14, 2010
   Washington
   Three Pakistani men arrested Thursday in connection with the case of alleged Times
   Square bomber Faisal Shahzad may be connected to an informal money-moving network
   that terror groups are increasingly using to finance their activities.
   The three men may not have known how Shahzad intended to use the money in question,
   say the officials.  Indications are they are not terrorist financiers per se, but
   links in an informal network of brokers, known as hawala, used to transfer cash
   quickly and easily over long distances.
   "Hawala is a popular value transfer method that predates the Western financial
   system and remains less expensive, and at times more widely available, than modern
   banking for transmitting legitimate funds around the world," writes John
   Rollins, a specialist in terrorism and national security with the Congressional
   Research Service, in a March report on terrorists and transnational crime.
   Thursday's high-profile law enforcement sweeps netted two men in Massachusetts
   and one in Maine, according to the FBI.  Sen. Susan Collins (R) of Maine said there
   is no direct connection between the arrestee from her state and Faisal Shahzad.
   Law enforcement officials instead indicated that the Times Square bomb suspect may
   have used hawala money-moving services provided by the men.
   Hawala dealers, also known as hawaladars, operate as part of an informal financial
   network used to bypass the traditional banking system.
   Here's how it works: Say a man in Pakistan wanted to send cash to a colleague in
   the US.  He would visit a hawaladar in his own country and hand over the money, plus
   a fee of about 5 percent.
   The Pakistani hawaladar would communicate with a trusted counterpart in the US, and
   indicate who should get the money, and how much.  The US hawaladar would then make
   the payment.  Usually, no money for that individual transaction actually travels
   between the two countries.  The US hawaladar would simply carry the debt until one
   of hi s clients needed to send money to Pakistan.  Then the whole process would be
   carried out in reverse.
   Hawaladars are supposed to obtain a license in the US, but few do.  It's a
   system that immigrants often use to send remittances back home, and that families
   abroad use to send money to, say, students in the US.
   But counterterrorist efforts have made it increasingly difficult for Al Qaeda and
   its associated groups to send money through the regular banking system.
   Increasingly the US and other nations have turned their scrutiny to the more
   informal hawaladars, said David Cohen, assistant secretary for terrorist financing
   at the US Department of Treasury, in January remarks before the Council on Foreign
   Relations.
   "As we have become more successful in preventing the abuse of the formal
   financial system, illicit finance has increasingly migrated to these other
   transmission techniques," said Mr. Cohen.
   According to Cohen, Al Qaeda's traditional sources of funds, such as donors
   and charities in Saudi Arabia and other Gulf countries, have dried up due to world
   counterterrorism efforts.  Top Al Qaeda leaders in recent months have taken the
   unusual step of issuing public pleas for funds.
   "Al Qaeda is in its worst financial state in years," Cohen said in April
   at a luncheon sponsored by the Washington Institute for Near East Policy.
   According to news reports, Al Qaeda has even begun charging some recruits for
   training.  The going rate for an AK-47 rifle, ammunition, and grenades is about
   $1,200.
   But terrorist attacks in Western countries do not cost a lot of money.  The 2004
   Madrid subway bombings cost a total of about $10,000, f or instance, according to
   an estimate by the Financial Action Task Force, an intergovernmental antiterrorist
   group.
   Regardless of the amount, US counterterrorism officials still take a cue from what
   Deep Throat told Washington Post reporter Bob Woodward during the Watergate
   investigation: "Follow the money."
   These days, that's a challenge.
   "The international community faces a daunting challenge in confronting global
   terrorism financing," Cohen told the Washington Institute luncheon.  "The task is
   especially tough in today's environment, with money constantly crossing
   borders and rocketing around the globe."

@_date: 2010-11-30 03:28:27
@_author: StealthMonger 
@_subject: any moment now ... 
Hash: SHA1
If by "secure" you mean that the individual doing the browsing cannot
be traced, note that in any low-latency Internet access, packet timing
correlations between the parties can easily confirm any suspected
linkage.  As the Tor documentation itself states,
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
More difficult to trace is Internet access by email via the remailer
network.  See my "uinmyn", URL below.
 -- StealthMonger     Long, random latency is part of the price of Internet anonymity.
   uinmyn: Is this anonymous surfing, or what?
      stealthmail: Hide whether you're doing email, or when, or with whom.
   mailto:stealthsuite at nym.mixmin.net?subject=send%20index.html
Key: mailto:stealthsuite at nym.mixmin.net?subject=send%20stealthmonger-key

@_date: 2011-02-23 01:32:49
@_author: StealthMonger 
@_subject: Feasibility of Using TOR or VPNs For Anonymity 
Hash: SHA1
Your skepticism is fitting.  In fact, even the TOR documentation
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
      uinmyn: Is this anonymous browsing, or what?
      stealthmail: Hide whether you're doing email, or when, or with whom.
   mailto:stealthsuite at nym.mixmin.net?subject=send%20index.html
Good stuff.  Stick with it.
 -- StealthMonger     Long, random latency is part of the price of Internet anonymity.
Key: mailto:stealthsuite at nym.mixmin.net?subject=send%20stealthmonger-key

@_date: 2011-03-04 08:30:48
@_author: StealthMonger 
@_subject: [Freedombox-discuss] Store-and-forward is a necessity 
Hash: SHA1
Absolutely.  And another application where store and forward message
passing is critical is to allow long, random latency at each stop.
Anonymizing remailers [1] need this to mix messages and thwart traffic
analysis.  Long, random latency is part of the price of anonymity.
Add to that list:
 * Support anonymizing remailers having long, random latency to mix
   messages and thwart traffic analysis.
Send encrypted ACKs via message pools which are broadcast worldwide,
such as Usenet alt.anonymous.messages [2].  Each interested party
checks all pool messages and decrypts her own.
And later in this thread, michiel at unhosted.org (Michiel de Jong)
suggests the good idea of extending Usenet to Freedombox hosts:
"Extending Usenet to a new medium" would be more accurate.  Usenet has
not died.  Probably the NNTP Usenet protocol can be adapted to the
Freedom Protocol.
Moreover, pools can be used for both sides of a dialog, not just the
ACKs.  See stealthmail [3].
[1] [2] [3] mailto:stealthsuite at nym.mixmin.net?subject=send%20index.html
 -- StealthMonger Key: mailto:stealthsuite at nym.mixmin.net?subject=send%20stealthmonger-key
Freedombox-discuss mailing list
Freedombox-discuss at lists.alioth.debian.org

@_date: 2011-03-16 00:08:10
@_author: StealthMonger 
@_subject: uinmyn 0.06 
Hash: SHA1
   The Internet is even more powerful at protecting privacy than it is
   at destroying it.
    --- StealthMonger
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
    ---    Long, random latency is part of the price of Internet anonymity.
    --- StealthMonger
           _                               ____  ____   __
     _   _|_|_ __  _ __  __ __  __ _ __   /  _ \/  _ \ / /
 | | | | '_ \| '_ \'_ \\ \/ /| '_ \  | | | | | | |  ^\
 |_| | | | | | | | | | |\  / | | | | | |_| | |_| | () |
    \__,|_|_|_| |_|_| |_| |_|/ /  |_| |_| \____(_)___/\___/
                            /_/
           __________________________________________
                                          |
                                          |
   IS THIS ANONYMOUS BROWSING, OR WHAT?!  |
                                          |
The url at is-not-my.name Internet page fetcher [1] allows the reading of
Internet content with strong anonymity.  An encrypted request is sent
through a chain of anonymizing remailers and content is returned
encrypted in Usenet newsgroup alt.anonymous.messages.  No one, not
even the is-not-my.name administrator, is able to link content being
fetched with any particular user, or with other requests.
Here are some scripts to facilitate use of url at is-not-my.name.
There are two main scripts:
   uinmyn-fetch-body.py
      -- code URLs into a request and save the key
   uinmyn-do-aam-article.py
      -- extract pages from returned a.a.m. articles
Given a (short) list of URLs, uinmyn-fetch-body.py generates a random
key for the encryption and hsub of the reply, saves the key in a local
database, and constructs the body of the request, encrypted and ready
to send through a remailer chain.
Each message from a.a.m. is then fed to uinmyn-do-aam-article.py.  If
the message matches a key in the database, the key is removed from the
database, the decrypted message is saved for further processing, and
the script returns with a positive code.  Otherwise, the script gives
a negative code.
The net effect, if all goes well, is that the pages addressed by URLs
submitted to uinmyn-fetch-body.py show up, after privacy-protecting
remailer random latencies.  No record leaves the requester's site of
who accessed the pages.
Also provided here are minor support scripts to list the URLs in a
given reply, and to insert page content into the browser-accessible
cache provided by wwwoffle [2].
Return codes from uinmyn-do-aam-article.py are useful for procmail,
which might be checking the same message for other hits.  The
following .procmailrc clause sequence will send the decrypted "inner
posting" to local-recipient.
   :0fW
 uinmyn-do-aam-article.py /path/to/uinmyn_pending_requests_db
   :0a
   ! local-recipient
Out of respect for your privacy, uinmyn does not require you to access
any web site for its installation or use (though you may if you wish:
mailto:stealthsuite at nym.mixmin.net?subject=send%20index.html).
Everything is right here in this posting.
ABOUT THE CODE
Succinctness and readability are given priority here over efficiency.
If efficiency becomes an issue, there are lots of opportunities here
for speedup.
These scripts are meant mainly as hints for you to adapt to the needs
of your particular case.  But they could be used verbatim if you like.
   Have python, gnupg, and mixmaster installed.
   Have the send at is-not-my.name public key on your gnupg keyring.
   Copy the scripts from below to somewhere on your executables path.
Of course, you are taking a full feed of a.a.m at all times without
interruption, separating wheat from chaff only after it's all behind
closed doors.  Otherwise, the world is informed about which articles
you find interesting.
Remember, long random latency is part of the price of anonymity.  It
can't be done with TOR or any other low-latency method.
   uinmyn-fetch-body.py db | mixmaster url at is-not-my.name
      ^D
will send a request for   The key is
added to db, which need not have existed beforehand.  (It's plain
ASCII, so you can look at it to better understand what's happening.)
Later, in a directory full of fresh a.a.m articles, the command
   for f in *; do uinmyn-do-aam-article.py db < $f >> mbox; done
will append the requested content to mbox if it has arrived.
[1] [2] World Wide Web OFFline Explorer    Encryption/hsub keys are exposed briefly during a.a.m. processing.
CHANGE LOG
   0.06
   Add time-stamps to database entries to facilitate removal of old,
   stale entries.
   Changed slogan from "Is this anonymous surfing, or what?".
   Documentation improvements.
   0.05
   Quote URL in uinmyn-do-aam-article.py against shell interpretation.
   0.04
   Did TODO item:
   Use PIPE for the gpg stdin in uinmyn-do-aam-article.py.
   (eliminating previous stupid size limit).
   0.03
   Add "decode=True" in uinmyn-to-wwwoffle-cache.py to capture coded
   files, such as .pdfs.
   Change the  reference to    0.02
   Add a script to enter gotten pages into a local browser-accessible
   cache.
   Improvements to the documentation.
Here are the scripts.
 /usr/bin/python
# SYNOPSIS
#   uinmyn-fetch-body.py # DESCRIPTION
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   url at is-not-my.name, and writes it to standard output.
from os import urandom
from base64 import standard_b64encode
import sys, os, time
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
# same key for both encryption and hsub:
key  = standard_b64encode(urandom(15))
gpgproc = Popen('gpg -e -a -r send at is-not-my.name --trust-model always --no-emit-version --batch', shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY " + key + '\n')
urls = [time.time()] # time-tag precedes the urls in the db entry
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE ' + line.rstrip() + '\n')
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
uinmyn_pending_requests[key] = urls
new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
new_upr_fd.write('uinmyn_pending_requests =\\\n')
 /usr/bin/python
# SYNOPSIS
#   uinmyn-do-aam-article.py # DESCRIPTION
#   Reads an article from standard input.  If its Subject: might be an
#   hsub, check it against each key in pending-requests-dict in turn.
#   If a hit is found, decrypt the inner posting and write it to
#   standard output.
import sys, os
from hashlib import sha256
import email
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
posting = email.message_from_file(sys.stdin)
subject = posting.get('Subject')
    iv = subject[:16].decode('hex')
except TypeError:
    sys.exit(1)
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
for key, urls in uinmyn_pending_requests.iteritems():
    if subject == (iv+sha256(iv+key).digest()).encode('hex')[:48]:
        # Doing part of the job in shell:
        gpgproc = Popen('mkfifo $HOME/passwdf ; (echo ' + key + ' > $HOME/passwdf &); gpg --passphrase-fd 3 3<$HOME/passwdf --trust-model always --batch 2>/dev/null ; rm $HOME/passwdf', stdin=PIPE, shell=True)
        gpgproc.stdin.write(posting.get_payload())
        # Other processing that could be done here:
        #  Deal with discrepancies between requested and obtained URL lists.
        #  Save the used key in an archive, rather than losing it forever.
        del uinmyn_pending_requests[key]
        new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
        new_upr_fd.write('uinmyn_pending_requests =\\\n')
        pprint.pprint(uinmyn_pending_requests,stream=new_upr_fd)
        sys.exit(0)
 /usr/bin/python
# SYNOPSIS
#   uinmyn-list-gotten-urls.py
# DESCRIPTION
#   List the URLs in the url at is-not-my.name "inner mail" on standard
#   input together with the sizes of the fetched pages.
import sys, email
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    print(page.get('Content-Description') + ', size = ' + repr(len(page.get_payload())))
 /usr/bin/python
# SYNOPSIS
#   uinmyn-to-wwwoffle-cache.py
# DESCRIPTION
#   Given a (decrypted) url at is-not-my.name "inner posting", enter each
#   page that it contains into the wwwoffle cache, overlaying any
#   previous content having matching URLs.
import sys, os, email
from subprocess import Popen, PIPE
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    p = Popen('wwwoffle-write \'' + page.get('Content-Description') + '\'', stdin=PIPE, shell=True)
    p.stdin.write('HTTP/1.0 200 OK\n')
    p.stdin.write('Content-Type: ' + page.get('Content-Type') + '\n\n')
    p.stdin.write(page.get_payload(decode=True))
    p.stdin.close()
    p.wait()
 -- StealthMonger     Long, random latency is part of the price of Internet anonymity.
   stealthmail: Hide whether you're doing email, or when, or with whom.
   mailto:stealthsuite at nym.mixmin.net?subject=send%20index.html
Key: mailto:stealthsuite at nym.mixmin.net?subject=send%20stealthmonger-key

@_date: 2011-05-31 04:36:18
@_author: StealthMonger 
@_subject: NYT Discovers Privacy! 
Hash: SHA1
What a disappointment!
On reading that Subject: line, my first thought was "Ah!  NYT have
decided to accept anonymous cash for electronic newspapers!"
But discovering in the first paragraphs that it was a blog about email
privacy, I still hoped that the blogger would conclude by pointing out
that it IS, after all, possible to do secure, even stealthy, email.
But, no.  Instead we find
I guess she never heard of encryption or stealthmail.  How sad.

@_date: 2011-11-23 17:10:13
@_author: StealthMonger 
@_subject: [serval-project-dev] We have store-and-forward SMS working 
Hash: SHA1
Could this enable phone-based anonymizing remailers having long random
latency for mixing?  How much memory is available, typically?
I know, this question belongs on the serval-project-developers mailing
list, so I'm trying to subscribe there now.
   This service uses direct mesh links if they are available by making
   use of the existing SMS capability in the Serval BatPhone software.
   However, if there is no direct link, then it uses a
   store-and-forward scheme, that asks any passing phones to copy the
   message and distribute it to other phones on the mesh, until it
   (hopefully) eventually reaches its intended destination.
Reinventing SMTP! :)
   While the delay in such a service is huge, the bandwidth is also
   great, as potentially gigabytes of data can be transferred between
   nodes.
These are both valuable attributes for anonymizing remailers.

@_date: 2011-10-31 14:57:17
@_author: StealthMonger 
@_subject: Good free mildly-private email service? 
Hash: SHA1
Have you considered stealthmail?  See mailto: below.
   Package: stealthmail
   Architecture: all
   Pre-Depends: gnupg
   Depends: procmail, esubbf, openssl, dc, libssl0.9.6 | libssl0.9.7,
    fetchmail | kmail, suck, ppp, solid-pop3d, exim | exim4, dpkg (>= 1.10.21),
    grep (>= 2.5), bash (>= 2.05b), ${shlibs:Depends}, ${misc:Depends}
   Description: scripts to hide whether you're doing email, or when, or with whom
    Maintain on-going random cover traffic via usenet newsgroup
    alt.anonymous.messages, substituting encrypted live traffic when
    available.  A live message is indistinguishable from a random cover
    message except with the decryption keys.  All potential participants
    send messages to alt.anonymous.messages with rigid periodicity
    uncorrelated with any live traffic, and maintain an uninterrupted
    full feed from alt.anonymous.messages, so that an observer cannot
    determine whether, when, or among whom live communication is
    happening.
    .
    Members of a "stealthmail group" -- call it "OurGroup" for purposes
    of this discussion -- are defined by their knowledge of the
    encryption keys created for the group.  With this package installed,
    mail addressed to OurGroup at stealthmail does not go directly to the
    Internet like ordinary mail, but gets encrypted by the OurGroup key,
    given an encrypted subject intelligible only with OurGroup keys, and
    queued to go to alt.anonymous.messages in place of a piece of cover
    traffic at the next scheduled sending time.  Meanwhile, all messages
    appearing on alt.anonymous.messages are downloaded into an incoming
    queue.  A POP3 server runs on the local host.  The mail reader is
    provided with filters so that when it fetches mail from this local
    server, messages having subject lines encrypted for OurGroup (or any
    other stealthmail group of which this host is a member) are decrypted
    by the appropriate key and presented.  Other messages are discarded.

@_date: 2011-10-31 15:45:46
@_author: StealthMonger 
@_subject: Good free mildly-private email service? 
Hash: SHA1
Have you considered stealthmail?  See mailto: below.
   Package: stealthmail
   Architecture: all
   Pre-Depends: gnupg
   Depends: procmail, esubbf, openssl, dc, libssl0.9.6 | libssl0.9.7,
    fetchmail | kmail, suck, ppp, solid-pop3d, exim | exim4, dpkg (>= 1.10.21),
    grep (>= 2.5), bash (>= 2.05b), ${shlibs:Depends}, ${misc:Depends}
   Description: scripts to hide whether you're doing email, or when, or with whom
    Maintain on-going random cover traffic via usenet newsgroup
    alt.anonymous.messages, substituting encrypted live traffic when
    available.  A live message is indistinguishable from a random cover
    message except with the decryption keys.  All potential participants
    send messages to alt.anonymous.messages with rigid periodicity
    uncorrelated with any live traffic, and maintain an uninterrupted
    full feed from alt.anonymous.messages, so that an observer cannot
    determine whether, when, or among whom live communication is
    happening.
    .
    Members of a "stealthmail group" -- call it "OurGroup" for purposes
    of this discussion -- are defined by their knowledge of the
    encryption keys created for the group.  With this package installed,
    mail addressed to OurGroup at stealthmail does not go directly to the
    Internet like ordinary mail, but gets encrypted by the OurGroup key,
    given an encrypted subject intelligible only with OurGroup keys, and
    queued to go to alt.anonymous.messages in place of a piece of cover
    traffic at the next scheduled sending time.  Meanwhile, all messages
    appearing on alt.anonymous.messages are downloaded into an incoming
    queue.  A POP3 server runs on the local host.  The mail reader is
    provided with filters so that when it fetches mail from this local
    server, messages having subject lines encrypted for OurGroup (or any
    other stealthmail group of which this host is a member) are decrypted
    by the appropriate key and presented.  Other messages are discarded.

@_date: 2011-09-18 20:18:42
@_author: StealthMonger 
@_subject: anonget 1.0 (formerly uinmyn) 
Hash: SHA1
NEW IN THIS RELEASE
anonget (1.0)
  * Name change from "uinmyn" (last version was 0.07)
  * Optional send confirmation now available, providing a progress
    report of the URL request and to help diagnose failures.
  * Reformat anonget-list-gotten-urls.py output for easier reading.
  * Change "is-not-my.name" to "mixnym.net".
  * Rewrite the documentation.
                                          _     __   ___
     _______ __  ____  _ __  _____ ____ _| |_  /  | / _ \
    /  _  | '_ \/  _ \| '_ \/  _ //  _ \_   _|  | || | | |
 |_| | | | | |_| | | | | |_| | |/ / | |    | || |_| |
    \___/_|_| |_\____/|_| |_\  __/ \___/ |__|  /___O\___/
                            / /__
           __________________________________________
                                          |
                                          |
   IS THIS ANONYMOUS BROWSING, OR WHAT?!  |
                                          |
N.B.: Below, replace all occurrences of "" with "
WHAT IS IT?
anonget facilitates browsing the Internet with strong anonymity via
urlmixnym.net [1].
HOW IT WORKS
Given a list of URLs, anonget encrypts the list and a fresh random key
and formats it for mailing by mixmaster [2] to urlmixnym.net
through a chain of anonymizing remailers.  The request contains
nothing to identify you or your site, and the outgoing mail is
indistinguishable from other remailer traffic that you may generate.
urlmixnym.net then gets the requested information from the
Internet, encrypts it to the fresh key, and broadcasts it worldwide on
Usenet newsgroup alt.anonymous.messages.
The fresh key (saved by anonget) is used to recognize and decrypt the
No one, not even the mixnym.net administrator, is able to link content
being fetched with any particular user, or with other requests.
EXAMPLE 1
The command
   echo  | anonget-fetch-body.py db \
 mixmaster urlmixnym.net
generates a fresh random key for the encryption and hsub of the reply,
adds the key to db (which need not have existed beforehand), formats
and encrypts key and list of URLs (just in this case) as required by urlmixnym.net, and sends it.  db is
plain ASCII, so you can look at it to better see what's happening.
Later, in a directory full of fresh a.a.m articles, the command
   for f in *; do anonget-do-aam-article.py db < $f >> mbox; done
will append the requested content to mbox if it has arrived.
ADDING SEND CONFIRMATION
Alternatively, a request can be formulated to not only get the wanted
information as above, but to send confirmation that it was mailed from
the last remailer in the chain.  This provides a progress report of
the request and can help to diagnose failures.  A copy of the request
is sent to a mail-to-news gateway with Subject: another hsub generated
with the same fresh key.
EXAMPLE 2
   (echo 'Chain: *,*,kulin'; echo  \
 anonget-fetch-whole.py db) | mixmaster
Unlike anonget-fetch-body.py of example 1, anonget-fetch-whole.py
generates a whole mail, including To:, Cc:, and Subject: headers,
instead of relying on mixmaster to provide them.  (Yet more headers,
like the Chain: in example 2, can be added as shown.  Note the
parentheses in the command.)
When anonget-do-aam-article.py processes the article in example 1, it
emits the inner reply mail and deletes the db entry.  But when it
senses that the article is not the returned data, but the request
itself, it constructs a confirmation message and leaves the db entry
intact.  (Note that if the fetched data get processed before the
request confirmation (due to net lag), the request confirmation will
not be noticed because the database entry will already have been
deleted.  But in this case it doesn't matter.)
CACHING OR ARCHIVING THE REPLY, AND RENDERING IT
A convenient way to save and render an anonget reply is to insert it
into the browser-accessible cache provided by wwwoffle [3].  The
script anonget-to-wwwoffle-cache.py is provided for this purpose.
To just list the URLs contained in an "inner mail", the script
anonget-list-gotten-urls.py can be applied.
AUTOMATIC DISPOSITION OF THE REPLY
Instead of the explicit anonget-do-aam-article.py command above,
procmail [4] can be used to forward the reply as local configuration
may require.  Return codes from anonget-do-aam-article.py are useful
for procmail, which might be checking the same message for other hits.
The following .procmailrc clause sequence will send the decrypted
"inner posting" to "local-recipient".
   :0fW
 anonget-do-aam-article.py /path/to/anonget_pending_requests_db
   :0a
   ! local-recipient
RESPECTING YOUR PRIVACY
Out of respect for your privacy, anonget doesn't require you to access
any web site for its installation or use (though you may if you wish:
Everything is right here in this posting.
ABOUT THE CODE
Succinctness and readability are given priority here over efficiency.
If efficiency becomes an issue, there are lots of opportunities here
for speedup.
These scripts are meant mainly as hints for you to adapt to the needs
of your particular case.  But they could be used verbatim if you like.
   Have python, gnupg, and mixmaster installed.
   Have public key '94F204C28BF00937EFC85D1AFF4DB66014D0C447' on your
      gnupg keyring.
   Copy the scripts from below to somewhere on your executables path.
Of course, you are taking a full feed of a.a.m at all times without
interruption, separating wheat from chaff only after it's all behind
closed doors.  Otherwise, the world is informed about which articles
you find interesting.
Remember, long random latency is part of the price of anonymity.  It
can't be done with TOR or any other low-latency method.
[1] [2] [3] WWW OFFLine Explorer [4] CHANGE LOG
   0.07
   Use long keyid, not sendmixnym.net, to identify encryption
   key, foiling fake key postings.  Contributed by Steve Crook.
   Use Python's internal encode('base64') instead of imported Base64
   to encode the random key.  Contributed by Steve Crook.
   Use Python "%"-style string substitution for type conversion and
   tidier code (yet to be finished).  Contributed by Steve Crook.
   Support hsub's ranging from 48 to 80 chars in length.  Contributed
   by Steve Crook.
   Systematically code all email addresses to avert Google corruption
   of its archived version of this posting.
   0.06
   Add time-stamps to database entries to facilitate removal of old,
   stale entries.
   Changed slogan from "Is this anonymous surfing, or what?".
   Documentation improvements.
   0.05
   Quote URL in uinmyn-do-aam-article.py against shell interpretation.
   0.04
   Did TODO item:
   Use PIPE for the gpg stdin in uinmyn-do-aam-article.py.
   (eliminating previous stupid size limit).
   0.03
   Add "decode=True" in uinmyn-to-wwwoffle-cache.py to capture coded
   files, such as .pdfs.
   Change the  reference to    0.02
   Add a script to enter gotten pages into a local browser-accessible
   cache.
   Improvements to the documentation.
Here are the scripts.
8<--------8<------- anonget-fetch-body.py --------8<--------8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-fetch-body.py # DESCRIPTION
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   urlmixnym.net, and writes it to standard output.
from os import urandom
import sys, os, time
import pprint
from subprocess import Popen, PIPE
ANONGET_PENDING_REQUESTS = sys.argv[1]
NYMSERV_KEY = '94F204C28BF00937EFC85D1AFF4DB66014D0C447'
# same key for both encryption and hsub:
key  = urandom(15).encode('base64').rstrip()
gpgcmd = 'gpg --armor --encrypt --recipient %s ' % NYMSERV_KEY
gpgopts = '--trust-model always --no-emit-version --batch'
gpgproc = Popen(gpgcmd + gpgopts, shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY %s\n" % key)
urls = [time.time()] # time-tag precedes the urls in the db entry
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE %s\n' % line.rstrip())
# Not dealt with here: Mutually exclusive access to the
# ANONGET_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(ANONGET_PENDING_REQUESTS):
    execfile(ANONGET_PENDING_REQUESTS)
    anonget_pending_requests = {}
anonget_pending_requests[key] = urls
new_upr_fd = open(ANONGET_PENDING_REQUESTS, 'w')
new_upr_fd.write('anonget_pending_requests =\\\n')
8<--------8<------- anonget-do-aam-article.py ----8<--------8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-do-aam-article.py # DESCRIPTION
#   Reads an article from standard input.  If its Subject: might be an
#   hsub, check it against each key in pending-requests-dict in turn.
#   If a hit is found, decrypt the inner posting and write it to
#   standard output.
import sys, os
from hashlib import sha256
import email
import pprint
from subprocess import Popen, PIPE
ANONGET_PENDING_REQUESTS = sys.argv[1]
posting = email.message_from_file(sys.stdin)
# Abort if Subject doesn't exist, otherwise get its length
if 'Subject' in posting:
    sublen = len(posting['Subject'])
    # No Subject, no hSub.
    sys.exit(1)
# hSubs must fall within the length criteria
if sublen < 48 or sublen > 80:
    sys.exit(1)
    iv = posting['subject'][:16].decode('hex')
except TypeError:
    sys.exit(1)
# Not dealt with here: Mutually exclusive access to the
# ANONGET_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(ANONGET_PENDING_REQUESTS):
    execfile(ANONGET_PENDING_REQUESTS)
    anonget_pending_requests = {}
for key, urls in anonget_pending_requests.iteritems():
    hsub = (iv + sha256(iv + key).digest()).encode('hex')[:sublen]
    if posting['Subject'] == hsub:
        # Doing part of the job in shell:
        gpgproc = Popen('mkfifo $HOME/passwdf ; (echo ' + key + ' > $HOME/passwdf &); gpg --passphrase-fd 3 3<$HOME/passwdf --trust-model always --batch ; rm $HOME/passwdf', stdin=PIPE, stderr=PIPE, shell=True)
        gpgstderr = gpgproc.communicate(input=posting.get_payload())[1]
        if gpgstderr.find('decryption failed') < 0:
            # Other processing that could be done here:
            #  Deal with discrepancies between requested and obtained URL lists.
            #  Save the used key in an archive, rather than losing it forever.
            del anonget_pending_requests[key]
            new_upr_fd = open(ANONGET_PENDING_REQUESTS, 'w')
            new_upr_fd.write('anonget_pending_requests =\\\n')
            pprint.pprint(anonget_pending_requests,stream=new_upr_fd)
            sys.exit(0)
        else:
            # gpg says 'decryption failed'; assume it's a send confirmation.
            print 'Subject: URL request send confirmation ' + key
            print ''
            print 'Key: ' + key
            print 'Request-time: ' + str(urls[0])
            print 'URLs: ' + str(urls[1:])
            print 'gpg-stderr:'
            print gpgstderr
            sys.exit(0)
8<--------8<--------8<------- anonget-fetch-whole.py -------8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-fetch-whole.py # DESCRIPTION
#   Alternative to anonget-fetch-body.py includes send confirmation.
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   urlmixnym.net, and writes it to standard output, prepended
#   with mail headers for send confirmation.
from os import urandom
from hashlib import sha256
import sys, os, time
import pprint
from subprocess import Popen, PIPE
from datetime import datetime
ANONGET_PENDING_REQUESTS = sys.argv[1]
NYMSERV_KEY = '94F204C28BF00937EFC85D1AFF4DB66014D0C447'
HSUBLEN = 48
# same key for both encryption and hsub:
key  = urandom(15).encode('base64').rstrip()
# Mail headers
print 'To: urlmixnym.net'
datestring = datetime.utcnow().strftime("%Y%m%d")
print 'Cc: mail2news-' + datestring + '-alt.anonymous.messagesm2n.mixmin.net'
iv = urandom(8)                 # hsub code adapted from that of Steve Crook
hsub = (iv + sha256(iv + key).digest()).encode('hex')[:HSUBLEN]
print 'Subject: ' + hsub
print ''
sys.stdout.flush()              # so headers definitely precede body
gpgcmd = 'gpg --armor --encrypt --recipient %s ' % NYMSERV_KEY
gpgopts = '--trust-model always --no-emit-version --batch'
gpgproc = Popen(gpgcmd + gpgopts, shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY %s\n" % key)
urls = [time.time()] # time-tag precedes the urls in the db entry
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE %s\n' % line.rstrip())
# Not dealt with here: Mutually exclusive access to the
# ANONGET_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(ANONGET_PENDING_REQUESTS):
    execfile(ANONGET_PENDING_REQUESTS)
    anonget_pending_requests = {}
anonget_pending_requests[key] = urls
new_upr_fd = open(ANONGET_PENDING_REQUESTS, 'w')
new_upr_fd.write('anonget_pending_requests =\\\n')
8<--------8<--------8<------- anonget-list-gotten-urls.py --8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-list-gotten-urls.py
# DESCRIPTION
#   List the URLs in the urlmixnym.net "inner mail" on standard
#   input together with the sizes of the fetched pages.
import sys, email
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    print repr(len(page.get_payload())).rjust(8),page.get('Content-Description')
8<--------8<--------8<------- anonget-to-wwwoffle-cache.py -8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-to-wwwoffle-cache.py
# DESCRIPTION
#   Given a (decrypted) urlmixnym.net "inner posting", enter each
#   page that it contains into the wwwoffle cache, overlaying any
#   previous content having matching URLs.
import sys, os, email
from subprocess import Popen, PIPE
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    p = Popen('wwwoffle-write \'' + page.get('Content-Description') + '\'', stdin=PIPE, shell=True)
    p.stdin.write('HTTP/1.0 200 OK\n')
    p.stdin.write('Content-Type: ' + page.get('Content-Type') + '\n\n')
    p.stdin.write(page.get_payload(decode=True))
    p.stdin.close()
    p.wait()
 -- StealthMonger nym.mixmin.net>
    Long, random latency is part of the price of Internet anonymity.
Key: mailto:stealthsuitenym.mixmin.net?subject=send%20stealthmonger-key

@_date: 2012-04-23 04:02:38
@_author: StealthMonger 
@_subject: [liberationtech] Jacob Appelbaum's Ultrasurf Report 
Hash: SHA1
On the contrary:
Tor has a serious weakness in that it uses a low-latency connection
between user and server, allowing anonymity to be broken with simple
packet timing correlation.  Even the Tor documentation states
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
    --- Long, random latency is part of the price of Internet anonymity.  And
there are competitors to Tor (open source), which use long, random
latency.  The basic idea is to use store-and-forward communication
such as email and Usenet to allow the long random latency on which
anonymity depends.  This can be done by mailing an access request
through a chain of anonymizing remailers to a web-to-mail gateway,
with a return address contrived to cause the fetched information to be
broadcast world-wide on Usenet.  The requester watches for it there
and plucks it when it arrives.
Usenet and the remailer network are well-known.  There are several
web-to-mail gateways.  The easiest these days is url at mixnym.net, and
an easy way to use it is with (open source) anonget, see below.

@_date: 2012-08-26 11:40:13
@_author: StealthMonger 
@_subject: Hawala on the big screen 
Hash: SHA1
For a dramatic and touching story of hawala in use, see the current
film release "Premium Rush".
Lots of bicycle action, too, if you like that.

@_date: 2012-12-02 23:11:16
@_author: StealthMonger 
@_subject: Fwd: [IP] Darn thing works  -- Application that provides   
Hash: SHA1
Assuming the correspondents exchange keys out of band, this looks like
true end-to-end encryption, the keys residing on the users' respective
machines.  If so, server compromise can cause loss of service but no
confidentiality or authentication breach.
Please correct me if I'm wrong.  Otherwise, this looks like an
important new option for those who love their webmail, especially
after the Firefox version becomes available.

@_date: 2012-12-10 22:07:23
@_author: StealthMonger 
@_subject: [liberationtech] Mailvelope: OpenPGP Encryption for Webmail 
Hash: SHA1
To compare it with CryptoCat is unfair to MailVelope.  As I understand
things, CryptoCat has an ongoing reliance on server integrity.  On the
other hand, MailVelope is self-contained once securely installed, thus
providing true peer-to-peer confidentiality and authentication
(assuming that the correspondents have confirmed keys out-of-band).
Please correct this if in error.

@_date: 2012-12-12 23:22:28
@_author: StealthMonger 
@_subject: [liberationtech] Mailvelope: OpenPGP Encryption for Webmail 
Hash: SHA1
So unless and until the Mailvelope author(s) remedy this, support for
Mailvelope has to be muted.
However, comparison with Cryptocat is still unfitting because
Cryptocat does not even pretend to do store-and-forward authenticated
email using public key cryptography.  In fact, its author asserts [1]
   2. Cryptocat does not mean to compete with GPG, it means to replace *
   plaintext.*
[1] Date: Mon, 6 Aug 2012 18:14:33 -0700 Message-ID:

@_date: 2012-11-03 23:53:46
@_author: StealthMonger 
@_subject: [liberationtech] Bitcoin and The Public Function of Money 
Hash: SHA1
Not true.  Look at the sources:
   ... Bitcoin can be considered to be another variety of cash,
   i.e. digital cash. ... and cash can also be used for tax evasion
   purposes. [1] [2]
   Bitcoin prevents inflation and helps tax evation [sic] (the system
   itself is hard to regulate) [3]
States describe their pronouncements as "law" in an effort make them
Are you suggesting that there is something unkind or thoughtless about
promoting a free market?
Seems to be on-topic.  From the liberationtech Info Page:
   The Program on Liberation Technology "Liberationtech" seeks to
   understand how information technology can be used to defend human
   rights, improve governance, empower the poor, promote economic
   development, and pursue a variety of other social goods. [4]
By these criteria, Bitcoin discussion qualifies.
Resource starvation?  Anonymous markets have thrived throughout
history, and probably before.
[1] [2] "tax evasion" is their euphemism for successful defense against
their extortion.
[3] [4]

@_date: 2013-08-09 14:18:13
@_author: StealthMonger 
@_subject: [tor-talk] Secure email with limited usable metadata 
Precisely the opposite is the case.  Email can go by way of anonymizing
remailers, while real-time communications are vulnerable to IP packet
time and volume correlation at the end points.  With email, the security
is in the message, not in the connection.

@_date: 2013-08-26 00:54:03
@_author: StealthMonger 
@_subject: Who bought off Zimmermann? 
How ironic and sad it is that Phil Zimmermann, the author of PGP, has
become so imbued with the enterprise culture that he's now so blind to
the original peer-to-peer spirit of PGP that he would say things like
   There is no way to do encrypted e-mail where the content is
   protected.  [1]
This is simply false.
If sender and receiver exchange keys out-of-band and nobody else knows
the keys, the content can have cryptographically strong protection.
Why would Zimmermann allow himself to be bought off?  What kind of
pressure is being brought to bear?  Is this protracted world-class human
engineering in action?
[1]

@_date: 2013-08-27 17:16:11
@_author: StealthMonger 
@_subject: Metadata anonymization through time delayed email messaging. 
Thank you danimoth for making that connection.  [Will they never learn?]

@_date: 2013-08-31 20:04:38
@_author: StealthMonger 
@_subject: Who bought off Zimmermann? 
Yep.  World-class protracted human engineering.  Maybe it takes a poet
like John Young to express it.
Thanks John for identifying for us non-poets your intended targets.

@_date: 2013-08-09 14:18:13
@_author: StealthMonger 
@_subject: [tor-talk] Secure email with limited usable metadata 
Precisely the opposite is the case.  Email can go by way of anonymizing
remailers, while real-time communications are vulnerable to IP packet
time and volume correlation at the end points.  With email, the security
is in the message, not in the connection.

@_date: 2013-08-26 00:54:03
@_author: StealthMonger 
@_subject: Who bought off Zimmermann? 
How ironic and sad it is that Phil Zimmermann, the author of PGP, has
become so imbued with the enterprise culture that he's now so blind to
the original peer-to-peer spirit of PGP that he would say things like
   There is no way to do encrypted e-mail where the content is
   protected.  [1]
This is simply false.
If sender and receiver exchange keys out-of-band and nobody else knows
the keys, the content can have cryptographically strong protection.
Why would Zimmermann allow himself to be bought off?  What kind of
pressure is being brought to bear?  Is this protracted world-class human
engineering in action?
[1]

@_date: 2013-08-27 17:16:11
@_author: StealthMonger 
@_subject: Metadata anonymization through time delayed email messaging. 
Thank you danimoth for making that connection.  [Will they never learn?]

@_date: 2013-08-31 20:04:38
@_author: StealthMonger 
@_subject: Who bought off Zimmermann? 
Yep.  World-class protracted human engineering.  Maybe it takes a poet
like John Young to express it.
Thanks John for identifying for us non-poets your intended targets.

@_date: 2013-08-09 14:18:13
@_author: StealthMonger 
@_subject: [tor-talk] Secure email with limited usable metadata 
Precisely the opposite is the case.  Email can go by way of anonymizing
remailers, while real-time communications are vulnerable to IP packet
time and volume correlation at the end points.  With email, the security
is in the message, not in the connection.

@_date: 2013-08-26 00:54:03
@_author: StealthMonger 
@_subject: Who bought off Zimmermann? 
How ironic and sad it is that Phil Zimmermann, the author of PGP, has
become so imbued with the enterprise culture that he's now so blind to
the original peer-to-peer spirit of PGP that he would say things like
   There is no way to do encrypted e-mail where the content is
   protected.  [1]
This is simply false.
If sender and receiver exchange keys out-of-band and nobody else knows
the keys, the content can have cryptographically strong protection.
Why would Zimmermann allow himself to be bought off?  What kind of
pressure is being brought to bear?  Is this protracted world-class human
engineering in action?
[1]

@_date: 2013-08-27 17:16:11
@_author: StealthMonger 
@_subject: Metadata anonymization through time delayed email messaging. 
Thank you danimoth for making that connection.  [Will they never learn?]

@_date: 2013-08-31 20:04:38
@_author: StealthMonger 
@_subject: Who bought off Zimmermann? 
Yep.  World-class protracted human engineering.  Maybe it takes a poet
like John Young to express it.
Thanks John for identifying for us non-poets your intended targets.
