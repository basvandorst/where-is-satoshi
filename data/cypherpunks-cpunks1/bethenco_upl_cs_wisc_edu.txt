
@_date: 2003-02-01 18:01:11
@_author: John Bethencourt 
@_subject: Who owns stuff that falls onto someone's property? 
Yep, ebay has already removed such auctions, e.g., item `SPACE SHUTTLE COLUMBIA PIECE OF WRECKAGE PART'.
John Bethencourt

@_date: 2003-01-24 15:35:47
@_author: John Bethencourt 
@_subject: thumdrive integrity --Deniable Thumbdrive? 
Good points. I've thought a lot about the possibility of such devices (I
suppose they are kind of obvious/inevitable to crypto-minded people).
One comment:
One the of the primary uses for such a device would be in protocols requiring
digital signatures. If the device is to be used for this, it would seem
necessary to also include a small display on it so the user can view what the
untrusted computer wants signed and authorize the signature. Of course, with
a screen, it's going to be more like a PDA and less like a key-chain sized
One of these days, I might build a little device that stores a private key
and does on-board encryption using a microcontroller. I would do it just for
fun, since it is pretty useless if the infrastructure to support it is not out
John Bethencourt

@_date: 2003-05-20 13:27:08
@_author: John Bethencourt 
@_subject: idea for OTP system, comments desired 
I've come up with an idea for a one-time-password based authentication
protocol, and I would like any comments on it. It doesn't use
sequences of passwords that need to be periodically reinitialized, so
it is more convenient than systems like S/Key.
In the following explanation, `h' is a cryptographic hash function and
`x.y' denotes the concatenation of strings x and y. The `server' is
taken to be a system which users need to authenticate to, e.g., to use
some service. The `client' is software run by the user to assist them
in authentication.
To begin, the administrator of the server adds a user to the
system. The server stores the username and an initial password set by
the administrator. A flag is set for that user to indicate that that
user has never been authenticated. The administrator tells the initial
password to the user.
To authenticate for the first time, the client connects to the server
and sends the username. The server requests the initial password. The
client prompts the user for it, and sends it to the server. The server
then generates a random string, r_0, and sends it to the client. The
client now prompts the user for the password, s, which they would like
to use from now on. The client computes h(h(s.r_0)) and sends it to
the server. The server stores the username, r_0, and h(h(s.r_0)).
To authenticate for the second time, the client connects to the server
and sends the username. The server sends r_0 to the client. The client
prompts the user for s, then computes h(s.r_0) and sends it to the
server. The server computes h(h(s.r_0)) and checks that it matches
what it has stored for that user. The server then makes a new random
string r_1 and sends it to the client. The client computes h(h(s.r_1))
and sends it to the server. The server stores the username, r_1, and
All subsequent authentications proceed like the second.
Here's the protocol in a more concise form:
[first authentication]
Client -->       username      --> Server
Client <-- 'initial password?' <-- Server
Client -->      initialpass    --> Server
Client <--          r_0        <-- Server
Client -->      h(h(s.r_0))    --> Server
[subsequent authentications]
Client -->       username      --> Server
Client <--          r_x        <-- Server
Client -->       h(s.r_x)      --> Server
Client <--          r_y        <-- Server
Client -->      h(h(s.r_y))    --> Server
This protocol seems pretty simplistic. I wonder if people have
considered it and found a flaw in it. If not, I would expect people to
be using it in place of S/Key, since it has the advantage of not
requiring the password sequences to be reinitialized. I searched
around on the web and couldn't find anything that seemed relevant. The
only possible flaw that I could think of was the following:
The attacker will have a large number of pairs like
h(s.r_0), r_0
h(s.r_1), r_1
h(s.r_2), r_2
h(s.r_3), r_3
Is there some way to use this knowledge to make inverting h to find s
easier? Of course, that would depend on the particular hash function,
and I don't know enough of the math behind secure hash functions to
answer the question. Also, the random string r_i will need to be long
enough to make collisions sufficiently unlikely (or the server could
keep a list of past random strings to ensure it does not reuse them).
If anyone can think of any flaws in this system or knows of any
relevant literature, I would very much like to hear about it.
John Bethencourt

@_date: 2003-05-21 21:07:11
@_author: John Bethencourt 
@_subject: idea for OTP system, comments desired 
Thanks for responding.
Oh, no, that's not what I meant. s is not the same as initialpass, and s
is not stored anywhere. The server never knows what s is, and the client
only uses it during an authentication and then forgets it.
Right, that would be horribly wrong.
It isn't really needed; it's just for setting up an account. The
alternative would be for the user to pick s and r_0 and give the sysadmin
h(h(s.r_0)) right off the bat. I just thought this would be more
Yes, that's the idea.
Good point; that is a big flaw. A precomputed dictionary attack won't
work, but if a user picks a weak password, guessing it would be feasible.
I guess you could also do a dictionary attack against S/Key, but it would
take longer since for each trial you would have to compute the, say, 50th
Cool; thanks for the pointer. I hadn't heard of SPEKE before. Dictionary
attack immunity is a really nice feature.
John Bethencourt
