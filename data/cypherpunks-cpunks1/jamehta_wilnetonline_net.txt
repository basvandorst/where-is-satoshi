
@_date: 2001-03-08 02:35:26
@_author: jamehta@wilnetonline.net 
@_subject: a request for help regarding rc5 algorithm from a student 
respected sir,
       i am a student(B.E,electronics) of M S University,Baroda,India.my
name is kurang mehta. as my final year project i am implementing voice
encryption algorithm using the dsp kit tms320c5x. i came across your
reference by surfing the net. i have implemented the rc5 encryption
algorithm but the decryption part is becoming a problem for me. i am
herewith sending you the encryption algorithm:
We assume that the input block is given in two w-bit registers A and B. We
also assume that key-expansion has already been performed, so that the array
S[0...t-1] has been computed. Below is the encryption algorithm in
pseudo-code. The output is also placed in registers A and B.
     A = A + S[0];
     B = B + S[1];
     FOR i = 1 TO r DO
          A = ((A [Image] B) <<< B) + S[2*i];
          B = ((B [Image] A) <<< A) + S[2*i+1];
The key expansion is also performed as showm below:(Image is any constant)
The first algorithmic step of key expansion is to copy the secret key
K[0...b-1] into an array L[0...c-1] of c = [Image] words, where u=w/8 is the
number of bytes/word. This operation is done in a natural manner, using u
consecutive key bytes of K to fill up each successive word in L, low-order
byte to high-order byte. Any unfilled byte positions of L are zeroed.
The second algorithmic step of key expansion is to initialize array S to a
particular fixed (key-independent) pseudo-random bit pattern, using an
arithmetic progression modulo [Image] determined by the "magic constants"
[Image] and [Image]. Since [Image] is odd, the arithmetic progression has
period [Image].
     S[0] = [Image];
     FOR i = 1 TO t-1 DO
          S[i] = S[i-1] + [Image];
The third algorithmic step of key expansion is to mix in the user's secret
key in three passes over the arrays S and L. More precisely, due to the
potentially different sizes of S and L, the larger array will be processed
three times, and the other may be handled more times.
     i = j = 0;
     A = B = 0;
     DO 3*max(t,c) TIMES:
          A = S[i] = (S[i] + A + B) <<< 3;
          B = L[j] = (L[j] + A + B) <<< (A+B);
          i = (i + 1) mod(t);
          j = (j + 1) mod(c);
The key-expansion function has a certain amount of "one-wayness": it is not
so easy to determine K from S.
Now if possible i would like to get some help from you regarding the rc5
decryption algorithm (in the form of source code or c language).
awaiting a response at the earliest.
sincerely yours
