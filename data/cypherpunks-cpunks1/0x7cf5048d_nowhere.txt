
@_date: 1994-08-22 09:46:13
@_author: 0x7CF5048D@nowhere 
@_subject: pgp -c,no initialization vector, possible bug, pgp 26ui 
In pgp 2.6 UI When pgp is called with the -c switch, the routine idea_encryptfile
in crypto.c is called from main in pgp.c.
Note that idea key is a 16 bytes.
Now idea_encryptfile calls squish_and_idea_file in crypto.c
with this 16 byte key.
Now squish_and_idea_file calls idea_file in the module crypto.c
with the same 16 byte key.

@_date: 1994-08-23 00:16:09
@_author: 0x7CF5048D@nowhere 
@_subject: pgp -c,no initialization vector, possible bug, pgp 26ui 
In pgp 2.6 UI When pgp is called with the -c switch, the routine idea_encryptfile
in crypto.c is called from main in pgp.c.
Note that idea key is a 16 bytes.
Now idea_encryptfile calls squish_and_idea_file in crypto.c
with this 16 byte key.
Now squish_and_idea_file calls idea_file in the module crypto.c
with the same 16 byte key.

@_date: 1994-08-23 18:47:19
@_author: 0x7CF5048D@nowhere 
@_subject: pgp -c,no initialization vector, possible bug, pgp 26ui 
Darn, the remailers keep truncating this!
In pgp 2.6 UI When pgp is called with the -c switch, the routine idea_encryptfile
in crypto.c is called from main in pgp.c.
Note that idea key is a 16 bytes.
Now idea_encryptfile calls squish_and_idea_file in crypto.c
with this 16 byte key.
Now squish_and_idea_file calls idea_file in the module crypto.c
with the same 16 byte key.

@_date: 1994-07-24 02:30:31
@_author: 0x7CF5048D@nowhere 
@_subject: legally circumvent the Sept 1,94 Legal Kludge, Program Part 000 
released to the public domain.
The legal kludge makes output from PGP 2.6 from an Eastern University
incompatible with earlier versions after Sept 1 1994.
A Usenet article has documented a discovery by Paul Elliott that the
pgp 2.6 legal kludge can be disabled by invoking it with the following
pgp +CERT_DEPTH=0 +LEGAL_KLUDGE=OFF +CERT_DEPTH=real_desired_value others
This program invokes pgp with the above
parameters. "real_desired_value" is taken from the CONFIG.TXT
file. This will cause the legal kludge that makes PGP from an Eastern
University incompatible with earlier versions of PGP to be turned
off. This program does not address the incompatible signature format
problem. This does not modify the code or the executable of PGP in any
way. It simply invokes it with unusual parameters.  Therefore it
should be legal.
The program searches your config.txt file for the default value of
CERT_DEPTH. It will run slightly faster if this variable is at the top
of that file.
The program to be invoked may be controlled by the environment
variable "PGPEU". EU stands for Eastern university.  This variable may
specify the file name or a complete path.  If this variable is
undefined, the program indicated by the hard coded string "PGPEXE"
will be invoked this string may be defined with a -DPGPEXE= flag at
compile time.
By default (that is if PGPEU is undefined) PGPNOKLG.EXE
will search your path for a program called "PGP.EXE".
Thus the command:
PGPNOKLG -e file
will call PGP 2.6 in a way so that the result will be
compatible with earlier versions of PGP.
The program PGPNOKLX.EXE invokes (by default) a program called "PGP26.EXE".
So you could take the original program "PGP.EXE" from an Eastern
University and rename it to "PGP26.EXE" somewhere in your path.
You could the rename "PGPNOKLX.EXE" to "PGP.EXE" then when
PGP is invoked normally it will really be PGPNOKLX which
will invoke the original pgp (AS PGP26) in a way that output
will be compatible with earlier versions. Thus scripts, shells and mail
programs that are designed to invoke pgp could continue to work,
but in a way that the output is compatible with earlier versions
of PGP.
This program has been ported to MSDOS and OS/2. Somebody please port
to all other platforms.
I have posted a zip file which contains source, makefiles and binaries
as a pgp signed binary, in 3 posts.
The following is the source for the programs pgpnoklg and pgpnoklx.

@_date: 1994-07-24 02:30:47
@_author: 0x7CF5048D@nowhere 
@_subject: legally circumvent the Sept 1,94 Legal Kludge, Program Part 003 
part 3/3 of a pgp signed zip file=kludge.zip
not encrypted.

@_date: 1994-07-24 02:31:02
@_author: 0x7CF5048D@nowhere 
@_subject: legally circumvent the Sept 1,94 Legal Kludge, Program Part 002 
part 2/3 of a pgp signed zip file=kludge.zip
not encrypted.

@_date: 1994-07-24 02:31:16
@_author: 0x7CF5048D@nowhere 
@_subject: legally circumvent the Sept 1,94 Legal Kludge, Program Part 001 
part 1/3 of a pgp signed zip file=kludge.zip
not encrypted.

@_date: 1994-09-02 19:50:19
@_author: 0x7CF5048D@nowhere 
@_subject: How do I choose constants suitable for Diffe-Hellman? 
How do I choose constants suitable for Diffe-Hellman?
According to _Applied Cryptography_ n should be prime,
also (n-1)/2 should also be prime. g should be a primitive root of unity mod n. n should be 512 or 1024 bits long.
Are there any other requirements?
How can I choose such numbers? Are such numbers published

@_date: 1994-09-02 20:20:37
@_author: 0x7CF5048D@nowhere 
@_subject: Hiding conventionally encrypted messages in PGP messages to someelse. 
I have been thinking about steganography lately. Correct me if I am
wrong, but it seems to me that if one wants to hide encrypted data, then
all this public key encryption stuff becomes irrelevant. It seems that
the sender and the recipient must agree on a way to hide the data. The
time of this agreement is a perfect time to exchange conventional
Speaking of conventional encryption, PGP uses conventional encryption
(IDEA). RSA is only used to transmit a conventional encryption key,
after it has been randomly chosen. So if we wish to hide conventionally
encrypted data, why not use the purloined letter method, and hide it as
the conventionally encrypted data in a PGP encrypted file?
Then, when Darth Vader finds the PGP encrypted file, we can say that we
can not decrypt the file, because it was encrypted for
obiwan at galaxy.far.far.away. If the RSA headers confirm this, Darth will
have no reason to disbelieve us. Hopefully, obiwan will be out of
Darth's reach.
To create such a file, we would simply create as PGP usually does,
except that we specify or record the conventional IDEA key used. Then to
decrypt the file, we simply ignore the RSA headers and use the specified
or recorded conventional IDEA key. We could even insure that the IDEA
key in the RSA encrypted headers is wrong. So, obiwan can not reveal
the data even if Darth can seize him.
I have created a hack to PGP ui to do all of the above!
The hack works exactly like ordinary PGP except that there
are 3 new configuration parameters which may only be specified
only on the command line. These parameters are +DISPLAYIDEAKEY
+SPECIFYIDEAKEY and +WRONGIDEAKEY.
+DISPLAYIDEAKEY=on causes the IDEA key used to be displayed in
+SPECIFYIDEAKEY is used to specify the idea key. It can
be specified as a passphrase or as a hexadecimal string.
+WRONGIDEAKEY=on causes the wrong idea key to be encrypted
into the RSA blocks so that the nominal recipient can not
decrypt the file.
pgp "+SPECIFYIDEAKEY=my pass phrase" -eat file obiwan at galaxy.far.far.away
We will be able to decrypt the encrypted file even though we are
not obiwan by:
pgp "+SPECIFYIDEAKEY=my pass phrase" file.asc
If we wish to encrypt as above but we do not want obiwan to be able
to decrypt we would say:
pgp +WRONGIDEAKEY=on "+SPECIFYIDEAKEY=my pass phrase" -eat file obiwan at galaxy.far.far.away
obiwan will not be able to decrypt (but we will), because the wrong idea
key (chosen randomly) will be RSA encrypted in the headers.
We can use the +DISPLAYIDEAKEY=on parameter to display the idea key used.
pgp +DISPLAYIDEAKEY=on -eat file obiwan at galaxy.far.far.away
This will print the idea key in hex.
We will be able to decrypt by specifying the displayed key in hex.
pgp +SPECIFYIDEAKEY=0X7ee723d686cf5aac8d4b3fd091a00e3e file.asc
We can use the parameter +SPECIFYIDEAKEY=PROMPT (upper case)
to cause the hacked PGP to prompt for the pass phrase or hex
string from the terminal.
If you use any of the above be sure that +SELF_ENCRYPT
is off. It will not do to have your own name in the RSA headers
when Darth comes for you.
To create a hacked version of the program, do the following 1) Run this message thru pgp to restore the cutmarks.
2) unpack the pgp 2.6 ui sources to a directory.
3) apply the context diffs (below) using patch.
  		key[count] = idearand() ^ try_randombyte();
  /* Write out a new randseed.bin */
*** 501,507 ****
  	return IDEAKEYSIZE;
  }
!   word32 getpastlength(byte ctb, FILE *f)
  /*	Returns the length of a packet according to the CTB and

@_date: 1994-09-15 22:35:31
@_author: 0x7CF5048D@nowhere 
@_subject: pgp 2.6.1 circumventing legal kludge 
I have examined the source to the latest modification to
pgp2.6 pgp2.6.1. It appears that the +legal_kludge command
parameter remains as also does the bug that prevents this code
from working! (Value is used instead of Flag.)
One would have thought that the bug would have been fixed
or the legal kludge code would have been removed in pgp2.61.
The existence of this bug was widely publicized. Perhaps
the authors wish there to continue to be a way to circumvent
the kludge, but can not be seen taking explicit action to fix
the bug.
The bottom line is that to encrypt a message to be sent to
someone with an earlier version of pgp such as pgp 2.3a,
one should disable the legal kludge by using the following
command line:
pgp +cert_depth=0 +legal_kludge=off +cert_depth=4 -eat file them
My program in noklg.zip is a way to use the above feature to
cause pgp to be compatible with earlier versions of pgp without
the extra typing. (It supports MSDOS and OS/2). You can set up
the program so that pgp shells and other programs work as originally
designed, but encrypting files compatible with earlier versions
of pgp. I wish that someone would store this program in at a public
ftp site.
