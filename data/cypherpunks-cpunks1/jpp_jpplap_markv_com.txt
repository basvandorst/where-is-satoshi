
@_date: 1994-06-26 12:06:25
@_author: Jay Prime Positive 
@_subject: Linux under SecureDrive partition? 
I don't know how to make a dos device driver run under linux.  I
would be interested since due to lack of space, most of my dos
partition is doublespaced.
  I supose you could port SecureDrive to linux, after all, you have
(or theoreticaly can get) the source.

@_date: 1994-05-24 14:20:29
@_author: Jay Prime Positive 
@_subject: Graph isomorphism based PK cryptosystems? 
I've been out of the literature for quite a while now so pardon me
if this is a dumb question.  Do any of you know of any public key
cryptosystems based on the graph isomorphism problem?  Last I heard
there weren't any.  But I think I've found one.

@_date: 1994-05-24 22:52:35
@_author: Jay Prime Positive 
@_subject: Graph isomorphism based PK cryptosystems? 
Date: Tue, 24 May 1994 18:11:51 -0400
   From: perry at imsi.com ("Perry E. Metzger")
   There was a powerful result a while back concerning public key systems
   based on NP complete problems
Hmm.  Was it the set of 'super increasing' knapsack problems?
   It would be cool to hear about your graph isomorphism based system in
   any case.
I only worry that if I publish, it could be patented.  And I don't
want the algorithm to end up in the hands of the software patent
folks.  Especially if they will be making money off it, and I wont.
   Perry

@_date: 1994-05-26 03:53:49
@_author: Jay Prime Positive 
@_subject: (fwd) FBI Digital Telephony Wiretapping a Done Deal?? 
A little early with this report aren't you?  I though today, 26 May
1994, was before May 30 1994.  What is you source?  Could you get me a
copy of the financial pages too?

@_date: 1994-05-26 04:05:14
@_author: Jay Prime Positive 
@_subject: Magazines commonly predate issues, e.g. June Byte at hand 
Oops.  Boy, that was sure a snide, surly thing for me to say.  Let me
publicly apologise to you Harry, and to the readers of Cypherpunks.  I
though US News & World Report was a news paper, but that doesn't
really excuse my tone.  Sorry again.

@_date: 1994-05-26 08:45:14
@_author: Jay Prime Positive 
@_subject: Unicorn vs. tmp@netcom 
Well there is a distinction to be made between the law, and the
government.  Today, the government claims a (virtual) monopoly on the
law*.  Thus resort to the law today must almost always also be a
resort to governemt.  So, we cannot tell from outside if Unicorn's
'master' is government, or law.  Perhaps we should ask him?
  On the other hand, I certainly agree that 'kicking folks when they
are down' is not nice.  Especially if it is done in a premeditated
manner.  But you didn't sugest that -- did you?
  Btw, is cyber1 at io.org by any chance another nym for tmp at netcom.com?
  * Footnote: Arbitration services are almost a seperate law, but
generaly their 'teeth' come ultimately from government monopoly on
force.  It is posible to imagin arbitration services with shaper
  I supose that criminal organizations which chalange the government's
monopoly on force could provide an example of alternative law.  Hmm.
Didn't you mention something about that kind of law being cheaper to

@_date: 1994-05-26 14:11:30
@_author: Jay Prime Positive 
@_subject: Graph isomorphism based PK cryptosystems? 
No I haven't tested it against any known GI algorithm.  Your
references are all very interesting and I will investigate them.  If
you had a publisher handy, along with the city the publisher is in, I
would happily phone them up and get a copy.  But if not, I can operate
a card catalog.
  No, I didn't expect GI to be NP-complete at all.  I expect rather
that P < GI < NP.  That is one of the reasons that GI is an
interesting problem.  Especialy because (as you point out) GI is amost
always in P.
  In any case, my PK cryptosystem is not interesting except for the
new complexity point.  (Although, the general construction may be
interesting.)  I can prove that my cryptosystem has a level of
security which is reduceable to GI, and GI to it.  (The reduction is
only in polynomial time.  I will try to see about getting the slow
parts down to O(n) time.)
  PGP will almost certainly never include my PK system as an
alternative to RSA.  For one thing it needs a k^3 to 1 expantion in
communication costs for a security parameter of k.  For another the
'fast' decrypt routine requires O(n^3) in the number of nodes in the
graphs.  But there is no known GI algorithm which is O(n^3) in
general.  (And if there is one for *my* graphs, then I will give you a
polynomial time algorithm for all of GI.)

@_date: 1994-05-27 07:55:31
@_author: Jay Prime Positive 
@_subject: GI based PK cryptosystem. 
Ok, here it is.  I currently belive that this publishing makes the
system un-patentable by anyone but me (and I can only patent it in the
US, not in the EC).  It is my intent that this algorithm be unfettered
by copyright, liscence, trademark, patent, or any other icky
intelectual property right.  So let me state here that the algorith is
in the public domain.  I release all copyright to it.  There, i hope
that does it.
  But if I'm wrong, oh well.  I don't think there is much economic
worth in this scheme.  But, I would be happy to be proven wrong!  I
expect that the odds that this system actually work are pretty long.
But I've been over it too much, and can't see any holes, its time for
others to poke at it.  Besides, I like the tase of crow.
This is an -*-outline-*- of my public key crypto system
(setq outline-regexp "[!$=*]+")
(setq paragraph-start "^[ 	]+\\|^[!$=*]+")
(setq paragraph-separate "^[ 	]*$\\|^[!$=*]+")
* Informal introduction
** Description of the system
*** Key generation
  In total secrecy, Andy generates two graphs, one for encoding 1's and
the other for encoding 0's.  He then openly publishes these two graphs.
*** Sending a bit
  In total secrecy, Beth selects one of the two graphs, and generates a
new graph isomorphic to the selected graph based.  Then Beth publicly
sends the new graph to Andy.
*** Recieving a bit
  To decrypt which bit Andy recieved, he must determin which graph Beth
selected, and permuted.  He must solve one case of the GI problem.  To
make this easy, he has hidden trapdoor indentifiers in the published
graphs.  Using my special JGI algorithm, and the trapdoor identifiers,
Andy will be able to discover which bit Beth sent.
*** The trapdoor information
  To make hiding a trapdoor identifier possible, Andy also publishes a
labeling of the two graphs.  For each node and each edge in the
published graphs, Andy associates a labeling string.  (He uses 2k-bit
binary numbers as labels.)
  When he constructs the graphs, Andy insures that each one has a
Hamiltonian Circuit.  The trapdoor information is the labeling of the
Hamiltonian Circuits of the two graphs.  Naturally, each graph has a
different Hamiltonian Circuit from the other, with a different labeling.
** Informal security argument
  For Eve to be able to determin the bit sent from Beth to Andy, she
must be able to either solve instances of the Graph Isomorphism problem,
or find the trapdoor identifier in the graph that Beth sends to Andy and
also in the two published graphs.
  (I will ignore the posibility that Andy's and Beth's 'total secrecy'
is penetrable by Eve.  She might have psychic powers, or access to
sophisticated spying technology.  If this is the case, too bad for Andy
and Beth.)
*** The Graph Isomorphism problem
  Graph Isomorphism (GI) is a problem for which people believe there is
no polynomial time solution.  Although GI is belived to be easyer than
problems known to be NP complete.  So we belive that Eve has a fairly
hard problem ahead of her, although the problem might not quite fit the
usual definition of intractable.
*** The Hameltonain Circuit problem
  Instead Eve could try to discover the trapdoor information.  But since
the Hamiltonian Circuit Decision problem is NP complete, and since NP
complete problems are (belived) at least as hard as GI, it doesn't seem
that there is much profit for Eve to try this aproach.
* The formal version
** Key generation
  For a particular security parameter k, the published key consists of
an ordered pair of graphs .  G0 is used for sending 0 bits, and
G1 for sending 1 bits.
  Both G0 and G1 contain 2^4k nodes, and 2^4k*2^2k==2^6k edges.  Each
graph contains a Hameltonian Circuit.  Each node, and each edge of each
graph is labled with a member of {0,1}^k (the set of bit strings k bits
long).  Each node has exactly 2^2k outgoing edges (and 2^2k incomming?).
  To construct a graph, begin with a random set of labled nodes.
Construct the Hameltonian Circuit by adding edges from vi to vj, each
with a random label.  Note (one of) the string(s) which is formed by
appending the node and edge lables in order along the Hameltonian
Circuit.  This is the trapdoor information which makes the graph
isomorphism problem easy.  Next add edges to the graph until each node
has exactly 2^2k outgoing edges, label each edge at random.
  (Here is where I should talk about how the GI problem is only rarely
hard, and that the edges labeled at random garantees that we _sometimes_
land in the hard susbset of the GI problem.  It would be nice to make a
better construction which always landed in the hard subset of GI.  But
this is likely to be a hard research problem.  Oh well.)
** Sending a bit
  Reciever sends two graphs as described above to the sender.  The
sender decides which bit to send -- 1 or 0.  The sender then selects a
permutation P of the nodes of the apropriate graph.  The sender then
sends the isomorphic graph defined by the permutation P to the reciever.
The reciever uses my GI algorithm to determin which graph was sent.
** Recieving a bit
  The reciever runs the folowing algorithm twice in parallel, and the
algorithm to finish first determins which graph was sent.  The other
algorithm is terminated (since its result is unnecesary.)
*** Description of the algorithm
  The JGI algorithm takes as input a trapdoor string T of labels  (tni, and tei are strings of binary digits), and a
graph G= of |V| nodes.  It either halts and accepts the input, or
halts and rejects the input.  After initializing, the algorithm will
halt in exactly V iterations of the main loop.
**** Initialization
  For each node v in the graph, if the node's label matches the first
label in the trapdoor, create a set sv containing v.  Also create a
pair pv of .  Finally add the pair pv to the active set.
Remove the first label from the trapdoor string.
**** Main Loop
  While the trapdoor string T is not empty and the active set is not
empty, do the Outer Loop.  After performing the outer loop, make the
next active set be the active set, and then remove the first two
labels from the trapdoor string.
***** Outer Loop
  For each pair pi= in the active set, do the Inner Loop.
****** Inner Loop
  For each edge e= in E where vi==vj, if T's first label
matches e's label, and if vk is not in svi, and if T's second label
matches vk's label, then add the pair pi'= to the
next active set.
**** Final step
  If the trapdoor string is empty, halt and accept. If the active set
is empty, and the trapdoor string is not, halt and reject.
*** Proof of polynomial time and space behavior
  (This is a little weak, but I belive it can fly.)
  The main loop executes no more than |V| times since the trapdoor
string contains exactly |V| node labels, and each iteration removes
one of them.  The important question is how many new pairs are added
to the next active set, for each pair in the active set, by the outer
and inner loops.  For one of my graphs, the expected number is (less
than) one.  To see this note that the product of number of edge labels
and the number of node labels equals the numbe of edges leaving a
node.  However, the test to see if the new vk is already a member of
the old svi reduces this number.
** Proof of security
  The evesdropper must solve the GI problem for the subset of graphs
constructed, or must discover the trapdoor information, and use my GI
algorithm.  To show how hard this is, I will show that GI of the
subset of graphs generated is (polynomial time) GI complete, and I
will show that discovering the trapdoor information is as hard as the
Hameltonian circuit path discovery problem.
*** The reduction to HP
  Now how am I going to do this?  Ideas are solicited.
*** The reduction to GI
  (All I actually present are the constructions for the reductions.  I
don't proove that isomorphism and (where apropriate) hameltonian
posetion is retained.  But I am convinced.  Just tiered of typeing.)
  I will write GI for graph isomorphism, LGI for labeld graph
isomorphism, HLGI to Hameltonian posesing labeled graph isomorphism,
FAHLGI for fixed (at |V|^1/2) arity Hameltonian posesing labeled graph
  The subset of graphs that are generated in the key generation process
are exactly those of the FAHLGI problem.  (This is true by
**** FAHLGI <= GI <= FAHLGI
  I will now prove that FAHLGI <= GI <= FAHLGI.  I will prove this by
the chain FAHLGI <= HLGI <= FAHLGI, HLGI <= LGI <= HLGI, LGI <= GI <=
***** FAHLGI <= HLGI <= FAHLGI
****** FAHLGI <= HLGI
  Obvious: Since FAHLGI is a subset of HLGI, a HLGI algorithm will work
just fine when given graphs from the FAHLGI problem.
****** HLGI <= FAHLGI
  Replace each node with a clique of size |V|.  Label the nodes in the
clique as the original node, and the edges in the clique 00.  For each
ordered pair of nodes  in V^2, add an edge from one of the nodes
in the clique for v1 to one of the nodes in the clique for v2.  Label
the new edge 11x if the there is an edge  in E and its label is
x, label the new edge label 10x for some random x, if  is not in
***** HLGI <= LGI <= HLGI
****** HLGI <= LGI
  Obvious: Since HLGI is a subset of LGI, a LGI algorithm will work just
fine when given graphs from the HLGI problem.
****** LGI <= HLGI
  For each v labeled x, construct v', v'' labeled 0x and 1x resp.  For
each v', and each v'', add the edges  and  each
labeled 0x for some random x.  For each e=  in E labeled x add
e'=  labeled 1x.
***** LGI <= GI <= LGI
****** LGI <= GI
  For each node label add a new node, and an edge from the new node to
each of the nodes so labeled.  For each edge, add an intermediate node.
For each label of the edges, construct a new node, and edges from it to
the new edge nodes.
****** GI <= LGI
  Obvious construction: give each node and edge the label 0.

@_date: 1994-05-27 11:51:46
@_author: Jay Prime Positive 
@_subject: From: nowhere@bsu-cs (Anonymous) 
If you tried to send me a message (or two) anonymously via the
remailer Anonymous , please try again -- the
body of the messages were empty.

@_date: 1994-05-27 12:02:06
@_author: Jay Prime Positive 
@_subject: (fwd) Re: NSA Helped Yeltsin Foil 1991 Coup 
Date: Fri, 27 May 1994 14:21:28 -0400
   From: perry at imsi.com ("Perry E. Metzger")
   We are all very dependent on things like MD5 and IDEA, which may or
   may not actually be secure. We should bear this in mind.
If you suspect that some of the non DOD/NSA cyphers might be broken,
but you are not ready to employ one-time-pads, then you should
threshold you mesages into N parts so that all N are needed to recover
the original.  Then encrypt each part under a different cypher.
Perhaps IDEA, and 3DES would be apropriate.  This will not increase
the size of your messages very much since you compress before
encrypting -- don't you?

@_date: 1994-05-27 19:55:22
@_author: Jay Prime Positive 
@_subject: (fwd) Re: NSA Helped Yeltsin Foil 1991 Coup 
The problem with forming product cyphers is the birthday paradox.
The problem with threshold cyphers is bandwidth.
  Concider for example e1( e2( e3( x ))), and the permutations it
generates.  Let E1 represent the number of permutations generated by
e1 under all the different keys, and similarly E2 and E3 the number
generated by e2 and e3 respectively.  E1, E2, and E3 are all nearly
the same as the number of keys for the respective cryptosystems.  But
there is no garantee that the number of permutation that the
composition of e1, e2, adn e3 is equal to the product of the number of
keys (E1*E2*E3).  Infact, the birthday paradox just about garantees
that the number is less than E1*E2*E3.  So some of the additional
keybits are lost.
  On the other hand, the number of permutations that the system Eli
and I describe *is* garanteed to increase with the addition of
cyphers.  Concider the same three encryption functions as in the
previous case.  If the number of permutations generated by e1, e2, and
e3 is E1, E2, and E3 respectively, then the number of permutations in
ej{e1,e2,e3}(xi) ==  and ri is a cryptographic
random number generated by e3, is exactly E1 * E2 * E3.  The problem
with thresholding is the linear increase in cyphertext with linear
increase in number of keybits.
  So if you are a bit too paranoid to rely on a single non DOD/NSA
cypher, but not willing to use a one time pad, then concider
thresholding.  If you don't have the communication bandwidth to
support it, then certainly fall back to the simpler scheme Perry
  (Note that Eli and My scheme is only slightly slower to compute than
Perry's.  It requires computing one extra xor per block.  Also note
that the actual increase in bandwidth for a three cypher system
threshold in a practical encryption package like PGP would not be 2 to
1 since it likely compresses before encryption.)

@_date: 1994-05-27 22:38:52
@_author: Jay Prime Positive 
@_subject: (fwd) Re: NSA Helped Yeltsin Foil 1991 Coup 
Date: Fri, 27 May 94 18:54 PDT
   From: jpp at jpplap.markv.com (Jay Prime Positive)
   Infact, the birthday paradox just about garantees
   that the number is less than E1*E2*E3.
After thinking about it some more, I think I would like to rephrase
that.  I don't think 2^k is nearly close enough to ((2^k)!)^(1/2) for
me to say 'garantee'.  But, it is possible for E1*E2*E3 to excede the
number of permutations of the e1( e2( e3( x ))) system.
j(no i am not a tmp tenticle)'

@_date: 1994-05-28 00:24:19
@_author: Jay Prime Positive 
@_subject: (fwd) Re: NSA Helped Yeltsin Foil 1991 Coup 
I don't see why.  I assume the PRNG is cryptographic, and concider
its key (and iv) as part of the key to the system.  And I don't see
why the PRNG needs to be so tremendously strong.
  Hmmm.  Now I think I get it.  If the PRNG is the weak link, then the
atacker can solve the easy PRNG crypto system and the hard e1 crypo
system.  On the other hand if it is the strongest crypto system, the
atacker will solve the weaker e1 and e2 crypto systems instead.
  Hmmm.  Yeah, you are right.  Although the PRNG threshold scheme has
E1*E2*E3 permutations, it is really only as hard as either E1*E2, or
E1*E3.  Yet another example of 'key size is not proportional to
  So my new criteria is if you have bandwidth, and strong random
numbers, use the threshold scheme.  If not, use the product cypher.
But perhaps the fenced DES stratagy is better than either.  For
comparison purposes we would need to know how the fence permutation(s)
are keyed.
  Yeah, your are right.  The Cthr/Cpro will be about 2 to 1.  (2 cause
I used one key for the PRNG, the other two for encrypting the
thresholded pieces.)  But Cthr/Plain will not be nearly 2 to 1.
  I think this is interesting.  If you, Eli, think it is interesting
enough for the general list, feel free to forward this.

@_date: 1994-05-30 07:17:05
@_author: Jay Prime Positive 
@_subject: Compress before encrypting?  (Was Re: NSA Helped Yeltsin...) 
From: janzen at idacom.hp.com (Martin Janzen)
   Date: Fri, 27 May 94 14:43:02 MDT
   Most compression programs add a characteristic signature to the beginning
   of the compressed output file.  If a cryptanalyst guesses that you may
   be compressing before encrypting, wouldn't this make his job easier?
   To me, this sounds as though you're adding a known bit of "plaintext" to
   the start of each message.
  In short, you are right, compression algorithms often _do_ include a
magic number at the begining.
  However, compression algorithms intended for cryptographic
applications don't have to include a magic number.  This is especialy
true if the crypto system is never used without the compression
  And if magic numbers are unavoidable, then they can be put at the
end, and the system run in CFB or CBC modes.  Alternatively, a random
block can be prepended to the plaintext, and then exored with each of
the folowing plaintext blocks (thus creating a garanteed flat
distribution for the first bytes of the plain text).
  Finaly, the state of the art in cryptanalysis (as far as I know),
sugests that modern crypto systems aren't as vulnerable to known
plaintext as past systems.  The best attacks I know of (differential,
and linear cryptanalysis) require masive (about 2^30 blocks for DES)
amounts of known, or chosen, plaintext -- though miniscule relative to
the key size (2^56 again for DES).

@_date: 1994-05-30 09:06:17
@_author: Jay Prime Positive 
@_subject: Compress before encrypting? (Was Re: NSA Helped Yeltsin...) 
Date: Mon, 30 May 1994 16:53:32 +0200
   From: amck at maths.tcd.ie (Alastair McKinstry)
   While this is true, don't forget the usefulness of known plaintext
   for brute-force analyses. If you're doing a brute-force search
   Costs: <$20 million (see Schneier) and this then makes breaking DES
   keys (for example) trivial, if they all have the plain text.
[I presume Alastair ment to say] ...the same known plain text.
Ah yes.  Well, the state of the art in cryptanalysis (as far as I
know) just moved forward a notch. =)

@_date: 1994-05-31 15:58:55
@_author: Jay Prime Positive 
@_subject: FWD: Encryption for Newton 
This is a bad sign.  They didn't use IDEA or 3DES it seams.  On the
other hand, they are making the encryption algorithm available for
study, which is good news.
