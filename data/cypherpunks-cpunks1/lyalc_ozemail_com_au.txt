
@_date: 1995-12-03 12:09:54
@_author: lyal collins 
@_subject: bulk RC4 brute forcing 
Some time ago, I wrote about testing multiple plain/cipher pairs against a
key as a possible speed up for brute forcing 40 bit RC4 key cracking.
I have finally done something about it, written some code, and run tests
which I believe gives a about 6-8 times improvement over single
key/plain/cipher testing against RC4-40 encryption.
A single RC4 master "key schedule" is generated.
This is copied to an master array of 126 RC4_keys (126 chosen due to segment
boundary probs).
Then each of 126 plain/cipher (P/C) pairs are tested for a match. Acquiring
the plain/cipher pairs in real life is another question.
If a match is found, the pair is marked 'found', and testing continues on
the remaining unfound P/C pairs.
This loops until all 126 plain/cipher/keys have been tested and found.
8 plaintext, 8 cipher bytes are used. Keys are 8 bytes, the last 5 of which
are variable (40 bits).
Test results :
A test set of data was created by incrementing a key byte, and making a P/C
Then all keys bytes are set to 0, and testing commenced.
Typically, a 486/33 with the above in 'C' code running on DOS achieves about
15000 tests per second.
One extended test ran about 480 million tests in 7.5 hours and found 68% of
the keys - approx 17,700/sec, averaging 5.6 million tests per found key.
My reasoning follows thus:
For 126 plain/cipher pairs, with "randomly" generated keys, one valid
key/plain/cipher pairs 'should' be located in 2^33 key tries (126 is approx.
15000 tests/sec across 126 P/C pairs is about 119 keys/second tested.
at 119/second, 2^33 key tests will take 835 days. This should "guarantee"
a key match is found.
By contrast: The "bruterc4.c" code used by this forum earlier showed approximately 2200
key tests per second on my machine. Testing 2^40 keys at 2200/sec will take
5784 days to guarantee a key match (using 2^39, 2892 days).
This is a 6.9(3.46) ratio, that finds a single key match.
Finding all 126 keyswould should take approximately 293 years in "bulk"
mode, or 1996 years in single mode (126x5784 days).
The code is available, and will be posted here is desired (it is messy).
Ideally, faster key/plain/cipher testing could be accomplished if a larger
array of keys could be used. The Intel segment problem has prevented me for
making larger arrays - I don't know how to turn these features in my
compiler (yes - I am a beginner at coding, but the "huge" directive in
Borland C did not seem to work, and I don't know why - yet). Tests on 31, 63 and 126 P/C pairs showed results of 10689, 13326 and 15689
tests/sec, respectively. This indicates array size has a direct relationship
with test/sec.
I invite others who can better manipulate statistics, or better exeprienced,
to comment, refute, or otherwise contribute to this.
All mistakes in this message belong to me - you should not use them!

@_date: 1995-12-05 02:52:00
@_author: Lyal Collins 
@_subject: bulk RC4 brute forcing 
following requests for this test code, the attached should compile and run the tests I desciribed earlier.
It is messy - sorry.

@_date: 1995-10-19 06:48:16
@_author: lyal collins 
@_subject: STT - useable in real life ? 
certificates - root, country CA, issuer Ca, and cardholder/merchant.
Two certificates are based upon a 1024 bit public keys, 1 (root) is 2048
while the cardholder PK is 512/768 bit.
I believe a decrypt operation is required to verify each certificate.
I have seen test result from a local crypto company which indicate a 1024
bit decrypt operation will take between 2.5-30 seconds (Pentium 90 - 386/33
- I am trying to relate this to userland, not the well equipped cybernaut).
PK encrypt is somewhat faster. On this basis, a credential verify will take 10+ seconds up to several
minutes, on this range of equipment.
This seems to take a significant amount of time in verifying certificates.
This situation will only get worse as renewal certificates are appended to
existing certificates.
Can someone comment, or steer me in the right direction if I have
misunderstood certificate verification ?
Working for a bank who may have to use this one day, customer impact is a
big deal - we can afford specialised  hardware, but not all our customers can.
thanks for any clarification,
 lyal
All mistakes in this message belong to me - you should not use them!

@_date: 1995-09-03 04:45:46
@_author: lyal collins 
@_subject: A bold ssl idea ? 
Having watched the discussions of recent of the SSL bruting, it occured to
me that a variation could also be useful.
I understand that setting up RC4 keys is slower that testing for the correct
key (I may have misuderstood this bit).
As a company using SSL can ahve all it's SSL traffic sniffed, from multiple
people accessing, a log can easily be built of message/keys.
Is it considered practical to modify the brutessl code to have multiple
message data, and test each against a key from allocated key space ?
If so, this may mean that perhaps 3 message can be tested against a single
in the time two single keys could be tested against one message.
An an attack scenario, this is a hell of a lot more "efficient" than current
trials have been. I realise this could also be considered a bit of target
for the main purpose of demonstrating weaknesses, and improving techiquess.
My thoughts, anyway - i hope they make sense.

@_date: 1996-01-31 16:39:56
@_author: lyal collins 
@_subject: Java Sniffer (Was: Re: FV Announces That The Sky Is Falling) 
A very realistic scenario - any comments or reasons it can't happen ??
second question:
How can you be sure you receive the applet that you "think" you've requested ?
Any illuminating comments to assit my awareness of java ?

@_date: 1996-07-14 00:36:03
@_author: Lyal Collins 
@_subject: Reasonable validation of a software package 
This touches upon a favourite rant of mine.
If someone had your public key, and a trusted software module with which to use it, you could use a "Digital Signature".
PGP offers such data integrity and signing functions.
You also indicate you have PGP - even better.
So, now you are left with ensuuring people have your public key,
and the recipient having a trusted software tool.
Again, PGP is relatively well accepted in this regard.
Trusted - depends on the source of the recipient's
So, now you need to ensure that you can get your public key (to verify the digital signature with) in the hands of all your possible, or intended, recipients. Now the race is on for as many people as possible to generate PGP public keys/certificates bearing your name, or variations of it. Once that occurs, there is a fair chance that one of these keys will verfiy the digital signature on a piece of
software purportedly from you. Still, not many people will have your true PGP public key/certificate, but, them's the breaks.

@_date: 1996-07-14 23:20:29
@_author: Lyal Collins 
@_subject: Cybank breaks new ground; rejects public-key encryption 
Actually, it doesn't take too much effort to discover them yourself.
Get a visual basic discomplier (VB version 4 compatible need, I think), and go for It.
I cracked version 1.5 of the Cybank software - I could load up an ".INI file" with as much "value" as I wanted.
Basically, they seem to convert ASCII characters to the decimal value of the hex code, then add, subtract etc on that value, along with some XOR'ing of the resulting string and an embedded table of data.
Oh, and it's all "locked" by the serial number, generated from the install date and time.
Yeah I trust it - not.
I hesitate to distribute the discomplied source code I used, asince it may get used by the unscrupulous to do trusting Cybank customers out of their hard earned money. Maybe, enough resquests will convince me Or, take a challenge, - it took me 6 hours to achieve this, including learing enough VB3 (ther version I cracked, 1.5 was in VB3).
Lyal

@_date: 1996-07-17 01:10:14
@_author: Lyal Collins 
@_subject: FYI: Cybank 
To clarify my earlier post :
Up until anbout 29 May, 1996, the Cybank site
had a "test" file that was placed as a challenge.
As there was a challenge, I took it.
The following describes the data I was able to recover from the test file.
I have received a number of files asking
how I had hacked the Cybank server. I have acheived
no such feat, merely determining the
methodology used at the Cybank site.
I communicated that fact to Cybank's operators,
who subsequently seemto have altered their
site, and download client.
Taking this issue any further has no interest
to me, and I am unable to post any
VB source code - I "cleaned" some hard disk space, and have deleted the working files
I used at the time. Silly me.
Also, the Cybank site seems to have changed, so I don't
know how you would get a test fle without becoming a Cybank user, which would probably mean passing your name,
credit card etc to them.
At the time, Cybank seemed very happy with actual user testing,
however, I have had little further contact (1-2 emails).
ps - i have also learned some interesting spelling methods as a result of informative emails.

@_date: 1996-05-16 16:03:46
@_author: Lyal Collins 
@_subject: Java & signed applets 
Signing anything is somewaht a waste of time, unless the verification
siftware is highly trusted, and there is good intergity/authenticity
control of the root public key(s).
So, in geneal - ho hum - until trusted hardware is available on the

@_date: 1996-05-29 19:54:22
@_author: Lyal Collins 
@_subject: Tempest Info 
As the water pipe can form a signal "drain", monitoring that with respoect to an artificial refernce "earth" allowsthe signal(s) to be reccovered, unless the waterpipe is of very low
