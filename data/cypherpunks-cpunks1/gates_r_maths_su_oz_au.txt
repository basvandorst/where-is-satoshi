
@_date: 1995-12-05 16:03:36
@_author: Robbie Gates 
@_subject: Secure versus ? 
i don't think the maths works here ... let
Na = 257, Ea = 13, Da = 197, Nb = 263, Eb = 11, Db = 143
choosing M = 2, i calculate
C1 = 225, C2 = 144, C3 = 205, C4 = 33 != M
(and bottom bit is different)
choosing M = 7, i get
C1 = 127, C2 = 53, C3 = 19, C4 = 139 != M
(and top bit is different)
so your channel doesn't get the bit from alice to bob ...
the problem is that you are mixing reduction modulo two different numbers
Na and Nb ... this screws up the powering law you are trying to use.
 - robbie

@_date: 1995-12-19 22:10:10
@_author: Robbie Gates 
@_subject: Bit Commitment Query 
I am confused about bit commitment via one way hashing as described
in Schneier (1st ed, p 73)
h is a one way hash function.  This description from Schneier, except
that variables are changed so i don't need subscripts:
1. Alice has a bit b she wants to commit to. She picks random bit
2. To verify commitment, she tells Bob S and b so he can verify the hash.
What i don't get is Schneier's claim:
``If Alice didn't send Bob R, then she could change the value of S
and then the value of the bit. The fact that Bob already knows R prevents
her from doing this.''
Can someone explain exactly how Alice cheats if Bob doesn't know R.
I can't see how she can alter R and S and b at all without being
able to produce hash collisions.
In essence, why doesn't the following work:
1. Alice has a bit b.  She picks a random bit string R and sends Bob
2. To verify, she tells Bob R and b.
Assuming Bob knows b is a single bit, how does Alice cheat without needing
to produce hash collisions for h.
thanks in advance for any help,
 - robbie

@_date: 1996-01-05 07:00:45
@_author: Robbie Gates 
@_subject: unknown_subject 
What you say here isn't quite true.  The number with decimal rep
where the number of zero's is going 1!, 2!, 3!, 4!, ...
is transcendatal, and hence irrational, but clearly doesn't contain
the decimal representation of every natural number.
i'm sure the above fact is believed about e, pi & other such
``important transcendentals'' - i can't recall if there is a proof
or how it goes.  diagonalization is used to prove that there are
uncountably many irrationals.
if you want to argue the ludicrosity of trying to ban certain numbers,
just consider the function f(n) = n + 1.  Iterating this function
yields all natural numbers, so the increment operation should clearly
be banned.  I'm not sure how much programming you can do without increment.
 - robbie
