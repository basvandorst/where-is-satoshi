
@_date: 2002-07-03 10:36:30
@_author: Patrick Chkoreff 
@_subject: [OT] why was private gold ownership made illegal in the US? 
Roosevelt did devalue the dollar.  On January 31, 1934, he issued an Executive Order which devalued the dollar from 23.22 grains of gold down to 13.71 grains.  That was a 59% devaluation.
As you say, devaluing the dollar did increase the value of gold in terms of dollars.  The value of gold in terms of dollars jumped from $20.67 to $35.00, an increase of 69%.
Yeah, good thing Roosevelt didn't make the mistake of devaluing the dollar!  Whew!  :-)
Yes, the only way to avoid communism was to devalue the dollar and make possession of a yellow metal punishable by fine and imprisonment.  Anybody can see that.  :-)
Seriously though, we didn't avoid communism at all.  FDR was our first communist president.

@_date: 2002-11-07 19:36:41
@_author: Patrick Chkoreff 
@_subject: Did you *really* zeroize that key? 
Thanks for the reminder about "volatile."  It is an ancient and valuable feature of C and I suppose it's implemented correctly under gcc and some of the Windoze compilers even with high optimization options like -O2.
Everybody probably also knows about the gnupg trick, where they define a recursive routine called "burn_stack":
static void
burn_stack (int bytes)
     char buf[64];
     memset (buf, 0, sizeof buf);
     bytes -= sizeof buf;
     if (bytes > 0)
         burn_stack (bytes);
Then there's the vararg technique discussed in Michael Welschenbach's book "Cryptography in C and C++":
static void purgevars_l (int noofvars, ...)
   va_list ap;
   size_t size;
   va_start (ap, noofvars);
   for (; noofvars > 0; --noofvars)
     {
       switch (size = va_arg (ap, size_t))
         {
           case 1:  *va_arg (ap, char *) = 0;
                    break;
           case 2:  *va_arg (ap, short *) = 0;
                    break;
           case 4:  *va_arg (ap, long *) = 0;
                    break;
           default:
                    memset (va_arg(ap, char *), 0, size);
         }
     }
   va_end (ap);
Here's an example of how you might call the routine:
   purgevars_l(2, sizeof (la), &la,
                    sizeof (lb), &lb);
But hey, if "volatile" keyword works then so much the better.  I would recommend examining the assembly language output of your compiler to verify that it honours "volatile."

@_date: 2002-11-07 19:54:57
@_author: Patrick Chkoreff 
@_subject: Did you *really* zeroize that key? 
Oops, I missed your real point, which is that "volatile" ought to suffice as a compiler guide and there is no need for an additional pragma.  By declaring a variable as volatile, the compiler would also leave untouched any code which refers to that variable.
Too bad that volatile is not guaranteed to work in all major ANSI-compliant compilers.  Oh well.  I wonder how gcc does with it?
[Moderator's note: I've quoted chapter and verse -- if it follows the
current standards, it is required to honor "volatile". It isn't
compliant by definition if it does not. gcc does indeed honor
"volatile", as do almost all other C compilers I have access to. --Perry]
I guess we should stick with either the recursive routine trick or the var-arg trick.

@_date: 2002-11-08 14:01:25
@_author: Patrick Chkoreff 
@_subject: Did you *really* zeroize that key? 
Right, unfortunately the compiler might be insightful enough just to optimize that whole thing to skip() -- Dijkstra's null statement.
Even Welschenbach calls "ispurged" immediately after "purgevars" to make sure the memory is actually zero.  The ispurged routine is also defined using va_list, and if you turn on assertion checking it dies if the memory is nonzero.
The problem is you NEVER KNOW if the compiler is just being clever and optimizing the assertion away, e.g.:
sensitive = 0;
if (sensitive) abort();
The compiler will simply "know" to optimize this whole thing to skip().
However, it is highly unlikely the compiler will be able to see through va_list manipulations.  This problem is a real bear.  I guess you just have to check the assembler output, eh?

@_date: 2002-11-08 18:19:39
@_author: Patrick Chkoreff 
@_subject: Did you *really* zeroize that key? 
Good point   Excellent point, in fact.
Good point   Excellent point, in fact.
So, given 1 and 2, it sounds like a good strategy might be:
a.  Declare your sensitive variables volatile and zero them normally.
b.  Check the assembler output because you have to do that anyway  :-)
c.  If (b) exposes an out-of-spec compiler, report it far and wide to all available e-mail lists.  Then preferably use a different compiler.  If that's not an option, try the va_list trick and go to (b).
