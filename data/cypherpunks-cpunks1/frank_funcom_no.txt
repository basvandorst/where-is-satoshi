
@_date: 1995-12-04 08:52:01
@_author: Frank Andrew Stevenson 
@_subject: Cracked: WINDOWS.PWL 
A few days ago Peter Gutmann posted a description on how
Windows 95 produces RC4 keys of 32 bits size to protect
the .pwl files. I verified the information and wrote a
program to decrypt .pwl files with a known password, I then
discovered that the .pwl files where well suited for a known
plaintext attack as the 20 first bytes are completely predictable.
The 20 first bytes of any .pwl files contains the username, which
is the same as the filename, in capitals, padded with 0x00. From then
I wrote a program to bruteforce the .pwl file and optimized it
so it would run in less than 24 hours on an SGI. I run a test
of the bruter software and recovered an unknown rc4 key in 8 hours,
but the decrypted file was still largely uninteligeble, I then proceeded
to decrypt the file at all possible starting points, and discovered
valuable information (cleartext passwords) offset in the file.
This has enormous implications: RC4 is a stream cipher, it
generates a long pseudo random stream that it uses to XOR the
data byte by byte. This isn't neccecaraly weak encryption if you
don't use the same stream twice: however WIN95 does, every resource is
XORed with the same pseudo random stream. What's more the 20
first bytes are easy to guess. This is easy to exploit:
XOR the 20 bytes starting at position 0x208 with the user name
in uppercase, and slide this string through the rest of the file
(xoring it with whatever is there) this reveals the 20
first bytes of the different resources.
something like this (decrypted):
where wp is i word pointer to the different resources (from start
of pwl file) The 2 first bytes of the resource (rs) is its length in bytes
(of course XOR with RC4 output) It is the fairly easy to find all the
resource pointers by jumping from start of resource to next resource,
had it not been for the fact that the size sometimes is incorrect
(courtesy of M$)
What follows is a short c program that tries to remedy this and
reconstruct the pointertable thus generating at least 54 bytes of the RC4
pseudorandom stream, and then proceedes to decrypt as much as possible from
the different resources.
What does this show? Although RC4 is a fairly strong cipher, it has the
same limitations as any XOR streamcipher, and implementing it without
sufficient knowledge can have dire consequences. I strongly suggest that
the programmers at Microsoft do their homework before trying anything like
this again! This is a quick hack, I don't make any claims about usefulness for
any purpose, nor do I take responsibility for use nor consequences of
use of the software. FUNCOM of Norway is not responsible for any of this,
(I speak for myself, and let others speak for themselves)
This source is hereby placed in the public domain, please
improve if you can.
--- glide.c ---
  unsigned char Data[100001];
unsigned char keystream[1001];
int Rpoint[300];
main (int argc,char *argv[]) {
E3D2BCADBEF8C82F A5891D2B6730EA1B PGPencrypted mail preferred, finger for key

@_date: 1995-11-02 23:20:58
@_author: Frank Andrew Stevenson 
@_subject: REQUEST: Win95 password encryption details 
Can anyone please give pointers to the details of the
.PWL password encryption. Thanks.
 Key fingerprint =  E3 D2 BC AD BE F8 C8 2F  A5 89 1D 2B 67 30 EA 1B
PGP encrypted mail preferred, finger for key

@_date: 1995-11-09 09:14:16
@_author: Frank Andrew Stevenson 
@_subject: True Random (short c-source) 
I have written a short random number generator which appears to produce
reasonable random numbers even in DOS, at the heart of the code is the
short function fGetRand, the amount of entropy derived from this
function varies from >1 to >>6 depending on system load, I haven't
made any effort to whiten it at all. I am not making any claims about
its usefulness. I am only trying to demonstrate the ease at which
good random number may be obtained. Any comments and analysis will be
mostly welcome, the source is hereby placed in the public domain:
I have used WATCOM10 to compile and test under DOS/WIN95, where
clock is running at 18hz. I have also tested on IRIX with impressive
--- START ----
  int   fGetRand (void);
main (void) {
   long vCount;
   FILE *out;
   int byte;
   int tick;
   out=fopen("random.bin","wb");
   if(out==NULL) {
      printf("cant write to file random.bin\n");
      exit(1);
   }
   for(vCount=1;vCount<=512;vCount++) {
      tick=fGetRand()&0x01;
      byte=byte+byte+tick;
      if((vCount & 0x7)==0) fputc((char)byte,out);
      fputc((char)tick,out);
   }
   fclose(out);
int   fGetRand (void) {
   int count;
   clock_t tick;
   tick=clock();
   while(tick==clock()) count++;
   return (count);
----- END -----
PGP encrypted mail preferred, finger for key.
The above views are ONLY endorsed by BoggleMind Inc. (not to be confused
with MindBoggle Ltd.)

@_date: 1995-11-30 03:47:42
@_author: Frank Andrew Stevenson 
@_subject: Microsoft weak encryption 
I have been able to verify the key generation for the
.pwl file, and sucessfully decrypted one, the contets
is really suited for a known plaintext attack as the
first characters appears to be the USERNAME in capitals
padded with 0x00 to a total field size of 20,
I have written software to bruteforce this field, but without
optimizing I have a running time of 130 hours (Pentium 66)
An interesting observation: If the password is shared with a UNIX
fileserver (8 letters) once the 32 bit RC4 key is found guessing the
last 4 letters of the password will reveal the remaining letters.
This will then greatly reduce the keyspace needed to crack the UNIX
password (you need to guess the case of the password though - (2^8) )    E3D2BCADBEF8C82F A5891D2B6730EA1B PGPencrypted mail preferred, finger for key

@_date: 1995-09-21 02:34:47
@_author: Frank A Stevenson 
@_subject: netscape's response 
Suppose you divide your random material into several parts:
A: Userinput (updated from Keystroke timing etc.)
B: 'Random' numbers from remote server
C: Time, pid, ppid, etc..
D: other...
Whenever you want to incorporate new data into B you could do something like:
B = B xor Hash (A,B,C,D, fresh 'random')
This would be very hard to pollute with well chosen input.
  Frank

@_date: 1995-09-27 00:50:40
@_author: Frank A Stevenson 
@_subject: netscape NSRANDFILE compatible with /dev/random ? 
What happens if NSRANDFILE is set to /dev/random ?
will netscape try to read an infinite number of random bytes ?
  Frank

@_date: 1996-10-02 16:56:44
@_author: Frank Andrew Stevenson 
@_subject: Can we kill single DES? 
DES CRACKING SCREENSAVER
Sorry for writing twice, beside wanting to add that I might be able to do some
programming for a worthy cause, I just got a rather good idea to make a
screensaver unique and interesting ( making people want to burn cycles )
Picture this: the user upon installing the program points at his/her location on
a world map. This location is send to the keyserver, which sends back highly
compressed information about where other people are running their
"screensavers", the screensaver itself can simply display a rotating globe,
where the different densities of global usage is given in colour shades, showing
an inverse sunclock of sorts. I think such a concept might give the DES-cracking
screensaver a critical mass.
  frank
