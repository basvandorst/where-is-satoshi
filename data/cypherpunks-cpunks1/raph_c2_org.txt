
@_date: 1995-12-28 22:18:23
@_author: Raph Levien 
@_subject: Announcing a new alpha release of premail 
This is to announce that premail version 0.42 is now available. It
is a full alpha version of the new premail, containing all the
features and functions planned for the production release.
   Features include:
* Support for all cypherpunk remailers.
* Support for Mixmaster remailers.
* Encrypted and signed email, including both preparation and decoding.
* Support for the emerging PGP/MIME standard.
* Support for MOSS through TIS/MOSS 7.1.
* Creation and management of alpha.c2.org style nyms.
* More secure handling of sensitive "secrets".
* Much improved automatic selection of remailer chains.
* Clean handling of "cc:" field and other such interactions.
* Numerous other features.
   For more information about premail, see the premail Web page at:
         If you are in the US or Canada, you can download premail now, from
the premail Distribution Authorization Form:
         Please forward bug reports, comments, and suggestions to me, so
that the beta release can be as solid as possible.
Raph Levien

@_date: 1996-01-01 06:14:45
@_author: Raph Levien 
@_subject: A great time to be a cypherpunk 
Amidst all the silliness, flames, and lunacy of this list, there's
a tremendous amount of exciting stuff going on. I thought I'd take the
opportunity to do one of those self-indulgent look back at the year
   Cypherpunks write code. One of the best things about 1995 was the
volume and quality of cpunk code that was released, and, perhaps
equally importantly, existing cpunk programs that continue to be
supported and improved.
   Here's a subjective top 5 list:
1. SSLeay, by Eric Young and Tim Hudson. Ordinarily, I wouldn't
consider a crypto library to be all that newsworthy, but SSLeay is
clearly an exception. SSLeay's real strength is its ability to be
integrated easily into real applications, including Apache/SSL,
Mosaic, telnet, etc.
I'll go out on a limb and guess that one of the reasons why SSLeay is
so good is that Eric has a lot of experience doing this kind of thing.
His libdes code dates back at least to 1990, and (I think) even
2. Ssh, by Tatu Ylonen. There are a quite a few secure shells around.
What sets ssh apart is its dedication to usability. It is one of the
few crypto applications that is _more_ usable than the non-crypto
version. The transparent X forwarding is fabulous.
3. Mixmaster, by Lance Cottrell. Finally, we have remailers that come
close to real cryptographic security. The mixmasters are more
reliable, in addition to more secure, than the type-1 remailers. The
client is well written with a fairly easy interface. No wonder it's
becoming so popular.
4. Alpha.c2.org, by Matt Ghio. The idea of pseudonyms incorporating
strong cryptography has long been a cypherpunk dream. Thanks to Matt's
work in writing and maintaining this nymserver, it's now reality.
There are well over a thousand nyms registered on alpha.c2.org now,
and that's likely to increase now that automated tools are becoming
5. Netscape, by Jeff Weinstein et al. Netscape Navigator is the first
massively popular program to incorporate strong crypto. The email
hasn't materialized yet, and there have been some scary statements by
top management, but I'm hopeful that this program will become the
primary vehicle for acheiving cypherpunk goals.
   Code, while important, is not the only useful cypherpunk activity.
It's also been a great year for getting the word out there. The Net
was _the_ hot story this year, and a lot of the coverage had a
cypherpunk spin. Much of the credit goes to Sameer Parekh for his PR
work. I know some cypherpunks dislike the "interview yourself" style
of press release writing, but I'm very glad that we've got someone on
our side who's good at it and is willing to put in the work.
   More broadly, we've found that our viewpoint and opinion matters.
People are at a loss for how to think about the Net and its social
implications. We've been thinking about that for a while, and have
something to add to the discussion, and people are listening.
   1995 will surely go down in history as the year that The Great
Drive to Censor the Net began. The powers that be will continue
pushing ahead with laws restricting speech, increasing liability for
speech, and outlawing strong crypto.
   A short term effect will be to create some real differentiation
between service providers. Up to now, the difference between one
service provider and another has been an equation with bits on one
side and dollars on the other. Starting soon, it will make a
difference in what information can be easily accessed. A domain name
of compuserve.com now clearly labels its account holder as a free
speech inactivist. More cypherpunkish domain names are a sign of not
being afraid of information.
   Over the long term, I agree with Lucky. The powers that be will
have some success in censoring the Unwashed Massnet. However,
cypherpunks will be able to create an infrastructure where freedom of
speech thrives. A large part of this work is the development of
censor-resistant protocols. My favorite such protocol is NNTP, even
though it contains no crypto.
   HTTP is also a bit censor-resistant because it's so easy to set up
a Web server. However, it still has grave weaknesses from this
perspective, because of the need for a full time Internet connection
_and_ storage in order to publish on the Web. The Web can become
either more centralized or more decentralized, and there are strong
forces pushing in both directions.
   I think the best hope for a cypherpunk Web is to emphasize dual-use
techniques, those that advance mundane as well as cpunk goals. For
example, distributed caching will make transfers go faster and make
"unable to connect to server; try connecting again later" errors much
less frequent. If done right, it can also make part-time Web servers
feasible, and perhaps make it extremely difficult to delete documents
that the publisher didn't want deleted (can anyone say "cryptographic
authentication?"). Similarly, the same crypto-enabled filters that
keep spam out of Joe Random's mailbox can drive a real public key
infrastructure (Web relevance: the Web is the natural home for a
pubkey infrastructure. Let's make sure to be there for the
housewarming party).
   The way that the low-tech protocols of the Web have crushed and
assimilated corporate Weblike networks is inspiring - it holds out
real hope we can win, even against opponents as dedicated and powerful
as governments. It will take hard work, tenacity, cooperation, and
technical sophistication, though. Remember that Windows took about
seven years to become successful.
   For dud of the year, I'd have to nominate Java. Don't get me wrong,
this language shows a lot of potential. But, to a large extent,
they've done the easy part, and the hard part remains. Given its
existing security model, it's difficult or impossible to do anything
really interesting with Java. Yet, fixing the security model _is_ the
hard part. Best of luck to the Java people and all javapunks, but I
think a strong case can be made that the hype machine went overboard.
   To all the cypherpunks who helped make 1995 such an exciting year,
best holiday greetings and wishes for 1996.

@_date: 1995-11-18 16:57:26
@_author: Raph Levien 
@_subject: Design proposal: crypto-capable generic interface 
Hi to cypherpunks who write code,
   The recent discussion of "plug-in" crypto is reminding me of some
design work I did earlier this year. This post presents the motivation
and some of the details of that design, slightly updated.
   First, a few words about what I consider to be good interface that
can support plug-in crypto. It has to support both email and the Web;
I feel that everything else follows. It should support completely
transparent integration, by which I mean no extra clicking or commands
or anything like that. Finally, it should be generic in that it will
support a number of other plug-in applications besides
cryptography. Two specific applications which interest me are file
format conversions and external-body resolving.
   The design is based partly upon .mailcap, which is perhaps the best
example of a generic interface we have today. However, while .mailcap
is a nice interface for popping up windows to present semi-interesting
multimedia types, it certainly cannot support transparent
cryptography. I feel that its primary weakness is the inability to
support MIME to MIME rewriting. However, .mailcap has some good ideas
which are worth stealing.
   For the purposes of this proposal, I will assume that all objects
are MIME encapsulated. I think that's a reasonable assumption, as it
handily covers all cryptographic protocols that have any hope of
   I will propose my design at a very high level. Please forgive me
for leaving out the juicy details.
   I propose that the new interface lives as a sort of daemon, rather
than a static collection of command line script pieces. A reasonable
way for applications to talk to the daemon would be Unix domain
sockets, or whatever the equivalent is on Mac and Windows
platforms. There should be a simple protocol for automatically
starting up a daemon if there isn't one already running.
   The first part of the interface is the negotiation. The daemon
tells the application what MIME types it can understand (this part is
very similar to the .mailcap file, but doesn't include the
corresponding command lines). In reply, the application tells the
daemon what MIME types it can understand (this is like the
Http-Accept: field in HTTP).
   Once the negotation has been established, the application can send
the daemon MIME objects that the app does not understand but the
daemon does (for example, an image/fractal). The daemon can return a
MIME object that the app does understand (for example, an image/ppm).
   Alternatively, the daemon may request an authentication. This is
useful when resolving external bodies that require authentication,
including non-anonymous FTP, and standard authenticated HTTP. In this
case, the daemon sends a message to the app requesting the
authentication. It specifies whether it needs both username and
password, or just password. In the latter case, it hands a username to
the application.
   The application can then query the user for the authentication
data. It hands this back to the daemon. In reply, the daemon indicates
success or failure. In case of success, it hands the object back to
the app.
   I'm quite pleased with this protocol as outlined. It's fairly
simple, which means it might actually get implemented. It's also easy
to see that it does exactly what you want for file format conversions,
external body resolving, and decryption of encrypted messages.
   Encryption is a bit more tricky, but in essence you just hang a
premail-alike off this kind of protocol. The hard part is specifying
the key, but you just call it a "parameter" and put in hooks for the
daemon to ask for whatever parameters it needs. This requires that
keys have some nonforgeable names, which is unfortunately not a
feature of PGP 2.6.2. S/MIME will do it just fine, if you buy into the
Certifcation Authority ( at Nick Szabo).
   One final aside: I've been fairly frustrated with this mailing list
as a forum for talking about real design proposals and implementation
issues. Ignorant posts by the likes of Dr. Fred and Alice d'Clueless
tend to attract far more attention than real crypto work. I want a
forum for, and just for, cypherpunks who write code. If I had just a
smidgen more free time (as if), I'd be trying to start one
myself. Anyone else?

@_date: 1995-11-19 03:14:13
@_author: Raph Levien 
@_subject: Design proposal: crypto-capable generic interface 
One per user. I'm thinking that, most of the time, the daemon process
would only last as long as the application.
It is certainly true that if there were to be one daemon per machine,
the security requirements would be a lot greater, as it would no
longer be possible to rely on the operating system to get the file
permissions right, etc. On the other hand, the daemon process better
be done right, or your're in trouble anyway.
   Exportability. There is a general feeling that a mailer program
with specific hooks to libpgp is going to have trouble with
exportablity (and forget about binaries), where a program that
supports a generic interface (the likes of .mailcap) is out of the
NSA's jurisdiction. Of course, this is speculation until we actually
get a ruling, but it sounds plausible enough to me to warrant spending
some time on design and implementation.
   Your question brings up another point: if the daemon process is
going to run as the personal slave of the application, then why not a
dynamic library instead? Two reasons. First, on Unix anyway,
interprocess communication through domain sockets is a more mature,
robust, and portable technology than dynamically linked libraries. On
Windows, it's probably the other way around, and that's worth thinking
   The real reason is, though, that the daemon and application should
naturally be distrustful of each other's address spaces. Can you see
Netscape shipping code that links in a Joe Random dll? Conversely, do
you want your PGP secret data structures sharing an address space with
one of Netscape's beta releases? Using two processes in two address
spaces solves this problem.
   Jeff, if you're reading this, what do you think Netscape's chances
are for supporting such a protocol, assuming of course that there were
nicely implemented daemons, and that the protocol itself was going to
standards track? Is it something you'd be interested in?

@_date: 1995-11-19 03:43:15
@_author: Raph Levien 
@_subject: Design proposal: crypto-capable generic interface 
atilla brings up many good points, including:
   An even better solution is to design the cryptosystem so that it
doesn't _need_ temp files int he first place. MOSS wins, PGP loses. I
don't know enough about S/MIME to say.
   In a related vein, Darren New  sent me a pointer
to First Virtual's SMXP (Simple Mime eXchange Protocol). This is a
cool protocol that does about 50% of what I'm talking about. If you're
interested, here it is:
      ftp://ftp.fv.com/pub/docs/smxp-spec.{ps,txt}
   In order to adapt SMXP into something that's useful for what I've
proposed, numerous changes would need to be made:
* Unix Domain Sockets instead of TCP
* Add negotiation
* Add authentication
   Without these three changes, the system is nearly useless for
crypto. Further, there are two "aesthetic" points I'd like to see
claned up given the chance. First, SMXP makes the "ASCII assumption."
Since the daemon and app will be tightly coupled, definitely running
on the same machine, there is no reason to exclude binary MIME
objects. On the other hand, as far as I know, all of the MIME crypto
protocols are ASCII based (somebody please correct me if S/MIME is the
   Second, in order to support operation without temp files, it's
necessary to interleave the operations of transferring the object from
the app to the daemon and vice versa. I have a proposal for a
lower-level spec which can handle this quite readily, if anyone is
   Unfortunately, the proposal doesn't look much like SMXP. However,
the possibility of creating a prototype based on SMXP is intriguing.
P.S. Did anyone see the mention of the perl/RSA CJR in the latest
Wired? Managed to get the attribution wrong. Still no response.

@_date: 1995-11-19 12:37:53
@_author: Raph Levien 
@_subject: Design proposal: crypto-capable generic interface 
MIME Object Security Services. It's a technically superior alternative
to PGP, but one with an uncertain future. It's not being actively
developed by anyone other than TIS, and their TISMOSS prototype
implementation is far from being generally usable.
For more information on the standard, see RFC 1848:
      For more information on the TIS effort, see:

@_date: 1995-11-21 01:18:23
@_author: Raph Levien 
@_subject: Design proposal: crypto-capable generic interface 
Ah, I was hoping that my statement would stir some controversy. I've learned that well thought out, carefully reasoned posts never get any I agree with you that the X.509 stuff is extra baggage in MOSS. Fortunately, the use of X.509 is optional.
MOSS has two very large advantages over PGP:
1. It can operate without temp files.
2. It has no non-MIME variant.
It will take forever for PGP/MIME to catch on. Thus, PGP will never really be a suitable candidate for my generic interface. Ah well.
This is true. I hope it happens.

@_date: 1995-11-23 02:50:14
@_author: Raph Levien 
@_subject: Design proposal: crypto-capable generic interface 
In restrospect, "daemon" was a poor choice of words to describe my
proposal. "Slave process" gets the idea across much better, but may be a
bit less PC. A daemon sits on a publicly accessible port, such as a TCP/IP
socket. The slave process is only accessible to the user who invoked it
(enforced by the OS's file permissions). Further, it only gives secrets to
individual processes that authenticated themselves first (by sending a
passphrase down the connection to the slave process).    I'm glad you like it!
   No, the communication is not via a LAN. On a Unix system, the communication is through Domain Sockets. Both processes live on the same machine, and the socket "lives" on the local file system.
   I submit that my proposal is every bit as secure as, say, PGP is now. If you can't trust the operating system not to hand domain sockets from one process to another, then you certainly can't trust it to, for example, substitute different binaries for the crypto program (an attack which Ian et al cleverly mounted a few weeks ago).
   If it were not the case that my proposal was as secure as PGP, then I would want to withdraw it. However, the proposal has so many advantages that I would want to see a serious description of the attack, rather than just feelings of endangerment to Will Robinson.
   I should have made it cleaer that I am referring to public keys. If public keys are on the list of things that can't be distributed, then I believe we are in trouble.
   Ok. But public keys have one serious disadvantage: their size. I can't put a public key on my business card or read it over the phone. I want a unforgeable key name. I want this to be the standard key name in the interface between the application and the crypto engine. I want users to be able to specify them directly, at the very least to bootstrap the public key infrastructure.
   I propose using the MD5 hash of the whitespace-free MOSS representation of the public key, in hex. It's simple enough to be described in one sentence, but does everything I want.
   Note that PGP 2.6.2 does _not_ allow the use of a public key as the name of a public key, unless you do a horrible hack such as replace the pubring.pgp file with the one public key of interest. This is a significant problem when trying to identify which key signed a signed message. I haven't bashed around with TISMOSS enough, but I'm not sure it will allow this either. I got the impression that it preferred the use of an alias.
   Thanks for the suggestion. However, my concerns are with implementation and deployment, not research.  I am perfectly willing to consider cryptographic algorithms to be black boxes that do what they say they will. I think the charter exists to start a new list. John Gilmore has already offered to start a "coderpunks" list on toad.com. Shall we take him up on it?

@_date: 1995-11-23 04:59:14
@_author: Raph Levien 
@_subject: Design proposal: crypto-capable generic interface 
What I am getting from you is "worry." This does not convince me. I
want solid technical criticism. Sorry for being so harsh, but that's how I
feel.    In fact, I propose that the security of the "slave process" model is
_better_ than the realistic alternatives. Without it, the application
stuff (for example, displaying pretty MIME content) and the crypto stuff
must share an address space. A bug in the application stuff could corrupt
or compromise the crypto data structures. As we have seen demonstrated
several times, it is just not practical to build large, complex
applications which are worthy of the highest level of trust. Factoring it into two processes helps.
   Tokens are nice, but I think there's a lot to be said for software solutions as well. At the very least, I don't consider the existence of tokens to be an argument that software crypto systems shouldn't be built.
   I would accept SHA as a reasonable alternative.
   Using the modulus alone is not good enough. A bogus key with the same modulus and a different exponent could be used to mount a denial-of-service attack. Note that the PGP 2.6.2 key fingerprint scheme suffers from a similar problem; since the sizes of the modulus and exponent fields are not included in the hash, it is possible to generate bogus keys with the same fingerprint. Specifying the key size and fingerprint together is, however, unforgeable.
I looked at the MOSS representation of the key (I'm talking PK's here
only, not all the X.509 stuff). I don't think it would be that hard to
code.    I was referring to the interface that PGP presents to the outside world, not its internal keyring structures. These issues come up whenever using PGP from the command line, or trying to interface it with other    I understand that Matt Blaze's forthcoming "Policymaker" will do all this and more.
   This is fine, but it's one more thing to manually maintain. How is the user going to verify that the alias is really right? This is another place where a 32- (or 40-) hex digit unique name would come in handy.
   I agree that a moderated list would be better, but I do not have the
time do it myself.
   One suggestion that I think is very good is to moderate on the basis on the basis of sender, rather than message. The best way to do this would be to keep a keyring of "approved" senders, and match the signature of each message against the keyring. As I say, I'm not volunteering, but if somebody else was so moved, I think it would be a valuable service.

@_date: 1995-11-28 03:33:05
@_author: Raph Levien 
@_subject: The future will be easy to use 
Here's a quote from Bill Gates' book:
   The mechanism that will make this possible is based on
   mathematical principles, including what are called
   "one-way functions" and "public-key encryption." These
   are quite advanced concepts, so I'm only going to touch
   on them. Keep in mind that regardless of how complicated
   the system is technically, it will be extremely easy for
   you to use. You'll just tell your information appliance
   what you want it to do and it will seem to happen
   effortlessly.
(Thanks to the anonymous person who typed it in)
   We may not all like Bill Gates, and some of us even boycott his software, but we must admit he is a very shrewd businessman and knows which side of his toast is buttered. I think this paragraph is right on the mark. The competition for which cryptographic protocol wins will be decided on the basis of usability.
   The "dark forces" are no doubt aware of this fact, and have already
made some advances in this area. One example is the Fortezza card.    If cypherpunks are to have any hope of getting their vision of strong crypto implemented and deployed, it has to be in the context of usable    Form this perspective, let's take a look at the recent thread on
"establishing trust." Carl Ellison advocates the MOSS alias system. My
understanding of this system is that individual users associate "aliases" with public keys. If done right, it can work well. However, from a
usability perspective, it is just one more trouble spot.    First, on what basis will users decide which keys are worthy of being
assigned which aliases? Public keys are big hunks of base64 encoded
gibberish. They are difficult to present in a user interface, difficult to communicate in alternate, known secure channels (such as telephone calls and face to face communication). There is no way that a person could memorize one.
   The other issue is how much time and energy the user has to spend keeping the alias database up to date. There is no way to communicate securely with anyone who's not in the database. If the user is communicating with a large number of people, then it's very tempting to get sloppy.
   There's no way around it. This kind of system will not make it in the big time. As I see it, any system that does must have the following    * Some variant on the Web of Trust.
   * Online key-servers for getting keys in real time.
   * A clean mechanism for validating keys through alternate channels.
   There are three possible outcomes: we build it, the NSA builds it, or Microsoft/Netscape builds it. This last outcome might not be so bad, but only in the first one can we rely on our principles being advanced.

@_date: 1995-11-28 05:57:51
@_author: Raph Levien 
@_subject: The future will be easy to use 
Full agreement.
I think that changing the focus of cypherpunks is intractable enough that forming a new group is the only feasible alternative. Right now, I don't have the time to try to form such a group, but I would be an enhusiastic participant if such a group was to be formed.
Incidentally, I've had one bad experience with this type of thing (it was
the PGP 3.0 development team), so I realize it's not easy. A couple of
things I've learned from the experience: * Clear goals.
* A leader, someone who would call the shots, and would also serve as the
person you'd have to convince.
* Open communications. Shrouding a project in secrecy is a good way to kill it. This is one potential advantage we have over the spooks.
It _is_ doable. I know the skill is out there. Wei Dai, Eric Young, Peter
Gutmann, and others have proved themselves quit capable of writing good
solid code. Sameer Parekh has done an incredible job with PR. Phil Karn,
Dan Bernstein, and some others (who I'm not sure want to be named) are
talking to the government. GUI I'm less sure about, but I'd hope that some
cpunks would come out of the woodwork.
It is not a matter of ability, but of will.

@_date: 1995-11-29 04:03:41
@_author: Raph Levien 
@_subject: The future will be easy to use 
This is the induction case, not the base case. It assumes that you've already got a bunch of trusted public keys in your database. It also assumes the willingness of the ownsers of those public keys to sign new keys. See, now they've got the same problem of trying to determine whether the key is valid. Turtles all the way down.
There being no reason, of course, why Mallet couldn't just sign all that stuff with his own signature. Here, you're relying on the ability of data to authenticate itself.
I am simply proposing a third alternative that has neither of these
problems: a short unique name for the key. Its success relies on
alternate, non-digital forms of communication: the phone, ink-signed
paper, face to face, whatever. [complex stuff deleted - I only wanted to make a simple point]

@_date: 1995-11-29 04:07:54
@_author: Raph Levien 
@_subject: The future will be easy to use 
Unfortunately, it's _way_ too early to recruit volunteers to test out the user interface. But thanks.

@_date: 1995-11-30 07:10:28
@_author: Raph Levien 
@_subject: Response to ping re: CJR 
I just got a message on my answering machine from Sam Capino. He said
they are working on answer to my CJR. They had hoped to get it out by
now, but were set back by "the furlough." I had called him about a
week ago to check up on the status, but at the time only got his
answering machine.
Of course, the original 15 days have passed, but I'm perfectly willing
to let that slide since I'm not completely sure that the CJR was
submitted using exactly the right process.
Just thought you'd like to know.

@_date: 1995-12-01 05:50:28
@_author: Raph Levien 
@_subject: Getting a copy of the Jim Clark speech 
I called Netscape public relations. Here's what I found out:
1. Netscape PR does not keep transcripts, etc., of Jim Clark's
2. You can order a tape of the speech from Conference Copy for
$12. Their phone number is +1 (717) 775 0580. Be advised, though, that
it will take three weeks.
If we are lucky, an amateur recording technician (trained by the
Grateful Dead, perhaps?) will come out of the woodwork before
then. Failing that, maybe a Fair Witness was there and is willing to

@_date: 1996-04-02 20:07:02
@_author: Raph Levien 
@_subject: "Dead beef" attack against PGP's key management 
This post is signed by a forged key for Phil Zimmermann. I forged
the key this morning. The key has the same user id and visible key id
as an old key for Phil Zimmermann, which he has since revoked.
   I should stress that this attack does not in any way weaken the
security of PGP's message formats. However, it does expose a problem
in the user interface of its key management. Namely, it is fairly easy
to forge a key that looks very similar to an existing key. In fact,
the only way to distinguish between real and forged keys in general is
by the fingerprint and keysize together.
   My purpose in posting this is to demonstrate that such forgeries
are possible. The lesson is: please do not use the key id alone to
identify keys.
   Another reason for the public posting of this forgery is to goad
the PGP development team into improving the user interface in PGP 3.0,
so as to make the detection of such a forgery much easier, if not
routine. Derek Atkins has assured me that PGP 3.0 will include a
cryptographic hash of the key, for use as a key id. If implemented
properly, such a facility would address this attack.
   I am not the first to propose this attack. According to Derek
Atkins, Paul Leyland first proposed the attack two years ago. Also,
Greg Rose successfully mounted a similar attack six months ago,
creating a key with user id 0xDEADBEEF, thereby giving rise to the
   The pseudocode for the attack is as follows:
      choose random 512 bit prime p
      choose random 480 odd x
      q = x * ((0xdeadbeef * (p * x) ^ -1) mod 2^32)
      do {q += 2^32} while q composite
   The above bit of pseudocode replaces the original selection of p
and q, which are normally just random 512 bit primes. Without having
done detailed analysis, I believe that the resulting forged keys are
just as good as ordinary PGP keys. Further, the modified key
generation is almost as fast as ordinary PGP key generation, and I
think I could speed it up a bit more.
   The attack took me a few hours to design and code. Any good
programmer familiar with PGP could duplicate it easily.
   One practical application of this attack is to implement a certain
degree of "stealth." Since PGP includes the key id in encrypted
messages, it is in most cases possible to identify the recipients of
encrypted messages. However, if a lot of people generated keys with
the same key id, then it would not be possible to tell from the
encrypted message which one was the intended recipient.
   Here's the public key I forged, which can be used to check the
signature of this message:
Key for user ID: Philip R. Zimmermann 1024-bit key, Key ID FF67F70B, created 1992/07/22
Also known as: Philip R. Zimmermann

@_date: 1996-02-15 16:45:58
@_author: Raph Levien 
@_subject: A brief comparison of email encryption protocols 
This message briefly reviews and compares the four major email
encryption protocols under discussion: MOSS, PGP, PGP/MIME, and
S/MIME. Each is capable of adequate security, but also suffers from
the lack of good implementation, in the context of transparent email
   I will try to address issues of underlying cryptographic soundness,
ease of integration with email, implementation issues, support for
multimedia and Web datatypes, and backwards compatibility.
   An additional grave concern is key management. Contrary to some
beliefs, key management is not a solved problem. All of the proposals
contain some mechanism for key management, but none of them have been
demonstrated to be scalable to an Internet-wide email system. My
belief is that the problems with key management do not stem from the
classic Web of trust/certification hierarchy split, but the
nonexistence of a distributed database (with nice interfaces) for
holding keys. The encryption protocols also stand in the way of such a
database, with key formats that are either overly complex, inadequate,
or both.
   In case it is not clear by now, this review will be quite
subjective, in many cases representing my own beliefs rather than
objective fact. I'll try to point that out where I can. Also, I do not
claim to have a thorough understanding of PEM and PKCS. Much of my
knowledge comes from implementing premail, a tool that acts as "glue"
between mailers and encryption packages. It supports PGP, MOSS (using
the TIS/MOSS 7.1 implementation), and a draft of PGP/MIME, in addition
to a wide range of anonymous remailer services. While usable, premail
has many limitations, and certainly does not represent the "holy
grail" of transparent email/crypto integration. Thus, my participation
in the Internet Mail Consortium Secuirty Workshop
   I apologize for the wide distribution, and ask that followups be
   PGP (Pretty Good Privacy) is, of course, the de facto standard for
email encryption on the Internet.
   PGP's underlying cryptography is quite sound - RSA (up to 2048 bits
with the most recent implementation), IDEA with a 128 bit key, and
MD5. PGP is entirely in accordance with the recent recommendations on
minimum keylength ( and in
fact does not include a mode of operation in violation of those
recommendations. This makes PGP (and, by extension, PGP/MIME) unique
among the encryption protocols.
   PGP is packaged in a single application (i.e. a single binary)
which performs encryption, decryption, signing, verification, and key
management. It does not depend on the existence of great deal of
infrastructure. These factors have, in my opinion, been decisive in
PGP's popularity.
   However, PGP is still not suitable for fully transparent email
encryption. The reasons are complex, and I will only touch on them
   The main missing feature is the lack of MIME integration. Thus, PGP
is not suitable for multimedia types other than US-ASCII text. PGP
does contain some support for 8-bit charsets, but at cross-purposes
with MIME. Signature checking of non-US-ASCII data is simply not
reliable. To give an idea of this problem, the most recent
international version (2.6.3i) tries several different character set
conversions when verifying signatures, to see if any of them will
   However, since a large fraction of email _is_ US-ASCII text, this
feature alone probably does not explain the lack of deployment. PGP
contains a number of implementation flaws (including silly things like
not locking files, so that concurrent invocations fail). In addition,
key management has some problems. Mostly, key management is hard to
learn, time consuming, and requires a great deal of manual
intervention. The "Web of trust" is supposed to fix this, by providing
transitive trust of key authenticity. However, in practice the Web of
trust has not delivered. In my experience (with many dozen
correspondents), I have only had one or two keys transitively trusted.
   A standard PGP-signed message consists of a "-----BEGIN PGP SIGNED
MESSAGE-----" line, the signed text (subject to some canonicalization
rules), a "----BEGIN PGP SIGNATURE-----" line, a version line, the PGP
signature itself, and an "-----END PGP SIGNATURE-----" line. All this
is in the message body. The headers indicate that the message is a
standard 7-bit, us-ascii, text/plain message. Thus, mailers have to
parse the message contents to identify the message as PGP signed, or
to extract the signed parts. This is at cross-purposes with MIME.
Mailer implementors are reluctant to include such ad-hoc extensions.
Existing extensibility mechanisms, based on MIME, cannot be used.
   PGP encrypted messages are similar - the identification as an
encrypted message can only be made by parsing the message body.
   One technical problem with PGP is its inability to support
single-pass processing, because the data format includes a size
   PGP/MIME is an effort to integrate MIME and PGP. There is a
workable draft based on the MIME security multiparts, but the PGP/MIME
mailing list is divided. Some particpants are happy with the existing
draft, while others feel that other points in the design space
(for the most part, labelling existing PGP message formats with
appropriate MIME types) would be better.
   The design space is large and complex, with many constraints on
efficiency, simplicity, backwards compatibility, and functionality. It
is not clear that a consensus will develop at all.
   There are two implementations of the PGP/MIME draft: premail, and
the PGPMIME reference implementation by Michael Elkins.
   For more information about the PGP/MIME draft, see
 .
PGP 3.0
   Many people are hoping that PGP 3.0 will somehow come along and
solve all their problems. PGP 3.0 is only an evolutionary improvement
over the existing implementations (MIT PGP 2.6.2 and PGP 2.6.3i). For
the most part, it will support only the existing message formats.
There may be support for decoding draft PGP/MIME signed messages, but
this is still being negotiated.
   The main advance in PGP 3.0 is a cleaned up implemenation. The PGP
2.6.2 code is disgusting, and should not be integrated directly into
any mailer application. The 3.0 code will be modular and based on
published interfaces. Furthermore, the 3.0 development team plans to
release the code as both a stand-alone application and as a library.
   It is difficult to predict when the public release will happen.
Based on what I've seen, fall of 1996 seems the most likely.
   MOSS (MIME Object Security Services) is an attempt at an email
encryption protocol in accordance with MIME. It is currently an
Internet RFC. There is a reference implementation (TIS/MOSS 7.1).
   MOSS is mostly cryptographically sound. However, the choice of
symmetric encryption algorithm (and key size) is left unspecified.
Thus, it cannot be said that MOSS is in accordance with the
recommendations for minimum keysize. In fact, the only public
implementation, TIS/MOSS 7.1, uses 56-bit DES, which is in direct
violation of these standards.
   The TIS/MOSS implementation has a number of other problems. It is
big and complex, probably due to its TIS/PEM ancestry. For more
information about TIS/MOSS, see
 .
   MOSS supports two modes of key management: X.509, and completely
manual key management. In this way, it is a dramatic advance over PEM,
which only supported X.509, but life for implementors remains hard.
One feature which I believe is sorely lacking is a cryptographic hash
of the public key as the basic unit of manual key management. Thus,
people either have to trust the mechanism by which the key was
delivered, or examine the base-64 representation of the entire key. I
consider this to be a serious usability problem.
   For an example of how hashes of keys have been done right, see
Netscape 2.0's handling of untrusted certificates.
   S/MIME is an attempt to graft MIME support onto underlying PEM
standards. See  for more info.
   I feel compelled to deal harshly with RSA's S/MIME FAQ
( It suggests that MOSS has
interoperability problems because of multiple implementations, while
S/MIME presumably doesn't. I take strong exception to this statement.
There is no technical basis for it. I consider the possibility of
admitting multiple implementations as a _requirement_ for an Internet
email standard. However, because S/MIME is documented, it hopefully
will be possible to create independent implementations, in spite of
what RSA says.
   The only symmetric encryption algorithm mandated by S/MIME is
40-bit RC2. Thus, S/MIME is in violation of the key size
recommendations. Further, RC2 has not been confirmed to be publicly
known. If RC2 is not known, then an independent implementation of
S/MIME is impossible. Fortunately, source code for an alleged
implementation of RC2 has recently been posted to the Internet,
resolving this problem, if it is authentic. If not, then my
reservations remain.
   S/MIME also recommends 56-bit DES CBC and (either 112 or 168 bit)
DES EDE3-CBC. This is good; any S/MIME implementation in accordance
with the recommendations will conform to the keysize recommendations
as well.
   S/MIME remains firmly grounded in the X.509 certification
hierarchy, although the FAQ claims that the guidelines for hierarchies
are "more flexible" than in PEM.
   One cryptographic weakness of S/MIME is that eavesdroppers can
distinguish between encrypted and signed-and-encrypted messages. This
violates the principle of disclosing a minimum amount of information.
PGP, PGP/MIME, and MOSS do not have this problem.
   Probably the most controversial aspect of S/MIME is its signature
format. An S/MIME signed message is a MIME multipart in which the
first part is the data to be signed, and the second part is a complete
PKCS  (section 10) signed message. This protects quite well against
munging by mail transport, but has two problems. First, the size of
the message is doubled. Second, the fact that the two singed messages
are identical is not enforced (if it were, mailer munging would cause
too many signatures to fail). Thus, Eve can send Alice and Bob a
message (M1, (M2, Signature(M2))). Alice, not having an S/MIME
implementation, would see only M1. Bob, having an S/MIME
implementation, would see only M2, for which the signature would
check. Alice, being suspicious, might call Bob up on the telephone and
ask whether the signature was really valid. Bob would of course say
yes. Unless they compared notes on the contents, they would not notice
the discrepancy. To my mind, this counts as protocol failure, and thus
it is not possible to claim that S/MIME conforms to best cryptographic
   I would expect that doubling the message body will create
performance problems in a Web environment. For example, if the first
message is used for display, then it becomes necessary to compare the
two messages. If, instead, the second message is used, then the first
message will be responsible for significant added latency.
Integration with mailers
   Integration with mailers is quite difficult. In general, the mailer
implementor will need to add specific features to support
cryptography. Because of the restrictiveness of ITAR regulations, such
an approach may not be practical for US developers, at least while
supporting strong cryptography.
   Perhaps the biggest feature required in the mailer is integration
of key management and the "address book". If this feature is not
implemented in the mailer, then two address books are required - one
to select email addresses, and another to map email addresses to keys.
This approach is used by premail, and is the source of many usability
problems. It would be nice if a database existed which could map email
addresses to public keys without manual intervention, but none of the
proposals on the table are capable of it. Such a database would
certainly improve usability, as well as making it considerably easier
to    Another feature that is required for fully transparent integration
is caching of decrypted session keys. If not implemented, then the
user interface delays in navigating a mail folder become unacceptable.
To my knowledge, no implementation supports this feature.
   One dimension in the design space is whether the cryptographic
engine is tightly integrated with the mailer (i.e. shares an address
space), or is a separate process that communicates with the mailer.
Both approaches have been implemented. Both approaches are subject to
numerous pitfalls, which have unfortunately not been entirely avoided.
   These issues have more to do with implementation than with the
encryption protocol, but I thought I'd mention them here, so that they
are not actively thwarted.
   All of the proposals described here can be used for secure email.
None of them will be widely deployed in this capacity unless they are
implemented well. I have concerns that both MOSS and S/MIME are
susceptible to political pressure which will restrict key sizes
insecurely in practice. I would like to see consensus develop around
one of the proposals, so that energies used for implementation can be
more focussed and effective. It is my hope that this conference will
move in that direction.
Raph Levien

@_date: 1996-02-24 10:42:23
@_author: Raph Levien 
@_subject: Conference report - resolving security workshop 
(Note: subject line restored - it got chopped because I misspelled it as "subect" and used raw sendmail. Also, the original text, with small corrections, is available at    This can be fixed as easily as allowing the protected MIME part to be
an S/MIME signed message. The S/MIME spec will need to recommend that
mailers deal gracefully with this case; if not, there will be user
interface disasters. I'd recommend that mail readers treat recursive
encrypted and signed S/MIME messages identically to non-recursive (i.e. PKCS  native). Even better would be for the RSA's S/MIME toolkit to be able to perform the translation automatically.
   I agree with Brad that it needs to be fixed. If a large installed base of S/MIME clients gets deployed that cannot handle the S/MIME format hiding the signatory, then we will have failed in an important way.
   Agreed. The changes to PGP could be good, bad, or some combination. My real point is that whatever the reasons have been for PGP's success or failure, they won't resemble much the reasons why PGP will succeed or fail in the future.
   One of the action items from the conference was for the contenders to
converge on any pieces that were not gratuitously different. For S/MIME
and PGP/MIME to simply adopt receipt and labelling standards, even to lift
them wholesale from MSP, would be well in accordance with this goal, I
think.    Hear, hear. My point is that it isn't just cypherpunk advocacy of
strong crypto. Any company that ships a 40-bit product is going to get
badly burned by well publicized breaks. Their customers are going to feel
betrayed. They thought they were buying a "secure" solution, but they
   Perhaps this is putting it a bit strongly, but using the word "secure" in conjunction with a 40-bit produce borders on fraud. Perhaps it makes more business sense to defend against the ITAR on First Amendment grounds than to defend against fraud charges on ITAR grounds. If not a lawsuit, then a disillusioned customer base, which is just as bad.
   I think we just did. The only other way for the field to reduce any
more is for PGP to tank (unlikely), for RSA to drop S/MIME (unlikely) or
for MSP to disappear (won't happen entirely - witness X.400).    I was speaking about others ;-). A lot of people have announced that they're going to implement S/MIME. The remaining question is whether they're really going to do so. Without sticking out my neck and naming individual companies, the impression I got is that they are.
   Yes.
   There was support, but was there consensus? My brain is just too fuzzy to remember.
   Absolutely.

@_date: 1996-02-24 16:18:31
@_author: Raph Levien 
@_subject: No Subject 
Here follow one cypherpunk's impressions of the Internet Mail
Consortium's Security Workshop
( on Wednedsday 21 Feb 1996.
Since there will be official notes of the proceedings, I felt I had a
little more scope to convey mood and feelings rather than dry
technical facts. After all, I think the buzz will do more to determine
what gets deployed than the technical merits.
   This document is available on the Web at:
      The setting
   Paul Hoffmann and Dave Crocker recently started the Internet Mail
Consortium ( This workshop was its first major
activity. Dave Crocker moderated the event, skillfully herding almost
70 secure email proponents and representatives from user communities
through a very tough subject.
   The title of the workshop was "Resolving email security," but there
was no real expectation that the issues would be resolved that day.
What was expected (and what happened) is that people would get a
better understanding of why secure email hasn't happened yet, what
kinds of things could be done to make it happen. More impressively,
there was "room consensus" for a few _very_ positive steps, about
which more later.
   One of the goals of the IMC is to involve users, not just
developers. I was ready to "officially" represent the "cypherpunk user
community," but fortunately, I didn't need to. In fact, the strongest
advocacy of strong crypto came from an employee of a "large service
provider in America." Overall, I felt that the user communities were
pretty well represented, and all important technical points got made.
MOSS is dead, long live MOSS
   There was a lot of energy around S/MIME. People are implementing
it. Internally, it's pretty kludgely, but it does provide pretty good
cryptographic services. (as an aside, my favorite kludge anecdote is
the fact that X.509 certificates use an IA5 character set rather than
ASCII, so that the @ in email addresses has to be represented as (a)
   The main thing people didn't like about the existing S/MIME spec is
the signed message format. In the existing spec, you've got a choice
between a message unreadable to non-S/MIME-aware clients, or
duplicating the data. Neither alternative is very palatable.
   Apparently, though, a new version of the S/MIME spec _will_
incorporate the multipart/signed format of RFC 1847. This made almost
everybody happy, although I'm sure all those S/MIME developers are a
bit unhappy with the spec changing, and having to reimplement stuff.
   The biggest problem with S/MIME is that the signed and encrypted
format reveals who made the signatures. Obviously, this has severe
consequences for anonymous mail. Believe it or not, a lot of people
care. For example, the car manufacturers do not wish to broadcast the
email addresses of their employees over the net.
   One technical workaround is to do it the MOSS way - first, sign the
message, resulting in an intermediate S/MIME message, then encrypt
that into a second S/MIME message. I'd recommend that implementors
make provisions for such recursive formats; I think it's likely that
we'll see a lot of these on the Net.
PGP: troubled, but still alive
   I've been thinking about the 40 bit thing a lot. It makes me very
uncomfortable. From the cypherpunk perspective, this should be nothing
new or remarkable, but keep in mind that there's a _lot_ of pressure
on companies to be able to make money in overseas markets.
   In one of the "modular algorithms" designs, it's not easy to figure
out which algorithms your recipient can understand. Guess wrong, and
your message goes out with 40-bit encryption. In my opinion, this is
worse than no encryption at all, because it gives the false sense of
security. Building such a failure mode into an email encryption
protocol strikes me as a bad idea.
   This is my subjective impression, but I sensed that there was a
collective delusion that US software developers would actually be able
to sell a 40-bit product overseas. Certainly, Netscape has proved that
it is possible, but then again, encryption is peripheral to the value
of their product. You'd still be using Netscape even if it had no
encryption at all, wouldn't you? How many https: URL's are even in
your history.db file? For a "secure email" product, it's a different
   There were a few other things that led me to the conclusion of a
40-bit delusion. First, people still seemed to thing that the
cypherpunk 40-bit cracks were a concerted effort by highly expert
people, rather than the weekend hacks that could be duplicated by any
competent sysadmin or grad student. I don't think the message really
got through. If 40-bit email gets deployed, we need to make a few more
high-profile cracks just to hammer it in.
   Finally, there's an almost religious belief that making the choice
of algorithms indepenent of the encryption protocol will somehow solve
the problem. From the point of view of the user, this is just not
true. What the user selects is an encryption protocol, an algorithm
suite, and whatever other parts of the spec were left open. What the
user selects doesn't have any modularity in it at all. It's either a
good protocol or a bad one.
   Maybe customers today think that 40-bit encryption offers some
value, but I think they'll soon be disillusioned. This is something
that cypherpunks can have a role in. In the medium to long term, it
will become clear that 40-bit encryption offers no benefits, and in
fact is dangerous.
   My advice to US developers: don't even try to export a 40-bit
version of your product. Just leave crypto out of the export version.
Your product will have better performance and many fewer configuration
problems. Include 40-bit in the US product if you have to, but don't
allow it to be used silently. For example, put up a little dialog that
says, "are you _sure_ you want to use 40-bit encryption? It's not
secure, you know."
   If care about offering crypto in the non-US market, form a
partnership with overseas developers to add the crypto.
   Non-US developers, now is a fabulous opportunity. Get those
implementations underway, the sooner the better.
   Since there is no one single standard that everyone feels
comfortable with, we will somehow have to deal with the coexistence of
multiple conflicting protocols. Fortunately, this is something the Net
is good at.
   Most serious email vendors plan to "implement everything that's
real." That means S/MIME for sure, PGP/MIME assuming they can get
their hands on a decent implementation, and MSP if they sell a lot of
stuff to the government.
   If everyone follows this path, then we really will have
interoperable secure email. Perhaps over the long term, one of the
standards would come to dominate, perhaps not.
   I know that the deployment of secure email has been a year away for
the past decade or so, but now I think it really is poised to happen.
The implementation effort is very much real. Over the next few months,
we will see some very high profile, mass market implementations.
   Before that happens, though, the protocols must actually become
stable. It's a characteristic of _all_ of the viable protocols that
they're still in flux, still in the process of being defined. But at
least the direction is clear, largely as a result of feedback from
this workshop.
   At the end of the meeting, Dave asked the room for consensus on
several points. First, there was strong consensus that the encryption
protocols converge on multipart/security for their signed message
format. Second, it was agreed that the proponents of the surviving
schemes get together to list their differences, justify these
difference, and commonalize things that don't _need_ to be different,
also agreeing on a timetable concluding at the Montreal IETF meeting.
   I'd say that's quite a remarkable achievement for a such a
difficult area.
Raph Levien

@_date: 1996-01-03 15:24:44
@_author: Raph Levien 
@_subject: New year's letter picked up by Netly News 
Hi cypherpunks,
   In case anyone missed it the first time, or just prefers to see it
in HTML (with URLs), my new year's eve letter got picked up by the
Netly News, Josh Quittner's daily column on Time's Pathfinder Web
   The second part will run tomorrow.

@_date: 1996-01-06 07:04:07
@_author: Raph Levien 
@_subject: An open letter to Commtouch 
Hi Commtouch people,
   I am intrigued and hopeful about your secure e-mail product, Pronto
Secure. However, I am puzzled about its support for POTP encryption.
   The other encryption protocols (PGP, PEM, MOSS, and S/MIME) have
all been reviewed carefully by outside experts, and there is general
consensus that these protocols embody state-of-the-art cryptographic
technology, and that there are no known major security flaws. POTP
stands out on your list because such a review has not been carried
out. In fact, grave doubts have been raised regarding its security,
and (to my taste, anyway) not satisfactorily answered.
   I do not wish to raise those points here, nor do I wish to claim
here that POTP is insecure. However, I believe the reputation of your
product is drawn into question by association. Should POTP be
definitively demonstrated to be weak, then it would not be the case
that using your product according to the instructions would provide
"security." Further, I would consider it slightly misleading to
describe it as "mission-critical."
   I feel the situation is analogous to that of a hypothetical
networking company claiming that their product delivers high bandwidth
by offering the choice of ATM, Myrinet, 100Mbps Ethernet, or string
and tin cans.
   That said, I applaud your multiprotocol approach in general. In
fact, I feel it is the future of Internet security tools. I hope your
product gains widespread acceptance, and helps to further the cause of
deployment of strong crypto.
Raph Levien

@_date: 1996-01-08 03:09:59
@_author: Raph Levien 
@_subject: "Re: NSA says strong crypto to china?? 
The original article in the Indpendent contained too many factual
inaccuracies to take the NSA statement at face value. Further, some of
the details resemble an interchange between Carl Ellison and the
OSTP. For the details, check out:
      Here's the relevant excerpt:
Sell to Chinese dissidents
In the opening session, Mike Nelson of the OSTP (Office of Science and
Technology Policy on the vice president's staff) presented his
discussion of the Key Escrow criteria. He was asked who in his right
mind would buy a product with a master key escrowed in the U.S., with
access by US Law Enforcement.
His answer was that a Chinese dissident would be quite happy to have
the key escrowed by a US agent, in the US, for US government access --
rather than by a Chinese agent, in China, for Chinese government
That's a good plan, Mike. That's a huge market. I'm looking forward to
seeing the agreement with the People's Republic under which they allow
the importation of such products.
[end excerpt]
   My best guess is that we're seeing a distortion of this
interchange. If I were a Chinese dissident, I wouldn't want to use
GAK, for three reasons: using US-lackey encryption is certainly not
going to get you into any _less_ trouble than using independent
encryption, if you used GAK you'd be working as a US spy whether you
wanted to be or not, and finally, who says the Chinese can't decrypt
it, especially with the rapid growth of television.
P.S. To those who are suriprised that I'm still here - my flight got
delayed, and I'm waiting it out on the Net, in true geek style.

@_date: 1996-01-30 10:57:19
@_author: Raph Levien 
@_subject: Authentication of crypto clients 
This post contains (somewhat) technical discussion of (what I believe
is) an important issue in integrating crypto with applications that do
not contain their own cryptographic implementation. If that doesn't
interest you, hit 'n' to resume your regularly scheduled flamefest.
The issue is: how does the crypto provider authenticate the client?
For example, if the crypto provider can accpet connections from any
application in the user's process space, then any bogus application
can easily start decrypting and signing as it likes. In this model, a
precondition for security is that no bogus programs can be allowed to
An alternative, slightly more complex model is that the client must
somehow authenticate itself to the crypto provider. One simple way of
doing this is to require the client request a password from the user,
which is then forwarded to the crypto provider. The crypto provider
will only provide service on connections which have been authenticated
in this way. This model gives security even in the face of some bogus
Of course, as Nathaniel quietly reminded us this morning, any bogus
application which can intercept keystrokes can subvert any such client
authentication. Barry Jaspan (in his analysis of a security flaw in
SSH 1.2.0) reminds us that access to the image of the process is also
sufficient to break security. Perhaps the class of bogus programs
which have enough capabilities to connect to the crypto provider, but
not enough to intercept keystrokes or examine RAM is null, meaning
that the two models have equivalent security. Actually, the simpler
model has some security advantages, because the client never has to
deal with any very sensitive material, such as the password.
I'm interested in this question right now because the current version
of premail implements the simpler model (in fact, it simply stores all
the secrets in a file in /tmp, with permissions set to 600). I want to
know whether it's worth the trouble to design and implement an
approach based on per-client authentication.
This issue is also relevant to the discussion of Microsoft's CAPI,
which (as far as I can tell) allows only the simpler model. I'm not
saying it's bad, but I do feel that the implications should be
discussed. Thus, I have forwarded a copy of this post to
cryptapi at microsoft.com in case they have any comments.
If there's been a discussion of this that I missed, then apologies for
brining it up again and appreciation in advance for any pointers.

@_date: 1996-01-30 12:23:45
@_author: Raph Levien 
@_subject: Alleged-RC2 code posted to sci.crypt 
I'm surprised I haven't seen a mention of this here.
Path: agate!usenet.ins.cwru.edu!slider.bme.ri.ccf.org!kira.cc.uakron.edu!neoucom.edu!news.ysu.edu!news.ecn.uoknor.edu!news.eng.convex.com!hermes.oc.com!news.unt.edu!cs.utexas.edu!howland.reston.ans.net!news.nic.surfnet.nl!sun4nl!xs4all!utopia.hacktic.nl!not-for-mail
Newsgroups: sci.crypt
Organization: Hack-Tic International, Inc.
Lines: 182
Sender: remailer at utopia.hacktic.nl
NNTP-Posting-Host: utopia.hacktic.nl
Comments: Hack-Tic may or may not approve of the content of this posting
Comments: Please report misuse of this automated remailing service to
Comments: * To commemorate the 1996 RSA Data Security Conference, the following  *
* code is released into the public domain by its author.  Prost!       *
*                                                                      *
* This cipher uses 16-bit words and little-endian byte ordering.       *
* I wonder which processor it was optimized for?                       *
*                                                                      *
* Thanks to CodeView, SoftIce, and D86 for helping bring this code to  *
* the public.                                                          *
[potential trade secret and ITAR violation elided]
   So far, no confirmations, denials, or test vectors posted.
   If true, this removes my biggest objection to S/MIME (leaving all the nonbiggest objections in place, of course).

@_date: 1996-01-31 00:52:01
@_author: Raph Levien 
@_subject: Vladimir: put up or shut up 
Most of the recent cypherpunks traffic from Vladimir has been a reiteration of the position that discussing ITAR is bad because it discourages cypherpunks from releasing good crypto software.
Well, here's one cypherpunks who recently released some software, and
futhermore did so making significant (some might say extreme) concessions
to the ITAR rules. I made the software available only on an export-restricted Web server, and asked explicitly several times for it not to be exported. If my timezone math works out right, it took about half an hour for it to be available on utopia. The ITAR did _nothing_ to stop, or even slow down, the reease of my software.
Why is it, then, that we still don't have usable strong crypto tools?  I'd
say the reason is complex, much more so than could be explained by a
simple conspiracy theory or even too much discussion of ITAR. The main
reason is that it is very damned hard to write good crypto-enabled
applications.  Trust me, I know. I have done the best I could with the
software I released, but I'm still quite frustrated with its limitations,
especially with respect to nontechnical users. Ultimately, to create really good crypto-enabled applications, it's going to take money. And there's where ITAR is most effective. If the powers that be disapprove of your software, then there goes your foreign market. There go your government sales. There go those "strategic alliances" with the other companies in the market, because the pressure can be applied transitively too. ITAR is actually only a small part of the process.
Still, free software has a lot of vitality left in it. It's still strong at blazing new trails in software design. Where it's weak (and this is what really counts now), is being usable, easy to learn, and easy to install. I think if we explicitly work towards these goals, there's hope for great free crypto-enabled applications. Hell, PGP came pretty close, and it's saddled with all kinds of lousy design decisions.
But back to Vladimir: instead of whining at us about how our fear of the
law is hurting the acievement of our goals, why don't _you_ write that
killer crypto-app and distribute it to the world? Who's stopping you?

@_date: 1996-07-05 12:51:07
@_author: Raph Levien 
@_subject: Announcing the release of premail 0.44 
The long awaited release of premail 0.44 is now available. This
release integrates PGP and anonymous e-mail functions into Unix
versions of Netscape 3.0's built-in mailer. It also does a pretty good
job with Pine 3.94 (transparent integration of plain PGP mail,
decoding of MIME protected mail requires a single command).
   For those of you interested in experimenting with S/MIME, it
contains some S/MIME functions, but does not yet fully comply with the
   The main premail Web page is:
          The premail documentation is at:
          I appreciate any bug reports, suggestions, or comments.
