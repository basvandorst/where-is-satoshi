
@_date: 2013-08-16 19:55:56
@_author: Tony Arcieri 
@_subject: Re: [cryptography] urandom vs random 
On Fri, Aug 16, 2013 at 12:49 PM, Patrick Mylund Nielsen <
I was quoting the title of the paper in the context of a thread in which
someone claimed that /dev/random should be used in lieu of /dev/random.
That's all I was pointing out.

@_date: 2013-08-16 19:30:56
@_author: Tony Arcieri 
@_subject: Re: [cryptography] urandom vs random 
On Fri, Aug 16, 2013 at 9:18 AM, Patrick Mylund Nielsen <
I'm not sure if you feel the same way, but the  opinion of many uneducated
observers[1] seems to be that using a PRNG at all in these contexts is
"insecure" when that is absolutely not the case, and for the most part
there isn't a meaningful difference between the security of random vs
urandom except that random will run out of entropy.
The "urandom is insecure" claims are specifically what I was trying to
challenge, and I hope this paper helps drive it home. If "urandom is
insecure" it isn't more so than /dev/random

@_date: 2013-08-16 15:42:47
@_author: Tony Arcieri 
@_subject: Re: [cryptography] urandom vs random 
This presumes that urandom is somehow more "insecure", which is not the
case despite the ancient scare-language in the manpage. The security of all
stream ciphers rests in secure CSPRNGs. Meanwhile, /dev/random is not

@_date: 2013-08-26 17:44:33
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Implementations, attacks on DHTs, Mix Nets? 
Check out this paper: Security Considerations for Peer-to-Peer Distributed
Hash Tables

@_date: 2013-09-06 20:21:21
@_author: Tony Arcieri 
@_subject: Re: [cryptography] regarding the NSA crypto "breakthrough" 
There are curves not selected by e.g. NIST with a published rationale for
their selection, like Curve25519. Is there any reason why such curves can't
be evaluated retroactively?
See in particular Theorem 2.1.

@_date: 2013-09-25 20:36:47
@_author: Tony Arcieri 
@_subject: Re: [cryptography] The Compromised Internet 
What threat are you trying to prevent that isn't already solved by the use
of cryptography alone?

@_date: 2013-09-25 20:36:47
@_author: Tony Arcieri 
@_subject: Re: [cryptography] The Compromised Internet 
What threat are you trying to prevent that isn't already solved by the use
of cryptography alone?

@_date: 2013-09-15 04:17:31
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Why prefer symmetric crypto over public key crypto? 
Why? We already have NTRU. We also have Lamport Signatures. djb is working
on McBits. I'd say there's already many options on the table if you want to
build a "quantum-proof" system.

@_date: 2013-09-07 22:40:08
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Why prefer symmetric crypto over public key crypto? 
Lattice-based (NTRU) or code-based (McEliece/McBits) public key systems are
still considered "post-quantum" algorithms. There are no presently known
quantum algorithms that work against these sorts of systems.
See

@_date: 2013-09-07 20:06:14
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Why prefer symmetric crypto over public key crypto? 
As soon as someone builds a large quantum computer (probably at least 10
years away, even for the NSA) most of the public key cryptosystems we use
today will be easily breakable with e.g. Shor's algorithm. Symmetric
algorithms will take a hit as well, with their keyspace cut in half, but
that's the equivalent of going from 256-bit keys to 255-bit keys, so
symmetric crypto will weather the post-quantum era just fine.
In order to beat quantum computers, we need to use public key systems with
no (known) quantum attacks, such as lattice-based (NTRU) or code-based
(McEliece/McBits) algorithms. ECC and RSA will no longer be useful.
Tony Arcieri

@_date: 2014-07-02 00:31:30
@_author: Tony Arcieri 
@_subject: Re: [cryptography] Stealthy Dopant-Level Hardware Trojans 
This went to the cypherpunks list, but not to the others:
Reversing stealthy dopant level trojans!

@_date: 2014-07-02 00:31:30
@_author: Tony Arcieri 
@_subject: Re: [cryptography] Stealthy Dopant-Level Hardware Trojans 
This went to the cypherpunks list, but not to the others:
Reversing stealthy dopant level trojans!

@_date: 2014-07-19 21:37:28
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] hard to trust all those root CAs 
If only X.509 name constraints actually worked.
Perhaps if the implementations could get fixed / finished, it would be
possible to get the browser vendors to agree to put them in place for
select new TLDs.

@_date: 2014-09-27 02:05:10
@_author: Tony Arcieri 
@_subject: Informing the user they have the wrong key 
If we build fancy systems to detect things like misadvertised keys or MitM
attacks, how can we reasonably inform an end user what is amiss in an
actionable way that won't confuse them with too many false positives to
avoid taking action when something bad actually happens?
I recently went to SOUPS and saw a number of presentations on the general
difficulty of communicating security-actionable information to users. From
what I saw I'd say the problem is twofold:
1) How does the system provide a high confidence level that when it tries
to communicate a security-actionable event, it's fairly certain it's not a
false positive? False positives condition users to ignore security warnings
2) How do you express what's happening to the user in such a way that they
will actually take action on it and not just click-through dismiss it?
Given the wide-ranging number of scenarios, the answer will of course be
contextual, and I'd be curious to hear any replies about how systems try to
solve the "right key" user experience problem in general.
That said, the messaging use-case (in conjunction with a "key directory"
system) is particularly interesting to me.
If an end-to-end encrypted messaging system which relies on a
centrally-managed key directory (e.g. iMessage) were to by coersion or
compromise publish a poison key to their directory to facilitate a MitM
attack, but the system creators wanted to make such action obvious to their
users, how can the systems reasonably detect and reflect this in such a way
that such users aren't conditioned to ignore such alerts for routine events
(e.g. the SSH "SOMETHING NASTY" message) and actually feel compelled to
take action on that knowledge?
And then what? How can we help someone who is a victim of an attack like
this actually compile all of the necessary information for someone to
figure out what actually happened? How can encryption tools compile
incident reports that experts can scrutinize to determine what happened?

@_date: 2014-10-01 23:28:15
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Best Internet crypto clock ? 
You could take a hash of some content, use that hash as a Bitcoin private
key, and send the associated public key 1 Satoshi. You could then prove you
calculated that hash at a given time by looking up the associated public
key in the block chain.
Here's something that does just that:

@_date: 2014-12-07 08:37:19
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Toxic Combination 
On Sat, Dec 6, 2014 at 7:14 PM, Peter Gutmann Why not get rid of the password part while we're at it? Passwords suck

@_date: 2014-12-04 17:28:22
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Toxic Combination 
There's nothing new in your system, and a lot of orthogonal concerns which
are unrelated and complicate the discussion.
ad a) the user agent (yes: browser) manages the cryptographic operations
This is how the web works today.
ad b) the site operator has a few extra steps to take:
Having each site run an intermediary server CA accomplishes nothing if you
decide to trust it using DNSSEC/DANE.
You want to preserve privacy, but you recommend DNSSEC and DANE over X.509?
DNSSEC is not encrypted, it only provides authentication, so you're already
worse off from a privacy perspective.
DNSSEC keys are held by governments, so you can't prevent a government
holding a key higher up the hierarchy from impersonating you (e.g. if you
have a *.com domain, the NSA probably has a way to MitM it)
DNSSEC has no solution to these problems on the horizon: where a lot of
effort has gone into building an X.509 transparency system (Certificate
Transparency), no work (to my knowledge) has gone into building one for
Don't get me wrong, there are aspects of DNSSEC I like, but it doesn't
solve any of the problems you described and is in fact arguably worse at
all of them given your requirements.
Furthermore, all of this is orthogonal to user authentication: you've
muddled up the problems of authenticating the user and authenticating the
 - sign client certificates;
This can be done today using the HTML  tag to generate a client
certificate. A CSR is sent to the server, which can sign it under its own
client CA, and send the signed certificate back to your browser for
Unfortunately, there's one problem: the user experience! All of the
technical problems are solved, but it's still a terribly confusing process
for users.
Everything you've described can be built and deployed today without any
changes to (most) browsers. But the user experience is so bad and confusing
that nobody will use it:
- Different browsers have different trust stores
- Users have to pick which certificate to use to authenticate
- Users have to copy certificates from browser-to-browser or
- Users need to back up certificates so they don't lose them
- Users need some way to recover their account if they do lose the
Fixing the user experience problem is where systems like FIDO alliance
U2F/UAF come in:
- Hardware tokens generate and statelessly manage user credentials
- Credentials follow the same-origin policy and are thus privacy-preserving
(unique credential per origin)
- Support for U2F hardware tokens shipped in the latest releases of Chrome
and will be present in Windows 10

@_date: 2015-11-10 07:43:30
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Cryptogit 
On Mon, Nov 9, 2015 at 8:53 PM, Phillip Hallam-Baker There are many, many systems that aspire to this sort of thing. Some are
already git compatible. Others (that have more notable cryptographic
designs) can model git-like concepts, but are not yet git compatible (but
perhaps should be). Not naming names yet as I'm not a big fan of any of
these systems (at least in the git-compatible department), but they're
certainly out there and you can find them with a bit of Googling.
I can assure you it's a difficult problem, especially if you want both 1)
robust, modern cryptography and 2) a system that's backwards compatible
with git
For starters, git's Merkelized DAG is based on SHA1 with no futureproofing
built into the protocol. To safely encrypt and authenticate it would
require a complete wrapper based on modern primitives.
There are some safety features around collisions built into git, but they
require collisions be spotted in the wild, when an attacker might e.g. be
trying to get code A through an approval workflow, only to swap out
approved code A prior to malicious code B prior to merging, and workflow
systems built around git might try to correlate everything based around
commit SHA1s.

@_date: 2015-11-17 18:19:25
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Sadly predictable: Terrorism used as excuse to attack encryption 
On Tue, Nov 17, 2015 at 8:12 AM, Perry E. Metzger The New York Times apparently posted a similar article earlier, then
silently retracted it:
That said, for all the talk of crypto being a terrorist tool, allegedly
(Daily Mail, quoting Fox News, take it with a grain of salt...) ISIS social
media accounts were already posting pictures of the Eiffel Tower along with
"God bless you on your mission" 72 hours before the attack:
It would be rather ironic if ISIS committed an opsec failure that bad which
intelligence services weren't able to pick up on, and yet encryption is
blamed anyway.

@_date: 2016-05-07 05:25:25
@_author: Tony Arcieri 
@_subject: Re: [Cryptography] Proof-of-Satoshi fails Proof-of-Proof. 
Interesting sidebar: ECDSA nonces were one of the sources of Bitcoin's
transaction malleability. The (massive pile of hacks that is) segregated
witness feature being added to Bitcoin has an added side effect of removing
signatures from the hash of a transaction, and with it the associated
All that said, if you're designing a new system today, pick Ed25519.
