
@_date: 2011-12-20 19:06:19
@_author: Nick Mathewson 
@_subject: Re: [tor-talk] Automatic vulnerability scanning of Tor Network? 
When I read Lee's above paragraph, I worry Lee might have gotten the
idea that Fabio is speaking for Tor in some official capacity.  So:
Please be aware that Fabio is speaking for himself, and does not speak
on behalf of the Tor Project.
For my own part, I am perfectly fine with the idea of working *with*
server operators to help them secure their systems, and with making
sure that only secure systems are on the network.  But efforts in this
area need to work with the foreknowledge and consent of node
operators, and not alienate our volunteer community.  Also, the
appropriate response to horribly insecure servers on the network would
be to inform the operators and de-list the servers if they didn't get
fixed--not to publicly post them but leave them on the network.  That
would be the worst of all worlds.
tor-talk mailing list

@_date: 2013-09-07 17:02:04
@_author: Nick Mathewson 
@_subject: Re: [tor-talk] NIST approved crypto in Tor? 
The TLS ECDH groups P-256 and P-224 are NIST-certified.  For circuit
extension, we use Dan Bernstein's non-NIST-certified curve25519 group.
NIST has certified tons of stuff, including AES and SHA1 and SHA256
and SHA3.  If you're jumping ship from NIST, you need to jump ship
from those as well.
Of all the NIST stuff above, my suspicion is not that they are
cryptographically broken, but that they are deliberately hard to
implement correctly: see
  * (on the P groups)
  *  (on AES)
Also, we're not using DSA, but DSA (as recommended by NIST) fits into
this pattern: DSA (as recommended by NIST) requires a strong random
number generator to be used when signing, and fails terribly in a way
that exposes the private key if the random number generator is the
least bit week or predictable. (see
To me, this suggests a trend of certifying strong cryptographic
algorithms while at the same time ensuring that most implementations
will be of poor quality.  That's just speculation, though.
(And I'm probably falling to the fallacy where you assume that
whatever results somebody gets are the ones they wanted.)
Of course, the "deliberately" in "deliberately hard to implement
correctly" is almost impossible to prove.  Is it nearly impossible to
write a fast side-channel-free AES implemenation in C because because
of a nefarious conspiracy, or simply because cryptographers in 2000
didn't appreciate how multiplication in GF(2^8) wasn't as
software-friendly a primitive?  (Looking at the other AES finalists, I
see a bunch of other hard-to-do-right-in-fast-software stuff like
GF(2^8) multiplication and table-based s-boxes.)   Are the ECC P
groups shaped that way for nefarious reasons, or simply because the
standards committee didn't have an adequate appreciation of the
software issues?
And it's not like NIST standards are the only ones that have problems.
 TLS is an IETF standard, but TLS implementations today have three
basic kinds of ciphersuirte: a fraught-with-peril CBC-based
pad-MAC-then-encrypt kind where somebody finds a new active attack
every year or so; a stream-cipher-based kind where the only supported
stream cipher is the ridiculously bad RC4, and an authenticated
encryption kind where the the AEAD mode uses GCM, which is also hard
to do in a side-channel-free way in software.
Conspiracy, or saboteurs in the (international) TLS working group, or
international bureaucratic intertia? Who can say?
And let's not mention X.509.  Let's just not, okay?  X.509 is
byzantine in a way that would make any reasonable implementor's head
spin, *and* the X.509 CA infrastructure is without a doubt one of the
very worst things in web security today.  And it's an international
Yes; see above.  Also, there were once NIST recommendations for using
TLS; I have no idea whether we're following them or not.  (There are
NIST recommendations for nearly )
I'm not sure that there *are* international-standards recommendations
for ECC groups or for ciphers that diverge from NIST's.  The IETF is
an international body, after all, and TLS standards have been happily
recommending SHA1, SHA256, AES, DSA, and the P groups for ages.  (See
also notes above about the not-much-betterness of international
With any luck, smart cryptographers will start to push non-NIST curves
and ciphers into prominence.  I've got some hopes for the EU here;
ECRYPT and ECRYPT II produced some exceptionally worthwhile results; I
hope that whoever makes funding decisions funds a nice targeted ECRYPT
III some time.
As I said on another mail, I've got a mind to move a lot of our crypto
for other reasons, as well.
The elephant in the room here is TLS itself.  Frankly, I'm starting to
think we should cut the Gordian Knot here and start a little
independent protocol group of our own if the TLS working group can't
get its act together and have one really good ciphersuite some time
Yeah, I know how it is.  I'm seeing conspiracies under every protocol
and in every patch these days.  Gotta stay focused, write the best
protocols and designs and software I can, and maintain.
(And with that in mind I should really start on my weekend soon.)

@_date: 2014-04-18 17:48:46
@_author: Nick Mathewson 
@_subject: Re: [tor-talk] Programming language for anonymity network 
[Replying to Stevens and tor-talk only. Crossposting runs against my
religious beliefs.]
Also consider
  5) Amenability to side-channel-free programming.  It is
next-to-impossible to write cryptographic code in some programming
languages without introducing timing side channels.
  6) Availability of, or access to, high-quality cryptographic and
networking backends.  You don't want to be doing your own from
  7) Runtime quality on target platforms.  If you want to deliver
packages to windows users, your options are more constrained than they
might be than if you only need to support Linux.  If you need to run
on smartphones, that's also a factor to consider.
  8) Testing strategies. Some languages and environments make it
easier to isolate components for testing than others do.
Personally, if I were starting over, I'd look into a multi-languge
approach: a memory-safe compiled language for most of the programming,
with cryptographic and lowest-level networking code in C, and a
scripting language for higher level tasks and for component testing.
I'd probably use a multi-process architecture rather than trying to
cram everything into one address space.  I'd use a terse performant
functional language for testing cryptographic components for
(As a charming coincidence, this _is_ the architecture that I'd like
to migrate Tor to, resources permitting.)
Also, as I'm sure you're finding out, language choice is a classic
"bikeshed problem" (see  you will get more
advice from more people about your choice of language than you will
about any other question you might ask, with the possible exception of
which license to use.
Best of luck and wishes for your anonymity network!

@_date: 2014-10-31 13:03:52
@_author: Nick Mathewson 
@_subject: Re: [tor-talk] Facebook brute forcing hidden services 
Also, if you're feeling technical, you might want to jump in on
reviewing and improving proposal 224 [prop224] , which include a brand
new, even less usable, but far more secure, name format. :)
[prop224]
