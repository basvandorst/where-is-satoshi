
@_date: 2009-11-17 04:39:09
@_author: Sandy Harris 
@_subject: Re: hedging our bets -- in case SHA-256 turns out to be insecure 
I was suggesting using the authentication data in the construction:
 C(x) = H1(H2(x)||A(x))
where H1 is a hash with he required output size, H2 a hash with
a large block size and A the authentication data from your
This is likely a very bad idea if you already use that data in some
other way, e.g. for authenticating stored data. However, if C is
going to be your authentication mechanism, then this might be
a cheap way to get one input to it.

@_date: 2009-11-11 02:03:45
@_author: Sandy Harris 
@_subject: Re: hedging our bets -- in case SHA-256 turns out to be insecure 
NIST are dealing with that via the AHS process. Shouldn't you just use
their results?
Yes, but there's also a risk that whatever you come up with will turn
out to be flawed.
This requires two hash(x) operations. A naive implementation needs
two passes through the data and avoiding that does not appear to
be trivial. This is not ideal since you seem very concerned about
What about this construction:
  C(x) = H1(H2(x) || H3(x))
H1 is something that gives the output size you require. Use SHA-256 or
choose an AHS candidate conservatively. This only hashes a few blocks
so you need not worry much about overheads here.
H2 is the 512-bit variant of a different AHS candidate, or Whirlpool, or
even Skein-1024. Here speed is a criterion, though of course not the
only one.
H3 might be some really cheap fast function invented for the situation.
As I recall, the GOST hash just used a sum of input blocks, and that's
enough to defeat the multi-block attacks. If it is simple enough, you
can code it into your implementation of H2 so you only need one
Since you are encrypting the files anyway, I wonder if you could
use one of the modes developed for IPsec where a single pass
with a block cipher gives both encrypted text and a hash-like
authentication output.  That gives you a "free" value to use as
H3 in my scheme or H2 in yours, and its security depends on
the block cipher, not on any hash.

@_date: 2010-07-25 00:34:45
@_author: Sandy Harris 
@_subject: Re: Intel to also add RNG 
Yes. A hardware RNG seems an obvious Good Thing. Not
a complete solution, but a very useful component.
IPsec gateways and web servers doing a lot of SSL are obvious
cases. Neither has much mouse or keyboard activity, they may
have solid state drives or smart RAID so disk timings are not
random. Packet timings might be somewhat random, but they
may also be knowable by an enemy.
In some cases, a non-kludge alternative is Turbid:
That uses a sound card or on-board equivalent. Some boards
will have this, or it is cheap & easy to stick in a slot.

@_date: 2013-07-30 23:57:52
@_author: Sandy Harris 
@_subject: Re: Getting started 
One reference is:
Wikipedia, largely copied from the above:
Links in those articles will give you more.

@_date: 2013-07-23 15:22:00
@_author: Sandy Harris 
@_subject: Re: Python Random Number Generator for OTP 
If you want to use a sound card as an entropy source,
look at turbid, a solid design with well-documented
analysis of its randomness:
For a timing-based source, look at haveged
which is in Debian:
but consider this critique:
For a cheap simple RNG that needs more
analysis before it is seriously trusted, see
my timing-based demon:
Documentation there discusses several

@_date: 2013-08-28 10:01:35
@_author: Sandy Harris 
@_subject: Re: Metadata anonymization through time delayed email messaging. 
if you control the end-user sending machine & it runs some sort of Unix,
this is trivial; the required command is just:
at 04:00 mail whoever < message_file
Writing a script to do this using a random time would not be hard.
Of course this does not encrypt the file, though it could send a file
that was already encrypted. Nor does it provide any sort of
protection against someone who can snoop on the sending
machine (nothing I know of does!), so it does not work in your
Internet cafe example.
Better to modify the mail server to introduce a random delay.
This also does not look hard. Avoiding time stamps in the
Received: lines in the headers would also be necessary,
but that looks straightforward as well.
To block tracking, you also want to avoid putting the client
machine's IP address in the headers. Easily done, but it
makes it harder to deal with spammers.

@_date: 2013-08-21 22:28:57
@_author: Sandy Harris 
@_subject: Re: [cryptography] urandom vs random 
Two good ones are listed & linked here
My system is running Xubuntu. Randomness testers that are in its
repositories, and presumably quite a few others, are ent(1) and
See other posts in the thread for limitations of such testing.
cryptography mailing list

@_date: 2013-08-19 15:50:52
@_author: Sandy Harris 
@_subject: Re: [cryptography] urandom vs random 
Yes, & there is software to turn a sound device into one:
A sound device is available on many server boards and often
unused, or you can add one in a slot or USB on others,
cryptography mailing list

@_date: 2013-08-17 16:48:12
@_author: Sandy Harris 
@_subject: Re: [cryptography] urandom vs random 
No, it doesn't, or at least did not last time I looked at the code, a few
months ago. There are similaities, but also large differences.
My program to deal with this (which needs more analysis before it
should be entirely trusted) and a paper which discusses it and
several alternatives are at:
cryptography mailing list

@_date: 2013-08-17 16:39:30
@_author: Sandy Harris 
@_subject: [cryptography]  urandom vs random 
(Talking about Linux, the only system where I know the details)
urandom uses cryptographically strong mixing (SHA-1) and has
enormous state, so it should be secure barring pathological
cases like the router vendors whose version of Linux failed to
initialise things properly or an enemy who already has root on
your system so he/she can look at kernel internals. (and that
enemy has much better targets to go after).
Papers like Yarrow with respected authors argue convincingly
that systems with far smaller state can be secure.
That would make no sense since the interface provides another
way to get the effect. If you really need guaranteed entropy,
for example to generate a long-term key, then use /dev/random.
The driver then checks the entropy and blocks (makes your
program wait) if there is not enough.
cryptography mailing list

@_date: 2013-09-07 11:04:39
@_author: Sandy Harris 
@_subject: Re: [cryptography] Compositing Ciphers? 
I did a paper on that sort of thing a while back:
A much improved version is in the works, but not done.
cryptography mailing list

@_date: 2013-10-16 12:49:53
@_author: Sandy Harris 
@_subject: Re: [Cryptography] /dev/random is not robust 
Yes. it is not at all clear that their analysis actually matters:
From the paper:
" Several security notions have been defined:
" =96 Resilience: an adversary must not be able to predict future PRNG
outputs even if he can influence the entropy source used to initialize
or refresh the internal state of the PRNG;
" =96 Forward security ( resp. backward security): an adversary must not
be able to predict past (resp. future) outputs even if he can
compromise the internal state of the PRNG.
" ... Barak and Halevi [BH05] model a PRNG with input ... and define a
new security property called robustness that implies resilience,
forward and backward security. This property actually assesses the
behavior of a PRNG after compromise of its internal state ...
None of this matters much if the enemy does not already have root on
your system. If an enemy does have root, he has far better targets
than the RNG available and the defenders have bigger worries. Without
root, he cannot see the internal state and, if you use the typical
setup where some saved entropy from last time is pumped in by the boot
scripts, he cannot read that file and using it seems to complicate the
state enough for security. It would take a completely different
analysis including a very clever new attack to show a problem there,
and this paper does not even attempt that. Moreover, having looked at
the driver internals, I do not think it is even possible.
Also, the definition of resilience mentions an adversary who "can
influence the entropy source" but the random(4) driver uses multiple
sources so the degree of influence is generally limited. There are
cases where this is a serious concern -- for example a router does not
have keyboard, mouse or hard disk, some skip the initialisation from a
file and an enemy can monitor or even control network inputs. However,
those are fixable; just using a file of saved entropy goes a long way
toward solving the problem.
There are a number of good ways to get additional entropy sources. My
attempt at writing one and a paper that comments on several others are
Another along similar lines but not mentioned in that paper is:
The cryptography mailing list

@_date: 2013-10-21 22:50:54
@_author: Sandy Harris 
@_subject: Re: [Cryptography] [RNG] on RNGs, VM state, rollback, etc. 
There are at least half a dozen programs about that some
claim might replace random(4) or be used as an extra
source of entropy for it. I have written one, and the PDF
file on its page discusses several others, including
If it is avoidable, I would not want to trust any of
those (or anything else, really) as a sole source
of entropy, even though as far as I can tell Turbid
is close to ideal and the others seem plausible.
As I see it, the only way to be confident in the
face of risks like the NSA fiddling with RdRand
or Turbid being messed up by a hardware
failure or virtualisation is to use multiple
sources and have something pretty much
like the random device to cache, buffer and
mix those inputs.
The cryptography mailing list

@_date: 2013-10-19 16:55:29
@_author: Sandy Harris 
@_subject: Re: [Cryptography] [RNG] on RNGs, VM state, rollback, etc. 
I don't think anyone imagines that those provide an adequate
seed or more than a few bits of entropy at most. However,
they do have useful effects.
Mixing in the MAC addresses ensures that when a bunch
of routers all have the same ROM image or a bunch of
machines all get the same install from CD or USB, then
at least to some extent, they all behave differently. John's
fix for the CD/USB problem is far better, but it is not
certain to always be applied & won't work for masked
ROMs, so this is still worth doing.
Mixing in the clock makes a machine behave a bit
differently each time it is rebooted.  Again, there
are better fixes such as mixing in a saved file, but
again this is still worth doing.
These are reasonably cheap and done only once
at boot time. They can do no harm and are useful
in at least some cases, so worth doing.
The cryptography mailing list

@_date: 2013-10-19 14:17:04
@_author: Sandy Harris 
@_subject: Re: [Cryptography] [RNG] on RNGs, VM state, rollback, etc. 
Yes. I think urandom must block initially, though not at any other time.
There is a function add_device_randomness() with this
introductory comment.
 * Add device- or boot-specific data to the input and nonblocking
 * pools to help initialize them to unique values.
 *
 * None of this adds any entropy, it is meant to avoid the
 * problem of the nonblocking pool having similar initial state
 * across largely identical devices.
 */
I have not looked in detail; at first glance I suspect this
function could & should do more. But it is there.
The cryptography mailing list

@_date: 2013-10-31 17:44:03
@_author: Sandy Harris 
@_subject: Re: [Cryptography] [RNG] /dev/random initialisation 
Yes, but the authentication is only that it must come from a process
that is running as root. There are a lot of candidates. Four people
I know of on the list (Peter Gutmann, John Denker, Stephan Mueller
and me) have written something that could be used, and I think
there are at least another half dozen available. Then there are
various ones built into CPUs or chipsets.
Quite likely not all of those are as solid as their authors hope, and
even the ones that sometimes are might fail in other situations.
The cryptography mailing list

@_date: 2013-10-28 20:38:45
@_author: Sandy Harris 
@_subject: Re: [Cryptography] [RNG] /dev/random initialisation 
We all agree here, at least for /dev/urandom
My understanding, though is that /dev/random uses a different
model requiring a one-to-one relation between (estimated) input
entropy and output size. This makes it safe even if the crypto
used is flawed. That is clearly a desirable property. Whether it
is essential seems debatable, but this is not the place for that
In the worst case the attacker has subverted a network switch or router
so he or she knows all packet timings down to the resolution of that
device's clock. There might still be some tiny amount of entropy in
that case due to things on your machine like cache & TLB misses or
having to wait for a lock and lack of sync between your clock and
the attacker's, but basically, you are screwed.
We may also need to distinguish between an attacker who can get
root privilege on the running machine (with any sane configuration
non-root access will not pose a threat) and one who steals or seizes
the machine later.
Using an encrypted file system blocks seizure attacks, but that is
inconvenient in many situations and in some jurisdictions there
may be heavy pressure to give up the password.
As I see it, the current recommended Linux system of saving 4K bits of
new installs that have no history to get the file from.
This should be clear; PFS is a design requirement here. Given the
machine including the saved file, it should be impossible to infer
previous state. Since all output goes through SHA-1 which is
generally thought to have pre-image resistance, it seems clear
enough to me.
How about pushing /etc//shadow into /dev/random? Except for a
fully automated install that gives exactly the same accounts and
passwords on every device, that is bound to have some variation
that is unknown outside.
The cryptography mailing list

@_date: 2013-10-28 16:35:29
@_author: Sandy Harris 
@_subject: Re: [Cryptography] [RNG] /dev/random initialisation 
Only an attacker who can log into the system. That blocks
most remote attackers, and something like a router (the
sort of system where this is most likely to be an issue)
should have tightly restricted logins.
Sure, and I definitely am not saying either that this sort of
thing should be given entropy credit or that you don't need
better sources as well. My only question is whether this is
useful as a worst case fallback measure.
Yes, and uname -a includes a timestamp.
This looks to be a real problem, or at least a restriction on
which things can be used there. Perhaps Ted can comment?
User space programs can inject data at any time, but it may
come too late if the driver produces output early and it may
be quite unnecessary once other entropy sources have made
some contributions. The stuff I suggest above is certainly
possible, but it may not actually be useful, let alone needed.
The cryptography mailing list

@_date: 2013-10-24 21:42:55
@_author: Sandy Harris 
@_subject: [Cryptography] [RNG] /dev/random initialisation 
There can be problems with inadequate initialisation of the Linux
random(4) driver, as demonstrated by the research that found many RSA
keys using duplicate primes and attributed their creation mainly to
badly configured routers. As several people have pointed out,
discussion of crypto without a threat model tends to be pointless.
This is an attempt to provide an explicit model for those threats.
This deals only with threats from weak initialisation; I do not
discuss general entropy gathering and estimation or the new threats
that may arise with virtualisation.
If Linux is configured in the usual way, there is a file of saved
random data that is pushed into /dev/random by boot scripts. On some
systems there is a high-volume entropy source -- RdRand
( Denker's Turbid
( Havege
( my maxwell
(ftp://ftp.cs.sjtu.edu.cn:990/sandy/maxwell/), Mueller's jitter-based
generator ( ...
In those cases, provided that the file or source is secure, the
initialisation question is simple; all we need to determine is whether
urandom should block until the system gets enough entropy to put it
into a secure state. I think it should, but that is not the question
What I want to model here is the harder case where none of the above
is in place or urandom starts producing output without waiting for
them. In an ideal world, this case would never arise but in the real
world it has and likely will again. The problem involves avoiding
duplicate outputs, so the birthday paradox works against us. If we
need a low risk of collision for 2^n cases, then we need about 2n bits
of input entropy.
There are two separate cases to consider: avoiding duplicate outputs
when a single device is rebooted many times and avoiding it when many
identical devices are deployed.
Multiple reboots of the same device are the easy case. One threat
involves a computer that is rebooted often (perhaps several times a
day) and whose outputs are monitored continuously over a fairly long
period (perhaps a year). Another involves an enemy that can force many
reboots of a network device without the administrators noticing and
blocking the attack. Neither threat looks at all likely to involve
more than a few thousand reboots, so a dozen or so bits of timing
information per reboot should be enough to block them.
Timing data appears to be the only thing we can use against this
threat; more-or-less everything else is constant across reboots. Linux
random already mixes in some timing information, but I am not certain
how much.
Many identical devices are a harder case. A manufacturer might produce
tens or hundreds of thousands of the same device and a Linux distro
might send out some huge number of installation images; allowing for
the birthday effect, we then need a fairly large amount of entropy.
For example, if there are 64K (2^16) devices, we need at least 32 bits
to make duplication unlikely. Something like 48 bits would probably be
enough for all cases that seem at all likely, though of course if we
can get more good bits, we should.
More-or-less anything that is unique per system will help here. System
serial number if there is one accessible, MAC addresses, IP addresses,
Just including a file of stored entropy does not solve this problem if
that file is the same on all devices or in all images. There is
available code to add different files to CD/USB images:
However, it is not clear that this could be applied at reasonable cost
in manufacturing and in the case of downloadable images using this
would make every image unique which would complicate the use of hashes
to verify the downloads. For large numbers of images it might also
involve significant loads on the server.
Also, keeping a stored entropy file secure is much harder if it is
burned into a CD or flash image and can be attacked anywhere in the
distribution chain than for a file that changes on every boot and can
be attacked only with root privileges on the target system. Using
different files looks like a fine solution in some cases -- for
example if you are creating USB keys to set up a few dozen servers
within an organisation -- but it cannot help with all cases.
There are two ways one might get suitable material into the driver
state. One can build it into the kernel's device initialisation code
or do it externally with a script along the lines of:
    ifconfig > /dev/random
    netstat > /dev/random
    uname -a > /dev/random
    ....
Gutmann has written a full RNG along these lines as part of Cryptlib:
That works just fine on a reasonably complex multi-user multi-process
system, but it is not clear that it would be adequate on a very
limited system such as a router which might have no users and small
non-varying sets of devices and processes.
However, if all we need is a few bits to help initialise the random
device, then something like the script above may fit. We do not need
any mixing since the driver does that. Nor do we need the full range
of entropy sources that Gutmann's code uses, or its careful error
checking. No doubt my first-guess code above could be improved by
taking ideas from Gutmann, but we do not need his whole system.
In general, building such operations into the device initialisation
code in the kernel is preferable to leaving it to an external script.
The environment is better known; there is no chance of writing a
script that relies on some program the target system turns out not to
have. Also, there is less chance of user error; the system
administrator cannot just disable the script in search of efficiency
or to get rid of an annoying error message.
There may be an exception. The random driver is generally initialised
early in the boot sequence so that it is ready before other programs
need it; that is best done within the driver. On the other hand,
initialisation based on overall system state may be best done later,
after everything else has been set up. Recognising that situation may
be hard to do from within the kernel, but it is trivial in the init
scripts; making a script along the lines above the very last thing the
init scripts do is straightforward. It is not clear that this would be
useful, but it is easily done if it is.
It looks as though getting 64 bits or more is possible. One of the
FreeBSD guys wrote on the other crypto list:
" We also added entropy based on device attach times. Measurements show this
gives at least 4 bits of entropy per device (usually a lot more), and in
the worst case we saw, 32 devices were measured.
Ted is aware of this and says looking at something similar for Linux
is on his ToDo list. If something along those lines can be built and
the claim of four bits per device (or even two) is correct for Linux,
it appears that it would solve the problem.
If not, there may be other options. Any volatile kernel table --
processes, open files, devices ... -- might provide some entropy and
it would be possible to instrument some system processes (init?) or
system calls so they did as well.
The cryptography mailing list

@_date: 2013-10-08 00:39:14
@_author: Sandy Harris 
@_subject: Re: HTML'ed mail 
It is the sender's job. No-one should be sending such stuff
to a public list since it serves no useful purpose. If your
client won't send clean ASCII-only email, then switch to
a client that will.
If senders do not do that, there are four options: flame
them to a crisp (off-list, please!), let every reader handle
it, remove the HTML at the server, or set the server to
drop such messages entirely. I'd prefer the last, with
an appropriate bounce message,

@_date: 2013-10-23 13:01:18
@_author: Sandy Harris 
@_subject: Re: Curious RNG stalemate [was: use of cpunks] 
There is configuration info for some common sound devices.
Only people with a device for which a configuration file does
not already exist. If you have to do this, you can send your
file to the Turbid maintainer so others can use it without
having to do the measurements themselves.
Of course, then there is a trust issue. The maintainer may
not have the device in question, so he cannot verify. If
you want to verify, you are back to building a cable.
Without verification, it looks as though someone could
subvert Turbid for a device by submitting a suitably
bogus parameter file.
I'd also like to see a default parameter file, guaranteed
to give some entropy on a lowest common denominator
device. I'm not sure if that is possible.

@_date: 2013-10-18 15:42:21
@_author: Sandy Harris 
@_subject: Re: Curious RNG stalemate [was: use of cpunks] 
If you have an audio device free or can add one and are using
Linux, I'd say Turbid is the obvious solution:
Open source, available for over a decade, well thought out
and well documented. It even has a proof, using only some
quite mild assumptions, that it gives almost perfect entropy
in the output. What's not to like?
If you are on Linux, getting Turbid into your distro might
well be the most important RNG work you could do. For
If you are concerned with other systems, it might well
be worth considering whether Turbid could be ported.
It appears better than anything else I have seen
because it is the only one with a proof of randomness,
and as far as I can tell the proof is solid.

@_date: 2013-11-07 18:07:52
@_author: Sandy Harris 
@_subject: Re: [Cryptography] randomness +- entropy 
As John says, the right solution in that case is almost certainly to
boot from USB instead so you can have some writable storage than can
hold a seed file between reboots. In other situations -- a Linux
smartphone or an embedded system with severe limitations -- none of
the known-good solutions may work. No on-board hardware RNG, no free
sound device for Turbid, no writable storage for a seed, ...
In those situations, it seems worth looking at RNGs based on various
sorts of timing jitter. At least two people on the list have written
something along those lines. My maxwell
(ftp://ftp.cs.sjtu.edu.cn:990/sandy/maxwell/) was specifically
designed for such limited systems. Stephan's jitter
( and Havege
( are more general. I am not
entirely convinced that these can be secure against an attacker with
enormous resources, but breaking them does not look anywhere close to
The cryptography mailing list

@_date: 2014-04-08 02:07:13
@_author: Sandy Harris 
@_subject: Re: [cryptography] The Heartbleed Bug is a serious vulnerability in OpenSSL 
OK, but if you have the patches, should you still assume all your keys
may have been compromised and therefore replace them all? Should a
careful user assume any server that does not replace keys
approximately now is untrustworthy?
How do those interact with key pinning? Or use of SSL to reach a TOR
server? Or other things?
cryptography mailing list

@_date: 2014-06-20 02:02:35
@_author: Sandy Harris 
@_subject: Re: Introduction to crypto 
That's not a good combination.
From " As for databases and real-time programming, cryptography looks
deceptively simple. The basic ideas are indeed simple and almost any
programmer can fairly easily implement something that handles
straightforward cases. However, as in the other fields, there are also
some quite tricky aspects to the problems and anyone who tackles the
hard cases without both some study of relevant theory and considerable
practical experience is almost certain to get it wrong. This is
demonstrated far too often.
I'd say start with Ross Anderson's book. The 1st edition is online & free:
Either a bookstore or a university library should have the 2nd
edition, which I'm told is even better.

@_date: 2014-07-22 15:04:47
@_author: Sandy Harris 
@_subject: Re: [Cryptography] hard to trust all those root CAs 
What about restricting the Chinese CA to signing certs in .cn and imposing
similar restrictions on other CAs?
The cryptography mailing list

@_date: 2017-09-25 21:59:47
@_author: Sandy Harris 
@_subject: Re: new idea for random number generation 
There are plenty of good online references for the issues raised in
this thread. I'll give two for each, a more-or-less standard reference
& a Citizendium article that I wrote much of & that may be easier
reading. Of course Wikipedia has both as well, and various crypto
texts have deeper detail.
Random numbers:
One-time pads:

@_date: 2017-10-16 13:11:52
@_author: Sandy Harris 
@_subject: Not assassination politics, but perhaps getting close? 
Reward of $10 million offered for info that will get Trump impeached:
