
@_date: 2009-10-30 05:57:35
@_author: StealthMonger 
@_subject: Re: [Fwd: [p2p-research] Slashdot | Federal Judge Says E-mail 
Hash: SHA1
Or people who just take incoming mail straight to their site by SMTP.
It's not even necessary to "be an ISP".
Or who encrypt the mail.
Where should the rock be thrown?
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite
Finger for key.

@_date: 2009-11-10 10:49:41
@_author: StealthMonger 
@_subject: Re: managing and protecting nyms.... 
Hash: SHA1
Tor is not practically untraceable.  The Tor documentation asserts:
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
Use of a nym server is practically untraceable because of the high
random latency and mixing with other traffic provided by the
anonymizing remailers through which a nym server is controlled.
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite
Finger for key.

@_date: 2009-11-10 10:18:58
@_author: StealthMonger 
@_subject: Re: managing and protecting nyms... 
Hash: SHA1
Tor is not practically untraceable.  The Tor documentation asserts:
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
Use of a nym server is practically untraceable because of the high
random latency and mixing with other traffic provided by the
anonymizing remailers through which a nym server is controlled.
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite
Finger for key.

@_date: 2009-11-10 10:04:01
@_author: StealthMonger 
@_subject: Re: managing and protecting nyms... 
Hash: SHA1
Tor is not practically untraceable.  The Tor documentation itself
asserts the contrary:
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
In contrast, the "obfuscation" attained with a nym server is
attributable precisely to the high random latency and traffic mixing
of the anonymizing remailers through which the nym is operated.
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite
Finger for key.

@_date: 2009-11-06 09:30:00
@_author: StealthMonger 
@_subject: Re: managing and protecting nyms... 
Hash: SHA1
Please explain other ways to be practically untraceable.
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite
Finger for key.

@_date: 2009-11-06 03:29:31
@_author: StealthMonger 
@_subject: Re: managing and protecting nyms... 
Hash: SHA1
Are you suggesting that you're not using a nym server [3] for your
What's your threat model again?
A worthy but difficult thing to do.
[3]  -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite
Finger for key.

@_date: 2009-12-10 16:48:54
@_author: StealthMonger 
@_subject: Re: schneier on schmidt 
Hash: SHA1
Eugen, thank you generally for your postings to this forum.
But thank you especially for bringing these vital words from Schneier
to our attention at this time.  For example:

@_date: 2010-05-15 10:44:21
@_author: StealthMonger 
@_subject: hawala in the news again 
Hash: SHA1
Hawala has been discussed in this forum [1] in connection with the
design of digital money systems.  Now hawala is in the news (again).
[1] For example:
   Message-Id:    Date: Mon, 13 Jan 2003 08:21:27 -0500
   To: Digital Bearer Settlement List ,cypherpunks
   From: rah ("R. A. Hettinga")
   Subject: Money laundering regulations
   Sender: owner-cypherpunks
Why FBI is following the money in Times Square bomb case
   Three Pakistani men arrested Thursday in Massachusetts and Maine may have used an
   informal network known as hawala to channel funds to alleged Times Square bomber
   Faisal Shahzad, officials say.  Counterterrorism efforts have made it increasingly
   difficult to transfer money by traditional means.
   By Peter Grier, Staff writer / May 14, 2010
   Washington
   Three Pakistani men arrested Thursday in connection with the case of alleged Times
   Square bomber Faisal Shahzad may be connected to an informal money-moving network
   that terror groups are increasingly using to finance their activities.
   The three men may not have known how Shahzad intended to use the money in question,
   say the officials.  Indications are they are not terrorist financiers per se, but
   links in an informal network of brokers, known as hawala, used to transfer cash
   quickly and easily over long distances.
   "Hawala is a popular value transfer method that predates the Western financial
   system and remains less expensive, and at times more widely available, than modern
   banking for transmitting legitimate funds around the world," writes John
   Rollins, a specialist in terrorism and national security with the Congressional
   Research Service, in a March report on terrorists and transnational crime.
   Thursday's high-profile law enforcement sweeps netted two men in Massachusetts
   and one in Maine, according to the FBI.  Sen. Susan Collins (R) of Maine said there
   is no direct connection between the arrestee from her state and Faisal Shahzad.
   Law enforcement officials instead indicated that the Times Square bomb suspect may
   have used hawala money-moving services provided by the men.
   Hawala dealers, also known as hawaladars, operate as part of an informal financial
   network used to bypass the traditional banking system.
   Here's how it works: Say a man in Pakistan wanted to send cash to a colleague in
   the US.  He would visit a hawaladar in his own country and hand over the money, plus
   a fee of about 5 percent.
   The Pakistani hawaladar would communicate with a trusted counterpart in the US, and
   indicate who should get the money, and how much.  The US hawaladar would then make
   the payment.  Usually, no money for that individual transaction actually travels
   between the two countries.  The US hawaladar would simply carry the debt until one
   of hi s clients needed to send money to Pakistan.  Then the whole process would be
   carried out in reverse.
   Hawaladars are supposed to obtain a license in the US, but few do.  It's a
   system that immigrants often use to send remittances back home, and that families
   abroad use to send money to, say, students in the US.
   But counterterrorist efforts have made it increasingly difficult for Al Qaeda and
   its associated groups to send money through the regular banking system.
   Increasingly the US and other nations have turned their scrutiny to the more
   informal hawaladars, said David Cohen, assistant secretary for terrorist financing
   at the US Department of Treasury, in January remarks before the Council on Foreign
   Relations.
   "As we have become more successful in preventing the abuse of the formal
   financial system, illicit finance has increasingly migrated to these other
   transmission techniques," said Mr. Cohen.
   According to Cohen, Al Qaeda's traditional sources of funds, such as donors
   and charities in Saudi Arabia and other Gulf countries, have dried up due to world
   counterterrorism efforts.  Top Al Qaeda leaders in recent months have taken the
   unusual step of issuing public pleas for funds.
   "Al Qaeda is in its worst financial state in years," Cohen said in April
   at a luncheon sponsored by the Washington Institute for Near East Policy.
   According to news reports, Al Qaeda has even begun charging some recruits for
   training.  The going rate for an AK-47 rifle, ammunition, and grenades is about
   $1,200.
   But terrorist attacks in Western countries do not cost a lot of money.  The 2004
   Madrid subway bombings cost a total of about $10,000, f or instance, according to
   an estimate by the Financial Action Task Force, an intergovernmental antiterrorist
   group.
   Regardless of the amount, US counterterrorism officials still take a cue from what
   Deep Throat told Washington Post reporter Bob Woodward during the Watergate
   investigation: "Follow the money."
   These days, that's a challenge.
   "The international community faces a daunting challenge in confronting global
   terrorism financing," Cohen told the Washington Institute luncheon.  "The task is
   especially tough in today's environment, with money constantly crossing
   borders and rocketing around the globe."

@_date: 2010-05-01 22:28:58
@_author: StealthMonger 
@_subject: Re: Facebook is spooking me - privacy concerns 
Hash: SHA1
What expectation of privacy do you have, using facebook?
As far as I know, facebook can only be accessed through a plain-text
real time connection.  These emissions from your site, along with all
the others, are subject to being archived by your adversary.  Being
plain-text, they can later be used to assemble a dossier on you.
Privacy is lost.

@_date: 2010-07-26 16:33:23
@_author: StealthMonger 
@_subject: uinmyn 0.05 
Hash: SHA1
           _                               ____  ____  ____
     _   _|_|_ __  _ __  __ __  __ _ __   /  _ \/  _ \| ___|
 | | | | '_ \| '_ \'_ \\ \/ /| '_ \  | | | | | | |__ \
 |_| | | | | | | | | | |\  / | | | | | |_| | |_| |__) |
    \__,|_|_|_| |_|_| |_| |_|/ /  |_| |_| \____(_)___/|___/
                            /_/
           _________________________________________
                                         |
                                         |
   IS THIS ANONYMOUS SURFING, OR WHAT?!  |
                                         |
The url Internet page fetcher [1] allows one to read
Internet content with strong anonymity.  Content is returned encrypted
in Usenet newsgroup alt.anonymous.messages.  No one, not even the
is-not-my.name administrator, is able to link content being fetched
with any particular user, or with other requests.
Here are some scripts to facilitate use of url
There are two main scripts:
   uinmyn-fetch-body.py
      -- code URLs into a request and save the key
   uinmyn-do-aam-article.py
      -- extract pages from returned a.a.m. articles
Given a (short) list of URLs, uinmyn-fetch-body.py generates a random
key for the encryption and hsub of the reply, saves the key in a local
database, and constructs the body of the request, encrypted and ready
to send through a remailer chain.
Each message from a.a.m. is then fed to uinmyn-do-aam-article.py.  If
the message matches a key in the database, the key is removed from the
database, the decrypted message is saved for further processing, and
the script returns with a positive code.  Otherwise, the script gives
a negative code.
The net effect, if all goes well, is that the pages addressed by URLs
submitted to uinmyn-fetch-body.py show up, after privacy-protecting
remailer random latencies.  No record leaves your site of who accessed
the pages.
Also provided here are minor support scripts to list the URLs in a
given reply, and to insert page content into the browser-accessible
cache provided by wwwoffle [2].
Return codes from uinmyn-do-aam-article.py are useful for procmail,
which might be checking the same message for other hits.  The
following .procmailrc clause sequence will send the decrypted "inner
posting" to local-recipient.
   :0fW
 uinmyn-do-aam-article.py /path/to/uinmyn_pending_requests_db
   :0a
   ! local-recipient
Out of respect for your privacy, uinmyn does not require you to access
any web site for its installation or use (though you may if you wish:
mailto:stealthsuite  Everything is right here in this
ABOUT THE CODE
Succinctness and readability are given priority here over efficiency.
If efficiency becomes an issue, there are lots of opportunities here
for speedup.
These scripts are meant mainly as hints for you to adapt to the needs
of your particular case.  But they could be used verbatim if you like.
   Have python, gnupg, and mixmaster installed.
   Have the send public key on your gnupg keyring.
   Copy the scripts from below to somewhere on your executables path.
Of course, you are taking a full feed of a.a.m at all times without
interruption, separating wheat from chaff only after it's all behind
closed doors.  Otherwise, the world is informed about which articles
you find interesting.
Remember, long random latency is part of the price of anonymity.  It
can't be done with TOR or any other low-latency method.
   uinmyn-fetch-body.py db | mixmaster url
      ^D
will send a request for   The key is
added to db, which need not have existed beforehand.  (It's plain
ASCII, so you can look at it to better understand what's happening.)
Later, in a directory full of fresh a.a.m articles, the command
   for f in *; do uinmyn-do-aam-article.py db < $f >> mbox; done
will append the requested content to mbox if it has arrived.
[1] [2] World Wide Web OFFline Explorer    Encryption/hsub keys are exposed briefly during a.a.m. processing.
CHANGE LOG
   Quote URL in uinmyn-do-aam-article.py against shell interpretation.
   0.04
   Did TODO item:
   Use PIPE for the gpg stdin in uinmyn-do-aam-article.py.
   (eliminating previous stupid size limit).
   0.03
   Add "decode=True" in uinmyn-to-wwwoffle-cache.py to capture coded
   files, such as .pdfs.
   Change the  reference to    0.02
   Add a script to enter gotten pages into a local browser-accessible
   cache.
   Improvements to the documentation.
Here are the scripts.
 /usr/bin/python
# SYNOPSIS
#   uinmyn-fetch-body.py # DESCRIPTION
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   url and writes it to standard output.
from os import urandom
from base64 import standard_b64encode
import sys, os
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
# same key for both encryption and hsub:
key  = standard_b64encode(urandom(15))
gpgproc = Popen('gpg -e -a -r send --trust-model always --no-emit-version --batch', shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY " + key + '\n')
urls = []
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE ' + line.rstrip() + '\n')
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
uinmyn_pending_requests[key] = urls
new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
new_upr_fd.write('uinmyn_pending_requests =\\\n')
 /usr/bin/python
# SYNOPSIS
#   uinmyn-do-aam-article.py # DESCRIPTION
#   Reads an article from standard input.  If its Subject: might be an
#   hsub, check it against each key in pending-requests-dict in turn.
#   If a hit is found, decrypt the inner posting and write it to
#   standard output.
import sys, os
from hashlib import sha256
import email
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
posting = email.message_from_file(sys.stdin)
subject = posting.get('Subject')
    iv = subject[:16].decode('hex')
except TypeError:
    sys.exit(1)
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
for key, urls in uinmyn_pending_requests.iteritems():
    if subject == (iv+sha256(iv+key).digest()).encode('hex')[:48]:
        # Doing part of the job in shell:
        gpgproc = Popen('mkfifo $HOME/passwdf ; (echo ' + key + ' > $HOME/passwdf &); gpg --passphrase-fd 3 3<$HOME/passwdf --trust-model always --batch 2>/dev/null ; rm $HOME/passwdf', stdin=PIPE, shell=True)
        gpgproc.stdin.write(posting.get_payload())
        # Other processing that could be done here:
        #  Deal with discrepancies between requested and obtained URL lists.
        #  Save the used key in an archive, rather than losing it forever.
        del uinmyn_pending_requests[key]
        new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
        new_upr_fd.write('uinmyn_pending_requests =\\\n')
        pprint.pprint(uinmyn_pending_requests,stream=new_upr_fd)
        sys.exit(0)
 /usr/bin/python
# SYNOPSIS
#   uinmyn-list-gotten-urls.py
# DESCRIPTION
#   List the URLs in the url "inner mail" on standard
#   input together with the sizes of the fetched pages.
import sys, email
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    print(page.get('Content-Description') + ', size = ' + repr(len(page.get_payload())))
 /usr/bin/python
# SYNOPSIS
#   uinmyn-to-wwwoffle-cache.py
# DESCRIPTION
#   Given a (decrypted) url "inner posting", enter each
#   page that it contains into the wwwoffle cache, overlaying any
#   previous content having matching URLs.
import sys, os, email
from subprocess import Popen, PIPE
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    p = Popen('wwwoffle-write \'' + page.get('Content-Description') + '\'', stdin=PIPE, shell=True)
    p.stdin.write('HTTP/1.0 200 OK\n')
    p.stdin.write('Content-Type: ' + page.get('Content-Type') + '\n\n')
    p.stdin.write(page.get_payload(decode=True))
    p.stdin.close()
    p.wait()
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite
Finger for key.

@_date: 2010-07-08 12:56:34
@_author: StealthMonger 
@_subject: uinmyn 0.02 
Hash: SHA1
     _   _|_|_ __  _ __  __ __  __ _ __   /  _ \/  _ \|___ \  | | | | '_ \| '_ \'_ \\ \/ /| '_ \  | | | | | | | __) |
 |_| | | | | | | | | | |\  / | | | | | |_| | |_| |/ __/
    \__,|_|_|_| |_|_| |_| |_|/ /  |_| |_| \____(_)___/|_____|
Change log
   Add a script to enter gotten pages into a local browser-accessible
   cache.
   Improvements to the documentation.
The url Internet page fetcher [1] allows an individual
to read Internet content with strong anonymity.  Content is returned
encrypted in Usenet newsgroup alt.anonymous.messages.  No one, not
even the is-not-my.name administrator, is able to link content being
fetched with any particular individual, or with other requests.
Here are some scripts to facilitate use of url
There are two main scripts:
   uinmyn-fetch-body.py
      -- code URLs into a request and save the key
   uinmyn-do-aam-article.py
      -- extract pages from returned a.a.m. articles
Given a (short) list of URLs, uinmyn-fetch-body.py generates a random
key for the encryption and hsub of the reply, saves the key in a local
database, and constructs the body of the request, encrypted and ready
to send through a remailer chain.
Each message from a.a.m. is then fed to uinmyn-do-aam-article.py.  If
the message matches a key in the database, the key is removed from the
database, the decrypted message is saved for further processing, and
the script returns with a positive code.  Otherwise, the script gives
a negative code.  The script is therefore useful for procmail, which
might be checking the same message for other hits.  The following
.procmailrc clause sequence will send the decrypted "inner posting" to
   :0fW
 uinmyn-do-aam-article.py /path/to/uinmyn_pending_requests_db
   :0a
   ! local-recipient
The net effect, if all goes well, is that the pages addressed by URLs
submitted to uinmyn-fetch-body.py show up, after privacy-protecting
remailer random latencies.  No record leaves your site of who accessed
the pages.
Also provided here is are minor support scripts to list the URLs in a
given reply, and to insert page content into the browser-accessible
cache provided by wwwoffle [2].
Out of respect for your privacy, uinmyn does not require you to access
any web site for its installation or use (though you may if you wish:
mailto:stealthsuite  Everything is right here in this
ABOUT THE CODE
Succinctness and readability are given priority here over efficiency.
If efficiency becomes an issue, there are lots of opportunities here
for speedup.
These scripts are meant mainly as hints for you to adapt to the needs
of your particular case.  But they could be used verbatim if you like
the way they are structured.
   Have python, gnupg, and mixmaster installed.
   Have the send public key on your gnupg keyring.
   Copy the scripts from below to somewhere on your executables path.
Of course, you are taking a full feed of a.a.m at all times without
interruption, separating wheat from chaff only after it's all behind
closed doors.  Otherwise, the world is informed about which articles
you find interesting.
Remember, long random latency is part of the price of untraceability.
It can't be done with TOR or any other low-latency method.
   uinmyn-fetch-body.py db | mixmaster url
      ^D
will send a request for   The key is added
to db, which need not have existed beforehand.  (It's plain ASCII, so
you can look at it to better understand what's happening.)
Later, in a directory full of fresh a.a.m articles, the command
   for f in *; do uinmyn-do-aam-article.py db < $f >> mbox; done
will append the requested content to mbox if it has arrived.
[1] [2] World Wide Web OFFline Explorer    Use PIPE for the gpg stdin in uinmyn-do-aam-article.py.
   Encryption/hsub keys are exposed briefly during a.a.m. processing.
Here are the scripts.
 /usr/bin/python
# SYNOPSIS
#   uinmyn-fetch-body.py # DESCRIPTION
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   url and writes it to standard output.
from os import urandom
from base64 import standard_b64encode
import sys, os
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
# same key for both encryption and hsub:
key  = standard_b64encode(urandom(15))
gpgproc = Popen('gpg -e -a -r send --trust-model always --no-emit-version --batch', shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY " + key + '\n')
urls = []
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE ' + line.rstrip() + '\n')
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
uinmyn_pending_requests[key] = urls
new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
new_upr_fd.write('uinmyn_pending_requests =\\\n')
 /usr/bin/python
# SYNOPSIS
#   uinmyn-do-aam-article.py # DESCRIPTION
#   Reads an article from standard input.  If its Subject: might be an
#   hsub, check it against each key in pending-requests-dict in turn.
#   If a hit is found, decrypt the inner posting and write it to
#   standard output.
import sys, os
from hashlib import sha256
import email
import pprint
from subprocess import Popen
UINMYN_PENDING_REQUESTS = sys.argv[1]
posting = email.message_from_file(sys.stdin)
subject = posting.get('Subject')
    iv = subject[:16].decode('hex')
except TypeError:
    sys.exit(1)
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
for key, urls in uinmyn_pending_requests.iteritems():
    if subject == (iv+sha256(iv+key).digest()).encode('hex')[:48]:
        # Doing part of the job in shell:
        gpgproc = Popen('mkfifo $HOME/passwdf ; (echo ' + key + ' > $HOME/passwdf &); echo "' + posting.get_payload() + '" | gpg --passphrase-fd 3 3<$HOME/passwdf --trust-model always --batch 2>/dev/null ; rm $HOME/passwdf', shell=True)
        # Other processing that could be done here:
        #  Deal with discrepancies between requested and obtained URL lists.
        #  Save the used key in an archive, rather than losing it forever.
        del uinmyn_pending_requests[key]
        new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
        new_upr_fd.write('uinmyn_pending_requests =\\\n')
        pprint.pprint(uinmyn_pending_requests,stream=new_upr_fd)
        sys.exit(0)
 /usr/bin/python
# SYNOPSIS
#   uinmyn-list-gotten-urls.py
# DESCRIPTION
#   List the URLs in the url "inner mail" on standard
#   input together with the sizes of the fetched pages.
import sys, email
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    print(page.get('Content-Description') + ', size = ' + repr(len(page.get_payload())))
 /usr/bin/python
# SYNOPSIS
#   uinmyn-to-wwwoffle-cache.py
# DESCRIPTION
#   Given a (decrypted) url "inner posting", enter each
#   page that it contains into the wwwoffle cache, overlaying any
#   previous content having matching URLs.
import sys, os, email
from subprocess import Popen, PIPE
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    p = Popen('wwwoffle-write ' + page.get('Content-Description'), stdin=PIPE, shell=True)
    p.stdin.write('HTTP/1.0 200 OK\n')
    p.stdin.write('Content-Type: ' + page.get('Content-Type') + '\n\n')
    p.stdin.write(page.get_payload())
    p.stdin.close()
    p.wait()
 -- StealthMonger
 --
   stealthmail: Scripts to hide whether you're doing email, or when,
   or with whom.
         mailto:stealthsuite
Finger for key.

@_date: 2010-08-03 04:48:51
@_author: StealthMonger 
@_subject: Microsoft Quashed Effort to Boost Online Privacy - WSJ.com 
Hash: SHA1
Microsoft Quashed Effort to Boost Online Privacy - WSJ.com
By NICK WINGFIELD
   The online habits of most people who use the world's dominant Web
   browser are an open book to advertisers.  That wasn't the plan at
   first.
   In early 2008, Microsoft Corp.'s product planners for the Internet
   Explorer 8.0 browser intended to give users a simple, effective way
   to avoid being tracked online.  They wanted to design the software
   to automatically thwart common tracking tools, unless a user
   deliberately switched to settings affording less privacy.
   That triggered heated debate inside Microsoft.  As the leading
   maker of Web browsers, the gateway software to the Internet,
   Microsoft must balance conflicting interests: helping people surf
   the Web with its browser to keep their mouse clicks private, and
   helping advertisers who want to see those clicks.
   In the end, the product planners lost a key part of the debate.
   The winners: executives who argued that giving automatic privacy to
   consumers would make it tougher for Microsoft to profit from
   selling online ads.  Microsoft built its browser so that users must
   deliberately turn on privacy settings every time they start up the
   software.

@_date: 2010-11-30 03:28:27
@_author: StealthMonger 
@_subject: Re: any moment now ... 
Hash: SHA1
If by "secure" you mean that the individual doing the browsing cannot
be traced, note that in any low-latency Internet access, packet timing
correlations between the parties can easily confirm any suspected
linkage.  As the Tor documentation itself states,
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
More difficult to trace is Internet access by email via the remailer
network.  See my "uinmyn", URL below.
 -- StealthMonger     Long, random latency is part of the price of Internet anonymity.
   uinmyn: Is this anonymous surfing, or what?
      stealthmail: Hide whether you're doing email, or when, or with whom.
   mailto:stealthsuite
Key: mailto:stealthsuite

@_date: 2010-12-02 00:12:03
@_author: StealthMonger 
@_subject: Re: any moment now ... 
Hash: SHA1
Earlier he wrote
So, what can be done with that Tor node once it's set up?  It can't be
used interactively (i.e. with low latency) because that "permanent
record of all of your transactions in Internet-space" can be used
today or tomorrow or "next year or next decade or ..." to correlate
packet timings and destroy whatever anonymity the Tor node might
otherwise have had.  And if the Tor node is configured to respond to
instructions anonymized by a remailer network, the remailer network
might as well have by used by itself in the first place, without the
Tor node in the picture at all.
 -- StealthMonger     Long, random latency is part of the price of Internet anonymity.
   uinmyn: Is this anonymous surfing, or what?
      stealthmail: Hide whether you're doing email, or when, or with whom.
   mailto:stealthsuite
Key: mailto:stealthsuite

@_date: 2011-02-23 01:32:49
@_author: StealthMonger 
@_subject: Re: Feasibility of Using TOR or VPNs For Anonymity 
Hash: SHA1
Your skepticism is fitting.  In fact, even the TOR documentation
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
      uinmyn: Is this anonymous browsing, or what?
      stealthmail: Hide whether you're doing email, or when, or with whom.
   mailto:stealthsuite
Good stuff.  Stick with it.
 -- StealthMonger     Long, random latency is part of the price of Internet anonymity.
Key: mailto:stealthsuite

@_date: 2011-03-16 00:08:10
@_author: StealthMonger 
@_subject: uinmyn 0.06 
Hash: SHA1
   The Internet is even more powerful at protecting privacy than it is
   at destroying it.
    --- StealthMonger
   ... for low-latency systems like Tor, end-to-end traffic
   correlation attacks [8, 21, 31] allow an attacker who can observe
   both ends of a communication to correlate packet timing and volume,
   quickly linking the initiator to her destination.
    ---    Long, random latency is part of the price of Internet anonymity.
    --- StealthMonger
           _                               ____  ____   __
     _   _|_|_ __  _ __  __ __  __ _ __   /  _ \/  _ \ / /
 | | | | '_ \| '_ \'_ \\ \/ /| '_ \  | | | | | | |  ^\
 |_| | | | | | | | | | |\  / | | | | | |_| | |_| | () |
    \__,|_|_|_| |_|_| |_| |_|/ /  |_| |_| \____(_)___/\___/
                            /_/
           __________________________________________
                                          |
                                          |
   IS THIS ANONYMOUS BROWSING, OR WHAT?!  |
                                          |
The url Internet page fetcher [1] allows the reading of
Internet content with strong anonymity.  An encrypted request is sent
through a chain of anonymizing remailers and content is returned
encrypted in Usenet newsgroup alt.anonymous.messages.  No one, not
even the is-not-my.name administrator, is able to link content being
fetched with any particular user, or with other requests.
Here are some scripts to facilitate use of url
There are two main scripts:
   uinmyn-fetch-body.py
      -- code URLs into a request and save the key
   uinmyn-do-aam-article.py
      -- extract pages from returned a.a.m. articles
Given a (short) list of URLs, uinmyn-fetch-body.py generates a random
key for the encryption and hsub of the reply, saves the key in a local
database, and constructs the body of the request, encrypted and ready
to send through a remailer chain.
Each message from a.a.m. is then fed to uinmyn-do-aam-article.py.  If
the message matches a key in the database, the key is removed from the
database, the decrypted message is saved for further processing, and
the script returns with a positive code.  Otherwise, the script gives
a negative code.
The net effect, if all goes well, is that the pages addressed by URLs
submitted to uinmyn-fetch-body.py show up, after privacy-protecting
remailer random latencies.  No record leaves the requester's site of
who accessed the pages.
Also provided here are minor support scripts to list the URLs in a
given reply, and to insert page content into the browser-accessible
cache provided by wwwoffle [2].
Return codes from uinmyn-do-aam-article.py are useful for procmail,
which might be checking the same message for other hits.  The
following .procmailrc clause sequence will send the decrypted "inner
posting" to local-recipient.
   :0fW
 uinmyn-do-aam-article.py /path/to/uinmyn_pending_requests_db
   :0a
   ! local-recipient
Out of respect for your privacy, uinmyn does not require you to access
any web site for its installation or use (though you may if you wish:
Everything is right here in this posting.
ABOUT THE CODE
Succinctness and readability are given priority here over efficiency.
If efficiency becomes an issue, there are lots of opportunities here
for speedup.
These scripts are meant mainly as hints for you to adapt to the needs
of your particular case.  But they could be used verbatim if you like.
   Have python, gnupg, and mixmaster installed.
   Have the send public key on your gnupg keyring.
   Copy the scripts from below to somewhere on your executables path.
Of course, you are taking a full feed of a.a.m at all times without
interruption, separating wheat from chaff only after it's all behind
closed doors.  Otherwise, the world is informed about which articles
you find interesting.
Remember, long random latency is part of the price of anonymity.  It
can't be done with TOR or any other low-latency method.
   uinmyn-fetch-body.py db | mixmaster url
      ^D
will send a request for   The key is
added to db, which need not have existed beforehand.  (It's plain
ASCII, so you can look at it to better understand what's happening.)
Later, in a directory full of fresh a.a.m articles, the command
   for f in *; do uinmyn-do-aam-article.py db < $f >> mbox; done
will append the requested content to mbox if it has arrived.
[1] [2] World Wide Web OFFline Explorer    Encryption/hsub keys are exposed briefly during a.a.m. processing.
CHANGE LOG
   0.06
   Add time-stamps to database entries to facilitate removal of old,
   stale entries.
   Changed slogan from "Is this anonymous surfing, or what?".
   Documentation improvements.
   0.05
   Quote URL in uinmyn-do-aam-article.py against shell interpretation.
   0.04
   Did TODO item:
   Use PIPE for the gpg stdin in uinmyn-do-aam-article.py.
   (eliminating previous stupid size limit).
   0.03
   Add "decode=True" in uinmyn-to-wwwoffle-cache.py to capture coded
   files, such as .pdfs.
   Change the  reference to    0.02
   Add a script to enter gotten pages into a local browser-accessible
   cache.
   Improvements to the documentation.
Here are the scripts.
 /usr/bin/python
# SYNOPSIS
#   uinmyn-fetch-body.py # DESCRIPTION
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   url and writes it to standard output.
from os import urandom
from base64 import standard_b64encode
import sys, os, time
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
# same key for both encryption and hsub:
key  = standard_b64encode(urandom(15))
gpgproc = Popen('gpg -e -a -r send --trust-model always --no-emit-version --batch', shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY " + key + '\n')
urls = [time.time()] # time-tag precedes the urls in the db entry
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE ' + line.rstrip() + '\n')
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
uinmyn_pending_requests[key] = urls
new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
new_upr_fd.write('uinmyn_pending_requests =\\\n')
 /usr/bin/python
# SYNOPSIS
#   uinmyn-do-aam-article.py # DESCRIPTION
#   Reads an article from standard input.  If its Subject: might be an
#   hsub, check it against each key in pending-requests-dict in turn.
#   If a hit is found, decrypt the inner posting and write it to
#   standard output.
import sys, os
from hashlib import sha256
import email
import pprint
from subprocess import Popen, PIPE
UINMYN_PENDING_REQUESTS = sys.argv[1]
posting = email.message_from_file(sys.stdin)
subject = posting.get('Subject')
    iv = subject[:16].decode('hex')
except TypeError:
    sys.exit(1)
# Not dealt with here: Mutually exclusive access to the
# UINMYN_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(UINMYN_PENDING_REQUESTS):
    execfile(UINMYN_PENDING_REQUESTS)
    uinmyn_pending_requests = {}
for key, urls in uinmyn_pending_requests.iteritems():
    if subject == (iv+sha256(iv+key).digest()).encode('hex')[:48]:
        # Doing part of the job in shell:
        gpgproc = Popen('mkfifo $HOME/passwdf ; (echo ' + key + ' > $HOME/passwdf &); gpg --passphrase-fd 3 3<$HOME/passwdf --trust-model always --batch 2>/dev/null ; rm $HOME/passwdf', stdin=PIPE, shell=True)
        gpgproc.stdin.write(posting.get_payload())
        # Other processing that could be done here:
        #  Deal with discrepancies between requested and obtained URL lists.
        #  Save the used key in an archive, rather than losing it forever.
        del uinmyn_pending_requests[key]
        new_upr_fd = open(UINMYN_PENDING_REQUESTS, 'w')
        new_upr_fd.write('uinmyn_pending_requests =\\\n')
        pprint.pprint(uinmyn_pending_requests,stream=new_upr_fd)
        sys.exit(0)
 /usr/bin/python
# SYNOPSIS
#   uinmyn-list-gotten-urls.py
# DESCRIPTION
#   List the URLs in the url "inner mail" on standard
#   input together with the sizes of the fetched pages.
import sys, email
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    print(page.get('Content-Description') + ', size = ' + repr(len(page.get_payload())))
 /usr/bin/python
# SYNOPSIS
#   uinmyn-to-wwwoffle-cache.py
# DESCRIPTION
#   Given a (decrypted) url "inner posting", enter each
#   page that it contains into the wwwoffle cache, overlaying any
#   previous content having matching URLs.
import sys, os, email
from subprocess import Popen, PIPE
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    p = Popen('wwwoffle-write \'' + page.get('Content-Description') + '\'', stdin=PIPE, shell=True)
    p.stdin.write('HTTP/1.0 200 OK\n')
    p.stdin.write('Content-Type: ' + page.get('Content-Type') + '\n\n')
    p.stdin.write(page.get_payload(decode=True))
    p.stdin.close()
    p.wait()
 -- StealthMonger     Long, random latency is part of the price of Internet anonymity.
   stealthmail: Hide whether you're doing email, or when, or with whom.
   mailto:stealthsuite
Key: mailto:stealthsuite

@_date: 2011-05-31 03:36:18
@_author: StealthMonger 
@_subject: Re: NYT Discovers Privacy! 
Hash: SHA1
What a disappointment!
On reading that Subject: line, my first thought was "Ah!  NYT have
decided to accept anonymous cash for electronic newspapers!"
But discovering in the first paragraphs that it was a blog about email
privacy, I still hoped that the blogger would conclude by pointing out
that it IS, after all, possible to do secure, even stealthy, email.
But, no.  Instead we find
I guess she never heard of encryption or stealthmail.  How sad.

@_date: 2011-06-14 21:30:18
@_author: StealthMonger 
@_subject: [cryptography] Digital cash in the news... 
Hash: SHA1
Hmm?  Protection from the state is the very reason some of us are
here.  Even Philip Zimmermann wrote twenty years ago [1]
   Why Do You Need PGP? ...  you may be doing something that you feel
   shouldn't be illegal, but is.
And the very title of David Chaum's 1985 paper was "Security without
Identification: Transaction Systems to Make Big Brother Obsolete" [2]
[1] pgpdoc1.txt
[2] CACM 28(10), October 1985

@_date: 2011-09-18 19:18:42
@_author: StealthMonger 
@_subject: anonget 1.0 (formerly uinmyn) 
Hash: SHA1
NEW IN THIS RELEASE
anonget (1.0)
  * Name change from "uinmyn" (last version was 0.07)
  * Optional send confirmation now available, providing a progress
    report of the URL request and to help diagnose failures.
  * Reformat anonget-list-gotten-urls.py output for easier reading.
  * Change "is-not-my.name" to "mixnym.net".
  * Rewrite the documentation.
                                          _     __   ___
     _______ __  ____  _ __  _____ ____ _| |_  /  | / _ \
    /  _  | '_ \/  _ \| '_ \/  _ //  _ \_   _|  | || | | |
 |_| | | | | |_| | | | | |_| | |/ / | |    | || |_| |
    \___/_|_| |_\____/|_| |_\  __/ \___/ |__|  /___O\___/
                            / /__
           __________________________________________
                                          |
                                          |
   IS THIS ANONYMOUS BROWSING, OR WHAT?!  |
                                          |
N.B.: Below, replace all occurrences of "" with "
WHAT IS IT?
anonget facilitates browsing the Internet with strong anonymity via
urlmixnym.net [1].
HOW IT WORKS
Given a list of URLs, anonget encrypts the list and a fresh random key
and formats it for mailing by mixmaster [2] to urlmixnym.net
through a chain of anonymizing remailers.  The request contains
nothing to identify you or your site, and the outgoing mail is
indistinguishable from other remailer traffic that you may generate.
urlmixnym.net then gets the requested information from the
Internet, encrypts it to the fresh key, and broadcasts it worldwide on
Usenet newsgroup alt.anonymous.messages.
The fresh key (saved by anonget) is used to recognize and decrypt the
No one, not even the mixnym.net administrator, is able to link content
being fetched with any particular user, or with other requests.
EXAMPLE 1
The command
   echo  | anonget-fetch-body.py db \
 mixmaster urlmixnym.net
generates a fresh random key for the encryption and hsub of the reply,
adds the key to db (which need not have existed beforehand), formats
and encrypts key and list of URLs (just in this case) as required by urlmixnym.net, and sends it.  db is
plain ASCII, so you can look at it to better see what's happening.
Later, in a directory full of fresh a.a.m articles, the command
   for f in *; do anonget-do-aam-article.py db < $f >> mbox; done
will append the requested content to mbox if it has arrived.
ADDING SEND CONFIRMATION
Alternatively, a request can be formulated to not only get the wanted
information as above, but to send confirmation that it was mailed from
the last remailer in the chain.  This provides a progress report of
the request and can help to diagnose failures.  A copy of the request
is sent to a mail-to-news gateway with Subject: another hsub generated
with the same fresh key.
EXAMPLE 2
   (echo 'Chain: *,*,kulin'; echo  \
 anonget-fetch-whole.py db) | mixmaster
Unlike anonget-fetch-body.py of example 1, anonget-fetch-whole.py
generates a whole mail, including To:, Cc:, and Subject: headers,
instead of relying on mixmaster to provide them.  (Yet more headers,
like the Chain: in example 2, can be added as shown.  Note the
parentheses in the command.)
When anonget-do-aam-article.py processes the article in example 1, it
emits the inner reply mail and deletes the db entry.  But when it
senses that the article is not the returned data, but the request
itself, it constructs a confirmation message and leaves the db entry
intact.  (Note that if the fetched data get processed before the
request confirmation (due to net lag), the request confirmation will
not be noticed because the database entry will already have been
deleted.  But in this case it doesn't matter.)
CACHING OR ARCHIVING THE REPLY, AND RENDERING IT
A convenient way to save and render an anonget reply is to insert it
into the browser-accessible cache provided by wwwoffle [3].  The
script anonget-to-wwwoffle-cache.py is provided for this purpose.
To just list the URLs contained in an "inner mail", the script
anonget-list-gotten-urls.py can be applied.
AUTOMATIC DISPOSITION OF THE REPLY
Instead of the explicit anonget-do-aam-article.py command above,
procmail [4] can be used to forward the reply as local configuration
may require.  Return codes from anonget-do-aam-article.py are useful
for procmail, which might be checking the same message for other hits.
The following .procmailrc clause sequence will send the decrypted
"inner posting" to "local-recipient".
   :0fW
 anonget-do-aam-article.py /path/to/anonget_pending_requests_db
   :0a
   ! local-recipient
RESPECTING YOUR PRIVACY
Out of respect for your privacy, anonget doesn't require you to access
any web site for its installation or use (though you may if you wish:
Everything is right here in this posting.
ABOUT THE CODE
Succinctness and readability are given priority here over efficiency.
If efficiency becomes an issue, there are lots of opportunities here
for speedup.
These scripts are meant mainly as hints for you to adapt to the needs
of your particular case.  But they could be used verbatim if you like.
   Have python, gnupg, and mixmaster installed.
   Have public key '94F204C28BF00937EFC85D1AFF4DB66014D0C447' on your
      gnupg keyring.
   Copy the scripts from below to somewhere on your executables path.
Of course, you are taking a full feed of a.a.m at all times without
interruption, separating wheat from chaff only after it's all behind
closed doors.  Otherwise, the world is informed about which articles
you find interesting.
Remember, long random latency is part of the price of anonymity.  It
can't be done with TOR or any other low-latency method.
[1] [2] [3] WWW OFFLine Explorer [4] CHANGE LOG
   0.07
   Use long keyid, not sendmixnym.net, to identify encryption
   key, foiling fake key postings.  Contributed by Steve Crook.
   Use Python's internal encode('base64') instead of imported Base64
   to encode the random key.  Contributed by Steve Crook.
   Use Python "%"-style string substitution for type conversion and
   tidier code (yet to be finished).  Contributed by Steve Crook.
   Support hsub's ranging from 48 to 80 chars in length.  Contributed
   by Steve Crook.
   Systematically code all email addresses to avert Google corruption
   of its archived version of this posting.
   0.06
   Add time-stamps to database entries to facilitate removal of old,
   stale entries.
   Changed slogan from "Is this anonymous surfing, or what?".
   Documentation improvements.
   0.05
   Quote URL in uinmyn-do-aam-article.py against shell interpretation.
   0.04
   Did TODO item:
   Use PIPE for the gpg stdin in uinmyn-do-aam-article.py.
   (eliminating previous stupid size limit).
   0.03
   Add "decode=True" in uinmyn-to-wwwoffle-cache.py to capture coded
   files, such as .pdfs.
   Change the  reference to    0.02
   Add a script to enter gotten pages into a local browser-accessible
   cache.
   Improvements to the documentation.
Here are the scripts.
8<--------8<------- anonget-fetch-body.py --------8<--------8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-fetch-body.py # DESCRIPTION
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   urlmixnym.net, and writes it to standard output.
from os import urandom
import sys, os, time
import pprint
from subprocess import Popen, PIPE
ANONGET_PENDING_REQUESTS = sys.argv[1]
NYMSERV_KEY = '94F204C28BF00937EFC85D1AFF4DB66014D0C447'
# same key for both encryption and hsub:
key  = urandom(15).encode('base64').rstrip()
gpgcmd = 'gpg --armor --encrypt --recipient %s ' % NYMSERV_KEY
gpgopts = '--trust-model always --no-emit-version --batch'
gpgproc = Popen(gpgcmd + gpgopts, shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY %s\n" % key)
urls = [time.time()] # time-tag precedes the urls in the db entry
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE %s\n' % line.rstrip())
# Not dealt with here: Mutually exclusive access to the
# ANONGET_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(ANONGET_PENDING_REQUESTS):
    execfile(ANONGET_PENDING_REQUESTS)
    anonget_pending_requests = {}
anonget_pending_requests[key] = urls
new_upr_fd = open(ANONGET_PENDING_REQUESTS, 'w')
new_upr_fd.write('anonget_pending_requests =\\\n')
8<--------8<------- anonget-do-aam-article.py ----8<--------8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-do-aam-article.py # DESCRIPTION
#   Reads an article from standard input.  If its Subject: might be an
#   hsub, check it against each key in pending-requests-dict in turn.
#   If a hit is found, decrypt the inner posting and write it to
#   standard output.
import sys, os
from hashlib import sha256
import email
import pprint
from subprocess import Popen, PIPE
ANONGET_PENDING_REQUESTS = sys.argv[1]
posting = email.message_from_file(sys.stdin)
# Abort if Subject doesn't exist, otherwise get its length
if 'Subject' in posting:
    sublen = len(posting['Subject'])
    # No Subject, no hSub.
    sys.exit(1)
# hSubs must fall within the length criteria
if sublen < 48 or sublen > 80:
    sys.exit(1)
    iv = posting['subject'][:16].decode('hex')
except TypeError:
    sys.exit(1)
# Not dealt with here: Mutually exclusive access to the
# ANONGET_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(ANONGET_PENDING_REQUESTS):
    execfile(ANONGET_PENDING_REQUESTS)
    anonget_pending_requests = {}
for key, urls in anonget_pending_requests.iteritems():
    hsub = (iv + sha256(iv + key).digest()).encode('hex')[:sublen]
    if posting['Subject'] == hsub:
        # Doing part of the job in shell:
        gpgproc = Popen('mkfifo $HOME/passwdf ; (echo ' + key + ' > $HOME/passwdf &); gpg --passphrase-fd 3 3<$HOME/passwdf --trust-model always --batch ; rm $HOME/passwdf', stdin=PIPE, stderr=PIPE, shell=True)
        gpgstderr = gpgproc.communicate(input=posting.get_payload())[1]
        if gpgstderr.find('decryption failed') < 0:
            # Other processing that could be done here:
            #  Deal with discrepancies between requested and obtained URL lists.
            #  Save the used key in an archive, rather than losing it forever.
            del anonget_pending_requests[key]
            new_upr_fd = open(ANONGET_PENDING_REQUESTS, 'w')
            new_upr_fd.write('anonget_pending_requests =\\\n')
            pprint.pprint(anonget_pending_requests,stream=new_upr_fd)
            sys.exit(0)
        else:
            # gpg says 'decryption failed'; assume it's a send confirmation.
            print 'Subject: URL request send confirmation ' + key
            print ''
            print 'Key: ' + key
            print 'Request-time: ' + str(urls[0])
            print 'URLs: ' + str(urls[1:])
            print 'gpg-stderr:'
            print gpgstderr
            sys.exit(0)
8<--------8<--------8<------- anonget-fetch-whole.py -------8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-fetch-whole.py # DESCRIPTION
#   Alternative to anonget-fetch-body.py includes send confirmation.
#   Reads URLs from standard input, one per line, generates a fresh
#   random key to encrypt the reply and for its hsub, adds the key and
#   the requested URLs to pending-requests-dict (creating it anew if
#   it doesn't exist), constructs and encrypts a request for
#   urlmixnym.net, and writes it to standard output, prepended
#   with mail headers for send confirmation.
from os import urandom
from hashlib import sha256
import sys, os, time
import pprint
from subprocess import Popen, PIPE
from datetime import datetime
ANONGET_PENDING_REQUESTS = sys.argv[1]
NYMSERV_KEY = '94F204C28BF00937EFC85D1AFF4DB66014D0C447'
HSUBLEN = 48
# same key for both encryption and hsub:
key  = urandom(15).encode('base64').rstrip()
# Mail headers
print 'To: urlmixnym.net'
datestring = datetime.utcnow().strftime("%Y%m%d")
print 'Cc: mail2news-' + datestring + '-alt.anonymous.messagesm2n.mixmin.net'
iv = urandom(8)                 # hsub code adapted from that of Steve Crook
hsub = (iv + sha256(iv + key).digest()).encode('hex')[:HSUBLEN]
print 'Subject: ' + hsub
print ''
sys.stdout.flush()              # so headers definitely precede body
gpgcmd = 'gpg --armor --encrypt --recipient %s ' % NYMSERV_KEY
gpgopts = '--trust-model always --no-emit-version --batch'
gpgproc = Popen(gpgcmd + gpgopts, shell=True, stdin=PIPE)
gpgproc.stdin.write("KEY %s\n" % key)
urls = [time.time()] # time-tag precedes the urls in the db entry
for line in sys.stdin.readlines():
    urls.append(line.rstrip())
    gpgproc.stdin.write('SOURCE %s\n' % line.rstrip())
# Not dealt with here: Mutually exclusive access to the
# ANONGET_PENDING_REQUESTS database, as would be required if request
# issuance might be concurrent with a.a.m. processing.
if os.path.isfile(ANONGET_PENDING_REQUESTS):
    execfile(ANONGET_PENDING_REQUESTS)
    anonget_pending_requests = {}
anonget_pending_requests[key] = urls
new_upr_fd = open(ANONGET_PENDING_REQUESTS, 'w')
new_upr_fd.write('anonget_pending_requests =\\\n')
8<--------8<--------8<------- anonget-list-gotten-urls.py --8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-list-gotten-urls.py
# DESCRIPTION
#   List the URLs in the urlmixnym.net "inner mail" on standard
#   input together with the sizes of the fetched pages.
import sys, email
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    print repr(len(page.get_payload())).rjust(8),page.get('Content-Description')
8<--------8<--------8<------- anonget-to-wwwoffle-cache.py -8<--------
 /usr/bin/python
# SYNOPSIS
#   anonget-to-wwwoffle-cache.py
# DESCRIPTION
#   Given a (decrypted) urlmixnym.net "inner posting", enter each
#   page that it contains into the wwwoffle cache, overlaying any
#   previous content having matching URLs.
import sys, os, email
from subprocess import Popen, PIPE
pages = email.message_from_file(sys.stdin)
for page in pages.get_payload():
    p = Popen('wwwoffle-write \'' + page.get('Content-Description') + '\'', stdin=PIPE, shell=True)
    p.stdin.write('HTTP/1.0 200 OK\n')
    p.stdin.write('Content-Type: ' + page.get('Content-Type') + '\n\n')
    p.stdin.write(page.get_payload(decode=True))
    p.stdin.close()
    p.wait()
 -- StealthMonger nym.mixmin.net>
    Long, random latency is part of the price of Internet anonymity.
Key: mailto:stealthsuitenym.mixmin.net?subject=send%20stealthmonger-key

@_date: 2011-10-31 15:45:46
@_author: StealthMonger 
@_subject: Re: Good free mildly-private email service? 
Hash: SHA1
Have you considered stealthmail?  See mailto: below.
   Package: stealthmail
   Architecture: all
   Pre-Depends: gnupg
   Depends: procmail, esubbf, openssl, dc, libssl0.9.6 | libssl0.9.7,
    fetchmail | kmail, suck, ppp, solid-pop3d, exim | exim4, dpkg (>= 1.10.21),
    grep (>= 2.5), bash (>= 2.05b), ${shlibs:Depends}, ${misc:Depends}
   Description: scripts to hide whether you're doing email, or when, or with whom
    Maintain on-going random cover traffic via usenet newsgroup
    alt.anonymous.messages, substituting encrypted live traffic when
    available.  A live message is indistinguishable from a random cover
    message except with the decryption keys.  All potential participants
    send messages to alt.anonymous.messages with rigid periodicity
    uncorrelated with any live traffic, and maintain an uninterrupted
    full feed from alt.anonymous.messages, so that an observer cannot
    determine whether, when, or among whom live communication is
    happening.
    .
    Members of a "stealthmail group" -- call it "OurGroup" for purposes
    of this discussion -- are defined by their knowledge of the
    encryption keys created for the group.  With this package installed,
    mail addressed to OurGroup does not go directly to the
    Internet like ordinary mail, but gets encrypted by the OurGroup key,
    given an encrypted subject intelligible only with OurGroup keys, and
    queued to go to alt.anonymous.messages in place of a piece of cover
    traffic at the next scheduled sending time.  Meanwhile, all messages
    appearing on alt.anonymous.messages are downloaded into an incoming
    queue.  A POP3 server runs on the local host.  The mail reader is
    provided with filters so that when it fetches mail from this local
    server, messages having subject lines encrypted for OurGroup (or any
    other stealthmail group of which this host is a member) are decrypted
    by the appropriate key and presented.  Other messages are discarded.

@_date: 2011-10-31 14:57:17
@_author: StealthMonger 
@_subject: Re: Good free mildly-private email service? 
Hash: SHA1
Have you considered stealthmail?  See mailto: below.
   Package: stealthmail
   Architecture: all
   Pre-Depends: gnupg
   Depends: procmail, esubbf, openssl, dc, libssl0.9.6 | libssl0.9.7,
    fetchmail | kmail, suck, ppp, solid-pop3d, exim | exim4, dpkg (>= 1.10.21),
    grep (>= 2.5), bash (>= 2.05b), ${shlibs:Depends}, ${misc:Depends}
   Description: scripts to hide whether you're doing email, or when, or with whom
    Maintain on-going random cover traffic via usenet newsgroup
    alt.anonymous.messages, substituting encrypted live traffic when
    available.  A live message is indistinguishable from a random cover
    message except with the decryption keys.  All potential participants
    send messages to alt.anonymous.messages with rigid periodicity
    uncorrelated with any live traffic, and maintain an uninterrupted
    full feed from alt.anonymous.messages, so that an observer cannot
    determine whether, when, or among whom live communication is
    happening.
    .
    Members of a "stealthmail group" -- call it "OurGroup" for purposes
    of this discussion -- are defined by their knowledge of the
    encryption keys created for the group.  With this package installed,
    mail addressed to OurGroup does not go directly to the
    Internet like ordinary mail, but gets encrypted by the OurGroup key,
    given an encrypted subject intelligible only with OurGroup keys, and
    queued to go to alt.anonymous.messages in place of a piece of cover
    traffic at the next scheduled sending time.  Meanwhile, all messages
    appearing on alt.anonymous.messages are downloaded into an incoming
    queue.  A POP3 server runs on the local host.  The mail reader is
    provided with filters so that when it fetches mail from this local
    server, messages having subject lines encrypted for OurGroup (or any
    other stealthmail group of which this host is a member) are decrypted
    by the appropriate key and presented.  Other messages are discarded.

@_date: 2011-11-23 17:10:13
@_author: StealthMonger 
@_subject: Re: [serval-project-dev] We have store-and-forward SMS working 
Hash: SHA1
Could this enable phone-based anonymizing remailers having long random
latency for mixing?  How much memory is available, typically?
I know, this question belongs on the serval-project-developers mailing
list, so I'm trying to subscribe there now.
   This service uses direct mesh links if they are available by making
   use of the existing SMS capability in the Serval BatPhone software.
   However, if there is no direct link, then it uses a
   store-and-forward scheme, that asks any passing phones to copy the
   message and distribute it to other phones on the mesh, until it
   (hopefully) eventually reaches its intended destination.
Reinventing SMTP! :)
   While the delay in such a service is huge, the bandwidth is also
   great, as potentially gigabytes of data can be transferred between
   nodes.
These are both valuable attributes for anonymizing remailers.

@_date: 2012-03-31 05:15:55
@_author: StealthMonger 
@_subject: Re: [cryptography] Key escrow 2012 
Hash: SHA1
Yep.  It should be no harder than maintaining a personal telephone
Would-be telephone correspondents somehow manage to get each other's
phone numbers into their personal directories.  Similarly, would-be
email correspondents can get each other's public keys.

@_date: 2012-03-30 12:10:42
@_author: StealthMonger 
@_subject: Re: [cryptography] Key escrow 2012 
Hash: SHA1
Nope.  If we had won, crypto would be in widespread use today for
email.  As it is, enough FUD and confusion was sown to avert that
outcome.  Even on geek mailing lists such as this, signatures are

@_date: 2012-08-26 10:40:13
@_author: StealthMonger 
@_subject: Hawala on the big screen 
Hash: SHA1
For a dramatic and touching story of hawala in use, see the current
film release "Premium Rush".
Lots of bicycle action, too, if you like that.

@_date: 2012-12-02 23:11:16
@_author: StealthMonger 
@_subject: Re: Fwd: [IP] Darn thing works  -- Application that provides   [Open]PGP for Webmail 
Hash: SHA1
Assuming the correspondents exchange keys out of band, this looks like
true end-to-end encryption, the keys residing on the users' respective
machines.  If so, server compromise can cause loss of service but no
confidentiality or authentication breach.
Please correct me if I'm wrong.  Otherwise, this looks like an
important new option for those who love their webmail, especially
after the Firefox version becomes available.

@_date: 2013-03-08 08:08:25
@_author: StealthMonger 
@_subject: Re: Summary of where we are right now 
Hash: SHA1
No.  If we had won, (a) new p2p acquaintances would be wary until they
had a opportunity to verify each other's keys out-of-band (having
already exchanged them on first meeting); (b) merchants would proudly
include the Key ID of their signing key in every web page, print ad,
letterhead, and customers would instinctively recognize verification
failure as the sign of an impostor; (c) banks would require customers
to identify themselves by Key ID; (d) Verisign and the other CAs would
no longer exist; (e) thinly disguized government agents like Ted Smith
would be scorned into insignificance.

@_date: 2013-04-06 23:31:16
@_author: StealthMonger 
@_subject: Re: [cryptography] ICIJ's project - comment on cryptography & tools 
Hash: SHA1
This is again the "world-class protracted human engineering",
mentioned before in this forum.  Kevin Wall goes on to describe some
of its manifestations.  It wouldn't be surprising if it's an
identified function within NSA, maybe even with its own department.

@_date: 2013-05-07 09:54:55
@_author: StealthMonger 
@_subject: US regulators eye Bitcoin supervision 
Hash: SHA1
US regulators eye Bitcoin supervision [1].  See also [2,3].  Sample:
     * Senior officials at a top U.S. financial regulator are
       discussing whether Bitcoin, the controversial cybercurrency,
       might fall under their regulatory remit.
     * Bitcoin "is for sure something we need to explore," Bart
       Chilton, one of the five commissioners at the Commodity Futures
       Trading Commission told the Financial Times.  A person familiar
       with the CFTC's thinking said that the regulator is "seriously"
       examining the issue.
Now the fun begins!  Enjoy the show!  Or better yet, be part of it!
[1] [2] [3]

@_date: 2015-05-01 12:45:42
@_author: StealthMonger 
@_subject: Sanitizing google search results 
Hash: SHA1
It used to be usually really easy [1] to sanitize google search results,
stripping off all the tracking and leaving the target URL.  For example,
would become
Now, more and more it seems, google search results are encoded in a less
obvious way.  Does anybody here know how they can be sanitized?
 -----
[1] sed 's,^

@_date: 2015-12-22 22:49:33
@_author: StealthMonger 
@_subject: Re: surveillance side effects - sometimes with thrill ride included! 
Hash: SHA1
I have  downloaded December
7 04:14 UT (18963087 bytes).  Are you interested?  sha256sum:

@_date: 2016-06-03 05:22:27
@_author: StealthMonger 
@_subject: Re: [tor-talk] Tor (and other nets) probably screwed by Traffic Analysis by now 
Hash: SHA1
This stuff has been in daily use since the last millennium.  The links
below are out of date but should get you started.
See usenet newsgroup alt.privacy,anon-server

@_date: 2017-01-16 23:55:41
@_author: StealthMonger 
@_subject: Re: Torproject disease infects WhatsApp - User experience trumps(sic) security 
Hash: SHA1
This message needs to be repeated, reaffirmed, and reaffirmed again --
in any forum where there might be a receptive reader.
Managing keys should be no more difficult than maintaining an address
book, which lots of people do all the time.
