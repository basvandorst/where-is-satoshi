
@_date: 2001-12-18 21:02:20
@_author: "Hari Gadi" 
@_subject: a question 
I have a small question regarding the use of NETLINK sockets. I have a
small character driver and  an application which to I want to send some
data using NETLINK sockets.
The questions I have are:
Can I use NETLINK functions from any character driver and to any
Below is the skeleton of my application.
Below is the skeleton of my application program (ioctl.c) which tries to
read data sent by
char_dev driver.
int kernelsock_open(void)
  int kernelfd;   kernelfd = open("/dev/char_dev",0);
  length=read(kernelfd,(char *)buffer,(sizeof(struct buffermsg);
(2) And the skeleton of my driver program is as shown below. (trying to add
netlink support to
 *  * Create an input/output character device
 */
int init_module()
  int ret_val;
  /* Register the character device (atleast try) */
  ret_val = register_chrdev(MAJOR_NUM,                                  DEVICE_NAME,
                                 &Fops);    sendnetlinkpacket();
  return 0;
void sendnetlinkpacket(void)
  struct  buffermsg *s;
  struct sk_buff *tmpskb;    tmpskb=alloc_skb((sizeof(struct buffermsg)),GFP_ATOMIC);
  if(tmpskb)
  skb_put(tmpskb,sizeof(struct buffermsg));
  s=(struct buffermsg *)tmpskb->data;
  s->version= 1;
  s->type=SADBM_ACQUIRE;
  if(sadb_netlink_post(NETLINK_FIREWALL,tmpskb))
  kfree_skb(tmpskb);
int sadb_netlink_post(int unit,struct sk_buff *skb)
  struct socket *socket1;    struct sock *sk=netlink_kernel_create(NETLINK_FIREWALL,NULL);
  socket1=  sk->socket;
  if(socket1)
  netlink_broadcast(socket1->sk,skb,0,~0,GFP_ATOMIC);
  return 0;
  return 1;
}/*static int sabd_netlink_post()*/
static int device_open(struct inode *inode,                        struct file *file)
  Device_Open++;
  /* Initialize the message */
  Message_Ptr = Message;
  MOD_INC_USE_COUNT;
  return SUCCESS;
static int device_release(struct inode *inode,                           struct file *file)
{   /* We're now ready for our next caller */
  Device_Open --;
  MOD_DEC_USE_COUNT;
 LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
  return 0;
static ssize_t device_read(
    struct file *file,
    char *buffer, /* The buffer to fill with the data */       size_t length,     /* The length of the buffer */
    loff_t *offset) /* offset to the file */
  /* Number of bytes actually written to the buffer */
  int bytes_read = 0;
  /* If we're at the end of the message, return 0    * (which signifies end of file) */
  if (*Message_Ptr == 0)
    return 0;
  /* Actually put the data into the buffer */
  while (length && *Message_Ptr)  {        put_user(*(Message_Ptr++), buffer++);
    length --;
    bytes_read ++;
  }
  return bytes_read;
static ssize_t device_write(struct file *file,
                            const char *buffer,
                            size_t length,
                            loff_t *offset)
  int i;
  for(i=0; i= KERNEL_VERSION(2,2,0)
    get_user(Message[i], buffer+i);
    Message[i] = get_user(buffer+i);
    Message_Ptr = Message;   return i;
int device_ioctl(
    struct inode *inode,
    struct file *file,
    unsigned int ioctl_num,/* The number of the ioctl */
    unsigned long ioctl_param) /* The parameter to it */
  int i;
  char *temp;
 LINUX_VERSION_CODE >= KERNEL_VERSION(2,2,0)
  char ch;
  /* Switch according to the ioctl called */
  switch (ioctl_num) {
    case IOCTL_SET_MSG:
       temp = (char *) ioctl_param;       get_user(ch, temp);
      for (i=0; ch && i= KERNEL_VERSION(2,2,0)
  NULL,  /* flush */
  device_release  /* a.k.a. close */
void cleanup_module()
  int ret;
  /* Unregister the device */
  ret = unregister_chrdev(MAJOR_NUM, DEVICE_NAME);
  /* If there's an error, report it */   if (ret < 0)
    printk("Error in module_unregister_chrdev: %d\n", ret);
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo
More majordomo info at  Please read the FAQ at
