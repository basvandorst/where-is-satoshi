
@_date: 2015-07-13 21:02:16
@_author: Alfonso De Gregorio 
@_subject: Re: Stealing Keys from PCs using a Radio 
While I was not born yet back then, less than twenty years later I
built such program, playing with control messages sent from the host
to the AT keyboard.

@_date: 2015-07-10 23:50:11
@_author: Alfonso De Gregorio 
@_subject: Re: From: root@hackingteam.it To: vince@hackingteam.it [and who?] 
Exactly. Just consider, for instance, the long "lineage" of
vulnerabilities affecting PCRE libraries.

@_date: 2015-08-19 22:30:58
@_author: Alfonso De Gregorio 
@_subject: Crypto policy is a presidential campaign issue 
"Crypto policy is a presidential campaign issue." -- Matt Blaze,
âIf you create encryption, it makes it harder for the American
government to do its jobâwhile protecting civil libertiesâto make sure
that evildoers arenât in our midst,â -- Jeb Bush,
Those damn communists commented:
"ÃbeltÃ¤ter und kryptographen aller LÃ¤nder, vereinigt euch!" -- Karl
Marx and Friedrich Engels on Crypto Wars II

@_date: 2015-09-07 14:01:16
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
It doesn't, as long as we don't confuse what is desirable -- and
indeed it is so -- with the practically and systematically attainable.
Or, to paraphrase Danny Strong, idealism loses to pragmatism when it
comes to engineering security.
I'm not even persuaded that writing a formal specifications gives us
always the ability to check the equivalence of implementations. As a
negative case in point, take languages/protocols and their parsers. A
grammar can be understood as a specification. Still, "arithmetically
checking the computational equivalence of parsers [...] is decidable
up to a level of computational power required to parse the language,
and becomes undecidable thereafter". [1]
All of which is to say that checking the computational equivalence of
parsers is still possible. But, as designers, in order to reconcile
the desirable with the practically attainable, we need to stick to the
simplest possible input languages (i.e., regular and context-free).
This is the kind of security trade-offs I was alluding to.
And this also links us to the other thread on browser security,
exploits, and Firefox.

@_date: 2015-09-07 12:07:14
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
The only hope to have a formal verification that extends also to
algebraic properties, is to start from formal specifications. A
top-down approach in stark contrast with the dynamic, agile, and
pragmatic "ship, then test" paradigm [1] and the "don't worry, be
crappy" mantra [2], repeated by entrepreneurs innovating the most.
We need better security trade-offs.

@_date: 2015-09-05 16:15:16
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
Yes, I did. The DSA PoC works again OpenSSL version 1.0.2d (snapshot).

@_date: 2015-09-05 15:40:24
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
I'm not aware of any implementation that fails to abort is q is composite.
As a case in point, OpenSSL versions implementing X9.42 DH
(1.0.2-Beta2 and above) test both p and q for primality:
int DH_check(const DH *dh, int *ret)
   /* ... */
    if (dh->q) {
        /* ... */
        if (!BN_is_prime_ex(dh->q, BN_prime_checks, ctx, NULL))
            *ret |= DH_CHECK_Q_NOT_PRIME;
    }
    if (!BN_is_prime_ex(dh->p, BN_prime_checks, ctx, NULL))
        *ret |= DH_CHECK_P_NOT_PRIME;
    else if (!dh->q) {
       /* ... */
    }
I have no evidence though that application built on OpenSSL call
DH_check() function every time they need to.

@_date: 2015-09-05 15:21:30
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
I'm confused. What do you mean by proper DH vs non-proper DH? Are you
referring to the performance of group parameters validation or lack of
the same, or something else?

@_date: 2015-09-05 14:41:51
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
I'm concerned with Fixed Diffie-Hellman implemented properly.

@_date: 2015-09-05 14:06:22
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
A key-recovery attack may allow the retroactive decryption of past
communication sessions, if the network endpoints rely on fixed
Diffie-Hellman. Of course, whenever an attacker can successfully mount
a MITM attack the current sessions are compromised.

@_date: 2015-09-05 13:41:23
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
While I sympathize with your point of view, and while I would welcome
a full equivalence of implementations, exclusivity of mandatory
requirements is neither a principle governing today's standardization
works, nor, sure enough, a principle that guided the standardization
of protocols back in the 1990s.
The key words defined in RFC 2119 reflect one one or any combinations
of the following:
  * A robustness principle, codified in the Postel's Law;
  * Economic interests at stake;
  * Understanding of the subject matter.
Today our community has finally reconsidered the principle that,
asking designers to "[b]e conservative in what [they] send, [but] be
liberal in what [they] accept", promised robustness on the internet.
But the incentives are still the same; interoperability and security
are always in tension.
It is worth to note that, yesterday as today, we need a better
understanding of the subject matter. It should have been obvious that
a validation of group parameters has security implications. And, just
like any and all security relevant requirements, it should have been
made a mandatory check.
I second Peter's recommendation; consider filing an erratum.

@_date: 2015-09-05 08:10:50
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
Correct. I have the same feeling. I hope further research will prove
both to be wrong about this.

@_date: 2015-09-05 07:41:11
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
Sure, the questions are: What is the origin of the current wording of
the standard, that opens an avenue for lax checks for group
parameters? Or, if, as you correctly pointed out, an implementation
MAY NOT check group parameters, which entity deserves credit for it?
Interestingly, a review of revisions (using rfcdiff) shows that the
current wording was introduced in draft  of draft-ietf-smime-x942
This is dated October 1998. Yet, it is still not clear if the diff is
to be attributed to Rescorla, or any other contributor to the this
standardization effort.

@_date: 2015-09-05 06:37:09
@_author: Alfonso De Gregorio 
@_subject: Re: Possible crypto backdoor in RFC-2631 Diffie-Hellman Key Agreement Method 
just a quick note to thank you for sharing your research and taking
time to verify your findings against OpenSSL.
I've been researching cryptographic backdoors -- you may want to
review this  -- and the lack of checks on group
parameters, malicious or otherwise (*), is to me yet another cause for
concern. Great catch!
(*) It would be interesting to look at the story of RFC-2631, as
Bernstein, Lange, and Niederhagen did for the Dual EC standard

@_date: 2015-09-06 17:44:58
@_author: Alfonso De Gregorio 
@_subject: =?UTF-8?Q?Re=3A_Hackers_spent_at_least_a_year_spying_on_Mozilla_?= =?UTF-8?Q?to_discover_Firefox_sec 
It made me reconsider the true meaning of [XXXXXXXXXXX] to read about
[XXXXXXXXXXX] and, especially, [XXXXXXXXXXX].
More seriously: After years of fierce debate, vulnerability disclosure
is still looking for a convincing answer. The NSA may contribute its
substantial share to discussion --- albeit less to the practice --- of
vulnerability disclosure. Needless to say, it would have been more
helpful to read a less heavily redacted 'Vulnerabilities Equities
Policy and Process' to this end.
On September 29, NTIA will convene a meeting on this topic. For those
considering to attend it
Will we never stop from drinking from the (endless?) stream of
exploitable vulnerabilities?

@_date: 2015-09-05 15:48:48
@_author: Alfonso De Gregorio 
@_subject: =?UTF-8?Q?Re=3A_Hackers_spent_at_least_a_year_spying_on_Mozilla_?= =?UTF-8?Q?to_discover_Firefox_sec 
Yesterday Mudge highlighted on Twitter
 :
  1990's CERT compromised for vendor vulns.
  2015 Mozilla's Bugzilla popped for the same reason.
  Tactics only change when they stop working.
Which is quite true. Therefore, I ask vulnerability sellers: How
effective your favorite exploit acquisition platform / program is at
preventing this from happening again?

@_date: 2016-09-28 10:40:57
@_author: Alfonso De Gregorio 
@_subject: Re: Two distinct DSA keys sign a file with the same signature. Is this repudiation issue? 
If you are able to generate colliding signatures for a target (chosen) key,
this may amount to an impersonation attack, depending on the exact
origin authentication checks -- which may be considered even worse
than a repudiation issue.
If what you can do is to generate two new key pairs, where the
signatures made by first can be verified as signed by the second (or
viceversa), then this provides plausible deniability, and the
possibility to repudiate any valid signature made by any of the
affected signing keys.
