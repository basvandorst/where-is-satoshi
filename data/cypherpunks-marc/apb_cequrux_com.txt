
@_date: 2002-01-22 09:25:49
@_author: Alan Barrett 
@_subject: Re: password-cracking by journalists... 
When I last brought this up (29 to 30 July 2001, Subject: Effective
and ineffective technological measures), people posted references to
two slightly different sections that try to define what "effectively
protects" and "effectively controls" means:
1201(b)(2)(B): a technological measure ''effectively protects a right of
    a copyright owner under this title'' if the measure, in the ordinary
    course of its operation, prevents, restricts, or otherwise limits
    the exercise of a right of a copyright owner under this title.
1201(a)(3)(B): a technological measure ''effectively controls access to
    a work'' if the measure, in the ordinary course of its operation,
    requires the application of information, or a process or a
    treatment, with the authority of the copyright owner, to gain access
    to the work.'
The key phrase seems to be "in the ordinary course of its operation".
If you publish the fact that you use rot to protect your copyrighted
material, but keep secret the fact that n = 13, then the ordinary course
of operation of the decryption process requires the application of
this secret value, so the process "effectively controls access" and
"effectively protects".  The fact that somebody can guess the secret
value would seem to have no bearing on whether rot "effectively" does
--apb (Alan Barrett)

@_date: 2002-11-08 08:58:32
@_author: Alan Barrett 
@_subject: Re: Did you *really* zeroize that key? 
No crypto here, just C language lawyering.
It certainly appears to be guaranteed by my reading of the c89 and c99
standards.  See below for citations.
I don't believe this, unless you have citations to sections in the
Yes, sure.
I strongly disagree. The whole point of the volatile qualifier is to
tell the compiler that external things that it doesn't know about might
read and write the value behind its back, and that the sequence of reads
and writes done by the program are important.
The c89 standard was not quite as clear as c99, but c99 says:
        Accessing a volatile object, modifying an object, modifying a
        file, or calling a function that does any of those operations are
        all side effects, which are changes in the state of the execution
        environment.  [ISO/IEC 9899:1999 section 5.1.2.2.3 paragraph 2]
        In the abstract machine, all expressions are evaluated as
        specified by the semantics. An actual implementation need
        not evaluate part of an expression if it can deduce that its
        value is not used and that no needed side effects are produced
        (including any caused by calling a function or accessing a
        volatile object).  [ISO/IEC 9899:1999 section 5.1.2.3 paragraph 3]
        An object that has volatile-qualified type may be modified
        in ways unknown to the implementation or have other unknown
        side effects.  Therefore any expression referring to such an
        object shall be evaluated strictly according to the rules of the
        abstract machine, as described in 5.1.2.3.  [ISO/IEC 9899:1999
        section 6.7.3 paragraph 6]
Section 5.1.2.3 gives implementations permission to optimise, but only
if no needed side effects are produced.  Section 5.1.2.2.3 says that
accessing a volatile object is a side effect.  Section 6.7.3 says that
external factors unknown to the implementation might depend on accesses
to volatile objects.  Unfortunately, I can't find a definition of a
"needed" side effect, as opposed to an un-needed side effect, but I
think the overall intent is clear, and I think that the parenthetical
phrase in section 5.1.2.3 implies that accessing a volatile object is
a "needed" side effect.
The C++ standard makes the intended meanting of the volatile qualifier
even more clear by adding words like "The observable behavior of the
abstract machine is its sequence of reads and writes to volatile data
and calls to library I/O functions."  [ISO/IEC 14882:1998 section 1.9
paragraph 6]
An interesting argument.  But I claim that there's no way for an
implementation to know whether the program is running/will run in
emulated hardware rather than real hardware, nor whether or not a logic
alalyser is/will be attached to the bus.  Logic analysers and hardware
emulators would allow the accesses to volatile storage to be observed,
and the implementation would have to ensure that the observations
matched the behaviour intended by (the orthodox interpretation of) the
volatile qualifier.
True.  But any compiler that tried to use such arguments to weasel out
of the requirement to handle volatile in the expected way would become
Declaring the buffer as volatile would remove the compiler's licence to
do such optimisation.
--apb (Alan Barrett)

@_date: 2004-06-27 13:23:14
@_author: Alan Barrett 
@_subject: Re: For Liars and Loafers, Cellphones Offer an Alibi 
At least with GSM, the base station always knows the approximate
distance to the phone (this is needed by the GSM protocol, for reasons
related to time slot management in the presence of finite speed of
light, but it might be possible to hack the phone's firmware to fool it,
or to register with fewer base stations than usual).  The GSM network's
database knows the exact locations of all the base stations.  Add a
little software to do triangulation from multiple base stations, and the
GSM network knows the location of the phone, to an accuracy that depends
chiefly on the base station density.  Add a layer of user interface
software, and you're done.  No cooperation from the phone is necessary,
except what the phone would normally do in order to register itself with
base stations so that it can receive calls.  No GPS or other non-GSM
protocols are necessary.
This is already offered as an extra cost service (branded "Look for me")
by Vodacom in South Africa.  It's targeted at parents who want to know
where their children are, and the phrase "with their permission" is
included in current advertising.  As the seeker, you send an SMS (text
message) to a special number to "register" your phone as a user of the
locator service, and to ask for the location of another phone.  The
network sends a message to the target phone, and the user must reply to
give permission to be located.  Then the network sends a text message
to the seeker, telling them the location of the target.  I don't know
whether the target's permission is asked every time, or just once per
seeker; I do know that it's not just once globally.  In any case, the
"permission" is just a flag in a database, and is not really needed by
anybody with back-door access to the GSM provider.
--apb (Alan Barrett)

@_date: 2004-10-23 20:21:23
@_author: Alan Barrett 
@_subject: Re: Financial identity is *dangerous*? (was re: Fake companies, real money) 
The risks of using *somebody else's keypad* to type passwords or
instructions to your smartcard, or using *somebody else's display* to
view output that is intended to be private, should be obvious.
--apb (Alan Barrett)

@_date: 2004-10-13 08:38:30
@_author: Alan Barrett 
@_subject: Re: Cash, Credit -- or Prints? 
... or a replacement reader that fakes the signals to the rest of the
security system.
--apb (Alan Barrett)

@_date: 2008-02-20 19:29:19
@_author: Alan Barrett 
@_subject: Re: uniform pseudo random number generation 
This equivelent to shuffling a deck of 361 cards.  Wikipedia has a good
article: --apb (Alan Barrett)
