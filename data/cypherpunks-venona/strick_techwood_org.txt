
@_date: 1994-12-12 12:23:23
@_author: RFC934 
@_subject: (RFC934) Re: extra dashes in PGP-related blocks? 
THUS SPAKE jrochkin (Jonathan Rochkind):
# # Does anyone know what it is that's putting in these "- "s, why it's putting
# them in, and how to stop it?
They're part of RFC934 and they are the correct standard way to encapsulate messages inside messages, short of using MIME.
Many mailers produce & handle these correctly.  The extra "- " are due to "Character-Stuffing the Encapsulation Boundary".
What you&we need is filters to extract encapsulations that unstuff
nested encapsulations.
Relevant excerpt from RFC934 follows.    --strick
Network Working Group                        Marshall T. Rose (Delaware)
Request for Comments: 934                       Einar A. Stefferud (NMA)
                                                            January 1985
              Proposed Standard for Message Encapsulation
  ...
Message Encapsulation
  ...
   Definitions: a draft forwarding message consists of a header portion
   and a text portion.  If the text portion is present, it is separated
   from the header portion by a blank line.  Inside the text portion a
   certain character string sequence, known as an "encapsulation
   boundary", has special meaning.  Currently (in existing
   digestification agents), an encapsulation boundary (EB) is defined as
   a line in the message which starts with a dash (decimal code 45,
   "-").  Initially, no restriction is placed on the length of the
   encapsulation boundary, or on the characters that follow the dash.
  ...
      2.3. Encapsulated Messages
      Each encapsulated message is bounded by two EBs: a pre-EB, which
      occurs before the message; and, a post-EB, which occurs after the
      message.  For two adjacent encapsulated messages, the post-EB of
      the first message is also the pre-EB of the second message.
      Consistent with this, two adjacent EBs with nothing between them
      should be treated as enclosing a null message, and thus two or
      more adjacent EBs are equivalent to one EB.
  ...
Character-Stuffing the Encapsulation Boundary
   It should be noted that the protocol is general enough to support
   both general forwarding of messages and the specific case of digests.
   Unfortunately, there is one issue of message encapsulation which
   apparently is not addressed by any forwarding agent (to the authors'
   knowledge) in the ARPA-Internet: what action does the forwarding
   agent take when the encapsulation boundary occurs within a the text
   portion of a message being forwarded?  Without exception, this
   circumstance is ignored by existing forwarding agents.
   To address this issue, this memo proposes the following
   character-stuffing scheme: the encapsulation boundary is defined as a
   line which starts with a dash.  A special case is made for those
   boundaries which start with a dash and are followed by a space
   (decimal code 32, " ").
      During forwarding, if the forwarding agent detects a line in the
      text portion of a message being forwarded which starts with the
      encapsulation boundary, the forwarding agent outputs a dash
      followed by a space prior to outputting the line.
      During bursting, if the bursting agent detects an encapsulation
      boundary which starts with a dash followed by a space, then the
      bursting agent does not treat the line as an encapsulation
      boundary, and outputs the remainder of the line instead.
   This simple character-stuffing scheme permits recursive forwardings.
  ...
  strick <...!{ihnp4,akgua,allegra,gatech}!techwood.org!strick>
  echo '[q]sa[ln0=aln256%Pln256/snlbx]sb3135071790101768542287578439snlbxq'|dc
                                           --keithv

@_date: 1995-02-07 15:54:09
@_author: 694 characters\ 
@_subject: noiz-0.5: simple noise-emitting package 
noiz -- a simple package for accumulating and dispensing
                cryptographically-strong noise, using MD5 as
                a stirring function
I'm interested in someone pointing out serious errors in my
algorithm or the implementation.  See particularly the ALGORITHM section at the end of "noiz.doc".
I believe this will meet Tim May's standards for practical entropy,
but probably not Matt Blaze's high standards.
It allows users to decide how much true entropy they require, and lets
them share entropy with each other if they want.  Crunching with MD5
obscures where the randomness came from.  The "noizout" command
produces 128 high-entropy bits in a split second, and can be repeated
for more, although it is theoretically better to add entropy to the pool
every time you take some out.  But I personally use a crontab that adds
a few bits every minute, and rely on the crunching to hide correlations.
p.s.  	I will be in chicago this weekend,
MAKE A DIRECTORY NAMED "noiz-0.5" and unshar it there.
This works on SunOS and probably on almost any unix platform
with minor tweaks to the Makefile.
 /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh 'README' <<'END_OF_FILE'
X	noiz -- a simple package for accumulating and dispensing
X		cryptographically-strong noise, using MD5 as X		a stirring function
X	Anticopyright (A) 1995 Henry Strickland X	This package is placed this package in the public domain.
X	Because this package is free, there is no warranty X	for it whatsoever.  Caveat hacker.
X	This is alpha-quality software.  It seemed to work for
X	me, but it may not do what I say it does.
X	The MD5 implementation is by Colin Plumb (1993), X	and is also in the public domain.
XSee "noiz.doc" for more information.
XEND $Header: /mvp/fjord/strick/yaxen/noiz-0.5/RCS/README,v 1.1 95/02/07 14:55:59 strick Exp Locker: strick $
if test 694 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
# end of 'README'
if test -f 'Makefile' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'Makefile'\"
echo shar: Extracting \"'Makefile'\" \(1904 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X  noiz/Makefile
X#       Anticopyright (A) 1995 Henry Strickland X#       This package is placed this package in the public domain.
X#       Because this package is free, there is no warranty
X#       for it whatsoever.  Caveat hacker.
X#       This file Makefile is dedicated to the ascii	TAB	character.
XCC= gcc
XCFLAGS= -O -D'NOIZ_FILE="$(NOIZ)"'
Xall : noizinit noizstir noizout noizspin
Xnoizstir : noizstir.o md5.o X	$(CC) -o noizstir $(CFLAGS) noizstir.o md5.o
Xnoizout : noizout.o md5.o X	$(CC) -o noizout $(CFLAGS) noizout.o md5.o
X	rm -f *.o
X	rm -f noizinit noizstir noizout noizspin
X	rm -f a.out core
Xinstall: all
X	test -d $(BIN) || mkdir $(BIN)
X	strip noizinit noizout noizstir noizspin
X	install -o $(OWNER) -g $(GROUP) -m  550 noizinit $(BIN)
X	install -o $(OWNER) -g $(GROUP) -m 2555 noizstir $(BIN)
X	install -o $(OWNER) -g $(GROUP) -m 2555 noizout $(BIN)
X	install -o $(OWNER) -g $(GROUP) -m  555 noizspin $(BIN)
X	$(BIN)/noizinit
X	chown $(OWNER) $(NOIZ)
X	chgrp $(GROUP) $(NOIZ)
X	chmod 660 $(NOIZ)
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	ls -li / /var/adm/ | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	netstat -s | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	$(BIN)/noizspin | $(BIN)/noizstir
X	:
X	:
X	: Suggestion for your crontab:
X	:   "* * * * * $(BIN)/noizspin | $(BIN)/noizstir"
X	:
X# END $Header: /mvp/fjord/strick/yaxen/noiz-0.5/RCS/Makefile,v 1.6 95/02/07 15:35:36 strick Exp Locker: strick $
if test 1904 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
# end of 'Makefile'
if test -f 'md5.c' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'md5.c'\"
echo shar: Extracting \"'md5.c'\" \(7656 characters\)
sed "s/^X//" >'md5.c' <<'END_OF_FILE'
X * This code implements the MD5 message-digest algorithm.
X * The algorithm is due to Ron Rivest.  This code was
X * written by Colin Plumb in 1993, no copyright is claimed.
X * This code is in the public domain; do with it what you wish.
X *
X * Equivalent code is available from RSA Data Security, Inc.
X * This code has been tested against that, and is equivalent,
X * except that you don't need to include two pages of legalese
X * with every copy.
X *
X * To compute the message digest of a chunk of bytes, declare an
X * MD5Context structure, pass it to MD5Init, call MD5Update as
X * needed on buffers full of bytes, and then call MD5Final, which
X * will fill a supplied 16-byte array with the digest.
X */
X 	/* for memcpy() */
X "md5.h"
X HIGHFIRST
X byteReverse(buf, len)	/* Nothing */
Xvoid byteReverse(unsigned char *buf, unsigned longs);
X ASM_MD5
X * Note: this code is harmless on little-endian machines.
X */
Xvoid byteReverse(unsigned char *buf, unsigned longs)
X	uint32 t;
X	do {
X		t = (uint32)((unsigned)buf[3]<<8 | buf[2]) << 16 |
X		            ((unsigned)buf[1]<<8 | buf[0]);
X		*(uint32 *)buf = t;
X		buf += 4;
X	} while (--longs);
X * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
X * initialization constants.
X */
XMD5Init(struct MD5Context *ctx)
X	ctx->buf[0] = 0x67452301;
X	ctx->buf[1] = 0xefcdab89;
X	ctx->buf[2] = 0x98badcfe;
X	ctx->buf[3] = 0x10325476;
X	ctx->bits[0] = 0;
X	ctx->bits[1] = 0;
X * Update context to reflect the concatenation of another buffer full
X * of bytes.
X */
XMD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
X	uint32 t;
X	/* Update bitcount */
X	t = ctx->bits[0];
X	if ((ctx->bits[0] = t + ((uint32)len << 3)) < t)
X		ctx->bits[1]++;	/* Carry from low to high */
X	ctx->bits[1] += len >> 29;
X	t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */
X	/* Handle any leading odd-sized chunks */
X	if ( t ) {
X		unsigned char *p = (unsigned char *)ctx->in + t;
X		t = 64-t;
X		if (len < t) {
X			memcpy(p, buf, len);
X			return;
X		}
X		memcpy(p, buf, t);
X		byteReverse(ctx->in, 16);
X		MD5Transform(ctx->buf, (uint32 *)ctx->in);
X		buf += t;
X		len -= t;
X	}
X	/* Process data in 64-byte chunks */
X	while (len >= 64) {
X		memcpy(ctx->in, buf, 64);
X		byteReverse(ctx->in, 16);
X		MD5Transform(ctx->buf, (uint32 *)ctx->in);
X		buf += 64;
X		len -= 64;
X	}
X	/* Handle any remaining bytes of data. */
X	memcpy(ctx->in, buf, len);
X * Final wrapup - pad to 64-byte boundary with the bit pattern X * 1 0* (64-bit count of bits processed, MSB-first)
X */
XMD5Final(unsigned char digest[16], struct MD5Context *ctx)
X	unsigned count;
X	unsigned char *p;
X	/* Compute number of bytes mod 64 */
X	count = (ctx->bits[0] >> 3) & 0x3F;
X	/* Set the first char of padding to 0x80.  This is safe since there is
X	   always at least one byte free */
X	p = ctx->in + count;
X	*p++ = 0x80;
X	/* Bytes of padding needed to make 64 bytes */
X	count = 64 - 1 - count;
X	/* Pad out to 56 mod 64 */
X	if (count < 8) {
X		/* Two lots of padding:  Pad the first block to 64 bytes */
X		memset(p, 0, count);
X		byteReverse(ctx->in, 16);
X		MD5Transform(ctx->buf, (uint32 *)ctx->in);
X		/* Now fill the next block with 56 bytes */
X		memset(ctx->in, 0, 56);
X	} else {
X		/* Pad block to 56 bytes */
X		memset(p, 0, count-8);
X	}
X	byteReverse(ctx->in, 14);
X	/* Append length in bits and transform */
X	((uint32 *)ctx->in)[ 14 ] = ctx->bits[0];
X	((uint32 *)ctx->in)[ 15 ] = ctx->bits[1];
X	MD5Transform(ctx->buf, (uint32 *)ctx->in);
X	byteReverse((unsigned char *)ctx->buf, 4);
X	memcpy(digest, ctx->buf, 16);
X	memset(ctx, 0, sizeof(ctx));	/* In case it's sensitive */
X ASM_MD5
X/* The four core functions - F1 is optimized somewhat */
X/*  F1(x, y, z) (x & y | ~x & z) */
X F1(x, y, z) (z ^ (x & (y ^ z)))
X F2(x, y, z) F1(z, x, y)
X F3(x, y, z) (x ^ y ^ z)
X F4(x, y, z) (y ^ (x | ~z))
X/* This is the central step in the MD5 algorithm. */
X MD5STEP(f, w, x, y, z, data, s) \
X	( w += f(x, y, z) + data,  w = w<>(32-s),  w += x )
X * The core of the MD5 algorithm, this alters an existing MD5 hash to
X * reflect the addition of 16 longwords of new data.  MD5Update blocks
X * the data and converts bytes into longwords for this routine.
X */
XMD5Transform(uint32 buf[4], uint32 const in[16])
X	register uint32 a, b, c, d;
X	a = buf[0];
X	b = buf[1];
X	c = buf[2];
X	d = buf[3];
X	MD5STEP(F1, a, b, c, d, in[ 0]+0xd76aa478,  7);
X	MD5STEP(F1, d, a, b, c, in[ 1]+0xe8c7b756, 12);
X	MD5STEP(F1, c, d, a, b, in[ 2]+0x242070db, 17);
X	MD5STEP(F1, b, c, d, a, in[ 3]+0xc1bdceee, 22);
X	MD5STEP(F1, a, b, c, d, in[ 4]+0xf57c0faf,  7);
X	MD5STEP(F1, d, a, b, c, in[ 5]+0x4787c62a, 12);
X	MD5STEP(F1, c, d, a, b, in[ 6]+0xa8304613, 17);
X	MD5STEP(F1, b, c, d, a, in[ 7]+0xfd469501, 22);
X	MD5STEP(F1, a, b, c, d, in[ 8]+0x698098d8,  7);
X	MD5STEP(F1, d, a, b, c, in[ 9]+0x8b44f7af, 12);
X	MD5STEP(F1, c, d, a, b, in[10]+0xffff5bb1, 17);
X	MD5STEP(F1, b, c, d, a, in[11]+0x895cd7be, 22);
X	MD5STEP(F1, a, b, c, d, in[12]+0x6b901122,  7);
X	MD5STEP(F1, d, a, b, c, in[13]+0xfd987193, 12);
X	MD5STEP(F1, c, d, a, b, in[14]+0xa679438e, 17);
X	MD5STEP(F1, b, c, d, a, in[15]+0x49b40821, 22);
X	MD5STEP(F2, a, b, c, d, in[ 1]+0xf61e2562,  5);
X	MD5STEP(F2, d, a, b, c, in[ 6]+0xc040b340,  9);
X	MD5STEP(F2, c, d, a, b, in[11]+0x265e5a51, 14);
X	MD5STEP(F2, b, c, d, a, in[ 0]+0xe9b6c7aa, 20);
X	MD5STEP(F2, a, b, c, d, in[ 5]+0xd62f105d,  5);
X	MD5STEP(F2, d, a, b, c, in[10]+0x02441453,  9);
X	MD5STEP(F2, c, d, a, b, in[15]+0xd8a1e681, 14);
X	MD5STEP(F2, b, c, d, a, in[ 4]+0xe7d3fbc8, 20);
X	MD5STEP(F2, a, b, c, d, in[ 9]+0x21e1cde6,  5);
X	MD5STEP(F2, d, a, b, c, in[14]+0xc33707d6,  9);
X	MD5STEP(F2, c, d, a, b, in[ 3]+0xf4d50d87, 14);
X	MD5STEP(F2, b, c, d, a, in[ 8]+0x455a14ed, 20);
X	MD5STEP(F2, a, b, c, d, in[13]+0xa9e3e905,  5);
X	MD5STEP(F2, d, a, b, c, in[ 2]+0xfcefa3f8,  9);
X	MD5STEP(F2, c, d, a, b, in[ 7]+0x676f02d9, 14);
X	MD5STEP(F2, b, c, d, a, in[12]+0x8d2a4c8a, 20);
X	MD5STEP(F3, a, b, c, d, in[ 5]+0xfffa3942,  4);
X	MD5STEP(F3, d, a, b, c, in[ 8]+0x8771f681, 11);
X	MD5STEP(F3, c, d, a, b, in[11]+0x6d9d6122, 16);
X	MD5STEP(F3, b, c, d, a, in[14]+0xfde5380c, 23);
X	MD5STEP(F3, a, b, c, d, in[ 1]+0xa4beea44,  4);
X	MD5STEP(F3, d, a, b, c, in[ 4]+0x4bdecfa9, 11);
X	MD5STEP(F3, c, d, a, b, in[ 7]+0xf6bb4b60, 16);
X	MD5STEP(F3, b, c, d, a, in[10]+0xbebfbc70, 23);
X	MD5STEP(F3, a, b, c, d, in[13]+0x289b7ec6,  4);
X	MD5STEP(F3, d, a, b, c, in[ 0]+0xeaa127fa, 11);
X	MD5STEP(F3, c, d, a, b, in[ 3]+0xd4ef3085, 16);
X	MD5STEP(F3, b, c, d, a, in[ 6]+0x04881d05, 23);
X	MD5STEP(F3, a, b, c, d, in[ 9]+0xd9d4d039,  4);
X	MD5STEP(F3, d, a, b, c, in[12]+0xe6db99e5, 11);
X	MD5STEP(F3, c, d, a, b, in[15]+0x1fa27cf8, 16);
X	MD5STEP(F3, b, c, d, a, in[ 2]+0xc4ac5665, 23);
X	MD5STEP(F4, a, b, c, d, in[ 0]+0xf4292244,  6);
X	MD5STEP(F4, d, a, b, c, in[ 7]+0x432aff97, 10);
X	MD5STEP(F4, c, d, a, b, in[14]+0xab9423a7, 15);
X	MD5STEP(F4, b, c, d, a, in[ 5]+0xfc93a039, 21);
X	MD5STEP(F4, a, b, c, d, in[12]+0x655b59c3,  6);
X	MD5STEP(F4, d, a, b, c, in[ 3]+0x8f0ccc92, 10);
X	MD5STEP(F4, c, d, a, b, in[10]+0xffeff47d, 15);
X	MD5STEP(F4, b, c, d, a, in[ 1]+0x85845dd1, 21);
X	MD5STEP(F4, a, b, c, d, in[ 8]+0x6fa87e4f,  6);
X	MD5STEP(F4, d, a, b, c, in[15]+0xfe2ce6e0, 10);
X	MD5STEP(F4, c, d, a, b, in[ 6]+0xa3014314, 15);
X	MD5STEP(F4, b, c, d, a, in[13]+0x4e0811a1, 21);
X	MD5STEP(F4, a, b, c, d, in[ 4]+0xf7537e82,  6);
X	MD5STEP(F4, d, a, b, c, in[11]+0xbd3af235, 10);
X	MD5STEP(F4, c, d, a, b, in[ 2]+0x2ad7d2bb, 15);
X	MD5STEP(F4, b, c, d, a, in[ 9]+0xeb86d391, 21);
X	buf[0] += a;
X	buf[1] += b;
X	buf[2] += c;
X	buf[3] += d;
if test 7656 -ne `wc -c <'md5.c'`; then
    echo shar: \"'md5.c'\" unpacked with wrong size!
# end of 'md5.c'
if test -f 'md5.h' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'md5.h'\"
echo shar: Extracting \"'md5.h'\" \(519 characters\)
sed "s/^X//" >'md5.h' <<'END_OF_FILE'
X MD5_H
X MD5_H
Xtypedef unsigned long uint32;
Xstruct MD5Context {
X	uint32 buf[4];
X	uint32 bits[2];
X	unsigned char in[64];
Xvoid MD5Init(struct MD5Context *context);
Xvoid MD5Update(struct MD5Context *context, unsigned char const *buf, unsigned len);
Xvoid MD5Final(unsigned char digest[16], struct MD5Context *context);
Xvoid MD5Transform(uint32 buf[4], uint32 const in[16]);
X * This is needed to make RSAREF happy on some MS-DOS compilers.
X */
Xtypedef struct MD5Context MD5_CTX;
X /* !MD5_H */
if test 519 -ne `wc -c <'md5.h'`; then
    echo shar: \"'md5.h'\" unpacked with wrong size!
# end of 'md5.h'
if test -f 'mkshar' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'mkshar'\"
echo shar: Extracting \"'mkshar'\" \(76 characters\)
sed "s/^X//" >'mkshar' <<'END_OF_FILE'
Xset -x
Xmake clean
Xrm -f .shar
Xshar README Makefile [a-z]* > .shar
if test 76 -ne `wc -c <'mkshar'`; then
    echo shar: \"'mkshar'\" unpacked with wrong size!
# end of 'mkshar'
if test -f 'noiz.doc' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'noiz.doc'\"
echo shar: Extracting \"'noiz.doc'\" \(9532 characters\)
sed "s/^X//" >'noiz.doc' <<'END_OF_FILE'
X	noiz -- a simple package for accumulating and dispensing
X		cryptographically-strong noise, using MD5 as X		a stirring function
X	Anticopyright (A) 1995 Henry Strickland X	This package is placed this package in the public domain.
X	Because this package is free, there is no warranty X	for it whatsoever.  Caveat hacker.
X	This is alpha-quality software.  It seemed to work for
X	me, but it may not do what I say it does.
X	The MD5 implementation is by Colin Plumb (1993), X	and is also in the public domain.
X	noizinit
X		creates the file /etc/noiz
X	noizstir < noise-source
X		stirs the noise-source into /etc/noiz
X	noizout < noise-source > output-noise
X		produces 16 bytes of noise, for applications to use
X	noizspin > output-time
X		prints a somewhat-random number, with several bits of
X		entropy.
X	/etc/noiz       a binary file containing 256 bytes of noise
X			state.   That's 2048 bits of entropy, assuming
X			it has been stirred with that much entropy.
X	noizinit        creates /etc/noiz and initializes it with bytes
X			0, 1, 2, 3, ... 255.
X			It must be stirred several times with noizstir
X			before it is ready to be used by noizout.
X	noizspin        Set an alarm for 1 second.  Using an unsigned
X			long, count until the alarm is received, and
X			print the count, in ascii, as a decimal number,
X			followed by a newline.
X	noizstir        changes the noise ("stirs" it) in /etc/noiz,
X			based on prior contents of /etc/noiz, current
X			time, pid, ppid, and input bytes read from
X			standard input.
X			The standard input may be empty (as in
X				noizstir < /dev/null
X			) or may be some system-generated noise (as in
X				ps uaxg | noizstir
X				ls -li /tmp/ | noizstir
X				netstat -s | noizstir
X			) or you may use the "noizspin" command which
X			was designed especially for this purpose:
X				noizspin | noizstir
X	noizout         Produces 16 bytes of random noise, based on the
X			contents of /etc/noiz, current time, pid, ppid,
X			and input bytes read from standard input.   The
X			output is 16 raw binary bytes; if you want some
X			kind of ascii encoding, you must convert the
X			output.  Piping the output into "od -x" is
X			useful for debugging.
X			Unlike noizstir, noizout does not change
X			/etc/noiz.  You may use it without empty
X			standard input, but it is better to feed it
X			some extra noise.  The noizspin command is good
X			for this:
X				noizspin | noizout X			The bytes emitted from noizout do not reveal
X			the contents of /etc/noiz.  In fact, no command
X			does, so all users can share /etc/noiz.
X			Because noizout always stirs current time, pid,
X			and ppid into its output, even this command,
X			repeated many times without running noizstir,
X			will generate fairly high-entropy random
X			output:
X				noizout < /dev/null
X				
X	All four programs print one line to stderr and exit with a
X	nonzero status if they cannot read or write /etc/noiz and they
X	need to.
X	Otherwise the programs execute without writing to stdout, and
X	they exit with status zero.
XRECOMMENDED INSTALLATION
X	You should probably be root to do the "make install".  You may
X	use "make BIN=/etc install" to put the four binaries into the
X	/etc/ directory instead of /usr/local/bin/.
X	/etc/noiz	owner root X			group kmem
X			mode 660     (not publically readable or writable)
X	/usr/local/bin/noizinit
X			owner root
X			group kmem
X			mode 550	(no special permissions)
X					(only execute at install time)
X	/usr/local/bin/noizstir
X			owner root
X			group kmem
X			mode 2555	(setgid kmem)
X					(anyone can execute)
X	/usr/local/bin/noizout
X			owner root
X			group kmem
X			mode 2555	(setgid kmem)
X					(anyone can execute)
X	/usr/local/bin/noizspin
X			owner root
X			group kmem
X			mode 555	(no special permissions)
X					(anyone can execute)
X	For your crontab:
X		* * * * * /usr/local/bin/noizspin | /usr/local/bin/noizstir
X		This will stir the /etc/noiz with a few bits of noise
X		per minute.
X		You may put it in the crontab for root, or for daemon,
X		or users themselves may do it.
XEXAMPLE SESSION
X		gwarn#
Xinitialize	gwarn#
X/etc/noiz	gwarn#
X		gwarn#
X		gwarn# /usr/local/bin/noizinit
Xshow initial	gwarn#
Xcontents 	gwarn#
X		gwarn# od -x /etc/noiz
X		0000000  0001 0203 0405 0607 0809 0a0b 0c0d 0e0f
X		0000020  1011 1213 1415 1617 1819 1a1b 1c1d 1e1f
X		0000040  2021 2223 2425 2627 2829 2a2b 2c2d 2e2f
X		0000060  3031 3233 3435 3637 3839 3a3b 3c3d 3e3f
X		0000100  4041 4243 4445 4647 4849 4a4b 4c4d 4e4f
X		0000120  5051 5253 5455 5657 5859 5a5b 5c5d 5e5f
X		0000140  6061 6263 6465 6667 6869 6a6b 6c6d 6e6f
X		0000160  7071 7273 7475 7677 7879 7a7b 7c7d 7e7f
X		0000200  8081 8283 8485 8687 8889 8a8b 8c8d 8e8f
X		0000220  9091 9293 9495 9697 9899 9a9b 9c9d 9e9f
X		0000240  a0a1 a2a3 a4a5 a6a7 a8a9 aaab acad aeaf
X		0000260  b0b1 b2b3 b4b5 b6b7 b8b9 babb bcbd bebf
X		0000300  c0c1 c2c3 c4c5 c6c7 c8c9 cacb cccd cecf
X		0000320  d0d1 d2d3 d4d5 d6d7 d8d9 dadb dcdd dedf
X		0000340  e0e1 e2e3 e4e5 e6e7 e8e9 eaeb eced eeef
X		0000360  f0f1 f2f3 f4f5 f6f7 f8f9 fafb fcfd feff
X		0000400
X		gwarn#
Xspin some 	gwarn#
Xrandom numbers	gwarn#
Xwith noizspin	gwarn#
X		gwarn# noizspin
X		3082293
X		gwarn# noizspin
X		3025490
X		gwarn# noizspin
X		3077496
X		gwarn# noizspin
X		2985100
X		gwarn# noizspin
X		3047690
X		gwarn# noizspin
X		3082529
X		gwarn# noizspin
X		3063415
X/etc/noiz	gwarn#
Xis unchanged	gwarn#
Xuntil stirred	gwarn#
X		gwarn# od -x /etc/noiz
X		0000000  0001 0203 0405 0607 0809 0a0b 0c0d 0e0f
X		0000020  1011 1213 1415 1617 1819 1a1b 1c1d 1e1f
X		0000040  2021 2223 2425 2627 2829 2a2b 2c2d 2e2f
X		0000060  3031 3233 3435 3637 3839 3a3b 3c3d 3e3f
X		0000100  4041 4243 4445 4647 4849 4a4b 4c4d 4e4f
X		0000120  5051 5253 5455 5657 5859 5a5b 5c5d 5e5f
X		0000140  6061 6263 6465 6667 6869 6a6b 6c6d 6e6f
X		0000160  7071 7273 7475 7677 7879 7a7b 7c7d 7e7f
X		0000200  8081 8283 8485 8687 8889 8a8b 8c8d 8e8f
X		0000220  9091 9293 9495 9697 9899 9a9b 9c9d 9e9f
X		0000240  a0a1 a2a3 a4a5 a6a7 a8a9 aaab acad aeaf
X		0000260  b0b1 b2b3 b4b5 b6b7 b8b9 babb bcbd bebf
X		0000300  c0c1 c2c3 c4c5 c6c7 c8c9 cacb cccd cecf
X		0000320  d0d1 d2d3 d4d5 d6d7 d8d9 dadb dcdd dedf
X		0000340  e0e1 e2e3 e4e5 e6e7 e8e9 eaeb eced eeef
X		0000360  f0f1 f2f3 f4f5 f6f7 f8f9 fafb fcfd feff
X		0000400
X		gwarn#
Xso stir it,	gwarn#
Xwith some	gwarn#
Xrandom input	gwarn#
X		gwarn# noizspin | noizstir
X		gwarn# od -x /etc/noiz
X		0000000  b695 3c73 7a0c 73e0 b37b 55f5 e6cf 2dec
X		0000020  1fa7 1544 890e a039 6a21 e2ec 4669 35ea
X		0000040  a9d8 1175 0dd9 9742 fd6a 1501 9039 1d73
X		0000060  2b0e 0864 93e8 63bf 4a63 3398 b63c ef77
X		0000100  2534 cd7e 0e79 fb56 5f53 bcc5 5b68 968d
X		0000120  910e bbf4 e222 03b2 13d8 908c e508 74a8
X		0000140  d056 fb99 ea7f dddb 9b2f c654 4cd0 1384
X		0000160  8899 3507 1dbb c367 43f1 9806 17e0 8780
X		0000200  95f7 af5a 7a78 92e0 126c 4f2d 3721 a5ee
X		0000220  4a12 f7c3 3186 febb 3ea8 f048 4fd1 41b8
X		0000240  812f 1d43 66a7 8e2d 7ca4 cddb 39c6 6b5f
X		0000260  9a8c 646b c511 304b eb9b b235 46da 5d2e
X		0000300  ec53 5816 c742 e92d 2468 8579 302d d932
X		0000320  2f45 03fb 4f2c ff10 b84d 15a5 8e46 8e84
X		0000340  ff12 0d68 26a3 10c2 87b5 4ebc 3b59 afa2
X		0000360  2bb2 bb64 371e 2f99 b108 c7d5 42eb 68c9
X		gwarn#
X		gwarn#
Xnow emit some 	gwarn#
X16-byte		gwarn#
Xhigh-entropy	gwarn#
Xoutput and 	gwarn#
Xdisplay it	gwarn#
Xwith od -x	gwarn#
X		gwarn# noizspin | noizout | od -x
X		0000000  be7b 81f9 744c 2dca e36d a6c6 9394 7bf2
X		0000020
X		gwarn# noizspin | noizout | od -x
X		0000000  1cea b243 2b0e 55c3 7630 886c 3be3 d03f
X		0000020
X		gwarn# noizspin | noizout | od -x
X		0000000  6887 864d b4fc 40e6 7eb1 0d9e 6b47 f148
X		0000020
X		gwarn#
Xdemonstrate	gwarn#
Xhigh-entropy	gwarn#
Xoutput even	gwarn#
Xwithout noise	gwarn#
Xinput and 	gwarn#
Xwithout 	gwarn#
Xstirring	gwarn#
X		gwarn#
X		gwarn# noizout < /dev/null | od -x
X		0000000  e54f 67a6 52ec 3d61 ddfd 1208 5f52 fead
X		0000020
X		gwarn# noizout < /dev/null | od -x
X		0000000  6472 5f9e fe81 fcab bca8 6d22 2400 0d0a
X		0000020
X		gwarn# noizout < /dev/null | od -x
X		0000000  2df4 9d73 ddc2 5aa4 10c6 59b8 e31c efda
X		0000020
X		gwarn# noizout < /dev/null | od -x
X		0000000  7f64 6671 957e b4aa ae4b 8fd8 7e90 601e
X		0000020
X		gwarn# noizout < /dev/null | od -x
X		0000000  2d8e 522c 700a 5367 d67f dae3 0977 0689
X		0000020
X   Let the syntax X[i..j] represent a subrange of an array X.
X   Let the syntax X[] represent the entire array X.
X   Let the array Noiz[0..15][0..15] represent the 256 bytes of /etc/noiz
X   Let the array Noiz[r] represent the rth row (16 bytes) of Noiz
X   Let the array Input[] represent bytes read from standard input
X   Let the syntax  MD5( x, y, z... )  represent the MD5 hash of the X   concatenation of the arguments x, y, z...
X   Algorithm of "noizstir":
X	read Noiz[][] from /etc/noiz
X	read Input[] from standard input
X	In_hash[0..15] := MD5(  Noiz[][], X				Input[],
X				time, X				pid,
X				ppid,
X				and some extra stuff from sloppy buffering
X			     );
X	FOR r := 0 TO 15
X	    Out_hash[0..15] := MD5(	Noiz[r],
X					In_hash[0..15],
X					In_hash[0..r]
X	    		   	  );
X	    Noiz[r] := Noiz[r] BITWISE_XOR Out_hash[];
X	NEXT r
X	write Noiz[][] to /etc/noiz
X   Algorithm of "noizout"
X	read Noiz[][] from /etc/noiz
X	read Input[] from standard input
X	Out_hash[0..15] := MD5(  Noiz[][], X				 Input[],
X				 time, X				 pid,
X				 ppid,
X				 and some extra stuff from sloppy buffering
X			      );
X  	write Out_hash[] to standard output XEND $Header: /mvp/fjord/strick/yaxen/noiz-0.5/RCS/noiz.doc,v 1.6 95/02/07 15:35:37 strick Exp Locker: strick $
if test 9532 -ne `wc -c <'noiz.doc'`; then
    echo shar: \"'noiz.doc'\" unpacked with wrong size!
# end of 'noiz.doc'
if test -f 'noiz.h' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'noiz.h'\"
echo shar: Extracting \"'noiz.h'\" \(395 characters\)
sed "s/^X//" >'noiz.h' <<'END_OF_FILE'
X/* 	noiz.h
X	Anticopyright (A) 1995 Henry Strickland  X        This package is placed this package in the public domain.
X        Because this package is free, there is no warranty
X        for it whatsoever.  Caveat hacker.
X	NOIZ_FILE	"/etc/noiz"
X/* END $Header: /mvp/fjord/strick/yaxen/noiz-0.5/RCS/noiz.h,v 1.2 95/02/07 14:19:52 strick Exp Locker: strick $ */
if test 395 -ne `wc -c <'noiz.h'`; then
    echo shar: \"'noiz.h'\" unpacked with wrong size!
# end of 'noiz.h'
if test -f 'noizinit.c' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'noizinit.c'\"
echo shar: Extracting \"'noizinit.c'\" \(767 characters\)
sed "s/^X//" >'noizinit.c' <<'END_OF_FILE'
X/*      noizinit.c
X        Anticopyright (A) 1995 Henry Strickland X        This package is placed this package in the public domain.
X        Because this package is free, there is no warranty
X        for it whatsoever.  Caveat hacker.
X	This file noizinit.c is dedicated to Richard Stallman,
X	who taught me the joy of free software.
X X "noiz.h"
X	int e;
X	int i;
X	FILE* f= fopen( NOIZ_FILE, "w" );
X	if (!f) goto bad;
X	for ( i=0; i<256; i++ ) {
X		e= putc(i,f);
X		if (e==EOF) goto bad;
X	}
X	e= fclose(f);
X	if ( e!=0 ) goto bad;
X	return 0;
X	perror( NOIZ_FILE );
X	exit(255);
X/* END $Header: /mvp/fjord/strick/yaxen/noiz-0.5/RCS/noizinit.c,v 1.3 95/02/07 15:28:59 strick Exp Locker: strick $ */
if test 767 -ne `wc -c <'noizinit.c'`; then
    echo shar: \"'noizinit.c'\" unpacked with wrong size!
# end of 'noizinit.c'
if test -f 'noizout.c' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'noizout.c'\"
echo shar: Extracting \"'noizout.c'\" \(1559 characters\)
sed "s/^X//" >'noizout.c' <<'END_OF_FILE'
X/*      noizstir.c   -- stir the noise file with stdin
X        Anticopyright (A) 1995 Henry Strickland X        This package is placed this package in the public domain.
X        Because this package is free, there is no warranty
X        for it whatsoever.  Caveat hacker.
X/* X	This file noizout.c is dedicated in memory of John Cage,
X	who explained to me the point of his pointless noise. X X "noiz.h"
X "md5.h"
Xchar noiz[256];
Xchar pad[256];
Xunsigned char out_hash[16];
Xstruct MD5Context context;
X	int e;
X	int i;
X	long seconds;
X	long pid;
X	long ppid;
X	int row;
X	FILE* f= fopen( NOIZ_FILE, "r" );
X	if (!f) goto bad;
X	for ( i=0; i<256; i++ ) {
X		e= getc(f);
X		if (e==EOF) goto bad;
X		noiz[i]= e;
X	}
X	MD5Init( &context );
X	MD5Update(&context, (unsigned char*) &noiz, 256);
X	while ( fread(pad, 1, 256, stdin) > 0 ) {
X		MD5Update(&context, (unsigned char*) &pad, 256);
X	}
X	time( &seconds );
X	pid= getpid();
X	ppid= getppid();
X	MD5Update( &context, (unsigned char*) &seconds, sizeof seconds );
X	MD5Update( &context, (unsigned char*) &pid, sizeof pid );
X	MD5Update( &context, (unsigned char*) &ppid, sizeof ppid );
X	MD5Final( out_hash, &context );
X	for ( i=0; i<16; i++ ) {
X		e= putchar(out_hash[i]);
X		if (e==EOF) goto bad;
X	}
X	e= fflush(stdout);
X	if (e==EOF) goto bad;
X	e= fclose(stdout);
X	if (e==EOF) goto bad;
X	return 0;
X	perror( NOIZ_FILE );
X	exit(255);
X/* END $Header: /mvp/fjord/strick/yaxen/noiz-0.5/RCS/noizout.c,v 1.3 95/02/07 15:29:00 strick Exp Locker: strick $ */
if test 1559 -ne `wc -c <'noizout.c'`; then
    echo shar: \"'noizout.c'\" unpacked with wrong size!
# end of 'noizout.c'
if test -f 'noizspin.c' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'noizspin.c'\"
echo shar: Extracting \"'noizspin.c'\" \(729 characters\)
sed "s/^X//" >'noizspin.c' <<'END_OF_FILE'
X/*      noizspin.c
X        Anticopyright (A) 1995 Henry Strickland X        This package is placed this package in the public domain.
X        Because this package is free, there is no warranty
X        for it whatsoever.  Caveat hacker.
X	This file noizspin.c is dedicated to Matt Blaze,
X	because I learned the trick from his code.
X X X Xunsigned long x;
X	printf("%lu\n", x );
X	fflush(stdout);
X	exit(0);
X	signal( SIGALRM, enough );
X	alarm(1);
X	while (1) {
X		++x;
X	}
X	/*NOTREACHED*/
X	return 255;
X/* END $Header: /mvp/fjord/strick/yaxen/noiz-0.5/RCS/noizspin.c,v 1.1 95/02/07 15:35:39 strick Exp Locker: strick $ */
if test 729 -ne `wc -c <'noizspin.c'`; then
    echo shar: \"'noizspin.c'\" unpacked with wrong size!
# end of 'noizspin.c'
if test -f 'noizstir.c' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'noizstir.c'\"
echo shar: Extracting \"'noizstir.c'\" \(1841 characters\)
sed "s/^X//" >'noizstir.c' <<'END_OF_FILE'
X/*      noizstir.c   -- stir the noise file with stdin
X        Anticopyright (A) 1995 Henry Strickland X        This package is placed this package in the public domain.
X        Because this package is free, there is no warranty
X        for it whatsoever.  Caveat hacker.
X	This file noizstir.c is dedicated to Jacques Atali,
X	in honor of his book "Noise, The Political Economy
X	of Music."
X X "noiz.h"
X "md5.h"
Xchar noiz[256];
Xchar pad[256];
Xunsigned char in_hash[16];
Xunsigned char out_hash[16];
Xstruct MD5Context context;
X	int e;
X	int i;
X	long seconds;
X	long pid;
X	long ppid;
X	int row;
X	FILE* f= fopen( NOIZ_FILE, "r+" );
X	if (!f) goto bad;
X	for ( i=0; i<256; i++ ) {
X		e= getc(f);
X		if (e==EOF) goto bad;
X		noiz[i]= e;
X	}
X	MD5Init( &context );
X	MD5Update(&context, (unsigned char*) &noiz, 256);
X	while ( fread(pad, 1, 256, stdin) > 0 ) {
X		MD5Update(&context, (unsigned char*) &pad, 256);
X	}
X	time( &seconds );
X	pid= getpid();
X	ppid= getppid();
X	MD5Update( &context, (unsigned char*) &seconds, sizeof seconds );
X	MD5Update( &context, (unsigned char*) &pid, sizeof pid );
X	MD5Update( &context, (unsigned char*) &ppid, sizeof ppid );
X	MD5Final( in_hash, &context );
X	for (row=0; row<16; row++ ) {
X		MD5Init( &context );
X		MD5Update( &context, noiz+16*row, 16 );
X		MD5Update( &context, in_hash, 16 );
X		MD5Update( &context, in_hash, row+1 );
X		MD5Final( out_hash, &context );
X		for ( i=0; i<16; i++ ) {
X			noiz[16*row+i] ^= out_hash[i];
X		}
X	}
X	fflush(f);
X	rewind(f);
X	
X	for ( i=0; i<256; i++ ) {
X		e= putc(noiz[i],f);
X		if (e==EOF) goto bad;
X	}
X	e= fclose(f);
X	if (e==EOF) goto bad;
X	return 0;
X	perror( NOIZ_FILE );
X	exit(255);
X/* END $Header: /mvp/fjord/strick/yaxen/noiz-0.5/RCS/noizstir.c,v 1.3 95/02/07 15:29:01 strick Exp Locker: strick $ */
if test 1841 -ne `wc -c <'noizstir.c'`; then
    echo shar: \"'noizstir.c'\" unpacked with wrong size!
# end of 'noizstir.c'
if test -f 'patchlevel' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'patchlevel'\"
echo shar: Extracting \"'patchlevel'\" \(2 characters\)
sed "s/^X//" >'patchlevel' <<'END_OF_FILE'
if test 2 -ne `wc -c <'patchlevel'`; then
    echo shar: \"'patchlevel'\" unpacked with wrong size!
# end of 'patchlevel'
if test -f 'version' -a "${1}" != "-c" ; then   echo shar: Will not clobber existing file \"'version'\"
echo shar: Extracting \"'version'\" \(9 characters\)
sed "s/^X//" >'version' <<'END_OF_FILE'
if test 9 -ne `wc -c <'version'`; then
    echo shar: \"'version'\" unpacked with wrong size!
# end of 'version'
echo shar: End of shell archive.
exit 0

@_date: 1995-02-08 00:11:19
@_author: kerb4 or kerb5 or both? 
@_subject: noiz ... and more SKRONK 
Right.   But you notice I made it mode 660, owner root, group kmem, to
parallel the /dev/*mem devices.   You have the same vulnerabilities as
always on a multi-user system, even if you put /dev/noise in the kernel
or run a TCP daemon.  Another parallel is the randseed.bin file in
From an information theory point of view, I don't know how to describe
the kind of shared-entropy that this pool exhibits.  Making the source
of the entropy hidden to the users by crunching on the way out with MD5
adds something to the data -- it's not true entropy, but it's some kind
of effective entropy, from the point of view of the users.  Unless MD5
has weaknesses that I assume it doesn't, it's not really possible for users
to know where their spaces of possible random values overlap, so they
don't know how to exploit it.
A final note -- I should have put /etc/noiz somewhere in the But one can edit the Makefile to do that, and no other software
has to actually know where it is, since its access is totally
encapsulated by noizinit, noizstir, and noizout.  The location of
these in /usr/local/bin/ is what needs to be standardized, so I
hope that's good enough for most users.
Oh, I meant to thank everyone for the great discussion and constructive criticism of SKRONK and "encrypt tcp connections" hacks.
Especially Perry -- your enumeration of projects was good.
Based on that, and what I know of the others, the priority of protocols I'd like to support with skronk are
Thus SKRONK becomes what I wanted it to be:  a way for sites to
advertize the availability of enhanced services (via the skronk map UDP
daemon) and a way to painlessly integrate crypto with existing code.
(The last aspect always draws user interface problems -- if it's so
transparent, how do you know if you're encrypted?  Right now I have the
client end scribble to stderr when it skronks.)

@_date: 1995-02-08 10:52:26
@_author: http://home.mcom.com/info/SSL.html 
@_subject: Re: skronk 
THUS SPAKE "Kipp E.B. Hickman" :
# FYI:
# # If you haven't already, I suggest you take a look at the SSL spec
# (
[ carbon to cypherpunks, whom i think would be interested]
i've been looking at that.  It seems that a special port has to be allocated for each TCP service.
So it's not clear to me how to find out if others on the net offer SMTP
with SSL, or how I can put SSL into my X11 clients & server.  You see
what I'm getting at?
It also looks like some heavy equipment is necessary to manage these
RSA certficiates.  Is there anything like PGP's keyring management for
manipulating my web-of-trust?  Where do I find the docs?
# It does what you are trying to accomplish (I think), and it is already deployed
# in production code (the Netscape client and server products). In addition, we
# announced this week a free (for non-commerical use) reference implementation.
# The code will be out on the net as soon as the lawyers are happy :-)
aha ... that's the missing link.  I'd certainly like to add it to the
protocols that SKRONK advertizes and negotiates, but doing my own
implementation of these complex protocols, and building machinery for
using non-PGP certificates, was way more than I could handle.
Please beat your lawyers to a pulp, until they make it useful for us.
If I can't create generally useful things with it, and share it with
thousands of others on the net for free, it's not going to be used by
the cypherpunk community.
I recommend you put your reference implementation in the public domain
(except for the RSAREF component).  Or take Matt Blaze's crypto
offerings from AT&T as your model.

@_date: 1995-02-08 11:02:25
@_author: Communications Decency Act 
@_subject: Re: Effects of S.314 (Communications Decency Act) 
# > > I beg to differ. Remember the "Seven Dirty Words Case"? (I think WBAI/Pacifica
# > > v. US, year?...). WBAI-FM in NY played George Carlin's "Seven words you can't
individual words can be "indecent", but not obscene.
obscene refers to the content of the work as a whole, and would
be very difficult to attain with a few dirty words.
# > > say on television" skit and was taken to court. The court ruled that there
# > > were some obscene things which could be censored, but other things were
All obscene things are censored on broadcast radio & TV.  Massive penalties for broadcasting obscene material.
# > > indecent so could at most be relegated to late night hours (and they've
# > > struck down laws banning indecency 24 hours... I think some stations are
# > > suing with the claim that such relegation constitutes censorship).
In the U. S., you have a first ammendment right to indencent speech.
The question of a late-night "safe harbor" for indecent speech on the
air is about when children are likely to be listening.  First
ammendment rights apparently don't apply to children who are listening
to the radio.  Right now there is a "safe harbor" from around 10pm (or is it 9pm?)
thru 6am, but this changes regularly, usually as a result of "case law"
(someone being prosecuted under next month's rules, not this month's)
