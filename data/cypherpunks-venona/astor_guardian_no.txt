
@_date: 1998-08-06 05:25:02
@_author: Alexander Kjeldaas 
@_subject: Re: SecDrv and Win95 
There is something called TCFS - transparent cryptographic file
system.  You could take a look at
ftp://ftp.pvv.org/pub/Linux/kerneli/v2.0/. I'm just starting a project
to provide an easy to use and up to date international patch for the
linux-kernel.  The current patch integrates the steganography and
crypto-patches for loopback filesystem, CIPE, and TCFS in one patch.
I'm looking at integrating IPsec as well, but at this time, there are
at least 5 different implementations of it.

@_date: 1998-10-19 21:55:12
@_author: Alexander Kjeldaas 
@_subject: Re: Disk (block device) encryption for Linux and *BSD? 
I have collected the available loop-crypto patches in the
international kernel patch.  It contains blowfish,twofish,serpent, and
cast-128 modules (and an idea module which I haven't ported yet).  The
loopback modules have been updated to work with the latest loopback
patches.  I plan on adding other AES candidates - I have free
implementations of rc6, rijndael, mars, and dfc.  The patch is
available from:
I have a collection of utilities you'll need and other 2.0-crypto
stuff mirrored at:

@_date: 1998-12-12 06:53:31
@_author: Alexander Kjeldaas 
@_subject: Re: Linux Encrypted File Sytem 
I'm maintaining the international kernel patch for Linux which aims to
collect all crypto-related features for the Linux kernel in one easy
patch.  This patch is tracking the development version of Linux, not
the stable one.  The patch is available from:
The loopback modules currently supports the following ciphers: serpent
(cbc), mars (cbc), rc6 (cbc), dfc (cbc), blowfish (cbc), cast-128
(ecb), and twofish (cbc).
This code is changing rapidly, so if you feel uneasy about development
versions of the kernel, this might not be for you until it has become
a bit more stable.
If you patch linux-2.1.131 (the latest release) with
patch-int-2.1.131.1.gz you can look in the Documentation/crypto
directory for some mount-patches.  However I intend to make a newer
patch with support for more of the cipher algorithms - and against the
latest util-linux.
If you want to use the stable kernel, you can look at
ftp://ftp.kerneli.org/pub/Linux/kerneli/net-source/loop/ for a
collection of loop-crypto patches against 2.0.x.
You can also look into tcfs available at This is basically crypto-support for NFS which is more integrated than
CFS (the T in TCFS stands for 'transparent').

@_date: 1998-12-12 06:54:11
@_author: Alexander Kjeldaas 
@_subject: Re: German government press release on Wassenaar 
I applied for an examination of the Open Source definition to the
department for foreign affairs in Norway.  The response (no surprise)
was that Open Source is compliant with what the Wassenaar-agreement
calls "public domain" software.

@_date: 1998-12-13 14:44:11
@_author: Alexander Kjeldaas 
@_subject: passwords and hashes 
Content-Length: 1215
Lines: 32
I'm looking into how passwords should be transferred into keys for the
loopback filesystem in Linux.  Currently, what happens is that you
take the SHA or RIPEMD-160 hash of the password string and use that as
a key.  If the cipher only uses a 128-bit key, the last 32 bits of the
hash is unused.  I have some questions about this scheme:
o In the case of a 128-bit cipher, do I lose any information by not
  using the last 32 bits of information?  Should the last 32 bits be
  xored with the first 128 in order to not lose any info?
o Is there any advantage to _not_ using a 256-bit hash function? (i.e
  - use a 128-bit hash for 128-bit ciphers).  Currently there are lots
  of AES ciphers that don't get fed a 256-bit key because we only have
  a 160-bit hash.
o Is there a good 256-bit hash function?  I don't know of any other
  than snefru.  In this application, speed doesn't matter much.
  Should I use a 256-bit cipher instead maybe?
o Is it safe to always take the hash of the password, or is it better to
  use the password directly as the key if it is less than 16
  characters for 128-bit cipher?

@_date: 1998-12-13 15:12:18
@_author: Alexander Kjeldaas 
@_subject: cfs' ecb+ofb mode vs. interleaved cbc mode 
Content-Length: 2761
Lines: 57
For fast file-system crypto, you really want to implement the ciphers
so that you encrypt several blocks at a time.  CFS does this by using
a special mode (described as ecb+ofb by schneier).  The CFS
documentation explains:
"At attach time, CFS derives from the passphrase into two DES keys, K1
and K2.  K1 is used to create two (or three) DES pseudorandom stream
ciphers, each 128KB long, S1 and S2.  To encrypt a file block, it is
first XORd against a unique bitstream derived from the inode number of
the file.  The result is then XORd against S1 based on its offset in
the file.  This is then DES ECB encrypted with K2, and the result of
that is XORd against the appropriate position in S2.  The resulting
ciphertext is what is stored.  The cipher is reversed in the obvious
manner.  Filenames are similarly encrypted.
There does not appear to be a feasible attack that allows an
independent search for the two subkeys K1 and K2; in a brute-force
known-plaintext attack, an attacker would have to try all 2**112 key
combinations.  Note that in the single DES mode, the two keys may be
vulnerable to independent exhaustive search under a so-called "linear"
attack, but this attack appears to require a large number of chosen
plaintexts encrypted under the same inode number.  Under most
conditions where the attacker cannot introduce large numbers of chosen
plaintexts, I believe even the single-DES CFS encryption to be very
strong in practice.  Note that this is not the same as a "proof".  In
any event, CFS is always at least as secure as DES or triple DES (as
selected when the directory is created).  If want high security,
select triple DES (now the default); for better performance, use the
hybrid single-DES option."
I'd like to know how this method compares to using an interleaved cbc
mode - for example 8-way interleaved cbc.  The n-way interlaved
cbc-mode works by chaining each n'th block together instead of each
block.  This means you get n more messages.  For a 512-byte block and
a 128-bit block length, this means that each message will be
512/(8*16) = 4 blocks long.  For a 4k block you get messages that are
32 blocks long.  This might or might not be a problem.
With CFS you need 2x the key material - something that is really hard
to get by when you're using 256-bit keys.  It seems to me you'll have
to type in an extremely long password or each of the keys will in
practice be weaker than what the theory tells you.  Another point is
that CFS requires a lot more nonswappable memory than interleaved cbc
mode. This means that interleaved cbc mode initially seems more
attractive for file-system use.  Am I missing something?

@_date: 1998-12-14 02:06:22
@_author: Alexander Kjeldaas 
@_subject: Re: German government press release on Wassenaar 
Content-Length: 892
Lines: 31
I haven't heard anything about there not being any exemption on
128-bit crypto.  To my knowledge there is a general exemption on all
Open Source software, regardless of the key length.  However, I will
check into this.

@_date: 1998-12-14 03:12:31
@_author: Alexander Kjeldaas 
@_subject: Re: German government press release on Wassenaar 
Content-Length: 474
Lines: 20
No laws have to be changed.  This is just a "small" change to an
existing law.
