
@_date: 1994-01-31 22:20:30
@_author: Garet Jax 
@_subject: Remailers Revisited 
The following is the specifications of the proposed anonymous remailer
system ( described by various people here ) as I understand it.
   1)  all messagess are PGP ( or otherwise ) encrypted to hide their
       content.
   2)  real headers and to/from lines are stripped and replaced
       with a code which the system uses to retrieve that information
       when the message is answered ( double-blind ).
   3)  from their first entry into the remailer system, messages
       are rerouted using one or more of the following methods
       in attempts to defeat message traffic analysis and tracking:
          i) random garbage prefix/suffixes used to pad messages
         ii) multiple messages combined with possibly dummy messages
             before remailing through random number of stops in
             remailer system
        iii) message remailings are delayed by a possibly message-sender-
             defined amount of time.
         iv) messages are sent via atleast one non-American remailer
Given that my understanding is basically correct, why couldn't
the remailer system be set up similarly to the way IRC is?
detailed example :
When one wants to send a message, she would load up a local Anonymous
Internet Remailer (AIR) daemon which would attempt to connect to one of
the AIR clients running elsewhere on the Internet.  Then she would send
a PGP pre-encrypted message down the line, prefixed with the e-mail
address of the person who is to receive the message.
At this point, the AIR-client sends out a general message to the other
AIR-clients.  This message contains an encrypted copy of the receiver's
e-mail address.
The response to this message is two-fold.  First a response is
circuitously sent back to the original AIR-client, telling it that an
alias has/has not already been assigned by that AIR-client to the
receivers e-mail address; further, if one has been then a reference
number would be assigned to the message ( which it does not have a copy
of ) and be sent back in the same message.  Second, if the alias exists
then the responding client sends a circuitous message to the receiver's
e-mail address telling him that he now has AIR-MAIL waiting for him.
If none of the responses about the alias are positive, then one is
assigned by the original AIR-client, and encrypted 'add new alias'
messages are sent to two other randomly selected AIR-clients to ensure
that the alias is redundandly recorded.  The original AIR-client would
then assign the reference number to the message.
In either case, the reference number would always be used to reference
the message.
The encrypted message is then sent circuitously to a random number of
other AIR-clients.  After all of these have responded to the original
AIR-client that the message was received, the original AIR-client would
then choose atleast two of them ( again for redundancy ) to keep the
message, all others to purge it.  This same encrypted hold/purge message
would then be sent circuitously to ALL of the holding AIR-clients.
Finally the original AIR-client would purge its copy of the message.
(this does not however, preclude the original AIR-client's being one of
the holding AIR-clients)
The AIR-client <=> AIR-daemon and AIR-client <=> AIR-client connections
could invisibly handle further encryption and padding.
Finally, the message needs to be picked up by the intended recipient.
He would run the AIR-daemon on his machine, which would then connect to
one of the AIR-clients ( this being hereafter the receiving AIR-client
). He would send the message reference number, which the AIR-client
would then encrypt and send out in a general message to all of the other
AIR-clients... requesting that they send this message.  If an AIR-client
has the requested message then it pads, encrypts and sends it...
otherwise if the AIR-client does not have the message it creates a
garbage file which it encrypts and sends to the receiving AIR-client.
The receiving AIR-client would then send one copy of the message with
the correct reference number to the receiver's AIR-daemon, where it
could be saved on disk.
This system has several advantages over a purely e-mail based system:
     i) messages would no longer be limited to 60k in size as it is now,
        due to the fact that none of the messages would actually be sent via
        e-mail.
    ii) every site and daemon could have a unique encryption key for use
        by the other sites.
   iii) even if the message is tracked to its holding client, the trackers
        still have to chase it again when the receiver requests its delivery.
    iv) the receiver need not necessarily be at his home e-mail address when
        he requests the message.  he could choose to run the AIR-daemon
        on a remote host several rlogins from his home site.
     v) if coded well, any user could run an AIR-client on her home site,
        thus permitting the network to grow to hundreds or thousands of
        sites very quickly, each with much lower overhead than the current
        non-networked, anonymous remailers available.
        Futher, as administrator of that particular AIR-client, the user could
        configure her AIR-client's involvement in the overall AIR-network based
        upon the resources of her system.  She could for example, choose that
        her site be only a remailer site and not a holding site, or vice
        versa... thus adding further message tracking problems for any snoopers.
Futher hairyness which could be added:
     i) AIR-daemons could accept command-line parameters rather than
        being full interfaces, thus allowing redirect.
    ii) listserv software could be configured to allow connection to
        the AIR-network, thus allowing someone to send a PGP-encrypted
        message to the listserv for forwarding via the AIR-network.
        A further advantage of this is that users from non-Internet sites,
        such as CompuServe or RIME could still make use of the remailer.
   iii) the receiver could send the message code to a listserv for
        message retrieval.
    iv) when a user starts up an AIR-daemon on his machine, make it
        automatically continue to run and become another non-holding bounce
        site, thus accounting for why messages are suddenly being sent
        to a non AIR-network site.
     v) one could have several completely separate AIR-networks running
        on the Internet.  These would dynamically expand as more people
        ran daemons.
Constructive comments solicited...
-Garet          {Garet.Jax

@_date: 1994-02-05 05:45:29
@_author: Garet Jax 
@_subject: Remailers Revisited 
Why not set up a mailgroup (such as cypherpunks.pgp) wherein ALL
messages are PGP encrypted?  Once one subscribes to the group, she would
receive a message containing both the standard further information about
the group as well as public and PRIVATE PGP for the mail group keys to
add to her PGP key ring.
Then whenever she sent a message to the group remailer
(cypherpunks.pgp it would already be PGP encrypted with the
group key.  And anyone who received that message would be able to open
and read it because they would already have the private key for the
The remailer could check the messages before forwarding them to the list
subscribers to make sure that they are PGP encrypted.  If they aren't
then they wouldn't be sent... a nice side effect of this would be that
the list subscribers would no longer receive those 'unsubscribe user'
messages as most likely these would not have been encrypted before
-Garet          {Garet.Jax

@_date: 1994-02-05 05:45:33
@_author: Garet Jax 
@_subject: how to solve this prob. 
There MUST be some way that the LISTSERV software can be modified
so that a user can send an unsubscribe message to the -request line
for another user.
Take this Detweiler for example.  If he forgets where to send his
unsubscribe message and sends it to the list instead, someone could send
an unsubscribe message to the proper address for him. ex:
   'unsubscribe [ listname ] user
The system would note that the name of the person sending the
unsubscribe message ( user1 ) was different from the one who was being
unsubscribed ( user2 ) , and would, after unsubscribing user2 send a
message to user2 telling him that he had been unsubscribed from the list
by user1. ex:
   'Dear user2, you have been unsubscribed from the Cypherpunks
   list by user1.  If you wish to resubscribe, send a message
   containing...'
That way, instead of the list readers bombarding the folks who send
the unsubscribe requests to the list, they could simply forward the
request to the proper place.
Now, how do we get it implemented?

@_date: 1994-02-05 11:15:40
@_author: Garet Jax 
@_subject: Remailer Tearline Variant 
Eli ebrandt said:
Actually a variation on this '--truncate here--' scheme might solve the
user-selected multiple-remailer scheme that we're trying to get up here.
Place the 'truncate' or '::'  line at the beginning of your message,
just after the last local header line.  Then add routing instructions
for the remailer.  Then maybe another 'truncate' message followed by
more routing instructions for the next remailer chosen.  Then a blank
line and your message.
BEGIN example:
Request-Remailing-To: hh
Request-Remailing-To: elee7h5
Request-Remailing-To: cypherpunks
Eli ebrandt said:
END example
Each remailer would only strip off the first 'Request-Remailing-To:'
instruction in the message.  The remailer would assume that anything
following that was part of the message, until it reached the signature,
which it would truncate.  Then it would remail the new 'message' as

@_date: 1994-02-10 04:20:24
@_author: Garet Jax 
@_subject: Prime Numbers 
I'm presently trying to generate a list of prime numbers on
a friend's 486 DX2 66mhz computer, but that is rather slow going
as you might imagine.  I'd like to get a list of all the prime
numbers up to 80 digits in length, and I know these numbers must
have already been computed by someone... atleast for cryptography
Does anyone know where I can get such a list, or a portion thereof?
Thanks in advance,
-Garet                  {Garet.Jax

@_date: 1994-04-03 07:45:39
@_author: Garet Jax 
@_subject: Code Obfuscation 
Okay if you want to obfuscate your code on a much more secure level
albeit with some execution penalty, build public key encryption
into the CPU.  One would simply compile the program and encrypt it
using the public key of the chipset (680xx, 80x86, &c), then the
CPU would decrypt and execute the code on the fly using its private
