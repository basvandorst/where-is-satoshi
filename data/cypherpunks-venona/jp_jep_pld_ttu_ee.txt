
@_date: 1994-05-26 09:58:24
@_author: Jyri Poldre 
@_subject: Learning to divide ( again ) 
RE every1.
Recently i became involved in project of designing semi-custom VLSI device for endecryption. The device uses variable length RSA for key exchange and
IDEA for data encryption. For pipelinig IDEA block we have to use 6
multipliers 16 bit ant that leaves us with 96 bit adder for RSA calculations.
( The chip should be reasonably cheap ). Otherwise the RSA speed would not
be so cruicial but we have to generate both keys in chip ( involves
physically random generator based on variable frequency being samled with
constant clock, VF generator is inside chip )  to guarantee absolute
secrecy - you cannot tell Secret component if you do not know it. To
generate keys we have to use Fermat test for primality and that takes
time. Although the RSA keys need not to be changed so very often it is
still important to keep the process running in 'normal' time limits.
So - I can use multiple operand adders ( meaning a+b+c+d with one carry-propagation time ) For RSA basic operation a*b mod Z  i have
decided to use radix4 modified Booth algoritm for multiply , but i am still
not sure about divide. Has any1 encountered similar problems? I would greatly
appreciate Feedback, cause i have to make up my mind in some weeks.  If you are interested in more details about the design, let me know. I would like it to be good product for use in different applications.
JP from PLDesign lab of Tallinn Technical University.

@_date: 1994-05-31 02:58:16
@_author: Jyri Poldre 
@_subject: Estonian RSA chip 
I think that i was a bit rushing and did mainly focus on my own problem,
that was this division. I will enlighten this more clearly, so that you do not think about me being 'FSP hard/soft/whateverware stealer'.  Yes, this chip is basically 'FAST integer calculator' with different levels of microprogamming. I think that user-accessible levels include A*B mod Z , where A,B,Z are 510- local_register_ram_limit nr of bits. The only main difference about commercially available circuits would be relative cheapness- meaning that  modular exponents are optimized in algorithm level, not via HUGE adder, and main force lies in 16 BIT calculations , needed for fast encryption algorithms. (EStimated speed using IDEA will be not less than 2 Mbit/sec, RSA  key exch will be less than 0.4 sec. ), But still it will not contain IDEA or RSA to start with. ( though using primitives like A*B mod Z this is 10~20 lines of code. )  Now i do explain in a few words, why i do not like the idea of user tinkering with that. Every known cryptosystem using one-way functions contains trapdoor. While there will be no reason in users snooping around with things that run IDEA or DES  just because you might lose the ability to have one-to-one mapping of data, there is nothing wrong in just changing a bit of RSA. Everything would possibly 'LOOK' the same with one guy opening trap^2 door occasionally. That would zero the whole meaning of the chip, what would otherwise work like that:
(just for example i am  using RSA and IDEA. )
CHIP would look like it
IN RAM we will keep PUBLIC components and id-s of those we want to keep secure chat with. FOR RAM we will have D2,E2 the chips ID will be pair E1,D1
they will be generated inside chip and  !!! Both of them not known to users!!!. when you want to initiate communication you bind 2 chips together and they will exchange public components through trusted channel - meaning you should avoid the write access to that channel- nothing is wrong with read access. It can be achieved rather easyly with 2 chip modules. ( 3 special lines and single sided PCB board- you 'see' the lines and it would rather hard to write into them ) after initialisation chips will store their partners Public components and real names in RAM using D2. Now the rest is obvious. After chip A receives talk request from Chip B it looks up public components in RAM and if it matches then uses these do decrypt and get IDEA key from X. If everything is Ok you will get data and the name of CHIP B. Now i cannot guarantee what happens between chip and terminal, but that is not my problem. For this chip-to-chip construct i could give money-back guarantee on some reasonable sums ( dependidng on the length of key change moduli  and while-it-is-safe-to use IDEA or DES or whatever for one session.) Now let us look at it from the different viewpoint. Just imagine the possibility of firmware being left to user. I am not even thinking about stupid things like i-will-keep-the-code-secret. This simply won't work. Imagine you being able to reprogam this chip. I know that this would be hard, but it would be NPboring instead of NP-difficult task of factorizing large primes. For me as a constructor it makes no differnce to let or to let not user cahnge microcode technically, but i am still fond of my life and would tell the codes for firmware to publicity at once. Therefore my idea has been from the start open design while in devolopment and no user interaction when in production. ARGUE with me. - that is the main idea I am anyhow using VHDL firmware devolopment and have my own assembly language for this chip. So far I have decided no interaction in algorithms for user, due to licences it will possibly turn out the other way.
Jyri Poldre from Tallinn Technical University
PHONE/fax 372-6-392062 If it was not for the MIPS
being so good at building CHIPS
the yards would still be open for the lines
remix, From Pfloyd, The final Cut

@_date: 1994-05-31 03:41:06
@_author: Jyri Poldre 
@_subject: sorry, serios error in previoos text 
It is rather hard to factorize even small primes :-) it should of cource read like fact. large numbers.
JP from TTU.

@_date: 1994-06-06 05:50:00
@_author: Jyri Poldre 
@_subject: Clipper LEAF simulator chip??? 
As far asi I know there has been no direct info about how the checksum is calculated, only that it is somehow connected to IV. So , the function of the chip for doing IT would look like the following:
1. Intercept original LEAF.
  Can be done. There should be no problems with such small timeouts, cause phones may sometimes have bad links, also the data transfer rate is of no big deal. 2. Generating Random LEAF and testing it. The only problem here is the time it takes to test these forged LEAFs. Does it have the limit? Maybe chip waits some time before allowing for next testing, 0.1 sec would be enough - you would have to wait almost 2 hours for finding forged LEAF and for law-obeying user 0.1 sec makes no difference. Then maybe Clipper chips will re-initiate key exchange or whatever after some time-out.
If that is no question, meaning that  other chip will wait for connection then the whole design would consist of RND generator and some logic. This would fit perfectly into XILINX 3010 FPGA. There is another good point in using FPGA- the configuration info could be made public knowledge and then everyone could go out and make themselves one for some hamburgers price. price of 3010 FPGA in Estonia is  $5-$8 Oops. add a Coke to these burgers :-)
(Xcuse me if I misunderstood smth. Haven't seen a live clipperphone, therefore can give no soldering / other details. ) JP from TTU.

@_date: 1994-06-06 08:38:54
@_author: Jyri Poldre 
@_subject: Clipper- Who's Fooling Who 
It simply is not possible for them to have ACCIDENTALLY OVERLOOKED such a thing as 16 bit CRC. Let us assume, that 2 distinct users want to initiate clipper connection. They will have their secret keys generated inside chips and as key distribution is not a part of clipper they can happily use DH or whatever to do it, meaning that they still are the only ones to know them. To be able to intercept these keys clipper chips have ( presumably ) skipjack cipher to make LEAFS. Now cipher must take arguments data and key. But we assume, that Chips  have Family key, but not Master key ( such a thing would have been nonsense- you cannot rely on one key for all chips ), meaning that they share no global knowledge except SJ algorithm. So, for other chip to make difference between RIGHT and WRONG LEAF it has shared secret, meaning session key and LEAF. What could have been simpler than using these 2 components and SJ to generate cryptographic checksum? Nothing, execpt that this checksum is of no use to goverment- it does not know shared secrets, so it cannot use this checksum anyway. BUt that is not such a big pr
oblem - line noise and checksums can be applied externally. So why not use session key and SJ, generate a 80 BIT checksum and append it to LEAF. I do not believe that it would make SJ useless because of cancellation :-) The proposed scheme would look like this:
Sa, LEAFa, Sb, LEAFb  the session keys and LEAFs of a and b
1. A and B generate and exchange keys
2. A sends to B SJ(LEAFA,Sb), LEAFA
3. B verifyes it and takes into use Sa. ,the same thing in opposite directions.
Rather EASY not to implement it.      Now they did not do it. Instead they used only 16 bits. Weird. Unless...
OK, SJ has no backdoors, but somehow manages to send the parts of LEAF fields maybe 0.5 bits per one SJ coded user data block. (it is always possible to compress data that much ) That would change the things. We would be happy about our checksum and they would be really happy about (us) US.
A little media now and then - it's for advertisment. Just think that This 16 bits did not make SJ weaker, meaning people who would have used it for sequrity will do so anyway. The i-do-not-know class will switch over to it because of if-I-want-I-can-crack-it( or buy device or have it installed or whatever). I'm Looking for a partner Someone who gets things fixed
Think about it seriosly
do you want to get rich?
OK for Pet Shop Boys, but NSA???
JP from TTU

@_date: 1994-06-06 10:19:13
@_author: Jyri Poldre 
@_subject: that is cool 
And by doing that add silicon area and  new algorithm? Instead of using one that already existed? Concern for Net bandwith ( 16 instead of 80 bits per session ) and stupidity is of cource noteworthy, but i personally think that they have got spy working there, who deliberately disrupts their work to an extent where they just must quit Clipper and say Oh, let us be friends and use DES :)
JP from TTU.

@_date: 1994-06-20 08:28:12
@_author: Jyri Poldre 
@_subject: PC RND generator based on physical  random 
What you need is natural source of random. I have used clocking
higher speed quarz generator with
lower speed (10 x is ok ) unstable frequency oscillator  and then taken parity of the result (4-5 bits is enough for most situations, depends of cource on distribution of LF generator values) . Variable Freq. oscillator  is RC and higher quarz. Now as we are not willing to give up card slot (and PCB board area ands so on ) for just RND generator
maybe it is good to find existing source of random in PC itself. So - do we have RC generator in PC? YES. We have 4 of them, to be exact.
Most of us do not make much use of these ports, because most games do not support them correctly. But anyhow, joystick ports are there. IO card costs 10$ if you have not already got one. So I propose scheme for PC RND generator:
1. Make LF generator using Joystick ports
2. Use HF oscilltor of PC clock ( Program Execution, if any interrupts occur,
   it is no problem).
3. Find out the distribution of LF oscillator and calculate the needed Parity
   filter size.    ( By parity filter I concider parity values of N last bits)
4. Use it
