
@_date: 1994-07-03 02:07:50
@_author: "Timothy L. Nali" 
@_subject: Re: Dr. Dobbs Dev. Update 1/5 July 94 & Schneier 
Excerpts from internet.cypherpunks: 3-Jul-94 Re: Dr. Dobbs Dev. Update
1.. by Eli Brandt e>         return  a;
Note that some compilers might not be smart enough to use logical shift
ops and instead use expensive division ops.  Just to be safe...
int byte_ones(int a)
         a = (a & 0x55) + ((a & 0xAA) << 1);          // 0x55 == 01010101b
         a = (a & 0x33) + ((a & 0xCC) << 2);          // 0x33 == 00110011b
         a = (a & 0x0F) + ((a & 0xF0) << 4);          // 0x0F == 00001111b
         return a;
And this runs in O(lg n) where n is the number of bits in `a'.  Does
anybody have an algorithm for this that beats O(lg n)?
 Tim Nali            \  "We are the music makers, and we are the dreamers of
 tn0s  \   the dreams" -Willy Wonka and the Chocolate Factory
