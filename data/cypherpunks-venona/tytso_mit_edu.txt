
@_date: 1995-09-07 15:25:19
@_author: Theodore Ts'o 
@_subject: Re: Kerberos v5's experience with ASN.1 
To: Cypherpunks Lite    Date: Sat, 2 Sep 1995 13:55:38 -0400
   From: jis (Jeffrey I. Schiller)
   However, the problem with ASN.1 isn't its waste of space (which actually
   isn't that bad for a mechanism for encoding arbitrary objects). While I won't argue about the rest of Jeff's note about the use of ASN.1
being a mistake, I do want to point out that certain ASN.1 types are in
fact very wasteful of space.
Most notable of these is the ASN.1 Generalized Time --- which encodes
the a timestamp in ASCII.  ASN.1 GeneralizedTime therefore requires 17
bytes to encode, an over four-fold increase in the amount of space
needed to store a time, compared with a 4 byte representation of "number
of seconds since 1970".  This is deadly in a protocol which has to store
lots of timestamps, which is the case in Kerberos V5.
We could have gotten around this problem by merely storing an integer
whenever we needed to store a timestamp, instead of using the ASN.1
abstract type.  Then it would have only taken 6 bytes (ASN.1 adds a
2-byte overhead for each object which you store).

@_date: 1995-09-22 13:40:17
@_author: Theodore Ts'o 
@_subject: Re: /dev/random for Linux 
> > On this same track, I suggest that "/dev/random" devices for unix are
   > > an excellent idea. Ted Tso did one for Linux that steals all the bits
   > > of semi-random timing information it can.
   >
   > Anyone know where I can find more information on this wonderful device?
I've just sent patches (versus the Linux 1.3.28 kernel) off to Linus.
There's a fairly long exposition at the beginning of
drivers/char/random.c which explain its theory of operation.
There are some things that I had wanted to do to make it better; for
example, not use MD5 in the inner bucket-mixing, but use a CRC-based
mixing algorithm that Colin had suggested; this should be much faster,
and since I'm using MD5 on the output side of the random number
generator, it should be good enough.  Also, at some point I want to add
code so that it can sample the Pentium instruction cycle clock register,
which will give us a much finer granularity clock with which to measure
However, given the current interest in random number generators ---
thank you Netscape for providing such a wonderful object lession!  :-) ---
and keeping in mind the saying that the best is often the enemy of the
good, I've decided to make what I have available now, and worry about
improving it later.
In any case, here it is.  With any luck, it'll be included in the 1.3.29
Linux kernel; the idea is that application programs running under Linux
should be able to assume that /dev/random exists and that they can rely
on it.  Perhaps if enough free OS's do this, commercial OS vendors will
get shamed into providing /dev/random on their Unix systems.  Or better
yet, perhaps hardware vendors will decide it's worth including the $10
(if that) worth of parts necessary to have a real, hardware-based random
number generator in their machines.
If there are any representatives from such computer manufacturers,
please consider this a hint.  :-)
begin 644 patches.random.gz
M'XL("'WS8C " W!A=&-H97,NCSOQ9)%201O
MVG$VM$39G)4E M0 X*
M]!?0(.A9R1A:37V5L%!%8Y=J'%N18$XUQ.)FN/0 PM.YGX@ 9]*%I<
MJ&'J,Q 601)PBAA3IC%V8LH+>C1W$/8KB*//.+$:"YDNFT
MRE%)0A;D9HH$*\42PH39R4 M72D5EE2$;L%-]2ZR)'(=1=MQ
MSFM<.A V[[\:32YO!J-/PRM(>W2+J\7P\_!V
MP\L1_1C^8PCZ!V.8'S9?WMU.AG]_P"),BJO!I\$'P\[QGT \_$85@
M??+P?C(=31^F0_'A[NZ*9,S'3(;CSZ/+X>2MN+DCR5^+A\FPAINF R8 QT!"
MF":^'B8CEM7H%FXR?KB?CNYNM:H_WGV!,$ -NO6+!WM\PZY'(W_H4.)IFP
MZN_ XN - 3J],^*4=98CV)T+097GW'.56XNM $F
M &"HP^7YD ',$()QZ"-FE"I+
M=VE"<1& ( J
M\D?FF7D2ZEL:JX4"K42? ,(S(3&X7$8Z36H.
M+I(]VQ*1"0H)]Q2]4\;<^)8GD  3 M/+9/2 M:7Q:3^\2Z'$'MB1)
M"E[FCD&P 2U8YUJ(O1Q? B$%>7%0T%&36,J'?03J!0E(DA]
M2>3P3G9 "'%5HKSS" QU7, .X@ R_VYXY0]8/N
MT9.W%23N)R5!N("ZCUS/F 8$L&5"1!N3+T,ZGU1:.-<3 B
M?Z83S>^9 .B6^SSUKTX,]QS
MAHDNU(KFC!!7?O)UBRF39FV54C0V!6&>[PT+)$= M9&.L)HI=3CE!*I,\H.Y4Y*6] T
M;)2!GY\\%^;A'UP,\Q+9_TJ^?< M2B-EK0^U>_&
MLD2_"&$45J!,UH])AK.0BQ8N>KTL+OH.Q;M.2'FQ3E0 D)&04:V%%\B55G\2
M!=1B6S ">J51I$\.6;QLRUL5!<<,;(K2
M"K6]I=$2-)IW:T5KH3 0OKS;KN/R2N]G M)V!.%- 9]OF1GNV+F
M=+Z421I [C4Q29%=Q64<49S1'/]->9Z8.%!B8* A=_3_ZGNN\H!!PNP;/9G&
MV8\\<)% I.[Y_*?=&=.=VS>UD/\=Q7MGZ-5:.-L[94 E354G9;*X2-2,=+2U
MC6:0 AYU?X>H*%!$
MPD:Y$)N^UP0]5AQOIOXJ1B"QI[Q,7W-9LM0)UN9:!?7(8H .A%C.E\
M<7>]0.M>D IXR!0K5B&
MM -$?V?'-B=\1Z/35FW9)HVT=G9L6Q;K4/7M
MX !\&
MI _V6V7W.FZS7_!!-0M7+U0&/
MUN)Q*>G;I[=% ?EZ6?[VGU!W:BW$NWVB(_QW\5I,4AFG8O19-V'X'V5Q=;SU
M*=G)M+[??OL " + M$9\*0'<);!\E"%M2)K;@ ?
MWM7*QQW*XT5>U2C5 4:7V$/G'AB"NUXH%W[P5F
M;N4>;OW $Q6&J-?%D;!HR7+$ N_;H74R)3QAD]Z67=
MZ=);P_P&?9C9SU^S0 K
MZ&3,Y*@ A,^,/O% T6<
MGBHTX^;I1O%!8192=YNM56_59XPLG* FH>KK^09VHH4=-[$/$G/!,[C4
M&E7%T1'+-]+MM%0DW>0 !)6  WPA&0!GJZP^*B*%W)VL>*3
MOZLL5C"]&/M-< 3G &4,?L10C%G M*>1$K$P?8'\L)QSCQ. "<*>P"> CQ\_LB"8>MYUQ(
M)B(C?0CXFBT75\Z\ AXT*'CT 68]N9:H"DN7QY?$Y4U21&/2GW$?+
M GN,O8N29NE&18+27BT<]2'G"O&8.E%7Q['ZT/(KP^_6&=(O,B?B%%T3 11M&GK?SN"BJ=0WZL
M(?7OX(QC^U8'JK/*7,P<, Q"K31C POP!FX5^4W05
MUTE>=$,LY;EL1/-B0Z*GWGB.T$?3[K39 )-%AUQ$/.
MM<-VBR>3[UR[_Z.Y]+4!)9K T2LB[]I9S,91A?(V"% M/ ZF_!*E,4)QEJ:K,^/+TI>
M3R9T<>9]TE';,.&%14=6**7T!2P.RZ(J":-8 EFQO$]')V+O:%5E
M[/"W*0O'R$0[]&4F!%YN 0U=1OB3 E[M2ALF57H.'
MU/2UNLM,V%E.*5?$N]YXZAPQ(E9AX!M&F BQI"L& A^!2+,
M>MCB[+B26 DB'&1O
M'/9Z>>R< ?U*UP[/!Y;^'[Z&Z&U?'
MN'> I7IFU+PB('A%XICG1V
M%^^3VC2!+9 E+T^&K]Z)^(^%^SF, 7XX2P%VE" R^E:T,O!
MAZ3K=]TM<>H,7_YP"9CM'V* MA(KSU&%;Q=11U'R_T6]*TFBCS(1/)HU\GF$ G(FY?ODJ<
M4!3E&>) ;9M&:MN*BI5T SY
M< %SF<:(J&V$KL)$S"QBEE^%&>U5_9UP%"MZ$1]Y+&0,$Z)JNJD'.:]N$<%'
M*J> 6Z:ZRO9RJ:R]N/+P.[%<PBO[)
M-0,9S/. SZR$8TOEB9I8P^?5L:[+VE_-?JM=K)-+86RK;[=8WW5(W75*%+-R
MA ++C*J+B  Y*;V9\
M3=X_OR/DPR%YR36ZIX"+ SD[;_(N<]Q
MD&/QIC%O&,?B5/5&+KP78CT>_M_ D[QO
M]&U,F>HCPY7YNH(MK5Z:+=? KG\3 M_Y3KO
M>X]W*BOTB:QGC (?K;RZM$/I%D,',%JY??
MY6"83?H@ SK9SQ]9BLMU+-"DIINI<\./
M& <S3"IZ*ETH\ +24%5YZMAOE5!'"0 'I$\O(5S/0LK
MEBG^"_^ZU0.!T09\*[8_F7C7OKM(7AZ'1%5 .&].AN?G/V%8HBEX,%IT9"EH
MFQMLE] 3K\DG:52V/VB_*72O!+Q!>DT4/4Y $J_H.Y%7IP>3

@_date: 1995-10-31 05:26:43
@_author: "Theodore Ts'o" 
@_subject: Re: /dev/random for FreeBSD [was: Re: /dev/random for Linux] 
Date: Mon, 30 Oct 1995 20:16:24 +0200
   From: mark (Mark Murray)
   A colleague drew my attention to this, and I was so pleased with it that
   I ported it to FreeBSD.
Which version did you grab?  More recent versions of the driver use a
more efficient mixing algorithm suggested by Colin Plum.  There's also
the beginnings of support for user-mode deamons to add randomness into
the random pool by writing to /dev/random.  I also added support for
reading the instruction timing register for x86 platforms that support
it.    2) We felt that hooking all interrupts might be dangerous. IDE drives can
   interrupt at a heck of a rate, and so can some serial ports, and we felt
   that in these cases _not_ using the interrupt was a good idea. So I
   added an ioctl to allow the superuser to select his own set, appropriate
   to the hardware in use. It is nearly impossible to do this automatically.
Indeed; I can't emphasize this enough.  The clock interrupt, for
example, is a very bad irq to try to use.  In the Linux driver, only
device drivers who register their interrupt driver with the
SA_SAMPLE_RANDOM flag actually have the interrupt timings sampled for
the random number generator.
People have suggested using making it possible to select at run-time
which interrupts to sample, instead of at compiling it into the device
drivers.  I've generally not been convinced this is a good idea, because
most system administrator won't likely know which irq's are good and
which are bad for random number generation.  For example, although it
may not be obvious, the network interrupt may not be a good choice,
since an adversary who is monitoring the ethernet cable can make a
pretty good guess about the timing of your network interrupts, and hence
what the likely inputs are to the random number pool might be.
   Gimme a yell if you want copies :-)
Sure, why not.   I'd be interested to see what you did.

@_date: 1995-10-31 07:10:10
@_author: "Theodore Ts'o" 
@_subject: Re: /dev/random for FreeBSD [was: Re: /dev/random for Linux] 
Date: Mon, 30 Oct 1995 21:25:50 +0200
   From: mark (Mark Murray)
   Version 0.92 21st Sept 1995.
Yup, there's a more recent version in the Linux tree at this point.
   Something I didn't mention earlier; we felt that letting the unwashed
   masses read /dev/*random was not a good idea, as they could deplete
   the pool of entropy all to easily for attack purposes. That should be a system administration issue.  If someone wants to make
I don't see any point in trying to enforce that in the kernel code.
I don't agree that restricting read access is useful.  First of all, if
the pool of entropy is depleted, someone who tries to obtain entropy by
reading /dev/random will know that they didn't get enough entropy.  So
assuming a program that actually checks return values from system calls,
this is at worse a denial of service attack, and there are much easier
ways of performing those srots of attacks: "while (1) fork()", for
Secondly, making /dev/random only readable by "privileged programs"
means that people won't be able to compile their own version of PGP that
can take advantage of the random number generator.  Instead, they would
have to use a setuid version of PGP, and I'm quite sure PGP wasn't
written such that it would be safe to turn on its setuid bit.  Finally, even if you did have trustworthy applications which you could
setuid and only allow those programs to have access to /dev/random,
someone who repeatedly ran those applications could still end up
depleteing the pool of entropy.
So in the general case I would advise that /dev/random be left world
readable, since you *do* want general user programs to have access to
high quality random numbers.     For the same (or similar) reason, giving the said unwashed masses
   _write_ privelige might allow them to set /dev/*random to a known
   state. You've probably already thought of this, but I just had to say
   it :-).
Again, /dev/random can be set to whatever permissions the system
administrator wants.  Secondly, writing to /dev/random merely adds
randomness to the pool, via the mixing algorithm.  It won't actually
permit people to *set* the state of the pool, and assuming that the
state of the pool is not known before the write operation, writing to it
won't allow the user to know what the state is after the write
The ioctl() which sets the entropy estimate, however, *does* need to be
runnable only by the superuser, however, since that does represent an
attack path.
And, for race condition reasons, something which I need to implement
soon is an ioctl(), usuable only by root, that simultaneously updates
the entropy estimate *and* submits data to be mixed into the pool.  (Why
this is necessary should be obvious after a few minutes thought.)
   > For example, although it
   > may not be obvious, the network interrupt may not be a good choice,
   > since an adversary who is monitoring the ethernet cable can make a
   > pretty good guess about the timing of your network interrupts, and hence
   > what the likely inputs are to the random number pool might be.
   Are you sure about this? The stochastisity if this would be pretty
   hefty. Not only would our attacker have to get the _time_ that the
   interrupt occurred (if it interrupted our machine), he would then have
   to process in brute-force mode all possible times in his error range.
   What is more, more interrupts are coming in...
I didn't say that it would be trivial for an attacker to do this, but
it's certainly *doable*.  Some of the network traffic analyzers that
have been made available (I think Sandia National Labs has one that does
this), records down to millisecond accuracy when a packet was sniffed on
the network.  For this reason, people shouldn't really trust initializing PGP's random
number generator over a network connection, since it is possible for an
adversary to obtain very high quality timings of when your telnet or
rlogin packets appeared on the network, and hence be able to guess
(within some error range) what the interkeyboard timings which PGP used
to initialize its random number generator.
The adversary might have to try a large number of possibilities, but if
the number of possibilities is less than a brute-force search, you
definitely have a weakness --- a fact which Netscape learned to its
embarassment a few weeks ago.
   Hokay! Please also send me _your_ latest. (BTW - did Linus put it in
   his latest kernel?)
Yup.  1.1.34 and higher has most of my changes.  (I'm still making
changes which are still in development, though.  Mostly incremental
improvements of one sort or another.)

@_date: 1995-10-31 07:47:22
@_author: "Theodore Ts'o" 
@_subject: Re: /dev/random for FreeBSD [was: Re: /dev/random for Linux] 
Date: Mon, 30 Oct 1995 23:48:24 +0200
   From: mark (Mark Murray)
   > Secondly, making /dev/random only readable by "privileged programs"
   > means that people won't be able to compile their own version of PGP that
   > can take advantage of the random number generator.  Instead, they would
   > have to use a setuid version of PGP, and I'm quite sure PGP wasn't
   > written such that it would be safe to turn on its setuid bit.     How about SetGID? We were going for 660 root.kmem.
Bad idea; anyone who can run PGP could then get instant access to kmem
   > Again, /dev/random can be set to whatever permissions the system
   > administrator wants.  Secondly, writing to /dev/random merely adds
   > randomness to the pool, via the mixing algorithm.  It won't actually
   > permit people to *set* the state of the pool, and assuming that the
   > state of the pool is not known before the write operation, writing to it
   > won't allow the user to know what the state is after the write
   > operation.
   What happens if some attacker does:
   for (;;) {
   }
   ? "Gut feel" suggests to me that large ammounts of "predicted" input might
   be worse than the normal sort of system noise you have been using.
But keep in mind that what we're doing is XOR'ing the input data into
the pool.  (Actually, it's a bit more complicated than that.  The input
is XOR'ed in with a CRC-like function, generated by taking an
irreducible polynomial in GF(2**128).  But for the purposes of this
argument, you can think of it as XOR.)  So since you don't know what the
input state of the pool is, you won't know what the output state of the
Also, you never get to see the actual state of the pool, even when you
read out numbers from /dev/random.  What you're getting is a *hash* of
the pool.  So if you can actually implement
check_to_see_if_state_is_crackable(), then you've found a weakness in
MD5 (or SHA, to which I'll probably be switching in the near future).
   > And, for race condition reasons, something which I need to implement
   > soon is an ioctl(), usuable only by root, that simultaneously updates
   > the entropy estimate *and* submits data to be mixed into the pool.  (Why
   > this is necessary should be obvious after a few minutes thought.)
   Clue me in - I'm not quite with you? :-)
Consider this scenario:
1)  Process one writes randomness to /dev/random.
2)  Process two immediately consumes a large amount of randomness using
3)  Process two uses the ioctl() to bump the entropy count by the amount
of randomness added in step 1.  Unfortunately, that entropy was already
consumed in step 2.
   > I didn't say that it would be trivial for an attacker to do this, but
   > it's certainly *doable*.  Some of the network traffic analyzers that
   > have been made available (I think Sandia National Labs has one that does
   > this), records down to millisecond accuracy when a packet was sniffed on
   > the network.     Is this millisecond accuracy quantifiable in terms of bits of entropy?
   if so, the ethernet is surely safe?
Well, no.  If you're only using as your timing the 100Hz clock, the
adversary will have a better timebase than you do.  So you may be adding
zero or even no bits of entropy which can't be deduced by the adversary.
This is even worse in the PGP keyboard timing case, since the adversary
almost certainly can find a better time resolution to measure your
incoming packets when compared to the timing resolution that most
programs have.  Far too many Unix systems only make a 100Hz clock
available to the user mode, even if you have a better quality high
resolution timing device in the kernel (for example, the Pentium cycle
counting register).
   Again, if you can quantify the number of possibilities into bits of entropy,
   your code is good. Depending on current technology, this may have to change.
The problem is that in order to do this requires making assumptions
about what the capabilities of your adversary are.  Not only does this
change over time, but certain adversaries (like the NSA) make it their
business to conceal their capabilities, for precisely this reason.
So I like to be conservative and use limits which are imposed by the
laws of physics, as opposed to the current level of technology.  Hence,
if the packet arrival time can be observed by an outsider, you are at
real risk in using the network interrupts as a source of entropy.
Perhaps it requires buidling a very complicated model of how your Unix
scheduler works, and how much time it takes to process network packets,
etc.  ---- but I have to assume that an adversary can very precisely
model that, if they were to work hard enough at it.
People may disagree as to whether or not this is possible, but it's not
prevented by the laws of physics; merely by how much effort someone
might need to put in to be able to model a particular operating system's
networking code.  In any case, that's why I don't like depending on
network interrupts.  Your paranoia level may vary.

@_date: 1995-10-31 11:52:56
@_author: "Theodore Ts'o" 
@_subject: Re: /dev/random for FreeBSD [was: Re: /dev/random for Linux] 
Date: Mon, 30 Oct 1995 21:59:14 -0500
   From: stripes ("Josh M. Osborne")
   When /dev/random doesn't have "enough" enthropy left does reading
   from it return an error, or block?  I would strongly suggest
   blocking, as the non-blocking behavur is not really all that useful.
It acts like many character devices and named pipes in that if there is
no entropy available at all, it blocks.  If there is some entropy
available, but not enough, it returns what is available.  (A subsequent
read will then block, since no entropy will then be available.)
Actually, what's currently in Linux doesn't work precisely like this,
but it will soon.  After talking a number of people on both sides of the
block vs. non-blocking camp, this seemed to be a suitable compromise.
At least one Major Workstation Vendor is planning on using this behavior
for their /dev/random, to appear in a future OS release.  If we all can
standardize on this behavior, it'll make application writer's jobs that
much easier.

@_date: 1995-11-01 05:48:18
@_author: "Theodore Ts'o" 
@_subject: Re: /dev/random for FreeBSD [was: Re: /dev/random for Linux] 
Date: Tue, 31 Oct 1995 19:15:35 +0200
   From: mark (Mark Murray)
   >    Is this millisecond accuracy quantifiable in terms of bits of entropy?
   >    if so, the ethernet is surely safe?
   >    > Well, no.  If you're only using as your timing the 100Hz clock, the
   > adversary will have a better timebase than you do.  So you may be adding
   > zero or even no bits of entropy which can't be deduced by the adversary.
   In a 386 or a 486 (under FreeBSD at least) there is a 1Mhz clock available.
   How would _this_ be? On the Pentium there is the  register
   which will give the board's oscillator (or 90 MHz) I believe.
What's HZ set at for FreeBSD?  Most of the x86 Unixes have generally
used HZ set at 100, because the interrupt overhead on a x86 isn't cheap,
and so you want to limit the number of clock interrupts.
You can sample the timing clock, but it turns out to be rather expensive
to do so; several I/O instructions, which will require several delays if
they have to go through your 8 MHz ISA bus.  We've moved away from using
the hardware clock on the 386 because of the overhead concerns.  On the
Penitum, we use the clock cycle counter.
   What then is a body to do? Preserve all _verifiable_ randomness like gold?
   Dish it out under some quota? A denial of service attack would be
Well, verifiable randomness really is like gold.  It's a valuable
resource.  On a time-sharing system, where you really want to equitably
share *all* system resources perhaps there should be a quota system
limiting the rate from which a user is allowed to "consume" randomness.
On the other hand, most Unix systems *aren't* great at doing this sort
of resource allocation, and there are enough other ways of launching
denial of service attacks.  "while (1) fork();" will generally bring
most systems to their knees, even in spite of limitations of the number
of processes per user.  Most Unix systems don't protect against one user
grabbing all available virtual memory.  And so on....
   forever {
   }
   Severely limiting most decent folk's chance at getting PGP to work.
If you have such a "bad user" on your system, and the PGP /dev/random
code is written correctly, it will only be a denial of service attack.
But it'll be possible to identify who the bad user is on your system,
and that person can then be dealt with, just as you would deal with some
user that used up all of the virtual memory on the system trying to
invert a 24x24 matrix, or some such ---- in both scenarios, the ability
for another user to run PGP is severely limited.  There's nothing special about /dev/random in this sense; it's just
another system resource which can be abused by a malicious user, just
like virtual memory or process table slots.
   > So I like to be conservative and use limits which are imposed by the
   > laws of physics, as opposed to the current level of technology.  Hence,
   > if the packet arrival time can be observed by an outsider, you are at
   > real risk in using the network interrupts as a source of entropy.
   > Perhaps it requires buidling a very complicated model of how your Unix
   > scheduler works, and how much time it takes to process network packets,
   > etc.  ---- but I have to assume that an adversary can very precisely
   > model that, if they were to work hard enough at it.
   This is a strong argument for some form of specialised noise source.
   I have read of methods of getting this from turbulent air flow in a hard
   drive (an RFC, I believe).
Yes, ultimately what you need is a good hardware number generator.
There are many good choices; from radioactive decay, noise diodes, etc.
I'm not entirely comfortable with the proposal of using air flow
turbulance from a hard drive, myself, because the person who suggested
this still hasn't come up with a decent physical model which tells us
how many bits of true entropy this system really provides.  What Don
Davis did was to develop more and more sophisticated models, and
demonstrated that his more sophistcated models weren't able to explain
the "randomness" that he observed in the time that it took to complete
certain disk requests.  However, that doesn't prove that the
"randomness" is really there; it's just that he couldn't explain it
away.  It might be that the NSA has a much better model than Don Davis
was able to come up with, for example, and the amount of randomness from
air turbulance really is a lot less than one might expect at first
Short of good hardware sources, the other really good choice is
unobservable inputs.  Hence, the Linux driver is hooked into the
keyboard driver, and the various busmice drivers.  Those are really
wonderful sources of randomness, since they're generally not observable
by an adversary, and humans tend to be inherently random.  :-)

@_date: 1995-11-07 12:18:42
@_author: "Theodore Ts'o" 
@_subject: Re: /dev/random - using up entropy? 
Date: Sat, 04 Nov 1995 15:52:03 -0800
   From: stewarts (Bill Stewart)
   So that says you use up m bits of entropy if you get m bits of good output.
   However, what I'd like to suggest is that you don't, from the perspective
   of a user who doesn't have direct access to the reservoir R of random bits.
   For that user, p(X|H(R)=O) is the same as p(X) or P(X|H(R)=O'), because
   the user is neither able to invert H, nor to enumerate all possible R,
   nor to calculate anything useful based on multiple outputs, since the
   reservoir R is shuffled between outputs; even a simple circular shift
   may be enough.   This doesn't apply to the case where n is 32 or 48
   and the hash function produces n-bit outputs, or even m<<n bit outputs,
   because that maybe be inverted or brute-forced, but it seems to apply
   for the case where n is sufficiently large and the hash is good.
   If the hash is simpler than MD5, it may apply anyway, since the hash
   produces far fewer bits than its input, as long as the hash and the
   mixing function don't give away any information about the reservoir
   between successive outputs.
All of this assumes that MD5 or SHA, or whatever, is a "good hash
function".  Unfortunately, this strikes at the heart of "what we don't
know" about writing good hash functions, which is still today much more
of an art rather than a science.
So the conservative among us will probably not want to count on this
fact when generating long-term, valuable secrets, like public/private
   This would suggest that /dev/random ought to have a mode that says
   "give me output of whatever quality you have available",
   and that it ought to be OK to use it, as long as the reservoir has    been seeded with sufficient high-entropy input to have decent randomness.
Yup; in the Linux implementation which I've done, that's what the
good enough.  However, I would character it as numbers which are
"cryptogrphically random", as opposed to "truely random", in that they
depend on the intractibility of MD5 towards analysis.  One can imagine
descending scale of "quality of random numbers" where physically
generated random numbers would best, followed by /dev/random numbers,
followed by /dev/urandom numbers.  It may be that /dev/urandom is just
as hard as /dev/random --- but given the our current knowledge, it's
impossible to prove one way or the other.  P.S.  Here's the header from my current /dev/random driver, if people
are interested:
 * random.c -- A strong random number generator
 *
 * Version 0.95, last modified 4-Nov-95
 *  * Copyright Theodore Ts'o, 1994, 1995.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, and the entire permission notice in its entirety,
 *    including the disclaimer of warranties.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *  * ALTERNATIVELY, this product may be distributed under the terms of
 * the GNU Public License, in which case the provisions of the GPL are
 * required INSTEAD OF the above restrictions.  (This clause is
 * necessary due to a potential bad interaction between the GPL and
 * the restrictions contained in a BSD-style copyright.)
 *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 * (now, with legal B.S. out of the way.....)  *  * This routine gathers environmental noise from device drivers, etc.,
 * and returns good random numbers, suitable for cryptographic use.
 * Besides the obvious cryptographic uses, these numbers are also good
 * for seeding TCP sequence numbers, and other places where it is
 * desireable to have numbers which are not only random, but hard to
 * predict by an attacker.
 *
 * Theory of operation
 * ===================
 *  * Computers are very predictable devices.  Hence it is extremely hard
 * to produce truely random numbers on a computer --- as opposed to
 * pseudo-random numbers, which can easily generated by using a
 * algorithm.  Unfortunately, it is very easy for attackers to guess
 * the sequence of pseudo-random number generators, and for some
 * applications this is not acceptable.  So instead, we must try to
 * gather "environmental noise" from the computer's environment, which
 * must be hard for outside attackers to observe, and use that to
 * generate random numbers.  In a Unix environment, this is best done
 * from inside the kernel.
 *  * Sources of randomness from the environment include inter-keyboard
 * timings, inter-interrupt timings from some interrupts, and other
 * events which are both (a) non-deterministic and (b) hard for an
 * outside observer to measure.  Randomness from these sources are
 * added to an "entropy pool", which is mixed using a CRC-like function.
 * This is not cryptographically strong, but it is adequate assuming
 * the randomness is not chosen maliciously, and it is fast enough that
 * the overhead of doing it on every interrupt is very reasonable.
 * As random bytes are mixed into the entropy pool, the routines keep
 * an *estimate* of how many bits of randomness have been stored into
 * the random number generator's internal state.
 *  * When random bytes are desired, they are obtained by taking the MD5
 * hash of the contents of the "entropy pool".  The MD5 hash avoids
 * exposing the internal state of the entropy pool.  It is believed to
 * be computationally infeasible to derive any useful information
 * about the input of MD5 from its output.  Even if it is possible to
 * analyze MD5 in some clever way, as long as the amount of data
 * returned from the generator is less than the inherent entropy in
 * the pool, the output data is totally unpredictable.  For this
 * reason, the routine decreases its internal estimate of how many
 * bits of "true randomness" are contained in the entropy pool as it
 * outputs random numbers.
 *  * If this estimate goes to zero, the routine can still generate
 * random numbers; however, an attacker may (at least in theory) be
 * able to infer the future output of the generator from prior
 * outputs.  This requires successful cryptanalysis of MD5, which is
 * not believed to be feasible, but there is a remote possiblility.
 * Nonetheless, these numbers should be useful for the vast majority
 * of purposes.
 *  * Exported interfaces ---- output
 * ===============================
 *  * There are three exported interfaces; the first is one designed to
 * be used from within the kernel:
 *
 * 	void get_random_bytes(void *buf, int nbytes);
 *
 * This interface will return the requested number of random bytes,
 * and place it in the requested buffer.
 *  * The two other interfaces are two character devices /dev/random and
 * /dev/urandom.  /dev/random is suitable for use when very high
 * quality randomness is desired (for example, for key generation or
 * one-time pads), as it will only return a maximum of the number of
 * bits of randomness (as estimated by the random number generator)
 * contained in the entropy pool.
 *  * The /dev/urandom device does not have this limit, and will return
 * as many bytes as are requested.  As more and more random bytes are
 * requested without giving time for the entropy pool to recharge,
 * this will result in random numbers that are merely cryptographically
 * strong.  For many applications, however, this is acceptable.
 *
 * Exported interfaces ---- input
 * ==============================
 *  * The current exported interfaces for gathering environmental noise
 * from the devices are:
 *  * 	void add_keyboard_randomness(unsigned char scancode);
 * 	void add_mouse_randomness(__u32 mouse_data);
 * 	void add_interrupt_randomness(int irq);
 * 	void add_blkdev_randomness(int irq);
 *  * add_keyboard_randomness() uses the inter-keypress timing, as well as the
 * scancode as random inputs into the "entropy pool".
 *  * add_mouse_randomness() uses the mouse interrupt timing, as well as
 * the reported position of the mouse from the hardware.
 *
 * add_interrupt_randomness() uses the inter-interrupt timing as random
 * inputs to the entropy pool.  Note that not all interrupts are good
 * sources of randomness!  For example, the timer interrupts is not a
 * good choice, because the periodicity of the interrupts is to
 * regular, and hence predictable to an attacker.  Disk interrupts are
 * a better measure, since the timing of the disk interrupts are more
 * unpredictable.
 *  * add_blkdev_randomness() times the finishing time of block requests.
 *  * All of these routines try to estimate how many bits of randomness a
 * particular randomness source.  They do this by keeping track of the
 * first and second order deltas of the event timings.
 *
 * Acknowledgements:
 * =================
 *
 * Ideas for constructing this random number generator were derived
 * from the Pretty Good Privacy's random number generator, and from
 * private discussions with Phil Karn.  Colin Plumb provided a faster
 * random number generator, which speed up the mixing function of the
 * entropy pool, taken from PGP 3.0 (under development).  It has since
 * been modified by myself to provide better mixing in the case where
 * the input values to add_entropy_word() are mostly small numbers.
 *  * Any flaws in the design are solely my responsibility, and should
 * not be attributed to the Phil, Colin, or any of authors of PGP.
 *  * The code for MD5 transform was taken from Colin Plumb's
 * implementation, which has been placed in the public domain.  The
 * MD5 cryptographic checksum was devised by Ronald Rivest, and is
 * documented in RFC 1321, "The MD5 Message Digest Algorithm".
 *  * Further background information on this topic may be obtained from
 * RFC 1750, "Randomness Recommendations for Security", by Donald
 * Eastlake, Steve Crocker, and Jeff Schiller.
 */

@_date: 1997-01-31 20:26:23
@_author: "Theodore Y. Ts'o" 
@_subject: Re: CAST 
Date: Fri, 31 Jan 1997 12:42:23 -0500
   From: jya (John Young)
   For a paper on CAST see:
         "Constructing Symmetric Ciphers Using the CAST Design Procedure"
That URL didn't work, but the following URL did....
Does anyone know what the intellectual property status of CAST is?
