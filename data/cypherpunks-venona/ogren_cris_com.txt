
@_date: 1996-05-30 09:47:20
@_author: "David F. Ogren" 
@_subject: Re: [crypto] crypto-protocols for trading card games 
I've had similar ideas, but there are snags.  Card playing via encryption techniques is a great idea in theory, but in reality the
technical requirements often prevent implementation.
Think of the requirements of this system:
1. Cards must be transferrable.
2. Cards must not be duplicated by anyone other than the game 3. Cards must be able to be randomly shuffled.  (Since most trading
card games are two-player games our task is simplified greatly.)
Here is one possible algorithm, and some of its weaknesses.
The game company generates a master public key pair with which it will
sign all game cards.  Each player generates a public key pair to
verify his identity.
Each card is composed of the following fields:
A serial number, so that each card is unique.
A public key generated by that the owner as a proof of indentity.    (Each card owned by a player will have the same public key.)
The name of the card and (optionally) a desception of its effects.
Each card is then signed using the game company's secret key.
For each game both partners generate a public key pair.  Alice then
signs each card in her deck with the public key she generated for this
game and then transmits the cards (in a random order) to Bob. Bob does
the same thing for his deck. Each time Alice needs a card, Bob selects
one of Alice's encrypted cards and Alice decrypts it. As an additional measure to determine that Bob's cards are genuine,
Alice sends Bob a random string and asks that he sign it with the
secret key that matches the indentity-verifying public key on his
cards.  If Bob can return a signed version of that string, the
ownership of his cards is verified.  This indentity verifying routine
can be conducted as soon as Bob's first card is revealed. Bob of
course, conducts the same procedure for Alice after she plays her
first card.
After the game is over (or Alice's deck needs to be reshuffled), she
reveals her secret key and Bob verifies that her cards are genuine and
that she played fairly.
This system prevents anyone other than the game company from
duplicating cards (each card has a unique serial number), and from
copying other people's cards (each card has an indentifying public
Any cheating can be discovered at the end of the game.  Bob knows the
order in which he selected Alice's encrypted cards.  After the game,
when Alice hands over her game-session secret key, he can check to
make sure that Alice revealed her cards in the order he selected them.
Only a reasonably amount of encryption/decryption is required.  Most
importantly only one key per player needs to be generated for each
shuffle.  During play only decryption is required.  In other words, a
modicum of set up is required, but once play begins the decryption
shouldn't slow the program down appreciably.
The entire integrity of the system relies on the security of the
game company's key pair.  If the secret key is comprimised, either by
a disloyal employee or by crytographic techniques, all cards in
existence must be recreated.
Cards are not transferrable.  In order to make cards transferrable the
game company must be able to invalidate cards which have been traded
to others.  In other words if Alice wants to give a cards to Bob she
1. Contact the game company and tell them she wants to give the card
to Bob. 2. The game company must issue a new card to Bob with a new
serial number and with Bob's public key rather than Alice's. 3. The
game company must invalidate Alice's old card.  Since there is no way
that the game company can make sure all copies of the card have been
destroyed it must create a "invalid serial number list" and have the
players dial into that list everytime the game is played.
Since step 3 is so costly to implement, I think it is unlikely that a
cryptography-based trading card game will have tradable cards.
David F. Ogren
ogren (alternate address: dfogren
PGP Key ID: 0xC626E311
PGP Key Fingerprint: 24 23 CD 15 BF 8D D1 DE  81 71 84 C8 2C E0 4B 01
(public key available via server or by sending a message to
ogren with a subject of GETPGPKEY)

@_date: 1996-05-31 20:12:29
@_author: "David F. Ogren" 
@_subject: (Fwd) Re: [crypto] crypto-protocols for trading card games 
Gary Howland asked me to forward his response to the mailing-list:

@_date: 1996-05-31 20:40:44
@_author: "David F. Ogren" 
@_subject: Re: [crypto] crypto-protocols for trading card games 
In my earlier message I said:
Gary Howland said:
Me again:
Mr. Howland again:
And herein lies the problem with an implementation of trading card
games.  In order to detect "double spenders", the system must be
on-line.  However, I believe going on-line will drive the costs of
running such a game out of the range of commercial feasibility.
First of all, it requires that all players have Internet access.  This
reduces marketability.
Secondly, it requires that both players make an Internet connection
with the game company everytime they want to play a game.  This will
incur costs to the game company that it invariably will want to pass
on to the players.  Players, however, will be very resistant to a game
that requires a subscription fee as well as costs for purchasing
"cards".  Especially, if becomes known that the only reason for the
game requiring on-line access is to prevent "cheaters".  It also
raises the question of whether the game program could be "hacked" to
avoid checking for authenticity of cards.
I think that a more realistic solution to the "double spending" problem is to not allow the transfer of cards between players.
David F. Ogren
ogren (alternate address: dfogren
PGP Key ID: 0xC626E311
PGP Key Fingerprint: 24 23 CD 15 BF 8D D1 DE  81 71 84 C8 2C E0 4B 01
(public key available via server or by sending a message to
ogren with a subject of GETPGPKEY)

@_date: 1996-05-31 20:56:02
@_author: "David F. Ogren" 
@_subject: Re: Where does your data want to go today? 
Using a random IV also limits the effectiveness of using known headers for "known plaintext" attacks.  Also note that a good block cipher isn't that vulnerable even to "known plaintext" attacks.
David F. Ogren
ogren (alternate address: dfogren
PGP Key ID: 0xC626E311
PGP Key Fingerprint: 24 23 CD 15 BF 8D D1 DE  81 71 84 C8 2C E0 4B 01
(public key available via server or by sending a message to
ogren with a subject of GETPGPKEY)

@_date: 1996-06-01 19:27:17
@_author: "David F. Ogren" 
@_subject: Re: Where does your data want to go today? 
Bill Frantz: I will concede that having a known header, such as a PKZIP header,
does weaken a crypto to certain degree, but I still believe that it is
not a significant problem.  Here's why:
1. If the best attack against the crypto system is to brute force
attack (having to decrypt two blocks per key) I don't consider that a
weakness. Assuming you are using IDEA or another 128 bit key algorithm
and if everyone in the world owned two computers, each powerful enough
to make a million attacks a second, and they all decided to cooperate
in cracking your key it would still take (on average) until the next
ice age to complete this attack.  Admittedly DES wouldn't hold up
nearly as well, but if you are using straight DES you have bigger
concerns than the occaisional known plaintext attack.
2. Known plaintext is something that you have to assume that your
enemy has at least occaisional access to.  Lots of messages have known
beginnings and endings.  Sure it would be nice to reduce the amount of
known plaintext, but I think there are much more significant concerns.
3. The disadvantages of not having the headers.  The headers are
there for a reason: to communicate that the following file is in a
specific format.  Without the headers, you have to use another secure
channel to communicate what file type is being transmitted.
Again, I concede that a crypto system would be more secure if no
known plaintext was ever transmitted, such as compressed file
headers.  But this minor loss of security is nearly inescapable and
also relatively insignificant.
David F. Ogren
PGP Key ID: 0xC626E311
PGP Key Fingerprint: 24 23 CD 15 BF 8D D1 DE  81 71 84 C8 2C E0 4B 01
(public key available via server or by sending a message to
ogren with a subject of GETPGPKEY)

@_date: 1996-06-22 08:16:40
@_author: "David F. Ogren" 
@_subject: Win95 Blowfish Implementation 
I am nearing completion of the alpha version of my Win95 Blowfish implementation aka "Hootie" (I couldn't resist).  Both the pre-releases and final version of Hootie will be freeware.
But before I do so, I want to double check by information on the rights to the following algorithms.  I'm only interested in US patents, since I won't be able to export it anyway.
So correct me if any of the following statements are incorrect:
1. Blowfish is not patented and can be used without royalty.
2. SHA can be used without royalty.
3. MD5 can be used without royalty if the RSAREF library is used, and if the proper credit is given to RSA.
Also, can the MD5 algorithm be used outside the RSAREF library?  In other words, can I rewrite the code to take in effect MFC classes?
I'll post more information about Hootie later. It's not an earthshattering or groundbreaking program.  I wrote it largely as a learning excercise in MSVC++, but it's a functional program with a good user interface so I decided to release it.
David F. Ogren
ogren (alternate address: dfogren
PGP Key ID: 0xC626E311
PGP Key Fingerprint: 24 23 CD 15 BF 8D D1 DE  81 71 84 C8 2C E0 4B 01
(public key available via server or by sending a message to
ogren with a subject of GETPGPKEY)

@_date: 1996-06-23 17:19:55
@_author: "David F. Ogren" 
@_subject: Re: Win95 Blowfish Implementation 
Thanks to everyone who replied to my original message.  I was confident I could use those algorithms (I wouldn't have spent months on the code otherwise) but I wanted to check one more time
before I publicly released software using them.
One question though.  The following text is quoted from Bill What exactly is the difference between SHA and SHA-1?  Is it the left circular shift when generating the W array?  I coded the SHA alogrithm according to _Applied Cryptography_ Second Edition.  Is that the updated version of SHA?
Many thanks.
David F. Ogren
Here is the super short description of Hootie:
Hootie is a Windows 95 implementation of the Blowfish algorithm.  It is a fully graphical interface which includes drag and drop support as well as Explorer launch.
It can support both CBC and ECB modes.  The passphrase can either be directly entered by the user or the passphrase can be SHA hashed before use.
Hootie can optionally add headers at the beginning of the file which automatically select the block encryption mode and confirm good passphrases, or (for people concerned about known-plaintext attacks) omit the headers.
Future features include: generation of keys via a TNG (which are then saved to file), using MD5 rather than SHA, and a primitive text editor which which can be encrypted/decrypted to/from.
I currently expect to release the alpha version in two to three David F. Ogren
ogren (alternate address: dfogren
PGP Key ID: 0xC626E311
PGP Key Fingerprint: 24 23 CD 15 BF 8D D1 DE  81 71 84 C8 2C E0 4B 01
(public key available via server or by sending a message to
ogren with a subject of GETPGPKEY)

@_date: 1996-07-01 15:47:27
@_author: "David F. Ogren" 
@_subject: Re: rsync and md4 
Are you sure?  MD5 is a 128 bit hash, and the probability of collision with a specific random piece of data (of any length) should be 2^-128.  I could be wrong, but do you have any explanation of why you think the answer is MD4 is the fastest hash I am aware of.  However, there has been some successful attacks against two rounds of MD4.  Although this is not to suggest that MD4 is insecure, MD5 almost as fast (~1.3 times slower) and more secure.
David F. Ogren                | ogren          | "A man without religion is like a fish
PGP Key ID: 0xC626E311        |  without a bicycle"

@_date: 1996-07-01 17:05:33
@_author: "David F. Ogren" 
@_subject: Re: rsync and md4 
But this isn't a birthday attack. Its a comparison between one specific file and one randomly chosen one.
Unless you are aware of some attack that I'm not, this is the most current information on MD4 and MD5:
MD4 has had successful attacks on limited rounds.  It has _not_ been completely cracked.
MD5 has not been broken.  A weakness has been shown, but collisions still cannot be developed.  So checksums should still be secure.  Additionally, in this case we are more concerned with the chance of random collisions than intentional collisions.
In fact, I was probably wrong to suggest MD5.  It _is_ more secure, but speed is his first priority, not security.  SHA1 is a good hash algorithm as far as security goes (I've used it myself), but it's over three times slower than MD4.

@_date: 1996-07-01 17:43:51
@_author: "David F. Ogren" 
@_subject: Re: rsync and md4 
I stand by my statements.  I have followed the current developments regarding MD5 with interest, and am using SHA1 in the program that I am currently authoring because of its MD5's weaknesses.
However, MD5 (and MD4) have not been completely cracked.  The problems that you bring up have to do with situations where an active attacker develops a slightly different pair of documents with the same hash.
Although this is highly undesirable characteristic for a hash function, and shows a weakness in the function that may eventually lead to its being completely cracked, it does not mean that a fraudulent document can be created from an already signed document.  This is an old argument and I don't want to get into it here.  However, there a lots of people that who still think MD5 can be safely used to a) sign documents that you create yourself, and b) sign documents that you have made cosmetic changes to.
Irregardless, this argument is moot.  This thread is titled "rsync and md4".  It is a discussion about which hash function suits this particular purpose and he is not particularly concerned with resistance to deliberate attack.  In this case MD4 will function adequately.

@_date: 1996-07-02 04:01:46
@_author: "David F. Ogren" 
@_subject: Re: rsync and md4 (my final comments) 
At this point, I can see that we have agreed to disagree.  Mr. Watt has kindly quoted the exact text from Dobbertin, which I did not have handy.  Let the readers of this list decide for themselves in regards to the security of MD5.
But I wanted to make two last comments before this thread (finally!) dies.
1. I think that you will agree that MD4 will work fine for Mr. Tridgell's program, irregardless of your criticisms.  He specifically stated that he was not concerned about intentional collisions, only random ones.
(quoted from Mr. Perry in an article entitled "MD5 breaks, etc.")
As I understand the current plans, PGP 3.0 _will_ incorporate a SHA option. In fact, I believe that there may already be "bootleg" versions that incorporate SHA.

@_date: 1996-07-02 06:32:05
@_author: "David F. Ogren" 
@_subject: Re: rsync and md4 
And I told myself I wouldn't respond to this thread anymore.  Oh well.  I just don't want to be misinterpreted.
I never meant to imply (and don't think that I did), that the attacks against MD5 were insignificant.  As I said, I'm moving to SHA in any software I develop from now on.
What I said was the attacks were insignificant in the application being considered (rsync) and that MD5 was not completely broken.  Come on, all the guy wanted was a fast 128 bit checksum.
For example, I am still using PGP clearsigning which, of course, uses MD5. Dobbertin indicates that his attack cannot be used against me as long as I only sign messages that I create myself.  Yes, PGP would work better with SHA.  I'd be able to sign documents that others created with (more) certainty.  But that doesn't mean that I should stop using PGP.
P.S. I apologize to the list for flooding this list recently.  Unfortunately, I took it a little too personally when Perry told me to "stop spewing inaccurate information" and to "quit posting".  It was late, and I let him bait me more than I ordinarily would.
Now I find myself running in circles trying to make sure that I've made myself clear and that no one else (other than Perry) is misintepreting what I'm saying.

@_date: 1996-07-03 12:32:09
@_author: "David F. Ogren" 
@_subject: Lack of PGP signatures 
I've noticed recently that two PGP programmers (Mr. Zimmerman and Mr. Atkins) do not seem to PGP clearsign their messages to this list. In fact, a surprisingly small percentage of messages on the C-punk list are signed. This despite the fact that the average subscriber is at least literate in Does anybody have any speculation on why this is?
Is it because people consider mundane mail unimportant enough to sign?
Is it because the members of this list are more concerned with encryption than authentication?
Is it because most mail programs are not PGP aware?
Is it because of the weaknesses in MD5?
David F. Ogren                |
ogren          | "A man without religion is like a fish
PGP Key ID: 0x6458EB29        |  without a bicycle"

@_date: 1996-07-03 15:18:36
@_author: "David F. Ogren" 
@_subject: Re: Lack of PGP signatures 
From the responses I received, this one may be a biggie.  And it's one that we can't do much about remedying.
I'm beta testing a PGP aware mailer right now called Pronto Secure.  It will be a great program when its release.  Requires almost no PGP knowledge.  Everything is almost perfectly transparent to the user.
There is also Private Idado, of course, but that's a little harder to use, and doesn't have the features of a full-fledged mailer.
I figure that if strong encryption becomes legal to export from the US (making international standards easier to implement), we may see more programs like these.
David F. Ogren                |
ogren          | "A man without religion is like a fish
PGP Key ID: 0x6458EB29        |  without a bicycle"

@_date: 1996-07-04 07:58:05
@_author: "David F. Ogren" 
@_subject: Re: Lack of PGP signatures 
Lots of people still deal with the Internet remotely, despite the profileration of SLIP/PPP accounts.  To see the the difference consider the following two scenarios:
1. Alice connects to the Internet via a PPP account.  She downloads all of her mail to Exchange (on her local computer), from which she can encrypt/decrypt et cetera.  All encryption is done locally and securely.
2. Bob connects to the Internet via a "shell" account.  All processing is done by his ISP's unix machine.  He reads his mail on the mail reader provided by unix machine.  He has two choices:
2A. Install PGP on the ISP's unix machine and use it to encrypt/decrypt messages.  This is relatively easy, but also insecure.  The ISP's administration has access to his secret keyring, and his password must be sent over the modem line to the ISP before it used.  Thus he is "typing his passphrase over the net".
2B. He can download the mail to his local machine manually.  Manually encrypt/decrypt the mail there and then upload it (again manually) to the host computer to be sent.  This is secure, but it's also a pain in the David F. Ogren                |
ogren          | "A man without religion is like a fish
PGP Key ID: 0x6458EB29        |  without a bicycle"

@_date: 1996-07-09 16:54:33
@_author: "David F. Ogren" 
@_subject: A case for 2560 bit keys 
Here is a few thoughts on RSA key sizes.  There is nothing new or revolutionary herein, but I think it does provide a good case for using large RSA keysizes.
Traditionally, we examine the threat model and determine the approximate ability of the attacker to factor secret keys.  Then a keylength is selected that exceeds the attackers ability to factor in a reasonable amount of time.
For example, if we assume that the NSA can factor any number with the speed of the special number sieve, and has 10^9 mips of computing power (doubling every 1.5 years) we can make the following estimations:_1_
Using these assumptions, the NSA could crack a 1024 bit key in ~11 days, a 1536 bit key in 10 years and a 2048 bit key in 26 years.  _2_  Note that this would require the full resources of the NSA, however.  Thus, even the mighty resources of the NSA could only crack 42 1024 bit keys in 1996 (including Moore's law). _3_, _4_
Similarly, a large corporation with 10^7 mips in computing power (and the same super-efficient factoring algorithm) could crack a 1024 bit key in 2 years, a 1536 bit key in 20 years, and a 2048 bit key in 36 years.
My interpretation of these results: 1024 bit is probably safe for most reasonable threat models.  Only individuals with extremely high threat models should be concerned about 1024 bit keys in 1996.  Even those with extremely high threat models should be satisfied with 1536 bit keys.
Despite the above, there are convincing arguments for longer RSA keys.  Instead of asking "Why should we have longer keys?", perhaps we should be asking "Why _shouldn't_ we have longer keys?"
In a hybrid cryptosystem such as PGP, very little of the computational process is consumed by RSA encryption.  Only a tiny fraction of the message is RSA encrypted (the session key), and thus the time-critical operation is the symmetric crypto system (IDEA for PGP).
As an experiment generate a 2047 bit PGP key and a 512 bit PGP key.  Encrypt a file (preferably of a reasonable size) using both keys.  Depending on the computer you are using, the time difference between the two keys will be a matter of few seconds or even a fraction of a second.
And so we have to ask ourselves, why _not_ use a 2047+ bit key.  It has greater longevity and greater security.  Why not be overcautious when the cost is so small?
It seems foolish that we use RSA keys that are less secure than our IDEA session keys.  Our RSA keys are much more valuable than our session keys.  I will use my RSA key to encode hundreds of messages.  Each session key I will use only once.  An attacker who learns one of my IDEA session keys can decrypt only that message.  An attacker who learns my RSA key can decrypt any of my messages, past or present.  (He can also impersonate my signature, but that's another discussion entirely.)
If I send one message weekly that my attacker is interested in, and change my RSA key every two years, my RSA key is at least 104 times more valuable than any individual key.  Does it not make sense that the RSA key should ideally be 104 times more difficult to crack?
If increasing the RSA keylength was overly cumbersome to the process then designing the RSA keylength to meet minimum acceptable standards could be understood.  But since increased RSA keylengths are cheap in terms of computing power, would it not be better to pick RSA keylengths that are more secure than the session keys?
And thus, 2560 bit keys are not unreasonable.  They are not significantly slower to use (most of PGP's time is spent IDEA encrypting), and yet are effectively invulnerable. By "invulnerable" I mean that any attacker capable of cracking your RSA key would have an easier time hacking your individual IDEA session keys, and would never have any need to hack the RSA key itself.  And if you have threat models this severe you are a) hopelessly paranoid, b) SOL.
_1_ These approximations of factoring difficulties and the computing resources are taken directly from Applied Cryptography by Bruce Schneier, page 161.
_2_ Taking into account Moore's law, the amount of processing power spent during a period of time is the integral of Power * 2^(t/1.5)dt (from 0 to x) = Power * 1.5 / (ln 2) 2 ^(t/1.5) (also evaluated from 0 to x).  Which is approximately equal to Power * 2.164 * (2^(x/1.5) - 1).  Thus in three years a corporation starting with 10^7 mips could produce 10^7 * 2.164 * (2^(3/1.5)-1) = 6.492 * 10^7 mips-years.
_3_ Any attempt to determine the computing power and cryptanalysis power of the NSA should be taken with a grain of salt.  There are several very critical and arbitrary assumptions made in order to obtain these numbers.
_4_ Additionally, any attempt to discern the future of cryptanalysis should also be taken with a grain of salt.  Who can tell what computers will like be in ten years?

@_date: 1996-07-14 06:42:48
@_author: "David F. Ogren" 
@_subject: Re: A case for 2560 bit keys 
This is an issue that is connected with the "Need PGP awareness" thread.  If everyone is decrypting their messages by hand then nine seconds is a hinderance.  On the other hand, if everyone is using an off-line reader that checks signatures/decrypts as it receives messages then nine seconds (or less for a newer machine) is less significant.
I'll refrain from making any product plugs here, but I could barely notice the difference moving from a 1024 bit key to a 2047 bit key.

@_date: 1996-07-19 05:24:57
@_author: "David F. Ogren" 
@_subject: Re: Making encoding out of an authentication cipher 
This, along with several other methods (Karn, Luby-Rackoff and MDC are some others) have been suggested in order to convert a hash function into and encryption algorithm.  And while the method you suggest has not been broken (at least to my knowledge) there are at least two major problems:
1. It is slow.  This method would appear to be approximately the speed of MDC.  And MDC (using SHA, what appears to be the most secure hash) is (very roughly) 5 times slower than Blowfish and 3 times slower than IDEA.  And although MDC is faster than 3DES in software, 3DES could easily outpace MDC in hardware.
2. (To directly quote Bruce Schneier from Applied Cryptography, page 353) "While these constructions can be secure, they depend on the choice of the underlying hash function.  A good one-way hash function doesn't necessarily make a secure encryption algorithm.  Cryptographic requirements are different.  For example, linear cryptoanalysis is not a viable attack against one-way hash functions, but works against encryption algorithms."  (Any typos are mine.)

@_date: 1996-07-21 10:04:24
@_author: "David F. Ogren" 
@_subject: ITAR's 40 bit limit 
Another paradox of the US export regulations.
The NSA is allowing 40 bit crypto exports.  So as a hypothetical example assume that I write a crypto program that uses 40 bit RC4 to encode data (licensing from RSA).  I then get an export license using the accelerated process for 40 bit RC4.
I then export my program to Alice who wants to use it to transmit messages to Bob.
If she uses my program to encrypt messages to Bob, any reasonably powerful attacker can decrypt her messages.
However, what if she runs the program three times with three different passwords.  (Ignore the problems of Inner-CBC and Outer-CBC for now.)  Now the file is triple RC4 encoded with the equivalent of 80 bit security.  Alice and Bob now have strong crypto.  And if they run the program five times they have 120 bits of effective protection.
The problem of using Inner-CBC is a little tricky, but if we assume that I can export in a DLL format, a Windows program could be written that calls the DLL repeatedly to layer it into triple or pentuple CBC RC4.
The entire above discussion is entirely theoretical.  I realize that it's a moot point since strong crypto is already perfectly accessible outside of the US.  And that strong crypto algorithms can be exported in non-machine readable format (another paradox).  (And that running 5-layer RC4 is a really inefficient block cipher.)
I just wanted to point out yet another reason why ITAR regulations over crypto are not effectively preventing strong crypto.  They are merely making it difficult for American business.
