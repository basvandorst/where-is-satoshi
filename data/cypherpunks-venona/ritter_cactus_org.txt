
@_date: 1994-02-01 23:25:29
@_author: Terry Ritter 
@_subject: NxM DES 
Ritter Software Engineering
                       2609 Choctaw Trail
                       Austin, Texas 78745
                (512) 892-0494, ritter
          Strong Block Ciphers from Weak Ones: NxM DES
               A New Class of DES Operating Modes
                          Terry Ritter
                        January 31, 1994
Many security vendors are now preparing a new generation of software
and hardware products.  Given the well-known criticism of DES, and the
government's unwillingness to publish their new Skipjack algorithm,
much attention has been focused on triple-DES as a replacement for DES.
But triple-DES requires three times the processing of normal DES, and
retains the same small block size which must be increasingly vulnerable
to improved dictionary attacks.  Thus it is reasonable to seek
alternatives to triple-DES, and compare them with respect to keyspace,
processing requirements, and block size.  Vendors should be cautioned
that triple-DES is not the only, nor necessarily the best, alternative
to DES.  They should consider delaying implementation of alternatives
until a consensus develops on exactly what the replacement should be.
New ciphering algorithms are often challenged to "prove" they are
stronger than DES.  Since it is impossible to measure the "strength"
of a cipher (and there has been no absolute proof of strength for any
practical cipher), new cipher algorithms are often considered
curiosities.  On the other hand, DES itself is well-known and accepted
(despite having no proof of strength), so there seems to be great
interest in the possibility of forming from DES a stronger cipher. Triple-DES is one approach at forming that stronger cipher, and is what
we could call a 1x3 DES structure: one DES block wide by three DES
cipherings deep.  Naturally, we expect software for any three-level
ciphering to operate at about one-third the speed of normal DES. There is an alternative approach which offers a larger keyspace,
reduced processing, and larger block sizes (which, nevertheless, can
often be used without data-expansion beyond that of normal DES).  I
call that approach "NxM DES," of which 2x2 DES is perhaps the easiest
nontrivial example:
2x2 DES
Instead of repeatedly enciphering a single 8-byte block, consider using
multiple DES cipherings to form a 16-byte block operation and thereby
improve plaintext block statistics.  2x2 DES will be two DES blocks
wide by two DES cipherings deep.  First, encipher two data blocks with DES, each under a different key. Exchange half the data in the first and second blocks.  Then encipher
the resulting blocks again, using two more keys:
Let us denote a DES enciphering by:       ciphertext := DESe( plaintext, key ) .  We want to encipher two DES-size blocks, call them A and B, and end up
with ciphertext blocks G and H:
     C := DESe( A, k1 );          D := DESe( B, k2 );
     E := C[0..3],D[4..7];        F := D[0..3],C[4..7];
     G := DESe( E, k3 );          H := DESe( F, k4 );
The byte-index notation on the second line is intended to convey the
exchange of the rightmost four bytes of the first two DES ciphertexts. The exchange is a permutation, costless in hardware, and simple and
cheap in software.  This particular permutation is also a self-inverse,
so that the same permutation can be used for both enciphering and
deciphering.  If we give each two-bytes of data a symbol and denote the
original data as:
     0123  4567
then after the permutation we have:
     0167  4523 .
For example,
     A:    01A1D6D039776742       B:   5CD54CA83DEF57DA
     k1:   7CA110454A1A6E57       k2:  0131D9619DC1376E
     C:    690F5B0D9A26939B       D:   7A389D10354BD271
     E:    690f5b0d354bd271       F:   7a389d109a26939b
     k3:   07A1133E4A0B2686       k4:  3849674C2602319E
     G:    b4de11d10c55c267       H:   64f1a0b723d360a7 .
Deciphering is similar to enciphering, except that the last-stage keys
are used first, and we use DES deciphering instead of enciphering:
     E := DESd( G, k3 );          F := DESd( H, k4 );
     C := E[0..3],F[4..7];        D := E[0..3],F[4..7];
     A := DESd( C, k1 );          B := DESd( D, k2 );
Thus, 2x2 DES enciphers DES blocks A and B to DES blocks G and H in
four DES cipherings.  This is faster than triple DES, because twice as
much data are enciphered in each block:  2x2 DES has a cost similar to
double-DES.  But 2x2 DES is potentially stronger than triple-DES,
because each of the resulting ciphertext bits is a function of 128
plaintext bits (instead of 64), as well as three DES keys.  (Although
four keys are used in 2x2 DES, only three keys affect each output
block, a 168-bit keyspace.) 2x2 DES does have a larger block size, so, when used alone, last-block
padding overhead increases from four bytes (on average) to eight; a
four-byte data expansion.  Naturally, when used alone in CBC mode, the
initialization vector (IV) will also be larger, 16 bytes instead of 8. This 12-byte overall increase in overhead should be weighed against the
stronger 16-byte block size, since strength is the reason for moving
away from normal DES in the first place.  4x2 DES
In a manner similar to 2x2 DES, we can consider enciphering four DES
blocks of plaintext, sharing data between them, and then enciphering
the resulting four blocks again.  4x2 DES has a larger keyspace than
2x2 DES, yet retains the same ciphering cost.  4x2 DES does have some
additional last-block and IV overhead, in return for a greater keyspace
and larger block-size strength.  Each 4x2 ciphering requires eight DES
keys:       E[0..7] := DESe( A, k1 );
     F[0..7] := DESe( B, k2 );
     G[0..7] := DESe( C, k3 );
     H[0..7] := DESe( D, k4 );
     (swap right-hand half of the data in {E,F} and {G,H})
     I := E[0..3],F[4..7]
     J := F[0..3],E[4..7]
     K := G[0..3],H[4..7]
     L := H[0..3],G[4..7]
     (swap the middle half of the data in {I,L} and {J,K})
     M := I[0..1],L[2..5],I[6..7]
     N := J[0..1],K[2..5],J[6..7]
     O := K[0..1],J[2..5],K[6..7]
     P := L[0..1],I[2..5],L[6..7]
     Q := DESe( M, k5 );
     R := DESe( N, k6 );
     S := DESe( O, k7 );
     T := DESe( P, k8 );
The intermediate permutation involves four 32-bit exchange operations,
an expense still trivial compared to the DES ciphering operations.  (In
a hardware implementation, the byte-swaps are the connections always
needed between stages, just connected differently, with no added
expense at all.)  This permutation is also a self-inverse.  If we
denote each two-bytes of the data symbolically:
     0123  4567  89ab cdef
then after the permutation, we have:
     0da7  49e3  852f c16b .
Alternately, if we denote the data prior to permutation as:
     0000  1111  2222 3333
then after the permutation we have:
     0321  1230  2103 3012 ,
showing that each permuted block contains exactly two bytes from each
of the four original DES blocks.  Each 8-byte output block in 4x2 DES
is a function of 32 bytes of input plaintext, as well as five DES keys,
a 280-bit keyspace.
For example,
     A:    01A1D6D039776742       B:   5CD54CA83DEF57DA      C:    0248D43806F67172       D:   51454B582DDF440A
     k1:   7CA110454A1A6E57       k2:  0131D9619DC1376E
     k3:   07A1133E4A0B2686       k4:  3849674C2602319E
     E:    690F5B0D9A26939B       F:   7A389D10354BD271
     G:    868EBB51CAB4599A       H:   7178876E01F19B2A
     M:    690f876ecab4d271       N:   7a38bb5101f1939b      O:    868e9d109a269b2a       P:   71785b0d354b599a
     k5:   04B915BA43FEB5B6       k6:  0113B970FD34F2CE
     k7:   0170F175468FB5E6       k8:  43297FAD38E373FE
     Q:    89af722f592664c4       R:   012d483a04db300f
     S:    dd60060ad098e3e0       T:   a3832dc4ff5c99ad .
Again, 4x2 DES deciphering is similar, except that we use the last-
stage keys first, and DES deciphering instead of enciphering.  NxM DES
8x2 DES would have a 64-byte block and 16 DES keys, yet should still
be considerably faster than triple-DES.  Even larger blocks are
possible, but would seem to require exchange operations on non-byte
boundaries (to assure that each permuted block contains bits from each
stage-one ciphertext block), so 16x2 DES and larger structures may have
a larger software permutation cost.  Nevertheless, the Nx2 approach
gives us a way to increase the keyspace while generally retaining
processing costs similar to double-DES.
DES structures with additional ciphering levels, such as 2x3 DES or
4x3 DES, are also available, at a processing cost similar to triple-
DES, but with the increased strength of a larger block size.  A 2x3 DES
structure would have a 280-bit keyspace similar to 4x2 DES, but with
50 percent higher processing costs.  A 4x3 DES structure could be
appropriate for some applications, but would have a huge 504-bit
keyspace which would require us to create, transport and store the
associated 84-byte key set.  Large Blocks in Existing Systems
It should be possible to adapt many existing systems to use larger
blocks without further data expansion.  Consider an 82-byte message,
which would normally be structured as eleven 8-byte DES blocks, for a
total of 88 bytes:  An NxM DES alternative might use two 4x2 DES
blocks, one 2x2 DES block, and one 1x3 DES block, for 32+32+16+8 or 88
bytes, exactly the same as normal DES.  A 63-byte message (normally 8
DES blocks) would use just two 4x2 DES blocks for a total of 64 bytes,
also the same as normal DES.  If larger blocks are always used until
smaller blocks would be more efficient, there is exactly one way to
structure any given amount of data, and the resulting length is
sufficient to reproduce the multiple-size blocking structure.  The
overhead of these blocking manipulations remains insignificant when
compared to the DES ciphering operations.  We could call this sort of
use of multi-size blocking "NxM+ DES," and 4x2+2x2+1x3 DES (which we
could call "4x2+ DES") would seem to be a very practical system.  Clearly, in CBC mode, 4x2 DES will require a larger IV than normal DES. Perhaps the IV could be transferred as part of the key-exchange; there
is obviously no way to avoid using larger keys if we want a stronger
cipher, whatever approach we use.  Smaller blocks at the end of a data
area could just take the left-most part of the preceding block as their
chain value.  Similarly, a 2x2 DES block might use the left-most two
DES keys at both levels of a 4x2 DES block (k1,k2,k5,k6), while a 1x3
DES block might just use the first three keys of the 2x2 DES block.  Overall, 4x2+ DES might be a simple firmware upgrade for existing DES
hardware.  Because the DES cipher is well known, there is interest in creating a
stronger cipher which builds on normal DES as a base.  By introducing
a larger block width in addition to repeated cipherings, additional
complexity can be obtained with a moderate increase in processing. This approach is unusual in that various levels of strength can be
obtained at virtually the same processing cost, a cost comparable to
double-DES and substantially less than triple-DES.  Furthermore, the
larger data blocks can be used even in systems which would not support
data expansion beyond that inherent in normal DES.  Consequently, the
NxM DES approach would seem to have significant practical advantages
over either double-DES or triple-DES as a replacement for DES.  NxM DES is a product of my own research.  I am not aware that this
approach has been previously published.

@_date: 1994-02-11 01:30:24
@_author: Terry Ritter 
@_subject: Nx2 DES Found Weak 
Ritter Software Engineering
                       2609 Choctaw Trail
                       Austin, Texas 78745
                (512) 892-0494, ritter
                       Nx2 DES Found Weak
                          Terry Ritter
                        February 11, 1994
 Summary
 Any Nx2 DES system succumbs to meet-in-the-middle attack at a
 cost only N times that of normal DES, and is probably not worth
 using.  If we assume that DES would fall with 2^55 cipherings
 (on average), then the 4x2+ DES system which I previously
 recommended would require only 2^57 cipherings.  Such an attack,
 however, might require substantially more storage and might be
 more difficult to mechanize and slower in operation than an attack
 on normal DES.
 Nx3 DES systems seem not to be affected by this attack, but they
 are also not faster than triple-DES (1x3 DES), which was the main
 reason for recommending Nx2 DES over triple-DES.  On the other
 hand, Nx3 DES systems apparently would provide added strength
 against dictionary attacks; such attacks might be possible against
 ASCII plaintext when ciphered in small 8-byte blocks.
 Double-DES
 A 1x2 DES construct (double-DES) is something like this:
             A
             v
      k1 -> DES1
             v
             B
             v
      k2 -> DES2
             v
             C
 Each single capital letter represents an 8-byte DES block.
 Meet-In-The-Middle Attack on 1x2 DES (double-DES)
      [ This is probably similar to:
        Merkle, R. and M. Hellman.  1981.  On the security of
        multiple encryption.  Comm. ACM 27(4): 465.
      which I have not seen.  This analysis resulted from trying to
      understand the comments on NxM DES made by email from Eli
      Biham, which led me to:
        Davies, D. and W. Price.  1984.  Security for Computer
        Networks.  Wiley.  75.
      and the attack on double-DES.  Obviously I did not expect
      that attack to work on Nx2 DES, or I would have skipped Nx2
      entirely. ]
 First we need some known-plaintext (A) and its associated ciphertext
 (C).  Now we encipher A with every possible random key k1 and save
 the results.  Then we decipher C with random keys k2, eventually
 finding a match to the enciphered data.
 There are many possible pairs of keys (k1, k2) which will produce
 matching B's.  Since there are 112 key bits (k1, k2), and we match
 64 bits each time, there should be about 112 - 64 or 48 bits of
 freedom (that is, 2^48 possibilities) to be resolved with one or
 two more known-plaintext blocks.
 We can guarantee to find the correct key pair if we try every
 possible key for k1 and also every possible key for k2; this is
 only twice the effort of a full DES key search, and we need
 only search half that, on average.  (In practice, we would do
 some k1's and then some k2's, repeated until success occurred.)
 However, we should note that this technique may require the
 intermediate storage of 2^56 results.  This would be over 2^59
 bytes of store, and this amount of storage and lookup is not
 nearly as easy or fast as the on-chip ciphering-and-compare
 solution for DES.  Still, the result is not comforting.
 A 2x2 DES construct is something like this:
             A             B
             v             v
      k1 -> DES1    k2 -> DES2
             v             v
             C             D
              Exchange Half
             E             F
             v             v
      k3 -> DES3    k4 -> DES4
             v             v
             G             H
 Meet-In-The-Middle Attack on 2x2 DES
 Suppose we first try the 2x1 approach:  With one known-plaintext
 block, we can search two keys (say k1 and k2) until a match
 is found for the center block.  Then we can validate that match
 with additional known-plaintext blocks.  (Since there is only a
 32-bit match-check and a 112-bit keyspace, there will be
 112 - 32 or 80 bits of freedom to resolve at about 32 bits per
 known-plaintext pair, so we would want to check a minimum of 3 or
 4 other known-plaintexts.  The cost of the subsequent cipherings
 and comparisons would be relatively insignificant, however.)
 We can guarantee that the two keys will be found by searching all
 possible k1 and k2.  This is only twice the normal DES keyspace,
 and we only need search half of that, on average.  And we can do
 this again for the other two keys at a similar cost.  Again, the
 attack hardware will be considerably more awkward than any simple
 search for a DES key which matches a given ciphertext value, but
 the total number of DES cipherings will be about twice the DES
 keyspace, on average.
 Nx2 DES Falls
 Similar arguments lead to the conclusion that, for any N, Nx2 DES
 must be generally comparable in strength to DES itself.  This means
 that the larger block has not helped strength much in any Nx2 DES
 system, despite the fact that every ciphertext bit is demonstrably
 a function of every plaintext bit in the large block as well as
 every bit in all the separate DES keys.  Note that the form of the
 inter-stage permutation has absolutely no effect on this attack
 or overall strength, despite the fact that a great deal has been
 written about designing S-P permutations.
 The meet-in-the-middle attack seems not to apply to Nx3 DES.
 Dictionary Attacks
 Normally we define "strength" as the *minimum* effort expected to
 "break" a cipher, when taken over *all possible attacks*.  Working
 out the extent of "all possible attacks" is a major part of the
 effort in cryptography.
 With respect to DES, most of the current attacks have considered
 the relatively-small 56-bit keyspace.  But I am also concerned
 by the relatively-small 8-byte block size.
 Consider an 8-byte block of ASCII text:  Modern data-compression
 programs typically compress such data by 60 percent.  This means
 that we typically have less than 26 bits or so of "uniqueness" in
 the various blocks.  Rigidly-formatted business documents, letters,
 or forms would be even less unique, and, thus, even more attackable.
 To the extent that a substantial amount of known-plaintext could
 be acquired (or possibly even inferred), a dictionary attack
 becomes possible.  For this reason, if a change is to be made,
 then I would like to see a block size at least four times that
 now used.  This would be a reasonable approach with a 4x3+ DES
 system, which would be comparable in throughput to a 1x3 DES
 system, but, alas, not faster.
 Conclusion
 A two-stage or Nx2 DES construction is probably not worth using.

@_date: 1994-02-17 00:55:18
@_author: Terry Ritter 
@_subject: Isolated Double-DES 
Ritter Software Engineering
                       2609 Choctaw Trail
                       Austin, Texas 78745
                (512) 892-0494, ritter
   2x Isolated Double-DES: Another Weak Two-Level DES Structure
                          Terry Ritter
                        February 16, 1994
The time has come to replace DES, the US Data Encryption Standard,
but there is no clear alternative.  While there are many ciphers
which are demonstrably faster and also arguably stronger than DES,
the fact that cipher strength cannot be _tested_ but must instead
be_argued_ makes many users nervous.  The US government offers some
alternative ciphers, but those are secret designs whose strength
_cannot_ be argued, again making users nervous.
The current leading candidate for a replacement to DES is "triple-
DES," a three-level construct using DES at each level.  This is a
comforting design, because users are already convinced that DES
can be relied upon for a certain level of strength.  Unfortunately,
a software implementation of triple-DES takes three times the
processing of normal DES.  While this is a mere detail on systems
which process the occasional enciphered email message, operational
speed is fundamental to widespread industrial use.  Ciphering speed
is essential in LAN servers and other fully-enciphered communications
nodes.  Speed is also important when ciphering is an integral part
of laptop software which communicates to a central facility.  Fast
software ciphering is important.
Because the ciphering speed for triple-DES is not acceptable, no
three-or-more-level construct could possibly be satisfactory in
this respect.  This limits our design alternatives to one-or two-
level constructs based on DES.
The goal, then, is to find--if possible--a construct which is based
on DES, has strength substantially beyond normal DES, but requires
less processing than triple-DES.  This time we start from the base
of double-DES, and directly confront the known weakness of that
The classical double-DES construct is something like this:
            A
            v
     k1 -> DES1
            v
            B
            v
            C
            v
     k2 -> DES2
            v
            D
where each single capital letter represents an 8-byte DES block.
Double-DES is normally not used, because of the meet-in-the-middle
Meet-In-The-Middle Attack on Double DES
Assume we have known-plaintext A for ciphertext D:  Encipher A
under every possible key k1, and decipher D under every possible
key k2.  (The cost for this is only two full DES key searches.)
Then check for matches between B and C.  If there are multiple
matches, the correct k1 and k2 will be there somewhere, and we
can isolate the correct pair with one or two more known-plaintext
blocks (this is a loose interpretation of [2]).
This works for the normal double-DES construction because it is
possible to check for matches between B and C; the weakness seems
to be the ability to check for a match.  Assuming that we have
properly identified the principal weakness of double-DES, let's
fix it:  We can isolate the two values, making a match check
impossible, so that not even one bit can be checked.
Isolated Double-DES
Consider a two-level DES construct like this:
            A
            v
     k1 -> DES1
            v
            B
            v
     km -> XOR
            v
            C
            v
     k2 -> DES2
            v
            D
where k1 and k2 are 56-bit keys, but km is a 64-bit key.
Technically, this construct could be considered to be either
double-DES with an intermediate ("isolating") XOR operation, or
triple-DES with XOR replacing the middle DES operation.  But since
the processing cost for this system is similar to double-DES, it
is reasonable to call it a form of double-DES.
While it is true that we now have three keys for a two-level DES
structure, this is no worse than triple-DES with separate keys.
But is it stronger than double-DES?
Isolated Double-DES Meet-In-The-Middle Attack
Again, encipher A under every possible key k1, and decipher D under
every possible key k2 and check for matches between B and C.
But in the isolated construction, every possible pair of values
(B,C) has some key km which would make that pair match.  Thus, the
weakness of match identification in the original construction is
not possible in the alternate construction.
The keyspace seems to be 56 + 64 = 120 bits, which would probably
be satisfactory for another couple of decades, or until an open
science of cryptographic machine design has matured.  It still
has a small block size, however.
Larger Blocks
DES uses a relatively-small 8-byte block, so if DES were used
in Electronic Code Book (ECB) mode and large amounts of plaintext
were known, a dictionary attack would be possible.  Fortunately, DES
is normally used in Cipher Block Chain (CBC) mode, making dictionary
attacks difficult.  But a dictionary attack on ECB mode could be
viewed as a "certificational attack" which is "indicative of
weakness" in the cipher itself. [1:466]
If we make the modest assumption that ordinary text has an
information content of under 40 percent of the binary size, then
a 64-bit block of text generally contains less than 26 bits of
uniqueness.  Worse, short words occur far more often than an even
distribution would indicate.  Although it would certainly be ill-
advised to send 2^26 blocks (2^29 bytes) of data under a single set
of keys, it is interesting to note the relatively small size of this
figure when compared to other cryptographic quantities.
For this reason, it seems appropriate that any new standard specify
an expanded block width.  Here is a double-width approach, 2x2 DES
described in an earlier article:
             A             B
             v             v
      k1 -> DES1    k2 -> DES2
             v             v
             C             D
          Exchange Right 4 Bytes
             E             F
             v             v
      k3 -> DES3    k4 -> DES4
             v             v
             G             H
Note that the 64-bit quantity G (for example) is a complex nonlinear
function of A, B, k1, k2, and k3; a total of 296 bits.  Nevertheless
the system is still solvable with meet-in-the-middle:
2x2 DES Meet-In-The-Middle Attack
With one known-plaintext block, we can search one top key and one
bottom key (say, k1 and k3) and find pairs (E,C) which match at the
appropriate 32 bit-positions.  Then we can identify the correct
pair with additional known-plaintext blocks, resolving the keys at
32-bits per known-plaintext pair.
We can guarantee that the two keys will be found by searching all
possible k1 and k3.  This is only twice the normal DES keyspace,
but may well require a huge amount of storage to identify all the
values and associated keys (say, E and k3) which match a particular
result (say, C).  We do not want to run through every k3 every
time we change k1.
2x2 DES Differential Attack
Eli Biham [1] points out that a differential attack can eliminate
the need to store the result from every possible key.  In this case
we need two different large blocks of known-plaintext with plaintext
or ciphertext half the same (say, A:B -> G:H and A:X -> Y:Z).  With
A the same in both large blocks, we know that the left-half of E
must also be the same.  Then, since we have two different blocks, we
can step through all possible values for k3, deciphering G into E
and Y into E' each time, looking for any results with the left-half
the same.  This should occur about every 2^32 trials, producing 2^24
trials which match, which should be resolved in only one or two more
set of known-plaintext blocks.  No huge storage is needed.
2x Isolated Double-DES
Consider a pair of isolated double-DES structures, combined as
described for 2x2 DES:
            A              B
            v              v
     k1 -> DES1     k2 -> DES2
            v              v
     km -> XOR1     kn -> XOR2
            v              v
         Exchange Right 4 Bytes
            v              v
     k3 -> DES3     k4 -> DES4
            v              v
            C              D
The result is a double-width structure, in which every ciphertext
bit in C depends on each and every bit in A, B, k1, k2, and k3, as
well as half the bits in km and kn.  Ciphering occurs at the rate
of double-DES.  While it is certainly true that six keys are needed,
keys need be transmitted far less often than data, and by having
separate keys we avoid attacks which depend upon having the same
key at multiple parts of the operation.  If we say that enciphering
occurs "from the top down," (XOR before exchange) then we would say
that deciphering occurs "from the bottom up" (exchange before XOR).
2x Isolated Double-DES Meet-In-The-Middle Attack
The double-DES meet-in-the-middle attack depended upon having a
structure in which the enciphered plaintext was identical to the
deciphered ciphertext.  This allowed both keys to be manipulated
and the resulting data space searched for matches.
In isolated double-DES any enciphered plaintext value can be
related to any deciphered ciphertext value by varying the middle
or "isolating" key.  Thus, meet-in-the-middle seems not very useful.
2x Isolated Double-DES Differential Attack
The 2x2 differential attack depended not upon identical top and
bottom values, but upon producing an identical value (in particular
known bit positions) from a bottom deciphering (for example).  This
situation is not affected by the XOR and so the differential attack
will still work.
2x Isolated double-DES falls to a differential attack.
[1]  Biham, E.  Mon, 7 Feb 1994 16:59:28 GMT.  Comments on Nx2 DES.
[2]  Merkle, R. and M. Hellman.  1981.  On the Security of Multiple
     Encryption.  Communications of the ACM.  24(7): 465-467.

@_date: 1994-02-22 00:57:22
@_author: Terry Ritter 
@_subject: Ladder DES 
Ritter Software Engineering
                        2609 Choctaw Trail
                        Austin, Texas 78745
                 (512) 892-0494, ritter
          Ladder-DES: A Proposed Candidate to Replace DES
                           Terry Ritter
                         February 22, 1994
 Introduction
 Data enciphered by DES, the US Data Encryption Standard, has become
 vulnerable to modern technical attacks.  Currently, such attacks
 require substantial capital and high-tech engineering development
 to produce a special "DES breaking" machine.  However, once such a
 machine is built, attacks would become relatively fast and cheap.
 Businesses which currently protect very expensive and marketable
 secrets with DES should take immediate notice.
 To maintain earlier levels of security, DES must be replaced with
 a stronger cipher.  The one obvious alternative to DES is a simple
 construct built from DES called triple-DES.  Triple-DES, while
 generally being thought of as "strong enough," also carries the
 baggage of requiring three times the processing of normal DES.
 Because every security system is required to provide more benefit
 than its cost, raising costs by a factor of three (when compared
 to the alternative of normal DES) is a significant issue.  Such
 costs could dangerously delay the retirement of ordinary DES.
 Requirements
 The goal of this sequence of designs is to identify one or more
 better candidates to replace DES.  Obviously, the first requirement
 is that each candidate be substantially "stronger" than normal DES.
 One problem here is that we can only _argue_ strength, so it is
 important that candidate designs be openly presented and reviewed.
 We cannot expect that most proposals will withstand such review.
 The second requirement is that each candidate design also be faster
 than triple-DES; otherwise, we might just as well use triple-DES
 and be done with it.  Speed is a measurable design quantity.
 My third requirement is to include operation on data blocks larger
 than the 8-byte DES block.  Although DES is not normally used in a
 way which is conducive to "dictionary" attack, such attacks could be
 effective on the bare cipher itself.  This raises the possibility
 that a "certificational" weakness may exist which we currently do
 not know how to exploit, but which may be dangerous anyway.  This
 particular weakness depends upon small blocks.
 At this point there is still some question as to whether it is
 _possible_ to come up with candidate designs which meet these
 three requirements.
 Ladder Diagrams
 DES itself is frequently shown in figures which are described as
 "ladder diagrams" because of their appearance:
                    v
           Initial Permutation
                    v
              <-- SPLIT -->
             |
      k1     |
             v      v      |
            XOR <-- f -----|
             |
      k2     |
      v      v
----- f --> XOR
             |
                  . . .
      k16    |
      v      v
----- f --> XOR
             |
             |
             --> COLLECT <--
                    v
             Inv. Init. Perm.
                    v
 This is the data-transformation part of DES.  Not shown is the
 key-schedule computation which produces k1 through k16, the 48-bit
 "round" keys.  Also not shown is the construction of function "f."
 It will later be interesting to note that in DES each 32-bit data
 rail value is expanded to 48 bits, the XOR occurs with a 48-bit key,
 and the result contracted to 32 bits in 6-bit to 4-bit substitutions
 known as "S-boxes."
 Ladder-DES
 Consider this simple construct which looks something like two
 rungs or steps on a ladder:
             A              B
      k1      |
             v      v       |
            XOR <- DES1 ----|
              |
      k2      |
      v       v
---- DES2 -> XOR
              |
             v              v
             C              D
 A, B, C and D represent 8-byte blocks; k1 and k2 represent 56-bit
 DES keys.  This enciphers two DES data blocks in two DES operations;
 this is a data rate similar to normal DES.  It can be described as
 working on a single large block composed of A and B.  Note that the
 data paths are twice the size of those used in DES itself.
 Also note that the design is asymmetric:  While ciphertext block C
 is a function of every bit in plaintext blocks A and B, as well as
 every bit in key k1, ciphertext block D is _also_ a function of
 key k2.
 Known-Plaintext Attack on Two-Rung Ladder-DES
 With known-plaintext, we essentially have a single-DES complexity:
 Since A is known and C is known, the output of DES1 is known.  Since
 the input to DES1 is also known, to find k1 we just do a normal DES
 search.
 Alternately, since B is known and D is known, the output of DES2 is
 known.  Since the input to DES2 is also known, to find k2 we just do
 a normal DES search.
 Total complexity: twice DES; thus, hardly worth using.
 Four-Rung Ladder-DES
 Now consider a similar construct, twice as long:
             A              B
      k1      |
             v      v       |
            XOR <- DES1-----|
              |
      k2      |
      v       v
---- DES2 -> XOR
              |
      k3      |
             v      v       |
            XOR <- DES3 ----|
              |
      k4      |
      v       v
---- DES4 -> XOR
              |
             v              v
             C              D
 A and B are 64-bit DES blocks; k1 through k4 are 56-bit DES keys.
 A total of four DES operations process two DES blocks at double-DES
 rates.  We would expect this to be both stronger than normal DES
 and faster than triple-DES.
 In general, the left-leg of a ladder-DES structure is affected by
 one fewer key than the right-leg.
 Belief
 Can we "believe" in this basic structure?  Well, DES itself is
 based on it.  But we do need to remember that DES also includes
 seriously nonlinear data expansions and contractions around each
 XOR.  Certainly expansion and contraction could be added to ladder-
 DES, although this could be expensive.  (To avoid specifying
 particular S-box contents, we could specify a cryptographic RNG
 which would be used to permute a base S-box arrangement; this
 should also avoid normal differential attacks.)  It is not clear
 that the lack of expansion and contraction operations necessarily
 negates the overall approach.
 Key Reduction
 The four-rung ladder-DES construct uses four 56-bit DES keys, but
 certainly a cipher would be strong enough if it had "only" a real
 two-key (112-bit) keyspace.  Thus, we might consider making k3 = k1,
 and k4 = k2, or perhaps, k3 = k1 and k4 = k1 XOR k2.
 On the other hand, perhaps it would be worthwhile to support
 additional keys simply to avoid the necessity of showing that a
 reduced key approach could never reduce strength.
 Known-Plaintext Attack on Four-Rung Ladder-DES
 No longer do we have the advantage of knowing both the input to
 and the output from XOR operations, so we can no longer gain access
 to the output of particular DES operations.  Thus, the obvious
 search strategy is not available.
 Divide-And-Conquer Attack on Four-Rung Ladder-DES
 Normally we try to separate the effects of the different DES
 operations, so we can "divide and conquer" each separately.
 In this case, DES4 is the obvious first choice, since with the
 keys k1..k3 fixed, only k4 affects the output, and then it only
 affects block D.  However, unless we know the values of k1 and k2,
 we don't know the input to the bottom XOR, and so apparently
 cannot separate DES4 to work on it.
 Meet-In-The-Middle Attack on Four-Rung Ladder-DES
 With four keys involved, and no obvious "middle," it is not clear
 how this attack could be applied.
 2x Four-Rung Ladder-DES
 The basic Ladder-DES construct can be expanded to cipher four
 blocks at once:
             A              B         C              D
      k1      |         |      k2      |
             v      v       |         v      v       |
            XOR <- DES1 ----|        XOR <- DES2 ----|
              |         |              |
      k3      |         |      k4      |
      v       v         |      v       v
---- DES3 -> XOR        |---- DES4 -> XOR
              |         |              |
             v              v         v              v
             E              F         G              H
                         Re-arrange Blocks
             H              E         F              G
      k5      |         |      k6      |
             v      v       |         |      v       |
            XOR <- DES5 ----|        XOR <- DES6 ----|
              |         |              |
      k7      |         |      k8      |
      v       v         |      v       v
---- DES7 -> XOR        |---- DES8 -> XOR
              |         |              |
             v              v         v              v
             I              J         K              L
 This construct enciphers four DES data blocks in eight DES
 operations; again, this is a speed comparable to double-DES, and
 substantially faster than triple-DES.
 Ciphertext block I is now a function of every bit in plaintext
 blocks A, B, C, and D, as well as every bit in keys k1, k2, k4,
 and k5.  Every bit in the 64-bit I is a complex function of
 480 bits.
 We could certainly afford to reduce the number of keys in these
 constructs, and this might be done in any number of ways.  For
 the 2x construct, for example:
      k2 := k1 XOR k3;  k4 := k3 XOR k5;
      k6 := k5 XOR k7;  k8 := k7 XOR k1;
 leaving us with a need for four keys:  k1, k3, k5 and k7.  It is
 also possible that the same two keys could be used in every two-
 rung ladder-DES section, for a total of two keys.
 Conclusion
 DES operations can be arranged into a "ladder-DES" constructs which
 are especially-clean and familiar and seem to resist known attacks.
 These constructs seem potentially stronger than normal DES and are
 demonstrably faster than triple-DES.  Thus, ladder-DES could be a
 reasonable candidate to replace DES.

@_date: 1994-03-01 16:25:01
@_author: Terry Ritter 
@_subject: Large Block DES Newsletter 
Large Block DES Newsletter
                      Vol. I, No. 1
                      Feb. 28, 1994
                    Terry Ritter, Ed.
 Current Standings for the Large-Block DES Proposals:
 I. NxM DES:
             A             B
             v             v
      k1 -> DES1    k2 -> DES2
             v             v
             C             D
          Exchange Right 4 Bytes
             E             F
             v             v
      k3 -> DES3    k4 -> DES4
             v             v
             G             H
      Falls to meet-in-the-middle like double-DES.  Falls to a
      practical attack by Biham, now called "fix-in-the-middle."
 II.  NxM DES Found Weak
      Announcement of above.
 III.  Isolated Double-DES
      2x construct found weak in original article.
      The 1x construct:
            A
            v
     k1 -> DES1
            v
            B
            v
     km -> XOR
            v
            C
            v
     k2 -> DES2
            v
            D
      was found weak by Chris Dodd  who pointed
      out that two different blocks of known-plaintext (A,D) and
      (A',D') will allow matching (B XOR B') and (C xor X').  (This
      is similar to Biham's "fix-in-the-middle.")  Good going Chris!
      Also found by Stefan Lucks .
 IV. Ladder-DES
             A              B
      k1      |
             v      v       |
            XOR <- DES1-----|
              |
      k2      |
      v       v
---- DES2 -> XOR
              |
      k3      |
             v      v       |
            XOR <- DES3 ----|
              |
      k4      |
      v       v
---- DES4 -> XOR
              |
             v              v
             C              D
      Joseph C. Konczal  points out that the
      construct is indeed vulnerable to meet-in-the-middle.  I
      agree, but note that this seems to imply a 112-bit search.
      Since we don't need more than 112 or 120 bits of strength,
      I don't see it as a problem.  (Indeed, if we could get more
      strength, we might want to trade it for speed anyway.)  112
      bits (or so) is the design goal, which should be enough for
      a couple of decades.
      In a normal cipher design, I would expect each key bit to
      contribute toward strength, but these are hardly normal cipher
      designs.  Especially when we try to expand block size, extra
      keys may simply provide another small block with the same
      strength as a previous small block.  Keys will be delivered
      electronically, so the relatively rare delivery of 2x or 4x
      or even 8x the expected key material should not pose a serious
      problem.
      However, Biham reports:
           "ladder DES is not more secure than 2**88 steps and
           2**64 chosen plaintexts."
      Now, 2^88 cipherings is 2^32 times as strong as the 2^56
      currently in DES (and larger than Skipjack), but hardly the
      2^112 intended.  For the current design the current options
      are:
         1) live with the 2^88 strength (so far!),
         2) design the rest of the system to prevent chosen
            plaintexts, or
         3) prevent more than, say, 2^32 block cipherings under a
            single key.
      Actually, we need to know exactly what the problem is, and the
      limits of it, before we can propose a fix, or decide whether
      the ladder-DES scheme is unfixable.
 Summary
 Three substantially different constructs proposed; of these, two
 fall, and one is wounded.
 To review, the intent is to find some relatively-simple construct
 which builds on the assumed strength of DES to deliver wide blocks
 and something like 112 bits of strength, with less processing than
 triple-DES.  (I see no need for super-strength, unless it is free.)
 We still do not know whether or not this is possible.

@_date: 1994-03-12 21:18:36
@_author: Terry Ritter 
@_subject: Block Mixing Transforms 
Ritter Software Engineering
                        2609 Choctaw Trail
                        Austin, Texas 78745
                 (512) 892-0494, ritter
     Keyed Balanced Size-Preserving Block Mixing Transforms
                          Terry Ritter
                         March 12, 1994
 Introduction
 Modern block ciphers seek to emulate extremely large substitution
 tables algorithmically, using complex combinations of various simple
 internal mechanisms.  These internal mechanisms include small
 substitutions and trivial combinings, but the art and mystery
 of block cipher design is how to couple these simple and weak
 operations in ways which produce a strong overall cipher.
 One apparently new type of mechanism which might be useful in block
 cipher design would take two blocks in, share data between them,
 and then produce two generally-different blocks as a result.  In
 particular, this mechanism might be used to mix data to (and from)
 a pair of substitutions, thus hopefully producing a stronger result
 than the two substitutions operating separately and independently.
 In most cases, it would be necessary for the mechanism to have an
 inverse, and to produce output blocks of the same size as the input.
 The result would be a mechanism which could be inserted anywhere
 in the internal data paths common in block-cipher designs.
 Block Mixing Transforms
 Consider constructs like this:
             A              B
              |
             v              v
             Mixing Transform
              |
             v              v
             X              Y
             X              Y
              |
             v              v
             Inverse Transform
              |
             v              v
             A              B
 Capital letters represent data blocks.  Alternately, we can
 describe the transform, in general, as:
      X := f1( A, B );   Y := f2( A, B );
      A := f3( X, Y );   B := f4( X, Y );
 The intent of such a system is to mix two input blocks in a complex
 yet reversible way.  This could provide two advantages:
      1) It should make each output bit a function of all the input
      bits (on average), thus providing a way to expand block size
      while using smaller block-cipher functions.  Hopefully the
      construct would also defeat attempts to "divide-and-conquer"
      the smaller functions separately.
      2) It could provide a way to connect block-cipher functions
      in sequence, while eliminating any fixed direct connection
      between the blocks, such connections being vulnerable to
      "fix-in-the-middle" attack.
 A mixing transform is not unlike a "butterfly" section in a fast
 Fourier transform (FFT) [3].  But the usual FFT operates on complex
 values which are normally represented in floating-point.  When
 implemented in fixed-point (as needed for mixing data blocks), the
 normal FFT butterfly expands the range of the input values, thus
 requiring a larger amount of storage (a larger block size) for the
 result.  Fast Hadamard / Walsh transforms [2] behave similarly.
 For cryptography, we need transforms which are "size preserving"
 so that we can perform fixed-size block operations (such as DES)
 either on the input data or on the transformed results.  It was
 not clear to me that this was going to be possible (at least with
 equations of practical complexity) until Eli Biham provided some
 examples of size-preserving mixing transforms:
      X := A - B;   Y := 2A - B;
      A := Y - X;   B := Y - 2X;
 for n-bit blocks, A, B, X, and Y, and arithmetic mod 2^n.
 There are actually many such transforms, and Biham has found a
 generalized form:
      (-1  1  )
      (-w  w-1)
 and
      (w-1  -1)
      (w    -1)
 where w is some constant.  For example, when w = 2:
      X := -1*A +     1*B  =  B -  A
      Y := -2*A + (2-1)*B  =  B - 2A
      A := (2-1)*X + -1*Y  =   X - Y
      B :=     2*X + -1*Y  =  2X - Y
 with the arithmetic mod 2^n.
 To see inverse, note that
      A  =   X - Y  =   (B - A) - (B - 2A)  =  A
      B  =  2X - Y  =  2(B - A) - (B - 2A)  =  B
 These are fixed, linear transformations.  If we know the input
 values, and the transformation, we will also know the output
 values.  Even when the full equation is unknown, the simplicity
 and linearity of these transforms means that they require
 special protection in cryptographic applications.  Mixing
 transforms can only be used when both the input and the output
 values cannot be exposed simultaneously.
 Alas, the transform mentioned above has a problem:  Specifically,
 the least-significant-bit (lsb); that is, lsb(Y) = lsb(B).  This
 is because the expression B - 2A has shifted A left one bit,
 leaving the bottom bit of B exposed.  This provides a bit of direct
 correlation between an input value and an output value.  This is
 probably sufficient to support a practical "fix-in-the-middle"
 attack if the transform is used to isolate two DES operations.
 Consider these correlation experiments on the above transform with
 4-bit blocks:
           x3  x2  x1  x0  y3  y2  y1  y0
      b0   64  64  64  64  64  64  64 128
      b1   64  64  64  64  64  64  64  64
      b2   64  64  64  64  64  64  64  64
      b3   64  64  64  64  64  64  64  64
      a0   64  64  64  64  64  64  64  64
      a1   64  64  64  64  64  64  64  64
      a2   64  64  64  64  64  64  64  64
      a3   64  64  64  64  64  64  64  64
 This is a 0 -> 0 correlation count.  For each possible input value
 (over both A and B), for each input bit which is zero (somewhere in
 A and B) and each output bit which is zero (somewhere in X and Y),
 a count is recorded.  The count of 128 means that y0, the lsb of Y,
 occurs twice as often as expected when the lsb of B is zero.
 Similarly,
           64  64  64  64  64  64  64   0
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
 a 0 -> 1 correlation count, shows that no cases exist where the
 lsb of B is a one and the lsb of Y is a zero.
 Cryptographic Mixing
 In [8] I introduced a new type of reversible stream-cipher combiner
 (the first stream-cipher combiner, which we now call "exclusive-OR"
 or "mod-2 addition" was described by Vernam [12]).  "Combiner" is
 the traditional cryptographic name for a mixing function.  [11,5,1]
 (Non-reversible combiners are also used, typically to make confusion
 sequences difficult to penetrate. [e.g., 6])  Combiners and mixing
 transforms have much in common.
 Basically, a combiner will look like any other two-input one-output
 function:
             A             B
             |
             v             v
             Mixing Function
             v
             C
             C              B
              |
             v              v
             Inverse Function
             v
             A
 The capital letters represent the block size; in a typical stream
 cipher these are byte values.  A is the plaintext, B the confusion
 stream, C the ciphertext.  Note that exactly the same confusion
 stream is needed to recover the original data; this is the heart
 of stream-cipher security.
 There are many two-input functions, but most are not useful as
 cryptographic data combiners, which must be reversible and must
 have no correlation between either input and the output.  Combiners
 which do have correlation [e.g., 4] fall to statistical attacks
 [e.g., 10].  If we see mixing transforms as a matched-set of
 cryptographic combiners, we can see that correlation is a problem
 with the example transform.  (Biham did have an example of one
 balanced but non-keyed transform based on rotation and subtraction
 mod 2^n.)
 Mixing in Mod-2 Polynomials
 Since the "weak" exclusive-OR form of combiner has long been
 available, modern combiner designs are normally intended to be
 "stronger" and, thus, are more complex.  But it is not at all clear
 that "stronger" is what we need in a mixing transform.  Presumably,
 "strength" can be provided more efficiently by some other function,
 like DES, or a substitution table.  Thus, we may really want a
 modest-strength extremely-fast mixing solution, and one approach
 is to consider the well-known field of mod-2 polynomials.
 In mod-2 arithmetic, addition is the same as subtraction
      X + Y  =  X - Y
 and any value added to itself is zero
      X + X = 0
 so, in general, multiplication cannot be achieved by addition
      X + X <> 2X
 (assuming X is non-zero) but is instead achieved by shifting.
 Then
      2X + X = 3X
 so multiplication is not restricted to binary powers.  Of course
      3X + X = 2X
 which just shows that mod-2 arithmetic can be surprising.
 It is interesting to see just how unusual good mixing transforms
 are.  Consider a first approach
      X := A + B;  Y := A - B;
 (mod-2, mod-p, where p is some primitive mod-2 polynomial of
 appropriate degree for the size of the data blocks).  While this
 is a reasonable approach in the integers, in mod-2 polys,
 A + B = A - B.  This means that  X = Y, and the two resulting
 identical blocks cannot possibly carry enough information to
 provide an inverse transform for two arbitrary input blocks.
 It does not work.
 Next consider
      X := A + B;  Y := A + 2B;
 with inverse operations
      A := (2X + Y) / 3;   B := (X + Y) / 3;
 (mod-2, mod-p), and the division done by multiplying by the inverse
 of 3, mod p.  (Appropriate inverse equations may not always exist;
 finding the inverse equations is interesting in itself.)  This
 works.  But here  X  is never affected by p at all, thus producing
 an extremely regular (and un-keyed) transformation.  And the
 inverse multiplication is, in general, far more expensive than
 multiplication by a small integer.
 Finally, consider
      X := 2A + 3B;   Y := 3A + 2B;
      A := 2X + 3Y;   B := 3X + 2Y;
 Again, operations are mod-2 and mod-p, where p is some primitive
 mod-2 polynomial of appropriate degree for the data blocks X, Y,
 A and B.  This works, and the transform is a self-inverse.  The
 primitive affects the result in both data blocks.  And the
 multiplications are simple.
 Correlation experiments conducted as before show a nice, balanced,
 uncorrelated system:
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
           64  64  64  64  64  64  64  64
 These functions are extremely fast.  Addition is a simple
 exclusive-OR.  Multiplication by two is simply a left-shift and
 a conditional add of the primitive.  Multiplication by three is
 a multiplication by two plus an addition.
 Keyed Mixing Transforms
 The mod-2 polynomial transforms depend on having some primitive of
 the appropriate degree.  Different primitives produce different
 mixing functions, with similar overall performance.  This leads
 to the possibility of keying the transforms by selecting arbitrary
 primitives.  (Some references to primitive-finding algorithms
 are given in [9].)
 Rabin gives the number of degree-n primitives as about p^n / n
 [7].  Thus, for degree 64, we have about 2^64 / 2^6 or about 2^58
 primitives.  This means that each randomly-selected degree-64
 primitive carries about 58 bits of key.  Of course, this key can
 only be effective to the extent that the linear transformation
 cannot be attacked and the primitive thus deduced.
 Some Consequences
 If a single input bit changes on one of the mixing transform input
 blocks, we can be sure that at least one bit will change in both
 output blocks.
 If two input bits change, we can be sure that these bits will not
 "cancel" each other; changes will still occur in the output blocks.
 If many input bits are changed, and the transform primitive is
 known, it is possible to engineer a no-change in one output block
 (although this is unlikely to happen by chance).  Should this be
 undesirable, it might be made impossible by design (such as
 ciphering the input blocks before mixing), or by keying the
 transform (so the necessary bit patterns are unknown).
 If it becomes possible to define the input to, and what the output
 must be from a ciphering element, it will be possible to key-search
 that element independent of other elements, and this is what we
 hope to avoid.  To prevent this it may be necessary to use keyed
 input and output transforms, or even multiple ciphering levels
 between transforms.
 Applications
 It is crucial to remember that these simple, high-speed, but linear
 mixing transforms can be said to have "strength" only if the input
 and output values are never both available.  That is, these
 structures do not by themselves handle "known-plaintext" attack.
 (Of course, the same could be said for many other simple internal
 mechanisms used in block cipher construction.)
 Simple constructs like
           A      B
      |
           v      v
           MixTrans
      |
           v      v
           C      D
 are not likely to be very useful as ciphers by themselves, even if
 the mixing transformation is keyed and the blocks are large.
 On the other hand, constructs like
           A      B
  p1  |
           v  v   v
           MixTrans
      |
           v      v
          DES1   DES2
      |
  p2  |
           v  v   v
           MixTrans
      |
           v      v
           C      D
 are considerably more interesting.  Note that this construct
 ciphers a double-size DES block at single-DES rates.  It seems to
 require keyed mixing transforms.  Similarly,
           A      B
      |
           v      v
          DES1   DES2
      |
  p   |
           v  v   v
           MixTrans
      |
           v      v
          DES3   DES4
      |
           v      v
           C      D
 will cipher a double-size DES block at double-DES rates, and at
 least superficially avoids all weakness in the mixing transform by
 placing strength in each input and output port.  This may avoid
 the need to key the mixing transform.
 Alternately,
             A              B
      k1      |
             v      v       |
            XOR <- DES1-----|
              |
      k2      |
      v       v
---- DES2 -> XOR
              |
      p       |
             v      v       v
             Mixing Transform
              |
      k3      |
             v      v       |
            XOR <- DES3 ----|
              |
      k4      |
      v       v
---- DES4 -> XOR
              |
             v              v
             C              D
 also ciphers at double-DES rates.
 Of course, larger external blocks mean an increase in the number
 of internal data paths, making various sorts of interconnection
 configurations possible.  Thus
           A      B      C      D
  p1  |      |  p2  |
           v  v   v      v  v   v
           MixTrans1     MixTrans2
        p3 |      |  p4  |      |
        v  v      v  v   v      v
       -Trans3    MixTrans4     Mix-
      |      |      |
           v      v      v      v
          DES1   DES2   DES3  DES4
      |      |      |
  p5  |      |  p6  |
           v  v   v      v  v   v
           MixTrans5     MixTrans6
        p7 |      |  p8  |      |
        v  v      v  v   v      v
       -Trans7    MixTrans8     Mix-
      |      |      |
           v      v      v      v
           E      F      G      H
 will cipher quadruple-size DES blocks at single-DES rates,
           A      B      C      D
      |      |      |
           v      v      v      v
          DES1   DES2   DES3   DES4
      |      |      |
  p1  |      |  p2  |
           v  v   v      v  v   v
           MixTrans1     MixTrans2
       p3  |      |  p4  |      |
       v   v      v  v   v      v
      -Trans3     MixTrans4     Mix-
      |      |      |
           v      v      v      v
          DES5   DES6   DES7   DES8
      |      |      |
           v      v      v      v
           E      F      G      H
 will cipher quadruple-size DES blocks at double-DES rates, and
           A              B              C              D
      k1      |              |      k2      |
           v      v       |              v      v       |
          XOR <- DES1 ----|             XOR <- DES2 ----|
              |              |              |
      k3      |              |      k4      |
      v       v              |      v       v
---- DES3 -> XOR             |---- DES4 -> XOR
              |              |              |
              |              |              |
      p1      |              |      p2      |
           v      v       v              v      v       v
           MixingTransform1              MixingTransform2
   p3      |              |      p4      |              |
   v       v              v      v       v              v
 -Transform3              MixingTransform4              Mixing-
              |              |              |
      k5      |              |      k6      |
           v      v       |              |      v       |
          XOR <- DES5 ----|             XOR <- DES6 ----|
              |              |              |
      k7      |              |      k8      |
      v       v              |      v       v
---- DES7 -> XOR             |---- DES8 -> XOR
              |              |              |
           v              v              v              v
           E              F              G              H
 will also cipher quad-size blocks at double-DES rates.  But in
 each case, four double-level mixing transforms could be replaced
 by a single double-size mixing transform:
           A      B      C      D
      |  p1  |      |
           v      v  v   v      v
           ---------mix1---------
      |      |      |
           v      v      v      v
          DES1   DES2   DES3  DES4
       p2  |      |      |      |
       v   v      v      v      v
       ix2---------      --------m
      |      |      |
           v      v      v      v
           E      F      G      H
           A      B      C      D
      |      |      |
           v      v      v      v
          DES1   DES2   DES3   DES4
      |      |      |
      |  p   |      |
           v      v  v   v      v
           ---------mix----------
      |      |      |
           v      v      v      v
          DES5   DES6   DES7   DES8
      |      |      |
           v      v      v      v
           E      F      G      H
           A              B              C              D
      k1      |              |      k2      |
           v      v       |              v      v       |
          XOR <- DES1 ----|             XOR <- DES2 ----|
              |              |              |
      k3      |              |      k4      |
      v       v              |      v       v
---- DES3 -> XOR             |---- DES4 -> XOR
              |              |              |
              |      p       |              |
           v              v      v       v              v
           ---------------------mix----------------------
              |              |              |
      k5      |              |      k6      |
           v      v       |              |      v       |
          XOR <- DES5 ----|             XOR <- DES6 ----|
              |              |              |
      k7      |              |      k8      |
      v       v              |      v       v
---- DES7 -> XOR             |---- DES8 -> XOR
              |              |              |
           v              v              v              v
           E              F              G              H
 These are new ciphering architectures.  Clearly, it is not known
 how strong these constructs would be.  However, this situation can
 hardly be considered unusual.
 Other opportunities exist when constructing completely new block
 ciphers.  These might, for example, be based on byte-wide key-
 permuted substitutions, thus avoiding differential attacks on
 fixed "optimal" tables.  Thus
    ------------------------------mix------------------------------
    --------------mix-------------- --------------mix--------------
    ------mix------ ------mix------ ------mix------ ------mix------
    --mix-- --mix-- --mix-- --mix-- --mix-- --mix-- --mix-- --mix--
    mix mix mix mix mix mix mix mix mix mix mix mix mix mix mix mix
    S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S
    mix mix mix mix mix mix mix mix mix mix mix mix mix mix mix mix
    --mix-- --mix-- --mix-- --mix-- --mix-- --mix-- --mix-- --mix--
    ------mix------ ------mix------ ------mix------ ------mix------
    --------------mix-------------- --------------mix--------------
    ------------------------------mix------------------------------
 enciphers 256-bit blocks through 32 keyed 8-bit substitutions by
 using five levels of input keyed mixing transform and five levels
 of output keyed mixing transforms of varying size.  Clearly, there
 are a plethora of alternate interconnection possibilities here.
 For example, the mixing rows could be permuted, different sizes
 of mixing combined in some rows, the mixing not arranged on 2^n
 boundaries, etc., etc.  Since the mixing transforms are extremely
 fast, we would expect this 256-bit system to be much faster than
 64-bit single-DES.
 And,
    S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S
    mix mix mix mix mix mix mix mix mix mix mix mix mix mix mix mix
    --mix-- --mix-- --mix-- --mix-- --mix-- --mix-- --mix-- --mix--
    ------mix------ ------mix------ ------mix------ ------mix------
    --------------mix-------------- --------------mix--------------
    ------------------------------mix------------------------------
    --------------mix-------------- --------------mix--------------
    ------mix------ ------mix------ ------mix------ ------mix------
    --mix-- --mix-- --mix-- --mix-- --mix-- --mix-- --mix-- --mix--
    mix mix mix mix mix mix mix mix mix mix mix mix mix mix mix mix
    S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S S
 enciphers 256-bit blocks through 64 keyed 8-bit substitutions by
 using nine levels of mixing transforms of varying size.  With the
 substitutions all keyed, we can probably avoid keying the mixing
 transforms.  Again, there are a plethora of alternate
 interconnection possibilities.
 Summary
 Practical, high-speed, keyed, balanced, and size-preserving block
 mixing transforms are introduced for cryptographic service.
 References
 [1]   Arko, R.  1961.  Mechanical Signal Combiner.  U.S. Patent
       3,159,712.
 [2]   Beauchamp, K.  1984.  Applications of Walsh and Related
       Functions.  Academic Press.
 [3]   Brigham, E.  1974.  The Fast Fourier Transform.
       Prentice-Hall.
 [4]   Geffe, P.  1973.  How to protect data with ciphers that are
       really hard to break.  Electronics.  January 4.  99-101.
 [5]   Kohler, H.  1951.  Combining Circuits.  U.S. Patent 2,567,214.
 [6]   Massey, J., and R. Rueppel.  1989.  Method of, and Apparatus
       for, Transforming a Digital Data Sequence into an Encoded
       Form.  U.S. Patent 4,797,922.
 [7]   Rabin, M.  1980.  Probabilistic Algorithms in Finite Fields.
       SIAM Journal on Computing.  9(2): 273-280.
 [8]   Ritter, T.  1990.  Substitution Cipher with Pseudo-Random
       Shuffling:  The Dynamic Substitution Combiner.  Cryptologia.
       14(4): 289-303.
 [9]   Ritter, T.  1991.  The Efficient Generation of Cryptographic
       Confusion Sequences.  Cryptologia.  15(2): 81-139.
 [10]  Siegenthaler, T.  1985.  Decrypting a Class of Stream Ciphers
       Using Ciphertext Only.  IEEE Transactions on Computers.
       C-34: 81-85.
 [11]  Smith, H.  1950.  Combining Circuit.  U.S. Patent 2,496,317.
 [12]  Vernam, G.  1919.  Secret Signaling System.  U.S. Patent
       1,310,719.
 ---
 Terry Ritter   ritter (alas, cactus.org dies March 18)
                ritter (perhaps temporarily)
