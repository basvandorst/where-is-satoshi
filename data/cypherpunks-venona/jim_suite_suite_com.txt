
@_date: 1996-09-13 16:51:08
@_author: Jim Miller 
@_subject: really undetectable crypto 
Most everybody on the list is familiar with the technique of hiding  encrypted messages in the LSBs of image files.  Personally, I would not  use such a technique because don't I believe it's really undetectable.  I  assume, without proof, that the LSBs of images files have statistical  properties that are sufficiently different from encrypted data that a  clever person could determine whether or not an image file contained an  imbedded encrypted message.
Fortunately, there are other steganographic techniques that, I believe,  are undetectable.  The trick is to hide your encrypted bits in other  encrypted bits.
trick    Let's say you want to send a short encrypted message via a  communications channel that only allows cleartext messages with optional  MD5 message hashes.  You can construct cleartext messages, via  trial-and-error, such that the first 4 or 8 bits (or more, if you have the  time) of the MD5 hash match the first 4 or 8 bits of your encrypted  message.  You can pre-compute all the required cleartext messages in  advance, and then send them one after another.  The recipient of the  cleartext messages can reconstruct the encrypted message by gathering  together the first 4 or 8 bits of each MD5 hash.
Since the bits in an MD5 message hash are presumably cryptographically  random, there should be no way to tell if some of the bits combine to make  an encrypted message.
trick   Let's say you are allowed to use 40 bit encryption, but nothing  stronger.  As in trick  you can pre-compute plaintext messages such  that the first 4 or 8 of the bits in the output of the government-approved  40 bit encrypted data match the first 4 or 8 bits of your hidden encrypted  trick  see above.  Any communications channel that allows you to send  *any* bits that are cyptographically random can be used to send arbitrary  encrypted messages.
P.S. The pre-computed plaintext messages don't have to be garbage  messages.  You can probably make an innocent-looking message produce the  desired bits by adding extra whitespace or typos.

@_date: 1996-09-14 08:05:26
@_author: Jim Miller 
@_subject: Re: really (?) undetectable crypto 
True.  The examples was just illustrative.  Given unkeyed hashes or 40 bit  encryption, Walter could also frame you by replacing your bits with ones  that combine into a very incriminating encrypted message and then leaking  the key.
Hey, I never claimed it was efficient.  :-)
Actually, the messages don't have to arrive in order.  The correct order  can be discovered by trial and error (e.g.  does this combination decrypt  into something readable?  No. How about this one?).
Depending on the cryptographic protocol, there may be other, more  efficient means for sending hidden encrypted messages.  If, for example, a  protocol requires a cryptographically random confounder to be appended to  the front of the plaintext before encryption, you could use chunks of you  secret encrypted message for the entire confounder.

@_date: 1996-09-14 10:01:18
@_author: Jim Miller 
@_subject: Re: really undetectable crypto 
Why am I not surprised.  :-)
I would think you could do better than 1 bit per message.  Using just  hashes, I would think you could get at least 4-8 bits per message using a  standard Pentium-class machine.  Maybe more, I haven't actually run any  tests to see how long it would take to generate innocent messages that  produces hashes with specific bits in certain positions.
I don't see why this is necessary.  If the hidden message is encrypted  using a key (or key pair) known only to Alice and Bob, then Walter should  not be able to fool Bob.  Walter could disrupt the communications in any  number of ways, but he wouldn't be able to generate innocent messages that  produce hashes that contain bits that combine to form a message encrypted  using a key (or key pair) known only to Alice and Bob.
The above paragraph has given me an idea:  You don't need to send hashes  or digital signatures to send hidden encrypted messages.  All Alice needs  to send is the carefully constructed plaintext.  Bob can generate the  hashes himself, extract the proper bits and attempt to decrypt the hidden  message.  If the hidden message does not decrypt, then either the  plaintext was tampered with, it was forged, or not all of the plaintext  That being the case, then I think we have a very simple proof that any  communications channel, even one that allows only unsigned plaintext  messages, can be used to send arbitrary encrypted messages (if a bit  slowly).  So much for Clipper.

@_date: 1996-09-17 13:24:56
@_author: Jim Miller 
@_subject: really undetectable crypto made somewhat practical 
The primary drawback to the stego scheme I described in the previous post  was the ratio of stego bits per message.  The scheme would only transmit  an estimated 4 stego bits per message.  Then it occurred to me that I can  improve the ratio by basing the scheme on the hashes or words rather than  the hashes of entire messages.
Previous Scheme:  construct a sequence of plaintext messages such that the  first 4 bits of the MD5 hashes of the messages combine to produce the  cyphertext of the true stego message.  The sender would only need to send  the plaintext messages.  The recipient would calculate the MD5 hash of  each plaintext message, extract the first four bits from each hash, append  them together, then decrypt the result to obtain the true stego message.
New Scheme:  First, calculate the MD5 hash of all the words in the various  dictionary files used by the password cracker program and create a  database containing every word and the first 4 bits of its MD5 hash.   Given such a database, it would be possible to write a program that  accepts as input a block of cyphertext (the stego message, encrypted),  chunks it up in to groups of 4 bits and then, for each chunk, displays the  words that have hashes that start with those same four bits.  The person  running the program would select words that form meaningful sentences but  also produce hashes that combine into the encrypted stego message.  This  scheme would send 4 stego bits per word.
In addition to ordinary words, the database could contain names,  misspelled words, abbreviations, words with alternate capitalization,  slang terms, technical jargon, whatever.
Fortunately, senders and receivers don't need to synchronize word  databases.  The recipient doesn't need to have any word database.  The  receiver can reconstruct the hidden encrypted message simply by  calculating the MD5 hash of each word in the plaintext message, gathering  up the appropriate hash bits and decrypting the result.
This scheme could send more than 4 stego bits per word, but as you  increase the number of stego bits per word (sbpw), you reduce the number  of words that will work for a given chunk of cyphertext, making it harder  to construct meaningful sentences (e.g. given a 40,000 word database, 4  sbpw yields 16 word groups with approx 2500 words per group; 8 sbpw yields  256 word groups with approx 156 words per group.  8 sbpw would probably  not work well).
Would this scheme work?  It works in the sense that you can use it to send  arbitrary encrypted messages through channels that don't allow anything  but human-readable plaintext messages, but does it do so in an  undetectable manner?  I think so, but I don't know for sure.

@_date: 1996-09-24 17:35:18
@_author: Jim Miller 
@_subject: Re: really undetectable crypto made somewhat practical 
Few on the cypherpunk list replied to my post, so you didn't miss  anything important.
I like your suggestion, although not for the reason you suggested it  (although your use is a good idea, too). The use of keyed hashes solves  one of the problems I saw with my scheme.  The main problem I saw with my  scheme was that it might be possible to detect that an innocuous message  was conveying a hidden encrypted message by analyzing the statistical  properties of the relevant hash bits.
If the words in a message are chosen so some of their hash bits (say, 4  bits per hash) combine to form an encrypted message, then those combined  hash bits would be suspiciously cryptographically random, whereas the  combined hash bits of a message that was not created for the purpose of  conveying an encrypted message would not necessarily be cryptographically  random.  It is conceivable that a program could be written that uses  this difference to test if a message is conveying a hidden encrypted  Rather than using an unkeyed hash, which gives Eve the ability to  generate the relevant block of combined hash bits and test them for  certain properties, use a keyed hash.  Since Eve does not know the key  used to hash the words in the message, she will not be able to generate  the relevant block of combined hash bits and will not be able to perform  meaningful analysis of the properties of those bits.
Further analysis:
By hashing words and then using only the first 4 hash bits, what you are  really doing is sorting all words into 16 groups.  Group 0 consists of  all words whose first four hash bits are 0000, group 1 consists of all  words whose first four hash bits are 0001, ..., group 15 consists of all  words whose first four hash bits are 1111.
If a message is constructed by selecting words so their first 4 hash  bits combine to form an encrypted message, then, if the message is long  enough or you send enough messages, you will probably select words  "evenly" from each of the 16 word groups.  However, I can think of no  reason to assume the distribution of group selections would be "even" for  normal messages.  Maybe, by some weird fluke, normal messages are mostly  constructed from words in groups 1, 3, 4, 9, and 14, for example.
By using a keyed hash, your not stuck using a fixed set of word groups.   A different hash key will sort the words into different groups.  Hash  keys effectively prevent Eve from knowing which words in your message  came from which groups, thus preventing her from determining if words  were chosen "evenly" from each group.

@_date: 1996-10-16 19:33:07
@_author: Jim Miller 
@_subject: Re: Comments on binding cryptography (1) 
Then he comments on binding cryptography.  Then he concludes with:
Feeling any cognitive dissonance, Mr Koops?
