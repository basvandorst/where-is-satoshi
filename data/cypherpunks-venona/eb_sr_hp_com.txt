
@_date: 1994-03-03 15:46:41
@_author: Eric Blossom 
@_subject: YA semi-novice question 
Can someone please tell me how 3-way calling would work under Clipper (or
   other encrypted phone system)?  That is, I'm Alan talking to Betty.  During
   the conversation Clive calls me and I want to "add" him so that we have a
   3-way conversation.
   How do the key/session exchanges happen?
Basically it doesn't, unless you have extra hardware.  This is the
same problem that you have with ISDN phones.  No extensions.
If you were going to do it, somebody acts as a hub, call it H, and the
other two users A and B connect to the hub.   Note that A and B are
not directly connected.
A and H negotiate a session key.
B and H negotiate a session key.
H acts as a digital mixer.
H decrypts input from A using the A/H key and forwards it to B
encrypted under B/H.  H decrypts input from B using the B/H key and
forwards it to A encrypted with the A/H session key.
In the middle of all this (H) all components of the conversation are
in the clear.  They are mixed appropriately and sent out to the other
participants encrypted under the respective session keys.
Eric Blossom

@_date: 1994-03-31 10:28:19
@_author: Eric Blossom 
@_subject: Another view of the CFP 
Wow, I'm pretty sure I have some 4100 data sheets I got ~9 months ago
that said the 4100 did not use clipper, but used some "proprietary"
algorithm.  The 3600 sheets I rcvd at the same time did make reference
to clipper.  I'll have to dig them out and check.
Anybody know what SACS is?
Eric Blossom

@_date: 1994-04-14 15:41:21
@_author: Eric Blossom 
@_subject: Encrypted Telephones 
At this moment our primary efforts are on developing a family of
extensible protocols for both encryption and voice across point to
point links.  We indend to use existing standards where ever possible.
We are currently planning on building on top of the RFCs for PPP (see
RFCs 1549, 1548, and 1334).  The basic idea is to add a new Link
Control Protocol (or possibly a Network Control Protocol) that will
negotiate base and modulus and perform DH key exchange.  Some forms of
Authentication are already supported by RFCs.  We're looking at
The next layer up will perform an encrypted negotiation (using a fixed
algorithm, perhaps Hellman-Pohlig) of the type of encryption to use
for the session.  This includes algorithm and modes.  We are currently
looking at 3DES or IDEA in OFB-64 or OFB-8.  This gives you a
synchronous stream cipher that does not propagate errors.
At this point, you have an encrypted tunnel.
The next layer up will negotiate the voice protocol, and support for
muxing data and voice.  On the voice front, we are looking at FED-STD
1015 LPC-10eV55 (2400bps), FED-STD 1016 CELP (4800bps) and a couple of
CVSD variants in the 13000 - 28800bps range.  There is a MILSPEC for
CVSD.  CVSD has the advantage of being cheap to compute, but since the
data rate is higher, your crypto demands are higher.
For those of you unfamiliar with PPP, it provides a very nice
framework for negotiating options across both ends.  The same
automaton can be used for each layer, simplifying matters greatly.
I'd welcome any comments or suggestions.  I'll probably have a
complete draft available in a week or so.
Stay tuned for further developments...
Eric Blossom

@_date: 1994-04-14 16:10:09
@_author: Eric Blossom 
@_subject: [hughes@hughes.network.com: Encrypting tunnel negotiation protocol] 
This came across the ipsec list.
Apologies to those who have already seen it.
Eric Blossom
This note is to start a discussion regarding key negotiation for encrypting tunnels. There are several specific attacks and authentication capabilities that will be addressed.
The tunnel establishment protocol must negotiate several parameters and well as reliably negotiate a session key. A 2 message authentication/session key negotiation was chosen because of the complexities of multiple messages.
Authentication will be accomplished with RSA. Getting certified public keys will be beyond this document. It is expected that they will be distributed via "secure sneaker-net", via secure DNS or X.509 certification services. An example of a secure sneaker-net is where the public keys are gathered together on a disk and then distributed to potential partners. During this phase the disk mst be guarded to ensure that "Mallet" can get at the disk and replace the keys. After the keys are loaded into the partners, they must be protected form unauthorized external writes and/or erasures.
Attacks addressed will be "denial of service because of message playback", "man in the middle", and "rubber hose" attacks.
Denial of service
It is expected that processing tunnel establishment messages will be an processor expensive task, and this protocol is intended to minimize the processing required to determine if a tunnel establishment packet is not an old packet or a malicious packet created to "clog up" the tunnel establishment task. If the tunnel is established, a tunnel request will be ignored unless the request has the proper identifier. If there is an active tunnel, then there will be an active tunnel negotiation request identifier. A malicious user can not interrupt an exiting tunnel without this "once". Once a request is received, that request identifier is (probably) not used again.
When a tunnel is not established, there is not an existing tunnel negotiation request identifier, and a malicious user can create a packet that passes the initial checks. All a malicious user can cause is a one block of RSA decryption, one block of RSA encryption and a MD5 calculation. This vulnerability can be limited by queueing only the oldest packet per requestor IP address if the tunnel renegotiation task is busy.
If the malicious user sends in old packets, the increasing time of day check will be enough to catch them. if the user modifies the time of day, then the RSA and MD5 checks will catch that.
In either case, the malicious user can not interrupt existing tunnels and if the tunnel request processing is a background, low priority task, throughput will not be adversely effected.
Other attacks.
Man in the middle is addressed with (unspecified) trusted public key distribution mechanism.
Rubber hose attack is where the private key is extracted through (possible painful means) and all previous messages passed can then be decrypted. The more common method of using this would be to "steal" the host or router and then use in circuit emulators or the like to extract the public key. After an attack like this the key would be compromised and never used again. What this is trying to protect is all previous messages passed before the rubber hose is applied even if the private key is compromised.
The key establishment protocol
The protocol is comprised of two messages.
        Requestor                                     Responder
        Tunnel Request ----------------------------->
                  <---------------------------------- Tunnel Reply
If there is not a reply from the first packet, the source will resend the packet with a new time of day (and recomputed MD5).
Sending traffic on the new tunnel or sending a Tunnel alive message will complete the negotiating.
Tunnel keep alive messages are sent and acknowledged at a predetermined regular basis. Both sides send the requests and both sides send the Ackd. These messages are passed within the tunnel and are encrypted by that process. The format of the tunnel alive messages are in the tunnel document.
The contents of the tunnel request is:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +
                   Requestor IP address                        |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
                   Responder IP address                        |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
                   Request Identifier                          |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
                   Time of Day         (2 words)               |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
                   Diffie-Hellman modulus Length               |   |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |                    g                  (16 through 64 words)    |   |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  MD5                     Modulus            (16 through 64 words)    |   |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |            Diffie-Hellman (X=g^x mod n) (16 through 64 words)  |   |    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |   +
                   Reply identifier                            |   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |   |
              Tunnel request and parameters (TBD)  (? words)   |   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |   |
                   Tunnel Lifetime                             |   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +  RSA
                   MD5 residue             (2 words)           |       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       |
                   Padding (Random data) (? words)             |       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       +
"Request Identifier" is the value from the last tunnel negotiation that identifies this packet as the correct tunnel renegotiation packet. If there is not a current tunnel in effect then this is 0.
"Time of day" is the unix format time of day, that is, the high word contains the number of seconds since January 1, 1970 GMT, and the second word contains the number of microseconds elapsed during the current second. The clock needs to be monotonically increasing, but does not need to be synchronized. The microseconds can be an increment.
"Tunnel request parameter" contains information which is used in the negotiation of the tunnel. This includes tunnel ID (SAID), encryption type(s), compression type(s). Details TBD.
"Reply identifier" is the value expected in the reply. This is a random number.
"Tunnel Lifetime" is the expected time for the tunnel to live. This value, added to the local time of day creates both the expected time of day to be used in the next request as well as allowing the Responder to calculate the time after which it is to expect that negotiation to occur. Tunnel renegotiation can occur sooner if the tunnel keep alive messages show that the tunnel has collapsed.
"Random Padding" is used to pad out the block to the RSA modulus.
RSA is used to double encrypt this with the requestors private key and the responders public key. The double protection will obscure from any potential eavesdroppers the exact encryption methods, compression options as well as renegotiation times and reply identifier.
The Diffie Hellman modulus length (in bytes) is then followed by the 3 values, g, n, and (g^x)mod n. (x is the secret value to be used to calculate the key later.) The length can be from 512 to 2k bits.
When the packet is received the following steps are performed. 1. The IP address, request ID are validated to ensure that the packet is from the correct requestor. If the requestor id is 0, and the tunnel is still operational (as of last tunnel alive request), then toss the packet. (The requestor id should be 0 only if the tunnel is not operational.) If the request is 0 and the tunnel is not operational, the time of day is checked to ensure it is increasing.
3. The RSA protected data is decrypted by the responders private key and then encrypted by the requesters public key. 2. MD5 hash of the entire packet is calculated and determined to be correct. The originator and this packet has been authenticated.
5. The time of day is saved as being correct.
7. Create the random number y and calculate the value X^y mod n. A number of these bits are used as the session key.
The responder then creates a reply packet.
Once the packet is sent, the responder should be ready to accept packets using the new SAID. (Packets using the existing SAID can continue to be sent.)
The reply should be resent after time-out until a packet is received on the The responder can not use the SAID until a packet is received on the tunnel.  The contents of the tunnel reply is:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +
                   Requestor IP address                        |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
                   Responder IP address                        |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
                   Reply identifier                            |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
                   Time if Day             (2 words)           |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
                   Diffie-Hellman modulus Length               |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  MD5
           Diffie-Hellman (Y=g^y mod n) (16 through 64 words)  |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |   +
                   Next Request identifier                     |   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |   |
              Tunnel request and parameters (TBD)  (? words)   |   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |  RSA
                   Tunnel Lifetime                             |   |   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +   |
                   MD5 residue             (2 words)           |       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       |
                   Padding (Random data) (? words)             |       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+       +
Where "Time of day" is the time received in the request. (Actually, this is not used, but it is easier to leave the space there.)
"Tunnel request parameter" contains results of the negotiation. This includes tunnel ID, encryption type(s), compression type(s). Details TBD. "Fixed Pattern" A value to ensure that the RSA decryption was successful. "Tunnel Lifetime" is the value received in the request or smaller.
"Random Padding" is used to pad out the block to the RSA modulus.
RSA is used to double encrypt this with the responders private key and the requestors public key. The Diffie Hellman modulus length (in bytes) is then followed by the (g^y)mod n. (y is the secret value.)
When the packet is received the following steps are performed. 1. The source, destination and time are validated to be correct. 2. MD5 is calculated over the packet.
3. The RSA protected data is decrypted by the requestors private key and then encrypted by the responders private key.
4. The fixed pattern is checked. The packet has now been validated.
5. Verify MD5(2) is correct.
5. Calculate the value Y^x mod n. A number of these bits are used as the session key.
The new SAID can now be used.

@_date: 1994-04-20 14:56:54
@_author: Eric Blossom 
@_subject: cryptophone ideas 
Yeah, eventually.
Analog Devices 2105's cost $12 in quantity 1.
They are capable of doing 2 data moves, a 16x16 multiply, a 40 bit
accumulate and a prefech of the next instruction all in 100ns.
10 Million Multiply-Accumulates per second.  Ever tried that on a 386?
For more money, you can get ones with 60ns clocks (16.7 MACS).
Eric Blossom

@_date: 1994-05-06 14:38:49
@_author: Eric Blossom 
@_subject: Lady Ada's Cryptophone 
Another thing to remember is that out of the DH you're going to get
somewhere in the neighborhood of 1000 - 2000 bits of secret.  Assuming
triple DES you only eat up 3*56 = 168 (you may actually use 3*64 = 192 just
to keep life simple) of these bits.  You can rekey 5-10 times without
having to re-exponentiate.
Eric Blossom

@_date: 1994-05-31 14:42:23
@_author: Eric Blossom 
@_subject: Cypherpunks' Electronic Book2 
Please! Don't keep thinking somebody else has got to do something for
you to make this work.  You don't need any changes made to
MajorDomo.  Just subscribe a new user that points at your mail
processing code.  For that matter, you could do most of it with
procmail or perl out of your ~/.forward
Cypherpunks write code.  There's nobody stopping you from doing it.
Eric Blossom

@_date: 1994-06-01 15:05:09
@_author: Eric Blossom 
@_subject: [garay@watson.ibm.com: Tunnel protocol revisited] 
Apologies to those who have already seen this.
Eric Blossom
Return-Path: We (Amir Herzberg, Hugo Krawczyk and I) took a look at your key
negotiation protocol for encrypting tunnels.
We applaud your bringing up the issue; we fully agree that this constitutes
an essential component of any secure architecture for Internet.
In this note we present a secure tunnel establishment protocol that is
related to, but different than yours. The remainder of the note is
organized as follows. We first sketch the requirements/goals for/of
a key establishment protocol. This is combined with comments and observations
about your proposal. We then present the protocol in two stages: a high
level design, followed by an implementation-oriented description. We
conclude with a review and more detailed comparison.
(WARNING: this is a long note.)
GOALS OF A KEY EXCHANGE PROTOCOL
1. Provide a shared session key. Your protocol achieves this from public
        keys. However, it should be possible in general to obtain a session
        key from a "master" shared key. The master key itself could be
        obtained from the public key, but not exclusively. Besides being
        more efficient, this approach would accommodate a variety of solutions,
        like key distribution centers, manual key installation, key cacheing,
        etc. In particular, the life span of a master shared key can cover
        several sessions; in each of these sessions a new (session) key is
        derived from the master key using conventional functions which are
        significantly more efficient than public-key operations.
        We maintain this distinction between master and session key throughout
        the rest of this note.
        An integral part of a key exchange and session establishment
        protocol is the mutual authentication of the parties.  This provides
        to each party assurance on the authentic identity of the other.
        Also, included in these protocols is the negotiation of tunnel
        parameters.
2. Efficiency. It is important to minimize both the number of flows and the
        the number of exponentiations (with large exponents).
        While the number of exponentiations required by your proposal is 8,
        our scheme  support different variants that require from 2 to 4
        exponentiations only (and no exponentiation at all if the parties
        already share a master key).
        Our scheme does not use Diffie-Helman, although it can be
        accommodated in the protocol. The reason is that D-H is expensive
        (4 exponentiations), but, as you mention, takes care of the
        "rubber hose" attack. This effectively poses a tradeoff
        in terms of the number of exponentiations that are required
        to achieve a certain level of security (see item (3) below).
        Key cacheing is also an important efficiency consideration.
        In your protocol, public keys are used in each session to derive the
        session keys. In our approach, public keys are used to obtain master
        shared keys, which in turn are used to obtain the session keys.
3. Level of Security. Our protocol is immune to the exposure of one of the
        private keys (indeed, an adversary needs to discover the private keys of
        both sender and receiver to derive the tunnel's key). We feel that this
        should be sufficient for the vast majority of applications.
        Your protocol, on the other hand, is secure even if both keys are
        exposed, at the expense of using Diffie-Helman.
        Simplicity and being amenable to analysis and proof are important
        features of any cryptographic protocol. Our protocol is structured,
        simple, and thus easier to analyze. (Indeed, methods similar to those of
        [1,2] can be used to establish the protocol's desired properties.)
Here's our proposal. We first present the high-level design, including
only the relevant information - the additional information (e.g., tunnel
parameters) which requires authentication is omitted here for simplicity.
We then specify the optimized implementation in more detail. Also for the
sake of clarity, in the high level description we present the two protocols
(i.e., master key exchange and session establishment) separately, and then
indicate how to combine them.
THE MASTER KEY EXCHANGE PROTOCOL
There are two parties, S and R. We assume that S and R posses an
authentic public key of each other, as well as share a nonce (a random
number).  The nonce serves as a challenge for guaranteeing the freshness of
the authentication (i.e., avoid replay attacks). Sharing a nonce is not
essential; it can be replaced by use of time stamps (at the expense of
requiring good clock synchronization) or by adding an extra flow to the
protocol (at the expense of performance).  The nonce also serves the purpose
of your Reply Identifier, namely, alleviating the effect of clogging.
In any case, we stress that our nonces require no secrecy, i.e., they can be
transmitted in the clear.
S (for sender) is the party that initiates the protocol.
We first include a brief explanation of the terminology:
        K_X: Random string chosen by party X.
        N_X: A nonce (i.e., a random number) chosen by X.
        E_X: RSA encryption with X's public key (this is your RSA1).
             We assume that the information is padded with a random string
             prior to encryption.
        SIGN_X: X's RSA signature (your RSA2).
        More specifically, by SIGN we mean first apply MD5 to the signed
        information, and then apply RSA (i.e., exponentiation with X's
        private key.) Since RSA operations require an argument as long as its
        modulus, and the MD5 output is shorter than this modulus, then
        the RSA operation will be performed on the concatenation of MD5 and
        some other fields in the packet to complete the modulus length
        (probably, with added randomness and redundancy). Details TBD.
        K: The shared master key, outcome of the protocol.
        MAC_K: A Message Authentication Code (or function) which is applied
        to a piece of information for authentication using a secret key K.
        Examples include block ciphers, e.g. DES, in MAC mode, or key-ed
        cryptographic hash functions, e.g. MD5 with prefixed/suffixed key.
        (MAC mode of block ciphers is like CBC encryption mode but only the
        last block is output.)
Here's the two-flow protocol. Initially, S and R share N_R:
  S                                             R
  S randomly chooses K_S, N_S
  Let E_1  = E_R(K_S)
      E_1, N_S, SIGN_S(E_1, TIME, N_S, N_R)
       ------------------------------------>
                                                 R randomly chooses K_R, N'_R
                                                 Let E_2 = E_S (K_R)
         E_2, N'_R, SIGN_R(E_2, N'_R, N_S)
       <-------------------------------------
  Both S and R compute the new master key as K = K_S XOR K_R.
  N'_R is the nonce to be used next time, i.e., S and R set N_R:=N'_R.
1) The use of TIME in the S-->R flow is not strictly necessary. If the random
        nonce is not kept, then R may agree to use the time instead.
2) SIGN_R in the return flow is not really necessary either, it
        can be replaced by MAC_K(E_2, N_S, N'_R).
        The advantage of this is efficiency (i.e., less exponentiations),
        at the price of not being homogeneous in both flows.
        This replacement of SIGN by MAC doesn't hold for the first flow,
        where the signature is mandatory
        (i.e., anybody can choose K_S and compute E_R(K_S) and MAC_K_S(...)).
3) R first verifies the signature, and only if this succeeds it decrypts K_R
        (this reduces computational overhead, e.g., against
        clogging, since signature verification is much cheaper than decryption).
4) The protocol is in some sense minimal, since 2 flows are always
         needed, as well as secrecy and authentication each way (thus the 2
        exponentiations). This can be made even cheaper by letting
        only one party choose the key (in which case the compromise of the
        private key of this party would compromise the exchanged key).
5) The above protocol uses 4 exponentiations in total (2 by each party).
        Using variant 2) reduces the number to 3 (2 by S and 1 by R). By
        using also 4) the number of exponetiations can further be reduced to
        2 (1 per party).
        Our proposal is based on variant 2).
THE SESSION ESTABLISHMENT PROTOCOL
We now turn to the process of establishing a session between S and R.
This includes mutual authentication and the exchange of a session key (SK).
We assume that S and R already share a master key K, as well as the nonce N_R.
The protocol becomes:
  S                                              R
           N_S, MAC_K(TIME, N_S, N_R)
       ------------------------------------>
                                                  R randomly chooses N'_R
             N'_R, MAC_K(N'_R, N_S)
       <------------------------------------
Let T be the MAC expression in the return flow, i.e., T = MAC_K(N'_R, N_S).
Then, both S and R compute SK = F_K(T) and SK becomes the new session key.
Here F_K is a pseudorandom function with index K (K is the shared master
key). Roughly speaking, pseudorandom functions are characterized by the
pseudorandomness of their output, namely, each bit in the output of the
function is unpredictable if K is unknown.
Some of the functions used as MAC are also used as pseudorandom functions,
e.g., DES in MAC mode. Some key-ed hash functions, as MD5, are also conjectured
to be pseudorandom (although there exists less evidence for that than in the
case of DES; the same is true for the use of these functions as MAC).
1. Notice that the session key SK is not explicitly transmitted. This avoids
        the need to encrypt this key as well as the need to authenticate it.
        The authenticity of SK is derived from the authenticity of the
        expression T.
2. The method can be readily extended to derive in turn several session keys
        (different keys may be needed, for example, for confidentiality and for
        integrity verification).
3. Notice that this protocol involves no public key at all.
THE COMBINED PROTOCOL
When exchanging a master key it is desirable to also have a mechanism to
derive a session key. This is obtained by combining the two protocols
presented above. This allows S and R to establish, starting with their
public keys, both a master key AND a session key in just two flows. The
first flow (from S to R) is the same as in the master key exchange protocol
described above.  For efficiency, the second flow uses observation 2)
of that protocol.
  S                                           R
      E_1, N_S, SIGN_S(E_1, TIME, N_S, N_R)
       ------------------------------------>
         E_2, N'_R, MAC_K(E_2, N'_R, N_S)
       <-------------------------------------
Let T' be the MAC expression in the return flow, i.e.,
T' = MAC_K(E_2, N'_R, N_S).  Then, both S and R compute SK = F_K(T') and
SK becomes the new session key.
Remark: the similarity between this protocol and the above session
        establishment protocol allows having the same packet format for the
        flows of both protocols.  This is presented in detail in the next
        section.
We now describe the implementation aspects in more detail. (We are
borrowing the layout you used in your note.)
Most importantly, we stress that both the master key exchange protocol
and the session establishment protocol use the SAME packet format for the
different flows. Thus, we get added functionality without the penalty
of managing more packets.
For the sake of clarity we start with a description of the packet for the
case of master key exchange, and then comment on the use of the same packet
format for the session key establishment task.
Some of the details are still left undefined. Some of them are already treated in
your proposal; others will be added once/if the group shows interest in this
The contents of the protocol's first flow (in the master key exchange
protocol) are as follows:
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +
                   S's IP address                              |     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
                   R's IP address                              |     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
       Protocol Id; flow  length of signature  (16 bits)     |     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
 Length of public key; Options (prot. mode, tunnel param., etc)|     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  +  |
                   K_S                                         |  |  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ E_1 |
                   Random pad                                  |  |  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  +  |  *
                   Time                                        |    MD5 |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |  |
                   N_S                                         |     |  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |SIGN_S
                   N_R                                         |     |  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +  |
                   HASH                                        |        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        +
"Tunnel parameters" includes all the administrative data, such as tunnel
lifetime, etc.
"Protocol Id"
"Protocol Mode" is basically a bit(s) indicating how should the contents
be interpreted.
The field K_S and the subsequent random pad do not appear in plain but
encrypted under RSA_R (this is E_1 in our notation).
The encryption can be extended, if desired, to hide additional fields
(e.g., the protocol parameters).
The HASH field contains the result of MD5 (or other one-way hash function,
if desired) computed on all previous fields (or in all fields that require
NOTE: The position of N_S and N_R as the last arguments in the computation
of MD5 is intentional. The effectiveness of these nonces as freshness
guarantee is enhanced by fixing their offset relative to the beginning
or end of the authenticated arguments.
The signature (using the private key of S) is applied to information of
the length of the RSA modulus in use. This information MUST include the
result of the HASH in the last field and may include other
authentication fields as well as additional random padding and
redundancy. These details TBD.  We recommend, as Jim did, having the
nonce N_R included since this represents a good check against clogging.
(Notice that the variability on the signature scope is represented in
the above figure by the *).
The order of operations is as follows.
For S:
- Encrypt (i.e., E_1);
- perform MD5; and
- sign.
For R (upon receiving):
- Open signature;
- verify N_R;
- verify MD5; and
- decrypt.
Here's the master key exchange protocol's second flow:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +
                   S's IP address                              |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
                   R's IP address                              |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
       Protocol Id; flow  length of signature  (16 bits)     |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
 Length of public key; Options (prot. mode, tunnel param., etc)|     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  +  |
                   K_R                                         |  |  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ E_2 |
                   Random pad                                  |  |  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  +  |
                   Time                                        |   MAC_K
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
                   N'_R                                        |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     |
                   N_S                                         |     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +
                   MAC                                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
The field K_R and the subsequent random pad do not appear in plain but
encrypted under RSA_S (this is E_2 in our notation).  The encryption
can be extended, if desired, to hide additional fields.
The MAC field contains the result of MAC_K computed on all previous fields
(or in all fields that require authentication). As explained above for MD5
computation, also here the position of N'_R and N_S as the last fields in the
computation of MD5 is intentional.
The order of operations. For R:
- Encrypt (i.e., E_2); and
- compute MAC_K(...).
Upon receiving (S):
- Verify N_S;
- decrypt; and
- compute MAC_K(...) and compare with MAC field.
USE OF ABOVE PACKETS FOR THE SESSION ESTABLISHMENT PROTOCOL. Notice that
the second flow of both protocols (master key exchange and session
establishment) is identical except for the field E_2 in the first case.
Therefore, the packet for the second flow of the session establishment
protocol is identical to the one described above with the E_2 field omitted.
Since E_2 is a variable length field (depending on the modulus size) one
can use length 0 to accommodate the second flow of session establishment.
As for the first flow, in the case of session establishment no public key
operations are required. This means the following:
a) There is no need to use the field E_1 (this is similar to the omission of E_2,
discussed above); and
b) the HASH field in the above packet is used as the MAC field of the session
establishment protocol (128-160 bits will accommodate both cases).
We have presented a protocol for the establishment of a secure tunnel.
The protocol supports the exchange of a shared (master) key for the
communicating parties as well as the establishment of secure sessions
between them. The sharing of a master key uses public key to a minimum,
and for session establishment (including session key exchange) no public
key is required.  Moreover,  our solution supports scenarios where shared
keys are obtained by different means, e.g., manual key installation
("sneaker-net"), key distribution centers, etc., and takes advantage of the
cacheing of these keys.
This added flexibility and functionality relative to Jim's proposal comes
without additional price in complexity (system- and computation-wise).
On the contrary, our solution accommodates the above scenarios with protocols
that require a) minimal interaction (i.e., two flows), b) a single and
compact packet format, and c) minimal computational overhead (only 3
long exponentiations).
[1] R. Bird et al., "Systematic Design of Two-Party Authentication
        Protocols," Proc. Crypto '91, August 1991.
[2] Bellare, P. Rogaway, "Entity Authentication and Key Distribution",
        Advances in Cryptography '93, Springer-Verlag Lecture Notes on
        Computer Science

@_date: 1994-06-13 11:25:58
@_author: Eric Blossom 
@_subject: The Crypto Home Shopping Network 
No, RC4 is not the European cellular phone encryption algorithm, but
   that 32-bit figure *has* come up in discussions of what NSA will allow
   the carriers to put into next-generation digital cellular telephones.
By "allow", I'm assuming that you mean "allow for export".
Or, are you saying that they won't allow strong crypto in *domestic*
next-generation cellular phones?
What forms have the "incentives" or "disincentives" taken?
Eric Blossom
