
@_date: 1996-03-25 07:08:52
@_author: Jack Mott 
@_subject: apology - here is C source code 
I apologize to everyone for the binary posting, I figured it was small enough to not cause problems.  Here is the source.  I do not claim to be either a good programer, or any good at cryptography.  I am a junior in high school and I am interested in it, and I think I have some good ideas here.  The code may be kinda hellish, any CONSTRUCTIVE criticism would be appreciated. I have been programming about a year.  I can assure you though, this isn't some stupid XOR encryption...at least it is better than WordPerfect ecryption (I hope to god :)  think the only C++ in it is the comments and inline declarations, might want to double check though. I think the only non-portable code is the gotoXY statements, and the random function works differently under GCC if I remember correctly (I have had Linux for a little while) Oh yeah, I kinda stretched the definition of HASH in my code a lot... here goes.
***************************INCLUDES************************************	            // <-- dont need this in Unix
***************************VAR*****************************************	char 		key[80];
    //
main(int argc,char* argv[]) {
if (argc < 4)
if (ed[0] == (('e') | ('E')) )
else if (ed[0] == (('d') | ('D')) )
  {
  }
    //
void input()
                  vkey[i] = '';
                  vkey[i] = '';
some characters.");
    //
void openfiles(void)
infile  = open(ifn,O_BINARY | O_RDONLY);
if (ed[0] == (('e') | ('E')) )
O_CREAT | O_TRUNC | S_IWRITE);
    //
void closefiles(void)
if (ed[0] == (('e') | ('E')) )
  {
  }
    //
void encrypt(void)
char buf[BLOCK];
float blocks = 0;
long sizeoffile = filelength(infile);
long numread;
long maxblocks = sizeoffile / BLOCK;
if (maxblocks == 0) maxblocks = 1;
x = wherex();
while ((numread = read(infile,buf,BLOCK)) > 0 )
    //
void CopyBack(void) {
backfile = open(ifn,O_BINARY | O_WRONLY | O_TRUNC);
char buf[BLOCK];
long pos;
long size = filelength(outfile) - HASHSIZE;
long blocks = 0;
int numread;
long maxblocks = size / BLOCK;
if (maxblocks == 0) maxblocks = 1;
printf("\nRemoving encryption block:");
x = wherex();
lseek(outfile, 0L, SEEK_SET);
  do {
  } while (pos != size);
  close(outfile);
  chmod("KRYPT000.TMP",S_IWRITE);
  unlink("KRYPT000.TMP");
    //
void decrypt(void) {
char buf[BLOCK];
float blocks = 0;
long sizeoffile = filelength(infile);
long numread;
long maxblocks = sizeoffile / BLOCK;
if (maxblocks == 0) maxblocks = 1;
x = wherex();
while ((numread = read(infile,buf,BLOCK)) > 0 )
    //
    //
       //
file,   //
was      //
         //
void superhash(void)
printf("Generating System/Time/File specific SuperHash:");
x = wherex();
Havg = 0;
for (i = 0; i < HASHSIZE; i++)
key[i % keylen]) % MaxPos;
* hbuf * key[i % keylen]));
sin(key[i % keylen])+i);
if ((key[SuperHash[5] % keylen] + (key[SuperHash[3] % keylen] / 10)) != lseek(infile, 0L, SEEK_SET);
    //
void grabhash()  {
printf("Grabbing SuperHash Values...");
long sizeoffile = filelength(infile);
int keylen = strlen(key);
lseek(infile,sizeoffile - HASHSIZE,SEEK_SET);
Havg = 0;
for (i = 0; i < HASHSIZE; i++)
  {
  }
Havg = Havg / key[SuperHash[5] % keylen];
lseek(infile, 0L, SEEK_SET);
    //
void initblocks(void)  {
long total = 0;
int keylen = strlen(key);
for (i = 0; i < keylen; i++)
Kavg = total / keylen + total;
for (i = 0; i < BLOCK; i++)
  {
  }
seeya - thanks

@_date: 1996-03-26 14:12:14
@_author: Jack Mott 
@_subject: Mentor request - ISEF/Westinghouse science fair project 
Hello cypherpunks,
  My name is Jack Mott, and I'm the junior in highschool who posted the c++ source code a while ago, and as you can see it is pretty bad. ( self taught over 9 months ) Anyway for a science fair project this year, I would like to either create a new, or implement an existing encryption algorithm from scratch.  I need someone who has some experience programming in C/C++ and with crypto to get advice from and consult with from time to time. I have done well in science fairs in the past, and I could definitely win states with some help.  If anyone is interested let me know.
p.s. - there is another interesting twist to my project, but I don't want to give the idea away just yet.

@_date: 1996-03-27 18:08:04
@_author: Jack Mott 
@_subject: trouble with idea.c from cryptl99.zip 
Hey, I downloaded the crypto lib 'cryptl99.zip' from one of the crypto web sites, I got IDEA.C to compile, but it doesn't seem to encrypt.  The test code that comes with it shows the sub-key groupings, then it does this
X 0 1 2 3 4 5 6 7
Y 0 1 2 3 4 5 6 7
Z 0 1 2 3 4 5 6 7
It looks like X should be the plaintext, Y the ciphertext, then Z the plaintext again from the code, but it isn't working.  If anyone knows the source code I am talking about let me know what is wrong. Here is what the main piece looks like:
printf("\n Encrypting %d bytes (%ld blocks)...", BLOCKS*16, BLOCKS);
from this, Y should be encrypted, but it isn't! Thanks in advance for any help.

@_date: 1996-03-29 04:37:07
@_author: Jack Mott 
@_subject: RC4 implementation questions 
I just finished coding RC4 from the algorithm described in applied crypto 2nd edition.  Could someone send me a little file encrypted with a know-to-work rc4 program so I can see if mine is working right? thanks a lot.

@_date: 1996-04-01 16:14:32
@_author: Jack Mott 
@_subject: cryptanalysis questions 
What are the general methods used for statistical analysis of ciphers? Should I just use conventional stat analysis and look for patterns? Does anyone have any source or programs that do some of these kinds of things?

@_date: 1996-04-06 09:47:37
@_author: Jack Mott 
@_subject: RC4 improvement idea 
I got a paper from the cryptography technical report server  " about a weak class of RC4 keys.  The report said that with some keys, it was possible to predict what some parts of the State-Box would be.  I was thinking of a way to fix this, and had this idea:
do some sort of hashing function with the key that derives a number between 55 and 500 or something like that, then scrabmle the S-box that many times.  In this way, the chances that the State-Box will have any correlation becomes extremely small.  I think it is 1/125 to begin with anyway, so this would make it around  1/(125*NumPasses).  And since the exact number of passes is a function of the key, the cracker won't know how many times it went through.   I tried this out and having 1000s of passes doesn't effect the randomness of the state-box in any negative way, possibly it makes it more random? If anyone has any thoughts I'd love to hear them.

@_date: 1996-04-06 17:56:59
@_author: Jack Mott 
@_subject: rc4 weak keys fix? 
I got a paper from the cryptography technical report server
" about a weak class of RC4 keys.  The
report said that with some keys, it was possible to predict what some
parts of the State-Box would be.  I was thinking of a way to fix this,
and had this idea:
do some sort of hashing function with the key that derives a number
between 55 and 500 or something like that, then scrabmle the S-box that
many times.  In this way, the chances that the State-Box will have any
correlation becomes extremely small.  I think it is 1/125 to begin with
anyway, so this would make it around  1/(125*NumPasses).  And since the
exact number of passes is a function of the key, the cracker won't know
how many times it went through.   I tried this out and having 1000s of
passes doesn't effect the randomness of the state-box in any negative
way, possibly it makes it more random? If anyone has any thoughts I'd
love to hear them.
"It can't rain all the time"

@_date: 1996-04-06 18:24:35
@_author: Jack Mott 
@_subject: coderpunks questions 
I am really into programming and the math involved in crypto, and could care less about the politics.  I assume that coderpunks are more into that sort of thing. I have heard they are invitation only. How can I get an invite?

@_date: 1996-04-09 14:11:45
@_author: Jack Mott 
@_subject: questions about bits and bytes 
This may be a bit of a no brainer, but everything I have read sorta skips over this point.
a bit is 1 or 0
8 bits make up a byte (0-255)
If I have a 5 byte key, does that make it a 40 bit key?  The only
reason this doesn't make sense to me is it seems useless to use 5 byte
keys, yet that is what companies export since the government limits keys
to 40 bits.

@_date: 1996-04-13 15:51:56
@_author: Jack Mott 
@_subject: Known Plaintext attacks on symmertric algorithms 
Now maybe I have this all wrong, but it is my understanding that a known plaintext attack is when the cracker knows part of the plaintext of an encrypted file.  Then he/she uses that and runs the inverse of the algorithm to calculate the key.
  Whether or not I am right about what known plaintext means, isn't the entirely possible on all of the symmetric algorithms out there? If I grab a file that I know is, say, a standard credit card transaction form, and I know what the first 256 bytes are because they are always the same, shouldn I always be able to find the entire key that corresponds with those 256 bytes? (assuming the key is 2048 bits or less) And then with that key decrypt the whole file?
  Maybe I am missing something but it seems that all the symmetric algorithms are vulnerable to this, and I thought of a fix, but it involves having two keys (or one thats twice as big)

@_date: 1996-04-15 05:07:35
@_author: Jack Mott 
@_subject: key bit lengths 
In Applied Crypto, it talks about thermodynamic limitations of brute force attacks.  I did some calculations and it looks like it will take, given a perfectly effecient computer, the combined energy of 509,485,193 average supernovas to brute force a 256 bit key. I was just wondering if there are any theoretical ways around this. I am just talking about plain brute force here, not attacking other weaknesses.

@_date: 1996-04-15 09:12:04
@_author: Jack Mott 
@_subject: RC4 licensening 
Hello Cypherworld,
handling the whole situation?
2.0 version, I'm pumped. Now I just have to get GCC figured out and I'll make the Linux version work too. yyyeeeeha.

@_date: 1996-04-21 12:25:32
@_author: Jack Mott 
@_subject: Re: spinner entropy 
I think it is best to have a black box that can not be modeled personally. Anyway I am in the middle of putting together a portable RNG that will should consist of nothing more than a photoelectric tube, 9volt battery, and a bit of wiring. It will connect through the serial port. Just put your favorite radioactive substance near it and your set. before people freak out, there are many substances that will produce enough beta particles without killing anyone. In fact you could just use background radiation, but it would take longer. Anyway I'll let you all know how it turns out.

@_date: 1996-04-21 15:33:07
@_author: Jack Mott 
@_subject: Re: spinner entropy 
Take an RC4 state box.  grab 30 or so random seeds from a hardware device, use them to mix the state box, and use the rest of RC4 to grab random values. Just an idea, very fast at least.

@_date: 1996-06-30 14:40:40
@_author: Jack Mott 
@_subject: Hardware RNG 
I just recently built a hardware RNG, I just wanted to see what you guys think of it, here is how it works:
see if the geiger counter got a hit, if it did, record that number in the S-box as our first byte, do this 100 times, and we have 100 random random numbers in about 8 seconds, and the S-box will make a complete cycle between 1000 and 350,000 times between geiger hits, depending on how long between hits.
any thoughts? It seems to work well, no basic stat analysis reveals any pattern, and physicists have backed me up on radioactive decay being 'the great randomizer'.

@_date: 1996-09-23 06:18:44
@_author: jack 
@_subject: Evolving algorithm for faster brute force key searches? 
I got an idea last night, maybe this has already been thought of and
tried, but I thought I would give a quick outline of the program I was
thinking of:
-Specify a maximum key size (assume 1024bits or something)
-Start with an arbitrary key "aaaaaaaaaaaaaa"
Start a loop
-create five mutations of the key
-use each key to try and decrypt a few bytes of the message
-run a (or some) statistical analysis tests and come up with a value
for how 'random' the decrypted bits are
-Pick the key that produced the least random ouput
Probably this wouldnt work on any very strong algorithm, but it seems it
might be effective against some.  I am going to write the code and try
it out on RC4 and on a weakling little algorithm I wrote a while back.
Let me know what yall think.
