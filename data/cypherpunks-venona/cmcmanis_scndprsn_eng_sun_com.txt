
@_date: 1995-08-16 21:04:04
@_author: Chuck McManis 
@_subject: Re: Phone call for Mr. Doligez, was Re: SSL challenge -- broken ! 
This is the problem of using "physical" world analogies with the network.
A similar argument that is posited is that "Sure its not 100% secure but
its better than the carbons from a receipt (now gone) or people who
don't shred their garbage." I respond that the network isn't the "real"
world so the laws of physics don't apply. Someone in Boston MA is unlikely
to fly into Sunnyvale to paw through my garbage, but it would be "trivial"
for them to see my receipt go flashing by can throw some spare compute
cycles at breaking it. A snooper/cracker program on a "spare" machine
might yield a half dozen credit cards a week. I prefer the attitude of better vigilance through layered encryption. That
is the transaction might be 40bit RC4 but the "jewels" (otherwise known
as the credit authorization information) should be DES3. Just my opinion of course.

@_date: 1995-10-02 09:19:56
@_author: Chuck McManis 
@_subject: Re: NetScape's dependence upon RSA down for the count! 
Why forge it? Why not simply buy a netsite server with a valid certificate.
Let's say you paid full list for it $5000. It is the classic MITM attack
but the protection against that attack was generally that the parties
communicating "knew" each other. This is a fundamental weakness of putting the security at the SSL level as
opposed to a possibly higher level. With the netscape attack since your
client never cares "how" (or to whom) the SSL connection is made, it never
shows you the information about where the source key came from. Only that
it is valid.

@_date: 1995-10-09 10:11:17
@_author: Chuck McManis 
@_subject: java security concerns 
Perry pointed out the standard set of concerns that anyone should have with
Java. About the only thing I'd care to dispute at the moment is that Java
is a "large complicated" application. It is in fact less than 20K lines of
C code. And while it is true that applications of even this size are
difficult to prove safe, there has been an effort to break that problem
up into components such that each "layer" can be proven safe and where
that layer is used that safety carries over. Let me give you an example:
There are three "parts" of the Java system:
At a "meta" level there is the Java Language and the compiler that converts
it into byte codes however for the purposes of a security discussion those
are irrelevant since the browser in this case receives byte codes and the
compiler at the other end is presumed suspect.
So one way to approach this analysis is to look first at the bytecodes. One
of the things you will discover is that Java is *not* a general purpose language. It lacks crucial features such as introspection and anonymous
memory access. So you might ask "How can anyone write anything useful in it
then?" and that is a fair question. The answer is that it does have one
loophole and that loophole is the 'native' keyword on a method description.
Basically, if you need a general purpose feature (like object inspection)
you can get it with a native method. "So I write a native method to delete
your files, what does that buy me?" you might ask. Well Java is also a _late binding_ language. Thus the binding of external method references
(which native methods are by definition one) can be identified at bind/link
time (which always occurs on the client) and optionally rejected.
The next level of inspection is all of the classes that, through one of their
methods, actually call a native method. Those can be analyzed closely and
there are relatively few of them (about 28).
The final level of inspection is the virtual machine interpreter. Its operation as a giant switch statement can be inspected for valid code
design. It isn't all that large and a team of three can inspect it in under
a week. If the layers work, the system works. We encourage any questions on security
or identifying any "holes" to be sent to java for our immediate
However, Java is also late

@_date: 1995-10-09 17:29:54
@_author: Chuck McManis 
@_subject: Re: java security concerns 
Good point.
I don't necessarily agree. The core java interpreter is simply:
Its a useful metric. But the concept of trust isn't defined. If
you write in pure Java code (that is no references to any native
methods) we should be able to do much better than that. And since Java doesn't have "programs" it just has "classes" and
many of those fit on two pages where does that leave us? Would it
be reasonable to say that if I want to write a Java class I trust
I should keep it under two pages? If I then write another class that uses that class, that is also under two pages have I met
the requirement? Can this aggreagate four page Java class be trusted?
Many times. I agree.
I don't think the lawyers would let us. Would anyone be interested in a Java daemon that one could send arbitrary
classes to in an attempt to subvert the runtime? I once thought this would
be a good way to give safe exposure to the system in general. You know sort
of "here's a program that can feed classes to a Java runtime on a system
which is known to have a file X on it. Try to return the contents of X."
It probably wouldn't be to useful beyond that, and it would only validate
the classes you have access to, not necessarily the full set in a release.
(hence my not doing it given its utility only in testing the core runtime)
--Chuck
