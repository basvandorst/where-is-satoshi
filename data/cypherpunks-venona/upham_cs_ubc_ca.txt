
@_date: 1993-03-15 18:27:23
@_author: Derek Upham 
@_subject: Re: HIDE: embeddin msgs into snd & graphics 
Uh, unless the JPEG FAQ sheet has seriously mislead me, lossy
compression would be excellent for this sort of steganography.
In the standard JPEG encoding procedure, an image is broken into
square blocks of pixels, eight per side.  These blocks are run through
a 2-D discrete cosine transform, producing a set of cosine waves that
are equivalent to the original blocks (within small errors).  If the
original image was smooth (a natural image, for example), the low-
frequency waves will contain all the information necessary for
reproducing the block; the high-frequency waves will contain nothing
but faint noise.  So the JPEG encoder _dumps_ the high-frequency
cosine waves.  That's how the format gets a lot of its compression.
This is where steganography comes in.  Take these empty wave slots and
stick your data in them.  For example, if the wave magnitudes are
stored as four-byte integers, store one byte of data in the lowest-
order byte in the slot (or go down to four, two, or even one bit per
integer, if necessary; floating-point would be wonderful, here).  As
long as the hidden data representation looks like very tiny values to
the JPEG decoder, the data should be completely unnoticeable on
display---but the steganographic decoder will know where to look for
it and what to do with it.
Anyone have honest-to-god practical experience with JPEG/JFIF to
assess the feasibility of this technique?
Derek Lynn Upham                               University of British Columbia
upham                                   Computer Science Department
"Ha!  Your Leaping Tiger Kung Fu is no match for my Frightened Piglet Style!"

@_date: 1993-05-06 13:57:15
@_author: Derek Upham 
@_subject: HIDE: Alpha version of JFIF steganography available 
I've got a working version of a JPEG steganograpy program.  It uses
modified cjpeg/djpeg sources to stick arbitrary files in JPEG images
and then extract them.  It needs testing.
The files are in ftp.cs.ubc.ca:pub/pickup/jsteg.  There is a copy of
the JPEG-v4 sources (or use your own), a context-diff of the source
changes (use "patch -p0" in the directory above the sources), and a
test ".jpg" file.  Assuming everything works correctly, running
  djpeg -crypt filetoread.txt miyazaki.jpg > /dev/null
will extract the steganized text into the file "testout.txt" and dump
the PPM file.  (The extracted text should be an exact copy of the
"USING" file in the JPEG-v4 distribution.)  To steganize a file, use
  cjpeg -crypt filetohide.txt image.ppm > image.jpg
or replace "image.ppm" with "-G image.gif", etc.  If "cjpeg" reports
that it's unable to inject the file, compress the file or use a higher
"-Q" parameter.  In general, the stegfile needs a final JPEG file
that's at least eight times larger.
"Naaaaaaaaaaah, Quess isn't stupid.  A vicious, vindictive, underhanded, slimy,
double-crossing, self-deluding, daddy-hunting, family-killing, conscienceless,
callous, sexually repressed, Electra Complex victimized, self-interested, snot-
ty, obnoxious little preadolescent whining B*T*H, yes.  But she's not stupid."

@_date: 1993-07-15 15:13:28
@_author: Derek Upham 
@_subject: Looking for fastest Legendre/Jacobi algorithm 
In 1991, Tygar and Yee published a paper describing an authentication
and security system for Mach.  At least two of the techniques
described in the paper can be used elsewhere; one is a zero-knowledge
proof of identity algorithm, and the other is a public-key algorithm
for exchanging arbitrary data (i.e., private encryption keys).
The security of the scheme is based on the intractability of
determining quadratic residuosity.  Variable $a$ is a quadratic
residue on $n$---it has the Jacobi value of 1---if and only if there
exists some $x$ such that $(x^2\mod n)=a$; otherwise it is not a
residue and has Jacobi value -1.  (If $n$ is prime, the Jacobi value
is also the Legendre value).  Rabin(???) has proven that working
backwards from $a$ and $n$ to find $x$ is equivalent to factoring
$n$, so only the person who generated $n$ will be able to check the
residuosity of $a$ (if factoring $n$ is difficult, of course).
In the private key exchange algorithm, for example, the Sender
generates a series of quadratic residues and non-residues $a$ over
$n$ and passes these values on to the Receiver.  The Receiver
calculates the (non-)residuosity for each and assigns it a bit value,
thus building up a string of bits that determine the key.  Any Tapper
will be unable to calculate the residuosities from the data stream,
and so will not intercept the key.
I've written a bunch of programs to generate keys and run an
encrypted bit exchange, but the performance is lacking.  Decoding
time seems to grow at $O(\el^2)$ with the length of $p,q$, which
makes using any sort of secure public-key $n$ quite infeasible---
especially if people want to use these algorithms on small home boxes
for dialup security.  On a 386/40, receiving 56 bits encoded with a
512 bit public key takes twenty-two minutes...
So: anyone know tricks to bum as much speed as possible out either
the Jacobi or Legendre algorithms?  For our purposes, they are
equivalent.  If the Tygar and Yee algorithms ever run efficiently,
they could be very nice alternatives to RSA.
Derek Lynn Upham                               University of British Columbia
upham                                   Computer Science Department
"Ha!  Your Leaping Tiger Kung Fu is no match for my Frightened Piglet Style!"

@_date: 1993-09-25 11:55:51
@_author: Derek Upham 
@_subject: The "mpack" MIME encoder has just been released. 
The newsgroup comp.sources.reviewed has just released the sources to
"mpack", a utility for encoding binary files into a MIME-compliant
format, then mailing them to recepients or posting them to a
newsgroup.  "munpack", a utility for decoding the files, is also
included.  The package is supposed to work on MS-DOS and MacOS
systems (and it's quite small), so people playing with PGP might be
able to get some use out of it.
Derek (the other other Derek)
Derek Lynn Upham                               University of British Columbia
upham                                   Computer Science Department
"Ha!  Your Leaping Tiger Kung Fu is no match for my Frightened Piglet Style!"

@_date: 1994-02-18 21:16:22
@_author: Derek Upham 
@_subject: Newsgroup/list moderation techniques 
So people are arguing that USENET newsgroups need moderation to keep
out extraneous posts.  Other people are arguing that moderation brings
the danger of ``cabals'' and the like; who chooses the moderators?
How about this: anyone can be a moderator.
Supposed Ann wants to be a moderator.  She sends e-mail to the
moderator site saying ``make me a moderator''.  Afterwards, she gets
periodic mail messages containing newsgroup posts.  For each message,
she responds to the moderator site saying "APPROVED" or "NOT
From the point of view of the moderator site, it gets newsgroup
messages through e-mail and then forwards that e-mail to one person
chosen randomly from the moderator list.  Soon afterwards, it gets an
"APPROVED" or "NOT APPROVED" message back from that person, and
depending on the response, either posts the message or does not post
the message to the newsgroup.
This moderation method has two major benefits: the load of culling
posts is distributed among many people, which helps responsiveness;
and the decision of culling posts is distributed among many people,
which reduces the risk of partisanship.
There are, of course, issues of how do we deal with people who can't
be reached or who don't read their mail in a reasonable time, but they
can be answered, I'm sure.
For an example of a similar system of distributed responsiblity,
look at the fabled USENET Oracle...
Derek Lynn Upham                               University of British Columbia
upham                                   Computer Science Department
"Ha!  Your Leaping Tiger Kung Fu is no match for my Frightened Piglet Style!"

@_date: 1994-02-27 14:17:50
@_author: Derek Upham 
@_subject: Re standard for stegonography? 
There appear to be two existing steganography packages for images.
One is "jsteg", a Unix-based system which stores data in JFIF-
compliant JPEG images; it is based on version 4 of the cjpeg/djpeg
package.  The other is "Stego", a Mac-based system which stores data
in Mac PICT files (I think---I don't have a Mac to examine it).
"jsteg" is available in the Cypherpunks FTP archive in the
applications subdirectory as the original jpegsrc package, plus the
patches, plus a README file.  However, you might be better off
tracking down the "Stego" sources since "jsteg" stores its data in a
rather odd way (see the docs for more information).
Derek Lynn Upham                               University of British Columbia
upham                                   Computer Science Department
"Ha!  Your Leaping Tiger Kung Fu is no match for my Frightened Piglet Style!"

@_date: 1994-04-10 18:16:13
@_author: Derek Upham 
@_subject: Re: Zero Knowledge, Hamiltonian Cycles, and Passwords 
Look at "Strongbox: A System for Self-Securing Programs" by J. D.
Tygar and B. S. Yee in the "CMU Computer Science 25th Anniversary
Commemorative" proceedings (from 1991).  As the paper describes:
    ``Strongbox uses an authentication protocol derived from Rabin's
    observation about the square root operation: if one can extract
    square roots modulo  n  where  n=p*q ,  p  and  q  primes, then
    one can factor  n .  [That should be `if and only if', i.e.,
    finding the square roots is too hard unless you created  n  in the
    first place.]  Both our protocol and FFS are *zero-knowledge
    authentication protocols_*  [. . .]  And in contrast to Needham
    and Schroeder's authentication protocol, zero-knowledge
    authentication protocols require no central authentication server
    and thus there is no single point of failure that would cripple
    the entire system.''
In addition to zero-knowledge authentication, the paper provides an
algorithm for the secure exchange of sessional symmetric encryption
keys, and ways of combining authentication and key-exchange steps.
I managed to get the key-exchange working some months back (in C++,
using GMP to handle the number-crunching), but it was hampered by my
incredibly slow 386 on one side and odd bugs in the Sun4 environment
on the other.  Contact me if you want to hack around on it.  I also
know where to find unreleased GMP 1.9 sources for some additional,
probably more reliable, functions for calculating the Legendre symbol
(which the whole system depends upon).

@_date: 1994-05-12 02:03:49
@_author: Derek Upham 
@_subject: Re: Cypherpunks Goals: Bad debate drives out good debate 
Let's face it: Usenet is inherently broken.
There are two ways to filter for content: filter at the newsgroup
source via moderators, or filter at the newsgroup destinations via
killfiles.  Moderating does seem to get rid of most of the cruft, but
the moderators are required to read every post that comes through,
and, worse, make judgements with some degree of impartiality (which is
not always possible).  On the other side, kill files are useful, but
only to a certain degree.  Blocking sertain key words in subjects
doesn't help against topic drift; blocking Sternlight won't help you
in the slightest when umpteen other people respond to his posts.
The situation for most mailing lists is just as bad.  Anyone can send
a post to a mailing list, and there are usually no moderators to
enforce content.  A reader's only recourse is another kill file---and
most mail killing facilities are pretty lousy when compared with their
Usenet counterparts.  The only thing mailing lists have going for them
is that they tend to be less obvious than newsgroups.  Harder to find.
To fix them problem, then, we either have to either improve the kill
files or improve the moderation.  Personalized AI filters (see Moran's
"The Long Run") will be spiffy when they arrive, but they're not going
to be arriving any time soon.  This leaves moderation.  If we increase
the number of moderators, we can reduce the load on each and take into
account as many tastes as possible.  In the best case, the moderators
would consist of all the readers of the newsgroup.
How would this work?
Assume we're running a mailing list (Usenet v.2.0 will be just a
special case of a mailing list).  All posts are sent to the central
site.  The mailing list software picks one e-mail address from all of
the list receivers, and forwards the post to that e-mail address
(keeping the original post on file).  The forwarded post will have a
subject line something like:
  Subject: Post ACK, list cypherpunks, msg with the post contained in the body.  The receiver reads the post,
then replies to it.  The reply subject line will be:
  Subject: Re: Post ACK, list cypherpunks, msg and the body will contain "ACK" or "NAK" or "post" or "dump" or
whatever.  This goes back to the list maintainer, who can check that:
  * The message in question is in fact outstanding.
  * The person who sent back the evaluation was the one who was
    supposed to.
  * Other sordid details.
If the message was approved, it goes to everyone.  Otherwise, the
original poster is informed that the post did not meet standards.
We might even want to forward the evaluation body to the original
poster; this would allow the evalutors to send comments explaining why
the post was rejected.
The nice thing about this technique is that the more people a person
pisses off, the less likely it is that his or her posts will ever see
the light of day.  Even better, aware readers can nip MAKE.MONEY.FAST
and Green Card Lottery posts in the bud.
Something very similar to this exists now in the Internet Oracle, so
distributed moderation ought to be possible.  I suspect that the mail-
handling features could be incorporated entirely into "procmail" and
"SmartList" (a filter program and a mailing list program), although
the databases would need C maintenance programs for efficiency.
I'll go to bed and await comments.

@_date: 1994-05-13 00:41:06
@_author: Derek Upham 
@_subject: Re: Cypherpunks Goals: Bad debate drives out good debate 
Okay, I'll call the moderation method I suggested the ``asymptotic
moderation'' method.
Some problems that people have with asymptotic moderation:
1> It requires either a trusted subset of the membership to be
1> moderators and the most trusted are also the ones with the least
1> free time, or you trust everyone.  I'd hate to send a message to
1> Detweiler to see if he thinks it should be posted or not :)
We trust everyone.  Let's take a look at the four possible cases here:
Good message, good moderator: message accepted.
Bad message, good moderator: message denied.
Bad message, bad moderator: message denied.
Good message, bad moderator: SEND THE MESSAGE AGAIN.
If you're confident that your post was good, but rejected out-of-hand
by a bad moderator, just send the thing again.  It's highly unlikely
that the same bad moderator get it the next time around.
Obviously bad posts, though, will be rejected by everyone, no matter
how many times they get re-posted.  And just to be safe, the mailing
list program can keep track of rejection slips and refuse posts from
obvious abusers (and maybe it could do something similar with the
above denial-of-service attack).
2> The trouble with random single moderators are many, but worst would
2> probably be time-delay. If the chosen moderator for a message is
2> busy, sick, or away from their desk messages could be delayed for
2> days. The problem gets even worse if a delayed message is then
2> approved, and posted out of sequence.
The mailing list program can detect cases where people are taking too
long to reply; those posts can go to a designated list maintainer (or
maintainers) for immediate approvial.  People who are consistently
late will lose moderation privs.  Remember that posting out of
sequence isn't necessarily a thread-killer---Usenet survived for years
with UUCP transfer delays.
3> Instead of picking random list receivers to moderate, readers should
3> choose their own moderators.
3> As a moderator reads the latest messages on the list, he or she can
3> mark each one as junk or not junk.  This causes advice messages to be
3> sent to their subscribers.  The subscribers can use mail programs which
3> process the advice and only show messages which have passed.  ("If all
3> three of my moderators say a message is junk, then don't read it,
3> otherwise, show me.")
So now we're back to kill files.  Here, though, the kill file rules
are based on out-of-band messages that can be received at any time
(possibly after you've read the message!).  And every user who wants
to use the kill file must set up killing software.  And there's no
guarantee that people would bother to rate every message they read
(I've participated in something similar on a BB, and _that_ particular
aspect failed miserably).
4> How about auto-moderation?  I came up with this idea a while back for
4> automatically moderating mailing lists.  Here's how it works:
4> [. . .]
4> If a person becomes a nuisance, people send their votes in to the
4> moderator-robot, and it tallies the votes. If within XXX days more
4> thumbs down votes are received than thumbs up votes, the person is
4> placed on the disapproved list.
Pretty good, but it wouldn't do anything to stop those people who
create random net addresses and post lone MAKE.MONEY.FAST or Jesus Is
Coming!!! messages.  And it's a bit too harsh to deal with
intermittent flame fests, especially flames from people who are
usually productive contributors (you know who you are).
5> There's a simpler solution.  Using the majordomo hack I posted
5> earlier, mail from known abusers would be bounced to the moderator
5> for his approval or rejection.  This would be a small volume, which
5> should be within the capabilities of one moderator.
How do we determine known abusers, and how can we deal with unknown
abusers or intermittent flame fests as above?
In summary, the aysmptotic moderation method has a couple of benefits.
All of the custom code is concentrated in one place; anyone with a
mail reader can perform moderation duties.  The moderation duties are
simple and well-defined.  You _know_ when you are being asked to make
a critical judgement (instead of judging everything---or more likely,
nothing).  All of the approval/disapproval information passes through
the central site, so that site can keep track of chronic abusers
through plain ol' numbers.  Finally, since the primary filtering
method does not depend on filtering specific users, it works just as
well for drive-by posters and for people who are suffering from a
temporary lack of control.
Derek Lynn Upham                               University of British Columbia
upham                                   Computer Science Department
"Ha!  Your Leaping Tiger Kung Fu is no match for my Frightened Piglet Style!"
