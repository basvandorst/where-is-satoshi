
@_date: 1996-01-19 10:09:22
@_author: David A Wagner 
@_subject: Re: Hack Lotus? 
In article <2.2.32.19960118195838.008a4944
Hack Lotus?  Please do.
I would love to see the internals of how Lotus Notes does the escrow.
Every conceivable way I can see to do it seems very vulnerable to attack.
If the receiving Lotus Notes program doesn't check whether the high 24
bits have been escrowed correctly in the LEEF-like field, then a simple
hack to the sending Lotus Notes program to not send the LEEF field
should give foreigners true 64 bit encryption.
[LEEF = Law-enforcement / Espionage Exploitation Field = the RSA-encrypted
high 24 bits of the key]
If the receiving Lotus Notes program does verify that the high 24 bits
are escrowed correctly, then anyone can verify that, so in 2^24 trials,
I can recover the high 24 bits, and with 2^40 more trials, I can recover
the high 40 bits.  Therefore 2^40 + 2^24 trials should suffice to hack
Lotus if this is how it works.
Or maybe it works in some other crazy manner.
Waiting to hear the technical details of how it works,

@_date: 1996-01-24 12:06:35
@_author: David A Wagner 
@_subject: Re: Why is blowfish so slow?  Other fast algorithms? 
In article <199601221851.NAA16938
If you want authentication, you must use a crypto-strength MAC.
Encryption (be it RC4, DES, etc.) is not enough.
False.  CFB has limited error propagation, so if I modify any block
before the next-to-last, it will not show up with your method.
This seems to be a really common error.
If you want message integrity guarantees, you must use a MAC.  Always.

@_date: 1996-01-22 15:08:34
@_author: David A Wagner 
@_subject: Re: Lan Manager security 
In article <9601221620.AA11356
     [ ... the LanMan / Samba(?) password authentication protocol ... ]
     [...]
     [...]
Oh yeah, this protocol again.  I remember looking at it a while ago; many
thanks to Andy Brown , who showed it to me and kindly
gave me lots of information.
It's pretty crappy, IMHO.  It's very weak against dictionary attacks
(assuming I have a sniffer).
For instance, if you use a password which is less than 12-14 characters
long, it will be very easy to recover bytes 7..13 of your password.
After that, it will often be simple enough to extend the password backwards
if it is based on a dictionary word; even if the password is purely random,
this reduces the strength of the password to an effective length of 7 bytes.
Also, there is no salt used in the password hashing function, so precomputed
dictionary attacks are easy (e.g. the "Exabyte attack", where you precompute
the hash of each likely password and store each result on a huge tape.)
Unfortunately, I don't have time right now to follow up with a sample
exploit program or anything.  Sorry 'bout that.
Microsoft should have used a real crypto-quality hash function (e.g. MD5),
instead of trying to synthesize one from multiple concatenations of DES.
The technical details on the attacks follow.
Call the bytes of the password P_0 .. P_13, the 16-byte key K_0 .. K_15,
and the response R_0 .. R_23; and call the challenge C and the static 8-byte
server key S; K is generated by DES encrypting S with P, and R by DES
encrypting C with K.
I know C,R and want to find P_7 .. P_13.  First, try all possible values of
K_14, K_15; the right value can be recognized when C_16 .. C_23 encrypts to
R_16 .. R_23 under K_14, K_15, 0, 0, 0, ..  Now that we know K_14, K_15,
I can try the likely values of P_7 .. P_13; wrong values can be quickly
discarded by trial encrypting S under P_7 .. P_13 and noting whether the
last two bytes of the ciphertext equal K_14, K_15.  Each remaining guess
for P_7 .. P_13 gives me a candidate for K_8 .. K_13; I can check all K_7
possibilities to see if there's any for which C_8 .. C_15 encrypts to
R_8 .. R_15 under the K_7 .. K_13 candidate.  If there is such a K_7, the
guess for P_7 .. P_13 is almost certainly correct; if not, try another
candidate for P_7 .. P_13.  If there are N likely values of P_7 .. P_13,
this recovers the true value of P_7 .. P_13 with about N trial encryptions.
Note that there is no salt used; in fact, if I'm willing to do N precomputed
trial encryptions, recovering the true value of P_7 .. P_13 takes N / 2^16
Once I've found P_7 .. P_13, if I'm willing to do M precomputations [where
M is the number of likely values of P_0 .. P_6], then recovering the true
value of P_0 .. P_6 can be done with about M / 2^8 trial encryptions.
(If I'm not willing to do precomputations, it'll take M trials.)
Did that make any sense?
