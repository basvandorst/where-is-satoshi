
@_date: 1994-07-02 17:01:34
@_author: Ian Farquhar 
@_subject: Re: Dr. Dobbs Dev. Update 1/5 July 94 & Schneier 
An interesting thought hit me when reading this.  The "classic"
Cray series (Cray-1, X-MP, Y-MP) all have a rather curious instruction
generally known as population count.  All it does is to take a register
and count the number of one bits in it, and return that count.  Originally
I could never figure out a use for this, but later was told that it was the
"canonical NSA instruction", and was consistently demanded by almost all
military SIGINT operations.
On reading this, I realised that one possible use was to implement a
vectorized version of a LFSR.  Take a vector register (the shift register),
AND it with a mask of the taps into another vector register, and then
do a population count to determine the carry in.
Just a thought.  It's the only plausable use that I have yet thought of
for this instruction.  Has anyone else got any ideas?
As for military ciphers having been "the workhorse of military
cryptography for years", I am reminded (with some amusement) of the
structure of A5.  I wonder if all of the fuss about secrecy was not
about the almost non-existant security of the cipher, but simply it's
similarity to more sophisticated military ciphers?

@_date: 1994-07-06 19:58:27
@_author: Ian Farquhar 
@_subject: Bit counting 
Because on a lot of architectures this implementation may be hideously
inefficient.  All the world is not an Intel chip, thank god.

@_date: 1994-07-06 23:48:51
@_author: Ian Farquhar 
@_subject: Re: Counting bits 
Both Sun C and GCC on a Sun SPARC system running 4.1.3 produced this code
for each bit-count line (-O4 optimization used):
        andcc   %o0,2,%g0		; AND the bit
        bne,a   L77044			; branch/anull if zero
        inc     %o5			; increment bitcount
This, I believe, is as optimized as it is possible to get on a uniprocessor
On both compilers, the routine size was 28 instructions total, and that
would also be the maximum path length for the execution of this routine
when passed an ASCII 255 value.
A MIPS-based DECserver running Ultrix 7.1 produced this (again, -O4):
        lb      $11, 0($sp)		; Load the byte off the stack
        and     $12, $11, 16		; AND the bit
        beq     $12, 0, $35		; branch/anull if zero
        addu    $3, $3, 1		; increment bitcount
Total instruction count was 28.  This is non-optimal, as there is no
need to reload off the top of the stack on every line, and if so modified it would be equivalently efficient to the SPARC implementation.
On a Cray Y-MP/EL running UNICOS 7.0.6 (-O3, which is equivalent to
- -hinline3,scalar3,task3,vector3):
L5          =               P.*
            S7              2		; Move 2 into S7
            S0              S2&S7	; S0 = S2 AND S7
            JSZ             L6		; Jump to L6 if the bit was zero
            S7              1		; Move 1 into S7
            S1              S1+S7	; Up the bitcount in S1
L6          =               P.*                             ;               9
Note that the Cray C compiler (or indeed any C compiler I know of) is not
yet capable of recognising the option of using the population count
instruction here, because it is nearly impossible to determine what this
particular routine is doing.  Even so, the total instruction count is
80, which is somewhat excessive.  The "Move 1 into S7" could probably
be eliminated by using another scalar register, and I suspect (but don't
have the manual here so I cannot confirm) that they'd be better not
to reload the mask every line, but instead to load it once and shift.
Additionally, you could probably vectorise this, but I doubt it would
buy you much.
Anyway, that's an analysis of three high end architectures on this
code fragment.  Personally I feel that a lookup table would be a MUCH
more efficient implementation for most systems which lack population
count, even for words up to 20 bits or so in size (depending on your storage
requirements and latency at accessing main memory, of course).
Enjoy.  One of these days I will get back to my project of implementing
crypto primatives in CAL, but I do not have the time right now.
BTW, folks, playing around with this is fun.  I still believe that either
the SKIPJACK interim reports Cray-implementation timing figures were
wrong, or the conditions under which the program was compiled was
incorrect (most likely), or that SKIPJACK contains no s-boxes.
Take your pick.

@_date: 1994-07-07 18:03:10
@_author: Ian Farquhar 
@_subject: Re: Mastercard, Visa, Access, Barclaycard, Amex, JCB ... 
My fiance regularly configures remote EFTPOS (Electronic Financial Transcation
at Point Of Sale) terminals from her job in the 24 hour answer centre of a
major bank in this state, and when she is doing so she reads a "public key" off the screen to for the vendor to key into the unit.  Sounds very much like some sort of assymetric session key exchange to me, and I'd lay money on the symmetric cipher behind that being DES.  Apparently there is also an Australian Standard for the ecryptographic exchange of pin numbers, and I know that DES is also sanctified in an AS (and recommended by DSD, who even now still consider DES "appropriate" for the banking industry).

@_date: 1994-07-07 19:03:08
@_author: Ian Farquhar 
@_subject: Re: Question: Key Distr. in realtimeo applications? 
It does not.  The Clipper initative (FIPS-185) deals solely with the
specification of a symmetric cipher with escrowed keys.  Key exchange
and authentication is outside the scope of the protocol, but most
implementations would probably use something like a D-H key exchange
to do it (remember that a Clipperphone guarantees privacy between yourself
and the person on the other end, but does NOT authenticate them to you
or you to them.  Man in the middle attacks are obviously possible,
depending on the key exchange protocol that your Clipperphones employ.)

@_date: 1994-07-10 16:09:27
@_author: Ian Farquhar 
@_subject: Re: Request: tamper-proofing executables 
The neatest trick I heard of was to use the 68000's single step mode
to decrypt each word of the program on the fly, run it, then write it back
reencrypted under another key, so that a decrypted copy never existed in memory, and what was there was a moving target.  Unfortunately, the decrypting software did sit in memory, and so you could eventually hack that right out,
and decode the core image.
There was a CMU (I think) paper on the subject, but it assumed fully
protected hardware (CPU's wrapped in huge quantities of wire all sealed in
epoxy etc.)  Such hardware tricks - as I think the NSA learned with
ViaLink - are never completely satisfactory. :)

@_date: 1994-07-10 18:35:31
@_author: Ian Farquhar 
@_subject: Re: Request: tamper-proofing executables 
Somewhat easier, though.  And utilizing single-step defeats a lot of
debuggers too, who don't expect programs to use it.  The tool of choice
for killing such systems is an ICE, although most hackers do not have
access to these.
Exactly the point I made in the original article: the code to do the
decryption is vulnerable.
Ditto in my original article.
And it's not particularly secure, either.  There are well-known techniques
for defeating such approaches.  These are discussed in the CMU paper
I referred to.

@_date: 1994-07-10 22:39:25
@_author: Ian Farquhar 
@_subject: Re: "uncrackable" executables 
And what code is checking that the program which is fed through the dongle
actually verifies?  Why, code in the file itself, which can be fairly
easily removed from the program, thus removing the need for the dongle.
That's the problem: the dongle IS always optional.  It plays no part in
how the program runs, and thus removing it from the protection "protocol"
(to use that word's widest definition) is comparitively trivial.  What
you need to do is to make sure that the dongle plays some major role
in the way in which the program runs, and as I have said on this list
recently, the commonest way this is done is to have the dongle server
constants to the program.  Even this is reverse engineerable, but at
a much greater cost.
The ultimate dongle would be one which contains additional computing
resources (say, a coprocessor), the duplication of which would render
reverse engineering at the same level of difficulty as building one
from scratch.  Thus the program is dependent on the dongle, which
enforces your protection protocol in hardware.
Not on PC boxes (with the possible expection of the cartridge port on the
PC Jr.  Am I showing my age or what? :)
Actually, if by dongle you meant a plug-in-card, yes it is possible.  But
most people would not accept the loss of a card slot for a dongle unless
it did actively assist in running the program, and it is still a major
on-cost for the program.

@_date: 1994-07-11 13:52:14
@_author: Ian Farquhar 
@_subject: Re: Supposed NSA turncoat reveals monitoring of anon remailers? >pshah!< 
Of course, there is an amusing side to this.  As a matter of course,
they'd probably have the originator investigated (just to make sure
he had no contacts or association with the NSA outside of his imagination),
which might be rather unpleasant for him now or if he ever needs a
security clearance.
In reality, tracking the use of anonymous remailers should be fairly
trivial for the NSA if the traffic passes through an US/International
gateway (and can thus be legally observed under the NSA's charter).  The majority of remailers do not encipher the output in
any way, and even those which do would leave enough traces (eg.
comparable sized messages being seen shortly afterwards, simple
patterns emerging using traffic analysis) that would reveal the
mapping fairly quickly.
On the subject of network monitoring, Bruce posted a copy of an NSA
technology transfer which described a database searching algorithm
that looked fairly sophisticated (I don't have the actual posting
handy.)  Did anyone (Bruce?) obtain a copy of the algorithm, and if
so, were there any distribution limitations on it?  It looked like
just the thing that the NSA would use as their "watchword" scanner,
and even if not, it looked like a very useful design all the same.

@_date: 1994-07-11 17:29:37
@_author: Ian Farquhar 
@_subject: Idle question... 
I was compiling a list of crypto algorithms the other night, trying to
produce a library of description documents for the algorithms, and an
interesting but idle question hit me: what ever happened to RC1, RC3,
MD1, MD3, A1, A2, A4, A6, and A7?
Just wondering if anyone knows...

@_date: 1994-07-12 15:19:45
@_author: Ian Farquhar 
@_subject: Re: NSA technology transfer (fwd) 
Which rather gives one the impression that the technology transfer program
was forced from above, rather than being their own initiative.
Two suggestions:
1. See your local Congress-critter, and explain that the NSA's Technology
   Transfer program is being subverted.  After all, you guys in the US PAID    for the development of this algorithm, and it strikes me as being a bit    offensive that you should pay again to see it.
2. FOI it.
I'm rather glad that _I_ didn't ring the number up and ask for the details
("Hello, I am a foreign national.  Can I have this algorithm please?")
I must admit that I was sorely tempted after reading Bruce's post, though!

@_date: 1994-07-12 16:14:47
@_author: Ian Farquhar 
@_subject: Re: Idle question... 
I left it out simple because it is a known cipher.  All of the ciphers mentioned
above are parts of series, but I have never seen published mention of them
(eg. we know MD2, MD4 and MD5, but those very numbers imply the existance of
MD1 and MD3, which I have never seen any reference to.)  I left A3 and A8
out as well.
Definitely, although the algorithm description posted was not complete.
What is clear, though, is that the French-designed A5 cipher is hideously
insecure (unless there is some amazing subtlty to it's design, and I
very much doubt it).
Some implications:
1. The French - with their well-known and legislated hatred of civilian
   crypto - won the battle of the GSM crypto algorithm, and managed to
   corrupt any chance of the incorporation of decent security in this
   mobile protocol.  The French position has had wide reaching implications
   globally, which I suspect that a lot of people would not be too happy
   about.
2. That our governments lied to us about the security of the algorithm.
   I note with some disgust that Australian organisations like ASIO and the
   AFP pushed HARD for A5X over A5 on the grounds that A5 was too hard
   to break.  This position was a fabrication, that much is clear.
3. That GSM phones are NOT in any way secure.  Sure, it's better than AMPS,
   but that is not saying much.  I also wonder if the embargo on the
   release of the A5 algorithm was simply to enforce the monopoly of
   the government SIGINT operations.
Anyway, let's throw this discussion open.  Here is the algorithm description,
and don't forget that A3 and A8 probably came from the same guys, and they're
part of GSM's key exchange protocol.  If they're as good as A5, GSM is in deep,
deep trouble security-wise.
BTW, the algorithm leaked, it was not reverse engineered.  I do not expect
SKIPJACK to leak, as it's distribution would be VERY limited, even within
the NSA and chip houses.  Even A5 was reputed to be known to only 2 or 3
people within Motorola.
I do not have a description of A5X, but I have heard rumors that A5 generates
a single 114 bit key, and then continues to use it over and over again.
As all of you would realise, this would be utterly trivial to break.
The GSM encryption algorithm, A5, is not much good. Its effective key length is
at most five bytes; and anyone with the time and energy to look for faster attacks
can find source code for it at the bottom of this post.
The politics of all this is bizarre. Readers may recall that there was a fuss last year about whether GSM phones could be exported to the Middle East; the official line then was that A5 was too good for the likes of Saddam Hussein.
However, a couple of weeks ago, they switched from saying that A5 was too strong to disclose, to saying that it was too weak to disclose! The government line now pleads that discussing it might harm export sales. Maybe all the fuss was just a ploy to get Saddam to buy A5 chips on the black market; but Occam's razor suggests that we are really seeing the results of the usual blundering, infighting and incompetence of bloated government departments. Indeed, my spies inform me that there was a terrific row between the NATO signals agencies in the mid 1980's over whether GSM encryption should be strong or not. The Germans said it should be, as they shared a long border with the Evil Empire; but the other countries didn't feel this way. and the algorithm as now fielded is a French design.
A5 is a stream cipher, and the keystream is the xor of three clock controlled
registers. The clock control of each register is that register's own middle bit, xor'ed with a threshold function of the middle bits of all three registers (ie if
two or more of the middle bits are 1, then invert each of these bits; otherwise just use them as they are). The register lengths are 19, 22 and 23, and all the feedback polynomials are sparse.
Readers will note that there is a trivial 2^40 attack (guess the contents of
registers 1 and 2, work out register 3 from the keystream, and then step on to
check whether the guess was right). 2^40 trial encryptions could take weeks on a workstation, but the low gate count of the algorithm means that a Xilinx chip can easily be programmed to do keysearch, and an A5 cracker might have a few dozen of these running at maybe 2 keys per microsecond each. Of course, if all you want to do is break the Royal Family's keys for sale to News International, then software would do fine.
It is thus clear that A5 should be free of all export controls, just like CDMF and the 40-bit versions of RC2 and RC4.
Indeed, there seems to be an even faster attack. As the clock control is stop-go rather than 1-2, one would expect some kind of correlation attack to be possible, and on June 3rd, Dr Simon Shepherd of Bradford University was due to present an attack on A5 to an IEE colloquium in London. However, his talk was spiked at the last minute by GCHQ, and all we know about his attack is:
(a) that sparse matrix techniques are used to reconstruct the initial state
    (this was published as a `trailer' in the April 93 `Mobile Europe');
(b) that he used some of the tricks from my paper `Solving a class of stream     ciphers' (Cryptologia XIV no 3 [July 90] pp 285 - 288) and from the follow-up     paper `Divide and conquer attacks on certain classes of stream ciphers' by     Ed Dawson and Andy Clark (Cryptologia XVIII no 1 [Jan 94] pp 25 - 40) (he
    mentioned this to me on the phone).
I believe that we have to stand up for academic freedom, and I hope that placing A5 in the public domain will lead to the embargo on Simon's paper being lifted.
Ross Anderson
APPENDIX - AN IMPLEMENTATION OF A5
The documentation we have, which arrived anonymously in two brown envelopes, is incomplete; we do not know the feedback taps of registers 2 and 3, but we do know from the chip's gate count that they have 6 feedback taps between them.
The following implementation of A5 is due to Mike Roe , and
all comments and queries should be sent to him.
 * In writing this program, I've had to guess a few pices of information:
 *
 * 1. Which bits of the key are loaded into which bits of the shift register
 * 2. Which order the frame sequence number is shifted into the SR (MSB
 *    first or LSB first)
 * 3. The position of the feedback taps on R2 and R3 (R1 is known).
 * 4. The position of the clock control taps. These are on the `middle' one,  *    I've assumed to be 9 on R1, 11 on R2, 11 on R3.
 */
 * Look at the `middle' stage of each of the 3 shift registers.
 * Either 0, 1, 2 or 3 of these 3 taps will be set high.
 * If 0 or 1 or one of them are high, return true. This will cause each of the
 * middle taps to be inverted before being used as a clock control. In all
 * cases either 2 or 3 of the clock enable lines will be active. Thus, at least
 * two shift registers change on every clock-tick and the system never becomes
 * stuck.
 */
static int threshold(r1, r2, r3)
unsigned int r1;
unsigned int r2;
unsigned int r3;
int total;
  total = (((r1 >>  9) & 0x1) == 1) +
          (((r2 >> 11) & 0x1) == 1) +
          (((r3 >> 11) & 0x1) == 1);
  if (total > 1)
    return (0);
  else
    return (1);
unsigned long clock_r1(ctl, r1)
int ctl;
unsigned long r1;
unsigned long feedback;
 /*
  * Primitive polynomial x**19 + x**5 + x**2 + x + 1
  */
  ctl ^= ((r1 >> 9) & 0x1);
  if (ctl)
  {
    feedback = (r1 >> 18) ^ (r1 >> 17) ^ (r1 >> 16) ^ (r1 >> 13);
    r1 = (r1 << 1) & 0x7ffff;
    if (feedback & 0x01)
      r1 ^= 0x01;
  }
  return (r1);
unsigned long clock_r2(ctl, r2)
int ctl;
unsigned long r2;
unsigned long feedback;
 /*
  * Primitive polynomial x**22 + x**9 + x**5 + x + 1
  */     ctl ^= ((r2 >> 11) & 0x1);
  if (ctl)
  {
    feedback = (r2 >> 21) ^ (r2 >> 20) ^ (r2 >> 16) ^ (r2 >> 12);
    r2 = (r2 << 1) & 0x3fffff;
    if (feedback & 0x01)
      r2 ^= 0x01;
  }
  return (r2);
unsigned long clock_r3(ctl, r3)
int ctl;
unsigned long r3;
unsigned long feedback;
 /*
  * Primitive polynomial x**23 + x**5 + x**4 + x + 1
  */
  ctl ^= ((r3 >> 11) & 0x1);
  if (ctl)
  {
    feedback = (r3 >> 22) ^ (r3 >> 21) ^ (r3 >> 18) ^ (r3 >> 17);
    r3 = (r3 << 1) & 0x7fffff;
    if (feedback & 0x01)
      r3 ^= 0x01;
  }
  return (r3);
int keystream(key, frame, alice, bob)
unsigned char *key;   /* 64 bit session key              */
unsigned long frame;  /* 22 bit frame sequence number    */
unsigned char *alice; /* 114 bit Alice to Bob key stream */
unsigned char *bob;   /* 114 bit Bob to Alice key stream */
unsigned long r1;   /* 19 bit shift register */
unsigned long r2;   /* 22 bit shift register */
unsigned long r3;   /* 23 bit shift register */
int i;              /* counter for loops     */
int clock_ctl;      /* xored with clock enable on each shift register */
unsigned char *ptr; /* current position in keystream */
unsigned char byte; /* byte of keystream being assembled */
unsigned int bits;  /* number of bits of keystream in byte */
unsigned int bit;   /* bit output from keystream generator */
  /* Initialise shift registers from session key */
  r1 = (key[0] | (key[1] << 8) | (key[2] << 16) ) & 0x7ffff;
  r2 = ((key[2] >> 3) | (key[3] << 5) | (key[4] << 13) | (key[5] << 21)) & 0x3fffff;
  r3 = ((key[5] >> 1) | (key[6] << 7) | (key[7] << 15) ) & 0x7fffff;
  /* Merge frame sequence number into shift register state, by xor'ing it
   * into the feedback path
   */
  for (i=0;i<22;i++)
  {
    clock_ctl = threshold(r1, r2, r2);
    r1 = clock_r1(clock_ctl, r1);
    r2 = clock_r2(clock_ctl, r2);
    r3 = clock_r3(clock_ctl, r3);
    if (frame & 1)
    {
      r1 ^= 1;
      r2 ^= 1;
      r3 ^= 1;
    }
    frame = frame >> 1;
  }
  /* Run shift registers for 100 clock ticks to allow frame number to
   * be diffused into all the bits of the shift registers
   */
  for (i=0;i<100;i++)
  {
    clock_ctl = threshold(r1, r2, r2);
    r1 = clock_r1(clock_ctl, r1);
    r2 = clock_r2(clock_ctl, r2);
    r3 = clock_r3(clock_ctl, r3);
  }
  /* Produce 114 bits of Alice->Bob key stream */
  ptr = alice;
  bits = 0;
  byte = 0;
  for (i=0;i<114;i++)
  {
    clock_ctl = threshold(r1, r2, r2);
    r1 = clock_r1(clock_ctl, r1);
    r2 = clock_r2(clock_ctl, r2);
    r3 = clock_r3(clock_ctl, r3);
    bit = ((r1 >> 18) ^ (r2 >> 21) ^ (r3 >> 22)) & 0x01;
    byte = (byte << 1) | bit;
    bits++;
    if (bits == 8)
    {
      *ptr = byte;
      ptr++;
      bits = 0;
      byte = 0;
    }
  }
  if (bits)
    *ptr = byte;
  /* Run shift registers for another 100 bits to hide relationship between
   * Alice->Bob key stream and Bob->Alice key stream.
   */
  for (i=0;i<100;i++)
  {
    clock_ctl = threshold(r1, r2, r2);
    r1 = clock_r1(clock_ctl, r1);
    r2 = clock_r2(clock_ctl, r2);
    r3 = clock_r3(clock_ctl, r3);
  }
  /* Produce 114 bits of Bob->Alice key stream */
  ptr = bob;
  bits = 0;
  byte = 0;
  for (i=0;i<114;i++)
  {
    clock_ctl = threshold(r1, r2, r2);
    r1 = clock_r1(clock_ctl, r1);
    r2 = clock_r2(clock_ctl, r2);
    r3 = clock_r3(clock_ctl, r3);
    bit = ((r1 >> 18) ^ (r2 >> 21) ^ (r3 >> 22)) & 0x01;
    byte = (byte << 1) | bit;
    bits++;
    if (bits == 8)
    {
      *ptr = byte;
      ptr++;
      bits = 0;
      byte = 0;
    }
  }
  if (bits)
    *ptr = byte;
  return (0);
End of post...

@_date: 1994-07-12 17:14:31
@_author: Ian Farquhar 
@_subject: Re: NSA technology transfer (fwd) 
There is a similar information brochure for the DSD, available at most
career advisory services in Australian Universities.
The DSD brochure is interestingly sanitized too.  The surprise was
their acknowledgement that they own a Cray, although the pictured model
is an X-MP (which I know has been subsequently decommissioned, cut in half,
and now graces the CRI foyer in Melbourne and, it is rumored, the DSD
foyer in their HQ at Russell, ACT).  DSD have a more recent model now.
Amusingly, it was not up until recently that they were admitting that they
HAD a Cray, and the current model is still confidential.
The picture also shows some fairly hackerish looking people pointing
logic probes into circuitry, and viewing the output of programs on what
look like 3270 terminals!  On closer inspection, these boards appear to
be domestic modems (Dataplex models, by the look of them).  There is one
fairly interesting looking board, which appears to be covered in ceramic-
packaged custom chips, but it looks circa 1975 or so and ancient.
I went through the document as closely, but could not get much out of it.
The sanitisation was quite competent, which is no surprise for that
Does this include left-wing political interests?!

@_date: 1994-07-12 17:33:45
@_author: Ian Farquhar 
@_subject: Re: Validating IDEA 
There is some sample data included in the appendix to the IDEA
description (chapter 3 or someone's thesis) which is floating around
the network.  This sample data should allow at least a partial
validation of your cipher implementation, and arbitrary amounts of
it can furthermore be generated by using the sample C implementation
contained in the same appendix.
This document is widely available, but until the end of the week I have
stored it in:
I do not know how much longer it will remain after Friday, as I will be
leaving my position here on that day and moving accounts.

@_date: 1994-07-14 15:43:31
@_author: Ian Farquhar 
@_subject: Re: Idle question... 
An interesting question.  Presumably the companies are obliged to use
internal security procedures on the masks.  Let's face it: Motorola
manufactures a lot of other chips which contain sensitive implementation
details anyway, so they should be able to insure that the masks stay
relatively private.
You might also like to consider this.  I would expect an average chip
which implements the GSM protocols to contain 100K-500K transistors,
probably as a CMOS gate array with some standard cells.  The A5 cipher could
conservatively implemented in about 500 transistors.  Assuming that
Motorola maintains reasonable control and security over the masks on the
fab line, it is going to be extremely difficult for anyone to recover
the cipher's algorithm.  Besides, have you ever tried to figure out an
algorithm from a gate array?!  Insanity lies down that path. :)
A much more viable technique would be to decap it and use electron
microscopy to recover the algorithm.  Obviously this possibility
was factored into the design of A5.
The technology used to implement this is ViaLink (Ref: Computer Design,
Jan 93, pp. 28-30).  It's an antifuse (ie. OC till blown) technology,
which buries an amorphous silicon fuse between two layers of metal.
The cell which forms part of this fuse is known as a VROM cell.
A blown VROM cell is inspectionally identical to an unblown cell (it
is conjectured.)  It is not visually inspectable certainly, and the
blown fuse has the same X-ray diffractive index as an unblown cell.
There are reportedly also procedures used to defeat EM analysis of the
running chip.
The s-boxes would certainly be implemented in VROM cells, and it is
also quite conceivable that these fuse cells are also used as crossbar
connects across busses (thus even hiding the information flow from
module to module).  One suggestion has even been that the implementations
may include unused modules to confuse any inspection, which would be an
amusing diversion.
Anyway, as Matt said, the chip is programmed in the SCIF, during which
time the two keys and unit serial number are also established (in VROM).
Originally this technology was claimed to require a $40 million/6 year
reverse engineering effort.  Recently that seems to have fallen to
$1 million/1 year.  Matt's followup to the post he refers to does cast some doubt over the technique's ability to resist destructive reverse engineering (in which the chip is not expected to survive).
It is certainly conceivable, for example, that if an attacker was to expose the lower-layer conductors, physical connections into and out of the VROM cells could determine their state and reconstruct the algorithm.
BTW, this is my current list of known facts and rumors about SKIPJACK
(_not_ Clipper, just the algorithm).  Has anyone got anything to add?
* 64 bit "electronic codebook" block cipher, 80 bit key. (Disclosed)
* Can use all four FIPS-81 modes of operation. (Disclosed)
* 32 rounds.  All rounds non-linear. (Disclosed)
* Not suceptible to differential cryptanalysis. (Claimed in the Interim report)
* Classified "Secret". (Disclosed)
* Part of a NSA suite of "Type 1" algorithms.  Such algorithms are suitable
  "for protecting all levels of classied data."  SKIPJACK, however, is only
  certified for unclassified/sensitive data. (Disclosed)
* Design commenced in 1987, based on algorithms circa 1980 or so. (Disclosed)
* No correlation observable between the output and input/key bits. (Claimed)
* No known weak keys found. (Claimed in interim report)
* SKIPJACK does not feature DES's complementation property. (Interim report)
* SKIPJACK incorporates design features found in algorithms which are
  used to protect classified information. (Interim Report)
* Contains 16 S-boxes (rumor attributed to Dorothy Denning.  Unverified.)
Anyone got anything else to add?

@_date: 1994-07-20 20:58:35
@_author: Ian Farquhar 
@_subject: Re: Clipper Chip retreat 
There are three of ways they could proceed from here.  The first is
to declassify SKIPJACK, which would (IMO anyway) be another welcome
boost for civilian crypto, in that it would be the chance to see
and analyse a NSA-designed cryptosystem.  For that very reason,
I doubt that they will do it.  (Small aside from another field: it will be _very_ interesting to compare the old SHA to the revised version.  One of
the reasons I suspect that the problem is quite significant is simply
because they have decided to revise it and run the risk of invoking
comparitive research which may disclose design techniques or methods
of attack.  If the later option is the lesser of two evils, I would
guess that it is a nasty hole indeed.)
The second would be to take an existing commercial cipher, and to
sanctify that as their recommended algorithm.  Again, assuming that
they selected a properly secure algorithm, the very features of the
algorithm they chose would be another point of interest.  This is
the least favorable option.
Their final option would be to release another cipher, but with a
reduced keysize or key entropy.  Not the best solution, but one
which I have a nasty suspicion will happen.
