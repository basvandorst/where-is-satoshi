
@_date: 1994-10-06 12:26:55
@_author: TCL || !TCL 
@_subject: Stallman & Ousterhout && (TCL || !TCL) && practicing cypherpunks 
Below is the post from Rich Stallman "Why you should not use Tcl",
and the reply from Ousterhout, which is basically: Why you should
not listen to Stallman, in this case.
The mentions in the [fantastic] Cyphernomicon of TCL are probably due
to my crypto-prototyping project.  I did not take the choice lightly
when I chose TCL as my "glue" in this project.
Two issues that may be interesting but had *little to do* with
my decision are (1) language support for big numbers and
(2) the TK toolkit (which happens to be in TCL).
The reason I chose TCL is that it is designed to work above, underneath, and alongside of C code.  TCL has two published
interfaces:  one is the language and standard commands, and one
is a C API for use in combining the language with other C packages.
I think of TCL as more of a subroutine library than a language: in the same way that (say) C++ string, file, and dictionary classes can help you be more productive in writing C++ programs,  a
"little language" interpreter can make you more productive in
many kinds of programs.  Crypto prototyping systems is one of them.
I am not new to LISP or PERL or AWK or POSTSCRIPT or FORTH or SHELL or
BASIC or HYPERTALK or various other interpreted langauges.  For many
differnt projects I would leave TCL for one of them.  However when TCL
came along, I recognized it as being just the language I had wanted to
write myself for doing projects like my current one.
Which may say more about what kind of a computer scientist I am
that about what lanaguage is best for you in your situation.  I'll add that I have a version of my crypto toolkit that is a PERL
interpreter, and I've looked briefly at embedding it in PYTHON as
well.  My problem now is that I need a chunk of time to port it all and
package it on sun4 (currently it's on sun3).  My problem is not yet
that I need more languages to port to.  But i'll be glad to have some
people help embed these things in all the popular interpreted languages
soon.  It would be particularly nice to have some people versant with
Macs and PCs to package crypto components on those machines -- in
applescript or hypercard or visual basic or whatever would help people
write crypt code.
Below I repost the original articles by Stallman (the spiritual leader of GNU) and Ousterhout (the author of TCL).    I'll also point out my greatest respect for both of them, and for
their respective projects.   They've both made my job as a practicing cypherpunk much easier.
Talk about prototyping environments, but please don't spam the list on
religious issues.   PERL and PYTHON and SCHEME are all pretty good
little languages.
[ thanks to iansmith and boyz for bringing these articles to my attention. ]

@_date: 1994-10-06 13:30:58
@_author: strick@yak.net 
@_subject: Stallman & Ousterhout && (TCL || !TCL) && practicing cypherpunks 
[ this is a repost of an attempt to send this yesterday --strick ]
-----BEGIN PGP SIGNED MESSAGE-----
Below is the post from Rich Stallman "Why you should not use Tcl",
and the reply from Ousterhout, which is basically: Why you should
not listen to Stallman, in this case.
The mentions in the [fantastic] Cyphernomicon of TCL are probably due
to my crypto-prototyping project.  I did not take the choice lightly
when I chose TCL as my "glue" in this project.
Two issues that may be interesting but had *little to do* with
my decision are (1) language support for big numbers and
(2) the TK toolkit (which happens to be in TCL).
The reason I chose TCL is that it is designed to work above, underneath, and alongside of C code.  TCL has two published
interfaces:  one is the language and standard commands, and one
is a C API for use in combining the language with other C packages.
I think of TCL as more of a subroutine library than a language: in the same way that (say) C++ string, file, and dictionary classes can help you be more productive in writing C++ programs,  a
"little language" interpreter can make you more productive in
many kinds of programs.  Crypto prototyping systems is one of them.
I am not new to LISP or PERL or AWK or POSTSCRIPT or FORTH or SHELL or
BASIC or HYPERTALK or various other interpreted langauges.  For many
differnt projects I would leave TCL for one of them.  However when TCL
came along, I recognized it as being just the language I had wanted to
write myself for doing projects like my current one.
Which may say more about what kind of a computer scientist I am
that about what lanaguage is best for you in your situation.  I'll add that I have a version of my crypto toolkit that is a PERL
interpreter, and I've looked briefly at embedding it in PYTHON as
well.  My problem now is that I need a chunk of time to port it all and
package it on sun4 (currently it's on sun3).  My problem is not yet
that I need more languages to port to.  But i'll be glad to have some
people help embed these things in all the popular interpreted languages
soon.  It would be particularly nice to have some people versant with
Macs and PCs to package crypto components on those machines -- in
applescript or hypercard or visual basic or whatever would help people
write crypt code.
Below I repost the original articles by Stallman (the spiritual leader of GNU) and Ousterhout (the author of TCL).    I'll also point out my greatest respect for both of them, and for
their respective projects.   They've both made my job as a practicing cypherpunk much easier.
Talk about prototyping environments, but please don't spam the list on
religious issues.   PERL and PYTHON and SCHEME are all pretty good
little languages.
[ thanks to iansmith and boyz for bringing these articles to my attention. ]

@_date: 1995-02-05 02:03:31
@_author: strick@The Yak 
@_subject: The SKRONK protocols (version 0.6) 
The SKRONK protocols                                         version 0.6
                                                        Henry Strickland                                                         Sun Feb  5  1995
                          This is a working document, subject to change.                                                    Please comment on it!
Skronk is a user-level C library that re-implements the usual "posix
i/o" (unix man 2) functions and "berkeley socket" functions with a set
of functions that can use enhanced or alternate ("skronked") protocols
for TCP connections.  (Typical enhancements could be authentication
and/or encryption of the connection.)  A simple negotiation protocol
allows the clients and servers to agree on what enhancements are
desired or required.
Skronk is designed so that your common unix network clients and servers
(telnet, sendmail, ftp, nntp, X11, etc.) can be merely relinked with the
skronk library (libskronk.a) without changing the source code for the
As a matter of configuration and policy, skronked clients and servers
may choose either to interoperate with normal (non-skronked) client and
servers or to forbid normal connections.  In order to not interfere
with non-skronked programs, skronked connections take place an
alternate TCP server port numbers.
 *   massively saxaphonish kind of music, e.g. John Zorn   */
---- THE UDP PROTOCOL BEGINS HERE ----
THE SKRONK MAP DAEMON
A skronk map daemon is a UDP service that tells what skronked services are
available from a site, and what alternate TCP server port numbers they
The skronk map daemon receives "skronk map request" packets and returns
"skronk map reply" packets that list pairs of port numbers, mapping
normal server port numbers to corresponding skronked port numbers.  The
skronk map reply packet is sent to the same IP address and host port
that the request was received from.
If there is no map reply in a certain time, after a couple of map request resends, the skronk map client should assume that skronked services are not currently available on that host.
SKRONK MAP REQUEST PACKET
See "struct skronk_map_request" below.  The comment will say
something like "finger skronk for info", to explain what
is going on to network administrators who see these packets for
the first time probing their hosts.
SKRONK MAP REPLY PACKET
See "struct skronk_map_reply" below.  The "serial" field should
match the serial field of the map request packet.  Replies be cached,
using the "ttl" time-to-live field for a timeout.
If the request packet cannot be replied to (perhaps because the action
was not understood, or the version was wrong), a reply with action
SKRONK_MAP_NACK should be returned.  If the magic field of the request
is wrong, do not reply.  (The magic number should be changed if the
first five fields are changed; otherwise, version and opcode may be
changed to implement new protocols.)
Skronk map clients should also recognize as a reply the relevant ICMP packets indicating that there is no skronk map daemon.
Version numbers 128 through 255 will not be assigned and are
available for experimentation.  Action codes 128 through 255 will
not be assigned and are available for experimentation.
Initial prototypes use UDP port 333 for the skronk map service,
until a number is officially allocated.
END $Header: /x/nepal/x/yak/strick/work/skronk-write/RCS/skronk.proto,v 1.3 95/02/05 01:18:49 strick Exp Locker: strick $

@_date: 1995-02-05 17:06:28
@_author: strick@The Yak 
@_subject: "encrypt tcp connections" hacks 
Perry, could you enumerate them?  I take your opinions more
seriously than perhaps I should, so I want to understand
what you're saying.
I'm not doing this to re-invent the wheel.  I'm doing it because
I need it, and nothing else is working very well for me.
I'm doing it because I don't see anything that's easy-to-use in wide
use today.  I don't just want one or two encrypted applications -- like
the Kerberos telnet and rcp -- but something to transparently provide
privacy for all TCP sockets -- like SMTP sockets between (re)mailers,
NNTP, X11, FTP, MUDs, etc.
Let me name the ones I can think of.
  1.  	Matt Blaze just announced one.  As always, he has the best
  2.	Kerberos4.  I use Kerberos4 between home and work all the time.
  3.	Kerberos5.  I've been unable to build Kerberos5 on my   4.	The new telnet program with Telnet Options for authentication
  5.	Standards for IPng.  Vapor, as far as I know.  Is there any
I think it comes down to the fact that, of these, only Skronk and Blaze's software use a Diffee-Hellman -like Key Exchange so that
administration stuff doesn't have to be done by humans and footnet.
The real value I'm adding is not the crypto.  It's the packaging.
When I'm done it should be possible to skronk all your current clients and servers by just overriding the shared library libc.so,
running a skronk map UDP daemon, and customizing a configuration
file to tell the daemon what to say.
As for the UDP service:
UDP packets are for automatic configuration of skronk maps.  Skronk maps could be announced other ways too -- including via
manual configuration, where you put skronk maps in your SKRONK_CONF
environment variable.
I may have to spend more effort on this than I wanted to.   I have
a SKRONK_CONF variable, and an option to say "dont ask the UDP skronk map daemon" about this port, just skronk it -- but right now it's only dependant on port number, not on the IP address too.
This can be fixed.
You need to be root to install it properly on your system, for the
skronked services to become bona fide system services.  Users should
not be able to hijack SMTP and TELNET connections to a site unless
they're root.
For people who run their own web server on a nonstandard port on a machine that someone else administers -- we're back to the manual
configuration method.  Maybe we can build a PGP service with signed certificates to collect nonstandard skronked services.  But really I think these services will be marginal.
I had thought about using DNS TXT records.  But I decided against that
because a *lot* of people have autonomy over their workstation on
the net, but not over their DNS records.   Linux boxen in dorm rooms
come to mind.  Or anyone who puts a new machine on someone else's
ethernet, grabbing an IP address via ARP.
================= Thanks to everyone for your comments.
The discussion question is -- if we have so many hacks already -- howcome they're not in use.  I hope I found the reasons and addressed
them.  The firewalls issue bugs me a bit.  Would using a well-known
TCP port instead of the UDP port fix the problem?  I don't think so.  Firewalls will block my new TCP port as well.  Matt Ghio's
project to tunnel through the telnet port sounds good.  Of course,
that defeats the purpose of the firewall, which is not my aim.
My aim is to work with the internet and within its policies, so it
can get widespread use.
How much of skronk works today?  I'm nearing alpha of a version that's
hardwired to do DH exchange (using RSAREF2.0) and IDEA CBF (stolen from
PGP sources) for the symmetric encryption.  But I broke it recently
when I added hacks for servers to fake select() listening on both
skronked and normal ports, when the program only thinks it's only
listening on normal ports.
I gotta go ...     strick
p.s.	need some wizard-level help here.
