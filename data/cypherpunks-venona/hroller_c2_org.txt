
@_date: 1995-08-30 18:47:02
@_author: hroller Mixmaster 
@_subject: Mixmaster Security Issues 
Apart from thwarting traffic analysis attacks, how does the security
of a Mixmaster Type II remailer packet compare to that of a
PGP-chained Type I message?
For example, is each remailer in the path limited to knowing only
the next remailer in the path?  Is there any way for a remailer
(except for the first and last in the chain) to know how many hops
have already occurred or how many remain?  Is there a session key
chosen via an RNG?  If so, how random is the RNG?  Is it seeded from
a pseudo-random source that's at least as secure as measuring
keystroke latencies, as PGP does?
Lance Cottrell's original "remailer essay" which proposed the Type
II concept envisioned, if I'm not mistaken, the use of PGP
technology to do the actual encryptions.  Now it seems that another,
seemingly proprietary, implementation of RSAREF was used, instead.
What was the reason for this change?
Would any security be lost if Type I and II technology were combined
and a PGP-chained Type I packet were initially sent via Mixmaster?
This would would seem to provide the necessary protection against
traffic analysis while bypassing any *POSSIBLE* hidden weaknesses in
Mixmaster.  IOW, if the outer Mixmaster "envelope" were "steamed
open", perhasps based on some hidden weakness in Mixmaster, the
inner, nested PGP envelope(s) would remain intact.
BTW, what volume of message traffic is the Mixmaster network of
remailers currently handling?  Is much cover traffic necessary to
minimize delays while providing enough reordering to thwart traffic
analysis?  (IOW, so a remailer with a reordering pool size of five
messages, and averaging one REAL message a day, wouldn't have to
keep a message for an average of five days before sending it on its
next hop, as a worst-case scenario).
Is my math correct in surmising that chaining a message through five
remailers, each with a reordering pool of five messages, could mean
that the message eventually leaves the chain as one of 5^5 (3125)
possible messages?  (My math is a bit weak, so please feel free to
correct my methodology, if necessary.)  If so, does that work in
reverse?  Could a given output message that finally surfaced in the
clear be narrowed down to one of 3125 Mixmaster input messages
through traffic analysis?  Or would the fact that the attacker
didn't know the exact number of hops utilized significantly increase
the odds against identifying the sender?  What effect, if any, would
increasing the number of available remailers have on traffic

@_date: 1995-09-14 09:12:58
@_author: Hroller Anonymous Remailer 
@_subject: No Subject 
conversion and is not responsible for any bugs in it.
   This a 'C' conversion of the reference Turbo Pascal implementation
Examples of Encryption with SAFER SK-64 (i.e., with the strengthened key
schedule of 64 bits.)
PLAINTEXT is        1   2   3   4   5   6   7   8
The KEY is          0   0   0   0   0   0   0   1
after round 1     131 177  53  27 130 249 141 121
after round 2      68  73  32 102 134  54 206  57
after round 3     248 213 217  11  23  68   0 243
after round 4     194  62 109  79  24  18  13  84
after round 5     153 156 246 172  40  72 173  39
after round 6     154 242  34   6  61  35 216  28
CRYPTOGRAM is      21  27 255   2 173  17 191  45
PLAINTEXT is        1   2   3   4   5   6   7   8
The KEY is          1   2   3   4   5   6   7   8
after round 1     223  98 177 100  46 234  13 210
after round 2     182 246 230  93 158  14  48  89
after round 3      45 234 128 149  40 101  10 134
after round 4      30  17 249 236 158 120  69 100
after round 5       1 200 182 241   0 127 152 162
after round 6     144  85  94 214   5  38  65 150
CRYPTOGRAM is      95 206 155 162   5 132  56 199
 unsigned char a1,a2,a3,a4,a5,a6,a7,a8,
              b1,b2,b3,b4,b5,b6,b7,b8,
              r;
unsigned char k[21][8],k1[9];
int logtab[256],exptab[256],i,j,n;
unsigned char p1,p2,*q1,*q2;
  *q2=p1+p2;
  *q1=*q2+p1;
unsigned char p1,p2,*q1,*q2;
  *q1=p1-p2;
  *q2=-*q1+p2;
   element 45 of the finite field GF(257) and stores these numbers
   in the table "exptab".  The corresponding logarithms to the base
   45 are stored in the table "logtab" */
  logtab[1]=0;
  exptab[0]=1;
  for(i=1;i<=255;i++)
  {
    exptab[i]=(45*exptab[i-1]) % 257;
    logtab[exptab[i]]=i;
  }
  exptab[128]=0;
  logtab[0]=128;
  exptab[0]=1;
  int rounds;
  do
  {
    printf("Enter number of rounds (max 10): ");
    scanf("%d",&rounds);
  } while(rounds<1 || rounds>10);
  r=(unsigned char)rounds;
  int i1,i2,i3,i4,i5,i6,i7,i8;
  printf("Enter plaintext as 8 bytes (0-255 separated by spaces)\n");
  scanf("%d%d%d%d%d%d%d%d",&i1,&i2,&i3,&i4,&i5,&i6,&i7,&i8);
  a1=(unsigned char)i1;
  a2=(unsigned char)i2;
  a3=(unsigned char)i3;
  a4=(unsigned char)i4;
  a5=(unsigned char)i5;
  a6=(unsigned char)i6;
  a7=(unsigned char)i7;
  a8=(unsigned char)i8;
  int i1,i2,i3,i4,i5,i6,i7,i8;
  printf("Enter key as 8 bytes (0-255 separated by spaces)\n");
  scanf("%d%d%d%d%d%d%d%d",&i1,&i2,&i3,&i4,&i5,&i6,&i7,&i8);
  k[0][0]=k1[0]=(unsigned char)i1;
  k[0][1]=k1[1]=(unsigned char)i2;
  k[0][2]=k1[2]=(unsigned char)i3;
  k[0][3]=k1[3]=(unsigned char)i4;
  k[0][4]=k1[4]=(unsigned char)i5;
  k[0][5]=k1[5]=(unsigned char)i6;
  k[0][6]=k1[6]=(unsigned char)i7;
  k[0][7]=k1[7]=(unsigned char)i8;
  k1[8]=k1[0]^k1[1]^k1[2]^k1[3]^k1[4]^k1[5]^k1[6]^k1[7];
  for(n=2;n<=(2*r)+1;n++)
  {
  /* each byte of the key k1 is left rotated by 3 */
    for(j=0;j<=8;j++)
      k1[j]=(k1[j]<<3) + (k1[j]>>5);
  /* the key bias is added here to the right rotated k1 */
    for(j=1;j<=8;j++)
      k[n-1][j-1]=k1[(j+n-2) % 9]+exptab[exptab[(9*n)+j]];
  }
  for(i=1;i<=r;i++)
  {
  /* Key 2i-1 is mixed bit and byte added  to the round input */
    a1=a1 ^ k[2*i-2][0];
    a2=a2 + k[2*i-2][1];
    a3=a3 + k[2*i-2][2];
    a4=a4 ^ k[2*i-2][3];
    a5=a5 ^ k[2*i-2][4];
    a6=a6 + k[2*i-2][5];
    a7=a7 + k[2*i-2][6];
    a8=a8 ^ k[2*i-2][7];
  /* The result now passes through the nonlinear layer */
    b1=exptab[a1];
    b2=logtab[a2];
    b3=logtab[a3];
    b4=exptab[a4];
    b5=exptab[a5];
    b6=logtab[a6];
    b7=logtab[a7];
    b8=exptab[a8];
  /* Key 2i is now mixed byte and bit added to the result */
    b1=b1 + k[2*i-1][0];
    b2=b2 ^ k[2*i-1][1];
    b3=b3 ^ k[2*i-1][2];
    b4=b4 + k[2*i-1][3];
    b5=b5 + k[2*i-1][4];
    b6=b6 ^ k[2*i-1][5];
    b7=b7 ^ k[2*i-1][6];
    b8=b8 + k[2*i-1][7];
  /* The result now enters the linear layer */
    mat1(b1,b2,&a1,&a2);
    mat1(b3,b4,&a3,&a4);
    mat1(b5,b6,&a5,&a6);
    mat1(b7,b8,&a7,&a8);
    mat1(a1,a3,&b1,&b2);
    mat1(a5,a7,&b3,&b4);
    mat1(a2,a4,&b5,&b6);
    mat1(a6,a8,&b7,&b8);
    mat1(b1,b3,&a1,&a2);
    mat1(b5,b7,&a3,&a4);
    mat1(b2,b4,&a5,&a6);
    mat1(b6,b8,&a7,&a8);
  /* The round is now completed! */
    printf("after round %d   %3d %3d %3d %3d %3d %3d %3d %3d\n",
  }
  a1=a1 ^ k[2*r][0];
  a2=a2 + k[2*r][1];
  a3=a3 + k[2*r][2];
  a4=a4 ^ k[2*r][3];
  a5=a5 ^ k[2*r][4];
  a6=a6 + k[2*r][5];
  a7=a7 + k[2*r][6];
  a8=a8 ^ k[2*r][7];
  init_tables();
  for(;;)
  {
    set_rounds();
    get_plaintext();
    get_key();
    printf("PLAINTEXT is    %3d %3d %3d %3d %3d %3d %3d %3d\n",
    printf("THE KEY IS      %3d %3d %3d %3d %3d %3d %3d %3d\n",
    key_schedule();
    encrypt();
    printf("CRYPTOGRAM IS   %3d %3d %3d %3d %3d %3d %3d %3d\n\n",
  }

@_date: 1995-09-14 09:19:58
@_author: Hroller Anonymous Remailer 
@_subject: No Subject 
conversion and is not responsible for any bugs in it.
   This a 'C' conversion of the reference Turbo Pascal implementation
Examples of Encryption with SAFER SK-128 (i.e., with the strengthened key schedule of 128 bits.)
PLAINTEXT is        1   2   3   4   5   6   7   8
KEY Ka is           0   0   0   0   0   0   0   1
KEY Kb is           0   0   0   0   0   0   0   1
after round 1     131 177  53  27 130 249 141 121
after round 2      68  73  32 102 134  54 206  57
after round 3     248 213 217  11  23  68   0 243
after round 4     194  62 109  79  24  18  13  84
after round 5     153 156 246 172  40  72 173  39
after round 6     154 242  34   6  61  35 216  28
after round 7     100  31 172  67  44  75 133 219
after round 8      78 226 239 135 210  83  93  72
after round 9      72  64  46 195 163 159 243 114
after round10       3 133  76 190 191  52 220 123
CRYPTOGRAM is      65  76  84  90 182 153  74 247
PLAINTEXT is        1   2   3   4   5   6   7   8
KEY Ka is           1   2   3   4   5   6   7   8
KEY Kb is           0   0   0   0   0   0   0   0
after round 1      64 214  74 216 103 222  26  54
after round 2      61  14  68  15  46 111 124  80
after round 3     197 124  96  59 255  24   2  30
after round 4      63  59 214 103 236 166 153  24
after round 5      66 254  26  45 152 223   5 122
after round 6      89  47  58 105 161  38 135  45
after round 7      19 202 174  44  57 206  52  25
after round 8      78 179 113 208 169  26 121  22
after round 9      53  17  81 215 120  37 206 246
after round10     189 177   9   0 186  82 208 253
CRYPTOGRAM is     255 120  17 228 179 167  46 113
PLAINTEXT is        1   2   3   4   5   6   7   8
KEY Ka is           0   0   0   0   0   0   0   0
KEY Kb is           1   2   3   4   5   6   7   8
after round 1      95 186 209 220 166  66 213  10
after round 2     200  65 189 120  96 135  42 166
after round 3      64 169  43 166 132 171  31  40
after round 4     199 167  76 189 145 158 241  19
after round 5      71  55 184 212 108 198  77 108
after round 6     173 197 139  11  17  48  97  59
after round 7      17  51 142   4 170   7 207 124
after round 8      62 205 253 225 167 179 228 202
after round 9     133 168 127 138 193 243  34 226
after round10      59 194  69 220 220 231 123 148
CRYPTOGRAM is      73 201 157 152 165 188  89   8
 unsigned char a1,a2,a3,a4,a5,a6,a7,a8,
              b1,b2,b3,b4,b5,b6,b7,b8,
              r;
unsigned char k[25][8],ka[9],kb[9];
int logtab[256],exptab[256],i,j,n;
unsigned char p1,p2,*q1,*q2;
  *q2=p1+p2;
  *q1=*q2+p1;
unsigned char p1,p2,*q1,*q2;
  *q1=p1-p2;
  *q2=-*q1+p2;
   element 45 of the finite field GF(257) and stores these numbers
   in the table "exptab".  The corresponding logarithms to the base
   45 are stored in the table "logtab" */
  logtab[1]=0;
  exptab[0]=1;
  for(i=1;i<=255;i++)
  {
    exptab[i]=(45*exptab[i-1]) % 257;
    logtab[exptab[i]]=i;
  }
  exptab[128]=0;
  logtab[0]=128;
  exptab[0]=1;
  int rounds;
  do
  {
    printf("Enter number of rounds (max 12): ");
    scanf("%d",&rounds);
  } while(rounds<1 || rounds>12);
  r=(unsigned char)rounds;
  int i1,i2,i3,i4,i5,i6,i7,i8;
  printf("Enter plaintext as 8 bytes (0-255 separated by spaces)\n");
  scanf("%d%d%d%d%d%d%d%d",&i1,&i2,&i3,&i4,&i5,&i6,&i7,&i8);
  a1=(unsigned char)i1;
  a2=(unsigned char)i2;
  a3=(unsigned char)i3;
  a4=(unsigned char)i4;
  a5=(unsigned char)i5;
  a6=(unsigned char)i6;
  a7=(unsigned char)i7;
  a8=(unsigned char)i8;
  int i1,i2,i3,i4,i5,i6,i7,i8;
  printf("Enter left half of key as 8 bytes (0-255 separated by spaces)\n");
  scanf("%d%d%d%d%d%d%d%d",&i1,&i2,&i3,&i4,&i5,&i6,&i7,&i8);
  ka[0]=(unsigned char)i1;
  ka[1]=(unsigned char)i2;
  ka[2]=(unsigned char)i3;
  ka[3]=(unsigned char)i4;
  ka[4]=(unsigned char)i5;
  ka[5]=(unsigned char)i6;
  ka[6]=(unsigned char)i7;
  ka[7]=(unsigned char)i8;
  printf("Enter right half of key as 8 bytes (0-255 separated by spaces)\n");
  scanf("%d%d%d%d%d%d%d%d",&i1,&i2,&i3,&i4,&i5,&i6,&i7,&i8);
  kb[0]=(unsigned char)i1;
  kb[1]=(unsigned char)i2;
  kb[2]=(unsigned char)i3;
  kb[3]=(unsigned char)i4;
  kb[4]=(unsigned char)i5;
  kb[5]=(unsigned char)i6;
  kb[6]=(unsigned char)i7;
  kb[7]=(unsigned char)i8;
  ka[8]=ka[0]^ka[1]^ka[2]^ka[3]^ka[4]^ka[5]^ka[6]^ka[7];
  kb[8]=kb[0]^kb[1]^kb[2]^kb[3]^kb[4]^kb[5]^kb[6]^kb[7];
  for(j=0;j<8;j++)
    k[0][j]=kb[j];
  for(j=0;j<9;j++)
    ka[j]=(ka[j]>>3) + (ka[j]<<5);
  for(i=1;i<=r;i++)
  {
  /* each byte of the keys ka and kb is left rotated by 6 */
    for(j=0;j<=8;j++)
    {
      ka[j]=(ka[j]<<6) + (ka[j]>>2);
      kb[j]=(kb[j]<<6) + (kb[j]>>2);
    }
  /* the key bias is added to give keys k2i-1 and k2i */
    for(j=1;j<=8;j++)
    {
      k[2*i-1][j-1]=ka[(j+2*i-2) % 9]+exptab[exptab[18*i+j]];
      k[2*i][j-1]=kb[(j+2*i-1) % 9]+exptab[exptab[18*i+9+j]];
    }
  }
  for(i=1;i<=r;i++)
  {
  /* Key 2i-1 is mixed bit and byte added  to the round input */
    a1=a1 ^ k[2*i-2][0];
    a2=a2 + k[2*i-2][1];
    a3=a3 + k[2*i-2][2];
    a4=a4 ^ k[2*i-2][3];
    a5=a5 ^ k[2*i-2][4];
    a6=a6 + k[2*i-2][5];
    a7=a7 + k[2*i-2][6];
    a8=a8 ^ k[2*i-2][7];
  /* The result now passes through the nonlinear layer */
    b1=exptab[a1];
    b2=logtab[a2];
    b3=logtab[a3];
    b4=exptab[a4];
    b5=exptab[a5];
    b6=logtab[a6];
    b7=logtab[a7];
    b8=exptab[a8];
  /* Key 2i is now mixed byte and bit added to the result */
    b1=b1 + k[2*i-1][0];
    b2=b2 ^ k[2*i-1][1];
    b3=b3 ^ k[2*i-1][2];
    b4=b4 + k[2*i-1][3];
    b5=b5 + k[2*i-1][4];
    b6=b6 ^ k[2*i-1][5];
    b7=b7 ^ k[2*i-1][6];
    b8=b8 + k[2*i-1][7];
  /* The result now enters the linear layer */
    mat1(b1,b2,&a1,&a2);
    mat1(b3,b4,&a3,&a4);
    mat1(b5,b6,&a5,&a6);
    mat1(b7,b8,&a7,&a8);
    mat1(a1,a3,&b1,&b2);
    mat1(a5,a7,&b3,&b4);
    mat1(a2,a4,&b5,&b6);
    mat1(a6,a8,&b7,&b8);
    mat1(b1,b3,&a1,&a2);
    mat1(b5,b7,&a3,&a4);
    mat1(b2,b4,&a5,&a6);
    mat1(b6,b8,&a7,&a8);
  /* The round is now completed! */
    printf("after round %d   %3d %3d %3d %3d %3d %3d %3d %3d\n",
  }
  a1=a1 ^ k[2*r][0];
  a2=a2 + k[2*r][1];
  a3=a3 + k[2*r][2];
  a4=a4 ^ k[2*r][3];
  a5=a5 ^ k[2*r][4];
  a6=a6 + k[2*r][5];
  a7=a7 + k[2*r][6];
  a8=a8 ^ k[2*r][7];
  init_tables();
  for(;;)
  {
    set_rounds();
    get_plaintext();
    get_key();
    printf("PLAINTEXT is    %3d %3d %3d %3d %3d %3d %3d %3d\n",
    printf("KEY Ka IS       %3d %3d %3d %3d %3d %3d %3d %3d\n",
    printf("KEY Kb IS       %3d %3d %3d %3d %3d %3d %3d %3d\n",
    key_schedule();
    encrypt();
    printf("CRYPTOGRAM IS   %3d %3d %3d %3d %3d %3d %3d %3d\n\n",
  }

@_date: 1995-09-16 09:53:30
@_author: hroller Mixmaster 
@_subject: Arnold Bowker and John Joslin vs. Privacy 
"Case Could End Anonymity of Computer Network Users"
               by Brian Bergstein (Associated Press)
Anonymity and freedom of speech in cyberspace are being challenged
by a Caribbean resort owner in a court case that could dramatically
restrict the rights of computer network users.
The resort owner and scuba instructor claim that they were defamed
on a computer bulletin board by an anonymous user, and they asked a
judge this week to force America Online to reveal the name of the
subscriber so they can sue the person for libel.
If Arnold Bowker and John Joslin are successful in obtaining the
name, it could have serious implications for millions of people who
use the Internet to think, write and debate in a world where they
are identified by their ideas, not their names.
Technology experts fear a morass of court cases that would hold
computer users accountable for what they say anonymously.
"What this case brings up is the specter of millions of libel suits
every time there's a disagreement on the Internet," said Daniel
Weitzner of the Center for Democracy and Technology in Washington.
"I think it's a critical issue."
Several calls seeking comment from officials at America Online were
not immediately returned Friday.
Abraham Haddad, chairman of the computer science department at
Northwestern University, said the anonymity of cyberspace should be
maintained as long as it was not being used to commit a crime.
"There's really a need to protect people's privacy as long as no
laws have been broken," Haddad said.

@_date: 1995-09-25 00:11:09
@_author: Hroller Anonymous Remailer 
@_subject: No Subject 
<Anyway, the mainstream media trashing of the Net continues.
And the trashing will continue.  It is the classic scenario.
Feed the media negative press clips about the entity you wish
to discredit (here, the Net), e.g.:
1.  All those pedophiles out to lure your children;
2.  Big coverage on catching some of those pedophiles;
3.  First page coverage on breaking Netscape's code with the
    headlines that your sensitive information such as your
    credit card numbers, etc. can be retrieved (ignoring that
    the reason was to show Netscape's poorly structered code
    would allow this and, therefore, preventing it before it
    could happen);
4.  Expect cryptology to crop up in the Oklahoma bombing trial.
    There already has been articles of those involved having
    allegedly used that *damned* Net to correspond.
Now, the stage is set.  The general public will demand that the
Net (the bastion of perverts and radicals) be controlled,
monitored, and censored - all as a result of a carefully
planned methodology of those specific powers that be.  Having
the general public believe that their children and the national
security are being threatened makes it a much easier task for
*them* to attain their goals.  After all, who wants to be
bothered with proposed legislation when you can have Jane and
John Doe yelling for what may have taken *them* a while to attain by "normal" routes?
Never underestimate....

@_date: 1995-11-21 04:45:06
@_author: Hroller Anonymous Remailer 
@_subject: No Subject 
The other anonymous poster was referring to Detweiler's
belief that cryptoanarchy was a budding Nazism as one
of his apparent motivations. After a little bit of amateur Detweiler study I can agree with this. His page at  has sections that
emphasize his concern about cryptoanarchy as a kind of
"neo-nazism". Thankfully the cryptoanarchist sentiments
on this list are much different than nazism in the way
it advocates complete disengagement from the political
process, something that tended to make the Nazist agenda
highly dangerous. Without that you just have a bunch of
subversive guerillas. Like gnats, irritating but irrelevant.
So as long as we stick with the non-political advocation,
and stay disorganized, and don't ever amount to anything
significant as far as visible political clout, I think
Detweiler is generally going to continue to leave us alone,
thank God.

@_date: 1995-11-30 13:17:05
@_author: Hroller Anonymous Remailer 
@_subject: Your faith is PGP is charming and quaint, but wrong 
All of these articles from people claiming to be me!
I repeat, for the slow learners, that I consider PGP to be untrustworthy, at least on my machines. I don't want those Mounties to do to me what they did to Mulroney en passant. You in the southern colony are free to use PGP, but I prefer other means of establishing my uniqueness. Style, for example, cannot be easily copied.
I am, as always,   Alice de 'nonymous ...
                                    ...just another one of those...
  P.S.  This post is in the public domain.
                    I.  A.  M.  A.  M.  O.  R.  O.  N.

@_date: 1995-12-06 14:58:26
@_author: Hroller Anonymous Remailer 
@_subject: [NOISE] Re: PGP 
** Vast numbers of double spaces deleted **
He means that this is NOT alt.security.pgp - we are not here to teach you how to use a bloody C compiler or to summarise README notes for you. You want help, but supply minimal information.
Post your problem to the appropriate place - alt.security.pgp, and supply
a bit of information - what version of the source are you trying to compile, what Unix platform, what version of the C compiler, etc.

@_date: 1996-01-27 17:16:13
@_author: Hroller Anonymous Remailer 
@_subject: No Subject 
It's not often we see an active and overt defense of ignorance.  Good work, Vladimir!  But to really avoid being contaminated by evil knowledge, I recommend the following 12-step program:
1.  Admit that you are powerless to get a clue. Print out this message for reference.
2.  Unsubscribe from Cypherpunks, and all other sources of information that might be relevant.
3.  Unsubscribe from all sources of information that probably aren't relevant, to avoid hostile agents forcing you into unwitting coercion.
4.  Read William S. Burroughs books until you begin to see your neighbors as giant cockroaches and slugs.
4a. In the event that you already see them this way, read Burroughs until they look like something else.
5.  Join as many religions as possible, so that you have incompatible memes busily protecting you from facts.
12. Seal your head in a plastic bag until you suffocate.
This will protect you from such problems in the future.
Hope this helps!
A Friend

@_date: 1996-01-31 14:33:26
@_author: Hroller Anonymous Remailer 
@_subject: No Subject 
Farce Virtual has discovered that some persons using the
Internet are not using the names they were born with. We
made this discovery in the wake of criticism of our
discovery of keyboard sniffing programs, a major discovery
we were able to get several reporters to write about.
We consider our latest discovery to signal the imminent
death of Usenet as we know it.
We are taking the unusual step of announcing our discovery
to the world, and in a simultaneous series of articles in
major newspapers, to alert the world to our discovery.
Farce Virtual provides the only reliable solution to this
problem. We do not use in encryption, because many of our
customers say it is too hard to understand. Instead, we
rely on the oldest method in the book: fear, uncertainty,
and doubt. We have invented a new term for this: FUD.
``Using the FUD Factor line of products, our customers are
protected from those who are not using the names that God
gave them,'' said Nathaniel Boringsternlight, Farce
Virtual's chief publicist.
Asked about women on the Net who are using their married
names, Mr. Boringsternlight added, ``It was to deal with
married women that I invented Safe-Tickle.'' No further
explanation of this comment was offered.
There's simply no other way to keep your sanity safe on the
net. The program we have demonstrated completely undermines
the sanity of all known users of the Internet.
Nathaniel Boringsternlight Chief Publicist, Farce Virtual Holdings
FAQ & PGP key: nsb+faq

@_date: 1996-02-01 10:06:05
@_author: Hroller Anonymous Remailer 
@_subject: No Subject 
Anyone interested in visiting a good virus site should point their browsers to:
Quite a good site, really.  It hasn't been "Netscape Enhanced" yet, so there
are no frames and tables and inline A/V, but it gets the job done.  They
offer a *lot* of virus source code (almost all of it in x86 assembler) and
many related resources.  Some highlights of the home page are included below.
I would recommend the use of something like WebWhacker, which automagically
downloads the contents of a web site to your local system and edits the html
files to work correctly from your local web browser.  It will allow you to
replicate the site quickly and easily, instead of clicking on each of the
more than 2500 links one at a time.
Hope this helps.  If you're interested, better get there quickly.  (Of
course, it's been up for six months now, so it's likely already withstood a
substantial amount of negative response.  It may be there to stay.)
---- 8< ----
        Welcome to the VIRUS Source Homepage!
        This page contains several virus code generators, a few mutation
engines, over 500 virus source files and over 2,100 executable virus files.
This material is being submitted for educational purposes only. Play at you
own risk. But have fun!         The purpose of this page is not to inflame, but to educate,
stimulate and confront you with alternative information on the sensitive
issue of virus creation and propagation. The only way in which to know the
whole of a subject, is by gaining knowledge from every variety of opinion on
the subject, and studying all modes in which it can be looked at. Inform
yourself by analyzing and studying the source code of actual viruses, read
the virus writing & assembly language tutorials. Then consider and examine
every variety of opinion on the subject; the anti-virus folks, mainstream
society, and most importantly ideas and opinions that are considered
radical, reactionary, minority or stigmatized by some other uncomplimentary
label.         No wise person ever acquired wisdom in any other way...         A special note to those of you who would like to see an end to this
page: If all humankind minus one were of one opinion, and only one person
were of the contrary opinion, humankind would be no more justified in
silencing that one person than it, if it had the power, would be justified
in silencing humankind... What's New?
        Last updated on 12/26/95.
Message Board
Code Generators
        The 2nd Generation in Virus Creation (46k)         Virus Creation Lab (164k) Password: Chiba City         Mass-Produced Code Generator (45k)         Instant Virus Production Kit (39k)         Trojan Horse Construction Kit (18k)         German Virus Construction Kit (12k) Mutation Engines
        Mutation Engine (13k)         Mutation Engine Tests (18k)         Polymorphic Engine (8k)         Visible Mutation Engine (20k) Source Code
        [A-Z]
Executable Files
        [A-Z]
Debug Scripts
        Over 33 debug script files (184k)         Debug.com based interrupt stripper (3k)         V-86 based interrupt stripper (13k)         VSUMX507.ZIP (96k) - database of viruses. Assembly Language (resources)
Virus Writing Tutorials
---- 8< ----
