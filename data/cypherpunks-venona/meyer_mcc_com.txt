
@_date: 1993-04-15 11:47:50
@_author: Peter Meyer 
@_subject: Decryption 
Date: Wed, 14 Apr 1993 17:28 CDT
    From: trump (Louis Edward Trumpbour)
    ok well i am sure that there are a lot of people out there that want to learn     how to do basic cypher/decyphering... so i think it would be nice if people     gave their knowledge on how to do decryption... even if its very very basic
    and perhaps a faq could be made out of this info...
    Clovis
sci.crypt has recently put out a FAQ (at last).  I forget where it's
ftp-able from but there's always someone on sci.crypt asking where the
FAQ is, and it gets reposted from time to time.
There are lots of ways to encrypt/decrypt/cryptanalyze.  The sci.crypt
FAQ lists some books on the subject.  Would-be cryptanalysts could take
a look at Abraham Sinkov's "Elementary Cryptanalysis, A Mathematical
Approach", published by The Mathematical Association of America, 1966.

@_date: 1993-04-16 19:16:21
@_author: Peter Meyer 
@_subject: The New Mykotronix phones... 
Date: Fri, 16 Apr 1993 14:54 CDT
    From: pcw (Peter Wayner)
    Okay, let's suppose that the NSA/NIST/Mykotronix Registered
    Key system becomes standard and I'm able to buy such a system
    from my local radio shack. Every phone comes with a built in
    chip and the government has the key to every phone call.     I go and buy a phone and dutifully register the key.     What's to prevent me from swapping phones with a friend or     buying a used phone at a garage sale? Whooa. The secret registered
    keys just became unsynchronized. When the government comes     to listen in, they only receive gobbledly-gook because the     secret key registered under my name isn't the right one. Knowing nothing except what I've read on the net today, I suppose that
while scrambling the phone conversation the chip inserts in the data
stream some ID (perhaps once per second) to tell the govt. which chip is
doing the scrambling.  This would allow multiple trapdoor keys (as
claimed) and also there would be no need for phone users to register.
The chip might also insert the number of the phone originating and/or
receiving the call, though presumably the wiretappers would already know

@_date: 1993-04-16 19:42:56
@_author: Peter Meyer 
@_subject: White House Encryption idea 
Date: Fri, 16 Apr 1993 15:13 CDT
    From: treason
    Well, this all sounds fine and dandy, but...
    1)  They are not passing out the algorithym, and I dont trust ANYONE to tell
    me its secure.  ...
    4) No explanation of what the 'key' contents are composed of (numbers, letters,
    alphanum, characters, some odd cyphercode???) is even implied.
    5)  No explanation of how the key is propegated or if it will even be needed
    for the remote site is mentioned.  How are the remote sites going to
    decypher your cyphersounds(text)?
    There was no mention of further releases in information...is this all we get?
    treason Question (5) is particularly acute.  Offhand I can think of two ways the
remote site might decrypt the message:
1.  If the two phones can talk to each other then the originator phone
might ask the receiver phone for its public key (as in public key
cryptography) and then use this to encrypt the message.  (The receiver
phone then decrypts with its private key.)  But since the encryption is
occurring in real time, this is probably not feasible unless short keys
are used.
2.  The originator phone might simply send the encryption key down the
line, perhaps itself encrypted or disguised in some way.  If so then it
might not be too hard to discover the key.  In this case all security
lies in ignorance of the encryption algorithm used (violating crypto-
logical principles).  It probably wouldn't be too long (at most a year
or so) before someone figures out what the algorithm is, in which case
all security is compromised.  However, security in particular cases is
relative to the expertise of the attacker, so it might still be the case
that one's neighbors and business competitors could not decrypt the
message, even if XYZ Security Consultants could.

@_date: 1993-04-16 20:20:59
@_author: Peter Meyer 
@_subject: New versions of encryption software released 
I suppose I could use a fig leaf to cover the price of this software so
that this posting might seem less "commercial", but - what the hell -
this isn't sci.crypt and we're not concerned with maintaining academic
purity.  This encryption software is available *now*.  You might
consider shelling out a few bucks (which allows you to make use of the
result of a few years' work) before the govt. makes it illegal to buy,
sell or use encryption software.
                   New Version Release Announcement
             Dolphin Software releases three new versions
                    of MS-DOS encryption software
Dolphin Software's data encryption software has been released in two
new versions, Dolphin Encrypt (V. 2.11) and Dolphin Encrypt Advanced
Version (V. 2.10).  The encryption routines are also available as a
C function library.
Both Dolphin Encrypt and the Advanced Version use a symmetric key
encryption process to encrypt data on MS-DOS computers, and can
encrypt multiple files with a single command.  File pathnames are
supported and there is extensive error checking.  If you wish to
transmit encrypted data as email then Dolphin Encrypt can be told to
output the encrypted data as text.  There is no limit on the size,
the type or the number of files.  Files are normally compressed during
encryption.  Screen output can be sent to a file or to a printer for a
record of operations.  The encryption process, described in detail in
the documentation, relies partly on the RSA Data Security, Inc., MD5
Message Digest Algorithm.
The Advanced Version has all of the features described above, and also
encrypts whole floppy disks.  All common disk sizes are supported and
are automatically recognized.  Additional command line options are
supported, including the options of echoing or not echoing the
encryption key during entry.  There is a decrypt-and-display-only
option (with no plaintext written to disk).  The Advanced Version can
be run silently from another application program to encrypt or decrypt
files.  It has a script language (with if-else-endif) which allows
automation of frequently-performed, complex or conditional operations.
The Advanced Version comes with utility programs to read multiple text
files, compare files, purge files and wipe a disk clean of data; these
can be called from scripts.
The Dolphin Encryption Library is a C function library containing
functions for encrypting and decrypting blocks of data in memory
(from 1 byte to about 10K in size).  Complete source code is included.
Dolphin Encrypt is priced at $64.00 and the Advanced Version at $128.00.
The function library is available for licensing to developers.  For more
information contact Dolphin Software at 4815 W. Braker Ln.  Austin,
TX 78759 (phone 512-479-9208).

@_date: 1993-04-22 13:47:20
@_author: Peter Meyer 
@_subject: Re: New Algorithm... 
Date: Thu, 22 Apr 1993 15:07 CDT
    From: pmetzger ("Perry E. Metzger")
    "Haywood J. Blowme" says:
    [Lots about some J. Random Companies encryption chip]
    All fine and well, but since we have IDEA already, why should we want
    it? For virtually all applicatons these days other than fully
    encrypting network traffic, software is fine. DES implementations in
    software can handle 1.5 Mbit/s on reasonable machines. Beyond that, if
    we need hardware, why not use one of the currently publically known
    algorithms like DES or IDEA, or a combination of them? Why use some
    other companies algorithm?
    Perry
Even when using encryption software there may be reasons to use
something other than DES.  One possible reason (apart from doubts about
whether NSA can break DES in one or more of its modes) is that, although
the security and speed of an encryption algorithm is of central
importance, the quality of the user-interface is also important.
For example, if you want to encrypt/decrypt thirty files in five
different subdirectories twice a day, and do it in an office with your
colleagues looking over your shoulder, you won't want to be using
software that encrypts only one file at a time and also displays the
encryption key as you type it in (though you might like to have the key
echoed when no-one else is about).
There are lots of other things to be considered besides the algorithm
itself when designing good encryption software, e.g. if someone
accidentally yanks out the power cord to the computer during decryption
do you kiss goodbye to the data?

@_date: 1993-04-28 14:25:07
@_author: Peter Meyer 
@_subject: Program to measure entropy 
Cypherpunks write code, so here's some (at the end, anyway).
Someone asked awhile back (just before the deluge of postings on the
Wiretap Chip swamped my announcement of the release of new versions of
our Dolphin Encrypt encryption software) about (something like) how to
tell whether a file consists of something like English text or just
(apparent) garbage.  Here's one way, a program to calculate the entropy
(and the relative entropy) of the set of bytes in a file.
First the documentation (extracted from Appendix III in the manual for
the Dolphin Encryption Library):
Information theorists have attempted to formalize and to quantify the
notion of randomness, also called entropy.  The usual definition of
entropy in a string of letters from some alphabet is due to Claude
Shannon (who formulated this concept in the 1950s).  Let S be a string
of letters from some alphabet A = { a(0), a(1), ..., a(k-1) } of k
letters, and let p(i) be the probability (that is, the relative
frequency) of occurrence of a(i) in the string S, then the entropy E of
the string S may be defined as:
                           k-1
                  E  =  - Sigma  ( p(i) * ln ( p(i) ) )
                          i = 0
where ln is the natural logarithm.  It can be shown that this value is
maximized when all letters occur in S with equal frequency (in this
case E = ln(k)), and is minimized when one letter occurs all the time
(in this case E = 0).
Since E ranges between 0 and ln(k), we may obtain a modified entropy
value E', which we call relative entropy, which ranges between 0 and 1
by dividing E by ln(k) thus:  E' = E / ln(k).
The program ENTROPY1.EXE calculates the relative entropy of the bytes
in a given file.  For a DOS text file consisting of English text the
relative entropy value is typically in the range 0.48 - .68.  The
relative entropy values for most non-random files, including .OBJ,
.COM and .EXE files, usually fall in the range 0.50 through 0.95.
Files consisting of bytes generated by pseudo-random-number generators
typically have relative entropy values in the range 0.970 - 0.999.
Thus a file with a relative entropy value of at least .98 looks (at
least according to this test) very much like a file consisting of
random bytes.  ENTROPY.EXE can thus be used to test whether a file
appears to consist of random bytes or something like natural language.
The ENTROPY1.EXE program takes two parameters on the command line, a
file specification (wildcard characters are not allowed in this
version) and (optionally) a byte space size, e.g. ENTROPY1 FILE.TXT 150.
The program produces results such as:
           File           Size        Entropy   Rel. entropy    Diff. bytes
     HAMLET.TXT           1459       3.037405       0.547756             42
       PTRS.TXT           3683       3.415741       0.615984            108
     CHAP04.TXT          51162       3.339292       0.602198            100
      FILE1.RND           1762       5.473655       0.987102            255
      FILE2.RND           3400       5.503647       0.992511            256
      FILE3.RND          29225       5.541324       0.999305            256
     HAMLET.ENC           1762       5.478605       0.987995            256
       PTRS.ENC           3400       5.501231       0.992075            256
     CHAP04.ENC          29225       5.540785       0.999208            256
       NULLFILE          20000       0.000000       0.000000              1
The file called NULLFILE consists of 20,000 null (zero) bytes, and has a
relative entropy value of zero (as do all files which contain only a
single byte value).  Note that the relative entropy values for the .ENC
files (encrypted using Dolphin Encrypt) are about .99, as are those for
the .RND files (created by using a pseudo-random-number generator
similar to Microsoft's rand() function) of the same size.
The last column gives the number of different bytes found in the file.
This may be less than the size of the byte space for the file.  If the
size of the byte space is less than 256, as is the case with text
files, then the space size parameter may be included in the command
line, as in  ENTROPY1 HAMLET.TXT 108.  In this case the program
produces results such as:
           File           Size        Entropy   Rel. entropy    Diff.bytes       HAMLET.TXT           1459       3.037405       0.648723             42
       PTRS.TXT           3683       3.415741       0.729527            108
     CHAP04.TXT          51162       3.339292       0.713199            100
Thus decreasing the value for the byte space increases the entropy
measure.  Relative entropy tends to be larger for larger files.
Now the C source code:
 *  Written by Peter Meyer, last revised 1993-04-27.
 *  Calculates the relative entropy of the bytes in a file
 *  defined as the negative of the sum for each byte of the product of
 *  the relative probability of that byte times the natural log
 *  of that byte, divided by the natural log of the number of
 *  different bytes occurring in the file; values can range from 0 to 1.
 */
           /*  Microsoft header files  */
   unsigned long n[256];
double p[256];
unsigned char *usage =
    "\nUse: ENTROPY1 filespec [space_size]"
    "\nspace_size = number of possible bytes (default = 256)\n";
void measure_entropy(unsigned char *filename, unsigned long *total,
    double *entropy, double *relative_entropy, unsigned int*num_diff_bytes,
    unsigned int *space_size, int *err_flag);
void main(int argc, char *argv[])
int err_flag;
unsigned int num_diff_bytes, space_size;
unsigned long total;
double entropy, relative_entropy;
if ( argc == 1 )
    {
    printf(usage);
    exit(0);
    }
if ( argc == 2 )
    space_size = 256;
    {
    space_size = (unsigned int)atoi(argv[2]);
    if ( space_size == 0 || space_size > 256 )
        {
        printf("\nInvalid space size.\n");
        exit(1);
        }
    }
    &space_size,&err_flag);
switch ( err_flag )
    {
    case 0:     /*  no error  */
        printf("Space size = %u\n",space_size);
        printf("\n%15s%15s%15s%15s%15s",
            "File","Size","Entropy","Rel. entropy","Diff. bytes");
        printf("\n%15s%15lu",argv[1],total);
        printf("%15.6f%15.6f%15d\n",entropy,relative_entropy,num_diff_bytes);
        exit(0);
    case -1:
        printf("\nCannot open file %s.\n",argv[1]);
        exit(2);
    case -2:
        printf("\n%15s is inconsistent with space size %d.\n",
            argv[1],space_size);
        exit(3);
    }
void measure_entropy(unsigned char *filename,
                     unsigned long *total,
                     double *entropy,
                     double *relative_entropy,
                     unsigned int *num_diff_bytes,
                     unsigned int *space_size,
                     int *err_flag)
int j;
FILE *file;
*err_flag = 0;
file = fopen(filename,"rb");
if ( file == NULL )
    {
    *err_flag = -1;
    return;
    }
memset(n,0,256*sizeof(unsigned long));
while ( !feof(file) )
    n[fgetc(file)]++;
*num_diff_bytes = 0;
*total = 0L;
for ( j=0; j<256; j++ )
    {
    *num_diff_bytes += ( n[j] != 0 );
    *total += n[j];
    }
if ( *num_diff_bytes > *space_size )
    {
    *err_flag = -2;
    fclose(file);
    return;
    }
for ( j=0; j<256; j++ )
    p[j] = ((double)n[j])/(*total);
*entropy = 0.0;
for ( j=0; j<256; j++ )
    {
    if ( p[j] )
        *entropy += p[j]*log(p[j]);
    }
*entropy = -1.0*(*entropy);
*relative_entropy = *entropy/log(*space_size);
If anyone wants the MS-DOS executable version of this program then send
me (meyer a snailmail address and I'll send it to you on the
Dolphin Encrypt demonstration disk.
