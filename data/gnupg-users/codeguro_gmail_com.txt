
@_date: 2019-05-31 18:27:17
@_author: Tony Lane 
@_subject: Encryption Algorithm for GnuPG? 
I would say chacha2020 is also a strong cipher up there with AES. The fact that AES uses lookup table with an index derived from the secret makes general implementations vulnerable to cache-timing attacks. ChaCha20 is not vulnerable to such attacks. (AES implemented through AES-NI is also not vulnerable, but I don?t know if GPG?s implementation of it uses that)
It also has the benefit of being made by Daniel J. Bernstein which is the same guy who formulated the Ed25519 curve and fought off the US government in court in declassifying elliptic curve crypto from being a military munition. You can see the rfc for the algorithms here:

@_date: 2019-06-07 18:28:51
@_author: Tony Lane 
@_subject: gnupg installation and verification 
Hash: SHA512
GPG is an implementation of the OpenPGP standard.
It's software that can help you utilize the tools of public key cryptography.
Public key cryptography comes in two flavors: encryption and signatures.
The PGP signatures you saw is a special hash that aids in verifying the authenticity of some data. You do this by trusting the public key of some distributor(s) or persons. The signature scheme then allows you to ensure the authenticity of the contents even if it goes through some insecure medium. You can be sure that if the signature is valid that it has been signed by the private key corresponding to the public key you trusted and that it has not been tampered with. The principle being that some change in the data requires a distinct signature, a signature that can be generated by only the holder of the private key.
Likewise, public key encryption allows you to communicate securely over an insecure medium. As I said before, this is done with public key cryptography, and the key principle here being that the keys for encryption and keys for decryption are distinct. Deriving the one key from the other is very infeasible. The keys used to encrypt the payload are public and can be exchanged freely, hence the name public keys. The keys used to decrypt the payload are kept secure and known only to the person who generated the keypair, hence the name private keys. Using this scheme you can establish a secure channel and communicate securely without meeting up in person and agreeing on a shared secret.  This, paired with signatures, allows you to not only communicate some secret, but also ensure that this secret hasn't been tampered with.
You can read the tutorial for GPG here. For more details, you can see the GPG manual here:

@_date: 2019-05-02 21:32:55
@_author: Tony Lane 
@_subject: safecurve implementations 
I've heard from some old archives...
And am wondering if or when the Curve448 (Ed448-Goldilocks -  will be implemented.
It would be nice to have matching the presumed levels of security of the standard NIST curves P-384 and P-521. From the sources I've
read it seems like this was on the books. I know that TLS has already
implemented it into their standards in 2017. When can we expect GnuPG
to step up?

@_date: 2019-05-05 11:22:56
@_author: Tony Lane 
@_subject: ProtonMail and Anonymity 
Isn't it obvious?
If ProtonMail is forcing you to sign up and use an SMS registered to your cellphone then clearly
it's in their interest to collect cellphone numbers.
They're probably selling this information just like
facebook and so many other data-mining corporations.
After all, they have to fund it somehow.

@_date: 2019-05-08 18:41:13
@_author: Tony Lane 
@_subject: ProtonMail and Anonymity 
Hash: SHA512
Or you could just use qmail+GPG with the -R option.
Or heck, just post it the clearnet on some *chan. Isn't the whole point of GPG to hide the content or who it's intended to?
GPG is perfect for this imo

@_date: 2019-05-09 15:28:36
@_author: Tony Lane 
@_subject: ProtonMail and Anonymity 
Hash: SHA512
Uhh... no.
You can absolutely hide the recipient with the '-R' option in Gnupg.

@_date: 2019-05-24 20:31:26
@_author: Tony Lane 
@_subject: No subject 
Hash: SHA512
"This?" You mean the mailing list? It's for sending out emails to GPG users, usually for asking or answering questions.
Or do you mean GPG itself? For that, use it for encrypting messages or, alternatively, signing it like I'm doing right now.

@_date: 2019-05-26 12:14:09
@_author: Tony Lane 
@_subject: I've been hacked and now I only use a key pair on keybase. 
Hash: SHA512
There's also paperkey: Books can last a long time, you know...

@_date: 2019-05-26 12:38:45
@_author: Tony Lane 
@_subject: I've been hacked and now I only use a key pair on keybase. 
Hash: SHA512
With GPG, of course. You use GPG to communicate securely over an insecure medium.
You do not have to be online to use GPG. It's done entirely on the host machine.
Or are you asking, exactly how to do that?
Paperkey is used to store your information offline, namely on paper.
Particularly, paperkey is used to aid with storing your private keys.
If you're looking to store messages offline, plain old GPG can do that trivially.

@_date: 2019-05-26 13:47:58
@_author: Tony Lane 
@_subject: I've been hacked and now I only use a key pair on keybase. 
Hash: SHA512
You don't communicate with paperkey. You use GPG to communicate.
GPG uses the secret key to sign messages as well as decrypt messages that were encrypted with its corresponding public key.
Paperkey is just a tool to help store that secret key on a paper medium. That's it.
To use it, use the following command: gpg --export-secret-keys | paperkey
You can print the contents out, type them by hand, or whatever.
I think what you're asking is: "How do I sign or decrypt messages without crypto software such as GPG on the compromised computer? I don't want to risk my secrets being exposed!"
To that, my answer is "you can't." If your machine is compromised then your best bet is to keep your secret keys away from that machine entirely. Instead, install GPG on your offline machine and do all of your signing/decryption there.
To sign messages in PGP ascii armored format, you can do:
gpg --clearsign inputfile
gpg --detach-sign --armor inputfile
Similar commands can be used for encryption.
Remember that when encrypting that if you don't include yourself as the recipient, you won't be able to decrypt it.
Here is a good tutorial for GPG and enigmail:

@_date: 2019-05-29 13:55:32
@_author: Tony Lane 
@_subject: Is limit-card-insert-tries a working option? 
Hash: SHA512
When encrypting or signing or decrypting with a specific key, if you have a set of keys (say, a master key and 3 encryption subkeys etc), GPG may try to try each key until it finds a match.
However, you can do something like:
gpg -u !
to tell GPG to use that specific key. Note the exclamation mark. When using gpg an exclamation mark (!) may be appended to force using the specified primary or secondary key and not to try and calculate which primary or secondary key to use.
You can take a peek at the documentation here for more info: There is also a manual here, with more options if it helps:

@_date: 2019-05-29 14:26:14
@_author: Tony Lane 
@_subject: Is limit-card-insert-tries a working option? 
While I'm on it, I'd like to add here that GPG doesn't really use passwords like one may think.
GPG uses public key cryptography - it doesn't use passwords to protect your files; it uses passwords to protect the keys that decrypt or sign the files.
Beneath the covers, GPG actually generates an ephemeral symmetric key used for a cipher such as AES and it's this key that actually encrypts the payload and is also the key that's encrypted by a public key and is attached to the message as the pgp protocol. When encrypting to multiple recipients, multiple encrypted ephemeral keys are attached. The recipient who holds a private key just decrypts their copy of the pad with their key, and then decrypts the payload with that.
The more you know

@_date: 2019-05-30 17:46:55
@_author: Tony Lane 
@_subject: Is limit-card-insert-tries a working option? 
Hash: SHA512
I don't know much about this 'pass' tool so I can't give you much advice for that.
But more importantly, your setup seems a little... odd. If I'm understanding this correctly, you have *multiple* smartcards with (what I presume are your) unique identities on each of them but registered to the same email address? I'm not sure if I understand your exact setup, but if I have it right, I don't think this is optimal.
You should have your cert-only (master key) private key stored away somewhere offline registered to your email address.
Under this cert-key, you'd have at least 2 subkeys signed by it... an encryption subkey and signing subkey. You can have more than one of these and you can specify which one to use with: gpg -u ! for signing or: gpg -e -r ! for encrypting. Note that with encrypting however, you typically use *other* people's key ids to encrypt to. Well, you could add yourself as the recipient so you could decrypt it as well.
And yes, you can use an email address and GPG will be smart enough to pick and choose which key to use. You typically don't explicitly specify key-id! for signing unless you have multiple signing subkeys and need to use a specific one, and likewise don't typically use key-id! for encrypting unless your recipients have multiple encrypting subkeys and they request you to use a specific one (perhaps they have a subkey for work-related stuff and another for at home?).
In any case you should have only one cert key and all of your subkeys stem from that.
If you're getting prompted for a passphrase multiple times for this, I think what may be happening is that a subset of your recipients' public keys are partitioned across the two smart cards. You should just have the public keys all in one card. Public encryption keys can be freely exchanged and shared without risk.

@_date: 2019-11-01 15:42:26
@_author: Tony Lane 
@_subject: How to improve our GUIs (was: We have GOT TO make things simpler) 
Hash: SHA512
That doesn't sound very safe. My interpretation of the
goals of GPG is two server two purposes:
1) To transmit data securely over an insecure medium in
a way such that it can protect itself against some
eavesdropper or man-in-the-middle listening, or...
(2) Provide a means to create digital signatures on data
such that you can be assured that some message was sent
only by someone who possesses the private key who's
public key you've added.
Your proposal doesn't seem to address the MITM attacks.
It doesn't seem deal with signatures either.
It seems only to encrypt things only on receipt. What
does that protect against, exactly? Maybe I'm missing
something here...

@_date: 2019-11-01 15:53:31
@_author: Tony Lane 
@_subject: Is replacing a revoked signature valid? 
Hash: SHA512
The result is correct. When you revoke a signature, your exported signatures
will have the revocation of that key/signature. So it makes no sense to
sign it twice. You are better off instead cleaning your key such that the
the revoked key(s) and any other IDs no longer usable (expired, for instance)
are removed entirely. This will allow you to sign them "afresh" again.
See

@_date: 2019-11-02 11:51:36
@_author: Tony Lane 
@_subject: encrypt file in batch mode 
Hash: SHA512
Assuming you're using gpg 2.2.7 or above...
gpg --batch --yes --passphrase="pw" --pinentry-mode loopback -o zz -esr user at domain.com zz.gpg
This can only be used if only one passphrase is supplied. Obviously, this
is of very questionable security on a multi-user system. Don't use this
option if you can avoid it. Also, unless you add yourself to the list of
recipients, you won't be able to decrypt the file even if you possess
the original unless you hold the private key for user at domain.com

@_date: 2019-11-03 00:46:51
@_author: Tony Lane 
@_subject: How to decrypt a message while preserving the signature? 
Hash: SHA512
The term you're looking for is a detached signature.
You can create a detached signature (or any signature, really) only if
you possess the private key.

@_date: 2019-11-03 01:28:43
@_author: Tony Lane 
@_subject: How to decrypt a message while preserving the signature? 
Hash: SHA512
I do not think there is a way to do this. When both '-s' and '-r' options
are used for some given file, the decryption operation atomically decrypts
and verifies the file. Actually, I don't think it goes through PGP in two
"passes" like you might think. You are probably best off having the signer
encrypt and sign distinctly, like so:
gpg -s <infile | gpg -er gpg at example.com -o outfile.sig.gpg
That way, you can extract the encryption layer to get to the signed file.
I think your request to "extract" the atomic sign-encrypt layer is at odds
with itself. The signed file is intended for the recipient only, so it
only makes sense that it can be decrypted/verified only by the recipient
as well.

@_date: 2019-11-03 01:52:50
@_author: Tony Lane 
@_subject: encrypt file in batch mode 
Hash: SHA512
Are you sure? Try to --edit-key and select that key (not the cert key).
Then passwd, for the empty passphrase. Don't forget to save.
Be careful with that option. The docs say this:
Is there a chance that's what's happening here?

@_date: 2019-11-04 00:15:58
@_author: Tony Lane 
@_subject: How to decrypt a message while preserving the signature? 
Hash: SHA512
The '--unwrap' option alone seems to work for me. Thanks for sharing this.
compression layer
Why is keeping the compression layer a problem? Also what other undocumented options are out there?
Can they be documented somewhere?

@_date: 2019-11-04 18:10:21
@_author: Tony Lane 
@_subject: encrypt file in batch mode 
Hash: SHA512
I must disagree here. GPG is modular, and it's monolithic. A piece of software is modular if it is decomposable into distinct functional units such that each unit addresses a specific concern. This- the gpg-agent seems to do very well.
A piece of software is monolithic if its components (if it has any at all) are tightly coupled--that is, components logically depend on one another to the point where using them in different contexts requires re-implementing the missing ones. The point is, despite the fact that gpg-agent (and tools) is comprised of multiple binaries, the hierarchical logical coupling between them means that it is more accurate to think of them parts of the same program as a unit that just happens to run in separate address spaces. They are not truly independent, composable programs.
I do not think that it was the intent to develop gpg-agent as an interface that could be replaced by some other agent but instead to be run, as you said, as a daemon that provides helper functions in the background. For this reason I think it was a mistake to decouple the gpg-agent from the gpg core in this way, and to say that this agent was made with the unix philosophy in mind. Perhaps it would've been better to write the gpg-agent as a shared library to be called by the core instead. Well, we're probably too far down down the rabbit hole to change that now.
Oh, wait, it's free software. We _can_ change it. And redistribute those changes.
God I love free software. So, any volunteers?

@_date: 2019-10-01 19:55:04
@_author: Tony Lane 
@_subject: We have GOT TO make things simpler 
Hash: SHA512
With all due respect... NO.
It is not wise to impede on the power-users who use GPG due to the availability of the various configurations that brought us here in the first place.
This is not an issue with GnuPG. GnuPG is a back-end utility that front-end applications (like GUIs) interface to. Go to your vendor of choice that interfaces with GPG and complain to them about the complexity their interface. As far as GPG goes, it does exactly what it's supposed to. It's a command-line utility. Its raw interface is not supposed to be exposed to the kind of user you're expecting.
For instance, the following command exports all of your signed public keys in PGP format:
gpg -a --export
...or you can export a specific key by suffixing that last command with the key (or name or email some other identifier) that you want to export. Exporting private keys is done the same way. Exporting the trust database can be done this way as well, albeit with different options.
gpg --send-keys $KEY_IDENTIFIER

@_date: 2019-10-04 00:01:44
@_author: Tony Lane 
@_subject: We have GOT TO make things simpler 
Hash: SHA512
I don't know about the EU, but I can name at least 20 fortune-500 businesses that use GPG, including Facebook (yes, even they use GPG, see for yourself).
And those are just the ones -I- know of. And this isn't even counting government. As far as security goes, you cannot beat GnuPG. You do not have to submit your secret online or to some shady third party.
In fact, there's an entire industry dedicated to the sorts of services GnuPG provides, you might've heard of one - Yubikey.

@_date: 2019-10-04 13:08:14
@_author: Tony Lane 
@_subject: We have GOT TO make things simpler 
Hash: SHA512
_At least_ 20 fortune 500 businesses _that I know of_. Mind you, I'm not even counting governments.
And yes, it is recognized by the US government at the very least. See  and Digital signatures are, in general, legally binding.
If for instance a government official who's known to use PGP signatures signs off on a treasonous act, that signature can be used against him or her in court of law.
But it can also be used for contracts.
e-signature  is a legal concept used to capture a person?s intent to be legally bound by the terms of an agreement or contract.
While a digital signature is  a mathematical algorithm. A cryptographic technology used to make data tamper evident, digitally sign of documents.
Even the "newer" signatures that are the Elliptic Curves are recognized as per FIPS-186-4, see:
and notably

@_date: 2019-10-05 03:34:01
@_author: Tony Lane 
@_subject: We have GOT TO make things simpler 
Most don't even work on software to begin with. What's your point?
Did you really set the bar _that_ low? Forgetting for a moment that Whatsapp is proprietary
and there's no way to actually audit the code... We already know that governments
have been pushing  for ways to decrypt it directly
and that they can in fact read messages via a central authority/server
 when the receiving user of a message is offline. If you consider deliberately breaking E2E encryption by design a "success" then
yes, our views _strongly_ differ on not just what's successful, but also what's acceptable.
But go ahead, please rationalize why "ease-of-use" is more important than actual security
for power-users such as myself and those who absolutely won't compromise on true E2EE.

@_date: 2019-10-05 16:57:44
@_author: Tony Lane 
@_subject: We have GOT TO make things simpler 
Hash: SHA512
Thank you. This was exactly the point that set me off in my first message.
The standalone GnuPG interface was never meant for those kinds of end-users.
It was meant for power-users, system administrators, developers, and other
folk who know their way around the terminal. If we want, say, an elegant
graphical user interface for your average Joe, then that's a discussion to
be had. But it's not an issue with GnuPG, per say. Applications that
interface to GnuPG are responsible for _that_ burden. You don't go complain
to OpenSSL devs when it's difficult to attain a secure connection to
some website unless it's a technical issue with OpenSSL.
No, you complain to Mozilla (or whoever made your browser of choice) or
to Github admins. OpenSSL (or NSS, whatever your tool of choice) is just
a back-end utility that non-tech-folk who don't know what they're doing
should -never- interface to. And it's not because it's a difficult tool
to use (it is), but because it's not intended for them. Dumbing the
interface down, _especially_ if it compromises its security or our level
of control over it, is a recipe for disaster.

@_date: 2019-10-09 00:26:31
@_author: Tony Lane 
@_subject: We have GOT TO make things simpler 
Hash: SHA512
Not quite. Enigmail addon Thunderbird and even GPGMail addon for Apple Mail
encrypt it out of the box if you reply to a recipient who's sent you an an
encrypted email if you already imported their public key. Moreover, the
private key is stored on your local machine so no middleman can read it
without access to your device. AFAIK, protonmail holds your private keys
for you in some server. That doesn't sound very safe to me, and I wouldn't
take that risk. I would argue even Gmail with inline PGP encryption over
Enigmail or GPGMail is more secure than protonmail for this reason alone.
That seems terribly inefficient. Do you intend to maintain accounts on
each of these platforms and take all of the risks of each into account?
You must have a lot more trust than I do, but I digress. I think his whole
point is "We should use e-mail as an insecure transport protocol and do secure end-to-end encryption on an agnostic encryption module such as GPG".
And it makes sense to do things this way if you want to be secure.
And before you point me to how PM stores your private keys (I've read it),
remember that all of that salting and hash/password storage is done using
business logic they developed, which means anytime there's an update,
hidden or announced, you are running a risk of a backdoor being introduced.
Can you even audit that code? At least with GPG I can not just audit but
also substitute the module with any OpenPGP-compliant library. This gives
me a heck of a lot more freedom (and security) than maintaining a
thousand different accounts on a thousand different platforms.

@_date: 2019-10-09 03:06:33
@_author: Tony Lane 
@_subject: Future OpenPGP Support in Thunderbird 
Hash: SHA512
It doesn't do that? Why would they choose to tightly couple TB with OpenPGP? If I have to maintain two key databases, that's a dealbreaker for me.
Welp, looks like I won't be upgrading. Thanks Mozilla.

@_date: 2019-10-17 18:30:02
@_author: Tony Lane 
@_subject: FAQ: seeking consensus 
Hash: SHA512
If you absolutely, positively, _need_ the most bits of security then
RSA4096 shouldn't be your go-to anymore. RSA4096 doesn't actually
provide 4096 bits of security. The _key_ sizes may be 4096 bits, but
you must understand the security comes from the the cardinality of prime numbers, so the actual amount of security is only 131 bits of
security. Compare this to RSA's 3072 bit keys providing 125 bits of
security. Unlike RSA, ECC keys don't scale logarithmically. For ECC,
the fields need to be a prime modulus, but that's about it. As a
result, the key sizes scale linearly with the bits of security by
a factor of 2. So, if you want the most security possible with GPG
_today_ you won't beat curve P-521, which provides ~261 bits of security, and to get an equivalent in RSA your key size would need
to be at least 15360.
But you have to understand, even 128 bits of security is so
incredibly large that even the combined computing power of every
processor we have now won't be enough to crack it. See:
 for just how effort
it'd take.
By the way, 256 bits of security isn't twice the amount of 128 bits.
129 bits is twice the amount of security of 128 bits. Get it?
If you are curious just how much effort it'd take to break a 256 bit
key, I'd argue that it's physically impossible because there simply
isn't enough energy in the universe to break it... see: But I digress. It's not the bits of security that matter anymore.
You have a far bigger chance of being insecure with side-channel
attacks etc, than you are with not enough bits of security. That is
a far bigger security hole... Being on a device that is exposed
to the internet. That's where you'd get cracked. Not the key size
being too small.

@_date: 2019-10-18 19:40:28
@_author: Tony Lane 
@_subject: FAQ: seeking consensus 
Hash: SHA512
Not exactly. Actually, this is precisely why I find public key cryptography so cool. If you do not explicitly add your own address
to the list of recipients, you will not be able to decrypt the message!
This may sound silly, but you may want to write something to someone
that you cannot ever possibly be compelled to decrypt. It will be impossible for you to decrypt, even though you wrote it and encrypted
it and even if you have the file in your possession and even if you
have all your secret keys and you know all of your own passwords
and have them written down. You can smile serenely while they're
beating you with a rubber hose, knowing that you can't endanger the
lives of your sources, nor give up your rights, even if you felt like
that might be entertaining for a change. This is also exactly why
governments find it such threat - the idea we have a way to truly,
securely communicate in a way they cannot prove who sent what
terrifies them. It's also what lead to the US trying to classify
such crypto as a military munition, which was later repealed in court
in Bernstein vs US Department of State. They're trying to bring it
back though (hah, fat chance)!
I didn't realize there were people in this mailing list who didn't
use it. Well, I turned it off here... that better?
