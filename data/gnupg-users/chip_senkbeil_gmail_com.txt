
@_date: 2019-06-04 07:42:47
@_author: Chip Senkbeil 
@_subject: Is limit-card-insert-tries a working option? 
Hey ?ngel, thanks for the reply!
My setup is that I have multiple computers: two work laptops, a personal laptop, a desktop, and a cell phone.
I'd originally used a private key to purely do encryption of my passwords on one of my work laptops, replacing lastpass with the pass utility from passwordstore.org.
The pass tool stores each of your passwords in a separate, encrypted file on your computer, where the recipients are whatever encryption IDs you provide. Originally, this was just the one encryption subkey I had.
When I wanted to use my password manager on other computers, I needed to have an appropriate subkey available. Initially, I was just going to copy around the same subkey, but I had the problem that the password manager utility on my phone would also need the subkey and I didn't want to copy over a private subkey onto my phone directly.
Then I learned that smart cards could store encryption, authentication, and signing keys. I already had one Yubikey at work for one-touch passwords, so figured I'd give that a go.
 highlights the main issue with copying keys in that the stub generated also has the card's ID associated with it and - presently - gnupg doesn't support multiple card IDs or anything like that. So you'd be prompted for a different smart card even if you had a smart card with the same encryption subkey, right? Just want to make sure I understand that issue properly.
I've been using the authentication subkeys just fine for SSH and the signing subkeys also work for signing my git commits, but that's all I've used so far.
I hadn't taken a look at encrypting my email just yet, although it was something on my backlog to do with neomutt eventually. There may be some issues with my approach and mail encryption, as you mentioned earlier.
At this point, each of my computers ONLY has a single stub available with all of the other subkeys listed as offline (pound symbol), yet the gpg utility still selects the latest subkey (rather than the only one available) if I don't including the exclamation mark on the keys when encrypting with recipients. Here's an example now of what `gpg -K` outputs for me, minus a couple of additional subkeys I've generated for other devices.
How would you approach my setup? Thinking about it now, I really should have asked for advice on this mailing list before I got started to see what other people would do! Would love to know what you and others would do to leverage a unique smartcard per device (I've got one per laptop/desktop/phone) for encryption, etc.

@_date: 2019-05-29 09:56:31
@_author: Chip Senkbeil 
@_subject: Is limit-card-insert-tries a working option? 
Hey folks, I'm trying to figure out if
    a) the gpg option --limit-card-insert-tries is currently functioning (I'm assuming it is)
    b) setting --limit-card-insert-tries=1 does what I expect
My current setup is that I have my passwords stored using the pass tool from passwordstore.org. Each password is encrypted as a separate file and the encryption/decryption is handled by one of several of my encryption subkeys.
I've made multiple encryption subkeys from a master key after reading around best practices and other tidbits from other GPG users. My subkeys are each individually stored on a separate Yubikey from Yubico.com.
The encryption and decryption works great. For my multiple devices, I can have different keys inserted and encrypt/decrypt just like I would if the same master key was on each device. This is by using the `pass` tool initialized with each subkey's 0xid with an ! added to the end.
The annoyance comes from the pinentry prompt I'm using with the gpg agent. When needing to refresh the cache, the agent prompts me multiple times to insert my other smart cards before it reaches the smart card that is currently plugged into my device. This happens on both OSX and Fedora using version 2.2.15 of gpg and gpg-agent.
I've read about the --limit-card-insert-tries option and that, if specified as 1, the prompt shouldn't appear to insert the card. To my understanding, it should fail and move on to the next subkey silently. Am I reading the option correctly?
If I am, I currently have `limit-card-insert-tries 1` within my gpg.conf config, but it isn't having any impact. I can confirm that other settings within my gpg.conf are being read and utilized.
I pulled down the latest copy of gpg from git://git.gnupg.org/gnupg.git and tried to follow the path from when the --limit-card-insert-tries is provided, but I'm getting lost with where the setting goes. I'm sure it's used somewhere, but I seem to hit a dead end following the program's usage of the option.
Can anyone give me guidance as to what I'm doing wrong? Did I misunderstand the usage of the option? Is there some alternative I could do instead?
I love the setup I have, but I'm fairly new to gpg and smart cards; so, not sure if I've made some mistake along the way.

@_date: 2019-05-30 11:00:01
@_author: Chip Senkbeil 
@_subject: Is limit-card-insert-tries a working option? 
Thanks for the info, Tony! I'm trying to make sure I understand the exclamation mark setup as well as still figure out the --limit-card-insert-tries.
    gpg2 -e -r keyid1! -r keyid2! -r keyid3! -o content.gpg --quiet --yes --compress-algo=none --no-encrypt-to --batch --use-agent /path/to/content.txt
Where keyid1, keyid2, etc. are in the long form of 0x0123456789ABCDEF
I added the exclamation mark because when I provided multiple subkeys to the tool originally as it appeared that gpg was selecting the first subkey in my list regardless of which smart card I had inserted (each has a different subkey) without the exclamation mark. This seems to follow gpg trying to figure out the appropriate primary or secondary key to use, I think.
If I didn't insert the smart card of the selected key, gpg would fail saying something along the lines of no secret key available.
To get around this, providing the exclamation mark for all subkeys appeared to force gpg to try each in turn. This worked in that gpg would eventually reach the subkey that I had available through the inserted smart card, prompt me through pinentry to enter the password for the smart card, and then encrypt (or decrypt).
I take it there's no way for gpg to know which subkey on a smart card is available and automatically pick it, right? If not, does me using the exclamation marks impact the --limit-card-insert-tries option? I would have thought that I could have used that option to suppress the "insert card" dialog and only have the dialog of an actively-inserted card appear.
Does the --limit-card-insert-tries option do as I've described? I'm still trying to figure out how/if it works because it seems to have no impact on the prompts I receive regarding inserting a smart card.
Also, based on your first link, would me providing a different user ID be an option I should pursue? Would using an exact match on the email address (given all of the subkeys have the same address) be an option? Would gpg be able to figure out the appropriate subkey that is available in that manner?

@_date: 2019-05-31 12:53:06
@_author: Chip Senkbeil 
@_subject: Is limit-card-insert-tries a working option? 
============================== START ==============================
Maybe my setup is like you described? I thought it was a reasonable setup, but being a gpg beginner, I'll take any advice I can get!
I've got a master key that I've used to create subkeys for encryption, signing, and authentication. Here's my current setup below:
I've moved one encryption, signing, and authentication subkey to each of my three smart cards from Yubico. I'd deleted the master key from my laptop after that, but added it back from a backup to create the signing and authentication subkeys. I'll be deleting it again shortly.
Putting that aside for a moment, I dug through the gnupg codebase a little more and I think the functionality for --limit-card-insert-tries was removed in some update. The CLI option is still there, but the logic that was previously specified in cardglue.c is gone (as is that file itself).
It looks like the last commit I can see that had the functionality in master was from tag gnupg-1.4.5 (commit 21de807d1a170d44dabcb34f37ce90504e303b81), located in g10/cardglue.c
    rc = app_select_openpgp (app);
    if (opt.limit_card_insert_tries
        && ++retry_count >= opt.limit_card_insert_tries)
        ;
    else if (rc && !opt.batch)
The cardglue.c file was removed (presumably refactored?) in the next commit 8c219602515ae1dba5bc0da31077852dab61809e, which seems to be a large update labeled, "Moved 1.9 branch to trunk". I'm guessing development happened separately from the master branch and was merged in several versions later.
I'm assuming the logic could be added back in at agent/divert-scd.c in the main loop of the ask_for_card function.
Should I move over the limit-card-insert-tries functionality discussion to gnupg-devel?

@_date: 2019-10-15 09:14:30
@_author: Chip Senkbeil 
@_subject: GPG Agent discarding cache before ttl/max ttl 
Hey folks!
Been using GPG for a couple of months to encrypt, sign, and authenticate and it's been great!
I'm trying to understand the scenarios in which the GPG agent will remove an entry from its cache.
I've got my default and max cache (both cache-ttl and cache-ttl-ssh) set to one day such that I don't need to enter my password upon accessing my mail on a timer, etc.
This works great until my laptop goes to sleep, I close the lid, etc. At that point, it appears to me that the agent tosses out the cache regardless of the length of time. This was not the case when I had GPG configured on a Mac, but when I switched to Fedora 30, I began having this problem.
It's a little frustrating because I frequently enter and exit a dock for work, closing and re-opening my laptop, as I dart between meetings, resulting in me needing to re-enter passwords through pinentry more frequently than I'd desire.
Is there some separate setting for GPG agent to discard its cache earlier than the ttl/max ttl settings? I've checked the GPG agent process and its still the same instance that had been running since I booted the laptop, so I don't believe it's the case where the agent is getting killed and restarted.
For reference, here's my gpg-agent.conf file:
    pinentry-program /usr/local/bin/my-pinentry-gui
    default-cache-ttl 604800
    max-cache-ttl 604800
    default-cache-ttl-ssh 604800
    max-cache-ttl-ssh 604800
    enable-ssh-support
I've got a custom bash script for the pinentry program that selects an appropriate pinentry process based on OS and capabilities (GUI/terminal).
And my gpg.conf file:
    # NOTE: Apparently does nothing with gpg2
    use-agent
    # When outputting certificates, view user IDs distinctly from keys:
    # NOTE: Since 2.0.10, seems to be obsolete as always used, but no harm in
    #       keeping it here
    fixed-list-mode
    # Long keyids are more collision-resistant than short keyids (it's trivial to
    # make a key with any desired short keyid)
    keyid-format 0xlong
    # When multiple digests are supported by all recipients, choose the strongest
    # one:
    personal-digest-preferences SHA512 SHA384 SHA256 SHA224
    # Preferences chosen for new keys should prioritize stronger algorithms:
    default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 BZIP2 ZLIB ZIP Uncompressed
    # You should always know at a glance which User IDs gpg thinks are legitimately
    # bound to the keys in your keyring:
    verify-options show-uid-validity
    list-options show-uid-validity
    # When making an OpenPGP certification, use a stronger digest than the default
    # SHA1:
    cert-digest-algo SHA256
    # Prevent version string from appearing in your signatures/public keys
    no-emit-version
    # Never ask to insert smartcard if it wasn't already inserted to begin with
    # NOTE: Currently broken as the functionality appears to have been removed by
    #       commit 8c219602515ae1dba5bc0da31077852dab61809e when g10/gluecard.c
    #       was removed. From the latest commit, it seems like appropriate logic
    #       could be added back in agent/divert-scd.c in the main loop of
    #       ask_for_card function
    limit-card-insert-tries 1
    expert
~ Chip Senkbeil
