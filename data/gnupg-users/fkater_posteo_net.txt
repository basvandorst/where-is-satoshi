
@_date: 2018-12-11 09:28:47
@_author: Felix A. Kater 
@_subject: Chance to get --with-agent-s2k-calibration=MSEC into stable branch? 
in the master branch there is the commit
from September 2017 for configure.ac that allows to circumvent a
huge performance regression with gnupg v2 keys in some contexts.
This commit is not in stable though.
I am not familiar with the process how commits get selected for
inclusion into the stable branch.  Is there a chance that it will
make it into gnupg stable anytime soon?
 Felix
To recall: This issue applies to contexts like gnupg being called
internally by postgresql where there is no agent, so the security
calibration / delay of 100 MESC is applied to every single
decryption call.  Refer to my original posting and the explanation
by Werner Koch, proposing to reduce MSEC at compile time:

@_date: 2018-09-19 12:45:02
@_author: Felix A. Kater 
@_subject: Performance regression for gnupg v2 keys 
I have older keys and newer keys that behave quite different in the
decryption performance.
Old keys: Generated with gnupg-1.4.x, rsa2048, at 2017-01-10.
New keys: Generated with gnupg-2.2.8, rsa2048, some weeks ago.
I've always been using the defaults for generating the keys (no
--full-gen-key, no --expert).
Test case: Unfortunatelly a bit complicated. It is postgresql's
pg_pub_decrypt() that performs approx. 10x slower when the keys,
generated by gnupg and being passed to postgresql as a binary
string, are generated with gnupg-2.2.8. Postgresql is using gnupg
My questions here:
If the issue is caused by the keys: Do I have the chance to compare
old/new key internals?  I've diff'ed the output of gpg -ivv ... of
both keys and AFAIK only the default digest algo has changed from
SHA1 to SHA256. Not sure here though.
What would be a suitable test case with gpg only, without postgresql.

@_date: 2018-09-20 15:05:15
@_author: Felix A. Kater 
@_subject: Performance regression for gnupg v2 keys 
A little update:
When I change the passphrase of an existing 1.x generated key with
gpg 1.4.x, the key stays ok (fast).
When I change the passphrase of an existing 1.x generated key with
gpg 2.2.8, the key gets somehow updated (slow).
So, besides fast/slow:
What's the difference between default (rsa 2048) keys generated with
1.x and 2.x?

@_date: 2018-09-21 10:14:07
@_author: Felix A. Kater 
@_subject: Performance regression for gnupg v2 keys 
Oh, I see...
So, the trigger for this delay is then inherent to the re-encrypted
key itself, not primarily dependent on the agent or gnupg library
configuration, correct?
I am asking this detail because
- I need to move the keys to another machine, into a postgresql
  database where gnupg seems to be part of postgresql itself
  (pgcrypto) and cannot be hand-configured easily, and
- I'd like to know if I have to re-create all existing (slow) keys
  after applying --with-agent-s2k-calibration=MSEC to gnupg (on the
  machine where the keys are generated).
Please confirm.
Indeed: We do many decryptions, let me explain in short:
It is postgresql that receives passphrase protected gpg keys
(pgcrypto). Otherwise it couldn't execute SQL queries on encrypted
data. So, I am forced to move the whole decryption work to
postgresql instead of dealing with decryption after the query using
(a clean version of) gnupg. I don't know about postgresql's
internals but it doesn't seem to even run an agent... And just as an
example: A query using gnupg 1.x keys that completes within 3 sec
takes 40 sec with 2.x keys.
This sounds like a suitable solution.  I've seen that option here
[1] but it is missing in official gnupg.  What do you recommend?
[1]

@_date: 2018-09-27 17:03:27
@_author: Felix A. Kater 
@_subject: Performance regression for gnupg v2 keys 
I permit myself to sum up the open questions:
That option doesn't seem to be present in gnupg configure.ac...?
With the above build-time setting applied, do all previously
generated (slow) keys have to be recreated or is this delay gone
with a newly compiled agent/gnupg library?
