
@_date: 2006-08-10 14:49:07
@_author: Vinod Jacob 
@_subject: encrypt/sign 2048 bit RSA key using another Rsa 2048 bit Key 
I am using libgcrypt 2048 bit encryption.
what is the maximum size of the buffer that i can encrypt using 2048
bit key.is it 2048 bit ?
 I am getting incorrect values when i try to encrypt a buffer of size(
more that 2048 bit ). Encryption/decryption function is success .But
when i tried to print the decrypted buffer , it is showing different
values. so what i needs to do if ,1 want to encrypt buffer of large
size ? (i know we can encrypt large buffer using AES and encrypt AEs
keys using RSA ).But my requirement is to encrypt large buffer using
RSA .
Let me try to explain what i am trying to do in more detail,
  I have to encrypt/sign Rsa ( 2048 bit) keys using another Rsa  2048 bit Key
say Entity A there is one Rsa Keys A_pub_key & A_sec_key
and say Entity b there is one Rsa keys B_pub_key & B_sec_key
 i want to encrypt A_sec_key using B_pub_key is it possible ? how i
have to do encrypt a RSA key using another RSA key ? Do i need to take
each mpi values and do encryption ? is it posssible to concate each
mpi value and encrypt it?
here is the piece of the code i am using,
if(gcry_ac_open(&GcryptRsaHd, GCRY_AC_RSA, 0)!=0)
      {
         printf (" Gcrypt RSA Cipher Open : %s\n", gpg_strerror(GcryptErrVal) );
         //return RSA_CIPHER_OPEN_FAILURE ;
      }
      data = gcry_ac_key_data_get(RsaKey);
      for (i = 0; i < gcry_ac_data_length(data); i++)
      {
            gcry_ac_data_get_index(data, 0 , i, &sName[i], &mpiTemp[i]);
            printf(" MPI %s Bits : %d \n" ,sName[i]
 GcryptErrVal = gcry_ac_data_encrypt( GcryptRsaHd
            if ( GcryptErrVal )
            {
                 printf (" KeyEncryption : %s :%s \n",gpg_strerror(
GcryptErrVal ), gpg_strsource( GcryptErrVal ));
                 gcry_ac_close(GcryptRsaHd);
                 //return SECURITY_FAILURE;
            }
            else
            {
                 printf("KeyEncryption : %s \n",gpg_strerror( GcryptErrVal ));
            }
     }
     printf(":::::::::::key Decryption function ::::::::::::::::::::::::\n");
     GcryptErrVal = gcry_ac_data_new( &GcryptDecryptedData);
     for (i=0 ;i<6; i++)
     {
 GcryptErrVal = gcry_ac_data_decrypt(GcryptRsaHd
         if ( GcryptErrVal )
         {
           printf (" KeyDecryption : %s :%s \n",gpg_strerror(
GcryptErrVal ), gpg_strsource( GcryptErrVal ));
           //return SECURITY_FAILURE;
         }
         else
         {
           printf (" KeyDecryption : %s  \n",gpg_strerror( GcryptErrVal ));
           printf(" MPI %s Bits : %d \n" ,sName[i]
           if(gcry_mpi_cmp(mpiTemp[i],mpiTemp2[i] )==0)
           {
                  printf ("MPI cmp success \n");
           }
           else
                 printf ("*********MPI CMP FAILURE ***********\n");
           if (gcry_ac_data_set(GcryptDecryptedData,
GCRY_AC_FLAG_COPY,/*RsaKeyMpiNames[i]*/sName[i], mpiTemp2[i]))
           {
             gcry_ac_close(GcryptRsaHd);
             gcry_mpi_release(mpiTemp2[i]);
             //return -3;
           }
          gcry_mpi_release(mpiTemp2[i]);
        }
     }
     gcry_ac_key_init(&GcryptTestKey,GcryptRsaHd,GCRY_AC_KEY_SECRET ,
     GcryptErrVal = gcry_ac_key_test(GcryptRsaHd ,GcryptTestKey );
     if(GcryptErrVal)
     {
          printf ("********** Testing Rsa Secret Key :
%s\n",gpg_strerror(  GcryptErrVal ),gpg_strsource( GcryptErrVal ));
          gcry_ac_close(GcryptRsaHd);
          //return RSA_KEY_TEST_FAILURE;  /* TBC */
     }
     else
        printf ("************Testing Rsa Secret Key :
%s\n",gpg_strerror(  GcryptErrVal ),gpg_strsource( GcryptErrVal ));
 But I am getting out put
 KeyEncryption : Success
  MPI e Bits : 6
 KeyEncryption : Success
  MPI d Bits : 2041
 KeyEncryption : Success
  MPI p Bits : 1024
 KeyEncryption : Success
  MPI q Bits : 1024
 KeyEncryption : Success
  MPI u Bits : 1024
 KeyEncryption : Success
 :::::::::::key Decryption function ::::::::::::::::::::::::
  KeyDecryption : Success
  MPI n Bits : 0
 *********MPI CMP FAILURE ***********
  KeyDecryption : Success
  MPI e Bits : 6
 MPI cmp success
  KeyDecryption : Success
  MPI d Bits : 2041
 MPI cmp success
  KeyDecryption : Success
  MPI p Bits : 1024
 MPI cmp success
  KeyDecryption : Success
  MPI q Bits : 1024
 MPI cmp success
  KeyDecryption : Success
  MPI u Bits : 1024
 MPI cmp success
 ********** Testing Rsa Secret Key : Invalid public key algorithm
 What is the problem ? could some one help me in solving this one  ?
   Vinod

@_date: 2006-08-10 14:49:29
@_author: Vinod Jacob 
@_subject: encrypt/sign 2048 bit RSA key using another Rsa 2048 bit Key 
I am using libgcrypt 2048 bit encryption.
what is the maximum size of the buffer that i can encrypt using 2048
bit key.is it 2048 bit ?
 I am getting incorrect values when i try to encrypt a buffer of size
more that 2048 bit
. Encryption/decryption function is successfully finishing  .But
when i tried to print the decrypted buffer , it is showing different
values. so what would i need to do, if , I want to encrypt buffer of large
size ?
 (i know we can encrypt large buffer using AES and encrypt AEs
keys using RSA ).But my requirement is to encrypt large buffer using
RSA .
Let me try to explain what i am trying to do in more detail.
 I have to encrypt/sign Rsa ( 2048 bit) keys using another Rsa  2048 bit Key
let's say Entity A there is one Rsa Keys A_pub_key & A_sec_key and say
Entity b there is one Rsa keys B_pub_key & B_sec_key
 Now i want to encrypt A_sec_key using B_pub_key. is this possible ?
how to encrypt  RSA key using another RSA key ?
 Do i need to take each mpi values and do encryption ?
is it posssible to concate each mpi value and then encrypt it?
here is the piece of the code i am using,
if(gcry_ac_open(&GcryptRsaHd, GCRY_AC_RSA, 0)!=0)
     {
        printf (" Gcrypt RSA Cipher Open : %s\n", gpg_strerror(GcryptErrVal) );
        //return RSA_CIPHER_OPEN_FAILURE ;
     }
     data = gcry_ac_key_data_get(RsaKey);
     for (i = 0; i < gcry_ac_data_length(data); i++)
     {
           gcry_ac_data_get_index(data, 0 , i, &sName[i], &mpiTemp[i]);
           printf(" MPI %s Bits : %d \n" ,sName[i]
 GcryptErrVal = gcry_ac_data_encrypt( GcryptRsaHd
           if ( GcryptErrVal )
           {
                printf (" KeyEncryption : %s :%s \n",gpg_strerror(
GcryptErrVal ), gpg_strsource( GcryptErrVal ));
                gcry_ac_close(GcryptRsaHd);
                //return SECURITY_FAILURE;
           }
           else
           {
                printf("KeyEncryption : %s \n",gpg_strerror( GcryptErrVal ));
           }
    }
    printf(":::::::::::key Decryption function ::::::::::::::::::::::::\n");
    GcryptErrVal = gcry_ac_data_new( &GcryptDecryptedData);
    for (i=0 ;i<6; i++)
    {
 GcryptErrVal = gcry_ac_data_decrypt(GcryptRsaHd
        if ( GcryptErrVal )
        {
          printf (" KeyDecryption : %s :%s \n",gpg_strerror(
GcryptErrVal ), gpg_strsource( GcryptErrVal ));
          //return SECURITY_FAILURE;
        }
        else
        {
          printf (" KeyDecryption : %s  \n",gpg_strerror( GcryptErrVal ));
          printf(" MPI %s Bits : %d \n" ,sName[i]
          if(gcry_mpi_cmp(mpiTemp[i],mpiTemp2[i] )==0)
          {
                 printf ("MPI cmp success \n");
          }
          else
                printf ("*********MPI CMP FAILURE ***********\n");
          if (gcry_ac_data_set(GcryptDecryptedData,
GCRY_AC_FLAG_COPY,/*RsaKeyMpiNames[i]*/sName[i], mpiTemp2[i]))
          {
            gcry_ac_close(GcryptRsaHd);
            gcry_mpi_release(mpiTemp2[i]);
            //return -3;
          }
         gcry_mpi_release(mpiTemp2[i]);
       }
    }
    gcry_ac_key_init(&GcryptTestKey,GcryptRsaHd,GCRY_AC_KEY_SECRET ,
    GcryptErrVal = gcry_ac_key_test(GcryptRsaHd ,GcryptTestKey );
    if(GcryptErrVal)
    {
         printf ("********** Testing Rsa Secret Key :
%s\n",gpg_strerror(  GcryptErrVal ),gpg_strsource( GcryptErrVal ));
         gcry_ac_close(GcryptRsaHd);
         //return RSA_KEY_TEST_FAILURE;  /* TBC */
    }
    else
       printf ("************Testing Rsa Secret Key :
%s\n",gpg_strerror(  GcryptErrVal ),gpg_strsource( GcryptErrVal ));
And this is the output..
 KeyEncryption : Success
 MPI e Bits : 6
 KeyEncryption : Success
 MPI d Bits : 2041
 KeyEncryption : Success
 MPI p Bits : 1024
 KeyEncryption : Success
 MPI q Bits : 1024
 KeyEncryption : Success
 MPI u Bits : 1024
 KeyEncryption : Success
 :::::::::::key Decryption function ::::::::::::::::::::::::
 KeyDecryption : Success
 MPI n Bits : 0
 *********MPI CMP FAILURE ***********
 KeyDecryption : Success
 MPI e Bits : 6
 MPI cmp success
 KeyDecryption : Success
 MPI d Bits : 2041
 MPI cmp success
 KeyDecryption : Success
 MPI p Bits : 1024
 MPI cmp success
 KeyDecryption : Success
 MPI q Bits : 1024
 MPI cmp success
 KeyDecryption : Success
 MPI u Bits : 1024
 MPI cmp success
 ********** Testing Rsa Secret Key : Invalid public key algorithm
 What is that i am missing here? could some one help me in solving this one  ?
  Vinod

@_date: 2006-08-18 22:05:09
@_author: Vinod Jacob 
@_subject: extra chars added to the decrypted string ( RSA encryption) 
Hi all,
    This is my second  mail to the list, thanks for the book
references, i could start coding with more confidence.  thanks Werner!
     Still i have to admit that i am still a newbie to the libgcrypt
world, but had to start coding because of the time constraints of the
project. Hope people would bear with me and would help me !
the Problem : I get some additional characters to the decrypted char buffer.
Say, i am trying to encrypt, a 256 byte buffer, with a 2048 rsa key.
when i print the decrypted data, there are some additional characters
added . But if the data buffer is less than 256, (say 255) , the
decrypted data matches with the initial data.
here is the code:
 "./src/gcrypt.h"
int main()
gcry_ac_data_t data;
gcry_ac_key_t key1,key2;
gcry_ac_key_pair_t keypair;
gcry_ac_handle_t handle;
gcry_ac_key_spec_rsa_t rsa_spec;
gcry_error_t err;
char buf[256]={"123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8"};
char newbuf[256];
gcry_control (GCRYCTL_DISABLE_SECMEM, 0);
size_t r,v;
rsa_spec.e = gcry_mpi_new (0);
gcry_mpi_set_ui (rsa_spec.e, 1) ;
err = gcry_ac_open (&handle, GCRY_AC_RSA, 0);
err = gcry_ac_key_pair_generate (handle, 2048, &rsa_spec, &keypair, NULL);
key1 = gcry_ac_key_pair_extract (keypair, GCRY_AC_KEY_SECRET);
key2 = gcry_ac_key_pair_extract (keypair, GCRY_AC_KEY_PUBLIC);
int err1= gcry_mpi_scan (&mpi1, GCRYMPI_FMT_USG, buf , 256, &r);
if (err1==0)
 {
  printf ("Scan Success\n");
 }
printf ("bytes Scanned = %d \n", r);
err = gcry_ac_data_encrypt (handle, GCRY_AC_FLAG_NO_BLINDING, key2,
mpi1, &data );
if (err==0)
 {
  printf ("Success\n");
 }
printf ("In Return : %d \n", r);
err = gcry_ac_data_decrypt (handle, GCRY_AC_FLAG_NO_BLINDING, key1,
&mpi2, data);
if (err==0)
 {
  printf ("Success\n");
 }
gcry_mpi_print (GCRYMPI_FMT_USG, (unsigned char *)newbuf ,256, &v, mpi2 );
printf ("bytes Printed = %d \n", v);
printf ("\n buffer: %s\n", newbuf );
return 0;
here is the output printed on terminal if the buffer is actually 255
bytes: ( this works)
Scan Success
bytes Scanned = 0
In Return : 0
bytes Printed = 256
 buffer: 123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
here is the output printed on terminal if the buffer is actually 256
bytes: (this doesn't Work)
Scan Success
bytes Scanned = 0
In Return : 0
bytes Printed = 256
 buffer: 123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8123456 8123456 8123456 8123456 8123456 8123456 8123456
8123456 8xs?
See the extra characters in this case.
Any Pointers?
 thanks in advance,
    Vinod

@_date: 2006-10-07 06:52:26
@_author: Vinod Jacob 
@_subject: Problem with Padding 
I am trying to write some code to make the libgcrypt handle the pkcs1.
for this to achieve, do i need to use the s-expression interface ?
 I am using sexp_data_to_mpi() with pkcs1 flag , which sets the MSBs
to 0x00. But when its 'gcy_mpi_scan'ed, the MSB 0x00x are ignored due
to mpi_normalize().
 Any Pointers how to go about this and what is missing here?
Thanks in advance,
   Vinod
