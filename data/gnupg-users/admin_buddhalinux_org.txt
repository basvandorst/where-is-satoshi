
@_date: 2005-03-03 20:52:39
@_author: Thomas Jones 
@_subject: group options 
GPG seems to be reading your group value(s) not as expected. Referencing the source file g10.c:
  if(string==NULL)
    {
      log_error(_("no = sign found in group definition \"%s\"\n"),name);
      return;
    }
The strsep function is attempting to access the token(value) in the &string variable. The first token is separated from the group name via the equals Try to concatenate the name declaration, separation character(=), and value list. I've never tried, but you may need to quote the arguments(group value list) to keep it from being expanded unexpectedly in the configuration file. I know that passing the group command to bash requires quotes on my system.
See if that has a desired effect.

@_date: 2005-03-03 22:28:33
@_author: Thomas Jones 
@_subject: group options 
Actually the group argument can go on the command-line. I've used it in various custom scripts on my systems.
gpg -e -a --group TestGroup="0x57BF9042 0x515FAF83" -r TestGroup test_file.txt
or in a script
gpg -e -a --group ${GroupName}="${GroupList}" -r ${GroupName} test_file.txt
This way the recipient group can be appended as needed throughout the script. And can then be expanded into the execution sequence.

@_date: 2005-03-15 19:28:38
@_author: Thomas Jones 
@_subject: Decryption via UNIX shell script 
I use one file readable only by root for all local scripts. And run the script's in a jail or sandbox. I would also mention that you need to be sure not to export the variable into the user's environment. Be sure to keep the scope of the password(s) contained within the script's execution processes

@_date: 2005-10-07 17:55:56
@_author: Thomas Jones 
@_subject: Disk Partition 
What do you mean by this statement? Are you referring to the randomization of the partition by use of /dev/urandom?
Is this fat32 partition encrypted? If so, what algorithm was utilized?

@_date: 2005-10-07 23:35:56
@_author: Thomas Jones 
@_subject: Disk Partition 
The above statement, although worthwhile, is not well founded. I think it would be better to restate that randomization through utilization of SOME pseudo-random generators is not recommended. Or maybe even that some are more recommended than others.
For instance, I utilize the GSL for my system(s). Although, it is not truly random; it is significantly better to utilize such rng's rather than default rng's with a cots system.. After all, I don't know anybody who has the resources to acquire hardware rng's.
However, if you may have a recommendation on how to obtain the highest amount of sufficiently random number generation; I would be most interested to hear it. I am always looking for more secure methods to perform everyday activities.

@_date: 2005-10-08 02:01:41
@_author: Thomas Jones 
@_subject: Disk Partition 
The use of prng generated data to seed another prng function is utilized to compute data that is inherently random from the previous generation.
Now this is not to say that it is truly random. Only that it is "sufficiently" random to provide for security of a particular resource.
For instance, there are such entities such as cryptographically secure prng; also known as csprng. A few instances of these entities are block ciphers such as 3des, aes, and the idea algorithms in cbc mode of operation.
Surely, you are not stating that the above are not cryptographically secure even though they utilize prng seeds? ;)

@_date: 2005-10-09 02:41:21
@_author: Thomas Jones 
@_subject: Armor headers 
I am really not sure that it is a good idea to do such. Some poorly written binaries may fault at an unexpected header; and bring your productivity to a grinding halt. However, all you should have to do is alter the source code.
I haven't done alot of research, however, it would be trivial to alter the following lines in the "g10/armor.c" source file to whatever you choose:
        if( !opt.no_version )
          {
        iobuf_writestr(a, "Version: GnuPG v"  VERSION " ("
                   PRINTABLE_OS_NAME ")" );
        iobuf_writestr(a,afx->eol);
          }
Then simply recompile the "new" sources. Also I believe from the little bit of code that I did read that the end-user can append to the default version header with the addition of a -(dash) and some printable characters. Search for the DEVELOPMENT_VERSION variable if interested.

@_date: 2005-10-10 04:15:26
@_author: Thomas Jones 
@_subject: Disk Partition 
I am not sure of the context of this statement. To what are you referring?
Identification, and the subsequent authentication is already performed at the system(operating system) level.
Is there a specific application-level(?) authentication mechanism that you are aware of? If so, how does this abstraction interface with the filesystem -- which is at a considerably lower level than general user-space applications?
