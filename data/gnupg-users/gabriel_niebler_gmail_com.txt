
@_date: 2014-04-23 23:00:41
@_author: Gabriel Niebler 
@_subject: UI terminology for calculated validities 
Hash: SHA1
tl;dr: "validity" is confusing, please consider using "ownership" or
"authenticity" for same concept.
Dear all,
it seems to me that the problem here is mainly one of semantics. The
technical concepts are clear to everyone involved, the question is how
to name and explain them so they can be readily understood -
especially by novices and non-technical users.
To this end, I would like to add two points:
1) I believe that the word "validity" is a poor choice for how it is
used at present (i.e. the assignment of faith in the identity of the
key's purported owner), because it gets people thinking along the
wrong lines.
The average layperson already has a concept of "validity" from such
things as credit cards ("valid thru"), mass transit tickets ("not
valid unless stamped") and passports ("valid from ... until ...", also
made invalid when one gets a new one). These pre-existing notions,
which are impossible to rub out, naturally translate to _expiration_
and _revocation_ of keys, NOT to the question who the key really
belongs to. Technically inclined people have a second association with
the word "valid", more akin to "well-formed" ("is this valid XML?"),
which naturally translates to whether e.g. a given version and
implementation of OpenPGP can understand a given key etc. and, again,
does NOT translate to the question of the key holder's true identity.
Hence the confusion.
What makes it worse is that in the above examples, i.e. the cases
people are familiar with, validity can usually be determined from the
document itself (here that would be the key), or at worst the system
that works with the document (here that would be GnuPG), but neither
is the case with key ownership. Instead, it is a determination only
the user can make (possibly through intermediaries, with the WoT).
Simply put, the word "validity" already means something to most
people, but it was taken and redefined to mean something else in the
context of asymmetric encryption keys - it's a bit like making a
calculator and using the '+' sign for multiplication: it will do the
correct thing and it's all in the manual, but it's still horribly
Therefore, I propose that the word "validity" is not chosen well for
what it now means in GnuPG, because it carries with it connotations
that are quite different from the intended meaning, which is
confusing. And thus a better, clearer word should be found and used in
future. Which word is obviously a matter for debate.
2) There are words that are already used to describe the right sort of
relation between an object and a person, or between a document and an
identity, and thus convey the right sort of meaning. The two best
examples that came to my mind (so far) are:
a) "ownership" and b) "authenticity".
Ad (a): A user wants to know whether the key they obtained is really
_owned_ by the person whose UserID(s) came with it. Instead of saying
the UserID is "invalid", the UI may warn that the UserID's "ownership"
is unconfirmed/has not been confirmed and may even say "this UserID
could be (a) fake". A GUI button could read "Sign to confirm
ownership" and open a dialogue that further asks "Are you (reasonably)
sure/certain/confident that the key with fingerprint ... belongs to
?" and then maybe have a link "How do I check this?" to some
explanatory text, below. GnuPG options could be renamed
Ad (b): A user wants to know whether a key is authentic, i.e. the
identity of the person it belongs to is that given in the UserID(s).
Instead of saying the key is "invalid", the UI may warn that its
"authenticity" is unknown/unconfirmed or that the key is "possibly
FAKE". A GUI button could read "Sign to authenticate" and open a
dialogue like above. GnuPG options could be renamed "show-uid-authenticity".
This language is very similar to the one we use for passports, ID
cards etc. and I believe this is a good thing, because the
understanding carries over:
My government issued passport is authentic and I own it, because it's
really me on the picture and that's my name and there's my date of
birth and these things can be checked, if needs be. But it may well be
invalid, because it expired or I got issued a new one and they punched
a hole through my old document. Likewise, my key is authentic and I
own it, because that's my name and email address in the UserID and
this can be checked by anyone who knows me with the help of my
fingerprint. But it may well be invalid, because it expired or I
revoked it.
A fake or stolen passport OTOH is valid, near as anyone can tell,
based on the expiration date printed in it, but if it's fake it's not
authentic and if it's stolen then the person carrying it is not the
owner. Likewise, a fake or "stolen" (copied) key is still valid, as
long as it hasn't expired or been revoked, but if it's fake it's not
authentic, and if it's been stolen then the person I'm talking to may
not be the owner.
The customs agent at the border checks both validity and
ownership/authenticity and so do we with UserIDs on keys.
Validity, in the sense of expiration and revocation status, can be
checked more or less automatically with the help of key servers (just
like the expiration date can be read by machine with with OCR or
RFID), but ownership/authenticity must be checked manually (or by WoT)
If you've made it this far, please also note that the word "trust"
was completely avoided in the above wall of text. No collision of
meaning with the WoT's concept of ownertrust.
Faithfully Yours
 gabe

@_date: 2014-04-25 00:13:32
@_author: Gabriel Niebler 
@_subject: UI terminology for calculated validities 
Hash: SHA512
Am 24.04.2014 11:13, schrieb Peter Lebbing:
Thank you very much!
Yes, I simply posted both options that had occurred to me, but
thinking a bit more about it  I agree that "authenticity" is the
better term.
The word "ownership" only works with another word (established,
confirmed, ascertained), because it is not a property of the UserID
itself. I can't say a UserID "has ownership", it's the other way
around. And the question is not "Who owns this UserID?", but rather
"Who owns this key? Is it the entity behind this UserID?" - that's not
nearly as clear as "Is this UserID authentic (for this key)?".
Finally, speaking of computed, fractional values of ownership sounds
weird, too.
So yes, "authenticity" gets the point across better and would also
work as a drop-in replacement of "validity".
 gabe

@_date: 2014-04-25 00:19:12
@_author: Gabriel Niebler 
@_subject: UI terminology for calculated validities 
Hash: SHA512
Peter Lebbing has thankfully pointed out that, out of my two
suggestions, "authenticity" is the word that should be preferred.
I agree with him on this, so I shall use that word here.
Yes, this is understood.
I believe, however, that the above statement would be easier to grasp
for novices if it were modified thus:
A key on my keyring is "valid" if it is not expired or revoked.
It is "authentic" if it bears one signature from one of my keys, or
several signatures from other keys to which I have granted marginal
authority to authenticate keys.
This way, the word "valid" in the first sentence - for which a clear
technical definition is given - still means what a novice user would
expect it to mean, based on common usage. The word "authentic" in the
second sentence is also defined in clear, technical terms, its meaning
is also pretty much what one would expect.
That is true, but one could also use the word "authentic" in this
case. I can consider some given key with some pseudonymous UserID
"authentic", because I know that it works to communicate with this
email address, whether I know the real identity behind the address or
not. I note this "authenticity" to myself by a local signature on the
key. GnuPG will only accept encryption keys that are both "valid" and
"authentic". It all works and the meaning is a little clearer, IMO.
"True identity" was perhaps not the best turn of phrase to use, while
trying not to repeat myself. I should have written "does NOT translate
to the question whether the entity/entities controlling the key is/are
indeed the one(s) represented by the UserID(s)".
And I maintain that this is true for the second common usage of the
word "valid" (as in XML etc.)
As far as keys are concerned it all boils down to the association
between private key and UserID. This is understood.
Yes, but only if the user has already begun to build their WoT. It has
been pointed out by other people in this same thread, that
a) this will usually never be the case for novice users (unless the
first thing they do is to maximally trust e.g. pgpca at ct.heise.de and
they may be better advised to start by comparing fingerprints off-band
with acquaintances) and
b) some, maybe many, perhaps even most users may never get to the
point of having a WoT large enough to be useful for this calculation.
So as it is now, a new user finds they must (basically always)
establish a keys "validity" themselves, when the expectation is that
GnuPG should know whether a given key is "valid". This may frustrate
some. (Real life examples are described by other people in the thread)
Instead, if we used "validity" for expiration/revocation status, then
we can explain "GnuPG always knows whether a given key is 'valid'* -
as you would expect. It (usually) can't tell whether the key is
'authentic', though. You need to check that and tell GnuPG by making a
signature." This is very easy to explain and understand, because it
gels with people's expectations.
And once new users have grasped this, they can be told that "GnuPG
*can* inspect the signatures present on a key to determine
authenticity." (This sentence could start the very next paragraph, or
could be under "advanced topics") And then we explain the whole
concept of the WoT.
And neither does authenticity. Terms used in GnuPG _are_ technical
terms and connotations will only get one so far. But at least the
connotations can get one thinking in the right direction.
Yes, it is a simple mechanism and the aim is not to change it.
But why not say "The key is 'authentic' by virtue of the signatures it
carries. It is 'valid' if it has not expired or been revoked."?
In normal life, it is "authenticity", not "validity" that is
established by signatures.
A passport is authentic if the information contained in it (the
bearer's UserID, to to speak) is correct, as witnessed by the
signature of some official. The passport is valid if it has not
expired or been marked/stamped/made invalid (i.e. revoked).
The analogy is very clear.
The question of "the meaning of signatures" is a different kettle of
fish altogether and - yes - may also give rise to (a different kind
of) confusion. That's not the topic of debate here.
And "Authenticity" is an equally clear and additionally _intuitive_
descriptive name for the same simple, mechanistic concept.
"Validity" naturally lends itself to the combination of
expiration/revokation status, and should be used for that (if at all).
Obviously, no argument here. My knowledge who really controls a key
would not make it "authentic" to GnuPG any more than it makes it
"valid" now. Signatures are still required, this is well understood.
Yes, I know. That's why official jargon uses the word "bearer". This
is a technicality, though, I "own" it in the sense that is _my_
passport. A thief who stole it from me does not "own" it even in that
sense, they merely possess it.
"Ownership" is not such a good replacement for "validity" anyway, as
stated in the beginning, so this is somewhat off topic now.
 gabe
* Yes, GnuPG's information for determining "validity" in terms of
revocation/expiration may be out of date. The key may have been
revoked - thus be invalid - and GnuPG hasn't downloaded the revocation
certificate yet. Or the key's expiration date may have been set to a
later date, so it's still valid, but my GnuPG does not know this. This
is beside the point, though, the intuitive understanding of "validity"
in this context is still correct.

@_date: 2014-04-25 01:10:15
@_author: Gabriel Niebler 
@_subject: UI terminology for calculated validities 
Hash: SHA512
Am 25.04.2014 00:22, schrieb Doug Barton:
To my mind, "verification" is the _process_ whereby the _properties_
like "validity" and "authenticity" are established*. I see a
difference there, but one could absolutely use the word "verified" and
"verification", of course.
Yes, it would. That's pretty much my whole point.
"Validity" is misleading, because it's commonly associated with dates
(valid from ... until ...) or a some sort of stamp that (in)validates
something. In terms of GnuPG keys, this would translate more readily
to expiration dates and revocation, so "validity" could be used for
that (if at all).
So if a UserID or key is listed as "validity unknown", new users
scratch their heads.
If instead GnuPG lists a UserID as "not verified" or with
"authenticity unknown", then even most new users should understand
more-or-less intuitively that they need to verify or authenticate the
key (and, hopefully, why).
And it also works in the WoT model, one just says something like
"GnuPG can compute authenticity/verification from a key's
signatures..." or "GnuPG can authenticate/verify a key based on its
I thought a bit about other languages and I believe the issue is
similar there. In German, validity translates to G?ltigkeit,
authenticity to Echtheit or Authentizit?t, verification to Best?tigung
or Beglaubigung and the connotations are very much the same as in
English. I'm fairly confident that it will be similar in a great many
languages (probably almost all Indo-European ones, at least).
So if a slight change in language would make things clearer to English
speakers, the corresponding change translated should also help
speakers of other languages.
 gabe
*: Say I received a key with my friend's UserID bound to it. I call
them to _verify_ that it's actually the same key they generated and
sent me by comparing fingerprints. With the _verification_ done (which
did not involve any fiddling with bits), I know validate/authenticate
the key by signing it (bit fiddling). Now the key is
"valid"/"authentic" to GnuPG.

@_date: 2014-04-27 00:01:15
@_author: Gabriel Niebler 
@_subject: UI terminology for calculated validities 
Hash: SHA512
Thank you. That was the whole point, really.
You and Peter are quite right and thanks for pointing this out. Having
a word, with an established meaning in GnuPG, and then suddenly
changing its meaning would cause far more confusion than its worth.
If one were to rename "validity" to "authenticity", then from that
point on, the word "validity" should not be used anymore, at all, in
the context of OpenPGP keys (or certificates, as I should probably
say). That's a shame, as "validity" is a good word with useful
connotations for some things, but it couldn't be helped.
Hmm, well as far as GPG is concerned, the question does not really
come up, because it shows the "validity"/"authenticity" _levels_ and
the words for those (ultimate, full, marginal, unknown) don't need to
be changed.
But this discussion is mainly about other UIs and it's relevant there.
I agree that 'inauthentic', the natural opposite of 'authentic', is
saying too much. The software doesn't know whether the given ID is
authentic or not, so it shouldn't pretend to know that it isn't.
I came up with the following pairs of (functional) antonyms:
1) 'authentic' - 'unknown'
2) 'authentic' - 'possibly fake'
3) 'authenticated' - 'unauthenticated'
4) 'authenticated' - 'not authenticated'
... or one can adopt the GnuPG CLI convention:
5) 'authenticity': 'unknown'/'marginal'/'full'/'ultimate'
And some other suggestions were made, too:
6) 'verified' - 'unverified'
7) 'verified' - 'not verified'
8) 'verification': 'unknown'/'marginal'/'full'/'ultimate'
9) 'accepted' - 'not accepted'
10) 'usable' - 'unusable'
11) 'usable' - 'not usable'
There may have been others I'm forgetting.
Ah, yes ... you're right, of course. I glossed over that, since I
believe that most certificates simply consist of a master signing key
(an encryption subkey, which we can ignore here) and one UserID. But
there may be other UserIDs and - for that matter - different
certificates with the same UserID and the question is always only "Is
this UserID valid/authentic/verified/usable/accepted/whatever with
this key?". It's good to state this clearly here.
GnuPG will also allow me to encrypt some text to (an encryption subkey
of) such a mixed-case certificate (I think), because it cannot
possibly know the intended recipient, so checking
validity/authenticity/... of that specific UserID is up to me. That's
as it should be, so also here, I can talk of the
validity/authenticity/... of the certificate as a whole.
Some higher level software, however,  may _know_ who I want to write
to and not allow me to use a given key, because
validity/authenticity/... of THAT UserID on THAT certificate with THAT
master key has not been established.
When that happens, such software should inform me of this in a way
that's helpful and as understandable as possible even to new users.
And it's at this point that the detail will have to exposed to the user.
I trust, though, that such mixed-case certifcates will be found very
rarely in people's public keyrings and almost never in those of new
users (after all, when signing a key, the signature is ausually
applied to all UserIDs by default), so I think it's perfectly
acceptable to hide a bit of the complexity by simply showing a
_certificate's_ validity/authenticity/... and to only go into details
when necessary.
 gabe

@_date: 2014-08-22 00:46:38
@_author: Gabriel Niebler 
@_subject: Fwd: GNU hackers discover HACIENDA government surveillance and 
Hash: SHA512
I'm sorry, I know this is OT for the list, but...
Am 21.08.2014 um 15:54 schrieb Robert J. Hansen:
On the contrary, IMO this sort of thing is fully encompassed by the
word surveillance, at least as far as I have always understood it.
Otherwise any surveillance camera installed in a public or publicly
accessible place would not be one, by definition, since it is only
gathering publicly available information.
After all, when I go out of the house I cannot reasonably expect to
have all my actions and whereabouts remain private. I might meet
someone I know who would then know where and when they saw me.
And yet, if I was being either (a) systematically tracked through
cameras and face recognition software, or (b) followed by
people/drones (or (c), both) so my every step (in public, mind) would
be recorded, then I would absolutely call that surveillance. What else
could it possibly be?
And if a system was put in place that would simply track everyone as
in (a), then what else could we call it but mass surveillance? And
yet, it's only gathering publicly available information.
Of course, surveillance, _can_ mean a lot more than that:
I would call that espionage, snooping, spying etc., but yes, this also
absolutely falls under the heading of surveillance. It's just one
facet, though.

@_date: 2014-06-24 13:28:16
@_author: Gabriel Niebler 
@_subject: riseup.net OpenPGP Best Practices article 
Hash: SHA512
Am 24.06.2014 09:36, schrieb Cpp:
I consider myself quite the amateur (I haven't even read most of RFC
4880 yet), but I do take issue with one point in the riseup.net Best
Practices page, namely the bit where it says "self-signatures must not
use SHA1".
I find that statement too strong.
AFAICS this will lead to keys which may not be understood by some
perfectly standards-compliant OpenPGP implementations, since SHA-1 is
the _only_ hashing algorithm that MUST be supported by all
implementations of that standard. Everything else is up to the
I do not know that there are any such implementations out there, but
there seem to be a lot of people "rolling their own" who occasionally
post to this very list.
Possibly breaking OpenPGP compatibility does not seem like a Best
Practice to me. I raised this concern in a comment on the _original_
page at but it didn't garner any interest.
I believe additional self-signatures can always be added to existing
UIDs and subkeys later and I presume (someone correct me, if I'm
wrong, please) they can use other hashing algos. That might be a way
to get "the best of both worlds": Not breaking standards compliant
clients (which would hopefully just ignore the selfsigs they can't
understand and focus on those they can) AND strong hashing.
Maybe other people can weigh in on this, notably those involved with
that document. I would be especially interested to hear dkg's opinion.

@_date: 2014-11-14 14:38:57
@_author: Gabriel Niebler 
@_subject: Why the software is crap 
Hash: SHA512
Dear David, dear fellow GnuPG users,
this conversation made me curious, so I tried to do it myself. Here's
what I did on my work laptop, just now, five minutes ago (in my home dir):
$ rm -rf .gnupg
$ scp -r ${myfileserver}:${pathtobackupsfromOTHERlaptop}/.gnupg/ .
$ rm .gnupg/random_seed
$ echo "My hovercraft is full of fish, but I tell everyone they're
eels." > my_big_secret.txt
$ gpg --encrypt --recipient 0x65A3F1CC8303C0EC my_big_secret.txt
$ rm my_big_secret.txt
$ gpg --decrypt my_big_secret.txt.gpg
You need a passphrase to unlock the secret key for
user: "Gabriel Niebler "
2048-bit RSA key, ID 0x65A3F1CC8303C0EC, created 2014-03-16
         (subkey on main key ID 0xD05AF6C786CB34F4)
gpg: encrypted with 2048-bit RSA key, ID 0x65A3F1CC8303C0EC, created
      "Gabriel Niebler "
My hovercraft is full of fish, but I tell everyone they're eels.
So this all worked and the fact that this message is signed (using
Enigmail/Thunderbird) is further proof that the method worked for me.
Now that we have established that simply copying over your .gnupg
directory from one machine to another and deleting random_seed does
indeed produce the desired result for some people, maybe you can walk
us through exactly what you did and we'll see if we can't figure out
what the problem is. I suggest copying and pasting shell commands and
their output verbatim.
If you do not want to bother the rest of the list with this you are
welcome to send mails directly to me. I am not an expert, but I'm
willing to help you.

@_date: 2014-11-14 19:24:38
@_author: Gabriel Niebler 
@_subject: Why the software is crap 
Hash: SHA512
Dear David,
Could you please show me exactly what you did, i.e. copy and paste the shell session(s),
commands and output. Also, please make it clear which session was run on the origin (where
everything works) and which was run on the target (where things don't work).
(Feel free to censor whatever you feel is sensisitive info, of course.)
I really don't believe I can help you without a clear picture what commands you ran and the
output they produced.
Don't despair, we'll get it working yet!

@_date: 2014-11-16 10:43:13
@_author: Gabriel Niebler 
@_subject: The Facts: 
Hash: SHA512
it is not a gpg2 problem and it is also not relatd to modern versions
of your mail programmes. In my case Thunderbird 31.2 with
Enigmail 1.7 runs just fine with GnuPG 1.4.16. I also have GnuPG
2.0.22 installed as gpg2, but I'm not actively using it. You don't need
to downgrade your Thunderbird, if it has problems signing and
encrypting mail, somthing else is amiss.
I now think you may be hitting the pinentry issue Philip Jackson
reported several months ago. There seems to be a problem specifically
with pinentry-gtk2 and IIRC that's what you're using. You're on KDE, I
believe, so have you tried removing 'pinentry-gtk2' and replacing it
with 'pinentry-qt4'? If that doesn't work, could you try using
Also, what's the content of your gpg.conf? (Just do 'cat

@_date: 2014-11-26 23:51:31
@_author: Gabriel Niebler 
@_subject: digest-algo SHA256, SHA-1 attacks 
Hash: SHA512
I just wanted to say thank you very much for the explanation. It was very enlightening.
I especially like the fact that, despite nobody asking specifically about SHA-1, you
still decided to take the time to write a lengthy message explaining the nature of the
known attacks on SHA-1 - and in a very understandable manner, too.
I actually learned something today.

@_date: 2015-01-01 22:28:40
@_author: Gabriel Niebler 
@_subject: Updating public key problem 
Hash: SHA512
Am 01.01.2015 um 18:10 schrieb Linux Debian:
Yes, key servers are purely cumulative.
Information cannot be deleted or made to disappear from them,
including revoked or expired (sub)keys.
This is by design, so that noone can e.g. remove someone else's
(sub)key(s), signatures, preferences etc. from the key server network.
I don't know that service, but if that is the case, then I suggest you
take it up with the people who run the encrypt.to service. If it
cannot handle expired subkeys then they don't implement the OpenPGP
standard correctly.
