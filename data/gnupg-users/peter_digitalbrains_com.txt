
@_date: 2006-12-06 20:08:07
@_author: Peter Lebbing 
@_subject: Christmas is upon us again. 
Hash: SHA1
Yes, I will join in too and donate to the FSF, as a strong supporter of
enabling *free speech* (GnuPG and other crypto/anonimity products), and
free software in general.

@_date: 2006-03-27 19:26:29
@_author: Peter Lebbing 
@_subject: SCM SPR 532 cardreader pinpad 
I bought an OpenPGP card (from kernelconcepts.de) along with the SCM SPR 532 cardreader, based on the remark in the HOWTO "The pinpad may be used to securely enter the PIN without using the attached computer."
In the HOWTO they refer to a patch that is no longer available; I couldn't find it anywhere, but I suspect it's not needed for recent versions anyway.
Now, I won't document what I've all tried, since my question is pretty basic and doesn't need a lot of explanation. I found a message on the archive of this userlist:
Is this still true that the pinpad can not be used in GnuPG? If it can be used, I'd appreciate a general hint in the right direction, and if I can't figure it out then, I'll be back here with lots of detail :).
I must say the way it's phrased in the HOWTO is strange. The SPR 532 is described with "pinpad may be used", and the Kobil KAAN Advanced with "The keyboard is not yet supported by GnuPG". I honestly don't see much difference in practical use when the supporting code in GnuPG is there but not "connected" to the rest of GnuPG in the former case.
Peter Lebbing.

@_date: 2006-11-12 12:54:59
@_author: Peter Lebbing 
@_subject: Question about use of --cipher-algo AES & --openpgp 
The "file" command is a very useful tool for identifying files, but in
my opinion it is not necessary that it can obtain detailed information
from a file. You could probably write a magic info entry that
succesfully identifies a file as generally an OpenPGP file (of course
always with the possibility of false positives). Once you know it's
OpenPGP, you just use gpg to look at the details. "file" gives you a
good hint towards which tool to use to interpret the file, and that tool
can subsequently be used to get the real information about the file.

@_date: 2006-11-12 13:10:58
@_author: Peter Lebbing 
@_subject: OpenPGP Card implementation 
I got interested as well and though I understand it, I also see a lot of
added value in a true Open Source implementation. I'm looking into
implementing it on a general processor microcontroller, I have
experience with microcontroller programming. The main problem I see so
far is working out a way to get decent random numbers, for blinding and
key generation. Personally I don't use the latter function, because it
lacks the possibility for backups.
So far, it seems all cards that offer a true RNG out-of-the-box are
exactly those cards that also have other crypto functions, and all have
Non-Disclosure Agreements. It would be so great if general-purpose CPU
smartcards would be taken to a new level with true RNG and more memory
without any NDA's!
Limited memory is an issue, but I think not a show stopper. Hardware
TRNG isn't even difficult to create AFAIK, but obviously you can't add
one to a smartcard yourself.
I understand the decisions taken in the current and only implementation
of the OpenPGP card, but it's interesting to try other approaches. In
the worst case you build experience :). And when there is an
unsurmountable problem, it might provide a nice code-base to work from
when a future card would overcome those problems (I'm mostly thinking of
TRNG and memory size).

@_date: 2006-11-14 15:06:46
@_author: Peter Lebbing 
@_subject: Question about use of --cipher-algo AES & --openpgp 
I started writing this before HHH's last post. I'll trim it but some of
it could give insight.
The RFC is very clear on what could be the first bytes. OpenPGP messages
and alike don't have a *file header* but they do have a packet header
and only a limited set of packets can be the first packet of the file. I
did notice something: Exporting secret keys is handled in the RFC, as is
best shown by the existence of the "BEGIN PGP PRIVATE KEY BLOCK" ASCII
Armor option. However, in chapter 10, it is omitted. But logical
thinking applies the rule that was mentioned somewhere else: a secret
key is a public key with extra luggage.
Well as long as it is about identifying OpenPGP files I think it will be
on-topic in this group, the moment it moves to discussion about the
exact magic entry (and how good it is, considering false positives), it
becomes off-topic. If I'm wrong, someone may correct me.
Though I agree, you should understand where this format comes from. PGP,
starting from version 2.x! To be able to be somewhat backwards
compatible (parsing and creating), they based the whole format on what
PGP used. At least, that's my interpretation, I wasn't involved in
making the OpenPGP standard :).
OpenPGP messages don't have much to go on to identify them. But I tried
to make a recognition for your interest, symmetrically encrypted
messages with no "asymmetric recipients", only one or several passwords.
For this I just used the RFC, not even experience to go on. Other people
might see an error. However, my conclusion is that it cannot be done
with the extremely limited options of 'file'. For a very probable
packet, I need to match values ranging over 5 bytes. Since you can only
do one test, and some bytes can range over a lot of possibilities, I'd
need a numeric test with AND-masking applied. But only strings can be
matched on *5* bytes, and they can't be masked.
Here's how I recognise symmetrically encrypted messages:
These begin with either a Symmetrically Encrypted Data Packet
(deprecated, compatibility) or a Symmetric-Key Encrypted Session Key
Packet. There is one catch: it's conform spec to compress the entire
message. But let's suppose the implementation is nice enough to only
compress the embedded data of the message. Even then we run into a problem.
A Symmetrically Encrypted Data Packet can, with those basic tests of
'file', only be identified by it's packet tag. It's just not enough:
byte 0 & 0xFC = 0xA4 : Old format, packet tag 9
byte 0 = 0xC9 :	New format, packet tag 9
We get further with an ESK packet, luckily, and this is what you'll see
from recent OpenPGP implementations (right, everybody?).
Option 1:
byte 0 = 0x8C: Old format, packet tag 3, 1 octet length of packet
byte 2 = 0x4: SK-ESK packet version 4
byte 4 = 0,1 or 3: S2K specifier
Option 2:
byte 0 = 0x8D: Old format, packet tag 3, 2 octet length of packet
byte 3 = 0x4: SK-ESK packet version 4
byte 5 = 0,1 or 3: S2K specifier
You could continue the list for larger packet length specifiers (like
someone already pointed out, a small packet can still be specified with
a long specifier with leading 0's), new format packets, for public key
ESK packets, etcetera. If we could match more bytes in one match then we
would have at least 3 bytes identifying a file positively; that's fairly
okay I think. If this where possible:
0  belonglong&0xFF00FF00FC000000  0x8C00040000000000  OpenPGP File
0  belonglong&0xFF0000FF00FC0000  0x8D00000400000000  OpenPGP File
We'd match both options (with the added possibility of undefined S2K
specifier 2, but let's keep it simple).
However, then we run into a problem with new format packets, where the
structure depends on the value of the 2nd byte in the file. The real
solution obviously is more than 1 test.
When I started this, I hoped it'd be possible to match the file. I think
I've established though that it is impossible, which is also worth a bit.

@_date: 2006-11-18 21:01:17
@_author: Peter Lebbing 
@_subject: OpenPGP Card implementation 
Perhaps this is more a discussion for gnupg-devel or even not a gnupg
mailing list at all?
I have a question regarding the current OpenPGP Card for Werner: does it
blind RSA calculations? If not, is there a different firewall against
using power analysis to obtain the secret key?
A 16C84 has 68 bytes RAM, only 1 data register, 0,25 MIPS per MHz and no
hardware multiply instruction. A probably completely impossible basis
for RSA calculations. I was more thinking along the line of the AT Mega
Funcard with an Atmel ATmega161 or -163, with 1 KiB RAM, 32 registers, 1
MIPS per MHz and 8x8 multiply instruction (with 0,5 million
multiplications per second per MHz), or possibly the SuperPIC Zen with
PIC18F452: 1,5 KiB RAM, 1 data register, 1 MIPS per MHz and 8x8 multiply
with 1 million multiplications per second per MHz.
My personal preference goes to the Atmel, just a more pleasant platform
imo; the lower multiplication speed might be compensated by other
factors, or maybe not. Also, the ATmega Funcards are much easier to come
by than the SuperPIC Zen.
The lack of RNG might be a problem: obviously you need randomness for
key generation; but you could choose to omit this feature (and just not
be fully OpenPGP compliant) and still use the card effectively. However,
it greatly improves secret key secrecy when RSA calculations are
blinded, and that requires randomness as well. It might be possible to
obtain reasonable randomness; and if not, a non-blinded RSA card is imho
at least more secure than a private key file with a passphrase: for the
file, access to the computer, be it local or remote, plus the passphrase
is required to learn the secret key. For the card, *physical* access to
the card and the passphrase are required to be able to obtain the secret
key. The nice property that a key cannot be copied from the card is
lost, though, without blinding.
SOSSE is a nice starting ground for development; however, as this is a
security product, I think one should rewrite large parts of it with
constantly keeping security in mind. SOSSE is developed as an
educational platform, not a crypto provider. I think, if you audited
SOSSE code for security, you have more chance of overseeing a weakness
than if you wrote completely new code.
I'm not touching legality with a 40-feet pole, by the way :).

@_date: 2006-11-25 17:00:30
@_author: Peter Lebbing 
@_subject: GnuPG 2.0.1rc1 released 
Hello Werner,
Is it possible to backport this (or just the SPR 532 code) to GnuPG 1.4?
I would like this to work on my Windows box. Or is the architecture too
different? Back in March you wrote
I could imagine fixing that requires a running scdaemon to do it...

@_date: 2006-11-27 14:36:08
@_author: Peter Lebbing 
@_subject: GnuPG 2.0.1rc1 released 
Hash: SHA1
First off, I noticed I accidentally replied only to Werner and not to
the list. My previous post:
Yes, I was just hoping that it would be easy. Pity. Thanks for the replies!

@_date: 2006-10-16 19:21:21
@_author: Peter Lebbing 
@_subject: OpenPGP Card implementation 
Hash: SHA1
Is the implementation of the current OpenPGP Card open source? If so,
how can I obtain the source?
I'm just interested in seeing how it is done, I don't plan to use it for
any practical purposes.
Peter Lebbing.

@_date: 2007-06-25 12:55:11
@_author: Peter Lebbing 
@_subject: Prolem with gpg --with-fingerprint < keyfile 
Hash: SHA1
I've been playing around a bit with your public key file. I do not know the
cause, but the following gave me the fingerprint:
(watch out with the rm if you repeat this verbatim, it is more for
illustration of method than to copy literally)
$ gpg --dearmour test
$ gpgsplit test.gpg
$ rm *.sig
$ cat 00* >test-nosig.gpg
$ gpg --with-fingerprint test-nosig.gpg
pub  1024D/4E754BED 1999-11-16 Rainer W. Gerling       Key fingerprint = EB96 7ACE 1466 DA7E 48B8  261E DC77 8B07 4E75 4BED
uid                            Rainer W. Gerling uid                            Rainer W. Gerling uid                            Rainer W. Gerling In other words, when I delete all the signatures from the file, the
fingerprint does show up. Maybe someone with proper knowledge of it all can
use this hint to determine the problem.
By the way, let me be the first to say that in scripts you should probably use
$ gpg --with-fingerprint --with-colons <keyfile
because the --with-colons is intended for machine use, and what you are
using is for the human eye, which adapts a bit better to changed output.
Good luck,

@_date: 2007-05-11 14:53:26
@_author: Peter Lebbing 
@_subject: Secure text editor? 
Hash: SHA1
Hello all,
I want to have a text file with personal data in it, which I encrypt to
myself, and decrypt to view and edit. However, to do that securely, I need
an editor which will not leak the text in any way, so locking it's pages in
memory so they won't be swapped out, and other angles of attack. In short,
an editor written with security in mind, suitable for editing sensitive
data. It's okay if it does that on plaintext files, I suppose, I can encrypt
and wipe the original to get rid of that, or do I miss something there?
My workstation runs Windows, but I think I would prefer a tool that works
under Linux too (possibly under Cygwin in Windows). It would be cool if it
integrated with GnuPG so I don't have to manually en- and decrypt, but it's
not a demand unless, like I said, I missed some vector of attack.
Does anybody know an editor that's up to the job?
Peter Lebbing.

@_date: 2007-05-15 15:39:46
@_author: Peter Lebbing 
@_subject: Secure text editor? 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Thanks for all the helpful posts.
I think I will go with just using my Linux laptop for it. I can just encrypt
the swap, it's not difficult, I've played with cryptoloop before. I didn't
use it for swap, but it's identical. And while I'm at it, I'll just add a
file-backed cryptoloop for a small encrypted partition, which imho is easier
than using the vim plugin, although I will actually be using vim :). It's my
favourite editor on Linux. In that respect I have an important question: it
is correct that vim only makes a swapfile in the same directory, right? No
cute extra files in /tmp? :)
And yes, it's perfectly possible to run without swap at all under Linux. But
crypting the swap is rather trivial and it can be a useful addition. Since
Linux doesn't use the swap intensively on normal use, the performance
penalty is low. Windows seems to me to have a habit of overusing the swap,
and an en-/decryption on every use might incur quite some performance penalty.
The usual recipe involves choosing a random key on startup which is only
kept in memory, so on shutdown (controlled or forced) the contents of the
swap are just garbage since not even the legitimate owner still has the key.
Swap doesn't need to persist over reboot.
In this respect I have a nice idea, if you're worried about the swap
remaining readible to root later on during uptime (when it becomes hacked).
After all, some boxes stay up for years, so the swap is never wiped on
reboot. It might be a bit paranoid, but the procedure is so easy that I
thought I should mention it. Instead of using 1 swapspace of 512 MiB
(example), you set up two partitions of 512 MiB. You only use one, crypted.
After you've done something you wish to hide, you enable the other crypted
swap, and disable the original crypted swap /after that/. If you assume the
key for the crypted device is lost this way, your original data is
scrambled, and only active pages are transferred to the new swap when you
disable the first swapspace. If you're afraid the kernel might have swapped
the page containing the original key to the new swapspace, you "shred" the
old swapspace, but I think chances are low: a driver that handles crypting
to swap will not swap it's own key out, because how is it going to unswap
it? It needs the key to decrypt the key. The driver is written to keep
everything needed to access the swap in main memory. The only possibility is
that it keeps a second copy of the key, but I think this is unlikely. And
with this procedure, you always have a minimum of 512 MiB swap, unlike when
you just disable and re-enable the swap.
Alessandro Vesely talked about snooping in the memory space of the process.
Yes, if your computer is compromised, all activity at that moment is also
compromised. The thing with swapspace though, is that the plaintext remains
on disk long after you've edited the file!
- From the whole discussion I get the idea that it's not that sure that
Windows respects a locked page in the sense as we're talking about it here.
Hibernation though is not an issue. Obviously if you hibernate, all pages
are written to disk. You simply shouldn't hibernate while editing a
sensitive document. Anyway, after the previous messages I'm not convident
enough Windows will keep my plaintext off of the disk, not even with
LockNote mentioned by Zach Himsel. So I'll just accept the extra trouble of
grabbing my laptop in case I need the file. I am confident enough that Linux
with crypted swap and partition will keep it safe. I don't want my Windows
partition containing the literal text "Password for root access to important
machine: geheim". Maybe all of it is overkill for my security needs, but
it's not that much trouble. I just remember that time when my FAT root
directory was wrecked, and I recovered schoolwork by searching the whole
partition for a rather unique phrase I remembered having used in the
document :).
Thanks all,

@_date: 2008-06-15 15:43:52
@_author: Peter Lebbing 
@_subject: Remove public key from secret key 
At least with RSA, the public key can be computed with just the secret key.
So it would never be cryptographically secure, it only takes some effort on
the part of the attacker to break the scheme.
I obviously don't know your exact requirements, but instead of trying to
make something designed to be public private, perhaps this will accomplish
your goal:
Create two keypairs, A and B.
The machine mentioned under point 1. above has the public key of keypair A
and the private key of keypair B.
The machine mentioned under point 2. has the private key A and public key B.
The program encrypting on machine 1. encrypts to key A and signs with key B.
The program decrypting on machine 2. only accepts data encrypted to key A
and /signed with key B/.
Now someone with access to the keyring on machine 2. cannot create encrypted
data that is accepted by the decryption program, because he cannot sign it
with key B.
Peter Lebbing.

@_date: 2009-08-14 10:23:39
@_author: Peter Lebbing 
@_subject: Two convicted in U.K. for refusal to decrypt data 
If I read the news report at that link, I see the following:
Neither of whom were necessarily suspects, is the key thing.
Sounds to me like you can also be forced to disclose encrypted information
if it is thought you have incriminating evidence regarding somebody else. If
this interpretation is correct, it goes very, very far.
In The Netherlands, you can be forced to divulge /somebody else's/ password
if they think you know that. The suspect can't be forced. [1]
Still an interesting observation about other people's keys, I think. But
increasingly off-topic for this list. I hope people can still appreciate it.
[1]  (in Dutch)
PS: Yesterday I accidentally sent this only to "the dragon" where I intended
to send it only to the list. Let's try again :)

@_date: 2009-12-18 09:35:08
@_author: Peter Lebbing 
@_subject: cache-timeout not working with smartcard 
I would also like the features requested in this thread: having the card locked
again after a decryption/authentication and the possibility to easily unplug and
replug an ID-000 reader.
 > If you are talking about malware on your box, nothing will help you.
This is also about physical access. If I use the smart card and leave the
workstation for a moment (and forget to lock the card again), somebody can sit
down at my workstation and happily decrypt my gpg files and use ssh to log in to
other systems.
Sure, physical access can cause lots of trouble, but it takes more time and
effort than just typing "ssh interesting-host". I don't feel comfortable about it.
I'm not really convinced about the security of this method anyway. Access
control should be at the card. However, how about powering down _and_up_ the
card after every auth/decrypt? Configurable, of course. That way, PIN entry can
start immediately when the next auth/decrypt turns up, without the delay of
powering up and initialising the card (actually, the delay has been moved to the
moment after the previous use).
PS: I also use the internal CCID driver.

@_date: 2009-11-12 12:06:08
@_author: Peter Lebbing 
@_subject: FSFE Fellower Card + LUKS on Startup 
I hacked this together on Debian squeeze. It might need a little work to get
it working under another distribution. But I did not use LUKS; LUKS is based
on passwords and I use the asymmetric crypto of the OpenPGP card, so I
figured it made more sense to literally store the encryption key in a file
encrypted to the card. I use the cryptsetup package for this (which also
handles the LUKS drives, by the way).
The basic idea is to include the gpg binary and its libraries, especially
libusb-0.1.so.4. The libraries are handled automatically by initramfs-tools,
and most, if not all except for libusb, of the libraries are already in the
default initramfs.
The biggest problem is that gnupg opens /dev/tty and this is not available
in the initramfs. This might actually be a bug in initramfs-tools, I'm not
sure. To hack a fix, I changed gnupg to open /dev/console instead. This is a
hack that will only work in a very limited number of cases, so the binary I
create this way is special-purpose for the initramfs. See the diff[1] below.
I then use the debian build programs to build a .deb, and from that .deb
extract /usr/bin/gpg. I move that binary to
the binary, not a directory).
There are obviously different ways of compiling. I was just hacking
something together and the default Debian binary was fine except for the
binary, without even looking at other ways like a simple "make".
The cryptsetup package uses entries in /etc/crypttab for the encrypted
partitions. I use something like the following entry:
root_crypt /dev/mapper/vg1-root /etc/gpgcryptroot/root.gpg
This should be one line. vg1-root is the LVM logical volume root in volume
group vg1.
Next are the scripts for including and using gnupg in the initramfs. They
are highly initramfs-tools specific. Secondly, they are a little big to
include in this mail, so I uploaded them to [2]. This also includes the diff
mentioned before.
The actual decryption is done by the script /etc/gpgcryptroot/decrypt_gpg.
It does a crude check to see if it is running in the initramfs. If it is
not, it takes a different approach more suitable for activating partitions
from a fully running system instead of the initramfs. I'll come back to that
The script expects a directory with at least the following files:
  A limited public-key ring, containing only the needed key that is on the
  smartcard.
  The limited secret-key ring, again only the needed smartcard key.
  They key to unlock the root. The name is irrelevant (but needs to match
  the /etc/crypttab entry). It is just the literal key material cryptsetup
  expects; 16 bytes for AES-128 as above.
Optionally a gpg.conf could be placed there if it is necessary for gpg to
function correctly.
I placed these files at /etc/gpgcryptroot, together with the script. Please
mind the access permissions on the files and the directory; gpg expects them
to be "secure" and complains otherwise.
The decrypt_gpg script invokes the special-purpose gpg binary, and it asks
for the PIN of the smartcard. The contents of the decrypted key file are
passed to cryptsetup.
The final script glues together the other components with the initramfs. I
derived it from /usr/share/initramfs-tools/hooks/cryptopensc from the
cryptsetup package. It should be placed at
the files pubring.gpg, secring.gpg, root.gpg and optionally gpg.conf are,
and the script copies them to the initramfs. It also copies the
A few final words on which partitions (mount points) can be encrypted with
this hacked-together scheme. The root is the obvious target and the only one
that is somewhat tested. /boot can not be encrypted. This is a fundamental
limitation; unless the BIOS or boot loader can do the decryption, you will
always need something unencrypted to start from. /usr, as a separate
partition, can also not be encrypted without further tweaks, because the
script works either in the initramfs, or in a system with /usr/bin and
possibly more already mounted.
For the system I use it on, everything is in one partition. It's not my
normal workstation but a protected environment to do my super secret
stuff in ;).
The part of the script that does acces to encrypted partitions in a fully
booted system expects gpg to be able to decrypt the file succesfully with
its default settings. In fact, as a horrible kludge, I use "su" to load the
environment normally encountered when root logs in, as environment for gpg
to run in. By default, cryptsetup gives a really limited environment to the
keyscripts, and this was the first I thought of that works.
With "gpg with its default settings", I mean home directory, keyrings, etcetera.
I hope this all is somewhat clear. It is definitely not a step-by-step
HOWTO, requires some Linux skills and is completely not peer reviewed ;).
Good luck,
--- gnupg-1.4.9/util/ttyio.c    2007-10-23 09:55:31.000000000 +0200
+++ gnupg-1.4.9-new/util/ttyio.c        2009-10-05 17:54:25.000000000 +0200
 -106,7 +106,7     /* Assume the standard tty on memory error or when there is no
      ctermid. */
-  return name? name : "/dev/tty";
+  return "/dev/console";
 }

@_date: 2009-09-12 17:38:54
@_author: Peter Lebbing 
@_subject: Does the SCM SCR3320 work with GnuPG? 
Hello list,
Does anybody know if the SCM SCR3320 USB card reader works with GnuPG under
Linux? Specifically, I was thinking of buying the "ChipDrive MyKey 2" from
Conrad[1] in The Netherlands. It's only 20 euros.
If you look at the product page for the SCR3320[2] and compare the photo
with the product page for the MyKey[3], it looks like a different stick. I
hope this is just a change in the housing, because the MyKey description
still says it's the SCR3320.
I want to use it in combination with an OpenPGP v2 card, although I'm also
considering cutting up my v1 card to fit in the SIM size.
I don't think it is relevant, but I'm running Debian Squeeze/testing with
stock kernel and stock gnupg. But this can be changed if necessary, it's
just convenient (I mean the kernel and gnupg can be custom compiled, not
changing the distro).
Thank you for your time,
Peter Lebbing.

@_date: 2009-09-12 19:40:27
@_author: Peter Lebbing 
@_subject: Does the SCM SCR3320 work with GnuPG? 
Great, thanks for the info. One more question, does your reader look like
[1] or like [2]?
I must say I like the supposedly "new housing" ([2]) better than the "old"
one. Swapping cards seems easier and more logical with the new model. The
Conrad links have some more pictures showing how to swap cards.
I totally agree. I like the idea of the separate keypad of, f.e., the SPR532
I have (even though I don't use it currently), but mobility is worth more.
Peter Lebbing.
PS: I accidentally backspaced over the 'l' in '.html' in the link to the
MyKey on the SCM site in the previous mail.

@_date: 2009-09-13 13:51:15
@_author: Peter Lebbing 
@_subject: Does the SCM SCR3320 work with GnuPG? 
I've just ordered the MyKey with the new model card reader. I'll report
whether it works when I have it.

@_date: 2009-09-16 15:11:58
@_author: Peter Lebbing 
@_subject: Does the SCM SCR3320 work with GnuPG? 
Well, bit of a disappointment, but hopefully it can be fixed. It turned out
that the reader included with the new model MyKey is the SCT3511. It seems
like a nice device: it can also support hybrid cards and be used as a
contactless token when not plugged in.
However, it does not work error free with GnuPG (Debian version 1.4.9-4).
- Basic access works
- Changing cardholder name works
- Command "verify" works
- Changing Admin PIN works
- Changing "user" PIN FAILS
- Anything involving RSA keys FAILS
As soon as a command has failed, the only way to talk to the reader(/card)
again is by unplugging and replugging. I have not tried removing the card
from the reader while the reader is plugged in.
Could a GnuPG dev please have a look at the debug logs? I believe Werner
does the card stuff, right? I really hope this reader can be made to work
with GnuPG.
It reports itself as (lsusb):
04e6:5116 SCM Microsystems, Inc. SCR331-LC1 SmartCard Reader
Linux recognises it as a "SCR3310 v2.0 USB SC Reader", so I suppose they
share the USB ID's.
I created a test key on the card, and used it both in the perfectly working
SPR532 as well as in the SCT3511. The PIN is 12345678 (as can be seen in the
debug log, if you know where to look :).
I encrypted a test file to the encryption subkey on the card. I have
included debug logs for both card readers attempting decryption. This is not
one of my smallest posts to this group, but I think it's just within
acceptable ranges :). If I'm mistaken, I'll put files on a website from now on.
The test key has the following properties:
pub   1024R/D75DDA31 2009-09-16
uid                  Test Test sub   1024R/CAAB1A36 2009-09-16
sub   1024R/40DC2931 2009-09-16
When decrypting with the non-working SCT3511 reader, gpg --debug-ccid-driver
-d test.asc produces the following debug output:
gpg: DBG: ccid-driver: using CCID reader 0 (ID=04E6:5116:X:0)
gpg: DBG: ccid-driver: idVendor: 04E6  idProduct: 5116  bcdDevice: 0204
gpg: DBG: ccid-driver: ChipCard Interface Descriptor:
gpg: DBG: ccid-driver:   bLength                54
gpg: DBG: ccid-driver:   bDescriptorType        33
gpg: DBG: ccid-driver:   bcdCCID              1.10  (Warning: Only accurate
for version 1.0)
gpg: DBG: ccid-driver:   nMaxSlotIndex           0
gpg: DBG: ccid-driver:   bVoltageSupport         7  ?
gpg: DBG: ccid-driver:   dwProtocols             3  T=0 T=1
gpg: DBG: ccid-driver:   dwDefaultClock       4800
gpg: DBG: ccid-driver:   dwMaxiumumClock      8000
gpg: DBG: ccid-driver:   bNumClockSupported      0
gpg: DBG: ccid-driver:   dwDataRate          12903 bps
gpg: DBG: ccid-driver:   dwMaxDataRate      412903 bps
gpg: DBG: ccid-driver:   bNumDataRatesSupp.      0
gpg: DBG: ccid-driver:   dwMaxIFSD             252
gpg: DBG: ccid-driver:   dwSyncProtocols  00000000
gpg: DBG: ccid-driver:   dwMechanical     00000000
gpg: DBG: ccid-driver:   dwFeatures       000101BA
gpg: DBG: ccid-driver:     Auto configuration based on ATR
gpg: DBG: ccid-driver:     Auto voltage selection
gpg: DBG: ccid-driver:     Auto clock change
gpg: DBG: ccid-driver:     Auto baud rate change
gpg: DBG: ccid-driver:     Auto PPS made by CCID
gpg: DBG: ccid-driver:     CCID can set ICC in clock stop mode
gpg: DBG: ccid-driver:     TPDU level exchange
gpg: DBG: ccid-driver:   dwMaxCCIDMsgLen       271
gpg: DBG: ccid-driver:   bClassGetResponse    echo
gpg: DBG: ccid-driver:   bClassEnvelope       echo
gpg: DBG: ccid-driver:   wlcdLayout           none
gpg: DBG: ccid-driver:   bPINSupport             0
gpg: DBG: ccid-driver:   bMaxCCIDBusySlots       1
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 3B FA 13 00 FF 81 31 80 45 00 31 C1 73 C0 01 00 00 90 00 B1
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 01
               data: 11 10 FF 45 00 80 00
gpg: DBG: ccid-driver: GetParametes returned 82 07 00 00 00 00 02 00 00 01
11 10 FF 45 00 80 00
gpg: DBG: ccid-driver:   protocol ..........: T=1
gpg: DBG: ccid-driver:   bmFindexDindex ....: 11
gpg: DBG: ccid-driver:   bmTCCKST1 .........: 10
gpg: DBG: ccid-driver:   bGuardTimeT1 ......: FF
gpg: DBG: ccid-driver:   bmWaitingIntegersT1: 45
gpg: DBG: ccid-driver:   bClockStop ........: 00
gpg: DBG: ccid-driver:   bIFSC .............: 128
gpg: DBG: ccid-driver:   bNadValue .........: 0
gpg: DBG: ccid-driver: sending 61 07 00 00 00 00 03 01 00 00 11 10 FF 45 00
80 00
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 01
               data: 11 10 FF 45 00 80 00
gpg: DBG: ccid-driver: sending 6F 05 00 00 00 00 04 00 00 00 00 C1 01 FC 3C
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 00 E1 01 FC 1C
gpg: DBG: ccid-driver: IFSD has been set to 252
gpg: DBG: ccid-driver: sending 6F 0F 00 00 00 00 05 04 00 00 00 00 0B 00 A4
04 00 06 D2 76 00 01 24 01 2D
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 00 00 16 6F 12 84 10 D2 76 00 01 24 01 01 01 00 01 00
00 08 9B 00 00 90 00 7D
gpg: DBG: ccid-driver: sending 6F 09 00 00 00 00 06 04 00 00 00 40 05 00 CA
00 4F 00 C0
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 00 40 12 D2 76 00 01 24 01 01 01 00 01 00 00 08 9B 00
00 90 00 D0
gpg: DBG: ccid-driver: sending 6F 09 00 00 00 00 07 04 00 00 00 00 05 00 CA
00 C4 00 0B
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 00 00 09 01 FE FE FE 03 03 03 90 00 65
gpg: DBG: ccid-driver: sending 6F 09 00 00 00 00 08 04 00 00 00 40 05 00 CA
00 6E 00 E1
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 00 40 C4 4F 10 D2 76 00 01 24 01 01 01 00 01 00 00 08
9B 00 00 73 81 9D C0 01 78 C1 05 01 04 00 00 20 C2 05 01 04 00 00 20 C3 05
01 04 00 00 20 C4 07 01 FE FE FE 03 03 03 C5 3C 0A 70 A5 C5 B3 46 D2 1D DD
1B D5 EB 0F BC C6 E2 D7 5D DA 31 20 E2 BB 7D 50 8D C1 2F 83 5B 0C 20 2E FB
7A D3 40 DC 29 31 37 1E 37 7B 43 4A 27 A1 CF E1 B9 44 86 08 9C 6C CA AB 1A
36 C6 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 CD 0C 4A B0 C9 08 4A B0 C9 7C 4A B0
C9 52 5E 00 90 00 C6
gpg: DBG: ccid-driver: sending 6F 09 00 00 00 00 09 04 00 00 00 00 05 00 CA
00 5E 00 91
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 00 00 02 90 00 92
gpg: DBG: ccid-driver: sending 6F 09 00 00 00 00 0A 04 00 00 00 40 05 00 CA
00 6E 00 E1
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 00 40 C4 4F 10 D2 76 00 01 24 01 01 01 00 01 00 00 08
9B 00 00 73 81 9D C0 01 78 C1 05 01 04 00 00 20 C2 05 01 04 00 00 20 C3 05
01 04 00 00 20 C4 07 01 FE FE FE 03 03 03 C5 3C 0A 70 A5 C5 B3 46 D2 1D DD
1B D5 EB 0F BC C6 E2 D7 5D DA 31 20 E2 BB 7D 50 8D C1 2F 83 5B 0C 20 2E FB
7A D3 40 DC 29 31 37 1E 37 7B 43 4A 27 A1 CF E1 B9 44 86 08 9C 6C CA AB 1A
36 C6 3C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 CD 0C 4A B0 C9 08 4A B0 C9 7C 4A B0
C9 52 5E 00 90 00 C6
gpg: DBG: ccid-driver: sending 6F 11 00 00 00 00 0B 04 00 00 00 00 0D 00 20
00 82 08 31 32 33 34 35 36 37 38 AF
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 00 00 02 90 00 92
gpg: DBG: ccid-driver: sending 6F 11 00 00 00 00 0C 04 00 00 00 40 0D 00 20
00 81 08 31 32 33 34 35 36 37 38 EC
gpg: DBG: ccid-driver: status: 00  error: 00  octet[9]: 00
               data: 3B FA 13 00 FF 81 31 80 45 00 31 C1 73 C0 01 00 00 90 00 B1
gpg: DBG: ccid-driver: T=1 S-block response received cmd=26
gpg: ccid_transceive failed: (0x1000a)
gpg: apdu_send_simple(0) failed: card I/O error
gpg: verify CHV1 failed: general error
gpg: encrypted with 1024-bit RSA key, ID 40DC2931, created 2009-09-16
      "Test Test "
gpg: public key decryption failed: general error
gpg: decryption failed: secret key not available
gpg: DBG: ccid-driver: status: 01  error: 00  octet[9]: 01
               data:

@_date: 2009-09-17 00:00:00
@_author: Peter Lebbing 
@_subject: Does the SCM SCR3320 work with GnuPG? 
Hey, that's odd. I'm 100% sure I mentioned it was a v1 card. Must have
deleted that when I rewrote a part for clarity (the irony :).
It is a cut-up v1 card to fit in the ID-000 (SIM card) size. My v2 card is
on back order.
Since I'm replying anyway, let me mention two more things:
1) It is not always necessary to remove and re-insert the reader and card
after an error. Not sure when it is and isn't.
2) The data sent in error by the card when a "VERIFY" command is given for
the failing operations is the ATR response for the OpenPGP card. It's been
quite a while since I had a look at ISO 7816 based things, but I did notice

@_date: 2009-09-21 18:58:27
@_author: Peter Lebbing 
@_subject: Getting the SCM SCT3511 to work 
In a previous message [1] in the thread named "Does the SCM SCR3320 work with
GnuPG?", I wrote that gnupg with Debian version 1.4.9-4 cannot use an OpenPGP v1
card in the SCT3511 reader. I've installed Debian version 1.4.10-1 from
unstable, and it seems there is no change in the situation.
I did however discover something rather important. Just once in a while,
decryption with the card will actually work!
Always when the decryption fails, it is because the card sends its ATR instead
of the requested data.
It seems that most of the time decryption fails when the PC tries to read the
plaintext from the card after the card has reported succes for the issued PSO:
DECIPHER command.
Somewhat less frequent the card will send its ATR after the VERIFY CHV1 command.
And even less frequent it just works.
The mailing list complained about the length of my message, so I put the debug
logs on the web.
This is the debug log for when decryption is succesful:
This is the debug log for when it fails after PSO: DECIPHER:
This is the debug log for when it fails after VERIFY CHV1:
Oh, BTW, I changed the PIN on the test card to 123456 instead of the longer
12345678 used before.
Thanks for your time,
[1]

@_date: 2010-08-05 13:25:38
@_author: Peter Lebbing 
@_subject: Importing/Merging (secret) subkey into existing secret key 
Hash: SHA1
I managed to do this with gpgsplit and recombining. I'm doing this under Linux;
commands for other OSes might differ. Please read the whole mail before starting.
On one machine, I have a key with 2 encryption subkeys, let's say A and B. I
then use these commands:
$ mkdir key1
$ cd key1
$ gpg --export-secret-keys  | gpgsplit
Here, the $ sign simply indicates I type it at the prompt, a common convention.
Don't actually include the $. Replace  with your... keyid, indeed :).
If I now do a listing of the files in this directory, I see the following:
$ ls
000001-005.secret_key  000002-013.user_id  000003-002.sig
000004-007.secret_subkey  000005-002.sig  000006-007.secret_subkey  000007-002.sig
(sorry for the layout)
These files are the parts that together make up your whole key. Filenames are a
sequence number (increasing), and after the dash the packet type. The packet
type in human readable form is after the dot.
An explanation:
The primary key.
The user id.
The signature binding user id and specifying preferences.
The first secret subkey, encryption key A.
Signature binding A to the primary key.
The second secret subkey, encryption key B.
Signature binding B to the primary key.
You can het more information on these packets with, f.e.:
$ cat * | gpg --list-packets
This will list details about the packets, /in the same order/ as the files. Just
Now, on the second machine I have the same key, only unfortunately it has
encryption subkeys A and C. That is, on the first machine I miss key C and on
the second machine I miss key B.
I start out the same on the second machine:
$ mkdir key2
$ cd key2
$ gpg --export-secret-keys  | gpgsplit
The files created will in this case actually have exactly the same names as
described above. The big difference is the contents of the last two files:
Encryption subkey /C/
Signature binding /C/ to the primary key.
Unfortunately, gpg --list-packets does not list the key id's for key packets.
But it does list creation date (in UNIX time format) and expiration date. You
can use these numbers to match up which keys you want to combine. No need to
understand UNIX time format, just match up numbers so that you end up with all
unique subkeys together. You can always throw out unneeded ones later using GnuPG.
Now we want to have subkey C on the first machine. Assuming you've copied the
directory key2 and its contents to the first machine, you can do this:
$ cp key2/000006-007.secret_subkey key1/000008-007.secret_subkey
$ cp key2/000007-002.sig key1/000009-002.sig
Actually, the names are not very important, as long as they are in the same
sorting order as here. I chose to continue the naming GnuPG itself uses.
Now directory key1 has the full key: primary key, and subkeys A, B and C. These
can be combined to form the full key:
$ cd key1
$ cat * >secret_key.gpg
The difficulty you initially ran into is that GnuPG will not import a key it
already has in the keyring, even if the subkeys are different. So after making a
backup of everything, you delete the key already in the keyring. I suggest
making the backup before even starting all this, to avoid disasters if you got
something wrong.
So on both machines, we do:
$ gpg --delete-secret-and-public-keys $ gpg --import secret_key.gpg
The file secret_key.gpg is what we created in the previous step.
You should now have the full key on both systems.
I hope /I/ didn't do something wrong here, but the backup you made saves you
from disasters in that case.
Note 1: If this is too cryptic, you should not just type in what I say. You need
to understand commands you enter at the prompt, not blindly type in what some
stranger on the internet says. Just ask for more info.
Note 2: I strongly suggest setting the passphrase the same on the two systems,
or you'll run into funny behaviour when it prompts for the passphrase of your
new combined key. You might even want to "change" the passphrase after the
import of the whole key, but change it to the same passphrase you already had. I
won't go into the details, but this will make the key consistent with how GnuPG
normally stores encrypted keys. I don't think GnuPG was ever meant to support
the interesting combining of encrypted keys we do here, even though it works.
On a sidenote, I think it would be cool if GnuPG, on --import, inspected all
subkeys and user id's in a key individually, and add any that are missing. I
think such functionality is useful and intuitive. Perhaps I should create a
feature request ticket.
Good luck,

@_date: 2010-01-04 12:53:21
@_author: Peter Lebbing 
@_subject: How to use an "offline" primary key 
AFAIK, GnuPG will take the first version of the key it finds. The first version
of the key (primary and subkeys) is in your default keyring, with only a stub
You could try something like
--no-default-keyrings --secret-keyring secring2.gpg --public-keyring
pubring2.gpg --secret-keyring secring.gpg --public-keyring pubring.gpg
where secring.gpg/pubring.gpg are your default keyrings.
By exchanging the order of the keyrings, hopefully this will mean it looks for
the key in secring2.gpg first, where the primary key is included too.
I haven't tried it myself, though.
Good luck,

@_date: 2010-06-10 18:42:13
@_author: Peter Lebbing 
@_subject: Keyserver spam example 
Which RFC would this be?
I could not find the word "dynamic" in RFC 2822 (proposed standard) or RFC 5322
(draft standard, obsoletes 2822). The most basic mailserver, AFAIK, only has to
comply to this standard to be acceptable as a mailserver operating in the real
A Google search also did not help finding this standard.
It also begs the question how to define "a dynamic IP" in a manner worthy of an
RFC wanting to be a standard, which was one of the reasons I wanted to find the
RFC you mention.
Meanwhile, in the real world, people do not always comply to all RFC's. If you
define "legitimate mail" as "mail you'd like to receive" or "not spam" or
something similar, you will lose legitimate mail.
These days my mail server is on a static IP (on a consumer connection). With a
previous ISP, this was not possible, and my mail server had a dynamic IP. I
happily sent legitimate mail to my contacts from it.

@_date: 2010-10-08 10:21:51
@_author: Peter Lebbing 
@_subject: batch file automation -Nearly There! 
Hash: SHA1
It's been a while since I've written any sort of Windows batch scripting, but
looking at the rest of the statements, it seems the output should be specified
as %%F.pgp, not %F.pgp, and that is why you end up with a file called f.pgp (the
% is dropped as an escape char). The fact you don't specify an input file causes
the f.pgp file not to contain anything useful.
So probably it should read
ECHO bingos| GPG --batch -se --passphrase-fd 0 -r PGPTOKEY -o
"C:\encryptedfiles\%%F.pgp" %%F
Furthermore, it is almost always a better idea to drop the passphrase from the
key than to specify the passphrase in some file. In this specific case,
depending on your OS, the "echo bingos" might even show up in the process list
for any user of the machine to read. At least the secret keyring should be
protected by file permissions so only you and the superuser can read it.
Best to avoid a false sense of security by having a passphrase on a key and that
passphrase in plain text on your disk, and just remove the passphrase
altogether. That's usually the price to pay for automated signing. Only much
more elaborate setups can provide extra security in such a case.
Then again, I'm not a security expert.
You could create a signing key especially for this purpose and label it
"(Automated Signing Key)" for clarity. And another signing key that is
passphrase protected and use that when you yourself explicitly sign some document.
Good luck,

@_date: 2010-09-01 11:17:25
@_author: Peter Lebbing 
@_subject: Why do smart cards have a 'sex' option? 
My guess is it is to address the user correctly in dialogs, in some languages.
The sex of the person addressed might determine the grammatical gender of words
used in dialogs. I've forgotten which languages have this feature, but I'm
pretty sure there are such languages.

@_date: 2011-04-01 21:44:21
@_author: Peter Lebbing 
@_subject: Hi 
You seem to be inferring that the high number of hacked Google accounts is
due to the high number of Google accounts, which would not support your
apparent theory that it is because of the insafety of a Google account. But
that is beside the point, although it might make Rob slightly happier.
That was all just in good fun, I don't want to start bickering about it.
But why in [insert deity of choice]'s name do you think Google had anything
to do with a hacked hotmail.co.uk account? I receive this mailing list in
digest form, and though I immediately curiously tried to access the full
headers for the last few messages from Lee, I (re)discovered the mailing
list sadly scrubs away all the nice headers. Doesn't it scrub when you
select another delivery mode, and did you see a Google header there? And why
does that make you sure the hack itself was through a Google service?
In all honesty, I think your jumping conclusions. But I'm curious what made
you jump.
PS: I would also like it if common courtesy was applied instead of
exchanging feces in the name of one company for dollar signs in the name of
another. I'm not offended by it, just annoyed. For the record, I'm no fan of
either company.

@_date: 2011-08-04 17:14:30
@_author: Peter Lebbing 
@_subject: Extract numbers from a key 
And suppose GnuPG accidentally picked a composite. What would be the security
implications of that? I am supposing that the adversary does *not* know your key
isn't actually based on 2 primes.
As far as I can see, there would be a few messages that would be corrupted when
encrypted to this key, because it turns out the message is not co-prime with a
factor of the key. If this is a possibility in practice, I don't know. It would
depend on the padding of the session key and which numbers that can lead to for
the RSA operation. But I don't really know if it becomes easier to extract the
private part from the public key, as long as the attacker does not know a
composite was used.
If it is known that a certain piece of software often accidentally produces
composites, you could account for this in your cracking software and indeed gain
an advantage, I think.
I'm even thinking it might be *harder* to factorize the public key because the
attacker expects a number with two prime factors and dismisses the possibility
of one of the "factors" being composite ;D. This is somewhat tongue-in-cheeck,
but it might have a grain of truth to it.
By the way, on a related subject: I suppose the padding scheme is chosen in such
a way that the message is never a multiple of one of the primes of the key?
Because I suppose in that case the message would be corrupted, as it is not
co-prime with n?

@_date: 2011-08-04 17:22:49
@_author: Peter Lebbing 
@_subject: Extract numbers from a key 
Let's not forget the bug in the Debian OpenSSL package that limited the key
generation to about 2^15 keys.
Backdoors aren't limited to software where the source is not available. It can
be subtly done so it won't be discovered. It's not always:
if (knock)
  execve ("/bin/bash", ...

@_date: 2011-08-04 20:30:57
@_author: Peter Lebbing 
@_subject: Extract numbers from a key 
I'm pretty sure there is only one inverse given n and e, that is, d is unique.
Accidentally choosing the wrong d because you made an algorithmic/programming
error will create a non-working keypair. I'd say, since it works, it is correct.
Perhaps the better question is: *why* does it work? Why are the operations

@_date: 2011-08-04 20:48:39
@_author: Peter Lebbing 
@_subject: Extract numbers from a key 
Hmmmm. Per the Handbook of Applied Cryptography 5th ed[1], section 8.5,
computation of d can also be done modulo lambda, with
lambda = lcm(p-1,q-1) = (p-1)(q-1)/gcd(p-1,q-1)
So that answers your question. I'd hazard it's safe :).
I also found the answer to my own question in section 8.3. It does not matter if
the message and p or q are not co-prime, the equivalency still holds.
Which goes to show, when you have a question about cryptography, it's a good
idea to consult the HAC first :).
[1]

@_date: 2011-08-05 10:59:28
@_author: Peter Lebbing 
@_subject: Card only available to root user 
Look closely at the permissions for Debian. It has a plus-sign. This means there
is an ACL. Probably ConsoleKit is adding you to the ACL when you log in.
You can get the ACL with getfacl. Here is the output from my box:
peter at tweek:~$ getfacl /dev/bus/usb/008/004
getfacl: Removing leading '/' from absolute path names
# file: dev/bus/usb/008/004
# owner: root
# group: pcscd
Note how user peter has read/write as well.
However, I've been fighting with access rights to the cardreader as well, so
please don't take this as correct. In fact, the whole pcscd group business
stopped working for me at some point, oddly enough. Some Debian update
conflicted with my own tinkering in udev.

@_date: 2011-08-06 18:40:46
@_author: Peter Lebbing 
@_subject: Card only available to root user 
Unfortunately, I don't know much, hardly anything, about ConsoleKit and friends.
I suppose it is related to the following snippets out of the following files:
ATTR{idVendor}=="04e6", ATTR{idProduct}=="5115", ENV{ID_SMARTCARD_READER}="1",\
# smart-card readers
ENV{ID_SMARTCARD_READER}=="*?", TAG+="udev-acl"
# apply ACL for all locally logged in users
TAG=="udev-acl", TEST=="/var/run/ConsoleKit/database", \
  RUN+="udev-acl --action=$env{ACTION} --device=$env{DEVNAME}"
Here I picked a somewhat random vendor/product-id that is matched in the first
file. You might need a lot more configuration to get it working, I don't know.
By the way, I added the \ in the snippet from the first file, but not in the
second; that one was already there.
Good luck,

@_date: 2011-08-14 13:26:26
@_author: Peter Lebbing 
@_subject: Extract numbers from a key 
I still think this is an interesting academic question. Does anybody have some
insight to offer on this?
The conditions as I envision them are:
- An OpenPGP implementation uses heuristic methods to determine if the numbers
used in key generation are prime. I.e., there is an (extremely small) chance of
accidentally picking a composite number.
- The adversary doesn't know whether the implementation has a higher than normal
chance of accidentally picking composites.
- The adversary is trying to solve the RSA problem for a key where key
generation accidentally used a composite where a prime was intended.
Will the adversary likely have a better chance of solving the RSA problem
because key generation went "wrong"?
The reason for this scenario, is that I suppose that GnuPG uses heuristics as
mentioned above, and that there are no known weaknesses in these heuristics.
That is, either they have no weaknesses, or nobody has found them yet. So you
can't use knowledge of the weaknesses in your attack.
Again, this is purely academic. I won't push for GnuPG to adopt deterministic
PRIME algorithms or something :). I just wonder.

@_date: 2011-08-14 14:05:02
@_author: Peter Lebbing 
@_subject: Extract numbers from a key 
Yes [1], but it depends on your search space (and the route through it). You are
trying to find two 1024 bits long primes, not shorter ones.
The most na?ve method would be:
pick a 1024-bit random number a
pick a 1024-bit random number b
n = a*b? yes -> done!
  no -> again
Now, there is no reason why you would find 'a' quicker if a were composite. It's
still just one of those 1024-bit long random numbers. This na?ve method doesn't
use the fact that a and b are prime at all.
If, however, you *know* 'a' is composite, you can speed up, yes. But you do not
By the way, if 'a' is composite, there is nothing which says that it has ~512
bit prime factors. The degenerate case is a 1023-bit prime times two :).
Or harder :).
I have also learned a piece of the underlying mathematics, but it is long enough
ago that I happily postulate that I'm pretty sure that given n and e, d can only
be one value. And then I grab the Handbook of Applied Cryptography and learn
that you can use both phi and lambda to determine it, and lambda might give a
smaller d. Which obviously means d is not unique. And that I'm wrong.
[1] Actually, a 1024-bit RSA key is considered secure, and that consists of two
512-bit primes. Now, a 512-bit RSA key, yes, those are crackable, but not
512-bit primes. But it's the thought that counts, not the actual numbers, so
this is just a footnote.

@_date: 2011-08-15 11:06:53
@_author: Peter Lebbing 
@_subject: Extract numbers from a key 
Or, equivalently, looking through full 512 bit space takes the same amount of
time as checking all numbers between 2^513 and 2^514. It's exactly the same
thing, with a 1 tacked on at the end. I don't understand what significance 2^525
I'm not sure I follow.
You propose to check for the public modulus not being a semiprime when trying to
solve the RSA problem, because this will only take a fraction of the time needed
for subsequently solving it when p and q are prime?
I wonder if that will pay off. I just don't know. It's one of the possible
answers to my original question. If it pays off, it means that, yes, the
adversary has a better chance to solve the RSA problem if p or q is composite,
because the adversary could first check for this possibility "just in case", as
you put it.

@_date: 2011-12-01 11:11:13
@_author: Peter Lebbing 
@_subject: Possible IPv6 bug for --keyserver option 
Ah, okay. I figured this was not the case because his interfaces don't even have
link-local autoconfigured addresses. I thought those would be active as soon as
you enable IPv6.
Check. None of my machines do without :).
Anyway, GnuPG can't help what the library and OS do.

@_date: 2011-12-17 15:02:04
@_author: Peter Lebbing 
@_subject: keyserver spam 
The key property "keyserver no-modify" is meant to allow people to specify that
only they can change the key. However, this needs crypto in the keyserver
network and the solution to some practical problems. So it currently doesn't work.
You're not the first to think about the problem, and there was even acted upon.
However, there are key pieces missing in the puzzle before it works. Keyserver
synchronization is the biggest obstacle, I believe.
In the mean time, if somebody uploads offensive and spammy signatures, be
offended by the uploader, not by the person whose key is signed.
"--edit-key clean" will remove the cruft you don't need.
"--import-options import-clean" can be useful as well.

@_date: 2011-12-17 15:07:21
@_author: Peter Lebbing 
@_subject: keyserver spam 
Yet, so far so good (in general). And the infrastructure has existed for quite
some years already.
OpenPGP might never become popular enough to attract childish people to the
keyserver network :). I certainly hope it will become popular, but spending a
I think that time is better spent on deducing ways to make it popular! STEED
perhaps? Funny detail is, STEED doesn't use the keyserver network!

@_date: 2011-01-18 12:37:11
@_author: Peter Lebbing 
@_subject: gpg command output language??? 
The manual at [1] is, as far as I can see at a glance, largely the same as the
gpg2 man page. A lot of your questions so far could have been answered by
reading that manual.
Also, you could fetch and unpack the source for GnuPG. It is bound to contain a
lot of documentation for you as the developer of a new frontend, although a lot
of the documentation will be there only in source format, not as the man pages
or HTML files that would be generated from that source format.
[1]

@_date: 2011-07-20 21:48:50
@_author: Peter Lebbing 
@_subject: Where are those stubs.. 
AFAIK, you need to get the public key imported in GnuPG before you do
--card-status. So you first download your own public key from a keyserver or a
website or a USB stick, you don't get it from the smartcard. Only when GnuPG
already has the public key, will it create the secret key stubs when it sees
your smartcard.
Good luck,

@_date: 2011-07-28 21:46:08
@_author: Peter Lebbing 
@_subject: Including public key 
yuuz? That's where I draw the line. This mailing list is for communication, not
showing your "1337 skillz". So please communicate in a way where I don't have to
read every other sentence twice to get what you are trying to tell us.
PS: At first I wondered if you had an interesting variant of dyslexia :).
Perhaps quite the opposite of your intention.

@_date: 2011-11-01 13:37:16
@_author: Peter Lebbing 
@_subject: How to get the list of all keys to which the file has 
$ gpg --search-keys DE6CDCA1
gpg: searching for "DE6CDCA1" from hkp server pool.sks-keyservers.net
(1)     Peter Lebbing           2048 bit RSA key DE500B3E, created: 2009-11-12
Yup, searching for subkeys works.

@_date: 2011-11-01 13:51:29
@_author: Peter Lebbing 
@_subject: small security glitches 
In that case, I find it to be phrased very awkwardly.
Encryption provides encryption: people can't see what is in it. Period.
Signing provides a form of integrity: people can see that the signer attests
that the data is correct in some way.
So how is it a security glitch that encryption does not provide trust? It is a
glitch in someone's thinking to think that it does. PEBKAC. The advice to also
sign is sound, the absolute "you should always" is overdoing it, IMHO.
Personally, I was more thinking along the lines of the reasons to introduce the
MDC. Can't remember off the top of my head how that all pieced together.
In that case it might be useful to revise the text to say a few words on MDC's.

@_date: 2011-11-01 15:47:08
@_author: Peter Lebbing 
@_subject: GnuPG decryption problem 
That is the exact same error message you would get when you simply enter an
incorrect passphrase. The file might be damaged, or you might have misunderstood
the sender (that is, you actually enter the wrong passphrase).
If the passphrase contains "special" symbols (umlauts, c-cedillas, anything
other than letters, numbers, spaces and a few symbols), you might have a problem
with entering those, though. That is something that doesn't always work
correctly out-of-the-box. And which is beyond my expertise, by the way.
The website you mentioned earlier on installing the gnupg command line tool
without using GPG4Win calls their method "the proper way to install the GnuPG in
a modern Windows environment". I respectfully disagree, usually the proper way
described on that site is appropriate, but not for day-to-day use. I think
you'll be better off with GPG4Win.
Good luck,
PS: The following table could be useful. It's a list of symbols that I think
shouldn't give problems when entering those. If one of the symbols in your
passphrase is not in this table, you might have a "language issue" that prevents
you from entering that symbol in the passphrase.
  0 @ P ` p
! 1 A Q a q
" 2 B R b r
# 3 C S c s
$ 4 D T d t
% 5 E U e u
& 6 F V f v
? 7 G W g w
( 8 H X h x
) 9 I Y i y
* : J Z j z
+ ; K [ k {
, < L \ l |
- = M ] m }
. > N ^ n ~

@_date: 2011-11-12 18:18:38
@_author: Peter Lebbing 
@_subject: Signing already-encrypted files (all to self)? 
I think it was someone else (carrying an USB stick with a lot of individually
encrypted files) who mentioned disliking Truecrypt for their purpose.
For backups, you can get away without resorting to homomorphic encryption and
still have a small data transfer from live system to backup, at the cost of a
lot of sequential disk I/O at both sides.
In Truecrypt, only changing information changes (or rather, the sector or block
containing it). So if you have no problem with f.e. rsync doing rolling
checksums to find the parts that have changed, the actual data transfer will
still be rather small. But the rolling checksums are of course much more
intensive than a simple metadata check of each individual file, which is
probably what your setup does with individually encrypted files.

@_date: 2011-11-14 15:42:58
@_author: Peter Lebbing 
@_subject: Signing already-encrypted files (all to self)? 
The following is just a sketch, I'm not completely checking if I do it right.
find maildir/ -not -name '*.gpg' \
  -execdir gpg -r you -o '{}.gpg' -e '{}' ';' \
  -execdir gpg --print-md SHA256 '{}.gpg' ';'
The trick obviously is that find can do multiple executions. I didn't know this
either, I just tried it out :). There are different variations. This one outputs
the hashes on stdout, and I don't know a way to separate the stdout's, for when
the encryption command would start printing stuff on stdout.
But a different variation is to define a helper program (called do_gpg):
--8<----------(cut here)---------->8--
gpg -r you -o "$1.gpg" -e "$1"
gpg --print-md SHA256 "$1.gpg" >>sha256sums
--8<----------(cut here)---------->8--
and then:
find maildir/ -not -name '*.gpg' \
  -execdir do_gpg '{}' ';'
As a third variation, you could only define a helper program to do the
checksumming, and have two -execdir arguments to find.
Note that piping the output from find like you write gives issues with filenames
with special characters (space, newline, etcetera), but that might not be a
problem for you.
And also note that encrypting identical plaintexts will lead to different
ciphertexts, and hence, hashes. If you sometimes re-encrypt the same data, you
need to be aware of this or you'll think your files have been tampered with
because the hash no longer checks out.

@_date: 2011-11-17 22:36:12
@_author: Peter Lebbing 
@_subject: GPA File Manager 
notice the quote below is quoting yet someone else; it is not Sartoretti who
recommended GPGshell.

@_date: 2011-11-30 20:25:09
@_author: Peter Lebbing 
@_subject: Possible IPv6 bug for --keyserver option 
I also find the error message from curl somewhat misleading, although
technically correct. I would prefer not to see any IPv6 stuff when it is totally
not configured. I would in that case even prefer not to see a lookup for AAAA,
it is a waste of resources.
If you don't have IPv6, do you consider it unreachable or unavailable, that's
what it partly boils down to.
Do we need error messages for all the things a library /supports/, or only for
those things we have /available/ on our system? It is only confusing to a user
to see messages relating to something they might never have heard of. This time
it's IPv6, next time it's IPSec, then cool-extension-X... so the library should
only return errors relevant to the actual system, so the program using the
library can give relevant information to the user.

@_date: 2011-10-01 20:45:14
@_author: Peter Lebbing 
@_subject: kernel.org status: establishing a PGP web of trust 
But you need a good PRNG for generating the session key, which is a lot more
important than the CFB IV.
But when it comes to signing stuff, not encryption, I suppose you can indeed use
RSA without a good PRNG.
The Debian OpenSSL debacle, however, rendered every DSA key *used* on such a
system useless, whereas RSA was only compromised when the key was *generated* on
such a box.
Personally, I see it as an advantage of RSA that using it with a poor PRNG
doesn't disclose your private key, but it wouldn't stop me from using ECDSA when
it is mainstream. Your PRNG simply shouldn't be bad when you do crypto.
Obviously software bugs can always happen, and in the specific Debian OpenSSL
instance it was worse for DSA, but the next big bug might by chance hurt RSA and
leave DSA in the clear.
And we have DSA to thank for the fun of Sony's silly mistake! :)

@_date: 2011-10-05 11:21:14
@_author: Peter Lebbing 
@_subject: restoring SmartCard key with off-card copy 
IMHO, if you want to have a backup that also allows you to use the key without
the card, the following procedure is by far the easiest:
- Create a normal RSA key (gpg --gen-key)
- Back it up in a safe place, run it through paperkey, all the usual steps
- From gpg --edit-key, use the keytocard command.
Now you have the key on the card, and the secret key material that was in your
secret keyring is replaced by a stub that points to the smartcard. So the secret
key material is no longer in the keyring.
AFAIK, if you create a smartcard key with backup file, this is pretty much
equivalent: the key is created off-card by GnuPG, and uploaded to the card. Only
when you choose the option to create a smartcard key without backup file will it
get generated on card. I concluded this from reading the OpenPGP Card spec: I
don't see a possibility to generate an on-card key and have the secret key
material for the backup file, so the only possibility I see is that the key is
generated by GnuPG and then uploaded to the card.
PS: I accidentally hit the wrong "reply" button and sent this mail only to
Faramir. So this is a copy to the list.

@_date: 2011-10-05 13:35:40
@_author: Peter Lebbing 
@_subject: restoring SmartCard key with off-card copy 
Apart from hard drives there's the backup in a safe.
And what about encrypted data? If your card fails, you have then simply lost all
data. The only options are backups, a second card, or multiple recipients of the
encrypted data. All are variations of a theme (multiple somethings) that do not
satisfy Laurent's "one man"/"one card".
So if the loss of all your encrypted data is an acceptable risk, then you can do
the "one card" thing. Otherwise, you'll have to compromise somewhere else.

@_date: 2011-10-06 17:40:29
@_author: Peter Lebbing 
@_subject: restoring SmartCard key with off-card copy 
A bit odd. I hope it will not give problems. My suggestion: let the card
generate a new signature key (you don't need to use it if you don't want to).
Apart from that GnuPG might get confused by the key being used in two positions,
there are security reasons why we use different signature and encryption keys,
instead of one key for both. Might open you up to some subtle attack, if your
attacker knows what he's doing. Probably unlikely, but better safe than sorry.
Oh, by the way, it's GnuPG, not PGP. PGP is a commercial product supporting the
OpenPGP standard. GnuPG is the libre software you're using with your OpenPGP
This is the easy part.
Your "secret key" as stored on your PC simply says: use *this specific*
smartcard for that key. So GnuPG will ask for that specific smartcard, even
though your new card has the key.
Solution: delete the secret key. Watch out you don't throw out any real keys,
though. And don't delete the public key.
When GnuPG has the public key, and you insert the new smartcard with the secret
key, GnuPG will automatically recreate the "secret key" part that then says: use
*this specific* smartcard for that key. Best thing is to do
gpg --card-status
after you insert the smart card for the first time, this will then immediately
cause GnuPG to "bind" to the smart card.
Once again: watch out you don't accidentally throw out real secret keys!
No need to appologise. This list /is/ for asking questions. And it's a good
question, at that.
Wouldn't know if this is covered in manuals or howto's...
I learned a lot from playing around, and following this list.

@_date: 2011-10-08 17:26:22
@_author: Peter Lebbing 
@_subject: Is there a way to browse the GPG web of trust? 
Sounds to me like like Aaron would have tried to fix it if he had said

@_date: 2011-10-18 14:48:09
@_author: Peter Lebbing 
@_subject: private key protection 
One of those metal things in my pocket? What good are they for encryption? Even
if you manage to read it in, it still has way too little entropy...
Or in other words: the word has multiple meanings. If you want to discuss stuff,
you need to determine which of those meanings you're talking about, not attempt
to constrict the definition of the ambiguous word. That'll only lead to
bickering about which definition is the correct one.

@_date: 2011-10-18 15:07:38
@_author: Peter Lebbing 
@_subject: private key protection 
It's simply a chip card. Which means the same as: It's simply a computer. Only
small and not very powerful.
The key never leaves the smartcard. It does the decryption and signing instead
of your computer. Not of the whole file you decrypt or sign: in a hybrid
cryptosystem like GnuPG, the private key (on the smartcard) is only used to
decrypt or sign a very small piece of data.
If you decrypt a file, the only thing decrypted by your private key is the
"session key", which is a randomly generated key used to decrypt the actual file
with symmetric encryption.
If you sign a file, you sign a hash that is computed from the contents of the file.
So the actual data transfer between PC and smartcard is small.
If someone sniffs your PIN, and has trojaned or rooted your computer, he could
use your smartcard while it is still plugged in to your computer, just like you
are using your smartcard.
But he wouldn't have your raw secret key material and use it without also having
access to the smartcard.
A capable enough hacker might infect the USB pendrive while it is in your
internet-connected PC and that way still gain access to the non-connected system.

@_date: 2011-10-18 15:22:48
@_author: Peter Lebbing 
@_subject: private key protection 
Oddly, I don't recall Jerome ever making a statement remotely like "If I steal
your decrypted key, ...". I only remember him stating that he thought, as did I,
that the OP meant that he wanted ways to prevent people stealing his secret key
material when he said: "what is the best way to protect
your private key from getting stolen?". Anthony interpreted it as somebody
stealing the keyring, and Jerome disagreed on that interpretation. As do I.
When reading the thread, I wasn't for one moment confused about the intended
meaning of the word "key" when Jerome used it.
Funnily enough, Jerome was correcting Antony, and Antony replied:
"Rereading the post, you're probably right."
Which I think means the distinction was also not lost on Antony.
Produce the exact trivial statement, please, in a quote. Otherwise we'll never
be able to determine it's triviality.
Because I only see Jerome asserting:
- That the OP probably meant "raw secret key material" when he said key (my own
- That the distinction between a keyring/-file and a key as he meant it was that
the one was protected by a passphrase and the other was not, as it was the raw
secret key material.
I don't see the triviality.
What I do consider trivial is this silly bickering over who said what, when and
what the other one meant when he wrote what he wrote.
Just as a sidebar, I disagree. The access to my private key would be the worst
thing, the rest of my computer memory is much less interesting.
No, he never said that. It would come closer to truth to state he said it's game
over, but he did not say that when it's game over, that then it's game over. I'm
not going to assert what he actually meant when he said the exact words he said,
because that is something which is out of reach for all of us except Jerome or a
really good brainscanner attached to Jeromes head while he writes mails. Seriously.

@_date: 2011-10-18 15:27:17
@_author: Peter Lebbing 
@_subject: private key protection 
ls ~/.gnupg/private-keys-v1.d/
nowadays (adverb)
1. At the present time
2. In te current era
3. In GnuPG 2 ;)

@_date: 2011-10-18 15:29:29
@_author: Peter Lebbing 
@_subject: private key protection 
Yeah, that part was actually tongue-in-cheek.
The part about not being picky at all wasn't.

@_date: 2011-10-18 15:37:38
@_author: Peter Lebbing 
@_subject: private key protection 
The signature problem can still be solved by manual labour: you made *one*
signature. If you have a signature on your file that checks out, that's
apparently the one signature you made. This is thanks to the "Signature PIN:
forced" setting of OpenPGP smartcards.
However, there's another scenario involving encrypted files.
Once you've entered your PIN, your smartcard will decrypt files and stuff
without asking for the PIN again. So if you enter the PIN on your secure
smartcard reader, and someone has trojaned your PC, the trojan or attacker can
then decrypt further files until the smartcard is "reset".
Still, it is all restricted to the timeframe the smartcard is active "inside"
the hacked computer. At no point is the key fully compromised: the attacker
can't copy the key to his own system, and he can't sign or decrypt anything
without the smartcard being in a hacked computer at the time he wants to decrypt
or sign.

@_date: 2011-10-18 16:22:17
@_author: Peter Lebbing 
@_subject: private key protection 
Seems like you keep asserting Jerome posed (a) as something insightful. I don't
remember someone other than you posing (a) at all.
I really see no point in keeping on telling people they said something different
than what they meant to say. Isn't it way more productive to determine what they
meant, rather than what /you/ (or anyone) read in it?
Are we here to catch eachother on potentially saying something, for instance,
trivial, and going "aha! Got ya!"? Or are we here to discuss crypto and stuff
having to do with crypto?
Meanwhile, you are right about the heat versus light ratio, so I will stop this
side discussion as well, hopefully even if it annoys me some more :).

@_date: 2011-10-18 16:30:25
@_author: Peter Lebbing 
@_subject: STEED - Usable end-to-end encryption 
Because it is the e-mail address of the recipient you look up; that's all the
data you have in this scenario. Thus, for me you would look up a key
corresponding to user peter at the domain digitalbrains.com. The only logical
place to look for that without further information is in the domain
digitalbrains.com, which is under control of the e-mail provider. ISP here means
e-mail provider, by the way, perhaps that is the confusion. Unless I'm the one
confused ;).

@_date: 2011-10-19 21:30:48
@_author: Peter Lebbing 
@_subject: STEED - Usable end-to-end encryption 
Werner, Marcus,
Thank you for thinking about taking end-to-end e-mail encryption to the next
level. I really like your ideas.
However, I think you're not ambitious enough when you opt for using DNS for key
distribution. Yes, the infrastructure and RR types[1] are already there. But it
brings this nasty dependency on the provider. Because the part of the client
updates to the DNS is a key missing part in the DNS infrastructure as today, and
I don't see providers adding that soon.
I'm thinking more of things like DHT, Distributed Hash Tables, in BitTorrent, or
similar concepts in other peer-to-peer networks. I have no idea how it works :),
but it does. You fire up your BitTorrent, all the data it needs is the hash of a
torrent file, and suddenly it learns IP-addresses of other people who share that
torrent file. If you could do something similar for mapping e-mail addresses to
certificates, you don't need ISP's to implement extra stuff. Because I think
that is a really major hurdle; probably a too steep one, IMHO.
And if you design that infrastructure general enough to do X-to-certificate, we
could use the same infra for opportunistic end-to-end encryption of TCP/IP,
which would be great to have too, but a different paper altogether :).
[1] "Entries" in the DNS, for people not up to DNSpeed ;)

@_date: 2011-10-19 21:40:57
@_author: Peter Lebbing 
@_subject: STEED - Usable end-to-end encryption 
Given that all normal, literal hurdles are at right angles to the ground, they
are all equally steep. Obviously I meant high :D.

@_date: 2011-10-19 22:49:20
@_author: Peter Lebbing 
@_subject: STEED - Usable end-to-end encryption 
By default the STEED system as proposed creates a new certificate for every
e-mail address. So unless manually overridden, there is a one-to-one relation
between e-mail addresses and certificates and no way to "enumerate all e-mail

@_date: 2011-10-19 22:54:21
@_author: Peter Lebbing 
@_subject: private key protection 
Define your threat model... are we talking random trojan infection or a focused
attacker trying to gain your key? Because in the latter case, I hardly think
commonality matters.

@_date: 2011-10-25 11:26:57
@_author: Peter Lebbing 
@_subject: STEED - Usable end-to-end encryption 
So if we can't motivate users by showing the bad stuff that can happen if you
have no privacy, then how to do it? I don't see any other way.
Which for a pessimist might imply that it is simply doomed, and we'll never have
e-mail crypto by default.
Though pessimists are unfortunately more often right than optimists[1], I do
think the number of TLS connections between MUAs and MTAs has increased because
the clients have it on by default. And I base this on absolutely nothing.
PS: Nice anecdote :)
[1] Curse the researchers who actually did scientific research on this! Some
things are better left unknown and only speculated about :).

@_date: 2011-10-25 16:57:01
@_author: Peter Lebbing 
@_subject: STEED - Usable end-to-end encryption 
The problem with the current proposal in that respect is that it requires
co-operation of e-mail providers. If there is no significant user base, the
providers don't want to cater for that very small minority that asks them to
implement the extra DNS functionality. And without the functionality being
offered by the e-mail providers, there is no chance to build a significant user
If there was no dependency on third parties implementing stuff for their
customers, this catch-22 would not be there. It needs to be such that an
individual can say "I will install this" and then communicate with people who
did the same thing. If this individual then comes to the conclusion "My provider
does not support this", he would need to be very motivated indeed to do
something about it.
So currently there is no way to only have a few people do this, and let that
group grow slowly.

@_date: 2011-10-25 20:40:42
@_author: Peter Lebbing 
@_subject: STEED - Usable end-to-end encryption 
Yes, and if it could credibly be said "implement STEED and you'll get 10% more
clients", you'd need crowd control. Unfortunately, both "ifs" are not met. When
you try to create the perfect standard that solves all e-mail problems, it
quickly becomes a terrible mess. You need focus and compartmentalisation, draw
some boundaries.

@_date: 2011-10-29 14:39:19
@_author: Peter Lebbing 
@_subject: MS Exchange server corrupting PGP-MIME emails 
Wouldn't the more generally applicable fix be to simply *not* mess with the
layout of messages going through the server? Changing encoding is one thing, and
I believe the MIME spec says stuff about this being accepted, but rewriting the
whole structure and changing inline parts to attachment parts and stuff like
that seems like a sure-fire way to screw up all sorts of different things, not
just PGP/MIME and S/MIME.
Be liberal in what you accept, but *be conservative in what you create*. Plus,
it is not in the interest of the user to mangle their messages. If the recipient
would like to see it formatted in a certain way, he needs a MUA to do that for
him, it is explicitly not the task of the MTA. The SMTP spec has some stuff to
say about this too.

@_date: 2011-10-29 14:47:13
@_author: Peter Lebbing 
@_subject: MS Exchange server corrupting PGP-MIME emails 
Oh, I'm sorry, I might have misinterpreted Jerry. Obviously if you go the right
way about fixing the mangling you still need examples of the mangling to find
out which extension of Exchange do the mangling. To feed to your debugger, so to
My interpretation of only fixing a very specific instance of mangling is not a
proper interpretation of the request.
So I guess I should rephrase my comment as a request: when this behaviour is
fixed, please fix it for mangling in general and not just this specific PGP/MIME
and S/MIME case :).

@_date: 2011-10-31 11:14:44
@_author: Peter Lebbing 
@_subject: MS Exchange server corrupting PGP-MIME emails 
Would a lawyer perhaps say it as this?
I would like to see no mangling at all. If there are legitimate uses for
mangling, I would like to see no mangling of multipart/signed and
A lawyer would still need to define "mangling", but IANAL.
But still, the part you quoted is only about /signed, and the OP reported
problems with /encrypted. So it is perhaps not that strong an argument when you
want to fix the OP's problem ;).
And surely there must be a part of the MIME spec which says that the MTA
changing inline to attachment is not a good default[1]. If it's not specified,
I'd think that is because they thought it implied. Just like it is implied that
it is not a good default if the MTA inserts obscenities and verbal abuse in a
text/plain part.
[1] At first I wrote "is not allowed". But in special circumstances, it might be
okay, like when the user has explicitly configured his own MTA to do such a

@_date: 2011-09-27 17:22:45
@_author: Peter Lebbing 
@_subject: restoring SmartCard key with off-card copy 
It's been a while since I played with it, but it worked then. From the man page,
under --edit-key:
bkuptocard file
 Restore the given file to a card. This command may be used to restore a
backup key (as generated during card initialization) to a new card. In almost
all cases this will be the encryption key. You should use this command only with
the corresponding public key and make sure that the file given as argument is
indeed the backup to restore. You should then select 2 to restore as encryption
key. You will first be asked to enter the passphrase of the backup key and then
for the Admin PIN of the card.
So you can restore the key to the card using that command, after starting the
following from the command prompt:
gpg --edit-key And the reason you can't import it as a normal secret key, is that the backup is
purely the RSA secret material instead of the bundle of information referred to
as a secret key in OpenPGP.
Your first message made it to the list, by the way.
Good luck,

@_date: 2011-09-28 16:54:57
@_author: Peter Lebbing 
@_subject: restoring SmartCard key with off-card copy 
I'm fairly sure I tried it and it worked. It's a while ago, so I won't
testify in court on that ;). Just export the "secret key" from GnuPG
(actually with the divert-to-card stub), gpgsplit it, and replace the stub
with that off-card backup.

@_date: 2012-04-06 18:31:22
@_author: Peter Lebbing 
@_subject: List-packets help 
I just found this in the manual:
$ gpg --list-options show-sig-subpackets --with-colons --list-sigs KEYID
And I see for my own self signature:
sig:::1:AC46EFE6DE500B3E:2011-11-01::::Peter Lebbing
Referring to RFC 4880, subpacket 11 is preferred symmetric algorithms,
for example. But you need to parse the quoted octets that follow it. For
subpacket 11, this is rather trivial, since %07%09%08%03%02 just means
"S7 S9 S8 S3 S2" as preference string (each octet a symmetric algorithm
If you look at other strings, I see %ACF%EF... at subpacket 16, which is
a nice tricky example where the second octet appears to be 46 hex, ASCII
F. Since 16 is the issuer, it's no surprise the string expands to
AC46EFE6DE500B3E in hex, my long key id.

@_date: 2012-04-20 14:29:54
@_author: Peter Lebbing 
@_subject: Clarification in man page? (was Re: Cannot import private key) 
Yes, this is a property of the GnuPG command line that more people don't seem to
realise, that all options *must* come before the command. I initially missed it
myself, and I've seen it mentioned by others on this mailing list. At least on
*nix, it's relatively common that options can come in any position of the arguments.
Werner, perhaps it is an idea to have the man page more explicit that all
options *must* come before the command?
The man page does say in two locations (section COMMANDS and section OPTIONS):
However, the significance of this statement is perhaps lessened by the first
sentence of the section COMMANDS:
I think this sentence is easily misunderstood; in fact, I doubt the statement
can be made true. I read this as: since they are not distinguished, I can put
the (single) command in any old place I can put an option in.
While the very important difference between commands and options is that the
command comes after the options, and definitely not the other way around.
My suggestion would be to change the sentence
to something like
I just notice, this does work:
$ gpg2 -e -r  -o foo.gpg
$ gpg2 -r  -o foo.gpg -e -r All wanted keyid's get encrypted to, and foo.gpg is the output file.
Is perhaps the point that when a command can take multiple arguments, like
--export can, that the rest of the command line coming after the command is
always interpreted as arguments to the command? Still, it might be best to
educate users to put the options first, and then be liberal in what you actually

@_date: 2012-04-21 11:55:27
@_author: Peter Lebbing 
@_subject: Clarification in man page? 
Why is --armor dropped when it is not wanted as a filename?
I think you misread what I meant :). Confusion all around!
I have this command:
$ gpg2 -a -o foo.asc --export de500b3e
Now if commands and options are equal citizens in the land of the command line,
I think this should also work:
$ gpg2 --export de500b3e -a -o foo.asc
All I did was change the order; the only difference between commands and options
is how many are allowed in one command line. I stuck by the rule as I read it.
However, it doesn't do the same.

@_date: 2012-04-21 12:04:06
@_author: Peter Lebbing 
@_subject: Clarification in man page? 
Because clarifying the docs is "non-invasive". If you change the way gpg parses
its options, you risk breaking scripts people wrote and such. Plus, there is a
good chance the parsing was deliberately designed the way it is :). So rather
than challenge the design, I chose clarifying it instead. You could say I chose
the lazy way (of least resistance).

@_date: 2012-04-21 20:24:11
@_author: Peter Lebbing 
@_subject: Clarification in man page? 
Okay, I initially misunderstood. Never mind.
When one of the arguments to --export does not actually match a key in the
keyring, GnuPG v2.0.18 silently ignores it. That means that if --armor does not
match a key, it is effectively ignored when specified after --export.
I like the note, it is definitely clarifying.

@_date: 2012-04-24 14:33:52
@_author: Peter Lebbing 
@_subject: gpg2 
Perhaps you should explain what you are trying to accomplish in the end. I read
something about how long a passphrase will last, are you trying to decrypt
multiple e-mails after entering your passphrase only once?

@_date: 2012-04-27 14:40:01
@_author: Peter Lebbing 
@_subject: Question about key fingerprint uses 
You're turning it around :). Rather than verify you are speaking to John using
his fingerprint, you are verifying the fingerprint by speaking to John.
You should already be sure the person on the line is John Smith. John Smith then
tells you his fingerprint such that you can be sure the key you're looking at
actually belongs to John Smith, and hasn't been exchanged by a man in the middle.

@_date: 2012-08-08 10:20:51
@_author: Peter Lebbing 
@_subject: Malformed Revokation Certificate? 
Now, I haven't ever revoked a key, but I wouldn't be surprised if this is how it
is supposed to work. After all, the revocation certificate is just a special
type of signature. You don't upload signatures to a keyserver, you upload keys
with signatures to a keyserver. The keyserver then merges in all the signatures
it has on that key.
That's old. Like, really old. Why do you use such an old version?
As for PGP 2.6.3, I believe the idea (IDEA? :) is that if you really still want
to use that, you have to be prepared for some struggles to get all sides
communicating. That's the price you pay.

@_date: 2012-08-09 11:13:01
@_author: Peter Lebbing 
@_subject: Malformed Revokation Certificate? 
It's not really critical information, but I meant "using a revocation
certificate". I did revoke a key just by using "revkey" from the command
line "--edit-key", and subsequently uploading the key to the keyservers.

@_date: 2012-08-13 15:25:46
@_author: Peter Lebbing 
@_subject: Elliptic Curve Cryptography 
Yes, that is planned, indeed with an update to the standard. Search this
mailing list for terms like elliptic and ECC, and you will find messages
about it.

@_date: 2012-08-18 13:16:14
@_author: Peter Lebbing 
@_subject: OpenPGP smartcard, how vulnerable is it? 
This is correct for signing, when using the "signature force PIN" flag.
Unfortunately, there is no equivalent flag for encryption (or authentication),
so once a user has entered the PIN, the malware can just request additional
decryptions and authentications. The user probably won't notice. A LED on the
reader might flash when accessing the card, but if you do those additional
encryptions and authentications directly after a user-initiated action, they
probably won't notice that it flashes for a little longer than normal.

@_date: 2012-08-21 14:46:04
@_author: Peter Lebbing 
@_subject: [gnupg-users] Preferred hash algorithm when signing 
Please see the documentation for --personal-digest-preferences.
Your key's preferences are not used when signing (others use it when encrypting
to you).

@_date: 2012-08-28 10:28:10
@_author: Peter Lebbing 
@_subject: what is killing PKI? 
Please take your smut elsewhere. I'm sure you know people who will laugh; tell
it to them. Not here.

@_date: 2012-08-28 10:49:36
@_author: Peter Lebbing 
@_subject: Changing the email address of a key 
Surely, Werner meant "adduid" which adds a new e-mail address, and not "addkey"
which adds a new subkey.

@_date: 2012-08-28 14:21:29
@_author: Peter Lebbing 
@_subject: symmetric vs. asymmetric in group use 
When using OpenPGP, add RNG back to the list: the passphrase is only used to
encrypt the randomly generated session key that encrypts the data.
And in all cases, add some form of resisting tampering, i.e., a hash.
Furthermore, if you're going to reject hybrid crypto as used in OpenPGP as too
fragile, you might be better off migrating to a different planet :). Apparently
you have such capable adversaries in your threat model that living on our planet
might be a tad too dangerous for you :).
PS: Let's not argue based on that last statement, it was well tongue-in-cheek
with just a kernel of truth.

@_date: 2012-08-28 15:48:54
@_author: Peter Lebbing 
@_subject: what is killing PKI? 
I didn't want to actually quote the insulting stuff, but let me quote nonetheless:
(note that this is easily read, and probably meant, to refer to an underage
child! Your whole reply is centered around the daughter that was brought up in
the conversation. How dare you talk like that about the actual daughter of
another member of this mailing list?)
Please do not insult my intelligence by acting like I misread it. This will be
the last I have to say about it.

@_date: 2012-08-28 15:55:44
@_author: Peter Lebbing 
@_subject: Pseudonym (was Re: what is killing PKI?) 
Yes, it indeed is the content that counts. Note that there are quite some
regular posters on this list also using pseudonyms. Nobody dismisses their
opinion based on that. You keep focussing on the mention of using a pseudonym,
whereas it was the actual /content/, all the name-calling and insults, of your
initial mail that triggered the dismissal of what you wrote.

@_date: 2012-08-29 08:49:40
@_author: Peter Lebbing 
@_subject: Changing the email address of a key 
UIDs are not stored on the smartcard, so it does not matter.
Understandable. If I understand correctly, you used GnuPG to encrypt the file
that unlocks your netbook? In that case, the *uid commands should be safe,
because they do not influence decryption of files. To be on the safe side, keep
a copy of your key as it is now, and after you changed the e-mail address, try
to decrypt some file. If that works, it should also decrypt the file that
unlocks your netbook.
It is wise to keep a copy of your key as it is now around just in case, anyway.
If you do something wrong, you can take the backup and start over.

@_date: 2012-08-29 12:12:00
@_author: Peter Lebbing 
@_subject: A password, a passphrase, how about a passfile? 
Note that your changing access to the key from what you know (passphrase) into
what you have (a file). That's quite a change that's often not what you want.
In two-factor authentication, you use both. A smartcard with a PIN is an
example. But depending on just "what you have"...
Other than that, the suitability of a file depends on how it is turned into
accessing the key (is it hashed?) and whether an attacker could just, for
instance, try downloading mp3's of songs they know you like and try them as
keys. Or take your private photo collection from a backup you left lingering
around and try all those photo's. If the attacker has a collection of files
which does contain the correct file, a computer should have no trouble at all
trying all those files in a very short time.
In short, it seems like a bad idea to me.

@_date: 2012-08-29 14:11:59
@_author: Peter Lebbing 
@_subject: Changing the email address of a key 
Why are you forcing using the subkey? An UID is /always/ on the primary key, it
makes no sense to make an UID on the subkey. I think.
Simply losing the exclamation mark should fix it, or just specify
$ gpg2 --edit-key 0AE275A9
Also, apart from UIDs on subkeys making no sense, it would seem to me that an
UID needs to be bound with a Certification-capable signing key, whereas your
signing subkey E8401492 can only make signatures on data. That's probably why
GnuPG says:
Although it could also be that the secret part for that subkey is simply not
available? I'm not sure whether the "secret key is available" message I quoted
above pertains to the primary key or the secret subkey you forced on the command
If you still have problems after this explanation, please provide more data
about your setup. You have two encryption subkeys, two data signature subkeys,
and GnuPG complains that there are secret parts missing. It will be a lot easier
to help you if you can explain what pieces of data are where :).

@_date: 2012-08-30 10:48:19
@_author: Peter Lebbing 
@_subject: Changing the email address of a key 
The thing is that for a new UID, you need the, what they call, master key. That
would be the primary key. So when you followed the instructions under the
heading "Remove the master key from the keyring", you where after that unable to
use your master/primary key to create a new UID.
So you go back a little in the document to the part where you had your USB stick
with the primary key and all subkeys guarded by Orcs or some other fearsome
creature. Plead with the creature to have your USB stick back, once again follow
the section "Go offline", import your primary key from the USB stick (wipe away
the Orc spittle before inserting; ignore the chew marks on the protective cap).
After you have created the new UID with the primary key and exported the whole
to the USB stick, re-remove the primary key from the system.
Oh, by the way, the reason you need the exclamation mark to specify which key to
use to sign is because you have two signing keys. Apparently GnuPG tries it with
the one you don't have the secret part for if you don't give the exclamation
mark. But bear in mind the difference between a signature on a key(/UID) and on
data. The signing subkey is for signatures on data.
Good luck,

@_date: 2012-12-02 21:09:21
@_author: Peter Lebbing 
@_subject: Keypad support for PC/SC card readers? 
AFAIK, keypad entry is only supported through the internal CCID driver of GnuPG,
not through a PC/SC stack.

@_date: 2012-12-04 17:50:23
@_author: Peter Lebbing 
@_subject: Seperate RSA subkeys for decryption and signing or one for both? 
RFC 4880 says this in the "Security Considerations" part:
Where's your question coming from? As a theoretical musing, it's interesting. In
practice, I don't see why you would ever create a subkey with both capabilities
Also note that it is useful to keep around (and backup) an encryption subkey, to
decrypt old stuff. A primary key is useful to backup as it collects
certifications. But a signing subkey is not useful to keep around. You might
want to refresh your signing subkey more often than your encryption key for that
[1] That doesn't mean there is no reason.

@_date: 2012-02-07 15:31:58
@_author: Peter Lebbing 
@_subject: GPG2 hangs the system if I activate another window 
Locking up seems a bit harsh :). Here, on XFCE with Debian testing, my desktop
definitely does not lock up. I can press some buttons with the mouse, but I
can't type any text in any other window than the password input dialog. But at
no point do I lose control, and once I dismiss the password dialog, I can
continue using my computer. This would be the "design" I expected :).
That said, if you want to pass the password from a password database
application, you probably indeed need --no-grab, and that might solve the
locking problem as a byproduct.

@_date: 2012-02-24 11:19:07
@_author: Peter Lebbing 
@_subject: Encryption File Size 
But isn't there a worst-case overhead for the compression algorithm
used? There most likely is.
zlib, with default settings, avoids increasing the size of the
compressed text. That web page also gives detailed information on overhead.
And *if* (big if) there isn't an acceptable worst-case overhead for a
compression algorithm, there is probably a cut-off in GnuPG, or it would
become a DoS attack vector: get someone to encrypt a specially crafted
file that will fill his filesystem when the compression algorithm is run
on it.
IIRC, there's a cut-off for /de/compression like that.
Furthermore: the ciphertext is enciphered with a streaming mode
cipher, so the ciphertext is as big as the plaintext (after
compression). But obviously there is overhead from the rest of the
OpenPGP message.
And if the size of the plaintext is not known beforehand, you get some
extra headers for blocks of ciphertext in the OpenPGP message. At least,
I believe that is the case. I didn't check now.
The total overhead is small for big files, though.

@_date: 2012-01-09 20:27:16
@_author: Peter Lebbing 
@_subject: Encryption with key ID 
You originally indicated the key was as such:
If I read that correctly as an ElGamal encryption subkey with a size of 6000
bits, it might be that GnuPG cannot work with this particular key because it is
too large. You could hack the source and compile your own version that does
work, but the more logical course of action would be to ask your vendor to
create a new key that can normally be used by off-the-shelf OpenPGP
implementations. The key is *huge*.
you need ~6000 bits of randomness to encrypt to a key with a 6000-bit prime.
GnuPG complains it has a limit set at 4799 bits, so it errors out because it
can't generate enough randomness to encrypt the session key.
GnuPG offers me the range of 512 to 4096 bits for creation of an ElGamal key.

@_date: 2012-01-22 10:32:41
@_author: Peter Lebbing 
@_subject: Protecting IDs at a key signing party 
While I generally agree with you on the rest of your mail, this is not
necessarily the case. You met them at a keysigning party. They probably
presented you something they thought would prove their identity. If you read
"checked" as "you looked at it", then yes, probably that is also true :).
But I interpret "checked" here as "verified it was okay", and that is not
necessarily the case.
By the way, I think it's courtesy to send the signature to the key owner.
But it is not a security issue.
I have so far attended a keysigning party once. I noticed a few people had
not published my signature (don't know why)[1]. This also weakened my own
Web of Trust, which was not a big issue, but I still decided to do local
signatures on those keys that did not have my exportable signature. Fine.
But I also have a laptop, so I needed to export my local signatures,
etcetera. A lot of overhead, what with checking fingerprints again for the
local signature, all for a bit of courtesy...
[1] I have a slight tremor in the hands, and I noticed sometimes my passport
shaked a bit while I was holding it up so the person in front of me could
check it. Perhaps they thought I was bloody nervous because I was trying to
trick them??

@_date: 2012-01-25 11:42:36
@_author: Peter Lebbing 
@_subject: Keyserver spam experiment 
Hello list,
The topic of keyserver spam came up again. This seemed like a good moment to
mention the results of a little experiment.
On March the 18th of 2011, a little under a year ago, I created a bogus OpenPGP
key and uploaded it to the keyserver. The UID of the key has an e-mail address
that is 42 random letters and numbers  I wanted to see how
much spam it would attract.
Obviously, I could not tell anyone, because someone might disclose the address
to spammers for his or her own reasons. The experiment is now, by this mail,
tainted :).
I have received exactly one(!) spam mail. The headers will follow later. That's
only one spam mail in almost a year.
I chose 42 random letters and numbers to not get caught by an e-mail address
generator that generates likely e-mail addresses to spam. I only wanted it to
get picked up by a keyserver harvester. Now somebody might say: that harvester
might filter out a weird e-mail address with the local part a string of 42
letters. I don't think so; sending spam is dirt cheap, why filter when you might
miss a target for your spam?
Obviously I did not filter out spam for this address. But I forgot to turn off
two things:
 - If the SMTP envelope has a FROM address  that does not
exist (anymore), the mail is denied.
 - On Jun 16th, I started rejecting mails that had 4 or more recipients in the
SMTP envelope that did not exist (anymore).
Oh, and I also have no direct control over the backup mail relays for my domain;
they filter out spam as well. And I sometimes see spam coming in through a
backup mail relay while the primary mail server is online, so some spammers use
backup relays even when the main host is not down.
I think I addressed the most important things. So here come the headers of the
spam message I received on Jul 13th last year. I removed the e-mail address so
the experiment can keep running, albeit slightly tainted. Please don't mention
the address on the mailing list :).
------------8<--------------------cut here---------------------->8--------------
Return-path: Envelope-to: [...]
Delivery-date: Wed, 13 Jul 2011 23:18:09 +0200
Received: from Debian-exim by butters.digitalbrains.com with spam-scanned (Exim
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
X-Spam-Flag: YES
X-Spam-Level: *******************************************
X-Spam-Status: Yes, score=43.3 required=5.0 tests=ADVANCE_FEE_2_NEW_MONEY,
Received: from mail.digitalbrains.com ([2001:980:141d::3])
Received: from [118.224.1.233] (helo=entecnet.com)
Received: from User ([46.166.137.117])
Reply-To:

@_date: 2012-01-26 12:07:15
@_author: Peter Lebbing 
@_subject: hashed user IDs redux [was: Re: Creating a key bearing no user ID] 
I like it. I was thinking along the same lines, but you were a big step ahead of
me. I hand't thought of the fingerprint. I think you might have just solved the
whole issue with a much better solution!
I don't think you can add entropy to an e-mail address and end up with a
solution that is more elegant than what you just proposed with the fingerprint.
You just did yourself ;D.

@_date: 2012-01-26 17:22:24
@_author: Peter Lebbing 
@_subject: hashed user IDs redux [was: Re: Creating a key bearing no user ID] 
Maybe I should clarify that this is in no way a feature request; I just like the
pragmatic solution in itself.
I personally don't see a use case where one would be satisfied with an e-mail
address of the form
mailinglisten--noenum-zTTgFzNHU3RnkFyAxJuYMbs7 at hauke-laging.de but dissatisfied
with just handing the fingerprint for a key to someone. I wouldn't want to spell
out that e-mail address to someone. If I'm not going to give it verbally, why
not just give the key fingerprint?
You could print the fingerprint on your business card, and not enter your e-mail
address in the UID of the key.
And in e-mails, you have the header
OpenPGP: id=8FA94E79AD6AB56EE38CE5CBAC46EFE6DE500B3E

@_date: 2012-01-27 11:49:43
@_author: Peter Lebbing 
@_subject: hashed user IDs redux [was: Re: Creating a key bearing no user ID] 
Hi MFPA,
Can I ask what about the
dkg--noenum-0EE5BE979282D80B9F7540F1CCD2ED94D21739E9 at fifthhorseman.net form does
not satisfy your requirement that the
mailinglisten--noenum-zTTgFzNHU3RnkFyAxJuYMbs7 at hauke-laging.de does? Or do you
not agree with the latter form either?
I'm not sure of your requirements. I thought all that was needed was a way to
find a key belonging to an e-mail address without requiring the e-mail address
to be in the UID.

@_date: 2012-01-27 12:38:49
@_author: Peter Lebbing 
@_subject: Why hashed User IDs is not the solution to User ID enumeration 
If you don't solve the key enumeration problem, it seems to me you're more
enhancing the feeling of privacy people have rather than actually enhancing
their privacy.
It does not really offer privacy, it just makes people think they have privacy.
That's not Pretty Good Privacy. It's more a request "please don't look here".
Which by the way makes people curious :).
And a curious person with a mean streak might sign a key with an obscured e-mail
address with a signature saying "this is the key for expires2012 at rocketmail.com"
}:-]. Which is verifiable by hashing the e-mail address. And once "keyserver
no-modify" is implemented, he'll create a website with a dump of all the
unobscured e-mail addresses, just because he can. He's like that once he sees
something that's obscured but not really blinded.
On the other hand, I think Hauke Laging's demands are met by the idea Daniel
Kahn Gillmor came up with.

@_date: 2012-01-28 14:45:16
@_author: Peter Lebbing 
@_subject: [META] please start To:  with gnupg-users@gnupg.org,	i.e.:  To: 
This is a heuristic: RFC2822/RFC5322 do not require the field to be present, but
if there isn't one, it increases the probability the mail is spam. Rejecting a
mail for not having this field, while the rest doesn't look very spammy, is
overly zealous, and I would be upset with the person who installed such a filter
on my mailbox.
In the default SpamAssassin setup, it seems not having a To:-field is one point
towards the 5 points needed to be marked as spam. Note that other aspects might
deduct points and you can end up negative (which is a good thing).
You are confusing different layers. SMTP doesn't care about those fields, but
the "Internet Message Format" RFC's, 2822 and 5322 do. You are confusing
envelope with letter. Furthermore, SMTP genuinely doesn't care about those
fields, they are not mapped to RCPT TO:. RCPT TO: is part of the envelope, and
handed to SMTP, it does not deduct them from the fields. The mapping is these
days usually performed by the e-mail client software, which you did not consider
to be behind the scenes, apparently.
PS: You should look for a better solution to filter/order your mails into their
proper locations if your current solution cares about order of addressees. There
is no order in those, and any order needed by a filter is IMHO a bug.
Personally, I use the Sieve language to tell my IMAP server what to do :).
if address ["to", "cc", "bcc", "resent-to"] "gnupg-users.org" {
  fileinto "GnuPG-Users";
This is a deliberately suboptimal filter; I just use the List-ID as Remco suggested.

@_date: 2012-01-29 10:05:28
@_author: Peter Lebbing 
@_subject: hashed user IDs redux [was: Re: Creating a key bearing no user ID] 
Yes, exactly. The UID just says "Anonymous" or whatever you want it to say.
Yes. Either the user needs to be this savvy, or his tools (MUA, or GnuPG)
needs to recognise the special form e-mail address and do this.
To automate it, either the MUA or GnuPG needs to recognise the special form
e-mail address, but no other changes are necessary (f.e. the keyserver can
stay the same).
By the way, the way I see it, the e-mail address really exists. You can mail
to dkg--noenum-0EE5BE979282D80B9F7540F1CCD2ED94D21739E9 at fifthhorseman.net
and it arrives. Demanding the MUA to automatically strip it and mail
dkg at fifthhorseman.net instead really hinders adoption.
I assumed Hauke Laging's high-entropy e-mail address variant also needed the
e-mail address to actually exist, otherwise I don't see how that variation
could meet the requirements, namely that possession of the e-mail
address is enough to get someones public key.

@_date: 2012-01-30 10:26:55
@_author: Peter Lebbing 
@_subject: [META] please start To:  with gnupg-users@gnupg.org,	i.e.:  To: 
Or: how a boring off-topic conversation got on-topic.
Enigmail still recognises the "bonked" :) sig delimiter and correctly omits
the signature when replying. That is, I assume it is Enigmail doing it for
me, it seems the most logical conclusion. Could also be Thunderbird itself.
PS: I wouldn't mind if this silly conversation were over.

@_date: 2012-01-30 15:27:37
@_author: Peter Lebbing 
@_subject: [META] please start To:  with gnupg-users@gnupg.org, i.e.:  To: 
For crying out loud, stop crying out loud. Get over it. People will CC you.
Stop bothering us with your complaints every time. We all, including you,
have better things to do with our time than repeating this annyoing
discussion ad infinitum.
While I'm at it, I might point you towards DJB's Mail-Followup-To header. It
might help us all to be freed of this endless litany.

@_date: 2012-01-31 13:22:43
@_author: Peter Lebbing 
@_subject: Reply-to netiquette (was [META] please start To: with 
Well, I don't know if you refer to me, my apologies if so. I know how that comes
about when /I/ reply to a mail you write.
Thunderbird doesn't show me your Reply-To: header. Not even if I press "View->Headers->All"! It took me some time to find the circumstances under which this happens. It turns out that if To: and Reply-To: have the same e-mail address, Reply-To: is silently dropped. And this is exactly the case with your I just press the button "reply all", and Thunderbird addresses a CC: to you.
Remember I haven't seen your Reply-To header, so I can't take a decision on what
it means myself, only Thunderbird gets to do that.
If this dropping of Reply-To: is a bug, and fixed, then hopefully I'll notice it and remove a CC: if the person I'm responding to has "Reply-To: gnupg-users..." set. But it's still something that can easily be overlooked.
If I press "reply to list", even people who would want a CC: when I reply to
their message will not get one. I was under the impression "reply to all" was
the convention here on gnupg-users. Isn't it?
I read Dan J Bernsteins words on Reply-To and his propositions, Mail-Followup-To
etcetera. I'm going to be blunt here: it's a pity DJB came up with these,
because I think a less controversial person would have much more chance of
getting it into an RFC. I don't want to spark a pro- and contra-DJB discussion
here, so please take a few breaths before you reply.
There should be mail headers for:
- List customs: reply all/reply list
- Personal preferences overriding list customs: do you want CC:'s?
Either that, or we should all exclusively use Usenet ;). Do away with the
concept of mailing list altogether.
PS: I'm running Mozilla/5.0 (X11; U; Linux x86_64; en-GB; rv:1.9.2.24) Gecko/20111114 Icedove/3.1.16, as you can see in the headers ;). On Debian wheezy.

@_date: 2012-07-10 17:03:21
@_author: Peter Lebbing 
@_subject: why is SHA1 used? How do I get SHA256 to be used? 
Like Rob said,
To truncate SHA-256 to fit in a 1k DSA signature, specify "--enable-dsa2".
I personally don't use DSA, so there might be some more interesting options
related to it.

@_date: 2012-07-23 16:25:41
@_author: Peter Lebbing 
@_subject: KeePass or any other password wallet to store and transport keys 
A different method I'd like to throw in for consideration is using a very strong
random password generated by KeePass as the password to unlock your OpenPGP
private key.
A "password" with a lot of randomness is comparable to a symmetric encryption
key when fed to GnuPG. GnuPG will still throw in extra processing with a
String-To-Key conversion and a random session key, so there is some unnecessary
stacking of cryptographic operations, but as long as the weakest link isn't too
weak, I don't see much of a problem. [Hmmm, I must say that sounds like a rather
empty statement which is vacuously true...]
I'm assuming the reason for all of this is reduction of the number of difficult
passphrases to remember (incidentally the precise use case of KeePass). By using
a cryptographically strong password as just described, I think you get about the
same effective level of security as when you store unprotected OpenPGP key
material in your KeePass wallet, but at a greater convenience level. Although
you probably need to turn off keyboard grabbing and such for the pinentry
helper, which does reduce safety. Without turning off keyboard grabbing, you
probably can't paste the password from the clipboard.
PS: If you do store unprotected key material in your KeePass wallet, mind where
you put it when you want it used by GnuPG. The material could be left on your
hard drive depending on how you do it.

@_date: 2012-07-23 16:46:54
@_author: Peter Lebbing 
@_subject: GPA and Windows 
Widely used and recognised, but possibly only in certain professions.
Wikipedia, for example, lists it under "mathematical jargon". Computer
scientists will know it as well. But it might not be as widely recognised as
you think :).
(don't forget the mouseover text :)

@_date: 2012-06-02 00:27:43
@_author: Peter Lebbing 
@_subject: Is there a "-----END PGP SIGNED MESSAGE-----" tag? 
If I had been the one designing the armour format, and I had thought of this
little detail, I'd have named the three headers something like:

@_date: 2012-06-02 18:17:42
@_author: Peter Lebbing 
@_subject: Problem: cannot generate / copy keys larger than 1024bit on my 
Which exact OpenPGP-compatible card do you have? The v1.1 card only supports up
to 1024 bit. The v2.0 card is capable of larger keys.

@_date: 2012-06-04 10:13:44
@_author: Peter Lebbing 
@_subject: GnuPG 2.1 Windows 7, pinentry does not allow paste, no way to 
Or use a smart card.
BTW, with regard to remembering passphrases, the comic that has been mentioned
more often here:

@_date: 2012-06-06 21:54:01
@_author: Peter Lebbing 
@_subject: can someone verify the gnupg Fingerprint for pubkey? 
I agree it appears he has the correct key. I did a local sig on it after what
checking I seemed to be able to do without meeting people in person.
But it's a bit unclear to me on what basis you decided it looked correct? Your
mail suggests to me that you decided that based on the fact that the UID on
that key is "Werner Koch (dist sig)". But that would be the very first thing a
potential attacker would duplicate in his effort to fool our OP. Even if he's
using MITM tricks to subvert his system, he can still post his personally
generated key to the keyserver with this UID.
PS: I briefly considered signing this message, because the attacker might MITM
my message to the OP. Then I realised what good that signature would do :).

@_date: 2012-06-07 15:17:48
@_author: Peter Lebbing 
@_subject: can someone verify the gnupg Fingerprint for pubkey? 
I'm sorry, but I'm tech savvy and have some knowledge of OpenPGP and stuff and
I'm quite confused about what you are trying to say in this mail.
I'm also a bit worried that your mail can be read as quite brusque for no good
reason. Perhaps it comes across diferently than you meant.

@_date: 2012-06-09 13:21:46
@_author: Peter Lebbing 
@_subject: can someone verify the gnupg Fingerprint for pubkey? 
So how /do/ you verify that you have the distribution key for GnuPG? Let's not
lose sight of this specific instance of verification: that you want to know you
have the GnuPG source as distributed by its authors, and not some modified
version. It doesn't really matter how many Werner Kochs there are.
There is always a bootstrapping problem for the trust. So at some point you'll
have to satisfy yourself that you have the correct key. Crowdsourcing the
knowledge seems viable, if you make sure the messages from the crowd are not
altered by your attacker.
And it's always a costs/benefits decision. How sure do you want to be that you
have the unmodified sources? So I don't agree that it is as binary as "this is
or isn't a proper verification".

@_date: 2012-06-09 17:05:05
@_author: Peter Lebbing 
@_subject: can someone verify the gnupg Fingerprint for pubkey? 
I was under the impression you did. I interpreted your mail and particularly the
as meaning that there is only one correct way to do a proper verification. From
your reply, I understand now you did not mean it like that. I was already quite
puzzled about my interpretation because it didn't sound like you :).
Funnily, we're saying the same thing. You yourself said you don't particularly
care if Werner Koch is actually called Horace Micklethorpe or Harry Palmer or
... Then why are you interested in the number of Werner Kochs?
The thing I'm interested in: is the source of GnuPG I downloaded actually the
program we know and love. I'm at this point not interested in the fact that
Werner Koch is a main developer of it, or what his proper name is. For all I
know his birthname indeed is Horace. He might as well have given the UID "GnuPG
dist sig" to the key, instead of "Werner Koch (dist sig)". The only reason we
are talking about "the" Werner Koch is that his name is in the UID, which might
as easily not have been. As I said, the number of Werner Kochs is insubstantial.
So how did you verify your GnuPG source? If you say "I asked a close friend", my
counterquestion is: How did he/she? What I want to know is: what bootstrapped
the confidence that the key was the proper GnuPG dist sig?
Personally, I did it by checking from a number of locations that the key making
the signature is the same from wherever I try. Also, I spread the checks over a
substantial period of time. If the website got hacked, I hoped it would come out
in that period of time. It did not at any point include the quantity of Werner
Now, if I wanted more satisfaction, I would indeed turn to this mailing list,
ask members whether they see the same fingerprint, and check the replies from
several locations to see that from wherever I check, the replies are identical.
Again add a little time to allow for members to write to the mailing list "Hey I
did not write that reply!" in case of impersonation. Hopefully at least one
person would notice and expose the deception.
And I do not see this process as, to quote you, "certifiably crazy" at all. It
would perhaps be if I only checked it from the same computer as where I
downloaded the source and signature and keyblock, but nowhere is it stated this
is the case.

@_date: 2012-06-09 17:57:04
@_author: Peter Lebbing 
@_subject: can someone verify the gnupg Fingerprint for pubkey? 
Suppose you would want to build from the vanilla source downloaded from
gnupg.org and signed by "Werner Koch (dist sig)", how would you verify
authenticity of that key?
I also just trust the Debian repo for my software. Unfortunately, the problem is
just transferred to the signature on the ISO I download to install Debian on a
new system. I do the same: download the sig from various places and compare the

@_date: 2012-06-09 21:54:33
@_author: Peter Lebbing 
@_subject: can someone verify the gnupg Fingerprint for pubkey? 
To get the public key through finger, you don't need to have a finger daemon
running, you only need the finger client. Werner is the one having the finger
daemon running.

@_date: 2012-06-09 22:14:27
@_author: Peter Lebbing 
@_subject: can someone verify the gnupg Fingerprint for pubkey? 
Where the question is going is rather simple: what would you recommend Joe
Average User to do to verify the authenticity of the GnuPG source he downloaded,
not questioning his desire to build from that source.
Contacting the package maintainer of your Linux distribution seems a good
method. You could ask them to sign the dist sig instead, and publish it on the
keyserver. Then anybody who trusts the distribution will be able to infer trust
for the dist sig.

@_date: 2012-06-16 12:14:05
@_author: Peter Lebbing 
@_subject: RFE: --update-before-use 
Werner mentioned it[1] in his reply to this thread:
(Refer to that message for more information)
[1]

@_date: 2012-06-16 12:18:35
@_author: Peter Lebbing 
@_subject: Need a GUI for e ncrypt/decrypt in Ubuntu 11.10 
You can use GnuPG from a shell by issuing (f.e.) the command "gpg --edit-key".
And then there is a GUI program which is called GPGShell. And apparently
another GUI program called GnuPGShell.
It's pretty confusing :)

@_date: 2012-06-17 20:50:15
@_author: Peter Lebbing 
@_subject: GPG with GPUs 
The OP said he encrypted to about 50 recipients. With such a small file, the
asymmetric operation will be way more significant in the total time than if the
file were much larger. You seem to be encrypting to only one recipient (you have
a default-recipient?), so the comparison is way off.
Furthermore, you'll need to establish the key size and asym cipher used for the
recipients before you can do a fair comparison. Because a tin-foil hat RSA 16k
key will be a bit more intensive than a 1k DSA key ;).

@_date: 2012-06-18 17:37:41
@_author: Peter Lebbing 
@_subject: GPG with GPUs 
Just as a datapoint: I have a VIA Nano L2200 @ 1.6 GHz, which is a slow
processor (competition for the Intel Atom), but which has a hardware RNG hooked
up to /dev/random through rngd. I'm fairly sure that it's configured correctly
and that /dev/random will not starve.
It encrypts to the first 50 pubkeys in my ring as follows:
1.51user 0.14system 0:02.02elapsed 81%CPU (0avgtext+0avgdata 12992maxresident)k
0inputs+16outputs (0major+894minor)pagefaults 0swaps
It's a 64-bit Debian testing. I had to install the "time" package[1]. I also had
to remove the "$2~/[fmu]/" test as I have only 47 valid keys :).
System load was low when performing the test. Less than 10 percent CPU usage by
other processes.
[1] The bash keyword "time" can only be at the start of a command line. It can't
be used in the middle of a pipe. It's a keyword, not a builtin.

@_date: 2012-06-19 10:55:11
@_author: Peter Lebbing 
@_subject: VIA padlock (was: Re: GPG with GPUs) 
Actually... I just checked git.gnupg.org, and I see these lines in Libgcrypt,
file random/rndhw.c:
# if defined (__i386__) && SIZEOF_UNSIGNED_LONG == 4 && defined (__GNUC__)
# define USE_PADLOCK
# endif
I'm running x86_64: the VIA Nano is a 64-bits processor. So I think Libgcrypt
doesn't recognise it can use the padlock from the VIA Nano.
It's the same with OpenSSL in Debian. I don't particularly care about support
for the HWRNG (since it's already seeding /dev/random through rngd), but I do
definitely like hardware AES on this modestly powered beast. It runs a TOR node;
I think that is the main user of the hardware AES.
So I patch Debian's OpenSSL with a patch I based on a code repository from
upstream OpenSSL, so I can use the padlock AES under x86_64. I'd submit the
patch to Debian if I could still remember from where it came...

@_date: 2012-06-20 10:56:11
@_author: Peter Lebbing 
@_subject: Need a GUI for e ncrypt/decrypt in Ubuntu 11.10 
I just call it using GnuPG from the command line...

@_date: 2012-06-21 15:57:28
@_author: Peter Lebbing 
@_subject: "SHA1 Protection" from way to see what cipher/algo was used to 
First of all, it seems you understand it, but let me emphasize this: the
algorithms you get when using the inspection method vedaal showed you, are /not/
the algorithms used to create your secret key, as you asked. There is no cipher
or hashing involved in creating a key; it's just a random number which must
satisfy some mathematical properties. Key creation is determining random numbers
that satisfy the needed properties.
The symmetric cipher and hash algorithm are used to encrypt and protect the
secret key; protection is via a password.
All the details are in RFC 4880; you could read it at, e.g., [1]. It's a very
technical document.
I'll take the output vedaal gave as an example:
A password is used to protect this key. This password, along with a known, but
random "salting" value, is repeatedly fed through SHA256 hashing (hash: 8). This
is what "iter+salt S2K" means: A String-To-Key method that iteratively hashes,
with a salt. The result of this S2K is a symmetric encryption key.
The actual secret part of the secret key is protected by a symmetric cipher,
TWOFISH (algo: 10). The secret material is encrypted with TWOFISH using the key
the S2K gave.
However, there is the possibility for an attacker to modify this secret
material. If you don't notice, he has an attack vector on you as he can modify
the key you are using to sign and decrypt. To prevent modification, the secret
key material is hashed using the SHA1 algorithm, and this hash is stored in the
encrypted part. If the attacker modifies the encrypted part, the hash won't
check out anymore, and an OpenPGP implementation will reject the key as corrupted.
So that's the purpose of the "SHA1 protection".
The hashing algorithm you can choose is the one used to create a key with the
S2K specifier. The hashing algorithm to protect against modification of the
encrypted material is fixed. Note that since it is all inside the encrypted
part, a lot of attacks that are possible on hashing algorithms won't work
anymore. SHA1 would have to be extremely broken to be problematic for this
PS: BTW, the absolute worst possible checksum to use to protect integrity, when
put inside a streaming-mode cipher, is a cyclic redundancy check. Which they
used in WEP wireless LAN protection. My mouth fell open when I learned about
this :).
[1]

@_date: 2012-06-27 17:33:43
@_author: Peter Lebbing 
@_subject: ideal.dll // fixing thread breaking 
Go to , enter your e-mail
address and password you subscribed with, and you get an interface where you can
change such settings.
For future reference, that URL is in the headers of every mail you get from the
list, btw.

@_date: 2012-06-27 17:45:31
@_author: Peter Lebbing 
@_subject: ideal.dll // fixing thread breaking 
Having switched from digest to individual message mode myself about a year ago,
I can tell you you are mistaken. I did it succesfully in the options web
interface as described in my other mail.

@_date: 2012-06-28 13:52:37
@_author: Peter Lebbing 
@_subject: ideal.dll // fixing thread breaking 
The PGP/MIME signed mail by Brad Rogers in this very thread does include the

@_date: 2012-06-28 20:50:12
@_author: Peter Lebbing 
@_subject: ideal.dll // fixing thread breaking 
I don't believe my Enigmail is willing to check any PGP/MIME signatures for
me... must be something broken with the installation. I don't really pay
attention to signatures on this mailing list, and this is the only place I
come across PGP/MIME.

@_date: 2012-03-03 10:59:00
@_author: Peter Lebbing 
@_subject: small security glitches 
And the paper exploits exactly this fact by interleaving original ciphertext and
chosen ciphertext so they can XOR to get the original keystream for a block of
original ciphertext.
The paper is only 12 pages, so if the summaries Post Cartner or Tom McCune give
are unclear, it won't take forever to read the actual paper to clear it up.

@_date: 2012-03-06 20:58:50
@_author: Peter Lebbing 
@_subject: invalid gpg key revocation 
The keyservers don't do any validation on revocation certificates; anyone who
feels like it can add /invalid/ revocation certificates to your key to annoy
you. But as soon as OpenPGP software imports the key from the keyserver, it will
simply discard /invalid/ revocation certificates as noise.
So I think the most likely thing is that someone who wants to annoy you has
uploaded not only your key, but also a fake revocation certificate to the
keyserver so the web interface will give you misleading information.
My suggestion:
- Back up your GnuPG home directory (the one with the keyrings and stuff)
- Import the key from the keyserver and check the validity of the revocation
- Perhaps restore the backup of the directory afterwards, or not
If it is an invalid revocation: unfortunate. To answer your next question: no,
it is not possible to remove your key or the false revocation from the
keyserver. This stuff is just noise. Users of keyservers need to be aware that
keyservers can contain noise, which does not harm the operation of the software,
but can be misleading, or potentially insulting. It is out of *your* control,
and therefore when looked at it sanely, also out of your responsibility.
Good luck,

@_date: 2012-03-06 22:00:05
@_author: Peter Lebbing 
@_subject: Separate user account (was Re: invalid gpg key revocation) 
I don't even do that either. Sounds to me like mainly snake oil with an
insignificantly reduced actual hacking risk.
To clarify, an attacker is able to get into your personal user account on your
desktop machine, but then unable to escalate his privileges to administrator
level? That's an odd combination of skills and lack of skills at the same time.
It only takes one vulnerable program which he can (install and?) run. Or he just
needs to wait until you become superuser from your own user account and hitch
the ride.
And you also can't access that separate user account from your own, or you face
the same problem: the attacker is effectively you on your personal account.
Watches you access the separate user account, and bingo.
These are just the most obvious ones. The subtle ones are probably much cooler.
I'm not a hacker.
I find this unnecessarily harshly formulated. He hasn't refused to do anything,
even though he's not making it easy by being so secretive.

@_date: 2012-03-06 22:51:51
@_author: Peter Lebbing 
@_subject: Separate user account (was Re: invalid gpg key revocation) 
I don't see the counterargument here: why is the situation different for
becoming that other user account or the superuser? Just because they use less
programs? Wait slightly longer, for an exploit in the programs that do expose
those accounts.
BTW, I do hope there is some skill level needed to get into the user account of,
for example, seasoned computer users (remotely, not counting physical
access). For a suitable definition of "seasoned".
Yes, I get that. Like I said, I only gave the obvious ones. Unfortunately the
small-scale remedy to those is also obvious. However, you might plug a hole, but
the sieve as a whole keeps going.
I'm not saying you should give up protecting yourself. I just don't see a
significant role of the separate user account in those efforts.

@_date: 2012-03-07 12:26:21
@_author: Peter Lebbing 
@_subject: Please help! (Alastair Langwell) 
Define "no go". What are the actual error messages when you chown? And also, do
you use root to chown? Because you need to.
Finally, you don't have execute set in the permissions for the directory. I can
only imagine this is also by accident, and it should be set. "Execute" on a
directory means the right to descend into that directory. Now only root can get
into the directory (because root can do whatever he likes, not because of how
the permissions are set).
For reference, here's a redacted version of my directory:
peter at tweek:~$ ll -a .gnupg
total 7672
drwx------   3 peter peter    4096 Mar  7 12:14 .
drwxr-xr-x 121 peter peter   12288 Mar  7 11:15 ..
-rw-r--r--   1 peter peter      19 Nov 29  2009 gpg-agent.conf
-rw-------   1 peter peter     183 Jan 31 14:13 gpg.conf
drwx------   2 peter peter    4096 Dec  8  2009 private-keys-v1.d
-rw-------   1 peter peter 3870766 Feb 17 10:31 pubring.gpg
-rw-------   1 peter peter 3870766 Feb 17 10:31 pubring.gpg~
-rw-r--r--   1 peter peter      15 Dec 18  2009 scdaemon.conf
-rw-------   1 peter peter   11282 Feb  7 13:03 secring.gpg
-rw-------   1 peter peter    9840 Feb 17 10:31 trustdb.gpg
Particularly note the drwx------ on the directory itself.

@_date: 2012-03-17 17:25:30
@_author: Peter Lebbing 
@_subject: comments on uid 
Well, the UID is what other people sign. Suppose by a wonderful coincidence
my name is Barack Obama. To prevent confusion, I create this UID
"Barack Obama (NOT the US president) "
People sign this. They have seen my birth certificate... erm... I mean
passport :), and the comment is quite helpful. Now I change the comment. I
don't think by now I need to spell it out anymore, but here goes:
"Barack Obama (US president) "
People might not be so happy they signed this UID.
But you can simply create a new UID (command adduid from --edit-key) and
delete the old UID (command deluid). That, as you say, doesn't help when
it's on a keyserver as you can't delete data from a key on a keyserver.
Likewise, people who already have a copy of your key and import your "new"
key will still have the old UID as well(!).
When other people already have your key, revoking the UID (command revuid
from --edit-key) is the standard way, if you think it's worth it for a
changed comment. As people who sign your key sign an UID, you also "lose"
all signatures when you revoke the signed UID.

@_date: 2012-03-18 11:40:29
@_author: Peter Lebbing 
@_subject: comments on uid 
Different people mean different things by signing an UID; they could
express this by policy. By the way, an UID doesn't even need to be of
the form "Full Name (Comment) " though it is certainly
recommended and standard.
So some people might not care about the comment part; others might. The
example I gave is clearly a case where it might matter. I certainly
would not sign the one with the comment "(US president)", but I haven't
personally formulated a policy on what I think about comments.
I think there are other mechanisms to add some comments to an UID, via
signatures with notations. Other people might know more about this. If
you want to add comments that you can freely change, this might be more
what you're looking for, rather than changing the UID.
I should note that many people actually *don't* check if the e-mail
address belongs to the person whose UID they sign. If this were as
"simple" to prove as it is to prove you have a certain name by showing a
passport or something, it might be checked more often. But that's
government regulated, unlike e-mail addresses. All you can easily prove
is that you have access to an e-mail account, which is something
completely different. Just to begin with: so does your e-mail provider.
If you haven't given the key to anyone (the copy in your own keyring is
the only copy in existence), you can just add the new UID with adduid
and then delete the old one with deluid. A key needs at least one UID,
so you first need to add a new one before you delete the last and only UID.
The only catch is that if there is a copy in existence with the old UID,
and you import to that keyring the new version with the new UID, it will
have both UIDs.

@_date: 2012-03-18 21:43:23
@_author: Peter Lebbing 
@_subject: comments on uid 
The attacker is doing you a real service getting /your/ key signed then :)
Wasn't the purpose of the attacker to get his /own/ key falsely signed? The key
he does have access to?
BTW, your e-mail service provider does, necessarily, have access to mails sent
to your e-mail account. SSL/TLS might encrypt the connection to the SMTP server
serving your e-mail address, but the provider has the certificate for that
server, or more generally, has full access to their own server. So the
administrators of that SMTP server have full access to any mails sent to your
account, if they want to.
Obviously using GnuPG solves that problem, but not before identity is
established, and here we are talking about establishing that.

@_date: 2012-03-18 22:39:25
@_author: Peter Lebbing 
@_subject: comments on uid 
We could have a simple misunderstanding here: I do think many people check if
the person whose UID they sign have /access/ to the e-mail address in the UID.
But I'm making a distinction between access and "belonging".

@_date: 2012-05-04 21:41:25
@_author: Peter Lebbing 
@_subject: SSH Agent keys >4096 bit? 
And here is precisely something interesting: 8k RSA is discussed as a method
to keep messages confidential for decades. I haven't looked into it, but I'm
under the impression RSA is used purely for authentication in SSH, not for
key exchange[1]. What are you protecting decades against here? A server
reusing a random challenge? That seems quite far fetched.
Oh, by the way, only the computational load for the client was discussed.
There's also the server (although the public side of the computation is
quicker than the private side). The server gets logins from potentially a
lot of clients.
[1] I get this impression because there is a configuration option for
OpenSSH sshd that selects which key exchange methods to use, and they all
have DH (Diffie-Helmann) in their name.

@_date: 2012-05-05 12:08:58
@_author: Peter Lebbing 
@_subject: SSH Agent keys >4096 bit? 
Why should the GnuPG authors include a feature they don't believe in? If
it's in GnuPG official, it will need to be supported. What if there is
some bug that only rears its ugly head with 8k keys? They'll need to
spend more time on it, time better spent elsewhere.
And especially, why should they add something they simply don't believe in.
The use of 8k keys is bothersome to others. In the GnuPG case for
certifications and signatures, and in the SSH case for the owner of the
server you're logging in to and burning unnecesary CPU cycles.
I don't think it's up to you to decide that the GnuPG authors need to
officially support something they find silly.
And you seem to forget that when you use GnuPG with (for example) 4k
keys, the 4k key is simply not the weakest link! This has been said already.
It's an interesting take on things, that the GnuPG authors somehow think
your data must be invaluable, because they don't offer 8k RSA. If your
data is that valuable, keep it to yourself. Don't give even the
encrypted variant to your enemy. Because your formidable enemy will know
of a way to decrypt it without breaking your 8k key.

@_date: 2012-05-05 13:09:48
@_author: Peter Lebbing 
@_subject: SSH Agent keys >4096 bit? 
Well it's not my fault someone else went off-topic is it? If you are
here to persuade the GnuPG authors to include AES256 you're too late.
I think you can perfectly discern what message I was intending to get
I am very well aware of that. They don't convince, because they don't
tackle the problem of the weakest link.
Please read these three quotes again carefully. You are saying you
yourself are off-topic; discussing something totally different. I agree.
GnuPG should include 8k RSA because I didn't go through the trouble of
disabling AES256 in my browser, risking breakage when an oddball
webserver administrator disables all algorithms but AES256?
You also indicate yourself where this goes askew: RSA 8k is immensely
more CPU intensive than AES256 v AES128.
I was replying to:
I read that as: GnuPG authors decide your data is not valuable enough
for RSA 8k. I'm unsure how else to read it, but it certainly isn't /my/
conclusion, it's what I read as /your/ conclusion. Please don't make it
my conclusion, I would have to severely disagree with myself, and I hate
it when that happens.
A large error I made: I wrote invaluable when I meant not valuable at
all. Is this the source of the confusion?

@_date: 2012-05-05 14:05:13
@_author: Peter Lebbing 
@_subject: SSH Agent keys >4096 bit? 
I am sorry if I somehow offended you. That's the feeling I get from your
latest mail. It was not the intention.
I do want to note that no matter how careful you read, English is
multi-interpretable and ambiguous. So when someone interprets a
statement differently than you do, it does not necessarily mean they
must not have read carefully enough.

@_date: 2012-05-05 20:03:04
@_author: Peter Lebbing 
@_subject: SSH Agent keys >4096 bit? 
Okay, going out on a limb here, since all what I say is conjecture.
Actually consulting the SSH RFC's seems like too much work, or seems too
much like work :).
I think it's rather the case that the size of the DH parameters is
proportional to the keysize of the symmetric algorithm used to secure
the SSH session, because the DH params are used to compute the session
key. So you are right that the DH params are proportional in size to a
key used, but you've confused the keys, asymmetric vs symmetric. That
way it makes sense to me.
If I look at the debug messages emitted by the OpenSSH client, I'm under
the impression that key exchange is already completed before
authentication with RSA starts.

@_date: 2012-05-06 10:09:38
@_author: Peter Lebbing 
@_subject: SSH Agent keys >4096 bit? 
Ah, yes, I misunderstood your point.
But the DH protects the session. Cracking DH will get you the session
contents. RSA is only used to authenticate. If it weren't for the
symmetric encryption of the session, you can probably even get a
(plaintext,ciphertext) pair. I've quickly snooped through the RFC's. RSA
is used by the client to sign the "session identifier", which is
determined by DH.
Determining the (plaintext, ciphertext) pair from RSA gets you nothing
in this case. Which is fortunate, because the server you log into also
has the (plaintext, ciphertext) pair after you authenticate.
Actually factoring the semiprime is obviously something completely
different. But we were talking about keeping confidential messages
confidential for decades. There is nothing confidential about an
authentication challenge. Confidentiality is encryption. Authentication
is a form of signing[1]. With signatures, the plaintext is not confidential.
The /server/ is authenticated during key exchange. The /client/ can also
be authenticated with a plaintext password sent over the encrypted
connection to the server. I don't think the client is authenticated
until after key exchange, whether you use RSA or a password (or another
form of authentication).
[1] Signing a challenge, which is still quite different in nature from
signing data.

@_date: 2012-05-06 20:15:19
@_author: Peter Lebbing 
@_subject: Why the "--export-secret-key" switch is not listed in help screen? 
It does say in the "gpg --help" output:
There are many more options and also commands in the full man(ual) page.
I suppose it was thought that exporting a private key was such a
relatively "rarely used" command it did not need to be among the most
used commands listed by "--help". Or it was simply an oversight :).

@_date: 2012-05-08 12:12:58
@_author: Peter Lebbing 
@_subject: secret key not found 
Are you literally entering DIR? Because it was intended to be an indicator that
that is the place you should place the wanted directory name, as in for example[1]:
--homedir "C:\Documents and Settings\Rupali\Application Data"
or something similar.
[1] I don't use Windows, so I might make a mistake in syntax or actual directory
names or something like that

@_date: 2012-05-22 17:50:47
@_author: Peter Lebbing 
@_subject: Some people say longer keys are silly. I think they should be 
Or bugs only affecting large keys are not found because so few people use it,
and it becomes an attack vector affecting only those using large keys.

@_date: 2012-05-22 20:03:24
@_author: Peter Lebbing 
@_subject: Some people say longer keys are silly. I think they should be 
This presupposes that "people" will equate the whole movement with this single
individual. This is definitely not unlikely, though :-) [1]
[1] After all, *all* people generalise! ;)

@_date: 2012-05-22 20:09:41
@_author: Peter Lebbing 
@_subject: Some people say longer keys are silly. I think they should be 
David and Hubert, could you please trim the quotes in your replies? I'm typing
this with one hand because my scroll finger is cramping... ;) j/k

@_date: 2012-05-23 11:37:33
@_author: Peter Lebbing 
@_subject: Testing GPG EMail encryption 
A simple challenge-response system should suffice, I'd say. When a new user
mails to such an address, he receives a reply with a code that should again be
mailed back to indicate the user is a human and can respond to the challenge.
Bots could be adapted to defeat a lot of variations of this, but when it's a
special-purpose design, I don't think it would be worth their time. Otherwise,
use a captcha. I've never seen captcha's used in e-mail traffic, but it's easily

@_date: 2012-05-31 11:59:38
@_author: Peter Lebbing 
@_subject: Setting comments in gpg.conf 
Works for me. I just included this line in gpg.conf:
comment Works for me
It results in this line in an ASCII armoured signed message:
Comment: Works for me

@_date: 2012-11-05 13:54:32
@_author: Peter Lebbing 
@_subject: Is the signature encrypted 
You can find out yourself whether GnuPG encrypts the signature. I did the following:
$ echo Hoi|gpg2 -o bla.gpg -r de500b3e -se
$ gpg2 --list-packets --list-only bla.gpg
:pubkey enc packet: version 3, algo 1, keyid 26F7563E73A33BEE
        data: [2048 bits]
:encrypted data packet:
        length: 368
As it turns out, the signature is inside the "encrypted data packet" (since it's
not outside it). So the answer is: yes, GnuPG does encrypt the signature. To
check there is indeed a signature:
$ gpg2 --list-packets bla.gpg
:pubkey enc packet: version 3, algo 1, keyid 26F7563E73A33BEE
        data: [2048 bits]
:encrypted data packet:
        length: 368
        mdc_method: 2
gpg: encrypted with 2048-bit RSA key, ID 73A33BEE, created 2009-11-12
      "Peter Lebbing "
:compressed packet: algo=2
:onepass_sig packet: keyid 969E018FDE6CDCA1
        version 3, sigclass 0x00, digest 2, pubkey 1, last=1
:literal data packet:
        mode b (62), created 1352119549, name="",
        raw data: 4 bytes
:signature packet: algo 1, keyid 969E018FDE6CDCA1
        version 4, created 1352119549, md5len 0, sigclass 0x00
        digest algo 2, begin of digest b0 37
        hashed subpkt 2 len 4 (sig created 2012-11-05)
        subpkt 16 len 8 (issuer key ID 969E018FDE6CDCA1)
        data: [2046 bits]
This time I decrypted the packet (I omitted --list-only and it asked for my
smartcard PIN). Unfortunately (IMHO), --list-packets doesn't show hierarchy, so
it's not very apparent that the signature is inside the encrypted data packet,
but this time we do see a signature, so it's obviously there.
An interesting followup question is: does the OpenPGP standard dictate that it
be done this way, or is it left up to the implementer? I think somebody else
will know this without checking (I do not).

@_date: 2012-11-05 16:30:23
@_author: Peter Lebbing 
@_subject: new release of GPA 
I'd just like to say: *Thank you* for your constructive contribution.

@_date: 2012-11-05 16:55:35
@_author: Peter Lebbing 
@_subject: Is the signature encrypted 
You're constricting your view too much to just e-mail in your analysis. If you
look at files stored on someone's hard drive, you don't have a "from address".
The signer of that secret data in that file might be confidential as well.

@_date: 2012-11-29 10:16:51
@_author: Peter Lebbing 
@_subject: GPG W32 1.0.6-2 - PRIVATE KEY IMPORT ISSUE 
I'm confused by the version numbers you indicate. They sound like they're
prehistoric, unsupported and simply too old to use.
It should be:
gpg --allow-secret-key-import --import "secretkey.txt"
You are allowing secret key import, but not actually importing. You're invoking
the default action, which for keys is displaying them, not importing them. So
you need to specify that the wanted action is --import.
Good luck,

@_date: 2012-10-17 11:48:34
@_author: Peter Lebbing 
@_subject: lock/backup files 
If you mount them with a shell command, you could write a wrapper shell script
that you invoke instead of that command, like such:
You previously did
$ truemount /dev/sda3 /encrypted
You write a shell script:
-----8<---cut here--->8-----
truemount "$1" "$2"
find "$2"/'*.lock' -delete
-----8<---cut here--->8-----
Call this shell script mytrue, or such, and from now on use
$ mytrue /dev/sda3 /encrypted
Please don't use this actual script. It needs a whole bunch of extra safeguards
because the find/delete command is so destructive.
Just an idea. Good luck.
PS: I haven't ever used truecrypt, I just invented a command name :).

@_date: 2012-10-31 19:21:33
@_author: Peter Lebbing 
@_subject: new release of GPA 
It's code running as the user invoking it; it's not in any way restricted to
solely interfacing GnuPG. And if you have plans to attack people who use GnuPG,
putting your backdoor in a GUI for GnuPG means your backdoor ends up at people
you want to target. So it makes sense to put your backdoor there, and not in
something else.

@_date: 2012-09-05 21:25:13
@_author: Peter Lebbing 
@_subject: A safe text editor 
Is it me or does that plugin default to using temporary files, pretty much
defeating the whole purpose? Makes me wonder how well thought out this script is.

@_date: 2012-09-09 20:39:55
@_author: Peter Lebbing 
@_subject: A safe text editor 
Personally, I'd have more faith in a text editor that was written ground-up with
security in mind. If you take a full-fledged editor that was never intended to
hide the contents, and then bolt on the security with some scripts, it's quite
likely you're missing some way in which it is leaking your data.
On the other hand, you have to consider your threat model. It could be enough.
But I wouldn't be surprised if that nephew of yours who's good with computers
got hold of one of your passwords, greps your whole hard disk for that password,
and thus uncovers some temp file or swap page with all your passwords neatly
arranged around that one password he knew.
By the way, I don't suspect vim scripts can lock memory pages, so it could
indeed very well be a swapped out memory page that will match the grep expression...

@_date: 2012-09-09 21:16:34
@_author: Peter Lebbing 
@_subject: A safe text editor 
You seem to have quite misunderstood my mail? There was absolutely nothing I was
trying to prove by polemics with things you didn't write, I have no clue
whatsoever what you are talking about.
I was merely stating that I don't have a lot of faith in the correct workings of
a vim plugin that tries to keep your private texts out of temp files and the like.
And the nephew was the *metaphorical* whizzkid that every now and then comes by
and either completely fixes or catastrophically blows up your computer. I have
no idea about your family and don't intend to have.
Again, you read something completely different in that mail from what I was
trying to write.
I apologize that I seem to have offended you, though I am baffled as to how I
did that.
HTH = Hope To Help,

@_date: 2012-09-09 23:02:30
@_author: Peter Lebbing 
@_subject: A safe text editor 
Are you talking about how an encryption/signing tool is not a text editor??
What's with the sudden demeaning criticism?
PS: I must say I'm a bit surprised nobody here seems to know any good
secret-text-editors. I just fail to see how this is a failure of OpenPGP or
GnuPG. Or the people here.

@_date: 2012-09-11 16:16:42
@_author: Peter Lebbing 
@_subject: A safe text editor // why?? 
I think people want it because editing a text file *now* might expose the data
*far into the future*. Temp files and swap pages have the potential to live on
your hard disk for a very long time. So you might trust that today your computer
is safe, but you might feel less confident that the hard disk in your system now
won't somehow be exposed to some bad guy in the possibly rather distant future.
By the way, you say cleanse the memory. I'm not sure what you mean. We are
talking about temp files and swap pages that end up in random blocks on your
hard disk. If that block is then allocated for a 10-byte file, the rest of the
block data, containing your decrypted text file, will live for at least as long
as the tiny file that is now in that block. The only sure-fire remedy against a
temp file that got deleted is a full wipe of the partition the file was on, as
far as I know.
I have done this one time or another. I knew I wanted to edit some document
which would or might end up on my hard disk, but I absolutely wanted it kept
"safe". So I made a full image of the hard disk (every single byte of the hard
disk), edited the file, then restored the full image, every single byte of it.
In this particular case it seemed the easiest way, but it does mean pumping data
across for hours.

@_date: 2012-09-11 16:32:39
@_author: Peter Lebbing 
@_subject: A safe text editor 
You are absolutely right. But a text editor should be a rather simple target,
and it would fill a lot of needs (secret memo's and such). People never seem to
ask for a secure media player or photo editor, and it would be a lot more
difficult to write properly. But since a basic text editor shouldn't be that
hard to write, I'd think that somebody already designed one that locks its pages
in memory and interfaces securely with GnuPG to read and write OpenPGP text
files in a way that leaves no trace on hard disks.
In fact, I would personally fork over 50 euros for such a "secure" text editor
written by an author I trust. Perhaps we could ask Werner Koch to implement a
basic text editor and do some sort of fundraiser? I'd trust /him/ to write a
proper piece of code :). You want someone who knows where the pitfalls are with
keeping all your data in memory and not trusting user input (buffer overflows
and such). Validating user input should be straightforward enough if you only
allow printable ASCII (and the obvious controls like line feed).
Pour in a bit of copy-paste that avoids the system clipboard unless requested by
the user, and I think you have a recipe for a pretty functional text editor for
playing 007. Or Spy Girls. Perhaps even serious business, although /apparently/
that user base is somewhere else.
(Obviously, we need to be a bit more serious and specific about requirements
before actually starting this. I want my Spy Girl suit in bright pink.)

@_date: 2012-09-11 16:39:46
@_author: Peter Lebbing 
@_subject: options file usage 
You can see what the home directory of GnuPG is with the command
gpgconf --list-dirs
This all sounds about right, but I'm hesitant to outright confirm it because I
might have a detail wrong :). And it's a nicely detailed question.

@_date: 2012-09-11 16:57:36
@_author: Peter Lebbing 
@_subject: options file usage 
Oh, wait, no. I think you're supposed to name it gpg.conf, and that "options" is
some sort of legacy name that is also accepted? gpg.conf is the normal file you
would use to store your configuration, I know that for sure.

@_date: 2012-09-11 17:25:43
@_author: Peter Lebbing 
@_subject: A safe text editor // why?? 
So you store the unencrypted file to /tmp and edit it there with whatever
program is needed? Say you're editing an image. Personally, I have a .thumbnails
directory in my *home directory*. This would probably include thumbnails of
files I edit or browse in my /tmp directory. This leaks image information
outside the /tmp partition.
So you have to completely trust that the program you're using is keeping all
data in /tmp, which I certainly do not. Not in the last place because that was
never a requirement when the program was written.
This is not true. What if the 10-byte file I mentioned gets allocated on the
block that contains unencrypted information? There are programs that will try to
fill the internal fragmentation (slack space) thus created, but they warn that
this is racey for obvious reasons. It's not sure-fire.
And then we haven't even started discussing journalling filesystems.
I didn't go into the specifics, partly because I'm not sure anymore. But I am
sure that the tools I needed were not in an off-the-shelf live image so that
rules out the booting from live option.
I wasn't debating the merits of the method, to be honest. I was giving a
real-life example of avoiding leaking data to your hard disk.

@_date: 2012-09-11 17:55:13
@_author: Peter Lebbing 
@_subject: A safe text editor // why?? 
I also have an OS on full disk encryption (not my regular workstation OS). I
still see a use for a "safe" text editor, for example as a lightweight
alternative to FDE.

@_date: 2012-09-13 19:18:30
@_author: Peter Lebbing 
@_subject: encryption/decryption without files 
Also, this would obviously end up in the history file unless you turn that off.
Better just invoke gpg, start typing and end with Control-D.
$ gpg -c -a
just a test

@_date: 2012-09-13 19:50:00
@_author: Peter Lebbing 
@_subject: encryption/decryption without files 
I just thought of the fact that probably the text can still end up in swap as
well. The text is probably in the memory of the shell.

@_date: 2013-04-01 20:14:48
@_author: Peter Lebbing 
@_subject: smartcard: transferring to another account 
Importing the public key /should/ be enough, and when GnuPG sees the smartcard,
it will create the corresponding stub.[1]
So there is something wrong. But what exactly would be a whole lot easier to
establish if you could give some more details. Which operating system are you
using? Be as specific as you can, e.g., "Debian Squeeze" instead of "Linux", or
"Oracle Solaris 10 1/13" instead of "Solaris". Which versions of GnuPG and
associated programs and libraries, and what are the exact messages spewed by
those programs when you try to import keys and use your smartcard. Obviously you
can edit in it to remove identifying information. Don't just hand out debug logs
from the smartcard without recognising your PIN in the hex dump there ;).
[1] Once. So if you have two smartcards with the same key on them, you can't
(without further adjustments) mix those two smartcards because it will ask for
the one it saw first.

@_date: 2013-04-04 12:44:45
@_author: Peter Lebbing 
@_subject: Create subkey that will expire in 10 hours 
The doc file DETAILS mentions it for unattended key generation:
Although I interpreted it to mean the number of seconds since the epoch.
I didn't realise the notation was also valid for interactive key generation,
though. Otherwise I would have answered OP, because I found it while looking for
the answer to his question.

@_date: 2013-04-04 22:19:04
@_author: Peter Lebbing 
@_subject: Fingerprint of the subkey just created? 
A subkey doesn't really have a fingerprint, AFAIK. You use fingerprints to
identify/verify a key as a whole, which means the primary key.
I tried the following:
$ gpg2 --status-fd 0 --edit-key And indeed I get a whole lot more data, but not a key id. It ends in
[GNUPG:] KEY_CREATED S
However, I then tried again with:
$ gpg2 --verbose --verbose --status-fd 0 --edit-key Which was... very verbose, and included:
gpg: writing key binding signature
gpg: RSA/SHA1 signature from: ""
gpg: RSA/SHA1 signature from: "D8AB7B20 [?]"
gpg: writing key binding signature
gpg: RSA/SHA1 signature from: ""
gpg: RSA/SHA1 signature from: "D8AB7B20 [?]"
I did this with a test key which I used for a spam experiment, and I don't want
to crosspolenate that experiment, so I removed identifiers. But the "D8AB7B20
[?]" was the short keyid for the subkey.
This is for a signing subkey. If I repeat it for an encryption subkey, the key
binding signature is unidirectional, since an encryption subkey can't make a key
binding signature. So this method only works for signing subkeys. I don't have
reason to believe you need the --status-fd, and you could check if one --verbose
(or the short form) is enough. I just made supersure I had a lot of output :).

@_date: 2013-04-05 22:27:31
@_author: Peter Lebbing 
@_subject: gpg for pseudonymous users [was: Re: gpg for anonymous users 
I have no idea how Red Hat does this, but it seems unlikely to me. It's
not connected to the internet, but signs the whole repository, and each
individual security update etcetera. Is there a guy who keeps going back
and forth with a USB stick between this terminal and another?
AFAIK, in Debian, individual maintainers sign the packages they maintain
from their own systems. Some might choose to do a complicated dance with
a USB stick, but I expect many to sign on a net-connected machine. And
then an automatic signature follows from the repository key when the
maintainer's signature matches.
Last time I said AFAIK on this list I was wrong, though.

@_date: 2013-04-08 11:52:41
@_author: Peter Lebbing 
@_subject: (OT) Re: gpg for pseudonymous users 
I think you misread a statement /I/ made. I said individual maintainers
in Debian sign packages. They do not sign built binaries, but rather the
source package. After that, an automated build system takes over.

@_date: 2013-04-15 12:23:39
@_author: Peter Lebbing 
@_subject: Backing up Private Keys 
You should take a look at PaperKey[1]. It will produce text with some
redundancy for error checking that is the most concise description of the
secret part of your key. That means it is only the secret part, and in the
case of PaperKey, you /do/ need a separate backup of the public key to
reconstruct your secret key. But public keys are usually kept in several
public places.
The usual answer here is: stick to the defaults. They are the defaults for a
reason. Choose a good passphrase, other than that, the system is secure.
By the way, you say "more vulnerable to a brute-force attack". But a
brute-force attack is usually not associated with vulnerability. Anything
verifiable[2] can be brute-forced. The deciding factors are the number of
possible combinations and the computing power needed to do one guess. Seeing
the number of possible combinations in the crypto primitives used by the
default GnuPG settings, you shouldn't worry about brute forcing. I'd say
it's impossible.
There are no strongest settings. Different algorithms have their own strengths.
I think you're confusing the term "brute force" with the term "crack" or
something similar. --s2k-count is the most deciding in how difficult it is
to brute force, I think. A criticism of SHA-3 is that it can be so quick
that this might be an issue in some settings, but you can't choose SHA-3 as
the s2k-digest-algo anyway ;).
The defaults are fine. You could opt to use 3DES or AES instead of the
default CAST5. But your secret key is already safe with CAST5, so there
really is no need. If it were not safe by a big margin, it wouldn't be the
default. The authors of GnuPG weren't born yesterday.
If attackers already need all the energy of 5 suns to crack your private
key, it really doesn't matter if they need an additional 5 when you tweak
the settings. Attackers don't usually have 5 suns in their back pocket.
We're talking about completely hypothetical cracks already, barring any
major (and unforeseeable) advances in mathematics.
If you choose to believe me, obviously. I'm not a cryppie, and even cryppies
are only human.
[1] [2] Complexity class NP. Apart from the one-time pad, I don't think there is
useful crypto outside NP (I wouldn't call OTP very useful either ;). I'm
interested in hearing any arguments why something outside NP would be useful.

@_date: 2013-04-15 22:14:04
@_author: Peter Lebbing 
@_subject: Backing up Private Keys 
Just a very quick answer: this doesn't account for thermodynamics. Other
calculations for instance relate to the energy required to destroy/change a
certain amount of information. There's an information-theoretic limit to that,
and if the models hold it is not possible to flip a bit with less energy expended.
Furthermore, you are now indeed in the realm of almost brute force[1]. Security
of a cipher algorithm is no longer significant. What matters is the amount of
calculations needed for one guess. Off the top of my head I don't think this
depends significantly on the cipher. It depends on the hash algorithm (not it's
strength, it's amount of computation), and --s2k-count.
Also, calculating it depends on a good measure of the entropy of your
passphrase; the 10^25 you mention.
Dunno. What would a 19th century academic say of my Core 2 Duo PC with a video
card that can spit out nearly 50 milliard textures each second?
Other than that: do you care what people by then do with your stuff?
[1] You're still making educated guesses about the password, right?

@_date: 2013-04-16 11:50:36
@_author: Peter Lebbing 
@_subject: [OT] Trusting X.509 certificate 
Everything the certificate "says" is under attacker control when they redirect
the HTTPS session to their own system[1]. You need to find a trust path based
on cryptographic signatures, not on what the Subject and Issuer fields and
what not say in the certificate.
[1] With the possible exception of the fingerprint (and perhaps some other

@_date: 2013-04-22 13:52:50
@_author: Peter Lebbing 
@_subject: One Private Key for several users 
I consider this bad advice; just don't copy the random_seed file and let each
system generate its own.
Humans are notoriously bad at generating randomness, probably due to our
tendency to assign meaning and order to everything we encounter in life.
I also don't really see how it relates to OP's question.

@_date: 2013-04-22 14:06:03
@_author: Peter Lebbing 
@_subject: One Private Key for several users 
Oops, slight case of grumpiness? Since it's advice given in good faith, let me
rephrase that more pleasantly.
I don't think you should do that.
There, much better :). Sorry. My mistake.

@_date: 2013-04-22 19:26:35
@_author: Peter Lebbing 
@_subject: BCC'ing recipients on a mailing list 
Hello HHH,
It would appear that you BCC'd me on the message I'm replying to, because I got
it twice: once without going through gnupg-users and a copy sent through
gnupg-users. The messages have the same Message-ID and ID assigned by the first
mail server, so it's really a duplicate.
Please try not to BCC people that are on the list. The mailing list managing
software can't know that I was BCC'd and will send me a copy, which it wouldn't
do if it saw me in To or CC.

@_date: 2013-04-26 19:29:55
@_author: Peter Lebbing 
@_subject: Confusion with signature digest type. 
I think you're mixing things up. pref-hash-algos is the algorithms you'll
accept from others.
The page you linked to mentioned this to test if you use SHA-1 as the
self-signature digest algo:
gpg --export-options export-minimal --export  | gpg --list-packets
(should be one line)
The pref-hash-algos is the next section of the document.

@_date: 2013-04-28 13:34:39
@_author: Peter Lebbing 
@_subject: Web of Trust in Practical Usage 
I might be misinterpreting your request, because I can see two slightly
different interpretations and I'm going with only one of those! ;)
While signatures have a certain transitive quality (A signed B, B signed C,
there is a path from A to C), /ownertrust/ is not applied transitively[1]. This
means you'll still need to assign trust to a key introducing another key.
So if you're A, A signed B, B signed C, C signed D, you still need to assign
ownertrust to C /yourself/ to get D valid, and this has nothing to do with
ownertrust you assign to B.
So while tools like PGP Pathfinder can find signature paths, it doesn't really
help for validity, which needs ownertrust of a direct parent of the key you want
validated. There are no ownertrust paths.
Suppose you are downloading key D from a keyserver, and some tool decides there
is a path from A to D and it needs key C for that. If C is not already in your
keyring, it could download C for you. Superficially, this would seem to help
establish trust in D. But what good does it really do? Because you'll need to
assign ownertrust to C, and if you don't know C, how can you trust him or her?
And if you know C, why isn't he or she in your keyring already?[2]
I am most definitely not saying your request isn't a good one. Neither am I
saying there isn't a beatiful, elegant solution. Because I don't have enough
grasp of the material myself, and I might miss a lot. I'm also personally very
interested in tools to (meaningfully) expand the number of valid keys in my
keyring, which is why I was thinking about the exact same thing as you, but in
that line of thought I encountered the obstacles I just described.
So yay for more meaningfully valid keys on my keyring. I just don't see how :).
[1] I'm leaving trust signatures out of the picture, as they're uncommon in the WoT.
[2] If C was in your keyring already and you assigned ownertrust, the newly
imported D would immediately get some validity, so there's no extra tool needed.

@_date: 2013-04-29 16:02:03
@_author: Peter Lebbing 
@_subject: gpgee operation failed 
It says "Key validity - Unknown", so it seems you haven't signed the key and
GnuPG is refusing to encrypt to a key of which the identity is unverified.
Are we talking about GnuPG 1.1.4? Because that should be exhibited in a museum
instead of run on your computer. It is way too old to use.
If it's the GPG4Win version, I can't tell how old it is.
PS: I might be mistaken, but I think you're not supposed to include pictures in
mails on the mailing list. It's better to put it on the web somewhere and
include a link to it in your mail.

@_date: 2013-08-06 14:18:12
@_author: Peter Lebbing 
@_subject: Identifying your private key by the public KeyID 
Key IDs are /always/ based on the public key, not the private counterpart. So
the private key is also identified by the ID of the related public key. Can
you give an example of where you see different IDs which led you to believe the
private key had a different ID? Because I think you misunderstood something
about that.

@_date: 2013-08-12 11:18:23
@_author: Peter Lebbing 
@_subject: How to create new keyring from an existing key in an existing 
gpg --export 0xDEADBEEF | gpg --no-default-keyring --keyring \
(one long command line)

@_date: 2013-08-12 20:55:47
@_author: Peter Lebbing 
@_subject: [OT] Re: How to create new keyring from an existing key in an existing 
I simply took his own example.
Bad idea. It makes my eyes hurt, 1777 and trusted directly next to eachother ;).
I think it's not really directly related to the question, but if it were
relevant, I'd say that the correct way would be to let the ordinary user create
the file elsewhere and then have root move it to that directory, /after/
changing ownership of the file to root.
Eh? A bit sinister interpretation, but okay: I took 0xDEADBEEF for the fact that
it's a 32-bit identifier that's mildly funny. I still needed a filename for the
keyring, so I stored the dead beef in the meat file.

@_date: 2013-08-20 21:43:57
@_author: Peter Lebbing 
@_subject: need help for GPG 1.2.1 binary for REHL 5.8 
You're trying to install a version released in 2002 on an OS released in 2012.
I'm not surprised you can't find binaries! Why do you want to do this? 1.2.1 has
known issues and should not be used these days. It's more than a decade old!
I think your effort is much better spent on changing your workflow to use the
latest 1.4 release. Again, why do you want to install 1.2.1?

@_date: 2013-08-20 23:02:17
@_author: Peter Lebbing 
@_subject: need help for GPG 1.2.1 binary for REHL 5.8 
I didn't mean to say the OS is old or obsolete :). I meant the GnuPG version was
much older than the OS, so people don't usually make such a combination, hence
people don't build those binaries.
(Actually, RHEL 5 is from 2007, I only looked at the release date of the update,
so I accidentally made it sound more extreme than it was)
It might make a lot of sense to install the latest (or at least a recent and
supported) version of the 1.4 tree. Or it might make sense to install 2.0 as you
say, but the upgrade path from 1.2.1 to 1.4.x is easier.

@_date: 2013-08-22 10:48:28
@_author: Peter Lebbing 
@_subject: need help for GPG 1.2.1 binary for REHL 5.8 
The mail got delivered to me without generating a bounce, or as my primary mail
server liked to put it:
2013-08-21 02:48:53 1VBwbV-00021r-DK <= prvs=93857aca4=snehendu.ghosh at tcs.com
H=inmumg02.tcs.com [219.64.33.222] I=[83.161.152.50]:25 P=esmtp S=12319
id=OF6479E12C.F115F479-ONCA257BCE.00031D1A-CA257BCE.0004895B at tcs.com
2013-08-21 02:48:54 1VBwbV-00021r-DK => peter at digitalbrains.com
R=special_routing T=remote_smtp H=butters.digitalbrains.com [2001:980:a370::4]
X=TLS1.0:RSA_AES_256_CBC_SHA1:32 C="250 OK id=1VBwbM-0008DP-6l"
2013-08-21 02:48:54 1VBwbV-00021r-DK Completed
The mail also got delivered to gnupg-users as the web archive has it, so I think
the problem was either on your side or with one of the CC:-addressees.
I don't understand what you mean.
On to the subject...
I keep being amazed by companies using very old software which handles data
coming from the internet. Especially if that software includes GnuPG, which is
supposed to Guard something. All this old software is simply not safe anymore
because there are known security issues /which have not been fixed/ because you
are supposed to use a more recent version where the issues /are/ fixed. Back
then, the programs were fine because the security issues were (in principle) not
known, and people need to know about the issue to exploit it (or fix it). These
days, the issues /are/ known and a bit of Googling or reading release notes can
get you on the path to exploitation. I'm not talking about GnuPG here
specifically, I'm talking about ancient, unsupported software in general.
You don't /see/ security issues.
I wholeheartedly agree with Robert J Hansen's reply: GnuPG implements the
OpenPGP /standard/. Different implementations are explicitly supposed to work
with eachother, and there should be no problem with using 1.4 with 1.2.1.
"Should be" is not meant to say "I'm reasonably sure", it's meant to say "it's
designed that way".
This is a public mailing list for users enthusiastic about GnuPG and the
developers to talk about the program and crypto in general. If you need
commercial support, please contact g10 Code GmbH, owned by Werner Koch, the
principal author of GnuPG.[1]
Good luck,
PS: Some people on this list would much prefer it if you send plaintext mails,
without the HTML part. Or, as in the "About Gnupg-users" text on the mailman
[1] [2]

@_date: 2013-08-22 11:23:10
@_author: Peter Lebbing 
@_subject: key management & APG 
You would use an offline system which has the offline main key. Just copying the
main key back to your "normal" system would pretty much defeat the purpose. I
think "the purpose" is, by the way: "If my normal computer gets compromised in
the future, at least the attacker won't have my primary private key". I suddenly
thought of something which I'll come back to in the end.
So you would use an offline computer. Your offline system is not connected to
the internet, but you need to get data in and out. So you would for instance use
a USB key. It's also an attack vector, but you have to have something. There
simply is no perfect security, so at some point you need to compromise.
You transfer the key you want to sign to the offline system. On the offline
system, you simply do something along the lines of:
$ gpg2 --import /media/usb-key/someone_elses_key.gpg
$ gpg2 --edit-key "Someone Else" sign
And then you still need to transfer the signed key to the outer world. So you
put it on your USB key:
$ gpg2 -o /media/usb-key/someone_elses_key_signed.gpg --export "Someone Else"
And on your normal system, you import it and, e.g., send it to a keyserver:
$ gpg2 --import /media/usb-key/someone_elses_key_signed.gpg
$ gpg2 --send-key "Someone Else"
Note that it is not necessary to specify "sign" as the command for --edit-key.
If you don't give a command, you can then enter it in the interactive --edit-key
menu. Also, for the lone --send-key on the final command, you need to have a
default keyserver configured in gpg.conf, otherwise you need to specify it on
the command line.
I suddenly noticed something in Hauke's advice while I formulated my "future
compromise" scenario. I read his advice as "create the key on your normal
system, then delete the primary key from that system". But deleted files are
usually still on the hard drive. If I hacked your system and were interested in
your private key, I'd probably search all free space on the hard drive for data
that looks like a private keyring. I might be able to extract your private key,
even though you thought you were safe because you deleted it. I would advise to
create the whole key on the offline system you will be using to sign people's
keys, and export the subkeys to your normal system. You might want to wipe all
free space on your hard drive if you generated it on your normal system. Don't
forget the internal fragmentation at the end of allocated files; or to put it
more practically: use a tool that doesn't forget this ;). Journals can be nice
to snoop around in too. I tried to find a wipe tool in the Debian package
manager just now that said it also took care of the journal, but I can't find one.

@_date: 2013-12-01 11:12:00
@_author: Peter Lebbing 
@_subject: Aw: Re: multiple keys with different UIDs and common WoT? 
Yes, you are of course correct. I forgot the other side for a moment :).
How about this:
- On your work PC, you only have the secret subkeys (signing and encryption) of
your work keypair. The master key (for certification) is held securely at your home.
- You ask people, when they certify you, to certify both keys. It's a rare
event, it's not that big of a burden all in all.
- When you switch jobs, you revoke the existing subkeys, the ones where the
secret material was on the work PC. You create new subkeys for signing and
encryption and place those on your new work PC.
That way, the IT department of the company (or other people with access to your
work PC) will only gain access to work-related stuff /for that company/. Once
you go work for the competitor, they can no longer access any new work-related
stuff which is encrypted to the new subkey.
Your secret master key never enters the premises of the company you work for,
and other people certify that master key, so you don't lose the certifications
when you switch jobs.
You are a lot more free than that. Other people can sign both keys, and you can
sign other people's keys with either of your master keys. You just shouldn't
sign a key with /both/, if you want to keep the famous "some people" happy.

@_date: 2013-12-01 11:30:58
@_author: Peter Lebbing 
@_subject: Aw: Re: multiple keys with different UIDs and common WoT? 
A small detail I forgot to mention: people sign key/UID pairs. Obviously when
you have an UID "Klaus " and you go work for employer2, that
UID should be revoked and you will lose signatures on that UID. But you can
also[1] add an UID "Klaus", without e-mail, and get that certified. That UID
will still be valid, and there are multiple options for people sending you mail
to :
- They see your UID "Klaus" and select the key manually from their mail client
- They see your UID "Klaus" and make a local signature on the other UID to make
it valid[2]
- You ask the people who signed your UID "Klaus" to please also sign the new UID
to get it back in the WoT. You never changed your key (or your name), their
certification is still the same, you just added an e-mail address. People can
choose how they wish to verify that information, f.e. by sending their new
signature encrypted to your key, to that e-mail address. But since you never
changed the key, they don't need to do a full verification (identity and
I think the last solution is the best. It has the downside that other people
have to actually do it.
Hmm, not such a small detail after all!
[1] I'm not being literal here, I mean an UID with your full name, not just
Klaus :).
[2] This method has its downsides, for instance maintenance. What if the
signatures that made "Klaus" valid are revoked for some reason? Your local sig
is not automatically revoked as well, so the other UID stays valid even though
the WoT basis for the validity is removed.

@_date: 2013-12-01 12:58:07
@_author: Peter Lebbing 
@_subject: multiple keys with different UIDs and common WoT? 
I suppose it depends on how the mail client handles the case of multiple valid
UIDs on different keys matching the e-mail address. The GnuPG command line
simply picks the first in the keyring. If the mail client also does this, it's
entirely unpredictable which one will be picked by others. In this case, it
would be ideal if the mail client prompted with the two matches, allowing the
sender to pick one. Although it's debatable whether it should do this every
time; it might become annoying.
Maybe someone else knows more...
But keeping the e-mail address of your old employer with the scheme I proposed,
just means that your new employer will in principle have access to messages
encrypted to the work key. This might not be objectionable when you have left
your previous employer. It depends on the scenario; what type of mails people
send you after you have left the first employer.
If you have the private keys of the work key at home, you will also have access
to the mails sent to the work key. But I suppose you meant: at home but /not/ at
my new job.

@_date: 2013-12-02 19:33:22
@_author: Peter Lebbing 
@_subject: Any future for the Crypto Stick? 
Exactly the point I was going to make when I read your mail up to this point.
And don't forget that the draconian US laws aren't just for multinationals whose
main offices are in the US... it's also for multinationals with any office in
the US. I wouldn't count on it that NXP thought "we'd rather lose the US market
than backdoor our smartcards".
Since smartcards are primarily used for security purposes, I wouldn't be
surprised if it responded specially to a message signed by the NSA (or encrypted
with a symmetric cipher with a specific key known to the NSA).
I agree with you, but programs on BasicCards are generally rather simple since
they just define the contents for the ISO 7816 APDU's and files, and everything
else, including the file system on the card, is part of the interpreter and OS
on the card. And BASIC has two advantages: it's easy to learn, and it's easy to
compile to bytecode (that is, writing a compiler is easy).
Obviously, the design of the language from an academic standpoint is really bad
by todays standards; we learned a lot since BASIC was designed. But that's not
so important for the small applet-like programs that only work with the contents
of ISO 7816 APDU's and files.

@_date: 2013-12-02 23:14:02
@_author: Peter Lebbing 
@_subject: Any future for the Crypto Stick? 
Why couldn't the manufacturer simply put a different, backdoored firmware in the
card ROM than the one they showed to the other entities? Are those other
entities physically examining the ROM mask of the final product or somehow
bypassing the code protection and reading out the flash ROM?
I'm not so sure. This is equally true for the backdoors than are known to have
been placed by the NSA; yet still there they are. By the way, when NXP is kicked
out of the US, they lose their whole US market, not just the smartcard market.
Instead of "kicked out", also think of "harassed", "not getting government
contracts", etcetera.
Cool, the more, the merrier. NdK just pointed me to the FST-01 USB stick, not a
JCOP platform, but cool in a different way. Fully free software on a generic ARM

@_date: 2013-12-05 20:08:22
@_author: Peter Lebbing 
@_subject: Is there a chance smartcards have a backdoor? (was Re: Any future 
We're debating the risk that a card is backdoored. If there is such a risk, that
risk still exists if we allow for the possibility that manufacturers try to do
what you say. They're not mutually exclusive; how come you infer that I assume
that the manufacturer would not do the opposite?
But anyway:
So the NSA simply buys a card from a shop, and notices that it doesn't respond
to the backdoor command. Or they want to use the backdoor to get a suspect's
private key, and again, the card does not respond. How is the manufacturer going
to talk its way out of that?
However, if you're up against specific investigation by the NSA (not the dragnet
method), I think pretty much anybody will lose, backdoor or not. If they can't
extract your private key, they'll simply hack your computer and batch up
decryption requests to be bundled with your own next access of the card, or
something similar, or something really smart I didn't think of. So it's really a
question if it matters whether the NSA has a backdoor or not :).
PS: the new subject line is very verbose because I wanted to avoid the risk that
people interpret "Chance smartcard backdoored" as a statement rather than a

@_date: 2013-12-05 20:21:50
@_author: Peter Lebbing 
@_subject: Is there a chance smartcards have a backdoor? (was Re: Any future 
By the way, there's a big difference. In the scenario that they install a
backdoor but don't show it to the certification entities and such, they do that
because they're forced to do so by the NSA (the NSA wouldn't want their backdoor
certified :). If they feign helping the NSA, they aren't forced to do that, it
would be their choice.
But they are completely different circumstances: force versus own choice.

@_date: 2013-12-08 21:26:14
@_author: Peter Lebbing 
@_subject: Is there a chance smartcards have a backdoor? (was Re: Any future 
You can find it at:
And I've just told Sprite the link is dead :). I was just telling him he was
just featured on this mailing list :).

@_date: 2013-12-09 11:16:03
@_author: Peter Lebbing 
@_subject: determine the source(s) of validity 
Hash: SHA1
The Debian package signing-party has some tools working on this info, but I
don't think you can get the information you're really after, unfortunately. It
goes some way towards achieving it, though.
$ gpg --list-sig|sig2dot >sigs.dot
will create a .dot file for Graphviz and similar tools that has keys as nodes
and signatures as edges.
$ springgraph sigs.png
will create a picture of that graph; it's an alternative tool to the ones
provided by Graphviz.
Some other statistics can be had by:
$ pgpring -S -k ~/.gnupg/pubring.gpg|process_keys >preprocess.keys
$ keyanalyze
The first command will create a file preprocess.keys and the second a
directory called 'output' with distance analysis and stuff on the keys.
None of these commands take the trust database into account, AFAIK[1]. A
program that would take the output of --export-trustdb and the sigs.dot file
and annotates it with validity information would be cool. Perhaps pruning
sigs.dot to only include valid signatures.
I think the better approach is to write a tool combining --export-trustdb and
the sigs.dot file ;).
I think it's intentional. You would typically use ultimate trust for your own
keys. And if your own key expires, you might still very well trust the
certifications you made with that key. If the key of a fully trusted person
expires, that key no longer "validly represents" that person, and perhaps its
certifications can't be trusted anymore. I suppose the bond between you and an
ultimately trusted key is so strong that you are supposed to know all there is
to know about that key, and you should revoke the ultimate trust if you no
longer have ultimate trust in that key. Ultimate trust: I don't care what
anybody says, I believe in you.
In and of itself, it sounds unnecessary. The most important reason you would
make a local sig, is to make a key valid, but if it's already valid through
the Web of Trust, that's no longer necessary.
It also creates the burden of maintenance: through expiry or revocation of
keys and signatures, your WoT might at some point no longer consider a key to
be valid. But you did a local sig, so the key stays valid. You might not
notice that the validity has diminished.
But suppose that in certain scenario's, you consider a key (which isn't valid
yet) as "valid enough", but don't want to announce this to the world. I've
been pressing my point lately that I strongly believe your exportable
signatures should represent verification effort, not a belief of validity.
Still, you might want to use that belief of validity that you have to make a
key valid in your own keyring. This sounds like a perfect use case for a local
There might well be a scenario where you local-sign a key that's already valid
through the Web-of-Trust, but I can't think of one just now.
[1] Since you give either the public keyring file, or the output of gpg

@_date: 2013-12-11 10:43:11
@_author: Peter Lebbing 
@_subject: change passphrase in batch mode 
Hash: SHA1
I suppose because that is the agent protocol description, not the pinentry
protocol description. They're both Assuan protocols, but they're different
protocols. I can get a description of the pinentry protocol simply by:
$ info pinentry

@_date: 2013-12-11 10:51:16
@_author: Peter Lebbing 
@_subject: gpg-agent: pinentry-mode 
Hash: SHA1
That one is elusive indeed! I found it in the gpg2 manpage rather than the
gpg-agent man page (by simply grepping the source for GnuPG 2).

@_date: 2013-12-12 20:37:28
@_author: Peter Lebbing 
@_subject: show-uid-validity default to yes (was Re: a maximally simplified 
Hash: SHA1
I think it's a good idea. It's a vital piece of information if you actually
want to use the key properly, IMHO.

@_date: 2013-12-12 20:45:44
@_author: Peter Lebbing 
@_subject: (OT) signature generation failed (was show-uid-validity default to 
And that was all... I never intended to sign, but I have Enigmail's option
"Encrypt/sign replies to encrypted/signed message" turned on because I don't
want to forget encrypting when I reply to encrypted mail, which is especially
important if you quote something. So Enigmail wanted to sign the message, but I
don't have my card reader plugged in. Normally it complains, but this time it
sent this message with just the header and no footer. It's less annoying than
the time it ASCII-armoured an ASCII-armoured OpenPGP message in much the same
way (the recipient thought his mail client wasn't decrypting, but it was
actually only doing it once and showing the inner "layer").
I should probably file a feature request for two separate checkboxes:
- "Sign replies to signed message"
- "Encrypt replies to encrypted message"
Anyway, now you know why you see the strange header/no-footer combo: it was a
bug triggered by an unavailable smartcard reader (I think).

@_date: 2013-12-13 17:04:42
@_author: Peter Lebbing 
@_subject: show-uid-validity default to yes 
I suppose when those people have questions they go the mailing list of
the GUI in question, but still, since there is an amount of more-or-less
newbies coming here on gnupg-users with questions who are using the
command line, it would seem that there are inexperienced users who are
using the command line.
Has it ever been researched in which way users use GnuPG? A part of the
GUI users might also still use the command line for certain things.
Yes, but if you first say "Avoid using the output of this command in
scripts or other programs as it is likely to change as GnuPG changes"
and then still not make changes to the output because unthoughtful
people depend on it being stable, it kind of defeats the purpose. It's
something you should keep in mind, but it shouldn't stop you from
implementing something which is a clear improvement.
It is indeed debatable whether this particular improvement is worth it.
Just some thoughts,

@_date: 2013-12-15 13:58:58
@_author: Peter Lebbing 
@_subject: Sharing/Storing a private key 
My guess is the fact that ssss only supports secrets up to 1024 bits; if you
want to share a larger secret you need to do a hybrid approach where you
symmetrically encrypt the data and then use secret sharing for the randomly
chosen encryption key.
If I understand Mindiell's message right, his implementation works for larger
But I don't see why you wouldn't just use ssss and the hybrid approach. For one,
it uses much less entropy, since Shamir's secret sharing algorithm requires a
lot of it, I believe proportional to the size of the data to be shared. I
haven't checked the code by Mindiell, but this sounds like a potentially big issue.
It seems to me the hybrid approach is better. Since ssss supports the hybrid
approach, I don't see the need for a new tool. I do see use for a much simpler
tool that makes the hybrid approach more accessible: pick a random key, and use
that for invocations of both (openssl or gnupg) and ssss.

@_date: 2013-12-15 14:18:59
@_author: Peter Lebbing 
@_subject: Another step towards crowdfunding 
Hash: SHA1
That would most likely be the offer Robert J. Hansen made this year for his
yearly "Holiday giving" money to GnuPG in this message:
I was going to do my yearly donation as well and let Robert match it, but I
chose to wait for your crowdfunding campaign because I'm curious about the
"rewards for those who donate" :). Sorry Robert :). Hey, I'm Dutch, we love
free stuff!

@_date: 2013-12-16 20:38:26
@_author: Peter Lebbing 
@_subject: [Announce] Libgcrypt 1.6.0 released 
Hash: SHA1
I think this is a typo and you mean RFC-6979 "Deterministic Usage of the
Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature
Algorithm (ECDSA)"
Thanks for keeping on releasing new stuff,

@_date: 2013-12-18 17:53:43
@_author: Peter Lebbing 
@_subject: Sharing/Storing a private key 
If only everything in cryptoland was "only as secure as 3DES"...
I don't see why. If this is because you avoid "insecurities in symmetric
crypto", I just don't buy it. Otherwise, please explain.
And how do you propose to do that? You can't conjure up good quality entropy.
And if you don't trust symmetric crypto, you can't use that to create an
almost-random stream either.

@_date: 2013-12-19 21:39:39
@_author: Peter Lebbing 
@_subject: Holiday giving 
I just donated ? 75 to the crowdfunding campaign (and will soon be wearing a
nice t-shirt). Will you also match that or are you restricting yourself to the
"normal" Christmassy donations? It's your money, it's your call. Obviously.
Here's to a great funding campaign!
PS: By the way, why does goteo.org insist on speaking what looks like Spanish to
me? I intended to read the privacy policy, but it insisted on showing me
versions I couldn't comprehend. I could get a French one from the language
pulldown, but not English. My Accept-Language: is en-gb,en;q=0.7,nl;q=0.3 so
that can't be the problem. Perhaps some strange interaction with Privoxy,
although I feel strongly that it simply should respect my Accept-Language anyway.

@_date: 2013-12-20 11:53:28
@_author: Peter Lebbing 
@_subject: gpg-rsa-key decryption with a mobile 
Hash: SHA1
I'd be surprised if the smartcards don't employ RSA blinding because it is a
standard technique. A smartcard is supposed to protect the key even if it
falls into the wrong hands (up to a certain point). Analysis of the power
usage of the card during decryption or signing can quickly leak a private key
without blinding.
Another common thing is that you can get info on the private key by glitching:
momentarily sharply reduce the power supply voltage to make bits fall over in
the processor. If the processor returns the result of the faulty computation
to you, this can give insight on the private key. A simple technique to
counter this is to do the public counterpart of the private computation at the
end, and check if the result matches the original input. Only return data when
they match, otherwise just indicate "an error occured".
By the way, usually the actual crypto computations are implemented as
primitives in the smartcard, and the OpenPGP application just asks "decrypt
this for me". So all the masking techniques are part of the hardware and the
OS, not the OpenPGP application (although checking the result for glitches can
be done by the application).

@_date: 2013-12-20 13:28:39
@_author: Peter Lebbing 
@_subject: [Announce] GnuPG launches crowdfunding campaign 
111% of optimum now: EUR 24.151! In slightly more than a day. Congratulations!
Very cool.

@_date: 2013-12-22 21:35:26
@_author: Peter Lebbing 
@_subject: (OT) Mail-Followup-To or not? (was Re: 2.x) 
You could also interpret the absence of any headers indicating otherwise that
the person might not care enough about that to set headers.
My 2 cents,

@_date: 2013-12-23 20:54:04
@_author: Peter Lebbing 
@_subject: Possible to combine smartcard PIN with key password? 
The smartcard needs to know the plaintext key. It is no use to encrypt the key
with a password, because you'll simply offer the password to the smartcard so it
can decrypt it. Any exploit in the smartcard would then cache the key for the
three-letter agency. You gain nothing by the password.
The only interesting difference between the PIN and a password is that the
latter needs to be suitable to encrypt a secret with: it needs to contain
entropy, so be difficult. A PIN doesn't need this property, because the
smartcard checks each try, and will lock the card after three wrongs (OpenPGP v1
cards will self-destruct on three wrong admin PINs. I personally found this a
bit harsh). A suitable PIN doesn't need to contain all that entropy that is
needed for an on-disk encrypted private key. The latter needs to withstand an
off-line decryption attack of the disk file.
It is my expectation that it is very easy to find out: it won't. There's no
battery in a smartcard, and some kind of chemical release is very unlikely. So
it won't wipe it's non-volatile memory when probed. Instead, they make it
difficult to probe by putting, among others, metal layers on top of the
memory, making it a very expensive job to grind down without grinding away the
memory cells as well.
No. It has to stop somewhere: at some point you have to trust some party. With
smartcards, I think for most people that's that the hardware design can be trusted.
Some hacker group could at some point reverse-engineer the design from the
integrated circuit and check it for validity; they did it[1] for the MOS 6502.
After that, you can trust that cryptocards from the same mask can be depended
upon. When they change the mask, you won't notice, though.
It's an interesting thought, I'll definitely give you that. However, if you need
that kind of protection, I don't think you should use a normal computer with a
normal operating system. It seems to me, to attack your smartcard, they would
need to either hack your PC, or have physical access. In both scenarios, the key
on your hard disk is not secure anymore either.
Can you think of a scenario where the on-disk key adds security beyond the
[1]

@_date: 2013-12-23 20:55:10
@_author: Peter Lebbing 
@_subject: re-send public key necessary after setpref changes ? 
Yes, people will need a new copy with the updated preferences before they can
respect them. So you will need to upload it, and they need to download it.

@_date: 2013-12-24 11:23:14
@_author: Peter Lebbing 
@_subject: Possible to combine smartcard PIN with key password? 
The smartcard you could always keep on your person. This is slightly difficult
with computer hardware. So it seems to me that your adversary has an easier job
accessing your computer when you're not in the same room as your computer than
he has accessing your smartcard, which you could keep on a lanyard around your
neck and on your bedside table when you're sleeping[1].
Regarding the difficulty of wearing your computer: your adversary only needs
either your keyboard, your motherboard or your non-volatile storage. So even if
you have your OS on an SD-card on a lanyard around your neck, they can still bug
your keyboard or motherboard to log all keystrokes (returning later to collect
the keystrokes). Even if you keep a tiny computer on your lanyard (easy to
realise these days), that still leaves the keyboard.
And regaring the scenario: if you would keep your computer on your person at all
times, it is no longer easier to steal your computer than your smartcard, but it
is now equally difficult. The result is that the on-disk key again adds nothing,
because an adversary that can physically access the smartcard can also
physically access the computer. Only if you can make it more difficult to access
the computer than to access the smartcard, will the on-disk key add anything, I
This scenario doesn't involve additional security gained through two keys; it is
simply the advantage of a smartcard over an on-disk key.
[1]  Or taped to your body if you're worried you might not wake up, but now
we're well into 007 territory.

@_date: 2013-12-24 12:36:44
@_author: Peter Lebbing 
@_subject: Printing PGP Businesscard 
If you're using Debian, you should take a look at the gpg-key2ps script from the
signing-party package. From the man page:
viewers will allow to view and print the Postscript file directly). For
instance, ghostscript includes ps2pdf.
Have fun at 30C3! I already went to OHM2013, I'm skipping the CCC this year.

@_date: 2013-12-25 20:52:01
@_author: Peter Lebbing 
@_subject: Fwd: Rosetta CryptoPad released 
I really wouldn't mind never reading about this GoldBug messenger thingy again in this mailing list. I can't shake the feeling it's only discussed to give it a podium in the mailing list of a reputable cryptography tool.

@_date: 2013-12-27 10:27:56
@_author: Peter Lebbing 
@_subject: Fwd: Rosetta CryptoPad released 
Why is my quote altered? I said:
"Goldbug messenger thingy /again/" became "CryptoPad thingy" and all apostrophe's are gone, also in the next sentence.

@_date: 2013-12-27 11:16:21
@_author: Peter Lebbing 
@_subject: Possible to combine smartcard PIN with key =?UTF-8?Q?password=3F?= 
The solution in this scenario is so simple: don't take your smartcard with you; at all times leave it next to your PC.
I'm not saying this solves all problems, but it solves this scenario[1]. The thing is: you assume your house is a fortress, since you assume your PC won't get bugged with a keylogger or anything when you leave it at home. Your assumption is irrealistic, but even if you make that assumption, the smartcard is still safe inside your fortress. The on-disk key still adds nothing.
Possibly, when you only consider the theft. But after that, extracting the key from the smartcard is much, much more energy than installing the keylogger or camera.
You're building an adversary that has a very strange mix of qualities. They're unable to break into a house and start a computer from their USB-stick that infects the operating system, but they can pickpocket something on a lanyard around your neck and spend a lot of money very, very carefully grinding down a chip in a laboratory and then using equipment to measure the charge trapped in the transistors of the non-volatile memory.
I liked the suggestion by MFPA to have a laser projected keyboard! It should be possible to make it small enough to hang the whole computer and the keyboard on a lanyard around your neck. Only thing left seems the monitor. Good luck hacking my PC over a VGA connection (I'll cut the wires for the DDC data just to be sure). Not that I will do this, but it's a nice thought experiment.
[1] In fact, I find it not unreasonable. If nasty people get physical access to my PC, they've pretty much won. They can make my computer theirs, and bundle their RSA crypto with the requests I send to my smartcard. Werner once suggested recording audio while I type the PIN on my smartcard reader to deduce the PIN, I suppose by listening for changes in the time between keypresses. Anyway, the point is that you've lost when they get physical access to your PC.

@_date: 2013-12-30 22:43:09
@_author: Peter Lebbing 
@_subject: for GnuPG GUI, force gpg response in english language? 
You should take a look at --status-fd. It's format is described in the DETAILS
file in the documentation.
Oh, and if you wish to parse output that's not on --status-fd (like --list-key),
you should always include --with-colons. Again, see the documentation and DETAILS.
The human-readable output is not meant to be parsed by machines. That's why it
adapts to the language environment (l10n).

@_date: 2013-02-05 19:04:25
@_author: Peter Lebbing 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
While I agree with the broad sentiment, I'm not so sure a certain amount of
damage control is impossible with what he/she proposes. If you have a device
with small attack surface[1] that shows you the plaintext you're about to sign
before signing it *with that device*, you can at least prevent making bogus
signatures. That still means you're in trouble when your PC is under control of
an attacker, but you can't be coerced to issue false signatures. That's
certainly something.
Obviously I'm assuming the private key is not on the compromised PC. I'm
assuming a whole lot more that I'll leave implied. I'm just saying it doesn't
sound over-and-shut end of the game to me when the PC is compromised.
First of all, I think he/she meant "verify that the text I'm about to sign is
what I intended to sign", whereas you are probably thinking of "verifying a
cryptographic signature". And a dedicated, limited, well-designed single-purpose
device is more trustworthy than an Internet-connected general-purpose PC under
the right circumstances.
general English. Why argue semantics here?
Just my 2 cents,
[1] Read: not too much program code, well-defined limited communication
interfaces. I'd prefer a serial port :). Certainly not a USB device, though it
could contain a USB-to-serial chip, obviously.

@_date: 2013-02-06 10:28:13
@_author: Peter Lebbing 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
Can you explain (broadly) how one would compromise the signature/the device that
you sign with?
I myself always say "if you don't control your own PC, it's over". I don't see
however how that compromised PC in this instance can force me to do false
signatures, which is the context I'm placing it in.
You're still majorly screwed, obviously. An attacker will easily come up with
some other nasty thing to do to you. Just not issuing false signatures.

@_date: 2013-02-06 13:18:00
@_author: Peter Lebbing 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
Seems to me to be enough to do what OP requested: signing e-mails he/she wrote.
It indeed seems easy to me that this won't work for binary data, I left that
implied. A solution that works for signing e-mails sounds like a viable
solution. Just like the USB device the OP linked to only works for signing an
electronic bank transfer.
Obviously you shouldn't use the same signing key for other duties because those
other duties open up different methods to get an e-mail falsely signed. Still,
not a deal breaker.
I'm not suggesting anybody build this solution. I'm arguing on the technical
merits, not the economical ones. Robert suggested it is impossible or close to
that. I don't see it that way, but maybe I'm missing some interesting attack
vector. And that would be interesting to hear.
You're not going to achieve that.
I don't see how that would work. Or, put differently, how that would work any
better than transferring the file to a secured system.  Because I can't
calculate the hash easily using pen and paper, I really need to be seeing
something other than the hash before I can be sure it's the data I wanted to
sign. Even if hashes could be calculated by pen and paper, it seems like it's an
unworkable solution. You would also need to be able to interpret all the binary
data you're calculating the hash over, or else you still don't know what you're
signing. The PDF could contain a vector image that renders to text saying I owe
you ? 1000. I would need to be able to create that vector image in my head
before I can interpret the binary data that represents it. This just gets more
insane the more you think about it.
But it is really /way/ out of the scope of signing your e-mails.

@_date: 2013-02-06 13:45:29
@_author: Peter Lebbing 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
In my other mail I got kinda hung up on manual verification but forgot about
this part of your mail :).
I think what you propose is a completely different topic/solution.
You seek security in numbers: hope one of the many PC's isn't compromised. The
device proposed by OP/by me seeks security in being restricted and simple. And
also takes a whole lot less of effort to use ;).
I don't really believe in the security in numbers, by the way. Seems too
stochastical. If the attacker can attack all but one of the many, why not the
last one? Yes, you reduce the odds, but I prefer more determinism.
But let's stick to the e-mail signing in this thread, or the discussion will get
very unfocused and hard to follow. If you want to continue anyway, could you
please change the Subject: line?

@_date: 2013-02-07 13:46:56
@_author: Peter Lebbing 
@_subject: influence of signature type on trustdb 
So 0x10 is always accepted, 0x11 is by default rejected. You could, f.e.,
increase this to 3, meaning you only accept 0x13 (and 0x10). Or you could
decrase it to 1, accepting 0x11 as well. That at least is what I get from the
description. I've never fiddled with it.

@_date: 2013-02-07 14:14:44
@_author: Peter Lebbing 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
It's a good attack. Thank you for sharing it. But to say it makes the device
bogus is a way too easy dismissal.
So if an attacker compromises the system and makes the user unable to use the
device on that system, they will react by stopping using the device, but not by
stopping using the PC? But at the same time you said earlier
I would agree with the latter. The strength of the device is that it won't issue
false signatures in the period that your PC *is* compromised but you haven't
discovered it yet!
If my crypto device suddenly stopped working, I'd investigate why and possibly
re-install the system if I can't find the culprit.
Your case of not using the smartcard isn't really completely comparable to me.
You feel the fault lies with Fedora. Re-installing from scratch doesn't fix
anything. If you thought it not unlikely that an attacker was controlling your
system and blocking the smartcard, I really doubt you'd respond by putting your
private key in your keyring on that system, right?
Nice rhetorics. In isolation, it sounds nice. In context, it is itself bogus.
I'd really appreciate it if we discuss the technical merits, and not make a
competition out of who can come up with the best rethorics. You will no doubt
win. But this isn't about winning to me, it's about academical exploration of a
Your most generous assumptions are at first "about your dongle". In the next
sentence, those same assumptions are suddenly generalised, making the statement
nice and catching. But as soon as we look at the bigger picture, your
assumptions aren't that generous.
The most important reason is that you took it as a fact that if an attacker
compromised the PC, the user would react by rewarding him with a copy of the
private key, exactly the opposite of your advice to cut the PC out of the
process. I really wouldn't call that the "most generous assumptions possible" at
Unfortunately no cake for me, because human exploits are obviously very real and
need to be accounted for.
This is a viable attack. It might work. Because of user misjudgement. That does
not make the device useless. A properly cautious user should no longer trust the
PC that is not accepting the device when seemingly rather identical systems do
accept it. Caution is always required when working with cryptography you rely
on, there's nothing new there. This device doesn't magically make all worries go
[1] I split the quote to emphasize the last sentence

@_date: 2013-02-07 20:29:40
@_author: Peter Lebbing 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
Every decision is a weighing of how important things are to you. For most
people, it's a non-issue anyway. So yes, they will just get on with their work
and do the signature in software. But then this device was probably also more of
a gimmick to them. They bought it instead of a simple OpenPGP card, but can't be
bothered to do some investigation when this not quite ordinary piece of
cryptography equipment stops working? I really think their keys and signatures
must not be worth a lot to them then.
I'm not talking about myself. I would buy the device as a gimmick, actually. Or
not at all. I feel perfectly fine with my OpenPGP cards.
By the way, you talk about bisecting code changes and such. I would just grab
one of my other PC's, or install a brand new one. In the end, yes, an attacker
could thwart all my attempts. This isn't any different than for the products
that are already here today, GnuPG itself, the OpenPGP smartcards. The device
where you see your plaintext before you sign it is just an extension of the
smartcard, not a panacea. The smartcard prevents leakage of the key, as long as
you use the smartcard. The plaintext signature device prevents false signatures,
as long as you use the device.

@_date: 2013-02-07 20:31:09
@_author: Peter Lebbing 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
This is silly. Yes, you can do social engineering. That's always possible. And
yes, the attacker will win against me if he wants badly enough. I know that as
well. These are all just generalities.
You seem to be implying that unless something is perfect, something is bogus,
and people should not bother. Well, the perfect is the enemy of the good, and
apart from that, you seem to call not just the OpenPGP smartcard specifically
but everything else as well bogus for being exploitable when enough effort is
put into it. Why do you even have GnuPG if you feel that an attacker worth your
time would have you in his pocket?
Actually, you might want to rethink that whole Fedora thing, because I think
someone has gone through quite some effort for your private key. He even
pretended to be Werner Koch, and laughed himself silly when you gave him a
bloody account to the machine he already owned more than you did.
Better revoke now.
I'm out. You're a smart guy. If you feel those generalities add anything to this
discussion, I feel I'm completely done with it. I can't shake the feeling you're
not in this discussion for the same reason as I.
I just now read your other mail in this thread. In it you say:
I'm slightly confused. Because everything you object to the device I have in
mind is equally well deployed against the smartcard, yet the smartcard
apparently is not bogus. The smartcard prevents leakage of key material, as long
as you don't put your private key in your keyring as soon as an attacker
disables access to your smart card reader. The plaintext signing device prevents
false signatures, as long as you don't put your private key in your keyring as
soon as an attacker disables access to the device. Yet only the latter is bogus,
and you haven't made clear where the difference then lies.

@_date: 2013-02-08 10:48:25
@_author: Peter Lebbing 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
Just so you know, the OpenPGP card has a "forcesig", force signature PIN, flag
which you can set so you have to enter the PIN for every individual signature.
Unfortunately (IMHO), there's no such flag for decryption and authentication,
which can be done multiple times with one PIN entry.

@_date: 2013-02-08 11:09:40
@_author: Peter Lebbing 
@_subject: Feature request for future OpenPGP card: force PIN 
Hello Werner and list,
I'd like to do a feature request for a new version of the OpenPGP card, whenever
such a new version would be designed.
The current OpenPGP cards have a "force signature PIN" flag which can be set so
only one signature is issued with one PIN entry. I'd like to request similar
flags for the other two keys on the card, the encryption key and the
authentication key.
To me, it seems that the rationale for such a flag on the authentication key is
the same as for the signature key; both are a form of signatures. However, I'm
not familiar with the rationale for adding the force signature PIN flag.
I think there's an obvious use case for not setting the "force PIN" flag on
decryption: if you're searching your mail archive for a certain string, and you
have lots of encrypted mails, not forcing the PIN will mean you only need to
enter the PIN once for the search. But offering the option to force the PIN for
each decryption just means people with this use case will not set the flag; it
does not get in their way.
I don't have a mail archive with encrypted mails. To me, decryption is just as
much a "once only" action as signatures. So I would personally set the "force
decryption PIN" flag for the same reasons I set the "force signature PIN" flag.
It seems to me this is a simple and harmless addition, so I hope it can be
accepted on the grounds that it is useful to some, not harmful to others and not
that much work. I hope I see that right.
I regret not doing this feature request between the card v1.1 and v2.0 :).

@_date: 2013-02-08 15:18:30
@_author: Peter Lebbing 
@_subject: Feature request for future OpenPGP card: force PIN 
I have an SCM SPR 532 reader with pinpad; I thought the host could not get at
the PIN when entered on the pinpad? The way I understood it, the host sends a
VERIFY command "template" to the reader which the reader fills in with the PIN
entered on the pinpad of the reader, and then forwards to the smartcard.
I understand that if you enter the PIN on the keyboard of your PC, the force
signature PIN flag is completely useless.
Thanks for sharing the rationale for the force signature PIN flag.

@_date: 2013-02-08 17:26:00
@_author: Peter Lebbing 
@_subject: LiveCD with GPG 2.0.18+ 
A quick check shows that Knoppix claims to have gnupg2 2.0.19-1 on Knoppix DVD
versions 7.0.4 and 7.0.5. The version number is probably a Debian version number.
There are files called dpkg-l-dvd-704.txt and ..705.txt in the DVD mirrors of
Knoppix that give a listing of all installed packages along with version numbers.
Note that the CD version does not have GnuPG 2! Only 1.4.x.
Good luck,

@_date: 2013-02-14 21:11:10
@_author: Peter Lebbing 
@_subject: Unable to access Crypto Stick with gpg2 
You're confusing pcscd and scdaemon. OP doesn't use direct access by scdaemon,
but rather a PC/SC daemon which is run from init, and to which the scdaemon
If the card reader is supported directly by GnuPG, it might be better to remove
pcscd from the equation. And in that case, the ownership might indeed become an
issue again when it's like this.

@_date: 2013-02-14 22:03:45
@_author: Peter Lebbing 
@_subject: Unable to access Crypto Stick with gpg2 
pcscd will have GUID pcscd, so it's not a supplementary group. With
$ ps -e -o pid,egroup,supgrp,args
You'll most likely notice "pcscd" in the second column for that daemon.

@_date: 2013-02-22 20:28:47
@_author: Peter Lebbing 
@_subject: Is it possible to use keys that aren't on the keyring? 
I don't know if it is supported by GPGME, but here's an alternative I just
thought of: Store the public keyring on a RAM filesystem.
Sketch of operation (not fully tested, and please understand what you're doing,
don't just copy-paste):
mkdir ~/gnupg-ramfs
sudo mount gnupg-ramfs ~/gnupg-ramfs -t tmpfs -o mode=700,uid=$(whoami)
echo no-default-keyring >>~/.gnupg/gpg.conf
echo 'keyring ~/gnupg-ramfs/pubring.gpg' >>~/.gnupg/gpg.conf
Now you have an empty default keyring. --import your key, work with it,
--delete-public-key, and it's empty again.
This way, no disk activity is caused by the operations. Deleting the last key
from the keyring is probably pretty efficient (it would make sense if it is
programmed such that it will append the remaining 0 bytes at file pos 0).

@_date: 2013-02-26 11:19:14
@_author: Peter Lebbing 
@_subject: Questions about OpenPGP best practices 
Please realise that if it would have worked, you would have installed that
sks-keyservers certificate authority as a system-wide certificate authority, and
your browser and other programs might[1] happily accept a certificate for your
e-mail provider or your banking site created and signed by the sks-keyservers CA.
In other words, trusting a certificate authority is currently an all-or-nothing
thing where you now trust them to certify any SSL-protected service you connect to.
While I appreciate the sks-keyservers folk, I would never install their CA as a
system-wide CA. Actually, I already distrust "proper" CA's :).
[1] I say "might" because those programs could have their own list of CA's and
not use the system-wide one. Like Firefox and Thunderbird.

@_date: 2013-02-26 12:23:42
@_author: Peter Lebbing 
@_subject: Questions about OpenPGP best practices 
Okay, you made me laugh out loud, thanks :).
It probably won't hurt to add the sks-keyservers CA, although I don't know how
well they guard their private key. Probably fairly well, these are crypto guys.
But there's the principle of the thing, you know? :) The CA is pretty powerful,
and only useful for keyservers. There's no advantage to installing it
system-wide versus putting it in your gpg.conf, I think. So why do it?

@_date: 2013-02-28 22:34:45
@_author: Peter Lebbing 
@_subject: key length for smart card key generation 
============================== START ==============================
If we're all talking about RSA here, I think so.
Second line of the output for me:
BTW, the Application ID includes the unique serial number.

@_date: 2013-01-02 12:31:10
@_author: Peter Lebbing 
@_subject: smartcard key change 
It doesn't just flag the secret key as stored on card, the secret key in your
keyring is /replaced/ by a stub that just says the key is stored on the card. So
your secret keyring no longer contains the secret key.
You will need to recover the secret material from a backup.
At least, I am fairly sure this is the case. I have not tried it out since I
don't want to screw up the keys on my smartcards :).
You say we are talking about a signing key here, so you could also just generate
a new signing key.
Good luck,

@_date: 2013-01-07 17:54:15
@_author: Peter Lebbing 
@_subject: Paperkey 1.3 
I would assume the decay to make it irretrievable the moment you discover
it. Hoping the bit flips in a non-vital piece of (meta)data seems like a
risky backup strategy.
Flash memory stores its data as an electrical charge, which can leak away.
It does so very slowly, but it still does[1]. We are talking about years.
And reading a cell does not "refresh" it, so read-only use will in principle
not do anything to extend the storage time.
[1] Johan Wevers mentioned radioactive radiation. Sounds plausible to me,
that should be capable of knocking electrons away, I'd think as a layman.

@_date: 2013-07-02 21:08:16
@_author: Peter Lebbing 
@_subject: Refreshing keys 
Hmmmmm.... that can't be right, can it? --check-sigs normally doesn't complain
about missing User IDs. I think it should be --list-sigs.
Also, I think this is the (more robust) version with --with-colons:
gpg2 --with-colons --list-sigs|grep '^sig.*User ID not found'| \
cut -d: -f 5|sort -u|xargs gpg2 --recv-keys
I tried to do something about funny people using the literal text "[User ID not
found]", but this is simply indistinguishable in the output of gpg2, so scratch
that :).
If it /would/ have beeen distinguishable, this would have been better:
gpg2 --with-colons --list-sigs|awk -F: \
'$10 == "[User ID not found]" { print $5 }'|sort -u|xargs gpg2 --recv-keys
But since this doesn't help, I also dropped the explicit field number 10
reference in favour of the simpler command above.
PS: Any occurence of gpg2 can be replaced by gpg. I just try to learn myself to
use gpg2 unless I have specific need for v1.

@_date: 2013-07-08 11:00:29
@_author: Peter Lebbing 
@_subject: GPG keys for multiple email accounts 
The keys GnuPG creates by default have signature and certification capabilities
on the primary key and encryption on a subkey.
With an offline main key, it makes a lot of sense to move the signature
capability to a subkey (and /not/ have it on the primary key) ...
... but advising to set encryption capability on the primary key goes against
the advice of not using one key for both encryption and signing.
Also, why not create the separate one if you don't have it? You wouldn't get the
certifications that are already on the other key, but you save yourself the
hassle of having multiple, active encryption-capable (sub)keys in one key and
people having to select one of those.
Just my 2 cents.

@_date: 2013-07-08 11:22:23
@_author: Peter Lebbing 
@_subject: not recognizing my passphrase after moving from XP to Win7 
As one of the people to object, let me repeat that you simply shouldn't copy the
random_seed file to another system, but let it create its own. I agree that
having each keyring start out with the same random_seed file is a bad situation,
which is trivially avoided. Even removing it after the copying is less work than
monkey-bashing the hex part of your keyboard in a hexeditor :).

@_date: 2013-07-11 17:23:59
@_author: Peter Lebbing 
@_subject: not recognizing my passphrase after moving from XP to Win7 
My best guess is that the random_seed is only created when GnuPG actually uses
random numbers. Verifying a signature doesn't need randomness, unless you're
using randomness to defeat side-channel attacks. I suppose this is not the case.
Once it needs randomness, it will very likely just create a fresh random_seed file.
I absolutely believe your intention to randomly change things. I also strongly
suspect you are a human being, and I also believe humans are not very capable of
generating randomness. But I already said this, so I don't understand why you
think I doubt your intentions when I have explained my point earlier. Whether
you agree on the inability of humans to generate randomness (or recognise it,
for that matter) is another thing, in which I obviously leave you completely free.
It read as advice to me. You said:
If I read someone say that what he does is, from his point of view, far better,
I'm inclined to think he implicitly advises me to do the same. I'm not even
going to start thinking about another implication that could, indeed, be made
from this statement, which is not to have the same random_seed file some other
way, like by deleting it.
I agree :).
By the way, the random_seed file is only part of the input to the randomisation.
I don't think you'll actually create an insecure system when you copy it
literally from another system, although I'm not sure what a capable attacker can
do. That said, it's easy enough to not copy it (or delete it after copying), and
it was never intended to be copied, so why not just do that. If you think of it.
Otherwise, don't fret, you're probably safe.
PS: Since there are 1200 nibbles in my random_seed file, I would indeed expect
that after at most 16 changes, you will start changing nibbles to a value you
already used.

@_date: 2013-07-13 13:06:04
@_author: Peter Lebbing 
@_subject: Problem with omnikey cardman 4040 
Do you have pcscd running? If pcscd and GnuPG's internal CCID driver both
try to claim the device, they'll get in eachothers way.
Which distro do you use? You could try to stop pcscd with
service pcscd stop

@_date: 2013-07-13 17:10:35
@_author: Peter Lebbing 
@_subject: Problem with omnikey cardman 4040 
I think that command means processes accessing a file on the
filesystem where /dev/cmx0 resides, which means anything in /dev (not
counting pseudo-filesystems mounted inside /dev, I suppose).
I think you should use
fuser -v /dev/cmx0
I had forgotten about fuser, I always do an incantation with lsof...
Is GnuPG using the agent that is running? Do you have use-agent in
your gpg.conf? You are using GnuPG v1.x, but I can reproduce that
first using GnuPG v2.x to access the card through the agent, and then
using GnuPG v1.x to access the card directly, fails on that second
attempt. Until I kill scdaemon (takes quite a few stabs to kill it),
then GnuPG v1.x will access the card again.
However, the messages are different than yours, and also, it's
scdaemon that holds the device, not gpg-agent. This makes sense: GnuPG
v2.x asks the agent to access the card, and the agent asks scdaemon.
So both are needed, but scdaemon holds the access to the card.

@_date: 2013-07-13 17:15:30
@_author: Peter Lebbing 
@_subject: Error verifying encrypted and signed message 
The way it is implemented, only the recipient can see who actually
signed the message, so the person who signed is part of the secret
protected by the encryption.
If you really *need* to be able to verify files you can't decrypt, you
could first encrypt it and then sign the resulting encrypted file. But
it's a bit cumbersome.

@_date: 2013-07-26 20:26:27
@_author: Peter Lebbing 
@_subject: Answer: Are SHA1 sums on gnupg.org checked regularly? 
By running a Linux Live CD to do the verification. How does he know the CD is
genuine? The thing is, somewhere the trust has to start. It's a bootstrapping
Also, how do you trust the OpenPGP signature is made by the correct key, etcetera.

@_date: 2013-07-27 12:57:37
@_author: Peter Lebbing 
@_subject: License violation: GoldBug 
You're one of the devs of the project, or otherwise affiliated with it?

@_date: 2013-06-05 11:23:34
@_author: Peter Lebbing 
@_subject: Separate OpenPGP cards for master key and sub-keys 
I do this as well. The primary key is on a different card than the subkeys.
Unlike Pete, I had to resort to some key splitting and recombination tricks to
get GnuPG to recognise the situation. Perhaps this has since improved and is no
longer needed.
The thing is that when I stuck one smartcard in the computer and ran
--card-status, it would create a stub private key which only referred to the
card I had inserted. So far, this is obvious and correct. However, once I gave
it the other smartcard, I could not get GnuPG to update the private key stub to
refer to that smartcard as well.
Generating two stubs, one for each smartcard, 'gpgsplit'ting the secret key
stubs and recombining them to have stubs for both smartcards in one key, fixed
the situation for me.
If this happens to you as well, I can give detailed instructions.
Good luck,

@_date: 2013-06-05 14:50:26
@_author: Peter Lebbing 
@_subject: Separate OpenPGP cards for master key and sub-keys 
Ah. I hadn't noticed that. I believe the problem is that the "Key attributes"
(displayed on --card-edit) force a specific keylength and keytocard only works
for that keylength. I think I remember the solution was to create a key on
card of the desired length, and then overwrite that one with keytocard.

@_date: 2013-06-05 20:20:25
@_author: Peter Lebbing 
@_subject: Separate OpenPGP cards for master key and sub-keys 
I'm quite sure I never had data signature capability on my primary key. And I
moved it to an OpenPGP v2 card, so it worked for me. I did use a 2048-bit key,
but I don't see why that should make a difference.
You could try to temporarily add data signature capability to your primary
key, and see if it accepts it then. Then remove it afterwards. But I can't
come up with something better right now, sorry.
Good luck,

@_date: 2013-06-06 12:41:29
@_author: Peter Lebbing 
@_subject: Separate OpenPGP cards for master key and sub-keys 
Hmmm. Good point. No idea :)
If you use a hex editor to change flags, the signature will not check out.
Possibly --edit-key and then "expire" will allow you to re-issue a signature.
But I simply hadn't realised it's not a properly supported function of GnuPG.

@_date: 2013-06-08 10:42:51
@_author: Peter Lebbing 
@_subject: How do you show a list of cached keys in gpg-agent? 
$ gpg-connect-agent
# NOP
# CANCEL
# KEYINFO [--list] [--data] [--ssh-fpr] # KEYINFO [--list] [--data] [--ssh-fpr] # Return information about the key specified by the KEYGRIP.  If the
# key is not available GPG_ERR_NOT_FOUND is returned.  If the option
# --list is given the keygrip is ignored and information about all
# available keys are returned.  The information is returned as a
# status line unless --data was specified, with this format:
#   KEYINFO     - - # KEYGRIP is the keygrip.
# TYPE is describes the type of the key:
#     'D' - Regular key stored on disk,
#     'T' - Key is stored on a smartcard (token).
#     '-' - Unknown type.
# SERIALNO is an ASCII string with the serial number of the
#          smartcard.  If the serial number is not known a single
#          dash '-' is used instead.
# IDSTR is the IDSTR used to distinguish keys on a smartcard.  If it
#       is not known a dash is used instead.
# FPR returns the formatted ssh-style fingerprint of the key.  It is only
#     print if the option --ssh-fpr has been used. '-' is printed if the
#     fingerprint is not available.
# More information may be added in the future.

@_date: 2013-06-08 12:50:23
@_author: Peter Lebbing 
@_subject: Separate OpenPGP cards for master key and sub-keys 
I thought of another way to get the key on the card. During on-card key
generation, you're prompted if you want to make a backup in a file.
Such a backup is just a bare OpenPGP secret key material packet. It doesn't
have key usage flags, so they can't be in the way either.
We can create an equivalent file that contains the key material from your
normal key, so we can move it to the card. Note that we disable a lot of
safety checks by GnuPG by manipulating it like this. But I just did some
testing with an empty OpenPGP v2 card and GnuPG 2.0.20, and I can reproduce
your problem: a key with just Certify ability will not be copied to a card;
the list of options is empty as you said. If I create a key with Certify and
Sign on the primary key, I /can/ move it to the card, and it will also
correctly issue certifications from the card.
To get a bare OpenPGP secret key material packet for your key (adapt to your
------------8<--------cut here-------->8------------
peter at tweek:~$ gpg2 -o bla.gpg --export-secret-keys AE2B4D8A
peter at tweek:~$ gpg2 --list-packets bla.gpg
:secret key packet:
        version 4, algo 1, created 1370686349, expires 0
        skey[0]: [4096 bits]
        skey[1]: [17 bits]
        iter+salt S2K, algo: 3, SHA1 protection, hash: 2, salt: e627f9a2e13fb52d
^^^ Check that the secret key packet is a real secret key: it has a normal
String-to-Key specifier (S2K). What you don't want to see is "gnu-dummy S2K"
or "gnu-divert-to-card S2K" (although the latter is our goal).
peter at tweek:~$ cd tmp/
peter at tweek:~/tmp$ gpgsplit ../bla.gpg
peter at tweek:~/tmp$ ls
000001-005.secret_key  000003-002.sig            000005-002.sig
000002-013.user_id     000004-007.secret_subkey  000006-007.secret_subkey
peter at tweek:~/tmp$ gpg2 --edit-key AE2B4D8A
Secret key is available.
pub  4096R/AE2B4D8A  created: 2013-06-08  expires: 2013-06-15  usage: C
                     trust: ultimate      validity: ultimate
sub  2048R/34B258B1  created: 2013-06-08  expires: 2013-06-15  usage: S
sub  2048R/AF72E72E  created: 2013-06-08  expires: 2013-06-15  usage: E
[ultimate] (1). Testkey
gpg> toggle
gpg> bkuptocard 000001-005.secret_key
Signature key ....: [none]
Encryption key....: [none]
Authentication key: [none]
Please select where to store the key:
   (1) Signature key
   (2) Encryption key
   (3) Authentication key
Your selection? 1
gpg> quit
Save changes? (y/N)
Quit without saving? (y/N) y
^^^ GnuPG thinks something has changed about the key. It has not, and it is
safe to save, but err on the side of caution anyway.
------------8<--------cut here-------->8------------
Now you have the key on the card. Obviously, you also still have the secret
key on your keyring. That copy has to go; but think about what you're doing
and if you still have backups. We already covered the case of two smartcards,
with the subkeys on a separate smartcard, elsewhere in the thread. I'm just
going to throw away the secret key now, but obviously I also lose the subkeys
in the process. So think about what you're doing.
peter at tweek:~$ gpg2 --delete-secret-keys AE2B4D8A
peter at tweek:~$ gpg2 --card-status
Signature key ....: 522A 0C00 D2B3 E5A0 2003  0F7E 4E70 3236 AE2B 4D8A
      created ....: 2013-06-08 10:12:29
Encryption key....: [none]
Authentication key: [none]
General key info..: pub  4096R/AE2B4D8A 2013-06-08 Testkey
sec>  4096R/AE2B4D8A  created: 2013-06-08  expires: 2013-06-15
                      card-no: 0005 0000106E
ssb#  2048R/34B258B1  created: 2013-06-08  expires: 2013-06-15
ssb#  2048R/AF72E72E  created: 2013-06-08  expires: 2013-06-15
Et voil?, we have the needed stub. Let's see what the secret key looks like:
peter at tweek:~$ gpg2 --export-secret-keys AE2B4D8A|gpg --list-packets
:secret key packet:
        version 4, algo 1, created 1370686349, expires 0
        skey[0]: [4096 bits]
        skey[1]: [17 bits]
        gnu-divert-to-card S2K, algo: 0, simple checksum, hash: 0
That's correct! And it also works: I could certify another test key with my

@_date: 2013-06-08 13:01:29
@_author: Peter Lebbing 
@_subject: Is this a bug? Primary certification-only key will not "keytocard" 
Hello Werner and list,
I could reproduce the problem the user "Mustrum" had with moving his
certification-only primary key to a smartcard. If you have a primary key with
sign and certify abilities, you can "keytocard" it to the Signature slot of an
OpenPGP card, and it will issue certifications just fine. But you can't move a
certification-only primary key to the Signature slot.
I think I did exactly this with my own key in 2009, and it worked fine.
Also, if you trick GnuPG into moving the primary key to a smartcard, it will
issue certifications perfectly fine as well.
This message is a reply to a message where I explain how I tricked GnuPG, in the
thread "Separate OpenPGP cards for master key and sub-keys".
Is it deliberate behaviour to deny the operation? And if so, I'm very interested
to know why.
By the way, back in 2009 I used a 2048-bit key, and Mustrum ran into the problem
with a 4096-bit key. I just tried, but it won't work for a 2048-bit key either.
Obviously, the chances that it was related to keysize were already slim, but I
checked anyway.

@_date: 2013-06-19 11:30:22
@_author: Peter Lebbing 
@_subject: gpg --fingerprint show only fingerprints and nothing else? 
At the risk of sounding pedantic, let me point out that the output you get with
--with-colons is designed not to change. --with-colons is an option added
precisely because the output without that option might change and break scripts.

@_date: 2013-06-21 12:22:22
@_author: Peter Lebbing 
@_subject: encrypting to a user, "There is no assurance this key belongs 
I don't think that's the problem, gpg is picking the key the OP wants, since it
complains about key 468E35BC having insufficient validity.
Michael, what does --edit-key rconf tell you about key validity?
I don't know what's happening here, it looks to me like you're doing it
correctly and it ought to just work. I tried to reproduce on my Wheezy system
and couldn't reproduce it. But maybe I'm missing some detail.
Do you have any fancy stuff in your gpg.conf? Define "fancy stuff" broadly ;).
Anything you feel comfortable sharing might be useful to mention.

@_date: 2013-06-22 09:56:54
@_author: Peter Lebbing 
@_subject: encrypting to a user, "There is no assurance this key belongs 
I just thought of something. If for some reason your /own/ key is no longer
trusted, you can make signatures all day but it won't increase validity.
If you do --edit-key A8983CE7, what does its trust say?
Your own keys should normally be trusted ultimately, so if it's not trusted,
just give the --edit-key command "trust" and choose option 5.

@_date: 2013-06-29 19:56:05
@_author: Peter Lebbing 
@_subject: Smart card works with GPG v1 but not with GPG v2 on Ubuntu 
On Ubuntu 12.04, the gpgsm package contains the scdaemon, the smart card daemon.
So that's understandable that it needs to be installed.
On 13.04, they moved it to the separate scdaemon package.
GnuPG v1 can work without gpg-agent and scdaemon, but GnuPG v2 cannot. So the
problem is somewhere there.

@_date: 2013-03-05 13:57:27
@_author: Peter Lebbing 
@_subject: Public Keys not showing up in "Choose Recipients" 
People on this list are not paid to answer your questions. Asking twice with a
minute in between is not very civil in my eyes. And perhaps it takes a few days
for someone to /have the time/ and inclination to help you further, so even the
frist "can anyone help me" in less than two days is, IMHO, a bit impatient.
That said, I think this question isn't answered very quickly because this seems
the wrong place to ask. You seem to have a problem with a tool called GPG
Keychain Access or one called iOS Notepad or a plugin to that program. This is
the list for GnuPG, to which, I presume, these programs are a frontend; a
graphical interface. You might be better off looking for the support forum for
these tools rather than asking here.
By the way, some keys are not capable of receiving encrypted mail. This is
related to so-called "capabilities". Have you checked with the owners of the
keys you chose that they are capable of receiving encrypted mail with those
keys? Because this would be an obvious reason why the keys don't show up as
encryption targets, and your bit about the keys having no subkeys made me think
this could be the case.

@_date: 2013-03-06 18:57:47
@_author: Peter Lebbing 
@_subject: using same symmetric key for multiple files 
1) It is irrelevant that the files were similar. The passphrase you choose is
used to encrypt a random session key, and the random session key encrypts the
data. So the passphrase never "comes into direct contact" with the data
2) While in theory there are attacks thinkable that can exploit the fact that
the passphrase is the same each time, the passphrase is also salted before being
used as keying material, so the actual key used changes each time. The material
being encrypted also changes each time (the random session key with an algorithm
specifier prepended), and is very small.
I doubt an attacker would gain something by having multiple Symmetric-Key
Encrypted Session Key packets all created with the same passphrase. But some of
the experts here might know a sweet attack. Or some of those nasty experts that
don't share it here but rather go after your data.
I think you're safe. But why don't you just create a keypair and encrypt to
yourself? It does obviously mean you should have a good backup of it somewhere,
outside Florida, even though you love in Florida. Spread the love! ;)
There is the slight thingy that someone can replace your encrypted data with
other, also correctly decrypting data, since your public key is usually public.
So you should sign then too if you're worried about that.

@_date: 2013-03-07 21:20:54
@_author: Peter Lebbing 
@_subject: OpenPGP card reset procedure 
Always pleasant when one bug takes care of the other :)
PS: I'm not being serious, I just thought it was funny

@_date: 2013-03-20 12:53:03
@_author: Peter Lebbing 
@_subject: GPG2 and IDEA 
In that case you can just use the latest 1.4.13, as Werner indicated. It comes
with IDEA support by default because the patent has expired worldwide now. No
need to compile a separate module.

@_date: 2013-03-23 11:24:17
@_author: Peter Lebbing 
@_subject: dh key exchange via ascii email? 
I find it a really funny idea, in a positive way. "Hey, I've never thought about
it that way!". But it also sounds cumbersome. The e-mail clients will need to
retain a shared secret. If you regularly use multiple computers, you need to
distribute that secret, and it should probably be encrypted itself (protected by
a passphrase) depending on your scenario.
So the really obvious question is: what's wrong with the hybrid crypto offered
by OpenPGP? Why not just use public keys?
PS: Regarding "a simple program to write"; implementing crypto yourself is never
simple. The devil is in the details. Unless you implement an e-mail carrier for
the TLS packets to exchange and use OpenSSL or GnuTLS, I /think/ your
implementation comes close enough to cryptographic primitives to warrant the
credo "never implement crypto on your own".

@_date: 2013-03-23 20:30:23
@_author: Peter Lebbing 
@_subject: dh key exchange via ascii email? 
I hadn't quite picked up on the "forward secrecy" bit in your original mail.
Using subkeys, you can skip the signing. Just create throwaway encryption
subkeys but don't change the primary key that receives the certifications.
I don't see any principal difference with the overhead of maintaining multiple
ephemeral symmetric keys between multiple recipients. Asymmetric keys are more
expensive to create computationally, but I think your computer will be able to
cope. And all you'd need to do is create a few wrappers around GnuPG that force
usage of the desired subkey (a bang will do that: -r 0xDEADBEEF! forces usage of
that particular subkey. You might need to quote the exclamation mark for your
If you were designing a whole new system, the DH exchange makes a lot of sense.
But I think you could easily get comparable functionality by using subkeys a bit
creatively, with OpenPGP.

@_date: 2013-03-24 11:07:12
@_author: Peter Lebbing 
@_subject: How to verify X.509 signatures? 
This is probably a "Microsoft Authenticode" signature on a Microsoft PE
executable. It's very specifically a Microsoft thing, and you'll need a program
with specific support for this format. It's X.509 wrapped inside an executable.
If you Google for it, you'll probably find a lot of references to a heated
discussion between Matthew Garret and Linus Torvalds about including a parser in
the Linux kernel :).
The best I could come up with through Googling was [1]. You might be able to
write something up in Python with the pefile module.
Alternatively, just either
- verify on Windows, by checking the "Properties" of the executable
- verify using the OpenPGP signature they also provide
Seems to me that TrueCrypt is such a high-profile thing that I can see some
secret service subverting a CA to get a valid signature on their own backdoored
version of it.
Also, there is something strange going on? It says on the page you linked[2]
that all downloads are HTTPS, but all the HTTPS server on seems to do is redirect you to the HTTP server. I wanted to say that an X.509
signature on the executable doesn't add much compared to downloading it over
HTTPS, but when the server is downgrading the connection...
Anyway, my point, I wouldn't trust an X.509 signature on TrueCrypt anyway. It's
too big a target for very well-funded groups that can subvert one of the immense
amount of trusted CA's. If you're worried your download might be backdoored, you
should be worried that it probably also carries a valid signature.
Good luck,

@_date: 2013-03-24 13:43:06
@_author: Peter Lebbing 
@_subject: How to verify X.509 signatures? 
If it's about signing rather than verifying, I found this link on the Google
hunt I mentioned in my other mail:

@_date: 2013-03-25 20:01:44
@_author: Peter Lebbing 
@_subject: IDEA License 
Copyright on an algorithm? Don't you mean a particular implementation of the
algorithm? IOW: Wrong question, next try?

@_date: 2013-03-25 20:38:23
@_author: Peter Lebbing 
@_subject: IDEA License 
I see only one post by Julian H Stacey, and the web archive[1] agrees, so maybe
you got a private mail? (But why?)
Anyway, I was slightly irked by his way of phrasing. All in all, I prefer my
post to his, but I wouldn't normally phrase a post like that. So it indeed was
somewhat about etiquette.

@_date: 2013-03-25 20:57:46
@_author: Peter Lebbing 
@_subject: (OT) Re: IDEA License 
Yeah, after I wrote my reply, I wondered if it was even wise to fight fire with
fire. So the lesson didn't come entirely unexpected.
I respectfully disagree that the mail didn't warrant a reply at all. One could
also simply point out that it wasn't very friendly to use 2-word phrases to
point someone to a mistake. And make the same mistake subsequently ;P.
Anyway, on to something fun...

@_date: 2013-03-27 13:50:33
@_author: Peter Lebbing 
@_subject: IDEA License 
Posts by non-subscribers are moderated (held for approval by a moderator).
That's why it took (by comparison) so long to make it to the list. It's there
now, also in the web archive[1].
PS: By the way, your e-mail client doesn't seem to honor the Mail-Followup-To
header, because I spotted Werner Koch in the CC list. Just so you know.

@_date: 2013-03-27 19:27:30
@_author: Peter Lebbing 
@_subject: Mail-Followup-To (was Re: IDEA License) 
Correct, the problem originated when you replied[1] to Werner's mail[2].
Werner's mail had the following header:
Mail-Followup-To: "Julian H. Stacey" , gnupg-users at gnupg.org
The difference between that line and a simple Reply-to-All is that Werner would
be in the recipient list with the Reply-to-All, and not with the
Mail-Followup-To. Your reply should have only had gnupg-users at gnupg.org and your
manually added CC to Ulrich as recipients, since your MUA would conclude that
you don't need to CC yourself :).
Because Reply-To didn't really work out in practice for mailing lists, DJB came
up with two "non-canon" mail headers to remove ambiguity from the meaning of the
Reply-To header. He describes it in [3]. Not everybody agrees with his
view/solution, though.
Whether you like the headers Bernstein created or not, it would seem Werner
didn't want to be on the recipient list, which is why I brought it up in my PS.

@_date: 2013-03-28 11:56:12
@_author: Peter Lebbing 
@_subject: gpg for anonymous users - Alternative to the web of trust? 
People might be more inclined to sign the key when it says something like
adrelanos (Whonix signing key) rather than without the comment.
That way, their signature might mean: Yes, this is that key that signs that
Linux distribution called Whonix. The UID conveys a bit more information about
which adrelanos specifically we're talking here.
That said, the whole problem with establishing a pseudonym and even getting
signatures on such a key is difficult. With proper, real names, and most
importantly people you can meet face to face, it's reasonably established how it
works. But with a pseudonym, it's completely different.
So I'm just wildly spouting random suggestions actually. It's not really well
thought through, but I wanted to point out this possibility.

@_date: 2013-05-08 13:22:16
@_author: Peter Lebbing 
@_subject: How can I extract the --embedded-filename for scripting? 
I see two options.
One: get the name before you write the decrypted file. Since the name is
obviously encrypted, you do need your private key.
$ gpg --with-colons --list-packets foo.gpg
:pubkey enc packet: version 3, algo 1, keyid 26F7563E73A33BEE
        data: [2043 bits]
:encrypted data packet:
        length: 86
        mdc_method: 2
gpg: encrypted with 2048-bit RSA key, ID 73A33BEE, created 2009-11-12
      "Peter Lebbing "
:compressed packet: algo=2
:literal data packet:
        mode b (62), created 1368011777, name="Hi Michael",
        raw data: 16 bytes
I created a file named "Hi Michael" filled with 16 bytes of randomness.
Two: get the name from status-fd during writing the decrypted file.
$ gpg --status-fd 1 --use-embedded-filename foo.gpg
[GNUPG:] ENC_TO 26F7563E73A33BEE 1 0
[GNUPG:] CARDCTRL 3
gpg: encrypted with 2048-bit RSA key, ID 73A33BEE, created 2009-11-12
      "Peter Lebbing "
[GNUPG:] BEGIN_DECRYPTION
[GNUPG:] DECRYPTION_INFO 2 7
[GNUPG:] PLAINTEXT 62 1368011777 Hi%20Michael
[GNUPG:] PLAINTEXT_LENGTH 16
[GNUPG:] DECRYPTION_OKAY
[GNUPG:] GOODMDC
[GNUPG:] END_DECRYPTION

@_date: 2013-05-08 13:36:12
@_author: Peter Lebbing 
@_subject: How can I extract the --embedded-filename for scripting? 
Maybe I didn't read your message well enough before I answered. You said you
couldn't use standard out. This is a crude way to get the status-fd stuff in a
file as you mention:
$ gpg --status-fd 3 --use-embedded-filename foo.gpg 3>foo.status
You need a passphrase to unlock the secret key for
user: [...]
2048-bit RSA key, ID [...]
gpg:encrypted with 2048-bit RSA key, ID [...]
$ cat foo-status
[GNUPG:] ENC_TO [...] 1 0
[GNUPG:] USERID_HINT [...]
[GNUPG:] NEED_PASSPHRASE [...] [...] 1 0
[GNUPG:] GOOD_PASSPHRASE
[GNUPG:] BEGIN_DECRYPTION
[GNUPG:] DECRYPTION_INFO 2 9
[GNUPG:] PLAINTEXT 62 1368012643 Hi%20Michael
[GNUPG:] PLAINTEXT_LENGTH 16
[GNUPG:] DECRYPTION_OKAY
[GNUPG:] GOODMDC
[GNUPG:] END_DECRYPTION
Since my own key is on a smartcard, I couldn't use it to test the "ask for
password on the console" thing, so I used a test key which I don't want to
reveal as it's a spam honeypot key.
Bash scripting can do much nicer things with fd's than just throwing the output
in a file. By the way, you never mentioned the platform you're working on.

@_date: 2013-05-08 17:18:01
@_author: Peter Lebbing 
@_subject: How can I extract the --embedded-filename for scripting? 
2 is standard error (at least, I suppose Windows does that too), so it will be
mixed with any other output to stderr. On Linux, I see the "gpg: encrypted
with..." message on stderr together with the status-fd output.
Depending on the buffering chosen for standard error, it might be racey: if some
other message mingles with [GNUPG:] PLAINTEXT... it might become unreadable for
your script.
Somebody with good Windows scripting knowledge might be able to help you keep it

@_date: 2013-05-09 10:30:43
@_author: Peter Lebbing 
@_subject: How can I extract the --embedded-filename for scripting? 
I considered putting the status-fd stuff into a file, then reading the file and
finally deleting it a much cruder method than connecting the parsing logic to fd
3 directly.

@_date: 2013-05-21 11:08:36
@_author: Peter Lebbing 
@_subject: difference between gpg.exe and gpg2.exe 
It's most likely that gpg.exe is GnuPG 1.4.x, and gpg2.exe is GnuPG 2.0.x.
GnuPG 1.4 is more suited for use on servers and the like, and GnuPG 2.0 is
recommended for use on the desktop.
GnuPG 1.4 is being maintained for situations where GnuPG 2.0 is not appropriate
or less appropriate.
Both will work just fine. But I'd recommend using GnuPG 2.0 unless you have a
specific reason to use 1.4, such as needing it to work without an agent or
pinentry helper. If these terms mean nothing to you, just keep on using 2.0 :).

@_date: 2013-05-21 13:02:17
@_author: Peter Lebbing 
@_subject: Total Newbie Can't Unpack Tar Ball on AIX 
If somebody has a link to binaries for AIX, that might be a much shorter route
to a working GnuPG. Unfortunately I can't provide such a link.

@_date: 2013-05-21 21:36:44
@_author: Peter Lebbing 
@_subject: Windows 101 & GPG4WIN 
This file looks just fine to me, but in general I'd caution anyone not to run
commands they do not understand just because some guy on the internetz told them
to do it.
Note that the mail was also not signed, so even if you trust HHH you cannot know
in this case it wasn't an impostor pretending to be HHH.

@_date: 2013-05-23 13:29:44
@_author: Peter Lebbing 
@_subject: Bug preventing recent gpg4win from running on Chinese Windows XP? 
Are the developers aware of a bug preventing use of recent gpg4win on a Chinese
Windows XP system? At a glance, it would appear to be something that ought to be
fixed. China isn't a tiny country either :).
I do appreciate that some bugs are too complicated to just go ahead and fix,
which is why I phrase it as I do.
The only relevant thing a quick Google turned up for me is a Kleopatra bug
report[1], where there even was very recent activity: a message dated 15 March:
[1]

@_date: 2013-05-23 20:43:28
@_author: Peter Lebbing 
@_subject: Keyring on external encrypted drive 
Werner Koch does not agree it's a security feature (and I suppose that's why you
think it's useful), as he said in this[1] thread:
[1]

@_date: 2013-05-25 14:18:26
@_author: Peter Lebbing 
@_subject: --textmode not retaining the originating EOR 
If I understand correctly, it is the /sender/ who chooses how /you/ will see the
line endings. If they send it using the --textmode switch or the PGP equivalent
option, the .pgp file will be marked to instruct your GnuPG to convert the line
endings to local form, which is just LF. If the sender does not use --textmode
or its equivalent, you will get the EOL's that the original file of the sender
had. If they are using Windows, that will be CR-LF.
I don't think so. HHH mentioned PGP might have this option. The alternative, as
Werner said, is to convert it yourself. As long as the file is consistent in its
line-endings, this shouldn't be a problem.

@_date: 2013-05-28 18:32:13
@_author: Peter Lebbing 
@_subject: Relevance of e-mail (was [OT] Why are you using the GPG / PGP 
Personally, I /am/ interested in why people use their keys (the original
question), and not in the relevance of e-mail.
So I changed the Subject:-line to indicate a split in the thread, in the hope
that people pick up this Subject:-line (or do the same) and that I can recognise
future "relevance of e-mail" e-mails.
If you find this inappropriate, please tell me. I'm not sure on the ethics of
renaming other people's conversations ;).

@_date: 2013-11-01 20:17:41
@_author: Peter Lebbing 
@_subject: make gpg-agent forget the PIN 
Hi Johannes,
Based on a post once made by Werner, I have this script:
gpg-connect-agent 'SCD RESET' /bye
It's called 'scforget' here.

@_date: 2013-11-02 13:12:47
@_author: Peter Lebbing 
@_subject: make gpg-agent forget the PIN 
I unplug my reader (USB) when I don't use it; I leave the card in. I now have
OpenPGP v2 cards, but I earlier had v1 cards that started to malfunction after
some time. I had the impression that they were most likely to keep working if I
didn't remove them from the cardreader, so I tried to avoid that. Also, a worn
out USB connector is very easy to replace when you know which side of a
soldering iron is the hot side. If the contacts of my cardreader wear out, I
can't replace them as easily.
When I suspect I might need the card again soon, I don't unplug the reader. But
I know myself: when I leave for a moment, I might not think of a card that's
still attached and the PIN unlocked. I live on campus, with 9 other students in
this building, and I don't always lock my door. I don't think anyone will come
in, notice the unlocked card, and out of curiosity see what encrypted stuff they
can read, but I just feel a bit awkward when I leave the card unlocked. It's not
a solid argument, but I dislike feeling a bit awkward, so I "lock" the card.
I don't even have encrypted stuff that would be interesting to my housemates.
For example, even if they knew my credit card details, they wouldn't use them.
Or the private key to my own X.509 CA, as another example. It's just that
feeling a bit awkward thing :).
If people are determined and they are able to acces my cardreader with OpenPGP
card in, they are also already sitting at my computer. Then they can do all
sorts of interesting stuff. I just trust my OpenPGP card to keep its private key
to itself; even though other people can get physical access to the card if
they're determined to do so. If I'm up against adversaries that can extract
private keys from OpenPGP cards, I'm out of my league anyway.
I will move to my own house fairly soon; then my computer will be more secure :).

@_date: 2013-11-02 20:20:28
@_author: Peter Lebbing 
@_subject: gpgsm and expired certificates 
I think the most common way for an X.509 CA to be deceitful is by giving someone
else a certificate with your name on it, not by stealing your key.
Then I would be under the impression I was holding an encrypted and signed
conversation with /you/, but I would be talking to the well-funded attacker that
got the false certificate. That attacker could then re-encrypt and send it on to
you, to be a man in the middle.

@_date: 2013-11-07 11:48:07
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner identification? 
Let's leave trust signatures out of the equation, it makes it a lot more
complicated and they are rarely used. I also don't see the relation between the
statements in this quote here.
I get the feeling you're partly responding to my adamant statements earlier, but
you're confusing the situation I was responding to.
I think you're saying: Person X tells me their key is K1. I blindly trust person
X, and I know for a fact that person X was the one who told me K1 is his key.
That is, you were in the same room, or you recognised their voice on the
telephone, or something similar. This is acceptable to many people as a
But this is not the situation I was talking about. It's this:
Person X (having key K1) has signed key K2, asserting that it is held by Y.
Since you blindly trust X, you can assign him full (or hell, ultimate if you
prefer) ownertrust, and key K2 is valid for you. You don't need to sign K2
anymore, because it is already valid since you expressed your trust to GnuPG,
and GnuPG uses it to validate that it belongs to Y.
Now, what Stan Tobias appeared to want, is sign key K2 himself, probably to
express to others in the Web of Trust that he believes K2 to be valid. But this
doesn't add any additional verification of key validity to the Web of Trust,
it's noise. Because anyone else can look at the signature made by X, and decide:
I trust X fully as well. They assign full trust to X, and K2 becomes valid.
Let's get back to ownertrust: in the Web of Trust, ownertrust is an expression
of how well you think other people verify identities before they sign a key. If
you sign key K2 based on X's signature, you haven't verified Y's identity.
You've probably verified X's identity, but not Y's. So you shouldn't sign K2.
You might believe Y when he or she walks up to you and says: my name is Y and K2
is my key. But that is not what happened; X said: K2 is Y's key. Y didn't say
anything to you, let alone that you verified it was actually Y talking. That's
the absolutely necessary part of verification: you believe that it was actually
Y that told you K2 is theirs. Just believing K2 is Y's key is not verification;
it's key validity.
I'll give an example.
In the Web of Trust, key validity is a thing that can gradually build up until
it passes a certain point where we say: I have so much proof that it appears to
be valid, that I conclude it's, within reason, valid. This is why you have
"completes needed", "marginals needed", and "max cert depth". The latter says:
once we pass a certain depth, my proof of identity becomes so indirect I don't
wish to trust that information anymore. I will paint a picture with the default
settings, completes 1, marginals 3, max depth 5.
Suppose A has signed B. There are three people C, D and E, who have full trust
in A. They do what I'm arguing against: they sign key B as well, based on their
trust of A.
Now I come along. I actually have key A valid as well, but quite indirectly: it
is at level 4. I know A, but ownertrust is very personal. I think A does an okay
job of verifying identities, but not to the rigorous level I personally demand.
I work with pretty sensitive stuff, and my standards are high (I'm painting a
picture here, not describing reality). So I assign him marginal ownertrust. Now
what I would expect, is that I need some more signatures, and B will become
valid at level 5, the level where I have configured GnuPG to say: okay, this is
deep enough, I will not take into account B's signatures on other keys because
the proof becomes too indirect.
However, I also know C, D and E, signed their keys and assigned them marginal
ownertrust because I was under the impression they also verify identities pretty
well. I don't know that they go around signing keys based on other people's
C, D and E are thus at level 1 in my web. They all signed B's key, so I think:
that's reasonable proof that B is valid. Not only do I think that, so does
GnuPG. It leads to B's key being valid at level 2. B can have another few levels
of indirection before I consider the path too long. In fact, for signature paths
through B, it effectively just changed my "max cert depth". B belongs at level
5, because the proof of validity is very indirect in my *own* web, but he's at
level 2, so my "max cert depth" has effectively become 8 instead of 5 for paths
through B.
Furthermore, what does my Web of Trust seem to imply? It implies that 3
reasonably trustworthy people all individually certified B's identity. That's a
fair amount of proof that the identity is correct. More eyes have seen the
passport or more people have known B for very long.
What is actually the case? This one person, A, whom I somewhat trust, has
certified B's identity. It's almost as if I'd set my "marginals needed" to 1,
because no more verification has ever been done of B's identity.
This is why I am adamant that you should not sign based on other people's
certifications. You are muddling my view, and I think I'm basing validity on one
thing whereas I'm accidentally basing it on something else. I have keys on my
ring that are valid, even though they did not pass my personal demands of
Lying was also brought into the discussion, as if that changes things. We are
talking about trust here; I'm making a mistake when I assign ownertrust to a
liar, but that in no way implies that it's okay to sign keys without verification.
When I find out people lie about their verifications, I set those people to "I
do NOT trust". When I find out people sign keys they haven't verified, I set
those people to "I do NOT trust".
The rest of your message about how you check an identity is a different topic
altogether. But let me say this: when I sign an UID, I primarily sign the name.
I prefer there's no comment, so I don't have to think about that, and ownership
of an e-mail address is an interesting topic. Who owns l.gaspard at yourisp.com?
You or your ISP? Both? Neither? If you wish to debate about how you check an
identity, please create a separate thread, because it is a different topic.

@_date: 2013-11-07 19:21:28
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner =?UTF-8?Q?identification?= 
Of course it's not useless. You seem to misunderstand the Web of Trust.
I'll give an example.
I know and trust the people A, B, C, D and E. A has signed B, B has signed C, C has signed D, D has signed E, and E has signed F. I meet up with A, verify their identity, and sign their key. I assign ownertrust to A, B, C, D and E. Et voil?, the keys A, B, C, D and E are all valid, without me needing to meet up with my other friends to verify their key details. A is at level 1, B at 2, C at 3, D at 4, and E at 5. Unfortunately, F won't get valid because it is at level 6.
Now suppose C signs F as well. F is now at level 4, so it becomes valid. However, I don't trust F, so even if F now signs G, G won't become valid.
Signatures indicate verification, not trust or belief. Trust is in your trust database or in trust signatures, but the latter are not commonly used. Belief is expressed in validity calculated from your trust database and signatures. I don't know if you can choose to disagree with GnuPG, that is, if you don't believe a key is valid even though GnuPG calculated that it is.
I could get back to all the other points you raise, but I think it's a waste of time when you have reasoned from the standpoint that to get a key to be valid, you need to sign it, and that is how it looks to me.
It's not much of a Web when you don't have any depth... it's more of two intertwined strands then ;).
PS: My ownertrust for E is useless for now, because he/she is at level 5. However, if I get a shorter path to him or her later, it will become useful then.

@_date: 2013-11-08 19:01:34
@_author: Peter Lebbing 
@_subject: Signing keys on a low-entropy system 
Nope, OpenPGP uses EMSA-PKCS1-v1_5, which is completely deterministic.
I /think/ GnuPG doesn't need any randomness for RSA signatures.
I moved my random_seed file, and performed the following steps:
- Extend the expiration date on an RSA testkey that was expired[1]
- Sign a testfile
- Verify the signature; this launched a trustdb check since I had edited the key
And no new random_seed was ever generated. Then I tried encrypting to that key
(after having extended the expiry date of the subkey as well), and now a
random_seed was generated.
So my guess is that indeed, RSA signatures do not use randomness. And that as
soon as you use randomness, a random_seed file will be created.
In fact, I seem to get the same results when not removing my old random_seed,
but simply by looking at the modification time of the file: it will not be
touched when randomness isn't used.
Obviously, this is all conjecture.
[1] Format: primary 2048R has SC capabilities, sub 2048R has E.

@_date: 2013-11-11 11:58:28
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner identification? 
Actually, I think the whole Web of Trust business is deceptively
complicated, even though at first glance it seems not to be.
So there's no need to be apologetic about it.

@_date: 2013-11-14 19:45:09
@_author: Peter Lebbing 
@_subject: Does anyone use an NXP JCOP J3A smart card? 
You can't just take some smartcard and expect it to function as an OpenPGP card,
because the OpenPGP card is a specific application on the card. Think of the
smartcard as a computer, and the OpenPGP application as some piece of software.
Thing is, you don't normally change the software on smartcards like you would
with computers.
The only way to have a different card function as OpenPGP card is by writing
your own firmware(=software), which is hard and likely will require you to sign
a Non-Disclosure Agreement with the manufacturer of the card you are targetting.
I think your only option is to find some distributor that does sell OpenPGP
cards in your area, or somehow get a foreigner to buy one and send it in the
mail or something like that.

@_date: 2013-11-19 12:07:00
@_author: Peter Lebbing 
@_subject: Unusual (unintended?) behavor upon decryption of a message 
You're only partly correct. Letting 'gpg2 --list-packets --list-only' inspect
the message, I see:
:pubkey enc packet: version 3, algo 1, keyid CB0669F10BD2393E
        data: [2048 bits]
:symkey enc packet: version 4, cipher 3, s2k 3, hash 2, seskey 256 bits
        salt 8813f6959e774f45, count 9437184 (210)
gpg: CAST5 encrypted session key
:encrypted data packet:
        length: unknown
        mdc_method: 2
gpg: encrypted with 1 passphrase
gpg: encrypted with RSA key, ID 0BD2393E
So it can be decrypted either with the mentioned RSA key, or by some passphrase.
There are two ways to get at the data. If you don't have that RSA key, programs
will likely query you for the passphrase. If you do have the secret key for that
RSA key, I suppose it will ask that first, although I'm not sure. It will ask
for the passphrase for the RSA key, but I'm unsure if it will be the first
passphrase it asks for.

@_date: 2013-11-19 21:01:56
@_author: Peter Lebbing 
@_subject: Unusual (unintended?) behavor upon decryption of a message 
The passphrase is used to decrypt the concatenation of an octet specifying
what cipher was used for the symmetrically-encrypted data packet and the key
for that data packet. If you give the wrong passphrase, this comes out as
random rubbish, and that first octet specifying the cipher for the data is
rubbish as well. This is what GnuPG reports. There is no check if the
decryption was succesful; it just results in garbage. After a few tens of
tries, I suppose you can actually hit the case where the algorithm
identifier is something usable, and GnuPG will probably try to decrypt the
data packet with the rubbish it got from the symmetrically encrypted session
key packet :).
This line of reasoning is wrong. You are thinking of a system that knows the
passphrase, and through its error messages, leaks data about it. But GnuPG
knows as much as you. The security of the system is in the encrypted file,
not in the program you use to access that file[1]. If GnuPG gave error
messages that leaked data and this problem was fixed, you could simply write
your own program that gives leaky error messages to you and use that to
crack the key. Obviously it doesn't work that way.
[1] Actually, DRM borders on exactly this: it gives you everything, but then
tries to prevent your use of it. Which is why it has been called Broken By

@_date: 2013-11-19 21:05:06
@_author: Peter Lebbing 
@_subject: Unusual (unintended?) behavor upon decryption of a message // 
TWOFISH was used to encrypt the session key. What was used to encrypt the
data is still unknown, since that knowledge is encrypted. (With TWOFISH. Are
you still following? ;P)
There are potentially two symmetric ciphers at play, one to encrypt the
session key, and one to encrypt the data.

@_date: 2013-11-19 22:54:10
@_author: Peter Lebbing 
@_subject: Unusual (unintended?) behavor upon decryption of a message 
I only did a quick check of RFC 4880, and that (section 5.3) clearly states
there is an octet for the symmetric algo used inside the encrypted part:
So even if GnuPG always picks the same algo for both, the format of an OpenPGP
message still separately specifies the algo for the data.
How is this different from just writing your own implementation for decrypting
the symmetrically-encrypted session key packet? Why would you abuse the GnuPG
binary for this? The GnuPG binary doesn't provide the security, the encryption
on the file does that.
Furthermore, since the password is iteratively hashed with a salt, I don't think
it would be possible to leak anything about the first few characters of the
password. A hash evenly spreads all characters over the key (I'm oversimplifying
a bit here).
You just know the first octet of the plaintext of the symmetrically encrypted
session key packet; the rest is utterly random. This is even a better situation
than with "Monthly results.doc.gpg" where you probably know a lot of the header
of a Microsoft Word document; it would be a lot easier to immediately attack the
symmetrically-encrypted data than to first attack the session key packet and
then try that on the data.
When I say a lot easier, I still mean utterly impossible, though ;).

@_date: 2013-11-27 11:43:19
@_author: Peter Lebbing 
@_subject: Using Gnupg from the command line with no arguments 
I'm pretty sure this is not correct.
When you start it without arguments, it expects an OpenPGP message on stdin
(pronounce "standard in"). Since you're working from the command line, stdin is
your keyboard. You're calling this "a primitive sort of text editor" but it's no
more a text editor than the command line itself, where you enter commands to
execute, is a text editor.
On Linux, you can type Ctrl-D to signal the end of a stdin stream. Look what
happens when I do that:
peter at tweek:~$ gpg2
gpg: Go ahead and type your message ...
gpg: no valid OpenPGP data found.
gpg: processing message failed: Unknown system error
peter at tweek:~$
I typed: Blah
The lines "peter at tweek: ~$" are my command prompt.
Charly Avital mentioned pressing Ctrl-C; this would be to signal to gpg2 you
want it to exit. Here's what happens when I type Blah:
peter at tweek:~$ gpg2
gpg: Go ahead and type your message ...
gpg: signal Interrupt caught ... exiting
peter at tweek:~$
This does not process the input on stdin, because you're signalling you want
gpg2 to stop what it is doing and quit, which is different than signalling that
you're done with typing on stdin.
The ^C is the shells way of telling me I pressed ; this doesn't happen
for all control codes.
Now what you're probably thinking of is something like this:
peter at tweek:~$ gpg2 -r peter -ae
I'm talking to myself.
peter at tweek:~$
I typed the line of input, However, I had to specify up front I wanted to encrypt to myself, it's not, like
you said
Also, your cursor keys will most likely not work. You can type in text, erase it
with , and make a line final with . It's a really unfriendly
environment, because it's not an environment really meant for the user. So
you're much better off with a (primitive or not) text editor.
One final point: MacOS shares UNIX roots and POSIX stuff with Linux, so I expect
that  ends the stdin just like it does on Linux.
If you like, I can explain you where  and  come from. If you
don't care, you can stop reading and I wish you a good day :).
It might help you remember why these keys work, which is why I think it's very
slightly on topic. Actually, I just like telling this and I'm looking for a
When you type letters from the Latin alphabet, these letters are passed to the
system as ASCII, which is a table of 127 characters that contain the alphabet,
numbers, some more stuff, as well as so-called control codes. The control codes
are right at the beginning of the table: the first 32 entries (entries 0-31,
computers usually start counting at 0). On many systems, you can enter these
control codes by holding down "Control"[1] and using the keys @ followed by A-Z
followed by [, \, ], ^ and _. If you look at the ASCII table, you'll notice that
these are the entries numbered 64-96[2].
So when we're pressing , we're passing ASCII 3,  passes ASCII 4,
and  passes ASCII 28.
, ASCII 3, is called ETX, End of Text. , ASCII 4, is called EOT,
End of Transmission. , ASCII 28, is called FS, File Separator. These are
ancient names, and the names don't always still match current usage, although
there still is something reminiscent of logic.
Now I happen to know that  asks the program to "dump core"[3], so I
entered "ascii 1c dump core" in startpage.com (1c is hexadecimal for 28, I
expected more results for hexadecimal numbers), and it linked to a nice page[4].
It describes the three as (amongst others):
SIGINT is "signal Interrupt", compare to the GnuPG output.
Now if you from now on think of Ctrl-D as "End of Transmission" instead of the
awkward "control dee", maybe you can remember better. It's unfortunate that
Ctrl-C is called "End of Text", though. And File Separator just doesn't make
sense ;).
Just as a bonus:
 is called DC3 "Device Control 3", but also XOFF "Transmission off". You
can use it to pause the output on the terminal screen. When two systems are
communicating through ASCII, it is usually sent when the receiving system can't
keep up with the flow of data that the other system is producing. When you press
, you're basically saying "hey I can't read that fast!". When you've
caught up, you press , DC1 "Device Control 1", also XON "Transmission
on". The output on the terminal will resume, and you can read the rest of the text.
[1] You hold down "Control" to enter control codes on your keyboard. I don't
think this is a coincidence, but I didn't check the etymology.
[2] If you make an ASCII table in two columns they'll line up next to eachother
because you're putting entries 0-63 left and 64-127 right.
[3] I'm already explaining a lot, I'm not really going to touch that one... :)
[4]

@_date: 2013-11-28 10:10:01
@_author: Peter Lebbing 
@_subject: Smart card reader security 
Meh. They just replaced all hardware inside and only re-used the shell of the
While it illustrates the point they're making in the article, it's not nearly as
cool as modding the firmware of the actual hardware through a rogue firmware update.
And even then I'm missing some nice details: how did they take care of the
special sticker that is supposed to crack when you try to open the device? (It's
usually holographic to prevent reproduction). And did the case crack or snap
when disassembling, leaving obvious marks where it did? I'm not saying these are
sufficient methods to prevent access to the inside[1], I'm asking if they could
take care of these things. For all I know, the underside of the device in the
video is a mess of broken plastic with some strips of holographic sticker
keeping it all together.
They compare it to the hack on the voting machine. I absolutely disagree: that
hack is what I'm talking about, a rogue firmware update, throw in a little
electromagnetic emission analysis for extra goodness.
I could do the PIN pad hack. I certainly can't do the voting machine hack.
Again, it illustrates the point they're trying to make, but it's not spectacular.
[1] For instance, you could take two or more devices, and saw them through at
different places. Once you have them somewhat open, you can probably carefully
pry pieces apart until you have an undamaged specimen of each part of the case.
By the way, you could prevent access to the insides fairly well by filling it up
with polyurethane once assembled, obviously making sure you have sealed all gaps
like card insertion slot and keyboard :).

@_date: 2013-11-28 10:16:34
@_author: Peter Lebbing 
@_subject: Decrypting symmetrically encrypted text in Command Line (CL) 
Yes, that is what I was thinking, that it tries to read the password from stdin
as well. No matter the specific mechanisms at play, it is simply impossible to
reliably get both the message and the password from stdin, AFAIK.
Which is why I wanted to ask: are you using gpg-agent? Could you try configuring
(and using) gpg-agent such that it will ask for the password with a pinentry
window popping up? Because it should be possible to decrypt from a pasted text
in the command line as long as it's not necessary to enter the password in the
same command line window, which the agent should allow you to do.
I don't have access to Windows machines to try this myself.

@_date: 2013-11-30 22:48:13
@_author: Peter Lebbing 
@_subject: multiple keys with different UIDs and common WoT? 
You could build the WoT only on your personal key (which survives switching
jobs), and set your personal key as ultimately trusted on your work PC (work PC
only has the public key for your personal key). An ultimately trusted public key
is no different from installing the private key for trust calculations, I think.
I tested the situation, it seems the same to me with or without the private key[1].
BTW, some people frown on signing a key both with the personal and the work key
as in your scenario, because you will count as two people in trust calculations
done by GnuPG.
[1] Specifically, assigning ultimate trust moves the key to depth 0 in the trust
calculations, and it is used to validate keys at depth 1, just like an
ultimately trusted public/private keypair.

@_date: 2013-10-01 19:48:16
@_author: Peter Lebbing 
@_subject: OpenPGP Smartcard + signing email = two signatures? 
It's probably a benign bug, but it would obviously also be a reasonably good way
to get signatures if somebody had compromised your PC. Put a payload in GnuPG
such that when you try to sign something, it will first sign the attackers
message with your first pinentry prompt, and then just prompt again for your
signature. People who work with computers generally just try again if the first
time mysteriously failed.
This does presume that you enter your PIN on the cardreader, because otherwise
it would be simpler to just use the PIN you give to the PC :).
But I think it's more likely there's a little bug somewhere that loses the message.

@_date: 2013-10-03 13:26:56
@_author: Peter Lebbing 
@_subject: GPG2 encryption options 
100,000 tries for an attacker amounts to 17 bits of security. This is as little
as nothing at all.
gpg-agent can remember passphrases for you. You could also look into using a
smartcard. With a conventional, on-disk key, the passphrase cryptographically
protects the secret key material, so it needs to be complicated to have enough
entropy. With a smartcard, you only use a PIN, say 8 digits. 8 numerical digits
is 27 bits of entropy, again nothing. But that's not a problem because the card
locks after 3 tries; the PIN is not used as a cryptographic key. Entering an 8
digit PIN is much less work than entering a good passphrase.

@_date: 2013-10-03 14:09:59
@_author: Peter Lebbing 
@_subject: GPG2 encryption options 
Small detail: this feature is not working in the current stable versions. GnuPG
2.1 will support this.
I use the following script to make the card forget its PIN:
gpg-connect-agent 'SCD RESET' /bye
I created this based on a message of Werner Koch to this list. Earlier, I killed
the scdaemon.

@_date: 2013-10-08 10:45:56
@_author: Peter Lebbing 
@_subject: GPG2 encryption options 
As long as you send it to gnupg-users at gnupg.org, people on the list will get the
mail. Additionally, you can add specific people to To: and Cc: who you want to
mail directly.
The only thing is the Reply-To: header you set. It doesn't always do what you'd
expect for a mailing list. For instance, I had your yahoo address in Cc: when I
pressed reply for this mail. I removed it manually.
Can you describe what you are trying to achieve? Not how, but what, or perhaps
how you intend to use it. Because I don't think you're going about it the right
way, but I'm not sure what you're trying to do anyway.
I don't think it's a good idea to generate random passphrases or something like
that. If your use case is this:
- You have a lot of files you wish to use often
- You don't want them to be in plaintext, because you're afraid someone might be
able to get at your backups
- You don't want to enter a passphrase each time
Then I think this scenario is best met by using public-key encryption and having
gpg-agent store the passphrase after you enter it the first time after you
booted the system and use one of the files.
In this case, you're not using public-key crypto because you want to give your
key to the public, but because it is a good way to gave gpg-agent keep the
passphrase for you. If it weren't for your requirement that you don't want to
enter those passphrases, you could also use symmetric crypto, but then gpg-agent
doesn't know that it should have the passphrase for a file. By using public-key
crypto, gpg-agent sees that the file is encrypted to that key, and it knows the
passphrase, so it can just unlock the file without bothering you any further.
If you so wish, you could create a keypair specifically for this purpose, and
not give the public key to anyone or send it to a keyserver. I'm not saying it
gives some extra layer of protection, and I'm not suggesting you do. I'm simply
saying it's a possibility should you want to.
Note that the second point of the scenario I give ("you're worried about people
having access to your backups") is part of a very important thing you should
consider: what is your threat model?  What do you want to protect against? If
you just go and blindly encrypt stuff because it feels safe, you're not going to
end up with something that is actually helpful.
A passphrase is something you know. You store it in your mind and access it
through neurons. If you store it on your harddrive, I wouldn't consider it a
passphrase anymore. Surely, you can build some wrapper around GnuPG, but you're
changing the concept from a passphrase to key material.
But, gpg-agent can cache a passphrase for you. It doesn't store it unencrypted
on the hard disk. I think it keeps it in a piece of main memory that it told the
operating system about to keep the OS from writing it to swap, so it stays off
your disk.
$ man gpg-agent
--default-cache-ttl n
   Set the time a cache entry is valid to n seconds.  The default is 600 seconds.
You would put this without the two dashes on a single line in your gpg-agent.conf:
default-cache-ttl 1800
to cache it for half an hour. Also see max-cache-ttl; they probably need to be

@_date: 2013-10-09 11:17:22
@_author: Peter Lebbing 
@_subject: GPG2 encryption options 
I think this is the best suggestion so far, if I understand the use case
correctly. I had a case of tunnel vision restricting me to GnuPG as the tool
to use, when a different tool might be the better solution.

@_date: 2013-10-12 11:43:15
@_author: Peter Lebbing 
@_subject: First steps with GPG, am I off to a good start? 
The defaults are an RSA primary key for certification and signing, and an RSA
subkey for encryption. Even without the --expert flag, you can also choose to
generate a primary key just for certification and signing, and then in a second
step add more subkeys.
The choices of keys you get without --expert are:
So you don't need the --expert flag for that.

@_date: 2013-10-18 11:37:00
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner identification? 
Then you could simply sign the notary's key and assign it full ownertrust. No
need to sign keys you verified by checking the notary's signature.
In fact, if I found out someone was uploading signatures to the keyserver for
which they did no more verification than checking the signatures made by people
they trust, I would immediately assign that person "I do NOT trust" in my trust
database. They are poisoning my Web of Trust! If I trust the notary as well, I
can also assign that person ownertrust and get valid keys through his or her
signatures. But if other people are signing keys purely based on the notary's
signature, they are meddling with my parameters "marginals needed", "completes
needed" and "max cert depth".
Suppose I have "marginals needed" set to 3. And 3 people I assigned marginal
trust did no more than verify the signature by the notary before signing some
key themselves. All the verification that has been done on the identity of the
person holding that key is done by a single person, the notary. But I see 3
people who supposedly have verified the identity. Also, if the signature path to
the notary is longer than the signature path to these 3 people, they have just
artificially altered my "max cert depth" by shortcutting the route that would
otherwise have gone through the notary, who actually did the verification.
The moral: I think it is a really bad idea to sign keys because you trust
already made signatures. That's what your trust database is for, use that. You
should sign keys because you verified the identity *outside* the Web of Trust.
All this only applies to exportable signatures. If you wish to make a local
signature on some key to make it valid, go right ahead. You're not meddling with
my Web of Trust that way. You might inadvertently meddle with your own, though!

@_date: 2013-10-18 11:59:15
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner identification? 
However, here an interesting dichotomy surfaces: the scenario the OP painted was
that the HR person or notary did not use OpenPGP or key signatures, but that you
still rely on the identity verification done by the HR person. This would thus
constitute identity verification outside the Web of Trust, and I suppose I would
find that acceptable. Although I'm a bit unclear on how this "virtual keysigning
party" would in practice be held: how does the notary state he trusts the
identity? Where does the fingerprint of the key come in to play? You are
asserting that a certain person holds a certain key, the key has to be part of
the verification. But the notary wasn't using OpenPGP.
The dichotomy is thus: if the notary does not sign keys, I would be okay with
people signing keys based on the notary's verification efforts. But if that same
notary did everything he or she did before *and* did something extra, namely
signing keys, suddenly I'm not okay with people signing keys based on the
notary's verification efforts. That's odd.
But the dichotomy doesn't change my position on this. Perhaps a clear answer to
how the key fingerprint comes into play would take away the oddity, because
perhaps then suddenly there /is/ a verification effort by the people signing the
key: that the key belongs to the owner. That the owner is who they say they are,
is then left to the notary.

@_date: 2013-10-19 13:17:02
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner identification? 
I don't think I myself would consider that enough verification to sign a key.
Too many other communication components involved.
I was more thinking along the line of a Zimmerman-Sassaman protocol key signing
party where the HR person is present and every line on the list is done as follows:
Person on list: "Yes, entry 42 is indeed the fingerprint of my key"
HR person: "Yes, this person is indeed the person listed at entry 42"
This would be a considerable speedup for the ID verification stage, still
presuming that you trust HR to properly verify someone's identity.
I don't think this would still be a "virtual" keysigning party, though :).

@_date: 2013-10-23 20:52:42
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner identification? 
Paradox would be the best and is what I should have used. Not dissonance.
I strongly disagree. The paradox is created by the fact that you screw up my Web
of Trust parameters by signing stuff based on other people's OpenPGP signatures.
I don't see how willingness is ownership in other words. The concepts seem
rather dichotomous, oh sorry, disjoint to me :).
But since I wouldn't sign a key where the owner didn't give me the Key ID
theirself, it would indicate willingness. Even stronger, it wouldn't even
indicate ownership: they could have given me the Key ID of a key where somebody
else, the real owner of the key, made a User ID with their name in it. I can't
verify ownership: even if I see them making a signature right before my eyes,
they could secretly be talking to an automated service somewhere that actually
makes the signatures, and they might not have access to the key at all. I
wouldn't go so far as to stick them in a Faraday's cage to ensure they can't
communicate with the real owner of the key.
Only 3. would perhaps qualify for a signature, in my opinion. The other 2 are
food for your trust database or perhaps local signatures, not for exportable
I should add that signing a message that says "I use 0xABCDEFGH" with that same
key is a bit silly. (By the way, hex goes to F ;P). You use OpenPGP signatures
to add authentication to messages that can be forged otherwise. Those signatures
are only credible if you have verified that you have the correct key of that
person. It's not the other way around: the signature does not prove it's the
correct key, since the message could have been forged. You need a secure channel
to establish that it's the correct key, such as a face-to-face meeting. Or you
need to trust the corporation's signing key, but that belongs in your trust
database, not your exportable signatures.

@_date: 2013-10-24 11:35:46
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner identification? 
The paradox was very clear in my post where I still called it a dichotomy. There
was a paradox in my thoughts and conclusions, why do you suddenly state there is
no paradox?
And my original statement included: the moment I find out people sign keys
purely based on OpenPGP signatures they trust, they get an "I do NOT trust" in
my trust database. Obviously you also try to do this for liars, so this is no
different: when you find out someone's a liar, you give them negative trust in
your trust database.
The moment the verification is outside the Web Of Trust, it can start to be
enough. For an explanation I refer to my mail of 18 October, 11:37 CEST. You are
skewing my parameters "marginals needed", "completes needed" and "max cert
depth". If I trust the notary just like you do, I give that person full
ownertrust, and the keys they signed will become valid by that. I don't need nor
want your signature for that if it's just based on the fact you trust the notary.
Because these are verifications outside the Web of Trust.
No, the difference is that in case 3., you (hopefully) actually did the
verification yourself for key K1, an you extend this verification you did
yourself to key K2. In the other cases, I can get validity for the keys in
question by assigning trust to the same signers that you trust. In case 3., you
are actually adding information to the Web of Trust, just like in the case where
the notary did not create OpenPGP signatures themselves.
That's correct, you could be so demanding that you say that you insist on seeing
the person face-to-face before you signed their key, because key K1 could have
been stolen and you don't want to make /new/ certifications based solely on a
signed message. It's a personal decision. You could have higher standards for
certifications than for other communication (for which you would trust the
And these higher standards aren't prohibitive, because certifications are rare.
You can spend a little effort on them that you don't want to spend for other
I wouldn't sign K1 in this case (I'd assign ownertrust to my friends so the key
becomes valid), so if I would sign K2, I think that would be beyond a paradox
and just downright inconsequent. So no, I wouldn't sign K2. I never did any
verification of the identity of this person. They should ask my friends to sign
this key if they don't want to do a face-to-face.
Sounds to me like you give a good point why you shouldn't sign in case 2a.
Hehehe :)
I don't think it was. Too short, and you might not make your point properly.

@_date: 2013-10-24 20:52:10
@_author: Peter Lebbing 
@_subject: trust your corporation for keyowner =?UTF-8?Q?identification?= 
*Sigh*. No, it's the other way around. The Web Of Trust should never be a basis for your signature, because anyone else can simply trust the people who already made signatures to make keys valid, and you only muddle the view when you sign keys without verifying someone's identity. But I get the sense I'm not coming through to you, so maybe we can just agree to disagree, or at least agree to not understand eachother. I get the sense I've made my point already and I'm just rehashing old material by now.
Sure, if you like to. I never pressed you for an answer anyway. You don't have to convince me; I'm quite happy being stubborn.

@_date: 2013-10-27 12:30:34
@_author: Peter Lebbing 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
I think this is a very important one, as we've seen with the debacle with
OpenSSL in Debian where DSA keys were compromised even when just used to create
a signature[1].
But I can think of another one: much more hardware support. Both smartcards and
crypto-accelerators either in a general purpose CPU or as a module in a computer.

@_date: 2013-10-27 12:34:24
@_author: Peter Lebbing 
@_subject: 2048 or 4096 for new =?UTF-8?Q?keys=3F=20aka=20defaults=20vs?= 
Hmmm you press Send and you think: I might have overstated that. Where's unsend? I think it's a real advantage of RSA. I don't think it's a very important one, because other broken parts can compromise stuff just as well. Your stuff shouldn't be broken. Broken is bad, m'kay?

@_date: 2013-10-27 12:59:26
@_author: Peter Lebbing 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
I was thinking of automated systems doing verifications, not end users. But the
smartcard thing is the biggest advantage of hardware support.

@_date: 2013-10-27 13:11:16
@_author: Peter Lebbing 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
Okay, first of all, I'm doing something wrong here, I should group my responses
and think a little longer about it. This is mail, not chat. My apologies.
I think RSA has seen more cryptanalysis than DSA and ElGamal, which is in favour
of RSA.
Also, RSA allows hashes other than SHA-1, whereas with DSA you need to switch to
DSA2. So to get support for other hashes, a switch would be necessary anyway,
and less applications supported DSA2 at the time I believe.
A signature by a 2048-bit DSA key is twice as large as a signature by a 2048-bit
RSA key, but offers the same order of strength.
I think there were discussions about this on the mailing list around the time of
the switch as well, so you could browse through that. Other than that, obviously
only the people who made the switch can tell you exactly why they did that. My
guess is, Werner commented on that when there were discussions here around the
time GnuPG switched from DSA/ElGamal to RSA.

@_date: 2013-10-27 13:20:26
@_author: Peter Lebbing 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
Oops. I just read Werners message, and I had it reversed :). Taking a look at
RFC 4880, I see that a 2048-bit key has a 256-bit parameter q, and the signature
is two values mod q, so 512 bits. By the way, q limits the hash size.

@_date: 2013-10-27 13:32:12
@_author: Peter Lebbing 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
Yes, although I don't think it makes sense to create an X-bit primary key with a
Y-bit subkey if X is smaller than Y as the attacker can "simply" crack the
primary key and attach a new subkey which will be preferred because it is newer.
Optionally he can revoke the old encryption subkey.
But the following layout is sensible on some level:
3072-bit RSA primary for certification (C)
2048-bit RSA subkey for data signatures (S)
3072-bit RSA subkey for encryption (E)
Note that I'm not going into the discussion whether any protection beyond 2048
is sensible or whether it is already impossible to crack an X-bit primary key
for useful X's.
If signatures aren't that important to you anyway, you can wonder if it is
useful to spend time on making it more efficient by lowering the length.

@_date: 2013-10-27 19:47:31
@_author: Peter Lebbing 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
AVR XMEGA has DES and AES, no asymmetric acceleration. Also, I think the market
of XMEGA is phenomenally tiny compared to regular AVR/PIC (personally, I would
go to ARM if megaAVR isn't enough).
Are there 8-bit microcontrollers with RSA acceleration?

@_date: 2013-10-30 20:37:53
@_author: Peter Lebbing 
@_subject: The symmetric ciphers 
Why are you inventing new crypto primitives? Symmetric crypto is already good
But to immediately debunk this system: there is a strong correlation between P
and N (i.e., the plaintext). This means you are encrypting strongly correlated
material with two different ciphers. If you can somehow make them meet in the
middle, you no longer have to completely break one of the ciphers completely
but instead break both partially, which might be orders easier to do.

@_date: 2013-10-31 20:23:10
@_author: Peter Lebbing 
@_subject: The symmetric ciphers 
Then again: If brute forcing a key costs you all the energy in this solar
system, you don't have any light to read the decrypted message by. And that's
what we're talking about here.
So: forget about brute-forcing.

@_date: 2013-10-31 22:17:39
@_author: Peter Lebbing 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
I just glanced over the abstract, but didn't you glance over the term "related
key"? I.e., not generally applicable.

@_date: 2013-09-03 18:49:07
@_author: Peter Lebbing 
@_subject: Security of 3DES 
My main point is furtheron because I reply inline
I have to assume "can handle" here means: get good encryption speed. Because:
We /are/ talking OpenPGP here, so any implementation is required to be able to
handle 3DES. There is no OpenPGP-conformant implementation that will do CAST5
but not 3DES. Also, 3DES is always in your preference list; if not explicitly,
it's implicitly added as the least-preferred algorithm (i.e., at the end of the
To expand on what Johan Wevers said: symmetric ciphers do not change the length
of the encrypted text (by more than the block size). They certainly do not
compress. Usually, data is compressed before encrypting it (compressing it after
is pretty useless). If you set your key preferences to not allow compression,
files encrypted to your key will not be smaller than the original files.
*Here is my main point* which made me decide to reply.
3DES is safe. It's incredibly safe! How is it no match for modern CPU power?
There are no practical attacks on 3DES. What are you trying to say?
A passphrase on a key is already encryption and it is useless to encrypt it more
beyond that.
... which just creates a useless dependency on a piece of software you might not
be able to get for your computer in 10 or 20 years, IMHO. Put a passphrase on
the key and presto, nothing more needed.

@_date: 2013-09-06 10:29:08
@_author: Peter Lebbing 
@_subject: my statements were twisted 
I never deliberately twist people's words, I hate that[1]. I always try to see
what the person means to say, even if it's not literally what they wrote. But I
often find your walls of text hard to follow, so I'll probably sometimes
misinterpret it. It could be me, or maybe you could phrase better what you
intend to say.
It was an honest misunderstanding, there is no need to get angry. I'm sorry that
my reply upset you.
[1] Perhaps I might be nasty in different ways if grumpy and stroked the wrong
way, but twisting words is not my thing.

@_date: 2013-09-07 16:10:11
@_author: Peter Lebbing 
@_subject: Transfer subkey to other keyring 
I believe once GnuPG has a secret key, it won't update it anymore with any
subsequent imports. So to get the additional subkey, re-export the whole thing,
delete the existing one on the other system and import your re-exported whole thing.
I'm also wondering why you're being so explicit about it in the first place,
with transferring little chunks at a time using the exclamation mark instead of
the whole thing. Is there something specific you're trying to achieve?
This message to me implies it is actually possible to change something about a
secret key. I haven't figured out what yet.

@_date: 2013-09-07 16:11:57
@_author: Peter Lebbing 
@_subject: Issues with primary key & subkeys on different smartcards 
(from the first mail)
Yes, that is how I ended up doing it back when I started using the same setup
years ago (two smartcards, certifying key on one, signing on another).
Only shortly ago, I got the impression from someone's mail to gnupg-users that
GnuPG these days did it as we both expected it would do: upon inserting the
second smartcard, replace the dummy S2K stubs with divert-to-card S2K's for the
second card.
Apparently it does not...
Once GnuPG has a secret key, I think it won't update it with new data. It didn't
use to AFAIK, and apparently still doesn't. Somebody else recently tried
exporting and importing a new subkey, and the import didn't work either. I just
thought of that thread and replied to it as well.
I commend your spirit. Werner Koch does paid feature development for GnuPG as
well, although I am in no position to judge whether your financial contribution
can pay for the whole feature. I'm also willing to contribute, but don't hold
your breath over the amount of money ;). I've offered payment for a feature
before, can't exactly remember what right now, but it was worth to me more than
this particular one.
Come to think of it, I've never seen any mention of people paying for features
and/or features made possible by paying users. Perhaps an interesting subthread
to spawn, if Werner is comfortable discussing it?
Anyway, back to the topic: maybe there are situations where you don't want to
update a secret key with new subkeys or new "key material" (let's consider a
divert-to-card S2K as key material, and a dummy S2K as absence of it). But an
option "--import-options update-secret-key" or something seems like a useful
thing, and gives people the choice without resorting to gpgsplitting.

@_date: 2013-09-09 11:27:58
@_author: Peter Lebbing 
@_subject: Recommended key size for life long key 
You've just proven that all RSA is unsafe! Repeated application (bald man
paradox[1]) of your indeed valid premise can only lead to that
conclusion! Quick, let's switch to a one-time pad!
(No, I'm not serious ;)
[1]

@_date: 2013-09-09 12:54:49
@_author: Peter Lebbing 
@_subject: SSL on gnupg.org 
SSL is precisely /not/ the technology to use to escape the NSA (more
specifically, the Certificate Authority structure of the validation, I'm not
talking about the SSL session itself).
If there is /an/ organization that can spoof the authenticity of an SSL
website, it'll be the NSA. I will eat my hat[1] if they don't have access to a
few certificate authorities.
If you want to verify authenticity of a downloaded GnuPG, verify it with
GnuPG. Yes, I know, there's a problem there :).
[1] Luckily, the washing label says "AZO free". I have no idea what that is,

@_date: 2013-09-09 21:17:16
@_author: Peter Lebbing 
@_subject: GPG and Outlook revisited 
Remember that this would make it open source[1], but not free software. It can
come with some provision that you do not offer binaries built from that source
or modify the code. So then how do you know that the binaries he provides are
built from the source that you bought? The only way I think is to use the exact
same build setup he uses and then compare assembly (not full binaries, those
differ each build).
Anyway, his reasons not to make it free software remain rather shrouded in
mystery. I'm with Werner on being suspicious of mystery surrounding crypto
His comparison to Windows is moot, because Windows is not freeware by a long shot.
[1] As I see it being formulated, you might not even be allowed to share the
source you bought with others.
[2] My words, not his.

@_date: 2013-09-12 19:07:07
@_author: Peter Lebbing 
@_subject: Attacking an offline system (was: Why trust gpg4win?) 
The moment someone plugs in a mass storage device and we're talking about
attacking his computer, I think of a manipulated file system, exploiting an
error in the file system driver of the kernel (which runs at a nice privilege
level too). I missed that vector in the discussion so far, which focussed on
manipulated files.
The filesystem is also still there with this USB-via-serial-port thingy. And on
the CD.
You can avoid a filesystem by just storing a tar archive on the storage. I don't
think that's very helpful under Windows, but under Linux, using a block device
as tar input/output is easy. Hell, it's what tar was originally made for (tape
devices) :).
That only helps for the filesystem vector, though.
Anybody still using laplink cables? ;)
(I once blew up part of a mainboard with a laplink cable. Was on a different
phase of the mains electricity than the other PC and not grounded. Gave a nice

@_date: 2013-09-13 11:08:16
@_author: Peter Lebbing 
@_subject: Attacking an offline system 
I hadn't looked at the Vinculum module[1]; that would indeed be a way to remove
the filesystem from the equation, although you will end up writing something
similar to a filesystem driver for the PC which might itself be exploitable.
You can reduce the complexity of the software, but you can't eliminate some form
of driver. And I certainly wouldn't trust the module to give me only expected
data :). You've only moved the complexity of the USB stack to the module, it
needs to be regarded exploitable.
You mean threat model? I completely agree. All my contributions are just musings
about things I notice while reading other people's contributions. I'm not
contemplating actually doing any of this. If you seriously consider doing this,
you need to formulate a good threat model.
I use a USB stick to transfer stuff.
[1] I was just thinking in general terms of bridging USB mass storage to a
serial port through some driver.

@_date: 2013-09-13 11:11:51
@_author: Peter Lebbing 
@_subject: Why trust gpg4win? 
Since people were concerned about hacking the USB key, you need to define the
First of all, if we are talking about hacking through a rogue firmware update
for the USB key: is the write protect switch directly connected to the "Write
enable" line of the flash chip or is it done in the firmware? In the latter
case, it's useless. In the former case: the flash chip is reasonably
intelligent, and "closed source". There could be an exploit to write to it even
when the "Write enable" line is not asserted.
If we're talking about hacking the USB key by getting your hands on it and
physically altering it, I don't even need to explain. Although if you keep the
stick next to your offline PC, the attacker will probably not bother with the
stick ;).
So it really depends on your threat model if that switch is useful.
I think in my case, the only difference is the added possibility of attacking
the package manager. I put a debian mirror on an external hard disk, connect
that to my offline PC and then update the system.
I think it would be difficult to remove the package manager from the equation,
unless you switch distro's :).

@_date: 2013-09-13 15:49:28
@_author: Peter Lebbing 
@_subject: lsign produces exportable signatures when used for self-sigs 
The latter has the same problem as the no-modify flag: it can be subverted by someone as long as the keyservers do not do crypto.
PS: I accidentally replied to Nicholas only. Using a different client than usually.

@_date: 2013-09-15 12:34:23
@_author: Peter Lebbing 
@_subject: How to find and verify a trust path? 
Hello Philip,
There is no such thing as a trust path. There are signature paths, but trust is
not transitive in the normal Web Of Trust. Only with trust signatures, which
according to the man page "is generally only useful in distinct communities or
groups". I've replied to a similar request last April: [1].
Be careful to separate the issues of trust and validity.
[1]

@_date: 2013-09-16 10:00:19
@_author: Peter Lebbing 
@_subject: Preferred block cipher 
Hello Mike,
First of all, /please/ fix your mail client. You are breaking the threads and
inserting non-sensical Subject:-lines where you apparently reply to the digest
instead of a mail inside the digest. Similary, lines like
are confusing.
When you reply to a message, it will normally refer to the mail you are replying
to in its headers, such that mail clients can show the conversation in a
threaded view. Your client currently does not refer to the mail you are replying
to, meaning that a new thread starts where you are replying. It is then quite
annoying to search for the corresponding thread to see what you're replying to.
I'm not completely sure what Robert is referring to either, but the settings you
published in the prefences on your public key are combined with the
personal-cipher-preferences from the gpg.conf from the person sending you a
message, along with the preferences of any other recipients.
Note that setting a default-preference-list in gpg.conf will only affect any
'setpref's you do afterwards, just adding it to gpg.conf is not enough to
actually set the preferences on your existing key.

@_date: 2013-09-16 12:07:32
@_author: Peter Lebbing 
@_subject: How to find and verify a trust path? 
There are two ways to answer this. One:
Did you read my post from April I linked to? I know it sounds like
self-promotion, but it's just to avoid repeating myself too much.I think you
misunderstand what makes a key valid. In order for it to be valid, it needs to
be signed by one or more valid keys that you have assigned some ownertrust.
Signatures themselves can chain, but ownertrust does not. You cannot make a key
valid by downloading other keys. It can only become valid by being directly
signed by people (keys) you trust.
The second answer:
As far as I can see, there are two solutions:
1) Meet with the owner of the key, satisfy yourself that he or she is indeed the
owner, and sign the key.
2) In the list of signatures on the key, look for someone you know and at least
marginally trust to do proper verification of key ownership. You then assign
this key a certain amount of ownertrust, plus you need to make this key itself
valid. To make it valid, follow this process again: either meet up with this
person, or look for a signature on their key by someone you know.
There is a maximum depth to the second form of the solution. It can span no more
than 5 hops from your own key by default (max-cert-depth).
I'm afraid there are no automated solutions[1] because ownertrust is something
you decide, and the computer doesn't know who you know. The only "automated
solution" is that you have the key for everyone you know and somewhat trust on
your keyring: that way, GnuPG will immediately do the right thing, and compute
validity for the downloaded key if it can be done.
[1] Again, I don't take trust signatures into account because they are no part
of the normal Web of Trust.

@_date: 2013-09-16 20:11:52
@_author: Peter Lebbing 
@_subject: How to find and verify a trust path? 
If you actually don't know these people, I'd say it would be unwise to assign
them trust. Why trust a stranger? However, it is not out of the question to
trust a person you haven't met, which is different from being aware who someone is.
Well, I'm not going by what some people are willing to do, but the idea is that
you only assign trust for people you trust. Since you probably trust some people
whose keys you haven't signed, it makes sense to ask the trust question for keys
you haven't signed. Through signatures from trusted people, you can ascertain
that a key belongs to a person, you don't need to sign it yourself for that.
However, for that person to make other keys valid, you need to trust their
judgement. The trust question is exactly that: do you trust that this person
only signs keys he or she has properly verified?
I'm pretty sure they can't be directly queried for this information.
Most of them probably did nothing, since it's useless other than for statistical
fun. There is nothing to be gained from knowing one or more paths.
Any "attacker" doesn't need to do much effort to create so many paths to that
key it dwarves any other key by comparison. Is the validity of that key then
somehow increased, because it has so many paths?

@_date: 2013-09-16 20:23:43
@_author: Peter Lebbing 
@_subject: Sign key and export for each UID 
sign is for signatures that can be exported to other people and to keyservers.
lsign is for local signatures, for which you need to be very explicit to export
it. That way, the fact that you signed the key is known to you only, plus it
prevents you from accidentally uploading it without the owner's consent.
Most likely, it's caff or a derivative. caff, CA Fire and Forget, on Debian is
in the package signing-party. I don't know about other distributions, and I
certainly don't know about other OSes :). I think I saw two GUI derivatives
coming by recently here on GnuPG-Users, but I can't find them now.

@_date: 2013-09-16 23:00:22
@_author: Peter Lebbing 
@_subject: How to find and verify a trust path? 
Dijkstra's shortest path algorithm would amount to a breadth first search.
Keyserver operators might not like that, I dunno.
Errrrr..... by creating n keys and uploading them to the keyserver?

@_date: 2013-09-17 11:07:04
@_author: Peter Lebbing 
@_subject: How to find and verify a trust path? 
AFAIK, there is no such requirement in the Web of Trust. I've never heard of it.

@_date: 2013-09-17 11:25:56
@_author: Peter Lebbing 
@_subject: Sign key and export for each UID 
I've "found" the GUI tool that I mentioned:
My biggest feature request for caff is Debian Bug 680136[1]: Additionally
create a local signature on the user's keyring, so that you can strengthen
your own Web of Trust regardless of whether the other chooses to upload your
signature to the keyservers or not.
I thought I saw a tool that did this a short while back... but I can't find it
[1]

@_date: 2013-09-17 11:38:55
@_author: Peter Lebbing 
@_subject: How to find and verify a trust path? 
Euh... apart from the part where you said they need to start with Philip's key.
I didn't trim the quote far enough :). I meant there is no requirement that the
paths are independent.

@_date: 2013-09-17 20:02:06
@_author: Peter Lebbing 
@_subject: Sign key and export for each UID 
Thank you, bookmarking it now. That was the one I couldn't remember.

@_date: 2013-09-18 22:23:10
@_author: Peter Lebbing 
@_subject: How to find and verify a trust path? 
I don't see how this is different than not verifying at all and "assuming
gnupg.org isn't part of a conspiracy against me".
What is your thread model?

@_date: 2013-09-18 22:26:52
@_author: Peter Lebbing 
@_subject: How to find and verify a trust path? 
Alternatively, if you use a Linux distro: simply install it with the package
manager. You already implicitly trust that anyway. If somebody got inside the
package manager, they don't need to bother to attack GnuPG specifically.
I suppose technically you're also trusting the maintainer for the package. No
worse than trusting any other maintainer, I think. They all have access to the
binaries you run.

@_date: 2013-09-23 20:23:03
@_author: Peter Lebbing 
@_subject: OpenPGP card, gpgsm, decrypt 
I think I see what's going wrong here. On my card, OPENPGP.3 refers to the
authentication key. If you are trying to use this to decrypt stuff, the card
will outright refuse. Only the encryption key of the card will decrypt stuff,
and that one should refuse to sign. The other two will only sign stuff.

@_date: 2013-09-24 11:41:40
@_author: Peter Lebbing 
@_subject: Best Practice, subkeys and subkey cross-certification. 
Let me quote what Hauke wrote one and a half month ago, because I fully agree
:). Oh, and it's relevant.
I haven't looked at the latter two links you gave, but I recognised this link
from your list.

@_date: 2013-09-28 11:27:07
@_author: Peter Lebbing 
@_subject: GPG Private Key Export Question 
RFC 4880 really is the place to look for this stuff. All your questions can be
answered by carefully reading the relevant sections of that RFC. Key packets are
described in section 5.5. You showed a --list-packets for an RSA key, so section
5.5.2 tells us a public key packet, or equivalently the start of a secret key
packet, contains, in order: a version number, a creation time, the algorithm,
and a series of multiprecision integers describing the key material. For RSA,
these are the modulus n and the exponent e. It is easily seen that these
probably correspond to skey[0] and skey[1] respectively (or pkey), because the
first one is 2048 bits, which is a reasonable size for the modulus, and the
second one is 17 bits, and I believe that GnuPG always uses the public exponent
Section 5.5.3 goes on to explain what follows in a secret key packet. If you
would remove the password from the exported key, you could see that contents as
well; right now it's in the encrypted part. Let's take a look at a 2048-bit RSA
key secret packet without encryption:
:secret key packet:
        version 4, algo 1, created 1374835387, expires 0
        skey[0]: [2048 bits]
        skey[1]: [17 bits]
        skey[2]: [2043 bits]
        skey[3]: [1024 bits]
        skey[4]: [1024 bits]
        skey[5]: [1023 bits]
        checksum: 4527
        keyid: A1DAD4EC3E7F0306
Section 5.5.3 starts off talking about the encryption with an S2K
(string-to-key, the method to create cryptokeys from a passphrase). Then follows
algorithm-specific stuff, then a checksum. Since we didn't do encryption, the
output above just indicates the algo-specific stuff and the checksum.
Algo-specific stuff for RSA is described as: multiprecision integer (MPI) of the
secret exponent d, prime p, prime q and u, the multiplicative inverse of p, mod
q. The secret exponent's size is on the order of the modulus, so that would be
skey[2]. The others are indeed on the order of half the size of the modulus, so
those sizes make sense as well. It would seem justified to think that, like it
did so far, GnuPG is reporting them in the order they appear in the packet,
making p skey[3], q skey[4] and u skey[5].
If you look at the Wikipedia article on RSA, they define q_inv = q^(-1) mod p. p
and q are exchangeable in the definition, so q_inv is equivalent to u. u is
expensive to compute, so it is included in the secret key material. The two
derived private exponents modulo p or q are cheap to compute. At least, that's
how I always interpreted the presence of u and absence of the other two.
I don't know what you mean by "key value". It might be because...
I get the sense you don't know how the basics of RSA work. If you're going to
look at RSA key material, you should know what makes an RSA key and how it
basically functions. There's no need to know the mathematical proof of the
correctness of its functioning, but you do need to understand a bit of the math.
I think the Wikipedia article on RSA is pretty readable, but I think they don't
state clearly enough for the uninitiated that by choosing d and e as they are
defined, you get (thanks to Euler's theorem) the property that:
m^e^d (mod n) = m^(e*d) (mod n) = m (mod n)
m^d^e (mod n) = m (mod n)
Since you can do the (mod n) at any time you darn well like:
c = m^e (mod n)     -- creates ciphertext
m = c^d (mod n) = m^e^d (mod n) = m (mod n) -- message recoverable
s = h^d (mod n)   -- signature is based on hash
h = s^e (mod n) = s^e^d (mod n) = h (mod n) -- compare hashes
By comparing hashes, you've proven that the person making the signature knows d,
because only d would reverse the effects of raising it to the power of e.
Interestingly, the Euler's theorem Wikipedia article does mention the property:
Euler's theorem also forms the basis of the RSA encryption system: encryption
and decryption in this system together amount to exponentiating the original
text by k*phi(n) + 1 for some positive integer k, so Euler's theorem shows that
the decrypted result is the same as the original.
This can be seen from point 5 of "Key generation" of the RSA article:
Solve d for d*e = 1 (mod phi(n)) = k*phi(n) + 1
As indicated above: remove the passphrase from the key.
PS: I took the liberty to write = where it should be a congruence relation
modulo n. Keeps it ASCII.

@_date: 2013-09-30 10:21:20
@_author: Peter Lebbing 
@_subject: GPG Private Key Export Question 
Thanks! :) I appreciate the compliment!
(I was doubting whether to send this to the list, but I suppose civility isn't

@_date: 2014-04-05 13:08:15
@_author: Peter Lebbing 
@_subject: Chipdrive SPR 532 and OpenPGP Card with 4096Bit RSA Keys 
It works for me. I have an SPR 532 with firmware v5.10, and I'm running Debian
testing x86_64. I'm using GnuPG's internal CCID driver.
I couldn't generate a 4096-bit key on the card, but I could transfer one with
"keytocard". At that point, the key length mentioned in --card-status was
already set to 4096 bit by the failed generation attempt; that might have made a
It went along these lines:
I added the card public key to an authorized_keys file and could log in with
that key without any problems.
I have updated the firmware to v5.10 a long time ago. I think I used Windows XP
for that.
So it can work. I hope that bit of information helps in your quest for 4k
authentication :). Or you could create a shorter key. Auth keys can be changed
relatively easily, though not as easily as signature keys. More importantly,
they don't protect any secret data (just a random challenge), so I don't think
there's any reason to go beyond, say, 2048 bits.

@_date: 2014-04-06 21:50:06
@_author: Peter Lebbing 
@_subject: Using an RSA GnuPG key for RSA ? 
On Debian, there is the pgpdump package which, I just tested, outputs the
private key components in hex (or hex escaped string with -g).
Also, when I did apt-cache search pgpdump, I noticed there is a Python library:
[1]. That might be even better for your purpose.
[1]

@_date: 2014-04-14 22:36:53
@_author: Peter Lebbing 
@_subject: The bug... More info. 
In /this specific instance/, I believe these three can indeed be the product of,
well, mere hours.
I don't think it's unreasonable to suppose it might very well be :) the NSA is
reading through all patches that go into the OpenSSL stable tree; it's not that
much work for a big organisation and you might catch some low-hanging fruit.
This specific patch was extremely low-hanging! We take an unchecked 16-bit
length from a packet we receive from the internet, and use that to copy a block
of newly-allocated data to the return packet! Holy crap. The OpenSSL developer
that accepted this patch (that was submitted by an outsider) was not having a
good day, and I think he would never write this code. For a programmer that has
been working on a security project for quite a while, I believe it becomes just
a reflex while writing such code: you take a length argument from user-supplied
data, you do sanity checks on it.
Similarly, I think people at the NSA, trained at reading code for possible
exploits, might have actually squirted coffee when they read through this patch.
And it's really easily exploited, so yes, I think you can weaponize in a mere
I'm not going to assess these few points though, they are less obvious. However,
I think you don't need much distribution. You can just send the heartbeats
yourself, and read other people's data from the process's memory. Sifting
through that memory for interesting stuff is more complicated, but doesn't need
to be done on the spot.
That indeed is pure sensationalism.
The news report might have been completely made up. However, I think it might
still be true, given how big a target OpenSSL is, and how easy to spot the bug
was. Too bad none of the good guys actually spotted it. Such is life,
unfortunately. People make mistakes. Sometimes pretty big, dumb mistakes. Even
the smartest people.

@_date: 2014-04-15 22:06:57
@_author: Peter Lebbing 
@_subject: Chipdrive SPR 532 and OpenPGP Card with 4096Bit RSA Keys 
AFAIK, only the internal CCID driver supports entry on the pinpad, and it is by
default enabled when using the internal CCID driver. However, if you have pcscd
running, I suppose GnuPG will use that. Then the pinpad is not supported.
So: do you have a pcscd running? If you don't need it, stop it, and scdaemon
will use it's interal driver.

@_date: 2014-04-16 18:21:16
@_author: Peter Lebbing 
@_subject: signatures for other people's emails 
The usual way it works here would be, in your example, for the dean to send the recipients a message with "Please consider the request in the attached message", and your message would be attached. That way, it is the dean who requests something, and the PhD would be inclined to read

@_date: 2014-04-19 15:15:24
@_author: Peter Lebbing 
@_subject: gpg Feature request: merge gpg.exe and gpgsm.exe into one tool 
Don't most applications that support/use GnuPG use OpenPGP signatures? If you
would want to have signatures made by X.509 certs, the application needs to
understand CMS (S/MIME is one form of CMS) unless it is agnostic about it. Being
agnostic about it might be implementable in many scenarios, obtaining the signed
text from GPGME. I just read[1] that a GPGME backend for CMS is already
developed, so if an application uses GPGME (or some as yet unreleased version of
GPGME) in the appropriate way, it might already benefit from both OpenPGP and
But it boils down to: I don't think you can just change stuff on the GnuPG end
and expect the programs that use GnuPG to be able to handle the different format
Maybe a different feature request would be: use the X.509 certificates and trust
model in an OpenPGP context. That way, programs using GnuPG only ever see
OpenPGP messages. But that feature request (or one very similar) has recently
been done, and I can't remember seeing any acknowledgement of that. I myself
commented that I'd rather see CMS use a better trust model than porting the
X.509 trust model to OpenPGP: it's the wrong away around in my opinion.
[1]

@_date: 2014-04-19 18:27:01
@_author: Peter Lebbing 
@_subject: I never going to understand all this... 
This is for V3 keys, an old key format which has been superseded by V4 keys for
a long time.

@_date: 2014-04-20 11:05:54
@_author: Peter Lebbing 
@_subject: gpg Feature request: merge gpg.exe and gpgsm.exe into one tool 
I see the real problem in a different area.
gpg.exe with OpenPGP keys generates OpenPGP messages. gpgsm.exe with X.509
certificates generates CMS messages. Applications calling gpg.exe expect an
OpenPGP message. If you replace this OpenPGP message by a CMS message, perhaps
the application will still work. Or it will break in certain places or break
after the author of the application changes it in a way that needs OpenPGP
messages, because the author is under the /correct/ impression that gpg.exe
gives him an OpenPGP message, or parses an OpenPGP message passed to it.
Most applications should be using GPGME anyway instead of calling gpg.exe
directly, and X.509 support for GPGME is something that is being worked on, so
an application that doesn't mind whether it handles OpenPGP messages or CMS
messages can just use the appropriate functions of GPGME.
Unfortunately, no. A lot of applications would break. Suppose you are expecting
a certain subsystem to generate German messages, and you put those messages on
your website. If the subsystem would suddenly switch to Chinese, do you think
your clients from Switzerland would be happy that they now had support for both
languages, or do you think they would contact support and ask what the  that
stuff on your site is supposed to mean? ;)
It's up to the applications. If they call gpg.exe directly, they are
expecting OpenPGP functionality. You can just break that assumption and hope the
application still works, but it seems to me you're breaking the expectations the
programmer had when he wrote the code calling gpg.exe directly.
On the other hand, if the application uses GPGME, then CMS support (and thus the
X.509 trust model) seems to be already in the works, and when applications
choose they also want to support that, it might be as easy to support both
OpenPGP and CMS as it is to support just one. I don't know if CMS support in
GPGME is already usable, but it seems much more viable to do a feature
request[1] in that area than to request that the two binaries gpg.exe and
gpgsm.exe, which handle completely different messages, be merged into one. I
don't think that is going to happen, because it would break a lot of applications.
[1] Possibly involving funding

@_date: 2014-04-22 21:57:48
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
Perhaps the novice interface should just stick to "validity" and do away with
the whole concept of ownertrust to keep things simple. Suggest that people meet
up with someone and sign their key personally if they want validity.
Also, I think the word "trust" by itself should probably be avoided everywhere.
The word "ownertrust" is uncommon enough that people might be more inclined to
look up what it means, instead of thinking they already know what "trust" means.
My 2 cents,

@_date: 2014-04-22 23:40:40
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
Oh wow. I understand you can make any topic as difficult as you want if you put
some effort into it, but are there seriously people who have different keys for
different levels of identity verification? And do they admit they do this
because they are sadistic, or is there some way they try to explain this away?

@_date: 2014-04-23 00:11:22
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
I might have snipped my quote too much. Hauke was arguing that the term
"ownertrust" is not correct because it is not about trust in the owner, but
trust in specific keys.
In your example, you do not trust the two keys differently[1]. However, due to a
technicality, you can't assign both the same ownertrust, because they would add
up. I don't think this is a fundamental thing that changes the concept of
ownertrust, it is an unfortunate technicality. If GnuPG were somehow enhanced
that you could mark them as "this is the same person", you would assign both
"marginal" and benefit from certifications of either key. If it's that easily
fixed, it's not a fundamental issue in my book.
[1] Although you might mistrust a key that's no longer considered secure by
current cracking standards. Again, not an issue with trust in the owner, but a
I use the GNU Privacy Guard (GnuPG) in combination with Enigmail.
You can send me encrypted mail if you want some privacy.
My key is available at

@_date: 2014-04-23 11:23:01
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
Yes, after dkg's last message yesterday I also realised I had overlooked that
scenario. I think it can be generalised as "different roles", as even the
verification effort / signing policy can be different. Your boss might expect
you to sign certain keys with your work key while you are much more stringent
with your personal key.
But I don't see why we need to drop the term ownertrust for that. Sometimes you
need to pick a descriptive identifier for something and then define what it
exactly means; it happens all the time in science.

@_date: 2014-04-23 11:51:02
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
We agree on the first point, crypto is by its nature difficult. Which is
On the latter point: I think the user interfaces can be made better, but I
disagree with your description of that. We do agree to disagree, don't we?
That's how you want to improve the user interface for, I quote, the
"non-expert(!) user"? In that case we disagree about the right way to do this on
such a fundamental level that I don't think we're going to come to common ground.
Also, I think this discussion would benefit from a narrower scope. Let's focus
on terminology and user interface elements with the current mechanics, and leave
things like "the lack of transparency of the security level" to other threads.

@_date: 2014-04-23 11:56:17
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
Only a few days ago, a list of literature on the subject was posted to this
mailing list.
I propose we keep the scope of this discussion narrower, and not touch the
subject of adoption of crypto. I fear the discussion will quickly go nowhere
Let's stick to improving user interfaces for novice users so they use them
reasonably correctly.

@_date: 2014-04-23 12:36:41
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
Yes, I think the experience for novice users would be improved if you guide them
towards signing keys directly. Ownertrust, the WoT, being hidden for novice
users might take away enough complexity that you can explain to the novice that
the way to secure communications with someone is meeting up with them, verifying
the fingerprint and making a signature.
I think the word "validity" is still fine for that. I don't think it's difficult
to convey that a key won't be valid until you validated it yourself with the
owner by checking the fingerprint. A key that is expired or revoked might be
called "unusable" if it needs a stronger term than simply "invalid".
This need not be imposed as the default mode: you could ask on first use which
"mode" the user desires, giving a short explanation about the strengths and
weaknesses of different modes, and possibly referring to documentation on-line.
There could be a version of the documentation that completely ignores the WoT
and simply focusses on direct signatures.

@_date: 2014-04-24 11:13:22
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
I think "authenticity" covers the overtones much better than "validity", now
that you mention it. It even makes me wonder why it wasn't chosen in the first
place :). You have convinced me that it is the better term to use.
I'm not enthousiastic about "ownership", because it feels like a synonym to
"User ID" in OpenPGP context.

@_date: 2014-04-25 11:15:40
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
I don't think a UI should use both "authentic*" (~ated, ~ity, etc) and "valid*",
because this might not be confusing to newcomers, it would definitely be for
people who already know what "valid" means in OpenPGP context. I think it's
preferable to replace "valid" by "authentic" because it conveys the meaning
better, but you definitely shouldn't then call /something else/ "validity".

@_date: 2014-04-25 11:20:08
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
What do you mean? Validity (and it's proposed new form, authenticity) refers to
the coupling of a key and a User ID. It doesn't refer to either thing by itself.
Does it?

@_date: 2014-04-27 11:41:27
@_author: Peter Lebbing 
@_subject: A few newbie Qs 
Is this really a useful criterium? Sure, by not using the clipboard you might
stop some non-specific malware that simply does data trawling by sending all
likely clipboard contents to a server so a hacker can see if it sees any
passphrases in there. But since the malware is already in the position to
execute arbitrary code with your credentials, you should simply consider your
GnuPG installation compromised whether you use the clipboard or not. It can
simply catch all calls to gpg2 or gpg-agent and prompt you for your passphrase.
If you're talking about a malicious site being open in the browser, I'd very
much like to hear about known, unfixed vulnerabilities that allow
server-supplied code to get at your clipboard. That would be quite a
vulnerability in my eyes.
I use Keepass2 under Debian GNU/Linux to keep all the passphrases I use on this
machine (but my OpenPGP keys are on a smartcard, they're not protected by a
password but by a PIN). Since I'm not aware that there exists a plugin for Linux
integrating Keepass2 and Firefox, I copy-paste all my web passwords, including
high-profile stuff like PayPal. Also, there are some things that will never have
integrated Keepass2 support, like command line tools, which require me to
copy-paste. If I need to check which /other/ websites I have open at the same
time (or rather: close all open websites) whenever I use Keepass2, I'd very much
like to know.

@_date: 2014-04-27 13:35:29
@_author: Peter Lebbing 
@_subject: C&P'ing passphrases (was Re: A few newbie Qs) 
"Woof" back at you.
But I will just enter the same passphrase again tomorrow. Even if I notice I've
been compromised, it is unlikely that I notice this on the day of the
compromise. Even if I knew when the compromise happened, I wouldn't rely on my
memory to remember which passphrases I entered since. So, in conclusion, when I
notice my machine is compromised, I need to consider everything I access through
a passphrase using that machine as compromised, replace all those passphrases
and contemplate what the attacker could have done with the compromised services.
I don't think the risks I ran and the actions I need to take when my machine is
compromised are any different whether I use C&P or enter them directly, for the
common case that I regularly use the passphrase.
Well, you can't integrate your password manager with everything you need
passphrases for. And I highly prefer the more than hundred randomly-generated
passphrases[1] in my KeePass over trying to think of more than a hundred good
passphrases and remember them. I consider that waaaayyyy beyond my capabilities.
That word needs even more vowels, but it would make it hard to read ;).
Still, if there is a real risk that websites see my clipboard, I definitely want
to know.
[1] By the way, the best part of those passphrases aren't protected on my
system; they are in my browser's unencrypted credentials database and the
password for the KeePass database is a single lowercase "a" because you have to
enter something. They are just accounts on websites. Passphrases I do consider
important are in another well-protected KeePass database (and are copy-pasted).
I recently moved Amazon to the protected database because I noticed you can
order and pay stuff without re-entering your credit card number. It will be
shipped to one of your pre-existing addresses, but I still did not appreciate
it, so I changed the passphrase and moved it to my protected database.

@_date: 2014-04-27 13:51:42
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
Would those be smart users of a phone, or users of a smart phone? Where does the
intelligence reside? ;)
I'm reminded of a nice quote I saw in an e-mail signature.
"I have always wished for my computer to be as easy to use as my telephone; my
wish has come true because I can no longer figure out how to use my telephone"
 -- Bjarne Stroustrup
It's just b) without assigning trust to any key. I don't think there is a trust
model where you drop all assigned trust, but you can of course empty the trust
database (perhaps back it up, and restore it once the user selects a different
trust model).
Doesn't sound like a "let's make this less confusing for non-expert users"
thing. Also, making it configurable seems to imply to me that users would want
to switch back and forth. Otherwise, they would just use the verification effort
they feel comfortable with, and sign keys as "0x10 Generic certification" rather
than using "casual" and "positive" certifications. Without ever seeing those
descriptions, by the way, no need to burden them with those.

@_date: 2014-04-27 22:48:56
@_author: Peter Lebbing 
@_subject: Trustworthy Android implementation ? 
It's just a spam issue here at the mailing list currently. Every message I
write, I get at least one, but more commonly two mails from so-called bachelor
ladies, usually with a picture taken by a girl in the bathroom mirror. NSFW.

@_date: 2014-04-28 21:22:44
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
I was wondering the same thing, but I can think of two more ways:
- trust-model direct (and then set validity with "trust" command)
- trust: ultimate (note: don't do this!)
Still, I doubt Doug meant either of those, so I don't know.

@_date: 2014-04-29 10:51:35
@_author: Peter Lebbing 
@_subject: hash email addresses / directory privacy enhancement 
I have a key on the keyservers for the singular purpose of seeing how much spam
that address gets.
I only get 419 scams, for some reason. These are more manual processes than
usual spamming, so maybe they are also the only ones to do the extra work of
scanning the keyservers? Pure conjecture.
But it hardly ever happens. 22 attempted scams in 3 years, and they arrive in
batches. 7 batches to be precise; 7 distinct moments in time that scams arrived
on that address.

@_date: 2014-04-29 11:59:21
@_author: Peter Lebbing 
@_subject: hash email addresses / directory privacy enhancement 
It wasn't. It was an elaboration on one particular aspect of the answer MFPA gave.
The problem with keeping an e-mail address secret is you need to keep it secret
all of the time, while it only needs to leak to spammers once. Those are
overwhelming odds. If just one of your correspondents is infected by a virus
that harvests their addressbook or their mail folders, you've lost the battle.
Th?t is an answer.
Not a new one, though. It's been said multiple times and can be found in the
mailing list archives. The latest version of the sample-size-of-one statistics
of my experiment, on the other hand, were a new addition.

@_date: 2014-04-30 10:35:15
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
No, in the Web of Trust models[1], you can assign full and marginal trust to
keys. With the default parameters, 1 signature of a fully trusted, valid key
makes another key valid, or 3 signatures from marginally trusted keys.
In fact, I don't think there is any practical difference between "ultimate
trust" and "full trust" in trust-model direct. But I don't know anything about
trust-model direct except from experimentation.
[1] That is, pgp and classic. pgp is the default mode.

@_date: 2014-04-30 17:29:42
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
No, I don't think so. I suppose a trust signature places the key at depth 1 in
the certification chain, whereas the depth can vary with assigned trust, and the
chain is cut off at --max-cert-depth.
But this is just what I would expect happens with a trust signature.

@_date: 2014-08-05 23:05:11
@_author: Peter Lebbing 
@_subject: gpg: checking created signature failed: Bad signature 
It sounds like your hardware is failing. This will often show first on
computationally intensive, verified stuff like crypto.
Did you overclock your computer? You might need to lower some setting if
you did.
You could try memtest86+ for several hours. Note that failing tests do
not necessarily indicate a broken memory module; it can be something
else, like for instance the CPU, the motherboard or the power supply.
Another thing you could look for is blown capacitors on the motherboard,
especially close to the CPU. When you don't have solid capacitors, i.e.
ones containing liquid, they can short circuit, which will cause the
liquid to boil and the cap at the top to expand outwards, which can be
observed. They will form a slight dome, whereas normally it's flat or
even slightly inwards. This will only happen to the large ones. I'm sure
pictures can be found, although I'm not sure "blown capacitor" is the
correct English term... in Dutch we say "geplofte condensator", and I
never discussed the issue in any other language ;).

@_date: 2014-08-06 11:45:25
@_author: Peter Lebbing 
@_subject: gpg: checking created signature failed: Bad signature 
Hard disks store an error detection and correction code with the
data[1], and usually fail less subtly and regardless of the content of
the data. Whereas failure to motherboard, processor and power supply
tend to show themselves in very data-intensive scenarios such as
asymmetric cryptography. I think main memory less so, because the crypto
is likely completely contained in the cache.
[1] Although if the embedded processor for instance would start failing,
it's possible to damage data with consistent checksums. Note that SATA
communication between disk and computer also includes a checksum.

@_date: 2014-08-06 20:35:20
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
These three sound rather insecure, especially world-writable stuff?!
That's pretty extreme. That opens you up to bugs in a lot of services,
not to mention that I think most developers develop with the expectation
that world-readable stuff does not need to be protected from reading by
anybody / any service, so they're not very vigilant about that either.
My strong suggestion would be to change the process, giving each user
their own secret keyring. Can't you script a secret key import that
would import for both users?
Alternatively, and I'm not really in favour of this but it's your setup,
the man-pages for gpg and gpg2 mention:
But I would strongly suggest not making the three files mentioned
world-readable, let alone world-writable.
There is no need at all to share random_seed, so I would definitely give
each user their own copy of that for simplicity. It is written much more
often than secring.gpg.
I think trustdb.gpg is, or might also be, written on public key import.
If you fiddle with access permissions, you need to really think about
what you're doing. Your world-writable access makes me suspect you
haven't thought well about all the implications, so
--preserve-permissions might be a great way to shoot yourself in the
foot. I suppose you're using GnuPG for some kind of protection against
something nefarious, because I wouldn't know what else it is for (a
really over-the-top checksum? :). If you then kill off security in
another way, you only get a warm feeling, but so will your attacker,
when he uses a filesystem-traversal bug in some program running on the
same machine.

@_date: 2014-08-06 21:24:32
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
Can I ask what happened to --preserve-permissions? I checked the man
pages on a Debian stable system, which mentioned them.
I was a bit surprised to find the option since I agree with your current
Thanks for the pointer to that service!
Additionally, if the group is set to the wrong group, you might need to
make the gpghome directory set-gid. Forgot to mention that in my mail :).

@_date: 2014-08-07 11:39:14
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
That's a really bad solution for your problem. You want to keep secring
secret, and world-readable is the absolute opposite of that. And if
somebody manipulates trustdb, they can make you believe a key is valid
when it is in fact not.
I thought about it for a little, and I think your problem can be fixed
using just standard UNIX permissions. But I think the more elegant
solution might lie in a completely different process where secring is
not shared. That means that you should rethink your architecture, so
that you don't arrive at the scenario you paint with the shared files.
You should really consider that. There are many ways to satisfy your
requirements. One of the reasons I write this at all is to show that
actually, standard UNIX permissions can be rather flexible.
By the way, I inferred admin might add public keys as well. If this is
not the case, the thing only becomes simpler.
Here's my idea:
drwxr-xr-x admin nobody          gpgshared/
drwxrwxr-x admin gpgpubwrite     pub/
drwxr-x--- admin gpgsecread      sec/
-rw-rw-r-- admin gpgpubwrite     pubring.gpg
-rw-r----- admin gpgsecread      secring.gpg
-rw------- admin nobody          gpg.conf
-rw------- admin nobody          random_seed
-rw------- admin nobody          trustdb.gpg
secret-keyring /var/local/gpgshared/sec/secring.gpg
keyring /var/local/gpgshared/pub/pubring.gpg
-rw------- test1 nobody          gpg.conf
-rw------- test1 nobody          random_seed
-rw------- test1 nobody          trustdb.gpg
secret-keyring /var/local/gpgshared/sec/secring.gpg
keyring /var/local/gpgshared/pub/pubring.gpg
... and so on for user test2 ...
This is an example of the way the standard UNIX permissions can be used
to give pretty reasonable granularity of access. The only hitch is that
if world-readable access to pubring.gpg is not desired, I wouldn't know
how to do that (without sudo). But for pubring.gpg, it's usually not a
I haven't tested it, by the way.

@_date: 2014-08-07 11:46:41
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
He means that to get this functionality from GnuPG, you could edit the
source and recompile. I don't think you should read it as a suggestion,
though. So, that's could, not should.

@_date: 2014-08-07 11:55:28
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
Which is obvious, because Werners mail reminded me that in this setup
you still need this:
secret-keyring /var/local/gpgshared/sec/secring.gpg
keyring /var/local/gpgshared/pub/pubring.gpg
Though *not* for test1 and test2, they can stay as they were, since they
don't write secring.
However, I still think you should look for a solution without a shared

@_date: 2014-08-07 14:02:33
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
Can you point out where the solution I proposed would go wrong? Is it
the ownership of secring.gpg when test1 adds something? Perhaps it goes
wrong when the owner bounces between admin and test1. You might want to
amend /etc/group:
That way, they can both still read and write the file even when the
owner changes to test1. Before, I think admin got locked out then.
Oopsie :).
Is the problem that you are porting an existing system from Windows to
Linux? Is that why you are so constrained in the possible solutions?

@_date: 2014-08-07 14:11:42
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
Hah, I mixed things. Obviously I meant pubring, not secring, and it
should be:
Because otherwise admin might be locked out when test1 updates pubring;
although I'm not sure, it depends on the exact way GnuPG will write the
file. Creating a new file and moving the old one out of the way is
already allowed through the permissions on the directory.
I'm really posting a *lot* of amendments to my mails currently, I'm
sorry about that. I'm trying to be too fast about it, I suppose.

@_date: 2014-08-07 14:58:08
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
It was also an apology to list subscribers flooded by messages by me :).
If you can't administrate the machine (i.e., add groups, add users to
groups), then it's going to be /really/ difficult. I'm mentally throwing
my hands up in the air and muttering something about "not really a group
then, is it" :). I find it a fun exercise to think of a permission
system that will allow a reasonable granularity of access permissions,
but not being allowed to add groups seems like an unreasonable
requirement. I'm out of ideas.
You need the CAP_CHOWN capability, which normally only root has. I'm not
acquainted with changing capabilities; I have never done it.

@_date: 2014-08-07 20:54:37
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
Glad you could work it out. I still think the best solution lies
somewhere else, not sharing secring and having only one account update
pubring (or not sharing pubring).
But I have an important, but simple modification to your scheme.
Don't share anything else but pubring.gpg and secring.gpg. It's really
unnecessary and should be avoided. Include lines like
keyring /path/to/shared/pubring.gpg
secret-keyring /path/to/shared/secring.gpg
in each user's gpg.conf and don't share the other files.
I couldn't properly grasp your plan, so I have no comment on that. As
long as world-readable/writable secret files are out the window, it
seems a major improvement ;).
Oh! I just thought of something! If you include the following:
keyring /writable/by/admin/pubring.gpg
keyring /writable/by/test1/pubring.gpg
primary-keyring /writable/by/admin/pubring.gpg
keyring /writable/by/admin/pubring.gpg
keyring /writable/by/test1/pubring.gpg
primary-keyring /writable/by/test1/pubring.gpg
keyring /writable/by/admin/pubring.gpg
keyring /writable/by/test1/pubring.gpg
Then both admin and test1 can have their own writable pubrings which are
only readable by other users, and the users see the total of all keys in
either pubring.
This still leaves secring which is much simpler, since only admin needs
write access. Also, I don't think secrings stack like pubrings do, so
you couldn't do this.

@_date: 2014-08-08 11:06:11
@_author: Peter Lebbing 
@_subject: How to preserve the permission/owner/group owner on the 
You are completely right. I just tested on Debian stable with gpg 1.4.12
and 2.0.19 and it Just Works(tm). I can have multiple secret keyrings.
Maybe it was some old version, or maybe I'm just thinking of something else.

@_date: 2014-08-12 11:53:30
@_author: Peter Lebbing 
@_subject: can any one send me.... 
Hello David,
I'm pretty sure you don't need anything in those files to have it
working. The options I have in there are not related to it working. Can
you do a step-by-step analysis of what you're trying to do and what is
the exact content of the error messages? Also, if you have anything in
those .conf files, please post their contents as well.
PS: Anyway, here are the contents of my .conf's on this machine:
default-cache-ttl 0
max-cache-ttl 0
default-cache-ttl-ssh 86400
max-cache-ttl-ssh 86400
keyserver hkp://keys.gnupg.net
list-options show-uid-validity
verify-options show-uid-validity
The ttl's for OpenPGP keys aren't very useful anyway as I use a smartcard.

@_date: 2014-08-12 21:04:56
@_author: Peter Lebbing 
@_subject: Different signing & encryption keys 
The default is an RSA-2048 primary key with certify[1] and sign abilities, and
an RSA-2048 subkey with encryption capability. I think you're mistaken.
It's even recommended /not/ to use the /same/ key material for signing and
encryption. In other words, yes, it is definitely beneficial to use a separate
subkey for encryption.
Whether you want to split certification and data signatures is up to you. I
think the only benefit for splitting is that you can keep your
certification-capable key on an offline system and still issue signatures from
your online system[2]. Even if that's the only benefit, it's still quite a
benefit depending on your needs and wishes.
[1] /Every/ primary key has certify by necessity
[2] I can think of theoretical attacks under special circumstances and with bad
practices. I wouldn't worry about them.

@_date: 2014-08-12 21:49:20
@_author: Peter Lebbing 
@_subject: FAQ change, final draft 
A comparatively slight increase in ECC key length is equivalent to a large
increase in RSA key length, particularly since RSA key length scales only
logarithmically in key strength. So yes, a switch to ECC would be equivalent to
much larger RSA keys. I'm not sure, but didn't discrete-logarithm keys scale
roughly equivalently to RSA? I think so, but I'm not sure...
PS: For RSA, it's not that difficult to see the truth in the logarithmic
scaling. Primes get exponentially more sparse the larger the prime is, so the
keyspace scales logarithmically; the possible key components are spaced
exponentially wide from eachother.

@_date: 2014-08-13 12:01:45
@_author: Peter Lebbing 
@_subject: Different signing & encryption keys 
You say you generated it with the --batch command, and go on to say you
weren't prompted. Since --batch, unattended key generation, is for
non-interactive use, you will not be prompted because you are expected
not to interact.
If I look at the docs for unattended key generation, it seems that
indeed not specifying a Key-Usage: implies all usages are enabled.
Unattended key generation is not normally a user-facing interface. Many
people will probably not even know it's there. I don't think it helps to
call it what GnuPG works like by default.

@_date: 2014-08-13 12:23:24
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
I'm pretty sure that, yes, you can.
For decryption: No. UID's are always bound to the primary key. If
someone encrypts data to you, they are free to choose whatever
non-expired encryption-capable subkey or master key they want. In
practice, you'll usually see that it will be encrypted to the last
created non-expired key.
You choose which key you use to sign with; your peers will accept
signatures from any non-expired signing-capable key.
There is no proper way to say to your peers "encrypt to this subkey if
you want me to read it on the move and encrypt to that subkey if you
want I can only read it on my super-secure computer".
You can simply generate a new one. Certifications are done on the pair
of an UID and your master key. Subkeys don't play a role in certifications.
Precisely. Although you are actually a bit too specific. A certification
means what the signing party wants it to mean. Some people will not
verify the e-mail address. Some will decline to sign a key with a
comment they can't properly verify or otherwise object to. Some will
have their signature mean "I've seen multiple e-mails from this person
signed with this key", others will want to hire a private investigator
and interrogate your parents (obviously only after a DNA test).
There is no single best way. Both all UIDs on one key and separate keys
per UID are done. Both have their pros and cons.
No, I wouldn't think so. But obviously someone might say "I'm sorry,
that's too much effort for me" :).
It did come through twice; the time it takes for your message to be
circulated to all the members can vary quite a bit.

@_date: 2014-08-13 13:42:26
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
The RFC says very little on a lot of important things.
What is the use of not being able to double back on a UID revocation?
For key revocations, it's obvious: compromise means an attacker is able
to re-enable your key. I don't think there is an analogous "UID compromise".
So why would an OpenPGP implementation choose to treat a UID revocation
as final? Are there any that do?
By the way, small correction:
I take it you refer to the precise form of the data that is signed. In
fact, what is signed does have a header, it's not just the bytes from
the UID string. The header is somewhat unusual. It is an old-style
packet header for packet tag 13 (User ID packet) with a length-of-length
0. It is followed by a 4-octect scalar length and then the UID string.
The unusual thing is that length-of-length 0 means a 2-octet length, but
in actuality it is a 4-octet length.

@_date: 2014-08-13 14:22:29
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
$ gpg2 --homedir gpgtest -k DCDFDFA4
pub   1024R/DCDFDFA4 2012-03-17 [expires: 2014-08-15]
uid       [  full  ] Test Teststra uid       [  full  ] Test Teststra (Koning van Wezel) sub   1024R/77A3395A 2012-03-17
Revoking the work UID...
~$ gpg2 --homedir gpgtest --list-options show-unusable-uids -k DCDFDFA4
pub   1024R/DCDFDFA4 2012-03-17 [expires: 2014-08-15]
uid       [  full  ] Test Teststra (Koning van Wezel) uid       [ revoked] Test Teststra sub   1024R/77A3395A 2012-03-17
Had to add a list-options flag to show it.
Re-adding the UID...
And look, it's back in action.
It is precisely as you said, GnuPG does allow reinstigating a revoked
UID. However, there is a slight hitch in the UI that means you can't do
it completely straight-forwardly. You need to delete the offending UID
before re-adding it, but other than that, it works, and the
certifications are even carried over.
Ah, right, thanks for the correction!

@_date: 2014-08-13 14:29:49
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
Pretty much everything. You can edit what you give others to your
heart's content, but old data will still linger in a lot of places and
can recombine with your new data. Keyservers in particular never throw
any data out (I think), but only add new data to the existing data.
Similarly, unless explicitly instructed, GnuPG will keep old signatures
and uid's and stuff around.
They usually can, especially if the key is on the keyserver network.
The most information is given by a command like:
$ gpg2 --export KEYID | gpg2 --list-packets
There might be switches to be even more verbose, but this already shows
all old signatures and stuff.
You might want to import your own key from the keyserver to see anything
you have deleted locally.
But in general, assume that anything you send out will be uploaded by
someone to the keyserver, and stay there indefinitely.

@_date: 2014-08-13 14:45:20
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
Alternatively, delete only the revocation signature and the
self-signature using "delsig" and resign using "sign". That way, you
keep certifications in your local copy. The "delsig" interface can be a
pain with many signatures, so more straightforward is to do an --export
before you delete and re-add the UID, and an --import afterwards.

@_date: 2014-08-13 15:29:38
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
Ah, right. It depends a bit. Especially self-signatures, which include
key preferences, do normally accumulate. But if you use export-minimal
or the "minimize" command, I don't think anything historic is emitted.
And the del* commands indeed really throw stuff out, as far as I have
seen. So any UID or subkey deleted with deluid and delkey are really
Some of those subpackets can be rather cryptic as well as cryptographic ;).

@_date: 2014-08-14 11:43:28
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
No, that does not appear to be the case. I tried it; it just falls
through without doing anything.
I think this is a feature: you could accidentally unrevoke a revoked UID
with setpref otherwise.

@_date: 2014-08-14 11:46:17
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
Ah! I never thought of trying good old --expert. Thanks!

@_date: 2014-08-14 11:57:51
@_author: Peter Lebbing 
@_subject: Seeking clarification with a few GPG concepts 
Actually, interestingly, you can. There is no timestamp or anything in a
UID; two UIDs with identical text are completely identical[1]. That
means that old certifications in this case do carry over (if they're not
[1] Well; except for the fact that it is the UTF-8 encoded text that is
signed, and it is possible for two different UTF-8 texts to come out
exactly the same. In that case two UIDs look the same but are different.

@_date: 2014-08-14 16:20:08
@_author: Peter Lebbing 
@_subject: FAQ change, final draft 
It looks good to me[1], thanks for writing it!
[1] That feels a bit odd, who cares how it looks to me. On the other
hand, it never feels odd to object to something that looks wrong to me! ;)

@_date: 2014-08-15 02:18:26
@_author: Peter Lebbing 
@_subject: OpenPGP card feature request: as many encryption-capable keys as 
I was thinking about subkey expiration when using OpenPGP smartcards.
Expiring a data signing subkey is no problem.
Expiring a primary key has no bearing to the issue I'm raising. It has
rather large implications, though.
The problem is expiring a encryption-capable subkey on an OpenPGP
smartcard, replacing it with a new one.
Currently, the OpenPGP smartcard only allows a single
en-/decryption-capable key.
Suppose after some time I decide an old key has seen it's useful
lifetime. I'd like to create a new encryption-capable key. However, I
definitely need to keep the old key, or I won't be able to see anything
encrypted to me in the past.
The current OpenPGP smart card restricts me to a single key for
encryption, a single key for signatures, and a single key for
authentication. If it were possible to tell the card, on uploading the
key, what that key's usage will be, I would be able to have a separate
smartcard that decrypted the 3 OpenPGP subkeys I used for encryption
previously. This instead of being forced to use 3 separate smartcards. I
get the impression this is a relatively small change to the firmware of
the smartcard, but a larger change to the software running on the PC.
The current roles of RSA keys were clearly chosen to cover the 3 cases
of signing, encryption and authentication. Maybe the card still has
enough room for a fourth key, once the purpose isn't fixed anymore? Or
even a fifth...

@_date: 2014-08-15 12:31:44
@_author: Peter Lebbing 
@_subject: OpenPGP card feature request: as many encryption-capable keys 
I don't think you *have* to, but it is certainly something I'd
recommend. If the only existing copy is on one smartcard[1], and that
smartcard breaks... for signature keys, not a problem at all. For
primary keys pretty inconvenient. For encryption keys... data loss of
all your encrypted data: huge.
But you choose a smartcard for the properties that make it different
than an on-disk key. If you then start keeping all your previous,
expired encryption subkeys as on-disk keys, you defeat the purpose to a
large extent.
So if you had a smartcard with a lot of storage, you could copy the key
material of your old keys, taken from your secure backup, to the card
and keep on using a card to work with the keys.
Hope that clarifies it,
[1] Additionally, for on-card generated keys, the built-in hardware
random number generator is used as the only source of randomness. I've
understood that the quality of that RNG isn't up to par with GnuPG on a PC.

@_date: 2014-08-15 13:48:09
@_author: Peter Lebbing 
@_subject: OpenPGP card feature request: as many encryption-capable keys 
Please note I was specifically talking about the OpenPGP card as it is
now, not about smartcards or HSMs in general.
Obviously an HSM *can* have a really great hardware RNG. But they are
complex devices.

@_date: 2014-08-15 21:14:49
@_author: Peter Lebbing 
@_subject: (OT) Re: ICMP 
Okay. So an administrator willingly creates a PMTU blackhole? He *wants*
the people trying to communicate through his firewall to fail on
connections where the PMTU is smaller than the MTU of the networks at
the endpoint? That is, only failing as soon as they send big packets. So
for instance, an SMTP session will correctly authenticate. Both peers
are completely happy. Then, when it's time for the mail to pass, all
suddenly inexplicably falls silent. Hard to debug if you don't know
about PMTU blackholes!
The iptables man page calls it this (TCP MSS clamping target):
That is a direct quote, not my words.
But I most bloody emphatically agree. Criminally braindead. Should not
be allowed to touch network equipment. You don't let your the brakes in
your sometimes mentioned sweet car be serviced by the cleaning lady, do
you? In a similar vein, I wished network administration were left to
people who are not criminally braindead.
I would only agree when the one doing the configuration actually thought
through the consequences. At least the big consequences.
Blocking all ICMP is incredibly stupid.
You might have noticed I feel very strongly about this. I hate meddling
with packets at routers that shouldn't be touching them and completely
violating the layering of the network to deal with f***ing idiots.

@_date: 2014-08-16 18:01:27
@_author: Peter Lebbing 
@_subject: (OT) Re: ICMP 
Hehe :).
I do regret the swearing in the last paragraph though. That wasn't
My apologies to anyone who didn't appreciate that.

@_date: 2014-08-17 11:41:15
@_author: Peter Lebbing 
@_subject: Mail header encryption (was Re: It's time for PGP to die.) 
However, in practice, MTA's, and specific configurations of MTA's, might depend
on headers in the mail:
- Spam filtering setups. Enough said.
- Microsoft Exchange[1] is not an RFC2822-based messaging system. When
interfacing through SMTP, POP3 or IMAP, messages are converted to and from X.400.
And then there is the problem of RFC 6409, Message Submission for Mail, which
specifies that the SMTP server receiving the message from the user (in other
terms, the MSA receiving the message from the MUA) /is/ allowed to alter the
message. I see a very nice example in the RFC which could be a problem with your
And as a very specific example, I can't get my Exim server to interface to
Spamassassin without acting as an MSA to Spamassassin. This means it will
invariably add missing 'Date' and 'Message-ID' headers to any mail delivered to
me. This would not be a problem for what you're proposing; I'm just pointing out
that in practice, some unexpected issues might crop up.
The ones acting as MSA's will usually add them, though.
The date is usually the same as the moment it is passing through the internet. A
monitoring adversary doesn't learn anything worthwhile.
The Message-ID by itself doesn't seem interesting to me. However, when combined
with the In-Reply-To and References headers, it can be very interesting.
Yes, it only solves minor issues but leaves the major one untouched.
[1] I'm unsure if there are versions that are pure RFC2822. AFAIK, all Exchange
servers are prone to mangling your message, whether that's caused by X.400
conversions or not. Of course, Microsoft often knows better than RFC's, and
treats "MUST NOT" as purely optional.

@_date: 2014-08-17 12:17:11
@_author: Peter Lebbing 
@_subject: It's time for PGP to die. 
So basically what you're suggesting is:
- MUA's still work with RFC-822 based mail, with a sort of "dummy" envelope that
holds an encrypted MIME message/rfc822 inside with the real metadata. These
MUA's still talk IMAP and SMTP.
- We define a new transport; the message the MUA hands via SMTP is not sent on
with SMTP, but with a different transport that's not quite as leaky with
metadata. This transport ultimately delivers the message to a mailbox server
allowing access over IMAP for the MUA.
Did I interpret it correctly?
BTW: I still think hop-by-hop encryption with TLS, with the certificates
authenticated through something different than the CA system, goes a long way in
thwarting mass surveilance. For massive, passive data trawling surveilance, even
the CA system combined with ephemeral TLS keying might be enough, since it
requires a MITM to intercept TLS with a fake certificate. Ephemeral keys just to
be on the safe side :).

@_date: 2014-08-18 19:23:01
@_author: Peter Lebbing 
@_subject: Fwd: It's time for PGP to die. 
Unfortunately, so long as TLS is not demanded, a downgrade attack can
easily disable it.
My 2c

@_date: 2014-08-18 19:45:27
@_author: Peter Lebbing 
@_subject: (OT) It's time for PGP to die. 
Classic prisoners dillemma! You know, they should arrest a whole lot of
these groups, and in a controlled setting try this many times. For science!

@_date: 2014-08-18 19:48:12
@_author: Peter Lebbing 
@_subject: It's time for PGP to die. 
I completely agree with that statement but never read any disrespect in
the mail you are replying to. It /can/ be read that way, I agree. So it
might be good to point it out, as you did.
Thank you for that! It was something that bothered me about the blog
post. If the writer then and there came with a great new successor to
OpenPGP and put the title "OpenPGP needs to die" above his article that
then goes on "... because here is my killer application", then I would
congratulate him.
Now it's nothing but hot air. OpenPGP doesn't need to die; who is it
bothering by merely existing? What has OpenPGP ever done to him? Present
large blocks of base64 at the bottom of a mail? :)
Something better needs to live. That's the opposite of what he is
saying. What a negative Nancy.

@_date: 2014-08-19 22:27:04
@_author: Peter Lebbing 
@_subject: So on & so forth 
So apparently they're not too worried about the DoS fixed in 2.0.24. And
libgcrypt 1.6.0, which succeeds a version vulnerable to "Get Your Hands Off My
Laptop" if I'm not mistaken, was released in December. I'd hazard a guess that
they ship a vulnerable 1.5.x version.
So everybody: hands off the Mac! ;)
I think that you should only build or fork software[1] when you're willing to
provide the service of security fixes to your users, or clearly indicate this is
out of your scope. Do they provide security support? I think the libgcrypt one
might warrant a fix. A DoS is just annoying.
[1] Especially security software

@_date: 2014-08-19 22:56:15
@_author: Peter Lebbing 
@_subject: So on & so forth 
I'm starting to regret my from-the-sideline know-it-better comments. They aren't
charging any money for it, and it's all open source. They don't owe anybody
anything for as far as I can see.
My apologies. I was out of line. It's fair to bring up the matter of security
updates, but not in the manner I did.

@_date: 2014-08-24 18:26:45
@_author: Peter Lebbing 
@_subject: installing gnupg-2.0.26 
(Note that I don't build my own gnupg; Debian releases security updates
for the distribution-provided binaries and there aren't any new features
that I need, hence I'm satistfied using what my distro provides. I'm
just giving general advice, never having done it myself)
It looks like it could find it, but it is objecting that you installed
version 1.9, needing at least version 1.11. So you need to install a
later version.
I would remove any files installed by the old version before you install
the new one.

@_date: 2014-08-24 19:22:52
@_author: Peter Lebbing 
@_subject: (OT) installing gnupg-2.0.26 
Doesn't sound very dumb to me; it's just a regular mistake even if you
knew that directories are often sorted in this really basic sorting
order. Your mind doesn't sort numbers according to ASCII representation.
My graphical file manager, Thunar (XFCE), sorts such things as one would
expect, comparing numerical substrings according to numerical value
rather than ASCII representation[1]. It's a really useful little detail
that helps in such cases. Alhtough I've often made the reverse mistake,
looking for version 20 between 2 and 3 :D.
I would welcome it if they ever put this into ls and bash completion, so
it also worked like that on the command line.
[1] At least, that's how I assume it works.

@_date: 2014-08-25 14:28:29
@_author: Peter Lebbing 
@_subject: (OT) installing gnupg-2.0.26 
I think that might preferable because it's easier to oversee. The ftp
directories are really packed full of stuff.
But either way, a simple mistake is easy to make. And the output from configure
scripts is /really/ packed full of stuff :).

@_date: 2014-08-28 11:13:55
@_author: Peter Lebbing 
@_subject: installing gnupg-2.0.26 
The Ubuntu package libbz2-1.0 contains the actual _shared library_ that
programs can use.
However, if you want to _compile_ a program so it can use libbz2, you
need the Ubuntu package libbz2-dev.
Your system almost certainly already contains libbz2-1.0 but before you
can compile gnupg2 so it can use it, you still need the package
libbz2-dev. You should use that one and not bzip2-1.0.6.tar.gz because
otherwise you are installing multiple versions of a shared library and
this should only be done if you understand the implications. Otherwise,
you could cause any program compiled against libbz2 to fail. Although I
think this is unlikely in the case of libbz2 because it only has libc as
dependency. You still might accidentally override a security update
released by Ubuntu, though.
The meat of the Ubuntu packages is as follows:
(That final .so in -dev is a symlink to the .so in libbz2-1.0).

@_date: 2014-12-01 17:15:19
@_author: Peter Lebbing 
@_subject: Order/changing of subkeys derogates compatibility!? 
I think you're being a bit harsh. He asked if this was a known problem,
and how to work around it; he didn't report a bug.

@_date: 2014-12-11 13:22:28
@_author: Peter Lebbing 
@_subject: 31C3, keysigning party 
I intend to organise a keysigning party if no one else does. I did one at 29C3
as well. I did a pure Sassaman-Efficient process then. Now I'm considering a
mixed-mode party, basing on Sassaman-Efficient, but falling back to slips of
paper as produced by e.g. gpg-key2ps for people who brought those from home and
don't have access to a printer while at the congress. Oh, and there's this 2D
barcode keysigning thing as well, should look it up. It was demonstrated to me
at the keysigning at OHM2013.
I printed my own Sassaman-Efficient list at the hotel I was staying at[1].
Do any people have experience with paperless keysigning parties, using laptops,
tablets, mobile phones, that sort of stuff?
BTW, I will attend the whole congress (27 to 30), but I might sleep in some days.
[1] I figured the odds that the hotel would modify my list rather low,
especially since we were the only participants staying at that hotel, so they
had probably never even heard of OpenPGP :).

@_date: 2014-12-11 13:49:36
@_author: Peter Lebbing 
@_subject: 31C3, keysigning party 
Probably monkeyscan from monkeysign... the latter has been mentioned numerous
times on this list, btw.

@_date: 2014-12-11 15:06:45
@_author: Peter Lebbing 
@_subject: 31C3, keysigning party 
Thanks for the pointer!
Neither does caff, if the organiser of the keyparty simply collects all keys
(sent by the participants) and sends the resulting keyring to all participants.
Been there, done that, bought the GnuPG t-shirt. I haven't checked if you can
pass a keyring to monkeysign.
So I'm a bit surprised by that claim in the README of GNOME Keysign.
They also keep talking of an authenticated copy of a key. The authentication
usually consists of you checking the fingerprint (or the program checking the
fingerprint in a securely retrieved barcode). Surely that is enough? Am I
missing something somewhere?

@_date: 2014-12-11 18:26:47
@_author: Peter Lebbing 
@_subject: 31C3, keysigning party 
Excellent!
And thank you for pointing it out, especially since they expect you to sign up
will bring their own slips of paper or QR code for people to photograph). In
fact, I've mentioned this to the organiser while signing up.
Thanks! That certainly is useful.

@_date: 2014-12-12 13:01:35
@_author: Peter Lebbing 
@_subject: Mainkey with many subkeys?? 
Hash: SHA1
If this was advice directly relating to OpenPGP: Do not take advice from the
person/site who told you this. They shouldn't be giving advice if this is
their advice.
For all practical purposes, this is impossible. You don't get an improved chance
of computing the secret key with more ciphertexts and/or signatures; not in any
meaningful way.
Applications using symmetrical ciphers sometimes have provisions to rotate keys
after a certain amount of time or data has passed, but this is completely
unrelated to OpenPGP keys, which are of a very different nature. OpenPGP keys
are asymmetrical and only encrypt session keys or sign hashes, they never
operate on the underlying data directly.
The whole argument "the more encrypted data there is, the easier it is to crack"
is a complete fallacy anyway. Anybody with your public key can create an
unlimited amount of data encrypted to you; it's decrypting it that can only be
done by you. If the availability of data encrypted to a key would be a way to
compute the private key, that way would always already be available to an
attacker. Fortunately, it doesn't work that way at all.

@_date: 2014-12-13 12:20:16
@_author: Peter Lebbing 
@_subject: Mainkey with many subkeys?? 
That there may be theoretic methods to use signatures to learn information
about the private key, but that they are all so impractical that they can be

@_date: 2014-12-13 13:39:22
@_author: Peter Lebbing 
@_subject: Randomized hashing 
I finally found the time to write this up. In part, it is a more elaborate
version of what Ingo Kl?cker said in [1].
When you want to protect 'r' from modification, there are basically two ways to
do it. You can include 'r' in the hashed data, or in the signature.
I'll outline what an OpenPGP message might look like[2] with randomized hashing,
with a symbol prepended to each line that indicates whether that line is
unprotected, part of the hashed data or part of the RSA signature. A U means
Unprotected, an H means Hashed, an S means its part of the signature itself.
U One-pass Sig packet:
U     keyID 969E018FDE6CDCA1, sigclass "binary document",
U     digest randomized-SHA-1, pubkey RSA
U Randomized hashing specifier packet:
U     r = b299c230c293191bd900217ab0dc7aad
H Literal data packet:
H     This is the actual signed message.
H     It can go on for quite a while.
H     But I choose to end it here.
H Signature packet:
H     sigclass "binary document", pubkey RSA, digest randomized-SHA-1
H     Signature Creation Time subpacket:
H         Sig created 2014-12-13
U     Issuer subpacket:
U         Issuer key ID 969E018FDE6CDCA1
U     Begin of digest 49 1f
S     OpenPGP-RSA-randomized-SHA1-sign(r, )
Where OpenPGP-RSA-randomized-SHA1-sign is defined as (|| is concatenation):
OpenPGP-RSA-randomized-SHA1-sign(r, d):
H = SHA1(RMX(r, d || 0x04FF || len(d)))
m = 0x00 || 0x01 || 0xFF || ..   || 0xFF || 0x00 || 0x30 || 0x21 || 0x30 ||
    0x09 || 0x06 || 0x05 || 0x2B || 0x0E || 0x03 || 0x02 || 0x1A || 0x05 ||
    0x00 || 0x04 || 0x14 || H
return m**d (mod n)
** is exponentiation. So the signature is computed over the hash, and a constant
(which is padded with 0xFF's to make m the right size for an RSA signature).
The hash is computed over the RMX function.
The RMX function is rougly:
RMX(r, d0 || d1 || .. || dn) = r || d0 ^ r || d1 ^ r || .. || dn ^ r
^ is the xor operation here, not exponentiation. RMX is not exactly that, but
good enough for what I am trying to say. The point is, r is *included in the
hash*. That's what protects it from modification. The paper at [3] contains a
proof that it is intractable to modify r and get a message that hashes to the
same hash. This is not immediately apparent, but they prove it for hash
functions with the structure SHA-1 has.
'r' still needs to be passed to the recipient, but it needn't be protected
explicitly, since it is included in the hash anyway. In fact, it is pretty much
as if the "Randomized hashing specifier packet" I invented above wasn't of the
U(nprotected) type but of the H(ashed) type. It's just that it's solved at the
RMX level rather than the OpenPGP level.
The other way is also mentioned in the paper. I can't find the footnote you
mention; which paper were you looking at? The trade-off is that for that method,
the actual signing operation needs to be changed, which is the problem. The
advantage is that the rest of the message stays the same.
For OpenPGP One-pass-signature packets, this gets a bit silly. The purpose of
that is to start computing the hash while reading through the file the first
time. This becomes impossible with this method, so let's drop that packet,
pretend that it was never there in the first place, and we always needed two
passes. Pretend that we keep everything as it was, and only change the signing
H Literal data packet:
H     This is the actual signed message.
H     It can go on for quite a while.
H     But I choose to end it here.
H Signature packet:
H     sigclass "binary document", pubkey RSA, digest randomized-SHA-1
H     Signature Creation Time subpacket:
H         Sig created 2014-12-13
U     Issuer subpacket:
U         Issuer key ID 969E018FDE6CDCA1
U     Begin of digest 66 1a
S     OpenPGP-RSA-randomized-SHA1-sign(r, )
Now we define OpenPGP-RSA-randomized-SHA1-sign quite differently:
OpenPGP-RSA-randomized-SHA1-sign(r, d):
H = SHA1(H_r(r, d || 0x04FF || len(d)))
m = 0x00 || 0x01 || 0xFF || .. || 0xFF || 0x00 || some-new-ASN.1-specifier ||
    r    || H
return m**d (mod n)
H_r(r, d0 || d1 || .. || dn) = d0 ^ r || d1 ^ r || .. || dn ^ r
Now, r is included in the RSA signature itself. To get at it, the receiver
decodes the RSA message (raises it to the e-th power) and extracts r from it.
Then the receiver can start to compute the hash. The some-new-ASN.1-specifier is
a constant string specifying this new randomized-SHA1 scheme, because we changed
the message and can't give it the same identifier as we use for regular
In fact, they propose the latter variant, but with RMX instead of H_r, for those
cases where the message itself cannot be changed.
So that was what I was trying to say: you can include r in the hashed data, or
in the signature. They are not proposing to not protect r at all, they are
proposing you keep the signature algorithm as it is and include it in the hash.
[1] [2] This is probably not the best way to include 'r', but it illustrates the
method, rather than the actual OpenPGP packets defined.
[3]

@_date: 2014-12-13 14:41:53
@_author: Peter Lebbing 
@_subject: Mainkey with many subkeys?? 
Hash: SHA1
In what sense is that? It seems GnuPG is not letting me sign data with a
certify-only key:
$ gpg2 --edit-key de500b3e
pub  2048R/DE500B3E  created: 2009-11-12  expires: 2015-10-27  usage: C
                     trust: ultimate      validity: ultimate
sub  2048R/DE6CDCA1  created: 2009-11-12  expires: 2015-10-27  usage: S
sub  2048R/73A33BEE  created: 2009-11-12  expires: 2015-10-27  usage: E
sub  2048R/B65D8246  created: 2009-12-05  expires: 2015-10-27  usage: A
$ echo hoi | gpg2 -u 0xDE500B3E\! -o test_cert_sig.gpg -s
gpg: skipped "0xDE500B3E!": Unusable secret key
gpg: signing failed: Unusable secret key

@_date: 2014-12-17 01:35:32
@_author: Peter Lebbing 
@_subject: GnuPG and g10 code 
Hmmm, that article seems lacking. If you would have asked nicely, I might have
bothered to improve it. Now, I don't feel inclined to do it. I'll get around to
it one day.

@_date: 2014-02-04 19:38:07
@_author: Peter Lebbing 
@_subject: making the X.509 infrastructure available for OpenPGP 
FWIW, CACert signs OpenPGP keys of verified people with key 0xD2BB0D0165D0FD58
if you want them to. Since it's 1024-bit DSA, it's a bit dated in some respects.
And CACert still isn't in the default trusted root bundle on quite some systems,
I believe.
With regard to this discussion: I'd rather see the CA model replaced by
something a little more trustworthy than extending the trust in that broken
model to OpenPGP. Monkeysphere comes to mind.

@_date: 2014-02-05 19:04:04
@_author: Peter Lebbing 
@_subject: making the X.509 infrastructure available for OpenPGP 
I could think of /a/ reason to do it. You could leverage existing X.509
certifications by CAs to verify key validity in the OpenPGP world.
An X.509 certification obviously certifies that a certain X.509 certificate
belongs to the person or role identified by the Distinguished Name. But seen a
bit differently, it certifies that that Distinguished Name has control over the
key that is in the certificate.
If that same key is used as an OpenPGP key, it follows that that same
Distinguished Name has control over that key.
So you could create a hybrid model:
I assign trust to a specific CA. That CA has issued a certificate with DN "XYZ".
In my public OpenPGP keyring, there exists a key with a UID "XYZ", and that
public key has the same raw key material as the certificate. A key manager that
manages both types of keys can now in fact infer that UID "XYZ" is validated by
that CA.
This approach doesn't change anything about the format of certificates in either
X.509 or OpenPGP, it simply matches raw key material and DN's to UID's, and
infers a measure of validity from it. Since OpenPGP UID's are usually not in the
same format as DN's, people need to explicitly create such a UID to support this
kind of validity inference. For a better user experience, it might be useful if
frontends could work with the DN format, so such a UID is considered when
matching on an e-mail address.

@_date: 2014-02-05 22:30:38
@_author: Peter Lebbing 
@_subject: making the X.509 infrastructure available for OpenPGP 
I never intended my message to say I would trust any CA. Hauke was looking for a
way to leverage trust in a CA; I was merely contributing something I thought he
might find interesting.
By the way, I still think the CA certifies that the certificate belongs to the
person or role identified by the DN. The problem is that when someone vouches
for the truth of something, that doesn't make it an actual fact. It sometimes
means the certifier is simply sloppy or a liar. Certification is a statement,
not truth.

@_date: 2014-02-06 10:58:12
@_author: Peter Lebbing 
@_subject: making the X.509 infrastructure available for OpenPGP 
Actually, I suggested leveraging an existing X.509 certification to induce
validity in the OpenPGP model. The CA would not be actively involved.
I don't see how that would work[1] for the method I came up with. I suggested
matching the UID's, but UID's are always bound to the primary key, so it needs
to be the primary key which is certified.
Ha! If the Snowden revelations have made anything obvious, it is that the trust
model of X.509 is horribly broken[2]. Unless they do some sort of certificate or
CA pinning at the least, implementing this proposal would only induce a false
sense of security and require the NSA to do, for example, active MITM instead of
passive collecting. And since we're talking about e-mail traffic inside or
between universities, I don't think passive collecting gets you very far in any
case if they enable secure SMTP.
But at least it might cultivate people who at least think about, or realise
there is such a thing as security and attackers. Let's just hope we don't
cultivate fundamentally flawed practices.
I don't doubt security experts at the universities are much better at this than
I am, but I'm a bit cynical about them getting what is needed to implement this
If the reason for that is solely that he favours S/MIME, it sounds like a really
strange decision. It sounds like the problem is with this person, not with
OpenPGP. Have you tried to talk to his colleagues or staff?
Actually, in this last piece, it is your attitude which rises questions. You are
merely venting your own opinion, and do so in a way slightly offensive to people
with a different opinion.
I sincerely disagree as well. I don't see why OpenPGP needs to get involved with
CA's, a model which is at the heart of the problem of S/MIME. I don't see why
any alternative way of making it a more turnkey solution would be inferior to
getting involved with X.509. I don't know a good alternative way, but I don't
reject them either.
And how is it '"political" or whyever' to state that CA's can't be trusted? It
feels "policital" to me to say they /can/ be trusted. I'd expect a politician to
say that, along with "you can trust me". Yeah right.
I think some things that are already available get us part of the way, and
perhaps bundling them with good docs would make a major difference. The checking
of fingerprints is a bit annoying, but I've seen a program to make a QR code;
that way (if you trust your phone), it gets a whole lot easier to certify people
you know by taking a picture of that QR code with your phone.
[1] Without significant alterations to the existing model, which I was trying to
[2] Okay, it was obvious already before that.

@_date: 2014-02-09 13:45:18
@_author: Peter Lebbing 
@_subject: howto not list disabled keys? 
I don't know if there are more ways, but you can view the disabled status with:
$ gpg2 --with-colons -k
(note that it lists all keys because I don't restrict it with a search term)
This is the machine readable output, and colon-delimited field number 12
contains an uppercase letter D when the key is disabled (got this from the doc
file named DETAILS).
Now you can construct a way to list in human-readable format those keys that are
not disabled:
$ gpg2 --with-colons -k|gawk -F: '$1 == "pub" && $12 !~ /D/ { print $5 }'|xargs
gpg2 -k
Note that you should never just enter some command on the command line because
someone on the internet said so. You need to understand what you're doing or
there might be some mean little thing screwing up your system. The explanation
is as follows:
gawk splits the lines by the field separator :, and if the first field is
literally "pub" then the line indicates a public key. The regular expression D
is matched to field 12; it is an inverted match, so the pattern only evaluates
to true if field 12 does not match the regex D. In other words, the whole
pattern guards that we are reading a line with pub as field 1, and no D in field
12. If this is the case, we print field 5, which is the long key identifier.
This is then piped to xargs, which invokes gpg2 -k ${KEYID1} .. ${KEYIDn} with
all the matched key ID's, causing gpg2 to list the keys. If the list is very
long, multiple invocations will be done so as not to exceed the maximum line length.
Note that a collision in the long key identifier still causes a disabled key to
be listed, but this is rare. It is possible to write an AWK program that would
check the fingerprint, but it would be more complex. As long as you don't
this as a bit of static, you're fine.
Oh, by the way, I kinda assumed you're on a GNU system because you didn't say
anything and I am on one, so this is what works for me. In general, it would be
a good idea to indicate what OS you're using when asking something like this.
Although you perhaps expected a reply like "you use --list-options
exclude-disabled", and that would be cross-platform :).

@_date: 2014-02-10 18:27:49
@_author: Peter Lebbing 
@_subject: Hash of Win32 binary doesn't verify 
I agree. The OpenPGP signature is okay, but the hash is indeed what you say. So
I think it's a mistake on that integrity check page.

@_date: 2014-02-11 10:46:17
@_author: Peter Lebbing 
@_subject: Moving away from SHA-1 
Have you searched the mailing list archives? There are several times this has
been discussed already, including many different opinions, responses to those
opinions and arguments for and against specific plans of action. I don't think
there's anything substantial to add to those existing discussions.

@_date: 2014-02-13 14:32:56
@_author: Peter Lebbing 
@_subject: Subject: openpgp card and basiccard RNG 
If you create keys on the card with the option of a local backup, or if you
create normal keys which you then "keytocard", the included RNG is not used for
key material. I don't think it's used elsewhere (apart from the obvious GET
CHALLENGE command which is used to get verbatim random numbers from the RNG).
Signature generation is deterministic, and the random bytes used for an
encrypted message are generated by the sender, not the card.
Werner Koch had this to say about an on-card RNG[1]:
Considering that Werner was involved in the creation of the OpenPGP card, I
think the on-card RNG isn't blindly trusted.
That does beg the question: is it still used when using "addcardkey" and
declining to use a backup?
PS: I restricted your statement "trust ZeitCorp" to the RNG. Obviously, more
possibilities exist for a manufacturer to be nasty.
[1]

@_date: 2014-02-13 19:08:51
@_author: Peter Lebbing 
@_subject: Subject: openpgp card and basiccard RNG 
What in fact happens is that the key is generated on the PC, and it is both sent to the card using the same mechanism as 'keytocard' and backed up to a file on the PC. This is because it is impossible to get the private key out of the card, so if you generate the key on the card, you can't keep a backup of it.
So the card doesn't generate the key at all, hence not needing an RNG.

@_date: 2014-02-13 21:29:09
@_author: Peter Lebbing 
@_subject: Subject: openpgp card and basiccard RNG 
You need an NDA to get the SDK, and you can't disclose the source code for your
application. You don't need the implementation details of a smartcard to write
an application for it.
Those NDA's are rather common in the smartcard world, where companies with a lot
of money are worried you'll devise a way to watch pay-TV for free and such.[1]
Although I think there's a trend towards more openness, and I learned a while
ago that you can get crypto-capable JavaCards these days without requiring an NDA.
PS: I might be off on the exact details, this is all from an interested
observer's standpoint.
[1] Yes, security through obscurity. And they need the obscurity, because the
security often isn't all that well. Although they have to face the problem that
DRM is defective by design, and what they're doing borders on DRM, so partly
it's a fundamental problem.

@_date: 2014-02-16 13:02:12
@_author: Peter Lebbing 
@_subject: Decryption problem - Large .png file 
Sounds like the .png file is output to to your terminal instead of a file. This
is the default for the -d option. The -a option is used for specifying armoured
output; it is not used for decryption, AFAIK.
The default action for gpg when given an encrypted file is to decrypt it and
write the result to a file (as opposed to the terminal like with the -d option).
But it constructs the filename for the decrypted file from the filename of the
encrypted file, and the filename you've given is a bit odd. Normally,
something.png.asc would lead to a filename something.png. But with the added
.txt as a third extension, it seems gpg recognises that this is a strange
situation and prompts you what to do. It suggests using the filename of the file
that was encrypted, which is stored inside the encrypted file but not normally
used because it can lead to nasty surprises (you decrypt a file named
harmless.csv.asc and it creates a file named evil.exe). Supposing the original
filename was simply serial.png and the encrypted file is, as you say,
serial.png.asc.txt, this is what it looks like here:
$ gpg serial.png.asc.txt
gpg: encrypted with 2048-bit RSA key, ID 73A33BEE, created 2009-11-12
      "Peter Lebbing "
gpg: serial.png.asc.txt: unknown suffix
Enter new filename [serial.png]:
I simply pressed Enter on the "Enter new filename" prompt because I thought the
suggested filename was okay, and I now have a decrypted file serial.png next to
the encrypted one.
If you want to avoid the prompt, you can do either
$ gpg -o serial.png serial.png.asc.txt
$ gpg -o serial.png -d serial.png.asc.txt
This is because the default action for an encrypted file is to decrypt it, so
you don't need to explicitly specify -d.
Or you could use a GUI, but since the filename ends in .txt, it might be that
the fact that it is an OpenPGP file is not recognised (by your file manager, for
instance). You could drop the .txt and simply name the file serial.png.asc as usual.

@_date: 2014-02-20 11:06:27
@_author: Peter Lebbing 
@_subject: gpg asks for the same passphrase each time it uses new subkey 
I think Faru meant that he/she had at some point already given the passphrase
for decryption with his GnuPG key, but that he/she didn't expect to be prompted
again when signing with the same GnuPG certificate. I'm using the term
certificate here to refer to the whole of the primary key and all subkeys.
The reason that you're prompted twice is that there is no technical reason why
the passwords for different subkeys need to be the same. Since different
passwords is such an exotic configuration, there is no "proper" command to
achieve this, but it is technically possible[1]. This means that GnuPG actually
really doesn't know the password for the signing subkey. It won't just try the
password for the decryption key to see if that happens to fit; it will ask for
the password.
So you could arrange for the password to be asked on the start of your session
by simply having this execute at the start of your session:
$ echo dummy | gpg2 -s >/dev/null
The command you mentioned (gpg se | gpg d) would ask for two passwords, one for
signing, and one for decryption.
Obviously, you would need to set the time to live for the passphrase large
enough for it to still be valid when the cron job runs.
An alternative is a passphraseless separate signing key that you only use to
sign your backups. This has different security properties; you need to assess
which is best for you.
[1] If someone is interested, I can show how you can do this. But you could also
try to search the mailing list for it, because it has been done before :).

@_date: 2014-02-24 13:32:34
@_author: Peter Lebbing 
@_subject: Size of main key... 
However, if I see two keys:
0xCFAF704C Laurent Jumet
0xCFAF704C Laurent Jumet
Where the short ID and the UID matches but obviously the fingerprint does not,
I'm going to be mightily suspicious and think twice before signing either of
those. It looks like an attempt to subvert people into signing an attacker's key
(although the attacker seems to have forgotten to spoof the creation date :).
So you might not do yourself a service by creating this "convenient" key that
matches your old one.

@_date: 2014-02-24 21:21:50
@_author: Peter Lebbing 
@_subject: Size of main key... 
Well into hypothetical territory now because there was no attacker, but...
I suppose you have a good point. Those people that think you can verify
authenticity by just checking the short key ID, they might as well think that
both keys are genuinely those of Laurent, and pick the most recent one.
If I would do the attack, I would make everything as genuine as I could, so I
would alter my system clock. But perhaps that's missing the opportunity to be
chosen /in preference of/ the real key :). Neato. I was banking on just getting
the fake key to be the only one that the victims see.

@_date: 2014-02-26 22:29:46
@_author: Peter Lebbing 
@_subject: key generation: paranoia mode - explicit random input 
Ultrasound, in combination with a nearby compromised online system with a
microphone, for example. Your smartphone would be a pretty good candidate. Or
through not-so-random padding on subsequent messages when the key is used,
relying on you to bridge the air gap.
It sounds to me like the age-old "my system is compromised, but I still want to
use GnuPG on it". I think you've heard the answer to that.

@_date: 2014-02-28 11:38:20
@_author: Peter Lebbing 
@_subject: key generation: paranoia mode - explicit random input 
Your system bears similarities to deterministic compilation, where you build a
binary on different systems and compare the results.
There is a defining difference though. With deterministic compilation, the built
binary is the end goal. When one of the systems it builds on is trustworthy, and
all copies are the same, the binary is the one that you want and will use. Your
product is okay. You don't care about the machines it was built on.
With your scheme, the public key or the signed message are not the end goal. The
end goal is the secrecy of the private components. You do care about all the
systems it was built on, because they still have your private key.

@_date: 2014-02-28 20:47:38
@_author: Peter Lebbing 
@_subject: key generation: paranoia mode - explicit random input 
I'm Dutch, so I'll do a dyke analogy. A dyke has breached. Throwing in one sack
of sand is easily implemented, and it prevents the water from flowing over a
span of say half a meter. Too bad it's still flowing over the span of the rest
of the sixty meters the breach is wide.
Your solution seems analogous to throwing in the one sack of sand because it is
easy to implement.
So indeed: how much more security will one get? I think that's where the
opinions differ.
You just have to trust your most trusted computer, or you have a lot of water in
your living room.
By the way, if it's so easy to implement, you could write a patch, or pay
someone to do it for you. I would warn you to think about the source and quality
of your randomness. If a compromised computer supplied your file containing the
randomness, you'd look pretty foolish if you used that. So I suppose you need to
have each computer generate the amount of randomness that is (worst case) needed
for a key generation, and then have a well defined method of combining all those
different blocks of randomness in such a way that even if a part of the
randomness is crafted precisely to counteract the randomness in the other parts,
you still have enough randomness to generate a key. It seems to me assuring the
quality of the randomness is much harder than simply redirecting libgcrypt's
random functions.
Oh, and obviously, each computer that supplied a part of the randomness needs to
verify that that is still the same when it generates the key, or the last PC to
generate a block of randomness could just as well replace the earlier parts
without you noticing. Etcetera. I'm sure I've missed something interesting
relating to the randomness generation and transportation.
I have one final question: would you even use this yourself or do you just think
it's cool?
PS: Sorry for my wildly inaccurate description of a dyke breach and stopping it.
I might be Dutch, but I'm not an expert on water. I gladly leave that to the
king :).

@_date: 2014-01-03 12:13:04
@_author: Peter Lebbing 
@_subject: sign encrypted emails 
How do you know the sender doesn't have an unencrypted copy of the message in
an easily broken into online backup service? The encryption of one copy of a
message doesn't imply the confidentiality of all copies that exist.

@_date: 2014-01-03 20:29:50
@_author: Peter Lebbing 
@_subject: How to do pinentry in same screen as gpg 
I remember that post by Hauke. Let me quote my reply I wrote to this list back then:
True, it's not exactly the website :). I agree it would be good if the manual
were on the website, and I can't find it either, but let's wait for the new design.
Oh, btw, slight addition: BYE is not in the agent (or pinentry) protocol
description because it is a basic assuan command, so it's described at [1] or
"info assuan".
[1]

@_date: 2014-01-05 10:35:44
@_author: Peter Lebbing 
@_subject: sign encrypted emails 
Hash: SHA1
Eh? You yourself start this whole discussion by making the point that it is,
as things are now, unreliable to act differently depending on whether
encryption is applied to the message or not. That is precisely the whole
strong argument why people say: you just shouldn't act differently depending
on whether encryption is applied to the message or not.
I really do not understand one bit why you now say this is a claim without any
argument, I'm quite surprised. Unless you read "without any argument" as "this
is a thing we agree on", but that requires bending the sentence beyond
breaking point ;).
I agree with Robert, you're trying to solve a social problem with a technical

@_date: 2014-01-05 14:04:49
@_author: Peter Lebbing 
@_subject: sign encrypted emails 
Hash: SHA1
Don't write "I will encrypt this message"[1] in every mail hoping that the
recipient deduces that you want to do secret stuff, and leaving them to deduce
from the absence of that message that you want to do the regular stuff. Hoping
that other people will infer meaning from things that are totally not
apparent, /that/ is error-prone.
If someone writes me a signed statement "see me tomorrow", I will show up. I
will not come carrying my highly volatile nuclear concoction just because the
message is encrypted. You should feel confident a signed statement is coming
from the person who signed it. You can't deduce very much from the
message arriving encrypted, I think. When the message arrives /unencrypted/
and contains confidential stuff, you could show up with a clue-bat and say
"Dude, not cool, not cool", because it was obviously (within reason) sent
unencrypted. But it being encrypted means nothing.
The social solution is not "include some statement each and every time" but
"don't deduce anything from it being encrypted". It's not a burden, it's a
change of expectation.
If you want to convey something to someone, just say so. Don't say "see me
tomorrow", but say "I want to discuss X tomorrow with you, be sure to bring Y."
[1] By the way, your statement might not even be true; how often have you
written "See the attachment" and then forgetting to attach the file? I have
done it countless times.

@_date: 2014-01-06 11:48:24
@_author: Peter Lebbing 
@_subject: sign encrypted emails 
I guess it boils down to the point that I just don't see a use case.
I believe there are two scenario's you're treating:
- You wish to give significance to a mail being encrypted; this, for you,
changes the context of the contents. I disagree; I'd rather see it context-free
and unambiguous[1].
- You wish to catch noobs in the act when they forget to encrypt. I think secure
communications with noobs is impossible, so it doesn't help to plug a single
hole in the sieve[2].
The result is that I see no application for what you describe. At to that the
fact I find it a rather ugly kludge to sign a single message twice instead of
keeping all authenticated data inside the one signature, and you've lost me.
So I guess this discussion is indeed pretty much done.
[1] Hmmm, maybe we should define a formal e-mail language ;)
[2] I'm using noobs rather broadly here, since I think it takes a lot of
attention and rigour to secure communications.

@_date: 2014-01-07 21:35:51
@_author: Peter Lebbing 
@_subject: USB key form-factor smart-card readers with pinpads? 
Additionally, in the OpenPGP Card 2.0.1 spec, the DO with tag C4 on page 17,
section 7.2.2 (VERIFY) and section 7.2.8 (PSO: COMPUTE DIGITAL SIGNATURE) all
specify this one-VERIFY-per-SIG behaviour.

@_date: 2014-01-09 14:47:41
@_author: Peter Lebbing 
@_subject: export-minimal and expired subkeys 
A quick test indicates: no, it does not remove expired subkeys, using GnuPG 2.0.22.
I don't know.

@_date: 2014-01-13 10:38:04
@_author: Peter Lebbing 
@_subject: USB key form-factor smart-card readers with pinpads? 
Since most readers don't filter VERIFY commands and additionally you can't force
the OpenPGP smartcard to require a VERIFY before each decryption anyway, the
pinpad really doesn't add much at all for decryption.
With regard to the PIN not being known to the attacker when using a pinpad:
Werner disagrees that a pinpad can reliably accomplish that. I did a feature
request about a year ago, you should read this thread: [1]. And especially
Werners answer in [2]. So according to him, it doesn't add much for signatures
A bugged reader firmware (certainly a possibility) would even still work in the
face of a reader filtering VERIFY commands. I think most readers have
upgradeable firmware. If an attacker has your PC and knows a vulnerability in
the firmware upgrade method, they can just flash their own firmware in your
smartcard reader. This is a really difficult to solve scenario. I do think it
requires a rather capable attacker.
So at least in its current state, a pinpad doesn't add that much. Over to the
actual advantages of a smartcard. I disagree that an 8-digit PIN isn't a
usability advantage over a good passphrase; it's much easier to enter. But the
one big advantage of smartcards: you know that (ignoring very capable attackers)
there is only one copy of the key in existence, and that's inside your
smartcard[3]. It in principle can't be copied. While the card is connected, an
attacker may do as they wish, but once you regain control of your systems, your
key is safe again. Doing crypto on a compromised machine is in so many ways a
lost cause that this is the best it is going to get in reality: containment of
the problem to the compromised machine(s).
This requires the admin PIN. It's also more of a denial of service than anything
else. A denial of service is trivial by doing 3 false Admin PIN attempts,
locking the card.
By the way, all in all, I'm not convinced a pinpad reader with the ability to
force a VERIFY for each decryption wouldn't add a substantial amount of security
to the overall system, albeit not perfect. But this feature has been requested
and denied. So that's where I agree with you. I disagree that a smartcard
without a pinpad isn't useful.
[1] [2] [3] Okay, for primary and decryption keys maybe some more backups inside a safe,
but hey, that's safe ;).

@_date: 2014-01-21 12:23:40
@_author: Peter Lebbing 
@_subject: Trouble reseting OpenPGP card after admin PIN lockout 
TL;DR: I think you might be helped by [4]. Do an "scd killscd" from
gpg-connect-agent, install and start pcscd, install the Python module pyscard
and run the script from [4]. By the way, if you have an OpenPGP v.1 card, you're
screwed, they self-destruct on 3 wrong Admin PINs.
Since you already locked the PIN, the 8 commands that represent VERIFY attempts
with a wrong PIN should no longer be needed. They are these commands:
For the normal PIN (to be overly exact, for doing a signature)
For the admin PIN
This would normally be the first step of getting the card back to an unlocked,
clean state.
Note that an OpenPGP v1.1 card will self-destruct on 3 wrong admin PINs. If you
have a v1.1 card, you're out of luck.
However, a v2.0 card can be quite a bitch as well. I grabbed an unused v2.0 card
to try to replicate your situation. I exhausted the Admin PINs, disconnected and
reconnected the reader, and tried to re-initialise it. It wouldn't work. I
accidentally lost the log of what I did, but it would respond to "TERMINATE DF"
with the expected status 90 00, but "ACTIVATE FILE" would give an error in
SW1-SW2. Then I also exhausted the regular PINs, thinking that maybe both need
to be locked. No luck again. I interspersed all with the following APDU I
constructed from the docs:
scd apdu 00 ca 5f 52 00
Which gets the DO "Historical bytes" and looks like this for one of my v2.0 cards:
D[0000]  00 31 C5 73 C0 01 40 05  90 00 90 00
The fourth-to-last byte, 05, indicates it is in "Operational state". At no point
did the test card leave this state, even though after "TERMINATE DF" it should
say 03 for "Initialisation state", IIUC.
I changed the order of "TERMINATE DF" and "ACTIVATE FILE", and sometimes
repeated one of those, but no matter what I tried, I could never get 90 00 for
both commands, always only one of them.
Then at some point, my card stopped working. I would get "Incorrect value" if I
remember, euh... correctly. I got a bit worried at this point, and decided to
kill scdaemon and gpg-agent to start with a clean slate. gpg-agent however is
started by my X session, and killing it only made it . At this point I
logged out, and lost my log of what I had done. Oops! There goes an exact and
detailed transcript of how it went wrong. Aaarrrggh! Why didn't I set screen to
log all to a file?!
So now, the OpenPGP card would not select the OpenPGP application. A log of all
APDU's, generated by scdaemon (debug 2048) is:
I tried to decode this. ISO 7816-4 is annoyingly expensive to buy, but you can
find parts of it online. The first apdu "SELECT FILE" seems to request file
control information, but P2=0C is not defined by [1]. The error response by the
card is given, as "Wrong parameter(s) P1-P2" [2]. Hah, the card also doesn't
understand P2, I think.
On to the OpenPGP application. The second APDU is a "SELECT FILE" for the
OpenPGP application, but unfortunately, the card returns 62 85. Again, not
mentioned by [1] or [2]! It is of the class "State of non-volatile memory
unchanged", but SW2=85 is not defined. But it is obviously different from the
rest of the "SELECT FILE"s that follow, which aren't all that interesting
because I think they refer to different cards that are also supported by
scdaemon. The fact that selecting OpenPGP is different, is relevant, though.
Oh, by the way, the ATR is normal.
Perhaps I could get further with the full, real ISO 7816. But alas, I don't have
it, and it's expensive.
So I wrote all this, and then tried to find more about "TERMINATE DF". The
reasoning is: normally we select the DF for OpenPGP, and then do a "TERMINATE
DF", right? Selection errors out, so if we could parameterise "TERMINATE DF" to
directly specify the OpenPGP DF, maybe that will work. At this point I came
across this mailing list conversation: [3] and from that [4]. The script in [4]
did the trick to bring back my card, and it differs from the scdaemon approach
in that it doesn't error out when "SELECT FILE" doesn't work. What it does for
me, is "SELECT FILE" OpenPGP, it errors with 62 85 just as with the author of
the script, but then it nonetheless sends an "ACTIVATE FILE". Yes, at this point
it seems that I was wrongly informed earlier, and that it is actually as follows:
This is "ACTICATE FILE"
This is "TERMINATE DF"
If I now, with this experience, read the descriptions of those in the OpenPGP
card v2.0 spec, some more things become clear. "TERMINATE DF", INS=E6, will
indeed somewhat terminate the OpenPGP application, in that it will, documented
there, return 62 85 on a "SELECT FILE". Perhaps 62 85 is defined in ISO 7816-9,
where "TERMINATE DF" is defined, a specification which I don't have either.
However, it gets slightly annoying when scdaemon from then on will not talk to
the card anymore because it returns said 62 85. The Python script will do the trick.
That is, if I first do an "scd killscd" from gpg-connect-agent, then start
pcscd, and also make sure I have the pyscard package installed for Python.
At this point my card works again. A little while earlier in writing this mail,
I thought "well that's the last time I experiment with resetting an OpenPGP card
to help someone", but I suppose I'm good to go again :). I don't have to throw
out my unused card after all.
In fact, I did another test. As documented in the OpenPGP card spec, indeed both
PIN counters need to be down to 0, not just the Admin one.  And it seems the
following is required to reset it:
- Expire both PINs
- scd apdu 00 e6 00 00
"TERMINATE DF". If at this point you reset your card, scdaemon will become
useless because it will error out on selection of the OpenPGP DF.
- scd apdu 00 44 00 00
"ACTIVATE FILE". Works from scdaemon when issued after "TERMINATE DF",
otherwise, use the script in [4].
[3] [4]

@_date: 2014-01-21 12:34:49
@_author: Peter Lebbing 
@_subject: Any way for two correspondents to set up gnupg within a  few 
You mean what you personally consider insecure defaults. Please let's not
confuse people by stating opinions as facts. You're entitled to your opinion,

@_date: 2014-01-22 14:06:34
@_author: Peter Lebbing 
@_subject: (OT) ISO 7816 communications defined 
However, I just found out that, being registered as a student at the TU Delft, I
can get them for free! \o/ The master I'm doing gives me a registration at
multiple universities, and even though I'm studying at the University of Twente,
I can still use the facilities of two other universities.
The current ISO 7816-4 defines this first SELECT as "Select MF, DF or EF"
identified by the identifier "02 3F" which I could not find. P2 in combination
with Le is defined in the current spec, as "No response data".
Which is defined in ISO 7816-9 as "Selected file in termination state", the
proper response for a DF that has been terminated with "TERMINATE DF".
It seems to me that "DEACTIVATE FILE" would have been more appropriate for the
OpenPGP card than "TERMINATE DF", as ISO 7816 defines the latter as a permanent,
irreversable action AFAICT.
This parameterisation would in fact be possible under ISO 7816-9, by the way. It
would be:
scd apdu 00 e6 04 00 06 d2 76 00 01 24 01
Although because of the mixup between "TERMINATE DF" and "ACTIVATE FILE", I
think it would be more useful to directly give the DF to "ACTIVATE FILE", which
would be:
scd apdu 00 44 04 00 06 d2 76 00 01 24 01
Neither command is accepted by the OpenPGP card, though. It only implements the
implicitly referenced form where you first "SELECT FILE". Unless I'm making
mistakes, obviously.
Well, that's it. My curiosity has been satisfied :).

@_date: 2014-01-26 00:58:05
@_author: Peter Lebbing 
@_subject: trying to find a folder 
gpgconf --list-dirs
It's the entry "homedir".
Note that in general, with these kinds of questions, you should at least mention
what operating system you're running.

@_date: 2014-01-30 11:49:47
@_author: Peter Lebbing 
@_subject: Setting up shared access to gpg on a UNIX server 
If you're trying to achieve by the 744 what I think you're trying to achieve,
namely that users can't change the files, I think you're mistaken[1]. Look at
the following session I just did[2]:
The thing is, you're not allowed to change any files, but you are allowed to
replace those files by your own. The sticky bit might help, but I'm not sure.
gpg does stuff with a bunch of files in the homedir, and I suspect that some
might need the permission to overwrite files one of your other users created.
I haven't thought about the rest of your setup, this is just one issue that
stood out to me so I commented on that.
[1] Additionally, why are all files executable?
[2] ll is shorthand for "ls -l"

@_date: 2014-07-07 11:50:30
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to quantum cryptography 
I agree.
This conversation is still a mystery to me.
"The Fuzzy Whirlpool Thunderstorm", it seems to me you advocate revoking
an encryption key, or letting it expire, when you suspect the key could
be cracked by an adversary.
This does not help at all for anything already encrypted to that key, it
only prevents people (who have fetched the revocation) to encrypt any
new data to that key. Any old data can still be decrypted by your
adversary, who has computed your private key.
The method works reasonably well for signature keys, apart from the fact
that your adversary can still fake a signature in the past, when your
signature key was still valid. Also, your correspondents still need to
fetch the revocation before they realise new signatures are invalid.
Could you explain what you mean? I'm really getting the impression we're
talking about cracking an encryption key, and I don't see how revoking
such a key would help significantly for that.

@_date: 2014-07-14 20:50:59
@_author: Peter Lebbing 
@_subject: how to do 
The scenario painted is this:
The primary key is used for creating new UIDs and certifying other
people's keys.
The subkeys are used for signing data and messages, and for encryption.
The "authorized people" who can do decryption and signatures simply do
not have access to the key material of the primary secret key; they have
only been given the secret subkeys.
They are cryptographically prevented from adding UIDs or certifying
other people's keys because they only have the public key for the
primary key.
For example, in the case of RSA, there is no copy of the two large
primes of the primary key on their computer; not even an encrypted copy.
The data is simply absent.
The primary key and the subkeys are independent from a cryptographic
standpoint; it is only by (signed) data that they are linked, not by
math. This is precisely the reason why this works, so I suspect you've
accidentally left out a negation in that sentence or put one in too many.
GnuPG uses a "dummy-S2K" for this purpose, which signals that what
follows is not actually private key material, but an omission of that.
It looks like this when using --list-packets:
:secret key packet:
        version 4, algo 1, created 1331982780, expires 0
        skey[0]: [1024 bits]
        skey[1]: [17 bits]
        gnu-dummy S2K, algo: 3, SHA1 protection, hash: 2
        protect IV:
        keyid: 98B67DE4DCDFDFA4
:user ID packet: "Test Teststra (Koning van Wezel) "
:signature packet: algo 1, keyid 98B67DE4DCDFDFA4
        version 4, created 1405363401, md5len 0, sigclass 0x13
:secret sub key packet:
        version 4, algo 1, created 1331982780, expires 0
        skey[0]: [1024 bits]
        skey[1]: [17 bits]
        iter+salt S2K, algo: 3, SHA1 protection, hash: 2, salt:
        protect count: 1966080 (174)
        protect IV:  ad 80 21 8a a8 71 0f 7a
        encrypted stuff follows
        keyid: 211601B877A3395A
:signature packet: algo 1, keyid 98B67DE4DCDFDFA4
        version 4, created 1331982780, md5len 0, sigclass 0x18
Note how for the subkey it says "encrypted stuff follows" whereas for
the primary key it just says "dummy".
skey[0] and skey[1] are, in spite of their names, public key components
which correspond to pkey[0] and pkey[1] in public key packets,

@_date: 2014-07-18 21:01:54
@_author: Peter Lebbing 
@_subject: symmetric email encryption 
This creates a privacy issue with key lookup. It exposes correspondents
to the keyserver, including time-of-use.
Also, you need to define some negative-acknowledge time to live
(terminology borrowed from DNS). If on first contact an address does not
exist at the keyserver, when do you re-check? And since it can, in
unfavourable circumstances, take a while for a public key to propagate
through the keyserver network, if somebody just created an e-mail
address and key and uploaded it, then starts communicating, people will
check a keyserver and not see the key. Now their client will wait the
defined period before re-checking, adding even more to the propagation
Thirdly, if this is the default mode of operation, I think you need
automatic decryption before storing the mail, because searching mail is
an important feature, and searching encrypted mails a big usability
issue. An e-mail system with a default big usability issue will get
swapped out for a more pleasant to use one.
Finally, I think people might take issue with their e-mail address
automatically being posted to a public keyserver. And if it catches
wind, and many, many people use it, I think spammers might look again at
harvesting addresses versus generating them. Now it's a small pool to
fish from, but if most people have their address on the keyserver
network, the odds might change.
That said, I'm not commenting on the symmetric encryption proposal,
purely on your encryption-by-default proposal.

@_date: 2014-07-19 14:26:44
@_author: Peter Lebbing 
@_subject: Automatic e-mail encryption 
Pssh. What an argument. Please refrain from such useless rhetorics.
First of all, "trustworthy" is a really ill-defined notion. Should I
give them my credit card? Secondly: why? Why does a keyserver need to be
In fact, why do I even need a keyserver? It's a convenience. But I can
just exchange keys with my peers. I don't need to trust any keyserver
operator. Unless it is silently done behind my back, that is.
Here's an idea: when elliptic curve becomes ubiquitous, simply include
your public key in the header of every e-mail you send. That's way
closer to how SSH works, since it uses only one channel, in this case
the e-mails themselves. Perhaps it would be a good idea to only include
the actual EC public key, and not the whole OpenPGP packet, to keep it
You say signing isn't covered... I don't see why not. Just as you
automatically decrypt; automatically sign.
There still is the large issue of private key distribution. I have
several machines all connected to my e-mail account. It seems to me
there's a *lot* of infrastructure still missing for this to be almost
transparent to the end-user. This topic, if discussed at all, should be
discussed by itself and not as some kind of counter-offer to symmetric
encryption, because the problem space is vastly different.
By the way: if we had a working alternative to SSL/TLS, all the mail
servers could talk to eachother securely without eavesdropping. That way
the contents of e-mails is only exposed on the sending SMTP server and
the receiving SMTP and mailbox servers (f.e., IMAP). The mailbox server
already knows when you use automatic decryption to facilitate searching,
and the receiving SMTP server is probably under the control of the same
people that control the receiving mailbox server. So they are probably
about equally difficult to access. And likewise, the sender will have a
decrypted copy in his Sent folder on his mailbox server, and the sending
SMTP server is again close to that server. So if only we had a way to
properly authenticate SMTP servers, I think we get almost the same
effective protection for the users, albeit without signatures. And this
requires only changes to a "couple of" servers, instead of to all endpoints.

@_date: 2014-07-21 18:23:51
@_author: Peter Lebbing 
@_subject: Automatic e-mail encryption 
Well, I actually meant X.509 and the CA system, which is what is currently
abundantly used in SSL and TLS. If you plug in a different form of
authentication, I think the rest is okay.
Yes. I already explained why I think there is little difference when the mails
are stored unencrypted on a mailbox server. If you only decrypt to local
storage, then I agree.
By the way, regarding DANE as an alternative to the CA system: I think a proper
implementation of authentication through DNS could well be way better than the
CA system: at least you can only be screwed by people having access to signing
keys for the root and the TLD, instead of anyone with access to a CA certificate.

@_date: 2014-07-21 21:56:21
@_author: Peter Lebbing 
@_subject: Automatic e-mail encryption 
I don't think this helps much authenticating one SMTP server to another. Even if
it would be possible, they are usually operated by ISP's; I don't see them using
the WoT for that any time soon.

@_date: 2014-07-24 12:27:36
@_author: Peter Lebbing 
@_subject: mailto with pgp fingerprint 
I've just scanned through [1]. I'm not convinced.
This quote is from the front page:
This one from [1]:
The basic reasoning seems to be: if you want multiple websites to report
incorrect data to the user, you need to hack multiple websites.
You only need to be able to MITM close to the victim, and manipulate all
data your victim sees. There's no need to hack any server; you only need
to hack one router and be able to fake SSL certificates. No matter how
many accounts you "link", github, twitter, facebook, security is not
increased against a MITM close to you.
If they thought of this, why is there no mention at all of a MITM'ing
It's perfectly possible to write a program that scans all data for
OpenPGP signatures by a specific key, and replaces them on the fly by
OpenPGP signatures by another key. There's no need to MITM all SSL web
traffic: just do the keybase.io traffic, parse the response, and then
MITM the sites mentioned by keybase.io, which the keybase client will
now check.
A laptop "on the move", *not* always using the same VPN, might quickly
escape from the attacker and see the real data. However, the damage
might already be done. You might already have given your attacker that
plaintext that you were so worried about that you encrypted it.
The documentation in [1] is superficial, and my analysis is even more
superficial. This is just something that stood out to me.
[1]

@_date: 2014-07-26 13:40:25
@_author: Peter Lebbing 
@_subject: Where to save passphrases? 
I completely agree.
If an attacker has physical access, you've lost; game over.
I highly suspect gpg-agent marks memory pages with key material as non-swappable.
By the way, I think passphrase caching in gpg-agent is a rather common deployment.

@_date: 2014-07-29 19:02:59
@_author: Peter Lebbing 
@_subject: CRC error 
This is a really, really bad idea. Please don't invent your own crypto.
For instance, I only need one seventh of your secret RSA key to fully
reconstruct it using the public key I also have! Looky here at an RSA
private key{1}:
:secret key packet:
        version 4, algo 1, created 1300458324, expires 0
        skey[0]: [2048 bits]
        skey[1]: [17 bits]
        skey[2]: [2046 bits]
        skey[3]: [1024 bits]
        skey[4]: [1024 bits]
        skey[5]: [1024 bits]
I myself can reconstruct your private key if I either have skey[3] or
skey[4]. I can decrypt your messages if I just have skey[2]. And I think
someone who actually knows his stuff can do it with skey[5]; I might be
able too if I read up on the Chinese Remainder Theorem{2}.
And I can see whether it worked or not, so I can just take the one you
didn't damage.
Again: give me your public key and the 1024 bits of skey[3] and I can
compute your private key. Using only a seventh of the whole secret key
packet. And this "secret key packet" isn't even the full secret key that
you are wilfully damaging; there are even more packets in there,
including completely harmless ones that won't bother an attacker the
slightest bit. You might make the attacker laugh, though.
Don't be creative! You need either a good passphrase or good physical
protection or both, not some mangling of data.
Oh, the suspense! Are you Pedro, .... or not? Tadadadaaaaa..... ;)
Oh, I see it. The ~ is a logical not, so it's a double inverse, so
either you're Pedro or you converted Pedro to a boolean, depending on
whether you ask a logician or a C programmer...
{1} To reproduce: make a test key that you don't password protect.
Suppose the key ID of your test key is AB1256CD34, enter the following:
$ gpg2 --export-secret-key AB1256CD34 | gpg2 --list-packets
But first understand what that command does, because you shouldn't type
in commands that strangers tell you to type in.
{2} For context for people who know what I'm talking about but don't
know the order of components by heart, the 5 MPI's are, in order: n, e,
d, p, q and u (u = p^-1 mod q).

@_date: 2014-06-08 18:28:55
@_author: Peter Lebbing 
@_subject: Docs central, with 'Email Self-Defence' 
There is a /lot/ of bad advice out there; I'd be wary of linking to it.
There is no single best way, a lot of bad ways, and a lot of clashing outspoken
In my humble opinion, the best advice is: stick to the defaults, they are there
for a reason. Unless you have a specific threat model, in which case, good for
you, work with that, not your gut feeling.
Just my 2 cents,

@_date: 2014-06-08 20:59:41
@_author: Peter Lebbing 
@_subject: Docs central, with 'Email Self-Defence' 
This one seems easy... leakage of the revocation certificate is much more
benign. No secret stuff is compromised, and in order for the leakage to be
useful, your adversary would need to publish the revocation certificate, so you
would notice. This in stark contrast with the private key, which can be used
without you noticing, to read your secrets. And any new secrets produced in the
future, on account of you not noticing.
So the storage requirements for the revocation certificate are much less
demanding than for the backup secret keys, meaning there are more places you can
keep it, meaning you have a higher chance of still being able to access it.
... because a revocation certificate is only useful when the key backup is lost.
So obviously you should make sure that they are stored separately. This is one
of the silly recommendations I've also seen: store your revocation certificate
with your private key. That only covers the case of forgetting the passphrase;
in all other cases it's useless (I think). And that's hoping you didn't use the
same passphrase with your "encrypted USB-drive" and lost access to the
certificate as well.
It all boils down to: "a safe backup" depends on what you are backing up.
The problem lies in "qualified". I think the authors of the bad advice consider
themselves qualified, for instance. Otherwise why are they giving advice.
Hmmmm... this is the internet. I don't think you can keep the bad advice off the
net. You need to have the good advice in a prominent place. But maybe that's
what you meant.

@_date: 2014-06-15 23:39:38
@_author: Peter Lebbing 
@_subject: Docs central, with 'Email Self-Defence' 
Is there really that much flux in the crypto world? It seems rather steady to
me. Things which seem stable stay stable, things which seem suspect, stay
suspect. Generally.

@_date: 2014-06-17 12:18:09
@_author: Peter Lebbing 
@_subject: mascot_p 
I think a mascot would be nice. Is there some especially secretive animal? Some
animal that hides stuff? Or just a nice animal, something cuddly like a
pufferfish. Erm.

@_date: 2014-06-27 19:46:45
@_author: Peter Lebbing 
@_subject: On the advisability of stronger digests than SHA-1 in OpenPGP 
I think it's possible a good portion of these users have custom-written software
that's integrated into a larger system, which uses PGP. So even though GnuPG is
free to use, they'd still have to contract some software development company to
integrate it into their custom software.
I'm purely speculating, however, it doesn't seem an unreasonable case where it's
not just obtuse "I don't like change".
Plus, you still need to pay your system administrator or similar to deploy all
the changes, and the lost productivity of your employees while they get used to
the new system.
And this not because management wanted it, but because people on a mailing list
thought this would really be the best for you. Never mind that in the current
economy you're worrying whether you can afford to keep that young father or
mother employed and keep your business running. Fire that guy/gal, and get
yourself some SHA-256. Okay, now I'm getting a bit carried away ;). If you
didn't like this last bit, here's the start: ^H^H^H^H^H
I however have no clue what you expose yourself to when you still use PGP 8.x.
It could be possible that these guys take irresponsible risks, I don't know.

@_date: 2014-06-27 19:48:46
@_author: Peter Lebbing 
@_subject: On the advisability of stronger digests than SHA-1 in OpenPGP 
Oops, I missed this post when I wrote my own; quite some overlap there. Sorry
about that.

@_date: 2014-03-08 10:42:36
@_author: Peter Lebbing 
@_subject: Size of client key jumped from 2KB to 25KB 
You can inspect the data with a command like:
$ gpg --list-packets "C:/Documents and Settings/steve.strobel/Application
(that's one line)
It will spew a lot of stuff like the following:
:public key packet:
        version 4, algo 1, created 1258029184, expires 0
        pkey[0]: [2048 bits]
        pkey[1]: [17 bits]
        keyid: AC46EFE6DE500B3E
:user ID packet: "Peter Lebbing "
:signature packet: algo 1, keyid AC46EFE6DE500B3E
        version 4, created 1382876493, md5len 0, sigclass 0x13
:public sub key packet:
        version 4, algo 1, created 1258031707, expires 0
You can send me the oddly large key and a normal one, and I can take a look at
it and compare them. I won't spend a whole lot of time on it, but it sounds like
it will rather stand out, since it is, well, large :).

@_date: 2014-03-10 22:40:25
@_author: Peter Lebbing 
@_subject: Size of client key jumped from 2KB to 25KB 
A short reply, because this is not the time.
I wouldn't have said so either, because as I understand it, you are generating
the key, so it does not have any signatures from others yet.
This is a self-signature, a signature made by the key itself. I'm fairly sure
Johan was talking about signatures from other people.
Perhaps it created a whole bunch of self-signatures?
Could you still send me the overlong key and one that has been "correctly"
generated? I'm curious if we can figure out what it was. That's all it is to me,
a hobby :).

@_date: 2014-03-11 22:00:40
@_author: Peter Lebbing 
@_subject: Resetting an OpenPGP smart card "bricks" it 
You forgot the 'scd' prefix on reset. That might be the problem.

@_date: 2014-03-12 16:21:21
@_author: Peter Lebbing 
@_subject: Resetting an OpenPGP smart card "bricks" it 
Back in January, in a similar situation, I found[1] someone had written a little python script[2] to send the APDU's. If the smartcard isn't pleased by the order of the two APDU's, try them in reverse order (the code is easy to read).
[1] [2]

@_date: 2014-03-12 19:38:46
@_author: Peter Lebbing 
@_subject: Resetting an OpenPGP smart card "bricks" it 
That is probably because the program didn't recognise the exact status code, but
was able to place it in the class "NVRAM not changed". The class is defined in a
different standard than the exact status code, and the program gives the best
interpretation it can.
That's indeed a nice thing to have, although the "SERIALNO undefined" method in
scdaemon means that I wouldn't have to start pcscd since it uses the GnuPG
internal CCID driver, and thus requires less keystrokes for me to use in
practice :). But scriptor's more verbose status logging can come in pretty handy
I suppose.

@_date: 2014-03-27 16:52:46
@_author: Peter Lebbing 
@_subject: GnuPG encryption with key file 
Plus that it has the same problems as
$ echo mysecret|gpg --passphrase-fd 0
That is, it ends up in your history if your shell keeps a history and you don't prevent it, and other users on a multi-user system can see the passphrase / the specific file used as a passphrase in the process list.
These issues wouldn't exist if GnuPG actually *supported* key files, and would prompt for the key file as it does for a passphrase. That's why I simply said "no", as in "it is not supported". But you can hack it Also, key files easily lead to security-by-obscurity implementations where people think "an attacker doesn't know which file I use", whereas the attacker thinks "let's try all files, that's computationally feasible". But obviously that depends on the way you use it, it's just something to be aware of.
I would consider this an advantage: the actual session key has good entropy, and the file is just used to encrypt the session key. Even if a "key file" would be properly supported by GnuPG, I would still prefer this two-step approach.

@_date: 2014-03-27 17:47:06
@_author: Peter Lebbing 
@_subject: GnuPG encryption with key file 
I don't understand what you mean with "this way", could you explain? I must be
reading it differently than you.
I don't think it would be an improvement either. I've never really believed in
keyfiles in general. Especially because to everything else it is "just a file"
instead of "highly sensitive secret data". This means you have to be very
careful when handling the file, and assumptions by the tools you use (with
regard to swapping out, etcetera) can be detrimental to the security.

@_date: 2014-03-28 12:48:52
@_author: Peter Lebbing 
@_subject: GnuPG encryption with key file 
I suddenly realise that in the "problems" I mention I'm making the exact same
mistake as the one I'm warning for: I'm assuming that it is secret which file
you use, rather than that the contents of the file is secret.
If some other user on a multi-user system can see which file I'm using, but
doesn't have the rights to access the contents of that file, they are none the
So the "key file" method /is/ better than echo passphrase. It's still a risky
thing to use, in my opinion, though. And the hack presented doesn't allow for
the common scenario: a key file *as well as* a password. It might be possible to
hack that in as well.

@_date: 2014-05-01 11:57:42
@_author: Peter Lebbing 
@_subject: Access to www.gnupg.org only via TLS 
However, how many of the free StartSSL certs that the owners now wish to revoke
have actually been compromised by Heartbleed? Peter Eckersley of the EFF raised
this aspect in [1]. That the owner revokes the cert because it ran on a
vulnerable OpenSSL installation does not mean the key has been compromised; it's
a precaution because it was a possibility.
I'm torn on this issue. I feel StartSSL should do free revocations in such
cases, but I don't think it's fair they have to burn a lot of money because
another party, the OpenSSL dev team, made a mistake. I have no idea what it
costs in man hours to revoke all those certificates, and I have no idea about
the financial situation of StartSSL.

@_date: 2014-05-02 11:36:41
@_author: Peter Lebbing 
@_subject: UI terminology for calculated validities 
So did you read the description? Let me quote from that very section:
It is simply a wrapup of the information that follows on the validity of the
UID's on the key.
And this is also what that "validity" is in:
Although that is a rather poor example because it has ultimate ownertrust, so
it's always ultimately valid. But the entry refers to field 2 of a pub record in
the --with-colons output, AFAICT.
So when verifying a signature, the UI should simply display all UID's, or
possibly all valid UID's. Guess what? At least the command line does:
I have only signed that one fully valid key.
All this stuff is simply related to how things are presented to users, they are
not an essential part of how it actually works. I'd say a feature request to
only display valid UID's on signatures might have merit, but I still don't see a
technical reason to equate validity with just a key.
In the case of signatures, you definitely need to know who signed it, not just
that it is a valid signature. And I can't tell that from just the key ID[1], I
need UID's. If some hacker I validated sends me a signed message "Here, copy
paste this to your command line", I might not listen even though it's a valid
signature. If the signature was from the trustworthy IT guy who is helping me
solve some issue with my PC, I'd just do it. That's why you need more
information than "this is a valid signature".
This is just wrong. Validity is always calculated for couplings of keys and
UID's. However, when you certify a UID, that certification indeed comes from
your key, not your UID, so /ownertrust/ is assigned to a whole key rather than a
UID. This means that deeper in the certification chain, validity of a UID is
calculated based on the trust assigned to a key, not trust assigned to a UID.
So yes, ownertrust is indeed associated just with a key, not the UID's.
This is not the same as "validity is calculated over keys", which is much too broad.
[1] Which might not even be unique; and fingerprints are long!

@_date: 2014-05-02 15:38:55
@_author: Peter Lebbing 
@_subject: Access to www.gnupg.org only via TLS 
Well, unexpected to some extent. The policy, which you attest to have read when
you get the certificate, clearly mentions this fee. That you need to pay it now,
that is unexpected, that the fee is there is properly agreed to.
I just think it's important to note this difference, as I get the feeling some
people are suggesting that the fee itself was unexpected, which I find dishonest.

@_date: 2014-05-02 17:12:46
@_author: Peter Lebbing 
@_subject: Signature without policy meaningless? (was Re: UI terminology for 
I don't quite understand. If I know someone, I can talk with them about how they
verify ownership before they sign. Then I can judge whether I agree and assign
ownertrust accordingly.
If I don't know them, I wouldn't assign ownertrust even if their policy came
with sparkles, glitter and a free magazine subscription.

@_date: 2014-05-02 19:21:59
@_author: Peter Lebbing 
@_subject: Signature without policy meaningless? (was Re: UI terminology 
For yourself or as a public statement?
For yourself, it's as easy as signing the key, and then assigning "I do NOT
trust" as ownertrust to that person. So you can do what you want, unless I
misunderstand you.
As a public statement; now we're going into trust signature territory, which is
not really a common deployment in the WoT. But I guess you could simply make a
normal signature instead of a trust signature. True, you do not make a public
statement of distrust, but you don't make a statement of positive trust either.
An example would be when the HR department of your employer signs a key of one
of the employees who is not supposed to be introducing other people into the Web
of Trust, which actually would happen more often than not. The HR department
would simply issue a normal signature. Now when there's a new HR person who is
supposed to introduce other employees into the Web of Trust, they would issue a
trust signature to that new HR person.
But without trust signatures, your exportable signatures do not indicate that
you trust that person to certify others; they make no statement about that
aspect at all. It only potentially influences validity, never ownertrust.

@_date: 2014-05-14 11:12:12
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to quantum cryptography 
Brute-forcing a 128 bits key is, as far as we know, impossible without
destroying a large part of the earth in the process.
Also, you're really broadening from "some things are suspect" to "all things are
suspect", but let's not delve into that too deep. I might have to ask Robert how
comfortable his new asbestos longjohns are.

@_date: 2014-05-15 17:44:47
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to brute force 
Whoops, I mixed up one million and one thousand. Always makes me
realise I don't do physics calculations often enough, and feel a bit
ashamed :). Let me slightly redo that:
Leo called it 10^5, Rob called it 10^6. Let's take the more
conservative one for argument's sake. If you save 63 bitflips on a of one hundred thousand, that doesn't change the final numbers in the
least. Pull out some hairs and you still have a beard: 10^5 - 63 = Incidentally, we went from 100 nuclear warheads to 3 to 100,000[3].
[3] Or a million depending on whether 2^128 is better approximated by
10^38 or 10^39, when you're really nitpicking. Which you shouldn't do
when discussing exponential complexity. Let's say that with
exponential complexity, your fingers are too large to pick a nit.

@_date: 2014-05-15 18:55:08
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to brute force 
Oh, definitely. Unless our understanding of computing at the physical limits drastically changes, I think blunt-force cryptanalysis is way better than brute-force.
Decryption using a wrench rather than a key;  (don't forget the on-hover text!)

@_date: 2014-05-16 16:48:10
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to quantum cryptography 
You cannot get bits of cryptanalytic progress for brute-force.
Brute-force is by definition completely independent of such things.
And nobody here claimed a realistic estimate. All that was claimed was a
lower bound.
What does the specific cipher used have to do with anything? Since I
don't see where in the thread you replied, I'm not sure if we're still
debating quantum cryptography or that we're discussing brute-forcing.
Quantum cryptography was only discussed relating either to asymmetric
crypto, which AES isn't, or in relation to Grover's algorithm, which is
used to brute-force an algo.
When brute-forcing, the choice of algorithm is irrelevant by definition.
AES is simply used as an example, but the stuff discussed so far would
go for any symmetric algorithm with a 128-bit key. Only the number of
bitflips per trial would vary, which was never really established
anyway, but tentatively put at "quite a lot".

@_date: 2014-05-17 10:51:40
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to brute force 
I admit this is beyond my knowledge, but maybe the following is rather
intuitive and not too incorrect.
"Flipping one bit" is not enough. You don't make any progress toward a
solution if you only keep flipping the same bit. At the least, you need
to decide to flip which bit. That is also information, information that
is not stored in the resultant bit array where you flipped one bit.
More in general, I agree with Rob that this is not a physics course, and
this is just a thought I had and wanted to share.
You can't object to scientific theories on the basis that you did not
study them properly. It might have a bit of a Socratic feel to it, but
it quite falls short of the real thing.
Physics and computation at this level are pretty unintuitive, I think.
Maybe my little attempt to introduce some intuition about information
content is grossly wrong, and maybe it's a folly to attempt intuition at

@_date: 2014-05-15 14:30:55
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to brute force [WAS: Re: GPG's 
(This mail originally got dropped by the list managing software because
I had accidentally misused a new webmail plugin. I'm resending it
with all original identifiers so it hopefully threads correctly. I'm
also completely ignoring section 3.6.6 of RFC 2822, but who cares? ;)
I suddenly realised something about Rob's Crypto FAQ[1]. You state that you need 64 bitflips per attempt, because otherwise your attacker can simply adapt his key to the order in which you try them. But to save on those 64 bitflips, you could also simply do the whole keyspace in order[2]. Your expected number of computations does rise from 2^127 to 2^128, because obviously everybody will then use the key 2^128-1, which is the last one you try ;).
The save of 64 bits to 1 bit loses you 6 bits exponential complexity, the increase of the expected number of tries increases it again by 1 bit, so you have saved 2^5 = 32 = 10^1.5 on the numbers Rob gives. When I'm quickly reading through the calculations, it seems we changed it from 100 nuclear warheads to only 3, to scan the whole keyspace.
However, this whole thing completely falls apart. We were able to save 63 bitflips per trial in exchange for a twofold increase in total work. In the math done in [1], this changes the feel of the numbers radically, because to us, the difference between 3 and 100 is big (it's not when discussing exponential complexity). But that is because (at least) one very large source of bitflips is not looked at: the number of bitflips one trial of a key actually takes. Leo called it 10^5, Rob called it 10^3. If you save 63 bitflips on a total of a million, that doesn't change the final numbers in the least. Pull out some hairs and you still have a beard: 10^3 - 63 = 10^3. Incidentally, we went from 100 nuclear warheads to 3 to 1000[3].
The thing I'm saying is: the explanation for taking 10^2 as the amount of bitflips for a single try doesn't seem convincing. It makes it seem that you can actually save computation by linearly searching your [1] [2] Actually, make that Gray code order, which actually achieves 1 bitflip changes per succession, unlike normal binary encoding.
[3] Or 10,000 depending on whether 2^128 is better approximated by 10^38 or 10^39, when you're really nitpicking. Which you shouldn't do when discussing exponential complexity. Let's say that with exponential complexity, your fingers are too large to pick a nit.

@_date: 2014-05-17 18:51:28
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to brute force 
I think the register bank in a processor is still implemented as flipflops, and all computation ends up there (on a register machine)[1], so your statement is correct in that respect. A register bank is a RAM.
However, the word "normally" is not quite apt. What you normally call the RAM of your computer is DRAM, and DRAM is implemented by a charge on a capacitor. This achieves much higher densities on a chip than SRAM, but is also slower.
[1] Alternatively, in the registers between pipeline stages of the processor. If somebody knows about the latest CPU techniques and disagrees, by all means, enlighten me :). My knowledge pretty much ends at basic pipeline design, and is not up to speed with current CPU

@_date: 2014-05-17 20:09:16
@_author: Peter Lebbing 
@_subject: GPG's vulnerability to brute force 
Absolutely, no argument there. In fact, currently, we can't make transistors work without capacitance, and a flipflop is built of transistors, so the parallels go even further.

@_date: 2014-05-18 13:52:52
@_author: Peter Lebbing 
@_subject: gnupg smartcard on boot for LUKS on sid debian howto ? 
That's a pity it doesn't work on sid. I've been meaning to look into
this since you brought it up, and I finally made some time to do it.
Since I think Sid is a nasty kid who plays much too roughly with my
toys, I used Jessie, and it does work there. Looking at the Debian bug,
I think they'll fix it.
What I would really like, by the way, is if you clicked an unopened
encrypted volume in your file manager, and it would prompt for your PIN
through pinentry. But that doesn't work yet. Unlocking the root
filesystem and other filesystems that are unlocked on boot does work.
You can check out what I did on
I haven't tried it on Wheezy yet (I will), but I think it will work
there as well.

@_date: 2014-05-18 22:04:18
@_author: Peter Lebbing 
@_subject: gnupg smartcard on boot for LUKS on sid debian howto ? 
pcscd is not installed in the initramfs :). So your reader should be
supported by the internal driver of GnuPG for it to work.
You might have noticed you can optionally put a gpg.conf in /etc/keys
(or wherever your key is) and it will be copied and used in the initramfs.
Good luck,

@_date: 2014-05-18 22:31:20
@_author: Peter Lebbing 
@_subject: gnupg smartcard on boot for LUKS on sid debian howto ? 
No, that means something is wrong. It will always call the hook, even
when you don't use encrypted volumes at all. But when the hook
determines it has nothing to do, it will exit without any messages. So
apparently the hook thinks you don't need it to do anything. That's bad,
PS: Yeah, scripts don't think. I think. I /hope/. I kill those things

@_date: 2014-05-19 20:01:38
@_author: Peter Lebbing 
@_subject: gnupg smartcard on boot for LUKS on sid debian howto ? 
Indeed you will only get the messages when it's the root drive you want
to unlock. I haven't tested other configurations. I think it ought to
work for other volumes that are unlocked on boot.
Is your card reader supported by GnuPG's internal CCID driver or do you
need pcscd for the smartcard to work? Related question: Is pcscd usually
As I said, your smartcard reader really needs to be supported by GnuPG's
internal driver, it will not work if pcscd is needed. The messages seem
to indicate that pcscd is needed.

@_date: 2014-05-20 11:09:13
@_author: Peter Lebbing 
@_subject: recv-keys on e-mail instead of keyid 
I think you're looking for the command --search-keys.

@_date: 2014-05-20 11:20:18
@_author: Peter Lebbing 
@_subject: Diffie-Hellman Key Establishment 
What DH key establishment do you mean? Are you referring to ElGamal subkeys?
That sounds like random number generation, which is applicable to all
secrets, not just DH. I wouldn't trust myself devising a random number
generator, though[1].
[1] At least, not one I would protect secrets with. One to replace my
dice for a board game is fine ;).

@_date: 2014-05-21 20:58:10
@_author: Peter Lebbing 
@_subject: gnupg smartcard on boot for LUKS on sid debian howto ? 
I'm sorry that I currently don't have the time to help you properly.
I used an SCM SCR3310 while "developing" the scripts, but on my main PC (which I
did not use), I use an SCM SPR532.
Yesterday, I suddenly realised that your problem might be related to the fact
you have a pinpad. The script uses cryptsetup's askpass program to pass a PIN or
passphrase to gpg on stdin; perhaps it goes wrong because this is combined with
input from a pinpad, which would be an odd way to call gpg.
The scripts are pretty simple bash scripts; you could adapt them or try the
invocations done in the script from a root terminal and see what they do.
Oh, which reminds me. At least on Jessie, the askpass program disables echoing
and never re-enables it, so you can't see what you are typing after calling it.
(Blindly) type "reset" and press enter to reset your terminal settings, which
re-enables character echoing. I suppose it's a bug and should be reported.

@_date: 2014-11-02 12:38:58
@_author: Peter Lebbing 
@_subject: Is gpg-agent passphrase status query possible? 
This is the same channel as where session keys are exchanged. With a
session key, you can decrypt an encrypted message: very sensitive
information. So the channel in itself is secure; it all depends on the
application that uses it. I don't know if there are any other
applications than GnuPG itself that use the agent[1], but in your
scenario it would seem to be GnuPG itself and hence be secure.
IIUC, your question is whether it's principally possible for Enigmail to
decrypt only when you will not be prompted for the passphrase or PIN.
The GET_PASSPHRASE --no-ask seems ill equipped to do that. Even apart
from the raciness, Enigmail is quite far away from the agent interface.
I /think/ Enigmail simply executes the gnupg binary, defaulting to
v1.4.x which doesn't even necessarily use the agent! What seems to be
needed is a --no-ask command line option to GnuPG 1.4.x or 2.0.x. This
would, in the case of an agent, most likely translate into an agent
command PKDECRYPT --no-ask (which also doesn't exist yet).
So I think the answer is: without ugly hacks which also involve races,
no, Enigmail cannot currently decrypt only when it would not lead to a
But perhaps things will completely change with the new GnuPG v2.1.x?
By the way:
$ gpg-connect-agent "help pkdecrypt" /bye
# PKDECRYPT # Perform the actual decrypt operation.  Input is not
# sensitive to eavesdropping.
I've looked at the source (2.0.26), and there are no options. Is this
 still a relic from something that was once there, or planned
to be there? Why is it  instead of [options] anyway? :) Surely
that's a typo.
[1] I'm excluding gnome-keyring-daemon on purpose, since it's not using
but rather abusing.

@_date: 2014-11-02 12:59:30
@_author: Peter Lebbing 
@_subject: Broken mirrors 
It is a bit unclear to me where you should report broken mirrors or
whether you should do so at all; I thought I'd best just post it here.
ftp://ftp.surfnet.nl/pub/security/gnupg/ seems to only hold directories,
no files.
ftp://ftp.demon.nl/pub/mirrors/gnupg/ -> that directory doesn't even exist.
It seems that you can ward off the seven years of bad luck by either
burying the broken mirror under a tree or grinding it into very small
bits. What a shame to do that to a good server, but it's still better
than seven years of bad luck!

@_date: 2014-11-05 16:15:18
@_author: Peter Lebbing 
@_subject: Help needed to setup Passphrase with GNUPG 2.0.26 on Solaris 10 
You weren't entering a passhprase there. If it were asking for a passphrase, it wouldn't show your typing. Instead, your input was most likely simply not processed and echoed on the terminal. Try this and see what I mean:
$ sleep 10
Just type anything interesting in the 10 seconds the program sleeps
$ Just type anything interesting in the 10 seconds the program sleeps
That last line will be the new prompt with what you just typed echoed Are you sure there is an error? I interpreted it as that the Qt pinentry was simply not built, but the others, and the wanted curses pinentry was. Were there any binaries generated by the build?
See? If it's not going to build the Qt version, why would it need any Qt headers?

@_date: 2014-11-05 17:16:13
@_author: Peter Lebbing 
@_subject: Help needed to setup Passphrase with GNUPG 2.0.26 on Solaris 10 
Right, yes, I agree. I focussed just on the latest question and lost the context.

@_date: 2014-11-05 21:11:26
@_author: Peter Lebbing 
@_subject: Help needed to setup Passphrase with GNUPG 2.0.26 on Solaris 
Is it perhaps possible that you only notice the contributions to this
thread that are explicitly mailed to you, as opposed to the ones that
are only addressed to the mailing list?
Because there are several contributions on the mailing list that you
don't seem to notice. I'm talking specifically about the suggestion by
Robert J. Hansen that it seems that you might be much better served by
GnuPG 1.4.
I really suggest you look at that, perhaps returning to the mailing list
if there are any further issues.
As an aside, a pinentry for Qt is of no use when you use PuTTY to
connect to the server, unless you have a very specific setup. I think
you would need an X server running on your Windows machine to get that
working. I used to have that a long, long time ago. It was quite a
hassle to set up and frequently needed a good kicking to keep chugging
along ;). It was not a well-oiled machine at all.

@_date: 2014-11-06 14:25:21
@_author: Peter Lebbing 
@_subject: gpg-agent forwarding (was Re: Help needed to setup Passphrase with 
I think this certainly has its upsides, running the agent on the console
of the user instead of the system they ssh into. If the agent is simply
used as a method of password entry, the password is passed over the SSH
connection just as it is when entering the password in a curses pinentry
running on the system where gpg runs. When it's used with a smartcard,
this would mean the user can use it on his console, possibly even
entering the PIN on the pinpad of the reader. When it's used as it is in
GnuPG 2.1, the whole setup changes (as it does for the smartcard, btw),
because now the private key needs to be on the console instead of the
server running gpg.
But there are security issues.
How would this be implemented? I can think of two options: a TCP port,
forwarded by PuTTY, and an SSH subsystem.
Assume it's a TCP port listening on the console.
A TCP port is accessible by anyone. Even when you restrict it to
localhost, this exposes it to any other user on a multi-user system.
With the traditional setup, I think usually only root/admin/... and the
intended user can access an agent. On Linux, I think you can get the
owner of the socket, so you could simply verify the UID. But this is
non-portable. When you use a cookie to control access, you need a way to
get that cookie to the server where gpg is running. This could be solved
by instructing the user to copy the text of the cookie, presented by a
pinentry dialog, to the server. A separate helper "gpg-setup-cookie"
perhaps, invoked sometime after the user logs in (or when they do) and
before they use gpg.
Additionally, I think a TCP port might tempt people to construct truly
unsafe constructions, where the port is not forwarded by an SSH client
or otherwise suitably protected.
But perhaps an SSH subsystem is a nice alternative? This would change
the direction of initiation: the agent would need to connect to the
server via SSH. But it does include full user authentication and
provides a secure channel.
An SSH subsystem is, broadly, simply an SSH connection, but instead of
starting a shell and sending standard input and standard output over the
SSH channel, it starts a specified command with its stdin and stdout
sent over the SSH channel. This is also possible without using a
subsystem, but subsystems are specifically tailored to SSH. Though maybe
their primary feature is the possibility to enable access to subsystems
without enabling shell access, which is not needed in this case.
My 2 cents,

@_date: 2014-11-06 15:56:18
@_author: Peter Lebbing 
@_subject: What's new in 2.1 FAQ: Corrections, suggestions 
Hello Werner and list,
While reading that FAQ top to bottom, I encountered some typo's which I
fixed. I'm only used to git in a non-distributed fashion, so I'm not
accustomed to it's patch submission features and simply attach a
git-generated diff against 0968808. I hope that suffises.
And perhaps this needs clarification:
When I read this, I think, do I need this:
$ gpg2 --quick-sign-key '15CB 723E 2000 A1A8 2505  F3B7 CC00 B501 BD19
AC1C Daniel Ellsberg '
Or do I need this:
$ gpg2 --quick-sign-key '15CB 723E 2000 A1A8 2505  F3B7 CC00 B501 BD19
AC1C' 'Daniel Ellsberg '
In other words, is it one argument or two arguments? I'd be inclined to
the latter when thinking how I would design this, but I'm inclined to
the former by the phrasing "after the fingerprint". An example would
remove ambiguity.

@_date: 2014-11-06 16:09:01
@_author: Peter Lebbing 
@_subject: gpg-agent forwarding 
Sockets other than TCP you mean? Is this something generic that can be
invoked by using the command-line OpenSSH client? I can't find it.
Right, connecting to it was what I was referring to. And since I was
thinking about just using a forwarded TCP connection, the nonce/cookie
needed to be known to gpg running on the server, hence my elaborate
construction. If you include functionality inside the SSH client, this
is obviously not needed. Were you thinking of writing that functionality
for OpenSSH on Linux as well?

@_date: 2014-11-06 16:15:57
@_author: Peter Lebbing 
@_subject: (OT) Re: What's new in 2.1 FAQ: Corrections, suggestions 
Ah, I'm glad to see Muphry's Law is still in effect. The world works the
way it's supposed to.

@_date: 2014-11-06 18:51:38
@_author: Peter Lebbing 
@_subject: With the release of modern, is there intent to support ECC in 
Perhaps this warrants a mention on the what's new FAQ page, for people
that are using 1.4 for that specific reason.

@_date: 2014-11-09 11:18:30
@_author: Peter Lebbing 
@_subject: [Announce] GnuPG 2.1.0 "modern" released 
Hash: SHA1
Oops! Very nice find, kudos!
However, here's a small mistake. This should read:
gpg --verify gnupg-2.1.0.tar.bz2.sig gnupg-2.1.0.tar.bz2
For people not acquainted with this syntax: when --verify has multiple
arguments, the first one is the detached signature and the remaining arguments
are the signed files.
And finally, there is another little thing wrong with the announcement:
That is the list of WWW mirrors. It seems more useful to link to
 .

@_date: 2014-11-10 12:59:15
@_author: Peter Lebbing 
@_subject: Detached signature ambiguity (was: [Announce] GnuPG 2.1.0 "modern" 
That seems extreme. Although you could add commands that make it
explicit what you want, removing the existing, ambiguous one would cause
massive breakage of deployed scripts. Werner is always very cautious
about doing that.
Maybe this avenue of thought can help come up with a good solution. When
people verify a detached signature, they usually have two files named:
If GnuPG encounters this situation, but file.ext.sig is not a detached
signature, it could display a big fat warning:
WARNING: file.ext.sig is NOT a detached signature; the file file.ext is
NOT VERIFIED!
This does create some related issues:
These files can trick people into thinking they have the same filename.
This suggests this is either not foolproof or you need normalisation.
The extent of normalisation seems to make this unattainable. And
combining Unicode characters make matters even worse.
So it definitely has problems. But it might help think of the most
proper solution.

@_date: 2014-11-10 13:16:06
@_author: Peter Lebbing 
@_subject: ECDSA vs EDDSA 
I can give two significant differences between ECDSA and EdDSA:
1) Signature creation is deterministic in EdDSA; ECDSA requires high
quality randomness for each and every signature to be safe (just as
regular ol' DSA). If low-quality randomness  is used an attacker can
compute the private key. Using XKCD's get_random()[1] function as in the
Playstation 3 (as exposed by Fail0verflow) makes it trivial to compute
the private key. More specifically, using the same random number for two
different signatures is enough to trivially compute it.
Werner has mentioned that deterministic operation is a prerequisite for
him to consider an OpenPGP Card smartcard implementation due to lack of
trust in on-card generated entropy.
2) The process by which the actual parameters of Ed25519 have been
chosen is completely open. It is possible to create a backdoor by very
careful choice of the parameters; this means that there exists a chance
that the NIST and (I believe also) the Brainpool curves have been chosen
in a way that there is a secret backdoor only known to the organisation
that selected the parameters.
The parameters I'm talking about are the ones shared by all keys on a
specific curve; the actual private key is still chosen by the creator of
the key and is not what I mean.
Point 1) turns my thoughts to a related issue. Is there still any reason
to include deterministic classic DSA in OpenPGP or is that a bit late to
the party?
int get_random()
That's from memory, it might not be fully literal. Also, that XKCD comic
was actually one of the presentation slides of Fail0verflow; I was there
at the 27C3 when they revealed their hack, so cool!

@_date: 2014-11-10 13:25:53
@_author: Peter Lebbing 
@_subject: Detached signature ambiguity 
Hmmm, very solid point... unfortunately :(. Not a pretty situation to be
in at all...
It still suggests to me it should only break when normally there would
be a detached signature verified (i.e., without the .sig extension) but
it is not because it is not a detached signature. I suppose these
scripts wouldn't work anyway when files are named as in my problematic
So simply returning error in the case where there /is/ a full match
seems to fix the scripting case. It still leaves the user-driven case,
because the user can still be foiled by a single-character change.
It might be possible for an attacker to force a signature verification
failure of a script if he can name files in the same directory. Suppose
a script is supposed to verify ledger.csv.asc, which is /not/ a detached
signature, but simply has the data embedded. An attacker could create a
file in the same dir with the name ledger.csv and cause the ambiguity
detecting mechanism to trigger falsely, leading to signature
verification failure. Whether this is a real issue, I don't know.

@_date: 2014-11-11 11:00:52
@_author: Peter Lebbing 
@_subject: Detached signature ambiguity 
How would the warning be triggered? By the extension of the signature
file or by existence of a file without the .sig extension, or even some
other way?
If the warning is triggered by existence of a file without the .sig
extension, it does suggest to me that people should not rely on the
warning and thus always specify both the signature file and the signed
file on the command line. Because they might infer by absence of the
warning that the misnamed file has been verified, when the warning is
absent because GnuPG never noticed the misnamed file.

@_date: 2014-11-12 14:28:05
@_author: Peter Lebbing 
@_subject: ECDSA vs EDDSA 
That's great to hear, just like it is in general pretty great you got to
release a major new version! Congratulations!
After browsing a bit in the source, I conclude that RFC 6979 is used for
both classic DSA and ECDSA; something not immediately apparent from the
commit message when you don't know the code.
After reading parts of the Ed25519 specification[1], given the way they
formulate it there, I was left with the impression that ECDSA is
necessarily bound to real randomness. I completely forgot that RFC 6979
is cleverly designed to be a drop-in replacement with no changes needed
on the receiving side.
With Pete Stephenson also rightly calling out my wrong statement on the
Brainpool curves, I've come to regret my too hastily written reply. I
should have checked my statements. I already had enough doubt to qualify
my statement with "and (I believe also) Brainpool". There is enough FUD
out there without me adding to that :(.
But I'm glad people were quick to point out my factual errors. Thanks!
[1] Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B. Yang,
"High-speed high-security signatures", Journal of Cryptographic
Engineering Volume 2, Issue 2, pp. 77-89, September 2011,
PS: Is there a better way to say "classic DSA"? What about
"ElGamal-style DSA"?

@_date: 2014-11-19 12:17:19
@_author: Peter Lebbing 
@_subject: Encryption on Mailing lists sensless? 
I agree with several other important points you raise, but this one is not a big
deal. I have a highly customized mail setup. My SpamAssassin downloads rules
from the internet, but trains its Bayesian filter on only the e-mail I
personally receive.
Everyone who has ever sent me a non-spam mail is added to a whitelist. Mail from
whitelisted people never gets automatically moved to the Spam box, and my mail
client shows their messages in a different color. As soon as I receive a spam
mail from such an address, it is immediately (manually) deleted from the
whitelist (actually moved to the greylist so it's not added to the whitelist
again next time).
I have an empty blacklist. It exists, though. It would cause mail to be silently
deleted. Somebody once had the honour of having me create it and put him on it :).
SpamAssassin throws spams in a Spam folder for me to check every few weeks. I
sort them by subject line so I can quickly scan through. Checked spam that I
perceived as spam is still kept around for quite a while, just in case someone
writes to me "I wrote you months ago and you haven't replied". Then I can go
back to everything I've already written off as spam to see if I looked past
their mail.
This setup works great for me. If I get a few false positives in a year, it is a
lot. They are so scarce that I'm completely unsure what the actual number is. I
do get false negatives, but it doesn't feel like more than 10 each week. Every
now and then a short surge of nearly identical spams, though.[1]
I still think your overall point stands, and stands tall. But the spam filtering
issue; from personal experience, I don't think that's a really major issue.
If it were, I'm sure we can think of some way to have publicly available
training data that can be refined by individuals who can feed it back to the
publicly available data. It might need some thought: you don't want to have a
really classified mail which got qualified as spam to upload new words to the
public data. So probably most individuals would only adjust existing weights,
and only some setups would contribute new words. This could come from spamtraps
and organisations or even individuals who send in complete training mails. And
perhaps this all is even not necessary, and the system would be just as
effective with a big corpus of data where only weights are changed by submissions.
But this is all a bit beside the point. The point is that spam filtering works
just fine on an individual level, for me. And if it would create problems, I'm
sure we can think of things that would solve that specific issue.
PS: By the way, some mail is already denied at the mailserver and never enters
the system. The most important instance of this is mail purporting to come from
myself, but not originating from within my own network. Lots of spammers send
you spams from your own address, be it in the envelope or in the headers. I run
my own webmail server, so even if I need to send myself a message and I didn't
bring my laptop, it would still originate from my own webmail server.
[1] Actually that is a case where the distributed solution truely excels:
quickly homing in on the latest mass mailing. The sheer number of identical
mails alone is a big warning sign, and a lot of people will start reporting them
as spam.

@_date: 2014-11-19 12:28:04
@_author: Peter Lebbing 
@_subject: Encryption on Mailing lists sensless? 
They often do, don't they? I doubt that is what is meant, though. If I look in
the Oxford online dictionary:
Definition of charlatan in English:
A person falsely claiming to have a special knowledge or skill
Definition of snake oil in English:
[mass noun] informal , chiefly North American
1 A substance with no real medicinal value sold as a remedy for all diseases
1.1 A product, policy, etc. of little real worth or value that is promoted as
the solution to a problem
These all seem to definitely be how I interpreted Rob's messages. I personally
never read any implication of wilfull deceit, but I'm famous for missing
nastiness sometimes.[1]
I can completely understand you read an implication of wilfull deceit. I doubt
it is actually there, though. Does this help in defusing?
I hope you've already defused by now, because this looks like lighting the fuse.
Hopefully by now it's just a bit of fizzing wire, kept well away from the bomb.
[1] Okay, in light of a recent event: sometimes I see nastiness that's not there! ;)

@_date: 2014-11-22 11:11:07
@_author: Peter Lebbing 
@_subject: Symmetrical encryption or ... 
If I look at the KeePass website, specifically at [1], I see:

@_date: 2014-11-26 20:15:51
@_author: Peter Lebbing 
@_subject: Pros and cons of PGP/MIME for outgoing e-mail? 
1) What does a checksum add beyond the OpenPGP Modification Detection Code (MDC)?
2) Why doesn't an attacker replace the checksum?
Anyway, if you really care about your recipient getting what you sent, you
should simply sign, IMHO, due to 2).

@_date: 2014-11-26 20:15:59
@_author: Peter Lebbing 
@_subject: digest-algo SHA256, SHA-1 attacks (was: Setpref is not working or 
(By the way, how did the topic
- gpg.conf: settings for security and compatibility
ever get confused with the topic
- Setpref is not working or is it a bug or something?
because this definitely is the former but is called the latter. Also,  as you
apparently call yourself, you seem to start a new thread with each post, could
you try to get your e-mail client to properly thread?)
Wouldn't personal-digest-preferences be completely redundant when you also
specify digest-algo? It's going to force usage of SHA-256 anyway.
Now about SHA-1 for signatures on data (/not/ certifications).
As long as you sign only things you produced yourself, one would generally need
a preimage attack on SHA-1 to fake your signature. There are currently no
practical preimage attacks on SHA-1.
The attacks on SHA-1 that are the buzz these days are collision attacks.
But this is *only* a risk if the attacker can get you to sign a document the
attacker created!
If you are in the habit of signing binary documents (say, a Microsoft Word file
or an OpenDocument file), then it might in the future become possible to involve
you in a chosen-prefix collision attack and fake your signature. That is because
there is more in such a file than meets the eye. You think you sign what meets
the eye, you don't see the cruft appendage in that file that was cleverly
included to create a chosen-prefix collision.
This is what it would look like:
Company Alice gives the contract for job X to company Bob, Inc.
However, you wouldn't see that last bit because it is included in such a way
into the file that it doesn't appear on your screen. Still, it is part of what
you sign. The cruft at the end has the purpose to create a hash collision, and
the whole document hashes to b843e5fb9ccef0091fa3e65d2ff349fcb46a6061, which is
what you sign.
Now, the attacker has created a second message in tandem, which reads:
Company Alice gives the contract for job X to company Mallory.
They created this in tandem with his first message, and the cruft at the end is
chosen carefully such that this again hashes to
b843e5fb9ccef0091fa3e65d2ff349fcb46a6061.[1] And again, the cruft at the end is
hidden in the file and doesn't show when you view the document. Now they can
copy your signature, because you signed that hash.
In practice, there are still several problems, such as the time of the signature
being part of the hash and thus not fully under attacker control. It's just a
rough sketch of the problem to give you a feeling for it. The message behind it
is: unless an attacker can get you to sign something the attacker produced, you
don't have to worry about collision attacks. If you use the same key for
certifications and data signatures, then I think a certification is in the
category "sign something the attacker produced", though.
Has something like randomized hashing[2] been considered by the OpenPGP
standardization people?
[1] no, it doesn't, I can't do SHA-1 collisions, I'm sorry :)
[2] for example

@_date: 2014-11-26 20:39:33
@_author: Peter Lebbing 
@_subject: digest-algo SHA256, SHA-1 attacks 
'r' is randomly generated for each signature by the /signing/ party. So the
attacker loses control over the input to the hashing algorithm, and they no
longer can use collision attacks because they don't know the exact input to the
hashing algorithm.

@_date: 2014-11-27 11:07:03
@_author: Peter Lebbing 
@_subject: digest-algo SHA256, SHA-1 attacks 
The purpose of the signature is to ascertain that the OpenPGP message has not
been modified in transit. If you flip a byte anywhere in the message, either in
'r', or in the actual message, the hash changes. This is all the effect it has:
the hash changes; there is no remote code execution or anything :). And since
the hash changes, the message fails to verify as a valid signature.
Are you thinking of a preimage attack where the attacker is now able to vary the
hash of their nefarious message by varying 'r'? If there's a preimage attack
against the hash function, you've lost. Randomized hash or not, it's bye-bye.
I must admit I haven't read the actual specifications and publications
surrounding randomized hashing. But perhaps you should read them if you're
worried; they might answer your questions?
First of all, in the case of an OpenPGP card, the smartcard never sees or comes
in contact with 'r'. It just signs the hash using its private key. I'd assume
this is a common setup for smartcards doing crypto, since you wouldn't want to
feed your multi-gigabyte signed datafile through a smartcard interface. That
would take ages.
I'm fairly sure this side channel does not exist in the current OpenPGP card as
long as you don't use the on-card key generation. And adding randomized hashing
would not change that situation.
And it doesn't make sense when the PC signing your message is the one that is
leaking information through 'r'... If "They"[1] control your PC, it's game over.
Could you get a little more concrete than "I feel it's a huge attack vector"?
It's kind of difficult to argue with, second guessing and all.
[1] I feel "They" should be a 3 letter word, to fit with the parties it usually
refers to. Then again, 4 letter words have a nice reputation as well.

@_date: 2014-11-27 11:28:18
@_author: Peter Lebbing 
@_subject: Randomized hashing (was: digest-algo SHA256, SHA-1 attacks) 
Perhaps I should add that it takes real research and formal proof to show that
this randomized hashing doesn't add attack vectors, and I have been glossing
over that. But that is because at a glance it looks like such research has been
done. That doesn't mean it's a fact that there are no significant attack
vectors, but it does give the scheme credibility.
Here's the abstract of the first paper on [1], by the way:
[1]

@_date: 2014-11-27 14:45:31
@_author: Peter Lebbing 
@_subject: Randomized hashing 
I read this quite differently. I read it as that 'r' is not included in the
signature, that is, what is signed is still just the hash. It seems profoundly
silly to not include it in the signed data, for the reasons you mention. Can you
give a quote that actually says 'r' is not included in the signed data?
Oh, I agree, I already thought that might close any 'r'-swapping security
issues, if there would be any; just like you can include the hash
algorithm in the signature to prevent swapping it out for a weaker one. But when
swapping 'r''s does not actually create any security issues, it just makes
things needlessly complicated. To use your smartcard example: the smartcard only
accepts a specifically formatted message. If you change that message to now
include a new value, you would need a new smartcard. Furthermore, the size of
'r' might pose a problem; it's a significant addition to the data structure that
is signed.
I suppose also simplicity, verifiability, implementation cost...
The rest seems unrelated to randomized hashing except for what I already
mentioned: that including 'r' in the signature would mean you can't use an
existing OpenPGP card. But I'll answer anyway.
For RSA signatures, the padding is constant; there's nothing to generate. For
RSA decryption, the input is generated by the encrypting party; there's nothing
to generate on decryption.
I think you mean "RSA decrypt", for signing you use the "RSA decrypt" primitive,
just as you use to decrypt a session key.
But this is all already done in the OpenPGP card. It checks the data to be
signed conforms to PKCS it is optional to check the DigestInfo, but the rest
of the data structure already differentiates it from an encrypted session key.
It will only let you sign with the "Signing" and "Authentication" keys.
Likewise, it checks that the output of decrypting with the "Decryption" key
conforms to the PKCS format, so you can't fool it into a signing operation either.
Failing to let the card check the padding could lead to major issues. But this
is a solved problem and unrelated to randomized hashing. I don't understand the

@_date: 2014-10-02 21:10:15
@_author: Peter Lebbing 
@_subject: scute for fedora, is it in the =?UTF-8?Q?reppos=3F?= 
Well there's a reply I didn't expect. Can I ask what triggered you to write it?

@_date: 2014-10-03 19:47:11
@_author: Peter Lebbing 
@_subject: [Announce] The maybe final Beta for GnuPG 2.1 
Disclaimer: I'm not Werner, and I'm Dutch.
It is most definitely Staatssicherheit as in "die Sicherheit des
Staat(e)s". It's a genetive, just like it's People's Republic of China
and not People Republic of China.
In my mind, I pronounce the two esses. Not sure how much you would
notice that, though.

@_date: 2014-10-03 21:35:21
@_author: Peter Lebbing 
@_subject: [Announce] The maybe final Beta for GnuPG 2.1 
Please try to get the relevant part of the error message that actually tells
what it didn't find, because the log posted by Pete is cut down too far to
actually tell. You could also include the whole log, I think. Or would that hit
some size limit, either technical or social?
If so, would sharing it as a gist on github be an acceptable way? I've never
seen it suggested on this mailing list, but I encountered it while doing bug
reports, and it seems like a reasonable way to share a big make log...
PS: Please don't top-quote. The usual way to explain it is:
A: Because it messes up the reading order
Q: Why is it annoying?
A: Top-posting
Q: What is the wrong way to quote?
But while remembering this, I'm suddenly reminded of Time-Reversed Owls and I
like that one better now:

@_date: 2014-10-05 21:18:45
@_author: Peter Lebbing 
@_subject: gpg offering to encrypt to an unwanted key 
Remember that a single dash introduces *short* options, so each letter is an
option. I think this becomes:
$ gpg2 --encrypt --dry-run --symmetric --recipient ypt filename.txt
As you see, you've specified the recipient "ypt" because the short option -r
takes an argument, making the rest of the string the argument. The key you mention
has the string "ypt" in its name.
Actually, pinentry asks for the password for --symmetric. The fact that it asks
for confirmation indicates that it is prompting you for a new password, rather
than existing one, which it would only prompt again if you got it wrong.
The command line is a potentially dangerous place! ;)

@_date: 2014-10-13 18:33:10
@_author: Peter Lebbing 
@_subject: Renewal of revocation certificate required after adding a new 
I think that's a good way of summing it up.
PS: You could nitpick about "bound to the fingerprint", I think it
should be "bound to the public key itself". But it makes no real
difference, I'm just being fussy.

@_date: 2014-10-13 18:40:06
@_author: Peter Lebbing 
@_subject: Renewal of revocation certificate required after adding a new 
In fact, I think it is more informative to think of it being bound to
the fingerprint, even though this is not true. The fingerprint
corresponds one-to-one to the public key for all practical purposes, and
the revocation certificate is bound to the public key. However, "public
key" is ill-defined without context. It can also refer to the whole
thing with UID's and signatures and so on, which is not what I mean in
this context.
So, yes, the revocation certificate is on the fingerprint ;).

@_date: 2014-10-14 11:05:18
@_author: Peter Lebbing 
@_subject: Renewal of revocation certificate required after adding a new 
Yes, everything is revoked.
But that is implicitly. What the revocation actually revokes is the
actual primary key itself. It revokes the same part that the fingerprint
is computed over. Mathematically, it is computed over the numbers that
make up the primary public key and its creation time.
So no matter what UID's or signatures are later added (or already
existed), from the moment the revocation certificate is published and
combined with the primary public key, that public key can never be used
Remember that the original question was: do I need a new revocation
certificate when I add UID's? The answer to that is: no, because the
revocation certificate is not computed over the UID's and hence doesn't
So in that sense the revocation certificate is not bound to the UID's as
I stated. However, it does also revoke the UID's in the sense you mean.
Does this make sense?

@_date: 2014-10-15 11:21:18
@_author: Peter Lebbing 
@_subject: Libcrypt examples? 
(the word "of" seems to be missing)
So you're using the wrong tool for the job. Have you thought about using
off-the-shelf full disk encryption, perhaps restricted to a partition
where the data is stored?
Cryptography is very hard to get right. You shouldn't be designing your
own stuff based on such a low-level library as Libgcrypt; you need a
higher level thing where all the important bits have already been done
for you.
That previous paragraph is very important, the most important one of
this mail by a long shot.
That function is for one use and one use only: password storage and
checking. It just has a misleading name.
That is a desirable property in password storage, hence the oddly
looking design choice.

@_date: 2014-10-15 13:00:52
@_author: Peter Lebbing 
@_subject: [Announce] The maybe final Beta for GnuPG 2.1 
Wow, that is one verbose log. I started reading from the top, but
switched to reading from the bottom up, which is more useful for
configure logs. I didn't expect it to be quite that long at first.
Near the end, there's this bit:

@_date: 2014-10-16 19:52:35
@_author: Peter Lebbing 
@_subject: Libcrypt examples? 
I don't consider that a trivial problem, actually. I can think of
many threat models where it is entirely non-trivial. You never mentioned
a threat model.
There was no condescension in there; none at all whatsoever. I don't
consider myself knowledgeable enough to write such an implementation.
And I'm not condescending towards myself.
I'm sorry that you felt it that way; if I had ever considered that you
might find it condescending I would have included a disclaimer. However,
I thought the following two quotes together already made it clear that
it was no condescension.
. If this is how you wish this conversation to go, I don't feel
like helping. When we start out assuming bad faith on everything that in
some completely unlikely scenario could possibly be bad faith, then I am
done with this.
You have my apologies for writing something you misread as
condescending. Other than that, I'm done here.
Good luck,

@_date: 2014-10-17 11:47:36
@_author: Peter Lebbing 
@_subject: Libcrypt examples? 
This is simply not true. I had very little information to go on, but I
did suggest that perhaps full-disk encryption was something that might
be an alternative. That this wasn't a viable solution wasn't something I
could know, but I suggested an alternative.
Other than that, I think I simply do not know any alternatives. I was
happy with Rob's post about Peter Gutmann's cryptlib because I might be
able to use that hint myself one day.
And ultimately, I don't feel like the rest of my contribution somehow
obliged me to point out alternatives anyway.

@_date: 2014-10-17 22:20:29
@_author: Peter Lebbing 
@_subject: Libcrypt examples? 
I only see "Quantum vacuum plasma thruster", but not yours. Kudos on the nice
addition, including followup lines!
I hope you agree this doesn't go for the four letters I just threw in the mix :).

@_date: 2014-10-18 12:55:36
@_author: Peter Lebbing 
@_subject: Libcrypt examples? 
I'm sorry to hear that. Thank you for the apology.

@_date: 2014-10-19 13:18:29
@_author: Peter Lebbing 
@_subject: Restoring GnuPG 
Yes; also ignoring all assigned ownertrust values.
Public key and revocation certificate can be recreated; the latter is
usually only used precisely when you have lost access to the secret key.
I'm fairly sure even certifications from other users are included in the
private key, as long as you don't specify options scrubbing them from
the key on export.
Additionally, you'll most likely want to assign ultimate ownertrust to
the key; this is automatically done when using --gen-key, but not on
importing a secret key.
$ gpg2 --edit-key YOURKEYID trust

@_date: 2014-10-19 13:22:07
@_author: Peter Lebbing 
@_subject: Encrypt folders which include audio video and text files 
I'm still missing my favourite alternative in the suggestions.
device-mapper's dm-crypt target together with LUKS (Linux Unified Key
Setup). dm-crypt is somewhat the successor to encrypted loopback
mentioned by Rob, and fixes some of the issues perceived in encrypted
loopback. Some of those where subsequently also fixed in encrypted
loopback itself, to make things more clear for everyone ;P.
In Debian, the package cryptsetup provides all the goodness.

@_date: 2014-10-19 13:26:55
@_author: Peter Lebbing 
@_subject: new helper program for configuration import / export 
I'm not sure how you envision this, but wouldn't it be much easier, and
sufficient, to have a prompt on startup that read:
***WARNING*** Make sure all your secret keys are protected by an
adequate password before making a backup. Are you sure you wish to
proceed? [y/N]
Something in that vein.
Maybe even more verbose, explaining that the password is enough to get
the key from the backup. Or do that in the manual or something like that.
I think it might boil down to a simple file copy excluding some unwanted
files, and including everything else. Also remeber that the keybox
format is different between GnuPG versions (secring.gpg vs.
private-keys-v1.d); this suggests an "include everything except these
specific files" approach to me.

@_date: 2014-10-19 21:10:20
@_author: Peter Lebbing 
@_subject: new helper program for configuration import / export 
It is clear you are not working on the same assumption as I did: that
there were already good passphrases on the keys, because this is simply
good practice, and that the extra thing was just to prevent accidents by
making people think for a moment. Like you pat your pocket before you
close your front door, to make sure you have your keys in your pocket.
Have you thought of a way to only have to enter a password once and use
that for each (sub)key you wish to change, without keeping it in
swap-eligible memory? Or am I still not comprehending what it is you
want to do? Perhaps you could elaborate on the procedure you have in mind.
1.4 and 2.0 as they are now both use secring.gpg, I think. I don't know
in detail which versions use secring.gpg and which use
private-keys-v1.d, and neither do I know how this will be in the future.
And there's the kicker: if you just exclude the harmful files, you pick
up any later additions that don't exist yet but are worth it to backup.
I think it is more likely that things you want to backup are later
added, than that things that you wish to exclude are later added. But
this is an assessment, not knowledge.
I've forgotten. I think gpgsm already uses private-keys-v1.d and GnuPG
2.1 will be using them for OpenPGP as well. But Werner surely knows
better. I do know that just backing up pubring.gpg and secring.gpg will
soon mean you're not backing up the secret key.

@_date: 2014-10-20 10:55:48
@_author: Peter Lebbing 
@_subject: new helper program for configuration import / export 
It wouldn't; I simply hadn't thought of it. In other words:
When at some point my thoughts strayed to this mail thread, I suddenly
thought "D'Oh! Of course, it's much better to simply wrap it in a
symmetrically encrypted archive!". It seems we're on the same page again :).
trustdb.gpg, yes.
I proposed using a blacklist rather than a whitelist, because I suspect
useful files might later crop up. I came to realise a trade-off there
which needs to be mentioned: if you use a whitelist and miss useful
files, your backup is possibly not useful. That's bad. But if you use a
blacklist and a file is later added that compromises your security and
is included in the backup, that is a security issue. That's worse. But
this is mitigated by encrypting the whole backup with a good password.

@_date: 2014-10-22 11:19:30
@_author: Peter Lebbing 
@_subject: smart card under linux 
These steps were superfluous for me for Debian jessie/testing because the
necessary udev rules are included in the gnupg package already. However, I use
an SPR532 here. The SCM3512 is not mentioned in the rules file, so you might
need to add an entry.
Here's how it looks for me:
$ cat >/etc/udev/rules.d/60-gnupg-extra.rules <8----------------------
That last line is not part of the file, it signals end-of-file to the cat
command. Also, there's a long line that's split but shouldn't be.
And that would be all I need to add to udev! And it would work for anyone
logging into X on your monitor and keyboard (the "head").
TL;DR: Make sure your user has write access to the USB device. Also, differences
in Linux distributions mean the HOWTO might not be the optimal way to do it, or
even that you might not need to do anything at all.

@_date: 2014-10-26 12:44:53
@_author: Peter Lebbing 
@_subject: auto refresh for expired certificates 
After several tries I finally had luck. I also forgot the name :). But it's
parcimonie. It seems to live at  .

@_date: 2014-10-26 12:50:53
@_author: Peter Lebbing 
@_subject: auto refresh for expired certificates 
By the way, my search string was "keyserver lookup exposes keyring"
But this e-mail is to correct this bit: this is actually a reimplementation of
parcimonie. I hadn't looked at it well enough to notice this very obvious bit :).

@_date: 2014-10-26 12:42:36
@_author: Peter Lebbing 
@_subject: smart card under linux 
I've had a good look at this. On Debian stable, I couldn't get it to
work, but maybe it's possible.
The SCM SPR532 seems an unlikely candidate; it's not of the correct
device class:
I doubt the ID_USB_INTERFACES match works anyway, seeing how udevadm
info doesn't show it. But that might be a bug in udevadm for all I know.
This is as far as I got on Debian stable.

@_date: 2014-10-26 14:14:25
@_author: Peter Lebbing 
@_subject: auto refresh for expired certificates 
However, it does broadly correspond to your later comments about periodically
refreshing even before the expiry date.
And more importantly, an implementation of refresh-on-expiry might actually be
done as a new mode of the existing tool parcimonie, leveraging the code that
has already been written. And you get parcimonie's features as a bonus, i.e.,
not exposing too much about when you use keys and what keys you have.
I'm suggesting that automatic runs of parcimonie should schedule a refresh of
a key when a key is close to expiry. It seems to me postponing the refresh to
the first moment you use an already expired key leaks more metadata than
necessary, i.e., that you are about to encrypt to that key.
However, some thought needs to go into when and how often to check keys close
to expiry.

@_date: 2014-10-26 16:12:15
@_author: Peter Lebbing 
@_subject: auto refresh for expired certificates 
First of all, the number of parties in the know is enlarged by doing the
keyserver query. Somebody with access to the SMTP session always knows:
the sending and receiving mail providers and anybody who can listen in
on that connection. But you add a keyserver to that.
Secondly, more to the point, after thinking about it, I think it does
make more sense to incorporate this into GnuPG proper (as an optional
feature; --auto-key-locate seems appropriate).
The main motivation is that it sounds like a good option for many casual
users who are not particularly worried about the problem of leaking
social and usage data to keyservers, and those people will not install
parcimonie. And my argument of leveraging code already written equally
applies to GnuPG, that was a bit of a silly argument in retrospect :).
--auto-key-locate automatically retrieves unknown keys. I think it makes
sense to include expired keys, triggering a refresh. Or is there a use
case where this is unwanted?
PS: I didn't quite understand the different "you"s in your mail; they
all appear to refer to "anyone". But it doesn't seem important.

@_date: 2014-10-26 17:29:52
@_author: Peter Lebbing 
@_subject: auto refresh for expired certificates 
I don't see why this should be so easily dismissed. It's leaked metadata. And
combined with other sources it can provide more information.
And I never assumed parcimonie was used to do the keyserver query when I wrote
that statement, because you suggested including it in GnuPG. Hence my confusion.

@_date: 2014-10-26 17:36:24
@_author: Peter Lebbing 
@_subject: auto refresh for expired certificates 
Quote failure! I'm sorry about that. I did some stupid things with several
replies open at the same time and then picking the wrong one to use.
Let me redo that:
I don't see why this should be so easily dismissed. It's leaked metadata. And
combined with other sources it can provide more information.
And I never assumed parcimonie was used to do the keyserver query when I wrote
that statement, because you suggested including it in GnuPG. Hence my confusion.

@_date: 2014-10-28 18:53:45
@_author: Peter Lebbing 
@_subject: Terminal asks for passphrase even when passphrase is cached by 
-c is symmetric encryption, encryption with a passphrase. It is
prompting you what the passphrase should be.
If it were to ask you for your passphrase for *decryption*, it would ask
only once (unless you make a typo).
Encryption to a public key would be:
$ gpg -r KEYID -e test.txt
and it will never ask for a passphrase, since you don't need a
passphrase for _encryption_, but rather for _decryption_.
However, also signing the file will need your passphrase, regardless of
the recipient.
By the way, it is possible to specify a "default recipient" in the
configuration file if you do not use a "-r" when encrypting a file with

@_date: 2014-10-29 19:19:44
@_author: Peter Lebbing 
@_subject: key length/size RSA discussion/recommendations in the wiki 
Why is brute force even mentioned in something about RSA? You couldn't
brute-force a 128 bit RSA key. I'd say 2048 bit quite covers it 8-)

@_date: 2014-10-29 22:18:13
@_author: Peter Lebbing 
@_subject: key length/size RSA discussion/recommendations in the wiki 
No, I'm using a strict definition of brute force.
For p = 2^63 to 2^64-1
   For q = 2^63 to 2^64-1
     If p * q == n:
       Break
   Next
You're free to adapt the order of tries of p and q, though.
Happy breaking!
I don't feel the method outlined by Rob is still brute force. That brute actually is using his brain. Possibly his brain resembles a sieve, but still :). Am I too strict?
PS: I'm assuming a 128-bit RSA key is made up of two 64-bit primes.

@_date: 2014-10-29 22:46:02
@_author: Peter Lebbing 
@_subject: key length/size RSA discussion/recommendations in the wiki 
Well, why not restrict ourselves to primes whose product equal the modulus? I could solve any key in constant time that way. The distinction obviously(?) is in the cost of computing what makes a "possible". But that's the thing about brute force that I thought was not included: using computation to speed up your process, and using insight into the mathematical properties of an algorithm.
But you are obviously more in touch with the material than me. If you refer to just testing primes as brute force, I don't think it should be so easily dismissed as I initially did.

@_date: 2014-09-16 12:13:36
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
Sure! A week might be a bit much, but if it were 3 or 4 days I'd agree.
Starting from slightly before the expiration date to well past, I simply
sniff it, pour out a little, look if it is curdling... and if none of
those things apply, I happily pour myself some perfect moo juice. A
bloody shame to throw it away. You really throw out perfectly good food?
Just because someone said "well, given our process variations, even the
worst piece, even the milk produced on a hot day and picked up a bit
late, would still be okay for one and a half week. To cover our asses,
let's say we warrant it for a week"?
Your milk argument is worse. It advocates wasting food, and food is a
scarce resource.
But the argument that if someone /knows/ the expired key is actually
good, he or she should be free to override it, makes a lot of sense to me.
Also, I see a tendency to replace:
This key is valid until X
This key is invalid after X
Those are not equivalent. You might decide that is how you wish to
interpret it, but I don't see that interpretation mandated anywhere, and
it's certainly not the only reasonable interpretation.
David Shaw wrote it as:
I disagree. It says that something is true up to a certain point, it
doesn't say it's false afterwards. Otherwise, extending the expiration
date would conflict with the old expiration date in a very strict
interpretation. Revocations do work like this: it's final.
Also, RFC's try to be very explicit. If a term is only named, you can't
draw conclusions from meaning just from a common interpretation of the
name. I'm pretty darn sure a key is only ever used with a lock, not with
another key. Still, we decided to name the thing "key", in straight
defiance of common knowledge that you need a lock for a key to be a
useful thing. But if you wish to infer meaning from a name anyway, I
think an expiration date on food makes perfect sense to infer the
opposite of what David is arguing. I interpret it as the date up till
which the producer guarantees I can eat or drink it, providing proper
storage. After that, I need to use my own nose and common sense to see
if it's still okay.
I think Hauke makes a pretty good case, although I disagree with the
slight titbit:
If he's not willing to extend the validity period, he doesn't seem to
care enough, just send him plaintext already. Not capable, as in, there
are more important things he needs to do first before he has time to get
out his offline key, I would accept that. But not willing to extend? His
problem, not mine. I won't make extra effort then either.
But that doesn't diminish his other good arguments.
I support inclusion of an override of the expiration date.
Interpretation of key expiration is policy, not technical or mandated by
RFC (AFAIK).

@_date: 2014-09-16 12:45:09
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
I wanted to encrypt a document to myself on an offline system[1].
However, that copy of my own key was expired, and it wouldn't do it. I
was in a bit of a hurry, trying to get things done. Now, I had to get a
USB drive, start another computer, export my updated key, and import it
on the offline system. If I had --expert followed by yes to an "Are you
sure?" prompt, I would have done that and updated the copy when I had
more time.
Together with Hauke and his correspondent with the offline main key, you
now already have two actual cases, taken from real situations that
actually happened. At this rate, we'll be done this week.
I was slightly baffled by this comment as Hauke actually gave an example
that happened in real life. That is a lot more than I usually see when
people argue for or against a feature.
You can't argue that these aren't real users. You can't argue it's not a
real impact. You can only argue that the impact isn't that big. But that
is a long shot from "so hypothetical it's hard to take seriously". I
don't understand where that came from.
[1] This in the interest of security. You dislike the word, so it's in a
footnote to make it less offensive to you ;).

@_date: 2014-09-16 14:21:52
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
In the Netherlands, we have both. "Expiration" means the food might be
spoiled and you could get sick if you eat it. "Best before" means it
might taste less, or have a different texture, simply: it won't be the
same quality.
So I'm aware of the difference.
Milk definitely has an expiration date. I happily use it beyond that,
when it looks good. It's a reasonably apt comparison because it is easy
to judge if milk is still good, just like you can confirm out of band
that a key is still good.
I'm fully aware that normally, a key shouldn't be used beyond it's
expiration. But there can be perfectly good reasons to use it anyway,
unlike a revoked key. Just like you can send an e-mail encrypted to a
key that doesn't bear that e-mail address in it's UID's, because you
know the recipient actually has more e-mail addresses than UID's. This
example was, to my surprise, mentioned in this thread as something you
shouldn't be allowed to do either.

@_date: 2014-09-16 14:24:32
@_author: Peter Lebbing 
@_subject: Multiple Subkeys for different Uses 
Could you define "show up", i.e., could you give an example of you
trying a command and the output it generates?

@_date: 2014-09-16 18:12:12
@_author: Peter Lebbing 
@_subject: Multiple Subkeys for different Uses 
Not really. But GnuPG currently can't update a secret key; so it listens
the first time you tell it to import, which gets you one subkey. All
subsequent times, it doesn't change what it already has.
It would work if you did this with just the public key (I think).

@_date: 2014-09-16 18:53:53
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
Because I was archiving the file for later use and I had no desire to
come up with a good passphrase and try to remember it for I don't know
how long.
Ouch, that's really selective quoting you're doing. In one day you
object to people misunderstanding what you say and twist the words of
another. The very next sentence handles exactly this: how large the
impact is. In that context, I was clearly referring to "real" as in
"existing" not as in "significant", and you know it.

@_date: 2014-09-16 19:16:07
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
Utter nonsense. I'm not advocating putting an expiry date on something
beyond what you can reasonably "guarantee" (in practice, milk sometimes
curdles before the expiration date, even though I sure didn't leave it
out of the fridge. Or fruit rots). I'm advocating that you judge what
you put in your mouth based on your own common sense.
This may be a cultural thing; I think they might care less about waste
of scarce resources in the US, but to me it is offensive to suggest you
should throw out perfectly good food or food with a few minor spots that
you can cut out. I certainly wasn't raised that way.
It's illegal to sell or even give out food that is past its expiry date.
Once it's in my fridge, I will decide whether I will eat it or not.
And that you appeal to authority and say I should take food health and
safety advice from you because you were raised on a farm... well...
let's just say it's a bit silly. Let's keep it at that.
By the way, if stuff regularly exceeds the expiration date in your home,
you should buy smaller portions, not throw out more. That's advice from
someone who isn't exactly a city boy but a farm boy neither.
But back on topic:
It was claimed that an expiry date should be seen as a hard deadline. It
was claimed that this was in the very word itself, as can be seen in
food and drinks expiry dates. I strongly state that this is a very poor
basis to conclude that on, because an expiry date on food is certainly
not commonly and largely viewed as a hard deadline for consumption.
Maybe in some cultures, but I don't see a list of cultures used during
drafting the RFC among the references.
I missed no such thing. I think you're missing what a super market is
allowed to sell or give away and what I'm allowed to eat.
Yes, because GnuPG surely knows better that even if it warns the user
with some capitals and asterisks and requires them to type 'yes', that
still, the user is probably too dumb to be reasonable about this.
I thought you yawned over this feature. It looks more like a growl.
Opposing becasue of the addition of a really minor risk of
misconfiguration (who said anything about it being a persistent
option?), that's quibbling.
It's not treated as invalid. You can trivially override the validity
check on the command line. It's treated as effectively temporarily revoked.
You are arguing with yourself. You bring up a difference, and then
refute it. I never talked about "treating" and "being".
Here we go again. The restaurant is selling me something. I'm glad there
are laws for this.
However, if my neighbour handed me the drink with the same words when I
come over for coffee (er, milk), then yes, I would drink it. And I never
even made the point of handing it to anyone else, I made the point of
using your own judgement to determine what you put in your own mouth.
Let me be quite frank now. I can't quite imagine you don't see the
difference yourself. I think you're purposely ignoring it for the sake
of argument.
Hey, what do you know. You remembered! When it's part of your side of
the argument. I honestly wrote the previous paragraph before I read this
one. I started replying when you again advocated food waste and I got
offended, and went from there.
You are always and invariably at the mercy of what your correspondent
chooses to send you. This is not somehow magically prevented by denying
users to encrypt to an expired key. There is no sliding scale, there are
no floodgates opened, you are just as much at the mercy of your
correspondents as before. This is bikeshedding.

@_date: 2014-09-16 19:18:06
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
Regardless of whether you personally support or oppose the possibility
to override the expiry date, as it's your decision, I do want to point
out that this creates an issue with encrypt-and-sign. Although a little
footnote saying "hey dude, since your key expired in April, I had to
sign in April" could be added. I do wonder how many people would
understand that footnote, though.

@_date: 2014-09-16 20:32:28
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
I'm sorry I keep going on, but I have got to get this off my chest. You are
urging me to do something in direct defiance of how I was raised and my personal
beliefs, and even urging me to thank you for that! That really is bloody
facetious. You've really got nerve, man.
I only see the statement "I certify this key until X". That is certainly what I
did when I thought really well about how I wanted it to be and put an expiry
date on my key. I never made the statement "I no longer certify this".

@_date: 2014-09-16 20:51:28
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
No no no no, let me put that in context for you.
I was exactly asserting that you can only argue about the extent of the impact,
not that there exists an impact. But you snipped that so it became:
Which suddenly makes it look like I made a false statement, when in fact I was
simply stating that something that has an arguably small impact is a long shot
from something that is "so hypothetical it's hard to take seriously".
Thereby discrediting my view by association to a false statement.
I really hate it when you don't argue based on merits but seemingly just to sway
people to your point. I always wonder if maybe your point isn't strong enough by
There, I've said it. Deal with it. In fact, thank me for it.

@_date: 2014-09-16 21:30:51
@_author: Peter Lebbing 
@_subject: (Really OT!) encrypting to expired certificates 
However, I can't help but feel angry by your dismissal of my beliefs and
misrepresentation of my words. It's a flaw, I know that. But even if you are of
stone, maybe you should remember that it's actual people you are conversing with
who have emotions and might feel strongly about things. And really, really
dislike being made out to have said things they didn't. Twist your words
whicheveryway you want (is that one word?), but from context, it was completely
obvious I never attacked your "real impact" statement, but attacked your "so
hypothetical statement"; the former was simply a mode of expression that is not
at all uncommon and certainly not something to be lambasted for.
I can't believe I'm still replying. Another flaw, I know. I should be the bigger
man here. But I'm past the point where I still can. So I diminish myself to the
level you are currently conversing at. I really hope I can find the strength to
simply ignore your next dismissal of my heartfelt words and funnily meant
comments like "hot-button issue". You, sir, really like to take the piss. Again,
remember, real human being here, one who is currently having a bit of a problem
with repeating "This guy is not one of my friends, what do you care" to himself.
PS: Wow, really throwing myself wide open here emotionally. An asshole would
probably abuse that. Ah well, I don't think you would go /that/ low.

@_date: 2014-09-17 11:21:30
@_author: Peter Lebbing 
@_subject: encrypting to expired certificates 
Had to look that one up. I suppose "Sorry could not resist"[1]. I don't mind.
The bit best watched with a bag of popcorn wasn't very much about GnuPG though.
All I really wanted was an apology for 'a resounding "[...] you should be
thanking me."' and an apology for misrepresenting my words by very selectively
Too bad that seemed out of reach.
[1] Although "Signal to Coherent Noise Ratio" seems rather appropriate in the
discussion as well.

@_date: 2014-09-17 11:23:38
@_author: Peter Lebbing 
@_subject: Multiple Subkeys for different Uses 
I would like to point out that Sam really made it perfectly clear what his
problem was, in a way that's really helpful to people wanting to help him. It
was so clear cut, that I immediately homed in on the problem and forgot to
actually point out how clear cut it was.
People, if you experience a problem with GnuPG command line and wish people to
help you, this is a great example of how to phrase the question. People often
encounter the pitfall of interpreting what they see, and reporting that
interpretation. But it is much better to report what the tool actually says,
because it gives those vital hints to people helping.

@_date: 2014-09-18 10:53:53
@_author: Peter Lebbing 
@_subject: (OT) encrypting to expired certificates 
And to think I blew a gasket because I grossly misinterpreted this sentence:
Which I interpreted as that /I/ should throw out food that's past its expiration
date. And that I should thank Robert for showing me the error of my ways, which
is the part that got me fuming. And was a completely wrong interpretation!
Well, people, you are welcome for the entertainment! I hope I actually made a
few good points as well :).

@_date: 2014-09-18 18:23:23
@_author: Peter Lebbing 
@_subject: Keeping .gnupg folder in cloud 
The OP said:
So I think random_seed and all the other files are actually safe... I
might be missing something, though. This all depending on the actual
encryption. It would be wise to add a signature too, to prevent willful
corruption of the data.

@_date: 2014-09-21 11:59:46
@_author: Peter Lebbing 
@_subject: New beta 
What is the net effect when GnuPG 1.4 encounters, for example, such a key:
RSA pubkey with Certify and Sign capabilities
RSA subkey with Encrypt capability, created 2014-04-01
ECC subkey with Encrypt capability, created 2014-09-21
Everything is non-expired. If I were to try to encrypt to it, would 1.4 pick the
RSA subkey because it is valid and understandable to it, or would it fail to
encrypt to this key because it can't parse ECC keys?

@_date: 2014-09-22 11:02:21
@_author: Peter Lebbing 
@_subject: New beta 
Thank you for this clear example!
Luckily, it behaves as you would hope, picking the valid subkey it can
use and ignoring the one it can't.

@_date: 2014-09-26 14:14:46
@_author: Peter Lebbing 
@_subject: Keybase 
It came up this July, mentioned by Sam Gleske. That's the first I heard
of it, and here is my reply in that thread:
(The following assumes you read that mail first)
I'm worried that the documentation doesn't mention this threat model I
mention there. It seems like it should point out that their scheme
doesn't help in this threat model. It's important to realise it when
assessing the worth of the project for you.
If the creators didn't even think of it; that would make me quite
sceptical of how thorough they have thought all of it through. But
perhaps there is a very good reason I didn't see it mentioned anywhere yet.
My 2 eurocents,

@_date: 2015-04-01 13:34:12
@_author: Peter Lebbing 
@_subject: Instructions for converting keyring for 2.1 
After reading some docs and fiddling with stuff; is this okay?

@_date: 2015-04-02 18:35:46
@_author: Peter Lebbing 
@_subject: "g13" tool in GnuPG 2.1 (was: decrypt luks with gnupg Card: determine 
... in which the following message by Werner from 2009 is linked: [1]
So is G13 ready for use?
(note that the LUKS script written by me and modified by Jan also uses
real public key cryptography; that remark in the quote refers to a
different method of unlocking an encrypted drive using an OpenPGP card).
[1]

@_date: 2015-04-06 21:56:53
@_author: Peter Lebbing 
@_subject: Making the case for smart cards for the average user 
I think that would be quite an exploitable bug, passing UIDs to be
parsed by a shell... I hope they already don't do that. Is a shell even
involved I wonder?
PS: Little Bobby Tables' baby brother has been born, ; rm -rf / ;. He
already has an OpenPGP key! Please send him an encrypted birthday card
with The Bat! ;P

@_date: 2015-04-07 11:57:21
@_author: Peter Lebbing 
@_subject: Making the case for smart cards for the average user 
The type of UID that proves problematic when you include the angle
brackets in your search is this:
$ gpg2 -k ceo at example.org
pub   2048R/17C05EBD 2014-08-13 [expires: 2015-04-14]
uid       [ unknown] ceo at example.org
$ gpg2 -k ""
gpg: error reading key: No public key
It's about an UID without angle brackets! Hence, when you search for it
including the angle brackets, you don't find it. Your examples all are
with an UID that actually does include the angle brackets.

@_date: 2015-04-07 15:30:40
@_author: Peter Lebbing 
@_subject: Making the case for smart cards for the average user 
GnuPG implements the OpenPGP standard. What hoops the users need to jump
through to get a certain behaviour with GnuPG might not be there in
other OpenPGP compliant programs. The OpenPGP standard merely says:
That said, I understand your position. However, the patch to match on
bare e-mail addresses as UID even when searching with the angle brackets
already went in GnuPG 2.1 [1].
[1]

@_date: 2015-04-08 20:05:01
@_author: Peter Lebbing 
@_subject: Blind signatures for simple election 
Those are two different beasts, by the way. You want to blind the
the /hash/ is signed with, e.g., RSA. So it could be said that the hash
is blinded[1], but the signed data definitely is not.
My gut feeling is that OpenPGP is ill suited for this task, but I
haven't thought thorougly about it.
[1] Not sure if that is proper use of the terminology, I'd usually say
the operation is blinded, not the data.

@_date: 2015-04-13 16:20:47
@_author: Peter Lebbing 
@_subject: Blind signatures for simple election 
Personally, if I was actually going to use the program, I wouldn't write
it myself. I'd only write it myself if it was purely for the learning
I'd look for an existing project that makes me feel confident about it.
I'd want the code to have been looked at by as many cryptographers as
But it depends on your threat model. It could be enough to merely
obscure the data, not protect it against a determined attacker with
knowledge of cracking crypto.

@_date: 2015-04-21 11:34:27
@_author: Peter Lebbing 
@_subject: Passphrases for SSH connections not accepted via pinentry 
Note that this is not necessarily true: you can configure SSH to accept
both public key and passphrase authentication. If you fail to unlock the
private key, it could still allow you to login using the passphrase
associated with the account. There is no relation between the passphrase
protecting the private key and the passphrase associated with the login
But "Operation cancelled" is not what I'd expect for entering a wrong
passphrase; I'm not sure though. It could refer to the whole process of
pubkey auth being cancelled as you failed to unlock the private key, in
which case it does make sense for a wrong passphrase.
Sorry I can't be of more help at this time.

@_date: 2015-04-21 15:48:03
@_author: Peter Lebbing 
@_subject: Passphrases for SSH connections not accepted via pinentry 
Yes, that is what I mean. So I agree with your analysis then.
No, if it is able to show the preferred pinentry, it will do that. If
that is a graphical pinentry, you'll get a graphical pinentry if possible.

@_date: 2015-04-22 21:07:59
@_author: Peter Lebbing 
@_subject: Yubikey NEO OpenPGP advisory 
I think it's a major bug, I'm not completely satisfied with the way they
downplay the importance. I kinda agree with them, but it still leaves me
feeling a bit dissatisfied.
But apropos, what kind of protection did you buy it for then? I'm unsure
what you mean by "this specific kind of protection".
What does a smartcard protect against?
Leaking the private key. It protects against more copies of the private
key material existing.
Explicitly not /usage/ of the key by unauthorized people; it cannot
protect against that. There are many threat models where an attacker
gains use of the key.
This PIN handling bug still does not allow an attacker to extract secret
key material.
Furthermore, I see a lot of different scenarios chucked together:
malware, actual loss of the smartcard. The discussion quickly becomes
weird when everybody keeps on moving the goal posts. Please try to keep
this in mind.
Bank cards and SIMs each have such a different way of using them than an
OpenPGP card (which is an electronic signature card) that I can't
compare them.
Bank cards only go in terminals at shops or ATM's, not your own PC. They
also have a host of issues themselves, which indeed includes complete
failure to check the PIN. Yet they are not fixed; it's all just papered
over and denied by the banks. At the 31C3 there was a talk about
defending yourself when your bank tries to make you pay for misuse of a
stolen card.
And SIMs just need to hold off access until I've notified my mobile
phone provider that my card has been stolen. After that, the SIM is useless.
It's all so different that it's useless to compare.

@_date: 2015-04-23 10:36:47
@_author: Peter Lebbing 
@_subject: Yubikey NEO OpenPGP advisory 
Oh wait... I somewhat assumed the things were field-upgradeable. I
thought you could pick the applications to load on a multi-application
Yubikey. In that case you can just download a new version of the app on
your Yubikey and you're good to go (although it'd lose the keys
currently on there).
If already deployed Yubikeys are not updatable, that changes things in
my eyes. I don't think I'd still use such a device as OpenPGP card.

@_date: 2015-04-23 11:05:41
@_author: Peter Lebbing 
@_subject: Yubikey NEO OpenPGP advisory 
I hadn't considered NFC at all, it's good you brought it up. In fact, if
sniffing reveals the PIN and my threat model includes physically nearby
attackers, I wouldn't use it at all, whether it had PIN or not.
But I suppose it could work if you only use the NFC functionality when
you're in a safe environment such as your own home. It seems a
comfortable way of using your crypto hardware. As long as you only worry
about attackers that are elsewhere.
A similar scenario from real life:
Right now, they're rolling out a payment system here in The Netherlands
where you only need to tap your bank card to the payment terminal to do
small payments. That's all that is needed.
Or, since everything is relative, where an employee of the shop you're
in only needs to tap the payment terminal to your wallet as they
accidentally bumps into you.
So I'm still looking for a sturdy yet practical metallic sleeve to put
around the bank card as soon as they replace my non-NFC card with an NFC
card :). The one I've seen looked to finnicky to remove your bank card
from, which you do every time you need to pay in a shop...
I agree. However, I seem to have been under the wrong impression that it
was a matter of a software upgrade, and that we were merely assessing
the risk that something had gone wrong before you did the upgrade.

@_date: 2015-04-27 12:33:27
@_author: Peter Lebbing 
@_subject: Yubikey NEO OpenPGP advisory 
Those NFC pay things you both mention sound a lot like what we have here
as well (? 25 maximum, random PIN checks).
Thanks for the hints, guys. But I'm very happy with my current leather
wallet, and the bag I keep the wallet in is almost full. So I'm more
looking for something really compact around the card, like a sleeve.
getDigital has one: [1]. I just can't judge how sturdy it is; the sleeve
I have seen in real life looked like it was quite a hassle to remove
your card from because it looked really flimsy.
PS: getDigital has a lot of cool geeky stuff!
[1]  (the 5 euro cover)

@_date: 2015-04-27 12:36:32
@_author: Peter Lebbing 
@_subject: Yubikey NEO OpenPGP advisory 
Well, if the PIN protection actually works (unlike in the affected
Yubikeys) and you only enter the PIN in an environment where you're sure
nobody is sniffing the over-the-air data, I suppose you could decide to
rely on the fact that your PIN is still secret, preventing access to
unauthorized people.

@_date: 2015-08-05 15:45:52
@_author: Peter Lebbing 
@_subject: {gnupg 2.1.6} Howto change s2k cipher from AES -> AES256? 
Your question begs an interesting, though pretty academical question: what would
be even more difficult to crack: SHA-512 with an s2k-count equalling 1 second on
a modern Intel PC, or SHA-1 with an s2k-count equalling 1 second on that same PC?
Because you can clearly do many more SHA-1 rounds in one second, improving its
robustness against cracking.
It depends on so many factors. For instance: What is the speedup of a massive
FPGA-based implementation relative to that PC for both cases?
I wouldn't dare to say whether SHA-1 or SHA-512 would be the "better" option. I
do dare to say that it probably doesn't actually matter, since completely
utterly unbreakable is just as unbreakable as regular unbreakable. More
importantly, the key stretching does not appear to be the weakest component of
private key encryption either (that would usually be the passphrase itself).
Why do you think a configuration option for the key stretching hash algorithm
would be useful?

@_date: 2015-08-07 18:35:03
@_author: Peter Lebbing 
@_subject: Facing issue while installing GnuPG 2.0.27 on AIX 7.1 
If you require timely responses, you can purchase support from g10 Code. This is
a mailing list where volunteers help each other. You can't expect more than that
from it. I see Werner already referred you to  for
commercial support, by the way.
Personally, I dislike multiple exclamation marks. It makes you sound petulant;
I'm sure you didn't mean it that way.
Please quote correctly when replying in a thread on this mailing list. Trim your
quotes so only that which you are immediately responding to is left, and put
your response below that quote. If somebody needs more context, they can open
one of the previous messages of the thread.
I can't help you with the problem you're having.

@_date: 2015-08-12 11:58:58
@_author: Peter Lebbing 
@_subject: Inability to export and then import my secret key 
I don't think I agree with either statement. Copying the folder comes
with its own caveats: don't copy random_seed, and you might not want two
identical installations with regard to present private keys and such.
And "broken by design" implies to me that GnuPG doesn't *want* to
support merging secret keys; which would be odd given that the latest
version, GnuPG 2.1, does support it. I also can't remember ever hearing
a reason why it would be bad.
Anyway, the reason I think Bryant is seeing this issue, is that GnuPG
1.4 and 2.0 don't support merging new things into existing secret keys.
I suppose the key already existed on the other system but you added new
subkeys and are trying to import those?
If you can get the up-to-date system (sys1) to export the secret key as
you want it to be on the other computer (sys2), it boils down to:
sys1 $ gpg2 -o sec.gpg --export-secret-keys 1C0B95E5
[copy sec.gpg to sys2]
sys2 $ gpg2 -o sec_backup.gpg --export-secret-keys 1C0B95E5
sys2 $ gpg2 --delete-secret-keys 1C0B95E5
sys2 $ gpg2 --import sec.gpg
Now check if everything is okay on sys2, and if so, you can delete
I think this should be safe, since you keep a backup of the local copy
until you are sure the deletion didn't delete unintended stuff.

@_date: 2015-08-12 13:01:41
@_author: Peter Lebbing 
@_subject: Inability to export and then import my secret key 
Right, yes, then a full copy makes a whole lot more sense. I got thrown off by
the fact that the error message seems to indicate the key already existed, and
completely forgot about the introduction at the top of the message :). Such an
exceptionally short attention span seems to indicate an acute lack of caffeine,
I've taken swift action to remedy that!
Anyway, on-topic: don't copy random_seed though. And be aware that some options
in the *.conf files might only be applicable on the old system, and not on the
new one.

@_date: 2015-08-12 21:48:11
@_author: Peter Lebbing 
@_subject: Possible bug when using smartcards and gpg-agent2.0 as the 
The serial number is part of the application ID, it's not a bug. The one is
more verbose than the other. The AID ends in four zeroes, but the part before
that is the serial number and manufacturer ID.

@_date: 2015-08-14 16:06:56
@_author: Peter Lebbing 
@_subject: signing failed with master key when I have stronger subkeys 
I think the escape of the exclamation mark might not be correct for Windows
shell usage.
This would probably be the correct form for Windows. But: is that subkey
actually encryption capable or is it an encryption subkey?
What about
D:\>gpg -u "46D397FF!" --clearsign relay.txt
You can see what your (sub)keys are capable of as follows:
D:\>gpg --edit-key 46D397FF
pub [...] usage: SC
sub [...] usage: S
sub [...] usage: E
The primary key can sign and certify, the first subkey can sign and the second
can encrypt.

@_date: 2015-08-20 17:01:15
@_author: Peter Lebbing 
@_subject: The best practice of master/sub key capabilities 
I'd recommend the defaults as best practice. They're there for a reason.
Why are you restricting yourself to "the following 2 choices"? They both
seem ill-advised (and unusual as well). Most importantly, it's generally
advised not to do encryption and signing with the same key material.
Furthermore, it is disputed whether RSA-4096 offers a useful
cost/benefit tradeoff. Personally, I'm on the side that thinks it does
not. But who am I.
You also didn't indicate what your usage scenario is, so without that
information, "the defaults" again seem like a pretty solid answer.

@_date: 2015-08-21 10:44:14
@_author: Peter Lebbing 
@_subject: The best practice of master/sub key capabilities 
This is just a general recommendation, and abusing the fact a key is
used for both encryption and signatures is an intricate matter. But
since OpenPGP supports subkeys, the matter is easily avoided completely
by using a separate subkey for encryption, so it's a good idea to do so.
But it suddenly dawned on me you might have an actual issue when you
assign both Sign and Authenticate capabilities to a key! Authentication
is pretty much proving that you can sign what the server sends you. It
might be the case that these signatures can actually pass for data
signatures or key certifications! I don't think RFC 4880 says anything
about authentication (except when used to refer to data signatures and
key certifications). Checking the OpenPGP Card Specification 3.0, it
would seem that the key in the Authenticate command can indeed issue
signatures, since the PKCS padding is identical to the Sign command,
and there is no check on the signed data.
It seems like a genuinely bad idea to assign Authenticate capability to
a key that has Certify or Sign set. Even if GnuPG or GPG-Agent does
checks to catch abuse, it's just asking for trouble that is easily
avoided, in my opinion.

@_date: 2015-08-21 11:00:45
@_author: Peter Lebbing 
@_subject: Mixing Authenticate capability with others 
In the thread "The best practice of master/sub key capabilities",
Dongsheng Song asked for advice and gave an example where a master key
has both Certify and Authenticate set, and an example where a subkey has
both Sign and Authenticate set. I wrote in a reply in that thread:
Does GnuPG (or GPG-Agent in 2.1) actually check that the challenge sent
by the server is not a validly formatted OpenPGP signature or certification?
And should GnuPG in general perhaps refuse to assign Authenticate
capability to key material with other signature capabilities, just to be
Oh, I forgot to mention in that other mail that I'm fairly sure I
actually had a signature subkey in the Authenticate slot of an OpenPGP
v.1 card, which worked fine. This corresponds with the observation that
the padding is the same for both operations.

@_date: 2015-08-21 12:49:05
@_author: Peter Lebbing 
@_subject: The best practice of master/sub key capabilities 
I suppose because it doesn't hurt. They're both signatures in essence;
cryptographically they are the same and exchangable. The difference only
lies in the interpretation.
Also note that anyone who has access to the primary key material can
issue data signatures at will. They could either add the Sign capability
to the key or (easier) create a new subkey with which to issue signatures.
The actual reason why the default is as it is can probably best be
answered by someone else, though, since I can only guess.

@_date: 2015-08-24 14:29:26
@_author: Peter Lebbing 
@_subject: Mixing Authenticate capability with others 
I should note that it is not possible for an SSH server to evoke a data
signature from gpg-agent running as an SSH agent like this. The server
only controls a minor part of the hashed data.
Quickly browsing through the source code of the SSH agent code in
gpg-agent, it seems it will actually sign whatever it is sent, if I read
it correctly. I still don't think that's a problem because that is no
different than gpg-agent itself which will also happily sign with
unlocked keys, since this is actually its task. What gets sent to the
agent is still under the control of the SSH client, running as the user
But an SSH agent is only a possible application, it seems to me the
system with OpenPGP subkeys having the Authenticate flag is set up to be
more broad than that. Other applications might be built in a way that
the server controls all the data to be signed.
Am I seeing ghosts here or should the system be more careful of sharing
Authenticate with Sign/Certify?
Oh, and by the way, I quickly realised after my previous message that
authentication is probably always handled by the agent, not just in
GnuPG v2.1. It just didn't seem to be worth a message on its own ;).

@_date: 2015-08-28 18:12:39
@_author: Peter Lebbing 
@_subject: FAQ: drop mention of 1.4? 
1.4 is fully supported, but occupies a niche. Support is not dropped, nobody
forces you to upgrade. I really don't see where that is coming from. This is
about what one specific document, the FAQ, should treat. 1.4 is still completely
documented, but this niche application you cherish might not warrant the label
Can we please stay on subject. Your message feels like a general rant that has
nothing to do with the FAQ whatsoever.
Funny you mention that. I thought the main difference between 1.4 and 2.x was
that 1.4 just receives bugfixes and new features end up in 2.x. It sounds like
you got exactly what you wanted, yet you feel the need to lash out in a
discussion that has nothing to do with reducing support for 1.4.
There's some tension between two of your desires, by the way. What if your
correspondents in a few years have ECC keys? When 1.4 doesn't get ECC support,
you could complain that they apparently have dropped support for 1.4. But if it
does get ECC support, you can complain that 1.4 is feature-complete and should
only receive bugfixes. Or if your glass is half full, you could even be happy
with either outcome. I think Brian from Monty Python has something to say about it.

@_date: 2015-08-30 11:01:54
@_author: Peter Lebbing 
@_subject: The FAQ's 4GiB recommendation 
I think it's a good idea to stress you're talking about the block size,
not about the key size. Something like "a cipher with a 64 bit block size".

@_date: 2015-08-30 11:24:00
@_author: Peter Lebbing 
@_subject: The best practice of master/sub key capabilities 
Sorry I forgot to answer earlier. This seems a reasonable setup. If this
makes you feel happy, go for it :). I still think RSA-4096 is a bit
much, though. People who have your public key and use an underpowered
system will see that building the trust database can take significantly
longer in checking your certifications.
I don't know when GnuPG checks subkey bindings, but that takes
significantly longer as well. Subkey bindings verify the correspondence
between a primary key and a subkey, and are part of your public key.

@_date: 2015-12-01 11:24:05
@_author: Peter Lebbing 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
"Trivially cracked" implies that there is something to crack. That would
be the silly case with the empty string as the password. Instead, the
first octet in the secret part of the secret key packet indicates
whether to use an S2K or not:
The "any other" stuff is ancient legacy stuff, and MUST NOT be produced
by a conforming implementation. This byte is zero when there is no
encryption, and the following bytes are just the plaintext version of
the secret parts:
In this case, read it as "plain multiprecision integers ...".
[1]

@_date: 2015-12-03 15:15:59
@_author: Peter Lebbing 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
Why is all this hackery necessary? Why don't you just install GnuPG 1.4
next to your 2.1, instead of compiling a special hacked 2.1?

@_date: 2015-12-07 11:41:16
@_author: Peter Lebbing 
@_subject: GPA - unsupported certificate 
Eh? I don't find it silly at all. Why would someone, unprompted, fire up a
terminal to initialise the GUI program they installed because they'd rather
use a GUI program than a terminal program? That's like saying you should fire
up Vim before you can use XFCE's Mousepad editor. Well, not really, but it's
still silly to suggest that it is silly to expect a GUI program to do what it
is supposed to do: pretty much replace the command line alternative. Wow, long
complicated sentence. Better end with sentence fragments to compensate.
Anyway, a quick glance at the open bugs for GPA in Jessie[1] show that it is a
problem for people, but developers have difficulty reproducing it. In fact,
those bugs are still open in Sid.
That is, apart from the well-known issue: GNOME Keyring hijacks the agent
connection, which causes all sorts of problems. Up until recently, they were
unwilling to stop breaking GnuPG this way; but recently, they've finally
agreed to provide their functionality in a different way that actually agrees
with the GnuPG architecture.
GPA will get very confused when GNOME Keyring hijacks the agent connection.
For me, Debian Jessie x86_64 with XFCE, I'm pretty sure I fixed it with
"Settings -> Session and Startup", "Application Autostart", uncheck the box
next to "GPG Password Agent (GNOME Keyring: GPG Agent)". But a search on the
web for disabling GNOME Keyring's GPG Agent should provide more information.
[1]

@_date: 2015-12-08 13:16:29
@_author: Peter Lebbing 
@_subject: GPA - unsupported certificate 
No problem, it's what mailing lists are for: to give pointers in the
right direction.
I know certain recent versions of GnuPG complain and warn about the
hijacking, but that is during usage on the terminal.
No, this variable is part of the internal architecture of GnuPG and
should be set to the gpg-agent that is part of the installed version of
GnuPG. This is why I use the term "hijack", rather than something like
"provide an alternative service". It has never been intended that other
software packages use this variable and start imitating internal parts
of GnuPG.
Again, no. Lots of programs get vague problems. It's just that it used
to be that GNOME Keyring said "those problems are in GnuPG", whereas the
GnuPG project said "those problems are caused by GNOME Keyring breaking
our software". The result is that nobody fixed it. I hope that when
Debian Stretch is released, we can finally put this behind us, as the
problem has been fixed in recent versions that are unfortunately too
recent for Jessie AFAIK.
GnuPG 2.1 already always uses a fixed path and disregards the variable.
And recent GnuPG 2.0 versions already warn about the hijack. The problem
is that two software projects want opposite things; this would lead to
an arms race. But fortunately, it will all go away when distributions
start using recent versions of the software, as the issue has finally
been resolved.
Oh, by the way, the functionality that GNOME Keyring is providing is
that it offers the option of unlocking your GnuPG keys when you log in.
I've never understood why this is so darn important. Without GNOME
Keyring, you would type two passphrases per login session: once to
login, and for the second time when you use your GnuPG key for the first
time. The gpg-agent can then keep the key unlocked for the rest of the
time if you want it to. With GNOME Keyring, it is reduced to one
passphrase: your login passphrase. Some might say that's a 50% gain, I
say it is the smallest possible gain: you gain one less
passphrase-entering moment per session. Whooptie-friggin'-doo. I don't
get it.

@_date: 2015-12-08 13:46:14
@_author: Peter Lebbing 
@_subject: GPA - unsupported certificate 
What might be a better "fix", IMHO, would be to have GPA also warn about
this, so people know what to do. Perhaps with another environment
variable GPG_NO_WARN_AGENT_HIJACK because GUI's usually warn through
modal dialogs, which gets tiresome quickly when you actually want GNOME
Keyring. That is, if GPA works *at all* with GNOME Keyring; I don't know.
However, looking at the age and number of bugs reported against Debian's
gpa related to this mess, I think the package maintainers don't have a
lot of time to spend on this. So someone would need to champion it all.
Write a complete patch, and campaign for its inclusion in the next
Jessie point release. I don't know if it would work, though. If the GPA
maintainers campaign for its inclusion in a point release, it might
work, but I doubt an outsider could get it done. Note: I'm not a Debian
Developer. I'm just making observations from the outside. I might be
babbling complete gobbledygook (is that how you spell it? :).

@_date: 2015-12-10 11:46:42
@_author: Peter Lebbing 
@_subject: GPA - import keys more easily?.. 
For commandline usage, you can simply use GnuPG directly:
$ gpg2 --import pubkey.asc
GPA is a GUI frontend to GnuPG. Commandline support is already in GnuPG and
doesn't need to be in a GUI frontend.

@_date: 2015-12-10 11:49:24
@_author: Peter Lebbing 
@_subject: cache gpg passphrase for mutt on os x 
Sounds like GPG_AGENT_INFO is not set in that session, and hence cannot access
the already running agent that has the passphrase cached.
Other than that hint, I can't help you. I have no experience with Mac OS or mutt.

@_date: 2015-12-11 10:40:45
@_author: Peter Lebbing 
@_subject: Please consider joining Bountysource Salt to collect recurring 
While I think it's a good idea to include an alias, I think you should
do that consistently for all the menus, otherwise "Documentation" and
"Related software" are going to end up even more hidden ;).

@_date: 2015-12-11 10:49:39
@_author: Peter Lebbing 
@_subject: GPA - import keys more easily?.. 
Oh, okay, I misunderstood your request. I thought you wanted to invoke
GPA from the command line, since you called it a command line option.
But I suppose you want a file association so GPA is launched on an .asc
or .gpg file, and subsequently takes the most logical action for the
actual content of the file (show key info with an option to import for
keys, decrypt and verify for encrypted/signed data).

@_date: 2015-12-11 10:55:20
@_author: Peter Lebbing 
@_subject: GPA - import keys more easily?.. 
Since I'm constantly making wrong assumptions on implied contexts here,
just let me make this explicit: we are talking about e-mail clients for
which no OpenPGP plugins/extensions/etc. exist, like webmail and such,
right? Because I just have Enigmail handling keys in e-mail, in my
Icedove (Thunderbird).

@_date: 2015-12-21 11:43:33
@_author: Peter Lebbing 
@_subject: GPGrelay does not recognize Gpg-2.1 keys; Gpg4win-3beta... 
Install GnuPG 1.4 alongside 2.1 and manually sync all keys from GnuPG
2.1 to 1.4, with for instance:
$ gpg2 --export | gpg --import
I'm not sure how large the overhead is when you sync all keys everytime
you get a new key... GnuPG will figure out that it already has the keys,
but it will inspect all signatures to see if it already has them and
stuff like that, so it might have quite some overhead that way. The
obvious alternative is to import with both GnuPG versions every time you
import a new key.

@_date: 2015-12-24 17:50:47
@_author: Peter Lebbing 
@_subject: about cartoon in FAQ 10.1. 'Correct, horse! Battery staple!' 
My understanding is that these words in such a passphrase are chosen by
a random number generator in a computer. I use such a passphrase; I've
let my computer pick words out of a word list based on reading
randomness. I didn't let it generate four words; I let it generate a few
more until some combination of four words emerged that I could somehow
memorize. It is not a phrase, it is non-grammatical, it just has
something to it that makes it such that I can remember. The amount of
entropy each word contains is close to the amount of choice there is in
picking a word from the word list; i.e., base-2 log of the number of
words in the word list if you express it in bits.
This is grammatical. There is a subject (or two), a verb, an.. well
whatever those things are like "zum Tod", I don't often discuss grammar
in any other language than Dutch so I forgot the technical terms.
Furthermore, the phrase actually makes sense semantically. I don't know
if somebody ever said or wrote it; that would make it even worse, since
a passphrase cracker could try sentences from a corpus of likely texts
it has scoured from the internet.
It has grammar, it has semantics, it has a proper meaning. All these
things go at the expense of its entropy. Whereas a few words that only
make enough sense to be memorizable have loads of entropy, as the
cartoon expresses. "Memorizability" is not easily quantified when you
write a password cracker. It's almost a Turing test in a way. What you
want to avoid is that there is a a pattern that a password cracker can
look for. Replacing an i with a 1 (one) is a horribly little amount of
extra entropy that serves more to make it difficult for you than that
one little extra try that a password cracker has to do matters.
I don't think I can ever make myself forget Correct horse, battery
staple! :)

@_date: 2015-12-25 10:57:06
@_author: Peter Lebbing 
@_subject: about cartoon in FAQ 10.1. 'Correct, horse! Battery staple!' 
Yes, however, this characterization seems mathematically incorrect.
Let's assume one in four words in the dictionary fits the grammar. I
hope this concurs broadly with what you assumed. Rather than pick four
random words of the full list, and then pick one of those, you pick one
out of a quarter of the wordlist size.
So that's 2 bits per word you're losing, a lot more than if you were
free to pick one of four random words. And there is a lot more structure
to the sentence given by Matthias than just its grammatical soundness.

@_date: 2015-12-26 09:53:38
@_author: Peter Lebbing 
@_subject: about cartoon in FAQ 10.1. 'Correct, horse! Battery staple!' 
Hmmmmm.... how many of those would have been generated by a Markov chain
generator that a spammer used to generate some filler text in a spam
mail? I bet you've seen them, those texts that superficially look like
proper English sentences, but when you look closely, it's completely
What is your purpose by the way? Look for an estimated amount of entropy
contained in picking one of those sentences?

@_date: 2015-02-04 14:34:29
@_author: Peter Lebbing 
@_subject: Anonymous payment for hardware tokens 
But Gnuk is not secret, so the flash doesn't need to be read-protected. And if
you need a JTAG programmer to read the hash, you might as well reflash the MCU
to your known-good Gnuk.
I'm trying to think of a way to have the actual hardware present a hash to a
user who doesn't own a JTAG programmer, but it's tricky :). I thought of
something like dedicated pins connected to a shift register (so you don't need
256 pins), where only the hardware can shift out the actual hash; using the pins
from the firmware would be prevented. But then you need a display on your token.
Having four 7-segment LED displays on your token that displays the hash in
groups of 4 hex digits won't exactly make for a compact arrangement :).
Perhaps it could use a serial format as used by the serial port on a PC
(asynchronous start/stop). Then you could connect a USB-to-serial converter to
the pins on the token and see what the MCU is reporting as its hash.
All nicely academic musings, in the sense that I don't see an MCU with this
feature coming to the market soon...

@_date: 2015-02-04 23:07:18
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
What about non-governmental attackers who are able to update your reader
firmware through an evil maid attack or the like? You seem to imply that hacked
reader firmware is necessarily by a government or the manufacturer.
I don't think "it's easier to hack than comparable equipment from competitors"
is a particularly compelling argument, though, to be honest.

@_date: 2015-02-05 10:38:29
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
Yes, you /could/. However, we were talking about Rainer smartcard readers, which
I think we're really not having the same discussion here...
... as I didn't intend to say you did, but I thought we were discussing this
argument made by Werner.
I never read it that way. To me, it were two spearate arguments, one on how
trustworthy Rainer appears in its dealings, and the other on the hackability of
their hardware. So I might have misinterpreted what you wrote following that.
Oh, by the way:
I'm absolutely sure nobody made that claim. More miscommunication galore? ;)

@_date: 2015-02-06 12:09:35
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
Why?! Why would I do that?! I do like to think of myself as a bit altruistic,
but seriously, why would I go through all that effort? Thanks for making me
smile. It does a person good.
Furthermore, I am a bit tired of this subject, forgive me for not answering most
of what you say. I get the impression you're not picking up on what I'm trying
to say, and that becomes a bit tiresome.
If you would link[1] to the mailing list archives I wouldn't have to open the
(what Thunderbird calls) "message source" to visually compare the Message-ID on
a likely message.
Anyway, that wasn't such a long mail. It sure doesn't contain your suggestion.
You're really doing a lot of extra interpretation and inference if you take that
suggestion from:
To me, it says that 4k or 8k keys are not the weak spot of a cryptosystem. And
that we should discuss weak spots on this list. Thank you for your contribution
in that. But it sure as hell doesn't say that a smartcard keeps you safe when
you're working on a compromised system.
Glad we agree on that at least.
[1]

@_date: 2015-02-06 12:17:15
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
To st the record straight: no, I don't know this, I might myself have inferred a
bit too much from Werner stating that:
So I was wrong to make that statement, sorry. I might have no love for a company
that seems to shun the free software world, but it is wrong to make statements
that are simply not supported by evidence.

@_date: 2015-02-06 20:41:08
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
You know, if you had just said right from the start "I know that a smartcard is
supposed to protect theft of the private key but what is the use of that given
that they can still sign and decrypt", the discussion might have progressed a
never said in the first place, and hence didn't need to be refuted.
I think the answer to it is the timespan, by the way. If I'm working on a
compromised computer with a smartcard now, hackers can access my encrypted files
and sign stuff with my key. But let's say in a week I will be using a new
computer, then they will lose the ability to sign and can no longer decrypt any
new documents encrypted to me. If they had compromised my PC with the keys on
disk, they would have copied them, and as long as I use the key, they can access
the data and sign new stuff as well.
And given the many escalate-to-root security bugs that are constantly found and
fixed, I do not think any software measure is going to prevent a determined
attacker from gaining full control of your system once they get a hold of your
user account.
Your scenario of the attacker doing a key rollover, revoking your actual key and
substituting their own, can be prevented by using an offline master key so the
attacker only has access to the subkeys. Also, if I'm concerned this might have
happened, I can check with my correspondents to see if they are under the
impression I recently changed keys. Given a secure channel to them, I can detect
this. It's not nearly as stealthy as simply copying the key material.
The attack form popularized by the BadUSB people is a genuine problem; what if,
by plugging in the card reader I used on a compromised PC into a clean PC, it
immediately compromised that clean PC?
Similarly, if I think I'm cleaning my PC from infection by wiping the hard disk,
but the attacker modified the firmware of the hard disk, I'm still screwed, as
shown by Sprite_TM on OHM2013.

@_date: 2015-02-08 09:51:33
@_author: Peter Lebbing 
@_subject: Key keeps showing unknown trust 
Yes, you have interpreted it wrong. What you are doing now is this statement:
"I trust Hugo Osvaldo Barrera checks identities carefully before signing keys.
However, I do not know whether 1BFBED44 is really his key". So the statement
doesn't actually get you anywhere. And the fact that you're speaking in the
third person about yourself is lost on GnuPG, which doesn't know that.
Since it is your own key (right?), what you want here is "trust: ultimate".
Normally, what makes a key valid is that it is signed by a /trusted/ key. Note
the difference: key B is /valid/ because key A, which is /trusted/, signed it.
But this has to start out somewhere. This is usually your own key(s), which
are assigned "ultimate" trust, which means: this key is also valid, even
though it is not necessarily signed by a trusted key.
The option to use for your /own/ keys therefore, is usually "5 = I trust
ultimately". And when you are convinced someone is actually the legitimate
owner of a key, you would sign their key. Whether you would assign them any
trust depends on whether you think this person is trustworthy enough to rely
on their signatures on other people's keys.

@_date: 2015-02-08 10:40:56
@_author: Peter Lebbing 
@_subject: How to reset the PIN counter 
Fortunately, your card is not bricked. But GnuPG can't access it anymore. If you
have a recent enough version of GnuPG, there is a new command that helps in
getting low-level access to the card even though opening the OpenPGP application
on the card no longer works: scd serialno undefined.
This gpg-connect-agent script ought to get your card back on its feet:
scd serialno undefined
scd apdu 00 a4 04 00 06 d2 76 00 01 24 01
scd apdu 00 44 00 00
scd apdu 00 e6 00 00
If it doesn't, you could try swapping the order of the last two lines. There's a
bug in the OpenPGP card related to those two commands, but it was fixed in a
minor revision to the card, so it depends on your specific card. It's not clear
to me how this works out for the exact commands to send.
For me it looked like this (with an intentionally "bricked" test card):
$ gpg-connect-agent
S SERIALNO FF7F00 0
D[0000]  62 85                                              b.
D[0000]  90 00                                              ..
D[0000]  69 85                                              i.
If you don't get a 90 00 back with the second to last command, that would
probably be an indicator you need to swap the two. In any case, I'm interested
in what it outputs for you, as it helps me learn about the OpenPGP card. The two
bytes returned for every command sent are a status code, and they give
information on what the card thought of the command.
PS: For people who are interested in what it all *means*: the large-ish APDU I
send first is the command to select the OpenPGP application on the card; it's
exactly the same as GnuPG normally does. However, the card returns an error
62 85 "Selected file in termination state", and GnuPG is not so happy about
that, so it won't go on after that. We, however, know this is as expected and
simply continue with the following commands.

@_date: 2015-02-09 14:20:57
@_author: Peter Lebbing 
@_subject: Key keeps showing unknown trust 
Hash: SHA1
Also not when you quit and edit the key again? It should do a new trust
database calculation in between, unless it has been specifically told not to.
Then it might be related to [1] perhaps? I'm not sure, just throwing it out
there as a pointer.
[1]

@_date: 2015-02-09 14:28:19
@_author: Peter Lebbing 
@_subject: Revoked keys and past signatures 
Hash: SHA1
I believe so, yes. You should probably have expired it instead, sorry.
Suppose it is revoked because someone stole the key; then that person could
fake signatures set in the past; faking the time. If GnuPG accepted them
because at that time the key wasn't revoked yet, that would create a security
And GnuPG, AFAIK, doesn't do anything with the "revocation reason", so it will
see all revocations the same.
If you haven't uploaded the revocation to a key server, it is possible to have
it unrevoked; your correspondents would need to delete their copy of your
public key and only after that import your new unrevoked key. Say so if you
want me to explain how to surgically alter a key to no longer be revoked. This
however doesn't help when it's already on a keyserver; they will still keep it
revoked no matter what you do.

@_date: 2015-02-10 12:28:22
@_author: Peter Lebbing 
@_subject: Revoked keys and past signatures 
(By the way, I'm going to treat data signatures, not certifications,
since I believe that was what Hugo reported)
I started to think you were right and I was mistaken, but I can
reproduce Hugo's scenario:
$ gpg2 --verify test.gpg
gpg: Signature made Tue 10 Feb 2015 11:53:47 CET using RSA key ID B2F1C0D8
gpg: Good signature from "Testkey 3" [full]
Note how verify-options show-uid-validity notes it is fully valid. It is
signed by an ultimately trusted key.
Now I revoke it:
$ gpg2 --edit-key B2F1C0D8
gpg (GnuPG) 2.0.26; Copyright (C) 2013 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Secret key is available.
pub  1024R/B2F1C0D8  created: 2014-02-24  expires: 2015-02-17  usage: SC
                     trust: never         validity: full
sub  1024R/98AC4DFA  created: 2014-02-24  expired: 2014-03-03  usage: E
[  full  ] (1). Testkey 3
gpg> revkey
Do you really want to revoke the entire key? (y/N) y
Please select the reason for the revocation:
  0 = No reason specified
  1 = Key has been compromised
  2 = Key is superseded
  3 = Key is no longer used
  Q = Cancel
Your decision? 2
Enter an optional description; end it with an empty line:
Reason for revocation: Key is superseded
Test revocation
Is this okay? (y/N) y
The following key was revoked on 2015-02-10 by RSA key B2F1C0D8 Testkey 3
pub  1024R/B2F1C0D8  created: 2014-02-24  revoked: 2015-02-10  usage: SC
                     trust: never         validity: revoked
The following key was revoked on 2015-02-10 by RSA key B2F1C0D8 Testkey 3
sub  1024R/98AC4DFA  created: 2014-02-24  revoked: 2015-02-10  usage: E
[ revoked] (1). Testkey 3
gpg> save
Now let's check that signature again:
$ gpg2 --verify test.gpg
gpg: Signature made Tue 10 Feb 2015 11:53:47 CET using RSA key ID B2F1C0D8
gpg: Good signature from "Testkey 3" [unknown]
gpg: WARNING: This key has been revoked by its owner!
gpg:          This could mean that the signature is forged.
gpg: reason for revocation: Key is superseded
gpg: revocation comment: Test revocation
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the
Primary key fingerprint: EFF1 596F 1A68 F708 8699  579D 0815 4E55 B2F1 C0D8
The dates for signature and revocation are the same, but the times are
reasonably far apart:
$ gpg2 --export B2F1C0D8|gpg2 --list-packets
:public key packet:
        version 4, algo 1, created 1393271747, expires 0
        pkey[0]: [1024 bits]
        pkey[1]: [17 bits]
        keyid: 08154E55B2F1C0D8
:signature packet: algo 1, keyid 08154E55B2F1C0D8
        version 4, created 1423566838, md5len 0, sigclass 0x20
        digest algo 8, begin of digest 9c c5
        hashed subpkt 2 len 4 (sig created 2015-02-10)
        hashed subpkt 29 len 16 (revocation reason 0x01 (Test
        subpkt 16 len 8 (issuer key ID 08154E55B2F1C0D8)
        data: [1024 bits]
$ date -d "1970-01-01 +1423566838 secs UTC"
Tue 10 Feb 12:13:58 CET 2015
That's twenty minutes later. I don't see a reason for GnuPG to round to
full days when it has resolution down to the second for the times the
signatures (data, revocation) are made... is there?
The RFC clearly states "key superseded" doesn't invalidate old signatures:
But using GnuPG 2.0.26 on Debian jessie/testing, package 2.0.26-4, I can
reproduce signatures becoming invalid... what's going on? Does GnuPG not
implement the RFC here or is it a bug?

@_date: 2015-02-10 13:24:58
@_author: Peter Lebbing 
@_subject: (bug?) Revoked keys and past signatures 
In my opinion, the signature might be /good/, but it is not /valid/. A
downloaded off the internet. Here's the status-fd output:
$ gpg2 --status-fd 1 --verify test.gpg 2>/dev/null
[GNUPG:] SIG_ID mIjaz0UJC1cgEmJHXntwKHhdiuI 2015-02-10 1423565627
[GNUPG:] REVKEYSIG 08154E55B2F1C0D8 Testkey 3
[GNUPG:] VALIDSIG EFF1596F1A68F7088699579D08154E55B2F1C0D8 2015-02-10
1423565627 0 4 0 1 8 00 EFF1596F1A68F7088699579D08154E55B2F1C0D8
[GNUPG:] KEYREVOKED
[GNUPG:] TRUST_UNDEFINED
Note that unfortunately 'good' and 'valid' are slightly mixed up,
perhaps that's where the confusion comes from.
What you'd like to see, though, is TRUST_FULLY or better:
Note how it says /validity of the key/. It's not ownertrust it is
talking about![1]
This is exactly what a "superseded" or "retired" revocation is /not/. It
has not been stolen; the signature could not have been forged. The key
post. It's just that the key has since been revoked. The RFC clearly
says this doesn't invalidate past signatures, but this message is the
message you get for an invalid data signature.
No indication that the signature belongs to the owner... the exact same
message you get for any invalid key you just got from somewhere.
Why? The key was revoked because it was superseded or has been retired,
not because it was stolen or compromised.
If you're convinced you're not mistaken, could you please take the time
to show me where this data signature from a revoked key is any different
than a signature from any random invalid key?
PS: I've tagged the subject line so it stands out more, since it seems
like a bug to me.
[1] For certifications the terminology "trust" makes sense, for data
signatures not so much, in my opinion.

@_date: 2015-02-10 13:30:05
@_author: Peter Lebbing 
@_subject: (bug?) Revoked keys and past signatures 
Quick correction:
If you're convinced you're not mistaken, could you please take the time
to show me where this data signature from a revoked, but certified key
is any different than a signature from any random revoked invalid key?
The key difference (heh...) is that the key has been certified with a
trusted signature.

@_date: 2015-02-10 13:51:10
@_author: Peter Lebbing 
@_subject: (bug?) Revoked keys and past signatures 
Hash: SHA1
Does GnuPG consciously not follow the RFC here then? Otherwise, what does this
mean (RFC 4880 section 5.2.23, Reason for Revocation subpacket):
What is the important semantic difference between "Key is superseded" and "Key
material has been compromised", if past signatures are immediately questioned?
PS: Odd turn of the sentence, "there are thus important reasons for revoking
signatures." I wonder if they intended "there are thus important reasons for
handling the cases differently".

@_date: 2015-02-12 13:10:54
@_author: Peter Lebbing 
@_subject: [Announce] GnuPG 2.1.2 released 
Hash: SHA1
I'm so glad to hear that, congratulations! \o/
If there's anybody who deserves it, it's you. I hope this gives you some
well-deserved peace of mind regarding financially sustaining yourself and your
family while continuing to work on GnuPG.

@_date: 2015-02-13 16:17:28
@_author: Peter Lebbing 
@_subject: MIME or inline signature =?UTF-8?Q?=3F?= 
You'll find it is actually even an 8192 bit RSA key.

@_date: 2015-02-18 10:40:37
@_author: Peter Lebbing 
@_subject: Please remove MacGPG from gnupg.org due to serious security 
Hash: SHA1
There will always be people who think they know better and be very... vocal
about it on the internet. I'm sure it has been mentioned how they'll switch to
another program if you don't comply with their demands instantly... :(
I think you should just ignore them and not second-guess the security related
decisions taken by your upstream, the GnuPG project. I don't see any reason
why a version for Mac would need different RSA key size limits than a version
for Linux or Windows.[1]
In fact, the second-guessing might actually unintentionally lower the overall
My 2 cents,
[1] Unless of course all Macs are much more powerful and Mac users only
communicate with Mac users... just kidding :P

@_date: 2015-02-18 19:56:35
@_author: Peter Lebbing 
@_subject: 2.1.2: keyserver route failure 
Tired as I may be of this discussion (what's your next argument, NAT provides
beneficial firewalling behaviour?), I still wish to say that I will not "admit"
IPv6 has failed or that IPv4 advancements[1] made it obsolete. Get off your soapbox.
[1] I shudder to call NAT an advancement, but that's apparently how you present it.

@_date: 2015-02-19 18:31:14
@_author: Peter Lebbing 
@_subject: Please remove MacGPG from gnupg.org due to serious security 
I can understand you're pretty darn pissed off that they executed untrusted remote code on your computer, which, I think, explains why you're "lashing out" so strongly. And I also think that it was truly poorly designed. But I find your quest for bad faith on their part a bit far fetched... Never attribute to malice that which is adequately explained by stupidity.[1][2]
By now, you should probably cool down a bit. I'd say you've made your [1]  ; apparently after Robert J. Hanlon, not Hansen ;P
[2] Although with security software, a bit of healthy paranoia can be warranted, IMHO.

@_date: 2015-02-21 12:26:47
@_author: Peter Lebbing 
@_subject: Help need to use truecryt + openpgp applet. 
Hehe :). I think what Diego means, is that a SIM card can still be protected by
a PIN. You would need to enter the PIN before you had access to the SMS,
similarly as the private DO's on the OpenPGP card.

@_date: 2015-02-21 12:51:15
@_author: Peter Lebbing 
@_subject: Whishlist for next-gen card 
Yes! This would be a great feature to keep expired encryption keys on a card. I
personally would have no use for more than 1 signature and 1 authentication key,
but I don't see a reason why you wouldn't just have a whole bunch of generic key
slots and only indicate its intended usage on creation/upload so people can do
that as well.[1]
If ECC were supported by the card, you'd need quite a lot less storage to keep
all these keys.
This would partly amount to resurrecting an old feature. IIRC, there were 2 user
PINs in the v1.1 spec, but the v2 spec pretty much retired the second PIN. Don't
take my word for it, though, check the spec.
I suppose it makes sense. Especially when combined with 2 signature keys: one
could be your primary key, and the other your subkey. You would still keep them
on the same card, but would be more careful about entering the PIN that belongs
to your primary key.
However, I think the primary key/subkey feature is already covered pretty well
by simply having two smartcards (it's what I do).
Sounds like an interesting concept. I don't know how much work it would be to
have the ISO 7816 parts needed by the OpenPGP card really working for NFC. Do
you just exchange the lower few communication layers (physical, data, ...) and
is everything above the same for the subset of ISO 7816 you need? I haven't
looked at NFC yet.
What I'm hinting at: NFC and cards with contacts are different enough that it
might warrant handling NFC separately from the rest and hence doesn't need to be
"integrated into" the process for determining the next cards-with-contacts
standard and implementation.
But NFC authentication through asymmetric crypto sounds interesting.
What generates the HOTP then? Do you type a PIN on the HOTP device to get the HOTP?
What I'm guessing you might mean, is that the HOTP device might be more trusted
than the pinpad of the card reader: the card reader is connected to the PC. The
HOTP device is simply a standalone device; is air-gapped. So even if the PC is
compromised, it will not be able to learn your PIN, which you entered on the
HOTP device.
Is this what you're getting at?
I don't really see the use. Smartcards protect extraction of the private key;
they're not equipped to prevent usage of the key material through a compromised
PC. So what they can't learn your PIN; they'll just get you to enter it for
them. I don' see this adding something beyond your point 6, which I'll treat there.
I'm not terribly interested in that. Firstly, you would still need a backup of
the key the data is encrypted to; the chain has to start somewhere. Secondly,
provided you can have a trusted system for the generation of the keys, you could
simply generate them on that trusted system, encrypt them to the key you wish to
encrypt it to, and then store the encrypted data as you see fit.
On-card generation is putting a lot of trust in the on-card RNG as well; I put
more trust in Linux's PRNG on a trusted system. As long as you're generating the
keys on a PC anyway, you might as well handle all the backup thingies there.
This and 7 have been discussed in this[2] thread as well; just as a reference. I
think it serves a useful canary role, in that as long as I only press the button
once for each decryption/signature, I'm fairly sure that it's doing the
decryption or signature that I want. As soon as stuff starts to exhibit hickups,
I can at least account for the fact that perhaps it's not hardware failing but
someone playing me. Robert J Hansen clearly strongly disagrees with me on that
subject, as evidenced in the thread I indicated.
It's not watertight. Neither is a canary. I see it as defence in depth. But it
is clearly a contested subject. And I've never seen any indication that Werner
believes in this solution; I get the feeling he doesn't. I suppose he's the main
influence on what goes in the card specification and what doesn't.
See below for my view.
This seems to preclude ever allowing the user access to their own private key
material; otherwise you're moving your trust back again from the smartcard
attesting this policy to the user attesting this policy, since they can do what
they want, whatevah! I don't think we should limit the user in handling their
own keys; it reeks like DRM to me. But if you don't limit the user, there's no
reason to have the smartcard attest to any attributes, since the card can't
guard them anyway. Just leave the policy to the user.
Hmmm. I would definitely use a different card for this, regardless of all the
cool protections on the card. Say I have a card with my work identity, and one
with my private identity. I wouldn't ever stick the private identity in a work
PC, even if the keys were protected by a different PIN. It only seems to serve
the purpose of having one piece of plastic less in your wallet; but I already
need a separate card wallet because of all the cards I have, one more isn't
going to matter.
Third factor IMHO implies a different *kind* of factor. You already have
possession (the OpenPGP card) and knowledge (the PIN). What's your third factor;
To bend the terms to breaking point: I currently employ 9-factor authentication.
I have the OpenPGP card, and I know 8 PIN digits. This is a useless definition;
I think "factor" only makes sense as a *kind* of authentication.
Still, this is just about terminology; my substantial answer is above.
Malware can replace the hash of the object being signed... and still display the
correct file name type and size, etcetera, everything you mention. So I'm not
sure what you're getting at. You need to present data that is actually *signed*
for this to be useful in any way. It might be that SSH authentication does
include a "peer ID" in its challenge; I haven't checked. But that is all.
What is signed[3] is a hash computed over the data and a few OpenPGP
(sub)packets. People can't compute hashes. So you need a computer to do it. If
there's a computer you trust to do this for you, just sign the data there
already. I only see this work with trust in numbers: compute the hash on many
computers, and if they all agree, they're probably not all hacked. I say I see
this work, but I don't, really: I don't believe in this mechanism. And it's a
tremendous amount of work for the user for one single signature.
[... half a proofread of this mail later ...]
Oh ouch. I suddenly realise something about the canary press-to-decrypt button
(point 6). I've thought of a nasty attack. Maybe it's not such a great canary
for decryption keys...
So I access mail A, which is encrypted, and my PC is compromised. The malware
listens in, and, crucially, secretly saves the session key for mail A! A few
days later, I again access mail A. Now, I expect to be prompted for my PIN:
that's how it normally works when I access an encrypted mail. However, the
malware arranges that a document it is interested in is decrypted instead. And
since it has saved the session key for mail A, it still presents to me mail A as
expected. Now I haven't pressed the button any more than I expect to do, but
still it decrypts other data than I expect it to. I've just helped the malware
access my encrypted documents, and I'm totally unaware.
Detecting false signatures is already more complicated.
Now I'm really starting to have doubts about the canary button.
My 2 cents,
[1] It would probably be reasonable to not be able to change its usage. If you
really want to do that, you could also upload the key again, proving you already
have the secret material. If your point 5 were to be implemented, the usage
indicator could be combined with that.
[2] [3] Forgetting about authentication for a moment; as I said, the "peer ID" might
actually work for authentication.

@_date: 2015-02-24 12:10:20
@_author: Peter Lebbing 
@_subject: Surprising command line options handling 
However, if running interactively and --batch is not specified, might it
be useful to print "Warning: --export-options did not match any key"
with the command line Daniele tried in the OP, so people more quickly
recognise that GnuPG is trying to match it to a key rather than
interpret it as an option? It might save on some struggling and head
The warning would also help in other cases. What if I want to export
keys A, B and C, but match B wrongly. GnuPG doesn't complain, and I end
up with a file with exported keys. Only later do I realise B is not
among them...
This surprising command line handling has come up here from time to
time, I'm sure it was discussed before... I just can't remember...
I think this point isn't covered in the FAQ yet. I suggest we come up
with a question and answer that cover this case. Something like "GnuPG
ignores options I specify on the command line!" as a question that isn't
a question. Preferably, we make the answer an answer, though.

@_date: 2015-02-24 19:49:48
@_author: Peter Lebbing 
@_subject: GNU-divert-to-card S2K format 
RFC 4880 specifies that for a string-to-key usage octet of 255, the final two
bytes are a checksum, but it /is/ part of the encrypted data for v4 keys. I was
curious and also had a look at the packets and the source. For the
divert-to-card s2k, RFC 4880 is not very appropriate, and section 5.5.3 should,
I think, be freely interpreted as:
255 for plain checksum s2k
cipher algo 0
specifier 110
hash algo 0
3 bytes prefix GNU
(together 5 bytes)
Used to store up to 16 bytes of serial number
This whole block is absent! Somehow I expected no MPI's but two bytes where the
checksum should be. This is not the case.
Note that the serial number for OpenPGP cards has the following format:
D2 76 00 01 24
xx xx
xx xx
        00 05 ZeitControl
xx xx xx xx
00 00
16 bytes in total
Cipher algo and hash algo are written as 0, but don't seem to be used/checked on
I just wrote that up because I think I figured it out and didn't want the effort
to go to waste... It is rather unchecked.
[1]

@_date: 2015-02-25 00:01:21
@_author: Peter Lebbing 
@_subject: Unattended signing 
I suppose it depends on your definition of "destroying"...
I think you'd be fine with setting an expiry date and "--delete-secret-key"-ing
the subkey when the time comes.
If you asked me to /destroy/ the key, I would look through my drawers for all
backups I have and do a "shred" on them, and think really hard where any further
copies might have ended up.

@_date: 2015-02-25 10:49:52
@_author: Peter Lebbing 
@_subject: GNU-divert-to-card S2K format 
Oops, I realised I made a mistake.
As is apparent from the part of doc/DETAILS Werner quoted from, this is missing
something. It should be:
S2K specifier 110
hash algo 0
3 bytes prefix GNU
GNU protection mode specifier 2 (for mode 1002)
Serial number length 16
(together 7 bytes)
If the specified serial number length (16 for OpenPGP cards) is greater than 16,
only 16 bytes of serial number are read regardless.
Obviously, I could have made more mistakes.

@_date: 2015-02-25 10:56:07
@_author: Peter Lebbing 
@_subject: Unattended signing 
While I agree this could be a neat setup for OP, it might be overkill or even
impractical given the signing speed of a smartcard. I don't know what volume of
signatures will be issued.
Anyway, I said "destroy backups". I would arrange for backups not to include the
signing key in the first place. If the system needs to be restored from backup
(which would be very seldomly), just issue a new signing key.
Still, you might have forgotten to exclude it on a one-off backup you made at
one time or another.
And the point was that it is not /needed/ to destroy the key, so I'll stop
focussing on destroying the key... heh... :S

@_date: 2015-02-27 12:15:36
@_author: Peter Lebbing 
@_subject: German ct magazine postulates death of pgp encryption 
They are?
I can read German, but it is veeerryyyy slooowwww. So I'll probably not do that.
But I have a honeypot key on the keyservers that has a computer-generated random
e-mail address that does however exist. Anybody who looks at the name thinks
"huh?" but the purpose is to not catch spammers that simply address kathy@
peter@ john@ and variations on that, because they would be false positives for
the experiment.
Because the experiment is: does having an e-mail address on the keyserver
attract spam?
I reckoned that there's a good chance e-mail harvesters don't do any filtering
on unlikely local parts in the e-mail address; I think they'd rather not spend
effort on that and simply mail any and all addresses you find. That's insanely
cheap to do (since you use a botnet), and filtering might remove actual spam
So what did this key attract, being on the keyserver for four years now?
22 Nigerian 419 scams. That's it. Twenty-two! They came in batches; I haven't
seen anything since March last year.
I've kept this little experiment (which admittedly is rather small) secret for a
year, to avoid people with an agenda biassing the results. By then I had only
had one 419 scam. Even after I talked about it just a 419 scam every few months.
The latest one will celebrate its first birthday in 3 weeks! Hmmm.... I think
they might have stopped spamming that address.
I wonder if it says anything that all spams are 419 scams. Do they as a group
collect addresses differently than other spammers? Or is it simply that there is
only one person who harvests keys from keyservers, and his only customers are
419 scammers? Hell, the harvester could be the spammer; just one person.
Sooooo...... back to c't. Since they were writing an article, since they're
journalists, they should do some fact checking, right? Do they have proof, or a
strong indication that spammers use the keyservers?
Or is it the crystal ball "yes, but if more people start to use the keyservers,
then it will surely happen"? I've gazed in there and thought the same, but it's
not a fact and neither is the current keyserver network necessary for widespread
OpenPGP usage, IMHO.
Also, I've said it before: instead of saying "Let OpenPGP die", put effort in
getting something accepted by the mainstream that deserves to live! I think
right now we need an alternative for the e-mail infrastructure more than we need
an alternative to OpenPGP for our current e-mail. Work your way from the ground
up with security and privacy as a goal right from the outset. You could keep
legacy interfaces to the end-user (IMAP, SMTP), but the core should be replaced.
Upon this renewed core, we can build security and privacy.
When your housekeeper, mister Jones, is in his 70's and you need a new
housekeeper because the good man is simply getting too old for the job, what do
you say? "Wanted: good housekeeper, for two days a week, ..." etcetera?
Or "Let mister Jones die"?

@_date: 2015-02-27 15:09:01
@_author: Peter Lebbing 
@_subject: Thoughts on GnuPG and automation 
I'd say the JSON interface could just be an additional set of functions in
GPGME; and GPGME simply talks the old colon-separated protocol to the gpg
binary. You can't just take out the colon-separated protocol, and that protocol
has all the information. You could simply have GPGME reformat the output.
Unless you mean that you want to speak to the gpg binary yourself, without GPGME
in between. In that, case, I simply think you might be on the wrong track, and
should use a library. If GPGME itself is a problem because you don't know what
platform you should compile for, like in Python, then the library could be
re-implemented in pure Python instead of using a foreign function interface.
The old calling conventions of the binary cannot change, otherwise you'd break
everything that already depends on it. And adding multiple ways of doing the
same thing in the gpg binary seems the wrong place; more code, more chance of
bugs, etcetera. This is where libraries come in, to save you the burden of
working with the gpg binary.

@_date: 2015-02-27 19:43:12
@_author: Peter Lebbing 
@_subject: Whishlist for next-gen card 
I don't understand the practical difference between HOTP and the button
to confirm an action.
As it is now, it is the case that malware can sniff your PIN and use
that to use the card. When you add a button, it knows the PIN, but can't
push the button, so you're back in the loop. The malware needs an action
by you, the user.
If you use HOTP, the malware doesn't know the next HOTP to do an action,
which means it once again relies on you to enter the HOTP.
In the former, the user pushes the button. In the latter, the user
enters the HOTP.
What does the HOTP prevent that the button doesn't? And then I don't
mean "learning the PIN", but something that is a goal of an attacker.
Getting the PIN is only the means, their goal is, for instance, to
decrypt or sign. What goal can an attacker achieve when only the button
is there, not the HOTP?
I think the security benefit from having to enter your PIN on every
access is already very marginal, and outweighed by the burden of
entering the PIN. In other words, have the card remain unlocked and
ready for use with a single PIN entry. If you're working on a
compromised PC, you're already so screwed that your forced entry of the
PIN each and every time isn't going to help.
To me, the benefit of the button is that it is out-of-band. Re-entering
your PIN every time is in-band, and in my eyes, not worth it.
Are you proposing that the internal hash state after the hashing of the
document is handed over to the smartcard, after which the smartcard
computes the hash over the signature subpackets that you want protected
this way? It's unclear to me how you see such a thing be implemented
without passing all data to the smartcard.
I wasn't talking about what it shows me, I was talking about what is in
the challenge that is signed.
I've had a quick look in RFC 4252, with public key user authentication
for SSH2. I don't think there's anything that you can show on a display
that would help the user decide if it were what they wanted to see.
After a really quick glance in the RFC, I see just the username and the
session identifier. The username is hardly unique (I usually use peter),
and the session identifier is a unique number computed for the SSH
session. It's the bit that prevents signature replay attacks but is not
useful to show on a display, since the user can't tell whether it's good
or not: it's just the output of a hash function.
All this is based on a really quick read of documentation I hadn't
consulted before. It could be glaringly wrong. But when you said "it is
the fingerprint", I wondered if you misunderstood or that the
fingerprint is actually part of the challenge. I don't think it is.

@_date: 2015-02-27 22:49:28
@_author: Peter Lebbing 
@_subject: Whishlist for next-gen card 
I think you're confusing /host/ authentication and /user/
authentication. I was talking about using the auth key on your OpenPGP
card to do user authentication.

@_date: 2015-02-27 23:05:07
@_author: Peter Lebbing 
@_subject: German ct magazine postulates death of pgp encryption 
But what about that Man in the Middle who does nothing more than receive
your message encrypted to their key and forward it to the real recipient
you are building a trust relationship with? That MITM is following and
logging your interesting conversation without either of you noticing...

@_date: 2015-02-28 13:31:23
@_author: Peter Lebbing 
@_subject: German ct magazine postulates death of pgp encryption 
I think a bit of opportunistic encryption without proper identity verification
can be a very good thing. I was just pointing out that you need to know the
limits of that way of working, and make a conscious decision whether you need
proper verification or not.
But I didn't indicate that clearly enough.
PS: By the way, my ISP and some of it's employees are in a perfect position to
do a man in the middle. I sure hope they can't "just hack my system" because of
that position. The one capability certainly does not imply the other.

@_date: 2015-02-28 14:12:24
@_author: Peter Lebbing 
@_subject: German ct magazine postulates death of pgp encryption 
Let me stress again that the proper course might be to replace SMTP (e-mail) and
then work from that. If you have a sieve and wish for something to hold liquids,
you could plug up all the holes or say "Blow this for a lark" and get a pan.

@_date: 2015-02-28 17:10:28
@_author: Peter Lebbing 
@_subject: German ct magazine postulates death of pgp encryption 
Well, I think it's a bit grim to think that therefore a successor to replace
SMTP must surely be proprietary and centralized, and we should desperately
clutch to our last straw, SMTP. Plus, half the e-mail is  anyway.
Proprietary, and centralized. It can still communicate with the rest of the
world, but for most contacts, it doesn't need to.
But a large part of that is due to the fact that SMTP was never built to
accomodate any form of privacy or security.[1]
Hence my comparison of SMTP being a sieve and privacy being a liquid to
transport in that sieve.
I for my part think it's unrealistic to keep using SMTP. As I said, you can keep
the endpoint communication the same, but the core network needs to be designed
with a different goal than SMTP was designed for, to wit, privacy and security.
[1] At least where it concerns using OpenPGP for e-mail communication, which is
what we are discussing. I think most users of Debian properly use GnuPG for the
authentication of the package management, as an example.
PS: By the way, I think you don't mean "literally" in the first quoted
paragraph. Because then I need to read your words in a literal fashion, and
verbal communication qualifies, in a literal sense, as a messaging system and is
not proprietary or centralized.
PPS: I like the word "literal". It's the one word in the dictionary that can by
definition not be used in any other than its true sense :). It's comfortingly
solid in that respect.

@_date: 2015-01-02 17:11:19
@_author: Peter Lebbing 
@_subject: Craft public key so that private key equals given string (my 
This is possible with elliptic curve cryptography, although you should realise
that a passphrase usually contains a lot less entropy than a private key based
on random numbers. This means it is possible to try passphrases for your public
key and try them out as the secret key, which is not possible with ordinary
secret keys.
OpenPGP and GnuPG do not support this, though.
An example of software using this property of ECC keys is SECCURE[1]. This is
not a recommendation, and I'm also not recommending against it. I simply make no
statement as to its security. Other than what I will say now, that is.
The only input to key generation in SECCURE is your password; there is no
salting. The same password leads to the same public key.
If you were to use, for instance, PBKDF2 to generate the public key, you'd at
least strengthen the password against a number of attacks such as rainbow
tables. I don't know why the author of SECCURE didn't use that; it would
increase the size of the public key by at least 13 characters (making it 50%
longer) but it seems a good tradeoff to me.
[1]

@_date: 2015-01-02 17:14:22
@_author: Peter Lebbing 
@_subject: Craft public key so that private key equals given string (my 
Yes, that is perfectly possible. It is just as secure as using gpg's --symmetric
mode with the same password for each file you encrypt.
What feature are you asking for? It seems to me it doesn't need a feature,
doesn't need explicit support. You write a copy of the key to the same directory
as where you store the encrypted files. You write a script that fetches the
private key from there into GnuPG's secret keyring. GnuPG never needs to know ;).

@_date: 2015-01-02 17:37:19
@_author: Peter Lebbing 
@_subject: Key selection 
I respectfully disagree on both. Editing a revoked key might not have a use, but
editing an expired key is perfectly valid, i.e., to extend its expiry date.
The matching behaviour is also clear and known: without being specific, one of
the matching keys. While being specific and applying to 1.4 and 2.0: the first
one in the keyring. With all respect, that this doesn't match what you'd like
to see is something else than "this is clearly a bug".
And whether there is an easy fix can't really be said without knowing the
internal structure of GnuPG. I think matching the first key you find needs to
know nothing apart from the key ID and the UID's. Matching other
characteristics means you need to parse more details of the key, which might not
be done until after key selection. It is not clear cut that this is an easy fix.
It might be, it might not be. Patches might be welcome if it's a small patch
with clear behaviour, i.e., easily verified as correct and complete. I'm
inclined to think the patch is not that small and clear, though.
For the command line, it's a two-step process which requires the user to repeat
8 hex characters unless they have a mouse: they could also copy-paste. Surely
this is not much work.
$ gpg2 -k lebbing
pub   1024R/3E4FCA14 2006-03-31 [revoked: 2009-11-12]
uid       [ revoked] Peter Lebbing pub   2048R/DE500B3E 2009-11-12 [expires: 2015-10-27]
uid       [ultimate] Peter Lebbing sub   2048R/DE6CDCA1 2009-11-12 [expires: 2015-10-27]
sub   2048R/73A33BEE 2009-11-12 [expires: 2015-10-27]
sub   2048R/B65D8246 2009-12-05 [expires: 2015-10-27]
$ gpg2 --edit-key de500b3e
Possibly add a third step for a failed "gpg2 --edit-key lebbing" command as
the first step.
Conflicting short ID's make the first step above a bit more verbose but is
really rare:
$ gpg2 --keyid-format long -k lebbing
In this case, you might want to add keyid-format to your gpg.conf so you can
save on all that typing ;).
Conflicting long ID's are really, really rare but would make it a lot more

@_date: 2015-01-02 18:07:40
@_author: Peter Lebbing 
@_subject: Craft public key so that private key equals given string (my 
Minor nitpick: I meant 12 characters. I didn't want to think about it and simply
used 'echo 12345678|base64|wc' but that included the newline (should have
specified -n to echo).
And also, it's only an increase of 50% when you use a 160-bit curve; it gets
relatively less for larger curves.
The reason I'm taking 64 bits as the size of the increase is that PBKDF2
recommends at least 64 bits of salting.

@_date: 2015-01-02 21:35:12
@_author: Peter Lebbing 
@_subject: Craft public key so that private key equals given string (my 
No, I don't think this will become a feature :). However, if your OS is Linux or
something with the same "scripting power", you could simply have your script
create a tar file with the private key and the encrypted file, and a script that
unpacks the tar to a temp dir, imports the private key and decrypts the file.
All this could be done with a simple[1] bash script, tar, and some creativity.
[1] I think it would stay relatively simple, but you might have to think a bit
about it.

@_date: 2015-01-12 21:24:49
@_author: Peter Lebbing 
@_subject: gpg-connect-agent querying max-cache-ttl 
You're mistaken; it's as Patrick said through gpgconf, the program to
programmatically query the configuration.
$ gpgconf --list-options gpg-agent|grep ^max-cache-ttl: |cut -d: -f 10
But note:
The value is field 10, the default is field 8. So if the above command returns a
blank string, try:
$ gpgconf --list-options gpg-agent|grep ^max-cache-ttl: |cut -d: -f 8
Obviously you could do this in one go, doing your own parsing rather than
calling grep and cut, etcetera.

@_date: 2015-01-12 22:00:31
@_author: Peter Lebbing 
@_subject: gpg-connect-agent querying max-cache-ttl 
Oh ah!
Have you considered these two options:
1) gpgconf says the ttl is a 32-bit unsigned number. Have you tried entering the
value 4294967295 and making a mental note to rethink that strategy when your
system reaches an uptime of more than 136 years? (I got the impression you
didn't have ttl issues with your current solution, so I inferred this might be
because it doesn't expire).
2) You say you preset the passphrase with gpg-preset-passphrase. Have you
considered writing a wrapper script that does nothing but call
gpg-preset-passphrase and write a timestamp in some file? The actual ttl can
then be computed from the timestamp and the gpgconf output.
This might help you out without needing a feature that indeed isn't present AFAIK.

@_date: 2015-01-24 20:19:33
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
One man's paranoia is another man's common sense, I suppose. Since those
smartcards are pretty much exclusively used for security purposes, i.e., private
key storage, they're a likely target for an intelligence agency to try to subvert.
I've replied to this statement earlier, I won't repeat myself other than to say
I disagree.
Assuming it's not backdoored, yes. In the presence of backdoors this is
obviously not the case.
Yes, I agree.

@_date: 2015-01-24 20:25:25
@_author: Peter Lebbing 
@_subject: GPA fails to verify certain .asc files 
I think this might be related to this:
Quoting that mail:
Did the tool GPA just break? :). What is the proper solution anyways? A file
picker dialog for the signed data?

@_date: 2015-01-25 11:05:10
@_author: Peter Lebbing 
@_subject: GPA fails to verify certain .asc files 
I was postulating that the breakage might be related to the fact that GnuPG in
batch mode no longer verifies a detached signature as valid when it is only
given the detached signature, instead of the pair of signed file and detached
signature. This security fix was backported to 2.0 and 1.4, so it does apply.
I refer you to line 857 of src/engine-gpg.c in GPGME[1], which is used by GPA:
argv[argc] = strdup ("--batch");
I think it's quite likely --batch comes into play in your scenario, although I'm
not well acquainted with the source code.
By the way, I think it'd be helpful if you could indicate your distribution and
the version of GPA you use. Also, if you don't use the packages from your
distribution but instead compile yourself, that would of course be very valuable

@_date: 2015-01-25 12:05:58
@_author: Peter Lebbing 
@_subject: GPA fails to verify certain .asc files 
Hash: SHA1
So GPA never verified detached signatures in the first place? I read the
report by Philip as it being a regression, but when I reread, it doesn't say
so explicitly. The "hit and miss" doesn't actually say that it ever verified
It seems Philip is confusing signed files and detached signatures, by the way:
The first two are exactly equivalent. Neither three produce a detached
signature, which was the problematic case. The signed data is included in the
.asc file, not kept as a separate file.
This is the only one likely mimicking the files downloaded from the website:
an ASCII-armoured, detached signature.

@_date: 2015-01-25 17:25:04
@_author: Peter Lebbing 
@_subject: GPA fails to verify certain .asc files 
It was totally reasonable to bring this to the list, so no need to apologise
as far as I'm concerned.

@_date: 2015-01-25 17:51:59
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
I suppose you and I read the following statement from that mail by Werner
quite differently:
I don't see anybody in this thread saying the OpenPGP card is "secure", whatever
that is. In fact, the statement about Cyberjack is quantified in terms of ease
of implementation of a hack.
And I think the uncooperative attitude alone is a good reason to advise against

@_date: 2015-01-25 22:44:27
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
Werner has posted on this mailing list what he uses himself; I suppose a good
search term should turn it up rather quickly from the archives.
SCM is pretty okay; I use two of SCM myself (SPR532 and I believe SCR3310; not
sure of the latter type number). I forgot what that reader Werner
uses is called.

@_date: 2015-01-28 00:27:10
@_author: Peter Lebbing 
@_subject: Talking about Cryptodevices... which one? 
To put it in slightly different terms:
The AES key is only 16 or 32 bytes long (16 most likely). An RSA private key is
much longer. The 16 bytes holding the AES key are super well protected against
extraction, but this is expensive to produce on chip. The AES-encrypted private
key is stored in less protected memory, but the data is useless without
extracting the very well protected AES key.

@_date: 2015-06-09 13:49:22
@_author: Peter Lebbing 
@_subject: Hardware Keyring 
Just a quick scribble, not an extensive answer.
It's *not* open hardware. Only the specification is open. If you've
found the claim somehwere that it is open hardware, I think it would be
interesting to know where, so the webpage owner can be notified of the
mistake, or something.
It can be very difficult to make an open source crypto smartcard because
you usually have to sign NDA's and things to be able to use one. Open
hardware /with/ a crypto accelerator is definitely even more difficult.
Plus, how far do you go with "open"? Do you want the design of the chip
in the Hardware Description Language it was designed in? ("the preferred
form of the work for making modifications to it").

@_date: 2015-03-01 14:33:16
@_author: Peter Lebbing 
@_subject: German ct magazine postulates death of pgp encryption 
It was Werner who floated the idea of replacing SMTP here on gnupg-users. After
thinking about it, it made a lot of sense to me. You could search gnupg-users
for his messages about this. I had a real quick look and couldn't find it just now.

@_date: 2015-03-01 21:54:18
@_author: Peter Lebbing 
@_subject: Whishlist for next-gen card 
No, I'm talking about that as well. And I don't think the fingerprint of
the host is part of the signed data or the signature. Why do you think the
fingerprint of the host is part of that?
By /host/ authentication I mean that you verify that the host your are
connecting to is in fact the host you wanted to connect to; and /that/ is
through the public key of the host, of which you can verify the fingerprint.
Let's call this keypair A.
After you've verified the fingerprint, a copy of the hosts' public key, A, is
stored in ~/.ssh/known_hosts on your client machine.
But when the host is authenticating that you are in fact the user you are
claiming to be, you sign a challenge that only you could sign because you have
the private key, let's call it B. That is /user/ authentication.
The host checks that your public key B is in ~/.ssh/authorized_keys on the
server machine; if so, you're authenticated.

@_date: 2015-03-02 18:53:57
@_author: Peter Lebbing 
@_subject: German ct magazine postulates death of pgp encryption 
I think they basically completely control my system. For individual Debian
Developers, it might need some ingenuity to get something sneaky on my
computer, since they generally only provide source, and the binaries are built
on the Debian infrastructure. Mind you, I say they need some ingenuity, that
is a far shot from "it's difficult". But the keys that the package manager
checks? If you have those, and can get my package manager to download your
stuff, it's trivial to change any file, any binary, any program on my computer.
It has occured to me that I probably could simply local-sign and fully trust
all OpenPGP keys of Debian Developers, since if the holder of said key wanted,
they could simply hardwire my GnuPG installation to effectively do the same
without my consent. But still, I haven't done it :).

@_date: 2015-03-03 16:43:12
@_author: Peter Lebbing 
@_subject: Thoughts on GnuPG and automation 
In my opinion, if this is the case, then that is indeed the proper
solution: write a general-purpose library ? la GPGME, but don't call gpg
directly from your application.
Calling the gpg binary is indeed an API, as was said here. It's the API
GPGME uses, for instance. GPGME does not somehow load gpg in its address
space or something; it simply invokes gpg, in a separate process.
That calling the gpg binary is an API doesn't make it the right API for
other programs to use. The right API in general would be GPGME or an
alternative to GPGME.
Just like libc is the proper API for a program to use instead of
directly issuing syscalls to the Linux kernel. The syscall interface is
an API; it's just not the right one in many cases.
At least, this is my view of it.

@_date: 2015-03-03 19:09:32
@_author: Peter Lebbing 
@_subject: Thoughts on GnuPG and automation 
I have no idea about how difficult it is to launch the gpg binary with a
few pipes attached to a few file descriptors and perhaps anything else
you need.
But I fail to see why you brought it up.
I thought we were discussing two alternatives:
- Call gpg directly
- Use a library such as GPGME that calls gpg for you
In both cases, the gpg binary is executed as a separate process. So it
seems to me any issues with this are the same in both cases. In fact, if
it indeed is tricky as you say, you're better off if you have a library
do this for you, so you don't have to get it right in each and every

@_date: 2015-03-04 11:10:52
@_author: Peter Lebbing 
@_subject: Thoughts on GnuPG and automation 
Couldn't this be achieved by writing a C program that, for instance,
talks via JSON to you, and itself uses GPGME to call the gpg binary?
I think there is opposition to adding more stuff to the gpg binary. I
don't think there is opposition to you writing a program that uses GPGME
:). If it's good, it might be picked up for wider inclusion.
Since your Java/Python/etc program needs to install gpg anyway, it could
install the other C program as well. Packaging and distribution
definitely isn't a solved problem, but a separate one from what we are
now discussing, so let's not muddle this discussion by including it just
PS: When I say "you could write" I mean "someone could write"

@_date: 2015-03-05 15:10:25
@_author: Peter Lebbing 
@_subject: where can one find an official gnupg project statement on the 
I think you'll find that many distributions in fact backport security
fixes. Especially if they amount to more than a DoS. Debian, for
instance, has a policy to try and avoid new versions of software in
their stable version, favouring backporting fixes.
Why do you think an "official" (wouldn't be my words) package maintained
by an official GnuPG upstream, for instance, would be better than what
dkg does for Debian, for instance?
Which distribution's packaging are you dissatisfied with particularly,
and shouldn't you take this up with the maintainers of the package
rather than asking here for a different package for your distro?
I think sticking with your distribution's repository offers many
advantages: it works out of the box, you get security updates without
having to enter an additional repository in your package management, and
it leaves time for upstream GnuPG to focus on their software, leaving
packaging, and for instance packaging policy changes in a distribution,
to other people.
Plus, a fair number of distributions use GnuPG to authenticate the
software in their repository. It's part of the very core of the
distribution. It needs to be in the main repository, it needs to receive
security fixes. If you feel the packaging of GnuPG is lacking in your
distribution, you should definitely take that up with the maintainers there.

@_date: 2015-03-11 20:06:54
@_author: Peter Lebbing 
@_subject: AES-NI, symmetric key generation 
The passphrase-based encryption of GnuPG is entirely specified in RFC
4880, and there is no reason to worry that future versions of GnuPG
cannot read a symmetrically encrypted file created now.
Also, it is *not* the case that the key used to encrypt the data is the
key derived from your password!
The key to encrypt the data, the session key, is randomly generated. The
passphrase is used to derive a key, and this derived key is used to
encrypt the session key, and only the session key!
However, I do notice that RFC 4880 allows the use of a password-derived
key to encrypt the data[1]. I don't think GnuPG will generate such
OpenPGP messages, but it might accept and decrypt them.
[1] RFC 4880 section 5.3:

@_date: 2015-03-13 11:25:58
@_author: Peter Lebbing 
@_subject: Enigmail speed geeking 
And what if your hard drive holding your on-disk key crashes? Do you
also "socialize" a new key?
Of course not (I hope). You keep a backup of your key in a safe place.
This goes for smartcard keys as well. The situation is the same whether
you use a smartcard or not.
For signing subkeys, a backup isn't very necessary, not for on-disk keys
or for smartcard keys. But for your primary key and especially
encryption subkeys, this is important.
Not having a backup of your encryption subkeys means a not very robust
single point of failure, and if that hard disk crashes, or the file
system is corrupted, or your smartcard dies, you suddenly lose access to
all your encrypted files.
I cannot fathom why you would not have at the very least one backup of
your encryption subkey. It sounds like a phenomenally bad idea.

@_date: 2015-03-13 15:22:20
@_author: Peter Lebbing 
@_subject: Enigmail speed geeking 
I interpreted Dougs message as saying that a disadvantage of smartcards, as opposed to on-disk keys, is that you lose the key when the smartcard stops functioning. I was replying to this statement by So I say: you should use backups, duh.
The fact that you /can/ use a smartcard without a backup, which as you say can be advantageous, by no means implies that you /cannot/ keep a backup. This is what I was saying.

@_date: 2015-03-13 15:40:17
@_author: Peter Lebbing 
@_subject: Enigmail speed geeking 
When you ask GnuPG to create an on-card key, it will ask you whether you want to keep a backup of the key or not.
If you choose to proceed without a backup, the key is generated on-card. I consider this the inferior of the two methods because I trust the RNG of Linux much more than I trust the RNG of a smartcard that costs a few euros to produce.
If you choose to have a backup, GnuPG will create the key just as it would for a normal on-disk key, and then upload that key to the smartcard and keep a backup file. This thus uses the RNG of your PC; on which I would be running Linux.
You could then discard the backup if you want to have the quality of the RNG of the PC but don't want the backup.

@_date: 2015-03-13 22:17:23
@_author: Peter Lebbing 
@_subject: Enigmail speed geeking 
It is true, text is a truly god awful medium to communicate in.
We are apparently completely unaware of each other's intentions. I honestly thought you thought a disadvantage of using a smartcard is that you lose the key once it breaks. It quite surprised me, but I've seen smart people have odd misconceptions of things[1], so I simply sought to rectify it.
Let's put this whole thing to rest. Nobody thinks you can't have a backup of a smartcard key, nobody thinks that a smartcard without a backup is a useless thing, and we should all go and read a nice book. Perhaps even for the third time, in my case. It's a nice book!
[1] Sometimes in the mirror ;P

@_date: 2015-03-13 22:26:21
@_author: Peter Lebbing 
@_subject: Enigmail speed geeking 
Make that: I trust the RNG of GnuPG. There's more to it than what is provided by the Linux kernel. I should have acknowledged this extra work done by the GnuPG developers.

@_date: 2015-03-14 10:59:02
@_author: Peter Lebbing 
@_subject: Enigmail speed geeking 
I trust both /dev/random and the sanity of the default settings of
GnuPG. And when I'm generating a key in GnuPG, I put my trust in both. I
don't know what is all going on in GnuPG for generating the highest
quality of randomness, but it's more than "cat /dev/random". It was
simply incomplete to just say "Linux's RNG", and it didn't acknowledge
the effort the GnuPG developers put into the code that generates the

@_date: 2015-03-16 11:16:44
@_author: Peter Lebbing 
@_subject: Making the case for smart cards for the average user 
Perhaps the SIM cards are relatively well protected from remote access;
the session keys for GSM communication are not. IIRC, it requires an
on-line attack and would leave traces as soon as GSM network operators
started looking for such attacks, so it's less sneaky. But there were
two interesting talks on the subject at the 31C3:
Apparently GCHQ still wanted the SIM keys, though :).

@_date: 2015-03-17 18:35:13
@_author: Peter Lebbing 
@_subject: possible sshcontrol flag for ssh key comment? 
I don't fully understand what you're trying to accomplish, or what you
exactly need. Sorry about that. I hope my reply might help you though.
I don't think "identityFile" still does anything when you use an agent,
or at least with GnuPG as an agent. Because it is the agent's
responsibility to keep keys, and you're changing the config for the ssh
program, which merely asks the agent what it has. I think.
With SSH2 keys, the comment is simply appended to the public key.
There's nothing more to it.
So I went with the following workflow:
First, I added the key in ~/.ssh/id_rsa to the gpg-agent. The public key
for that is already in ~/.ssh/id_rsa.pub, so I didn't need to extract
that from the agent.
Then, I inserted my OpenPGP smartcard with an authentication key. I
understand you're probably not using a smartcard, but I'm talking about
what I did :). It hopefully allows you to adapt it to your situation.
The smartcard key is automatically added to the ssh agent component of
gpg-agent. But, like you, I still need it's public key in SSH format to
paste in ~/.ssh/authorized_keys on the machines I want to login to, like
you need it to give to gitolite.
I do:
$ ssh-add -L
ssh-rsa AAAAB3N[...]TrnoZzZdHJ cardno:000500000241
ssh-rsa AAAAB3N[...]TAiuL0Iw== /home/peter/.ssh/id_rsa
Now gpg-agent was kind enough to provide a comment that allows me to
distinguish them on sight. If there is no comment field, simply look at
the actual base64 key to see which one you're /not/ interested in, by
comparing to ~/.ssh/id_rsa.pub, for instance.
Now I copy the line ending in "cardno:[...]241" to the clipboard, and
open an editor for the new file ~/.ssh/id_card.pub. I paste from the
clipboard, but change the end:
ssh-rsa AAAAB3N[...]TrnoZzZdHJ peter at OpenPGPCard
All my SSH keys are of the form peter at hostname, and usually stored in
~/.ssh/id_rsa.pub. The filename and comment form are just to fit in with
the rest. It's free-format.
Now whenever I need to add that public key to a ~/.ssh/authorized_keys,
I don't use ssh-add -L, I simply open ~/.ssh/id_card.pub and copy it
from there. As I said, in SSH2 public keys, the comment is just text
appended to the key; there's nothing relating to it in that blob of
base64. You can just edit it with a text editor and store the result
wherever you like.

@_date: 2015-03-17 21:54:36
@_author: Peter Lebbing 
@_subject: Copy Current GPG Installation to Another Server 
Why is that? I understand getting a validated key can be tricky in
practice, but on the other hand, using *just* a short key ID to do your
verification feels like the other end of the spectrum... I think you
should at least verify the fingerprint on a web site or something.

@_date: 2015-03-17 22:15:15
@_author: Peter Lebbing 
@_subject: Copy Current GPG Installation to Another Server 
It's just as good as verifying the signature of a key with short ID 4F25E3B6. As
you can soon see elsewhere in this thread, I don't think it practically adds
anything. Proper verification of the key requires not relying on the short key
ID, or even the long one for that matter. It means you check the fingerprint of
the key, which is much longer.

@_date: 2015-03-17 22:19:07
@_author: Peter Lebbing 
@_subject: Copy Current GPG Installation to Another Server 
Assuming they're all protected by https, nothing.
What does verification of that signature buy you though? That your download
wasn't corrupted?
If I were to place something nefarious inside a GnuPG download, I'd sign the
result with a key I created with the short key ID 4F25E3B6. That way, your
--recv-key command will retrieve both my key and Werners, and the signature will
happily validate. Creating a short key ID collision is peanuts and can be done
with off-the-shelf software on a laptop.
This rakes in not just the people who don't check the signature, but also all
those who just verify the short key ID. Since it's hardly any effort, I'd do it,
even though it probably only gains me a few percent coverage.
No, but I'm also not telling people they can verify using the short key ID. No
guidance is better than wrong guidance, IMHO. No offence meant, I appreciate you
helping him out. I'm just trying to give some constructive criticism.

@_date: 2015-03-17 22:56:15
@_author: Peter Lebbing 
@_subject: Copy Current GPG Installation to Another Server 
No, I think that's what I mean as well. If they all come from the same source,
it gets you nothing to check the signature. So I don't see why you would verify
the signature at all.
By creating a short key ID collision, I'm also getting those people that read
your e-mail or a similar thing somewhere on the web, and just download the short
key ID. I'm also getting those people that get a "BAD signature" and then do a
new --recv-key with the short key ID in an unfortunate attempt to get it to
verify ("hmmm, maybe it has expired?").
Like you said, I passed a big hurdle. I'm either MITM, or I write-accessed the
ftp server of gnupg.org. Why stop there when it's so little effort to create a
short key ID collision? It sounds fun in a perverse way.
But back to my primary objection:
I consider it bad advice to tell someone to rely on the short key ID. Sounds
like a bad habit potentially getting bootstrapped to me.
That's really all this is about.
You could also say they should check the sha1sum, like Clark ended up doing. Or
gpg --fingerprint -k 4F25E3B6
and checking it says
pub   2048R/4F25E3B6 2011-01-12 [expires: 2019-12-31]
      Key fingerprint = D869 2123 C406 5DEA 5E0F  3AB5 249B 39D2 4F25 E3B6
uid       [  full  ] Werner Koch (dist sig)
sub   2048R/AC87C71A 2011-01-12 [expires: 2019-12-31]
with a little caveat that you should actually get the fingerprint from somewhere
trusted, not from a stranger. That would already go a long way. When I include
non-trivial code to be entered on someone's PC, I always include the disclaimer
"Please understand what you are doing here, never enter on your PC what a
stranger on the internet tells you to". At least, I think and hope I do, might
have forgotten in my enthousiasm sometimes.
Or don't check at all and simply see if it crashes during installation. I
wouldn't be surprised if it included a checksum in the .exe as part of the
But we obviously disagree in an informed way. I know I can be rather principal.
Thanks for appreciating my enthousiasm though :).

@_date: 2015-03-17 23:02:11
@_author: Peter Lebbing 
@_subject: Copy Current GPG Installation to Another Server 
Hah! Obviously it wouldn't say "full", firstly because you need list-options
show-uid-validity in your gpg.conf, and secondly because the whole issue here is
you didn't have a trust path to that key. I met Werner at the 31C3 this
December, so I can in fact now finally check the validity of this key! :)
Should properly read stuff I copy-paste before I send the message...

@_date: 2015-03-18 00:17:40
@_author: Peter Lebbing 
@_subject: Copy Current GPG Installation to Another Server 
I'm not asking for anything. I suggested they check the plain SHA1 checksum or even not check at all! I'm merely opposed to making people think the short key ID is any good for verification purposes, or that "when it comes to signed packages [it] is not really a necessity" to check the validity of the signing key.

@_date: 2015-03-26 21:54:58
@_author: Peter Lebbing 
@_subject: PGP/MIME 
With IMAP, you can run searches on the server as well (I'm assuming you're talking about a local search because you mention your client, not your server software). A good IMAP server could get you the search results quickly. And it can probably avoid searching the attachments; I think a lot of that 12 GB is attachments?

@_date: 2015-03-28 18:05:05
@_author: Peter Lebbing 
@_subject: One alternative to SMTP for email: Confidant Mail 
No, but nobody said the adjective was used tautological.
It's like someone says "they're doing shady business in a dark alley"
and you protest "Hey, I know plenty proper businesses that are just
upstanding people making sales! In fact, I also know plenty alleys that
let in a lot of sunlight..."

@_date: 2015-03-29 19:36:02
@_author: Peter Lebbing 
@_subject: Instructions for converting keyring for 2.1 
I just followed the instructions on [1] for converting your pubring.gpg to the
new keybox format. I discovered I needed --import-options import-local-sigs on
the import command to also import my local signatures, which obviously is very
desirable when converting your public keyring... it's a bit lossy otherwise :S.
Here's a diff for the gnupg-doc git:
diff --git a/web/faq/whats-new-in-2.1.org b/web/faq/whats-new-in-2.1.org
index bc312da..1056dd0 100644
--- a/web/faq/whats-new-in-2.1.org
+++ b/web/faq/whats-new-in-2.1.org
 -561,7 +561,7  then run import, and finally restore the ownertrust values:
 $ cd ~/.gnupg
 $ gpg --export-ownertrust >otrust.lst
 $ mv pubring.gpg publickeys
-$ gpg2 --import publickeys
+$ gpg2 --import-options import-local-sigs --import publickeys
 $ gpg2 --import-ownertrust otrust.lst
 [1]

@_date: 2015-05-06 12:00:20
@_author: Peter Lebbing 
@_subject: Incorrect general key info, for key on Yubikey NEO 
I can confirm this behaviour with multiple versions.
On a Debian wheezy/oldstable, normal gnupg2 package, with surgically
altered secret key such that the primary key is on one card, and the
subkeys are on another:
------- 8< ------------ >8 ------- 8< ------------ >8 ------- 8< ------------ >8 ---------------------
This latter installation also uses the card with serial 274 for the
primary key.

@_date: 2015-05-12 11:59:34
@_author: Peter Lebbing 
@_subject: WINDOWS - Adding passphrase to gpg via command line 
(Could you please not top-post and trim your quotes)
Often, this is not useful on a server. When someone gains access to the
processes that do the decryption and/or signing, they already have
access to the decrypted key material by virtue of the key being unlocked
and ready to use.
Another reason to encrypt a file (in this case the private key) is so it
doesn't end up in backups in unencrypted form. For GnuPG keys, it might
simply be sensible to arrange for backups to not include that file, and
handle the backing up of secret key material separately. This is
relatively little overhead because a secret key doesn't change often anyway.
Well, you quote an old thread from this mailing list. Later on
in the thread, Werner chimes in[1] about gpg-preset-passphrase and its
usage, however it seems you are using it wrong. You said you did:
That seems to miss the most crucial part of the whole command: the
keygrip of the key. Also your described behaviour of "it just sits there
in cmd on the next line doing nothing" doesn't seem like it is working.
So perhaps you should reread [1].
By the way, you should probably have gpg-preset-passphrase interactively
query you for the password, because including it in the command line
defeats part of the use of encryption (anyone logged in to the server
can observe the passphrase). And if it's in a startup script like that,
it wholly defeats the purpose of encryption and is a generous helping of
snake oil.
I was surprised to read that the person in that thread actually managed
to pipe in the password like that without anything like --passphrase-fd.
I wouldn't expect that to work, and it seems like a lucky hit, for some
definition of lucky. It also seems to serve no purpose at all. Not only
is the passphrase visible for anyone logged in at the moment the command
is issued, also it's part of the script and thus the data on disk. It
seems to be there just to comply with some ill-defined "keys need to be
encrypted" requirement, following the requirement to the letter rather
than to the spirit.
[1]

@_date: 2015-05-15 21:24:02
@_author: Peter Lebbing 
@_subject: Removing hkp from server 
No, that is not possible. Do you still have the private key? Because as
long as you still have the private key, you can still generate a
revocation certificate and upload it. That's the only way to flag a key
as unused or wrong.
Otherwise, you'll just have to accept that these keys turn up as a
search result. Normally, what counts is the signatures people place on
the keys to gain trust in them, so that should not be a problem. Old
unused keys are just noise, and the keyservers are full of them,

@_date: 2015-05-24 12:58:21
@_author: Peter Lebbing 
@_subject: Trying to install version 2.1.4 
It would be very helpful if you could share the actual commands you entered
and their output. This is just an interpretation of what happened, and makes
it impossible to give an answer as to what went wrong.
By the way, since you say you really want the latest, I assume 2.1.3 from the
Debian experimental "distribution" is too old for you? Because that is very
easy to install on jessie; it's what I do.
When it doesn't come from a Debian package but is something you installed
locally: the stuff will definitely not be re-installed.
In fact, having both the Debian gnupg2 package and your local GnuPG 2.1.4
installed at the same time might give subtle but show stopping issues down the
line... In my crystal ball, for instance, I foresee private keys, especially
smartcards, stopping to work in some graphical frontends, but not all ;).
(Stuff will start to depend on the precise combination of /usr/bin/gpg2 or
scdaemon, stuff like that).
Well, yes, but it's not recommended. You can fool the package system into
thinking that you have the gnupg2 package installed, and install your own,
unmanaged instance of 2.1.4. But it's really not recommended. I hesitate to
direct you down that path.
You can easily upgrade it to 2.1.3 by using the experimental "repository".
Come to think of it... you could perhaps make your own .deb package by taking
the source for 2.1.3 from experimental and upgrading the source in there to
2.1.4. I think that is actually the best way to go if you take for granted
that you really, really want the latest version. Otherwise, I'd stick with
It might also be that the package maintainers (hi dkg!) might soon put 2.1.4
into experimental themselves. So it really depends on how far you want to take
this "I need the latest and greatest".

@_date: 2015-05-24 19:03:09
@_author: Peter Lebbing 
@_subject: Trying to install version 2.1.4 
GnuPG 1.4.x and GnuPG 2.1.x are co-installable. You will not have any problems
with those two installed side-by-side.
The issue is that OP can't uninstall the gnupg2 package without it removing
other packages (like graphical frontends for GnuPG, I suppose). So he's facing
the situation that he can't install GnuPG 2.0.26 and GnuPG 2.1.4 side-by-side.
If he were to install 2.1.3 from the experimental gnupg2 package, that would
removed by removing the gnupg2 package.

@_date: 2015-05-27 12:03:00
@_author: Peter Lebbing 
@_subject: installing version 2.1.4 in Debian 8.0 (Jessie) 
I wouldn't recommend it, since you might change it for scripts and
programs as well as for yourself, and the programs will expect GnuPG
1.4. It might in some cases matter.
If you find adding the 2 tedious, you could make a symlink titled "g" or
"gp"... that way, you save a letter instead of having to type one extra,
and there is no chance that any script or program that executes "gpg"
expecting 1.4 will accidentally pick your symlink.
And the safest place anyway for such a symlink would be in $HOME/bin,
since this will keep it out of sight of programs that just use the
system-wide $PATH.
$ cd
$ mkdir bin
$ cd bin
$ ln -s /usr/bin/gpg2 gp
I think your .profile likely already contains the following:
# set PATH so it includes user's private bin if it exists
if [ -d "$HOME/bin" ] ; then
    PATH="$HOME/bin:$PATH"
And in that case, you need to log out and log back in and the directory
will be added to your $PATH. Under X, you probably need to log out of
the whole X session, not just start a new terminal.
Could you please trim your quotes?
And unfortunately, by replying to the digest, you break threading of the
conversation. People that use a threading mail viewer see all
conversations on the mailing list grouped by individual conversation.
When you reply to the digest, this appears as a new conversation rather
than a follow-up to the existing conversation.

@_date: 2015-05-30 11:57:29
@_author: Peter Lebbing 
@_subject: Trying to install version 2.1.4 
I hope you didn't interpret my message as pressuring you to package the
latest version, because it was in no way intended to be! I simply
factually noted it wasn't unlikely that it would be packaged soon, and
as I suspected you might be reading that message, it was just a cheerful
shout out or something equally silly.

@_date: 2015-11-18 13:08:14
@_author: Peter Lebbing 
@_subject: best practices for creating keys 
I disagree, I'd recommend people not to read that article, let alone
follow its advice.
He sounds convincing, but I'd much rather point people to Rob's answer
in this very thread[1] instead.
And just stick with the defaults.
By the way, this "Creating the perfect keypair" webpage has come up
multiple times on this list already. If you want some more thoughts
about it, use your favourite search engine.
[1]

@_date: 2015-11-18 15:15:40
@_author: Peter Lebbing 
@_subject: What causes this bad signature 
Actually, I understand what he means, I just don't know how to
investigate further. I tried with --debug-*, but I got no more info, and
was at a loss how to continue right there and then, so I didn't post a
Note the sig-3 line; the dash indicates a bad signature, as the man page
indicates for --check-sig. Additionally, GnuPG outputs the line:
which he didn't include in his quote because he trimmed the console
output; it would have included about 55 other signatures, so I get why
he did that ;).

@_date: 2015-11-18 19:33:14
@_author: Peter Lebbing 
@_subject: What causes this bad signature 
I could not reproduce this:
I have just now issued a signature on 0xDCDFDFA4 with 0x2C53B2ED. To do
that, I had to unexpire the latter, but I first made a backup of the
expired key. After putting the expired key back, the signature is still
shown as succesfully verified, not as bad.
So a signature by an expired key is not necessarily seen as a bad
signature. Either your explanation is incomplete or it is incorrect...
But thanks for looking into it! I never thought anything of the fact it
was expired; I probably never noticed?

@_date: 2015-11-21 12:07:37
@_author: Peter Lebbing 
@_subject: Crowdfunding USB Security Key for Email- and Data-Encryption 
I suppose by "serious" you mean "defined as 'Critical' in the pentest"?
There are unfixed issues with severity "High":
NK-01-008 OTP can be unlocked by replacing Smart Card (High)
NK-02-006 Micro SD and Smartcard Slots lack ejection switch (High)
Personally, I don't really see yet why the latter is so important;
however, gaining the ability to issue OTP's by simply inserting my own
OpenPGP card with my own PIN seems serious? Do I misunderstand it? Or is
it not part of the threat model because the attacker is unable to
extract the key used for OTP generation?
Anyway, thanks for all your work on the Nitrokey series! I think it's
great you put so much effort into creating these nifty devices.

@_date: 2015-11-21 13:09:57
@_author: Peter Lebbing 
@_subject: backing up keys 
Let's look at this at three levels:
1) What GnuPG actually does when you invoke --export-secret-key
GnuPG outputs both a "Secret-Key Packet" as well as all UID's and
binding signatures. It might output all certifications by others on the
key as well; I'm going to write a separate mail about this.
2) What is in a "Secret-Key Packet"
3) What you can do with just the RSA elements p, q, e, and optionally d
and u.
You could create a key that allows you to decrypt your encrypted data,
although you might have to jump through some hoops regarding the
To be able to recreate a key with the same fingerprint, you additionally
need to know when you created your key down to the very second. This
means that even if you can reproduce your UID from memory perfectly, any
signatures you issue will not be recognised by your peers and all
certifications on your UID are lost unless you have memorised the very
second the key was created.
All in all, I wonder: did someone tell you you could recreate your
public key using just the secret parts? Have you tried it yourself? As
far as decryption goes, I might agree, but when you say
I think you're talking about regaining certifications from others, and
for that you really do need the creation timestamp down to the second.
This is an oversimplification. A symmetric key has no structure; it is
just data. RSA, on the other hand, has specific mathematical properties.
The numbers p and q are primes, which are spaced rather far apart on the
number line; all numbers in between would make valid symmetric keys, but
not valid primes for RSA. As a consequence, the information content in
the number is lower. In practice, OpenPGP private keys also include the
numbers d and u, which in fact can be computed from p and q (given e,
which is usually a constant), so hold no additional information content
at all.
It is claimed (though not universally) a 2048-bit RSA key is about as
strong as a 112-bit symmetric key. If we take this to be the truth, then
remembering a cryptographically random 19-character base64 string and
using it as a password for your secret key would balance the relative
strengths, and brute forcing the "passphrase" is just as hard as
brute-forcing the public key to reveal the secret key. 112 bits is a
full order of magnitude smaller than 2048 bits; there is no need to put
a passphrase with 2048 bits of randomness on your key to balance it out.
An OpenPGP Secret Key Packet is identical to the public key packet, but
with the secret material appended to it. Paperkey just stores this
appendage, and uses the public key to reconstruct the secret key from
it. So when you print out the result of --export-secret-key, most of
what you are printing is actually the same stuff that is in the public
key, and you can just store the public key anywhere without stringent
security requirements; in fact, it's often available on the keyserver
network. Paperkey just stores the non-redundant bit, which is much smaller.
There certainly is checksum data in OpenPGP packets, and the fact that
your key doesn't work is a checksum in and of itself. There is no error
correction, other than that it is mathematically possible to reconstruct
a prime from a slightly corrupted copy, and furthermore that the numbers
d and u can be recomputed when p and q are still intact, and that p can
be computed from the public key when q is intact, and vice versa. So
basically, all you need is either p or q to be intact. I'm not now going
to spend time thinking about whether u or d is actually enough already.

@_date: 2015-11-21 13:24:50
@_author: Peter Lebbing 
@_subject: backing up keys 
Okay, it turns out it was a weird issue with my keyring. In fact, GnuPG
would seem to always output all certifications with
--export-secret-keys, and it does not honour --export-options
export-minimal or export-clean.

@_date: 2015-11-22 12:55:55
@_author: Peter Lebbing 
@_subject: Crowdfunding USB Security Key for Email- and Data-Encryption 
My guess is the OTP shared secret is stored in the non-volatile memory
of the microcontroller (in plaintext). That memory is reasonably well
protected against reading out (when properly configured). Sure, it's
possible with a lab, but it's not cheap. If such adversaries are in your
threat model, my guess (again) is that the OTP feature of this stick is
not aimed at you.

@_date: 2015-11-23 11:15:26
@_author: Peter Lebbing 
@_subject: Crowdfunding USB Security Key for Email- and Data-Encryption 
Ah, that makes sense! I forgot about that because I myself would
actually like an OTP protected by PIN as complete two-factor solution
(have the device, know the PIN). But that is an uncommon scenario.
Can I suggest you document this well so people know the limitations of
the functionality? As a part of that, I'm sure you are aware a physical
button is out-of-band (a remote attacker can't press it), but a remote
attacker can send a PIN to the smartcard.
I read this part of the pentest document as a bundle complete with a
supercap to keep the power applied when unplugged and the part where
there is tamper detection. All three together make sense, the tamper
detection beating the pupil[1].
But the odd thing there is that the ejection switch is rated high
importance, but the others medium.
Thanks for your explanation!
[1] With his own soldering iron, if need be ;P.

@_date: 2015-11-23 17:54:51
@_author: Peter Lebbing 
@_subject: best practices for creating keys 
Okay, so let me answer this one detail:
Separating encryption from signing is a general advice (and done by
default) because there is a range of subtleties that are avoided by this
simple action. This affects how your keys are actually *used*, not *usable*.
However, one who has access to the private part of the primary key can
easily change the capabilities of the primary key to add signing as a
capability, even if you had it removed. There is not enough reason to
separate certifications from data signatures to make it the default.
Whether there is reason at all from a cryptographic standpoint, I do not
know. But it is certainly nothing to be worried about, or it would have
been dealt with in the defaults.
No, signing other people's keys is known as certification, and is
something that can *only* be done by the primary key. If you have an
offline primary key, you would use an offline system that has the secret
part available to sign other people's keys, and then transfer the
signature from that offline system.
Or if you only delete the primary key from your laptop but still have it
on your desktop, you'd use the latter. For that setup, you could create
a signing subkey for your laptop to use without removing signing
capability from your primary key.
Yes, well, most importantly, maybe their threat model is different. In
this specific case, note that a signature by a Debian developer means
that, by and large, any Debian machine on the planet will trust the
software update that that signature validates and install it on the next
system upgrade. That's quite an important signature.
Normally, a Debian dev can only upload source code, not binaries, but
it's still a significant amount of power.
Yes, but the defaults are sane, so there's no need to fiddle with things
that are different from the defaults. It's all the other stuff you
should be meticulous about.
Furthermore, all is not lost if you wish to swap your primary key. Many
people will accept a transition statement and issue a signature on your
new key. Also; the Web of Trust is overrated, and you can probably
persuade your friends more easily to recertify.

@_date: 2015-11-27 11:32:37
@_author: Peter Lebbing 
@_subject: best practices for creating keys 
Well, GnuPG doesn't provide an easy means to change them; it could be
that you would need to edit the source. However, that is hardly an
obstacle for an attacker who can write C code...
It shouldn't be difficult to write an ugly little hack to replace your
capabilities. The first thing that comes to mind is changing the code
creating the signature that extends the expiration date to create the
signature that sets capabilities. Compile, run, throw away.

@_date: 2015-11-27 12:28:07
@_author: Peter Lebbing 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
Are you sure? I can't export an unprotected private key. The topic has come up
earlier on this mailing list, in [1].
If I have a passphrase on a private key, and I export it, it prompts me for the
passphrase and the exported key is protected by the passphrase.
If I don't have a passphrase set for a key and I export it, it prompts me as
If I don't enter a passphrase, it prompts me again warning me this is a bad
idea, I stubbornly choose "Yes, protection is not needed". Then the terminal
And it fails.
I think it makes sense to be able to store a private key without a passphrase in
a safe place (as in: an actual safe), so you don't run the risk that you forgot
the passphrase. Currently, this is not possible, but of course you can use the
passphrase "passphrase", make a note that that is your passphrase and store the
note in the same safe.
[1]

@_date: 2015-11-27 13:10:11
@_author: Peter Lebbing 
@_subject: best practices for creating keys 
Thanks for the pointer!
I agree for the most part. I'm not so sure about how easy it is to refrain from
using an A-capability. I think when an SSH server indicates it accepts a
signature from my primary key, and that primary key is on a smartcard, GnuPG
will try to do that. So that is in the hands of the server, not the client.
Although you might be able to disable it with an sshcontrol file, I'm not sure
of the exact way it all interacts.
Kill that client software until dead. Then some more.

@_date: 2015-11-28 16:36:11
@_author: Peter Lebbing 
@_subject: [RFC] Keychain for GPG, SSH, X.509 etc. (inspired by Split GPG) 
Could you outline a sequence of steps that goes wrong without your
solution and right with it?
- SSH to compromised PC
- Use SSH agent forwarding
- While logged in to compromised PC, SSH from there to another
- Compromised PC opens whole host of SSH connections purporting to be you
- Keychain confirmation server comes in guns blazing, data center
containing compromised server turns into mushroom cloud
- Mushroom clouds don't impersonate sysadmins
I'd like to see a detailed usage scenario. Preferably with mushroom clouds.

@_date: 2015-11-30 20:53:29
@_author: Peter Lebbing 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
It is a specific bug of GnuPG 2.1, and Werner's comment on the bug entry
mentioned here makes me believe he intends to fix it eventually.
GnuPG 1.4 and 2.0 can export keys without passphrases, and this is fully
defined in RFC 4880.
Yes; that's because there is a difference between not encrypting stuff
and encrypting it with an empty passphrase :). The latter is just silly.
The only purpose of doing that is to be able to tell your client that
you "encrypted it" without technically lying. And I'm not making stuff
up. This actually happens (I'm looking at you, DropBox!).
When a private key is stored without a passphrase, it is stored without
encryption. The actual packet looks different: it clearly indicates that
what follows is plaintext. If you were to encrypt it with an empty
passphrase, it would actually be encrypted, but with a key that
corresponds to an empty passphrase and hence would be trivially cracked
by anyone.

@_date: 2015-10-01 11:52:19
@_author: Peter Lebbing 
@_subject: Local PAM authentication with OpenPGP Card (was Re: PAM 
For me, it's about getting rid of the root password altogether.
Authentication as root can only be done with an OpenPGP Card and its PIN.
Or by booting the system into single user mode ;). Your comment
regarding securing the room is very true: once someone has unfettered
access to the machine, it's near impossible to secure. This is not a
threat model I consider. Once they have physical access to the machine,
I give up.
I'm primarily (though not exclusively) talking about machines that
normally run headless. But sometimes you can't use SSH with an OpenPGP
card to solve a problem, for instance if it's the network that is not
working. So you really need to connect a monitor to the system and do a
local login.
Thank you for your response and giving it thought!

@_date: 2015-10-01 12:35:09
@_author: Peter Lebbing 
@_subject: How to get your first key signed 
Well, it doesn't help me at all to know that the developer of said
software indeed has "David Niklas" on his passport. That gives me no
more confidence in the integrity of the software than if he had a
different name. All I need to know is that that piece of software that I
previously trusted has had an update written by the guy or girl I trust,
regardless of his or her name.[1]
I don't understand "it's only really a checksum". The key property is
that it's signed by the same developer each and every time. A checksum
has very different properties, but I might simply misunderstand you.
No, it should not degrade the key's value. Unfortunately the key's value
is in the eye of the beholder, and that eye is often not fully aware of
the lack of implications an untrusted signature has. An untrusted
signature has precisely one implication: useless baggage. It neither
increases nor decreases the value of the key it has signed.
One of the people who's key I've signed at a keysigning party gained a
signature by Adolph Hitler. Enter Godwin's Law. Anyway, he revoked the
key. I can understand that. It just looks bad when someone uses the web
interface of a keyserver to look up his key. But it doesn't degrade his
key in any way other than what is a misperception. Only trusted keys
matter. Untrusted keys can be wholly ignored. Even if they are from the
It /is/ totally meaningless. And we should educate users that it is
[1] If some really persistent threat was Man In The Middle all the time
I downloaded the software and the key, they could replace the key all
that time by their own. Then at some point, when I trust the wrong key,
they could still do something nasty with the software. But this is a
much higher bar than once MITM'ing and inserting nastiness.

@_date: 2015-10-01 14:32:37
@_author: Peter Lebbing 
@_subject: How to get your first key signed 
Well, first of all, a checksum is not a cryptographic hash. It has
different properties: a checksum usually has no collision resistance.
Which is why the designers of WEP should have never chosen CRC-32 to
protect their data, especially since said data was encrypted with a
stream cipher[1]. Anyway, it was not the most important shortcoming of
WEP, so it doesn't truly matter ;).
And a signature by a key has a lot of extra information that simply
putting a hash value on the website where you offer the download does
not have. Just a hash value on the website does not tell me who
calculated that hash value, and whether there is some MITM between me
and the website.
[1] Stream ciphers allow you to flip single bits in the plaintext. And
when I flip a bit in a piece of data, I know exactly which bit I need to
flip in the CRC-32 checksum to make the checksum correct again. So the
CRC-32 was completely useless for protection against malicious bitflips
in the plaintext it was supposed to protect.

@_date: 2015-10-04 21:50:04
@_author: Peter Lebbing 
@_subject: How to get your first key signed 
I think you're moving the goal posts. I think Rob says that he's unaware of any
case where a specific digital signature was argued to be non-repudiable.

@_date: 2015-10-04 21:55:49
@_author: Peter Lebbing 
@_subject: Unsubscription Request (was: Re: How to get your first key signed) 
Even though I might share your sentiment on the rest of your mail, I personally
find this statement disrespectful to the people who tried to help miss Lynn,
when she is not very approachable and offers no more explanation as to
why she can't just unsubscribe than the following:
And yes, I was one of those people trying to help, but I would have found it
equally disrespectful if I hadn't been one of the people at least trying.

@_date: 2015-10-08 21:45:23
@_author: Peter Lebbing 
@_subject: (OT) Blocking ICMP (was: Re: ?: keys.gnupg.net: Host not found) 
I hope you mean specifically dropping all ICMP echo-request packets, not all
ICMP packets. Because some ICMP packets are *essential* for proper functioning
of your internet connection, like path MTU discovery. Systems behind firewalls
that drop all ICMP packets can never properly do path MTU discovery, and this
is nicely reflected in the man page for the iptables cludge that prevents most
PMTU blackhole issues:
And PMTU discovery is not the only thing affected by blocking all ICMP, but
it's a biggy.
PS: It is referring to "working fine from your router" because this target is
for the router where the "pipe" so to say becomes "smaller": a small MTU in
between larger MTU's. The router is aware of the small MTU, but other systems
are not, which is why only the router works properly, provided the small MTU
is the smallest on the path.

@_date: 2015-10-08 22:05:39
@_author: Peter Lebbing 
@_subject: (OT) Blocking ICMP 
The issue with PMTU discovery only happens when there is a smaller MTU in the
middle of the path from you to another system. This can be a very rare
occurrence depending on your setup.
On the basis of no evidence whatsoever, I suspect that it mostly affects home
users with a PPPoE connection shared between multiple PC's[1]. Not the typical
system you (Antony) would *connect* to yourself and notice the connection stops
working as soon as a system tries to send a big packet.
That's a major part of the problem: the people who block all ICMP packets are
usually not the ones affected by the issue. They never notice, and it's other
people who get the issues when connecting to them.
Just blocking echo-request (or reply) is just a hindrance when debugging
connections, but not a connectivity issue, so you can safely do it if you want to.
[1] Note: you can actually use Jumbo frames[2] to have a shared PPPoE with a
regularly sized MTU. If this is the case, you have no problems.
[2] I'm not entirely sure if an Ethernet frame that is only slightly too large
is properly a Jumbo frame, but it is only a matter of terminology. I like
terminology to be exact, so I still put this in a footnote ;).

@_date: 2015-10-12 18:47:51
@_author: Peter Lebbing 
@_subject: How can it be made even easier!? 
Excellent post, I agree!
Ideally, some industry or sector organisation would hire professionals
to solve a large part of the problem for the common use case for
doctors, or lawyers, or what have you. That way the sector can save
money by combining it into a larger project, setting up the system for
more doctors, etc in one go.

@_date: 2015-10-29 19:57:29
@_author: Peter Lebbing 
@_subject: TOFU for GnuPG 
I would think that in most situations, that is not a problem. If you exclusively
use webmail, there isn't such a record directly on your computer's disk, but you
also can't use GnuPG with webmail, AFAIK. If you use a regular e-mail program
that works with GnuPG, that information is already on your disk and accessible
to the user account you run it as, so duplicating that information in the GnuPG
home directory adds nothing.
Do you know of a scenario where this information is not already available from
the e-mail program? Even if the user deletes the mail after they read it, I
wouldn't be at all surprised if this just marks the data as deleted rather than
that it scrubs the data from the disk. This would muddy the statistics, but
hardly be a security feature.
Also, you could just disable TOFU if you're worried by it, but you would lose
the functionality as well...
Maybe there's a use case for optionally not gathering these statistics if key
validity is already established through the WoT. That way, if you want to keep
the frequency of correspondence a secret, you could use the WoT to establish
An option to not gather statistics for specific keys rather calls out those keys
as interesting, and an option to disable the statistics for all TOFU keys seems
like losing a very valuable tool in assessing which key is the One Key.

@_date: 2015-09-01 10:27:18
@_author: Peter Lebbing 
@_subject: FAQ: drop mention of 1.4? 
I might have an idea about that. Gmail has an unusual feature: you can
add dots in the name-part of the e-mail address wherever you like, and
they don't matter. But the mailing list software might have a different
idea about that.
So perhaps you're subscribed as miss.crissylynn etcetera, and you're
trying to unsubscribe without that dot. Take a look at what the exact
e-mail address is that you're getting the mails from this list at. Then
unsubscribe with that address.
And don't forget to confirm with the mail that you will receive: the
software will send you a final mail asking you to confirm that you
really wish to unsubscribe, to prevent jokesters from unsubscribing
random people.
This is just a theory I've come up with, though.

@_date: 2015-09-06 12:02:32
@_author: Peter Lebbing 
@_subject: GnuPG modern can't genereate keys on my Windows 
May I suggest that you take down your compiled 64-bits versions and
issue a warning on the page, alterting people to the fact that Werner
Koch warned you that the random number generator might not work? It's
rather a huge issue, especially when people use your package to generate
their keys.
BTW, AFAIK, GnuPG builds its own random number generator upon the
services provided by the OS. It doesn't make sense (to me at least) to
make an exception for 64-bit Windows and swap it out for the OS provided
service there.
Is there any reason to provide 64-bits binaries, BTW? It's an unbiased
question, I simply don't know. Does it provide any benefits?

@_date: 2015-09-10 11:44:52
@_author: Peter Lebbing 
@_subject: Scdaemon log 
The user you're running GnuPG as probably doesn't have permission to
create files in /var/log. So this can only work when the file is already
created with the correct permissions, and even then there might be a
reason GnuPG needs more permissions on the directory.
So I'd advise to create it in your home directory, something like:
log-file /home/you/scd.log
where 'you' is your username.

@_date: 2015-09-16 21:24:48
@_author: Peter Lebbing 
@_subject: "g13" tool in GnuPG 2.1 
I'd much prefer dm-crypt as backend, so all the better! In fact, I think
LUKS might be better than plain dm-crypt; it seems to be getting the
most love from the devs.
(PS: I accidentally addressed my reply wrong; it went to Werner instead
of the list, so this is a new copy)

@_date: 2015-09-28 19:59:26
@_author: Peter Lebbing 
@_subject: Own Mail: PGP running on local server; Is it secure 
I think they mean that your private key material is compromised, meaning
"?ey"[1] can decrypt any future messages encrypted to that key. Sloppily
formulated, but I don't think they mean you've lost your crypto virginity .
I agree with the rest of what you say, they are full of crap. Just nitpicking here.
[1] Hey, I just thought of a way to ominously spell "they" as a sort of
three-letter agency thingy; just use a thorn!

@_date: 2015-09-28 20:22:00
@_author: Peter Lebbing 
@_subject: Own Mail: PGP running on local server; Is it secure 
Hehe, go ahead ;).
Absolutely. And it's curious that they're sprinkling technical terms in the rest
of what they say, yet completely dumb it down there. It doesn't matter what they
meant; the rest of what they write completely disqualifies their ramblings
anyway. Just another company jumping on the Snowden revelations bandwagon. I
don't know, maybe they mean well, but you need someone who also knows what
they're doing instead for it to be more than snake oil.

@_date: 2015-09-29 16:16:32
@_author: Peter Lebbing 
@_subject: Own Mail: PGP running on local server; Is it secure 
Well, for some reason I never got the mail that started this discussion,
a reply by Robert J. Hansen was the first I saw of it. And I didn't
check the website. But the quotes from the website he put in a
subsequent reply miss the mark by far, and that is a red flag to me. I
wouldn't need any more background for myself at that point. If they
can't get that right, I've lost trust. Crypto requires care, and I don't
see that reflected in what he quoted. I don't think my viewpoint is too
idealistic for the real world, but maybe I'm wrong about that.

@_date: 2015-09-30 12:54:29
@_author: Peter Lebbing 
@_subject: Local PAM authentication with OpenPGP Card (was Re: PAM authentication 
Personally, my main interest lies with authentication with the OpenPGP
card using the PIN of the OpenPGP card. So not as a second factor! My
two factors are: possession of the OpenPGP card and knowledge of the
OpenPGP card PIN. I find different, difficult passwords for all my
machines too cumbersome. I'd rather use multiple smartcards with
different PINs.
For remote logins, I think the SSH agent already does a great job;
thanks NIIBE and Jerome for the pointers to the PAM modules, they might
still be useful for things that really, really want me to use a
sudo-like construction instead of plainly SSH'ing as root.
But for local logins, I'd like authentication to succeed (PAM) when the
OpenPGP card is locally attached to the PC in question and I enter the
correct PIN. Pinpad support would be nice.
I think I really need to restrict the logins to local ones only. In
practice, I would like not to use a separate smartcard for each and
every machine. In addition to the cards I already use for my OpenPGP
key, I would buy one additional card that would not hold my OpenPGP key,
but be exclusively used for local authentication on the systems I don't
want to have my OpenPGP key. This means the PIN is the same on every
system involved. If remote logins would succeed with this card, one
compromised PC could connect to the other. If the smartcard needs to be
connected locally and is only accepted for local terminals (Linux VT,
local X console), this seems to me to be prevented. In fact, the
requirement it is only used on local terminals (which is something you
can express in PAM with pam_securetty) should already be enough, but it
feels better if the OpenPGP card was restricted to local USB ports. I
suppose it's not a strong requirement.
So that's my scenario. I'm just expressing my idea of what would be
cool. If you decide to work on authentication with OpenPGP cards, this
is an idea for one way of using it.

@_date: 2015-09-30 13:19:50
@_author: Peter Lebbing 
@_subject: Non-interactive PIN not accepted, gpg hangs 
You can't unlock the card when the server is booted and then leave it
unlocked for the whole time the server is up? You could do it in an SSH
session, when correctly set up.
The OpenPGP Card does not permit operation without a PIN.
There's a new feature in 2.1, loopback pinentry. Perhaps that allows you
to provide the PIN non-interactively on booting up the server? I haven't
tried the feature, though. Loopback pinentry is the replacement for
--passphrase-fd, AIUI.

@_date: 2015-09-30 14:45:00
@_author: Peter Lebbing 
@_subject: Non-interactive PIN not accepted, gpg hangs 
Yes, I realise that.
Processes dying tend to cause breakages in general. The issue here,
though, is indeed that simply restarting the process isn't enough.
That's where a custom pinentry could help.
In principle, it's not difficult to set up. If you want to account for
processes randomly dying, then yes, it gets difficult, I agree. But a
custom pinentry could save the day.
I think it's not that bad, actually. I think in the general case your
gpg-agent/scdaemon with loopback pinentry would be restarted
automatically if it wasn't available. So you'd "just" have to switch to
a normal pinentry when you need to do something requiring the Admin PIN.
Is this really something you foresee happening though? I think switching
keys on the card is going to be a downtime-incurring operation anyway,
since it's not atomic. On-disk keys are much more flexible in that respect.
IMHO, you're using a device meant for personal usage as an HSM. It's
possible, but your use case is a relatively unusual one, and might
require some tweaking indeed.
I take it you mean /downstream/ official support, then. Upstream support
is fine :). Anyway, a custom pinentry it is, then :). With 2.0. I
wouldn't recommend 1.4 with agent, since it is less seamless, and you're
gunning for seamless. When people recommend 1.4 for headless servers, I
don't think they mean using a gpg-agent with scdaemon.

@_date: 2015-09-30 16:10:36
@_author: Peter Lebbing 
@_subject: Non-interactive PIN not accepted, gpg hangs 
Yes. I have no experience in highly available services, let alone GnuPG in one.
I'm just an enthousiast. I don't know if an OpenPGP Card is suitable (yet?) for
situations where it is critical it always works. Since I upgraded to 2.1 on my
laptop, I sometimes encounter issues right after plugging in my USB smartcard
reader, which I solve by replugging. It could be that it's all rock solid when
you always have it plugged in, or it could be that it sometimes stumbles and
requires maintenance. That situation is not critical in personal use. "Have you
tried turning it off and on again?". In your case, it might very well be critical.
Like with a smartcard or RFID for access control. If the door doesn't open, you
just try again. It's not a major issue if sometimes the card doesn't work on
first use, and in practice, they don't always work on first use. Just watch out
you don't run into the door because you expected it to open. Been there, done
that :).
You could be right, I don't know. I think it would certainly be useful if there
was something in between.

@_date: 2016-04-01 12:45:29
@_author: Peter Lebbing 
@_subject: What am I missing? (Again) 
10^3 != 10^4.
10^4 is approximately 2^13, so 13 bits of entropy.

@_date: 2016-04-01 19:21:53
@_author: Peter Lebbing 
@_subject: where is gnupg configure file 
GnuPG 1.4 and GnuPG 2.x are co-installable, they can function
side-by-side. If you take the Jessie GnuPG 2.0 package, you get 2.0,
which will use the same key storage as 1.4.
GnuPG 1.4.12 (with backported fixes from later releases) is in package
gnupg, and the binary is called gpg. GnuPG 2.0.26 with backports is in
package gnupg2, and the binary is called gpg2. You appear to have both

@_date: 2016-04-02 12:42:31
@_author: Peter Lebbing 
@_subject: where is gnupg configure file 
apt will not ever use gpg2. On a normal Debian system, GnuPG 1.4 is
always installed. However, you can install and have installed GnuPG 2.0,
which will just be an additional installed package. It will in no way
replace anything from the GnuPG 1.4 package.
When you type (just as an example)
$ gpg --version
you will be using GnuPG 1.4.
When you type
$ gpg2 --version
you will be using GnuPG 2.0.
To reiterate, apt will always use GnuPG 1.4 from the gnupg package (and
gpgv from the gpgv package). You can use GnuPG 2.0 by starting your
command line with gpg2 as the program name.
This is all for Debian jessie. In the next release, some things will change.

@_date: 2016-04-03 13:56:57
@_author: Peter Lebbing 
@_subject: How to interprete the output of --export-ownertrust? 
Nope, that's just how you enter them in the dialog:
I don't know what the numbers in a trust database export mean; at the
very least, they seem to be one higher than the choices in the dialog
(note there are 6's in the output. On a quick check, this corresponded
to an ultimately trusted key, and a 4 corresponded to a marginally
trusted key).
However; this is meant as a machine-readable format, not a
human-readable one. I would have expected it to be documented in
doc/DETAILS, but I didn't find it with two scans through the document.
gpg2 --edit-key is for human consumption, gpg2 --export-ownertrust is
for a later --import-ownertrust, not for human consumption.
Christine, what are you trying to accomplish? Why do you need this
output from --export-ownertrust?
Also, when you start a new topic, could you please post a fresh new
message to the mailing list, instead of replying to an unrelated post?
People who use threading mail readers see this thread as part of the
"where is gnupg configure file" thread. They might even miss your
message altogether when they're not interested in that topic and ignore
any further messages in that thread.

@_date: 2016-04-04 10:58:20
@_author: Peter Lebbing 
@_subject: How to interprete the output of --export-ownertrust? 
Two people mailed me to say they didn't think this had happened
(thanks!). They are right; sorry for my mistake.
For some unknown reason, /my/ mail reader thought it would be a good
idea to mix the threads, it was not Christine who did this. I have no
idea why, it's an odd bug. You can see what it looks like for me[1]. I
totally did not expect the problem to be on my side, but the mail was
clearly posted correctly. Again, my apologies to Christine.
[1]

@_date: 2016-04-05 11:06:40
@_author: Peter Lebbing 
@_subject: Translate to dutch 
These two statements seem to be in opposition. Dashamir's project has a
pretty narrow target audience. His code will not run on Windows, and the
project is aimed at people comfortable with working at the command line,
whereas most beginners will use a GUI tool. If you want to reach a big
audience, you should probably work on either GnuPG documentation itself
or documentation for a commonly used GUI tool, perhaps Kleopatra or
Enigmail? Personally, I use the command line, I'm not that accustomed to
the GUI tools.
By the way, I'm Dutch and I enjoy playing with language. If you run into
trouble translating something, I might be able to help.

@_date: 2016-04-05 12:06:25
@_author: Peter Lebbing 
@_subject: Translate to dutch 
Dashamir, note I wasn't attacking your project. I was pointing out that
it seemed to me that Eva said she wanted to spend her volunteered time
in one way but at the same time seemed about to spend it in another. She
wanted to reach a large audience, I was merely giving context so she
could make better informed choices.
Documentation is more than invocation. You can document a whole lot of
GnuPG, OpenPGP and what not without ever instructing someone to type
something on the command line. But maybe I should have described it as
"GnuPG and OpenPGP", which is what I meant.
Well, that's a bit disingenious, I'm not the target audience of /your/
project either. I'm quite comfortable with GnuPG on the command line. I
do have Enigmail by the way, for its main feature, the integration to
Thunderbird. E-mail is a thing I don't do on the command line (yet?).

@_date: 2016-04-19 11:59:44
@_author: Peter Lebbing 
@_subject: Using a passphrase FD from variable and piped data for encryption 
That doesn't seem to be the case, though. $PASSPHRASE is expanded and
fed as an argument to echo. For instance:
$ ARGS=f
$ ps $ARGS
26958 pts/1    Ss     0:01 /bin/bash
27915 pts/1    R+     0:00  \_ ps f
In addition, there's a good chance your environment variable ends up in
your swap space.
I'm certainly not suggesting you use this method, but out of an
academical interest, I got it to work with:
$ tar zcf - . | gpg -c --passphrase-fd 3 -o dir.tgz.gpg 3< <(echo test)
I'm redirecting twice. First, I redirect "echo test" to an FD or FIFO of
Bash's choosing. Then I connect that to fd 3, so I can name fd 3 as the
passphrase-fd. <(echo test) is expanded to a filename, either of the
form /dev/fd/X or of some named FIFO created by bash, if I understand
the Bash manual correctly. The space between the two less-than's is
Which was my motivation exactly :).
Oh, by the way, your plaintext was already on disk. The only reason to
worry about the passphrase being on disk is that you might reuse the
passphrase, right?
Asymmetric crypto would nicely avoid the issue by never needing the
secret part to encrypt data in the first place.

@_date: 2016-04-19 17:20:33
@_author: Peter Lebbing 
@_subject: Using a passphrase FD from variable and piped data for encryption 
It's not safer. Regarding the complexity, however, the data to encrypt
is already on fd 0, so you would need to move either the data or the
passphrase to another fd, I think. The example from your code on GitHub
doesn't get data piped to it, so it doesn't need multiple fd's, which is
the point where it gets more complicated.
Depending on how --passphrase-file is implemented, it might be possible
to use --passphrase-file <(echo pass), which isn't very complicated.

@_date: 2016-04-20 11:21:35
@_author: Peter Lebbing 
@_subject: Using a passphrase FD from variable and piped data for encryption 
You mean like Phil Zimmerman believed BassOmatic was secure?

@_date: 2016-04-24 19:59:51
@_author: Peter Lebbing 
@_subject: Help needed 
Yes; it is also the current default, so no need to upgrade the key.
I consider "stick to the defaults" better advice. That website makes it
all rather complicated.
As for the OP's other questions, I can't answer them very well because I
don't know MacOS, but I can give you advice: could you please indicate
what software you are using? What mail client, what other GnuPG-related
software? You say you compose a mail, and you select Services from
somewhere. This seems /really/ little to go on if we don't know in what
program you compose a mail and where this Services comes from (it might
be that same mail application, I don't know).
FWIW, no, with a good e-mail plugin you don't have to copy-paste
anything to different windows. That's not a nice interface at all.
And when you are asked for your password, that is not because you are
password because you are /signing/, I think. And the time to cache a
passphrase is set with the option default-cache-ttl in the file
gpg-agent.conf in your GnuPG home directory (I don't know where that is
on MacOS, it could just be ~/.gnupg), as follows:
default-cache-ttl 3600
The argument is in seconds. The default is 10 minutes, so if you are
asked for your passphrase within 10 minutes, I expect something didn't
install properly...
I hope someone who actually uses MacOS can help you further with
specific advice.

@_date: 2016-04-24 20:49:11
@_author: Peter Lebbing 
@_subject: Help needed 
Could you please start a new thread instead of changing the subject of
this thread to something else entirely? Thanks!

@_date: 2016-04-25 11:35:55
@_author: Peter Lebbing 
@_subject: (OT) gpgme-sharp API missing 
The mail you sent Thu, 21 Apr 2016 14:24:50 +0200 showed up in my
mailbox at Thu, 21 Apr 2016 15:46:05 +0200. The mailing list always adds
a delay which can vary. Additionally, mails from non-members are
moderated by a variable-delay human.
But it did arrive. It's on the web archives as well[1]. No idea when it
showed up there :).
[1]

@_date: 2016-04-25 15:11:12
@_author: Peter Lebbing 
@_subject: Paper backup 
Yes, but I much prefer paperkey[1] for that rather than complete
(minimal) secret key files. Also consider the longevity of the format:
if you want to restore it in 10 years, do you still have the equipment
and software to do so? Do you expect to use your key in 20 years?[2]
Provided we can still work with OpenPGP v4 file formats, paperkey has
got this covered.
I have never used my paper backup. Prudence suggests you should try to
OCR it; laziness suggested otherwise in my case. Worst case, I type it in.
It's purely for when the digital media fail. Which they will, using
common consumer storage media.
[1] [2] It's real nice to hear people talk about this, but there are so many
things that could change.

@_date: 2016-04-26 13:32:42
@_author: Peter Lebbing 
@_subject: making a Debian Live CD for managing GnuPG master key and 
I think you are taking the "plugging my project" approach too far. While
generating exposure is definitely a good component of making your
project succesful, I think a bit more modesty is in order. If I had a
say in it: Just create your own threads (not too many please :), don't
mention your project in every thread where it has some common ground.
This is my personal opinion. I don't get to say what you do. But I feel
the need to express this opinion now.
Regarding your choice of words and also modesty, the answers to the
questions are not in your code. Your /opinions/ on the matter are in
your code. You do not get to decide what is truth, what is the answer.
Incidentally, the answer is 42, so you're late to the party... ;P
I hadn't even read the following until I almost trimmed it from the mail
and it caught my eye... so ...
Wait, wait, wait... I sincerely hope you're not suggesting that the
first thing Daniel Pocock and others need to do is build a .deb package
for your project, that instead you meant this to read as "the first
thing /I/ should do is build a .deb package for egpg", so that they can
play with your code. I wouldn't even agree with the latter; but the
former is just... I hope you can pick your own adjective.

@_date: 2016-04-26 14:52:28
@_author: Peter Lebbing 
@_subject: making a Debian Live CD for managing GnuPG master key and 
Quote or it didn't happen. I think I've treated you respectfully, though
I already noted my first reply to your first message here could have
been framed nicer. But that was the single exception.
The respect is starting to evaporate a bit at the moment, though.
Besides, I haven't spent much time on a lot of your messages, let alone
respond to every one of them or anything near such a thing.
Not impose extra work on random people[1], put your personal opinions in
proper perspective and represent your project as what it is, i.e., a
brand-spanking-new piece of code, one developer and a very small user
base? Or am I also wrong about that?
By the way, if I disagree with advice you give others here, such as here
advising to include your tool on the live CD, or the other day pointing
a new user to some webpage claiming he needed something more than the
default settings and do difficult stuff without knowing anything about
their requirements other than that they were already having some
difficulty with GnuPG in the first place, I will say so. Even if it
takes a ridicully long sentence that should probably be split into
proper parts. And I do it without bashing your messages, even though you
seem to take it personal.
[1] I'm thinking of suggesting to someone they translate your project
when this person clearly indicates they'd like to reach a broad user
base with the effort they spend on that, and other instances.

@_date: 2016-04-26 15:43:09
@_author: Peter Lebbing 
@_subject: making a Debian Live CD for managing GnuPG master key and 
This is not true: you are taking the word modesty out of the context I
used it in.
What you care about affects only you, and you can do to yourself
whatever you wish. I only butt in when it affects others. I've also
never until the previous message said anything about my personal opinion
of you ("respect evaporating a bit"), since it is, indeed, irrelevant.
You are inventing your own version of me, someone with who's responses
are emotionally motivated, a version that has little basis in reality.
I'm done with this topic. After some doubt, I will post this to the
list, though.

@_date: 2016-04-27 11:10:04
@_author: Peter Lebbing 
@_subject: Website usability issue 
Hi all,
Using a netbook with a touchpad, Debian Jessie/stable and Iceweasel
38.7.1esr-1~deb8u1 (Debian package), I encounter an issue with the menu
at the top of the website.
When you hover the pointer over a menu category (Home, Donate, Download,
...) it folds down and subpages appear. However, there is a small slit
between the category and the pages. If I'm not quick enough with the
touchpad movement, and manage to hover over the slit while moving down,
the menu folds up again just as I'm about to select a page. At the
moment, I'm having more difficulty keeping it open than not. I'm sure
this depends on pointer device, acceleration settings and the amount of
caffeine in the user... (none as of yet).
I'm not familiar with website development, but perhaps the slit can be
made a transparent part of the menu, such that it doesn't register as
"no longer hovering over the menu"?
Oh, I also use Privoxy and Ghostery. I disabled Privoxy and did a full
page reload (Ctrl-Shift-R), but the problem persisted.

@_date: 2016-04-27 11:31:19
@_author: Peter Lebbing 
@_subject: Evangelzation discussion 
I also think it's a good idea if you can read about related software on
this list, but I think that authors should be reluctant to promote their
own stuff in other threads. With care, it can be done, though.
Incidentally, the software will also need to be free software, as per
the rules for FSF lists.
Yes, I think it would be better if stuff like GPGME, libassuan,
libgcrypt, libgpg-error, libksba and pinentry got their own category on
the website rather than being a peer to the other stuff in related
I can't think of an instance where this appeared to be the case, though.
Then again, I know what is part of GnuPG and what not, so I might not
have noticed indeed.
While "related software" is a large list, I don't think it's meant to be
exhaustive. I'm also not sure what the qualifications are to be
considered for being added (other than being free software). I think
this is done informally, on an ad-hoc basis.
My 2 cents,

@_date: 2016-04-27 12:04:26
@_author: Peter Lebbing 
@_subject: (OT) Netiquette 
Right, I should have changed the Subject:-line on my first reply here,
since it was clearly not about the Live CD anymore... my apologies...

@_date: 2016-04-27 15:39:39
@_author: Peter Lebbing 
@_subject: making a Debian Live CD for managing GnuPG master key and 
I think this is interesting, and I would probably use it. But I'm just
doing it out of interest, not because I have particular security needs
(other than protect my network and the hosts on it from network-based
I'm not personally familiar with them, and I see Tails is even mentioned
on the wiki, so you're already aware of it.
A bunch of stuff can be sanely scripted, but unfortunately there are
also cases where this can lead to a very suboptimal or kludgy solution
and GPGME would be the better way to go.
I notice in the blog this person used GnuPG 1.4.x. I don't know why he
does that; I would recommend GnuPG 2.0.x. GnuPG 2.1 introduces some more
commands and features that are well suited to scripting, but I think it
could well be too new for a Debian Live CD. You mgi
In fact, you mention ECC keys on the wiki. GnuPG 1.4 does not and will
never support ECC keys.
Incidentally, when you use GnuPG 2.x, you can drop the 'use-agent'
statement from the configuration file which is a 1.4 thing: 2.x always
uses the agent.
I am of the strong opinion that this should be left to the default GnuPG
mechanism: the agent, combined with a (stock) pinentry. The agent will
remember passphrases for 10 minutes by default, but it is configurable
(not to an unlimited number, but there is some number like INT_MAX or
similar to emulate it).
The pinentry is responsible for securely querying the user and the agent
for securely keeping the secret in memory. They have been expressly
designed with this purpose. In your specific use case, with swap and
network disabled, I suppose it would matter less, but if you find agent
and pinentry unsatisfactory, perhaps the correct course would be to
discuss improvements to them rather than spin your own solution.
I have some suggestions.
You state that a smartcard reader with dedicated PIN-pad protects from
keyloggers. While there is some truth to it, it is not a panacea. The
firmware of the reader should not have a security issue where it accepts
rogue firmware updates, for instance. Or you could turn on the
microphone and listen for the cadence of the keypresses, or pop up a
message to the user saying that the PIN-pad of the particular reader is
not supported and request them to type on the regular keyboard. The
latter could take the form of a downgrade attack, where the malware
strips the part of the USB configuration descriptor describing the
PIN-pad support. In fact, I think this is the most low-tech solution
that would work pretty well in practice, so I'm putting my money on this
"solution". It works equally well with a hardware dongle hidden in the
connector of the smartcard reader, like a hardware keylogger in the
keyboard cable.
You save the private keys to flash storage. I'd like an option to use
writable optical storage. It's cheaper (per storage unit), you can
refresh it every so often for a low price (completely disintegrating the
old disc and throwing it out).
Additionally, I think paperkey[1] would make an excellent addition to
the software installed. Although I heard that a 4096-bit RSA key[2]
would take a lot of typing if it didn't scan with OCR. Oh, a good
OCR-font for printing, also good to include. Anyway, I considered a
2048-bit RSA key quite typable in an emergency; I have paper backups of
my master and my encryption keys. The signature key is unneeded as you
can just create a new one when you lose it.
I'd recommend a reading of the questions in the GnuPG FAQ[3], and
checking whether any apply to your project. Thought, discussion and
consensus have gone into the drafting of the FAQ, it is a valuable
source of information.
I'd suggest to support only OpenPGP smartcards, not PKCS  tokens. The
latter requires a lot of tinkering to get to work, and to make it into a
Live CD that runs on a fair multitude of systems? I think it would be
difficult, and the cost/benefit tradeoff seems bad. OpenPGP compatible
cards are not expensive. They were designed to offer a good alternative
to PKCS  in the first place.
Regarding expiry periods, I think they are too soon. I think the main
feature of expiry is to eventually disable a key to which the private
part has been lost. The purpose of this is to ease the selection process
when fetching a key from the keyservers. I consider several years to be
sufficient for this purpose, and subkeys need not expire sooner than
master keys.
Finally, I'll finish with how I've done it myself:
- I burned a generic Linux Live CD; I'm fairly sure it was Knoppix.
- I removed the cables from any hard disks and unplugged everything that
was not needed, especially network cables. I didn't have any wireless
communication in the system, otherwise it would have been removed if
possible. I didn't remove any expansion cards.
- I booted the Live CD, and created RSA keys with GnuPG.
- I burned the private keys to a DVD-R, passwordless.
- I printed a paperkey backup, passwordless. I don't have a revocation
certificate as I can revoke the key with the private key material, which
I intend not to lose. It was a personal choice, it is not a recommendation.
- I transferred the keys to smartcards. I use a setup with a smartcard
holding the master key and another two holding (identical) signature and
encryption keys. One of those two also has an auth subkey.
Unfortunately, the multi-smartcard solution requires packet surgery on
the private key files to work in GnuPG 1.4 and 2.0: otherwise it will
only ever accept either the master key one or a subkey one, but never both.
- I deleted all private key material.
- I inserted a USB stick, mounted it, and copied the public keys to it.
- I turned the PC off.
It was a few years ago, I might have a mistake in the details. The DVD-R
and the printout are stored in a secure location. I decided that I
didn't want to forget the passphrase to them and that a very simple
password would not offer any real security, so I'm depending on the
physical security of the storage. By now, I'm used to using a password
manager, and I think I would never forget the password I currently use
for that (difficulty: you've already memorized it, per XKCD[4]), so I
might use that instead.
I hope this will be of use to you. I don't have any experience with a
situation where I depended on the security of it all, nor experience
with the other side of the equation, trying to break someone else's
security. I'm just a hobbyist. But a lot of thought has gone into it,
and I vied to keep the thought process academical and well-funded, and
not based on gut feeling. No warranties though...
Thanks for your efforts! I appreciate them; Debian in general and this
Live CD in particular.
[1] [2] I'm not going to debate recommended key lengths. But please be aware
that the GnuPG FAQ[3] has a section about it.
[3] [4]

@_date: 2016-04-27 15:44:51
@_author: Peter Lebbing 
@_subject: (OT) Ignoring a subthread 
If we keep the proper discussion out of this particular subtree of the
topic, some mail readers actually offer the possibility to ignore the
subtree. With Icedove, I could click right on a parent post, and select
"Ignore Subthread", and I would never be notified of any discussion here.[1]
I spent some time writing up an on-topic response and posted it as a
child of the Original Post.
[1] (Note the hyopthetical)

@_date: 2016-04-27 15:55:04
@_author: Peter Lebbing 
@_subject: making a Debian Live CD for managing GnuPG master key and 
Ouch. After I had accidentally deleted my footnotes along with unused
quote, I did a whole bunch of "Undo", then copy the footnotes, then
"Redo" again. However, it is clear I didn't "Redo" enough. I sure hope
this is all that is lost :'(.
It was supposed to say:

@_date: 2016-04-28 12:45:52
@_author: Peter Lebbing 
@_subject: gpg and smartcard on ubuntu 16.04 
After I installed GnuPG 2.1 on my Debian Jessie (which doesn't have 2.1
itself), I encountered annoying issues. I also use smartcards, for SSH
auth as well. I got it to run much smoother by editing this file to be
the attached file. It did have a gotcha: if there isn't an agent
running, you have to do something like:
$ gpg-connect-agent /bye
before you can do SSH auth. Note that the agent survives a logout/login.
I got the impression that the explicit starting of the daemon in the
startup script somehow messed something up. But I had some trouble
pinning down the exact problem, and since it now works in a way that
works for me, I left it at this.
Perhaps you could just add the gpg-connect-agent call to the
if-ssh-support conditional, and it would be purrfect. I will try that
now and see if everything stays peachy.

@_date: 2016-04-28 13:10:10
@_author: Peter Lebbing 
@_subject: gpg and smartcard on ubuntu 16.04 
At a first glance, it seems to work with the attached version. On a cold
boot, the agent is running and listening for SSH when I login. When I
unlock a smartcard with the PIN, logout, and log back in, the smartcard
is still unlocked (and the original agent running). While this may not
be very expected, it is not related to logging *in* but rather to
logging *out*, in my opinion. I don't readily know how to do something
on logout.

@_date: 2016-04-28 21:10:39
@_author: Peter Lebbing 
@_subject: Website typo fixes 
I saw some typo's in libraries.org on the website. Seizing the occasion, I'm
also resending an older typo fix that either fell through the cracks or was
silently rejected.
I hope I'm using git-send-email right... I hardly ever use it.

@_date: 2016-04-28 21:10:40
@_author: Peter Lebbing 
@_subject: [PATCH] Fix typo's in libraries.org 
web/related_software/libraries.org | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)
diff --git a/web/related_software/libraries.org b/web/related_software/libraries.org
index 2a5cc8d..6c963d0 100644
--- a/web/related_software/libraries.org
+++ b/web/related_software/libraries.org
 -12,10 +12,10  ** Libraries required to build GnuPG
-  The libraries are requred to build currenrt GnUPG versions but may
-  also be used on its onw.  They are maintained by the GnuPG Project.
+  The libraries are required to build current GnuPG versions but may
+  also be used on their own.  They are maintained by the GnuPG Project.
-   -  [[file:libgpg-error/index.org][Libgpg-error]] :: Libgpg-error is helper library used by a couple
+   -  [[file:libgpg-error/index.org][Libgpg-error]] :: Libgpg-error is a helper library used by a couple
                       of other projects to provide a common set of
                       error codes and descriptions.
    -  [[file:libgcrypt/index.org][Libgcrypt]] :: Libgcrypt is a general purpose cryptographic

@_date: 2016-04-28 21:17:36
@_author: Peter Lebbing 
@_subject: [PATCH] Fix typo's in whats-new-in-2.1.org 
web/faq/whats-new-in-2.1.org | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)
diff --git a/web/faq/whats-new-in-2.1.org b/web/faq/whats-new-in-2.1.org
index 179b075..c1e6d09 100644
--- a/web/faq/whats-new-in-2.1.org
+++ b/web/faq/whats-new-in-2.1.org
 -376,7 +376,7  pub  rsa2048/BD19AC1C
 In case the key has already been signed, the command prints a note and
 exits with success.  In case you want to check that it really worked,
-use ==--check-sigs= as usual:
+use =--check-sigs= as usual:
  $ gpg2 --check-sigs  '15CB 723E 2000 A1A8 2505  F3B7 CC00 B501 BD19 AC1C'
 -515,13 +515,13  For load balancing reasons, keyservers are organized in pools to
 enable instant round-robin DNS assignment of random keyservers.  A
 problem with that approach is that the DNS resolver is not aware of
 the state of the keyserver.  If a keyserver has gone down or a routing
-problems occurs, /gpg/ and its keyserver helpers were not ware of it
+problems occurs, /gpg/ and its keyserver helpers were not aware of it
 and would try over and over to use the same, dead, keyserver up until
 the DNS information expires and a the DNS resolver assigned a new
 server from the pool.
 The new /dirmngr/ in GnuPG does not use the implicit round-robin of
-the DNS resolver but uses its own DNS look up and keeps an internal
+the DNS resolver but uses its own DNS lookup and keeps an internal
 table of all hosts from the pool along with the encountered aliveness
 state.  Thus after a failure (timeout) of a request, /dirmngr/ flags a
 host as dead and randomly selects another one from the pool.  After a
 -607,12 +607,12  revocation certificate are put at the top of the file.
 :END:
 The /scdaemon/, which is responsible for accessing smardcards and
-other tokens, has received many updates.  In particular plugable USB
+other tokens, has received many updates.  In particular pluggable USB
 readers with a fixed card now work smoothless and similar to standard
 readers.  The latest features of the [[ token are supported.  Code
 for the SmartCard-HSM has been added.  More card readers with a PIN
 pad are supported.  The internal CCID driver does now also work with
-certain non-auto configuration equipped readers.
+certain non-auto-configuration equipped readers.
 ** New format for key listings
 :PROPERTIES:
 -643,7 +643,7  that is =show-uid-validity= is implicitly used for the
 The annotated key listing produced by the =--with-colons= options did
 not change.  However a couple of new fields have been added, for
-example if the new option =--with-secret-= is used the ?S/N of a token
+example if the new option =--with-secret= is used the ?S/N of a token
 field? indicates the presence of a secret key even in a public key
 listing.  This option is supported by recent [[ versions and makes
 writing of key manager software easier.
 -682,7 +682,7  menu of /gpgsm/.
 In batch mode the certificate creation dialog can now be controlled by
 a parameter file with several new keywords.  Such a parameter file
 allows the creation of arbitrary X.509 certificates similar to what
-can be done with /openssl/.  It may this be used as the base for a CA
+can be done with /openssl/.  It may thus be used as the base for a CA
 software.  For details see the ?CSR and certificate creation? section
 in the manual.

@_date: 2016-04-30 15:45:45
@_author: Peter Lebbing 
@_subject: gpg and smartcard on ubuntu 16.04 
Purely out of interest, what is it that goes wrong? Is it that the
correct command-line arguments are missing? If it is autostarted by
gpg-connect-agent, it has the form
gpg-agent --homedir /home/peter/.gnupg --use-standard-socket --daemon
which is not what is in /etc/X11/Xsession.d/90gnupg-agent.
I know, which is why I added the gpg-connect-agent call in my version of
the script.
I don't understand what you mean. I just checked on the latest unstable
version of gnupg-agent, and that version starts the agent explicitly,
with the argument "--daemon". This is the variant that caused issues for
me. I start the agent by "gpg-connect-agent /bye". For reference, I
attach the script as it is by default in Debian.

@_date: 2016-08-01 19:28:25
@_author: Peter Lebbing 
@_subject: Which GPG version? 
I think usually the constraints are software constraints. But 1.4 might be more
appropriate in for instance a headless server. I suppose that counts as a
hardware constraint indeed :-).
I'd say, go for 2.1. I think 2.0 is more for people who wish to stick to 2.0 for
whatever reason. If you don't have any particular motivation to use 2.0 or 1.4,
you should go for 2.1.

@_date: 2016-08-01 21:12:21
@_author: Peter Lebbing 
@_subject: Which GPG version? 
Incidentally, for this use case I'd personally recommend to use 2.1 for
everything except accessing those ancient archives, and just use 1.4 for that,
if that is something that works for you.
I'm sure you know, but the OP might not: in this case, you're scripting in a way
not approved by the GnuPG devs, i.e., using interfaces meant for humans instead
of machines.
2.1 even has some functions that 2.0 does not with regard to easy scripting
(--quick-add-[stuff] and friends). I don't know whether there is stuff that 2.0
can do that 2.1 can't at the moment, though (which is different from stability,
it's feature completeness).

@_date: 2016-08-10 10:40:29
@_author: Peter Lebbing 
@_subject: Standard gnupg folder created despite --homedir parameter 
While the directory names give off a strong Unixy vibe[1], the text says "On
Windows systems" and "under Windows". Have you tried to create those
directories? I don't think there is any "translation", this is how you should do
it on Windows specifically. (The gpgconf tool is also indicated as
'gpgconf.exe', on Unix systems it would not have an extension.)
Try this:
[1] Heck, /usr/local/var/cache/gnupg is the concatenation of two standard Linux
directory names. Two for the price of one! It's an odd one, that. Makes you
wonder whether it's a copy-paste error.

@_date: 2016-08-10 11:16:24
@_author: Peter Lebbing 
@_subject: Which GPG version? 
The world even! :-)
What do you base this view upon? I based my advice upon two instances I can
remember Werner expressing his view about this:
On 04/05/16 11:55, Werner Koch wrote[1]:
Note that this is about a Live CD which is expected to be used by people with
larger than average security concerns. You mention the "regular end-user"
yourself. I'd say some of the intended audience of the Live CD have more
stringent needs even than the "regular end-user". On the other hand, a Live CD
for key management is a quite different scenario than day-to-day use on a
regular OS.
And the second, thanks to Lachlan Gunn for reminding me the other day:
On 02/06/16 21:47, Werner Koch wrote[2]:
So what makes you say that 2.1 will not be for end-users until 2.2 has been
released? I don't think that is the versioning model of the GnuPG project. It
wasn't during the 1.4/2.0 period, before 2.1 was released.
[1] [2]

@_date: 2016-08-11 12:46:42
@_author: Peter Lebbing 
@_subject: Standard gnupg folder created despite --homedir parameter 
No need to apologise, I wouldn't be able to count the number of times I misread
something and later wondered how I could have missed it. And in this case, it's
even clear how you could have missed it: the odd names and the fact that / is
used as a directory separator, rather than the \ of DOS and Windows.
Without disparaging the work I actually do ;-), I'm not affiliated with GnuPG.
This mailing list is just a hobby for me.

@_date: 2016-08-21 12:27:37
@_author: Peter Lebbing 
@_subject: Deleting SSH key(s) from agent 
Let me answer by example:
gpg-agent does not identify keys by the SSH fingerprint, but rather by a so-called keygrip. First I listed my keys known to ssh-add. Then I requested the same list through gpg-connect-agent, and this time it will show the keygrip as well as the SSH fingerprint. Using the information I thus learned, I was able to execute the DELETE_KEY statement using the keygrip of the "test_id" key I wanted to delete. Note that you can also delete the file "~/.gnupg/private-keys-v1.d/{KEYGRIP}.key" instead of using the DELETE_KEY agent command.
You can make the GnuPG agent forget any cached passphrases through:
$ gpg-connect-agent reloadagent /bye
While this is different from "ssh-add -x", it's also a form of locking Note that I answered these questions using GnuPG v2.1.

@_date: 2016-08-21 12:54:15
@_author: Peter Lebbing 
@_subject: File Encrypted with Primary key 
I have no experience with the software you mention. Keep that in mind
while reading my ramblings.
My key looks like this:
$ gpg2 -k de500b3e
pub   rsa2048/DE500B3E 2009-11-12 [C] [expires: 2017-10-19]
uid         [ultimate] Peter Lebbing sub   rsa2048/DE6CDCA1 2009-11-12 [S] [expires: 2017-10-19]
sub   rsa2048/73A33BEE 2009-11-12 [E] [expires: 2017-10-19]
sub   rsa2048/B65D8246 2009-12-05 [A] [expires: 2017-10-19]
If something is encrypted to this key, gpg2 will mention the following:
$ gpg2 test.gpg
gpg: encrypted with 2048-bit RSA key, ID 73A33BEE, created 2009-11-12
      "Peter Lebbing "
So it explicitly tells me that it was encrypted to the
encryption-capable subkey 73A33BEE. If it tells you that it was
encrypted to the primary key ID instead, I think your analysis is right.
I don't think it is possible to force a key to be used in a way that is
not indicated as a capability for that key. If something encrypts to a
key that is not encryption-capable, that seems to me to be a major bug.
Subkeys and key capability flags have been around for practically
forever by now. Software that can't deal with this is not OpenPGP
compatible and probably ancient.
It's possible, but first lets take a look if there is a different
solution. Keys that can both sign and encrypt are frowned upon. The
primary key necessarily has the Certify capability, which is a form of
signing. So it shouldn't get the Encrypt capability.

@_date: 2016-08-22 18:34:54
@_author: Peter Lebbing 
@_subject: File Encrypted with Primary key 
I thought OpenPGP-compliant implementations were required to respect the key
flags, but on scanning the OpenPGP RFC (I took RFC 4880), it does not seem to be
the case. That is, it is not required that compliant software encrypt to an
encryption-capable key. But perhaps I missed the relevant part where it said it
is a MUST/SHOULD NOT requirement...
I did find this statement:
I'm surprised that GnuPG will happily decrypt with a key that does not have the
Encrypt capability set. But perhaps it is precisely because OpenPGP-compliant
software is allowed to ignore key usage flags.
I might be a bit out of my league with this particular problem. I have no hard
But when it is confirmed that it is intended behaviour of GnuPG, perhaps the
problem is that "camel" is too strict. And perhaps they actually want to be; it
could be intended behaviour of "camel". In that case, "camel" and "MoveIt" are
simply incompatible.

@_date: 2016-08-23 10:36:12
@_author: Peter Lebbing 
@_subject: Deleting SSH key(s) from agent 
I don't make sure the correct one is used.
The challenge that is signed with your private key is based on data
provided by both the server and the client. I have never heard of an
attack that allowed a challenge for one SSH server to be used as
authentication to a different SSH server. In other words, I've never
heard of an attack where a rogue SSH server can impersonate you on a
different server when you authenticate to the rogue server.
If I'm mistaken, I'd like to know. But I suspect the system was
correctly designed to thwart such a thing.
So I don't think there is a need to ensure the correct key is used.

@_date: 2016-08-23 11:17:33
@_author: Peter Lebbing 
@_subject: OpenPGP Smartcard recommendations 
I was quite surprised by this blog post, by one small but, in my eyes,
significant part of it. A lot of the blog post seems not directly
related to being able to review the source and verifying that the loaded
firmware binary is indeed the reviewed source, which is what would
interest me most in a security device. There's a lot of talk about
field-updating firmware securely and related topics, which
is only tangential to the source being /available/.
But the really strange statement is this:
I'm with him on the first sentence. The context is broadly that when
your hardware is not secure, no amount of open sourcery would protect
the data the hardware holds. At least if I understood the context.
But then it gets iffy.
The attacker's job becomes easier because he knows the inner workings?
Alert! Alert! Security through obscurity! Prepare for battle stations!
A secure system is secure by having the knowledge of a secret key. It is
not secure because most people do not know how it works; because the
method is secret. This is Cryptography 101. If you want to know
more, I'd say just use your favourite search engine with the phrase
"security through obscurity".
I fully understand that stuff gets complicated when your hardware vendor
forbids you to disclose your source code. That's a nasty problem. I'm
less concerned about not meeting criteria for some certification because
the source is open. Would you rather have a certification stating some
party thinks you're secure, or would you rather actually be secure? I'd
know. Stuff those Common Criteria ;). They're not the holy grail. But
when you say "obscurity helps security", I'm seriously starting to doubt
your reasoning.
My 2 cents,

@_date: 2016-08-23 11:29:07
@_author: Peter Lebbing 
@_subject: SSH agent prompts for all passphrases (was: Deleting SSH key(s) from 
Hmmmmm. I use both a smartcard and an encrypted on-disk key, and am
never prompted for a passphrase for a key that isn't listed in
You can see a lot of the detail with:
$ ssh -vvv user at host
I can see how the client considers keys, offers them, and only when the
server indicates acceptance will it access the private key and prompt
for a passphrase.
See here how it first asks the server whether it would accept the key
the agent identifies by "/home/peter/.ssh/id_rsa", and the server
declines (that's not very explicit in the messages). I'm not prompted
for the passphrase for that key. The client then offers my smartcard,
and the server accepts. Only then am I prompted for the PIN.
Are both the server and the client in your case OpenSSH? Do you have
non-standard options set relating to auth perhaps?

@_date: 2016-08-23 12:03:35
@_author: Peter Lebbing 
@_subject: SSH agent prompts for all passphrases 
I don't know, but perhaps that's best asked on an SSH mailing list? If
it turns out that the agent has influence (for example because the
client parses the list of keys from the agent top to bottom), then it
would again be something for the GnuPG SSH agent implementation. Perhaps
the order can be influenced through the sshcontrol file, I don't know.
Maybe something changes when you list the keygrip of the smartcard key
in that file.
Or maybe the "Identity*" options in ssh_config help.
You're welcome!

@_date: 2016-08-23 14:36:23
@_author: Peter Lebbing 
@_subject: Security through obscurity (was: OpenPGP Smartcard recommendations) 
My main argument is this: white-hat security researchers would have a
difficult time assessing your design when it is closed.
But that /you/ can't just go and download the design from Yubico does
not mean that nobody can access (steal) or reverse-engineer it. And the
people who do this are often the people you least want to have the
design. They're not the white-hats[1].
People might think that "not available == not available". I don't think
that's accurate.
Lastly, depending on where the company is situated, governments can play
a nefarious role, looking at the design, mandating backdoors. An open
design is better equiped against government mandates than a closed design.
So you don't just want to know "this device does RSA", and "RSA is open
and secure". You want to know "it is correctly implemented". When you
can get good security experts to just download your code and design,
they can verify that. When you close the design, your only option is to
approach a handful of researchers and have them look at it under contract.
Bugs might still go unnoticed. Open access is not a panacea. But
"security through obscurity" IMHO pretty much means there are much more
bad guys looking into it than there are good guys.
But they can sell their knowledge and expertise on a black market...
I think they did it to the best of their ability. But I'd like it
independently verified that they actually didn't introduce a bad bug.
All software has bugs.
At least, none of the good guys did. I'm not trying to scare anyone. I'm
just saying that if the source was closed, there would be a lot less
good guys to ever do the spotting, and it would be harder to spot for
them. It makes it harder for the bad guys to spot the bugs by not having
the source, but it also makes it harder for the good guys.
This is what I was actually referring to by "a certification stating
some party thinks you're secure"; I just put it a bit starkly for
effect. I'm not convinced CC EAL-blah actually means much. I get this
itchy "designed by committee" feeling, and a feeling of imposed
bureaucracy. So if Common Criteria are actually promoting security
through obscurity, which is what I think the blog post is alluding to...
meh. Stuff your criteria. Just look at in what ways card payments are
broken. Pick any recent Chaos Communication Congress, you'll find a talk
about it, I think. These systems are Common Criteria certified, yet you
can buy a second-hand payment terminal on eBay, enter a store
indentifier that is printed on every receipt of a store, and start
reimbursing payments to cards from that store, payments that were never
done in the first place. It's the reverse of paying at the store: you
put in your card and the store pays you, on your bank account. Methinks
Common Criteria missed a criterium.
Oh, definitely. But I'm convinced that in security, both algorithms and
implementations, an open design is always better than a closed
design.[2] I don't see the algorithm and the implementation as
completely disjoint in this respect. All of the stuff that protects the
secret knowledge, whether it is algorithmic through multiplying the two
secret primes of RSA or the implementation which must prevent leaking
knowledge in random padding; all of this stuff is vital in keeping
secrets secret. Any part failing is catastrophical.
I've read about way too many goofs to still trust that something is
"secure" when the manufacturer claims it is. I just grudgingly have to
accept that there is quite a limit to what is openly available at the
moment, or at what price in comfort and features. You always have to
compromise, and everybody needs to decide for themselves where that
compromise lies. It would be very preferable if that decision was based
on an accurate understanding of the matter, though... :( (I'm quite
worried about all these so-called "free" services on the internet. I
mean the "gratis" ones).
[1] White-hats do reverse-engineer. For instance with voting systems,
which often turn out to have pretty lousy protection, even though the
manufacturer claimed all kinds of features.
[2] But I'm certainly not stating "any open design is better than a
closed design". That would be silly. There are certainly worse open
designs available than, say, a multiple-thousand-dollar Hardware
Security Module ;).

@_date: 2016-08-24 19:00:39
@_author: Peter Lebbing 
@_subject: Unsubscribe me please 
Yet, the "you" you are contacting are not in the power to help you. It would be
strange if the subscribers of a public mailing list could unsubscribe other
Please follow the link at the bottom of *every* post you receive through the list:
If you ever find yourself in this situation again, please look for some pointers
in the mail or on the web first, instead of posting such messages to the mailing
list. It is a bit disruptive.

@_date: 2016-08-31 12:58:29
@_author: Peter Lebbing 
@_subject: Key Discovery Made Simple 
Well, as long as we are submitting minor corrections to the blog post, I
wondered about the directory name in this command:
Specifically, the -f argument to make. It's clear you need to invoke this
command and others in the home directory of the user (and not a subdirectory of
the home directory). Perhaps it's better to put some emphasis on this aspect,
and I think the command could then be:

@_date: 2016-08-31 12:44:06
@_author: Peter Lebbing 
@_subject: Key Discovery Made Simple 
In Debian 8, the default cron daemon seems to come from the package 'cron'. I
don't think you get the 'systemd-cron' package by default: you need to
explicitly install it, and uninstall the 'Prio: important' package 'cron'.
Either way, I was unable to reproduce this. I installed systemd-cron, and it
accepted my "*/4" happily (and did indeed run the command every four minutes).
Though I no longer was able to edit my crontab as a regular user, I needed root
to do it with "crontab -u peter".
Do you have a Debian bug reference for this? I don't see it. The snippet Werner
quoted from the man page is also in the man page from 'systemd-cron', by the way.
I get the feeling systemd-cron is for supporting "legacy" stuff, and people who
go all-out systemd will use systemd facilities such as timers to implement stuff
"legacy people" ;-) do with crontabs.

@_date: 2016-12-03 15:35:09
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
Right, you're also hiding the proxy server. So if the proxy used the
same public key for multiple nym accounts, that would link them up as
all using the same proxy. That makes sense, I didn't know you were also
hiding the proxy you're building.
I think it would be better to implement the proxy on the client machine,
instead of on a server machine. That way, all secrets stay on the client
machine, and you could still use regular e-mail clients, just with an
IMAP server at the localhost. This seems *so* much better than a server
which can decrypt all client data! But let's take for granted that you
want to do it as you want to do it, on a server.
I doubt you would run into any trouble just using a separate homedir per
user account. I don't think agents take a lot of resources. When the
user logs out, you make the agent quit as well. You could remove its
socket; it will notice and quit within a short while. There's also the
Assuan command KILLAGENT which does what it says on the tin. I don't
know what interface to GnuPG you were planning to use, but I would
strongly suggest GPGME; it's the official way of programmatically using
GnuPG. That said, I don't know if GPGME offers a way to issue the
KILLAGENT command.
A separate homedir per user means you get the separation you wanted.
I don't see the purpose of using the password of the user account for
encrypting the private key, though. It doesn't seem to add security and
does seem to add problems. If you're worried about seizure of the data
at rest, you could use a single server-wide passphrase to encrypt all
private keys used by GnuPG. You could use disk encryption, that seems
like an easy way out and would protect other sensitive data as well. Or
you could use a specialized pinentry implementation, that always returns
the same passphrase, which could be seeded when the server boots up.
Pinentries are easy to write.
If you really want to cut down on the number of running agents, I'd
first discuss this with the GnuPG developers. Is the agent well suited
to serve dozens, hundreds of private keys? If the design never accounted
for this possiblity, it might be horribly inefficient or expose
unexpected issues.
(You could take the middle road and serve, say, 32 clients per agent.)
However, that still presents a serious issue with private key ownership,
both in the case of multiple recipients and with --throw-keyids, which
you would not have with an agent per user.
GPGME tells you which private key was used to decrypt the message.
However, if there are multiple recipients on the same proxy and they
share an agent, GnuPG will only use the first one that succeeds. If your
proxy software would inspect the recipient and only allow the owner of
the indicated key to read the message, the other recipients wouldn't be
able to read the message, because the agent never needed to use their
key in the first place. Argh.
For hidden recipients, it would be a serious resource hog to try all
keys, and would additionally have the same problem with multiple recipients.
An option --only-try-secret  would solve both (your software
would know which to try for a given nym account), but such an option is
not available. You could try to make the case that such an option would
be a good idea to implement. It would serve more scenarios than just
yours. For instance, people with smartcards could use it when a message
is also encrypted to an on-disk key, when they can't or don't want to
insert their smartcard. And if somebody knows which key is the hidden
recipient, but has multiple secret keys, it would save them declining
all the dialogs for the keys that aren't the recipient.
You are worried about all other kinds of key management issues. I don't
think that is really so worrisome. You could simply zap the revocation
certificate already on creation, or periodically zap the contents of the
openpgp-revocs.d dir altogether, I don't think they serve much of a
purpose in your scenario. And once a user account is deleted, simply
delete the accompanying secret key (--delete-secret-keys, not
As long as you don't meddle with multiple public keyrings, this is just
fine. You might say multiple keyrings "without doubt have stood the test
of time in GnuPG 1.4", but I suspect this test of time is precisely what
has shown the people actually maintaining this feature that it is
riddled with hard issues.
While we're touching on that subject, if you go the single agent route,
you could just hold all public keys in one keyring. I think it's built
to be big. GnuPG 2.1 is a lot more efficient with large keyrings than
previous versions. And public data is public data, right? No need to
wall it off.
That does leave deletion of public keys, but you could do reference
counting in your proxy server. If somebody, through your interface,
imports a public key you already have, you increment its reference
count. When the user deletes the public key or the account is deleted,
you decrease the reference count. Once it hits zero,
--delete-public-key. Perhaps multiple keyrings would have saved you of
this, but it doesn't seem very complicated, there are no dependencies to
track or anything, just a simple reference count.
Or you could use --no-default-keyring along with --keyring and use a
public keyring per user, that still works in GnuPG 2.1 right? Multiple
keyrings at the same time has interesting ambiguities, like where to
delete from and where to add to, which one to use when there are several
versions of a key, etcetera. I think your issue stemmed from using
--delete-secret-and-public-key rather than --delete-secret-keys. The
former is a combination of --delete-secret-keys and --delete-keys, and
with multiple public keyrings, --delete-keys gets "interesting".
Again, a large part of this mail could just be thrown away unread (or
unwritten :) if you simply use a single homedir per user account. Is
this perceived saving of resources worth all this trouble? Changing
secret keyrings in GnuPG 1.4 is more or less replaced by changing
homedirs in GnuPG 2.1. It's not this difference which you're coming up
against here, it's the difference that 1.4 does everything in a single
process that quits when it's done. In 2.1, there's the agent, which
Something totally different, but brought up by other people before. Do
the generated private keys hold UID's? And if so, it's just the nym
e-mail address, right? No name portion. You'd better *very* clearly
inform your users then that your server is pretending to be the owner of
their nym address, and very clearly inform them that your server can
read all this encrypted data! You say they are free to add another layer
of encryption. Sure, but make them realise that without this, they are
placing a huge amount of trust in your server and its operators, and
where it is housed etcetera. If your software would run on the client,
this wouldn't be an issue. And it's a huge issue, IMHO.
Right, yes, pseudonymity, the recipient could be the adversary. I'm not
used to thinking about Alice or Bob that way.
Anonymous remailers solve the time issue by random delays. You could do
that here as well: hold onto the mail for a random time once it's
submitted, then sign it, then hold onto it for some more time (random),
and only then submit it to the anonymous remailers. It's just two hops
extra random delay in the remailer network, in the sense of time spent.
But if you want to drop timestamps, I doubt --faked-system-time is your
friend. Like the manual says, "only useful for testing"! It affects
everything. If someone creates a key and sends it to their
correspondent, and the correspondent would use a --faked-system-time
from before the creation date, *poof*. GnuPG will notice the key seems
to come from the future and deny to encrypt to it. Everything breaks
down. Same with expirations and extensions thereof. Also, there's the
trust database, which is periodically rebuilt and timestamped.
Interestingly, my GnuPG 2.1.11 didn't complain that the trust database
was from the future, but I wouldn't depend on this staying this way.
Another nice edge case: a key is created at 14:54, but it's trying to
issue a signature at 12:00. Oops:
$ echo hoi | gpg2 --faked-system-time "20161203T110000" -u 0E675C27 -s
gpg: WARNING: running with faked system time: 2016-12-03 11:00:00
gpg: key 0E675C27 was created 10495 seconds in the future (time warp or
clock problem)
gpg: key 0E675C27 was created 10495 seconds in the future (time warp or
clock problem)
gpg: skipped "0E675C27": Unusable secret key
gpg: signing failed: Unusable secret key
(I'm on CET, and --faked... is in UTC).
And I wouldn't be surprised if there are more snags when you pretend
you're not living in the now.
I just checked the OpenPGP RFC, and though the signature timestamp is a
separate subpacket that could be omitted, there is a MUST requirement
that it is present. So to create an OpenPGP compliant message without a
good timestamp, you do have to fake a timestamp, unfortunately. Maybe
you could make the case that faking a signature timestamp should be a
feature? I can imagine a different use case: not letting the recipient
know you were still working on stuff at 3:00 in the night, even though
you were. But it doesn't seem like a high-priority feature request to me
Yes. My mind is used to thinking about the recipient as implicitly
trusted with knowledge, which just isn't the case in a pseudonymous
system. Anonymity is easier in that respect: signatures make no sense at

@_date: 2016-12-03 18:41:05
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
Hey, I didn't know that! Thanks!
The smartcard case seems to work anyway, in a test it seems to be tried
only after the on-disk keys.
It is indeed sufficient for the known-hidden-key example, but not for
the case with known recipients. I just tried, if there are two secret
keys that are encrypted to and they are named, it will try them in
order, no matter --default-key. Perhaps --default-key could be extended
to always try that first?
I think in fact --default-key is enough... I just tried with GnuPG 2.1,
and it only tried that secret key. Any additional keys need to be added
via --try-secret-key or --try-all-secrets. So it seems to complete solve
the hidden recipient problem, only the known multiple recipients problem

@_date: 2016-12-04 14:33:47
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
Hi all,
In just a few weeks, the 33C3 will be held in Hamburg, the 33th Chaos
Communication Congress organized by the Chaos Computer Club. I intend to
organize a keysigning party, just because they are fun.
I am asking for your thoughts on a variant of the organization of the
keysigning party. I'll explain my reasoning and intentions, and I would
like to know if you think I forgot to think of something important. Is
there a way a malicious party could get people to sign the wrong UID,
because I didn't think of that way? I'm not interested in ways people
could cheat at the usual "informal" keysigning party model, with
exchanging paper keyslips. This is because this would be my fallback
model, if the proposed model doesn't work out. So I'm only interested in
cases where the proposed model introduces extra issues compared to the
informal exchanging keyslips model.
There are several methods to do a keysigning party. One of them is the
"Sassaman efficient" version. It requires preparation, and this
preparation must be done in time that everybody can print out their copy
of the list. With a congress spanning several days, this means the
preparation should probably be done before the congress, since in
general you shouldn't print your list on a printer you don't completely
trust, and most people don't bring a printer (I did! :).
Now Sassaman efficient has a very big issue. There will always be people
who also wish to attend the keysigning party who did not participate in
the preparations. As far as I can see, these people could just
participate as equals with printed out keyslips to hand out to the other
people. However, I've seen multiple times that these late guests were
treated as second-class participants. I've actually seen them delegated
to the corridor outside the room where the party was held, told to wait
until the others were done! I never got a chance to exchange
fingerprints with these people because of course they left a long time
before the party inside was done. I can't imagine this was a very
pleasant experience for them.
The common denominator of the Sassaman efficient and the informal method
is that you form a line of people that folds in on itself. Now, as I see
it, you can just form a line beginning with the people on the list and
ending with the people who joined late.[1] With the people on the list,
you only check ID's and place a checkmark on your list when satisfied.
Once you get to the part with the late attendants[2], you instead
exchange key slips. I don't see why the people who are not on the list
should not be allowed to be in the same line, yet it is what I've seen
Anyway, so, Sassaman efficient has a major problem. It also has
advantages. At the bottom line, there is only one advantage I find relevant.
With Sassaman efficient, you actually only have to check one SHA256 hash
and your own fingerprint.
No matter how many attendees, you don't have to check anyone else's
fingerprint manually. Just the two!
This is because you have a SHA256-protected list of fingerprints already
in digital form; no need to compare to printed out digits on paper. All
attendees who participated in the preparation have gotten a text file
which contains all fingerprints of the participants, and they print out
this list as well as compute its checksum. Additionally, they check that
their *own* fingerprint in this list is correct. At the event, the
SHA256 checksum of the text file is read aloud and everybody compares it
to the checksum on their piece of paper. Next, each participant on the
list is asked in turn whether their fingerprint checked out.[3]
After the event, you'll go home and sign keys, using the verified text
file that has the correct SHA256 checksum. Now when you use CA - Fire
and Forget, caff, all you have to check are the UID's you are signing.
The SHA256 checksum has already ascertained that the fingerprints in the
text file are correct; anyone altering a fingerprint will necessarily
alter the checksum of the file. And caff checks the fingerprint for you
from the known-correct file! As long as all participants verified that
their own fingerprint is correct in the file with the correct SHA256
hash, all fingerprints have been verified already.
It will still be *very* important to verify the UID's manually. What if
the official list had a key with fingerprint X and UID
, but once you download the key with fingerprint X,
there's instead an UID ? You need to check that you
only sign UID's carrying Alice's name that you verified from her
passport or similar thing.
I quite like it that I don't have to verify dozens of fingerprints
manually; I'd like to keep the list if possible. So can we improve on
the party where there is a line of both people on the list and people
with keyslips? I think we can.
I think ideally, the participants who only joined after the preparations
should also be able to use the list for the people that are on it, to
put checkmarks and be able to sign without manual fingerprint
verification. But you can't /just/ give them a copy of the list on paper
to trust on, because that printout could have been altered. If they have
a printout with an altered fingerprint, this will confuse them and lead
them down a bad road. But they don't actually need to check the
fingerprint, right? Why print it out then?
First, let me show you a possible participant list for Sassaman
efficient, as produced by gpgparticipants (signing-party package of
Debian). Then let me show what I'd like to alter.
                                    CUT HERE
                                    CUT HERE
Now once these people get home, they get the original text file from the
organizer, and verify its checksum using their paper copy. Additionally,
they need to check that the UID's on their paper copy have the same
serial number as the ones in their digital copy. This is an additional
task compared to what the other participants need to do; since the
others printed their own version they *know* the only way UID's could
have been swapped or added is if they did it themselves before printing.
After the late participants have verified the checksum and the
serial<->UID mapping, they can continue as the other people, not
verifying fingerprints because they already verified the SHA256 sum.
The reason for wiping out the parts that aren't checked is so people
will not get confused should they mismatch. If the one doing the
printing was malicious, they could alter fingerprints on the list. This
would entice people to sign the key with that fingerprint, even though
it is the wrong one. You could tell people that they need to ignore this
unverified information and use the official, SHA256-verified digital
list only, but that is asking for trouble. Just remove this unverified
information and be done with it!
So, thank you for reaching the bottom of my mail. What do you think?
Does it work? If not, I'm falling back to the informal model, to remove
the perverse incentive that arises from using Sassaman efficient, the
incentive to treat latecomers as second-class (since my proposal
includes them explicitly in the process, they won't be left out).
[1] The only reason I group the list people and the keyslip people is so
you only have to switch exchange method twice; you start out with one
group, halfway switch to the other group, and then later switch back to
the first group. The people at the very beginning and end of the line
only switch once.
[2] Well, late as in not early. Let's hope they're not deceased by then ;-P.
[3] There will be an issue here if the checksum did not check out for
someone; the organizer should make clear that once your checksum is
wrong, you should stop using that mangled version at once.

@_date: 2016-12-05 12:18:01
@_author: Peter Lebbing 
@_subject: Toggle the authenticate capability 
Mathematically, I think you're wrong, it's very vulnerable :-).
Authentication is signing the challenge sent to you by someone else,
signature is signing the data you wish to approve of in some way. So if
I can send you a challenge that would turn into a nice signature of you
authorizing a bank payment to me, that would be easy money.
However, in practice, a challenge has a different format than a data or
key signature, and they can be differentiated. This isn't math, though.
For RSA, you still do the modular exponentiation of RSA.
When I brought up the issue some time ago here, I got no response, so I
concluded it's not a problem. I was worried that some future
authentication mechanism might actually produce the same data structure
as a normal signature, but the lack of shared concern made me think it's
probably not an issue then.
If this is a signature /subkey/, they can be rotated willy-nilly. Expire
the current signature key, create a new one and delete the private part
of the old signature key. It doesn't need to be revoked.
Which defaults produce an authentication-capable key by the way? I don't
remember seeing that.

@_date: 2016-12-05 17:05:56
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
I would seriously consider the option of just sticking to 1.4. It's not
deprecated for server use. It should still have a lot of life left in it.
That sounds like a bug. In fact, an agent-freezing bug was fixed a short
while ago, are you runnning the latest and greatest? Otherwise, it might
be a new bug.
I understand what you mean (I think :), but you can't really draw any
conclusions from that, I (also) think. The private key handling in the
agent is all different code, a new architecture. That GnuPG 1.4 in
practice works fine with many secret keys does not say anything about
what the agent will do, even though they basically perform the same task.
I might be overly cautious here; Werner might well say "well sure it
handles lots of keys fine". But being cautious sometimes pays off
tremendously well...
But you know which nym address the message was addressed to, right? When
somebody tries to open a message addressed to their me at nyma.com account,
you only try the key associated with me at nyma.com. Two keys at max, when
you're doing a key rotation and the old key is still valid.
There is no need to try their me at nymb.com key, because you know it was
addressed to me at nyma.com, and any message ending up there being
encrypted to me at nymb.com could even be an attempt to link those
identities: if me at nyma.com answers to the content of the mail, you now
know they actually have the private key for me at nymb.com, and you've
linked those accounts. It seems to me you *really* don't want any other
keys to be tried *at all*, even if the user owns them.
And similarly, if you could actually order the tried keys with
non-hidden recipients, you would only specify one or two keys which both
would be keys your user actually has. And --status-fd neatly tells you
which key was used to decrypt, so you can easily verify the intended key
was being used and not some other. However, right now, there is no way
to force trying specific keys first with non-hidden recipients.
Well, since Werner would actually like to get rid of multiple keyrings
because of the problems it is giving, I can quite understand not
touching it with a forty feet pole when creating something new. In fact,
I wouldn't have been surprised if multiple public keyrings wasn't
implemented in GnuPG 2.1. But he did maintain that feature for now.
Don't use --delete-secret-and-public-key, but --delete-keys and
And as I said, multiple keyrings is asking for ambiguities when removing
keys, or using a key that has multiple different versions on different
GnuPG 1.4 didn't always do the right thing with one secring and multiple
pubring's either. Or, "the right thing"... I mean, "the thing the user
No, but the freezing seems like a bug, a bug that should be fixed if it
is the agent's fault. And if you actually have hundreds of users logged
in at the same time, I would not think that hundreds of agents is
actually significant. Have you tried to run a test load, see what
resources those agents actually take? And whether that's actually
significant compared to the processing involved in handling all those
mails of which they are doing the assymetric decryption part?
I am assuming you kill an agent when a user logs off.
Maybe I don't understand, your proxy serving hundreds of users with each
possibly dozens of nym accounts is a diminutive part of the server? Or
do you mean when it is running on the client?
The problem is the impersonation and who actually is the account holder
of a nym account. Your server is pretending to be the holder, or,
actually is the account holder. Your users don't own the nym account
anymore. They need to know this. The proxy might allow them to use the
nym address, but the proxy is the holder of the nym address. It holds
the private key. QED.
In the end, the nym server is actually the real /owner/. But this is
more easily understood by users. They might not realize that they are
actually authorizing your proxy to do their business on their behalf,
impersonate them even. But it is a pseudonym, so it's less bad than
impersonating them using their legal name.
Iff they know how it works! User education is very important here,
because if they think "it's encrypted and pseudonymous" and don't use an
additional key, they are unwittingly including you (as server operator)
in their private communications!
This doesn't make sense to me. You don't want to expose the time the
signing is done, but then you go and expose the timing of it anyway by
sending the mail right away straight to its destination because your
user doesn't want to wait?
I think those users that can't wait also can't use anonymous remailers
then? Several hops of anonymous remailers takes longer than two delays
on the proxy. When they can't wait for the proxy to delay, they
certainly can't wait for the anonymous remailers taking even more time.
And if the anonymous remailers don't delay, they still leak the time of
sending as much as your signature timestamp does, and do so to all
passive listeners rather than just the nym server decrypting the message
and seeing the signature.
I can understand not wanting to change a design much that has been
running for many years, so I am not saying you should do everything
differently. But keep it as it is for the right reasons. This doesn't
seem to be one to me. Unless I'm once more missing something :-).
I'm not suggesting that the proxy force the client to wait before
sending the message to the proxy, or to wait for confirmation from the
proxy. That would be silly, because the actual communication over the
public internet would still take place at the same time as signing, just
a bit later. You want to lose the temporal connection between the client
sending the message and it being processed further. I'm saying it should
accept the message (do sanity checks), hold it in a queue for a while,
and only then sign it. Hold on to it some more, and then send it on.
An anonymous remailer wouldn't force an incoming connection to wait for
a while either, right? It would accept the whole message, wait, send on.
I think this distinction is important: *It's not a feature in any GnuPG
version*. That you can abuse things to do what you want does not make it
a supported feature!
I see a place for such a feature, but ultimately, the maintainers decide
whether it has a place in GnuPG or not, even if another developer did
the work of implementing it.
I enjoy thinking about such stuff, and I hope it is useful to people I'm
thinking it aloud to...
By the way, thanks for working on solutions to let people protect their
privacy and identity. It's important work in today's society!

@_date: 2016-12-06 20:29:42
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
--secret-keyring file
              This is an obsolete option and  ignored.   All  secret  keys  are
              stored  in the ?private-keys-v1.d? directory below the GnuPG home
              directory.
GnuPG 2.1 works in a different way with secret key material, so you can't have multiple secret keyrings in the same homedir anymore.

@_date: 2016-12-08 12:20:01
@_author: Peter Lebbing 
@_subject: Recording keysigning attendants on phone (was: Hybrid keysigning 
Yes, that is spot on what I had in mind. What do you think?
I can't say as to your perception, but all these "verify at the party, sign
after the party" share the problem that the list could be modified in the time
between verifying and signing.
Somebody could picpocket your list, add checkmarks with the same type of pen you
used, and then sneak it back into your possession. That's a physical act that
requires an intimate level of proximity.
A phone or tablet is a wirelessly connected device that could be hacked from a
distance, and it could be done even before the keysigning.
I'd say the latter is in principle more vulnerable; but it depends on your
threat model. If, for instance, you've already concluded that you want to have
your primary key on the same phone or tablet, it doesn't matter anymore if you
then also keep this party list on there.
For the sake of my sanity and the fact that I'll need to make the decision about
the 33C3 keysigning soon, let's please not mingle these subthreads. If you reply
to my "What do you think?", I'd suggest re-instating the previous Subject:-line :-).
Thank you!

@_date: 2016-12-08 12:35:11
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
Stephan and Lachlan, thank you for thinking about this! I need to make a
decision soon, I really need feedback!
The normal attendees also don't do any fingerprint verification *at the party*.
At home, before the party, they checked their own fingerprint, and generated the
SHA256 checksum for the file they got. At the party, everybody together checks
the SHA256 checksum by simply reading aloud each and every digit.
It is :-)
I wouldn't say my information is detailed actually, I could write a *lot* more
about proper procedure. But I hoped I didn't have to, instead just focussing on
what I wanted to do *differently* from usual.

@_date: 2016-12-08 14:55:12
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
Yes, the late attendees definitely need to be there at the beginning of the
party, verifying that the SHA256 checksum printed at the top of their scrubbed
list is the one being read aloud and hearing everybody confirm their fingerprint
is correct.
Correct, I actually cross out the full entry with my pen, but it would suffice
not to put a check mark on Fingerprint. A check mark on ID is totally out of the
question, that check mark indicates you have verified their identity!
The list is *immutable*. It is finished before the event even starts, and has a
known SHA256 checksum.
People are not added to or removed from the list.
Late participants get the original list as it was sent to the early registrants,
with the precise, known SHA256 list.
After someone has verified they at least received the correct list
electronically, they're free to change whatever they like on the list for
themselves, *but not to send on to others*. It is vitally important that wat is
sent to people is the original list with the correct SHA256 checksum. And if
somebody is unable to get a list with the correct SHA256 checksum, they have
wasted their time with verifying the people on the list. But this would be an
odd situation: nobody is able to send them an unmodified file? I'd worry about
my computer and my internet connection then, not the time lost during the
Checking serial numbers <-> UID mappings is /purely/ to catch out dishonesty on
the part of the person who printed the scrubbed lists for the late attendees. It
is not to account for changes in who was present and stuff like that.
Of course I'll provide the lists, so I for myself know they will be okay.
However, the other people would just have my word for it, and that is wholly

@_date: 2016-12-08 18:12:50
@_author: Peter Lebbing 
@_subject: An attempt at backporting 2.1.16 from Debian sid to Debian jessie 
Hello dkg and list!
Let me start out by thanking Daniel Kahn Gillmor for all his work on GnuPG and
its Debian packages. And also thanks to all the other devs!
I'd like to use the latest GnuPG 2.1 on my Debian jessie machines. When the
Debian package went from version 2.1.11-7 to 2.1.11-7+exp1, it started providing
Starting with stretch, if all works out, GnuPG 1.4 will no longer be providing
the major role it had in Debian so far.
I forked the Debian git repo for GnuPG 2.1 [1], and had a go at what was
primarily the reversal of the changes introduced by 2.1.11-7+exp1. You can find
the result at GitLab at [2].
I'm running this version myself now, and it all works so far (famous last words...).
I'm giving you all the loaded gun to shoot yourself in the foot. I do not
recommend my fork for general use, but rather as a service to people who really
want 2.1 and are prepared to deal with issues arising from having both 1.4 and
2.1 on the same system.[3]
I'm very interested in feedback! I'd like it if people check my changes, do they
seem okay to you? Did you run into issues? I'd also like to hear from people
succesfully using it, but don't feel obliged to tell me.
If you feel I shouldn't be doing this, we could discuss it further. Maybe we can
work out a deterring formulation for the README to prevent people installing it
:-). Or you convince me of my folly.
This version will replace jessie's 2.0.26 with 2.1.16, but it will install next
to GnuPG 1.4. However, mixing 1.4 and 2.1 is not for the faint of heart. There
are good reasons that dkg is choosing not to support 1.4 and 2.1 on the same
machine starting with Debian stretch: while on the surface they are compatible,
they quickly go out of sync regarding private keys and it can get interesting
with public keys as well. "Interesting" as in "May you live in interesting
times". not as in "Hey, that's interesting!"... that is, not a good thing at all.
*Use at your own risk! This is provided as-is without any warranties.*
I tried my best, but sometimes, your best isn't good enough... ;)
Oh, and I'm already behind. The latest and greatest is now 2.1.16-3, and I'm
still providing 2.1.16-2~dbbp8+1 [4].
[1] [2] [3] Hey, that's pretty good, I'll put that in the README.
[4] I means: Digital Brains BackPort Debian 8.x version 1. Same numbering scheme
as backports.org, different identifier.

@_date: 2016-12-11 11:51:12
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
I'm going to respond to a few points that I already know my answer to. I
might not actually have all that much interesting to say about the more
complicated points, though...
I meant that GnuPG 1.4 is not deprecated for server use. By which I mean
it is pretty much advised against for desktop use.
I didn't mean that GnuPG 2.x was deprecated for anything at all :-).
It does say "targeted to the desktop", by the way.
That's because it is assumed that if someone can access your ordinary
agent socket, that would mean they have full access to your user account
and are thus qualified to use it. It doesn't leak any information if it
is simply handing that information to the user. It's just that your
definition of "user" is quite different than the definition that was
used in the design of the agent!
(I kinda thought we had established this by now...)
I'm not talking about /problems/, I'm talking about /design/. I
atrociously hate car analogies in IT, so I'm going to do one. If you
compete with a lorry in the 24 hours Le Mans, and you finish last, would
you say this is an "initial problem" in the design of your new lorry?
And if you tried to deliver a load of 50 liter beer kegs to a bar in the
center of a city with a lot of speedbumps, using a Le Mans Prototype
racing car, would you then complain that it seems not to work altogether
that brilliantly?
I'm not even saying that the agent is incapable of handling a large
amount of keys. I'm just saying that since it is possible that the agent
was designed for use by a single human with a usual amount of keys, you
could run into unforeseen problems when you use it in a totally
different way.
Such as that the agent doesn't have the required bottom clearance to go
over speed bumps.
I really don't think it will prevent a cached passphrase from being used!
Also, I doubt it serves any purpose without hidden recipients.
But this is what you're doing right now with GnuPG 2.1, right? AIUI, you
have one agent and multiple public keyrings. This is similar to one
secret keyring and multiple public keyrings in GnuPG 1.4.
Erm... see above? :-)
Apart from that, it's actually something people do use. It's why you
need --no-default-keyring if you don't want to use multiple keyrings
with --keyring. If everybody only ever used one public keyring at the
same time, --no-default-keyring would be implied.
First of all, I'm saying "in this scenario of how you could solve it,
I'm assuming part of the way you solve it is by killing the agent when a
user logs off". So "No, I don't" is not an answer I'd expect, I'd then
expect "No, I would not".
Furthermore, I don't understand. When this user logs off why would it be
bad to kill their agent? They've sent "QUIT" to your POP3 server and
closed the TCP/IP connection: they've logged off your proxy! You can
just restart the agent when they log back in. It has no relation with
how many nym accounts this user has whatsoever, that's a non-sequitur to me.
No, I said this correctly, I think. I used two different words, owner
and holder. GMail is the /owner/ of all the e-mail accounts. If they
decide to go bankrupt, you can balk all you want, you won't get your
 name back to use it. It's gone together with its
owner, GMail / Google. You don't have any rights to the gmail.com name.
The /holder/ is the one who has the passphrase.
And since a nym account is not protected by a passphrase but by an
OpenPGP keypair, the one holding the private key is the holder. And your
proxy has the private key. Not your user. You yourself say they don't
even need to know the key's ID, let alone its private key.
If I know your GMail passphrase, and I log in and change that
passphrase, I've taken your account. Would you say you still hold that
account? By rights you perhaps should, but you *don't*.
If you decide you quite like being the pseudonym  and take
it from your user, would you say they still hold that account?
That's the crux of the matter.
Your users know that the server operator of nyma.com can just say to
them "Hey, it's my server, I don't want you to use anymore". They need to know this goes for your proxy as well.
I hope you mean "of course I need to inform them", not "of course users
should figure this out", because it's slightly ambiguous the way you say
it :-).
I'm saying you should
delay delivery
delay delivery
deliver to first remailer
it delays delivery
Don't delay the action of sending, delay the action of delivery.
Delay in a conversation serves no purpose at all.
What the people doing conversation see:
(TCP/IP connection from client to proxy)
12:00 C> Please send my message
12:00 P> Alright, please accept a delay...
12:05 P> Okay, I'm done pondering the great truths, deliver!
12:05 C> 12:05 P> Thanks
(TCP/IP connection from proxy to first remailer)
12:05 P> Got a message for ya
12:05 R> Go ahead
12:05 P> 12:05 R> Thanks
What an observer sees:
TCP/IP connection to proxy, originating at client:
12:00 C> 12:00 P> 12:05 P> 12:05 C> 12:05 P> TCP/IP connection from proxy to first remailer:
12:05 P> 12:05 R> 12:05 P> 12:05 R> The temporal connection between the two is glaringly obvious! You know
when the client sent this message!
Delay in a conversation doesn't help. You need to put a delay /between/
I can agree that delays shouldn't be infinite. Kinda goes without
saying, although this would be a *very* secure system.
It only reveals that your computer was running if your proxy is running
at the client. If the proxy is on a server, you could use the delay
tactic and it would severely limit the use of knowing the timestamp.
But when the proxy is on the client, then I think that a faked timestamp
is useful. Also when you don't want to change your whole design. But how
do/did you handle timestamps with GnuPG 1.4?
Yes. Also; when I didn't reply to things you said earlier in the
discussion, that was sometimes because I agreed so had nothing
interesting to say about. This tactic does make it seem like I only have
counterpoints and never agree with anything, so I should probably be
more aware of this effect...
This depends on the intelligence of the proxy. If it depends on the
first remailer to do checks and report success, then it won't work. But
if it can check the sanity of the message without doing any connections
to the outside world, it can do all of those checks and only delay the
signing. And I already said that I see no reason to use the user's
password to encrypt the private key, so signing can't fail due to a
wrong passphrase.
This seems to presume the proxy runs at the client. I've already said
above that the delay tactic only makes sense when the proxy runs on a
server, so I agree.
No, I said using --faked-system-time to fake a signature timestamp is
abuse of functionality.
The man page says "This option is only useful for testing", and that's
not what you're using it for.
Please read what I say. I said:
I think this distinction is important: *It's not a feature in any GnuPG*
*version*. That you can abuse things to do what you want does not make
it a supported feature!
do what you want -> fake signature timestamps
abuse things -> use an option that says "for testing only"
You said "worth to be backported to 1.4". This seemed to imply to me you
thought the worth was in faking signature timestamps, but a backport
implies that we're talking about an actual feature. To which I say:
*it's not a feature*.
Heh, well, I can't take credit for that, so I'll happily pass these
thanks on to the people that do :-).
Oops, this mail has gotten so much larger than I intended...

@_date: 2016-12-11 12:01:04
@_author: Peter Lebbing 
@_subject: Something strange with Stephan Becks Signatures? 
Woa, easy there. While the Subject:-line of the OP wasn't perhaps chosen
very wisely, please calm your tone. I don't think the OP has it in for
you (though it is a possibility, but let's assume good faith). It seems
like he has a killer issue, and if there really is a correlation to
opening your messages, that could be worthful info for tracking down the
Without looking up the specific case, it happens more often that people
go away satisfied without sharing their satisfaction. Hell, I've been
guilty of it myself. In fact, I should still thank someone who gave nice
extra information which I wanted to ponder for a bit before replying. I
never actually got that far pondering and haven't thanked him yet...

@_date: 2016-12-11 12:15:40
@_author: Peter Lebbing 
@_subject: An attempt at backporting 2.1.16 from Debian sid to Debian jessie 
I discovered I accidentally wasn't allowing public access to the
repository. I've fixed this and you can now download from:
The offending setting seemed to have been:
Feature Visibility
- Repository
  Push files to be stored in this project
Now I thought setting this to "Everyone" would allow anyone to push
files to the project, which seemed like a truly horrendous feature.
Apparently, it allows pushes/files to be visible?

@_date: 2016-12-11 18:15:18
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
The e-mail wasn't meant to be the text for participants. I've spent all
afternoon writing a text at the 33C3 wiki[1], but only part of it is
meant to be read by everyone, or essentially, everyone who wants to know
more than the most basic. It's 1764 words. I've tried to restrict it to
the important things, and I feel that cutting it further down would lose
important information. I don't think it's necessary for everyone to read
the whole section, though.
My e-mail was 1424 words though, so I am afraid I ended up in your
wishful thinking area.
The remaining 1607 words are in the sections "Background" and "Option
for advanced users", and those words happen to include the name Lachlan.
Go check it out! ;-P
I really like this suggestion! I had to think about it for a while
before I could see a way to make it work. The trouble is that I want
caff to be able to process the file, and for that I need to keep it
having much of the same patterns. I ended up not significantly altering
the two files compared to what I proposed, but instead suggesting
everybody should use the scrubbed version. That way, the instructions
are the same for all participants.
Thank you,
[1]

@_date: 2016-12-11 18:22:26
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
Personally, I find checking a few other participants to be too weak an
assurance. I don't believe in security by numbers. If I'm dealing with
statistics, I want them to be on the order of "chance of one in 2^127".
You might recognise the chosen quantity :-). But everybody is free to
decide their own policy.
And checking at everyone would hold up the process; it's 64 hex digits
to verify!

@_date: 2016-12-11 18:41:01
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
Or you might not because it was based on a stupid thinking error on my
side. Let's make it "a chance of 1 in 2^128", which could be the chance
of you trying a symmetric encryption key and actually being right about it.

@_date: 2016-12-11 21:52:03
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
Oh, I thought you were referring to my warning that running the agent
with lots of private keys might hit some unforeseen issues.
No, it specifies which keys to try for a hidden recipient. This is easy
to investigate if you create a few test private keys and create some
test messages. I did that earlier, and I could see no overruling
behaviour or even a preference to --default-key or --try-secret-key.
This is comparable to a one-homedir-per-user setup in GnuPG v2.1.
However, that means multiple agents.
Okay, I don't really understand. In the POP3 usage scenarios I'm
familiar with, the client downloads all new mail since last time it
connected, and then disconnects. I get the feeling you do something
different, and that's what is causing the confusion.
The owner of  is the nym-a.com's operator, not the proxy.
Surely you can use nym accounts without your proxy? Are you saying
everybody who uses a nym service uses your proxy?
I'd consider them an indivisible unit only if they are run by the same
operator. So if you run both nym server and the proxy, then yes, it's
one unit. But this seems rare: wouldn't it defeat the whole purpose of
spreading the message over so many systems? You hold entry and end
point, what is still anonymous about that?
If the nym server is run by someone else than the proxy, that means
there are two parties involved. You depend on the nym server operator to
keep operating your account for you on that end, and on the proxy server
operator to do the same on the other end.
Yes, they are. This, most people will realise.
That the proxy server operator is not only doing work on behalf of the
user, but is actually acting as account holder on behalf of the user is
something that I wouldn't think obvious.
Any proxy server that sees cleartext passphrases can abuse that power.
But normally, it is just a gateway passing passphrases. Your proxy is
actually the one *having* the passphrase so to say, not the user. This
is unusual and needs to be clearly communicated. That's all I'm
advocating: clearly communicating to the user that they are not the
holder of the nym account, but are only allowed to use it while the
proxy holds it on their behalf.
In my example, the client is forced to wait before the proxy will accept
the message. This is a delay in a conversation.
A delay between conversations would mean accepting the message without
delay, closing the connection to the client, and then not sending on the
message immediately. Only after a delay, open the conversation to the
First of all, you talked about a Tor hidden service earlier, not merely
Secondly, if the message is signed at 12:00, but the message is only
sent at 14:00, that means the signature time is no longer strongly
linked to the time the message was sent. I believe this was your goal,
rather than "adding mothing". It might not be the full day of difference
you advocated earlier (data signatures one day earlier, key management
operations two days earlier, you rougly said), but to dismiss it as
Ah, so the proxy user can't enter a wrong passphrase for the signing
key, which was my point.
I don't see the use of a per-key or per-user passphrase at all, by the
way. Just use a proxy-wide key or disk encryption.
Again, I remember you mentioning Tor hidden services and TLS on
client->proxy connections.
That's an odd question, since you answered it so clearly, as I see it.
There's no 'testing only' there, so why would it be abuse? It's abuse to
use something that's clearly labeled as "for testing only" for something
that is so adamantly not testing.
"A feature" here meant: something that is supported by the program. If a
program does not have a certain feature, it means that the program
currently is not designed to do that.
I'm saying GnuPG does not have a feature to fake signature times.
It could be a worthy addition to its features, but it is not a feature
that the current program has.

@_date: 2016-12-12 13:34:56
@_author: Peter Lebbing 
@_subject: Strange behaviour 
No, I don't think that is good advice if given without a specific reason
to do so.
The expiry of a main key already establishes that others need to
periodically refresh the key, which will mean changes propagate.
There are reasons to use expiries on subkeys, but it is an expert option
and should just be left alone without a specific reason.

@_date: 2016-12-13 18:17:07
@_author: Peter Lebbing 
@_subject: Expiration of subkeys (was: Strange behaviour) 
There's nothing inherently wrong with non-expiring subkeys. Without
knowing the threat model, I don't see a reason to either start using
expiring subkeys *or* stop using them.
Coincidentally, expiration of subkeys by default was just discussed on
gnupg-devel; you might be interested in that little thread: [1]. If you
want to read the whole thread[2], not just this subthread, note that
Robert J. Hansen's contribution[3] went to gnupg-users instead of
I recommend reading Robert's message anyway, since it also deals with
the whole concept of "best practices" in general. It's a good post and
apt here as well.
When I did a quick look-see, I found that their recommended Card
HOWTO[4] actually creates a non-expiring key.
I don't know which intended public the FSFE's instructions have, or what
threat models they considered.
I'd set an expiry on the main key, or trust the OP to guard his
revocation certificate well (in the sense of not losing it).
[1] [2] [3] [4]

@_date: 2016-12-13 18:56:07
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
If they want to have a known good copy, they can just print the detailed
They then also have the opportunity to have gpgsigs annotate it with the
signatures they already did at an earlier keysigning party, saving them
the trouble of re-identifying someone for nothing. (Note that not all
people consider this "for nothing", some actually like to have a new
I chose to replace them by empty lines so the lists still line up if you
choose the screen font to be a similar size as the printed font. I will
be literally holding my paper list next to my monitor, it's useful if
they line up and all information that is the same looks exactly the
same. You spot errors much quicker that way.
Thanks for your thoughts,

@_date: 2016-12-13 19:04:52
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
Oh, not at all, I hadn't even noticed one could see it that way.
. What I meant was that it
This was a mail to a crypto-mailing list asking cryppies for advice on
how to cripple... er... subvert a certain setup. Totally different audience!
Hmm, interesting idea. Could be possible.
Or hang a truly huge printout on the wall and at the start of the
session, together observe that it is correct. Any latecomers can be told
"look, everybody thinks it's completely normal that we have a 64 digit
hex code on the wall, and that's because we all agreed it's the right one".

@_date: 2016-12-13 19:20:40
@_author: Peter Lebbing 
@_subject: An attempt at backporting 2.1.16 from Debian sid to Debian jessie 
I did that because all the software in jessie that depends on GnuPG 1.4
might not work with GnuPG 2.1. So by doing it like this, I'm not
breaking any packages that have the package "gnupg" in their dependency

@_date: 2016-12-16 12:34:14
@_author: Peter Lebbing 
@_subject: Smartcards and tokens 
However, the defining property of a smartcard is that in principle, the
private key cannot be extracted. That no longer holds for the party who
backdoored the smartcard, since they could add a special command that
extracts the private key.
Also note that someone could "borrow" your card without you noticing,
rather than compromise your PC. This does depend on physically close
attackers being in your threat model. Your USB token could actually have
been compromised remotely on a different system, as a roundabout way of
compromising your machine in the end. So that one is actually possible
for remote attackers.

@_date: 2016-12-18 10:49:39
@_author: Peter Lebbing 
@_subject: Smartcards and tokens 
However, this randomness is added by the host, not by the smartcard. The
OpenPGP smartcard really only does a deterministic action, and its
correctness can be verified simply by doing the RSA public key operation
on the output and checking that the result is identical to what was fed
to the smartcard.
I can't think of a side channel to leak the private key to an attacker
through an uncompromised host, but I wouldn't be surprised if there is
such a side channel. Does anybody have a cool way to leak this? Single
bits at a time will do! :-)
(We've already established that if the private key is generated on-card,
it is trivial to reconstruct it for an attacker that can insert a
backdoor into the smartcard)

@_date: 2016-12-19 12:22:32
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
I think I've made my point, but more importantly, I feel that you
understood what I tried to get across. You reach a different conclusion
than I, but I think any further discussion on these points would lead to
rehashing of previously made arguments.
Hmmmmm, it looks like --try-secret-key only suppresses passphrase
queries for keys, any cached keys are tried anyway? I didn't notice this
before. I did use 2.1.11 before and now I'm using 2.1.16, but I don't
know if I tested this properly with 2.1.11.
Well, never mind the confusion, of which I still think there is some, as
I fail to understand your conclusions.
You say a logoff is so frequent it will not be a good idea to kill the
agent then (I think, or something on that order). Okay.
You don't need to use the logoff as the signal to stop the agent, you
could easily do a timeout as well.
First of all, in the following, assume a homedir and thus agent per
proxy user account.
Once you invoke a private key operation, you also put a timestamp
somewhere. Maybe a file called "last_used" in the GnuPG homedir, it
could also be a timestamp in a database.
Everytime you use a particular homedir(/agent) to decrypt or sign, you
update this timestamp.
Now you have a reaper process that looks at all "last_used" stamps there
are, every minute. Once it notices that "last_used" is more than a
minute ago, it'll kill the agent for that homedir, and remove the
"last_used" stamp.
This way, as soon as your user has done nothing for a minute, their
agent is stopped. When they do something again, the agent is just
started up again, and stays alive until the client is idle again, at
which point it is once again stopped.
So, agents are only running for clients that where active in the last
minute. This should not waste resources at any appreciable level.
I actually thought you were also offering a proxy server to the wide
public, not just as a corporation to its own employees. But you know
what, never mind. You seem to have understood my point.
I presented it as an alternative to fake timestamps, to avoid having to
do them. When you say "I see no reason to do that when you have fake
timestamps", well... Yeah. You'd be right. That's pretty much what
alternatives are for. To do the same thing in a different way.
I was talking about the encryption of the private keys sitting on the
multi-user proxy; there's no need to use different "passphrases" for
different keys. This is /not/ data in transit. These passphrases that
encrypt the private key never leave the proxy, it's private information
to the proxy.
Don't get me wrong, but... you know what? Let's just not.
And that's an unnecessary, cheap shot. It will not make feature requests
any more likely to succeed if you pour them in such a mould; on the

@_date: 2016-12-19 12:28:05
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
And is the message still delivered decrypted to the client? Because in
that case, it seems that the only thing preventing a user from
disastrously exposing the relation between two nym accounts is them
noticing the mismatch in this little header in the mail. That seems like
a really riskful user interface. Hopefully the message text is merely
saying "Message encrypted to wrong key", right?

@_date: 2016-12-19 20:40:02
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
Why don't you just disable passphrase caching if that is the only
problem? (max-cache-ttl 0, I think that works, didn't check).
I think one of the underlying problems is that Carola wants to prevent
keys from being used even though the correct passphrase is presented.
Come to think of it, if you include the keygrip in the passphrase, the
passphrase would ever only match the one key. Heh. The same would work
if you include the proxy user name, if that is the level of division you
want. Pretty obvious once you think of it.
Still, it seems like a small part of the overall puzzle presented by Carola.

@_date: 2016-02-02 17:51:37
@_author: Peter Lebbing 
@_subject: Error when signing 
Could you show the exact command you're trying, and also, do you have a
gpg.conf? If so, could you include it as well.

@_date: 2016-02-03 10:42:39
@_author: Peter Lebbing 
@_subject: Error when signing 
Your gpg.conf seems okay, but when I download your key from the
keyserver, it's telling me that you revoked the key on the day you
created it. The error "secret key not available" is a bit misleading; I
think perhaps "available" here indicates "usable". You cannot sign with
an expired key. However, this explanation doesn't quite account for this
output you got:
Because it should say "revoked" for the UID validity.
So... why are you trying to sign with a key that appears to be revoked?
And did you revoke it on a different computer and not import the
revocation to this computer that still says "ultimate" for validity?
BTW, which version of GnuPG are you using, and on which platform?

@_date: 2016-02-05 11:24:35
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
When the GnuPG default was not to show the key usage, I would have said:
unnecessary detail. In my opinion, in a very broad sense, the FAQ should be
aimed at people sticking to the defaults, not the people who tinker.
But now GnuPG shows the key usage by default. Personally, I would probably think
"usage: SC? What is it telling me?". The GNU Privacy Handbook doesn't seem to
mention it. The GnuPG 2.1 manual is not what I consider a guide for beginners,
it's more of a reference. But anyway, I don't see it there either. I just
quickly browsed through these two documents.
I do think it should be documented in a document that a beginner ought to read.
I don't know if it belongs in the FAQ; I would be equally satistied with it
being in the GNU Privacy Handbook. How well maintained is this latter document
My 2 cents,

@_date: 2016-02-05 11:55:46
@_author: Peter Lebbing 
@_subject: Glossary. Please add definitions to a Glossary... 
There's already a list of terms in the FAQ as well. "Signature" is not in it,
but I don't think that's a Frequently Asked Question. The other word Don Saklad
asked, "key", is there already.

@_date: 2016-02-05 11:55:39
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
Don't use --expert
... Don't use --expert ;P
Stick to the defaults
keyserver ...
And that's it.
Really. Having a look at my own gpg.conf, there are two more things:
default-key ...
And those should not be needed for normal users, who only have a single key (I
have a bunch of test keys to play with), and only use GnuPG 2.1 (I use 1.x to
help people here on the list who use it).
Like I said in the mail I just sent: in my opinion, in a very broad sense, the
FAQ should be aimed at people sticking to the defaults, not the people who
tinker. GnuPG is already more than complicated enough without drowning people in
unnecessary detail. The defaults are reasonable; you should stick to them until
you have very good reason not to. Otherwise it is very easy to shoot yourself in
the foot. Or get lost and give up.
So I don't think those things you mention should be in the FAQ. In fact, "things
to put in gpg.conf" would seem directly opposed to:
(from the FAQ)

@_date: 2016-02-05 12:07:32
@_author: Peter Lebbing 
@_subject: GNU Privacy Handbook 
I agree. I was composing a mail on the subject when I started... eh... composing
a different mail on a different subject ;).

@_date: 2016-02-05 12:23:05
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
I just notice section 8.19. It says to verify a download:
As became clear in this[1] discussion, you should always specify the file to be
verified, as in "gpg foo.zip.asc foo.zip".
Section 8.20 supposes GnuPG <2.1, by the way, since it plays around with the
fact that --export uses the same format as a keyring. I think it should be
rephrased to use --import instead of using the output of --export as a keyring.
Furthermore, I think a reasonably often asked question is "Why can't I provide
the password in a pipe to GnuPG anymore?". Old 1.4 allowed this, but 2.0 is
incapable of it and 2.1 needs a loopback pinentry. But of course, the answer
could instead say that it is very unlikely that it is more secure than just not
using a passphrase.
I don't have time right now to actually supply the text to use for these things,
[1]

@_date: 2016-02-05 12:32:24
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
Okay, I take that back, since section 8.7 clearly shows options you could put in
gpg.conf :).
Regarding that section, I think
should be rephrased to use fingerprints, not long keyid's.

@_date: 2016-02-05 13:22:51
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
If somebody can create a long-keyID-collision, and you download your own key by
that key ID and also import the other one, they might be able to be the one that
gets "encrypted-to", I think? Another way to get on your keyring is when someone
attaches "their" public key to an e-mail and you click import.
If I just specify a key ID as encrypt-to in my gpg.conf, I don't get a warning
like "It is NOT certain that the key belongs to the person", it just encrypts to
a key with unknown validity without giving so much as a peep! So the usual
"collisions are not a problem because the key is invalid" doesn't apply. You're
stuck with the much weaker "your own key will probably be first in the keyring,
so it will use that". I don't feel comfortable with such a weak assurance.

@_date: 2016-02-05 13:40:40
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
No, I don't think so. But I was under the impression that for a while now,
people were generally advised not to rely on the uniqueness of long key ID's.
And since this seems to be all you rely on with encrypt-to, key validity not
being a factor, it seems unwise to me. But it's your FAQ (and your gpg.conf
apparently ;). And since I just stipulated the implications as far as I see
them, I accept your judgement of the situation.

@_date: 2016-02-05 19:36:17
@_author: Peter Lebbing 
@_subject: GnuPG 2.1 how to delete card based secret key ? 
Do you want the key off your keyring or off your smartcard?

@_date: 2016-02-09 11:24:06
@_author: Peter Lebbing 
@_subject: Usage text 
While the primary key is certainly in a subordinate position to the
certificate, I don't think it's common to refer to it as a subkey of the
certificate? In my mind, you have the primary key, and zero or more
subkeys. So I suggest the following:
I also emphasized the first letters of the words. People who like
certain puzzles will immediately notice the correspondence of the first
letters of your itemization to the letters of the capabilities, but
others might need to hunt for it before they get it. Typographically, it
did suffer. Feel free to remove it, but you could also use boldface.
By the way, I think the abbreviations GnuPG uses are in favour of my
interpretation of the word subkey:
pub - public key
sub - subkey
sec - secret key
ssb - secret subkey
Then again, I'm interpreting these terms coming from my view of the
terminology, so it's a bit of a circular reasoning :).

@_date: 2016-02-09 11:38:39
@_author: Peter Lebbing 
@_subject: GnuPG 2.1 how to delete card based secret key ? 
It doesn't work for me either. Your error message is a lot more
descriptive, though. I just get:
I can delete the public key; then the secret key is not listed anymore
either. When I re-import my public key, it will instantly remember the
card as well, so it was there all along :). I do need to set my trust
again (not a surprise).
But anyway... it's usually harmless, since all it is, is a note that if
you need the secret key, it is located on card X. It will then prompt
you to insert card X. There is nothing secret on the disk of the
computer (unless you consider the fact you use a card and its serial
number as a secret).
So I'd suggest you let it be if you don't consider your card and serial
number a secret.

@_date: 2016-02-09 11:42:46
@_author: Peter Lebbing 
@_subject: OpenPGP cards and on-device subkeys 
You should just be able to use your smartcard to do all operations with
the master key on it, including generating and revoking subkeys. There
is one little snag: with GnuPG before 2.1, it's rather difficult to
spread one certificate over multiple smartcards. Once it sees one of the
two, it will mark the other keys as "not available" and never update it
when it subsequently sees the other smartcard. You need OpenPGP packet
surgery to transplant the correct data. GnuPG 2.1 does the right thing,
I believe.

@_date: 2016-02-10 16:27:52
@_author: Peter Lebbing 
@_subject: By Tom Simonite. Why [snip] 
A friendly reminder: On this list, it's encouraged to post at the least
an excerpt of the text, not just a link and nothing more.
Also, I think I'm not the only one who would rather see a subject line
contain maybe 60 characters at a maximum...

@_date: 2016-02-11 12:29:29
@_author: Peter Lebbing 
@_subject: GPGrelay does not recognize Gpg-2.1 keys; Gpg4win-3beta... 
First of all... it was established in this thread that you could not
share the key store between GnuPG 2.1 and 1.4. Why is that the case? I
can happily do that here on Linux. The only gotcha is that you don't
profit from the speed gains GnuPG 2.1 gets from the new format of the
key store. Oh, and there might be some issues with elliptic curve keys
as 1.4 can't work with those, but I think it just means GnuPG 1.4 will
complain a bit and not be able to use the elliptic curve keys, but
otherwise keep working. Perhaps I missed a message in the thread, or I'm
missing some knowledge about Windows. If you were to delete your GnuPG
homedir to start fresh (backups though!), then import keys in 1.4 before
you ever start 2.1, wouldn't 2.1 simply pick up the old key store format
from 1.4 and work with that? That would seem the best option here if
that were possible...
A word of warning: the best way to phrase the first command is as:
gpg2\gpg2.exe --output C:\temp\exported.keys --export
Options come before commands. After --export, you specify which keys to
export. Some common reorderings are recognised and "fixed for you", but
it might bite you with a different command. So: options come before
Furthermore, pipes do generally work on Windows. The last time I did
anything at a command prompt in Windows is seriously long ago, though.
Wouldn't this work?
gpg2\gpg2.exe --export | gpg14\gpg.exe --import
Yes, --import is to add keys to your keyring or update existing keys
with new information.
Hmmmm. I can't think of a good way. You could choose to delete keys from
both programs yourself; everytime you delete a key in GnuPG 2.1, also
delete it in GnuPG 1.4.
Deleting the keys beforehand is theoretically an option, but you would
have to do an --export-trustdb before (I'd take the gpg2 for that) and
an --import-trustdb afterwards, because you lose all trust settings.
However, I don't even know of any other way to delete all keys than the
rather rude way of deleting pubring.gpg. I can't think of a way to
specify a user ID that would match all keys in the command --delete-keys.
Deleting pubring.gpg seems to preserve private keys; if I import all
public keys including the ones I have the private key for, the private
key also "comes back" as it survived in secring.gpg.
Also, it's a process that takes a large amount of time as it has to
reprocess everything, including recomputing the key validity.
Maybe someone else has a bright idea.
Meanwhile, here is a not recommended way to do it... If your GnuPG home
directory is where I would expect it. I have no experience whatsoever
with GnuPG on Windows, so I'm just guessing based on what a quick
internet search gives me. You might need to adjust it.
Also, it is potentially dangerous. I'm very reluctant to suggest to
someone, without any knowledge about their specific situation, to run a
"del" command like that. Please, make backups, make your own judgement,
don't type commands unless you understand exactly what it does. It
might, for instance, delete your keys from a different installation of
GnuPG, such as gpg2.exe.
gpg2\gpg2.exe --export-ownertrust >C:\temp\exported.trust
gpg2\gpg2.exe --output C:\temp\exported.keys --export
del %APPDATA%\GNU\GnuPG\pubring.gpg
gpg14\gpg.exe --import C:\temp\exported.keys
gpg14\gpg.exe --import-ownertrust C:\temp\exported.trust
gpg14\gpg.exe --check-trustdb
Oh, you could do:
echo %APPDATA%
to see where that actually points to.
I'm not sure why --export-ownertrust doesn't allow you to specify a file
to export to, but --import-ownertrust does allow you to specify a file
to import from. But it means you need the redirect I used for exporting.

@_date: 2016-02-12 11:41:04
@_author: Peter Lebbing 
@_subject: GPGrelay does not recognize Gpg-2.1 keys; Gpg4win-3beta... 
Hehe :). Okay, I'll humour you :).
I'd probably extract all known keys from both installations, and
propagate deletions. You also still need to transfer keys known to both
installations, since there might be updates to the keys. Additionally,
all the "del..." commands in --edit-key, as well as things like "clean"
and stuff, become pretty impossible without doing it in both
installations before you sync.
gpg2 --fingerprint --with-colons -k | grep ^fpr | cut -d: -f 10
This gives a list of the fingerprints of all public keys known to gpg2.
However, it is using standard Unix tools which might not be available
(by default?) on Windows. Similarly, I'd continue to write a Bash script
that extracts the common set and the differences, and applies any
deletions on either side in addition to transferring the common set both
ways to get any new information.
Obviously, you can't tell the difference between a previously common key
that got deleted on one side and a key that got added on the other side.
So you need to keep the list of fingerprints from the previous sync to
tell the difference. You might even get update conflicts; I can't think
of a way right away though.
For the trust database, it's easy to imagine a conflict. If I set a
different trust level on either side, which one prevails? I do have to
say this is a perfect reason to alert the operator. You completely trust
someone when you're using GnuPG 2, but only marginally using 1.4? Make
up your mind! :)

@_date: 2016-02-14 12:58:03
@_author: Peter Lebbing 
@_subject: Heuristics of gpg's output 
Or, alternatively:
$ sha256sum -c SHA256SUMS
This will check each of the lines in SHA256SUMS against your actual
files. In this case, it will warn about a lot of missing files (for the
files you didn't download) and one line where it says the downloaded
file is OK.

@_date: 2016-02-19 14:26:12
@_author: Peter Lebbing 
@_subject: A problem in the web of trust model or a gnupg bug? 
I can't reproduce this. A revocation correctly invalidates any
certifications *both* before or after the moment of revocation. After
all, the time can be faked.[1]
I tested with no "revocation reason" specified, by the way. But I don't
think GnuPG uses the revocation reason for anything, although I'm not
100% sure.
Could you show some of the output you get, possibly redacted for privacy?
As a very simple explanation, are you overlooking a different
certification on the key that is still valid and trusted?
I used GnuPG 2.1.11.
[1] Other than that, if you revoke a key using the revocation
certificate you made when the key was created, it will show a revocation
date equal to the creation date even though you only uploaded the
certificate years later, for example. Even if only certifications made
after revocation would be invalidated, that situation would still
invalidate all revocations, since they're all later than the key
creation. This is not very relevant to your problem, though, I just
thought it was an interesting observation.

@_date: 2016-02-19 15:27:13
@_author: Peter Lebbing 
@_subject: A problem in the web of trust model or a gnupg bug? 
I don't see why this unexpectedly keeps user three fully valid... it
looks like you're right and three should be invalid. Do you have any
funny stuff in gpg.conf? For which of these keys do you have the private
key installed in this installation of GnuPG? I don't think the latter
should matter, but it could be useful to know...

@_date: 2016-02-19 20:12:48
@_author: Peter Lebbing 
@_subject: A problem in the web of trust model or a gnupg bug? 
Huh. That's odd. I've never observed GnuPG neglecting to update it
automatically when something might have changed.
But I'm glad you figured it out, it was pretty weird.

@_date: 2016-02-20 12:28:44
@_author: Peter Lebbing 
@_subject: When to use GPG flags 
For programmatic use of GnuPG, you should really be using a library,
preferably GPGME. That is the supported way of using GnuPG from another
program. Calling the gpg command line program directly is for use by
humans on a command line.

@_date: 2016-02-20 12:47:47
@_author: Peter Lebbing 
@_subject: Using gpg-agent for git credentials? 
You can use the agent for inquiry and /caching/ of your passphrases, but
not for /storage/. The difference is in the lifetime: once gpg-agent
exits, any cached passphrases are forgotten. It can't be used as a
general passphrase store, unfortunately.
As for something completely different, you could use an encrypted
partition to store the credentials... It's just a thought.
[1]

@_date: 2016-02-20 18:48:21
@_author: Peter Lebbing 
@_subject: When to use GPG flags 
Fine by me.
The difference is that --verify never produces any data output, whereas
you use --decrypt to get at the contents of the message. So for
instance, the following message is unencrypted but signed. But you
cannot discover what the message is with --verify, since it will just
tell you it's a good signature. You use --decrypt to actually look at
the contents.
This one isn't even signed; it's just data.
So --decrypt is: gimme the contents. --verify is: check the validity,
but don't ever produce any data.
But since you ultimately need to choose a reasonably short name for the
option, they're not called --decrypt-verify-or-decode and --verify-only ;).

@_date: 2016-02-21 14:37:11
@_author: Peter Lebbing 
@_subject: (OT) What is an appropriate link for =?UTF-8?Q?IceDove=3F=2E?= 
Broadly, I believe it's more that Debian wishes to be able to include patches they wrote in their distribution of Thunderbird, and Mozilla wishes to vet and approve each individual patch before allowing Debian to use the trademarked name. Because Debian does not want to run each of their patches by Mozilla for approval, they decided not to use the trademarked name.
I'm pretty sure there are trademarked names in Debian, and that Debian allows this.

@_date: 2016-02-23 11:11:16
@_author: Peter Lebbing 
@_subject: Email Self-Defense 
Note that it says "encrypted with a key that can't be trusted", not "signed with
a key that can't be trusted".

@_date: 2016-02-23 13:48:03
@_author: Peter Lebbing 
@_subject: Failure of comparison of valid pub key's .asc files 
This is also why the exported .asc files are different: the version on the
keyserver has an additional signature that the one on thr web page did not have.
That's it, that's all there is to it!
Absolutely. Certifications by other people are also included. They can change
order, they can be on one and not on the other. And there are more reasons why
the binary blob can be different, such as included information that is no longer
relevant but also doesn't hurt (old, superseded self-sigs, f.e.).
For authenticity, you should be looking purely at the primary fingerprint and
the UID's. If those two combined match your expectation (you expect John to have
a key with fingerprint X), you're good.

@_date: 2016-02-23 13:55:15
@_author: Peter Lebbing 
@_subject: More information on new 'external password managers' feature? 
Can't help you with that, sorry.
I believe the initial target audience was Gnome Keyring and possibly the MacGPG
project, but primarily to solve the issues with Gnome Keyring. But it is a
general feature.
The intended use case, AFAIK, is to have the external password manager store the
password for your OpenPGP key(s). That way, it can unlock your key when you log
in (and provide your login password). Without it, you would have to enter a
password twice each session: once to log in, once to unlock your OpenPGP key.
That's all I know. HTH,

@_date: 2016-02-23 14:01:50
@_author: Peter Lebbing 
@_subject: Can the NSA Crack GnuPG 
We've recently established that Einstein was wrong and that information can
travel faster than light. They managed to use entangled electrons to observe at
a distance that the other electron got altered, without any time passing. It
doesn't affect your exposition in the least, I just thought it was cool :).
Nice exposition, by the way. I didn't run the numbers, though :).
My 2 cents,

@_date: 2016-02-23 14:44:24
@_author: Peter Lebbing 
@_subject: Can the NSA Crack GnuPG 
I went by recollection of a news item, which even if I could find it was
probably in Dutch. But I think this is what I meant:

@_date: 2016-02-23 15:35:05
@_author: Peter Lebbing 
@_subject: (OT) Can the NSA Crack GnuPG 
Okay. For a moment I thought I heard your train of thought again, but it
turned out my cat had managed to throw over some pretty heavy stuff.
Luckily it didn't fall on him. If it had been your train of thought, we
probably would have to re-examine the speed of sound, though.
It all sounds very interesting, though. I'll try to get a faint grasp of
the additional weirdness, but I'm faced by not being taught the basic
weirdness either (= quantum physics).
I'm not even in that stage yet where you know so little of a topic that
you think you know a lot of it ;).

@_date: 2016-02-23 17:40:34
@_author: Peter Lebbing 
@_subject: Failure of comparison of valid pub key's .asc files 
You can use --list-sig to show the unverified signatures as well. Note they
could be bogus, you can't tell until you import the key that made the signature.
--check-sig checks signatures as its name implies, and you can't check a
signature made by a key you don't have.
Like this:
Without the key, it's just a short string of hex digits. You need to fetch the
key before there is anything more to go on (a user ID). Luckily, you can do that:
$ gpg2 --recv-keys 6DA5F2AC 8FCF9CEC
And several more ;)
In the webinterface you mean?
I should mention that the webinterface does no verification of anything, it
naively "believes" anything it is told. That means that nefarious people can
include bogus data that will only turn out to be bogus once you feed the key to
GnuPG, which does verify what it is fed.
Did you mock up this output yourself or is this something you actually got? I
wouldn't understand how the latter happened. That % is when the key is on your
keyring, but the signature could not be verified due to some error. So you
already have the Moonchild key, as can also be inferred from the fact that it
knows that UID. And that signature checks out fine for me.
I haven't seen anything that is both not implemented yet and physically
possible, unless I misunderstand. It is impossible to show data about a key you
don't have on your keyring. The data is simply not there.

@_date: 2016-02-24 20:53:03
@_author: Peter Lebbing 
@_subject: Tor and keyservers (was: Key selection order) 
I haven't looked at the links yet, but what is your purpose? Do you want to detect rogue keyservers in the keyserver network, or perhaps attacks on keyservers?
There is no need to trust keyservers in the Web of Trust, or even in TOFU (as I assume in the latter you got a signed message from the other to start things off, and the wrong key would not verify the message). Still, it could be interesting to see if the keyserver network is somehow messed with, I suppose.

@_date: 2016-02-24 21:55:58
@_author: Peter Lebbing 
@_subject: Tor and keyservers 
Thanks for the explanation. Good luck! Post-Snowden, you sure see a lot of
people trying to reduce the burden of key verification... But some ideas are
better thought out than others. A lot of misconceptions out there, it seems.
Personally, I stay far from actual biometric authentication. I can't revoke my
eyes... and biometric scanners that aren't easily fooled are insanely expensive.
Watch out with that logical implication there: some insanely expensive biometric
scanners can be easily fooled :).
It's interesting you're using "biometric" as a qualifier implying something
"good". I wouldn't agree.

@_date: 2016-02-24 22:13:39
@_author: Peter Lebbing 
@_subject: Tor and keyservers 
Ah! Then it makes sense. I hadn't picked up on that.

@_date: 2016-02-25 11:26:25
@_author: Peter Lebbing 
@_subject: Possible values for --compress-level and --bzip2-compress-level 
The canonical way to use the BZIP2 algorithm on Linux is through the
bzip2 program. Its man page lists the following:
The other two require you to look a bit further than just lowercasing
:), but I think they both use the DEFLATE compression method. On Linux,
you will often use gzip to create archives with DEFLATE. Its man page says:
This does however raise a question:
The defaults are apparently different?

@_date: 2016-02-25 11:43:01
@_author: Peter Lebbing 
@_subject: Problem compiling 2.0.29 
Where did you install the library? Is that path in /etc/ld.so.conf?
Perhaps you need to run
# ldconfig
to update the library cache.
I must admit I haven't ever compiled GnuPG myself other than with
dpkg-buildpackage, though :).

@_date: 2016-02-25 14:38:10
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
(If this feels like droning on to you, just stop reading and go do something fun!)
Thanks for the link! But my approach to it wasn't really from "is it a problem in practice" but more "should this be the advice we give" and "what's wrong with just using the fingerprint and be done with it forever". We always tell users to use the fingerprint if they need to be sure of authenticity. Or if I'm mistaken about that, I think we should.
My 2 cents,

@_date: 2016-02-25 15:54:03
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
I agree. Note that the discussed case, encrypt-to, silently encrypts to unvalidated keys that happen to be on a keyring. Just pick any key on your keyring that isn't valid, say it's mine, AC46EFE6DE500B3E, and put this in your gpg.conf (watch out what you're doing here, though!):
encrypt-to AC46EFE6DE500B3E
Now encrypt a test message to anyone, something like:
echo "I'm talking to myself" | gpg2 -o test.gpg -r E3EDFAE3 -e
Note how happy GnuPG is to do all this, and then do
gpg2 --list-only --list-packets test.gpg
Note how the unvalidated key is silently encrypted to without a peep from GnuPG.

@_date: 2016-02-25 15:56:32
@_author: Peter Lebbing 
@_subject: Single GPG key and multiple yubikeys 
gpg --delete-secret-keys XXX
But don't do this when your primary key is on-disk, only do this when all your secret key material is stubs.
Note that it is very impractical to regularly use two smartcards on the same computer because of all this. You should probably stick to using a single smartcard on any single computer.

@_date: 2016-02-25 19:20:28
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
I never, ever, once, argued the opposite. I sure hope you're not implying I am,
or that Kristian is. If you recall, I talked about public keys being attached to
e-mail messages, adding as a mitigating factor that your own key would probably
be earlier on the keyring. By now, we can add the mitigating factor that GnuPG
will bork on the key import. Plus, as was already established, the rather major
fact that as far as we know, nobody has pulled off a second-preimage attack
against a long keyID.
But take things as seriously as you see fit. As I indicated, this is more of the
variety of "what is prudence in user education", not "oh my God they are
H4xx0rzing our keez".

@_date: 2016-02-25 20:30:02
@_author: Peter Lebbing 
@_subject: FAQ maintenance 
Oh! I must have mixed up some things.
Thanks for the rectification!
I think perhaps I was thinking of entering a smartcard PIN, for which you do
need a loopback pinentry (right??), and which was impossible to do on 2.0
(right??). Oh man, let's hope I don't start to question everything now. I might
end up like Kyle in The Toothfairy's Tats episode of South Park...

@_date: 2016-02-26 10:55:46
@_author: Peter Lebbing 
@_subject: cipher used when both --encrypt and --symmetric is specified 
Those preferences are not what is used when encrypting to your own key.
To see those do:
$ gpg2 --edit-key {KEYID}
To change them do:
Note that this refers to all types of preferences, not just ciphers.
To set a default preference list for setpref, include in your gpg.conf:
default-preference-list I'd suggest a bit of browsing through the man page with a search term of
"preference" :). Note that these key preferences are part of your public
key, and if you want others to respect them as well, they need to
refresh your public key with the new preferences if you change them.
It would be helpful to know what your key preferences are, since it
might just be the most preferred algorithm from the intersection of
personal preferences and key preferences.

@_date: 2016-02-26 16:02:14
@_author: Peter Lebbing 
@_subject: gnupg-pkcs11 status & future 
Why is this the case? I must admit I'm fairly comfortable not rotating
my keys (which are on OpenPGP smartcards). But I can think of lines of
reasoning where it makes sense to rotate, but still keep the old
decryption key available. Think: "There's a non-zero chance that someone
got my private key material, but at least they can only decrypt stuff
encrypted in 2011, all other years use a different key". Note in this
scenario it is nice if I can still easily access my 2011 material as well.
I'm not saying this is a solid line of reasoning. I'm just curious why
limiting access to the decryption key is the only thing that makes sense.

@_date: 2016-02-27 14:41:46
@_author: Peter Lebbing 
@_subject: Question about getting started with PGP and smart cards 
Though I still need to experience it myself, I think I would recommend GnuK[1]
by NIIBE.
Otherwise, a standard OpenPGP card[2], which you can also get through an FSF
As a reader, in a large form-factor I like the SCM SPR532, which seems to have
been superseded by the SPR332[3][4]? In a small form-factor, I bought a
Chipdrive MyKey for something like ? 15, because it includes an SCM cardreader
that identifies itself as:
$ lsusb -s 1:6
Bus 001 Device 006: ID 04e6:5116 SCM Microsystems, Inc. SCR331-LC1 / SCR3310
SmartCard Reader
The disadvantage of this reader is that it is totally not dust tight, despite
what the manufacturer may claim. If kept in a trouser pocket, it'll accumulate
dust inside the USB connector quickly. I remedied this by buying a new shell,
which turned out to be ever so slightly too small in one direction. This I fixed
by filing off a part of the PCB of the reader, since I could determine I would
not damage any traces by doing so. Long story short, if you want to keep it in
your trouser pocket and have an easy solution, look further, don't buy the MyKey.
[1] [2]

@_date: 2016-02-27 18:14:30
@_author: Peter Lebbing 
@_subject: Question about getting started with PGP and smart cards 
I should note that pcscd is not needed for the readers I mentioned in my reply,
since they are well supported through the builtin driver of scdaemon (and GnuPG
In fact, installing pcscd will make it more difficult to use. I suggest to only
use pcscd for readers that are not natively supported by GnuPG, unless you have
specific needs (usually when you want to use smartcards for more things than GnuPG).
Heck, yeah.

@_date: 2016-02-28 14:12:06
@_author: Peter Lebbing 
@_subject: gnupg-pkcs11 status & future 
Ah, that makes sense, thanks for the clarification!

@_date: 2016-02-29 12:12:53
@_author: Peter Lebbing 
@_subject: cipher used when both --encrypt and --symmetric is specified 
For me, GnuPG 1.4 behaves as you indicate, which is counterintuitive,
especially given the text in the man page. But GnuPG 2.1 correctly gives
me the preferred algo from the intersection of
--personal-cipher-preferences and key prefs. It's a bit difficult for me
to test GnuPG 2.0 at the moment. I should do something about that.
I faintly recall some discussion about this, but that's it, I don't
remember more than that. You could try a search on this mailing list.

@_date: 2016-01-11 12:19:14
@_author: Peter Lebbing 
@_subject: basic identity mgmt 
You have to sign it; that's how it works :).
Yes. "The info" is contained in a UID, and you separately sign any UID's
you've verified. A signature done with lsign will not be exported to
others (unless you force GnuPG to do so), so you use it if you want the
fact that you verified it to only be known to yourself. A regular "sign"
command marks it exportable.
Yes, exactly. I can see you've read documentation! People always get
confused by ownertrust and validity; you've got it right in one go.
Since "trust" is such a broad concept, I always try to refer to it as
"ownertrust", to narrow it down to the specifics.
It makes no difference with regard to validity calculations. It's just
for your own information. The former would imply you still need to
assess the trust, where the latter means you assessed it and still don't
know, or won't say. There's a command to set the trust for all keys for
which it hasn't been set yet; this command would skip "undefined" but
ask you about "unknown".
My guess is that it's because it's quite an intensive calculation, and
you don't want to have that slowing down your interaction with the
program in this run.
Any change of trust or validity requires re-calculating all validity
values for keys, since a newly valid, trusted key may in turn make other
keys valid, which in turn... Obviously, it would be possible to
recalculate only the affected part, but that's not how it's implemented:
it will recalculate everything.
It would technically be possible. But I don't think it would be high on
a TODO list :).

@_date: 2016-01-11 21:42:21
@_author: Peter Lebbing 
@_subject: basic identity mgmt 
Signing other people's keys is called certifying, and certification is a
capability only the primary key has. The "Sign" capability indicates it can
create data signatures: files, e-mails, that kind of thing.

@_date: 2016-01-11 21:46:54
@_author: Peter Lebbing 
@_subject: basic identity mgmt 
You can only do an uncommon all-or-nothing change: with --trust-model direct,
you can set key validity directly, just like ownertrust in most other models,
but this means the Web of Trust and certification signatures are completely
unused, AFAIK. I'm not recommending either for or against it, I'm just throwing
it out there as an available option.
This apart from the already mentioned tofu+pgp.

@_date: 2016-01-12 19:37:52
@_author: Peter Lebbing 
@_subject: GPG-Agent not recognising SSH keys 
It's not an ignorant question, and even if it were, that wouldn't be a
problem :).
Which version of GnuPG are you using, by the way?
Did it go something like this?
I'm "quoting" the terminal interaction and writing comments in between.
You can see I'm using GnuPG 2.1, but I think it should go the same for
2.0. There /is/ a difference with regard to the agent configuration,
though, which is why I ask about your version above.
This is a testkey. It doesn't have an authentication capable subkey yet,
so let's add one (for that, we need --expert, hence my use of it).
I just noticed this possibility in a recent post by Werner to this
list... I don't know if it's a new 2.1 feature, but instead of first
toggling S and E, you can prepend an = to your A and presto, the key is
for A only.
So now we need the keygrip for this new authentication subkey:
The keygrip /follows/ the line with the short key ID; we need the
keygrip for the key with ID 38EF7410, so it's the very last line. The
other keygrips are for keys that don't have the authentication
capability and are hence useless to add to sshcontrol.
I used a screen editor, but let's pretend I used the command line... In
fact, all further lines have been edited to hide my real SSH keys. It's
probably overkill, but let's be cautious with what we broadcast on the
Now let's see if it's known:
If you did it just like this, there's an issue in your setup, as it
works for me. If you didn't do it like this, ... you probably should ;P.

@_date: 2016-01-14 15:58:15
@_author: Peter Lebbing 
@_subject: GPG-Agent not recognising SSH keys 
Hi Jacques,
That's hard to spot... "Is this jumble of characters the same as the one I just saw?"
Is the server and the user account configured to accept authorized keys? Are the permissions on ~/.ssh acceptable?
Do you have administrative access to a server in question? The configuration for sshd can configure different authentication possibilities to be offered, even per-user (or per-IP range).
But perhaps more likely is that ~/.ssh doesn't have the correct permissions. If you have access to sshd's log: it will likely complain verbally in the log about permission errors, even though you as a client don't see it.
 From the sshd manpage:
A good permission for ~/.ssh is 700. authorized_keys can be 755 or less[1]. From the way the manpage is phrased, one would think one's home directory can't be 775, even though that actually might make sense in some setups. But if you don't want to be able to appoint people with write permission, keep it on 755 or less. I think 755 is quite common; 750, 710 and 700 make sense as well.
[1] Less permissions, not numerically less. Don't go saying "677 is less"! :)

@_date: 2016-01-14 19:59:50
@_author: Peter Lebbing 
@_subject: Key selection order 
Or send them an e-mail saying "I've got something to say I don't want in
cleartext for passive attackers to read; could you send me your key ID?"
When you know the channel is being modified, you need an out-of-band something
to bootstrap. I think this is fundamental, independent of infrastructure. But
I'm too tired and hungry to think about it much :). Should eat...
By the way, "under attack" is a too generic term to usefully discuss stuff.

@_date: 2016-01-14 22:26:19
@_author: Peter Lebbing 
@_subject: Key selection order 
I disagree. It's a "good enough" solution for many circumstances. And we know by now how well the WoT works in many circumstances. Both have their uses. But this has been discussed on the list multiple times. It's fine if you disagree; but please don't phrase your words as fact when it's such a contended issue.
Isn't "MITM'ing all along" identity persistence then? It's quite unfortunate it's the /wrong/ identity, but it's identity persistence in my book, so I think you're using the terminology wrongly.

@_date: 2016-01-15 13:08:49
@_author: Peter Lebbing 
@_subject: Key selection order 
Ah, we are ascribing different attributes to an "identity".
I think you mean an identity belongs to a specific person, an individual. If you
MITM, there are two people, so two identities.
I describe an "identity" as "this person who's been giving me good advice on
topic X for several months", for example.
Note that I cannot differentiate between someone who thought up the advice from
someone who is just forwarding someone else's advice.
If there's this individual A who has been giving me great advice, but all their
mails were MITM'ed such that individual B put their signature under it, B could
at any moment abuse this trust that A built and give me horrible advice that
results in something that is useful for B.
But the same could happen with A! I know the guy/girl only from their e-mails.
For all I know, A is biding their time to eventually screw me over. And they
could be asking someone else and only writing down their advice.

@_date: 2016-01-16 00:08:51
@_author: Peter Lebbing 
@_subject: Yubikey, GnuPG 2.1 Modern, and SSH on OS X 
No, but I'm fairly sure Werner did not realise you were using a smartcard when
he wrote that. Obviously, I can't look into the man's mind, but that's my guess.
For regular, on-disk keys, it is necessary to add the keygrip to sshcontrol. For
smartcards, it's automatically added when the smartcard is inserted. I guess it
fits with automatically added secret key stubs when the smartcard is inserted
(to use a smartcard on a fresh PC, import your own public key, insert your
smartcard, and you're done).

@_date: 2016-01-17 11:17:58
@_author: Peter Lebbing 
@_subject: basic identity mgmt 
I'm sorry, this feels forced.
I suppose the payment is meant to be an outlandish request. I've heard
about banks using OpenPGP, I don't know what is usually in that
correspondence. It might be just bank statements.
So let's suppose it is an outlandish request. Just because someone would
not agree to an outlandish request based on a valid signature, this
doesn't mean there aren't reasonable requests that are horribly bad.
Let's take two political dissidents in a totalitarian regime. They
sometimes wish to meet up in real life, so one sends the other a signed,
encrypted request to "meet at 13:00 at X", and they talk.
Now a government agency sends one an encrypted message to "meet at 15:00
at Y" (you might notice I'm not a morning person). Then they wait for
him or her to pick them up and throw them in jail.
In this scenario, I'd say the signature key is damn important. It's on
par with the encryption key; if they had that, they could wait for them
at 13:00 at X, which is just as bad. But the signature key is equally
important, because they can sign a message to meet at 15:00 at Y with that.
So I think it's incorrect to say signatures are unimportant because you
can't get people to follow insane instructions. You need to look at the
sane ones.

@_date: 2016-01-18 11:43:01
@_author: Peter Lebbing 
@_subject: basic identity mgmt 
Well, to me it sounded like you said "Signature subkeys aren't enough by
themselves, so they don't matter". Whereas they are a necessary part of
the puzzle.
The only good argument (IMO) I can think of is: ease of replacement. If
you have an online primary key, and your computer is hacked, you have to
revoke the whole key, since the attacker got the private material. This
means you need to meet up with at least some of your contacts again to
exchange fingerprints. You can't do a key transition, because so could
your attacker; if you know your private material is out there, you need
to discard the key wholly.
Now, if you have an offline main key, on an air-gapped system, that
makes it a lot more difficult to attack. When your online, Internet
connected system gets hacked, you have a big problem. All your encrypted
stuff the attacker can get is readable to them, and as long as you don't
know yet, they can issue your signatures. But when you discover it, you
can reinstall or throw out the hacked hardware, issue new subkeys and be
done with it. Since your primary key was still safe, your correspondents
know it's still you.
And luckily, your certification key is also the one you use least of
all. Issuing new subkeys and certifying other people's keys; the most
rare of occurences, I think.
But as I wrote, this is what I can think of. I'm inclined to think there
are other reasons why an offline primary key can give a significant
advantage over an online one. I just haven't thought of them.
Similarly, I'm not convinced there aren't good reasons why a smartcard
for SSH authentication is indeed an advantage over on-disk keys. So your
is going to far for me, but obviously you're free to be of a different
opinion :).

@_date: 2016-01-18 15:06:56
@_author: Peter Lebbing 
@_subject: Key selection order 
Since it's been debated over and over again on this mailing list, I have
nothing to add but: search the archives.
I find it funny that people always dredge up the same old discussions.
Hmmmm. Maybe not that funny, actually.
I suppose we'll see more of this specific one now since TOFU makes
people think of the discussion of signing all e-mails to mailing lists.

@_date: 2016-01-20 18:13:47
@_author: Peter Lebbing 
@_subject: How to export ASCII armored secret key without passphrase? 
Install GnuPG 1.4 alongside your 2.1.10 (they co-exist perfectly, but they store
keys separately).
It then should be something like this:
$ gpg2 --export-secret-keys | gpg --import
Give some temporary passphrase, passes key from 2.1.10 to 1.4.
$ gpg --edit-key gpg> passwd
Enter temporary passphrase to unlock, then give new, empty passphrase, confirm
empty passphrase.
gpg> save
Now 1.4 has a passphraseless copy of the key
$ gpg --armour -o key.asc --export-secret-keys
Now key.asc should hold a passphraseless copy of your keys. Remember that it is
also still passphraseless in the key storage of 1.4, in case that matters.
An alternative if you only want passphraseless subkeys would be:
$ gpg2 --export-secret-subkeys | gpg --import
$ gpg --armour -o key.asc --export-options export-reset-subkey-password
This merely holds a stub for the primary key: there is no secret material for
the primary key.
Is your GnuPG 2.1.10 binary invoked as "gpg", not as "gpg2"? Which OS is this
and where did you get GnuPG 2.1.10? This might be an issue if you want to
install GnuPG 1.4 alongside. I believe in Debian, the plan is to name the 2.1
binary gpg and the 1.4 binary gpg1, but that hasn't been done yet AFAIK.

@_date: 2016-01-21 11:13:47
@_author: Peter Lebbing 
@_subject: problem signing with a smart card 
That's fine for the signature key, although you could also extend its
expiration date. But rotating signature keys is generally no more work
than distributing the extended expiration date, so IMHO you might as
well generate a new one.
But do note well that if you generate a new encryption subkey, you can
no longer use the smartcard to decrypt stuff encrypted to the old
encryption subkey! I'd hate for you to just go ahead and discover you've
just thrown out your only copy of the encryption subkey...
By the way, in my opinion, you should always have a backup of your
encryption subkey if it's on a card, because cards can break.

@_date: 2016-01-21 13:07:11
@_author: Peter Lebbing 
@_subject: Rotating encryption keys 
I'd say that's a bad idea anyway. What if the smartcard breaks?
I don't understand. The log with session keys requires one smartcard
decryption to decrypt the whole log. The old private subkey requires one
smartcard decryption to decrypt the material, and then one "computer"
decryption per item encrypted to it, so it takes more time. Also, we're
talking about compromise, but instead of measuring the amount of time it
takes to crack something, we're talking about the amount of time it
takes to do regular crypto? That seems silly, is the only attacker in
your threat model using a Commodore 64 or other homecomputer from the
80's to access your encrypted material?
Effectively, the same goes for the encrypted old subkey, AFAICS. Both
hold a session key encrypted to the new subkey, and a symmetrically
encrypted payload that serves to decrypt all your old data. This
symmetric encryption is the same as used on the encrypted messages, so
if it's not trustworthy, you're in trouble anyway.
One way to broadly approximate the "there is no other copy of this key"
behaviour of a smartcard is:
Buy two smartcards, use both regularly so you quickly notice one dying.
Put the key on both, and also encrypt a copy of the key to itself, store
the encrypted copy somewhere.
When one smartcard breaks, buy a new one immediately. Take a secure
system, use the other smartcard to decrypt the key and install it on the
new smartcard.
For a secure system, you can install a fresh copy of an operating system
and thoroughly scrub it with itself afterwards. I think it's fun to
watch an OS overwrite itself! Firmware-based exploits remain a problem,
But I'm rapidly going into a wholly different topic.

@_date: 2016-01-21 13:09:53
@_author: Peter Lebbing 
@_subject: Rotating encryption keys (was: problem signing with a smart card) 
(oops, accidentally forgot copy to list, sorry for thread breaks)
Not that I'm aware of.
That's an interesting solution, I hadn't thought of that! But does it
have better security properties than simply encrypting an on-disk copy
of the old encryption subkey, encrypted to the new encryption subkey?
That is a whole lot simpler.
If somebody is able to decrypt the log of session keys, they can
effectively decrypt everything encrypted to the old subkey. This is
presuming the old encryption subkey is no longer used, so all data that
was ever encrypted to the old subkey is in one of the logs (multiple, if
the user has more than one computer).
And if they can decrypt the on-disk copy of the old subkey, they can
decrypt everything ever encrypted to the old subkey, and anything new
that will be encrypted to the old subkey. But the latter is not going to
Without any rigorous thought having yet gone into it, it seems they have
the same /effective/ properties.
On the issue of usability: right now, an encrypted copy of an old subkey
is a hassle to work with. But GnuPG could implement a feature that it
automatically decrypts it using the current subkey, and then uses the
old subkey to decrypt the data. In a generic form, this means that the
private key storage, which currently only supports symmetric encryption
in OpenPGP parlance, also supports public-key encryption.

@_date: 2016-01-21 14:39:25
@_author: Peter Lebbing 
@_subject: Rotating encryption keys 
I don't understand, what are the session keys encrypted with? I thought they
were encrypted to the original smartcard subkey, which is dead. With two
smartcards, you might be able to get by if you get all your correspondents to
use the new subkey before the second smartcard dies. It seems much less of a
problem, though, because you could ask them explicitly to re-encrypt if they
encrypt to the old key.
That construction would have it merits, but it seems complex. Complex things in
crypto are best treated carefully. Or dismissed. All functionality introduces
new places to make mistakes and kill security.
Ah! Okay. I'm still not sure what you mean by re-encrypting; it seems you could
just add the OpenPGP Public-Key Encrypted Session Key packet (along with an
identifier to find it again on use).
That depends on the cipher mode; appending might be cheap. But this is
academical; your construction seems better.
Also, this means you can append to the log as soon as you see a message, rather
then the first time the user decrypts it. That does, however, introduce the
problem that you can't verify the correctness of the packet, meaning you just
created a free append-only datastore for everyone to use since they can just
send you data disguised as a packet encrypted to your key :). So I think that's
not such a good idea after all.

@_date: 2016-01-21 14:42:03
@_author: Peter Lebbing 
@_subject: On-card key generation (was: Rotating encryption keys) 
I think I prefer off-card generation, with GnuPG's random number generator,
rather than some low-power, proprietary hardware random number generator on a

@_date: 2016-01-21 16:13:14
@_author: Peter Lebbing 
@_subject: problem signing with a smart card 
Wait... Maybe I'm not following correctly, but to me it sounds like:
- Antoine has an encryption key on his smartcard, but no backup.
- If it is no longer possible to use the smartcard to decrypt data with,
Antoine will lose access to all his previously encrypted data.
- So to remedy, you suggest he replaces the *only copy* he has of that
key with a new one which does have a backup.
In effect, removing the fear of losing the key in the future by getting
it over with and losing the key now. That's rather cynical.
Is there any data already encrypted to that key?!
If you do save accidentally, remove they newly generated subkey before
publishing and start over. If you haven't published it yet, there's no
need for revocation, just remove it with delkey.
That is very good advice in general.
Let's talk about two separate issues:
- If the smartcard breaks, you don't have access to the key anymore and
you need some alternative way of getting a new key authorized (the
normal way being to log in and add it to authorized_keys, but you can't
login with the old key anymore because the smartcard broke).
- If your authentication subkey is /compromised/, you can still log in
to the SSH server, install a new key by editing authorized_keys, and at
the same time remove the old key from there. However, so can your
attacker. Having a key backup doesn't help against compromise.

@_date: 2016-01-21 17:01:52
@_author: Peter Lebbing 
@_subject: Rotating encryption keys 
No, not in this thread. I hadn't mentioned it since I focussed on the
archival and rotation aspect, not access to a specific session key.
But yes, there are those options to use.

@_date: 2016-01-28 17:00:20
@_author: Peter Lebbing 
@_subject: BAD signatures for GnuPG Stable 
My guess is that sharp-eyed Damien Goutte-Gattat was correct and you were accidentally verifying your first, corrupt download instead of your new one the previous time.
I'm glad that you've finally got a hold of the correct file :).

@_date: 2016-01-30 13:36:45
@_author: Peter Lebbing 
@_subject: User experience of --hidden-recipient encryption 
AFAIK, yes.
I think separate copies for BCC recipients is a much better user
experience. Yes, you have to send more copies, but in many environments,
that isn't relevant at all. Only when you pay per kilobyte on a mobile
connection or when you have large attachments would this actually incur
any significant penalty on the sender side, I think.
Also, some mail servers actually identify and aggregate identical
e-mails or attachments of their users. I suppose if you're in a
corporate environment with a lot of internal mail with large encrypted
attachments and hidden recipients, you would need more storage on your
mail server because each hidden recipient gets a different mail. This is
just something that occured to me, it doesn't seem to outweigh the
advantages of separate copies.
I'd say yes and yes. Every recipient has their own Public Key Encrypted
Session Key (PKESK) packet with the (shared) session key encrypted to
their key. The only difference between a regular recipient and a hidden
one is that the regular ones identify which key the packet is meant for,
whereas each hidden recipient has a packet without that identification.
So the number of PKESK packets without identification is equal to the
number of hidden recipients. It leaks that there were and how many there
were, just like you can identify all non-hidden recipients by the
remaining PKESK packets.

@_date: 2016-01-31 14:03:08
@_author: Peter Lebbing 
@_subject: User experience of --hidden-recipient encryption 
There is a lot of literature on masking the length of packets with
random padding. It's not as straightforward as it seems. I think this
has anologues, and should not generally be considered a good idea. But
in general, the kind of statistics that go into this kind of research is
beyond me, at least without a serious refresher course. So I don't think
I'm qualified to actually say much about it, other than that I've heard
that it's not generally considered a good idea.
Is it possible to differentiate between MPI's[1] that are the result of
encryption proper and random noise?[2] I think you can get away with
simple random data. And if not, it seems more economical to just add a
few packets encrypted to one of the public keys used. Each time you
generate a PKESK, it will come out differently, even for the same public
key. The PKCS EME-PKCS1-v1_5 encoding makes use of random padding. So
you could simply include the same public key multiple times as hidden
recipients. I don't see any problem with that, but if there is, you
could include PKESK packets with intentionally malformed data such that
the decrypting application will reject it as "okay, must have used the
wrong key for this packet", even though it was actually the correct key.
I don't know if the architecture of GnuPG would allow for such a
procedure (intentional malformation), and more importantly, I don't
think this is something that should be done anyway. I was just going
with the hypothetical situation that we need dummy PKESK packets, and
observing that dummy public keys seems a bit heavyweight for that purpose.
My 2 rather hyptothetical cents,
[1] Multiple Precision Integers, the base encoding blocks of public key
cryptography for at least many common cryptosystems.
[2] Some situations are impossible: in RSA, a ciphertext greater than
the modulus is obviously impossible, or at least, an invalid encoding.
But! Since this is a hidden recipient, we don't know what the modulus is
since we don't know what the recipient key is. So we can't identify a
too great ciphertext MPI!

@_date: 2016-01-31 19:13:38
@_author: Peter Lebbing 
@_subject: GnuPG and the debian-archive-keyring 
I see this more often. This seems like a suboptimal way to communicate on an
English list.
Presuming you have the environment variable LANG=de_DE.UTF-8 set, you could
invoke gpg2 as follows:
$ LANG=C.UTF-8 gpg2 --edit-key 0x46925553
And it will communicate with you in the standard C locale, which will have
English language.
My l10n-foo is not up to snuff, so I might have details wrong. The funny thing
is, if you specify nonsense it will fall back to the C locale, AFAIK, so I might
actually be specifying nonsense, but I think I'm doing it right. It might be
that LANG=C.UTF-8 is a dumb way to say LANG=C .
If you want to override any more complex locale settings, you could do:
$ LC_ALL=C.UTF-8 gpg2 ...
or perhaps
$ LC_ALL=C gpg2 ...
But to get back to your remark:
I think you interpreted it wrong. Primary key 46925553 revoked an encryption
subkey ADD6B7E2. "Der folgende Schl?ssel"! And then comes ADD6B7E2.
I don't know if there is an option to look at revocation reasons... which seems
a rather big lack in my knowledge, how did this come about? Anyway, apart from
my frustrations, you can actually look at it:
So it was a simple mistake: they added an encryption subkey. To keep
debian-archive-keyring clean, they don't include it there, but keyservers are
like elephants and never forget.
I suppose you don't have those keys. Neither did I, and that was the message I
got. I thought that this would have been due to not having those keys. After
all, how could you validate a revocation without the key that made that
revocation signature? But even with those keys, and even with them made fully
valid by signatures on those keys, it will still say this:
I think this is simply the message GnuPG gives for keys with designated
revokers. I don't know why it is saying that, somebody else will need to answer
that question.
Note that it says "may be revoked", which seems a different verb inflection than
"k?nnte widerrufen worden sein", which to me indeed sounds like "may have been
revoked". Is this a translation error and should it have been "kann widerrufen
werden" or something like that? I have to admit my grasp of German is mostly
passive: I can read it slowly, I can follow it if people articulate well, but
actively producing German is mainly good for laughs.
I'd like to know that as well!

@_date: 2016-07-04 13:36:13
@_author: Peter Lebbing 
@_subject: gpg-agent and ~/.ssh/config IdentityFile 
Are you talking about restricting the keys available for authentication? Because just using IdentityFile does not do that, as can be concluded from this part of the man page:
Note that last sentence.
This documented behaviour is indeed working for me, as you can see in this example session:
Correct: my agent does not have the necessary key.
Correct: my agent does have the key for that host.
Adding the necessary config option you are asking about. Since it needs to go before any Host-specific config in there, I'm prepending it so it is the first line in the file.
Ah, I can log in, but not through the agent. It's the ssh program which is prompting me for the password. Since the agent doesn't have this key, only the ssh program knows about it. All as I would expect.
And again as expected. Per the documentation, the keys from the agent are also still available, even with added identities through So at least for me, it's functioning as I would expect it would after reading the documentation. I get the sense you're interested in a different configuration, one with IdentitiesOnly as well. Another possibility is that you are using a different OpenSSH version with different configuration options. I'm using:
My GnuPG is the Debian package 2.1.11-7.
So can you clarify what it is you want to accomplish?

@_date: 2016-07-06 11:37:14
@_author: Peter Lebbing 
@_subject: gpg-agent and ~/.ssh/config IdentityFile 
Well, I'm stubborn, and I'm still going to answer here :-).
Yes, that occured to me as well as a possibility to try. It turned out
to be the correct idea.
With default config, no restrictions:
I'm not entering any password on purpose, so it will try more keys. And
it offered all it had (since I configured the server to accept them all).
Now with:
It only offers my smartcard.
Change it to
It only offers the key test_id.

@_date: 2016-07-06 20:23:21
@_author: Peter Lebbing 
@_subject: Migrating key to smartcard 
What is the threat model that this procedure thwarts?
I don't think this is what is usually meant by an "offline primary key".
The idea is that you have a separate computer for your primary key, not
that you import it now and then. Unless I misinterpreted it myself.
What's the practical difference between only typing in the password for
the primary key when you need it and only storing it on local disk when
you need it? I think usually a compromised PC doesn't spontaneously
become uncompromised later on, it stays compromised. As soon as you use
the primary key, it is compromised as well. And as long as you don't
type your high quality passphrase, good luck to an attacker with just
your encrypted key, they shouldn't be able to use it.
I myself have my primary key on a different smart card than the subkeys.
With GnuPG versions before 2.1, this required some "packet surgery",
it's not really well supported. I think 2.1 will happily do this out of
the box.
By the way, I'm implying that you use a different passphrase for your
primary key than for your subkeys. Again, with 2.1, easy, before that,
packet surgery, I think.

@_date: 2016-07-06 20:33:48
@_author: Peter Lebbing 
@_subject: That blog post, factual error or not? 
Hi Damien,
I scanned through your blog post[1] before I wrote my reply. Now as I
was about to close the webpage, my eye caught this remark in a smaller
font at the bottom:
Is this actually the case though? Have you checked the source or did an
strace? Before v2.1, gpg-agent only cached passphrases for OpenPGP
usage, and the gpg/gpg2-binary did the actual decrypting and using of
the private key material. However, in v2.1, the agent itself is
responsible for using the private key. I haven't looked at the internal
design, perhaps only the passphrase is cached and the key is decrypted
from disk each time. But that seems like a rather indirect method to
solve it, why not cache the decrypted key instead of the passphrase?
In fact, when you export a key, it will always prompt for a passphrase,
because it needs it to construct an OpenPGP private key packet. Why
would it need to do that if it had the passphrase cached? I think it
keeps the key cached, and discards knowledge of the passphrase as no
longer relevant. Of course, there are more steps between passphrase and
key file, perhaps it only stores one of those intermediate steps, which
could explain it as well.
I think the behaviour you are seeing might be that the agent notices you
removed the key, and it will forget about it. But it deliberately
forgets, it's not that it actually needs the file you removed.
Of course, if you checked the source, you know more than I. I just found
the comment surprising, so I thought I'd ask.

@_date: 2016-07-06 21:51:39
@_author: Peter Lebbing 
@_subject: That blog post, factual error or not? 
Ah, okay, thanks for the extensive info! I wouldn't have expected that.
There's probably a good reason :-).

@_date: 2016-07-19 14:12:34
@_author: Peter Lebbing 
@_subject: Yubikey 4 gpg 2.1.14 forget passphrase for RSA key 
I think you're looking for this command:
gpg-connect-agent 'SCD RESET' /bye

@_date: 2016-07-21 11:26:03
@_author: Peter Lebbing 
@_subject: Yubikey + GNUPG 2.1.14 + GPG Agent Forwarding + Mutt 1.6.0 (gpgme 
encryption key
GnuPG doesn't expect that you forward the normal gpg-agent socket. For
forwarding to a remote machine, there is the gpg-agent.conf option
extra-socket [socket file]
which creates an extra socket for forwarding. You can then forward this
socket the way you do now.
One gpg-agent can serve multiple local DISPLAYs. It is exactly intended
behaviour that gpg-agent listens to changes of DISPLAY; it tries to
adapt to the client inquiring the agent.
I'm a bit surprised you still get a graphical pinentry on your original
display when you unset DISPLAY on the remote side. I would expect it to
try a textual pinentry on the TTY indicated by the remote side, which
probably should fail as well since it is the name of a TTY on the remote
side. I'm probably missing a detail somewhere. The keep-{display,tty}
sounds like it indeed should work correctly, but it is quite restrictive.
PS: Wow, what an extensive and detailed answer from NIIBE! Cool :-)

@_date: 2016-07-27 16:19:32
@_author: Peter Lebbing 
@_subject: Disambiguating GnuPG Modern, Stable, and Classic 
Disclaimer: this is how I understand it. I'm just a bystander looking
on, I might have misunderstood.
Precisely, I think this is where the questions arise from: a
misunderstanding about the context of the word stable here. That there
is a branch named Stable does not mean the branch Modern is "unstable"!
If I wanted to hang something heavy, I might ascertain that the wall is
stable before I do so. Even more so, a wall that is not stable is
generally a thing you'd like to avoid or fix. Even with nothing hanging
from it, it can give you an eery feeling to be very close to it. You'd
better not lean against it! But that is not the sense of the word here:
here that interpretation is out of context.
So here it means:
- Modern is where new stuff happens
- Stable will not undergo major changes such as architectural changes
- Classic is what it was long ago (albeit without known serious bugs)
Modern is perfectly suitable for serious use, and not a security risk or
anything like that. It just might undergo rather large changes, which
means it's less suitable to some deployments where such a thing would
cost a lot of effort to follow along with those changes.
My 2 cents,

@_date: 2016-06-01 21:19:18
@_author: Peter Lebbing 
@_subject: Automating the generation of master keys 
... from any user. That seems odd? Why's the 'a' part of the ps
invocation? Do you perhaps have the same affliction as I, in that when
my fingers type "ps " they invariably append "fax" and press Enter
before I have a chance to think whether I want my processes only? :-)
Anyway, apart from the in this case entirely useful BSD-style ps
behaviour of by default listing only processes from the owner, pgrep
seems to be the even more compact option here. The only thing is that
pgrep does not provide an option to say "the owner" other than naming
the user. Something like:
while pgrep -cfxu "$USER" "gpg --batch --command-fd=0 --edit-key
$GPG_KEY" >/dev/null; do sleep 0.5; done
seems a more logical choice. I couldn't test it though, as I couldn't
reproduce the gpg process outliving the invocation. By the time it gets
to the wait loop, it has already finished. I did use GnuPG 2.1.11 for
it, but it still puzzles me why 2.0 would outlive the invocation.
Do note it is all academical because Werner just said "you can't use gpg
this way", which kind of defeats the purpose of the pgrep altogether.
Oh, when I say pgrep is more compact, that's because the equivalent of
the ps ax | ... etcetera invocation seems to be:
while pgrep -c -- --edit-key >/dev/null; do
It is a pity pgrep doesn't provide an option for silence.
A very useful little trick, but pgrep does it automatically, so in the
cases where pgrep is the more logical choice than grep, it is not needed.
PS: Talking about never learning about command-line invocation of a
tool... ps, sheesh... I think I just know three:
$ ps fax
$ ps fx
$ ps -fp 1 `pgrep blah`
(the latter has the init process in there because I don't like it
erroring out when pgrep turns up empty-handed)

@_date: 2016-06-01 21:40:29
@_author: Peter Lebbing 
@_subject: Automating the generation of master keys 
I think it's still an odd limitation of the Key-Usage: option that you
cannot generate a master key without optional usages. Either "none" or
"certify" would be a good option to have, where I regard "certify"
definitely the prettier way to phrase it.
Key-Usage: sign
would do Sign, Certify for a primary key, implicitly adding certify.
Key-Usage: certify
would do just Certify for a primary key.
Disclaimer: I know very little of programmatic use of GnuPG.
Is it an option to upgrade your GnuPG to 2.1? I think it provides for a
less bumpy ride with the pinentry loopback.

@_date: 2016-06-06 12:09:15
@_author: Peter Lebbing 
@_subject: Curve 25519 encryption subkey - problem encrypting 
2.1 has already passed into unstable as well as stretch/testing. The
version currently in experimental renames the binary from gpg2 to gpg,
which is, I think, truly experimental for now. My gut feeling says that
for now, you'd better stick to the versions in testing(/unstable) unless
you're willing to help development by reporting bugs :-).

@_date: 2016-06-08 13:08:02
@_author: Peter Lebbing 
@_subject: Older gpg version does not ask for passphrase 
GnuPG 2.1 uses a new storage mechanism for your private keys. And 1.4
and 2.0 use the same "old" mechanism. From the way you sum it up, here's
what I suspect might be wrong: you simply have no passphrase set on
those systems that use the "old" storage. You might have exported your
private key without a passphrase once, and used this unprotected copy to
import the key elsewhere. When the key is stored without a passphrase,
you won't be asked for one, and anybody with access to the files where
the key is stored can simply copy the file and use your key, without a
If this is the problem, a way to fix it is to invoke:
$ gpg --edit-key YOURKEYID
[... prompted for the new passphrase ...]
If after that you are once again prompted for the passphrase (at least
once after starting the computer, since the agent might be caching it
after you've entered it once), then this was probably the issue. You
have solved it for the future on that computer. You can then repeat this
process on the others.
HOWEVER: keys stored without a passphrase are vulnerable to being
copied. If you suspect someone, for instance, has access to a backup
containing this key, you need to consider whether you should revoke the
key. I can't make this assessment for you, it's your decision. If the
key was stored without a passphrase, anybody with access to the files in
your GnuPG homedir can take your key and use it as they wish. Somebody
could have made a copy of it before you fixed the problem.

@_date: 2016-06-09 14:30:53
@_author: Peter Lebbing 
@_subject: Fw: GnuPG - Encryption process issues. 
This turns out to be a problem. When including all recipients, the
message to the mailing list is held for manual moderator approval:
So I would suggest to solve the problem of including all intended
recipients differently. A suggestion would be to have one person
communicate on the gnupg-users mailing list, and keep the rest of the
discourse internal to your company.
Apart from the delay, moderator approval takes valuable time of the
human moderator.

@_date: 2016-06-09 14:36:11
@_author: Peter Lebbing 
@_subject: Forwarding scdaemon over SSH - is it possible? 
This sounds like a job for our new superhero the --extra-socket option
that gpg-agent gained recently. It is meant for forwarding agent
connections to remote hosts. The local agent will then create an
scdaemon process to communicate to your smartcard.
Think well on the security implications of letting the remote machine
access your locally installed private keys. Do you fully trust the
machine and anyone with access to the socket on the remote machine?

@_date: 2016-06-09 19:50:25
@_author: Peter Lebbing 
@_subject: Configuration hints for using gnupg (2.0.x) interchangeably with 
That's odd, I don't know pinentry-mac, but pinentry-gtk is always fully
on top. It's so much on top that you can't use any other window while
it's active. It would require the option "no-grab" to prevent it from
fully taking over the screen. Do you perhaps have that option or
something equivalent configured in gpg-agent.conf?
As for which display it pops up on... on an X11 server, it will use the
X display the request is coming from, but an X display may consist of
several physical screens. Since my two screens are next to each other, I
really can't tell you if it pops up on the same physical screen. I
suspect it might not, since it probably only communicates the contents
of the DISPLAY environment variable to the agent.
Now that is something that definitely should not be happening. That's
odd. It's a pity I know nothing about Macs, so I can't directly help
you. But this does not happen here on Linux. When you invoke gpg on a
terminal and that gpg needs a pinentry, it tells the agent on which tty
it is and what its DISPLAY environment variable is. When you use SSH,
this will not set a DISPLAY variable by default, so you'll get a text
pinentry on the text terminal you run SSH on. If you use X forwarding,
it will do the correct thing and set an appropriate DISPLAY and set up
access control, after which you'll get the pinentry on the system you're
SSH'ing from. Only if you misconfigure SSH and force it to pass through
the DISPLAY environment variable, would such a thing as you describe
happen. In that case, your DISPLAY variable is probably ":0", and it
will contact the first local X server, which will be the wrong one, as
"local" is interpreted wrongly.
This really shouldn't be necessary. The only thing where you normally
need to watch out is with the SSH agent support, which has no means to
communicate invoking tty and graphical display. But when you're just
using gpg, it should do the correct thing out-of-the-box, and you need
no configuration for using gnupg (2.0.x) interchangeably with graphical
frontend and in the terminal (your title :).
Yes, that is *very* annoying.
That's exactly what should happen by default. Well, at least on the same
graphical environment as the terminal emulator if you're using one.
I think the priority is different: it will prefer graphical, and only
when that is deemed not available, fall back to text on the controlling
tty. If that is not available either, I think it will give up and error out.
When I say it will prefer graphical, then I mean the graphical
environment the terminal emulator is running in, not just any
environment. Certainly not on a different system. Of course, if you
multi-display a single "screen" terminal session, it might go haywire as
any X application would, since it would pick the DISPLAY from the
"screen" session that started it.
Do you have any non-default configuration set?
Again, it's a pity I know nothing of Macs. I don't even know how MacOS
communicates the fact that there is a graphical display available.
AFAIK, using X11 is just a compatibility feature thing, not the main
method to talk to the graphical environment on OS X, so it's probably
not through the DISPLAY environment variable?
However, I haven't seen anyone with actual knowledge of the topic reply
to you yet, so I thought I'd give you what I do know,

@_date: 2016-06-09 20:27:38
@_author: Peter Lebbing 
@_subject: Fw: GnuPG - Encryption process issues. 
Note this last line. There is a file /named/ random_seed, but it's not
doing its purpose. The file random_seed is used to store some randomness
to carry it over from one invocation to the next. This file is empty; it
contains no data, and hence no randomness.
First of all, you can happily delete this file. It's useless in its
current state, and GnuPG will generate a new one.
I did a quick look at the code, and stopped looking when the code
detecting an empty random_seed file was at least there in the year 2000
(commit 7438612 of libgcrypt). This case should be handled gracefully.
But still, it seems to work for you when you block access to this file,
right? Why not delete it. Although I suspect you may have tried it already.
Coming to speak of moments something was introduced, I don't think you
ever mentioned which version of GnuPG you're using. Could you please
tell us?

@_date: 2016-06-09 14:17:17
@_author: Peter Lebbing 
@_subject: Fw: GnuPG - Encryption process issues. 
Hello all,
Since I'm afraid that the message written by Jonas might not be read, as
it is posted solely on the mailing list, let me quote him here and
expand on it:
My own addition to this is: a public mailing list with a few rules.
Among them are:
Could you please not top post and trim your quotes?
PS: Just to clear up any possible confusion, I am not affiliated with
GnuPG nor part of any "Team". I'm just a private individual posting to a
mailing list for GnuPG users.

@_date: 2016-06-11 11:08:22
@_author: Peter Lebbing 
@_subject: Configuration hints for using gnupg (2.0.x) interchangeably with 
I just realised this even happens with "regular" screen sessions,
without the multi-display functionality. If you start a screen session
locally, then detach it and attach it remotely, it will still have the
DISPLAY environment variable from when you started it locally. So yes,
in those circumstances any X program you start from that session will
display on the original graphical display, and so will a pinentry
prompt. In a sense, you could say the DISPLAY environment variable is
incorrect then. Unsetting it will mean the pinentry will pop up on your
"screen" display, as a text program.
Perhaps this is in part an explanation for what you're seeing? It still
doesn't explain why the pinentry isn't on top; that might be a
non-default configuration?
PS: I'm assuming OS X communicates the graphical display through an
enironment variable as well. And I base this assumption on absolutely
nothing, so I should probably shout angrily, as one is wont to do with
poorly founded opinions.

@_date: 2016-06-13 20:15:02
@_author: Peter Lebbing 
@_subject: WINDOWS - Adding passphrase to gpg via command line 
I think it's possible Werner was mistaken about the correct format of
the command. Here, on Debian GNU/Linux with GnuPG 2.1.11 (Debian
packages version 2.1.11-7), the correct invocation appears to be
different. However, so is the error message, oddly enough.
This is the help text for PRESET_PASSPHRASE:
So it appears to take a hexstring, not a percent-escaped string. Indeed
this is what happens (the passphrase is indeed "test", this is a test
key, not my real key :-):
Note it explicitly complains about the format, where on your invocation
it's more ambiguous. This is a bit odd, if you ask me.
Now let's write "test" as hexadecimal ASCII:
And indeed the key is unlocked for use and could be used to sign some data.
So you could try this. I don't know what utility you'd use on Windows to
easily get the hexadecimal. But to get the exact required input on a
system like Linux, this will do so:
PS: On your replies, could you edit the Subject:-line to remove all the
repeated strings of Re: or AW:?
PPS: I've never understood, by the way, why the people who write e-mail
clients that translate those headers (Reply -> Antwort) don't implement
some functionality to automatically prevent the madness of repeated
headers in different languages. Your system even seems to repeat when
it's in the same language? Here in The Netherlands, I also see stuff
like "Re: Aw: Re: Aw: Re: the subject" come by. Really annoying, IMO.

@_date: 2016-06-15 13:17:01
@_author: Peter Lebbing 
@_subject: WINDOWS - Adding passphrase to gpg via command line 
You're missing some necessary quoting. Right now, you're sending four separate commands instead of a single command with three options!
gpg-connect-agent 'preset_passphrase 74EC3FAA93CD49446EC6825C3EBEB2C336CCBE2A -1 4D7950617373706872617365' /bye
should do the trick. Or if the Windows command line doesn't like quoting with apostrophes, you could do
gpg-connect-agent "preset_passphrase 74EC3FAA93CD49446EC6825C3EBEB2C336CCBE2A -1 4D7950617373706872617365" /bye

@_date: 2016-06-15 14:35:11
@_author: Peter Lebbing 
@_subject: AW: WINDOWS - Adding passphrase to gpg via command line 
When I purposely enter the wrong passphrase, the PRESET_PASSPHRASE
command succeeds, but subsequently the pinentry will pop up to prompt
for the correct passphrase when I try to do anything with the key.
So you might have a mistake in the passphrase?
You could create a test key and set its passphrase to be test, and
explicitly use the hexified version of the word test to try if it works
then, since we obviously can't tell you if you've made a mistake with
hexifying your real passphrase :-).
By the way, depending on your situation, it might not be worse to use
your key without a passphrase. Your key is encrypted when stored on disk
so that an attacker getting hold of the file doesn't yet have your key.
However, when you use gpg-preset-passphrase in a way that stores the
passphrase argument plainly on disk as well, the attacker can simply
read that file as well and decrypt your key. In such situations, the
encryption serves no purpose (other than to make you despair slowly but
surely). But in other situations, it can be more secure to use a
passphrase, so it all depends.

@_date: 2016-06-16 13:41:11
@_author: Peter Lebbing 
@_subject: WINDOWS - Adding passphrase to gpg via command line 
Does it end in bytes 0D or 0A? Those are CR/LF ASCII bytes, and should
not be included.
By the looks of it, you could check this through:
preset_passphrase will take anything thrown at it without complaint, as
long as it's syntactically valid. Whether the information was useful
will only become apparent when it is needed.
Also, are you unlocking the correct (sub)key?
Let's take a look at a test key:
If I wanted to unlock the key for signatures or certifying, I would
unlock the first keygrip. Note that if you have a separate signing
subkey, you'd most likely use that for signatures.
If I wanted to decrypt stuff, I would unlock the second keygrip.
Finally, if I wanted to use the key for SSH authentication, I would
unlock the third and final keygrip. If I wanted to unlock the whole
private key, I'd unlock all three.
Keygrips work, so I'd stick to that.
You mean, like, what the program gpg-preset-passphrase uses? It might,
but before I spend time on that, please see if you've already figured it
out with the previous part of this message.
I don't feel qualified to comment on the usefulness of this arrangement,
so I won't. This says something about me, not about your setup.
No, gpg-agent will not write to disk, and tries to prevent the operating
system from doing so, if it is supported on your OS.
PS: Could you perhaps use inline-quoting and strip your quotes?
Alternatively, sometimes it's not unreasonable to just remove all the
quoted text. But the dangling original message below your reply is an
unwanted style here at gnupg-users.

@_date: 2016-06-16 16:51:28
@_author: Peter Lebbing 
@_subject: WINDOWS - Adding passphrase to gpg via command line 
That part got accidentally mangled when I asked my mailer to reflow the
message. It was supposed to be:
I'm at a loss, frankly. I don't understand. You're using GnuPG v2.1.11,
you can use the key itself, but the agent isn't aware of having it! That
does not compute. I can only think of one thing. Are you really using
GnuPG v2.1.11, or do you have GnuPG 1.4 co-installed and are you using
that? If the latter, that's not going to work with keygrips. If the name
of the binary you're invoking is "gpg", what does
"gpg --version" say?
Could you show the invocation and output of using gpg to sign or decrypt
something? Please add "-v" to the command line to make it more verbose.
And could you show command and output for determining the keygrip you're
intending to use?

@_date: 2016-06-17 10:19:40
@_author: Peter Lebbing 
@_subject: WINDOWS - Adding passphrase to gpg via command line 
Well, at least it seems to make more sense now.
(First of all, the third should just end "--with-keygrip -K", or
possibly with 29FDE3FE to select to list just that secret key. The rest
was in my example because I accidentally screwed up the formatting; it
is actually the start of the output on the next line)
The --homedir option has a lot of influence. You cannot use a "gpg" in
one homedir with an agent running in another. So you should also supply
the "--homedir " argument to gpg-connect-agent to get a connection
for an agent with the correct homedir.
You either need to supply the --homedir option to all commands you
invoke, or set it through the Windows registry
(HKCU\Software\GNU\GnuPG:HomeDir), or just keep it at its default. Also
note that running "gpg" as one user and the agent as another will most
likely lead to trouble.
In fact, since you're continually running into trouble with
preset_passphrase, it might make sense to first get it working using
just the default homedir, and only when that works, move on to a
different homedir. That is, if you do need that different homedir.
This is its default homedir.
Could you show its output as well?

@_date: 2016-06-17 10:25:59
@_author: Peter Lebbing 
@_subject: WINDOWS - Adding passphrase to gpg via command line 
Thanks for the pointer!
While I'm not sure, I think this isn't the problem in this specific
case. I think that bug affects stuff that uses the GET_PASSPHRASE
command only. In GnuPG v2.1, the private key is actually inside the
agent, and the agent no longer just caches passphrases. So the
GET_PASSPHRASE command is no longer used to do private key operations.
Instead, the commands PKSIGN and PKDECRYPT are used (if I'm not mistaken).
I myself got the PRESET_PASSPHRASE command to work for me, with GnuPG

@_date: 2016-06-17 10:29:32
@_author: Peter Lebbing 
@_subject: WINDOWS - Adding passphrase to gpg via command line 
With a -v somewhere there for some added verbosity!

@_date: 2016-06-17 11:33:19
@_author: Peter Lebbing 
@_subject: AW: WINDOWS - Adding passphrase to gpg via command line 
Ah that's really great!
I read that in v2.1.13, gpgconf gains an option "--homedir" as well. So
starting with that release, I'd advise to include the --homedir for
gpgconf invocations. In fact, I'm unsure whether the version before
v2.1.13 actually does what you want it to do now... it might only kill
an agent pertaining to the default homedir, I don't know.
You don't need the "-v" on every invocation. It just makes it more
chatty about what it does, and that is helpful when trying to root out
the cause of a problem. It's less useful in production.
You're welcome! I'm happy we found the problem.

@_date: 2016-06-27 11:43:16
@_author: Peter Lebbing 
@_subject: (OT) Tamper Resistance of SmartCards -- NitroKey Pro/ KernelConcepts 
You should integrate the crypto token and PIN pad under your skin.
Subdermal keypad on the back of the hand, or one sensor per finger [1].
Nobody can take either your crypto token or your means of entering PINs
without cutting you while you sleep, which you would notice.
The only problem I see ;-P is that you would need to rely on contactless
interfaces which are harder to secure than
But at least you can go to sleep feeling safe.
Just kidding,
[1] Flexing your left thumb is "0", flexing your right middle finger is
"8", something like that.

@_date: 2016-03-05 12:00:04
@_author: Peter Lebbing 
@_subject: Non-Beeping keypad 
I have the same reader, I can understand that that can be pretty annoying.
This is really not an issue. The length adds so utterly little
entropy... besides, the entropy content of a PIN is already not really a
feature. The true security feature is that the card locks after three
wrong tries. The entropy content of a PIN would be hopelessly
insufficient to protect against brute force if it weren't for the "three
strikes you're out" rule.
I can't directly help you with that, but I can tell you that you can use
your current reader without using the keypad, simply by entering the PIN
on your PC, by adding this to scdaemon.conf (for instance at
~/.gnupg/scdaemon.conf, depending on OS):

@_date: 2016-03-05 12:12:01
@_author: Peter Lebbing 
@_subject: Encryption of multiple files into another directory 
On Linux:
for x in /media/usb/folder_1/*; do gpg2 -o "/media/usb/folder_2/$(basename "$x")" -r 0x12345678 -e "$x"; done
You can do progressively more complicated stuff as well. The program "find" is your friend, and
"$(echo "$x" | sed 's+^/media/usb/folder_1/+/media/usb/folder_2/+')"
can be used for more complicated pathname changes in other situations. Note that I used a plus as substitute command delimiter because slash is already in the strings, and that I anchored it at the start of $x by including a hat operator (^).
On Windows: I haven't got a clue ;).

@_date: 2016-03-05 21:12:44
@_author: Peter Lebbing 
@_subject: Encryption of multiple files into another directory 
Yes! Hehe :)
for x in /media/usb/folder_1/*; do gpg2 -o "/media/usb/folder_2/$(basename "$x").gpg" -r 0x12345678 -e "$x"; done
I simply forgot the extension, and GnuPG does what "I" told it to do.

@_date: 2016-03-17 18:09:20
@_author: Peter Lebbing 
@_subject: Unattended/batch key signing 
For this, you can use external tools, like caff, which is available in
the signing-party package on Debian, and is also available for other
distributions. It will do all the work in its own homedir, so you can
keep your certifications separate.

@_date: 2016-03-17 21:19:15
@_author: Peter Lebbing 
@_subject: (slightly OT) SHA-1 checksums to be replaced with something better at 
This page then continues:
So, if I understand correctly, they intend to verify SHA2 checksums, and
addition"). That's just overkill. Do you trust SHA2? Yes? Go with it.
No? Stop using it. Don't "augment its reliability" with other checksums,
especially MD5. That's wringing a poor snake for its oil... Although
probably no snakes where harmed in the process.
All the on-topicness has already been dealt with adequately, IMHO.
My 2 cents,

@_date: 2016-03-18 13:18:36
@_author: Peter Lebbing 
@_subject: (OT) mathematicians-discover-prime-conspiracy 
So forgive me for the off-topicness, but something in the text caught my
I did try this at home; only I wrote a Python script to do all the
tedious tossing and accounting. This is its output:
After over a million coin tosses, it takes 6 tosses on average until you
see two heads in a row, but only 4 to see head-tail. Obviously, the
script is attached. Supply the patterns on invocation, as shown above.
Any number of patterns of any length are supported (I think). Well,
strictly positive numbers and lengths :).
Can someone point me in the direction of the solution to this
counterintuitive probability theory result? Any of a common name for the
property, a mathematical explanation or an intuitive explanation are
much appreciated!
Anyway, to make up for the off-topicness, let's get slightly on-topic...
To the OP: Please provide at least a short abstract of the text when you
post a link. That way people can tell from your mail what the text will
be about.
With regards to the article, I'm surprised by the choice of words in its
title. Other than to draw in more readers, I don't see what place the
word "conspiracy" has in it. That's like saying 0 and 1 are conspiring
to be consecutive on the integral number line. Oh no, pretty much all
are computers are based on 0's and 1's and now they are conspiring!
Probably against us! Quick, we need neutral numbers without an agenda...
In my opinion, this title really devalues the article. "Three secret
ways to cope with prime conspiracy mathematicians don't want you to know
about" isn't that much further out. Oh, I hope that phrasing doesn't
tickle any spam filters... Ah well.

@_date: 2016-03-19 15:09:14
@_author: Peter Lebbing 
@_subject: (OT) mathematicians-discover-prime-conspiracy 
Please, please, /please/ don't change any text you are quoting. This is not what
Doug said, so it is not a quote, but really looks like one.
Other than that, I have no idea what you are trying to convey.

@_date: 2016-03-19 16:34:19
@_author: Peter Lebbing 
@_subject: (OT) mathematicians-discover-prime-conspiracy 
Thank you all for helpful responses, I understand where the difference comes
from now!
Ah, in my code, I indeed wipe the slate clean. It feels more appropriate; and
since I get the same expected number of throws as the article states, apparently
so do they.
Oh yes!

@_date: 2016-03-21 18:38:31
@_author: Peter Lebbing 
@_subject: EasyGnuPG 
These things can simply be solved through new documentation rather than a new
interface. The man page is typical reference style: all commands and options in
a list format. It's not tutorial style, omitting all but common options and
presenting the material in a tutorial form.
I had a quick look through the source.
The only thing I see in that category, IMHO, is automatically naming output
filenames. The rest is debatable whether it should be the default, or it could
easily go into gpg.conf.
My impression is that it's superfluous. Automatically naming an output file
would be some nice icing on the cake; the rest can go. If GnuPG had an option -A
(--auto-name) I would definitely use it:
$ gpg2 -Ar de500b3e -e file.txt
is nicer than:
$ gpg2 -o file.txt.gpg -r de500b3e -e file.txt
My main objection to your solution: it increases incompatibility with other
people. Your filenames end in .sealed and .signature where everybody else uses
.asc (since you use ASCII armour) or .gpg (for binary files). You use a separate
homedir, meaning for instance getting GnuPG plugins for e-mail programs to work
require configuration work on the part of the user. The same for SSH
authentication, where it may work automatically for a distribution-managed
configuration. When somebody wishes to do something more than your wrappers
handle, they need to take care of insuring they still work with the same
homedir. I don't see the purpose of changing the homedir.
You override defaults for key generation, and do so badly, I'm sorry. 4k RSA
keys can be debated; I think they're overkill and are even unbalanced. But a
primary key that signs, *encrypts* and certifies? An expiry of *one month*?? I'd
pick the defaults, and would consider not setting an expiry, though I might also
pick a long expiry to reduce the number of trash keys on the keyservers.
Why do you make the passphrase end up in a process list through this construction:
While you should probably generate keys on a single user system, this still is
unnecessarily revealing... anybody typing "ps a" at the correct time (a long
time, it's key generation) will see the passphrase. GnuPG has an excellent
passphrase interface: the pinentry.
Why do you override the private key selection by always picking the first usable
private key explicitly? This seems to me to be a worse default than the default
algorithm, and it's not even possible to override it.
Many of your commands rely on the user interface of GnuPG not changing, for example:
Are you aware that this can change any time the developers feel like it? It is
meant for human consumption.
That's my first impression.
Well... the distribution scripts that launch X may not look there, for instance.
There may be more cases where programs will not notice an environment variable
set in .profile. You probably should not change the homedir at all... what is
the purpose?
I think they are meant as alternatives to your project.

@_date: 2016-03-21 20:54:15
@_author: Peter Lebbing 
@_subject: EasyGnuPG 
Ha! How silly of me. Why the hell did I think it would go to stdout? Once again:
try before you state with confidence.
Thanks for correcting me.

@_date: 2016-03-22 18:11:51
@_author: Peter Lebbing 
@_subject: Verification via the web of trust 
This doesn't help you one iota. The simple reason: trust is not
transitive. If you want key A, which is 4 hops away from you, to become
valid, you need to trust a key B that has signed it. So either you see
among the people who signed key A someone you trust, or you don't. I'm
pretty sure you would recognise the name of someone you trust.
If you do see a name you recognise, key B, and who you trust, the task
simply transfers from A to this B. Only if, on every hop along the path,
there are people you recognise and trust, can you actually get valid
keys that are several hops away.
That trust is not transitive is not some quirk of the web of trust: it
is fundamental. I might trust Carl, and Carl might trust Jenny, but if I
don't know Jenny, I would not trust her, despite the fact that I trust
someone who trusts her. Trust is personal and direct, not transitive.
There is one exception: when you trust someone so much that you'd
delegate the issue of trust to them. This is usually only done in
specific, small communities and employer-employee relations, and is a
"trust signature". They are hardly ever used. Note that the trust might
be more built into the relationship than that you actually do trust your
employer... ;)

@_date: 2016-03-22 19:30:15
@_author: Peter Lebbing 
@_subject: Verification via the web of trust 
It sounds to me like you're not looking for the Web of Trust, which is indeed
very limited in its options. Instead, you are probably looking for something
more like TOFU, in the sense that this developer whose signature you see is the
same one whose signature you saw last time.
Or maybe a radically different other trust model. Quite likely one which hasn't
actually been implemented. It's still the same though: the OP talked about the
Web of Trust, so my answer was about the Web of Trust. That the Web of Trust is
not what you are looking for is a completely different issue.
Exactly! Well observed. I've said it before as well, a nefarious person holding
the private key of a Debian Developer can do much more interesting stuff than
introduce false signatures in the Web of Trust, so you might as well trust them
on that too. That is, as always, depending on your threat model. But I'd wager
that it's compatible with a lot of threat models, since Debian developers can
pretty much execute code as root on your machine.

@_date: 2016-03-22 19:40:43
@_author: Peter Lebbing 
@_subject: Verification via the web of trust 
By the looks of it, you could get an interesting alternate trust path here.
You say you run Debian. You can download digitally signed source code through
Debian, and in this source code, I see this file:
My guess is that this is the list of keys accepted for apache2 source code for
the Debian builds. Your William A Rowe Jr is in there. Apparently Debian trusts
him, and if you download it with apt-get source, you can get a verified genuine
copy of this file. So if the signature is valid for the key in this file, you
can be pretty darn sure that you have the right one. Otherwise, somebody managed
to subvert the integrity system of Debian.

@_date: 2016-03-22 22:21:31
@_author: Peter Lebbing 
@_subject: EasyGnuPG 
First of all, let me say that I regret that I didn't start my mail with feedback
on your project on a positive note. I think it's good that people spend effort
trying to make things more usable, and I applaud you for it. It would have been
a lot nicer of me to start out with that. There's no excuse for forgetting basic
civility and just being friendly to one another. Sorry.
Please don't feel put off by the fact that I might lack some tact here and there...
So you should do a check on the version and fail if it is different than the
version you worked with. And you need to support all the versions of all your
users; on short notice as well, probably. Plus the elephant in the room that the
developers of GnuPG are very explicit in that this interface is not for
scripting, yet you use it as such. You can reason about it all you want, in the
end, you're still using it differently than upstream intended.
All asymmetric crypto is done in the agent by now, there are separate programs
for several tasks like keyserver communication and smartcard communication. Sure
you can argue that the tasks are not spread in the way you would like, but in a
strict sense it is definitely not monolithic. "Fairly monolithic" at most.
You might be bothered by this on principal grounds, since it is security
software and there's the attack surface and amount of code to consider, but it's
not a practical issue, purely a principal one. That's like saying you don't like
Inkscape because it lets you paint in pink and you hate pink and never use it...
A reasonably fair criticism... writing good documentation is hard, very hard. In
fact, it turned out to be easier to write academical papers on why it is so
difficult to make crypto easy to use than to write documentation that makes
crypto easy to use.
When I refer to the man page, which is just one bloody long list without
structure (and hence not a maze either), I use search terms to find what I look
for. If specific ones will not do, a generic one, repeating the search until I
find the option I want. Then again, by now I've referred to it reasonably often
when trying to help people on this list or playing around.
Yes. Again, if we had documentation that omitted these, you would not be
bothered by it, right?
This one is odd. Have you examined the structure of the man page? Let me quote
(quite) a bit:
This is the structure of the two sections 'commands' and 'options'. I find it
perfectly obvious which are which. If you're lost in the massive list of options
and wonder whether you're looking at a command or an option, you do a backwards
search for a line that doesn't start with a blank. You'll end up at either
"COMMANDS" or "OPTIONS", and you'll have your answer. Basic man page voodoo,
searching for a non-blank first character to navigate sections.
Everything OpenPGP related, yes. The gpg2 binary is the front end to GnuPG with
regards to OpenPGP. Is this the same argument as "it's monolithic"? What
practical gain do you get if, for instance, key management were done with a
binary called "keymgr", and so on? In the end, when you verify a signature, you
want to know the validity of the key, so the same code gets exercised, whether
it's in a library shared by several binaries or one binary.
And even the library, GPGME, executes a binary: that way you get address space
separation. That way, all the crypto is in a separate process, out of the grubby
hands of whatever calls it. The private key is even further away in the agent
:). Again a separate process.
This I strongly reject. A /lot/ of thought has gone into the defaults, for as
far as I can see from the sideline.
Your one month expiry thing is not well thought through. Not only will the owner
need to re-sign and redistribute every damn month, but all his contacts will
pretty much always need tor refresh the key before they can use it, /even/ if
they are currently working offline (e.g., commuting), which means they simply
need to wait until they have network coverage again. The 4k RSA primary key with
3 subkeys grows by 2 kilobytes on the keyserver every single month (new expiry
signatures). When, not if but when the user forgets to renew, his contacts have
no other recourse than to contact the user in plain text to remind them of their
And why is your primary key capable of encryption? One of the reasons for
subkeys is so you don't have to use the same key material for both encryption
and signing, since this opens up some subtle points of attack that are easily
There is definitely some source of confusion: sometimes validity is referred to
with some construction with the word "trust" in it, whereas ownertrust is
something completely different. Also, the word key is overloaded: is it key
material, or is it a certificate? Heck, in the vernacular, keys go with locks,
not other keys.
But if something in GnuPG, in official documentation, refers to validity with
"trust" somewhere, I think you should definitely report it, because I think it's
only third parties that do this.
Unfortunately, I think it's a bit too late to introduce a different term than
"key" for the certificate, even though it is clearly confusing. You could rename
stuff to "contacts", but you have an established body of users and terminology.
You can't just wish it away, unfortunately.
That crypto is really hard from a usability standpoint is well-established.
Renaming public keys of others to contacts might be pretty smart. But there is
then some asymmetry. I send them my key, but they do not get my key, they get a
contact. When my key preferences change, they should refresh their... contact
information I suppose. It could work, I just think it's several decades too late
to actually change it.
I think you're being overly critical of what is already there. Somebody one day
might get it completely right; it could be you. But I personally don't feel that
your current solution is it. It's too disconnected from the rest, and it meddles
with stuff it should leave well alone.
Current GnuPG is the culmination of several decades of very hard work by
talented people. Don't forget that when you think something isn't as you think
it should be.

@_date: 2016-03-22 23:25:54
@_author: Peter Lebbing 
@_subject: EasyGnuPG 
It's not a good default. There is something to be said for an expiry, so
keys eventually become stale if the owner loses the revocation
certificate and the key itself.
But we clearly have an informed disagreement. There's nothing more I can
say, I think.
That is not up to you! It's up to your peers, or your attackers. They
pick which key they encrypt to, and your GnuPG will just use whatever
key was encrypted to, to decrypt it. You don't have a say in it. Your
only recourse is to delete your primary key, meaning you can't certify
anymore either.
If there are hidden recipients, GnuPG will simply try both your primary
and your subkey to decrypt the hidden PKESK packet.
Why did you change this to the setting it had in the way before, the
long-long ago: one key for everything? I've only ever seen it advocated
in the sense that "you should encrypt to the primary key for TOP SECRET
material, since I only have that key on an air-gapped offline computer".
Not precisely a beginner's scenario, and a flawed argument anyway if you
ask me.
Go ahead. You've heard multiple opinions from several people. But please
be aware of the criticism with regard to the details like the key
capabilities and so forth. You're choosing this for your users, not just
for yourself. Be prudent. Don't hurt your users, and realise that the
defaults are that for good reason. I would strongly urge you to keep
GnuPG at its defaults: they are good. Just change the interface, not the
defaults. Okay, I should stop, I get the feeling every next sentence is
a rephrasing of previous ones :).

@_date: 2016-03-22 23:30:22
@_author: Peter Lebbing 
@_subject: EasyGnuPG 
No, I meant what it already does, I had it wrong in my head and should
have tried it. I mean that it would be nice if the following were
$ gpg2 -r de500b3e -e file.ext
$ gpg2 -o file.ext.gpg -r de500b3e -e file.ext
Which they are. So the whole argument is moot.

@_date: 2016-03-23 18:42:11
@_author: Peter Lebbing 
@_subject: EasyGnuPG 
I haven't tried it (it's more work than most "let's try this" things), but I
think if you have a smartcard with your primary key inserted, and your primary
key can do A, GnuPG would be quite happy to negotiate that key for SSH auth and
subsequently do that authentication.
Smartcard keys are automatically considered for SSH authentication, which is
where it differs from on-disk keys, which need to be added to sshcontrol explicitly.
Yes, an on-disk authentication subkey seems really uncommon to me. I would
completely omit an A subkey.

@_date: 2016-03-23 20:30:50
@_author: Peter Lebbing 
@_subject: EasyGnuPG 
Fair enough :). Things like monkeysphere are exactly where it makes
sense. I have no idea how many people deploy monkeysphere for SSH.

@_date: 2016-03-24 10:53:28
@_author: Peter Lebbing 
@_subject: Verification via the web of trust 
These situations are rather more extreme than "is somebody MITM'ing my
connection to the apache.org webserver". If you can decide that somebody
authorized by the Apache Foundation to sign off on releases actually did
sign the code you got, that's actually of value.
The trust starts somewhere, there is always some base step where you say
"I can't verify further, this will do". There are no absolutes in this
game. In fact, the two points you give are /always/ valid. They do not
make signatures useless.
If I can conclude that the Debian project accepts signatures by someone
for releases of the Apache webserver, I feel pretty confident that so
can I. Somebody might actually be playing a very intricate game. Well,
they seem to have managed to subvert a majorly large Linux
distribution[1], I might as well give up against this actor, I'm no
match for them.
My 2 cents,
[1] Or alternatively, the installation media from which I installed
Debian, because again, the trust has to start somewhere.

@_date: 2016-03-24 11:01:18
@_author: Peter Lebbing 
@_subject: Verification via the web of trust 
This can clearly be broadened to just "subverted my computer", at any
time, through any mechanism.

@_date: 2016-03-24 12:24:32
@_author: Peter Lebbing 
@_subject: Force textual pinpad 
Please don't pass the passphrase on the command line as Dashamir Hoxha
As long as you don't use gpg-agent as an SSH agent, you can use a
terminal-based pinentry as the entry method. For instance, install the
package of your OS that contains pinentry-curses and add this to
pinentry-program /usr/bin/pinentry-curses
Alternatively, pinentry-tty is for the true minimalists. I wouldn't
recommend it, though.
You will need to kill off your running gpg-agent; this should start a
new one once you need it again. The precise behaviour depends on whether
you're using GnuPG 2.0 or 2.1. Note that my 2.1 agent even survives X
logouts :). So logout/login isn't even enough.
The X11 pinentries are indeed the summum of modal dialog, and this is
purposely done to at least somewhat protect against mistakes and rogue X
clients. You can make it less obnoxious :) by adding to your gpg-agent.conf:
This latter solution I mean as a solution on its own, not in combination
with a different-than-the-default pinentry.
To be able to use a terminal-based pinentry with gpg-agent as an SSH
agent, more work needs to be done before it will work.
Oh, as a final point of interest, Debian uses the "alternatives"
mechanism for the pinentry, so it should be possible to change the used
pinentry through update-alternatives rather than gpg-agent.conf; then it
will be system-wide, though.

@_date: 2016-03-24 12:38:40
@_author: Peter Lebbing 
@_subject: Force textual pinpad 
(Note I also answered your post and suggested pinentry-curses rather
than pinentry-tty :)
There isn't one by default ($GNUPGHOME defaults to ~/.gnupg and is also
unset by default). You can simply create one.

@_date: 2016-03-24 12:56:23
@_author: Peter Lebbing 
@_subject: Force textual pinpad 
Oh, BTW, could you please not top-post? It messes with the mind ;).
On reflection, you just need:
$ gpg-connect-agent reloadagent /bye
And if that weren't enough, this would be prettier:
$ gpg-connect-agent killagent /bye
$ gpg-connect-agent /bye
The latter is only needed if the first thing you do is SSH; it is
automatically started for GnuPG.

@_date: 2016-03-30 19:13:05
@_author: Peter Lebbing 
@_subject: What am I missing? 
(I think this is too far off-topic actually, but hey)
Can I ask why the conspiracy theory is "outrageous"? Can't you imagine that the
FBI, or at least part of it, would like to have a backdoor? They even got the US
president to say that he would like phones to have a backdoor. (It's clear his
previous job wasn't in IT security, because he'd then know it would seriously
weaken the protection of all phones the whole world over.) I hear the police
here in the Netherlands sometimes outright say they would like easier access to
suspects' files, not having to crack encryption. Is it hard to imagine that the
FBI might want the same thing, and that they can decide to use public opinion, a
case where a lot of innocent people died, as a lever to force a change they'd
like to see? I don't believe one moment they are so kind-hearted that they would
never exploit a tragedy for their own gain. (But obviously, you can't say you're
doing that, because that would be self-defeating.)
There are some really odd things. Everybody with some interest in this area
knows the first thing you do is make a low-level copy of all storage before you
begin anything. However, the FBI complains "it will wipe itself after X tries".
Without a TPM-like chip, just using regular memory chips and software, this is
not an obstacle for a well-funded shop.
And several parties have offered to crack the encryption, but the FBI didn't
take them up on it. Whereas once you have your copy, you can go crazy on a copy,
fuck up, make a new copy and ?REDO FROM START. So as long as you are comfortable
with the third party also reading what's on the phone, you can take them up on
it without damage. Unless of course it isn't about the data on the phone.
So I definitely did think this was about more than just this one phone. Like I
said, they even got a statement from the US president that "phones should have a
backdoor". But then suddenly they drop the case because they cracked the phone.
That was a major surprise for me. I cannot place it.
You know much more about digital forensics than me obviously. The only thing /I/
can think of is that there actually /is/ a TPM-like device involved. However,
I've understood that there is not, that it is simply all software. Perhaps I was
Hmmm, if you want to use public opinion as a force, you'd first need a terrorist
or child molester or what not who uses a phone made by a small company... Which
phone would that even be, by the way? Ubuntu phone, Jolla? Because I think most
people have either Android, Apple or Windows Phone. All three large companies.
And it wouldn't help to sue Microsoft, as Microsoft is of the interesting
opinion that the FBI is right, so you wouldn't get a court order with legal
And you say the publicity is a bad thing. But they have a lot of sway because
this is a terrorist. If they just went after a small fish with an uncommon phone
and the court said "No, you can't have your backdoor", they'd have precedent for
the wrong outcome! You want to go in strong. For instance, you need to make it
like your opponent is in favour of terrorists and child molesters. "Smoking pot
funds terrorism"?
I'm not saying you're wrong; I don't know. I think there is more than just this
one phone, it doesn't add up without a good TPM chip deterring them. But that
they dropped the case doesn't seem to make sense in that scenario, which is in
favour of your view. I /am/ surprised by your vehemency stating it's
"outrageous". I don't think it's an outrageous view.
My 2 cents,

@_date: 2016-03-30 21:19:01
@_author: Peter Lebbing 
@_subject: What am I missing? 
I'll just speak for myself. My position: I think the FBI wanted
something that could be /reused/ later, not just for this case. It
wasn't just about this phone.
And if they can /then/ use that to compell other companies to write the
same software for their phones like Apple was supposed to do, that's
pretty nice too, and also a form of "to be reused later". But this is
getting into too much detail and only muddles the discussion. The core
point is: they wanted more than just this phone. But they said it was
only about this phone.
Is this "conspiracy theory" outrageous? Or only the one where they
wanted legal precedent?
So you really think the FBI needed Apple to do this for them? It's an
open question, it's not the leering "really" kind. They don't have the
equipment to read out the memory? They can perfect their technique on a
whole bunch of innocent sacrificial iPhones, I'm sure the expenses are
tax-deductible ;).
Anyway, I should mention that I limited my "what phones are there" to
interesting data... most of it can just be had from the provider (call
records, SMS). And if it has picture and sound storage, I don't think it
will be encrypted. Somebody else mentioned Blackberry, I guess there's
still that one.
PS: In Dutch, we write the name "Johan" with one n; they seem to
flourish quite well without the support of additional ones. It's the
Germans that seem to have trouble to /stop/ spelling Johan :).

@_date: 2016-03-31 19:52:28
@_author: Peter Lebbing 
@_subject: What am I missing? (Again) 
============================== START ==============================
Can this be concluded from documentation supplied by Apple? Has it been
independently verified?
Your "Yes." strikes me as a pretty strong statement. I feel much more in line
with this statement:
And given that most people will use a PIN with abysmally low entropy, I doubt
that the device even uses the PIN for entropy. They would implement this
functionality just for those few people who unlock their phones with a proper
passphrase? It's possible, but it would be nice if you supported your claim with
Of course, it is pretty good snake oil to state in your documentation that the
unlock PIN is used to encrypt the data. It sounds really good, unless you know
about entropy, and that an attacker would probably need mere seconds to crack it
(offline attack). 10 bits of entropy, seriously.... (PIN consisting of 4 decimal
numbers taken as example, I don't know what Apple uses)
My 2 cents,

@_date: 2016-05-01 10:55:52
@_author: Peter Lebbing 
@_subject: making a Debian Live CD for managing GnuPG master key and 
There are textmode pinentries that "grab" a console and use that to
query the user. The default GUI pinentries have a curses fallback. With
GnuPG 2.1, for me it's as easy as unsetting DISPLAY to have it prompt
with curses for my smartcard PIN.
$ DISPLAY= gpg2 -d test.gpg
You can explicitly configure a textmode pinentry in
pinentry-program pinentry-curses
or perhaps pinentry-program pinentry-tty for a real bare bones one.
These pinentries are in the identically named Debian packages; you do
need to explicitly install them (pinentry-curses is already listed on
the wiki).
I haven't tried them with whiptail and such, but if they corrupt
something during the interaction, that might be a bug in the pinentry. I
haven't looked at the code to see how they save and restore the old
contents. Do they switch to the alternate screen buffer? Then as long as
whiptail doesn't do that, I think they should co-exist.
pinentry-tty most likely does screw up the screen. You really can't
blame it though, it's a bit simple :).
Ah, I missed it. What about a good OCR-friendly font to print with?
And related to that, you could consider scanner support and OCR
software, but perhaps it is too much work for too little gain, as the
paper backup is for emergencies only (and can also be typed out). Maybe
something for a future version.
Please realize that this burden is not just on the owner of the key, but
also on others.
The correspondents of the key owner will need to refresh their copy of
the key as often as it expires. In fact, I suspect this might be the
reason to advocate for shorter expiry times: it forces your
correspondents to check if there is anything new, including newly
created subkeys. It limits the amount of time people can encrypt to an
old key that was retired, perhaps even compromised.
However, this also means they need internet connectivity when they want
to encrypt something. If they are working while commuting, on a laptop
without an internet connection, they will simply find they cannot
encrypt because the key has expired. I think this is a great
disadvantage, and the person who chooses short expiry times puts this
burden on their correspondents rather than just on themselves.
There's another aspect: the size of the key on the keyservers.
Keyservers are append-only. Every time a RSA-4096 key expiry is
extended, this appends about 600 bytes to the key, and on the order of
300 bytes for a RSA-2048 key. For the key you propose on the wiki, this
is 900 bytes for a subkey expiry (three 2048 subkeys) and 600 bytes for
every primare key expiry (one 4096 key).
Good point, I forgot: it most likely did not have paperkey :). The
others: yes, I think it contained them back then, and it does now (I
checked the list of installed packages, I didn't boot one up to check).
PS: Could you please trim your quotes when replying? I found it a bit
difficult to pick your words from my own endless ramblings while
composing this reply... (while composing a reply in Icedove, it's a lot
more difficult to see the quote-level, it's all the same color).

@_date: 2016-05-01 11:22:53
@_author: Peter Lebbing 
@_subject: making a Debian Live CD for managing GnuPG master key and 
I expect some people would be worried about the amount of metadata this
leaks with short expiry times. If you are in the position to sample
refreshes, it gives a nice view of how many people regularly use the
key, based on the number of refreshes of the key. When people don't use
things like Tor to hide their key refreshes, they also leak the
information that they personally are using the key.

@_date: 2016-05-04 11:37:32
@_author: Peter Lebbing 
@_subject: managing OpenPGP cards in batch mode? 
repository on the web at [2], and you can clone it to your local hard disk with:
git clone [1] [2]

@_date: 2016-05-04 11:40:07
@_author: Peter Lebbing 
@_subject: managing OpenPGP cards in batch mode? 
Werner, would you recommend they use 2.1 or 2.0 for the Debian Live CD?

@_date: 2016-05-04 14:07:04
@_author: Peter Lebbing 
@_subject: managing OpenPGP cards in batch mode? 
To the best of my knowledge, this would indeed not pose a problem at all.
Note that exporting a private key with 2.1 prompts the user to enter the
passphrase for the key. This is different from how earlier versions did it. The
reason is a technical one: the local storage is in a different format than the
export, and hence the passphrase is needed to decrypt the local storage, convert
the format and then re-encrypt the export. As far as I can see, it doesn't
matter whether the passphrase is already cached or not: I am always prompted for
I agree.

@_date: 2016-05-04 14:34:07
@_author: Peter Lebbing 
@_subject: (OT) development infrastructure 
Debian has its own infrastructure for that. In fact, the Git repository
for the Live CD is hosted by the Debian infrastructure.
Incidentally, GitHub is not as free (as in freedom) as some would like
it to be, so it makes sense Debian, with its DFSG, is using its own
infrastructure for it. (I'm just putting it in perspective, I'm not
trying to provoke a discussion on freedom)

@_date: 2016-05-05 17:52:26
@_author: Peter Lebbing 
@_subject: (OT) FSF involvement (was: managing OpenPGP cards in batch mode?) 
gnu.org lists GnuPG as a "GNU package", a part of the GNU Project. I
kinda assumed that that would imply some form of involvement of the FSF
in GnuPG... be that infrastructure or other support or whatnot...
Also, similarly, I thought the mailing list infrastructure was shared
with GnuTLS and that GnuTLS was a part of the GNU Project up till 2012?
Or is the shared infra perhaps from after the split between GnuTLS and
the FSF?

@_date: 2016-05-06 16:01:54
@_author: Peter Lebbing 
@_subject: (OT) FSF involvement 
Perhaps chapter 13: [1]
Furtheron it says:
You could consider promoting non-free services on the mailing list a form of
"legitimiz[ing] them" and the fact that it is not allowed here "us[ing] your
influence to lead people away from them".
Still, the way Werner phrased it:
Combined with the earlier part of that mail, it doesn't sound to me like he is
doing this to conform to some rule from the FSF or the GNU Project.
Anyway, thanks for pointing us to a written source of the "FSF does not want
this" rule I had never seen written down before!
PS: I converted the curly quotes from the gnu.org quote to straight quotes since
we're talking about netiquette and some don't like non-ASCII ;-).

@_date: 2016-05-08 14:30:45
@_author: Peter Lebbing 
@_subject: OT egpg evaluation 
This includes gpg2. The complexity of the gpg2 command line means some
things require a good ordering of options and commands, while often unix
tools will accept any ordering. But the convention that "--" means
everything that follows is input is also observed by gpg2, at least in
my quick check. The following two are decidedly different:
$ gpg2 -o test.gpg -r de500b3e -e -s
$ gpg2 -o test.gpg -r de500b3e -e -- -s
The second uses the file named -s and doesn't sign.

@_date: 2016-05-09 22:12:30
@_author: Peter Lebbing 
@_subject: how to configure default sign key for particular user? 
I think the configuration option "group" already covers your use case.
In my gpg.conf:
group peter=de500b3e
group test=DCDFDFA4
Testing it:
$ echo hi | gpg2 -u test -s|gpg2
gpg: Signature made Mon 09 May 2016 22:09:50 CEST using RSA key ID DCDFDFA4
$ echo hi | gpg2 -u peter -s|gpg2
gpg: Signature made Mon 09 May 2016 22:10:14 CEST using RSA key ID DE6CDCA1
Oh right, that's a bit unclear, DE6CDCA1 is a subkey of DE500B3E :-).

@_date: 2016-05-09 22:17:43
@_author: Peter Lebbing 
@_subject: how to configure default sign key for particular user? 
Crap. I did it wrong. It was a bit silly of me to choose group names
that overlapped with the uid's! It doesn't work, I'm sorry.
Okay, then maybe group could be accepted for -u (since multiple -u are
allowed, it's not strange either). That would be a feature request.
Hope that helps more than my previous message :),

@_date: 2016-05-14 20:54:23
@_author: Peter Lebbing 
@_subject: Problems with USB access to Omnikey 4321 
I haven't looked into your problem, but let me give this quick hint: try
LC_ALL=C . It should override all language settings.
I think if you kill the agent, and do something like:
$ export LC_ALL=C
$ gpg-connect-agent /bye
Then I would hope that the started agent would inherit the setting for
the logs...

@_date: 2016-05-15 18:36:31
@_author: Peter Lebbing 
@_subject: Problems with USB access to Omnikey 4321 
Oh, then what I showed is not sufficient to get the agent and scdaemon to change
locale, that's too bad.
I'll get back to your earlier mail now.
Can you tell what version of GnuPG you are using? I can't readily tell...
Anyway, your card still seems responsive. You can still select the OpenPGP
application on it and list its data.
I'm getting technical, which is also intended to help along any other people
trying to look into your problem. So if you don't understand what I'm saying,
just read on.
Where in the dump of your gpg --card-status --debug-ccid-driver, GnuPG seems to
immediately request for the OpenPGP application by Application Identifier, and
this succeeds, the gpg-connect-agent dump first tries a different SELECT
command, I think for the MF, Master File[1]. Then your card seems to go silent
and does not respond anymore.
On contrast, with a v2.0 card I have here where I depleted the tries for the
PINs, and using GnuPG v2.1, my GnuPG will always do the SELECT MF from [1], also
with gpg2 --card-status. My card then replies with SW1-SW2=6B00, indicating the
SELECT failed. The difference is it doesn't go silent like yours. Subsequently,
my scdaemon request the OpenPGP application by AID[2], this succeeds by
SW1-SW2=9000, and everything goes peachy. Whereas your card is never heard from
At this point, I'd really like to know which version of GnuPG you're using. And
if you're using GnuPG 1.4, do you have 2.x installed? Could you easily install
2.1 if you don't have a 2.x installed already?
My issue here is that my installation issues different commands to my card than
yours. At least, sometimes.
The first part of a dump of my scdaemon log when I do a gpg2 --card-status can
be found here[3].
Now don't trust me on this, but it seems to me that scdaemon is using its
internal CCID driver for your card reader, and this line, AFAIK, is only
relevant to setups where PC/SC is used, that is, not the internal CCID driver.
So I think it's not relevant.
I /think/ this was thus unneeded, as is a running pcscd. In fact, a different
program also accessing the card reader will cause issues when scdaemon is using
its own CCID driver.
[1] The raw APDU is 00 A4 00 0C 02 3F 00
[2] The raw APDU is 00 A4 04 00 06 D2 76 00 01 24 01
[3]

@_date: 2016-05-15 18:51:44
@_author: Peter Lebbing 
@_subject: Problems with USB access to Omnikey 4321 
On reflection, the difference in behaviour is in the scdaemon, not in the gpg
binary which talks to the agent. I don't recommend you use the gpg program from
GnuPG 1.4, but do it all with GnuPG 2.x, but it's not that which causes the
difference from how it goes here.
The difference is that your gpg --card-status does a "scd serialno openpgp",
unlike your "scd serialno". But for me, "scd serialno openpgp" also tries the
SELECT MF first.
By far the easiest way to factory reset an OpenPGP card is with GnuPG v2.1's
command factory-reset from --card-edit.
The thing is, there are cards where the two commands involved where accidentally
switched around. This keeps on confusing me, I still can't say which card needs
which order of reset commands to work.
You could try to do what you're doing with "scd serialno openpgp" instead of
"scd serialno", to see if it works then. But it's odd this is needed. The "scd
serialno undefined" you can also find is probably unneeded at this point because
that's for cards where the OpenPGP application is in "Terminated" state or
something like that, and your OpenPGP application is still responsive when you
do --card-status.
Which instructions are you trying to follow?

@_date: 2016-11-09 12:14:30
@_author: Peter Lebbing 
@_subject: Specifying different pinentry based on caller? 
One step in the right direction is unsetting the DISPLAY environment
variable when gpg is invoked. Ensuring that gpg never gets to see a
usable DISPLAY var might be all that is needed (or it might not,
depending on Desktop Environment, I don't know :-).
It works for me on a terminal just invoking:
$ DISPLAY= gpg2 -s test.txt
(Actually, that's not unsetting it, just setting it to an empty value.
But it works.)

@_date: 2016-11-11 12:12:38
@_author: Peter Lebbing 
@_subject: PCI DSS compliance 
Disclaimer: I know nothing about these compliance issues.
Couldn't you simply password protect the key and unlock it when the
server boots, with several admins entering a part of the password?
Alternatively, to use SSSS, you could wire up an SSSS implementation to
a pinentry, so you don't need specific admins but use any X of Y of
them. In this case, I suggest you use a randomly generated "passphrase"
for the GnuPG key. If you want to make your implementation real shiny,
you could store the actual shares encrypted, with each admin having the
possibility of choosing their own decryption password, so they don't
have to learn a seemingly random number.
To clarify, I mean you write the pinentry implementation and use an
already written SSSS implementation. This pinentry is then invoked when
you gpg-preset-passphrase the passphrase during boot of the server.
Just an idea,

@_date: 2016-11-11 12:29:21
@_author: Peter Lebbing 
@_subject: PCI DSS compliance 
Upon reflection, isn't this complaince issue for key management, like
subkey creation, setting of expiry, stuff like that, rather than decryption?
It seems like stuff you need the primary key for, whereas for
decryption, you only need the encryption subkey. They can be separately

@_date: 2016-11-17 17:13:45
@_author: Peter Lebbing 
@_subject: Primary and Signing Key on Different Smart Cards 
Which version, GnuPG 2.0 or 2.1? I think you can use 2.1 to reach the desired
outcome without difficulty, even if it might be a bit non-standard.
Separate homedirs is not necessary for 2.0 either. But you need to do some
"packet surgery" on the private key files as GnuPG 2.0 cannot update private
keys. It has been described before at least in this[1] and this[2] thread.
Can we first get out of the way which exact version of GnuPG you're using? If
you're using 2.0, start with the threads linked above, and feel free to report
back if you're unclear about something. For 2.1, if time permits, I can outline
the steps for you. You will need to have the private key on-disk for both
versions, I'm afraid. Then again, by doing the alternative, on-card key
generation, you're forced to use the on-card random number generator. I'd much
rather trust GnuPG's random number generator than the one on a cheap smartcard
(or any smartcard for that matter). So I would recommend to not use the on-card
key generation feature anyway.
I think I worked with the on-disk keys by pulling all hard drives from my
computer, booting Knoppix from USB stick and using the DVD writer to save
backups. I verified Knoppix had only opened stuff from the stick in read-only
mode, and decided to trust Knoppix in not saving any persistent stuff. However,
since you don't want backups, you could simply burn Knoppix to DVD and do away
with writable media altogether (ignoring writing DVD's for a moment; that's not
something you accidentally leave on). Unless you don't have a DVD writer, of
course :-).
Yes, I've used a key with the primary key on one smartcard and the subkeys on
another for 7 years.
[1] [2]

@_date: 2016-11-17 20:26:55
@_author: Peter Lebbing 
@_subject: Primary and Signing Key on Different Smart Cards 
You will need the private key on-disk *temporarily* while setting up the
smartcards. But with Knoppix, that "disk" can be a RAM disk in the main
memory of your computer, obliterated once you power it off.
I reread part of my own message in the reply by Arthur Ulfeldt, and
noticed how unclear I had worded it :-).

@_date: 2016-11-18 12:20:42
@_author: Peter Lebbing 
@_subject: gpg-agent crashes on Windows 10 
That's not the official place to get your GnuPG downloads. 2.1.15 for
Windows is available from .
While technically correct[1], 2.0.30 is the latest 2.0 release, and thus
the current version. Remember there are three parallel branches, 1.4,
2.0 and 2.1.
[1] The best kind of correct!

@_date: 2016-11-19 16:36:47
@_author: Peter Lebbing 
@_subject: gpg2 --version gpg: Fatal: libgcrypt is too old (need 1.7.0, have 
Did you issue a
# ldconfig
as root after you installed the libraries? Because you say you run
Debian jessie, and that has the file:
# libc default configuration
So unless you manually changed the settings for ld.so, this directory
should already be in the system search path. However, invoking ldconfig
as root is a necessary step to scan these directories for new additions,
AFAIK. Possibly this is only necessary if you put the first library in
one of the dirs, I don't have the details ready. But in a normal Debian
jessie system, libraries in this directory should "Just Work"(TM).
Or is this a problem with the 1.6.3 receiving priority over 1.7.3? I
don't know off the top of my head how to fix that, so let's try ldconfig

@_date: 2016-11-21 12:04:51
@_author: Peter Lebbing 
@_subject: Primary and Signing Key on Different Smart Cards 
Ah! I don't have time right now, but once I do, I'll try to see to write
up some instructions...
With 2.1, maybe it's possible. I'm curious to try it out. It might work.
It might not.
No, but I remember Werner Koch saying he'd rather not use the on-card
RNG. I tried to find this, but the best I could find was his statement
that you don't want regular DSA on smartcard[1]. As I understand it,
that is because of the risk of a failing RNG. Signature generation in
DSA requires a good quality random number, otherwise it might be
possible to reconstruct the private key through signatures. In the time
since that post, GnuPG gained deterministic DSA, which no longer
requires randomness for signature generation.
That is of course your choice. However, people have done analysis of
large amounts of public keys on keyservers before. If someone discovers
a way to exploit a weakness in the OpenPGP Card on-card RNG, they might
be able to analyse massive amounts of public keys and put the results on
the internet for everyone to see. Just to show they can, and win the
internets. Even if you don't suspect adversaries who target you
specifically, you might be caught in a massive untargeted sweep. I'm
just thinking out loud here, it's just something that came to mind. It's
your decision, I'm just trying to help you make it an informed decision.
Maybe you think I'm being overly paranoid. I'd rather have you consider
it and then dismiss it than not think of it at all.
[1]

@_date: 2016-11-21 12:08:29
@_author: Peter Lebbing 
@_subject: Primary and Signing Key on Different Smart Cards 
Oh, good point! Maybe it's possible without on-disk keys, I'll try it
out later. Otherwise: yes, it would be impossible to add new subkeys.
I'm not too sure about "removing the unencrypted copy", though. I'd much
rather not have the key hit the disk anyway. By using a Linux Live CD
and physically removing the cable from the hard disk.

@_date: 2016-11-22 11:41:27
@_author: Peter Lebbing 
@_subject: How to prevent passphrase caching in 2.1 
Why do you lump these users together? At a first glance it seems more
logical that they have separate system accounts, or at the least
separate GnuPG homedirs (and hence agents).
They shouldn't even have access to the encrypted private key in the
first place.

@_date: 2016-11-22 11:44:57
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
That's what filesystem permissions are for? Like I just said in the
other mail, if each user has their own system account, they can't access
the files containing the encrypted private keys of other users.

@_date: 2016-11-22 19:44:20
@_author: Peter Lebbing 
@_subject: How to prevent passphrase caching in 2.1 
Perhaps 1.4 is the best release for you... you'll miss out on Elliptic
Curve, but other than that, it's still a supported release.
Perhaps you should implement access control in your frontend, instead of
asking the agent to perform access control, for which it was not
intended, AFAIK. It sounds like you just want the ability to work with
OpenPGP material, rather than the user-centric model the agent seems to
correspond to. When GnuPG gives you a square peg, you'll have to build
your own adapter before it fits in a round hole ;).
By the way, I'm not recommending anything (this in response to your "do
you seriously recommend..."). I know nothing about your application or
what you demand of it. I'm merely trying to give you directions to look
in, while you search for the correct architecture of your application.

@_date: 2016-11-23 11:19:06
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
I could concur with this statement if we amend it a little: when two
MTA's are explicitly configured as TLS peers. They have to abort the
mail exchange when TLS can't be negotiated and when the certificate is
not as expected. "Expected" can mean: DN checking, issuer checking,
fingerprint checking, perhaps CRL checking.
There are many problems preventing succesful TLS on SMTP. It's trivial
to downgrade, and certificates are only checked whether they are valid
in the general sense, not even the DN is checked. I could MITM a
connection to mail.example.org, present a valid certificate for
mail.digitalbrains.com, and the peer would accept it even though it
isn't valid *for mail.example.org*. Basically, it only works for passive
But since the OpenPGP-protected mail payload would also require explicit
configuration, I don't think it is actually a disadvantage of TLS in
this case...
I'm not completely sure the "explicitly configured TLS" doesn't have a
snag somewhere that complicates stuff more, though... I vaguely remember
something like that from a presentation...

@_date: 2016-11-23 11:38:32
@_author: Peter Lebbing 
@_subject: configure warnings and errors upon ./configure for Pinentry v0.9.7 
Good one, the symlink. It makes me wonder: is the agent looking in the
right place for the pinentry? Perhaps if you compile your own GnuPG and
install it in /usr/local/*, it will look for /usr/local/bin/pinentry only?
The Debian jessie pinentry-curses package uses the alternatives system,
which means that /usr/bin/pinentry will be a symlink to
pinentry-curses, that will in turn be a symlink to
package, David should already have a /usr/bin/pinentry.

@_date: 2016-11-23 11:44:34
@_author: Peter Lebbing 
@_subject: configure warnings and errors upon ./configure for Pinentry v0.9.7 
(I'm not Werner :) Yes, GTK+-2 is one of the pinentries. It's the one I
use, on my XFCE Debian jessie.
Argh. Just do the "rm trustdb.gpg", it contains the ownertrust values
you have assigned to other people's keys (well, okay, as well as your
own). I'm under the impression you're starting out cleanly, without
keys, so the file would have been empty anyway.
Murphy, probably :-). I think it's just bad luck.

@_date: 2016-11-23 13:17:08
@_author: Peter Lebbing 
@_subject: Primary and Signing Key on Different Smart Cards 
Here are instructions for doing this on 2.1. First let me point out:
With 2.1, everything goes fine and you can later add new subkeys without a backup!
There are two ways to go about this. If you don't mind that the primary key will
have Certify and Sign abilities, you can do everything on-card and no RSA
private key material ever leaves the card. Note that you do use the on-card RNG
in this case! We've discussed this.
If you're being very strict and really only want the Certify ability on your
primary key, I think you're forced to do a regular on-disk keygen for the
primary key first. I don't think a Sign ability on your primary key will hurt in
the usual case. It means you can use either smartcard to issue signatures on
data. Signatures on subkeys or other people's keys are limited to the smartcard
with the primary key, since only the primary key has the Certify ability.
So let's start out with both Sign and Certify abilities on your primary key. I'm
simply copying my terminal output here, with some omissions where I thought it
was getting too verbose. I also don't mention when it prompts me to enter the
PIN on the card reader.
And note I'm not suggesting you set your key expiration to one week. I do that
for my test keys. I also edited these "ultimately trusted" keys to "NOT trust",
but I omitted that part. I do not trust my test keys :-). For one thing, they
have password "test" or PIN 123456.
And continue with adding subkeys as per above.

@_date: 2016-11-23 19:59:09
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
If you sign the data just before the interaction, the signature time and
the time noted in the Received:-header are virtually identical, so the
signature time doesn't leak data.
I think other people were thinking you wanted to use regular mail
transports in combination with your OpenPGP layer. Thus, only very few
MTA's would be involved and they would all be under the administration
of either the sending, or the receiving party. That is, the exact two
parties who have access to the private keys in the scheme you proposed.
Hence the noted similarity.

@_date: 2016-11-24 11:17:03
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
I still don't see why you need per-user keys.
OpenPGP, or at least as produced by GnuPG, is Sign-Then-Encrypt. If each
Message Submission Agent and each post office (POP3, IMAP) server had
their own key (you could use --throw-keyids or --hidden-recipient), it
could be as follows:
User sends from . Intended recipient is
Message Submission Agent for example.org adds a header indicating it was
alice who succesfully authenticated, and other interesting stuff. MSA
then signs and encrypts the whole message. Encryption recipient is the
nowhere-special.org post office server (but --throw-keyids). MSA creates
a new shell RFC822 e-mail message with everything removed but the SMTP
recipient  (this is a special address I'm
inventing for the protocol).
We now have a message that only leaks the fact that nowhere-special.org
is the receiving domain. The OpenPGP thingy itself leaks nothing. The
signature has a correct, normal timestamp, but this data is encrypted.
The recipient of the encryption is unknown (but can be inferred to be
nowhere-special.org, so it's not that useful to use --throw-keyids
perhaps). It's just an encrypted blob.
This goes through all the remailers, is beamed into space, buried for
some time on the dark side of the moon, etcetera.
Once it reaches nowhere-special.org, the process listening on
 decrypts the message using its own private
key. It checks the signature is indeed from its established peer server
at example.org. It knows when example.org signed the message. Then
again, in your proposed scheme, the receiving server also has all data
like when alice wrote it, and what she wrote. The timestamp from the
signature adds nothing substantial. The post office server then delivers
the message in the recipient mailbox, with some status headers.
As I said, I don't see what different keys for different accounts add
here. And I don't see why the intended recipient can't know of the
signature timestamp, so you don't need --faked-system-time. You could
use GnuPG 1.4, or you could use 2.1 with a gpg-agent daemon holding just
the private key for the server doing the crypto.
Oh, by the way, in reply to a bit from another mail:
It's not really that relevant, but anyway: as I said in the next
paragraph, this was all assuming you were using a regular mail
transport, not remailers.

@_date: 2016-11-24 14:32:53
@_author: Peter Lebbing 
@_subject: Implications of a common private keys directory in 2.1 
I don't understand this. Could you give an example or something, to help
me understand?
AFAICS, the recipient needs a way to send mail back to the sender, and
hence, a domain name for the sender. Having the signature tell them
which domain name the sender used, tells them nothing. Unless of course
you don't want pseudonymous, but anonymous mail. In the latter case, a
signature is meaningless and should just be omitted altogether.
And how will the adversary see this timestamp? It's encrypted to the
recipient! Surely, if he has the timestamp, he has the plaintext of the
mail and the timestamp is probably the least of your problems. I'm
really not getting this concern! Huh?!

@_date: 2016-11-24 16:04:42
@_author: Peter Lebbing 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
I think 2.0 also supported:
$ ssh-add -L
to list all SSH keys known to the agent. ssh-add is part of the
openssh-client package.

@_date: 2016-11-24 18:36:59
@_author: Peter Lebbing 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
I think the following:
$ gpg-connect-agent
# KEYINFO [--[ssh-]list] [--data] [--ssh-fpr] [--with-ssh] # Return information about the key specified by the KEYGRIP.  If the
# key is not available GPG_ERR_NOT_FOUND is returned.  If the option
# --list is given the keygrip is ignored and information about all
# available keys are returned.  If --ssh-list is given information
# about all keys listed in the sshcontrol are returned.  With --with-ssh
# information from sshcontrol is always added to the info. Unless --data
# is given, the information is returned as a status line using the #   KEYINFO     - -   # KEYGRIP is the keygrip.
# TYPE describes the type of the key:
#     'D' - Regular key stored on disk,
#     'T' - Key is stored on a smartcard (token),
#     'X' - Unknown type,
#     '-' - Key is missing.
# SERIALNO is an ASCII string with the serial number of the
#          smartcard.  If the serial number is not known a single
#          dash '-' is used instead.
# IDSTR is the IDSTR used to distinguish keys on a smartcard.  If it
#       is not known a dash is used instead.
# FPR returns the formatted ssh-style fingerprint of the key.  It is #     printed if the option --ssh-fpr has been used.  It defaults to # TTL is the TTL in seconds for that key or '-' if n/a.
# FLAGS is a word consisting of one-letter flags:
#       'D' - The key has been disabled,
#       'S' - The key is listed in sshcontrol (requires --with-ssh),
#       'c' - Use of the key needs to be confirmed,
#       '-' - No flags given.
# More information may be added in the future.
I just can't think of how to pick out the right key now... What little detail is eluding me?

@_date: 2016-11-24 18:46:17
@_author: Peter Lebbing 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
No, that's wrong, scratch that. That will not work for OpenPGP keys because those aren't handled by the agent in 2.0. Silly me.
I'm not sure you can add an OpenPGP auth subkey to the agent's SSH support without resorting to external tools, i.e., follow the method Stephan gave.

@_date: 2016-11-24 20:56:20
@_author: Peter Lebbing 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
Stephan, thanks for helping out! I think I can improve a bit on one part
of it, though.
This leaves open a window where the file with your private key might be
The thing I usually do is this:
$ mkdir safe
$ chmod 700 safe
$ cd safe
$ [... do your stuff ...]
$ cd ..
$ rm -rf safe
The directory permissions prevent anyone from getting a handle for your
file. Even if the file is world-readable, nobody can get towards the
file. This is not true if you are on an NFS share, though!
The thing I would expect to actually be in the textbooks is a variation of:
$ OLD_UMASK=$(umask)
$ umask 0077
$ [... do your stuff ...]
$ umask $OLD_UMASK
The umask 0077 will create any new files with all access rights cleared
for group and world. This is your A2 and A3 folded into one, safely,
without a gap.

@_date: 2016-11-24 21:17:23
@_author: Peter Lebbing 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
I mean: if you're on an NFS share, or an a disk partition from which
things are shared over NFS. So if you're sharing /srv/export and you're
on /srv/somewhere/else, it's still not safe.

@_date: 2016-11-25 21:37:40
@_author: Peter Lebbing 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
Let me reuse a bit of quote from an earlier mail:
Here a file is created with most likely mode 0644. It contains an
unencrypted private key, and anyone being quick about it can read the
file until you have time to type....
... and from this moment on it is secure.
If somebody knew beforehand you were going to do this on a multi-user
system, he could monitor likely directories programmatically and catch
you in the act. Paranoia mode... on!

@_date: 2016-10-06 20:41:34
@_author: Peter Lebbing 
@_subject: Listing signatures in edit mode? 
No, the cross-certification signature is part of the signature of
1E8BB8D0 on 63AB1D1A. This cross-certification signature is not really
that well visible.
For instance, take my key:
If I'm not mistaken, the cross-certification signature is "subpkt 32",
but unfortunately it is not parsed by --list-packets. What broadly
happens, if memory serves me correctly, is that DE6CDCA1 issues a
signature on DE500B3E, which becomes the subpkt 32. Then DE500B3E issues
this whole signature packet, which includes the signature just made by
The gory details are in RFC 4880.
Note that only signing subkeys issue a cross-certification, not
encryption or authentication subkeys. Some encryption subkeys might even
be mathematically incapable of issuing such a signature, depending on
the type.

@_date: 2016-10-08 12:59:40
@_author: Peter Lebbing 
@_subject: Linux GPG2 Encryption Getting Intermittent gpg: signing failed: 
This sounds like the bug . The
bug is that the error message is quite unclear, but means that the
program was unable to prompt for a passphrase with a pinentry.
I find it odd that this even works as intended for you at all. I usually
get confused as to which versions of GnuPG support which methods of
unusual passphrase entry, but my GnuPG 2.1.11 [1] does not respect the
--passphrase argument at all. It simply prompts me for the passphrase
through a pinentry anyway.
So my guess is that the "intermittent" behaviour you see is that when
the passphrase is known and cached, it will run okay, ignoring your
--passphrase argument. But when it needs to know the passphrase, it will
error out since it can't locate a method to interact with you.
Usually, the --passphrase argument makes no sense from a security
standpoint. You encrypt the private key because you don't want anyone
with access to that file to directly have your private key. Yet, they
only need to access the file with your script to simply obtain the
passphrase there. You've only changed the scenario from "there's one
interesting file" to "you need two files". That's not very useful.
Another point is that the passphrase is plainly in the process list when
someone does a "ps ax" while GnuPG is running.
For unattended signing, I think usually you either store the private key
unencrypted (or at least, the signing subkey), or you prime the
passphrase cache when you boot the server, with gpg-preset-passphrase.
But I don't know much about scripting GnuPG effectively.
[1] I should start compiling my own newer versions, but haven't started
yet. I run Debian jessie/stable, and the newest versions of GnuPG 2.1
for testing and unstable are not easily installable on stable. That's
why I'm a tad behind.

@_date: 2016-10-11 11:47:17
@_author: Peter Lebbing 
@_subject: Private key export for SSH 
I don't know if you can do private key export; perhaps with monkeysphere?
Here's a different idea. An .ssh/authorized_keys file is a list of text
lines, each line being a single authentication key. Normally, you append
the contents of id_xxx.pub, a single line, to an .ssh/authorized_keys
file to add that key.
How about you just create a separate key for the machine where you don't
use GnuPG, and then create a .pub file that contains two lines, one for
the GnuPG key and one for the other key?
$ rsync other:.ssh/id_rsa.pub combined.pub
$ gpg --export-ssh-key alice >> combined.pub
Note the second command appends to combined.pub.
Then any time you add combined.pub to an .ssh/authorized_keys file,
you're adding both keys, with the same procedure you would normally add
a single key, no extra clicks, nothing :-).

@_date: 2016-10-11 15:35:37
@_author: Peter Lebbing 
@_subject: Private key export for SSH 
I think I vaguely remember Monkeysphere supporting it.
(I'd consider key-per-user/workstation-combo cleaner :-)
I think other features simply were more important, and got priority...

@_date: 2016-10-18 13:25:32
@_author: Peter Lebbing 
@_subject: reviewing wiki / shortlist PIN-pad readers 
It would IMO not prevent key usage, so in that sense the user is defeated. It
would still limit the time of exposure, since key extraction should still be
prohibitively difficult.
This is a contentious topic I think :-). People put different amounts of stock
in the protection afforded by smartcards, and the likelihood of attack scenarios.
But luckily, entropy demands on a smartcard PIN are really low. The card locks
after three tries.
Conversely, if you protect your on-disk key with a 10-digit decimal number, an
attacker having the encrypted file could do the required average of 500 million
tries in less time than it takes you to make a cup of coffee.
A PIN just needs to be unguessable, i.e., properly random. It doesn't have to
withstand keyspace enumeration.
My 2 cents,
Note to self: make cup of coffee.

@_date: 2016-10-18 13:29:36
@_author: Peter Lebbing 
@_subject: list revoked UIDs 
I think it's:
gpg --list-options show-unusable-uids --list-keys <...>
I grepped the man page for "revoked" until I hit upon this.
That is a possibility, depending on import-options.

@_date: 2016-10-26 18:12:21
@_author: Peter Lebbing 
@_subject: pinentry dialog 
You need to add "--pinentry-mode loopback" to the arguments.
Also, while this is all fine for testing and debugging, it doesn't appear to
make sense in production. What use is it to encrypt file A with a passphrase
that is in plaintext in file B? Better not to encrypt file A, your private key,
in the first place, since you gain nothing in protection in the general case.
Then you don't need passphrase entry anymore, the key will Just Work(TM).
preset_passphrase takes a *keygrip* not a *fingerprint*. You can find the
keygrip as follows:
$ gpg2 --with-keygrip -K 035A38377BE10CD8
For my test key, it's as follows:
sec   rsa2048/3E7F0306 2013-07-26 [SC] [expires: 2016-11-02]
      Keygrip = BDAB81746D3696C48746896F4EA1670D312148C7
uid         err Test extra UID
uid         err Test more extra UID
uid         err Testkey
ssb   rsa2048/459A39FE 2014-01-09 [E] [expires: 2016-11-02]
      Keygrip = 815F15F918ECF9922D4CF60D0ED5C03143746201
If I want to prime the passphrase for decryption, I would use the keygrip
815F15F918ECF9922D4CF60D0ED5C03143746201. For the passphrase for signing, I
would need the other keygrip instead.

@_date: 2016-10-29 14:21:10
@_author: Peter Lebbing 
@_subject: pinentry dialog 
I just used
$ echo test | gpg2 --no-tty --batch --pinentry-mode loopback --passphrase-fd 0
-o test.out --yes -d test.gpg
as a variation on the precise invocation you provided, and it worked fine; under
Linux. And yes, the passphrase for the key is the word test.
Are you completely sure that the command correctly accesses the file "abc123$$$"
in your current directory when invoked, and that the password in that file is
correct? If so, all I can think of is line endings. DOS files end in CR LF where
most Unix-like systems end lines in just LF. Sure enough:
Since my agent caches passphrases, I need to flush the cache in between each
invocation or the results would make no sense.

@_date: 2016-10-31 11:20:31
@_author: Peter Lebbing 
@_subject: GNU Privacy Assistance Signing help 
============================== START ==============================
The key manager at the bottom says
"The key has only a public part"
so you can't sign or decrypt with it, as that needs the secret part.
If you exported and then imported this key, you should export the secret
part as well. Usually, you only export public keys, so it's a different
procedure for secret keys.
I could fire up a different computer that has GPA installed and try to
see what you should do, but perhaps you can figure it out with just this
hint, so I'll leave it at this first. Do ask for more information if you
can't figure it out.

@_date: 2016-09-04 13:19:04
@_author: Peter Lebbing 
@_subject: I think that's a false dichotomy 
And, with all due respect, for that reason I think policy should not be
determined by people who have been exposed to a very unbalanced amount of
horrible people. Constantly being confronted by the worst scum of the gutter
skews your view of human behaviour.
The same goes for police. Constantly dealing with people who have broken the law
corrupts how you think the majority of people behaves. It's only natural.
Safety and liberty can't both be maximized, it's a trade-off. At the edges of
the spectrum, there are some truly horrendous violations of safety, that in a
just world definitely should not have happened. There truly is no excuse, and
liberty is not an excuse either. But I still think we should strive for that
liberty. Please note, Robert, that I'm not saying you are not striving for
liberty. I see how you argue against weakening encryption in general, and I
applaud you for keeping your back straight despite all the horror you've seen.
My 2 cents,

@_date: 2016-09-04 18:32:28
@_author: Peter Lebbing 
@_subject: I think that's a false dichotomy 
We (at least I) live in a representative democracy. All these decisions *are*
taken by an extremely small subset of the people (i.e., politicians). It is just
hoped that they do this in a way that is representative of what the society as a
whole wants; yet again without the tiranny of the majority. Reality is a *lot*
more complicated than "the decision belongs to the people".
Very true. But those experiences should be viewed in a proper light.
Over here, police is knowingly ignoring privacy laws because it "is so
effective". That's what I mean when I say this shouldn't be left to the people
enforcing the law and doing the detective work.
(What I'm specifically referring to here: Automatic traffic cameras record all
licence plates that pass the camera. The purpose is to monitor for "flagged"
licence plates and report when one of those passes the camera. However, all
recognized licence plates are stored in a database for I believe several months.
That way, you can retroactively consult whether somebody passed that camera.
This storage is not lawful, but police insist on doing it).
I didn't say it was a zero-sum game. I merely asserted that they can't both be
maximized. Sometimes they can both be increased, but the amount of liberty I
desire for this society definitely does cost you in safety.
People could get abducted. Suppose you can at all times see where everyone is,
through technological means (GPS+GSM tracking), and you also have cameras
viewing all streets in every city and a warning system detecting suspicious
movement on the cameras. It would be very, very, very difficult to abduct
someone in a city by dragging them into a car and disappear from the radar. Yet
I fervently hope this will not become reality. I'd rather run the risk of being
abducted. I'd also grudgingly rather have children run this risk. You can
actually buy GPS-trackers for your children. I don't have any children myself,
but I would maybe use this until the child is, let's say, five years old and
then stop using the device. At some point a child deserves its privacy, and I
think parents shouldn't want to track their child in this way. You still want to
know at all times where your child *is* until they are quite a lot older. I'm
convinced of that. But not by tagging them with GPS. Just in the same way we've
done it all this time before GPS and mobile telephony existed.
I think it should not be viewed as a zero-sum game, but I do believe some
safety, and some forms of safety, needs to be lost in order to have liberty
increase. Or things left as they are for liberty, even though it costs us some
If you can find a way to increase both, that's great. But sometimes one or the
other needs to prevail. Some forms of liberty are not worth the risk, and some
forms of safety are stifling.
Life is risky. Life is also unfair. Not all of this is fixable. We should strive
to do so, but not at any cost.

@_date: 2016-09-11 14:42:51
@_author: Peter Lebbing 
@_subject: :-(( smart card no longer works 
It looks fine to me, I think you're getting confused by it referring to
the key in several ways. Here's part of the output for "gpg2 -v -d" for me:
It first notices the key it is encrypted to is 73A33BEE, which is a
subkey. Then it really wants me to know that it is using this subkey of
the primary DE500B3E :-). Finally it shows the actual subkey it was
encrypted to along with the primary User ID of the key as a whole.

@_date: 2016-09-30 12:59:33
@_author: Peter Lebbing 
@_subject: Terminology - certificate or key ? 
IMO, TOFU has just made it even worse.
I tried to be really strict, talk about ownertrust and validity. Always trying
to keep them separate. Personally avoiding the word "trust" without the "owner-"
Then we get Trust On First Use, which... increases or establishes validity of a
key on the first use...
I suppose, in this case, that's what you get when you import a term from outside
of the ecosystem. If invented here, it would be Validity On First Use.
PS: A while ago I said "I think it might be worth it to file a bug report if you
see the word 'trust' used for validity in the official documentation that
accompanies GnuPG." Then I read the new documentation on TOFU, and mentally
tagged it WONTFIX. It's just undoable with that terminology.

@_date: 2017-04-03 13:16:43
@_author: Peter Lebbing 
@_subject: some beginner questions 
I might misunderstand what you mean. But when somebody has full access
to your device, they can simply log your keystrokes when you type the
passphrase, and get your passphrase that way. Key compromise is very
well possible without you knowningly handing over the passphrase.
More generally, it is impossible to use GnuPG in a meaningful way on a
compromised device. I think this generally goes for pretty much all
cryptography. Different solutions limit compromise in different ways,
but to actually keep on using cryptography problem-free, I don't think
that will work.

@_date: 2017-04-03 13:20:53
@_author: Peter Lebbing 
@_subject: some beginner questions 
I'd like to extend this short description a bit :-). There is one
important somewhat-caveat, which is that you can't delegate the Certify
capability to a subkey. This means you always need to use the primary
key to sign other OpenPGP *keys*. Signing data can be delegated to a subkey.

@_date: 2017-04-03 15:57:07
@_author: Peter Lebbing 
@_subject: That which we call a rose 
I agree. But it might be too late.
I used it as a means of explaining what I meant with "Certify
capability". Next time I'll somehow work into my formulation that this
should be called certification, not signing.
Similar issues:
certificate vs (public) key
ownertrust, trust and validity
I'm inclined to give up on the latter now we have TOFU. Your speech
would become truly idiosyncratic if you were to introduce Validity On
First Use in it...

@_date: 2017-04-22 13:12:53
@_author: Peter Lebbing 
@_subject: "general purpose OS is fundamentally inadequate for trusted 
I completely disagree with this assessment. It is a completely wrong
portrayal of the motives of people who warn about putting all your money
on a smartcard.
So what real protection does it offer? If somebody has full access to
your general purpose PC, they can read your encrypted communication and
fake your signatures. Maybe faking signatures is something that would
leave a trail and will be noticed eventually, but what good does that do
you when your oppresive regime has just rounded up all your
collaborators and has them before a firing squad?!
The only thing they cannot do is make a copy of your key to use it
elsewhere; they are bound to your hacked PC for usage. I think there are
plenty threat models where the fact that they can read your encrypted
messages is far worse. And they can do that willy-nilly, by cleverly
using your smartcard for their own use while caching and providing the
session keys you are trying to decrypt. You don't even have to decrypt
the document they're interested in yourself, and no external push button
will save you. Just decrypt a document twice, and the second time, the
attacker can use your smartcard for their own good while providing the
session key they logged the first time for your decryption.
It feels like you are saying "if you have a real need for communication
security, a smartcard will make you more secure"; saying that much at
the least. And it is completely and utterly dependant on the threat model.
You accuse others of not caring about people with real threats, yet your
careless vague statements might encourage those people to place
inappropriate trust in their smartcard setup. I think you are the one
who is doing them a disservice, not people like Robert J Hansen who warn
that smartcards can't magically make you safe when your computer is

@_date: 2017-04-24 19:23:29
@_author: Peter Lebbing 
@_subject: GPG Signature Verification 
"data" seems to be correct: it is an EMSA-PKCS1-v1_5 encoded RSA SHA-256
signature. As RFC 3447 states:
EM = 0x00 || 0x01 || PS || 0x00 || T.
PS is a string of binary 1's to fill up the remaining space in the RSA
message, and T is a constant DER-encoding of SHA-256 followed by the
actual signature. The constant portion is in both RFC 3447 and RFC 4880:
 The full hash prefixes for these are as follows:
       SHA256:     0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
                   0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
                   0x00, 0x04, 0x20
The part of "cmp" that would correspond to the constant part of the DER
encoding I do not recognise. My guess is that you did not instruct the
library you're using to generate the signature to create an
EMSA-PKCS1-v1_5 encoding, and that's why it is generating an RSA message
that differs in construction.

@_date: 2017-04-26 12:23:49
@_author: Peter Lebbing 
@_subject: GPG Signature Verification 
It is still proper ASN.1, but it encodes a slightly different structure.
I wondered whether it was DER encoded or BER encoded, because I read that BER was valid for old PKCS v1.5 structures. DER is a subset of BER. If the Python ASN.1 module pyasn1 rejects malformed DER encoding then it is proper DER; or would pyasn1 be liberal in what it accepts?
Anyway, the two ASN.1 encoded objects are slightly different:
$ python
(Sequence().setComponentByPosition(0, Sequence().setComponentByPosition(0, ObjectIdentifier(2.16.840.1.101.3.4.2.1)).setComponentByPosition(1, Null(''))).setComponentByPosition(1, OctetString(hexValue='0000000000000000000000000000000000000000000000000000000000000000')), '')
(Sequence().setComponentByPosition(0, Sequence().setComponentByPosition(0, ObjectIdentifier(2.16.840.1.101.3.4.2.1))).setComponentByPosition(1, OctetString(hexValue='0000000000000000000000000000000000000000000000000000000000000000')), '')
There's an extra setComponentByPosition(1, Null('')) in the properly encoded ASN.1. It would appear that the library you're using *is* trying to generate a PKCS v1.5 message, but that it ends up with a slightly different DER encoding than what is defined for OpenPGP. You will have to find a way to generate a EMSA-PKCS1-v1_5 structure that is compatible to RFC 4880 (and RFC 3447 PKCS  Version 2.1).
I don't know much about ASN.1, so I can't really say anything useful about the results of the experiment above.

@_date: 2017-04-30 20:04:24
@_author: Peter Lebbing 
@_subject: Trouble installing Version 2.1 on Debian Jessie 
As others said, I'd use the packages from stretch/testing, as they have
already percolated down that far.
Perhaps your pinning in apt-preferences is interfering with the -t
option, because I think the -t option should promote dependencies to be
downloaded from the specified suite as well.
(Do you mean "apt-get" instead of "apt", by the way?)
What I do when I seem to get the wrong results regarding dependencies,
is just select all the specific versions of dependencies I want manually
with aptitude's visual mode. It helps tremendously to set the following
option in aptitude:
Options -> Preferences -> "The display format for the status line":
%d %t
That way it shows what suite a package version belongs to in the status
line. The config file version of this is:
$ cat ~/.aptitude/config
aptitude::UI::Package-Status-Format "%d %t";
The available versions of a package are right at the bottom of the
package information in aptitude.
Anyway, if you install GnuPG 2.1 from stretch/sid/experimental, it will
*replace* your GnuPG 1.4. But packages using GnuPG 1.4 in Debian jessie
do not expect this to be the case, and might malfunction. Another option
is to install my backport of GnuPG 2.1 which comes in the place of GnuPG
2.0 instead. I've put it on GitLab here:
My README.md is a bit alarming, I know, but I don't want to be
responsible for goofs. I tried my best, and to the best of my knowledge
it is in fine shape. I use it myself. You could look at the differences
compared to the Git repository at:
to check it for yourself (my tag dbbp/2.1.19-3-dbbp8+1 is based on
debian/2.1.19-3 from upstream; this similarity will generally be the
case). [1] As you can see, I'm a bit behind, but not much.
It is your decision to use it or not. I'm just providing it as a way for
people to avoid the chore of doing the changes themselves. The changes
that there are can be reviewed quickly. (It's a pity the quilt patch
files are so chatty in their irrelevant differences.)
Anyway. While this means that packages depending on 1.4 can keep using
it, it also means you'll have both 1.4 and 2.1 installed. Try to avoid
actually using both versions for yourself. The keystores can go out of
sync and confuse you. So if a system package (like apt itself or some
system daemon) uses GnuPG 1.4, that's fine. But if your e-mail plugin
uses GnuPG 1.4, you'll probably get confused.
[1] If you've got the git repository locally:
$ git diff debian/2.1.9-3 dbbp/2.1.19-3-dbbp8+1
Furthermore, note both tags are signed:
$ git tag -v debian/2.1.19-3 dbbp/2.1.19-3-dbbp8+1
object 372c9126144cb0e80613a317f46479a872f93b0a
type commit
tag debian/2.1.19-3
tagger Daniel Kahn Gillmor  1490114759 -0400
gnupg2 Debian release 2.1.19-3
gpg: Signature made Tue 21 Mar 2017 17:45:59 CET
gpg:                using RSA key 38276051EA477FA3E49539321498ADC6C1923237
gpg:                issuer "dkg at fifthhorseman.net"
gpg: Good signature from "Daniel Kahn Gillmor "
gpg:                 aka "Daniel Kahn Gillmor " [full]
gpg:                 aka "Daniel Kahn Gillmor " [full]
gpg:                 aka "[jpeg image of size 3515]" [never]
gpg:                 aka "Daniel Kahn Gillmor " [full]
object 4d66ca8885602e78b96a14f5e2a7fcb7f9bdead9
type commit
tag dbbp/2.1.19-3-dbbp8+1
tagger Peter Lebbing  1493556629 +0200
gnupg2 jessie backport 2.1.19-3~dbbp8+1
gpg: Signature made Sun 30 Apr 2017 14:50:48 CEST
gpg:                using RSA key 65008DC220AAE2A2574D6CD5969E018FDE6CDCA1
gpg:                issuer "peter at digitalbrains.com"
gpg: Good signature from "Peter Lebbing "
However, it remains for you to establish trust in these signatures,
otherwise it's like "someone on the internet said it, so it must be true".

@_date: 2017-04-30 20:32:21
@_author: Peter Lebbing 
@_subject: Extending Expiration dates of gnupg keys with the private key 
- Which version of GnuPG is this? GnuPG 1.4 will not ever update the
secret part of a key, so you'll have to delete the existing copy first.
Be very careful! You're deleting a copy of your secret key, make sure
you know what you're doing. I believe this also went for 2.0 and only
2.1 can update secret keys, but I'm not sure and can't check from the
passenger seat of the car I'm in :-D.
- Note that you are negating a large part of an offline master key by
bringing it online. Usually, you'd use a different computer to do master
key operations on, a computer that doesn't have an internet connection.
If you're worried about your computer being hacked, note it usually
won't suddenly automatically become un-hacked later, it'll just stay
hacked until reinstalled. But there is no single correct answer to this.
You shouldn't need to specify --expert to extend expiries.
This has just removed all your private keys belonging to this
certificate, primary *and* subkeys.
... You /did/ just delete all keys :-).
You'll need to restore your private key from backup, and follow the
instructions you used earlier to create a subkey-only keyring.
By the way, it helps if you post the output of the commands, because we
can't see if they appear to have worked correctly. I mean the console
ones; I wouldn't start with all the effort of taking screenshots and
cropping them and uploading them to the web...

@_date: 2017-04-30 20:34:40
@_author: Peter Lebbing 
@_subject: Extending Expiration dates of gnupg keys with the private key 
I saw one detail after I pressed Send. This appears to be a persistent
flaw in my e-mail writing.
I think keys 1, 2 and 3 are all subkeys; NOT your primary. To extend the
primary, don't issue a "key" command before "expire". Only after that
extend the subkeys.

@_date: 2017-04-30 20:41:38
@_author: Peter Lebbing 
@_subject: Question on Putty and gpg-agent 
I don't think you're telling gpg-agent "that key is not on a card".
You're telling it "you can't work with cards". Consequently, the little
guy or girl living in the code of gpg-agent goes "Hmmm, this is a key on
a card. I can't work with a card. I can't work with this key." I think
you were hoping it would think "let's look elsewhere", but it likely
will not do so.
It is a decidedly different behaviour than gpg-agent on Linux. There, it
will check if a smartcard is currently connected and if so, offer such a
key for authentication. For SSH, it will *never ask* to insert a card!
It'll just skip it outright. So it seems gpg-agent is doing entirely
different things on Windows. Does it even support on-disk authentication
keys or is it smartcard-only? I don't know, I haven't used Windows for
anything other than games for very long. I did read the release notes
when Putty support was introduced, and it only discussed smartcard keys,
but that isn't conclusive proof it only supports smartcard keys.

@_date: 2017-08-13 18:08:44
@_author: Peter Lebbing 
@_subject: Cache Timeout not working correctly 
Unless this has been fixed already, this is probably because cache-ttl
has simply never worked for smartcards. They stay unlocked indefinitely.
I would have expected that to work, but have never used the option
myself. For GnuPG 2.1.18, the documentation comes with a caveat:
It's the card itself! It'll stay unlocked until told otherwise or
powered down.

@_date: 2017-08-17 16:06:39
@_author: Peter Lebbing 
@_subject: export secret subkeys 
Note "gnu-dummy S2K". This is an empty placeholder for the key material.
An OpenPGP secret key always contains the primary key, but this is
GnuPG's method to get away with not actually including the primary key
"S2K" means "String to Key", and an S2K is a method that derives a
cryptographic key from a passphrase. The cryptographic key is
subsequently used to encrypt the secret key material (well, apart from
the fact that this is a dummy that doesn't actually do that).
And an OpenPGP secret key always contains the public key as well, which
And this is actually secret key material. First the public key again,
then the secret key in skey[2] (skey -> secret key). It is protected by
the "iter+salt" S2K.
This packet will be significantly larger than the earlier packet.

@_date: 2017-08-18 18:33:47
@_author: Peter Lebbing 
@_subject: Is it possible to certify (sign) a key using a subkey? 
Since making certifications using subkeys is extremely uncommon, there's
a good chance people will encounter issues when checking such a
certification. Since the purpose of a public certification is for other
people, not you, to check it, you are not doing them a service.
The impact of you doing this on your own seems vanishingly small. And
the ratio of disk space used by a public keyring versus everything else
that is commonly on a computer isn't different. If I were looking for
optimizations, I'd turn to processing time of a public keyring, not its
I disagree. The de facto standard is that certifications are issued by
the primary, even if this might not be encoded in the RFC (I didn't
check, though). You could create an ECC primary if you really want to
issue certifications with ECC. Do note that there are many OpenPGP
clients that do not support ECC yet.

@_date: 2017-08-25 17:36:50
@_author: Peter Lebbing 
@_subject: Extraction of decryption session key without copying complete 
Could you explain further what you are trying to accomplish?
"Batch scenario" suggests to me: the human user is not logged in.
"GnuPG agent forwarding" suggests to me: the human user is logged in
through SSH.
So I'm obviously missing some aspect of what you are doing.

@_date: 2017-08-25 18:57:34
@_author: Peter Lebbing 
@_subject: AW: Extraction of decryption session key without copying complete 
It doesn't sound like you need agent forwarding at all. I would expect
that you can decrypt with a session key without an agent, since the
agent is only consulted to get the session key, but you already have it.
Step 2 is not working, but it is all on the system with the private key,
with a locally running agent. Dit you either gpg-preset-passphrase or
remove the passphrase from the key? If the agent needs to prompt the
user with a pinentry, but there is no human since it is batch operation,
it will error out. So it needs to know the passphrase already or the
passphrase needs to be removed.
I think agent forwarding is an alternative to your idea, not a way to
implement it. With agent forwarding, the remote system without the
private key would ask the forwarded agent to decrypt the
public-key-encrypted-session-key for it and obtain the session key that
way and that would avoid all the extra steps. Provided it worked :-).

@_date: 2017-08-28 12:00:17
@_author: Peter Lebbing 
@_subject: Extraction of decryption session key without copying complete 
The gpg process communicates its TTY to the agent so the pinentry knows
where to pop up. This is a feature, not a bug. But when you deliberately
want to pop it up elsewhere...
I almost had it working in a test:
- Start an x-terminal, invoke "tty" and see that it is /dev/pts/7.
Start another x-terminal and:
$ unset DISPLAY
$ export GPG_TTY=/dev/pts/7
$ echo test | gpg -o /dev/null -s
And indeed the pinentry-curses popped up on the other terminal. BUT: a
few of my keystrokes went to the bash shell that was running there
instead of the popped up pinentry. So the passphrase I entered in the
pinentry was missing characters, and those characters were typed as part
of a command on the command line.
So my idea that GPG_TTY would override the terminal was correct, but it
didn't actually work in the end.
It seems that it's easier if you use a graphical pinentry, by just
overriding DISPLAY in the session where the batch runs.
Well, agent forwarding to access a remote private key only works on
GnuPG 2.1 (and later, once later exists). In general, mixing versions is
not a good idea, no, not even between minor versions. But possibly this
restriction is less stringent for the forwarded socket, because I expect
there it will be common to mix versions. It might have been designed to
account for this.
You should consider whether you should use a passphrase at all. Usually,
with unattended decryption, it's just bothersome. The passphrase
protects the key at rest. If you're worried about attackers getting
access to a backup, you could do the gpg-preset-passphrase dance. If an
attacker that gets the privileges to read the contents of your private
key dir is not part of your threat model (for instance, because it's
game over), you might as well remove the passphrase and be done with
this bothersome pinentry stuff, as FAQ entry 8.20 [1] says.
The admin that is submitting a list of PKESK packets already effectively
has unfettered access to your decryption key as far as usage is
concerned, no need to worry about them. And using just a forwarded agent
connection, they still have no access to the key material.
[1]

@_date: 2017-08-28 13:17:17
@_author: Peter Lebbing 
@_subject: pinentry-curses competing over tty (was: Extraction of decryption 
Those options had slipped my mind... Thanks!
Werner, do you know why the bash shell that was running on the X
terminal where pinentry-curses popped up received several of the
keypresses that were intended to go to the pinentry? If I use the
passphrase abcdefghijkl, the entry line in the dialog looks like this:
Pinentry got the wrong passphrase, and when I get back to the shell and
press Enter, bash tells me:
bash: bdfik: command not found
My impression is that both bash and pinentry-curses are reading from the
keyboard input, and it is up to chance who gets the keypress. Pinentry
echoes '*' on a keypress, and bash echoes the entered character.
I've seen this before when I used a terminal-based pinentry and I did an
ssh without first doing an updatestartuptty. Is pinentry-curses doing
all it should to grab the terminal?
Oh, and while I have your attention (I hope :-), is the extra-socket
suitable for sharing with a host running a different version of GnuPG
2.1 or later? It seems useful, in a heterogeneous setting with
distribution-provided GnuPG binaries.

@_date: 2017-08-29 16:24:28
@_author: Peter Lebbing 
@_subject: Questions about particular use cases (integrity verification w/o 
... which you can only do by trying each private key on the encrypted
session key packet and seeing whether the resulting plaintext (which
contains the session key) makes sense.
There isn't any information that can be learned without actually trying
out a particular private key. At least for RSA, it's the only algorithm
I know enough by heart about to make this claim with confidence.
You don't need to decrypt the data though, just the encrypted session
key, to see if it's the correct private key.

@_date: 2017-08-30 11:43:46
@_author: Peter Lebbing 
@_subject: E-mail with deniable authentication 
I don't think a repudiable message lets you off the hook in those examples
either, least of all the dictatorship...!
With a little scripting, you could create a new ECC keypair (fast!) for each
message, sign the keypair with your normal key, sign the message with the ECC
keypair. And when you want to backpedal on a signed message, publish the private
ECC key and say "look, anybody who downloaded my private key off the web could
have signed that message".

@_date: 2017-08-30 12:46:24
@_author: Peter Lebbing 
@_subject: E-mail with deniable authentication 
Either the timestamp can be faked and the repudiated document can have any
timestamp without any proof whatsoever. Both you and the supposed faker could
fake the timestamp.
Or there is a trusted timestamping service which can dependably assert the
minimum age of the document, and you have an extra hurdle to take.
You faking the timestamp has the problem that the signature is odd or doesn't
verify even during the period of time when you wish to have it validly signed.
If you never intended to convey it was true in some sense, you wouldn't sign it
at all. The purpose of a repudiable signature is to first assert validity and
only later deny it, as I understand. It is not something I know a lot about, though.
If there is a timestamping service, you need to make it credible that you had
already published the key by then. It seems credible enough by default. You
could do this from time to time (create ECC keypair, sign it with your key,
immediately publish the keypair), so it wouldn't seem out of character.

@_date: 2017-12-10 19:36:28
@_author: Peter Lebbing 
@_subject: pgpdump alternative for gpg2 
Have you tried "-v --list-packets"? I'm testing with public keys, not
private keys, but it seems to show the full data in hex.

@_date: 2017-12-13 14:05:07
@_author: Peter Lebbing 
@_subject: Upgraded gpg from 1.4.18 to 2.1.18: --default-recipient-self no 
That was simple luck, which failed you now :-). All this time, GnuPG
thought it was talking to a real person, and when it finally, after all
those years, tried to say something to that person, all GnuPG found was
a cron daemon... What a lonely moment that must have been.

@_date: 2017-12-21 22:50:08
@_author: Peter Lebbing 
@_subject: ld: symbol(s) not found for architecture x86_64 error when 
This is related to a little mistake in the declared dependencies. You'll need to
get a libassuan that is at least version 2.5.0.

@_date: 2017-12-22 20:14:05
@_author: Peter Lebbing 
@_subject: Problems reading smartcard 
I think the problem is that gpg2 is not the one doing the smartcard calls. It
spawns a gpg-agent process, which then spawns an scdaemon process. These two are
still running when you're back at the command prompt.
gpg does not do this by default, it talks to the card directly. However, after
gpg2 has spawned its helpers, these helpers are still alive, and *holding the
card reader exclusively*. So now gpg can no longer access the card reader
because scdaemon, running in the background, already has it open.
I don't know /anything/ about SELinux. But hopefully now you can look in the
right place, because I think you got sidetracked by the gpg2 process not
actually doing the business.

@_date: 2017-02-01 21:34:19
@_author: Peter Lebbing 
@_subject: Option print-md: outputlines (with CR/LF) vary depending on 
Add the option --with-colons for a machine-parseable output (colon

@_date: 2017-02-04 20:26:21
@_author: Peter Lebbing 
@_subject: Key Used to Lookup Symmetric Passphrase. 
I'd like to point out that one way of solving this completely
differently is to encrypt to a private key on your keyring rather than
using symmetric mode. Then GnuPG can trivially recognise it all can be
decrypted with cached data.
It doesn't have to be your usual OpenPGP key, you could create a key
specifically for this purpose (and set it to ownertrust never if you
will never use it to do Web of Trust stuff, just to make this fact clear
to GnuPG).

@_date: 2017-02-08 20:05:49
@_author: Peter Lebbing 
@_subject: Non-deterministic behavior using GnuPG and a smart-card 
I think it is appreciated if you actually describe the problem on the
mailing list itself rather than only linking to a website. And you're
also losing those people who would have read the mail and had an idea
but can't be bothered to chase the link.
Please provide error messages and other exact output, that gives
people more insight than "for some others no private key could be
found". And since it also happens at the command line (that's good! It
makes including everything easier), you could add -vv for verbosity or
even --debug-flags to dig deeper into the problematic encryptions.

@_date: 2017-02-09 11:08:12
@_author: Peter Lebbing 
@_subject: Non-deterministic behavior using GnuPG and a smart-card 
BTW, welcome to the list, Basil! I think it's interesting you encrypt
each and every mail you receive. That exercises all components a lot, it
might lead to some useful insights on how things might be improved. In
fact, we just encountered such an insight I think!
As a short term solution, you could revoke the encryption subkey and
create a new one with a common keylength; your current subkey is 3104
bits long for some reason, but the common keylength closest would be
3072 bits.
*However*, since you still want to decrypt mail already encrypted to the
revoked key, you would have to store an on-disk regular copy of that
subkey on your PC. If I understand correctly, you already use a regular
on-disk key on your smartphone, so this might not be a problem to you.
Changing subkey stuff has no effect on certifications; if people signed
your key, that signature will still be valid since it is on the primary
key (and an UID), subkeys are not involved in the process.
I'm curious how you ended up with 3104-bits RSA keys on your smartcard
in the first place, by the way!

@_date: 2017-02-13 12:16:40
@_author: Peter Lebbing 
@_subject: send-keys does not update my key 
An OpenPGP public key is composed of many parts which can be reordered
without changing the meaning. Keyservers do reorder stuff, so you can't
just compare two keys byte by byte and say anything useful about their
A command like
$ gpg2 --list-options show-unusable-subkeys,show-unusable-uids
--list-sigs [KEYID]
gives a pretty good overview of a public key. Here is what is on the
keyserver for you:
I've changed your e-mail address so web spam scrapers can't take it
easily. If you see all the components there really are on your key
reflected in this output, then the keyserver is already fully up to date
and any further sending of your key will not change it any further.

@_date: 2017-02-14 13:10:14
@_author: Peter Lebbing 
@_subject: Questions about --throw-keyids 
Maybe GnuPG already does this, but instead of a two-step process first
trying cached keys non-interactively and then falling back to trying
keys with prompting for passphrases, GnuPG could also simply, in one
plain standard invocation, first try all the cached secrets and when
that fails start prompting for even more secret keys.

@_date: 2017-02-15 13:34:39
@_author: Peter Lebbing 
@_subject: Expanding web-of-trust with subkey 
In addition to Kristian's answer, let me clarify:
"Ownertrust" is your assessment of how much you want to trust
certifications *done* by this person. So if this person A signed the key
of a person B, it determines whether this makes key B valid for you. It
does not relate to the validity of the key of person A!
I've written a bit about ownertrust for the keysigning party we held
last December:
In particular, the first section is relevant.
"Ultimate trust" is the odd one out and is generally only used for your
own keys. This makes the key valid even without a signature.
You could also perhaps take a look at TOFU rather than the Web of Trust.
You do need GnuPG 2.1 for that.

@_date: 2017-02-15 13:41:58
@_author: Peter Lebbing 
@_subject: Expanding web-of-trust with subkey 
Additionally, this topic is also briefly covered in the FAQ[1], which is
an up-to-date and maintained piece of documentation. The
The GNU Privacy Handbook[2] also contains interesting information, but
it hasn't been updated for a long while. It contains some outdated stuff
that makes me hesitate to actually recommend it, but the Web of Trust is
still the same.
[1] [2]

@_date: 2017-02-18 16:15:04
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
Hello Lachlan,
It failed on a trivial point: by the Friday before the congress, I had only
received four signups. A list with five keys is a poor list indeed. I switched
the model to the classic "bring keyslips" model.
I think it would work. I'd like to try again.
In fact, given that we don't need to place trust in the paper copies, I think it
would actually work if I kept sign-up open until just before the party, and
printed a stack of "scrubbed" lists myself to hand out. However, it was my
feeling that some people would not feel comfortable with this brand-spanking-new
"no need to trust me, really! Have my stuff" type of lists, so I didn't do that.
I intended to cater to the untrusting crowd by giving them enough time to print
their own lists and do it the in the usual Sassaman Efficient way.
Given that this would have, on the flip side, catered to the handful of people
who showed up without keyslips, perhaps it would still be a fair tradeoff for
limiting the untrusting people in their possibilities.
You could receive sign-ups by e-mail until the latest moment, and you would
print the untrusted lists so anybody who didn't bring any keyslips could still
be on that list by signing up.
Note that there is no value judgement in how I use "untrusting" here, it's just
a way to sum up a group of people in a single adjective.
Next opportunity for a keysigning party for me will be SHA 2017, starting the
4th of August in Zeewolde, The Netherlands[1].
O Come, All Ye Hackful! Adeste Fiddle-es[2]!
[1] [2] Fiddle-es: those who tinker.

@_date: 2017-02-19 12:19:35
@_author: Peter Lebbing 
@_subject: GPG, subkeys smartcard and computer 
Hi Stefano,
It depends on how the authorized authentication keys are added to the
server. If you just manually put them in ~/.ssh/authorized_keys, sure,
no problem. But Andrew did just write:
I have no personal experience, but I think it's possible this relates to
MonkeySphere handling the authorized keys on the server?

@_date: 2017-02-19 15:11:45
@_author: Peter Lebbing 
@_subject: GPG, subkeys smartcard and computer 
Thanks for the clarification.
Only one way to get this knowledge to the surface: we obviously need to
advise everybody to generate multiple A subkeys so somebody will
complain it doesn't work! Just kidding :).
I agree. I can't think of a compelling reason to use multiple ones; all
things considered, the added hassle is the larger factor in every
scenario I could think of just now. If you can't duplicate your A or S
subkey when you want to, for instance because you have it on smartcard
only, it's just as easy to create a new key and overwrite the old one on
the smart card. Then you can just use your new subkey everywhere from
now on. Just watch out you do it in the right order with respect to A
keys: first roll out the new key on all systems you want to authenticate
to, and only then overwrite your old key on your smartcard :-).
However, maybe someone has come across a reason to do it where it would
be worth the hassle. There certainly are people using multiple S subkeys.

@_date: 2017-02-20 17:49:55
@_author: Peter Lebbing 
@_subject: GPG, subkeys smartcard and computer 
Well, if you use only one, "revoke all" is still "revoke one" ;). It's not the
revocation step that gets any bigger, it's just that you need to roll out the
new key to all your client systems instead of just the server systems.
Personally, the number of server systems I use is way larger than the number of
client systems. Over all, I don't think it's that much more work, given it's a
rare occurence anyway (I hope).
With A per system:
1) Create new key on compromised system
2) Roll out new key to all server systems
3) Revoke old key on all server systems
With just one A:
1) Create new key
2) Roll out new key to all client systems
3) Roll out new key to all server systems
4) Revoke old key on all server systems
Steps 3 and 4 are more work than step 2. I have login credentials for at least
11 systems off the top of my head, yet only 3 client devices I regularly use [1].
When all your server systems automatically pick up on OpenPGP auth subkeys from
a keyserver, or when you use OpenSSH's CA mechanism, steps 3) and 4) are pretty
much automatic, in which case indeed step 2) would dominate and one key per
device once again wins.
So perhaps one key per device is superior, also for detecting which client
system was compromised by looking at the SSH auth logs on the server (supposing
the attacker didn't gain root privileges and wiped his traces immediately). But
I think it's not a very significant difference, or did I miss a scenario?
My 2 cents,
[1] However, I have four different auth keys on those clients, three on-disk,
one per system and one smartcard I only use on a single one of those systems. I
actually use one key per client, but note that I don't have multiple A-capable
OpenPGP subkeys. All my on-disk keys are just regular ol' OpenSSH keys, and I
think then one key per device is a much cleaner setup indeed.

@_date: 2017-02-20 17:58:01
@_author: Peter Lebbing 
@_subject: Hybrid keysigning party, your opinion? 
Thank you for organizing a party! I'm definitely up for assisting with the
I'd first have to look up on the FOSDEM format. The QR codes are indeed a nice
addition, however, it is inherently restricted to just a part of the attendees.
I don't trust my phone with my certifications, and holding a laptop with webcam
is really awkward and I might even drop it.
Normally I'd leave my certification-capable smartcard at home as well.

@_date: 2017-02-21 14:21:25
@_author: Peter Lebbing 
@_subject: GPG, subkeys smartcard and computer 
Revoking the old A key and creating a new one needs to happen on the
system you have the primary key on, so you need to subsequently roll out
the new A key to the compromised device. Obviously I assume the primary
key was not available on the compromised device, because then the whole
certificate would have to be revoked. I don't see much extra effort in
rolling it out to the few other systems you use as a client as well.
Also, I think you need to have a way to notify servers that they need to
get an updated certificate including the revoked old key *right* *now*.
We're talking about a compromised A key! The attacker has full access to
your login account for the time that the servers haven't checked for a
new key yet! Regular intervals just won't do. This looks to be the
painful step in the process.
The exception might be a private keyserver that gets hammered by all the
SSH servers every 10 minutes to check whether any updated keys were
uploaded. I don't think it'd be kind to do that to a public keyserver.
I'm not saying an A key per device is bad. Or even that it is not as
good as one A key. I'm just saying that, given you need to transfer
private keys anyway I don't think there's a significant difference in
practice. You can't generate these new A subkeys on the client device
itself, because it will not have the primary key of the OpenPGP
certificate. This is where the difference with plain old OpenSSH private
keys pops up: those you just generate on the client device itself and
you never have to worry about exporting and importing private keys at
all. In addition, it means you can then say "I'd never login to this
server from this client, so it needs not be in the authorized_keys
file". This kind of discrimination that provides defence in depth is not
possible with A subkeys on an OpenPGP certificate that get automatically
picked up by the servers, since they will always accept all A subkeys on
the certificate. So you lose that etra possibility you had with plain
SSH keys per client device.
PS: I realised that you can't even generate the A key on the previously
compromised system only after I'd written my previous mail. So the two
stepwise processes should have been:
With A per system:
1) Create new key
2) Roll out new key to compromised system
3) Roll out new key to all server systems
4) Revoke old key on all server systems
With just one A:
1) Create new key
2) Roll out new key to all client systems
3) Roll out new key to all server systems
4) Revoke old key on all server systems
However, since Kristian is placing it in the context of servers
automatically fetching keys, it could be:
With A per system:
1) Create new key, revoke old
2) Roll out new key to compromised system
3) Poke every server system that they need to refresh *now*
With just one A:
1) Create new key, revoke old
2) Roll out new key to all client systems
3) Poke every server system that they need to refresh *now*

@_date: 2017-02-21 15:15:09
@_author: Peter Lebbing 
@_subject: GPG, subkeys smartcard and computer 
Since I assumed you were siting behind a trusted machine with your
primary key installed when you revoke, it made no sense to me to just
revoke the key and not create a new one, as you are sitting there in
"gpg --edit-key" with your primary unlocked anyway.
But the rest of the mail makes clear this was not your assumption.
Yes, I had kinda assumed that this was not the level of trickery we were
willing to go to when suggesting people to use multiple A subkeys. It's
not even a feature of GnuPG, it's just being clever.
I did assume that you need the primary to do the revocations, as GnuPG
does not support revocation certificates for subkeys. So I assumed you
could only mitigate the compromise when seated behind your most trusted
system, or something to that effect.
I suppose we were working with different definitions of "compromise".
Yours makes more sense. Mine was too narrow.
If Kristian Fiskerstrand says it's okay for SSH servers to refresh their
keyring every 20 or 30 minutes from the public keyserver netowrk, then I
guess it really is :-). I had estimated it as inappropriate.
Okay, you have convinced me. To deal with the pyhsical loss of a device
or the medium holding the private key, it makes sense to create an
OpenPGP auth-capable subkey per device. However, the revocation trickery
limits its user-friendliness in a big way.
Thanks for expanding my understanding of this area.
It's still not for me though. I often need to be able to grant access on
a per-client basis. I try to limit access to accounts to client devices
where I actually need it, to somewhat limit the consequences of a single
client machine being compromised. It's not a panacea, more of a defense
in depth thing.

@_date: 2017-02-21 16:13:18
@_author: Peter Lebbing 
@_subject: Problems with cert validation via CRL 
Reading that part made me think it couldn't find the issuer of the CRL:
When I fetch the CRL we're talking about, OpenSSL tells me about it:
The issuer is the certificate that gpgsm knows about:
I suspect that even though gpgsm knows about it, dirmngr might not,
hence the failing CRL verification. I think you need to feed the
certificate to dirmngr as well.
Whether this is actually the reason you're having problems, I don't know.

@_date: 2017-02-21 16:17:10
@_author: Peter Lebbing 
@_subject: GPG, subkeys smartcard and computer 
Not for multi-user systems with many accounts; it would only be the case
for personal servers. Is a personal server really "normally" the place
monkeysphere is deployed?

@_date: 2017-02-21 16:23:27
@_author: Peter Lebbing 
@_subject: GPG, subkeys smartcard and computer 
But if an attacker can cut off your SSH servers from the keyserver, and
your SSH servers fail open, meaning that they conclude the old data is
still valid when it can't get new data, an attacker can keep using a
compromised and revoked subkey without the server noticing the
revocation in time.
It all depends on your threat model.
My 2 cents,
PS: Actually, on reflection, not /my/ 2 cents. I'm just repeating what
Kristian said earlier with some more words attached.

@_date: 2017-02-22 13:56:22
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
Hello Gerd!
Thank you for sharing your program with the world! I'm sure it will be
I beg to differ. Following your instructions, my PDF is 208 pages long!
The certificate (aka public key) includes all signatures, all the data
on the keyserver. It's data you don't really need to back up since it is
public, and it can be huge. My key.asc file is 137,424 bytes following
your instructions.
Additionally, --export-secret-key actually includes everything from
--export, it just *adds* the secret key material to it. So there is no
need to do both --export and --export-secret-key; it just doubles the
information from --export.
What you're probably looking for is:
$ gpg2 --armour --output key.asc --export-options export-minimal
--export-secret-key [KEYID]
$ paperbackup.py key.asc
$ paperrestore.sh key.asc.pdf | diff key.asc -
$ lpr key.asc.pdf
However, I'm running into a little problem here myself... GnuPG 2.1.18
does not respect the "export-minimal" option for --export-secret-key,
only for --export. So if you are using GnuPG 2.1, this will not work as
This is in all likelihood a bug in GnuPG 2.1, and I'll report it right now.
Leaving aside this bug, export-minimal will achieve your goal: it will
only include the currently valid parts of the key without any
certifications by other keys. It is all you need to have a working key.
The certifications by other keys are on the keyservers.
Oh, as an aside, the advantage of paperkey is that it is
self-describing. No matter what happens, as long as we can still use
hexadecimal digits to describe binary content (which would be trivial to
reimplement), we can reconstruct the binary private key file. Using QR
codes has the disadvantage that if you cannot find a QR-code decoder for
your platform in the future, reimplementing one is far from trivial. You
are dependent on QR codes surviving as an actually supported data format.
Finally, I remember something about QR codes inherently supporting
splitting data over multiple individual code blocks, specifically for
data that is too large to fit in a single block. I don't know if it
supports the number of blocks you need, but you might want to check it
out. Also, you say large QR codes are easily damaged by wrinkles and
deformations. Is this perhaps related to the amount of error correction
data included? You can tune the ratio of content data to error
correction data, making a QR code more resilient to damage. However, if
you find that it is not unreadable individual pixels but rather the
deformation of the total that is throwing off decoders, than I suppose
the ratio doesn't help: it either can reduce it to the required square
or it cannot, I'd think.

@_date: 2017-02-22 14:12:31
@_author: Peter Lebbing 
@_subject: export-minimal doesn't affect export-secret-key? 
I just found out that the following two commands are equivalent:
I thought "well this is surely a bug in the new 2.1, what with the new
secret key storage". But:
And now I'm confused... surely export-minimal is useful when backing up
your secret key and storage is limited? We just encountered this with
the paperbackup.py thread...
This works fine, BTW:

@_date: 2017-02-22 14:18:15
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
Whoops! I made a mistake here.
export-minimal does not remove "parts of the key that are currently not
valid". I wrote that, immediately thought "I don't know that", looked it
up and edited my text accordingly. Except I forgot to change this
sentence. The quote should have read:

@_date: 2017-02-22 20:23:26
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
I understand that. However, let me point out that any errors parsing
will only occur while *creating* a backup with paperkey. Once it
succesfully parses the data, the result can be used without the program,
it is stand-alone and complete. No further "parsing errors" can occur.
Rejoining the private key can be done by hand.
Could you share a bit more details about the error you encountered? If
it is a problem with paperkey, I think we (as a community) would like to
know about it and hopefully fix it.
All public data can be scattered all over the world and the internet,
and backed up and replicated in all manner of forms for resiliency.
In theory this goes for a private key with a good passphrase as well,
but that moves the point of failure to remembering the passphrase.
paperkey however can be used without a passphrase, and the result should
be guarded really well, unlike all the public data.
I'm not trying to convince you to do something differently than you do
now, I'm just trying to make the picture more complete. However, it
seems your solution to your use case depends on there being few
signatures on a key, as evidenced by my key needing 104 pages (that's
without the unnecessary duplication that resulted in the 208 pages I
mentioned earlier). I would not enjoy the amount of room this book
occupies in my safe, or scanning it.
Hmmmmm....... once we have export-minimal for --export-secret-key :-).
You might consider using a font designed for OCR rather than the current
Additionally, base64 has look-alike characters, and the only checksum is
for the whole key. So if it says "checksum failed" you've only learned
that factoid. A checksum per line would be better, so you can say
"checksum failed in line n".
Yep. But if you trust GnuPG, and you have a paper backup of your OpenPGP
key, you could encrypt a copy of your SSH key with your OpenPGP key and
publish the encrypted file. Then as long as you have a paper backup of
your OpenPGP encryption subkey, you can just fetch and decrypt the SSH
key. This by the way goes for any piece of data, no matter how large,
including all the videos you shot of your children while they grew up
and would really dread to lose. Just encrypt them, back them up with
several backup providers online, and as long as your paper backup of
your OpenPGP key survives, so do the videos. It might even provide that
little extra motivation to be extra sure the backup of your OpenPGP key
can be depended on, now that you really do depend on it for something
you care deeply about! ;-D

@_date: 2017-02-22 20:34:22
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
It is not an internal packet format by the way, it is defined in RFC
4880 (OpenPGP Message Format). And all GnuPG versions output their keys
formatted according to OpenPGP, so the problem you're experiencing is
more subtle.

@_date: 2017-02-23 19:48:13
@_author: Peter Lebbing 
@_subject: SHA1 collision found 
I already answered that here[1]. The use of SHA-1 in fingerprints is not
susceptible to a collision attack, so it's still safe. SHA-1 in
fingerprints is only susceptible to a second-preimage attack which is
much harder than a collision attack and unheard of for SHA-1.
It wouldn't help because of all the places SHA-1 is used internally if
you just change how it is displayed to the user. Disclaimer: I'm not a
developer, but this is my understanding of it. I can't say for sure.
[1]

@_date: 2017-02-24 11:32:33
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
More people trust that that key is mine, they don't trust me as a
person, my actions or my certifications. dkg already answered that bit
:-). These are mostly people I've met at a keysigning party. They have
seen my passport and asserted that "Peter Lebbing" is as far as they can
tell indeed the person in possession of that key. They don't trust me
more than the next guy, because they don't know me personally.
If there is still software that can work with OpenPGP v4 keys, then you
can restore your private key from your paperkey-style backup. If there
is no more software that can work with OpenPGP v4 keys, what are you
going to do with your restored private key? Frame it and put it on the
wall? ;-)
Understood. Good to see you've thought it through.
Given the size of those QR codes on paper, you could use a camera that
is so elderly it has developed presbyopia and cataract and still scan
them succesfully! :-D

@_date: 2017-02-24 17:17:01
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
Yes, it should be easy to use. In fact, I've sometimes heard the complaint that "paperkey is not easy to install and/or use". That's really too bad that those people feel that way.
It took me some fiddling... but using CRC RevEng[1] I got a checksum in Python that is compatible to POSIX cksum.
The following Python:
generates the same checksums as the following Bash code:
$ printf $(printf '%08x' $(echo -n 123456789 | cksum | cut -d' ' -f1) | sed 's/../\\x\0/g')|base64|cut -b-4
This is done with the attached Python code. It is written for compactness rather than speed. Just re-implementing the crc function would probably be quicker.
[1]

@_date: 2017-02-24 17:21:38
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
Crap, silly me... why do I always notice these things only after I've
hit send?
Let's make that:
And this one:
$ printf $(printf '%08x' $(echo -n 123456789 | cksum | cut -d' ' -f1) |
sed 's/../\\x\0/g')|base64|cut -b-6
Oh, and by the way, when the python module is invoked as the main
module, it mimics the working of cksum, so the following two are roughly
$ cksum *.c
$ posixcksum.py *.c

@_date: 2017-02-25 16:26:34
@_author: Peter Lebbing 
@_subject: export-minimal doesn't affect export-secret-key? 
I'd like to add to the bug report that I also observe this behaviour
with GnuPG 1.4.18 on Debian jessie/stable (package 1.4.18-7+deb8u3) and
GnuPG 2.0.26 on the same (package 2.0.26-6+deb8u1). So it is not just 2.1.
However, I think I can't actually add that to the bug report myself
because I only just created an account on bugs.gnupg.org :-).

@_date: 2017-02-26 12:01:05
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
By the way, don't worry about the license. I just slapped it on there
because you need /something/. (I didn't even look at paperbackup.py's
license, which was dumb, I would have put an MIT license on it otherwise.)
If you're going to use it, I assume you're just going to embed the few
lines of code there are into paperbackup.py. You have my permission to
use the code in posixcksum.py in paperbackup.py *without attribution*.
You don't have to name me, just use it.

@_date: 2017-02-27 13:30:13
@_author: Peter Lebbing 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
Yes, that should work just as well in practice, I think. 24 bits of
checksum is slightly weaker than 32, but I don't think it matters.
I doubt CRC-32 would be worse than 32 bits of MD5, since CRC-32 is
designed to catch accidental errors[1]. I don't know how a CRC-32
truncated to 24 bits would behave. A truncated MD5 should be fine for
detecting accidental errors, though.
So I think the three initial bytes of an MD5 would work well to detect
typing errors.
[1] Although it's probably better at physical noise in the transfer of
individual bits than typing mistakes in base64 data.

@_date: 2017-01-04 14:53:35
@_author: Peter Lebbing 
@_subject: Meaning of "text user ID's"? 
Hash: SHA256
I'm signing keys after a keysigning party, using GnuPG 2.1.16. Issuing

@_date: 2017-01-04 14:58:27
@_author: Peter Lebbing 
@_subject: Meaning of "text user ID's"? 
(Ah, isn't that nice, Enigmail reformats the message when I do a signature.
Manually restored some sanity)
I'm signing keys after a keysigning party, using GnuPG 2.1.16. Issuing
--edit-key sign, I'm asked:
"Really sign all text user IDs? (y/N)"
Now here's what I see (anonymized):
So how come that the jpeg image is about to be signed as well? What does "TEXT
user ID" mean? I would have expected only the other UID's to be signed. Is this
a bug in my head or in the code?
PS: Alice is Bob's forebear.

@_date: 2017-01-04 15:00:39
@_author: Peter Lebbing 
@_subject: Meaning of "text user ID's"? 
First and foremost, that it was actually signed when I agreed. I deleted the
signature afterwards.
Secondly, I just posted again with a bit more readable text :-). You can clearly
see it is proposing to do it.

@_date: 2017-01-04 18:51:49
@_author: Peter Lebbing 
@_subject: gpg-agent has to be restarted after GnuPG SmartCard pulled from 
I think you should be able to use this card reader without pcscd, using the
internal CCID driver of GnuPG[1]. Just stop and disable pcscd, hopefully GnuPG
will find the reader and use it right away. That might solve your problem. I use
GnuPG's internal CCID driver, and it is completely resilient against both
pulling the card as well as unplugging the reader.
[1]

@_date: 2017-01-08 18:29:56
@_author: Peter Lebbing 
@_subject: fetch yields "rejected by import filter" 
So what happens when you invoke
$ gpg2 -v --fetch-key [URL]?
Or for even more verbosity, do -vv.

@_date: 2017-01-09 10:25:03
@_author: Peter Lebbing 
@_subject: fetch yields "rejected by import filter" 
Or keys...
Perhaps GnuPG somehow thinks that the downloaded key does not match the
key on card, and that is the reason it rejects the key by an "import
Could you either simply post the public key stuff and public output of
gpg about this key, or otherwise anonymise it in such a way that we can
still see the correspondences between key ID's?

@_date: 2017-01-17 12:10:53
@_author: Peter Lebbing 
@_subject: Primary and Signing Key on Different Smart Cards 
Hello Anton,
I did that with Debian package 2.1.11-7.
Ah, that sounds like a likely culprit to me. I've thought more often
that scdaemon would be improved if it handled missing and changed
readers exactly the same as missing or changed smartcards.
I can't think of a way to solve this right now.
Yes, multiple reader support is a work in progress.
Something like:
debug-level expert
log-file /home//scdaemon.log
added to $GNUPGHOME/scdaemon.conf could help. But note that it may
contain the card PIN in the APDU dumps! The easiest way, IMHO, to
prevent leaking private data is to use a PIN like 123456 for your tests,
and only when you've got it working do it all for real with a real PIN
and real OpenPGP keys and *no more logs*. This also prevents leaking
your PIN to your storage or your backups for instance, which could be a
problem depending on your threat model.
I've never had any luck with anything other than a plain absolute path
for the log-file directive, so I'm always just writing them out completely.
(Similar debug log directives are available for other components)

@_date: 2017-01-17 12:23:09
@_author: Peter Lebbing 
@_subject: Feature request: treat missing smartcard reader as missing smartcard 
Hi devs,
I think scdaemon would behave more predictably and more *correct* if it
treated a missing or changed card reader as a missing or changed card.
For instance, if I open an encrypted mail in Thunderbird/Enigmail, I see
the following:
- Card reader is plugged in but no card or different card present in reader:
I am prompted to insert the correct OpenPGP card. Once I do this and
okay the prompt, decryption is succesful.
- Card reader not plugged in:
Empty message window with Enigmail error on the lines of "Decryption
failed. No secret key available."
These days, it is quite common to see readers with either integrated
smartcards or smartcards that can't be changed or removed easily. I
think these devices should be treated as currently the smartcard is.
I.e., if the reader is not plugged in, prompt the user to insert their
smartcard just like scdaemon would if the reader were present but empty.
I think this is also the reason why in this[1] mail to gnupg-users,
Anton is not able to do the same procedure as I could. I used a desktop
smartcard reader and two regular OpenPGP cards. Anton used one regular
OpenPGP card and one Yubikey. Where I was prompted to change cards, his
attempt likely failed because he had to swap *readers* as well as cards.
[1]

@_date: 2017-01-17 20:51:45
@_author: Peter Lebbing 
@_subject: Trust signature domain 
Seems like an extended regexp with a mistake. The dot would actually match any
character, it needs to be quoted:
<[^>]+ at example\.net>$
(and quoted even further if provided through a shell).
I hope I didn't miss any other mistakes.
(I haven't actually tried to do anything at all with trust signatures, I just
noticed a mistake while reading your message.)

@_date: 2017-01-18 15:55:14
@_author: Peter Lebbing 
@_subject: Did I break my Ubuntu GPG installation? 
What was the command line you used to invoke gpg? It looks like it is
expecting you to type in an OpenPGP message, i.e., one that begins with
"-----BEGIN PGP MESSAGE-----" for example. "test" is not valid OpenPGP
data. I think you made a mistake in the invocation.
A test for encrypting and decrypting stuff from the command line looks
something like this:
$ echo Hello >test.txt
$ gpg -r stefan.boehringer at posteo.de -e test.txt
$ rm test.txt
$ gpg test.txt.gpg
And at the end, you'll have your test.txt back. If (like me) you think
pipes are cool, try this:
$ echo Hello | gpg -r stefan.boehringer at posteo.de -e | gpg

@_date: 2017-01-18 16:02:25
@_author: Peter Lebbing 
@_subject: Feature request: treat missing smartcard reader as missing 
Ah, two birds with one stone! Thank you for working on multi-card-reader
I'm real happy to hear that! Thank you! I love the improvements GnuPG
2.1 brings!

@_date: 2017-01-21 11:55:46
@_author: Peter Lebbing 
@_subject: Choosing between multiple signing keys 
You should append a ! to the key ID. This specifies you want this specific key and not the keyset to which it belongs.

@_date: 2017-01-23 12:22:19
@_author: Peter Lebbing 
@_subject: Changing passphrase parameters (s2k options) 
GnuPG 2.1 handles the private key in a completely different manner than
earlier versions. I couldn't find any other configurable things than the
s2k-count. Look at the difference between the man page for 2.1.16 and
It's close to what you're talking about, but not exactly. That is
specifically about *exporting* an OpenPGP secret key, not how it is
*stored* in your keyring. The protection on private-keys-v1.d is
implemented differently than the protection of the OpenPGP standard
which is used for export.

@_date: 2017-01-23 13:34:46
@_author: Peter Lebbing 
@_subject: Changing passphrase parameters (s2k options) 
No, I meant that the bug report (turned feature request) is about
choosing the options for export. As long as the bug is open, it's not
possible to change it for export either.
However, in your initial mail you said:
the key is stored in the keyring, not about exporting the secret key.
What are you trying to do? Change the encryption on an exported private
key or changing the encryption of the private key store of GnuPG?
(FWIW, I don't think you can currently do either. Possibly you can
change the s2k-count via the agent protocol, but that might not pertain
to the private key store, I just don't know).

@_date: 2017-01-25 12:14:53
@_author: Peter Lebbing 
@_subject: gnupg website 
The OP might have meant "OCSP Stapling" which includes the OCSP data in
the data sent by the webserver during TLS session setup. That way, the
OCSP data doesn't need to be fetched from an OCSP server, which would
leak the fact a certain website certificate is being verified to the
OCSP server.
OCSP (without stapling) is already possible for the gnupg.org website

@_date: 2017-01-26 10:56:18
@_author: Peter Lebbing 
@_subject: sha1 pgp fingerprint 
Subverting SHA-1 as used for OpenPGP fingerprints requires a
second-preimage attack. The problems with SHA-1 are with collision
resistance, not preimage attacks.

@_date: 2017-01-27 14:10:31
@_author: Peter Lebbing 
@_subject: I'm confused about GPG, and it's confused about me 
This merely shows the content of a file on your disk.
To sign a key, you need to have it in your keyring. However, based on
I'm thinking you're trying to sign your own key, which is not something
that can be done. There is the so-called self-signature, but it is not
done by --sign-key but rather by changing some aspect of your key with
It would appear (because it asks for a passphrase) that your system has
this private key in its keyring.
You are asking GnuPG to issue a detached signature on a file in your
current directory called REIDgpg. This file appears not to exist.
The man pages are reference manuals, not introductory texts. They are
indeed opaque if you're trying to learn how to do stuff on the command
line. [1] is better, but it is old. I must admit I'm not really well
acquainted with introductory texts.
You can see which private keys your system has in its keyring by
$ gpg -K
And it would appear you have multiple since GnuPG complains "no default
secret key".
What are you trying to do? Please try to indicate the end rather than
the means. When you say "I want to sign key A780EFF6" it is not clear to
me what you are trying to accomplish by that. Do you want to make that
key valid? If it's your own key, that won't work. That's for making
other people's keys valid. Your own key should have its trust level set
to "ultimate" to make it valid. This is something that GnuPG does
automatically when creating a key, but not when importing a secret key
that was created with a different GnuPG installation.
Hope that helps a little bit,
[1]

@_date: 2017-01-27 14:16:15
@_author: Peter Lebbing 
@_subject: I'm confused about GPG, and it's confused about me 
Whoops, left out part of my answer.
I'm sorry to hear you are having such trouble getting it to work! That's
a pretty bad first user experience.
Are you doing this on a virtual machine? Certain virtual machine
deployments have trouble gathering randomness, which prevents generating
keys. Other than that, these programs should just have worked. Odd...
I don't fully understand. Are you trying to send someone else an
encrypted document, and are you encountering the situation that GnuPG is
warning you that there is no indication that the key belongs to the

@_date: 2017-01-28 22:37:22
@_author: Peter Lebbing 
@_subject: Trojan detected in Windows 10 Simple Installer for GnuPG Modern 
This is indeed truly the file signed by Werner's dist sig key:
$ gpg2 --verify gnupg-w32-2.1.18_20170123.exe{.sig,}
gpg: Signature made Mon 23 Jan 2017 22:12:23 CET
gpg:                using RSA key D8692123C4065DEA5E0F3AB5249B39D24F25E3B6
gpg: Good signature from "Werner Koch (dist sig)" [full]
gpg: werner koch (dist sig): Verified 1 signature in the past 5 minutes, and
     encrypted 0 messages.
$ sha256sum gnupg-w32-2.1.18_20170123.exe
1fd01e24f65465dfd075b8ad55a58eaee13e79c02c42096c325a7ccf5a1eb283  gnupg-w32-2.1.18_20170123.exe
(albeit that you accidentally typed a 9 in the date in the filename)
I suspect it's a false positive, but somebody else will need to check.

@_date: 2017-01-30 10:46:14
@_author: Peter Lebbing 
@_subject: gnupg website 
It just occured to me that it seems you're conflating bits and bytes.
Doesn't a 64-bit-block cipher operate on 2**3 rather than 2**6 bytes?
That would make it 2**35 bytes or 32 GiB. It would be 256 gibibit rather
than gibibyte.

@_date: 2017-01-30 11:48:46
@_author: Peter Lebbing 
@_subject: I'm confused about GPG, and it's confused about me 
First off, two questions:
Why are you using GnuPG 1.4 by the way? It's generally only recommended
for server deployments rather than end-users. For desktop use, 2.0 and
2.1 are often a better choice.
And are you sure GnuPG 1.4 is the only GnuPG on your system? 1.4 and 2.0
will happily work together, but 2.1 doesn't combine well with 1.4. If
some of the tools you use actually use 2.1 and others use 1.4, confusion
may arise.
Often, GnuPG 1.4 will nonetheless be installed on your Linux system. For
instance, the package manager might use it to verify the signatures on
the package lists of your distribution. This is another use case for
1.4: not for the people with user accounts but for the system itself.
If you don't have anything worthwhile in your GnuPG installation, you
could radically start anew by just
$ cd ~
$ rm -r .gnupg
$ gpg --gen-key
and follow the prompts. In your setup, you would do it twice, once for
both e-mail addresses. However, note that you could also create one key
and associate both e-mail addresses with that one key. Many people have
one key to rule them all, with as many associated identities as they like.
A lot can be said on key expiry and revocation certificates. I'm going
to be brief and without justification recommend a key expiry of 2 years
and generating and keeping safe a revocation certificate with for example:
$ gpg -o revoc.asc --gen-revoke [KEYID]
Give no reason and no comment, since you don't know right now why you
might use it in the future.
If you generated a key, it will just be available on your keyring and
already be valid. Trust needs to anchor somewhere, there has to be some
initial step where you simply state "this is trusted". For OpenPGP,
that's on your own keys. With GnuPG, this is done by assigning
"ultimate" ownertrust to keys (here, your own keys). So you don't need
to sign your own keys if it is just for your own consumption. You could
still sign your own keys with your other own keys to indicate to other
people that you are saying you are really you. (You have to love the
sentences you get when talking about your multiple disjoint identities! :-)
If however you need to spread your own keys to several of your own
systems, you'd use
$ gpg -o my_sec.gpg --export-secret-key [KEYID]
then transfer my_sec.gpg to the second system and there:
$ gpg --import my_sec.gpg
followed by (this is important):
$ gpg --edit-key [KEYID] trust
and assigning ultimate trust to the imported key. GnuPG does this
automatically for keys /created/, not for keys /imported/. In general,
do this just for your own keys.
If you will habitually use one key and only incidentally the other,
you'd put the following in your gpg.conf:
default-key [KEYID]
This will tell GnuPG that of the several private keys, it should use
that one to make signatures. If you have only one private key (even if
it has multiple associated identities, one for GMail, one for Runbox),
you do not need this.
To encrypt to your GMail account from the command-line, do:
$ echo Hi to myself >test.txt
$ gpg -r rsv869 at gmail.com -e test.txt
You now have an encrypted file test.txt.gpg. You are not prompted for a
passphrase since this is a public-key-only operation: it just needs the
public key of rsv869 at gmail.com, which is not encrypted data. However, if
you also want to sign with rsv869 at runbox.com, you'd do:
$ gpg -u rsv869 at runbox.com -r rsv869 at gmail.com -se test.txt
Now it will ask for a passphrase since you are signing it with the
Runbox key. If you had the Runbox key as a default-key in gpg.conf, you
could simply do:
$ gpg -r rsv869 at gmail.com -se test.txt
If there is a default-key in gpg.conf but you wish to sign using the
other this time, use the -u [KEYID] to choose which key to sign with.
To decrypt this file, you'd do:
$ gpg test.txt.gpg
which will prompt for the GMail key passphrase because that is the key
it was encrypted to. It will deliver a file called test.txt, and if it
was signed, it'll say so in the output.
Hopefully this helps you get started a bit.
Note that if you decide you want one key with both e-mail accounts
associated, you would add the second identity with:
$ gpg --edit-key [KEYID] adduid
You can just encrypt to yourself even with just one key, but if you
want, you can also send me an encrypted mail off-list and I will tell
you whether it could be decrypted or not.

@_date: 2017-07-04 21:37:05
@_author: Peter Lebbing 
@_subject: [Announce] Libgcrypt 1.7.8 released to fix CVE-2017-7526 
I think you need to see it in the context of this part of the announcement:
If you're worried about cross-VM crypto attacks, perhaps host your essential
crypto on a box that doesn't host potentially hostile VM's. Security has its
cost, or: there's no such thing as a free lunch.

@_date: 2017-07-11 16:50:06
@_author: Peter Lebbing 
@_subject: Changing PINs of German bank card 
But you were discussing both card PINs as well as web passwords with low
entropy, right? You said earlier:
I still don't think you could brute-force it with just two tries in
between your regular logins. However, this seems like a nice DoS if
someone dislikes you and is mean-spirited. They get a hold of your bank
account number, attempt to log in with the three password guesses "say",
"bye" and "now" and you need to phone up your bank, they need to send
you a new letter with a new password, etcetera. Or is there some other
secret or semi-secret, like a card number, that an attacker needs to
enter in order to decrement the failure counter?
This "three strikes and you're out" scheme is generally for two-factor
auth, not for regular web passwords. For a reason.

@_date: 2017-07-12 12:10:12
@_author: Peter Lebbing 
@_subject: Changing PINs of German bank card 
When my bank card is replaced because its validity is about to end, the
new card has the same PIN as the old one. I can't readily think of a way
to do that without the bank knowing my PIN, since the new card didn't
physically exist yet when the old card got its copy of the PIN.[1]
Furthermore, I see no use to the bank not knowing my PIN. If their
backend got hacked, these random 4 digits being public knowledge are the
least of the problems.
And since a pin has so low entropy, I don't see how to protect it with a
hash. Any system that can verify correctness in the time it takes to do
a PIN payment[2] can do 10,000 guesses in reasonable time.
Also, back when you could do payments with the magstripe (which, AFAIK,
can still be done in some countries, using your Dutch bank card, if you
allow it), the PIN necessarily went to the bank, there was no way for a
check by the chip in the card.
Anyway, I'm still writing this even though I questioned its usefulness.
But let's consider whether this thread really needs to go on much
longer, it seems it has run its course and is now turning into a wide
trickling delta that is no longer hurrying towards its destination but
rather seeking the path of least resistance in any random direction :-).
[1] Barring any neat trickery like waiting for me to enter my PIN and
listening in so they can then program the new card.
[2] That's what they're called in The Netherlands. Well, PIN-betaling
actually, I did translate.

@_date: 2017-07-13 12:50:22
@_author: Peter Lebbing 
@_subject: [HELP] pinentry-curses breaks SSH auth, but pinentry-mac works 
Note how Debian handles system-wide, system-specific pinentry alternatives:
If you use just "pinentry" or "pinentry-x11", you then use the
alternatives system to select a specific one:
* 0            /usr/bin/pinentry-gtk-2    85        auto mode
  1            /usr/bin/pinentry-curses   50        manual mode
  2            /usr/bin/pinentry-gtk-2    85        manual mode
Press enter to keep the current choice[*], or type selection number:
--8<---------------cut here---------------end--------------->8---
It might give you an idea how to do it for you. I suspect it might even
work if you wrap your pinentry in a shell script using if [ "$(uname)"
but it lacks elegance.
You could also use SSH's X forwarding. I haven't tried that, though.
Hmmm, an understandable knee-jerk response. Knees don't always do your
best thinking, though.

@_date: 2017-07-14 20:56:46
@_author: Peter Lebbing 
@_subject: A Quick Supplement 
There's an option missing that could cause data loss in its absence:
$ gpg --armor --export > pub.asc
I'd make that:
$ gpg --armor --export-options export-local-sigs --export >pub.asc
If you have made any signatures that are not exportable (so lsign and
friends), they would not be exported otherwise. That is obviously what
it is for, but if you do this to make a backup of your own keyring, you
would still want to keep those.
And symmetrically, you'll want
$ gpg --import-options import-local-sigs --import pub.asc

@_date: 2017-07-16 21:54:38
@_author: Peter Lebbing 
@_subject: use policy of the GnuPG-card 
I don't think a decryption counter makes sense as you'll decrypt the
same data multiple times (a signature is made only once).
An authentication counter would make more sense. However, you can't
collect all authentications you've ever done. You could collect all the
signatures you do and compare the number of results.

@_date: 2017-07-17 10:24:59
@_author: Peter Lebbing 
@_subject: A Quick Supplement 
Yes, instead of, not in addition to. The export-local-sigs will add the
local sigs, the other non-local sigs will still be there as well.
Yes, just use what you want to use, GnuPG v1.4, v2.0 and v2.1 all
support it, if I remember correctly.
I'm not sure if Rob's routine actually backs up local signatures... I
couldn't see anything explicit about it with a quick glance at the code.
That's fine if you don't use local signatures at all.

@_date: 2017-07-19 11:50:29
@_author: Peter Lebbing 
@_subject: gpg-agent/pinentry: How to verify calling application 
Hah, that's not helpful, thanks, systemd! All we've learned is that
whatever is invoking gpg2 is using systemd for that, I suppose. Well,
*that* narrows it down! Perhaps you can find something with journalctl,
which allows you to read systemd logs, I dunno. I'm still pretty new to
the systemd world. I do intend to learn.
I never use pstree, I use ps's "f" (forest) option. Does that show the
same thing? If you just add the "f" to your options, it would be ps
faux, sounds French fake but will work :-). Is there anything
informative in the full command line of those systemd processes?
That is a lot more informative. I believe kwallet is the credential
manager for KDE, keeping passwords and stuff.
I've got two guesses:
1) At some point you permitted kwallet to encrypt all your credentials
using your OpenPGP key. It is simply trying to decrypt your "wallet" so
it can be accessed.
2) It wants to add your private key to its credentials and manage it for
you from now on.
1) is pretty benign and actually cool, 2) might not be to your liking at
all. Personally, my neck hair rises remembering the way gnome-keyring
"interacted" with GnuPG back in the day. This is water under the bridge
now, gnome-keyring is a fine citizen again these days, and I thank them
for that.
However, I don't know kwallet other than its basic function. I hope my
contribution helps you along, small as it is.
PS: I just had a similar thing the other day where an ssh-agent was
launched against my will, but it had no parents at all in the process
tree! Cost me a long time of fruitless bug hunting until I thought of
replacing /usr/bin/ssh-agent with a shell script that logged "ps fx"
output at the moment it was invoked, when it still had a parent. Then
everything went quickly from there on.

@_date: 2017-07-19 16:49:17
@_author: Peter Lebbing 
@_subject: How to NOT gnutar files during encryption? 
And if you keep the box checked, does it produce a file named
Archive.zip.gpg or Archive.zip.tar.gpg? Because IMO, it should be the
latter. A good alternative would be: supposing the file is at
.../foldername/Archive.zip, call the tarred and encrypted file
foldername.tar.gpg. But naming it Archive.zip.gpg looks just confusing
and wrong to me. The chain of extensions is just incorrect; if we're
dropping "inner" extensions, it should be Archive.gpg, which just loses
all information.
If your client saw the filename "Archive.zip.tar.gpg" or
"foldername.tar.gpg", they might notice and think "Hey, where did this
come from?" instead of just sending it to you and leading to confusion
all round. Similarly, you might have noticed.

@_date: 2017-07-24 12:10:36
@_author: Peter Lebbing 
@_subject: Test symmetrically encrypted files for errors - make sure they 
I don't know what OS you're using, so the details might differ but this
works for me:
$ gpg --batch -o /dev/null -d test.txt.gpg ; echo $?
gpg: AES encrypted data
gpg: encrypted with 1 passphrase
gpg: WARNING: encrypted message has been manipulated!
I deliberately corrupted the file. I say it should decrypt and output to
output". With an uncorrupted file, the exit status is 0, but here it is
2. Any non-interactive use should carry the --batch parameter so GnuPG
knows it's not currently talking to a human, and it should specify the
command (-d).
Alternatively, you could parse the status fd. The best way to
programmatically interact with GnuPG is through GPGME, but my gut
feeling says that for this really limited case, --status-fd is good
enough and cleaner than just relying on exit status. Perhaps exit status
is already good enough as long as data is not signed (which would
influence exit status), I'm not sure.
$ gpg --status-fd 3 --batch -o /dev/null -d test.txt.gpg 3>&1
1>/dev/null 2>&1
[GNUPG:] NEED_PASSPHRASE_SYM 7 3 2
[GNUPG:] BEGIN_DECRYPTION
[GNUPG:] DECRYPTION_INFO 2 7
[GNUPG:] PLAINTEXT 62 1500889574 test.txt
[GNUPG:] PLAINTEXT_LENGTH 4
[GNUPG:] BADMDC
[GNUPG:] DECRYPTION_FAILED
[GNUPG:] END_DECRYPTION
I'm just keeping what is printed on FD 3 here, be gone with all the
other cruft. What you actually want is a line that says DECRYPTION_OKAY.
If you parse the status-fd output for that line, I'd say you can be
pretty sure that the file is okay. Don't rely on the opposite
(DECRYPTION_FAILED); you want positive confirmation the file is OKAY, so
that's what you should check.
The only way to verify correctness of every byte of data is to decrypt
it; only then can the Modification Detection Code be computed and
verified. But there is no need to write the decrypted data to disk, as I
Disclaimer: I don't usually script GnuPG, I might be forgetting about
something important like --batch (which I did remember).

@_date: 2017-07-27 11:46:33
@_author: Peter Lebbing 
@_subject: gpg-agent cache keygrip 
What would be the purpose?
I already fail to see the problem of GnuPG filling in a passphrase it
already knows... surely an attacker would try the same thing as well, I
don't know what GnuPG not trying a known passphrase would actually gain
you in security. GnuPG is not your attacker.
Adding a passphrase manager only introduces another layer of indirection
plus extra steps for the user to unlock their key, but it seems to solve
no actual problem. It just moves the item that is of interest to the
Mario, if you for some reason don't like to unlock both keys at once,
for instance so you notice the first time during your session you use
your key, you could also add a number to the passphrase. For instance,
if your passphrase for both keys is "This is surely suboptimal", you
could give one key the passphrase "This is surely suboptimal1" and the
other "This is surely suboptimal2". Then GnuPG won't unlock both keys at
once, but you still don't need to remember more than when you shared the
passphrase. If you can't remember which is 1 and which is 2, use
something you can recognise. For instance, if the pinentry asks you
"Please unlock key 0x6228A8BC", you could append a C, the very last
digit of the identifier.

@_date: 2017-07-27 14:23:44
@_author: Peter Lebbing 
@_subject: gpg-agent cache keygrip 
Ah yes :-). I agree.
Let's look at multiple cases of passphrase reuse:
1) Using the same passphrase for multiple remote systems
If one of the remote systems is compromised, all your accounts with the
same passphrase are compromised. Sounds to me like a bad idea. There are
many different actors and implementations. All it takes is one bad apple.
2) Using the same passphrase in multiple different programs on your own
When an attacker can compromise one of the programs, but only that, the
attacker still gains access to the encrypted data held in multiple
programs, even if the others are safe by themselves. Possible ways of
compromise that spring to mind are some way to access a running program
remotely, such as by feeding it crafted data exploiting a vulnerability
in the program, or by the fact that data at rest is not well encrypted,
using a file from a backup the attacker gained access to.
3) Using the same passphrase for multiple instances of data in the same
If an attacker is able to compromise one instance, why couldn't they do
another? You might be lucky if it is an attack that requires a running
computer and the attacker only manages to entice the program once. If it
is an attack at data at rest, at poor encryption of the file, then the
workload increases a mere factor two. If they need five days to crack
the encryption of one instance, they only need yet another five days to
crack the other even if the passphrases were different.
For case 3), I'd say it is sheer luck if an attacker only learns one
passphrase rather than the multiple passphrases you use with the same
program. It's not a significant increase in security.
This way of reasoning gets you quite far. It's not completely
conclusive; for one, it depends on all instances being treated the same
way, i.e., all secret keys are stored on the same system /and/ in the
same backups. And suppose some form of key derivation can be cracked
quicker if there are multiple derivations of the same data and salting
is somehow compromised. Then it would be a bad idea to reuse a
passphrase for multiple instances, but I'd say that key derivation or
the random number generator involved is bad anyway and shouldn't be used
at all, even when you don't reuse passphrases. And there are probably a
few different scenarios where you might make yourself weaker.
But personally, without further details convincing me otherwise, I would
not be overly worried about using the same key for multiple instances in
the same program on the same system.
Furthermore, I'd say that the way GnuPG uses a passphrase is safe and an
encrypted private key file doesn't help an attacker to gain access to
the same passphrase in a different program.
Now let's get on to a passphrase manager and GnuPG specifically. A
different way to look at it is this: would you use GnuPG to protect your
passphrase manager? This is actually a feature request I've seen
multiple times: please provide a way to use my OpenPGP key to unlock my
passphrase manager. In that way, the security of the passphrase manager
is utterly dependent on the security of GnuPG. Crack GnuPG, and the
passphrase manager falls immediately as well.
Now there is one avenue left: would we mind if the security of GnuPG is
utterly dependent on the security of the passphrase manager? If you
propose to store the GnuPG passphrases in the passphrase manager,
apparently you're okay with that as well. Crack the passphrase manager,
and GnuPG has no further protections.
Okay, so let's say we don't mind if the security of GnuPG utterly
depends on the security of the passphrase manager, *or* vice versa.
Furthermore, I state pretty confidently that the way GnuPG uses
passphrases does not cause an interaction with other data being
encrypted with the same passphrase in a different program; there is no
way to crack some other piece of data, say your passphrase manager
database, quicker because you have access to the *encrypted* private
keys of GnuPG. Conversely, there is no way to crack an encrypted private
key in GnuPG quicker because some other key derivation function is used
with the same passphrase (other than to crack that other key derivation
by itself).
Then why don't you just use the same passphrase for your passphrase
manager as for your private keys in GnuPG? Again, this only goes if you
belong to both user groups touched upon: those who would consider it a
good thing if the passphrase manager unlocks with their OpenPGP private
key, and those who would store their GnuPG passphrases in a passphrase
By the way, to reiterate, merely considering data at rest, I dare to
state that reusing passphrases in GnuPG does not compromise the
encrypted data in any way. If an attacker has access to two encrypted
private keys from GnuPG, encrypted with the same passphrase, they are no
further in cracking it than if they had only the one. Once they do crack
it, they can access both. But the cracking itself is, and remains,
impossible for a good passphrase, no matter how many pieces of data from
GnuPG with the same passphrase the attacker has. That's an important
property of a good key derivation function.
My 2 cents,

@_date: 2017-07-31 18:34:30
@_author: Peter Lebbing 
@_subject: 'sign (and cert)' or just 'cert' on a master key with subkeus 
IMO, the good middle ground is the defaults. A wide middle. Maybe more a
country than a ground ;-). And I wasn't very impressed last time I read
the riseup.net article.
I wholeheartedly agree with "Use the defaults until and unless you can
articulate a specific and compelling reason to deviate from them."

@_date: 2017-06-02 15:06:57
@_author: Peter Lebbing 
@_subject: Certification-only key 
Heh, that's an interesting take on it. Thanks for sharing it.

@_date: 2017-06-02 19:25:31
@_author: Peter Lebbing 
@_subject: Certification-only key 
Note that this related to an *expired* subkey. If people wouldn't update
their keyrings (which they indeed would not, probably), it would still
correctly be expired.
I did later realize that if somebody used a timestamping service to
timestamp a document you signed, you would have to argue that you
already published your secret key before that time. You can't defend
yourself anymore with "that was backdated and signed only after the key
expired and was published". It changes the argument somewhat.

@_date: 2017-06-06 12:46:34
@_author: Peter Lebbing 
@_subject: Fwd: Re: Question for app developers, like Enigmail etc. - 
TOFU is about *consistency*. It says: this e-mail is signed by the same
key you've seen on all the earlier messages you received from this
e-mail address. It keeps count, and alerts you when all of a sudden you
start receiving signatures made by a different key.
Note that it can also be combined with the Web of Trust. You could use
TOFU just to track consistency and not award validity to keys, or you
could use TOFU to award marginal validity and obtain the remaining
validity from, e.g., marginally trusted Web of Trust signatures.
But TOFU isn't for everyone, and neither is the Web of Trust. It's your
By the way, it is my feeling Stefan Claas is looking for TOFU. The
Identicon scheme feels like TOFU with the database on external storage,
to wit, the user's brain :). Better to store that database on disk,
IMHO. The (only) net loss is that there is no synchronization between
different devices.
My Enigmail works with TOFU, although I can't see any statistics. But it
correctly awards a green bar with "Good signature" to my TOFU-verified keys.

@_date: 2017-06-06 15:38:58
@_author: Peter Lebbing 
@_subject: Certification-only key 
I think you're going backwards about this.
This is how I understand it:
Until the key is expired, you want people to recognize your signatures
as valid and issued by you. Hence, you don't publicly disclose your
secret key. You only do this once your key is expired.
Henceforth, you want to plausibly deny you issued those signatures which
you in fact *did* issue. As long as there is no timestamping service,
you could claim the signature to be a recent forgery with a forged time
of signature.
However, if somebody has used a timestamping service to prove the
signature was in fact really issued before the key expired, you'll have
to claim that you had already disclosed the secret key back then. Even
though you didn't. So you can't prove it with a timestamping service
because it is not actually the case.
And then there is the issue that the timestamp in general proves the
data *existed* at the time of issuance. But this doesn't prove the data
was disclosed publicly. Obviously the secret key existed, nobody is
questioning that. To prove it was disclosed, you'll need to go through
some more steps.

@_date: 2017-06-07 10:57:37
@_author: Peter Lebbing 
@_subject: Fwd: Re: Fwd: Re: Question for app developers, like Enigmail etc. 
What prevents someone else from doing this with your ID-card? For
instance, someone with whom you live?

@_date: 2017-06-07 11:04:46
@_author: Peter Lebbing 
@_subject: Question for app developers, like Enigmail etc. - Identicons 
That would make it difficult.
This doesn't seem like a problem, depending on some assumptions. In the
usual case where you wouldn't want the two accounts linked to the same
person, you would use two completely separate certificates, each with
their own pseudonym with nym address.
If you don't care that peole realize they belong to the same person, you
would create two UIDs on the same key, one for each nym account.
Good to hear :-).
Did you already enable TOFU? It needs a line in your gpg.conf. Either:
trust-model tofu
trust-model tofu+pgp
The latter combines it with the Web of Trust. See the manpage for more
info. gpg.conf is in your GnuPG homedir. I think this is ~/.gnupg by
default on OS X as well.

@_date: 2017-06-07 11:10:55
@_author: Peter Lebbing 
@_subject: Question for app developers, like Enigmail etc. - Identicons 
You mean with "Set Owner's Trust of Sender's Key" in Enigmail? That's
the wrong one. There's key validity and owner's trust. Key validity is
about whether you believe the key belongs to the person indicated.
Owner's trust is to what extent you trust that person to correctly
verify other people's identities.
You should sign the key to make it valid, not set its owner's trust.
It's a common misconception.

@_date: 2017-06-07 13:21:44
@_author: Peter Lebbing 
@_subject: Question for app developers, like Enigmail etc. - Identicons 
Actually, that's not really correct. It also works without a From:. I
don't know the details by heart, and I spoke too easily. TOFU verifies
the consistency of the binding between a key and the e-mail address in a
UID. So if so far you've seen a particular key being used for signatures
from  and suddenly it's signed by a different key that
also has an e-mail address , TOFU will alert you that
this is not what it expected to see.
Your e-mail client can also verify the consistency between the UID and
the From:, but GnuPG primarily checks the consistency of the mapping
between key and UID on the key. And it also works on the command line,
where no From: is available. It will not alert you of similar-looking
e-mail addresses, since this is really hard to solve, but the statistics
printed will hopefully make you notice that even though you should see
"10 signatures verified in the past month", it suddenly says "0
signatures verified so far" and this tells you it is not the same key as

@_date: 2017-06-07 14:24:45
@_author: Peter Lebbing 
@_subject: TOFU (was: Question for app developers, like Enigmail etc. - 
Not necessarily!
I don't know if Enigmail checks whether the From: is equal to the key
UID, but we're talking about look-alike addresses here, not completely
equal addresses, so even that wouldn't help.
It would, depending on tofu-default-policy, potentially be marked as
Good with a green bar! It is from a new key from an e-mail address never
before seen. With the default tofu-default-policy, it would *not* be
green, because it would only get marginal validity. But with
tofu-default-policy good, it would get marked as valid because there
doesn't seem to be anything wrong with it. It's only a visual similarity
that fools the user, but a computer is an exact device and doesn't know
they look similar to you.
I hope Enigmail will add the TOFU statistics to the displayed
information. Or maybe they already did, I see that I'm using Debian
jessie's enigmail package for Enigmail, and Debian jessie/stable has
pretty old packages (well maintained, but old).

@_date: 2017-06-08 13:18:35
@_author: Peter Lebbing 
@_subject: Fwd: RE: setting GnuPG card to 'not forces' does not let sign 
Yes, same here. I thought it was rather funny that she told me:
and later:
How a spambot can be oddly on-topic for this mailing list...
But I doubt very much anyone can do anything about this. Somebody has
arranged their spambot to respond to messages on this list, but the list
is public, so anybody can see those messages to the list; it could be
anybody doing it. However, upon checking, all the 6 such messages I've
received over the last couple of days all originated from the IP
104.160.29.115. That's something.

@_date: 2017-06-08 17:19:40
@_author: Peter Lebbing 
@_subject: How to show fingerprint in email header? 
Enigmail puts the following in my mails:
Openpgp: id=8FA94E79AD6AB56EE38CE5CBAC46EFE6DE500B3E;
 url=
I think that is the generally accepted method to give both a fingerprint
and a URL. I'd wager the following is just the fingerprint:
Openpgp: id=8FA94E79AD6AB56EE38CE5CBAC46EFE6DE500B3E

@_date: 2017-06-11 21:37:51
@_author: Peter Lebbing 
@_subject: changing the passphrase of the secret key stored in the GnuPG card 
They are the same thing, it's just a choice of terminology. Since user
authentication to a smartcard is traditionally done using numerics only
and card readers with PINpads also usually only use numerics, the term
PIN has become commonly used (Personal Identification Number[1]). But
under GnuPG, you can use alphanumerics and symbols, and it is more
correct to call it a passphrase.
Put differently: the secret key stub on disk is a mere unencrypted
reference to a specific smart card. And what then unlocks the smartcard
is the PIN or passphrase passed to the card, which is set as Werner
indicates. There is only one authentication involved, not two. (It's
still two-factor authentication, so that last sentence needs to be taken
in the proper context).
[1] I'd say "Identification" is a misnomer, it's authentication instead.
Identification is the mere act of naming something, authentication is
providing a means to prove something is authentic, is true, is not fake.
You could identify yourself as Peter Lebbing, but it almost surely would
not be authentic.
(I've always fancied bringing up this point when the police asks me to
"identify myself", but it would be a very bad idea in practice probably :-)

@_date: 2017-06-11 21:53:20
@_author: Peter Lebbing 
@_subject: GPG4Win Advice 
This is an extra convenience added by the GUI program. It is not in the
command line interface.
The simplest way is to follow this by
but this introduces a race condition. So it's probably better to do
something like
for x in C:\Location\*.txt
gpg2 ... --encrypt $x
del $x
However, it's been many years since I last did anything with
MS-DOS/Windows batch files and I don't have the correct syntax ready. It
needs to bail out when gpg2 errors, but that is way beyond my limited
recollection of batch files.
Oh, and when building a gpg command line, you're supposed to put options
before the command. However, it does try to cope with people putting
options after the command. (And in the quote above, my e-mail client
ended up putting an en-dash where there should be two ascii dashes,
which kinda spoils the didactic value.) I'd suggest the following
command line:
I see you're mailing from a .UK address, so I thought I could point out
armour can be spelled with British spelling as well :-). --armor works
just as well.

@_date: 2017-06-11 22:00:00
@_author: Peter Lebbing 
@_subject: changing the passphrase of the secret key stored in the GnuPG card 
Ah! That's the encryption of the backup key, not of the secret key
stored in the smart card. Well, it's ultimately the same key, but it's
not the copy of it stored in the smart card but rather the copy stored
in the backup file.
That's actually a difficult question, since AFAIK, the backups are not
complete OpenPGP messages but just the relevant parts of an OpenPGP
secret key message. I actually can't think of the answer to your
question. I'd know how to use packet surgery to reconstruct a normal
on-disk secret key from that partial message, and subsequently change
the passphrase on that key. I could also subsequently extract the
fragment again. But this is all not normal use of GnuPG, it's "Look, I
can make it do this as well!". Hopefully somebody else can answer if it
is possible, and how.

@_date: 2017-06-12 16:06:55
@_author: Peter Lebbing 
@_subject: Fwd: Re: Fwd: Re: Question for app developers, like Enigmail etc. 
Don't do this! Or did you do it just for testing? "Ultimate" is for your
own keys. It makes the key itself valid and all keys signed by that key.
It's the odd one out, as the other trust levels only determine the
validity of other keys signed by that key but don't affect the key itself.
To make a key valid, sign it with a local signature. Or an exportable
signature, your choice.

@_date: 2017-06-12 16:31:25
@_author: Peter Lebbing 
@_subject: Fwd: Re: Fwd: Re: Question for app developers, like Enigmail etc. 
I hadn't gotten round to answer your earlier questions yet, since I
noticed a point I should first spend some effort and thinking on.
It is impossible to use any form of cryptography in a secure fashion
when somebody is in a position to mess with the computer you're using it
on. Worst is someone with administrator privileges, but somebody with
the same privileges as you is already more than enough to completely
subvert your security.
They could alter your search path and put their own binaries in them.
Any program you launch, be it GnuPG, your e-mail client, your shell, or
any other program you use, could be replaced by something else. Same for
your data files, as you point out.
Your user account needs to be secure from evildoers. It depends on your
threat model how you go about this.

@_date: 2017-06-12 21:15:26
@_author: Peter Lebbing 
@_subject: Fwd: Re: Fwd: Re: Question for app developers, like Enigmail etc. 
No, that's beside the point. Once somebody gets your user privileges,
there is no "additional security". It's game over. They could replace
your Enigmail with their Evilmail, which seems like a good name for an
Enigmail edited to show any fingerprint the attacker desires and give it
any colour of the rainbow.
You need to make sure your computer doesn't get hacked by someone who
wants to subvert your use of GnuPG. Luckily, for most of us, we get
hacked to send spam... ;)
(Remember there are two types of companies. Those who know they got
hacked and those who don't know yet that they got hacked.)

@_date: 2017-06-13 14:16:46
@_author: Peter Lebbing 
@_subject: Question for app developers, like Enigmail etc. - Identicons 
I use Open Source Tripwire for that. Its specification language is quite
lacking in my opinion, but it's not so bad that I start looking around
for a different solution. I've been using it for ages, and haven't
noticed any significant development on it since I started using it. As
far as I remember.
Note that someone in a position to replace your binaries is also in a
position to replace the sha256sum binary or whatever other binary you
are using to generate the hashes, so your hashes can just lie to you. As
can Tripwire.
And so I come to my other comment, in reply to:
Security is not an absolute. Quite the opposite: security is rather
simple economics. How much are you willing to spend on your protection,
and how much is an attacker willing to spend to compromise you? It's
that simple. There are some unpleasant little factors such as that you
need to do it right all the time, yet the attacker only needs to do it
right once. But in the end, it all boils down to: who is willing to go
that step further? As long as your secrets aren't very valuable, an
attacker will not want to spend a lot on obtaining those secrets; they'd
rather point their attention and money elsewhere.
So Tripwire is something that raises the cost of the attack; it's
defence in depth, not an absolute defence. And as the name suggests, if
the attacker doesn't notice Tripwire, they might well set off an alarm.
But if they notice it.... .

@_date: 2017-06-13 14:46:17
@_author: Peter Lebbing 
@_subject: GnuPG card && using the backup secret key 
Unfortunately you got lost in the advice from multiple people :-).
This file sk_... is not a public key. It is just the backup of the
material that is in one of the slots of the card.
When Werner said "make sure your public key exists", he meant you should
perhaps import the file created with:
Let's not use a temporary homedir. There have been some changes lately
regarding locating the agent and scdaemon with a changed homedir. I
don't know off the top of my head what the currect situation is. GnuPG
getting confused about its homedir is a great way to make you confused
as well.
However, *backup your homedir*. If all goes awry, you can restore from
And do you have a spare OpenPGP card? Don't use your OpenPGP card with
the keys on it! Or else you'll get "I tried to be prudent and test my
backup, my backup wasn't good and it trashed my card. I now need a
backup to restore my card. Hmmmm."
Since you are using your normal GnuPG installation to do this operation,
the public key is already available! If you do start from scratch, first do:
$ gpg2 --import ccid--export-key-guru.pub
Then do:
$ gpg2 --edit-key 47CCF7E476FE9D11
You don't specify a filename to --edit-key, you specify a key in your
keyring. In your original post, one can see that you could have also done:
$ gpg2 --edit-key Matthias
but this would fail as soon as you import another Matthias's key or you
generate a second key for yourself, since GnuPG wouldn't know which key
you meant.
And then at the prompt enter:
gpg> bkuptocard sk_61F1ECB625C9A6C3.gpg
*But do this to a scratch card*! Direct GnuPG to put it in the
Encryption slot.
Now that card holds another copy of your key. What I don't know is
whether this will also tell GnuPG to look for this key on the new card
from now on. Actually, that would be a good way to really test the
backup, but that shouldn't be necessary. If it is the case and GnuPG
asks for that new card any time you want to decrypt, proceed as follows:
- Determine the keygrip of your encryption key.
$ gpg2 --with-keygrip -k 47CCF7E476FE9D11
For me, the output is as follows:
My encryption subkey has the keygrip
- Delete the smartcard key stub:
$ rm ~/.gnupg/private-keys-v1.d/.key
- Insert your regular smartcard, the one which also holds the SC and A key.
- Execute:
$ gpg2 --card-status
Now GnuPG will once again pick up the E key on your regular card.
Finally, if you want to remove the restored backup from the new/scratch
OpenPGP card, do (with that scratch card in the reader):
$ gpg2 --card-edit
gpg/card> admin
gpg/card> factory-reset
That should be it.
At some point earlier you deleted a file from
~/.gnupg/private-keys-v1.d/. If you deleted the wrong one, you'll be
very glad you made that backup of the directory. Restore from backup.
Since the backup was made before you started fiddling with stuff, if you
restore the whole .gnupg directory, it will automagically restore the
correct situation you started out with, and it will ask for your regular
card, not the new one.

@_date: 2017-06-13 15:02:35
@_author: Peter Lebbing 
@_subject: Key expiration question 
An expired key will definitely not be able to issue valid signatures
after the expiration date. So any certifications made after the expiry
will definitely not influence the validity of another key either, either
positively or negatively.
I don't know how certifications made before the expiry are handled. So,
I don't know whether some other keys either lose their validity after
the expiry or they keep their validity.
So I disagree that expiry doesn't impact trust and validity.
Not everything that is needed for a sane implementation is in the RFC.
Expiring your key will certainly force your correspondents to see if
there is anything new about it if they still want to verify your
signatures or encrypt messages to you (you can't encrypt to an expired key).
You ask what the purpose is of key expiry, but I think it has multiple
possible purposes. I'd phrase it as "what is the mechanism of key
expiry" and then decide whether that mechanism fits the purpose you have
in mind or not. Supposing that you do have a purpose in mind.

@_date: 2017-06-15 17:49:35
@_author: Peter Lebbing 
@_subject: modern GnuPG verify signatures 
It's much easier to see what is going on if you simply include the
terminal output in your mail. When using GUI tools, one loses this great
advantage, but if you're working on the terminal, please always include
the output from the program itself rather than merely describing what
Could you give us an example?

@_date: 2017-06-16 11:17:34
@_author: Peter Lebbing 
@_subject: Key expiration question 
There is nothing ~in the key itself~ that makes a signature /valid/ or
not. It's either correct or incorrect, but I distinctly said /valid/.
The OpenPGP-compatible software that checks the signature is what
decides whether the signature is valid or not, and a signature carrying
a timestamp later than the expiry date of the key will not be considered
I was talking about timestamps included in the key (expiry date) and
signature (signature creation time), not about the system time of the
system doing verification. On the other hand, stuff appearing to be from
the future is usually rejected outright, so the system time is somewhat
It's true it's not a limitation on creating signatures. But the
interesting bit isn't the creation of signatures. It's verifying the
validity of signatures, which is very much /limited/ by other factors
than just the raw key material, not merely suggested.

@_date: 2017-06-16 11:29:10
@_author: Peter Lebbing 
@_subject: How to join pubring.kbx and pubring.gpg? 
This. It serves no purpose other than to confuse, to send someone who
doesn't use OpenPGP an OpenPGP message. People using X.509 certificates
for e-mail will probably expect S/MIME messages, which while potentially
using RSA just as OpenPGP can use, are distinctly different from OpenPGP
This is phrased wrong. Actually, what many people call OpenPGP keys are
more accurately called OpenPGP certificates. But X.509 certificates are
not OpenPGP certificates in any sense. They both potentially use RSA.
But RSA is an algorithm, giving computation rules for numbers. RSA is
not a data format or standard for message exchange. That would be
OpenPGP or S/MIME, which do not interoperate. And, by the way, don't
even necessarily use RSA at all, it's just a common option.
I hope this makes it more clear to you.

@_date: 2017-06-21 19:02:26
@_author: Peter Lebbing 
@_subject: TOFU 
I don't understand what you mean by "there are 3 equal email addresses".
I don't know what you expected either. But I spent some time doing a
little test of my own. Hopefully by reading along with what I did, it
becomes clear how stuff works and to what extent Enigmail can already
work with TOFU even though it doesn't really support it.
TL;DR: Enigmail can correctly identify "genuine" signatures by awarding
them a green bar with "Good signature". Fakes can be spotted by the fact
they only get the blue "UNTRUSTED Good signature".
A little side note: since plaintext mails don't support much formatting,
the following is a tad bit hard to read. If I could have marked the
pieces with console output with a more distinguishing formatting, the
mail would have been a lot easier to read, but alas.
I created two keys bound to an existing e-mail address. (Note that the
address will not accept mail from the internet, only from within my
local network.) I will consider one key to be the "genuine" article, and
one key to be fake. Using Thunderbird and Enigmail, I sent myself two
messages with either key. One message is PGP/MIME. But since that is not
pleasant to work with on the command line and I wanted to do some
command line stuff as well, I also sent a message with an inline
signature, which I could then easily export to a file. So all in all, I
have four messages: one PGP/MIME from the real key, one inline from the
real key, one PGP/MIME from the fake key, and one inline from the fake key.
I then moved my real ~/.gnupg home directory out of the way and started
with a maiden directory containing just gpg.conf. gpg.conf contains
"trust-model tofu+pgp" (and nothing else).
Then I did the following steps:
- Using Thunderbird, open mail considered genuine
  Yellow bar, "Unverified signature", no key
- Import genuine key
- Go back to Thunderbird, re-open message:
  Blue bar, "UNTRUSTED Good signature"
- Go to command line:
We are no longer bothered about the fake key; it would be a bit annoying
if it kept droning on about it after we've already said it was bad.
I hope this has given you some more insight into how it works!

@_date: 2017-06-21 19:11:43
@_author: Peter Lebbing 
@_subject: speedo Error 2, download swdb.lst failed 
I think this is because of an expired certificate for versions.gnupg.org:
$ wget -S --2017-06-21 19:11:03--  Resolving versions.gnupg.org (versions.gnupg.org)...
2001:aa8:fff1:2100::56, 217.69.76.56
Connecting to versions.gnupg.org
(versions.gnupg.org)|2001:aa8:fff1:2100::56|:443... failed: Connection
Connecting to versions.gnupg.org
(versions.gnupg.org)|217.69.76.56|:443... connected.
ERROR: The certificate of ?versions.gnupg.org? is not trusted.
ERROR: The certificate of ?versions.gnupg.org? has expired.
The certificate has expired
$ gnutls-cli -p https versions.gnupg.org
Processed 175 CA certificate(s).
Resolving 'versions.gnupg.org'...
Connecting to '2001:aa8:fff1:2100::56:443'...
Cannot connect to 2001:aa8:fff1:2100::56:443: Connection refused
Connecting to '217.69.76.56:443'...
- Certificate type: X.509
- Got a certificate list of 2 certificates.
- Certificate[0] info:
 - subject `CN=versions.gnupg.org', issuer `C=US,O=Let's
Encrypt,CN=Let's Encrypt Authority X3', RSA key 2048 bits, signed using
RSA-SHA256, activated `2017-03-22 09:00:00 UTC', expires `2017-06-20
09:00:00 UTC', SHA-1 fingerprint `57a54fb00d2eabc40afe221720b73fd3038e3929'
        Public Key ID:
                ee4ff057a2b9a377fd7c4499e48f535633ccf304
        Public key's random art:
                +--[ RSA 2048]----+
              E. |
               Bo|
              o.O|
               +=|
        S   . .=.|
       . o o oo o|
        . = .. o |
       . .oo. ...|
        o+oo   .+|
                +-----------------+
- Certificate[1] info:
 - subject `C=US,O=Let's Encrypt,CN=Let's Encrypt Authority X3', issuer
`O=Digital Signature Trust Co.,CN=DST Root CA X3', RSA key 2048 bits,
signed using RSA-SHA256, activated `2016-03-17 16:40:46 UTC', expires
`2021-03-17 16:40:46 UTC', SHA-1 fingerprint
- Status: The certificate is NOT trusted. The certificate chain uses
expired certificate.
*** PKI verification of server certificate failed...
*** Fatal error: Error in the certificate.
*** Handshake has failed
GnuTLS error: Error in the certificate.
My guess is that certbot, the tool usually responsible for downloading
new Let's Encrypt! certificates, hasn't been able to get a new
certificate for a month, and a system administrator needs to look into
getting it to succesfully obtain a new one.
The webserver also seems to reject IPv6 connections, BTW. I can
succesfully open IPv6 https connections with gnutls-cli to other sites.

@_date: 2017-06-21 19:17:44
@_author: Peter Lebbing 
@_subject: Using gpg for ssh (Maximum Portability) 
If all you want to do is SSH, you don't need your key, so it reduces to
"muck around with gpg and ssh agents". As long as gpg-agent is correctly
configured to be an SSH agent, it will automagically use a plugged in
OpenPGP card with material in the Auth slot to do SSH authentication. No
OpenPGP key needed at all!
Configuring gpg as an SSH agent for Linux in the easiest way is very,
very distribution dependent. If you're lucky, it's a single switch
somewhere. systemd, or Xsession, or something similar.
And for non-Linux, I have no experience with that.

@_date: 2017-06-21 20:49:42
@_author: Peter Lebbing 
@_subject: TOFU 
Or either:
- Used --tofu-policy good on the key after the first message
- or even easier: used --tofu-default-policy good in gpg.conf
But think a while about what you want from TOFU before doing the latter.
It will automatically flag any non-conflicting OpenPGP key as valid (but
you could still manually flag a key as bad).
An "UNTRUSTED Good" signature from Enigmail means that you *should*
*not* award any credibility to the signature. It means there is *no*
indication that it belongs to the one you consider the real person
behind the address. I think it's a bad UX choice to name an invalid
signature "UNTRUSTED Good" and a valid signature "Good". I think it
suggests they both have some credibility, which is a false suggestion.
(When I say "invalid signature" I mean a signature by a key that does
not have full validity.)
That stems from a misinterpretation. On the first and second messages,
"UNTRUSTED Good" is indicating it can't award any validity to the
signature. On the third message, it still cannot award any validity to
the signature. There is no surprise if you interpret it as this.
And the correct interpretation is vitally important! *Don't* *trust* any
signature that is "UNTRUSTED Good".
I think those things are unrelated. You don't use key ID's for
verification, neither short nor long ones. They are just easy
identifiers to refer to a key; if you need to verify the authenticity
you check the fingerprint, period. Not a long key ID, which would still
be marginally safe until computers are much faster, and certainly not a
short ID which is utterly unsafe and has always been.

@_date: 2017-06-21 21:04:09
@_author: Peter Lebbing 
@_subject: TOFU 
Which *might* still be marginally safe. I haven't done any actual
calculations, and I want to seriously dissuade anyone from verifying
keys by their long key ID. Don't do it, kids! 64 bits can be brute
forced, but perhaps it might still be quite some effort to get a working
key with a colliding long ID.
I really should not have written it the way I did in the previous mail,
it was very sloppy.

@_date: 2017-06-22 15:46:43
@_author: Peter Lebbing 
@_subject: Managing the WoT with GPG 
Don't you mean
? I don't see how --*-needed would limit the search depth, other than
that for an actual keyset increasing them would effectively probably
decrease the actual depth.
While in general there are probably many avenues to be more efficient
about --check-trustdb, introducing too much complexity raises the
likelihood of bugs, especially if you start to intelligently update
trust by partial traversal.
Perhaps it would already be enough to split it into three phases:
1) Consider every key signature potentially valid. Construct the graph
of signatures. Discard anything that is not rooted in an ultimately
trusted key.
2) Still assuming correctness of key signatures, now consider
ownertrust. Remove any key that clearly does not have enough trust from
further computations (but leave in place all edges in the graph of the
remaining keys).
3) Start at the ultimately trusted keys and consider each signature that
corresponds to an edge going out of a valid key. Check signatures until
full validity of a key is reached (or all signatures on a key have been
checked). Stop checking then; it can't become more than fully valid by
more signatures. The fact that a key has been added to the valid keys
means you now have more edges going out from a valid key; keep repeating.
When a key fails to become valid in 3), you could consider the criteria
of 2) again and prune some keys from the graph, but it might be
over-optimizing. Without it it might already be plenty quick.
I don't know what the current algorithm is, but given its runtime, I'm
thinking it might be "check all signatures that can be checked" followed
by "now propagate validity through ownertrust". In my sketched proposal,
a *lot* of signatures would probably remain unchecked because they can't
further affect the validity of a key.

@_date: 2017-06-23 12:52:48
@_author: Peter Lebbing 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
So if I understand correctly, the "summary"/"validity" field merely
affects the text that is displayed to the user when displaying TOFU

@_date: 2017-06-23 13:22:23
@_author: Peter Lebbing 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
Ah! Thanks for the information.
I was thinking about how GnuPG handled it, i.e., on the gpg command line
or as a backend for some frontend. I got the impression the "validity"
field affected the text of the gpg command line but nothing else
(g10/tofu.c:show_statistics() returns "show_warning" asserted for
valdities below 3).

@_date: 2017-06-23 13:49:28
@_author: Peter Lebbing 
@_subject: TOFU 
That's very well possible. In that case there is no verbal indication of
a valid signature, only a colour. The text I see for a signature by a
fully valid key is:
Good signature from First Name Last Name Key ID: 0xXXXXXXXX / Signed 0n: DD/MM/YY HH:MM
And this is with a green background. There is no verbal indication that
the signing key is valid, unlike the version with the blue background,
where the text is:
UNTRUSTED Good signature from First Name Last Name Key ID: 0xXXXXXXXX / Signed 0n: DD/MM/YY HH:MM
So this does verbally indicate invalidity.
Anyway, apart from what the developers /meant/ when they wrote it, it's
about how people interpret it. And I got the impression that Stefan
thought that "UNTRUSTED Good signature" had some positive conotation,
something saying this signature gave more validity to the message than
if it were not signed. But that's not what it means, it's a signature by
an invalid key. Anybody can make a signature by an invalid key. The only
thing "good" means here is that the message was not altered *after* it
was signed by that invalid key. But who made the signature...
When you say "not altered in transit", that would very much depend on
your definition of "in transit". If a Man in the Middle changes both the
text and the signature, I'd say it /was/ altered in transit. But it was
altered in such a way that it once again has an "UNTRUSTED Good"
signature, by a different (attacker-controlled) key.
So IMO, "good" doesn't even mean "not altered in transit", as you said.
Otherwise we could keep redefining "in transit" ad absurdum, and finally
claim that "in transit" means when the video card sent the signal to the
monitor, when the light hit my retinas, when the nerves excited my brain
cells... ;-P.

@_date: 2017-06-23 17:56:18
@_author: Peter Lebbing 
@_subject: Managing the WoT with GPG 
There are two hard problems in computer science: Cache invalidation,
naming things, and off-by-one errors.
Martin, I think --no-auto-check-trustdb and a cron job will already make
it much more bearable, with the current state of things. That's what I'd
Other than that, I don't think my outlined strategy is very complex, it
basically boils down to not actually checking a signature until it is
used to compute validity, and stop for a specific key when full validity
is reached. I could be wrong though. It just doesn't seem like it should
be high on a TODO list, which in practice probably means it won't be
done. If the cron job wasn't available as an option, the situation would
be different.
PS: I didn't come up with "There are two..." but I can't be arsed to
look up proper attribution :-).

@_date: 2017-06-25 14:20:51
@_author: Peter Lebbing 
@_subject: Enigmail signature status indications (was: TOFU) 
However, I don't think that this information is in any way relevant to a
user if the key that signed it was not valid. I'm afraid the current
formulation doesn't do enough to discourage people to attach value to a
signature by an invalid key. The word "good" is weakening the message of
the word "UNTRUSTED", IMO.
The gpg command line also uses the word "good". But it is much more
verbose about it being made by an invalid key:
I am aware that changing the formulation doesn't make people use it
correctly; using it correctly is hard. But I think it would be much
better if it just said "UNTRUSTED signature". And if the signature is
not "good", it'll simply say "Error - signature verification failed".
Well, let's assume that this is not possible. When weak hashes are
disabled, this should not be possible. If we start to include this kind
of things in our assumptions, we should also add "or that somebody
managed to compute the private key for the key that signed this message".

@_date: 2017-06-30 18:29:41
@_author: Peter Lebbing 
@_subject: [HELP] pinentry-curses breaks SSH auth, but pinentry-mac works 
Almost; it has to do with the GPG_TTY variable not being communicated to
the agent.  The agent does not know on which tty the request for a
pinentry is made. To use a text mode pinentry with SSH, you need to invoke:
$ gpg-connect-agent updatestartuptty /bye
on the tty where you'll be SSH'ing (or some variation, this one is
pretty succinct). Otherwise the pinentry will pop up on the tty where
you did that last, or the tty that started the agent if you never did
it. That tty might not exist, not exist anymore, or be in a surprising
It would be really good if the SSH agent protocol would be extended to
communicate on which tty a request comes in. Without updates to the SSH
protocol, there is simply no way to know where it comes from.
However, I think many people work around this problem by a) using a
graphical pinentry and b) using a single graphical session. As long as
one also refrains from SSH'ing from a remote terminal, with the
combination, you've circumvented the problem by just using the
effectively singleton graphical session :-).
That is a surprising characterization. Do they also think this of the
GNOME and KDE SSH agents, to name two? I suspect those two are much more
widely used, which might eliminate the qualification "unconventional",
but that still begs, why "hack"?
I'd wager that this problem also occurs with the GNOME and KDE SSH
agents, if you for instance share a "screen" session with a Linux
virtual terminal (which would take care of sharing SSH_AGENT). My guess
is if you SSH from the virtual terminal, it'll freeze while your
"swapped out" graphical session invisibly prompts you to enter your
passphrase. But I haven't tried it.

@_date: 2017-06-30 18:38:45
@_author: Peter Lebbing 
@_subject: TOFU 
That's not what a MitM is. A Man in the Middle has no access to the
endpoints, he's in between them, hence middle.
And as I said earlier, if your endpoint isn't secure (last time, I
phrased it as "if someone gets your user privileges"), it's game over.
Also, in regard to your earlier mention of "shouldn't 'Ultimate' be
differently coloured to recognize this scenario", note that your
scenario of ultimately trusting a key used for data signatures isn't the
only way.
Somebody could put their own public key in your keyring, assign that
Ultimate trust, and then certify another public key they wish to pop up
as valid. Ultimately trusted keys make other keys valid by their
certification. There is no way to see any difference between a key that
is fully valid because your own ultimately trusted key signed it or
because the attackers ultimately trusted key signed it. And since the
ultimately trusted key of the attacker isn't the one doing data
signatures, your "alternative colour" will not trigger.
There is *no* *way* to mitigate an attacker having your user privileges.
No, the attacker could simply modify your database so it sees what it
expects to see, or put a little shell wrapper around the gpg binary that
filters out anything suspicious. Or do any of an infinite number of
nasty things.

@_date: 2017-06-30 20:35:48
@_author: Peter Lebbing 
@_subject: TOFU 
And to mitigate this situation, you proposed to colour ultimately trusted keys
differently when they are used to sign a message. You proposed this several
times in different messages.
So let's say your key is A, it's ultimately trusted. And you verified someone's
key and signed it; this is key B. Data signatures by key B show up as valid with
a green background.
Now consider the attacker. You say: he could inject key C, assign ultimate trust
to key C and send me messages signed by key C. They would show up as valid. You
want them to have a different colour.
But instead of that, the attacker could also inject key C into your public
keyring and assign ultimate trust to it, and use this key C to certify another
key D. The attacker then sends messages signed by key D, and since this key is
certified by an ultimately trusted key (C), they will show up as valid with a
green background.
As key A made data signatures by key B valid and green, key C makes data
signatures by D valid and green. The situation is the same.
Let's not get into trust signatures, they are a different beast entirely and not
pertinent to this discussion. It would just make it even more complicated, and
we're having some communication hurdles already. Trust signatures are used to
delegate what you normally do by ownertrust to another person, which is
sometimes used inside organizations.

@_date: 2017-06-30 21:02:38
@_author: Peter Lebbing 
@_subject: TOFU 
There is no difference between your ultimately trusted key and someone else's
ultimately trusted key. It's the same function.
There is nothing to protect here. Trust has to start somewhere, there has to be
a root of it all where you say "this is where it all starts". Your passphrase
allows you to make signatures. What's the difference between your signature and
the attacker's signature? They're both signatures, on your disk. On a system
which is, in your scenario, compromised. Please, there is *no* *way* to mitigate
an attacker having your user privileges. As far as your computer is concerned,
they *are* you. You're asking your computer to tell the difference between you
and you. The problem is that we started out with the premise that your computer
thinks your attacker is you. And then you're trying to think of solutions to
have your computer tell the difference. That's begging the question.
PS: As a final note, what prevents your attacker from grabbing your passphrase
when you enter it? They control your computer! If you could use your passphrase
to verify it was really you, they would immediately also have that passphrase,
since you just gave it to them.

@_date: 2017-03-07 15:26:47
@_author: Peter Lebbing 
@_subject: From Masterkey to subkey 
With GnuPG 2.1, I think this is easily doable. Which version of GnuPG
are you using? With the older branches, this is quite difficult.
I do however wonder why you want to do this in the first place. Your
primary key should not have the Encrypt ability in the first place, and
signature keys are easily exchanged without affecting old signatures.
Is this about the certifications you already have on your old key? You
could publish a key transition statement and ask people to re-certify.
It's not as nice as just having the old certifications work, but that
might not be desirable for other reasons.
I doubt you would benefit from earlier certifications if you started
issuing signatures with your new subkey that was formerly a primary. I
think behaviour might be unreliable. How does the recipient GnuPG know
whether it was issued by your old primary, in its capacity of the old
primary, or by your new subkey? There is nothing in a signature that
indicates this[1]. The GnuPG installation of one person might decide it
is a signature by the old primary, and award validity to it based on
certifications on the old key. A different GnuPG installation might
decide it was the subkey of the new certificate that issued the
signature, and use the validity of the new certificate. People having
both keys might see either behaviour, and might see a new behaviour when
they change something about their public keyring.
Oh, and before you benefit from keeping your primary offline, you'd have
to revoke the old key. Any GnuPG installation that concludes the
signature is by the old primary will immediately flag the signature as
BAD because it was issued after the key was revoked. This makes it even
In fact, this realization tells me another thing: you can't benefit both
from earlier certifications and from having an offline master key, it is
Both look wrong to me. Why do you want to have the Encrypt capability on
that key, do you have that on your old primary? It is considered bad
practice to use the same key material for both encryption and
signatures, since it opens the door to some sneaky stuff that is easily
avoided by not using the same key for both. I'm not saying it is readily
exploitable and I'm not saying it is not.
It sounds like a pretty bad idea to me. I expect recipients to see
breaking signatures, and a primary key with the E capability should be
retired anyway. Don't throw the key away! You'll still need it to
decrypt things that were previously encrypted to it. But don't use it
Yes. Let's deal with the rest first.
[1] There is "Signer's User ID" which could theoretically be used to
differentiate. But this is not widely used, and I doubt it would work in
practice. The purpose is to differentiate between different user id's on
one certificate, not to differentiate between certificates.

@_date: 2017-03-07 15:31:10
@_author: Peter Lebbing 
@_subject: From Masterkey to subkey 
Right, yes, and that :-). I wholeheartedly agree, but kinda went past
that in my response.
I'm more worried about the possibility of your old primary having "E"
based on what you (Bill) said, which would go against the "state of the
art" and "general recommendations", IMO.

@_date: 2017-03-16 15:55:53
@_author: Peter Lebbing 
@_subject: Security doubts on 3DES default 
Perhaps we should either retire ciphers with a 64-bit block length or
make OpenPGP mandatorily rekey after a few gigabytes of data, so it's no
longer up to the user to be prudent with large amounts of data.
In this stage of the game, it might make more sense to just retire those

@_date: 2017-03-22 13:28:02
@_author: Peter Lebbing 
@_subject: Mac Pinentry problem 
I think GnuPG hasn't deleted your secret key stubs which still point to
the old smartcard with the different serial number. Unless I'm very much
mistaken, this is a shortcoming of GnuPG 2.1 currently.
The agent identifies keys by their so-called keygrip. You can see the
keygrips for your private key with:
$ gpg2 --with-keygrip -K 64C2F99E904F1906
These keygrips correspond to files in ~/.gnupg/private-keys-v1.d/. Just
bluntly remove these files, but be careful to only delete files
belonging to smartcard stubs! Double check each keygrip before deleting
them. In fact, make a backup of the directory first :-).
Did you mean to write "gpg" there rather than "gpg2"?
You didn't indicate which version of GnuPG you're using, but your
problem sounds like a 2.1 problem to me. If you are using GnuPG 2.1, you
shouldn't mix it with GnuPG 1.4, that road leads to pain. They don't
share their private key storage, and might or might not share public key
storage depending on which version created the public key storage on the
very first invocation.

@_date: 2017-03-23 11:40:34
@_author: Peter Lebbing 
@_subject: GnuPGv2 & 'pinentry' on Linux w/ remote access 
Hi Sndr,
The first thing we really need to know before we can give good help, is:
which version of GnuPG are you using?
$ gpg2 --version
gpg (GnuPG) 2.1.18
libgcrypt 1.7.6-beta

@_date: 2017-03-29 12:20:02
@_author: Peter Lebbing 
@_subject: GnuPGv2 & 'pinentry' on Linux w/ remote access 
This is the style for GnuPG 2.0, not for 2.1. 2.1 uses a standard socket
location and the OpenPGP part of the agent will Just Work(tm). You still need
something for the SSH part, and for GnuPG v1 if you want to have that use the agent.
The following is a variation on the Debian GnuPG v2.1 Xsession script.
If you need the agent for GnuPG v1, include the following snippet:
Note that the agent survives the user session, so if you logout and log back in,
the agent will already be running. gpgconf will not launch it again. And your
keys will still be unlocked if the time to live hasn't expired.
Finally, there is the TTY issue. gpg will pass the TTY (or DISPLAY) it is
running on to the agent, so the pinentry pops up on the TTY/DISPLAY where the
invoking gpg was running. Unfortunately, SSH has no facility for that, so the
pinentry pops up on the "startup TTY". When I'm using SSH from a terminal
running on my graphical X session, it turns out just fine: pinentry-gtk-2 pops
up on my X screen. When I'm connecting remotely, it goes wrong. Personally,
before I SSH from a remote session[1], I run:
gpg-connect-agent updatestartuptty /bye
You could put that in a shell script with a shorter name...
As long as I don't forget to run the gpg-connect-agent command, it always works
fine for me.
If you use a graphical pinentry and it needs to pop up on a text terminal
instead, it will automatically fall back to the curses based pinentry. So if you
want a graphical pinentry, you can use that as well. I don't think a curses
pinentry would actually work if some graphical program invoked gpg? Where would
it pop up? :-)
Furthermore, note that the ttl entries are only for OpenPGP. SSH keys have their
own entries, ending in -ssh.
When using gpg? I only have it with SSH, perhaps you really should switch to a
graphical pinentry. I can imagine gpg telling the agent "I'm running on
$DISPLAY", and then the pinentry cannot work with that. If gpg is not also
telling it on what TTY it is running...
Yes, this is also what I experience when I forget updatestartuptty and the last
updatestartuptty was on a text terminal.
I also see some of the letters I'm typing, as they are actually passed to the
shell running on the text terminal. I think every other character goes to the
terminal, with the messed up pinentry-curses getting half of the keystrokes and
the others going to your shell. It's a great way to get half of your password in
.bash_history if you just keep on typing. You could at least prevent that last
bit by immediately doing:
$ unset HISTFILE
But it will still end up in swappable memory. So just stop typing your
passphrase already! :-)
This for me is actually the only situation where it goes wrong by default at
all. But if you switch between multiple X and/or Linux VT sessions, it'll also
happen. I do sometimes have a Linux VT open during an X session, but I never use
it for SSH (or GnuPG).
I hope this helps you further along.
[1] I don't usually nest SSH terminal sessions. However, I /do/ use git remotely
every now and then. And git often uses... SSH. So that's still a remote SSH running.

@_date: 2017-05-01 11:07:31
@_author: Peter Lebbing 
@_subject: Trouble installing Version 2.1 on Debian Jessie 
Silly me. These dependencies are not to be found in experimental, so the
-t option will do you no good. Experimental is a bit special; it does
not contain a complete suite but only a few packages. If you would have
specified a full suite like stretch or sid, it can find its dependencies
Still, just resolving all dependencies manually with aptitude's visual
mode is something that will always work. Since the whole idea of a
FrankenDebian is to use as few body parts from different suites as
possible, it shouldn't be a lot of manual labor.
Oh, mark dependencies as automatically installed with the M key (capital
m) when you install them. So press + to install, and them immediately
press Shift-M to mark it as auto. That way, they will be automatically
be removed if nothing still depends on them.
I agree that usually a FrankenDebian is a bad idea. You run a real risk
of breaking library dependencies[1], or confusing the APT system. Still,
I do it myself anyway, but only on desktops where breakage is not a
catastrophe. I can't recommend it, but I also won't say "oh, you
definitely shouldn't do that". It depends on your skill and willingness
to suffer breakage.
[1] Packages built in stretch and sid are compiled against the -dev
packages in those distributions, but its dependencies might be met by
packages in stable. This means the library built against is different
than the library that is loaded at runtime.

@_date: 2017-05-02 11:15:09
@_author: Peter Lebbing 
@_subject: Extending Expiration dates of gnupg keys with the private key 
I was under the impression "key 0" deselected all subkeys and the man
page agrees with me :-). From the man page:
The important difference is that you could do
and select subkeys one and two. But either
will not select the primary as well as two subkeys. You can, however,
use "key 0" to return to extending the expiration of just the primary.
TIL, "*" will select all subkeys. I did not know that.

@_date: 2017-05-02 11:22:05
@_author: Peter Lebbing 
@_subject: Trouble installing Version 2.1 on Debian Jessie 
Actually, all dependencies are now in jessie-backports. To be exact:
- debhelper and its dependencies
- libassuan-dev, libassuan, libgcrypt20-dev, libgcrypt20,
libgpg-error-dev, libgpg-error0, libksba-dev, libksba8, libnpth0-dev and

@_date: 2017-05-02 12:20:44
@_author: Peter Lebbing 
@_subject: Trouble installing Version 2.1 on Debian Jessie 
Oh wait, unless of course you mean if you want GnuPG 2.1 to provide the
that's what you meant, because all the libraries were just a recompile
away from a backport, AFAIK.
By the way, your contribution to this thread got held up for almost a
day before it went through:

@_date: 2017-05-02 18:00:04
@_author: Peter Lebbing 
@_subject: Question on Putty and gpg-agent 
It turns out this isn't true. If you add the keygrip to sshcontrol, it
will ask for the card. However, I hadn't added my smartcard keygrip to
sshcontrol because it is unnecessary.

@_date: 2017-05-09 11:50:33
@_author: Peter Lebbing 
@_subject: gpg hangs when asking for passphrase 
Is it possible that this started occuring after upgrading the gnupg
package? 2.1.17-4 (from 10 Jan) introduced using systemd user sessions
for gpg-agent and dirmngr by default. When I had this enabled on Debian
jessie, a connection to the agent would just hang. I figured this had to
do with a difference in systemd between jessie and stretch/sid. But
perhaps you're experiencing a variant of it. Do you have the package
dbus-user-session installed?
I don't know much about systemd, and I don't run stretch or sid. So I
can't help you much. I just recognised your description of connections
hanging. However, that change was introduced several months ago. Perhaps
something else changed more recently that still broke the user session
thingy for you?

@_date: 2017-05-09 17:19:23
@_author: Peter Lebbing 
@_subject: gpg hangs when asking for passphrase 
I removed the following symlinks (format: destination - space - symlink):
usr/lib/systemd/user/gpg-agent-browser.socket usr/lib/systemd/user/sockets.target.wants/gpg-agent-browser.socket
usr/lib/systemd/user/gpg-agent-extra.socket usr/lib/systemd/user/sockets.target.wants/gpg-agent-extra.socket
usr/lib/systemd/user/gpg-agent-ssh.socket usr/lib/systemd/user/sockets.target.wants/gpg-agent-ssh.socket
usr/lib/systemd/user/gpg-agent.socket usr/lib/systemd/user/sockets.target.wants/gpg-agent.socket
usr/lib/systemd/user/dirmngr.socket /usr/lib/systemd/user/sockets.target.wants/dirmngr.socket
(To be exact, I prevented them from being installed in the first place.)
So I don't use the user session functionality. In Debian jessie, there also is no package dbus-user-session to install in the first place.
It's a question /I/ can't answer, but Daniel Kahn Gillmor is probably the one who introduced the functionality and he also frequents this mailing list.

@_date: 2017-05-16 09:31:42
@_author: Peter Lebbing 
@_subject: Newbie can't get --passphrase option to work 
You should also ask yourself what the purpose of the passphrase is other
than to make your life difficult. Your disk holds a file with an
encrypted private key as well as a file containing the plaintext
password. Why would an attacker that is able to access the encrypted
private key not also be able to access the PowerShell script with the
password? What purpose does the password serve in this scenario?
You should probably just remove the passphrase from the key. That way
any decryption or signature will just succeed without jumping through
hoops to pass the passphrase to GnuPG.

@_date: 2017-05-16 11:12:18
@_author: Peter Lebbing 
@_subject: Using a GnuPG CCID card in another computer (follow-up) 
The card only holds the basic cryptographic material. But a certificate
("public key") holds much more information: your name, the relations
between the cryptographic keys and how they are used, your preferences
with regard to algorithms, how long the key is valid, and certifications
by other users who have signed your key, to name some important ones.
So before you can use the smartcard, you need to import your
certificate/public key. You could publish this to the keyserver network,
or put it on the web. If the latter, you /can/ enter the URL in a data
field on the smartcard, enabling you to use the "fetch" command of
Either the real cryptograhic material for a private key, or simply a
note telling GnuPG "that key is on card X". However, I'm surprised by
the size of these files you show. All my "notes saying card X", stubs,
on this laptop are around a mere 360 bytes. I know these files are
S-Expressions, but I haven't checked the exact construction. I would
expect OpenPGP smartcard stubs to generally come down to very comparable
You can ask GnuPG to list all the OpenPGP private keys it knows about
along with the keygrip. The keygrip corresponds to the file name in
private-keys-v1.d. It will also indicate when a key is on a card:
A '>' after 'sec' or 'ssb' indicates it is on a card. A ' indicates
the key is unavailable.
You could do this to check what GnuPG thinks those files represent.
Note it only mentions the card serial number for the primary key, even
though the E and S subkeys are on a different card.
I have to admit I cheated a bit for the above output; I had to specify
"--list-options show-unusable-subkeys" because the test key was expired,
and I removed an awful lot of test keys from the output.
private-keys-v1.d also contains keys for gpgsm, which will not show up
when invoking "gpg2 -K" as above.

@_date: 2017-05-16 13:41:40
@_author: Peter Lebbing 
@_subject: Newbie can't get --passphrase option to work 
I was talking about the things one usually does on a headless server,
which is decryption and data signatures. I'm unaware of this having any
issues, and I don't see you mention them in your referenced posts either.
I haven't ever heard unattended certifications being discussed, I don't
know if it is straightforward.
With regards to key management, this is often something a logged in
human user does and can hence do without having to wrestle unattended
stuff. I understand this doesn't always apply, but the OP here was
talking about decryption, not key management. That should be
When I say, by the way, that having no passphrase is better than using a
passphrase which is literally contained in a script, I'm saying that it
is usually better, not that it is always appropriate. It might be
appropriate to solve it in a different way, but a passphrase literally
in a script is probably not it.

@_date: 2017-05-31 17:42:10
@_author: Peter Lebbing 
@_subject: Certification-only key 
Talking about not forgetting, you answered after seven years?! :-D
I don't think expiring a signing subkey will make anyone forget
anything. Keyservers are append-only, so the expired subkey stays there,
and many of your peers will also not scrub their keyrings and remove
expired subkeys. Those that do might still keep signing subkeys so they
can still now and in the future verify stuff you signed before it
expired. Expired encryption subkeys don't serve a purpose for your peers
anymore, I think, people who like cleaning up might remove those.
As far as I am aware, the only thing that happens when a signing subkey
expires, is that signatures which have an issuing time after the expiry
are flagged as BAD. All signatures made before the key expired will
still show up as valid signatures by you and your certificate.

@_date: 2017-11-02 20:04:31
@_author: Peter Lebbing 
@_subject: Why does import refuse to merge a new subkey? 
What version of GnuPG is this? It's a well-known limitation of GnuPG 1.4
and 2.0, but my 2.1.18 allows me to add secret subkeys through --import.

@_date: 2017-11-02 20:46:29
@_author: Peter Lebbing 
@_subject: Why does import refuse to merge a new subkey? 
Yes, I'm pretty sure of that as well. 2.0 can't update secret keys; it
was introduced with 2.1 or somewhere during 2.1.

@_date: 2017-11-03 12:50:06
@_author: Peter Lebbing 
@_subject: Efficent batch fetching with verification? 
I just tried this and a list of 1319 fingerprints caused one single call
to "gpg --recv FPR1 FPR2 FPR3 ... FPR1319". I don't understand why my
gpg is then doing trust database calculations every so many keys, so
what I ended up doing was:
$ cat list-of-fingerprints | xargs strace -ff -o gpgtrace -e
trace=process gpg --no-auto-check-trustdb --recv
And this ran happily until killed by me, fetching and updating keys,
with just a single execve, no spawns.
Anyway, I didn't look any further, but what is exec'ing much here then?
Which version of GnuPG are you using? I'm using the Debian stretch
provided 2.1.18 with a systemd supervised dirmngr. I can't readily think
of which process would be starting often here... am I completey
forgetting about something? :-)

@_date: 2017-11-04 11:45:22
@_author: Peter Lebbing 
@_subject: Efficent batch fetching with verification? 
Actually, I did not :-).
I asked "what is exec'ing much". I don't see one exec every 3200
fingerprints as overhead at all.
In your other reply, you say the 100 ms exec overhead for these 3200
keyserver fetches is significant. But I see a lot of round trips to the
keyserver; I didn't check the docs, but it must not be fetching many
keys in every HKP request. Perhaps even just a single key per request.
That is 3200 round trips to a remote server. And then the data will be
checked: this means running expensive asymmetric crypto.
So how long does this one gpg with 3200 key fetches run for you, as wall
time, and as cpu time? TBH, I'm having a hard time believing the
starting up of gpg.exe is relevant.

@_date: 2017-11-07 18:05:53
@_author: Peter Lebbing 
@_subject: New smart card / token alternative 
I'm not commenting on the rest of this topic, but let me pick this one
thing out.
How exactly can the identity ever be unknown when we're talking about
stuff encrypted to an OpenPGP public key or signed by one? That's a
completely unique identifier!

@_date: 2017-11-08 16:45:27
@_author: Peter Lebbing 
@_subject: New smart card / token alternative 
I did not phrase it properly, leading to a misunderstanding.
We are talking about using a smartcard on a compromised computer. I
reasoned from the OpenPGP Card specification[1]. You can simply ask the
smartcard for the public key; the actual cryptographic public key.
So as an attacker with control over the computer, you see that someone
succesfully decrypts a document using his OpenPGP card. You ask the
smartcard for the public key that was used to encrypt the document, and
you have a fully unique identifier for the key that was used.
[1] It isn't clear to me whether this project is actually adhering to
the OpenPGP card specification, though, I didn't check. I realised this
only later.

@_date: 2017-11-09 12:52:22
@_author: Peter Lebbing 
@_subject: New smart card / token alternative 
Hey, note that I'm not advocating against this proposed new alternative;
it sounds like you think I do. I explicitly said I'm not commenting on
it. I currently don't have the time to invest.
(I didn't understand the relevance of the part of your reply I snipped
at all, though. I must be overlooking a bit of context. But let's just
end that line of discussion, I merely wanted to quickly point out what I
said about unique identifiers and don't have the time to look at it more.)

@_date: 2017-11-10 12:20:36
@_author: Peter Lebbing 
@_subject: a bunch of questions 
Well, this depends on your threat model. If I can control what one of
your peers sees, I could strip the self-signatures that change the
expiry date, only keeping the ones that I agree with.
So if you have a self-signature from 16 Dec 2010 that says the key does
not expire, and a self-signature from 10 Nov 2017 that says the key
expires in two years, I could manipulate it such that the second
self-signature never reaches this peer but everything still verifies.
Then the manipulated peer thinks the key will never expire, and I can
"keep the key going" forever.
If however you only ever extend the expiry dates, an attacker could only
fake your still valid key to be expired, rather than the more
troublesome case of faking your expired key to be still valid.

@_date: 2017-11-16 16:22:30
@_author: Peter Lebbing 
@_subject: your message could not,be delivered to one or more recipients. 
It's probably not a port. Note that the port 465 you are using to submit
mail has nothing to do with how mail is delivered from there on. Port
465 is never used between mail servers[1].
It's probably SMTP status code 451, which is a temporary error message
inviting the sending server to try again at a later time. Combined with
the error message, I'm inclined to think it's a greylisting system on
the receiving server. But apparently your ISP's mail server has given up
on trying to deliver it and bounced it to you. Either your ISP is giving
up too soon, or the receiving server is holding it off for too long. The
latter might be because of a configuration error.
The mail I'm replying to got through, though.
I have to admit the formatting of the message with the 451 code was
pretty odd, "deliver mail from 451 " like the
451 is somehow part of the address. Weird.
[1] Unless someone explicitly configures two mail servers to chat to
each other on that port because... well, because they wanted to do that.
A mail server can be configured to inscribe your mail on a stone with a
chisel if you configure it to do so, but that doesn't mean it's a normal
thing to do.

@_date: 2017-11-19 15:10:52
@_author: Peter Lebbing 
@_subject: Getting more verbose details of a key 
Well, there's your problem.
GnuPG by default does not show *expired* subkeys. Use --list-options
show-unusable-subkeys to do that.

@_date: 2017-11-19 15:20:16
@_author: Peter Lebbing 
@_subject: Using the OpenPGP Card on Unix && Win7 
I don't use Windows myself, but AFAIK, this is normal and not a problem.
AFAIK, the exclamation mark triangle on the smartcard means that the OS
has no driver to work with that specific smartcard. But GnuPG
communicates directly with the smartcard; the "driver" so to speak is
inside GnuPG. In fact, if you found another OS-level driver that is
happy to work with your smartcard, you are probably /creating/ an issue
since it will keep a lock on the smartcard so GnuPG no longer can get
access to it. While shared access to a smartcard is not impossible per
se, often you'll find that programs want exclusive access, and you can't
use two programs with the same smartcard at the same time.
An exclamation mark triangle on the /reader/ would probably indicate an
issue, but an exclamation mark triangle on the /smartcard/ is probably
for the best.
Still, I've only used different types of smartcards on Windows, and only
very sporadically, so I don't think I can be of much further help.

@_date: 2017-11-20 15:07:44
@_author: Peter Lebbing 
@_subject: Using the OpenPGP Card on Unix && Win7 
Involving Cygwin is yet another non-trivial hurdle to take. I think it's
best if you get it working on Windows first, and only then try to
involve another layer in the form of Cygwin.
You can see what happens when you use gpg.exe from the Windows command
prompt. If that works out, see what happens in the GUI manager(s)
included with gpg4win-3.0.0.exe. Assuming it does include GUI software :-).

@_date: 2017-11-21 14:01:51
@_author: Peter Lebbing 
@_subject: Getting more verbose details of a key 
How about just --show? It was suggested in an unfriendly manner at
LWN[1], but apart from the unfriendliness, I do think it makes sense.
It does imply that it works for more than just keys, though. I wonder if
that is a bad thing. Wouldn't a command that just shows the contents of
a file without processing it make sense? It could show all that
--import-options show-only shows for keys, or show recipients for
encrypted files, signers for signed files (no verification), etcetera. A
less techy version of --list-only --list-packets.
[1]

@_date: 2017-10-02 18:21:39
@_author: Peter Lebbing 
@_subject: 1024 key with large sub key 
Note that the key in question appears to be an ElGamal subkey, not RSA.
Not that that makes a difference to your questions and sentiments :-).

@_date: 2017-10-09 20:12:33
@_author: Peter Lebbing 
@_subject: Working with an Online and Offline Computer when using GnuPG - 
I think perhaps this is a little low-bandwidth for security updates for
your OS. By the way, you could use a USB-to-serial converter and use a
serial cable. The problem with USB is sharing the same USB device
between multiple computers. If you always use the same converter in the
same computer, it's not an infection vector. But this is still very low
bandwidth. Many USB-to-serial converters can go to 0.5 Mbit/s. I think
the max I've seen is 2 Mbit/s. So it's not as low as the ol' 115k2 anymore.
I haven't read about SD cards being infection vectors, and they have
many gigabytes. Enough for, for example, a mirror of the debian-security
archive for your architecture.
I do know about subverting SATA harddisks, but haven't heard about it
actually being used, unlike USB. SATA sounds reasonable as well.
For both SD cards and SATA harddisks, you could again use USB-to-X
converters, as long as they are dedicated to your offline system.
This is just my personal opinion, and should be read as ideas rather
than authority (not that I claim to have any, that's precisely the
point). Meanwhile, if somebody knows of a transfer method that has
enough bandwidth to be able to keep a Debian system up-to-date, or a
FreeBSD system alternatively, that looks better than SD-card or
SATA/PATA, I'm interested as well. I'd rather have something better.
My 2 cents,

@_date: 2017-10-10 11:07:58
@_author: Peter Lebbing 
@_subject: Working with an Online and Offline Computer when using GnuPG - 
Let me start off by saying security is almost never absolute. I think it
approaches some really basic economics: how much do you think your
opponent is willing to spend to compromise your security? How much are
you willing to spend to protect it?
So there is no silver bullet. It depends on your threat model.
I don't really see the point of purposely reducing the bitrate of a
serial link.
The online system on one end of the link is potentially hostile. It can
still be hostile through a completely bona fide serial link. It would be
indistinghuihable from a hostile integrated circuit on the online system
side of the link.
I don't consider it likely that the offline computer would just start
interpreting stuff sent over a serial port; there would be no software
running trying to make something of the data and accidentally expose an
arbitrary code execution through a flaw.
Instead, there would just be a data transfer utility, let's say zmodem,
which would be simple enough to audit and write in an extremely
defensive manner.
If you need to get data out of the offline system, you still need a wire
back. If not, you can cut it.
If I were making custom hardware, I'd do something like this:
An ARM microcontroller with USB-device port. Connected to, ah, let's say
two 20 MHz SPI links. Connected to a second identical ARM
microcontroller with USB-device port. It would just offer a basic
USB-to-serial interface to the connected PC. But instead of an actual
regular serial interface, it would transfer all data bytes over the SPI
links. The firmware of the microcontroller would be so straight-forward
that you can clearly see that it will never do anything other with data
on the SPI bus than relay it to the USB side.
Pick a high-performance microcontroller, and you could get a 40 Mbit/s
serial line. If the microcontroller connected to the online system were
compromised, it could still not do anything more than send plain data
bytes to the other, trusted, offline side. It can't do more than a
compromised online computer could already achieve.
Thanks a lot for sharing what you are allowed to divulge! I really think
it's great you chose to do that. Thanks.
I wrote a quick short e-mail with food for thought, there is so much
detail I left out.
The first thing I can think of relates directly to left out detail. If
there is a bug in a filesystem driver you have enabled, it's possible
that a manipulated filesystem could trigger arbitrary code execution,
with kernel privileges. This would be possible with any piece of
hardware that the kernel can treat as a block device, not just SD cards.
So you would need to configure your system in such a way that it never
*tries* to scan any new block devices you connect to the system after it
has booted[1]. This is where I don't think that you can ever be sure
what Windows all does when removable storage is connected. Yet with a
basic Linux or BSD system, it's much better possible to locate
functionality that tries to scan removable storage.
So you disable all removable storage scanning and just use an
incremental tar archive directly on the block device to transfer your
debian-security mirror and your encrypted/signed files. Again there is
an attack surface, the tar program, but it is greatly reduced.
The thing with evil USB is that there are so many device drivers with so
many different functions, and any one of them can become active and
start communicating with your compromised USB device. With an SD card,
at least you can reduce it to something like the driver for SD storage
(probably a good idea to remove SDIO drivers), the block layer, the
partition table parsers (don't think you'll be able to lose those), and
some more stuff. Interestingly, with (U)EFI, it's also possible there is
still some firmware actually active during operation.
Note that it's not enough to just actually *use* a plain tar archive
directly on a block device. You need to make sure that your offline
system will never *try* to interpret it differently. It's not how you
use it, it's how it *can* be used. I see people sometimes forgetting
this important distinction. Even if /you/ don't place a plain,
unencrypted filesystem on the block device, your attacker could still do
that anyway.
In fact, a good friend of mine did this and did a fantastic talk about
it at the OHM2013 hackers camp:
He went a step further than JTAG. I'm not overly worried about
JTAG-based attacks, since it requires physical access to the hard disk.
If your attacker has physical access to your supposedly secure
equipment, you've lost in a major way. It's over.
Instead, you need the in-band firmware update ability that allows you to
reflash the firmware from the PC the disk is connected to, and that is
precisely what he achieved.
He wrote a proof-of-concept exploit. It is not clear to me whether you
are saying you have seen an actual evil exploit or not when you say
"been used as a vector". Because that could also refer to a proof of
But this proof of concept he wrote would not actually compromise the
offline computer if the offline computer just used the block device as a
tar archive like I proposed for the SD card scenario above. It was
written for an entirely different scenario that doesn't apply in this
case. What you need in this case is something that somehow uses the SATA
connection to feed the system unexpected data somewhere that gets
misinterpreted and leads to compromise. I haven't heard about SATA being
used in this way. Note that if the system /were/ to interpret the hard
disk as a filesystem, I do expect compromise is easily possible. The
kernel will expect data on the hard disk to be unchanged unless it
changes it itself, so there are probably time-of-check-to-time-of-use
issues for instance.
Well, I'm leaving it at this.
[1] Booting with the potentially compromised SD card connected would be
a bad idea for sure, since you expose it to the firmware of the computer.

@_date: 2017-10-10 11:22:54
@_author: Peter Lebbing 
@_subject: Working with an Online and Offline Computer when using GnuPG - 
Whether I would consider this sane or not depends a lot on the type of
data you'll be handling on the offline machine. If it's just checking
signatures on plain text, it sounds somewhat reasonable though I would
never consider Windows 10 for it. You don't know all the ways in which
it is trying to be user-friendly by interpreting data. So for all I know
even a short file stored as .txt might be checked to see if perhaps it
can be interpreted as an icon to show in the file manager. Add a buffer
overflow in the icon image parser, and you have an attack vector. At
least with free software, you can inspect the way it works, and probably
isolate all the services that are trying too hard to be helpful.
If, on the other hand, you are using rich file formats like images or
marked up documents, it sounds like a really bad idea to not patch
security vulnerabilities.
Same for Certificate Requests you are going to sign with an X.509
Certificate Authority on the offline system. A much too rich format
(ASN.1!) to not update security issues, but it would be a very common
use case for an offline system.
It would be really helpful if all you needed to transfer to the offline
system were secure data rather than software updates. But if that secure
data is anything more than trivial, I think you really do need updates,

@_date: 2017-10-10 11:45:12
@_author: Peter Lebbing 
@_subject: FAQ and GNU 
That to me means I would support leaving it as is. I don't feel strongly
on writing it one way or another, but I do dislike the pressure some
people exert on others pushing their view. If however you are
consistently writing "Microsoft Windows?" everywhere in the FAQ, I'd
find it natural to write "GNU/Linux" as well.
I think you should pick your fights. That means I think people shouldn't
be pushing others to include GNU/. It also means I would soon capitulate
and just give them their way, changing it to GNU/Linux. It's just not
worth it. Luckily, I've yet to see people pushing to drop the GNU/ :-).
I'm chiming in to say I don't have strong feelings :-D.

@_date: 2017-10-11 12:18:19
@_author: Peter Lebbing 
@_subject: Working with an Online and Offline Computer when using GnuPG - 
Ah, this isn't about corrupting data on the line, about getting wrong
data in what is the correct direction.
This is about ensuring that a simplex link is really a simplex link.
It's about data not going in the wrong direction.
Furthermore, it is a simplex link from a trusted to an untrusted system.
Whereas the OP was talking about wanting to transfer data from an
untrusted to a trusted system.
Our frames of reference were different: I was actually mostly thinking
about a duplex system, which if needed could be reduced to simplex, in
which case it would be the other way around than your use-case. I never
considered the scenario where the trusted system was already compromised
and you need to make sure it is completely deaf and blind so an attacker
can't influence it in real time.
I'm sure you're aware of this, but I think it's useful to point out
since this is a public mailing list :-).
If your attacker can get physically somewhat close to your tabulator,
there are RF and powerline attacks to consider as well... if you don't
trust the IC's in the tabulator, that can get tricky. The disadvantage
for your attacker is lack of economy of scale: an attack through
internet can be done from your home to anywhere on the planet. If you
need to be in the vicinity of your target, you lose that.

@_date: 2017-10-12 12:09:44
@_author: Peter Lebbing 
@_subject: Generating a new keypair through GnuPG 2.x in Ubuntu 16.0.4 
I think Vedaal is just using the gnupg2 package provided by Ubuntu 16.04
Current package version is 2.1.11-6ubuntu2. Shouldn't important fixes
have been backported by Ubuntu? Although it is odd this package hasn't
been updated for 18 months...

@_date: 2017-10-25 19:59:53
@_author: Peter Lebbing 
@_subject: Importing an off-card backup of the encryption key of a Nitrokey 
There is a pretty difficult workaround, using gpgsplit and standard
Linux command-line tools. However, I get the sense you're not really
looking for difficult workarounds :-). If I'm wrong about that, just say
so and I'll give an example. I'll whip out a blank OpenPGP card, create
a test key and do it, posting the results on the list.

@_date: 2017-10-30 14:05:46
@_author: Peter Lebbing 
@_subject: Verify that the file is from who I expect it to be from 
This was a misunderstanding: gpgv cannot decrypt, so when Werner
suggested gpgv, he mustn't have realised you were decrypting as well as

@_date: 2017-10-30 14:14:30
@_author: Peter Lebbing 
@_subject: Impact of ROCA (CVE-2017-15361) in subkey vs. private key? 
This is technically correct but in practice the point can be almost
moot, depending on the threat model.
When you know the primary key, you can issue a new signing subkey and
get your signature accepted by others without needing to know the
material of the real signing subkey.
Likewise, you could create a new encryption subkey and get people to
encrypt to that subkey instead of the real one, once again making
knowledge of the encryption subkey unnecessary.
This is much less inconspicuous; people, including the legitimate holder
of the key, might notice. But by then it might be too late.
But, I agree that the reverse is not true: a compromised subkey does not
compromise the primary key in any way I can think of. And systems
checking for ROCA should not reject a certificate because there is
something wrong with an already revoked key.

@_date: 2017-10-31 11:39:24
@_author: Peter Lebbing 
@_subject: Impact of ROCA (CVE-2017-15361) in subkey vs. private key? 
Oh, I was talking about a ROCA-affected *subkey* but a clean primary key, where
the subkey was already revoked by the primary key. I think you are talking about
a ROCA-affected primary key.
A ROCA-affected primary key should be revoked as *compromised*, replaced and not
used in any capacity.
And yes, the subkey should also be revoked with reason "compromised", for the
reason you state.
To clarify, do you agree if I reword the paragraph you contest as:
But, I agree that the reverse is not true: a compromised subkey does not
compromise the primary key in any way I can think of. And systems
checking for ROCA should not reject a certificate because there is
something wrong with an already revoked subkey.
The only change is in the last word :-).

@_date: 2017-10-31 11:46:40
@_author: Peter Lebbing 
@_subject: Impact of ROCA (CVE-2017-15361) in subkey vs. private key? 
And only now the penny drops.
I suppose a system checking for ROCA might rightfully take offense at a subkey
revoked as "superseded" or "lost"[1], because with ROCA it is actually
"compromised". I never checked what GnuPG does with two revocations on a key,
the earlier a "superseded" and the later a "compromised". The only correct thing
would be to treat it as "compromised", especially because the attacker could
generate a "superseded" with an earlier timestamp after the compromise and
create the same situation. So it ought to work.

@_date: 2017-10-31 11:48:22
@_author: Peter Lebbing 
@_subject: Impact of ROCA (CVE-2017-15361) in subkey vs. private key? 
I was already writing a follow-up but was momentarily blocked on the right way
to phrase some of it :-). Our mails crossed.
Having read my follow-up, do you now agree? If the subkey is revoked as
"compromised", all is well and good?

@_date: 2017-10-31 12:01:37
@_author: Peter Lebbing 
@_subject: Impact of ROCA (CVE-2017-15361) in subkey vs. private key? 
Revocations are done by the primary key. If the user has lost the secret
primary, they should fetch their revocation certificate, not fool around with
the subkeys ;-). (Incidentally, this is why you don't need revocation
certificates for individual subkeys.)
I'm glad we agree, because I didn't sleep so well and I see I'm making mistakes
:-D. The [1] in:
I suppose a system checking for ROCA might rightfully take offense at a subkey
revoked as "superseded" or "lost"[1], because with ROCA it is actually
should have been a footnote:
[1] Lachlan indicates "lost" is also treated as "signatures before revocation
date remain valid", but I haven't checked myself.

@_date: 2017-10-31 14:25:00
@_author: Peter Lebbing 
@_subject: Hacking off-card backup to be on-disk key (was: Importing an off-card 
============================== START ==============================
Hi Ralf,
I fiddled around with a test card. Prepare for a wall of text.
I created a test key on card:
--8<---------------cut here---------------start------------->8---
sec  rsa2048/A7C45205828E4D09
     created: 2017-10-31  expires: 2017-11-07  usage: SC
     card-no: 0005 0000106E
     trust: never         validity: ultimate
ssb  rsa2048/D614DCD256D4028C
     created: 2017-10-31  expires: 2017-11-07  usage: A
     card-no: 0005 0000106E
ssb  rsa2048/93104C8F5B4A4714
     created: 2017-10-31  expires: 2017-11-07  usage: E
     card-no: 0005 0000106E
--8<---------------cut here---------------end--------------->8---
We start with damage control. Always backup your .gnupg directory before doing risky stuff. I'm assuming the backup dir .gnupg~ does not already exist; otherwise, delete it first or choose a different name.
--8<---------------cut here---------------start------------->8---
$ cd
$ cp -a .gnupg/ .gnupg~
--8<---------------cut here---------------end--------------->8---
The following actions: export secret key, delete secret key from keyring, import secret key, show an interesting behaviour of my GnuPG 2.1.18 related to card keys:
--8<---------------cut here---------------start------------->8---
$ gpg -o cardkey.gpg --export-secret-keys 0976A143384202C99E7C26EFA7C45205828E4D09
$ gpg --delete-secret-and-public-keys-keys 0976A143384202C99E7C26EFA7C45205828E4D09
$ gpg --import cardkey.gpg gpg: key A7C45205828E4D09: "Test Backup Hack" not changed
gpg: To migrate 'secring.gpg', with each smartcard, run: gpg --card-status
gpg: key A7C45205828E4D09: secret key imported
gpg: Total number processed: 1
gpg:              unchanged: 1
gpg:       secret keys read: 1
--8<---------------cut here---------------end--------------->8---
It will not import the secret key stubs[1]. What it is obliquely saying is: don't import key stubs, just insert your smartcard and run --card-
status. Keep this in mind. It will come back in a different form.
Don't run --card-status at this time, by the way.
Now we start with packet surgery. Unlike a surgeon, we start by fully taking apart the body ;-).
--8<---------------cut here---------------start------------->8---
$ cd tmp/
$ gpgsplit ../cardkey.gpg $ ls
000001-005.secret_key  000004-007.secret_subkey  000007-002.sig
000002-013.user_id     000005-002.sig
000003-002.sig         000006-007.secret_subkey
--8<---------------cut here---------------end--------------->8---
I always have a "tmp" dir handy for throwaway stuff. Create an empty dir first if necessary.
An OpenPGP file always consists of a stream of packets. gpgslit just splits these packets over multiple files without changing anything else. We need to figure out which of the "secret_subkey" files is the secret key stub for the encryption key. First note that the encryption key is the key with ID 93104C8F5B4A4714, as can be told from the off-card backup file named sk_93104C8F5B4A4714.gpg.
--8<---------------cut here---------------start------------->8---
$ cat *secret*|gpg --list-packets # off=0 ctb=95 tag=5 hlen=3 plen=294
:secret key packet:
        version 4, algo 1, created 1509451630, expires 0
        pkey[0]: [2048 bits]
        pkey[1]: [17 bits]
        gnu-divert-to-card S2K, algo: 0, simple checksum, hash: 0
        serial-number:  d2 76 00 01 24 01 02 00 00 05 00 00 10 6e 00 00
        keyid: A7C45205828E4D09
# off=297 ctb=9d tag=7 hlen=3 plen=294
:secret sub key packet:
        version 4, algo 1, created 1509451630, expires 0
        pkey[0]: [2048 bits]
        pkey[1]: [17 bits]
        gnu-divert-to-card S2K, algo: 0, simple checksum, hash: 0
        serial-number:  d2 76 00 01 24 01 02 00 00 05 00 00 10 6e 00 00
        keyid: D614DCD256D4028C
# off=594 ctb=9d tag=7 hlen=3 plen=294
:secret sub key packet:
        version 4, algo 1, created 1509451630, expires 0
        pkey[0]: [2048 bits]
        pkey[1]: [17 bits]
        gnu-divert-to-card S2K, algo: 0, simple checksum, hash: 0
        serial-number:  d2 76 00 01 24 01 02 00 00 05 00 00 10 6e 00 00
        keyid: 93104C8F5B4A4714
--8<---------------cut here---------------end--------------->8---
These are the three packets with "secret" in their name, *in order*. The last of the three has the right key ID, so that means 000006-007.secret_subkey contains the stub we want to replace.
Now let's take a look at that pesky sk_93104C8F5B4A4714.gpg that you were trying to import, with the off-card backup of the encryption key:
--8<---------------cut here---------------start------------->8---
$ gpg --list-packets ~/.gnupg/sk_93104C8F5B4A4714.gpg # off=0 ctb=95 tag=5 hlen=3 plen=966
:secret key packet:
        version 4, algo 1, created 1509451630, expires 0
        pkey[0]: [2048 bits]
        pkey[1]: [17 bits]
        iter+salt S2K, algo: 7, SHA1 protection, hash: 2, salt: 0B784F565A0849EB
        protect count: 28311552 (235)
        protect IV:  84 f1 35 77 5c f1 e2 70 b7 00 76 aa ef 85 86 6e
        skey[2]: [v4 protected]
        keyid: 93104C8F5B4A4714
--8<---------------cut here---------------end--------------->8---
This is a "secret key packet", but we want a "secret sub key packet"
(sic). Let's first copy this "secret key packet" in the correct place, and then grab your scalpel:
--8<---------------cut here---------------start------------->8---
$ cp ../.gnupg/sk_93104C8F5B4A4714.gpg 000006-007.secret_subkey $ dd if=000006-007.secret_subkey bs=1 count=1|hd
1+0 records in
1+0 records out
00000000  95                                                |.|
1 byte copied, 3.1911e-05 s, 31.3 kB/s
$ echo -ne '\x9d' | dd of=000006-007.secret_subkey bs=1 conv=notrunc
1+0 records in
1+0 records out
1 byte copied, 3.4443e-05 s, 29.0 kB/s
--8<---------------cut here---------------end--------------->8---
With the first "dd", we check if the file starts with the byte 0x95. If so, we should replace that byte by 0x9d. If it doesn't start with 0x95, we need to grab a copy of RFC 4880 and figure out what to do next, but I have no reason to believe GnuPG will have used something else than 0x95 when it created your backup. It's just a safety check to be sure.
Flipping that single bit in the first byte is what changes the packet from a "secret key packet" to a "secret sub key packet".
So now we can reconstruct an OpenPGP file containing your private key, for just the encryption subkey. The other two keys (primary and authentication sub) are still key stubs pointing to the smartcard. --8<---------------cut here---------------start------------->8---
$ cat * >/../uncarded-key.gpg
$ cd ..
$ gpg --import uncarded-key.gpg
gpg: key A7C45205828E4D09: "Test Backup Hack" not changed
gpg: To migrate 'secring.gpg', with each smartcard, run: gpg --card-status
gpg: key A7C45205828E4D09: secret key imported
gpg: Total number processed: 1
gpg:              unchanged: 1
gpg:       secret keys read: 1
gpg:   secret keys imported: 1
--8<---------------cut here---------------end--------------->8---
Ah, here is our friend "run gpg --card-status" from before. It wasn't phrased very nicely the first time around, but this time it's even more confounding. Of the one key processed, one key is unchanged. Of the same one key, one is imported. Uhuh. What has happened is that it has not imported the primary key and the authentication subkey. But it *has* imported the encryption subkey. So it has both not changed and imported one key. In a universe with a different logic, this makes perfect sense. Note the double meaning of "secret key": we use it both to refer to individual keys like the primary and each subkey, as well as to refer to the whole of a primary key with its subkeys. It's what makes this even more confounding.
But, nonetheless, it works. We cannot use the primary or the auth key, at least until we insert the smartcard and run "gpg --card-status", but we *can* use the encryption subkey. It is now an on-disk key.
--8<---------------cut here---------------start------------->8---
$ echo test | gpg -r 0976A143384202C99E7C26EFA7C45205828E4D09 -o test.gpg -e
gpg: test backup hack: Verified 0 signatures and encrypted 0 messages.
File 'test.gpg' exists. Overwrite? (y/N) y
$ gpg -d test.gpg gpg: encrypted with 2048-bit RSA key, ID 93104C8F5B4A4714, created 2017-10-31
      "Test Backup Hack"
--8<---------------cut here---------------end--------------->8---
Workaround difficult enough for ya? :-)
If you screw up your installation, you should be able to put it back by deleting ~/.gnupg and copying back ~/.gnupg~ in its place. I haven't encountered any issues with gpg-agent staying alive throughout this swapping of the floor under its feet. Either it is watching the inode number of its homedir or something like that and notices it changed, or I simply haven't managed to trip it up yet. It might be prudent to kill the agent in between.
[1] "Secret key stub": a small bit of data that indicates on which smartcard the key is, rather than the actual secret key itself that would normally be there.

@_date: 2017-09-05 11:00:21
@_author: Peter Lebbing 
@_subject: Documentation of trust model 
The GNU Privacy Handbook has a good explanation of it:
That is to say, it explains the Web of Trust. It doesn't seem to even
mention trust signatures.
The difference between "classical" and "pgp" is, as the man page does
say, that "pgp" includes trust signatures.[1] But in practice trust
signatures are only used in such limited settings that these situations
probably have their own prescriptive practices and documentation. At
least, that's what I personally expect. So it's not that useful to
document trust signatures in detail. It could perhaps be wise to mention
this rationale for not explaining them.
The man and info pages are more reference manuals than user manuals;
they list all options, but don't explain what is all involved in using
GnuPG in a sane manner in practice.
While there are certainly ways to improve the man and info pages to be
more useful, I think a whole description of how to properly use the Web
of Trust would be out of scope.
[1] Although it is actually phrased ambiguously: it is not clear whether
the relative clause "as used in PGP 5.x and later" is a restrictive or
non-restrictive relative clause. Is it:
1. The Web of Trust combined with trust signatures, in the manner they
are used in PGP 5.x? So this Web of Trust is a different Web of Trust
than the one of PGP 2.x.
2. The Web of Trust combined with trust signatures, which is a model
that was introduced in PGP 5.x?
It actually is 2: the Web of Trust is the same as in PGP 2.x, but
another trust mechanism was added: trust signatures.
So perhaps the sentence should be rephrased as:
This  is  the Web of Trust combined with trust signatures, which is the
model used in PGP 5.x and later.

@_date: 2017-09-06 15:29:52
@_author: Peter Lebbing 
@_subject: How to encrypt using public certificate\key 
First of all, are we talking about OpenPGP, S/MIME, or both? I notice
you say PEM public key, which implies the X.509 and S/MIME ecosystem,
but GnuPG is more commonly used for the OpenPGP ecosystem. The "gpgsm"
binary of GnuPG does do S/MIME, though.

@_date: 2017-09-06 16:28:46
@_author: Peter Lebbing 
@_subject: Unsubscriing (was: How to encrypt using public certificate\key) 
*Someone* managed to subscribe your e-mail address, which is usually not
possible without being able to read mail addressed to your e-mail
address (and thus should usually just be you).
Anyway: you're asking your peers, who cannot help you. You can help
yourself by following the link at the bottom of every mail you receive
through the mailing list:
Note you will need to use the exact e-mail address that was subscribed.

@_date: 2017-09-06 16:34:58
@_author: Peter Lebbing 
@_subject: How to encrypt using public certificate\key 
Hello Shaarang,
"Root CA", "certificate chain" and your earlier "PEM public key" tell me
you are using certificates from the Cryptographic Message Syntax
ecosystem (to which S/MIME belongs also). These are not OpenPGP
certificates/public keys, and it is simply impossible to encrypt an
OpenPGP message to them. You will need to ask your peer for their
OpenPGP certificate (also called "public key")  before you can send them
an OpenPGP encrypted message.
They are two completely separate and incompatible ecosystems. It just so
happens that GnuPG does have some support for CMS as well, through the
gpgsm binary.
More about starting with OpenPGP is in The GNU Privacy Handbook[1]. That
guide is pretty outdated, though, so don't take its word for gospel.
[1]

@_date: 2017-09-08 11:56:32
@_author: Peter Lebbing 
@_subject: Poldi example usage of gpg-connect-agent fails 
Hmmm, it works for me on Debian stretch/stable, with the system-provided GnuPG 2.1.18.
If I am lazy and don't uppercase the slot identifier, I get a comparable $ gpg-connect-agent "/datafile /home/peter/bla.key" "SCD READKEY --advanced openpgp.3" /bye ERR 100663414 Invalid ID If I try it on a card which only has S and E keys, no A key, the result is something else:
$ gpg-connect-agent "/datafile /home/peter/bla.key" "SCD READKEY --advanced OPENPGP.3" /bye ERR 100663305 No public key Which version of GnuPG are you using? It does not appear to be that the functionality no longer works in newer versions, since 2.1.18 is pretty

@_date: 2017-09-14 11:40:59
@_author: Peter Lebbing 
@_subject: [Feature Request] Multiple level subkey 
Dutch person here; I had no idea what a European Health Insurance Card
is. All I have is a credit-card sized piece of plastic that mentions my
customer number at OHRA, the insurance company where I have my health
insurance. The piece of plastic has a black bar where the magstripe is
located, but I'd be very surprised if it's a magstripe. It's just inked
to look similar to one. (Never understood why they do that)
I've looked on the interwebs what a European Health Insurance Card is,
and yes, many Dutch people can request one free of charge. But given
that I have never heard of it before, I don't think many people do. And
there are insurance companies that don't give them out at all.
And even if you got one, the Dutch information about the card says its
validity period depends on your insurance company as well, ranging from
just the duration of your stay abroad up to maximally one year.
This does not sound like an obvious target for Dutch people who want a
government-issued certificate.
My 2 cents,
PS: Yes, I do travel abroad. But I simply depend on my travel insurance
and a "medication passport", which is a document that includes all the
standardized names of medication I have to take, in case I lose them.
Oh, and my organ donor card for when it really goes wrong :-).

@_date: 2017-09-18 16:48:48
@_author: Peter Lebbing 
@_subject: Extending expiration date and SSH 
No, if it is a regular SSH key, it will not change by changing the
expiration date.
Back up your .gnupg dir, and if something goes wrong, put it back from
backup. Always good advice.

@_date: 2017-09-18 20:27:19
@_author: Peter Lebbing 
@_subject: How to encrypt using public certificate\key 
If you want to learn about what makes an OpenPGP message, gpg
--list-packets is very useful:
$ echo Talking to myself | gpg -r peter at digitalbrains.com -e | gpg
And now you see which packets make up a message encrypted to me.
Well, in a sense that's correct, but it's missing an important point.
What GnuPG does is:
- Create a random session key, unique for each encrypted message. This
is what the data is encrypted with.
- For each public key the data is encrypted to, include a Public-Key
Encrypted Session Key Packet[1] (PKESK), which is the session key
encrypted to a specific public key.
- If decryption by passphrase is requested (--symmetric), also create a
Symmetric-Key Encrypted Session Key Packet[2] (SKESK), which allows to
decrypt the session key with the passphrase.
RFC 4880 section 2.1 indeed also mentions a different method where the
passphrase is used to derive the key to encrypt the data, rather than
using a random session key. This is possible if the data is preceded by
a single SKESK that specifies how to derive the key from the passphrase,
as in section 5.3 [2]. But this type of data is never produced by GnuPG,
to my knowledge.
So /the/ method, the single method, to create an encrypted message is to
generate a random session key which is used to encrypt the data. Then
get that session key to your recipient, be that by public key or by
shared passphrase.
Finally, multiple passphrases that all decrypt the data (multiple SKESK
packets) are permitted, but I don't think GnuPG can create such messages
(I'm not sure).
What you /should/ do is put all options before the command; that way the
command line is unambiguous and gpg will always catch your meaning. "-e"
is the command, and "somefile" is the command argument. So:
$ gpg -u "Sender User Name" -r "Receiver User Name" -e somefile
When you include options after the command, it might work, but it
requires guesswork on the part of gpg, so you should avoid it.
It encrypts the data with a random session key, and encrypts the session
key to the public key belonging to "Receiver User Name". To be exact,
the first public key it finds in its keyring that matches "Receiver User
Name". Which one is the first, you don't know, so it's best to make sure
only one key matches what you give.
And the command line contains useless cruft, as it specifies a signing
key, but doesn't request signing of the data. So the "-u" argument is
silently ignored as not relevant but not harmful either. If there is
only one private key, it's never necessary to specify it by "-u".
No, there's no third method to decrypt data, it's either encrypted to a
public key, or a passphrase unlocks it, or both. Okay, I guess that does
make three ;-).
Either the man page if you're on a UNIXy OS:
$ man gpg
Or the Texinfo documentation which is on the web[3] and can also be read
on UNIXy OSes by:
$ info gnupg
(or a different info reader, I usually use "pinfo").
The Texinfo manual has more than the man page, and is also a lot easier
to navigate. But they are mostly reference manuals, you'll still need
other documentation to get you started.
Let me point out, as you're perusing the OpenPGP RFC, that there is even
another method[4] to encrypt data[5] to a passphrase defined there, but
it's deprecated. As it should be, no salting!, obsolete cipher:
Just ignore this, it's ancient. If somebody sends you such messages,
please page them or send them a fax, requesting them to come over to the
21st century. It's not that scary on most days.
And there is more such stuff in the RFC. If it says something like
"deprecated" or SHOULD NOT or something, you can probably skip it.
[1] [2] [3] [4] [5] Okay, that puts "is there a third method to encrypt" into a
different light again :-)

@_date: 2017-09-28 15:18:09
@_author: Peter Lebbing 
@_subject: preferring --check-sigs over --list-sigs [was: Re: Houston, we 
Are you sure you had the Governikus key in your keyring? I am seeing the
same as Stefan: the signature is bad. It says sig-3, the dash indicates
failure. It should have been sig!3 for a good signature.
For reference, this is the Governikus signature in --list-packets format:
:signature packet: algo 1, keyid 5E5CCCB4A4BF43D7
        version 4, created 1506196241, md5len 0, sigclass 0x13
        digest algo 8, begin of digest 6b 6e
        hashed subpkt 2 len 4 (sig created 2017-09-23)
        hashed subpkt 5 len 2 (trust signature of depth 1, value 60)
        subpkt 16 len 8 (issuer key ID 5E5CCCB4A4BF43D7)
        data: [4095 bits]
It is a SHA256 trust signature issued by an RSA key. I think it's odd
they issue a level 1 partial trust signature, but I'd guess they think
they're doing their users a service by making it possible to
automatically assign partial trust to all keys signed by them, if you
want to. Don't worry, this won't happen unless you issue at least a
level 2 trust signature to Governikus. At least, I'm fairly sure it's
not enough to simply assign full ownertrust to Governikus, ownertrust
and trust signatures don't interact, right?
I don't see anything yet that stands out to me as "this must be why it's
a bad signature".
But we can always dig deeper. Using gpg's debugging output, it is clear
that the RSA signature is well-formed, but the hash doesn't match. If I
read it right, GnuPG wants the hash to be:
But the Governikus signature hash is:
I didn't actually parse the ASN.1, though, I simply used common sense:
the signature packet indicates the Governikus hash starts with 6b 6e,
and the length is correct for a SHA-256 hash, so it makes sense that the
ASN.1 ends with the pure hash. Haven't thought about endianness.
I don't know what could cause this. This is as far as I can go. Perhaps
a developer recognises the situation.
Here's the debugging output:
--8<---------------cut here---------------start------------->8---
gpg: DBG: rsa_verify
data:+01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffff003031300d0609608648016503040201050004208f \
gpg: DBG:
gpg: DBG: rsa_verify
sig:+7c0d84121a51ae5f5e99d131fc0e0e1e9157b03375b65bfd706aef1b42776ccd \
gpg: DBG:
c5ef1d4c7a4a77733af8f49648000e2c779e176e4874609ca3d22a88beac09c4 \
gpg: DBG:
f4556a9a25636ac6acc33e366356fb71f7c702771a622773ab55fe00cb4d3f71 \
gpg: DBG:
6d291871302dc35e0ecd9a37cf60887d9b65e2f751172eb9c81e5c9bb76d3b07 \
gpg: DBG:
f2589f29196761f39d9786956ba8d20a2a4df6f0157861bc49a972d923567135 \
gpg: DBG:
a45bcaf8bded2a55edcdadd7109fef620b533fabb0a29bcf4a254a2a6043be46 \
gpg: DBG:
be8606d0e21075a1b1927f3a3c846a21abb52d64c3260c451a7a9688ff290caf \
gpg: DBG:
9be60639618cd547dd6ad5beed0dd0167ba01fafbcf0b8650b02bd47166d5705 \
gpg: DBG:
2b30fd7314625b925b4638469524b54d084f1e4bec5fd3ed19b576fc25fffe27 \
gpg: DBG:
cf71b534be9cf865f4db030bf99f2617f4520c6c47bf94593af2fe91800cc838 \
gpg: DBG:
8e43c86864d5338b53ef88d65657b5ba241072cdc4b1744b44bd01ccbf9e8124 \
gpg: DBG:
83fb23c00e94900bd94c3070c0dfbfd85a8244e07b22f275376dd9ba8b8af16b \
gpg: DBG:
6f79ed424330e4b4611478863ad67819a1a12fe86ec6bb466d8823d5982c462a \
gpg: DBG:
4a2f35a8369092487d66d12f75e7701205e2d3b6b5932e01a98d66e2ac61243a \
gpg: DBG:
d97d8f5c46d7d965d27e1dbaee09af1c2787121845d11a73c8a3b5b6dc66d44b \
gpg: DBG:
gpg: DBG: rsa_verify
n:+ac04bff70099263c05a8a3be359f82648d18b3b0e5b7fd15994c438683ba175b \
gpg: DBG:
7d6763f59f8778f01957fa82a3edcc94896de20f1fe8b0e4d214db863f18013f \
gpg: DBG:
8e4ab9b4d16e4381cca8b877db3399a99aa8475c6ba9b6e04143e5e55ac8c438 \
gpg: DBG:
323e5365abef50c0468dc8afeb03cd0e15846393d5a52aaa7b60ade16b834214 \
gpg: DBG:
d8be2000ac9550327215c2e8da95cd8e5ba60dbf2846f139ffd44e1e3a1dd366 \
gpg: DBG:
e3e7c0a7c1dd8924501e8f93bfb18020fbae5c3f942a0e8b0c61f5561ee9b17d \
gpg: DBG:
23521cabc4c26213236720824a0356c34af4e22ee1da9dde2d151e1b0b0e04d6 \
gpg: DBG:
a63df7817aadaa43964bd57de7c1c4d0092ba132a9e5bd8bb05335d5e195a5b4 \
gpg: DBG:
c47d121004021f3648a13da771edf0a48601fc047b9aa54d4f58fba2f53b680e \
gpg: DBG:
29e2e8c6101f050fc5035f08f38300b1c799e6631efff5eb78c1d8898c6862cf \
gpg: DBG:
3cc167e371817499afff072f5b3f8e150a4c836580911d17f47fc460ae8d6547 \
gpg: DBG:
ca4b067811cae95590e294e89610af96aeb834697d9525d86ce74129e432dc7c \
gpg: DBG:
4380807b1eb6fd5dfc5604ab3d050bf9f1ba589979f914717e11807b02787681 \
gpg: DBG:
66b729babd216b2e85beb3565d2583fc1fff7c69a6ec91226b40b2fe0aead4f9 \
gpg: DBG:
7625d05eb251e3ab8a85f16981c85ec03d745db81dee38ca948e4aa5aff14529 \
gpg: DBG:
gpg: DBG: rsa_verify    e:+010001
gpg: DBG: rsa_verify
cmp:+01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:
ffffffffffffffffffffff003031300d0609608648016503040201050004206b \
gpg: DBG:
gpg: DBG: rsa_verify    => Bad signature
--8<---------------cut here---------------end--------------->8---

@_date: 2017-09-28 15:20:39
@_author: Peter Lebbing 
@_subject: preferring --check-sigs over --list-sigs [was: Re: Houston, we 
Okay, I made a boo boo regarding text wrapping. Let me repaste the debug --8<---------------cut here---------------start------------->8---
gpg: DBG: rsa_verify data:+01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffff003031300d0609608648016503040201050004208f \
gpg: DBG:                  a83f9358156973aa13d8bec76f29f960a5ef0baf4f9ecb63df7a0296ea1f46
gpg: DBG: rsa_verify  sig:+7c0d84121a51ae5f5e99d131fc0e0e1e9157b03375b65bfd706aef1b42776ccd \
gpg: DBG:                  c5ef1d4c7a4a77733af8f49648000e2c779e176e4874609ca3d22a88beac09c4 \
gpg: DBG:                  f4556a9a25636ac6acc33e366356fb71f7c702771a622773ab55fe00cb4d3f71 \
gpg: DBG:                  6d291871302dc35e0ecd9a37cf60887d9b65e2f751172eb9c81e5c9bb76d3b07 \
gpg: DBG:                  f2589f29196761f39d9786956ba8d20a2a4df6f0157861bc49a972d923567135 \
gpg: DBG:                  a45bcaf8bded2a55edcdadd7109fef620b533fabb0a29bcf4a254a2a6043be46 \
gpg: DBG:                  be8606d0e21075a1b1927f3a3c846a21abb52d64c3260c451a7a9688ff290caf \
gpg: DBG:                  9be60639618cd547dd6ad5beed0dd0167ba01fafbcf0b8650b02bd47166d5705 \
gpg: DBG:                  2b30fd7314625b925b4638469524b54d084f1e4bec5fd3ed19b576fc25fffe27 \
gpg: DBG:                  cf71b534be9cf865f4db030bf99f2617f4520c6c47bf94593af2fe91800cc838 \
gpg: DBG:                  8e43c86864d5338b53ef88d65657b5ba241072cdc4b1744b44bd01ccbf9e8124 \
gpg: DBG:                  83fb23c00e94900bd94c3070c0dfbfd85a8244e07b22f275376dd9ba8b8af16b \
gpg: DBG:                  6f79ed424330e4b4611478863ad67819a1a12fe86ec6bb466d8823d5982c462a \
gpg: DBG:                  4a2f35a8369092487d66d12f75e7701205e2d3b6b5932e01a98d66e2ac61243a \
gpg: DBG:                  d97d8f5c46d7d965d27e1dbaee09af1c2787121845d11a73c8a3b5b6dc66d44b \
gpg: DBG:                  d849cd96decb42ad8d4d7df80da7aa9ddc072c37fea1cf68c349d7c3a4909e2a
gpg: DBG: rsa_verify    n:+ac04bff70099263c05a8a3be359f82648d18b3b0e5b7fd15994c438683ba175b \
gpg: DBG:                  7d6763f59f8778f01957fa82a3edcc94896de20f1fe8b0e4d214db863f18013f \
gpg: DBG:                  8e4ab9b4d16e4381cca8b877db3399a99aa8475c6ba9b6e04143e5e55ac8c438 \
gpg: DBG:                  323e5365abef50c0468dc8afeb03cd0e15846393d5a52aaa7b60ade16b834214 \
gpg: DBG:                  d8be2000ac9550327215c2e8da95cd8e5ba60dbf2846f139ffd44e1e3a1dd366 \
gpg: DBG:                  e3e7c0a7c1dd8924501e8f93bfb18020fbae5c3f942a0e8b0c61f5561ee9b17d \
gpg: DBG:                  23521cabc4c26213236720824a0356c34af4e22ee1da9dde2d151e1b0b0e04d6 \
gpg: DBG:                  a63df7817aadaa43964bd57de7c1c4d0092ba132a9e5bd8bb05335d5e195a5b4 \
gpg: DBG:                  c47d121004021f3648a13da771edf0a48601fc047b9aa54d4f58fba2f53b680e \
gpg: DBG:                  29e2e8c6101f050fc5035f08f38300b1c799e6631efff5eb78c1d8898c6862cf \
gpg: DBG:                  3cc167e371817499afff072f5b3f8e150a4c836580911d17f47fc460ae8d6547 \
gpg: DBG:                  ca4b067811cae95590e294e89610af96aeb834697d9525d86ce74129e432dc7c \
gpg: DBG:                  4380807b1eb6fd5dfc5604ab3d050bf9f1ba589979f914717e11807b02787681 \
gpg: DBG:                  66b729babd216b2e85beb3565d2583fc1fff7c69a6ec91226b40b2fe0aead4f9 \
gpg: DBG:                  7625d05eb251e3ab8a85f16981c85ec03d745db81dee38ca948e4aa5aff14529 \
gpg: DBG:                  f6ae044278dec55f50ccb7c918d7f9b41443df640ddebc7d1632bf90d47dc9cf
gpg: DBG: rsa_verify    e:+010001
--8<---------------cut here---------------end--------------->8---

@_date: 2017-09-28 15:22:55
@_author: Peter Lebbing 
@_subject: preferring --check-sigs over --list-sigs 
Ugh, really, how hard can it be? :-(
Sorry about this. I'll try to get it right this time.
--8<---------------cut here---------------start------------->8---
gpg: DBG: rsa_verify data:+01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffff003031300d0609608648016503040201050004208f \
gpg: DBG:                  a83f9358156973aa13d8bec76f29f960a5ef0baf4f9ecb63df7a0296ea1f46
gpg: DBG: rsa_verify  sig:+7c0d84121a51ae5f5e99d131fc0e0e1e9157b03375b65bfd706aef1b42776ccd \
gpg: DBG:                  c5ef1d4c7a4a77733af8f49648000e2c779e176e4874609ca3d22a88beac09c4 \
gpg: DBG:                  f4556a9a25636ac6acc33e366356fb71f7c702771a622773ab55fe00cb4d3f71 \
gpg: DBG:                  6d291871302dc35e0ecd9a37cf60887d9b65e2f751172eb9c81e5c9bb76d3b07 \
gpg: DBG:                  f2589f29196761f39d9786956ba8d20a2a4df6f0157861bc49a972d923567135 \
gpg: DBG:                  a45bcaf8bded2a55edcdadd7109fef620b533fabb0a29bcf4a254a2a6043be46 \
gpg: DBG:                  be8606d0e21075a1b1927f3a3c846a21abb52d64c3260c451a7a9688ff290caf \
gpg: DBG:                  9be60639618cd547dd6ad5beed0dd0167ba01fafbcf0b8650b02bd47166d5705 \
gpg: DBG:                  2b30fd7314625b925b4638469524b54d084f1e4bec5fd3ed19b576fc25fffe27 \
gpg: DBG:                  cf71b534be9cf865f4db030bf99f2617f4520c6c47bf94593af2fe91800cc838 \
gpg: DBG:                  8e43c86864d5338b53ef88d65657b5ba241072cdc4b1744b44bd01ccbf9e8124 \
gpg: DBG:                  83fb23c00e94900bd94c3070c0dfbfd85a8244e07b22f275376dd9ba8b8af16b \
gpg: DBG:                  6f79ed424330e4b4611478863ad67819a1a12fe86ec6bb466d8823d5982c462a \
gpg: DBG:                  4a2f35a8369092487d66d12f75e7701205e2d3b6b5932e01a98d66e2ac61243a \
gpg: DBG:                  d97d8f5c46d7d965d27e1dbaee09af1c2787121845d11a73c8a3b5b6dc66d44b \
gpg: DBG:                  d849cd96decb42ad8d4d7df80da7aa9ddc072c37fea1cf68c349d7c3a4909e2a
gpg: DBG: rsa_verify    n:+ac04bff70099263c05a8a3be359f82648d18b3b0e5b7fd15994c438683ba175b \
gpg: DBG:                  7d6763f59f8778f01957fa82a3edcc94896de20f1fe8b0e4d214db863f18013f \
gpg: DBG:                  8e4ab9b4d16e4381cca8b877db3399a99aa8475c6ba9b6e04143e5e55ac8c438 \
gpg: DBG:                  323e5365abef50c0468dc8afeb03cd0e15846393d5a52aaa7b60ade16b834214 \
gpg: DBG:                  d8be2000ac9550327215c2e8da95cd8e5ba60dbf2846f139ffd44e1e3a1dd366 \
gpg: DBG:                  e3e7c0a7c1dd8924501e8f93bfb18020fbae5c3f942a0e8b0c61f5561ee9b17d \
gpg: DBG:                  23521cabc4c26213236720824a0356c34af4e22ee1da9dde2d151e1b0b0e04d6 \
gpg: DBG:                  a63df7817aadaa43964bd57de7c1c4d0092ba132a9e5bd8bb05335d5e195a5b4 \
gpg: DBG:                  c47d121004021f3648a13da771edf0a48601fc047b9aa54d4f58fba2f53b680e \
gpg: DBG:                  29e2e8c6101f050fc5035f08f38300b1c799e6631efff5eb78c1d8898c6862cf \
gpg: DBG:                  3cc167e371817499afff072f5b3f8e150a4c836580911d17f47fc460ae8d6547 \
gpg: DBG:                  ca4b067811cae95590e294e89610af96aeb834697d9525d86ce74129e432dc7c \
gpg: DBG:                  4380807b1eb6fd5dfc5604ab3d050bf9f1ba589979f914717e11807b02787681 \
gpg: DBG:                  66b729babd216b2e85beb3565d2583fc1fff7c69a6ec91226b40b2fe0aead4f9 \
gpg: DBG:                  7625d05eb251e3ab8a85f16981c85ec03d745db81dee38ca948e4aa5aff14529 \
gpg: DBG:                  f6ae044278dec55f50ccb7c918d7f9b41443df640ddebc7d1632bf90d47dc9cf
gpg: DBG: rsa_verify    e:+010001
gpg: DBG: rsa_verify  cmp:+01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff \
gpg: DBG:                  ffffffffffffffffffffff003031300d0609608648016503040201050004206b \
gpg: DBG:                  6e7c7823d29203332faae25a3abb18a7e36689a77e5f32feb57c73e7e0ec48
--8<---------------cut here---------------end--------------->8---

@_date: 2017-09-28 20:15:33
@_author: Peter Lebbing 
@_subject: onwnertrust and trust signature (tsig) interactions 
I didn't formulate what I meant well enough, I think. Sorry.
Fair enough; that I would expect, actually. It has to start somewhere,
and that's what "ultimate" is for, on your own keys. If "ultimate" keys
didn't have this capability, there would be no root for the trust
This I would not expect, but it is what I meant with my comment: do they
interact in this case, or not?
First of all, trust signatures indicate a maximum depth. Regular full
ownertrust does not; so are we to interpret this as unlimited depth
then? That sounds wrong.
Secondly, it seems undesirable. If I /want/ to delegate trust decisions,
I would tsign somebody, along with a maximum depth that is no deeper
than necessary[1]. However, if I just regular-sign :) their key and
assign ownertrust, what I'm trying to say is: "I trust this person to
check identities well". I'm not saying "I trust this person to decide
for me whether other people are trustworthy". I don't even care about
the whole trust signature business unless I tsigned some key myself. In
other words, as long as I don't tsign anything myself, I want
trust-model pgp to behave as trust-model classic. It seems to be the
path of least surprise.
So even if the person who has my full trust tsigns some key, I would
like to treat that signature as a regular key validating signature, and
wouldn't want it to influence ownertrust assigned to the person holding
that signed key.
When I'm trying to explain the Web of Trust here on the list, I usually
say "don't bother with or worry about trust signatures, they're only
used in very specific settings". If, however, they do affect the regular
Web of Trust, I've been explaining it wrong all along.
I'd like that as well. Because I was almost convinced that full
ownertrust would not "activate" trust signatures, but wanted to err on
the side of caution and not state this as truth while unverified. But if
it's important to figure out what it is, or is meant to be.
[1] As determined by company signing policy, for instance.

@_date: 2017-09-29 15:53:46
@_author: Peter Lebbing 
@_subject: Information on scdaemon protocol commands 
Talk to  the agent :-).
$ gpg-connect-agent
# SETATTR  # This command is used to store data on a a smartcard.  The allowed
# names and values are depend on the currently selected smartcard
# application.  NAME and VALUE must be percent and '+' escaped.
# However, the current implementation assumes that NAME is not
# escaped; this works as long as no one uses arbitrary escaping.
# A PIN will be requested for most NAMEs.  See the corresponding
# setattr function of the actually used application (app-*.c) for
# details.

@_date: 2018-04-06 11:27:58
@_author: Peter Lebbing 
@_subject: GnuPG usage for automatic remote decryption 
Let me clarify because it is not obvious: this is not the case. It is
perfectly valid to have a secret key without a passphrase. The drawback
is anyone with file access to the on-disk copy of the secret key has
full possession of it.
Try to work this thought out in detail for yourself: it depends on your
threat model. Try to think of ways an attacker can access the file with
the secret key. Think what that attacker could do with that level of
access, even if the secret key were not available to them. Could they
perhaps still fully compromise the process? If so, does it still matter
that they can also access the private key?
It might be wise to exclude the file containing the private key from
backups, though. That avoids a whole different class of access to cold
storage. I don't backup my SSH on-disk private keys. Should one of my
systems crash and need to be restored from backup, I would generate new
SSH keys and distribute them. Perhaps in your case it would also be
better to just bite the bullet and generate new keys whenever the system
is unrecoverable.
I don't think this makes sense.
A public key is inherently designed to be disseminated to anybody. The
system is designed like that, it expects public data to be non-secret.
Encrypting to the public key, if it were possible, means you intend for
anybody to be able to decrypt it. That's not encryption.
If you want to be sure that something originated from a person holding a
private key, sign it with that private key. That proves that the data
was not modified from what they intended to sign.

@_date: 2018-04-11 16:29:19
@_author: Peter Lebbing 
@_subject: GnuPG usage for automatic remote decryption 
I'm not sure what you're salting exactly, but anyway, this is not the focal
point of my reply. By the way, there are many ways to do what you describe in
such a way that the hash is utterly pointless and not authentication. For a
sweet example, check the use of CRC inside a stream cipher in WEP, the original
encryption layer of wireless LANs :-). Stream cipher + CRC = major D'oh!
This is only true for some algorithms and not for others, and even then only to
some extent.
For example, with RSA, encryption is: encrypt message with random key,
RSA-encrypt this random key to the private key of the intended recipient.
RSA signatures is the opposite, where a hash matching the signed data is
RSA-"encrypted" to the public key. Only the private key can "encrypt" to the
public key, so when anybody uses the public key to "decrypt" it, they can verify
the hash matches and was produced by the holder of the private key.
So for encryption, you choose the number and send it to the private key.
In signing, you obtain the number by hashing and send it to the public key.
They are mathematically equivalent. But note that the public and private key are
not interchangeable. The public exponent usually has a very low Hamming weight
while the private exponent is derived after fixing the public exponent. Simply
exchanging public and private variables would not give an equivalent keypair,
although mathematically they'd still work.
Obscurity can be obtained by many low-complexity methods and is not a goal of
OpenPGP. There is no O in PGP :-). (Oh, and the GnuPG implementation wouldn't
usually add such a major deviation from the OpenPGP standard.)
And how do you see this as authentication? The way you describe it, I'm thinking
you simply reverse the roles of the public and private key, and you are thus
encrypting the session key to the public key with your private key instead of
the other way around. What does this achieve? As you'd then be sharing the
symmetric encryption key with the world, anybody could re-encrypt their
malicious data to that symmetric key, tag the so-called "encrypted" asymmetric
algorithm output that only the private key can produce on and presto,
"authenticated" data. If this is what you meant, well, I've just explained it's
not authentication. If this is not what you meant, please elaborate.
Okay, that was a wall of words with way too long sentences. So let me combine it
with an example.
1 - We will use an RSA keypair with modulus n, public exponent e and private
exponent d
2 - Choose symmetric key: sk = 0x2dfe0af9eeb3352c390791f4710a63da
3 - Encrypt "Transfer $ 1000 to Mike" using AES and the symmetric key sk from 2.
Let's call this result "BONAFIDEDATA"
4 - Compute s = sk^d mod n
This is "encrypting" the symmetric key sk to the public key. It is equal to what
PKCS would consider the signature primitive RSASP1, mathematically equivalent
to the decryption primitive RSADP.
5 - Send s + "BONAFIDEDATA" to recipient
6 - Recipient computes sk = s^e mod n
This is "decrypting" the symmetric key sk using the public key. It is equal to
what PKCS would consider the verification primitive RSAVP1, mathematically
equivalent to the encryption primitive RSAEP.
7 - Recipient decrypts "BONAFIDEDATA" using the correct sk, yielding "Transfer $
1000 to Mike".
8 - Mike has spending money.
Now I come along.
1 - Intercept or observe on the network s + "BONAFIDEDATA". Preventing reception
is optional.
2 - I compute sk = s^e mod n
This is public data.
3 - Encrypt "Transfer $ 10,000 to Peter" using AES and sk, which we correctly
determined to be 0x2dfe0af9eeb3352c390791f4710a63da. Let's call the result
4 - Send s + "FAKEDDATA" to recipient
5 - Recipient computes sk = s^e mod n
This is "decrypting" the symmetric key sk using the public key. It is equal to
what PKCS would consider the verification primitive RSAVP1, mathematically
equivalent to the encryption primitive RSAEP.
6 - Recipient decrypts "FAKEDDATA" using the correct sk, yielding "Transfer
$ 10,000 to Peter".
7 - Peter has spending money, and then some.
If you were to use OpenPGP encryption instead of a shared symmetric key, key
management and access revocation becomes much simpler. Additionally, you'd be
encrypting much less data with the same symmetric key. So there are some more
gotcha's with a static symmetric key: don't choose a symmetric algorithm with a
64-bit block size, etcetera. That's the thing about inventing your own crypto,
even at such a high level. It seems much simpler to me to use a private key that
is stored in plaintext on your recipient machine. Or TLS with the same, which by
the way is an extremely common setup, much more so than a passphrase-less
OpenPGP private key, even though they are the same principle.

@_date: 2018-08-01 18:06:48
@_author: Peter Lebbing 
@_subject: Encrypt USB-HDD with LUKS using OpenPGP smartcard? 
On a system with systemd: no, I don't think this can be done. Systemd
doesn't want to implement cryptsetup keyscripts, and those would be needed.
On a different system: it depends. What system are we talking about? :-)

@_date: 2018-08-01 18:32:19
@_author: Peter Lebbing 
@_subject: Encrypt USB-HDD with LUKS using OpenPGP smartcard? 
AFAIK, this is just systemd delegating passphrase querying to the
physically present user. I suppose if you could somehow influence where
it got the passphrase from, there might be a way to achieve it, but I
have no idea how. That's all the direction I can provide.

@_date: 2018-08-02 14:14:17
@_author: Peter Lebbing 
@_subject: Cannot decrypt file encrypted with enQsig 
> It seems like the card reader
cannot decrypt the session key. *Is that correct?*
The fact this "enterprise solution" decided to encrypt it to your
primary, non-encryption-capable, key, is a big red flag that this
"solution" is not compatible to "modern-day" OpenPGP. So I think it's a
safe bet they also screwed up the PKESK packet for your subkey, and the
error is indeed related to it not representing a valid session key.

@_date: 2018-08-15 11:50:58
@_author: Peter Lebbing 
@_subject: Cannot decrypt file encrypted with enQsig 
Answering this in any detail would be a lot of answer. But the basic
mechanism is --debug, --debug-level or perhaps just --debug-all and
sifting through it. At the same time having a copy of RFC 4880 and
PKCS to explain all the numbers. The fact that it's a smartcard makes
this more difficult: when the decrypt action fails, you don't see the
actual numerical result. To protect against attacks, the smartcard
denies to divulge this data to protect the private key.
I don't think so. There are two ways to encode the packet tag, and GnuPG
takes the "old" if possible. RFC 4880 Section Section 4.2.
Yeah, sorry, this occured due to a transient failure in my brain matter
;-). When I wrote it, I really thought you were the first one to use the
acronym, so I could save time by using it as well. Unfortunately this
wasn't the case.

@_date: 2018-08-15 12:13:59
@_author: Peter Lebbing 
@_subject: Cannot decrypt file encrypted with enQsig 
Good find! This sounds plausible. I myself had completely forgotten
reading about this bug.
Besides, I completely dismissed the encrypting application in this case
because it decided to encrypt the session key to your primary key as
well, which is very clearly not according to specification.
Here's the catch: unless you have an on-disk copy of your private
encryption key, you can't. As I just wrote in my other answer in this
thread, the smartcard denies giving out the data it didn't like to see.
But whether 3DES was used can only be decided by looking at the
decrypted... erm... PKESK packet X-D.
If you have a computer with an on-disk copy, you could try it with that
on-disk copy and it will simply tell you when you ask for more verbosity
and stuff. The usual caveats apply: you are using a smartcard to protect
your private key material, but I'm now suggesting you use an on-disk
copy of the key. Treat it like you would if you were transferring the
key to a new smartcard to replace a broken one.
This strange product also encrypted to your primary key, but it's
probably only more difficult to use this than it is to use your
encryption key. You'd have to, again, load an on-disk copy and then
change the usage flags to make in encryption-capable. But if you don't
have a backup of the encryption key but do have one of the primary key,
you could do it. But after all this think about whether you should use
an encryption key you don't have a backup of: if your smartcard ever
dies, you can't decrypt anything anybody has ever sent you encrypted.
Because it inspects the decryption result for sanity before handing it
back to the computer. This is done because an attacker might learn
information about the private key if it were able to just have the
smartcard decrypt anything it was given. And the whole point of a
smartcard is that it should not be possible (or at least very hard) to
extract the private key from the smartcard.
I think the bug boils down to the card incorrectly dismissing the
decryption result as invalid. But I'm not intimately acquainted with the
bug, so this might be a misinterpretation.

@_date: 2018-08-15 12:57:04
@_author: Peter Lebbing 
@_subject: Encrypt USB-HDD with LUKS using OpenPGP smartcard? 
Hey, that systemd service file seems to basically grab cryptsetup
handling from the clutches of systemd, enabling all sorts of operations
not possible with systemd's cryptsetup handling! That's really clever!
I'm saving this for future reference, thanks.

@_date: 2018-08-16 09:58:38
@_author: Peter Lebbing 
@_subject: ECC smartcard (was: Cannot decrypt file encrypted with enQsig) 
I didn't look at the Trezor to check, but I'll assume it allows usage
with GnuPG based on the context you brought it up in.
Note that many OpenPGP peers might not support ECC. You could add ECC
subkeys to your current key, and arrange for peers that support them to
prefer those. That way, anybody able to send you an ECC-encrypted
document could do so, and others could fall back to the RSA encryption
For signatures, you'd either still use RSA or accept the fact that only
people with ECC-supporting clients could verify your signatures. The
alternative is signing with both keys; if both are on cards/tokens, that
becomes tiresome really quickly, I'd imagine.
If you add ECC subkeys to your current key, you'd still use an RSA
primary key, without anything elliptic about it.
There's also the GnuK, which is free software.
My 2 cents,

@_date: 2018-08-16 18:31:19
@_author: Peter Lebbing 
@_subject: Unable to get gpg-preset-passphrase working with gpg2 + gpg-agent 
gpg-preset-passphrase wants a keygrip, not a key fingerprint. To get the keygrip for a specific key, use f.e.:
--8<---------------cut here---------------start------------->8---
$ gpg --with-keygrip -k 211601B877A3395Apub   rsa1024 2012-03-17 [SC] [expires: 2018-08-23]
      825472F37172B95ADC7349BE98B67DE4DCDFDFA4
      Keygrip = 2F677680CA15F6F7B963AF35822E8EC01FBF840A
uid           [  full  ] Test Teststra uid           [  full  ] Test Teststra (Koning van Wezel) sub   rsa1024 2012-03-17 [E]
      Keygrip = 15CB764B81D542CF921978CA89910C69D53F4E2D
sub   rsa2048 2016-01-12 [A]
      Keygrip = 3D88DC9D60F791821AF8D537EEAC3C8DF7720D63
--8<---------------cut here---------------end--------------->8---
Or for machine-parseable output, f.e.:
--8<---------------cut here---------------start------------->8---
$ gpg --batch --with-colons --with-keygrip -k 211601B877A3395Atru::7:1534436270:1537177125
uid:f::::1534436249::A57955B7E1CD67534EBEB1E2F56C1FA882CDDE44::Test Teststra :
uid:f::::1534436247::B56114536967B4C81D29D6942712F43E831224A5::Test Teststra (Koning van Wezel) :
--8<---------------cut here---------------end--------------->8---
Scan lines up to the signing subkey, and take the grp-record that follows the signing subkey. See doc/DETAILS for details about the preset-passphrase works on individual keys, if you need to preset both encryption and signature keys, use it once for each keygrip.
By the way, the GnuPG 2.1 in Ubuntu 16.04 hasn't been updated in almost two years. I don't feel comfortable with it, and I would consider

@_date: 2018-08-16 18:34:32
@_author: Peter Lebbing 
@_subject: Unable to get gpg-preset-passphrase working with gpg2 + gpg-agent 
s/two years/two and a half years/
It hasn't been updated since release. For a moment I was thinking about
the .10 releases.

@_date: 2018-08-21 10:57:15
@_author: Peter Lebbing 
@_subject: Q: select between multiple signing key 
From the man page:
Section "HOW TO SPECIFY A USER ID", subsection "By key Id":
And so:
$ gpg2 --default-key A65B17610C406CE6\! --clearsign .bashrc

@_date: 2018-08-26 10:41:33
@_author: Peter Lebbing 
@_subject: Communication with card reader encrypted? 
The OpenPGP smartcard and generic smartcard protocols do define "Secure
Messaging", but I don't think this is commonly used for cabled OpenPGP
smartcards. So: no, I think in most cases data is unencrypted in USB wires.
I think you'll need to trust the cable anyway, since a malicious USB
device by someone with the means and motivation to attack your OpenPGP
smartcard will most likely be able to compromise your phone instead.
Securely using cryptography on a compromised operating system is simply
So in the end, it doesn't seem to make a difference: if the cable is
malicious, you're done anyway.
Even if it were encrypted, I think we still need to think about
man-in-the-middle resistance of Secure Messaging. I think there's a
distinct possibility it is only meant to thwart passive attacks, but I
haven't looked into it.

@_date: 2018-08-26 11:31:13
@_author: Peter Lebbing 
@_subject: Communication with card reader encrypted? 
I meant: even if the communication were encrypted and protected against
men in the middle, you still cannot use a compromised cable, ever, since
the compromised cable will compromise your entire phone instead of the
encrypted communication.
So avoiding the need of a separate cable altogether is indeed a
possibility if you're concerned about this. However, you'll need to
avoid cables for anything you plug into your phone, not just for your
smartcard reader. If instead you just store your charger, its cable and
your smartcard reader together, you can use that one cable for both
charging your phone and using the smartcard reader. And clearly you'll
need to protect all these parts against tampering, not just the
smartcard reader, regardless of whether your smartcard reader has a lead
or not.
Nah, for getting back that data you accidentally deleted ;-).

@_date: 2018-08-30 13:00:11
@_author: Peter Lebbing 
@_subject: exporting always prompts for password 
For GnuPG 2.1 and above: GnuPG really needs to know the password to
export an OpenPGP secret key. The key is stored on disk with a different
encryption scheme than in the export, so a decrypt-encrypt cycle is
needed to change the encryption scheme of the data.
It looks like gpg-preset-passphrase has no effect for this particular
application either. So I think you will have to pass the passphrase on
each export invocation, unless someone else has an idea :-). I did once
cobble together something that piped a passphrase from the agent
passphrase cache back to the agent; more to see if it could be done.
Expiration is public data, why do you want to refresh the secret data as
well? On restoration from backup, just import the stale secret data and
then refresh it with the latest public data by importing that subsequently.
The secret export includes a copy of the public data, so the secret data
will indeed have stale expiration dates. But you can refresh it from a
backup of the public data.

@_date: 2018-12-30 12:35:34
@_author: Peter Lebbing 
@_subject: Unblocking the user PIN does not work with a new PIN 
PINs need to be at least 6 characters long (8 for Admin PIN). Do you
perhaps try to set a too short PIN?

@_date: 2018-02-02 12:23:37
@_author: Peter Lebbing 
@_subject: How to avoid Passphrase prompt 
Hah, now I understand! :-)
There are two methods: gpg-preset-passphrase and pinentry loopback.
--8<---------------cut here---------------start------------->8---
max-cache-ttl 2147483647
--8<---------------cut here---------------end--------------->8---
gpg --with-keygrip -K
--8<---------------cut here---------------start------------->8---
sec   rsa1024 2012-03-17 [SC] [expires: 2018-02-07]
      825472F37172B95ADC7349BE98B67DE4DCDFDFA4
      Keygrip = 2F677680CA15F6F7B963AF35822E8EC01FBF840A
uid           [  full  ] Test Teststra (Koning van Wezel) uid           [  full  ] Test Teststra ssb   rsa1024 2012-03-17 [E]
      Keygrip = 15CB764B81D542CF921978CA89910C69D53F4E2D
ssb   rsa2048 2016-01-12 [A]
      Keygrip = 3D88DC9D60F791821AF8D537EEAC3C8DF7720D63
--8<---------------cut here---------------end--------------->8---
Note keygrip for [E] subkey.
Do this every time after starting the server/starting gpg-agent, to unlock the key:
gpg-preset-passphrase --preset 15CB764B81D542CF921978CA89910C69D53F4E2D
(Type in the password. Currently no pinentry support.)
Second method: pinentry loopback.
This method has a problem. Your code supplies the passphrase. Where is the passphrase stored? If it is simply stored on the hard disk, the passphrase is probably useless. An attacker can just read the passphrase. What are you protecting against?
It is simple, though:
echo passphrase | gpg --batch --pinentry-mode loopback --passphrase-fd 0 -d test.gpg
(Use code to pass the passphrase on some FD, don't actually use echo).
All this was tried out on Linux. I don't have Windows, or the necessary knowledge. I think it should work on Windows.

@_date: 2018-02-02 12:52:02
@_author: Peter Lebbing 
@_subject: Workaround for missing pinentry support in gpg-preset-passphrase? 
It is a pity gpg-preset-passphrase currently has no pinentry support.
While doing the dishes, I thought: can't we work around that for a bit? I'd like to know what people think of this hack:
--8<---------------cut here---------------start------------->8---
gpg-connect-agent -q '/datafile -' 'get_passphrase --data workaround:pass + Enter+passphrase: +' 'clear_passphrase workaround:pass' /bye | /usr/lib/gnupg2/gpg-preset-passphrase --preset 15CB764B81D542CF921978CA89910C69D53F4E2D
--8<---------------cut here---------------end--------------->8---
As far as I can tell, the first part neatly echoes a pinentry-obtained passphrase on stdout. This is then passed to gpg-preset-passphrase.
A neat work-around? Or an ugly hack that leads to system compromise, uncontrolled nuclear fusion in the processor and a new world war?
(By the way, I didn't know how to pass an empty string, and all the prompts are not optional despite what "help" says. So I passed single spaces for the text.)

@_date: 2018-02-06 10:51:30
@_author: Peter Lebbing 
@_subject: gpg: do_plaintext(): wrote 1210414045 bytes but expected 
While you are waiting for someone who knows what's going on to answer, I
think you should try to add --batch to the command line. Any
non-interactive use of the gpg binary always needs to have --batch. The
same pretty much goes for --with-colons, I don't know whether or how you
interpret output from gpg, but --with-colons gives you the
machine-readable form.
It's possible that it behaves a bit more pleasantly for this problem
with --batch, as it now understands that it's being used as such.

@_date: 2018-02-06 11:03:19
@_author: Peter Lebbing 
@_subject: OpenPGP card && exporting secret keys 
You need to do it the other way around: you need to create on-disk keys
and export them to a card. It is explicitly not possible to get a secret
key /from/ an OpenPGP card.
If you chose to have a backup of your encryption key while generating
card keys, this is what actually happens for the encryption key, but in
a streamlined process. The backup file that is created in that way can
be used to populate a new OpenPGP card once your current one breaks, but
only for the encryption subkey. It contains the actual private key material.
I think it will generate signature and authentication keys on the card;
I don't use this mode because I have more trust in GnuPG's random number
generator than any RNG on a smartcard. So I always just create an
on-disk key, back that up, and subsequently move the keys to the card.
Obviously you need to think about data left on disk after removal of
files; I'm just giving a quick outline. Hint: I don't have a hard disk
plugged into the system I'm using to do this.

@_date: 2018-02-11 12:56:40
@_author: Peter Lebbing 
@_subject: problems sending to the list 
I think you're not setting the "envelope from" correctly. While the
e-mail itself has your normal e-mail address, the bounce is going to the
address I quoted above, so apparently that is the envelope sender.
E-mail delivery works with the addresses in the envelope, and actually
the "From:" in the headers of the mail are not related to that. It would
appear that your ISP's server ends up delivering the mail somewhat like
MAIL FROM:
RCPT TO:
That envelope sender is causing problems further down the road, leading
to a bounce.
If you tell me off-list what MUA you're using to send the mail I might
be able to help configure it correctly.

@_date: 2018-02-18 11:33:10
@_author: Peter Lebbing 
@_subject: How can we utilize latest GPG from RPM repository? 
I don't think it is. I'm sorry your question didn't get answered
satisfactorily; that's just how things can go on community mailing lists.
I appreciate your well-formulated arguments for running GnuPG v.2.2.
I really don't think that it is the task for any upstream to provide
packages for distributions. That truly is what the distributions
themselves are for. For some upstreams it might make sense to provide
their own packages for certain distributions, but I think it's more the
exception that the norm.
Since nobody answered with "Oh yeah I happen to package it myself, if
you trust me, you can get it here" or "Oh yeah I know of this person who
packages them", etcetera, my guess is that nobody knows of such a
packaging effort. It's hard to answer affirmatively if you don't know
the affirmative answer :-).
Can I point out that even though you did not like Jeffrey Lightner's
response, Dirk Gottschalk and Konstantin Ryabitsev also replied? If you
could indeed just recompile the Fedora packages, that seems like a
pretty direct route. You do become responsible for updates and "security
support" yourself (in what sense is it still support if you do it
yourself, but hey).
And I wonder if perhaps your interpretation of Jeffrey Lightner's words
was a bit more abrasive than he intended them to be when he wrote those
words, but that is something only Jeffrey Lightner himself can
definitively answer.
Back to the matter at hand. Is it possible for CentOS to provide newer
packages than RHEL? I surmise RHEL will probably not listen to you
unless you get a paid support contract. If CentOS cannot significantly
deviate from RHEL, there doesn't seem to be a gratis way to influence
package versions for CentOS, right? You're dependent on someone
providing packages outside of the distribution proper.
Note, by the way, that interoperability between GnuPG 1.4 and 2.1/2.2 is
not that great, and that often distributions rely on GnuPG in their
internals, meaning there might not be a way to remove GnuPG 1.4 from a
system. It's why Debian deprecated 1.4 before packaging 2.1, so people
would not usually have a system where both are installed. If CentOS 7
relies on GnuPG 1.4, you will need to be careful with 2.1/2.2. Their
keyrings can get out-of-sync.
I'm sorry I don't have a ready answer; if I did, I'd have offered it
days ago...

@_date: 2018-02-18 22:37:59
@_author: Peter Lebbing 
@_subject: --verify with foo.gpg file does not assume signed data in foo? 
I'd like to suggest you shouldn't do it anyway. If somebody supplies you a
non-detached signed file with just a subtly different name, the only difference
will be this line "assuming..." is missing, it will still report a valid
signature. If you're human, like me, you won't notice, but just think "ha, a
valid signature" and continue to use the non-verified file. At this point, your
attacker has already managed to serve you the wrong .sig file, they also
probably supplied you the wrong file it was supposed to have signed.
I'm saying "a subtly different name" because otherwise GnuPG will still warn you:
gpg: WARNING: not a detached signature; file 'xxx' was NOT verified!
But it can't catch those cases where look-alike characters are used, and Unicode
is a vast collection of sometimes similar shapes.

@_date: 2018-02-19 21:54:35
@_author: Peter Lebbing 
@_subject: GPG encryption and decryption takes excessive time. 
GnuPG uses hybrid encryption. Content is already encrypted with
symmetric encryption, and only the randomly generated symmetric key, 16
or 32 bytes large usually, is encrypted asymmetrically to the recipient,
possibly twice as OP mentioned two customers.
Since symmetric mode of GnuPG uses passphrase stretching, I doubt that
would be faster anyway, though I haven't tried this.
The problem appears to be somewhere else. However, I think the OP should
provide more details. File sizes, specifications of the computers it
runs on, software versions...
My first instinct is: there is insufficient randomness, and GnuPG is
blocking waiting for more to become available before it can do any work.

@_date: 2018-02-20 11:30:44
@_author: Peter Lebbing 
@_subject: Why Operating Systems don't always upgrade GnuPG 
You are right and I feel stupid for suggesting it is uncontroversial.
Hell, you'd think running Debian stretch/stable (with its 2.1.18) on a
plethora of servers would be uncontroversial, but even that isn't
totally free of controversy. There are people having problems with
adjusting their process to use GnuPG 2.1+.
I am very grateful for all the work you put in to not only fix programs
in Debian depending on /usr/bin/gpg2 being 2.0, but also fix programs
depending on /usr/bin/gpg being 1.4. Because even though
co-installability was considered while designing 2.1, in practice 1.4
and 2.1+ don't mix well.
Thank you.
If done with care and attention, there are still situations where
installing GnuPG 2.2 on what is the most recent version of CentOS/RHEL
is a good thing to do. You have to carefully consider which software
will be using GnuPG, though.

@_date: 2018-02-21 11:53:56
@_author: Peter Lebbing 
@_subject: having trouble checking the signature of a downloaded file 
Note that not the key, but the /signature/ is made 14 years ago. So
we're talking about verifying the integrity of a really old file. The
author might not be available anymore or willing to expend any effort.
GnuPG 1.4 is kept around to verify such old files. So perhaps the OP
could use GnuPG 1.4 to verify the file; without further information
about the system he is using it is hard to explain how exactly to do
this. However, I get the feeling his OS is NetBSD :-). So if somebody
knows how GnuPG is installed there... (I don't)
This all comes with a major caveat. The reason you can't do it with
modern GnuPG is that the security of PGP-2 keys and signatures is no
longer at a sufficient level. So while it gives some confidence when the
signature verifies positively, a well-equipped attacker might have faked
it anyway!

@_date: 2018-02-21 12:07:48
@_author: Peter Lebbing 
@_subject: having trouble checking the signature of a downloaded file 
(Or the author might not have a more authentic copy of the file anymore
either. This is not the reason I'm self-replying though).
This sounds like there is no more assurance that the downloaded key is
authentic than that the downloaded file is authentic. When to decide
that a key is authentic is one of the more difficult problems of
practical cryptography use. Some people take confidence from downloading
identical copies of the key from multiple HTTPS websites. There are
still ways for an attacker to serve you the wrong one each time, but
it's better than nothing... The best is direct personal contact with the
owner of the key, but it seems a long shot.

@_date: 2018-02-21 17:55:13
@_author: Peter Lebbing 
@_subject: Why Operating Systems don't always upgrade GnuPG 
That would help for command-line usage for a user with only one private
key. But anything else might not use the default key.

@_date: 2018-02-22 16:05:57
@_author: Peter Lebbing 
@_subject: Being civil costs you nothing (was: How can we utilize latest GPG 
You are rapidly squandering good will here. Your hostile tone will not
motivate anyone to help you any further. You are asking people to spend
their spare time on your issues, you should not deride them. None of the
posters here spent their spare time on your questions without the intent
to help you. You are insulting them.
I almost get the impression half of the mails don't come through,
because I just read Ben McGinnes state the complete opposite.
Also, and more importantly, if you're so worried about the competences
of the people you ask questions, you should hire experts, not post on a
community mailing list.
And sometimes it is an insult thinly disguised as one.
I agree: I don't wish to debate you on this. I /will/ state my dissent
with the statement before. I consider Debian stretch/stable a "stable
and secure Linux operating system", and that carries GnuPG v2.1.18 (with
backported fixes of course).

@_date: 2018-02-22 17:13:51
@_author: Peter Lebbing 
@_subject: enigmail with pgp 2.2.4 
That would mean that GnuPG is in /usr/local/bin/gpg
So probably /usr/bin/gpg2 is the distribution-provided older version, hence your
You should probably configure all your GnuPG-using software to use
tools to use a non-default GNUPGHOME. That way, should one of your tools
accidentally pick /usr/bin/gpg2, it will hopefully also pick the default
homedir, and not interfere with all your correctly-configured tools. This is
just an idea that occured to me and is completely untested. Then again, mixing
these versions with identical homedirs is tested and has failed the test, so I'm
hoping for a net improvement ;-).

@_date: 2018-02-22 21:17:50
@_author: Peter Lebbing 
@_subject: enigmail with pgp 2.2.4 
While my mind was idly mulling this over, I suddenly wondered if what
you are doing is even supposed to work at all. I think perhaps you just
haven't discovered the dire consequences of it yet.
GnuPG 1.4 and 2.0 are co-installable, and will happily work installed on
the same system.
GnuPG 1.4 and 2.1+ are in the basis co-installable, but still can
present you with issues like keyrings going out of sync or requiring
careful crafting of configuration files, off the top of my head.
But 2.0 and 2.1+ are definitely not co-installable. You can't have them
both on the same system. Right now you put GnuPG 2.2 and its
dependencies in /usr/local, but GnuPG 2.0 and its dependencies are still
in /usr. Their dependencies might start to mingle.
The only way in which this might work is if I misinterpreted "not
co-installable", and 2.0 in /usr and 2.1+ in /usr/local is not actually
an instance of "co-installation". But I don't think that's the case. It
might also work by pure chance and break horribly on the next update.
A solution, where GnuPG 2.1+ is statically linked against its
dependencies, was discussed here:
Werner introduced the partial static linking in the just released 2.2.5.
Oh, and by the way, a little housekeeping information... You started
your thread on the mailing list by replying to a completely unrelated
thread (wotmate: simple grapher for your keyring). Could you please
start a new thread the next time? Just address a message to
 instead of replying to an existing message.
Those of us with a threading view of the mailing list now see it as
somehow being a part of the "wotmate: simple grapher for your keyring"
thread, but they bare no relation whatsoever.

@_date: 2018-02-22 21:29:55
@_author: Peter Lebbing 
@_subject: enigmail with pgp 2.2.4 
I think I might be a bit dense, as this cropped up in the other thread
as well yet I again forgot to account for it.
Other programs on your system might pick up your /usr/local/bin/gpg and
start using it as if it were /usr/bin/gpg at version 1.4. This will
expose wrong assumptions in those programs, causing them to malfunction.
The thing about the partially statically linked version mentioned in
is that it is in /opt, where your system will not use it unless very
explicitly configured to do so. In fact, I wouldn't even add it to your
own $PATH, because some other program you invoke might use it as well.
I notice that often when someone asks "I do this and it goes wrong, what
am I doing wrong", I will think "oh, this and that is what is going
wrong, do it like this" instead of "Wait, should you even be doing
that?" :-).
I don't think there is a fool-proof way to install GnuPG 2.1+ on a Linux
distribution that ships 1.4 and/or 2.0. It will always require being
cautious and knowing exactly what is using what. Luckily, if we as
end-users have a bit more patience, I think in the end all our
distributions will have done the hard work of fixing all of this for
you. I count myself lucky to be running Debian stable. For once, that
means I'm running a newer version than others! :-D

@_date: 2018-02-25 13:24:57
@_author: Peter Lebbing 
@_subject: enigmail with pgp 2.2.4 
Hehe, I think this is all just pure chance, it depends who has the time
to read and respond. I don't think it's related to threading. What does
make a difference, possibly a large one, by the way, is when the
question is accompanied by much useful contextual information. If I'm
reading a mail here and can already get a long way towards the solution
by all the information in a question, I'm more inclined to respond then
when my response would still be asking a lot of questions back. But this
is just some general musing on my part. And it is also unrelated to your
specific mail, it's a general observation.
And by the way, my knowledge of GnuPG is not exceptional, I'm not a
developer, just an enthousiast who has made it a hobby to try and help
people here on the list :-).
Yes, let's :-).
Ah! I see. I didn't know or had forgotten that Ubuntu 16.04 forked
Debian at a time when the gnupg2 package was a 2.1. AFAICT, looking at
.deb files, /usr/bin/gpg is GnuPG 1.4 from the gnupg package and
corresponds to what you say.
Now let's list problems and solutions:
- Programs invoking "gpg" (or explicitly /usr/bin/gpg) expect it to be a
1.4 installation.
This should be fixed by having your locally installed GnuPG 2.2.5
provide a "gpg2" binary, not a "gpg" binary:
./configure --enable-gpg-is-gpg2
(include whatever other configure options you want, but also include
that one).
Since it requires recompilation, let's pick the latest and greatest
2.2.5 :-).
Since in Ubuntu 16.04, anything invoking "gpg2" or "/usr/bin/gpg2" is
either working with a 2.1 version or is not working as shipped by the
distribution, you won't create more breakage (anything working with 2.1
should work with 2.2).
- You have a GnuPG 2.1.11 in /usr/bin/gpg2 and a 2.2.4 in
compiled libraries and stuff.
The best solution would be to create Debian packages yourself, based on
the Ubuntu packaging but utilising the latest GnuPG 2.2 instead of the
2.1.11 of Ubuntu that was last updated 2 years ago (on 8 April 2016, to
be precise) and contains known bugs.
That is some work, but doable. It requires looking at how Ubuntu
packaged it, and create something equal but using a vanilla 2.2.5
instead of a 2.1.11 with backported fixes. Well, with a 2.1.11 that had
backported fixes 2 years ago. I think it's unfortunate they stopped
backporting fixes once they released 16.04.
I'm not 100% sure about other good solutions. I think it's not a good
idea to have 2.1.11 in /usr and 2.2.5 in /usr/local. But if it works for
you, you could see if it keeps working for you. I'll come back to this.
Another solution is installing the stuff in /usr/local like you did, but
with some additional actions:
Make sure everything has /usr/local/bin in its PATH and ld.so is looking
for libraries in /usr/local/lib. On Debian, I think this is already in
And then replace the gnupg2 package, the gpg-agent package and all the
others for which you just installed a /usr/local package by an equivs
package. Just have a look at each file you installed in /usr/local with
your local compile, and do something like:
You see:
You inquire:
dpkg -S /usr/bin/gpg2
And dpkg tells you it is part of package gnupg2, so you need to build an
equivs for that. Etcetera.
Install the "equivs" package. Read its manual, and create packages named
"gnupg2" etcetera. Replace all real Ubuntu packages by these dummy
equivs package.
What did I just propose doing?
I don't like the situation where there is a full real GnuPG in /usr and
another one in /usr/local. The one in /usr might interfere with what you
intend with the one in /usr/local. But you can't just deinstall the
Ubuntu packages, because stuff depends on it. It would force
deinstallation of all packages depending upon gnupg2, gpg-agent etcetera.
With equivs, you can build an empty package. It doesn't install anything
in /usr, so there will no longer be a /usr/bin/gpg2 at all. But any
package that depends on "gnupg2" will see the empty equivs package named
"gnupg2" and be happy that it is installed.
I have done this myself with other packages, but never with GnuPG.
You could just see if it gives you any issues. I'm slightly worried
about silent issues, though, where you think everything is working fine
but it is failing in some subtle but nefarious way. I'm also slightly
worried about the 2.1.11 Ubuntu 16.04 users have installed, which hasn't
seen any maintenance since Ubuntu 16.04 was released two years ago.
It is your decision how thorough you wish to be. IMO, a true locally
built Debian package is the epitome of thoroughness ;-).

@_date: 2018-02-28 13:22:23
@_author: Peter Lebbing 
@_subject: gpgsm --gen-key with key on smartcard 
I don't think that's possible: keygrips are "protocol" agnostic, but key
IDs are not. So while the keygrip is the same for S/MIME and OpenPGP,
key ID's are inherently an OpenPGP thing. It doesn't make sense to
select a "key ID" for an S/MIME key. That's what I mean by protocol here.
My suggestion would be that
$ gpg --with-keygrip --card-status
would include keygrips in the output (it doesn't do that currently).

@_date: 2018-01-04 11:27:18
@_author: Peter Lebbing 
@_subject: Obtaining Key Stubs From Smartcard 
Could you post commands entered and their result? We can't tell what
goes wrong just by this description.
It has always worked fine for me.
By the way, a quicker method than
is using keytocard and then not saving the changes. That way, the key is
both on the card and on disk.

@_date: 2018-01-06 13:15:07
@_author: Peter Lebbing 
@_subject: Obtaining Key Stubs From Smartcard 
You don't show the process, just the end result.
I'm thinking more along the line of:
gpg2 --with-subkey-fingerprint -K
shows the private key is known, primary is offline and subkeys are on a
card. The # in sec# indicates the primary is offline, the > in ssb>
indicates the subkeys are on card. A mocked up output is like this:
--8<---------------cut here---------------start------------->8---
sec#  rsa2048 2009-11-12 [C] [expires: 2019-10-13]
      [fingerprint]
uid           [ultimate] Itsa me ssb>  rsa2048 2009-11-12 [S] [expires: 2019-10-13]
      [fingerprint]
      Card serial no. = FFFE 87061340
ssb>  rsa2048 2009-11-12 [E] [expires: 2019-10-13]
      [fingerprint]
      Card serial no. = FFFE 87061340
--8<---------------cut here---------------end--------------->8---
(It would be nice if the documentation indicates that
--with-subkey-fingerprint also lists the card serial no. I had a
suspicion it might work and it did.)
But, we're discussing how to change to a different smartcard. So let's
do that. The primary is already offline, we lose nothing there, and the
stubs we're trying to lose. Let's delete the secret key. It would be a
good idea to keep a backup of the whole .gnupg dir in any case, but I'm
not showing that.
gpg2 --delete-secret-keys mario
--8<---------------cut here---------------start------------->8---
sec  rsa2048/[keyid] 2009-11-12 Itsa me Delete this key from the keyring? (y/N) y
This is a secret key! - really delete? (y/N) y
--8<---------------cut here---------------end--------------->8---
Check it's gone:
gpg2 -K
gpg: error reading key: No secret key
Stick in the smartcard we want to bind; and lo and behold:
gpg2 --card-status
--8<---------------cut here---------------start------------->8---
General key info..: sub  rsa2048/[keyid] 2009-11-12 Itsa me
sec#  rsa2048/[keyid]  created: 2009-11-12  expires: 2019-10-13
ssb>  rsa2048/[keyid]  created: 2009-11-12  expires: 2019-10-13
                                card-no: FFFE 12345678
ssb>  rsa2048/[keyid]  created: 2009-11-12  expires: 2019-10-13
                                card-no: FFFE 12345678
--8<---------------cut here---------------end--------------->8---
For good measure, do a:
gpg2 --with-subkey-fingerprint -K
This is the level of detail I meant. It works for me. Where does it go
wrong for you?

@_date: 2018-01-06 13:32:45
@_author: Peter Lebbing 
@_subject: Obtaining Key Stubs From Smartcard 
Odd... it's working sometimes, and sometimes it's not. Sometimes, it
will not get rid of the stubs on --delete-secret-key, or --delete-key
for that matter. A different way of doing it is:

@_date: 2018-01-06 13:43:08
@_author: Peter Lebbing 
@_subject: Obtaining Key Stubs From Smartcard 
I love talking to myself...
Cute. I should have noticed my "rewrap" went wrong. It's either:
gpg-connect-agent "learn --force" /bye

@_date: 2018-01-07 14:57:26
@_author: Peter Lebbing 
@_subject: symmetric encryption is not working 
Your gpg-agent is probably caching the passphrase. You can evict the
cache with:
gpgconf --reload gpg-agent
After that, it will prompt you for the passphrase again.

@_date: 2018-01-07 15:01:31
@_author: Peter Lebbing 
@_subject: Import keys from .gnupg folder 
Yes, that is possible. However, you could also just copy the directory
in your new home directory. Upgrading from 2.0 to 2.2 will do the right
If you already have a .gnupg dir there, but you didn't do anything
worthwhile with GnuPG yet, you can just move that to a backup location,
and throw away the backup once you're confident everything works.
However, it is good practice to remove the file "random_seed". This file
should be specific to a single location and not shared.

@_date: 2018-01-15 19:47:39
@_author: Peter Lebbing 
@_subject: Remove public key from keyserver 
Wow, you're entertaining an interesting notion of what is "needed"!
Let's hope most people will just let keyserver operators alone while
they offer their kind service for free to the world.
What is "needed" if you must, is someone thinking of a way to
incorporate cryptographic validation into the whole gossip and what not
process. Not turning loose the lawyers on people offering a free
service. I can't believe what I'm hearing here. Just, wow.

@_date: 2018-01-16 11:35:39
@_author: Peter Lebbing 
@_subject: a step in the right direction 
So how about I insert some private information of somebody into the
"more contemporary" Bitcoin blockchain. Would you advocate that
everybody removes copies of the blockchain? Wouldn't that mean an end to
Or do you consider blockchains to be outmoded technology from a
different era? Just kidding :-).
What about those enlightened jurisdictions where anything not conforming
to a strict interpretation of the local major religion is forbidden?
Should country A get to forbid anything that is not directly conforming
to religion 1 and country B forbid anything not conforming to religion
2, and this world-wide? Perhaps then we can use all those high-bandwidth
links to exchange nothing but kitten pictures... provided there isn't a
religion forbidding the depiction of animals.
Why would you honour the EU's request to purge unwanted information from
the internet world-wide, but not honour country A and B? Who decides
what is "ethically justifiable" and what not? Do we need a world-wide
vote on which commission is the most enlightened to decide this? Would
such a vote require a majority, a large majority or be unanimous? And
who decides these parameters anyway? And when there's a radical regime
change somewhere in the world, do we go back to the drawing board?
(Oh, by the way, usually when I talk about DRM, I'm talking about giving
somebody data but restricting the ways in which they can use that data.
It's not clear to me how DRM applies when you want to simply not give
data at all, to anybody. But this is not really pertinent to the
discussion, so never mind.)

@_date: 2018-01-16 17:26:49
@_author: Peter Lebbing 
@_subject: DRM? (was: a step in the right direction) 
I think that's not really the issue. You can share the key all you want,
it just won't be provided to others /by/ the keyserver, that is the
crux. You could of course run your own keyserver if you want it to do
something different.
I am in the possession of this very mail I'm typing now, yet I can't
make it show up if somebody types in . That doesn't
mean that the GnuPG webserver is implementing DRM to prevent me to share
my own e-mail. It's basic access control when only the operator can
change the website, not DRM, and cryptography is used to facilitate the
access control.
The mechanism to prove you are the owner of a public key is pretty much
in place :-). A mechanism where you can have a signed statement saying
"on 2018-01-16, I allow my key to show up on keyservers", and a signed
statement saying "from 2018-04-01 on you should no longer expose this
key to clients" is not DRM, IMHO, just authentication. Anybody could
upload this statement to the keyserver. But it will only be
cryptographically valid if *created* by the holder of the private key.
I'm not saying this is the way to go. Just that I don't see it as DRM as
far as I understand.
This "right to be forgotten" is obviously management of restrictions on
the dissemination of data. It's just not digital so far.
My 2 cents,

@_date: 2018-01-16 18:05:54
@_author: Peter Lebbing 
@_subject: DRM? 
I was merely using the description of the basics of it as a means to
show how it would be access control rather than DRM. All the thorny
extra issues I never even seriously considered is part of why I also
said "I'm not saying this is the way to go."
Sounds really, really difficult to solve. Perhaps impossible? Since I'm
not advocating implementing this in the first case, I'm not spending
many computation cycles on the issue either :-). It might be there is an
imperfect but acceptable solution, though. The problem with that is
again litigation: "What do you mean, you can't remove me? You have a
removal feature! See you in court!"

@_date: 2018-01-16 18:11:52
@_author: Peter Lebbing 
@_subject: DRM? 
Now, /that/ would be DRM, I agree. I just considered "what
well-configured keyservers in the keyserver pool should do" as the
boundary of the problem statement. Just like a well-configured webserver
will not change their homepage when a random person on the internet asks
for it.

@_date: 2018-01-22 11:52:21
@_author: Peter Lebbing 
@_subject: Why exactly does pinentry fails with gpg-agent and ssh support? 
Because GnuPG *does* pass TTY and display to the agent.
It works for me out-of-the-box on Debian stretch/stable, supervised by
systemd... if I SSH before I do any GnuPG stuff, it correctly prompts me
in the (graphical) session that started the agent. So something must be
different in your installation.

@_date: 2018-01-23 12:34:40
@_author: Peter Lebbing 
@_subject: Keys clean of all signatures except those made by others I trust 
From the man page:
(Apparently you agree on the name for the concept, a "clean" key :-)

@_date: 2018-01-29 10:12:46
@_author: Peter Lebbing 
@_subject: SCM SPR332 PIN entry doesn't work 
Thank you for posting the solution to the mailing list! That's really
helpful for others in the future.

@_date: 2018-01-31 12:34:34
@_author: Peter Lebbing 
@_subject: How to avoid Passphrase prompt 
You can remove the passphrase from the private key by:
gpg --edit-key KEYID
Just enter the old password but keep the "new" fields blank. GnuPG will
prompt whether you're sure you want to remove the protection of the key.
Choose "Yes, protection is not needed".
It will prompt multiple times when you have subkeys. It would be
possible to remove passphrase protection from just the encryption
subkey, but leave it on the rest. But this appears to be a bit awkward
as the prompt doesn't tell me which subkey I'm currently changing the
passphrase for...
There's also a way to supply the password up front, which would still
keep the on-disk private key encrypted. But this is more cumbersome, and
you don't say whether that is needed or not, so I'm just mentioning it,
not working it out.
More in general, it helps if you explain more about your situation and
your goals.

@_date: 2018-01-31 13:11:07
@_author: Peter Lebbing 
@_subject: How to avoid Passphrase prompt 
I don't understand what you want me to explain.
A file is decrypted by using the private key. If the private key is
passphrase-protected, you will need to enter that passphrase. I
explained how to remove the passphrase from the key.
The private key is stored as a file on your hard disk. If there is no
passphrase to protect it, anybody with access to the file can use the
private key. They can also decrypt files, and use the key however they
want. This is why it has passphrase protection normally.
I don't understand what you mean.

@_date: 2018-01-31 14:12:45
@_author: Peter Lebbing 
@_subject: How to avoid Passphrase prompt 
The simplest way to avoid the popup is to remove the passphrase from the
private key.
The private key is stored on your hard disk. If there is no passphrase
on the private key, anybody with access to your hard disk can decrypt
files. They can also do anything else with your key.
So you need to make sure that only you have access to the hard disk.
Is this acceptable?

@_date: 2018-07-16 14:30:12
@_author: Peter Lebbing 
@_subject: Forwarding both gpg and ssh agents 
Have you played with OpenSSH's ForwardAgent option or its -A command
line argument counterpart? I'm fairly sure I had success with it in the
past with an authentication key on an OpenPGP smartcard, but it's quite
a while back.

@_date: 2018-07-17 11:00:04
@_author: Peter Lebbing 
@_subject: Forwarding both gpg and ssh agents 
Well, yes, even the man page warns about the security implications. There's a reason I said "it's quite a while back" :-). I try to avoid it. The security implications are severe.
If it's just about passing a firewall, the ProxyJump / -J options of OpenSSH are much more useful. You can even chain them easily to pass ever more firewalls :-).
ssh -J outerbastion.example.org -J nextlayer.example.org destination.example.org
The ProxyCommand mentioned there has been made more convenient with the ProxyJump option that was added later; especially if we're talking about multiple jump hosts.
Agent forwarding is really about connecting two remote hosts together, which Proxy can't do.

@_date: 2018-06-05 20:18:34
@_author: Peter Lebbing 
@_subject: Forward gpg-agent to container 
Have you tried by hand whether the concept of communicating over a
socket to a container works at all? You could use socat to create a
socket and communicate, one socat on your host system and one inside the
I have no experience with it, but it wouldn't surprise me at all if you
can't cross the container boundary given how local UNIX stream sockets
are. Then again, maybe I'm dead wrong.

@_date: 2018-06-11 11:07:58
@_author: Peter Lebbing 
@_subject: [Announce] [security fix] GnuPG 2.2.8 released (CVE-2018-12020) 
(Could you please trim your quotes? Incidentally, this would have
prevented the problem in the first place, both on the first and on your
It would appear that at least Enigmail (mine is from Debian
stable/stretch) ignores an inline encrypted block if it is indented, but
interprets it if it is quoted *and* indented. So while there was no
attempt to decrypt the block in the first message by Werner, as soon as
it was part of a quote, starting with ">   ", Enigmail will try to
process it. Type in the passphrase "abc" without quotes, and you'll
decrypt the test message part of the announcement.

@_date: 2018-03-01 13:06:03
@_author: Peter Lebbing 
@_subject: [FEATURE REQ] Keygrips in --card-status (was: gpgsm --gen-key with 
Currently, it's not that easy to get the keygrip for an OpenPGP
smartcard key.
For keys for which the public part is available, it's:
$ gpg --card-status
Note desired KEYID
$ gpg --with-keygrip -k $KEYID
Find the KEYID in the certificate listed and see the keygrip below it.
I have smartcards with Auth keys that are not part of an OpenPGP
certificate. For these and other cases where the public part is not in
the keyring, it's more difficult to get the keygrip. Probably something
$ gpg-connect-agent 'keyinfo --list' /bye|grep 87061340
for my GnuK with serial FFFE 87061340.
So if --card-status would actually use the --with-keygrip option, it
would be much easier to look up the keygrip for an OpenPGP smartcard,
*especially* when the smartcard is not currently in use by gpg. Even
though the query is done by "gpg --card-status", it is more a feature
for OpenPGP smartcards regardless of whether they are used for OpenPGP keys.

@_date: 2018-03-05 12:53:04
@_author: Peter Lebbing 
@_subject: enigmail with pgp 2.2.4 
> i thought you forgot about me)
It's all a matter of free time and willingness. If I have 5 minutes and
see a question I can quickly answer, I might do that. But if an answer
takes a lot of time, it will have to wait.
Ah, welcome :-). Using software that was not provided by or specifically
for your distribution is an advanced topic, so it's not surprising you
might feel uncertain what to do at times.
Well, building Debian packages is the best way to integrate into the
Ubuntu ecosystem. But that doesn't mean it's the only good solution.
Installing stuff into /usr/local is a time-honored Unix tradition. Many
distributions will respect those traditions. I'm merely indicating that
I'm not sure I'm giving 100% correct advice. But if I'm right, it should
just work fine.
It's not boring, it's time-consuming, that's the problem. I will not
build packages for Ubuntu 16.04. As a matter of fact, I think interest
in 16.04 will drop a bit in one and a half month :-). But if I can find
the time for it, I might have a look at building those equivs-packages
so you can use your local installation in /usr/local instead of the
packaged version.
But I haven't found that time yet.
I did notice an old post on gnupg-devel that was replied to just now,
where Phil Pennock says he's packaging GnuPG 2.2 for Ubuntu 16.04:
But he's explicitly staying out of the way of the 2.1.11 offered by
Ubuntu. That makes it more difficult to use for the end user. It seems
wise when the system has 2.0 installed. But I think there's something to
be said for going a bit further in the case of 16.04 and install a
recent 2.2 for usage by the whole system. The system already has a 2.1+
version, so anything that depends on gpg2 being 2.0 will already be
broken; you can't break it any further anyway. And 2.1.11 has known bugs
and deficiencies, and the fixes have not been backported by Ubuntu. It
seems nothing but a win to replace it with 2.2.

@_date: 2018-03-05 12:56:49
@_author: Peter Lebbing 
@_subject: GPG is not working because of gpg.conf 
The problem is that the log-file option is not supported by GnuPG 1.4;
it was introduced in some 2.x version.
GnuPG 1.4.22 will look for the following files in order:
and it will take the first one it sees and stop there. By creating
gpg.conf-1, it will never get to gpg.conf and take the unsupported
option from there. Any configuration for GnuPG 1.4.22 will have to be
done in gpg.conf-1, and a 2.x version will still pick up the log-file
option from gpg.conf.

@_date: 2018-03-13 16:00:04
@_author: Peter Lebbing 
@_subject: OpenPGP card bricked 
A notable difference between the built-in CCID driver and pcscd is probably the
user credentials that open the USB device. Make sure you have write access to
the character device in /dev/bus/usb that corresponds to your smartcard:
$ lsusb
Bus 001 Device 006: ID 04e6:e003 SCM Microsystems, Inc. SPR532 PinPad SmartCard
$ ll /dev/bus/usb/001/006
crw-rw-r--+ 1 root root 189, 5 Mar 13 15:55 /dev/bus/usb/001/006
$ getfacl /dev/bus/usb/001/006
getfacl: Removing leading '/' from absolute path names
# file: dev/bus/usb/001/006
# owner: root
# group: root
Also, if I were you, I'd clean the smartcard contacts with isopropyl alcohol.
I'm not sure what other cleaning agents would work well, I just use that one.
It could be that your card has just died. Smartcards are not the most robust
devices, and they are subjected to stress usually.
PS: I'm not 100% sure that libusb opens that particular character device... I
believe it's the correct one, but wouldn't swear on it.

@_date: 2018-03-23 13:19:26
@_author: Peter Lebbing 
@_subject: Is passphrase correct? 
--8<---------------cut here---------------start------------->8---
$ echo test | gpg -r '' -e | gpg -d
gpg: peter at digitalbrains.com: Verified X signatures in the past 19 months.
     Encrypted Y messages in the past 15 months.
gpg: encrypted with 2048-bit RSA key, ID 26F7563E73A33BEE, created
      "Peter Lebbing "
--8<---------------cut here---------------end--------------->8---
The fact that "test" shows up at the end proves that I could decrypt the
message, and that proves my passphrase was correct.
Note that I used my e-mail address as the "recipient" of the encrypted
message, but this might match multiple keys. Use your fingerprint to
uniquely select the correct key to check the passphrase for. The long
key ID is an okayish method of specifying it as well. Don't use the
short key ID.
--8<---------------cut here---------------start------------->8---
$ gpg --keyid-format long -k ''
pub   rsa1024/ADD8D49B3E4FCA14 2006-03-31 [SC] [revoked: 2009-11-12]
      F8D07102A4F52BD8DC1A7786ADD8D49B3E4FCA14
uid                 [ revoked] Peter Lebbing pub   rsa2048/AC46EFE6DE500B3E 2009-11-12 [C] [expires: 2019-10-13]
      8FA94E79AD6AB56EE38CE5CBAC46EFE6DE500B3E
uid                 [  full  ] Peter Lebbing sub   rsa2048/969E018FDE6CDCA1 2009-11-12 [S] [expires: 2019-10-13]
sub   rsa2048/26F7563E73A33BEE 2009-11-12 [E] [expires: 2019-10-13]
--8<---------------cut here---------------end--------------->8---
The fingerprint is the really long hexadecimal number below the "pub"
line of the key you're looking for. The long key ID is the number after
"pub rsa2048/", and actually is just the last 16 digits of the fingerprint.

@_date: 2018-05-04 10:41:21
@_author: Peter Lebbing 
@_subject: use gpg-agent for ssh login 
That's incorrect. If you insert an OpenPGP smartcard with a key in the
Authenticate slot, it will make that key available to the SSH agent
system. That is regardless of listing in sshcontrol.
The difference is that if you list it in sshcontrol, and a server
indicates acceptance of that key, the pinentry will prompt you to insert
that smartcard for authentication even when the smartcard is not
inserted. Whereas if it is not in sshcontrol and not currently inserted
either, the key will never be offered to the server in the first place.

@_date: 2018-11-09 16:12:19
@_author: Peter Lebbing 
@_subject: Utilizing facts of homedir organization (was: Exact definition of 
Daniel, many thanks for thinking about this! I'm sorry I didn't respond
The problem is that the gpg invocation is not at the time of building
the initramfs. gpg is only invoked once during setup of the
smartcard-encrypted root. In the end, the --export during setup and
--import during early boot is probably the best alternative; since it's
an --import to an empty keyring, this shouldn't waste much time during
every boot anyway.
I have an idea about elegantly handling the fact that the smartcard stub
is not known during boot, since there doesn't seem to be a stable
interface to transferring these stubs, and invoking gpg at initramfs
build time will leave a running gpg-agent, which is rather avoided. I'll
work this out when I have the time.
Yes, I think it's useful to know what is a stable interface and what is
not, so I hope he will.
Thank you,

@_date: 2018-11-09 16:40:18
@_author: Peter Lebbing 
@_subject: Refreshing keys (was: Utilizing facts of homedir organization (was: 
In that case you should refresh your copy of my public key from the
keyservers or from the URL in my signature:
$ gpg --refresh-keys peter at digitalbrains.com
$ gpg --fetch-keys or whatever method you prefer, possibly through your favourite frontend.
FWIW, my key's latest expiry was in October 2017, and then it was
refreshed until October 2019. At least, that's what it looks like to me.
I don't think I made a mistake somewhere, but it could be :-).

@_date: 2018-11-09 16:48:42
@_author: Peter Lebbing 
@_subject: (OT) Re: Refreshing keys 
Hmmm, normally Thunderbird will snip off the (was: ...) portion of a

@_date: 2018-09-03 19:25:10
@_author: Peter Lebbing 
@_subject: AW: How to fix "ERROR key_generate 3355453" / "GENKEY' failed: 
This has never been a supported use of gpg, it just happened to work
because GnuPG 1.4 happened to use a bunch of exported OpenPGP
certificates as the format of its public keyring. This was an
implementation detail which enabled you to do this. Just because you can
use the rear side of a screwdriver to hammer in a small nail doesn't
mean you're meant to do carpentry that way ;-). In GnuPG, the homedir is
pretty much not part of the interface, it is internal with some
exceptions like .conf-files and being able to retrieve revocation
certificates from it. The keyring format has changed and GnuPG also
expects a lot of other different things in its homedir. So it no longer
It could be that recently an option was added to check a signature by a
certificate in a file, but in general you need to import a certificate
before you can do verifications. I didn't see the new option in the few
announcements I read. Either it was discussed and not done or discussed
and implemented, can't recall.

@_date: 2018-09-04 11:57:51
@_author: Peter Lebbing 
@_subject: How to fix "ERROR key_generate 3355453" / "GENKEY' failed: IPC 
Ah, but you didn't pass it a keyring, did you? You passed it an exported
OpenPGP key, which is no longer the format of a keyring! :-)
Yes, the new option to *encrypt* to a key in a file made me forget about
the age-old gpgv :-). I got it mixed up.
I'd say: definitely. I'm not a GnuPG dev, though. I think for instance
the git repository with the man page can be reached through the web on [1].
Note that if you were to carefully read the long table of contents of
the "GnuPG manual"[2], you'd stumble upon these entries:
I think your addition to the man page would be helpful, but a balance
has to be struck between documenting what something does and what it
does not. Writing good, clear documentation is hard. I don't think the
current documentation is as good as it could be. The fact that there are
so many options and commands makes it very hard to do right. In the
current state of the documentation, I think your addition is a good one.
More in general, I think there should be documentation that users read
which means they wouldn't end up at the man page for the gpg
command-line tool at all, but they would immediately have chosen gpgv in
the first place. I hope I'm succeeding in getting my intention across,
I'm having some trouble putting it in words :-).
man pages are reference works, not user guides. You already know how to
use something, but the details elude you for a moment? You grab a
reference. You can't learn English from a dictionary, and you can't
efficiently look up the spelling of a word in an English course.
In this particular case, what set you off in the wrong direction was
that you were doing something which was never *intended* to work, it
just did. Worse, people have been telling other people that this was
something you could do. I think it's hard to catch all these things in
documentation when at the same time people on the interwebs are saying
"oh you should use an exported key as keyring".
[1] [2]

@_date: 2018-09-04 12:01:17
@_author: Peter Lebbing 
@_subject: First smartcard operation always fails 
I have no idea, it's quite curious. As an added bread crumb to follow:
what do the PIN retry counters say after the failure? gpg --card-status.
Do you always use the same reader? Perhaps it is the reader.

@_date: 2018-09-04 15:22:57
@_author: Peter Lebbing 
@_subject: How to fix "ERROR key_generate 3355453" / "GENKEY' failed: IPC 
I don't understand, could you give commands, expected behaviour and
actual output?
For gpgv, I'd just use an exported single public key like you tried to
do with gpg. gpgv has no problems with that.

@_date: 2018-09-04 15:39:12
@_author: Peter Lebbing 
@_subject: How to fix "ERROR key_generate 3355453" / "GENKEY' failed: IPC 
This would open /proc/self/fd/nonexistent/key.pub as the keyring.
From the man page of gpgv:
What works for me is:
$ gpgv --keyring ./key.gpg data.gpg

@_date: 2018-09-04 15:41:40
@_author: Peter Lebbing 
@_subject: How to fix "ERROR key_generate 3355453" / "GENKEY' failed: IPC 
To clarify, I thought you were giving an example of "starting gpgv
without any keyring at all", because you gave it a non-existing homedir.
Only on re-reading your other mail did I understand this was an example
of how you were actually trying to do it.

@_date: 2018-09-04 22:56:28
@_author: Peter Lebbing 
@_subject: How to fix "ERROR key_generate 3355453" / "GENKEY' failed: IPC 
You missed my point. You are not including a slash in the keyring
argument, so gpgv is looking for it in the homedir. To quote the gpgv
man page again:
And this works:
$ gpgv --keyring ./key.gpg data.gpg
This is an encrypted message. gpgv can't do anything with it.

@_date: 2018-09-05 12:18:06
@_author: Peter Lebbing 
@_subject: Hiding signature identification (was: How to fix "ERROR key_generate 
If there are six people I am actually interested in, and I know all
their public keys, checking if one of them signed a message with a
hypothetical "throw-keyid" takes me at most six trial verifications,
using their public keys in turn.
Now when you say that you could find the signer by brute-forcing "all
keys in the 2^2048 key space", that seems to miss a vital step. Let's
suppose you did this massive brute force, the universe still exists, and
you found that the RSA key with keygrip
8FE036329129F568D5B58A88F6F8580A064E4887 has signed the message. Back to
your goal. Who signed the message? You don't know. You know what the RSA
modulus of the key of this person is, but you don't know their identity,
because your brute-force search did not produce an identity, it produced
an RSA modulus and exponent.
So: to know who signed a message, you need their public key. So to check
a random signature without identification, you try all the public keys
you have at your disposal (perhaps ignoring the ones you know are
uninteresting). So your search space is your collection of public keys.

@_date: 2018-09-05 13:56:21
@_author: Peter Lebbing 
@_subject: Hiding signature identification 
What does an unencrypted, signed message mean to you? Because when we're
talking about the benefits or operation model of a hypothetical
"throw-keyid" option for signatures, that's what we are discussing.
Anything about encrypted messages is not relevant, since the signature
is inside the encryption as you noted. So the actual content of the data
is already deemed not to be sensitive knowledge, it just needs to be
Your method of correlating key ID's to out-of-band data like spying on
people's movements is something I had not considered, but the key ID is
just a bit of extra data; you could also simply correlate the production
of *an* OpenPGP signed message to the person in question and attack
them. Who cares what key they used when you can determine they are the
person who's always behind their keyboard when that interesting signed
message appears.
Furthermore, note that the design of OpenPGP assumes the data it calls
"public" is indeed public. You could try to retrofit OpenPGP into some
role where a public key is not public, but it is dangerous to use a
crypto ecosystem for something else than it was designed for. It seems
to me asking for a "throw-keyid" for signatures is exactly that, and
maybe you need to look for something else than OpenPGP if public data is
no longer public.[1]
As soon as the public key is indeed public, you've just reduced the
search space to all public keys rather than all possible public keys. I
don't particularly care if there is a meaningful user ID on the key,
that's up to the creator of the key, but it is relevant that the actual
modulus is indeed public knowledge.
[1] I made a typo and wrote "and pubic data is no longer public". My
pubic data would be among the least public data about me, thank you very
much :-).

@_date: 2018-09-05 14:38:38
@_author: Peter Lebbing 
@_subject: AW: How to fix "ERROR key_generate 3355453" / "GENKEY' failed: 
If you want to know which of the public keys you have signed a
particular message, instead of restricting your "keyring" to a single,
desired key, you can scan the status-fd for
[GNUPG:] GOODSIG   In this case, just keep your keyring as it normally is, containing all
public keys. You might then also reach a situation where you can
meaningfully use a trust model, instead of your --trust-model always.
status-fd is documented in doc/DETAILS.

@_date: 2018-09-05 15:20:30
@_author: Peter Lebbing 
@_subject: Both correct and surprising non-interactive gen-key (was: How to fix 
cancelled")
It is unclear where the passphrase is supposed to come from... so I think it's correct that GnuPG CANcels. Oh, by the way, commands should come last for robustness.
I discovered something odd though:
--8<---------------cut here---------------start------------->8---
$ cat passphrase $ cat template %echo Generating key
Key-Type: RSA
Key-Length: 1024
Subkey-Type: ELG-E
Subkey-Length: 1024
Name-Real: AutomationKey
Expire-Date: 0
$ exec 3<&- 38---
That works, with passphrase on fd 3 and command on fd 0. I should delete it though, "ultimately trusted" no thanks. But:
--8<---------------cut here---------------start------------->8---
$ exec 3<&- 3

@_date: 2018-09-05 16:05:55
@_author: Peter Lebbing 
@_subject: AW: Both correct and surprising non-interactive gen-key 
Can you point to the documentation where it says so? Because the
passphrase is correctly set to "my_passphrase", pinentry-mode should
only ever become relevant when a pinentry is about to invoked, and in
general I just don't see why this should be the case. Additionally, it
makes no sense that there is a "%no-protection" option if this is always
the case anyway. I think that GnuPG 1.4 defaulted to no passphrase if
not supplied with a "Passphrase" option, but this is not GnuPG 1.4; the
"Passphrase" option is a no-op, included only for backwards compatibility.

@_date: 2018-09-05 16:10:48
@_author: Peter Lebbing 
@_subject: AW: Both correct and surprising non-interactive gen-key 
It's just one bug, if even, depending on my understanding of the
mechanism. One swallow does not a summer make; such negativity.

@_date: 2018-09-05 16:31:22
@_author: Peter Lebbing 
@_subject: AW: AW: How to fix "ERROR key_generate 3355453" / "GENKEY' 
Generally: no. It just indicates the signature is cryptographically
valid, it does not indicate whether the *key* is valid. With
--trust-model always and a non-revoked key; perhaps.

@_date: 2018-09-23 15:38:35
@_author: Peter Lebbing 
@_subject: Exact definition of token S/N field for --with-colons 
doc/DETAILS says this about the output of --with-colons listings:
This suggests that a '+' is only output for --with-secret --list-keys,
but I see it as well in --list-secret-keys. Running gpg 2.1.18-8~deb9u2
from Debian stretch/stable. The specification leaves some interpretation
- Is '+' output iff it is an on-disk key, both on --with-secret
  --list-keys and --list-secret-keys?
- I see S/N's on --with-secret --list-keys, is there even a need to
  mention --with-secret separately or is field 15 completely identical
  for both invocations?
- Is field 15 ever anything else than a serial number, a ' or a '+' on
  --list-secret-keys? I presume the answer is "this may change in the
  future", but I mean currently.
The context is that for Debian's cryptsetup, I'm trying to determine
whether all secret (sub)keys in a homedir are stubs (serial numbers or
empty stubs). And the reason is that I'd like to error out if there is
any actual confidential data in the private keyring, instead of copying
it to the unencrypted initramfs. A password-protected on-disk key is a
major red flag despite its password protection.
Not all of my questions directly pertain to this use case, I'm just
trying to get a good feel for the field to be able to reason about it.
My attempt at bailing on confidential data is here:
and it is this:
--8<---------------cut here---------------start------------->8---
UNSAFEKEYS=$(gpg --batch --with-colons --homedir /etc/keys --list-secret-keys | \
if [ -n "$UNSAFEKEYS" ]; then
--8<---------------cut here---------------end--------------->8---
It will only accept true OpenPGP smartcard keys (matched on ISO 7816
Application Identifier) or empty stubs (no secret key whatsoever). No
other secret key material should be necessary for this particular
application. Note that the dialect (or lack thereof) is dash; if run in
bash, echo would need -e.

@_date: 2018-09-23 18:18:13
@_author: Peter Lebbing 
@_subject: Utilizing facts of homedir organization (was: Exact definition of 
Hi all,
The intent of this mail is not to ask whether something works. This can
be easily verified. It's asking whether it is a supported way of doing
things. I hope I can get some guidance on this!
 So this ran into a major mistake on my part. Not all keys in
private-keys-v1.d will be listed with this method, plus it launches an
agent which in this case is a no-go.
The situation with regard to which parts of the homedir are
implementation details and which are an API is a bit muddled IMHO. For
instance, we're supposed to be creating and editing *.conf files and
access revocation certificate files in openpgp-revocs.d, but a lot of
the rest is "Don't touch".
Would it be okay to scrub the private-keys-v1.d directory so it will
only hold KEYGRIP.key for that one smartcard stub we want to have? I'm
talking about a separate, special-purpose homedir, not the regular user
homedir, let's not scrub private-keys-v1.d there :-D.
That's the specific way of asking the question. A more general question
would be: in GnuPG 2.1+, can we expect the private key with grip X to be
at private-keys-v1.d/X.key and will an agent be happy to work on a
private-keys-v1.d with just files X.key, Y.key and Z.key when we
actually only need private keys X, Y and Z? Or is this an implementation
While I'm at it: there are conflicting opinions on whether it is okay to
build a keyring using:
$ gpg --export SOMEKEY >pubring.gpg
instead of:
$ gpg --export SOMEKEY | gpg --no-default-keyring --keyring ./pubring.kbx
Can we also get official guidance on that; is the former acceptable?
(FWIW, I've always thought it was not.)

@_date: 2018-09-24 12:44:38
@_author: Peter Lebbing 
@_subject: Utilizing facts of homedir organization (was: Exact definition of 
I'm sorry, I did a very poor job of explaining it. I'm not transferring
keys, I'm managing keyrings. This is all with the same version of GnuPG.
And yes, I simply forgot to type the --import command.
The context is that we want to build a keyring for a specialized runtime
environment. We will be invoking gpg in the initramfs stage, to get
decryption keys for encrypted filesystems. It's still the same computer
running the same software (same gpg), but the normal filesystems are not
available yet.
So what there is now is this:
# gpg --export 0xDEADBEEF >/etc/cryptsetup-initramfs/pubring.gpg
This pubring.gpg gets copied into the initramfs at /cryptroot. During
early boot, the following gets executed (with an empty homedir in
default location):
# gpg --no-options --trust-model=always --no-default-keyring --keyring=/cryptroot/pubring.gpg --decrypt -- /etc/keys/cryptkey.gpg
I objected to this on the grounds that it is using what I have thought
for years is an implementation detail. Up to GnuPG 2.1, keyrings were
simple concatenated OpenPGP exported format certificates. Even though it
might work, even with GnuPG 2.1+, I thought building keyrings by
concatenating --export was considered not an API. So I proposed:
# gpg --export 0xDEADBEEF | gpg --no-default-keyring --keyring /etc/cryptsetup-initramfs/pubring.kbx --import
Note how we're not even changing the homedir or the executable, it's
just the same GnuPG version talking to itself, but with a different
destination keyring for --import. Okay, it also doesn't have the default
keyrings anymore during this one invocation. This does have some implications, the invocation might not be optimal yet.
Copy the pubring.kbx to /cryptroot in the initramfs. During subsequent
early boot (again, default but empty homedir):
# gpg --no-options --trust-model=always --no-default-keyring --keyring=/cryptroot/pubring.kbx --decrypt -- /etc/keys/cryptkey.gpg
Just the extension of the keyring changed. Extensions here are a hint
for the user anyway, GnuPG doesn't seem to care.
The always-correct option would be to --export, copy the exported key to
the initramfs, and simply --import it before use, no meddling with
prefabricated keyrings. It does waste some processing.
So have I been too strict all these years? :-) Are we free to build
keyrings with --export and will GnuPG happily consume them as an
always-supported fallback?

@_date: 2018-09-26 12:43:45
@_author: Peter Lebbing 
@_subject: Monitoring queries to gpg-agent? 
This is reminding me of a message Werner wrote[1] last year that
pinentry will show some context of the reason it is prompting. So this
functionality might be in the works. I assume you are prompted by a
pinentry to push the button?
As you note, if access to your agent was compromised, this would not
constitute solid protection as the information could be spoofed or
substituted. It is informative, though.
[1]

@_date: 2019-04-02 13:11:50
@_author: Peter Lebbing 
@_subject: Stop popup which asks for the passphrase 
I'm reposting a question[1] asked by Shweta Tyagi in a different thread,
so it is in its own thread. I feel Shweta might have chosen to seek
their answer elsewhere after they only got unhelpful responses there,
and I'd like to rectify that.
Shweta asked:
Hi All,
I am using the following command
gpg --batch --passphrase-fd n and it stops popup which asks for the
passphrase. but when I run this command on window server 12 it's not
working its always show popup for the passphrase. can someone please
help me how can I stop popup on window server 12.
[1]

@_date: 2019-04-02 13:11:44
@_author: Peter Lebbing 
@_subject: Please start a new thread 
Hello Shweta,
Seeing how you did not start a new thread, I get the feeling we "scared
you off" from posting. That is really unfortunate, and not our intention
at all. I'm sorry if you felt intimidated by the response you got.
It's rather unusual, but I took the liberty of posting your question to
the mailing list again, but now not by replying to an existing mailing
list post but addressing a mail to . And
subsequently answering the question to the extent I could.
Let me conclude by copying the part of the list information page[1] that
pertains to basic rules of conduct. The rules are there to make
communication easier; for instance, if you don't trim your quotes it
becomes an effort just to read the flow of the conversation. People who
might otherwise have insightful stuff to add might have given up
reading. And if someone searches the list archive to find if someone
else was already helped with the same problem they're having, it should
be possible to quickly navigate through large amounts of conversation.
That is also why it's important to have one thread deal with one subject
only (or a set of closely related subjects at least :-).
[1]

@_date: 2019-04-02 13:12:23
@_author: Peter Lebbing 
@_subject: Stop popup which asks for the passphrase 
Hello Shweta,
It is not clear to me which versions of GnuPG you are using. Using a
recent version, but on Linux, I cannot reproduce that this command
works, so I agree with Windows there.
What works for me is:
$ gpg --batch --pinentry-mode loopback --passphrase-fd n [...]
(obviously filling in a number for n, and continuing with more options
and a command for gpg).
With older versions of gpg-agent, it might be necessary to specify the
following in ~/.gnupg/gpg-agent.conf (rather, its location on your OS of
but this is the default now.
As a full working example, this works for me:
$ echo Hi | gpg --batch -o test.gpg -u 1819B624D400781C8988105EC97A5BCE0BFBF628 --passphrase-fd 3 --pinentry-mode loopback -s 3<<

@_date: 2019-04-04 16:58:35
@_author: Peter Lebbing 
@_subject: How to tell gpg not to start gpg-agent on a remote machines when 
From the man page:
If you want to put this in the gpg.conf configuration file, drop the two
leading dashes (this is generally the case).

@_date: 2019-04-04 17:10:53
@_author: Peter Lebbing 
@_subject: card-sized 4 Kbit RSA Smartcard recommendation with 3 slots 
Well, the ZeitControl card, which was the first OpenPGP Card on the
market, is now at version 3.3 which would seem to support what you ask
for.[1] I have no personal experience, I do have v2.0 cards (and v1.1).
I don't expect 4k RSA to be very snappy, though. You might want to
reconsider your choice of algorithm and/or length.
Be warned that there are many cardreaders that will not work with larger
keys (where "larger" can already mean 2k) or even work reliably at all
with free software. So your mileage may vary a lot.
[1]

@_date: 2019-04-04 17:44:20
@_author: Peter Lebbing 
@_subject: FW: yubikey public key 
Hi Jennifer,
I think what you are looking for is
$ ssh-add -L
which will dump all the public keys known to the SSH agent. If properly
set up, your SSH agent will be gpg-agent, unless I misunderstand your
The others are probably looking at an OpenPGP public key rather than an
SSH public key (again, a guess).

@_date: 2019-04-06 21:02:53
@_author: Peter Lebbing 
@_subject: Generating revocation certificate 
The error message is really unclear, but the problem probably is that
you should have used "gpg2" instead of "gpg", consistently. So just
leave "gpg" behind and only use "gpg2" ever. Well, until an updated
Trisquel drops the old 1.4 and both refer to the same version.
GnuPG 1.4 and 2.1+ do not mix well in certain scenarios. You probably
encountered one.

@_date: 2019-04-06 21:10:04
@_author: Peter Lebbing 
@_subject: Generating revocation certificate 
Yeah, and it's probably high time to put gramps out to pasture as
well... ;-) That's a seriously old, unsupported version.

@_date: 2019-04-06 21:30:38
@_author: Peter Lebbing 
@_subject: Generating revocation certificate 
Hi Andr?,
Quite! :-)
Your operating system probably still requires GnuPG 1.4, so you can't
remove it. But you can solemnly pledge not to use it... I wouldn't mess
with the "gpg" binary, though. Don't use some method to prevent your
access to it, or you might silently corrupt some utility that you use
under your user account that expects it to be 1.4.
This was all quite an ordeal for Debian to get right, there are a lot of
subtleties to deal with. I really think your best bet is to get that "2"
suffix in your muscle memory for when you use the command line.

@_date: 2019-04-10 11:45:08
@_author: Peter Lebbing 
@_subject: Storing key on multiple smartcards 
I agree that GnuPG would benefit from preferring keys that are
available, both in the sense of different subkeys and different
smartcards with copies of the same subkey, in the sense you describe.
But let me pick out one detail you mentioned that is a different issue.
It's less difficult than that. After a "keytocard", simply exit the
--edit-key interaction without saving, and the key will still be
on disk as well. So use "quit" or Ctrl-D rather than "save", and
confirm that you wish to exit without saving changes.
Not really intuitive, but less bothersome than backups and restores. I
think maybe "keytocard" should have an option to just leave it on disk
as well. And then you can just insert all your smartcards you want the
key on and "keytocard" them one after the other without exiting the
--edit-key menu.

@_date: 2019-04-10 11:57:29
@_author: Peter Lebbing 
@_subject: Please ignore: Storing key on multiple smartcards 
Sorry for the noise. This message was intended to go to gnupg-devel, but
I screwed up. Please ignore it.

@_date: 2019-04-10 17:24:24
@_author: Peter Lebbing 
@_subject: How do I delete secret subkeys correctly? 
$ gpg --edit-key [KEYID]
gpg> key N
gpg> delkey
Where N is the number of the subkey you want to delete; they are
numbered 1 for the first one listed and so on. It will indicate with a
"*" next to the "ssb" line which one(s) you have selected. Deselect by
another "key N"; it's a toggle.

@_date: 2019-04-10 17:28:54
@_author: Peter Lebbing 
@_subject: How do I delete secret subkeys correctly? 
Sorry, my fatigued head was being silly. That's for deleting the public
part, not the secret part. I don't think I know the way to delete the
secret part when you just want to delete some subkey.

@_date: 2019-04-11 10:24:40
@_author: Peter Lebbing 
@_subject: Generating revocation certificate 
Because, as I said, it might silently corrupt the functioning of a
utility that expects "gpg" to be 1.4 and not 2.1. There are quite a lot
of utilities out there that parse the output of the gpg command in a way
that is not sufficiently robust. The different output generated by 2.1
might cause such a utility to misinterpret it, and silently accept an
invalid signature. The purpose of calling gpg to verify a signature was
surely to reject invalid signatures, so you might expose yourself to
attackers that way.
Depending on how the utility calls "gpg", it might be affected by your
alias and end up calling "gpg2".

@_date: 2019-04-11 16:26:55
@_author: Peter Lebbing 
@_subject: How do I delete secret subkeys correctly? 
Could you provide an example? I find this rather surprising, that -K
would ever list more than -k.
Yes, that is expected behaviour. You can't delete stuff from the
keyserver, and everything that is valid will be incorporated into your
copy when you fetch it.
I cannot reproduce this on Debian stable with 2.1.18. I think you might
be misinterpreting the result, so I've built a step by step "lack of
reproduction" with comments.
What might be misleading: you say you are dealing with revoked subkeys.
Unless you specify "--list-options show-unusable-subkeys", you might not
see those in the keylistings even though they are there.
--8<---------------cut here---------------start------------->8---
$ gpg --with-keygrip -K 8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
sec   rsa3072 2019-04-11 [SC] [expires: 2021-04-10]
      8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
      Keygrip = 97A3F4843F1B7669524F066472CFA935F23D7574
uid           [  undef ] Testkey
ssb   rsa3072 2019-04-11 [E] [expires: 2021-04-10]
      Keygrip = 6D610FB78404E0C80954BB993E3410ED9FA463A6
--8<---------------cut here---------------end--------------->8---
The gpg binary only deals with public keys in the keyring directly.
Secret keys are delegated to gpg-agent, and gpg-agent works with
keygrips only, so to take a closer look we need the keygrip. Note that
the subkey above starts with the word "ssb" without a suffix, indicating
this is an available key. If the secret part were not available, it
would say "ssb So we expect that if we query the gpg-agent directly,
it will hold that key.
--8<---------------cut here---------------start------------->8---
$ gpg-connect-agent S KEYINFO 6D610FB78404E0C80954BB993E3410ED9FA463A6 D - - - P - - -
--8<---------------cut here---------------end--------------->8---
It does. I'm exporting the public key now to be able to do something
similar to "fetching from the keyserver".
--8<---------------cut here---------------start------------->8---
$ gpg -o test.gpg --export 8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
File 'test.gpg' exists. Overwrite? (y/N) y
--8<---------------cut here---------------end--------------->8---
Let's delete that pesky subkey with delkey.
--8<---------------cut here---------------start------------->8---
$ gpg --edit-key 8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
gpg (GnuPG) 2.1.18; Copyright (C) 2017 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Secret key is available.
sec  rsa3072/0D72EEEAA1274AE5
     created: 2019-04-11  expires: 2021-04-10  usage: SC       trust: never         validity: undefined
ssb  rsa3072/E7ED2961F743E804
     created: 2019-04-11  expires: 2021-04-10  usage: E   [  undef ] (1). Testkey
gpg> key 1
sec  rsa3072/0D72EEEAA1274AE5
     created: 2019-04-11  expires: 2021-04-10  usage: SC       trust: never         validity: undefined
ssb* rsa3072/E7ED2961F743E804
     created: 2019-04-11  expires: 2021-04-10  usage: E   [  undef ] (1). Testkey
gpg> delkey
Do you really want to delete this key? (y/N) y
sec  rsa3072/0D72EEEAA1274AE5
     created: 2019-04-11  expires: 2021-04-10  usage: SC       trust: never         validity: undefined
[  undef ] (1). Testkey
gpg> save
--8<---------------cut here---------------end--------------->8---
I'm immediately suspicious. If it would have deleted the secret part,
I'd have expected a popup from gpg-agent asking me if I was sure about
that. I got no popup. Let's see whether we still have the secret key
available (with the keygrip).
--8<---------------cut here---------------start------------->8---
$ gpg-connect-agent
S KEYINFO 6D610FB78404E0C80954BB993E3410ED9FA463A6 D - - - P - - -
--8<---------------cut here---------------end--------------->8---
Yep, the secret key material is still in our GnuPG homedir. Let's look
at gpg -K and then re-import the public stuff.
--8<---------------cut here---------------start------------->8---
$ gpg -K 8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
sec   rsa3072 2019-04-11 [SC] [expires: 2021-04-10]
      8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
uid           [  undef ] Testkey
$ gpg --import test.gpg gpg: key 0D72EEEAA1274AE5: "Testkey" 1 new signature
gpg: key 0D72EEEAA1274AE5: "Testkey" 1 new subkey
gpg: Total number processed: 1
gpg:            new subkeys: 1
gpg:         new signatures: 1
$ gpg -K 8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
sec   rsa3072 2019-04-11 [SC] [expires: 2021-04-10]
      8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
uid           [  undef ] Testkey
ssb   rsa3072 2019-04-11 [E] [expires: 2021-04-10]
--8<---------------cut here---------------end--------------->8---
Ah yes. We now have the secret key "back" as well even though it is
definitely not part of test.gpg. It says "ssb", we can use it.
I know how to delete the secret subkey, but I don't know how to do it in
a user-friendly way. Let's chat to our gpg-agent again.
--8<---------------cut here---------------start------------->8---
$ gpg-connect-agent
$ gpg -K 8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
sec   rsa3072 2019-04-11 [SC] [expires: 2021-04-10]
      8CD9B759DBA3DC2EBEAA31B40D72EEEAA1274AE5
uid           [  undef ] Testkey
ssb#  rsa3072 2019-04-11 [E] [expires: 2021-04-10]
--8<---------------cut here---------------end--------------->8---
Ah, look. This time when we invoked gpg -K, it is now correctly
indicating that we have deleted the secret part of that subkey, but we
still have the public part. It indicates knowledge of the existence of
the subkey, but it is marked as "ssb this time around, meaning we
don't have the secret key material anymore. So I /have/ answered your
question "how do I delete the secret subkey", but I can only do it by
fiddling with the agent directly rather than through the gpg binary.
I hope this helps your understanding!

@_date: 2019-04-12 12:18:35
@_author: Peter Lebbing 
@_subject: Generating revocation certificate 
Thanks for this piece of information! I'm rather cautious when it comes
to these shell modes of operation. I think I'm understanding it
reasonably well now, but have been surprised about behaviour in the
I note the Bash Reference Manual says:
This use-case sounds like the "almost" bit :-).

@_date: 2019-04-12 12:27:40
@_author: Peter Lebbing 
@_subject: Documentation for agent and scdaemon interaction (Assuan protocol) 
For direct interaction with the agent and scdaemon, my first
documentation source is always the inline help. Only when I need more
than that will I look for more sources.
Talking to scdaemon is done by prefixing your command with "SCD ".
--8<---------------cut here---------------start------------->8---
$ gpg-connect-agent # NOP
# CANCEL
# KEYTOCARD [--force]    # KEYINFO [--[ssh-]list] [--data] [--ssh-fpr] [--with-ssh] # # More information may be added in the future.
# NOP
# CANCEL
# KILLSCD
# LEARN [--force] [--keypairinfo]
#   # Note, that this function may even be used on a locked card.
--8<---------------cut here---------------end--------------->8---

@_date: 2019-04-13 14:34:36
@_author: Peter Lebbing 
@_subject: gpg-preset-passphrase installation and usage 
This version is a full six years old. Not only is 2.0.22 unsupported,
the whole 2.0 branch has been end-of-life for a good bit more than a
year now.
How come you're using something ancient that upstream doesn't support
and which has known defects? Is this a distribution-supported version?
If there is no security support from any party, I think you should
switch to a supported version.
No, that's not how gpg-preset-passphrase works. You supply the
passphrase on the invocation of gpg-preset-passphrase. And you use the
keygrip, not the fingerprint. You can find the keygrip with the
--with-keygrip option when listing the key.
You would supply the passphrase on stdin of gpg-preset-passphrase,
probably from some utility that got it from the operator. Or with the -P
command line option directly, but this makes it visible for any user on
the system through the process list.
There is no feedback if either keygrip or passphrase is wrong. The net
result is simply you'll get a pinentry pop up when you try to use the
And it will only cache it up to max-cache-ttl as mentioned in the man
page for gpg-preset-passphrase, so you probably want to not remove that
option from gpg-agent.conf.
Alternatively, you could just set default-cache-ttl to whatever value
you desire and completely forego gpg-preset-passphrase. Because it
sounds like you are okay with just supplying the passphrase on the first
invocation, it seems?
gpgconf tells us that the data type of the TTL options is uint32, so you
can make a TTL of 136 years. I notice you use a NASA e-mail address.
This TTL might be a problem on an unmanned spacecraft, but somehow I'll
expect your use case is covered ;-). (Plus, max-cache-ttl always limits
it to the 136 years anyway)
If you did not use gpg-preset-passphrase to preset the passphrase, you
can't use gpg-preset-passphrase --forget to clear it again. Either
reload the agent (this will make it forget all passphrases), or issue:
$ gpg-connect-agent 'clear_passphrase --mode=normal KEYGRIP' /bye
I'm not sure whether that last method is future-proof or might change in
some new version. In other words, I don't know if it's part of the API
or an implementation detail.
I did these things on the distribution-provided GnuPG on Debian
stretch/stable. So it's possible that it works differently on different

@_date: 2019-04-13 14:41:02
@_author: Peter Lebbing 
@_subject: gpg-preset-passphrase installation and usage 
Of course I should have made that explicit. You reload the agent by:
$ gpgconf --reload gpg-agent
I should mention this before you start figuring out a way to send it
SIGHUP (which btw would also work fine, it's just that you need a PID

@_date: 2019-04-16 23:52:11
@_author: Peter Lebbing 
@_subject: How to prevent passphrase-caching from within a gpgme-based 
GPG_AGENT_INFO is obsolete and unused in GnuPG 2.1+ (and GnuPG 2.0 is
obsolete itself :-). So I'm afraid that won't work.
The agent and the homedir are tightly coupled. If you want to do
something special to the agent, I think you're going to have to go the
undesirable route of a separate homedir...

@_date: 2019-08-12 19:27:49
@_author: Peter Lebbing 
@_subject: PGP Key Poisoner 
There is no fix for the SKS keyserver network, which explains why it
wasn't fixed in 2.2.17 either. In fact, fixes have been deployed over
the last several years. DANE, WKD, Autocrypt, work on
I thought this (there is no fix) was pretty solidly established by now
on this mailing list and elsewhere?

@_date: 2019-08-13 13:07:07
@_author: Peter Lebbing 
@_subject: Difficulty of fixing reconciliation 
Others tell us: the synchronization protocol as it is cannot be fixed.
You reply: I agree it should - somehow - be fixed?
The sort and unhelpful answer of course is: read the first sentence
again, or disprove it mathematically just like the algorithm was
mathematically proven to work in the first place.
But I'll try to sketch it. I don't know the synchronization protocol.
What I do know: the design goals included resistance to oppressive
regimes interested in deleting anything from the network, so it was to
be designed so it was technically impossible to delete anything.
Furthermore, this is from memory, but when I read basic information
about the SKS reconciliation algorithm, I see the terms "monotonicity
requirement for progress" or something alike.
I don't know if this is how it works, but this is how it could work:
Somebody has worked years on an algorithm for their PhD thesis which
fulfills an important task, and through those years a lot of
mathematical proofs have been spent on proving that it does what was
asked of it. One of these demands was that it could provably never
delete data that had been available earlier.
In order to make this algorithm, the PhD student discovered that they
needed to have some properties hold at *every* single step: otherwise
they could not prove that the algorithm was correct.
So let's see a single step in the reconciliation process as the
reconciliation of a single piece of data that has been added to the
network. The PhD student found they needed a requirement they called the
monotonicity requirement. I don't know what it means precisely in this
case, but I can take a guess: if two hosts are reconciling, the
monotonicity requirement could mean that the data at either one of these
- gets data added and everything that was there stays
- the data it has stays exactly the same
Those are the only two cases that satisfy the monotonicity requirement.
Furthermore, the end goal is for all hosts to have the same dataset, so
let's define progress as that the hosts become more and more alike: when
the number of differences between the hosts has reduced, we have made
progress. Once completed, it has progressed to the point where the
number of differences is zero. As an aside, it has to be proven that we
eventually progress to that point where they are the same, otherwise
there could be a dataset that just keeps spinning, running the algorithm
endlessly. In fact, it's well possible that this is where the
monotonicity requirement plays a role.
Let's do this with your max 2.
Somebody uses SKS keyserver network host A to add two signatures, call
them A1 and A2 to the key in question, which did not have any signatures
yet. Host A accepts them, they fall within the limits.
Either this same person or someone else adds two signatures on SKS
server B on the same key, call them B1 and B2. Hosts A and B haven't
reconciled yet, so B sees no signatures on the key and accepts.
Now they reconcile.
They compare their datasets. They are not the same: we still need to
have progress to get to completion. Let's reconcile signature A1. Server
A offers server B signature A1. Wait a minute, the key already has
signatures B1 and B2. Server B cannot accept signature A1, it would
break the contract that there are ever only 2 signatures on the key.
Now we have a deadlock. There is no following step that would fulfill
the monotonicity requirement as well as make any progress. The only way
to fulfill the monotonicity requirement is when server A keeps the
signatures A1 and A2, and server B keeps B1 and B2. But the progression
has halted and the process never finishes.
Ah, you say, why don't you /swap/ B1 for A1? Well, there is no such
thing as swapping. Swapping is simply the deleting of B1 followed by the
addition of A1. And monotonicity says we can't delete anything.
Besides, any limit on the number of signatures is a Denial-of-Service.
In your case, if Alice, Bob and Carol all sign eachother's keys, there's
no more room for other signatures. And if Mallory creates two bogus keys
and signs all the keys of Alice, Bob and Carol, the three can't add any
real signatures anymore.
The algorithm is designed to withstand very well funded actors,
oppressive regimes were what the designers were thinking of. Obviously,
the algorithm does this regardless of who is trying to do something
otherwise, no matter whether it is a repressive regime or the legitimate
operators and designers of the system.
It seems to me there is (almost?) always a denial of service. Offline
systems have more trouble with this than online systems, and even
websites (online systems) have really expensive world-spanning networks
to mitigate (rather than truly deal with) DoS-attacks.
Asymmetric crypto has a very unfavourable runtime <-> data size ratio.
With just a few bytes, you need a hell of a lot of mathematical
processing to interpret those bytes correctly. It's a really unfortunate
amplification factor: when an attacker hands you a very small payload,
you need a lot of runtime to decide if it was actually something you
wanted. There are better and worse ways to design the data for this
aspect, but it's always going to be on the computation-intensive side of
So GnuPG gets a key with a lot of third-party signatures. It can keep
wading through all the crap looking for the real signatures the user
does want between all the crap added by attackers, and this takes a lot
of runtime.
Or it can decide: this is taking to long, I bail out.
In neither case will the user get that signature that they actually
want, and which according to Murphy is actually near the end of where
GnuPG will be looking.
So the user is denied the signatures it was looking for in either case.
How? You keep looking through the piles of crap, or you stop looking. In
either case, you don't find what you are looking for in a desirable
length of time.
I think the solution needs to be sought in a direction where GnuPG
doesn't have to look for valid data amidst a lot of invalid crap.
Because evaluating the invalid crap can always be made expensive, so
there should be other means to say "I'm not going to parse this, find
another way to get me the proper data where it's not buried in crap".

@_date: 2019-08-13 14:09:53
@_author: Peter Lebbing 
@_subject: PGP Key Poisoner 
I suspect we haven't seen this issue being done in the real world before
because it is not a useful attack in many scenarios. It's just a nasty
DoS that can be avoided by not using the SKS keyserver network. I'm
completely speculating, but I think that the people who really want to
learn something about their victim will use and have used completely
different attacks. This DoS isn't effective at what they want.
I don't know if that is the case, but I think it's a possibility.
This doesn't mean that this attack was harmless; far from it. I think it
has the potential to do a lot of harm to a lot of people. It just
possibly doesn't really accomplish the goals that, for instance,
oppressive regimes or black hats penetrating networks have. And since no
serious attacker used this weakness, by that virtue it might not be a
big problem. The good sides of the SKS keyserver network might outway
its flaws when the flaws are not the flaws that attackers will exploit
in practice.
Until little boys with matches come round and play at being responsible
security researchers without understanding how that actually works.
I don't think the bit about the OCaml code complexity was a good
argument in Rob's gist post.
I think the proper fix is to design an alternative to the SKS keyserver
network. The design choices in the reconciliation protocol don't work
out anymore, we shouldn't change the protocol but replace it.
Several alternatives for key distribution have actually been developed
for many years now. You can't say people are not actively working on
this problem, it's just not true. That they are actually looking in a
different solution space than what you want to see is their right.
Perhaps because there are still users who need it. GnuPG 2.2.17 already
led to a report[1] on the mailing list that they needed third-party
signatures from keyservers. I don't know if they need the SKS network,
but in general, there are users out there who can still use it.
But I obviously can't speak for anyone else.
Only people using the SKS keyserver network are affected by this issue.
You say you don't see a reason to use them. So don't. Tell your
correspondants to use different methods when they exchange keys with
you, and you'll never have to interact with the SKS keyserver network
again. Problem solved; for you. Others will take care of their own.
Also.... Facebook?
A lot of the alternatives to the SKS network have some issues regarding
either a form of trusted third party, or of anonymity. Every service has
its own trade-offs. And some stand out like a sore thumb. Again...
Facebook?! :-)
[1]

@_date: 2019-08-13 14:16:43
@_author: Peter Lebbing 
@_subject: PGP Key Poisoner 
I generally felt there was a lack of concise, complete instructions for
users, after the event. I was missing several pieces of the puzzle
myself. Still, I suppose I could have tried to do this, so it's a bit
odd to be pointing out that this area was lacking when I could have
solved it partially myself. But here we are: I never saw a good concise
complete set of instructions and guidance, and I was a bit surprised
no one wrote it.

@_date: 2019-08-13 14:25:01
@_author: Peter Lebbing 
@_subject: was Re: PGP Key Poisoner // now "Binding one person's subkey to 
But this issue has been fixed for so long that any CD's documenting the
fix will have since bit-rotted! It's ancient Information Technology
To be exact, this has been a non-issue since GnuPG 1.4.8, released
2007-12-20, which defaulted to --require-cross-certification after the
cross certifications had percolated through the ecosystem in the years
leading up to that new default.

@_date: 2019-08-13 17:22:07
@_author: Peter Lebbing 
@_subject: PGP Key Poisoner 
Ah, then the discussion about OCaml is a moot point by now and can be
disregarded until the moment someone proposes to write the replacement
in OCaml :-D

@_date: 2019-08-14 12:37:38
@_author: Peter Lebbing 
@_subject: Difficulty of fixing reconciliation 
Hello David,
I don't see anybody claiming that this is a valid use case.
There are several issues preventing actually limiting this in the
current keyserver network, but this has already been explained.

@_date: 2019-08-14 12:51:09
@_author: Peter Lebbing 
@_subject: Difficulty of fixing reconciliation 
In that case we need a different algorithm.
Which I had already been advocating, so you are preaching to the choir.
You can keep reiterating that you do not like the current algorithm, but
I already got that and I agree.
Which is a denial of service, which I point out in the next paragraph of
the mail you replied to. I'll copy-paste it here with a double
And that's again my very next paragraph:

@_date: 2019-08-14 13:06:55
@_author: Peter Lebbing 
@_subject: Difficulty of fixing reconciliation 
Hmmmm.... the authority could just be the primary key that the
third-party signatures are over. I'm not talking about the current SKS
keyserver network, but some still-to-be-created federated synchronizing
That authority could also authorize no longer sharing a particular third
party signature, I think. It might still circulate in the federated
network, but any time it rears its head again it could get ignored by
the revoked authorization (or more: authorization to revoke). "Ignoring"
might just mean not offering it to clients even though it's still part
of the federation for technical purposes.
There's a lot of chance for misunderstandings here. I started writing
something less ambiguous and stopped due to the amount of work :-).

@_date: 2019-08-14 13:19:02
@_author: Peter Lebbing 
@_subject: Difficulty of fixing reconciliation 
I meant that statement purely and only with regard to deleting data that
had already been in the network, nothing more.
It seems to me that the impossibility of deletion was at the core of the
design of the reconciliation algorithm. To say that we should change the
algorithm to no longer do that seems like claiming we should build
rockets out of sand castles ;-).
These same statements apply to a *lot* of critical infrastructure in the
Information Technology domain. It's a wonder it usually works well (or
at least gives that appearance when you don't look too hard).

@_date: 2019-08-15 11:26:31
@_author: Peter Lebbing 
@_subject: Key poisoning 
Plus, the attacker could just create a signature that looks likely to be
real (self-sig or existing third-party sig seems a good candidate). Only
when actually doing the cryptographic verification will it turn out to
be fake anyway. By that time the amount of processing GnuPG has done is
already enough for the denial of service.
I think the attacker only used cryptographically valid signatures
because it was easier to use existing tooling. There is no reason for
the poison to be cryptographically valid. It just has to be slightly
expensive to verify. GnuPG doesn't even get to the bit where the
signature is validated, since the signing key isn't on the keyring, and
still, we have this DoS.

@_date: 2019-08-15 11:48:37
@_author: Peter Lebbing 
@_subject: My mails to rjh bounce 
By the way, I keep intending to put this as a PS on a proper mail, but I
always forget.
All my mails to Rob keep bouncing. The first bounce was June 30th. I'm
not including the bounce message here on the off chance that there is
something non-public about Robs mail infrastructure :-). So Rob can find
it encrypted to him at [1].
All those bounced mails were also addressed to the mailing list, so he
got a chance to read them anyway...
[1]

@_date: 2019-08-15 12:43:42
@_author: Peter Lebbing 
@_subject: looking for assistance tracking down why i don't have the ability 
That doesn't show which process is starting that gpg. I would start by
$ ps fax | less
and then from within less type for instance
which will search for the line containing that PID. Then you can see its
ancestry (the f option makes a -f-orest of parent/child relations).
There are more ways to investigate, but this seems a good start.

@_date: 2019-08-16 12:16:17
@_author: Peter Lebbing 
@_subject: Key poisoning 
Hi MFPA,
I have no knowledge of the workings of the keyservers. But my guess is
that they would all be coalesced into the single signature that they are
(similarly to when a single new signature was uploaded to two different
SKS keyservers and these are coalesced on reconciliation).
It might be possible if you just change some bytes. I dunno.

@_date: 2019-08-21 12:03:40
@_author: Peter Lebbing 
@_subject: how to recover secret key passphrase? 
I think ilf is quite correct that you need to enter your passphrase to
do an export from the agent-managed store in private-keys-v1.d. The
encryption in the private key store is not the same as the encryption of
a transferable OpenPGP private key anymore, so it needs to be decrypted
and re-encrypted, which is why you're asked for your passphrase.
I think it would have worked in 1.x and 2.0. But for 2.1+, it no longer
works, and
you actually really need the agent to access the private keys from GnuPG
So what ilf probably needs is something that can read the private keybox
format. That's where my advice falls short: I can't help with that.

@_date: 2019-08-22 00:04:55
@_author: Peter Lebbing 
@_subject: BSI withdraws approval of GnuPG for confidential documents 
If I were you, I'd just ask, and note that you will post the answer to
"gnupg-users, the official GnuPG mailing list for general discussion and
help" or something on that order. In that case they will understand this
is for public dissemination among the GnuPG-using populace. This gives
it due weight as well. And relieves Werner of the work, making time free
for stuff only he (or few people at least) can do well.
(And in general, announcing you will publish what someone is writing to
you is the nice thing to do and might even be required)
And heck, it might lend urgency to the topic should Werner subsequently
also ask them.

@_date: 2019-08-27 23:41:39
@_author: Peter Lebbing 
@_subject: Slightly OT - mobile OpenPGP usage 
If a computer is compromised, this is game over for cryptography. Full
BYOD :-)

@_date: 2019-08-28 12:07:05
@_author: Peter Lebbing 
@_subject: Slightly OT - mobile OpenPGP usage 
Damage control in the case of GnuPG would be using a smartcard: while
you are using the smartcard, so can the attacker, but once you pull the
smartcard and no longer use the compromised system, the attacker no
longer has access to the key.
In this scenario it makes sense to have an offline primary key: while
the attacker can issue data signatures and decrypt your files, they
cannot change your key, e.g., add another signing subkey to be used
later when the smartcard is no longer available to the attacker.
Recovery... well, damage control already implied there was damage, and
recovery even more so. Stefan asked for a "best strategy for using
OpenPGP [...]". I did not interpret that as asking for how to limit
damage, but rather to avoid it.
Whether a compromise is game over depends on your scenario. However,
what is quite often asked for here is some way to use a compromised
system without compromising confidentiality of encryption or without
enabling an attacker to issue data signatures. These things cannot be
done on a system where the attacker has control over the whole computer
(root access, in *nix parlance, or hypervisor access). If you can show
me an example where the attacker has full access to a computer and a
user can still do decryption and issue signatures *on that computer*
while maintaining confidentiality and signature integrity, I'd love to
hear about it. However, I've heard many wrong solutions, so in actuality
I don't think I would love to hear about it, because it sounds like a
waste of time.
Here are two obviously wrong ones.
"Provide explicit confirmation of each signature issued by a smartcard
with an external button".
Attacker's solution: pretend something went wrong, and make the user do
the actions again. Nothing actually went wrong, the user issued two
signatures. Social engineering to the rescue. Or, demise.
When they're sending an e-mail, simply make it look like the mail client
crashed just after they confirmed the signature, for instance.
The confirmation button doesn't ensure signature integrity, it is
damage control.
"Provide explicit confirmation of decryption with smartcard".
Whenever user decrypts something, store the decryption key in a
database. When the user decrypts the same file twice, use the stored
decryption key and decrypt that interesting file the attacker wants to
read instead.

@_date: 2019-08-28 12:38:42
@_author: Peter Lebbing 
@_subject: Constantly restarting gpg-agent 
Ah yes, when I use the agent for SSH authentication and it picks the
wrong terminal, if on that terminal bash is active, they seem to race
for stdin. Some of the characters typed go to the pinentry, and some go
to bash. The characters for bash are echoed to the screen. It's a great
way to get part of your passphrase in .bash_history! :-D
But for gpg, this should not happen. gpg will pass the terminal and/or
the X display to the agent, which enables the agent to prompt on the
correct terminal.
You could try debugging the agent. If I add the following to my
--8<---------------cut here---------------start------------->8---
debug ipc
log-file agent.log
--8<---------------cut here---------------end--------------->8---
and then issue "gpgconf --kill gpg-agent", the agent that will be
subsequently started will log inter-process communication to the file
agent.log in my homedir ($HOME, not $GNUPGHOME). There I can see a git
commit signing passing the needed information:
--8<---------------cut here---------------start------------->8---
2019-08-28 12:17:46 gpg-agent[21792] DBG: chan_9 <- OPTION ttytype=screen.xterm-256color
2019-08-28 12:17:46 gpg-agent[21792] DBG: chan_9 -> OK
2019-08-28 12:17:46 gpg-agent[21792] DBG: chan_9 <- OPTION display=:0.0
2019-08-28 12:17:46 gpg-agent[21792] DBG: chan_9 -> OK
2019-08-28 12:17:46 gpg-agent[21792] DBG: chan_9 <- OPTION xauthority=/home/peter/.Xauthority
2019-08-28 12:17:46 gpg-agent[21792] DBG: chan_9 -> OK
2019-08-28 12:17:46 gpg-agent[21792] DBG: chan_9 <- OPTION putenv=DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
2019-08-28 12:17:46 gpg-agent[21792] DBG: chan_9 -> OK
--8<---------------cut here---------------end--------------->8---
Is it perhaps possible that you run something which unsets environment
variables crucial to passing the TTY information to the agent? Have
a look at the debug log the moment you encounter the issue again, and
compare the conversation with an earlier one that did work.
Killing the agent is fine. You shouldn't need to restart it; it is
autostarted and in fact it might interfere with the proper functioning
if you explicitly start it but with different options set than the
autostart would do.

@_date: 2019-08-28 12:47:13
@_author: Peter Lebbing 
@_subject: Slightly OT - mobile OpenPGP usage 
Sorry, I meant, it depends on your definition of "game over", definitely
*not* on the scenario.
I think it is perfectly acceptable to say "compromise = game over", the
only way I see that could be wrong is if you have a different idea of
what game over means.

@_date: 2019-02-01 20:23:26
@_author: Peter Lebbing 
@_subject: OpenPGP on paper 
Just an idea: OCR'ing a special OCR font like the two classics I
mentioned will go a lot better if the OCR engine *knows* it is looking
at that font. They designed the glyphs to be dissimilar. I don't know if
there are any free software OCR engines that can restrict themselves to
a specific font, I'm just reasoning about it without domain knowledge.
Also, if you choose an encoding that avoids similar glyphs like one and
ell, zero and oh, etcetera, your miss rate should go down.
That doesn't seem useful for secret letters. And I don't think you'll
get an offline engine which has been trained like theirs from them.
PS: Could you removed the (was: ...) bit from the subject in replies? I
think I'll stop doing that type of formatting from now on. I saw it
being used quite some time back and when it works it's okay, so I
followed suit. But it's not working that well anymore.

@_date: 2019-02-09 12:48:55
@_author: Peter Lebbing 
@_subject: Keysigning party: after the event challenges 
Hello Andr?,
This is going to be a pain to do manually. But you don't have to! As the
FOSDEM keysigning party page[1] notes, "You may find caff a helpful tool."
(last sentence of the page, not counting the footer).
If you open your ksp-fosdem2019.txt file and put "x" in every checkbox
you have checked on your paper list, you can feed this text file with
checkmarks directly to caff and it will import the keys for you *and*
verify their fingerprints! It will only consider entries with checkmarks
for both "Fingerprint OK" and "ID OK", so only when the participant has
acknowledged their fingerprint matches and you have marked that you find
their identification papers match.
The FOSDEM KSP offers a keyring with all the keys from the party. You
can feed that to caff as well and it won't even need to fetch the keys
from a keyserver (which might not have all keys).
My suggestion is to look for "caff" and documentation and try that
before you verify 107 fingerprints manually :-). If you still hit
problems, report back here and we can take a further look.
That sounds odd, there might be something malfunctioning. But if you use
caff, you don't need Enigmail. And if you use the supplied keyring from
the party, you don't need to use a keyserver at all.
[1]

@_date: 2019-02-10 18:07:26
@_author: Peter Lebbing 
@_subject: Configuring Linux system mail submission 
Hi Andr?,
I had feared it would break down at the mail configuration stage :-). I
have mail servers running with a hand-managed config file with Exim 4,
but I know nothing about Postfix. However, for mail submission, I use
nullmailer myself. It can only do mail submission, but is much easier to
manage than a full mail system (in my opinion).
So I don't know if you installed Postfix for this purpose or actually
use it for a real mail server, but if you can switch to nullmailer that
would allow me to easily help you, probably.
Personally, I run nullmailer on all systems that are not running a
full-fledged mail server, and they connect to my edge mail server for
mail submission. You can just use any SMTP-supporting provider for the
When installing nullmailer on Debian, it will ask you interactively for
entries for files in /etc and /etc/nullmailer. Mine look like this:
domain name of the local host)
That last one is the really important one. It uses the SMTP submission
port, STARTTLS, and in my case a password that has been chosen to not
require quotes. But you can use quotes to just use your provider account
I believe /etc/mailname is primarily used to build the sender address
and build recipient addresses that specify no host, i.e., something like
. /etc/nullmailer/defaultdomain is used for not fully qualified
hosts, i.e., if I write  it will qualify the hostname
butters with that domain name. It's not that important for this purpose.
There is one more detail to get right. Because this will actually make
the mail originate from the user  in
this example and a username of peter. This is probably not what you
want, you want  if you're me. If this is always
what you want when sending mail through the system mailer, you could
make sure the following environment variables are set for this user:
If you're anxious about changing environment variables that have
influence over programs other than nullmailer, you can use
NULLMAILER_USER and NULLMAILER_HOST instead.
But for me, the  is actually an e-mail
address that will be accepted on the right side of my firewall, and is
used for system messages from, e.g., cron. It is not the address I want
for caff, though. But caff does the right thing already by specifying
the e-mail address you want in ~/.caffrc:
$CONFIG{'email'} = 'p.lebbing at provider.nl';
This will automatically set both the envelope sender and From: to that
One remark: the hostname from /etc/mailname is used to build the Message-Id: header. If you'd like to hide that, you could set:
I think that mirrors Thunderbird's behaviour, taking a peek in my "Sent"
You could also arguably just set /etc/mailname to provider.nl and drop
the MAILHOST env variable in the process, but I'd feel slightly anxious
over accidentally building mail addresses of other customers of my
provider as if they were the sender, so I wouldn't do that. Imagine your
webserver started sending mails from  accidentally
that way, or ... these might annoy your provider. And
it gets worse with a regular user account, let's call her Anna. She
might not control .
I think that covers it. You can try stuff from the command line to see
what it becomes without actually sending with:
$ nullmailer-inject -nv

@_date: 2019-02-16 12:46:22
@_author: Peter Lebbing 
@_subject: Configuring Linux system mail submission 
Hi Andr?,
The more domain names, the merrier!
There is no single right answer. These names are used to build e-mail
addresses when you don't specify a fully valid e-mail address when you
send the mail; both for the sender and the recipient addresses. As I
indicated in the previous mail, I think you should avoid the situation
where nullmailer will build e-mail adresses on a domain you don't
control yourself, to prevent annoying people who happen to have the
address that nullmailer builds.
This all simply does not apply to caff, and caff is our intended goal.
But configuring nullmailer might also cause daemons on your computer to
try and start sending e-mails, and that is where it does apply.
I've gone through several iterations of this e-mail. The thing is,
there is no single right answer. There are multiple wrong answers. And
my system is configured differently than yours, so I can't just say
"this works for me", since I know for a fact it will not work for you.
I'm sorry if I'm confusing you. I'm doing my best, but I'm simply not
sure of the *best* solution in this case.
So I hope that this is the best outcome:
First, let's see what your computer thinks it is called. Invoke this:
$ hostname --fqdn
It will give you the domain name of the computer. Let's say this
$ hostname --fqdn
Then let's put this in the files:
This will cause any e-mails addressed to some-username at mario,
some-username at mario.itsa.me and some-username at localhost to end up being
delivered to andre at ockers.eu. They might not succeed, though, because
your e-mail provider might very well reject the sender of the mail. You
should probably check every now and then whether there is anything stuck
in /var/spool/nullmailer/queue.  You can delete any files there and it
will stop trying to deliver that e-mail. You do need to be root to
delete them.
Note that Postfix would probably not do better at delivering those
e-mails. It could be configured to do so, but by default it would not.
And the idhost line prevents the name mario.itsa.me from ending up in
the e-mail headers (specifically, the Message-ID line). It mirrors your
current e-mail setup, which I could see in your e-mail headers. Some
people don't like names from their internal network leaking out to the
big bad internet. But it might still happen in other places.
This is the same as when configuring your e-mail client. If your e-mail
service provider has given you the following outgoing mail server
Outgoing mail server: smtp.serviceprovider.nl
User name: some-username at serviceprovider.nl
Password: lalala
Then the line becomes
Some providers will use a full e-mail address as user name, others just
the bit before the You could take a look in your e-mail client software (which clearly
works) and see what it has there for outgoing mail server settings. That
probably will not show you the password right away.

@_date: 2019-02-18 12:09:36
@_author: Peter Lebbing 
@_subject: Yubikey keytocard: "Bad secret key" 
First of all, I think it's a much better idea to generate a 2048-bit key
anyway, so it worked out okay.
But the problem is interesting. Before --card-edit gained its key-attr
command, GnuPG would do the correct key-attr stuff automatically to
switch to the desired key length. Maybe it has stopped doing that now,
and you need to do:
$ gpg --card-edit
gpg> key-attr
to select the desired key length before keytocard.
At the moment, I don't have a version with key-attr at hand to quickly
test myself.

@_date: 2019-02-19 11:23:52
@_author: Peter Lebbing 
@_subject: Using Yubikey only to encrypt/sign 
Ah, well, there's your problem.
You should not use your primary key for encryption; they invented
subkeys for that.
And with the smartcard, you come into the uncomfortable situation that
the smartcard will decline to decrypt with what it knows is a signature
key, and likewise decline to sign with what it knows is an encryption
key. But both those usages are this key, and there will only be one stub
in GnuPG, which will refer to either a smartcard signature key or a
smartcard encryption key, but not both.
The most straightforward solution is to create an RSA primary key that
does certification and signatures (usage: SC), and an RSA subkey that
does encryption (usage: E). My --full-gen-key calls this option "RSA and
RSA (default)".
You can then upload those keys to the correct slots in the smartcard (it
will decline to pick the wrong slot). But if you wish to use the on-disk
keys after that, and the smartcard somewhere else, you should "Quit
without save", because as you have experienced, it will *delete* the
on-disk key when you "Save and quit" and only use the smartcard key from
then on.
As an aside, I'll note that you could also create a primary key that can
only certify, and a separate subkey that does signatures. That way, you
can have only subkeys on your smartcard, and compromise of the system
you use the smartcard on will only allow the attacker to issue
signatures on documents, but not edit your key or issue signatures on
other /keys/. But this might not be necessary for you, it depends on
what threat model you envision.

@_date: 2019-02-23 14:10:49
@_author: Peter Lebbing 
@_subject: Help with SSH and GPG subkey for authentication 
A key's fingerprint is something specific to OpenPGP. It includes
OpenPGP-specific information and formats. As such, it is undefined for
an OpenSSH key or a CMS (X.509) key; it simply doesn't exist.
A keygrip is a short representation of an asymmetric keypair's actual
public key material. For example, it is the same for an RSA key whether
that key is used for an OpenPGP key, an OpenSSH key or a CMS key.
gpg-agent works with keygrips because it provides services to all of
OpenPGP, SSH and CMS. And it allows you to use the same material in
multiple formats that way, such as with the Authentication subkey.

@_date: 2019-01-08 12:19:53
@_author: Peter Lebbing 
@_subject: gpg > addphoto 
Well, changing this number to something smaller would do nothing to
prevent this. It's probably just a generous upper limit to prevent a DoS
on GnuPG. What keyservers accept is not influenced by GnuPG.

@_date: 2019-01-08 14:32:21
@_author: Peter Lebbing 
@_subject: gpg > addphoto 
Hello Stefan,
I hadn't looked closely, but since this is MAX_..._LENGTH in
parse-packet.c, I assumed this is a cutoff while parsing packets. So if
GnuPG encounters a packet that declares it is more than 16 MiB in size,
instead of trying to gobble up and interpret and output all this data,
which could lead to DoS (memory exhaustion, disk space exhaustion, long
running time), GnuPG will just error out. So if GnuPG is ever fed
crafted data that tries to DoS GnuPG, it will simply refuse to process
So I assumed this didn't have anything to do with restricting what you
can do with your own GnuPG, but what others can do onto your GnuPG.
Suppose --edit-key restricted you in some way. This is free software.
You just remove the restriction and recompile. Just like some people
enjoy making insanely large RSA keys with GnuPG: they just remove the
limit and recompile. So restricting --edit-key does not prevent you from
bad actors.

@_date: 2019-01-08 16:17:21
@_author: Peter Lebbing 
@_subject: gpg > addphoto 
Hi Stefan,
Which is why I think this is not intended as a restriction to the users,
but a restriction for DoS.
Usually people here complain GnuPG doesn't allow for their use case,
it's refreshing to read an opposite complaint ;-).

@_date: 2019-01-08 18:50:12
@_author: Peter Lebbing 
@_subject: gpg > addphoto 
Hi Stefan,
I'm just guessing, I don't know for sure. But since it seems you're
unclear about what I meant, I'm trying to explain that.
I don't think this implementation is meant to restrict users in creating
image attributes at all. It's not meant as some means to stop a user
from creating a mega-large image. So you're coming from the wrong
direction when you say "isn't this a bit too much to allow".
Rather, it's meant as a means to prevent *reading* such a large image.
With all software, but with crypto even more, you need to build in
defenses against people trying to create a mess for others.
So suppose someone created a public key containing some mega-large
image, or corrupting a public key to contain nonsense data. In this
case, when you import this key and your GnuPG is reading this data it
needs to have some safeguards against malfunctioning. You ask why it was
implemented this way. The reasoning is: nobody bona fide would ever
create an (image) attribute larger than 16 MiB. In fact, it would be
much less, but we're being conservative and saying: well, no matter the
circumstances, 16 MiB is certainly ridiculous. So if GnuPG ever
encounters an attribute larger than 16 MiB, it should just stop and
display an error instead of trying to continue. Because clearly
something fishy is going on. A real attribute will always be much
smaller. That's a reason to halt and give up.
So, yes, 16 MiB is ridiculous. That's the point. It's a test to see
whether we are doing something that we're supposed to be doing, or
whether we're looking at something ridiculous.
So when you say "Shouldn't users be forced to limit themselves to
something much smaller?", that's simply a different subject as I
understand it. This 16 MiB has nothing to do with that, it's a different
I hope I did a good job of explaining my meaning this time around.
But I'd like to tack on even more thoughts :-). Because finally, what
GnuPG enforces is again something different from what the keyserver
network enforces. If you're worried about big images or other data being
uploaded to the keyservers, the place to fix that would be the
keyservers, not GnuPG, because a bad actor could just change their own
GnuPG. But they can't change the code running in the public keyserver
network other than by running their own keyserver.

@_date: 2019-01-10 19:25:26
@_author: Peter Lebbing 
@_subject: gpg > addphoto 
That would be rather surprising as usually such limits are chosen to be
quite conservative, i.e., way above what is legitimately used. That
would thus mean that there are no such large legitimate attributes.

@_date: 2019-01-20 17:07:23
@_author: Peter Lebbing 
@_subject: Discrepancies in extracted photo-id images from dumps 
I had a quick scan through the source code, but couldn't find it. But it
seems to me it's likely to be a hash of the User Attribute Packet (RFC
4880), which is an alternative form of a User ID. As such, it would be a
unique identifier of the image in question. Does it really matter?
It's 32 digits of base32, which makes it 32*2log(32) = 32*5 = 160 bits.
So my guess is it's a raw hash and as such not something to be
"understood" but high entropy data. Either a 160-bit hash (seems likely)
or a truncated longer hash.
Oh, note that the base32 is the one from RFC 6189, not the one from
3548. I saw that in the source. I played around a bit, but couldn't
quickly home in on what the hash actually is. Maybe you have better
luck (or more patience :-). Hashes are rather unforgiving of mistakes
you make in the input to it :-).

@_date: 2019-01-20 17:34:28
@_author: Peter Lebbing 
@_subject: decryption failed: Bad session key 
Hi Frank,
This is also the error message you get when you specify the wrong
passphrase. Perhaps you mistyped the passphrase when encrypting it? That
way, no matter how correct you type it when decrypting it... you get it.
Other password problems can occur if you use special characters and your
OS upgrade changed the handling of those in some way. If this is the
case, you could try temporarily running an old backup of your previous
OS. Or if that is not available, you could try a live CD, but that might
be configured differently than your old OS with regard to special
Or you could try purpose-built tools that will try variations on the
passphrase you supply brute-force. I don't have any experience with
these, I just saw them mentioned now and then. The idea is that it can
quickly try all kinds of typo mistakes and see if one of them gets you
in. Actually brute-forcing a good passphrase with no specific clues
should be impossible by design; the fact that you /almost/ know the
correct passphrase is what gives you the edge.

@_date: 2019-01-20 19:22:10
@_author: Peter Lebbing 
@_subject: Discrepancies in extracted photo-id images from dumps 
Oops! I was looking at ancient code instead of the current code. That's
why I didn't find it. It's a RIPEMD-160 hash of the attribute that
contains the JPEG image, but I'm not 100% clear on the exact byte
sequence. But it just hashes a representation of the image.  You can see
the hash in it's hexadecimal form in:
--8<---------------cut here---------------start------------->8---
$ gpg --with-colons -k KEYID
uat:n::::1497792746::91EC5F9C95BBB125AC85F65C06EF025712FCD036::1 2111:
--8<---------------cut here---------------end--------------->8---
The 8th field (91EC...) is the UID hash, and is equal to the base32
encoded string in the %U escape.
Or as DETAILS.gz puts it:
Furthermore, 'n' = validity, '1497792746' is creation time, '1 2111' is
the number of attribute subpackets followed by the total attribute
subpacket size. For more DETAILS, well, see DETAILS.gz.

@_date: 2019-01-21 11:45:47
@_author: Peter Lebbing 
@_subject: decryption failed: Bad session key 
Yes, it is somewhat unfortunate. It is due to the mechanics of
symmetrically-encrypted OpenPGP messages. The passphrase is used to
decrypt the session key. A wrong passphrase just results in garbage on
decryption. This garbage then leads to the "Bad session key" message.
I wrote some stuff about possible changed handling of special
characters. But that doesn't really match what you describe, you said it
occurred only after you encrypted it with the new system. Unless you're
mistaken, it's not likely to be a mismatch in handling special
characters then. But it might give some insight if you try to encrypt a
new file with the same passphrase: can you encrypt and succesfully
decrypt a different file with the same passphrase? In that case, your OS
would seem to handle that specific passphrase without problems. I'm not
committing to a stronger assertion than "would seem to", though :-).
Also, how do you invoke encryption and decryption? Maybe you're doing
something that might explain it that I'm not aware of. If you can give
the specific commands used (but with the filenames edited for privacy)
it might lead to insights.
Furthermore, the pinentry passphrase entry mechanism can interact with a
keyring manager like GNOME Keyring and such. Maybe this is throwing a
spanner into the works? Check your pinentry to see if it indicates some
keyring manager is being used or something like that.
Do you have a backup of the file before it went wrong, by the way?

@_date: 2019-01-21 14:21:53
@_author: Peter Lebbing 
@_subject: Discrepancies in extracted photo-id images from dumps 
Hello Stefan,
Since I didn't exactly follow the "22 bytes" part I looked at it one
more time; I got curious. It turned out I accidentally cut off part of
the inner header when I intended to strip the outer header, silly me. I
went too quickly.  What works for me is:
- Take the User Attribute Packet
- Strip off the header: 1 byte tag, and in my case, 2 bytes length
  (lengths are encoded on 1, 2 or 5 bytes)
- Hash what's left
$ gpg --export KEYID | gpgsplit
Take a file named *.attribute
Is the file smaller than 194 bytes? Wow, small attribute. Drop the first
two bytes.
Is the file between 194 and 8386 bytes inclusive? Drop the first three.
If it's larger than 8386 bytes, drop the first six bytes.
And hash the rest of the file.
$ dd if=002839-017.attribute bs=1 skip=3 status=none|gpg --print-md RIPEMD160
For a real implementation, it's better to inspect the length field
rather than reverse-compute its own length based on the file size.
The 22 bytes added goes in reverse: 2 octets encoded length apparently,
appropriate for the usual JPEG file smaller than a bit over 8 KiB, and
then 01 10 00 01 01 00 00 00 00 00 00 00 00 00 00 00 00 for the header
bits before the JPEG file.
--8<---------------cut here---------------start------------->8---
b32s = "ybndrfg8ejkmcpqxot1uwisza345h769"
def b32enc(i):
    s = ""
    while i:
        s = b32s[i & 0x1f] + s
        i >>= 5
    return s
def b32dec(s):
    out = 0
    for c in s:
        out = (out << 5) + b32s.index(c)
    return out
--8<---------------cut here---------------end--------------->8---
If the encoded string is shorter than expected, prepend y's :-). It's
the simplest code that sort-of works. There might be more issues, it's
really bare-bones.

@_date: 2019-01-30 20:22:35
@_author: Peter Lebbing 
@_subject: [OT] Where can I find some papers to read on mail (and envelope) 
The sender could  use their hat for that ;-P
Oh, most definitely.
In this day and age, I'd probably look at a two-dimensional barcode
Supposing I would even consider sending OpenPGP data on paper :-). Other
than key backups, where I'd opt for the program paperkey rather than

@_date: 2019-01-30 21:23:56
@_author: Peter Lebbing 
@_subject: OpenPGP on paper (was: Where can I find some papers to read on mail 
(Changed the subject because we went off-topic on an off-topic thread
and in doing so went back on-topic for the mailing list! :-)
Well there are the classical options:
Debian provides free fonts like that as packages fonts-ocr-a and
fonts-ocr-b, which come from:
Oh, nice. My bank uses something similar (you get a device with a camera
you point at your webbrowser screen), but this is an open standard,
that's much better.

@_date: 2019-07-01 12:44:38
@_author: Peter Lebbing 
@_subject: SKS Keyserver Network Under Attack 
I think this mail sums up the most important points about this whole
ordeal very well. I completely, wholeheartedly agree. I encourage
everyone to re-read it and internalise it.
The only point not touched upon in this specific mail, I think, is why
people who say that the damage that has been done is not of consequence,
are wrong.
It seems to me that rjh's and dkg's keys will be in many public keyrings
and in many (key) signature chains, and thus have the potential to cause
major problems for many people all around the world when they refresh
their keys. I'd say the consequences of poisoning precisely these
well-connected keys are pretty major. People who depend upon OpenPGP
will find their software is hung and timing out, even when they're not
trying to do anything with these specific public keys: often it's enough
the poison is on the keyring, as far as I can tell. Lacking the
knowledge to fix this, they will no longer be able to check signatures,
and probably be unable to read encrypted messages altogether.
For me, that'd be a nuisance.
For some people, it may have very large real-life consequences.

@_date: 2019-07-02 10:06:31
@_author: Peter Lebbing 
@_subject: Your Thoughts 
None of any of the alternatives to OpenPGP you mention solve the issue
that a secure offline system sets out to solve. They are orthogonal
Alternatives to OpenPGP have the same need or lack of need of a secure
offline system as OpenPGP itself. The only difference I can think of
would be in the number of messages disclosed or the range of signatures
that could be faked by a compromise, not the base premise of disclosure
and impersonation.
You might well reasonably object to the UX of OpenPGP. Just not on the
ground that there are people who think about offline secure systems,
that makes no sense to me. The two are unrelated. The only relation I
can think of is that people who think about deploying offline secure
systems probably aren't quickly scared off by an overly complicated
system ;-).

@_date: 2019-07-02 10:51:29
@_author: Peter Lebbing 
@_subject: Some thoughts on the future of OpenPGP and GnuPG 
Oh, for the love of...
Seriously, ... . I'm going to exercise some restraint here and not write
anything else, because I can't find words to do it politely.

@_date: 2019-07-03 11:59:08
@_author: Peter Lebbing 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
What is the difference in the end result between --keyserver-options
self-sigs-only and --import-options import-minimal? I think the former
keeps all self sigs and the latter only the most recent valid self sig?
Is it perhaps possible to incorporate the desired functionality of
self-sigs-only into import-minimal, avoiding another extra option?
Perhaps the extra granularity of self-sigs-only is not a useful feature
for users, and poisoned keys should just be imported by import-minimal
which could automatically imply the current functionality of

@_date: 2019-07-03 12:29:39
@_author: Peter Lebbing 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
Ah, based on a new message I just read the penny dropped. self-sigs-only
can be made a default because it only applies to keyservers.
import-minimal cannot be made a default because it affects all other
methods of importing.
Hope that helps myself / Happy to help myself / HTHM,

@_date: 2019-07-03 12:58:39
@_author: Peter Lebbing 
@_subject: Local solutions: SKS Keyserver Network Under Attack 
Hello Roland,
The usual case on Linux systems is that if a configuration file would
otherwise be empty or equal to the default (the two can be entirely
different things in general!), the configuration file simply does not
So instead of modifying ~/.gnupg/dirmngr.conf, *create* one and put a
single line in it saying
keyserver hkps://keys.openpgp.org/
I encountered some strange behaviour here: I invoked
$ gpgconf --reload dirmngr
afterwards (otherwise dirmngr will not reconsider its now changed
configuration), and it *did not work*. It was still using the default.
It did work after I rebooted (I was not in the mood to fiddle more with
it and did the most heavy-handed thing that would work).
Also, Enigmail doesn't seem to use this configuration at all and instead
it is configured at
Enigmail -> Preferences -> Keyserver
I did verify using systemd's journal that the gpgconf --reload command
reached its intended goal: dirmngr said "re-reading config". It just
didn't have an effect for some odd reason. For people thinking about
this: no, I don't use Tor for keyservers, it's not related to dirmngr
refusing to change keyservers when on Tor.

@_date: 2019-07-03 13:50:31
@_author: Peter Lebbing 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
But then import-minimal could be modified so it includes the behaviour
currently planned for self-sigs-only, and import-minimal could be made
the default for --keyserver-options, eliminating the need for another
option called self-sigs-only.
I don't think there is a need for the extra granularity:
1) --keyserver-options self-sigs-only retains all self-sigs
2) --keyserver-options import-minimal retains only the most recent
   self-sig
Is there a good use-case for the former? If the latter also filtered out
non-self-sigs in a very early stage like planned for self-sigs-only, in
addition to its current functionality in a later stage of import, it
would prevent the poison.

@_date: 2019-07-03 15:42:21
@_author: Peter Lebbing 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
I fear we're miscommunicating, so let me try to rephrase it again. Sorry
for my persistence, it's only because I think we're miscommunicating and
it would be good if that could be fixed.
--keyserver-options import-minimal
behaved like
--keyserver-options self-sigs-only,import-minimal
as I propose, why would it take longer than 0.2 s?
If there is no good use case for using
--keyserver-options self-sigs-only
instead of
--keyserver-options self-sigs-only,import-minimal
or for using
--keyserver-options import-minimal
instead of
--keyserver-options self-sigs-only,import-minimal
then the self-sigs-only behaviour can be folded into import-minimal,
avoiding creating yet another option in an already crowded option space.

@_date: 2019-07-03 15:55:11
@_author: Peter Lebbing 
@_subject: Local solutions: SKS Keyserver Network Under Attack 
Hello Roland,
I don't think Enigmail respects dirmngr.conf, it just provides its own
set of keyservers. At least, if I delete them all from the Preferences
dialog of Enigmail, it prompts me to enter a keyserver, defaulting to
the literal text "undefined".

@_date: 2019-07-03 16:43:40
@_author: Peter Lebbing 
@_subject: dirmngr not picking up new config? 
There hasn't been a keyserver line in my gpg.conf in a long time; I
checked this before I created dirmngr.conf. And I was testing on the
command line, using --refresh-keys.
My guess is: dirmngr reloads existing configuration files but fails to
check for new ones.
Here's a reproduction:
--8<---------------cut here---------------start------------->8---
$ pwd
$ rm .gnupg/dirmngr.conf $ gpgconf --kill all
$ gpg --refresh-keys ac46efe6de500b3e
gpg: refreshing 1 key from hkps://hkps.pool.sks-keyservers.net
gpg: key AC46EFE6DE500B3E: 2 signatures not checked due to missing keys
gpg: key AC46EFE6DE500B3E: "Peter Lebbing " not changed
gpg: Total number processed: 1
gpg:              unchanged: 1
$ cat >.gnupg/dirmngr.conf <" not changed
gpg: Total number processed: 1
gpg:              unchanged: 1
$ stat dirmngr.log
stat: cannot stat 'dirmngr.log': No such file or directory
$ gpgconf --kill dirmngr
$ gpg --refresh-keys ac46efe6de500b3e
gpg: refreshing 1 key from hkps://keys.openpgp.org/
gpg: key AC46EFE6DE500B3E: "Peter Lebbing " not changed
gpg: Total number processed: 1
gpg:              unchanged: 1
$ cat dirmngr.log
2019-07-03 16:30:01 dirmngr[13185.0] permanently loaded certificates: 0
2019-07-03 16:30:01 dirmngr[13185.0]     runtime cached certificates: 0
2019-07-03 16:30:01 dirmngr[13185.6] handler for fd 6 started
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 -> # Home: /home/peter/.gnupg
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 -> # Config: /home/peter/.gnupg/dirmngr.conf
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 -> OK Dirmngr 2.1.18 at your service
2019-07-03 16:30:01 dirmngr[13185.6] connection from process 13184 (1000:1000)
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 <- GETINFO version
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 -> D 2.1.18
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 -> OK
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 <- KEYSERVER
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 -> S KEYSERVER hkps://keys.openpgp.org/
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 -> OK
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 <- KS_GET -- 0x8FA94E79AD6AB56EE38CE5CBAC46EFE6DE500B3E
2019-07-03 16:30:01 dirmngr[13185.6] resolve_dns_addr for 'keys.openpgp.org': 'keys.openpgp.org' [already known]
2019-07-03 16:30:01 dirmngr[13185.6] resolve_dns_addr for 'keys.openpgp.org': 'keys.openpgp.org' [already known]
2019-07-03 16:30:01 dirmngr[13185.6] number of system provided CAs: 152
2019-07-03 16:30:01 dirmngr[13185.6] DBG: chan_6 -> S SOURCE 2019-07-03 16:30:02 dirmngr[13185.6] DBG: (16329 bytes sent via D lines not shown)
2019-07-03 16:30:02 dirmngr[13185.6] DBG: chan_6 -> OK
2019-07-03 16:30:02 dirmngr[13185.6] DBG: chan_6 <- BYE
2019-07-03 16:30:02 dirmngr[13185.6] DBG: chan_6 -> OK closing connection
2019-07-03 16:30:02 dirmngr[13185.6] handler for fd 6 terminated
--8<---------------cut here---------------end--------------->8---
Here's the stuff my Debian stable reports about my GnuPG:
--8<---------------cut here---------------start------------->8---
Package: gnupg
Version: 2.1.18-8~deb9u4

@_date: 2019-07-03 17:15:59
@_author: Peter Lebbing 
@_subject: SKS and GnuPG related issues and possible workarounds 
Do you object to your data being available not only from the many public
archives of this mailing list but also from the SKS keyserver network?
If so: why? Don't you think many more people would use a web search to
find out about your name and e-mail address than use a keyserver search?
And why the hell does  exist then?!?!
Or is it not that you wish to invoke the GDPR for what it was meant for,
but rather you want to force the SKS keyserver network to go down,
forcing your world view upon the good people running the network? If so:
why do you feel entitled to do that?
I seem to remember you threatening, more than a year ago, to hose some
specific person's public key, who was it again, with bogus third-party
I get the notion you're not what you'd call a "team player". "Bully"
seems to be a better description. I'm going to leave it at that, because
I don't want the list to go down the road I so desperately want to go
personally. I'll take some solace from having recently read some
stronger qualifications in a public post.

@_date: 2019-07-03 17:22:39
@_author: Peter Lebbing 
@_subject: SKS and GnuPG related issues and possible workarounds 
It's in the reconsiliation protocol and the very foundation of the
assumptions of the synchronizing keyserver network. GnuPG doesn't come
anywhere near this protocol, it's just a downstream casualty of the
implications of the system.

@_date: 2019-07-03 18:28:14
@_author: Peter Lebbing 
@_subject: SKS and GnuPG related issues and possible workarounds 
Pfah. Stop rationalising. If this is your concern, create a website
where your offer your services to people wishing to do this and
advertise that website broadly. Then do it for the first person that
truly wants to have their data removed.
I asked why you felt entitled to force your opinion upon others. You say
nothing about that.
You just like to bully. That's your reason.
Yes, really cool! And totally beside the point, because I brought up
keybase to illustrate my point that you do not want to invoke the GDPR
currently to remove your data. If you would currently want to remove
your data, you would have already closed your keybase account.

@_date: 2019-07-03 19:00:55
@_author: Peter Lebbing 
@_subject: SKS and GnuPG related issues and possible workarounds 
You just said that if only you had the time and money, you would try to
take down the SKS network using a legal procedure. A procedure meant to
object to your data being available on the internet, while you clearly
don't have a problem with your data being available.
A year ago, you threatened to do precisely what has happened now: poison
Rob's OpenPGP key. You might even be the one that has done it, we can't
That's not posting an opinion here. And it /is/ threatening to force
your way on other people.
This all is so bloody transparent that I don't see what your point is
yelling that the sky is green when clearly it's blue.
And apparently, I didn't check although it did ring a few bells, you
have in the past indicated you had wilfully fucked with other people's
OpenPGP keys to prove your point that it was possible. That's vandalism
in my book.
Neither of us gets to decide that for the other. BTW, you literally
asked a question ("Why so upset?").

@_date: 2019-07-04 15:35:11
@_author: Peter Lebbing 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
Ah, yes, I had completely not considered that area of impact.
No, I think it's a good name.
Thanks for making the rationale of the design clear!

@_date: 2019-07-05 11:26:58
@_author: Peter Lebbing 
@_subject: SKS and GnuPG related issues and possible workarounds 
Plus, the data is preserved in different places such as archive.org,
which I showed already in my earlier post:
That's a snapshot from 2 months ago, which will not go anywhere.
It kinda was my point posting that link ;-).
PS: Before you blame archive.org: they respect robots exclusions and
wishes from individual site owners. It was keybase.io which allowed it
in the first place, although it may or may not have been a conscious
decision on their part.

@_date: 2019-06-30 17:33:37
@_author: Peter Lebbing 
@_subject: SKS Keyserver Network Under Attack 
I had to read it twice to distill what I think Mirimir meant, but I
think they meant that if you blacklist/blackhole all affected
certificates, you remove the incentive for the attackers to poison more
certificates since the poison can't spread to the people fetching keys.
Thus stopping the attackers.
I concluded that Mirimir perhaps forgot about that this creates a second
attack model, where you can block keys from being on the keyserver. This
seems like a new problem that means this stopgap measure is probably not
the one we want, since it still provides the incentive for attackers to
poison keys.

@_date: 2019-03-13 18:24:41
@_author: Peter Lebbing 
@_subject: Newbie: Installing Build Dependencies to gnupg-2.2.13 update from 
I fully agree. In fact, I much prefer someone include a lot of
information and maybe include too much than that the person trying to
help has to ask for more information. The one thing that would have made
the mail even better was if shell output was put between markers like
--8<---------------cut here---------------start------------->8---
Terminal contents
--8<---------------cut here---------------end--------------->8---
Some mail clients auto-format this, which makes the e-mail more
readable, but even without special formatting it helps a /lot/ with the
In fact, Werner refuses to look at pastes on sites that require
JavaScript. That means you lose out on the expertise of the person who
knows the most about GnuPG! :-)
7) This is an FSF mailing list. Solely relying on libre services is much
preferred in any case. Suggesting people use non-free software quickly
ends up in the "not allowed here" territory!
Back on topic, I /do/ completely agree with Oscar Carlsson that it is
rather futile to compile stuff for an OS that will be unsupported in a
few weeks. Running an unsupported OS should not be done in almost every
instance. Running security software like GnuPG on an unsupported OS is
an enormous red flag and defeats the purpose of GnuPG IMNSHO.
My 2 cents,
PS: I found it ironic that the person admonishing someone to be concise
was the one who forgot to trim the quotes per list rules :-P. This is
tongue in cheek and should not be taken seriously.

@_date: 2019-03-15 20:35:02
@_author: Peter Lebbing 
@_subject: (OT) Formatting mails to this list 
Yes, that's exactly what I meant :-). That makes it easier on the eyes
to distinguish where prose is and where shell output is.
And when you reply to e-mails, please strip qoutes to the minimum
necessary to provide context. It's a mailing list, so anyone wanting to
read what the previous e-mail said can simply do so in the original
mail. Quoting is only to provide context what you are replying to.

@_date: 2019-03-16 11:11:57
@_author: Peter Lebbing 
@_subject: Identifying one of multiple authentication subkeys 
Hi Brian,
> Hi,
Provided the auth keys are in your .gnupg/sshcontrol file, the following
will help:
--8<---------------cut here---------------start------------->8---
$ ssh-add -L | head -1 >firstkey
$ ssh-keygen -l -E md5 -f firstkey 2048 MD5:69:22:fd:08:4e:a5:77:c5:2c:1c:c5:e4:e3:e0:96:96 /home/peter/.ssh/id_rsa (RSA)
$ gpg-connect-agent # KEYINFO [--[ssh-]list] [--data] [--ssh-fpr] [--with-ssh] # # Return information about the key specified by the KEYGRIP.  If the
# key is not available GPG_ERR_NOT_FOUND is returned.  If the option
# --list is given the keygrip is ignored and information about all
# available keys are returned.  If --ssh-list is given information
# about all keys listed in the sshcontrol are returned.  With --with-ssh
# information from sshcontrol is always added to the info. Unless --data
# is given, the information is returned as a status line using the format:
# #   KEYINFO       # # KEYGRIP is the keygrip.
# # TYPE is describes the type of the key:
#     'D' - Regular key stored on disk,
#     'T' - Key is stored on a smartcard (token),
#     'X' - Unknown type,
#     '-' - Key is missing.
# # SERIALNO is an ASCII string with the serial number of the
#          smartcard.  If the serial number is not known a single
#          dash '-' is used instead.
# # IDSTR is the IDSTR used to distinguish keys on a smartcard.  If it
#       is not known a dash is used instead.
# # CACHED is 1 if the passphrase for the key was found in the key cache.
#        If not, a '-' is used instead.
# # PROTECTION describes the key protection type:
#     'P' - The key is protected with a passphrase,
#     'C' - The key is not protected,
#     '-' - Unknown protection.
# # FPR returns the formatted ssh-style fingerprint of the key.  It is only
#     printed if the option --ssh-fpr has been used.  It defaults to '-'.
# # TTL is the TTL in seconds for that key or '-' if n/a.
# # FLAGS is a word consisting of one-letter flags:
#       'D' - The key has been disabled,
#       'S' - The key is listed in sshcontrol (requires --with-ssh),
#       'c' - Use of the key needs to be confirmed,
#       '-' - No flags given.
# # More information may be added in the future.
S KEYINFO ECBEA361DD2230F79F086E3CAE198EB94A0CE6CF D - - - P 69:22:fd:08:4e:a5:77:c5:2c:1c:c5:e4:e3:e0:96:96 - S
S KEYINFO 64711FCE432F5387CCDD5E466513387B63096989 D - - - P c1:34:c6:23:f7:d5:64:fb:49:7a:d3:53:db:d1:87:64 - S
--8<---------------cut here---------------end--------------->8---
ssh-add was used to export the first key in the agent to a file.
ssh-keygen can produce an MD5 fingerprint for that file for you.
You can match the MD5 fingerprint to the 7th field of KEYINFO. Then the
1st field will give you the keygrip of that SSH key.
If your auth keys are for some reason not in sshcontrol, you could use
--8<---------------cut here---------------start------------->8---
$ gpg-connect-agent 'KEYINFO --list --ssh-fpr' /bye | fgrep 69:22:fd:08:4e:a5:77:c5:2c:1c:c5:e4:e3:e0:96:96
S KEYINFO ECBEA361DD2230F79F086E3CAE198EB94A0CE6CF D - - - P 69:22:fd:08:4e:a5:77:c5:2c:1c:c5:e4:e3:e0:96:96 - -
--8<---------------cut here---------------end--------------->8---
because it wouldn't be much fun wading through all your keys if you have
a lot of key material, and that command without the grep will list it all.
(By the way, as you can see in the ssh-keygen output, my key actually
has a comment field in the gpg-agent. It was imported from an on-disk
OpenSSH file, that's where it came from. I don't know a way to have a
comment field for a key generated with gpg, although I could probably
hack it in in the private key store. Let's not do that.)
PS: I see no reason why you shouldn't have multiple auth subkeys, unlike
John Doe.

@_date: 2019-03-16 11:39:49
@_author: Peter Lebbing 
@_subject: Identifying one of multiple authentication subkeys 
Actually, if you want a specific subkey, you need to append a ! to the
key ID (probably need to quote it as well for the shell, \! ).
Otherwise, GnuPG will use key selection rules to take the latest
authentication subkey from the certificate selected.
It's a fine and simple method. The advantage of my method is it will
also work with keys that aren't part of an OpenPGP key :-). Plus it's
more fun.

@_date: 2019-03-16 14:42:49
@_author: Peter Lebbing 
@_subject: Identifying one of multiple authentication subkeys 
Yes, but it is only added by the --export-ssh-key command and has a
fixed form. Instead, for my keys, which by the way are not part of an
OpenPGP certificate and therefore can't be used with --export-ssh-key,
they are stored with the private key. The comment got there because they
were originally OpenSSH keys with that comment, and the comment got
retained on import into the agent. I could have put any comment
whatsoever in it and it would have been stored by the agent and shown on
any invocation of ssh-add -{l,L}.
--8<---------------cut here---------------start------------->8---
$ ssh-add -l
256 SHA256:xb01Ehdlix7o5oLN0YUEkhr70yZDXXCNXcMoNS48PB0 Just a comment (ED25519)
--8<---------------cut here---------------end--------------->8---

@_date: 2019-03-17 13:12:29
@_author: Peter Lebbing 
@_subject: Identifying one of multiple authentication subkeys 
Ooohhh. I would have hoped the OpenSSH server's MaxAuthTries would only
count failed signatures, not failed key matches. But I can reproduce
this problem.
Picking an auth key is a two-step process. First the client offers
different public keys until the server says it accepts one. Only then is
authentication tried with the key that was just negotiated. But indeed,
MaxAuthTries counts every *offer* as an auth try and cuts out after 6 in
the default configuration.
--8<---------------cut here---------------start------------->8---
$ ssh -v [...]
debug1: Next authentication method: publickey
debug1: Offering ED25519 public key: /home/peter/.ssh/id_ed25519
debug1: Authentications that can continue: publickey
debug1: Offering RSA public key: /home/peter/.ssh/id_rsa
debug1: Authentications that can continue: publickey
debug1: Offering ED25519 public key: Just a comment
debug1: Authentications that can continue: publickey
debug1: Offering ED25519 public key: Testkey 1
debug1: Authentications that can continue: publickey
debug1: Offering ED25519 public key: Testkey 2
debug1: Authentications that can continue: publickey
debug1: Offering ED25519 public key: Testkey 3
Received disconnect from ::1 port 22:2: Too many authentication failures
Authentication failed.
--8<---------------cut here---------------end--------------->8---
I don't know a satisfactory solution to this.
PS: Could you please trim your quotes when you reply on the mailing

@_date: 2019-03-17 13:40:15
@_author: Peter Lebbing 
@_subject: Identifying one of multiple authentication subkeys 
30% wrong? It actually is "the wire encoding of the public key", so key
material rather than a filename. Your comment made a click in my mind
though. I've solved it.
Put this in .ssh/config:
--8<---------------cut here---------------start------------->8---
Host your-server.com
IdentitiesOnly yes
IdentityFile ~/.ssh/testkey7.pub
--8<---------------cut here---------------end--------------->8---
Where testkey7.pub is a file containing the *public* key. Usually you
would use a private key here, but OpenSSH is just as happy with a public
key as long as the agent can do the private operation.
The passphrase is cached. The duration can be controlled through
default-cache-ttl-ssh and max-cache-ttl-ssh in ~/.gnupg/gpg-agent.conf
or on a per-key basis in sshcontrol. It is possible to turn off caching
for SSH keys completely. See "man gpg-agent".
Hehehe :-D

@_date: 2019-03-23 16:19:32
@_author: Peter Lebbing 
@_subject: Identifying one of multiple authentication subkeys 
If your OpenSSH private key is .ssh/id_ed25519, and you are running
gpg-agent as your SSH agent, it's a matter of:
$ ssh-add ~/.ssh/id_ed25519
Any comment on the private key that was already there (presumably
through ssh-keygen's -C option) will be saved in private-keys-v1.d.
I don't use monkeysphere, I just maintain all authorized_keys files by
hand. While I do have files with the public keys, often I'll just use
ssh-add -L to get the public key I need to put in there.
The point where stuff gets interesting is deleting SSH keys. For that I
would use the method I outlined in this thread to get at the keygrip,
because ssh-add -d doesn't work with gpg-agent. Well, not with the
version in Debian stretch anyway, I reserve the right to be ignorant
about features added since then.
I don't care enough to open a feature request. The development team's
time is limited after all.

@_date: 2019-03-25 16:02:14
@_author: Peter Lebbing 
@_subject: Identifying one of multiple authentication subkeys 
It might also be "slightly annoying" to remove key material which is
also in use for other purposes :-). You remove an SSH key, and suddenly
an OpenPGP subkey is also missing...
But something more user friendly to match SSH fingerprint and keygrip
could be beneficial. I'm not sure what that would look like and neither
do I think it is high on the priority list.
For one thing, OpenSSH seems to prefer SHA256 SSH fingerprints over the
old MD5 ones now.

@_date: 2019-03-26 11:49:33
@_author: Peter Lebbing 
@_subject: Identifying one of multiple authentication subkeys 
Right, yes, the comment lines in sshcontrol are also really helpful for
keys in sshcontrol.
I should have been more explicit about my weird edge case.
I use OpenPGP cards with a key in the authentication slot which is not
part of any OpenPGP certificate, and is not in sshcontrol. gpg-agent is
fine with this: if I have the card inserted, it will be offered as an
authentication key to SSH servers. If I don't have the card inserted, it
is not offered. This in contrast to the case where you were to add it to
sshcontrol: then it would /ask/ for the card to be inserted if the
server accepts the key. If it is not in sshcontrol, it will not be
offered for SSH authentication.
In this particular case, it is actually very easy to pick the correct
SSH public key, because gpg-agent will add the comment "cardno:XXX",
where XXX is the serial number of the card, to the public key when you
do ssh-add -l or -L.
It is more difficult to find the keygrip, though. While participating in
this thread, I worked from the assumption that the key, for whatever
reason, was not in sshcontrol, to catch edge cases such as this. I don't
know whether there are other edge cases than this specific one where SSH
keys are not in sshcontrol, though. This might be the only one.
The use case I considered is this: I have a card I use on two PC's, but
one of the PC's also has an on-disk SSH key. Some SSH accounts will only
accept the card for authentication, but there are accounts which accept
either key. If I'm on the machine with the on-disk key and my card is
not inserted, it will pick the on-disk key. If I'm on the PC without
the on-disk key, I cannot log in to that account without inserting the
If the card were in sshcontrol, and it were offered before the on-disk
key, I would be prompted to insert the card. But this would be
unnecessary, since I have an on-disk key that will do the job just as
But I have to say I no longer actually use this scenario :-). I did in
the past, though.
What would actually help in this use case, might be to have
--card-status accept a --with-keygrip option. Then you have the
"cardno:XXX" comment in ssh-add to pick the public key or its
fingerprint, and --card-status to find the keygrip.
Yes, I totally agree. And when matching stuff together like we do in
this thread, we don't actually use any cryptographic properties of the
fingerprint, there is no adversary. So MD5 might be easier on the eyes,
but it has the disadvantage that the user needs to be /aware/ that they
can get the same fingerprint format from ssh-keygen, ssh-add and
gpg-agent.  If they just see one format here and another there, they
might very well not realise they can be made to match.
So I'm inclined to think the default should be to output it in the same
format in both tools.
Plus, when it's purely for identification purposes, you can skip reading
more letters of the base64 encoding once you've identified the right
Neat! Thanks!
Sorry for the long mail. I didn't see a lot of opportunity to shorten it
without losing clarity. If I were to introduce a misunderstanding, it
will only take even more time to sort out.

@_date: 2019-03-26 12:29:11
@_author: Peter Lebbing 
@_subject: Please start a new thread 
Please start a new thread with your question, it is something completely
different than the thread you replied to.

@_date: 2019-03-26 12:51:20
@_author: Peter Lebbing 
@_subject: Please start a new thread 
Hi Shweta,
Start a new e-mail (rather than replying to one), and address it to
. That will start a new thread.
Oh, I forgot this the previous time, but some mailing list members
might appreciate it if you send a plain-text e-mail rather than one that
has plain text as well as HTML content. If you don't know how to, I
think it is acceptable to send them as you do now (not entirely sure
about how strict that policy is).

@_date: 2019-05-06 11:19:35
@_author: Peter Lebbing 
@_subject: ProtonMail and Anonymity 
Hello Stephan,
Something completely different.
What is that link with the binary data in your OP?
I did not click it because I don't know what binary data I'd be handing
to that site. But I see this text on the front page of that site:
I get the ugly feeling this is a referral link. That every time someone
clicks that link of yours, or perhaps only after they use some
functionality there, you get a "referral bonus".
If this is a referral link, I would consider that *extremely* bad form
of you. Made all the worse by you not explaining immediately that it
Could you please explain what the purpose of the data is? (Even with a
good explanation, I'd consider it basic hygiene to never click such
links, since the explanation cannot be verified).

@_date: 2019-05-06 15:30:13
@_author: Peter Lebbing 
@_subject: ProtonMail and Anonymity 
I think it's a worthwhile thing to point out that they state "because
hash functions are one-way functions, it is impossible to derive your
phone number [...]" without reservations, but that this is a false sense
of security. It is a very limited part of the complete picture, which is
that a Dutch mobile phone number has only 8 varying digits, meaning an
entropy of less than 27 bits, cryptographically laughable. And that an
adversary might not even be interested in reversing the hash at all, but
just to verify that the phone number of their target has been used to
set up a ProtonMail account.
With passphrase hashing, the passphrase should be secret. There's
nothing secret about a phone number or e-mail address. That completely
changes the picture.
For me, it's not so much that I question their methods, it's that I
question their claims. Blanketly stating "it is impossible to derive
your phone number" sounds like security theater to me, and they should
be aware of that if they are the least bit competent. That doesn't sit
I don't expect most of their clients to see through this theater. It is
their job to be open and honest about the consequences of their methods,
so their clients can make an informed choice whether they will go
through with it or not.
My 2 cents,

@_date: 2019-05-06 19:46:58
@_author: Peter Lebbing 
@_subject: ProtonMail and Anonymity 
The only purpose of that would be to specifically subvert the intentions
and processes of ProtonMail. They have designed a system which chooses
policy based on the source IP (including a different policy for Tor exit
nodes), and you try to subvert this policy selection, and possibly give
a route for spammers to register on the system.
If you don't like their policies, don't use them. Don't try to work
around the policies they impose on the use of their service. You don't
have a right to the use of their services under your conditions.

@_date: 2019-11-03 10:15:49
@_author: Peter Lebbing 
@_subject: How to decrypt a message while preserving the signature? 
Werner recently mentioned an undocumented command for this.[1]
 [1]

@_date: 2019-09-01 15:18:36
@_author: Peter Lebbing 
@_subject: ProtonMail and Anonymity 
Hello Stefan,
If you post URL's to this mailing list, could you please provide a short
description of what can be found at the URL? This prevents the situation
that people should visit the URL to know if they want to visit the URL,
and helps a lot when searching the archives.
In this case, since it's a scientific paper, I think the following would
be a good way to share it (I used the BibTeX citation to quickly get all
the relevant fields). But at least include a short description, please.
A scientific paper by Nadim Kobeissi published in 2018 in the Cryptology
ePrint Archive, titled "An Analysis of the ProtonMail Cryptographic
ProtonMail is an online email service that claims to offer end-to-end
encryption such that "even [ProtonMail] cannot read and decrypt [user]
emails." The service, based in Switzerland, offers email access via
webmail and smartphone applications to over five million users as of
November 2018. In this work, we provide the first independent analysis
of ProtonMail's cryptographic architecture. We find that for the
majority of ProtonMail users, no end-to-end encryption guarantees have
ever been provided by the ProtonMail service and that the
"Zero-Knowledge Password Proofs" are negated by the service itself. We
also find and document weaknesses in ProtonMail's "Encrypt-to-Outside"
feature. We justify our findings against well-defined security goals and
conclude with recommendations.

@_date: 2019-09-17 19:16:06
@_author: Peter Lebbing 
@_subject: Smartcard operation 
OpenPGP messages encrypted to a public key are hybrid encryption: the
asymmetric (public/private) crypto is used to establish a per-message
shared secret. This shared secret is used by a symmetric encryption
algorithm to encrypt the actual data.
The smartcard does the asymmetric part of it all by itself, the computer
just asks it to decrypt something and gets the per-message shared secret
back from the card.
Then the PC will do the symmetric decryption of the actual data.
During regular use, knowledge about the private key contents never
leaves the smartcard, not for the briefest period.

@_date: 2020-04-21 18:30:19
@_author: Peter Lebbing 
@_subject: Making a subkey a standalone Master key 
Another idea would be to deliberately destroy the encrypted primary key
material you upload to ProtonMail. I'd suggest setting the capabilities
of the primary key to just Certify, not Sign. It could very well be that
ProtonMail never tries to decrypt the encrypted primary private key
then, because it is never asked to do a certification. And since you can
only tell that the encrypted material has been destroyed once you
actually try to decrypt it, it would never notice and chug on happily
oblivious it has been lied to.
Oh, to answer the original question, you're looking for
$ gpg --expert --full-gen-key
and then option (13) Existing key.

@_date: 2020-07-11 12:34:58
@_author: Peter Lebbing 
@_subject: Newbie question. 
Could you do
$ gpg --with-subkey-fingerprint --list-secret-keys
$ gpg --version
And do you get a popup asking for your passphrase or is what you post
all the interaction that you get? If that is where the problem lies,
it's good to know your operating system/distribution, your desktop
environment, and stuff like that.

@_date: 2020-07-11 20:30:10
@_author: Peter Lebbing 
@_subject: Newbie question. 
Ah yes. Those two options have no place in your gpg.conf. They are
options that you might want to specify as part of the command line on
occasion, but unless you have a very unusual setup they should not be
there. You should remove both. The pinentry-mode is probably what is
preventing you being asked for the passphrase.
I'd recommend dropping this as well.
These commented out lines are probably why the pinentry-mode line was
there in the first place. Do you know why these lines, both the
uncommented and the commented ones, are in your gpg.conf?

@_date: 2020-07-12 18:15:33
@_author: Peter Lebbing 
@_subject: Newbie question. 
Heh :-). It's just that if I reply off-list, it only helps you, but if
it is on-list, other people can find it in a search engine when they're
facing something similar.
Well, in that case, you should supply --no-batch when you're using it
interactively; I'll show why further down.
My personal choice would be to have my scripts and programs supply the
--batch on invocation rather than put it in the config file, because you
only need to write that command invocation in the script once (as you're
writing the script), whereas you'll be writing the --no-batch every time
you /do/ use it from an interactive shell.
You only need the --expert on commands creating or adding keys for that.
Once you have the key, you no longer need --expert to just use it.
I think the combination that worked might have been
--8<---------------cut here---------------start------------->8---
pinentry-mode loopback
passphrase-file /home/ayoub/.gnupg/output.png
--8<---------------cut here---------------end--------------->8---
but once you commented out the passphrase-file entry, GnuPG had no way
to get the passphrase. Normally you should use the pinentry (so comment
out the pinentry-mode line as well), but you force it to use the
loopback pinentry-mode. gpg _could_ ask for your passphrase that way.
But, you also specify --batch. --batch tells GnuPG that the human is
currently unavailable and it needn't bother trying to interact with it.
So it has no way to get the passphrase and gives up.
It will ask you for the passphrase when you comment out --batch, but I
recommend also commenting out the --pinentry-mode line so it'll just
launch a pinentry like it wants to do.
Now about this configuration:
--8<---------------cut here---------------start------------->8---
pinentry-mode loopback
passphrase-file /home/ayoub/.gnupg/output.png
--8<---------------cut here---------------end--------------->8---
If this file is stored with the same access conditions as
~/.gnupg/private-keys-v1.d/, it serves no good purpose. You should then
just use a key without a passphrase. With a key without a passphrase, an
attacker would just need the file
and they're good to go. With your passphrase-file, they need two files:
and once again they're good to go, they have your private key. Why would
it be more difficult to get a hold of two files rather than one? Just
drop the passphrase, and all your problems magically disappear :-).
But given its name, I suppose output.png is generated by some unlocking
process. Suppose you did it like this before:
$ my-unlocker >~/.gnupg/output.png
You can actually unlock keys the way GnuPG intends to do that with:
$ my-unlocker | /usr/lib/gnupg/gpg-preset-passphrase --preset You can find the keygrip for your keys with:
$ gpg --with-keygrip --list-secret-keys You do need it for every subkey you want to use like this separately,
and also, it does not verify whether the passphrase was correct. Also,
max-cache-ttl in ~/.gnupg/gpg-agent.conf
and issue
$ gpgconf --kill gpg-agent
to reload.  is how long you want the passphrase to stay
available after gpg-preset-passphrase, and it defaults to a mere 2
hours. You could set it to 4294967295 to specify a lifetime of 136
years, i.e., infinitely for all practical purposes.
Watch out that my-unlocker doesn't leak the passphrase in any way. I
thought it was unhelfpul that you can't use the pinentry with
gpg-preset-passphrase and I proposed a hack more than two years ago:
It's pretty hacky, but it does seem to work.
You could actually just unlock your key by using it once when you start
up your system, and then use the caching feature to keep it available
for non-interactive use for the rest of the time. Then you don't use
gpg-preset-passphrase, but put, e.g., this in your gpg-agent.conf
default-cache-ttl 4294967295
max-cache-ttl 4294967295
and unlock your key by doing one decryption:
$ echo Open Sesame | gpg -r develop1 -e | gpg -d
This will pop up a pinentry for your passphrase, and since you set the
cache-ttl to infinity, it will never popup a pinentry again on
decryptions until you restart gpg-agent. It's a pretty good workflow
that uses all parts as they were intended.

@_date: 2020-07-26 11:48:21
@_author: Peter Lebbing 
@_subject: Newbie question. 
No, I think the available documentation is lacking in quality. And
on the other hand there's a lot of bad advice on websites. It's an
unfortunate situation, but few people enjoy writing good documentation.
It is a very laborious process.
Sorry I can't be of better assistance.

@_date: 2020-07-26 11:49:58
@_author: Peter Lebbing 
@_subject: Why is there no secret key? 
Are your gpg.conf and gpg-agent.conf (or let's just say any .conf-file
in your GnuPG home, ~/.gnupg) empty? Do you get a pinentry popup asking
for a passphrase?

@_date: 2020-07-27 10:17:40
@_author: Peter Lebbing 
@_subject: Deleting or renaming $HOME/.gnugpg 
Yes, as long as you also kill the daemons so they restart with the new
$ gpgconf --kill all

@_date: 2020-07-27 11:39:00
@_author: Peter Lebbing 
@_subject: Why is there no secret key? 
Which, by the way, is documented well in the man page gpg-agent(1):
       --batch
              Don't  invoke  a  pinentry or do any other thing requiring human
              interaction

@_date: 2020-07-27 21:13:32
@_author: Peter Lebbing 
@_subject: Why is there no secret key? 
But that only passes --no-batch to gpg, not to gpg-agent. Werner said
you shouldn't put these options in your .conf-files. Please just include
--batch on the command line with the actual batch commands.
--pinentry-mode is a gpg option, not a gpg-agent option. The
loopback-related option to gpg-agent is --allow-loopback-pinentry.
Please just include --batch (I assume you mistyped when you wrote
--no-batch) on the command line with the actual batch commands.
Not sure what you mean by through the API.

@_date: 2020-07-30 12:52:28
@_author: Peter Lebbing 
@_subject: Why is there no secret key? 
It seems to me that including options in gpg.conf that GPGME does not
expect people to put there might throw it out of whack.
Precisely when you do unattended operation should you have it on the
command line. And it should not be in your gpg.conf.
Why do you say "_even_ in unattended operation"?
No, it makes more sense to specify this on the command line in the
instances you actually need this. However, I explained two methods[1] of
seeding the passphrase, neither of which uses --pinentry-mode.
--pinentry-mode is a great way to shoot oneself in the foot
It's already the default, if you want to disallow it you would specify
Please see the man page.
I don't really understand the question.
Usually, you only specify command line parameters to gpg. gpg might
launch a gpg-agent, or connect to an already running instance. There
are gpg command line parameters that influence the command line used to
launch gpg-agent, but in general, gpg's parameters do not propagate to
They each have their own set of parameters, documented in the man pages
gpg(1) and gpg-agent(1) respectively. GnuPG consists of more binaries,
but those two are the major ones.
[1]

@_date: 2020-06-29 20:03:54
@_author: Peter Lebbing 
@_subject: decrypt aes256 encrypted file without gpg-agent 
You could try installing sequioa-pgp[1], an alternative but also libre
OpenPGP implementation (still in its infancy). It requires a Rust build
environment to compile.
Or just bite the bullet and install gpg-agent. If you also need
unattended decryption, there are ways to programmatically pass the
passphrase to it. Although many people make security theater of their
unattended decryption methods, it requires thought to design unattended
decryption that isn't trivial to bypass once the attacker has read
access to storage, or perhaps some other form of access that is
definitely within scope of your threat model.
[1]

@_date: 2020-05-24 18:03:34
@_author: Peter Lebbing 
@_subject: Backup of Keys 
Absolutely not ;-)
Note, however, that the first of these two is interactive in that it
asks for your passphrase(s). This is because it needs to be re-encrypted
because the storage format is different.
So you could do the first one manually every time you add (or remove)
private keys or change a passphrase. Anything else, including changing
key preferences, key expiry, etcetera, is equally reflected in
public-keys.gpg from the second line. The second can be done regularly and automatically.
Do back up other stuff from that directory as well. It's important,
non-public data: your ownertrust declarations, TOFU bindings and
You might want to omit the file random_seed. I forgot how important this
is these days. I believe it has gotten less important at some time.
But using Sherpa is probably a good bet.

@_date: 2020-05-24 18:16:39
@_author: Peter Lebbing 
@_subject: Backup of Keys 
The safety of the private key purely depends on the strength of the
passphrase. Note that backups will have the passphrase that was set when
the backup was _made_. Changing the passphrase on your computer will not
change the passphrase in any older backups.
But there is more data in your GnuPG homedir that is not encrypted but
is privacy-sensitive. If you ever assign someone ownertrust, that will
be reflected there. It indicates how much you trust people to correctly
verify other people's identities and how well you trust them to keep
their private key private. Your brother-in-law might be offended by you
assigning him "NEVER TRUST", and your partner might not appreciate you
apparently having somewhat recently assigned positive trust to that ex
you swore you never saw anymore.
And then there is the history data for TOFU, which exposes some data
about when you verified signatures by other people or when you encrypted
something to someone. This data is there to help you analyse
trustworthiness about the third party in question when so prompted, but
it is also communication metadata about you.
These pieces of data might not exist for your particular configuration,
but they can exist.
I think the definition of a good passphrase is that it is infeasible to
crack it. That makes it circular reasoning.
A well-executed "Correct Horse Battery Staple" passphrase or a long
enough diceware passphrase cannot be cracked. The problem is determining
whether you did it right or are misunderstanding some vital detail of
creating a good passphrase.
For instance, actually choosing "Correct Horse Battery Staple" is about
the worst thing you can do... :-)

@_date: 2020-05-24 18:28:09
@_author: Peter Lebbing 
@_subject: Backup of Keys 
Oh! That is perhaps not good enough :-). You need
$ gpg --export-options export-local-sigs -o public-keys.gpg --export
so you don't lose any non-exportable signatures. There's also
--export-options backup, which implies export-local-sigs. I just tested
that because I did not know. So I think for backup purposes this is the
$ gpg --export-options backup -o public-keys.gpg --export
Check the manual for more --export-options.

@_date: 2020-05-24 19:23:54
@_author: Peter Lebbing 
@_subject: Backup of Keys 
Just watch out for the catch-22 of "I lost my hard drive, let me restore
from that encrypted container. Hmmm, my only backup of my private key is
inside a container encrypted to that private key..."

@_date: 2020-05-25 09:36:17
@_author: Peter Lebbing 
@_subject: Backup of Keys 
I am very wary of biometrics for authentication purposes. There are so
many examples where the vendor assured us it was working really well,
and researchers easily cracked the system by using a photo, or
photocopied fingerprints they lifted off a glass or even more funny from
the fingerprint reader itself.
That's for authentication, where only non-reproducability is vital. For
encryption, it's much worse, because you need a lot of entropy for that
to ward off offline attacks. And biometrics just doesn't have that much
And both share that there is no recovery from compromise. If somebody
learns your passphrase, you change it, tracking down all backups and
changing them as well. That might be a little painful.
If somebody manages to copy your biometrics, you can't change them. You
could erase your fingerprints by taking a job processing pineapples on a
daily basis. And you could get plastic surgery for your face, but that
really puts the painful in "it's so painful to change your passphrase

@_date: 2020-05-25 10:01:44
@_author: Peter Lebbing 
@_subject: Biometrics 
How is that an advantage compared to passphrases? As soon as someone
threatens to go all XKCD 538 on you[1], just give them your passphrase.
No need to lend them your finger, either with or without you still
If this is your threat model, you need more than encryption or
... unless your whole comment was as serious as my comment about plastic
surgery of course :-) ...
More seriously, biometrics might be a nice deterrant to the casual
opportunistic curious peeker. It's quick, a finger swipe takes less time
and effort than a good passphrase. But it's not proper security in my
[1]

@_date: 2020-05-28 10:26:48
@_author: Peter Lebbing 
@_subject: gpgsplit/pgpdump replacement 
What about solving your entire use-case with an explicit two-step
There's an encrypted, signed OpenPGP file with just a cryptographically
secure random number. It is signed by a per-source signing key and
encrypted to the secure machine.
There's another file with symmetrically encrypted data using the tool of
preference (could be GnuPG with --symmetric encryption) which actually
contains the bulk of the data. The "passphrase" or encryption key is the
cryptographically secure random number from the OpenPGP file.
So every time you would now create a public-key encrypted file with the
historic data, you explicitly generate a fresh "session key". You
encrypt the data symmetrically with that key, and also public-key
encrypt and sign that "session key".
When you need to recover the historic data, the device sends only all
the public-key encrypted "session keys" to the secure machine. That
checks all these are signed by the device in the field, and if so,
returns all "session keys".
It's basically a duplication of the OpenPGP session key, and indeed,
internally you are using a session key to encrypt a "session key". So it
needs twice the randomness, which might be a problem on embedded
systems. But it prevents needing packet surgery and inspection, instead
just using default mechanisms.

@_date: 2020-05-31 11:07:53
@_author: Peter Lebbing 
@_subject: Exchange between muiltiple OpenPGP implementations 
Does the new TB implementation support TOFU? If so, you lose your TOFU
historical data and identity assertions when you would export/import to
a different OpenPGP implementation. That'd be a shame. Maybe there's a
need for a standardised interchange format for that.
