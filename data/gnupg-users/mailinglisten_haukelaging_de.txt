
@_date: 2010-04-08 02:31:33
@_author: Hauke Laging 
@_subject: secret keys are not imported 
I have tried to copy my new secret subkeys to another system. Though no error message appears this does not work:
# gpg hauke__0xECCB5814.sec.asc
sec  1024D/ECCB5814 2005-09-05 Hauke Laging uid                            Hauke Laging uid                            Hauke Laging ssb  2048g/E623EF88 2005-09-05
ssb  2048R/51B279FA 2010-03-04
ssb  2048R/3A403251 2010-03-04
That looks good to me.
# LC_ALL=C gpg --import hauke__0xECCB5814.sec.asc
gpg: key ECCB5814: already in secret keyring
gpg: Total number processed: 1
gpg:       secret keys read: 1
gpg:  secret keys unchanged: 1
This does not.
I do have the public keys (from an earlier import):
# gpg --list-keys eccb5814
pub   1024D/ECCB5814 2005-09-05
uid                  Hauke Laging uid                  Hauke Laging uid                  Hauke Laging sub   2048R/51B279FA 2010-03-04 [verf?llt: 2013-03-03]
sub   2048R/3A403251 2010-03-04 [verf?llt: 2013-03-03]
sub   2048R/2282921E 2010-03-08 [verf?llt: 2013-03-07]
But not the secret ones (except for those which were there before already):
# gpg --list-secret-keys eccb5814
sec   1024D/ECCB5814 2005-09-05
uid                  Hauke Laging uid                  Hauke Laging uid                  Hauke Laging ssb   2048g/E623EF88 2005-09-05 [verf?llt: 2010-04-03]
# gpg --version
gpg (GnuPG) 2.0.15
libgcrypt 1.4.4
Thus trying to decrypt a file fails though the smartcard with the keys can be read (so in fact there are two problems):
# LC_ALL=C gpg testfile.tar.bz2.gpg
gpg: encrypted with 2048-bit RSA key, ID 51B279FA, created 2010-03-04
      "Hauke Laging "
gpg: decryption failed: No secret key
# gpg --card-status
Encryption key....: F831 934A CD0D 5092 D1FC  53E9 8E3D D37A 51B2 79FA
      created ....: 2010-03-04 02:13:27

@_date: 2010-04-08 12:28:38
@_author: Hauke Laging 
@_subject: secret keys are not imported 
Am Donnerstag 08 April 2010 12:03:09 schrieb Werner Koch:
OK... I did this:
# gpg --delete-secret-key ECCB5814
# LC_ALL=C gpg --list-secret-keys eccb5814
gpg: error reading key: No secret key
And then I tried to import again:
# LC_ALL=C gpg --import hauke__0xECCB5814.sec.asc
gpg: key ECCB5814: secret key imported
gpg: key ECCB5814: "Hauke Laging " not changed
gpg: Total number processed: 1
gpg:              unchanged: 1
gpg:       secret keys read: 1
gpg:   secret keys imported: 1
This works:
# LC_ALL=C gpg --list-secret-keys eccb5814
sec   1024D/ECCB5814 2005-09-05
uid                  Hauke Laging uid                  Hauke Laging uid                  Hauke Laging ssb   2048R/51B279FA 2010-03-04 [expires: 2013-03-03]
ssb   2048R/3A403251 2010-03-04 [expires: 2013-03-03]
ssb   2048g/E623EF88 2005-09-05 [expires: 2010-04-03]
But why does the import command say 1 everywhere though obviously not one but three subkeys have been read and imported?

@_date: 2010-04-08 19:19:03
@_author: Hauke Laging 
@_subject: secret keys are not imported 
Am Donnerstag 08 April 2010 12:03:09 schrieb Werner Koch:
I had one (ElG) subkey before I started using a smartcard. Is it impossible to combine the old secret subkey and the smartcard keys?
It seems so to me. I have to delete the secret keys in order to make gpg use the smartcard. But after that I cannot import the old subkey andy more.
I should be able to use it by using seperate key rings though.

@_date: 2010-08-01 11:34:29
@_author: Hauke Laging 
@_subject: Importing/Merging (secret) subkey into existing secret key 
Am Sonntag 01 August 2010 09:17:41 schrieb Aaron Whitehouse:
That won't change anything. I had a similar problem, filed a bug report, and was told that this was an architecture problem in 2.0.x. The key handling will be changed in 2.1 which will solve this kind of problem. But for 2.0.x this will not be changed.

@_date: 2010-08-06 19:46:37
@_author: Hauke Laging 
@_subject: Message was not integrity protected. 
Am Freitag 06 August 2010 19:26:04 schrieb Wolff, Alex:
What is your problem, that there is no valid signature or just the warning The signature is not damaged. No signature has been created at all. If there was a non-valid signature the error message (instead of a warning) would look like this:
"gpg: decryption failed: Bad signature"

@_date: 2010-08-11 13:33:49
@_author: Hauke Laging 
@_subject: no-ks-modify effect on signature uploads 
a few weeks ago we had a discussion about the no-ks-modify flag (being not reliably supported by the keyservers yet).
It certainly makes a difference whether you can accidentally ignore this flag or have to ignore it intentionally. This raises the question (I admit I was too lazy to test that myself) whether gpg ignores this flag. Does gpg upload signatures for other people's key which have this flag? The keyservers don't do crypto checks but gpg could, of course. IMHO it would make sense for gpg to reject uploads in these cases.

@_date: 2010-08-11 17:52:50
@_author: Hauke Laging 
@_subject: no-ks-modify effect on signature uploads 
Am Mittwoch 11 August 2010 16:11:24 schrieb David Shaw:
Maybe but the number of people using both (with the same keys!) is probably not so high. And it would be obvious to anyone that this behaviour is due to an improvement in gpg. Avoid big number improvement in order to avoid small number confusion? A weak argument, even more as gpg is not strictly compatible to (all versions of) PGP (simultaneously) anyway.
gpg should issue an error message to inform the user.
When doing this with such a key then a warning should be issued. This would have the additional positive effect of making users aware of the privacy problem over time.
No, not an illusion of functionality, maybe an illusion of protection. The problem would not be solved but reduced. The illusion could be prevented by putting the relevant information into both the documentation and error/warning messages. Having such an illusion would be the fault of noone but the respective user himself. And there is no reason that there is noone out there who has this illusion even today. :-)

@_date: 2010-08-13 03:13:01
@_author: Hauke Laging 
@_subject: no-ks-modify effect on signature uploads 
Am Mittwoch 11 August 2010 22:11:06 schrieb David Shaw:
In my opinion that is a strange definition of noise.
If we agree that this is a useful default (the flag set) and that it would be great if the keyservers honoured it then the wished for future is that most people cannot upload signatures for keys which are not their own.
I would regard such gpg behaviour as a kind if information/education for this probable future (earlier or later). So people would start to change their view of the infrastructure and the way the use the toole before they are completely forced to do so (by the servers).
That is a valid argument but the combination of a feature and its documentation is not necessarily pretending of something. If the warning and documentation clearly state that this is a convenience feature and not a crypto level protection then it is not illusion if anyone gets that wrong. You are in big problems nearly at once of you use crypto software without having understood how all this stuff works. This would be just one more point, a rather harmless one. And you would be forced to ignore clear hints in order to make mistakes. That's nothing anyone has to (or even: can) be protected from.

@_date: 2010-08-26 00:09:49
@_author: Hauke Laging 
@_subject: Modified user ids and key servers and a possible security risk? 
Am Mittwoch 25 August 2010 20:37:08 schrieb Daniel Kahn Gillmor:
And in contrast to TLS this CPU load can be postponed without serious consequences. If the load is high then new signatures could simply be added and checked later. Only "strange" updates (e.g. many signatures for the same key) would be checked at once in order to prevent such a postponing feature to be easily abused.
To be on the safe side the keyserver could also prevent not yet checked information from being publicly available. So it might take a few hours until a key update is visible. Usually not a problem.
If such administrative decisions are possible then I would like the keyserver to inform the client (in a signed way...) about its policy.

@_date: 2010-08-26 02:13:50
@_author: Hauke Laging 
@_subject: Modified user ids and key servers and a possible security risk? 
Am Donnerstag 26 August 2010 01:45:07 schrieb Chris Knadle:
That's not a problem. You cannot require a server to make this decision immediately. The server can tell you that this decision is postponed and for how long it well be at most. The client can decide then to make a query at that time or later to check if the requested update has been made.
This way the information what kind the error was of is lost, though. But if you like to make it more complicated then the keyserver could log failed updates and their check result so in case of error (no update visible to the client after the given check period) the client would upload the same data again and then the server could respond with the error information without causing CPU load.

@_date: 2010-08-31 13:37:51
@_author: Hauke Laging 
@_subject: Encryption with no recipient 
Am Dienstag 31 August 2010 11:43:06 schrieb Ted Rolle Jr.:
gpg --symmetric file

@_date: 2010-12-02 01:23:46
@_author: Hauke Laging 
@_subject: GPF Crypto Stick vs OpenPGP Card 
Am Donnerstag 02 Dezember 2010 01:05:19 schrieb ?ukasz Stelmach:
Depends on the number of smartcards you intend to use and on whether you want a PIN pad. The Crypto stick is easier to transport but if it is used with other PCs than yours then the PIN pad becomes even more interesting.
But that's probably one without PIN pad, isn't it?

@_date: 2010-12-03 13:21:20
@_author: Hauke Laging 
@_subject: GPF Crypto Stick vs OpenPGP Card 
Am Freitag 03 Dezember 2010 09:47:27 schrieb Nils Faerber:
A first improvement would be to show the hash to be signed. Of course, you cannot trust the hash calculation on a potentially compromised PC but this would be a start for further protection (e.g. by sending the file to someone else and comparing the hashes).
If I understand the process correctly then not the file hash is signed but the hash for a combination of the file hash and some metadata (timestamp, signer ID). For a security progress the card reader would have to see both hash components which would require a protocol change. IMHO it makes sense to plan this for the future. Ask the card reader whether it has a display and can do the hash calculation itself. If so then send the data in a new format.

@_date: 2010-12-04 02:37:47
@_author: Hauke Laging 
@_subject: GPF Crypto Stick vs OpenPGP Card 
Am Freitag 03 Dezember 2010 17:32:50 schrieb Werner Koch:
Of course, you cannot trust the hash calculation on a potentially compromised PC but this would be a start for further protection (e.g. by sending the file to someone else and comparing the hashes).

@_date: 2010-12-06 12:06:19
@_author: Hauke Laging 
@_subject: GPF Crypto Stick vs OpenPGP Card 
Am Freitag 03 Dezember 2010 14:55:34 schrieb Marcio B. Jr.:
As you said: ONE of the ideas. The other one is to ptotect the keys (though not completely their usage) on your more protected system. As "more protected" is still a serious risk in typical environments. Using secret keys on other systems is the more serious argument but even for keys on a single host we are not missing the point.

@_date: 2010-12-08 23:35:04
@_author: Hauke Laging 
@_subject: Protecting IDs at a key signing party 
Am Mittwoch 08 Dezember 2010 22:54:02 schrieb Robert J. Hansen:
That should not be a question of personal attitude but of the signing policy for the respective key. As there are different scenarios in real life there should be different keys or at least signing descriptions available for As reading prose policys does not scale well I would like to have a standard for that. I have mentioned that on this list before.
The very simple certification level scheme could be extended be e.g. standardized notations. There is a IETF reserved notation namespace but there aren't any IETF notations yet. I suggest a standard for at least these pieces of information:
- key owner has been personally known for x years
- frequent contact with the key owner for x years
- x family members of the key owner have been personally known for y years
- identity has been checked by looking at document of type x
- identity has been checked by electronic means (of type x)
- email address has been checked
- key is on a smartcard
- key has been created on a smartcard with no backup
- key has been created on a smartcard with a secure offline backup only
- main key has been created in a secure environment
- key is intended for usage in an unsecure environment (e.g. Webmail)
- key is intended for usage in a secure environment only
- other keys of this key owner: ... (for better trust calculations)
- key is (not) intended for signing (small / high amount) treaties
The result would be a machine readable signature policy. And you could certify any key. GnuPG could be configured how to translate this detailed data into the current three levels of checking effort.
Today you have signature policies for some keys. But what are they worth? Imagine you have a rather insecure key for spam (filter) protection and the like. This key gets compromised. The attacker can easily write a signing policy which claims this key to be a high security smartcard key and sign it. Worth nothing. Trustworthy signature policies have to be signed by the people who sign the key itself, too. This would be achieved if you had a kind of signature policy within the signature notations.
The document types should contain both general entries and national This way an important feature could be added: Signing subkeys. The impossibility to do this makes GnuPG incompatible with at least the German law for digital signatures (unless the CA would destroy the secret main key and give only the subkeys to the customer which is not the idea of GnuPG I think). The subkeys would not be signed directly but their fingerprints would become signature notations.
A bit off-topic. Sorry. :-)  But I really hope there are a few people out there who see the same need...

@_date: 2010-12-09 14:41:10
@_author: Hauke Laging 
@_subject: multiple subkeys and key transition 
Am Donnerstag 09 Dezember 2010 07:14:53 schrieb Ben McGinnes:
What is the relation between a key and the hashing algorithms?
In case of doubt choose RSA. It's the only one you can use with the g10 It chooses the newest subkey.

@_date: 2010-12-09 18:38:01
@_author: Hauke Laging 
@_subject: multiple subkeys and key transition 
Am Donnerstag 09 Dezember 2010 18:18:00 schrieb Ben McGinnes:
And this hardware is always offline with no complex applications running? There are scenarios in which controlling the hardware is enough. But they are very rare. Probably somebody with such a scenario had said something different from "based on security".

@_date: 2010-12-09 18:42:10
@_author: Hauke Laging 
@_subject: multiple subkeys and key transition 
Am Donnerstag 09 Dezember 2010 18:35:00 schrieb Robert J. Hansen:
That attitude renders a term like "decision based on security" with no further information completely useless.

@_date: 2010-12-10 01:03:58
@_author: Hauke Laging 
@_subject: GPF Crypto Stick vs OpenPGP Card 
Am Montag 06 Dezember 2010 20:21:36 schrieb Marcio B. Jr.:
Sorry, spam filter...
In general that is correct. In detail that depends on the kind of attack and the computer usage.
If the computer has a network connection with not completely secure systems then the discussion ends at that point. Disk encryption does not protect against online attacks. With regard to every normal PC a smartcard is the better solution.
You need a hardware attack in order to get keys out of a smartcard. If you can spend millions of dollars for that then it's possible.
If you have an offline PC which never runs complex software with data from outside then disk encryption can be even safer than a smartcard. If the integrity of the hardware is not an issue and only obvious attacks are an issue (stealing and siezing) then only software attacks against the disk encryption are possible which can easily be made as hard as the key itself (making an attack a waste of time, no matter how much money you throw at it).
But can you be sure that this is the only kind of attack? ;-)  It would usually be much cheaper to get access to the system and manipulate the hardware, with a hardware keylogger e.g. than to get a key out of a smartcard.

@_date: 2010-12-10 14:15:36
@_author: Hauke Laging 
@_subject: multiple subkeys and key transition 
Am Freitag 10 Dezember 2010 02:40:10 schrieb Faramir:
man gpg2
bkuptocard file
Restore  the  given  file  to a card. This command may be used to restore a backup key (as generated during card initialization) to a new card.

@_date: 2010-12-11 22:55:35
@_author: Hauke Laging 
@_subject: Add sign key only? 
Am Samstag 11 Dezember 2010 17:36:46 schrieb Chris Poole:
1) Make a backup of the public (--export) and then of all secret keys (--
2) Delete the signing subkey.
3) Change the passphrase (--edit-key ...; passwd)
4) Export the secret subkey (the one for encryption): --export-secret-subkeys
5) Delete the key and import the backup.
Now you have a file with the key you may be forced to give away. This file is passphrase protected but with a different passphrase.
Depending on the scenario it may not be neccessary to give away your private key but be enough to give away the symmetric keys for the respective files. See --show-session-key.

@_date: 2010-12-21 16:17:49
@_author: Hauke Laging 
@_subject: clearsign failed: Bad signature 
Am Dienstag 21 Dezember 2010 13:59:16 schrieb John Ruff:
It seems that I have not understood the process of signing correctly. Does the smardcard create the hash value? Does not make sense IMHO. Or is this about the length of the value to be signed?
And I have no idea how tha smartcard could be involved in checking a signature as you don't need the secret key for that.

@_date: 2010-07-05 22:03:07
@_author: Hauke Laging 
@_subject: fsfe smartcard help 
Am Montag 05 Juli 2010 19:34:44 schrieb Remy van Elst:
Yes. First you import the public(!) key then you issue the command "gpg --
After that a "gpg --list-secret-keys" should show the above lines "ssb> ..." which indicate that the secret key is on a smartcard.

@_date: 2010-07-05 22:49:18
@_author: Hauke Laging 
@_subject: fsfe smartcard help 
Am Montag 05 Juli 2010 22:25:35 schrieb Remy van Elst:
I had the same problem a few weeks ago. I suggest to improve the man page. The explanation for card status could be changed from "Show the content of the smart card." to "Show the content of the smart card. If the public key is available but the secret key is not then the secret key is marked as available on the smart card (ssb> instread of ssb)."
I am not sure about the PIN caching. If you take the smartcard out of the reader then your description is correct. But if you leave the smartcard in the reader it may be that the card can be used without entering the PIN again. AFAIK this can be prevented by a flag on the card for signatures but not for decryption and authentication.
I guess you mix up the categories "secret keys and private keys" with "main key and subkeys". Both the main key and all subkeys have both a secret and a public part. You probably have a main key which has the only capability to certify (sub)keys.
Nobody can get the secret keys from the PC because they are not stored on the PC. The only information stored there is that the secret keys reside on a smartcard. And this information is not so valuable for an attacker.
The passphrase is usable with the encrypted secret keys only. Thus somebody with knowledge of your passphrase would have to get access to your key backup, Somebody with access to the secret subkeys (however) can read your encrypted data, can login as you (in case you have an authentication key) and can sign data as you. Only the last action can be detected on a smartcard (by the signature counter).

@_date: 2010-07-14 17:31:16
@_author: Hauke Laging 
@_subject: Certification of subkeys possible? 
is it possible today (if not: how big would the chanhes to gpg or the OpenPGP standard have to be) to sign not only the main key and UIDs but also subkeys?
I just had a discussion about the advantages of OpenPGP and S/MIME. This seems to be one of the few properties of X.509 which cannot be "emulated" with gpg.
AFAIK you cannot prevent someone who generates a key on a smartcard which is to be certified by you to only use the smartcard if it is for gpg. He could create a subkey on a PC (and keep it there), certify it by the main key on the smartcard and a third party would put too much trust in your "this key certifies smartcard keys only" signature.
If it was possible to certify subkeys, too, then you would sign all keys on the smartcard and a third party could recognize a later generated subkey by the missing signature. And you could limit the capabilities by e.g. signing subkeys for authentication only.
This would combine the flexibility of OpenPGP with the possibility to create a higher level of security and trust for certain applications.

@_date: 2010-07-21 17:33:34
@_author: Hauke Laging 
@_subject: decryption failed: secret key not available 
Am Mittwoch 21 Juli 2010 17:22:28 schrieb Rahul R:
The error message isn't hard to understand, is it?
"gpg --list-secret-keys" shows you the available secret keys of your gpg configuration. You need the key with the ID 424E35F0 which is obviously Under Linux:
gpg --list-secret-keys | grep -i eccb5814
sec#  1024D/0xECCB5814 2005-09-05
This is an examply with my key. "gpg --list-secret-keys | grep -i 424E35F0" probably does not deliver any content.
You need import the secret key 424E35F0.

@_date: 2010-07-21 17:52:38
@_author: Hauke Laging 
@_subject: decryption failed: secret key not available 
Am Mittwoch 21 Juli 2010 17:37:44 schrieb Rahul R:
gpg --import secretkey.asc
It might make sense for you to use an GUI (like GPA or Kleopatra) as tasks like key import are very easy with a GUI.

@_date: 2010-07-21 18:18:12
@_author: Hauke Laging 
@_subject: decryption failed: secret key not available 
Am Mittwoch 21 Juli 2010 18:01:58 schrieb Rahul R:
You are funny... Obviously it is impossible to "generate" the secret key for a given public key. Otherwise it wouldn't make sense to call it a "secret" key if anyone with access to the public part could easily create it.
Somebody has had access to the secret key once. If you know who that is and he still has the key then you can ask him to export it for you. It that's not possible and no export file of the secret key happens to appear then you don't have any chance to decrypt messages which have been encrypted for this key

@_date: 2010-06-06 19:31:06
@_author: Hauke Laging 
@_subject: Smartcard PIN change via card reader keypad? 
I am surprised that gpg asks for the smartcard PIN via the keyboard when it is to be changed. Do I misunderstand anything? Can I make gpg use the card reader keypad for that instead? IMHO an important part of smartcard security is that the PC does NOT know the passphrase. Is there any reason why the keypad cannot be used for this?

@_date: 2010-06-07 12:48:31
@_author: Hauke Laging 
@_subject: Smartcard PIN change via card reader keypad? 
Am Montag 07 Juni 2010 08:22:07 schrieb Simon Josefsson:
I have that reader model, too. The normal card usage works. (Not without problems but I don't know whether they are software or hardware related.)
When I use the keys on the card then gpg always asks me to use the reader keypad. Do you have a special configuration so that it does this for changing the PIN, too?
This is in the log file:
gpg-agent[3472.9] DBG: -> PASSWD  1
gpg-agent[3472.9] DBG: <- INQUIRE NEEDPIN ||Bitte die PIN eingeben
2010-06-07 12:38:51 gpg-agent[3472] starting a new PIN Entry
2010-06-07 12:38:51 gpg-agent[3472] DBG: connection to PIN entry established
Usually (signing) it has this message:
gpg-agent[3284.9] DBG: <- INQUIRE POPUPKEYPADPROMPT
Bitte die PIN eingeben%0A[Sigs erzeugt: 6]
(meaning: "please enter PIN [sigs created: 6]")

@_date: 2010-06-07 21:43:23
@_author: Hauke Laging 
@_subject: What is the "list keyring content" command? 
the man page says:
"gpg2 may be run with no commands, in which case it will perform a reasonable action depending on the type of file it is given as input (an encrypted message is decrypted, a signature is verified, a file containing keys is start cmd:> gpg secondsecring.gpg
sec  1024R/0x297AB799 2010-06-02 Smartcard Test ssb  1024R/0xF64B4F0F 2010-06-02
ssb  1024R/0xF17AAD5B 2010-06-02
ssb  1024R/0xD62B6574 2010-06-02
But which command is used here? I don't find a suitable one.
start cmd:> gpg --list-keys secondsecring.gpg
gpg: error reading key: Kein ?ffentlicher Schl?ssel
I hope there is a "tell me what this is" command that does nothing else (so that it can be safely used). If it is a keyring, list the content (like now without a command), if it is an encrypted file it would be nice to know that (and the recipients' key IDs) WITHOUT gpg automatically trying to decrypt it (assuming a cached passphrase). If it is a signature tell me the ID of the signing key (and the hash of the file?) without validating the signature (maybe the signed file is unavailable).

@_date: 2010-06-08 13:19:45
@_author: Hauke Laging 
@_subject: What is the "list keyring content" command? 
Am Dienstag 08 Juni 2010 04:05:20 schrieb John Clizbe:
No, that produces a comprehensive output for a keyring and tried to decrypt, I got the answer aside the list: It is (for a secret keyring)
gpg --no-default-keyring --secret-keyring secondsecring.gpg --list-secret-keys
I noticed meanwhile that you can use file for the information what kind of gpg file something is. But without the information I mentioned. Is there enough interest in such a command? ;-)

@_date: 2010-06-08 13:25:01
@_author: Hauke Laging 
@_subject: What is the "list keyring content" command? 
Am Dienstag 08 Juni 2010 11:18:10 schrieb Benjamin Marwell:
gpg --no-default-keyring --secret-keyring secondsecring.gpg \
--fingerprint --fingerprint --list-secret-keys
(the secret key version because my only additional keyring is a scret one ;-) )

@_date: 2010-06-09 10:40:13
@_author: Hauke Laging 
@_subject: help using Encrypt 
Am Mittwoch 09 Juni 2010 04:04:54 schrieb Luc?lio Gomes de Freitas:
--list-keys doesn't tell you the key capabilities.
start cmd:> LC_ALL=C gpg --edit-key eccb5814
pub  1024D/0xECCB5814  created: 2005-09-05  expires: never       usage: SCA
                       trust: unknown       validity: full
sub  2048g/0xE623EF88  created: 2005-09-05  expired: 2010-04-03  usage: E
sub  2048R/0x51B279FA  created: 2010-03-04  expires: 2013-03-03  usage: E
sub  2048R/0x3A403251  created: 2010-03-04  expires: 2013-03-03  usage: S
sub  2048R/0x2282921E  created: 2010-03-08  expires: 2013-03-07  usage: A
Does the main key have E (encryption)? If not then you need create an encryption subkey (--edit-key ? addkey).

@_date: 2010-06-10 17:39:46
@_author: Hauke Laging 
@_subject: Keyserver spam example 
Am Donnerstag 10 Juni 2010 16:00:18 schrieb David Shaw:
But that is the wrong argument. The correct argument is about the key server share of spam in a world in which nearly everyone has a public key. Of course, in that world signatures may be used to prevent spam. So the problem is mainly the mean time.
If you have an email address then you get spam. That is a reliable rule. But people cannot decide not to have an email address, that is virtually impossible. But people CAN decide not to have a public key (on key servers).
In my opinion we should see three important aspects:
1) The situation will change if PGP becomes more common (what we want).
2) This is not only about spam but about the protection of privacy. It is inacceptable that everyone can easily check who is in contact with whom via the clear text addresses and the web of trust. It was mentioned here that this can even be dangerous for people who get suppressed by their government.
3) Big parts of the problem are easy to solve. Don't export clear text names or addresses any more but their hash only. Store those clear texts seperately from the keys like the trustdb file.
Apropos hash, if I may "advertise" one of my proposals (no relation to PGP)... I think that it makes sense to make more use of hashes, visible to the user. Using this for the protection of names and addresses in gpg could be a guide for other applications (solving other problems, though). This could even be used for a "new" security mechanism (see the end of the document).
For the part of the audience which can read German:
And for the rest: The more or less great result of the Google translator...

@_date: 2010-06-10 19:04:37
@_author: Hauke Laging 
@_subject: Keyserver spam example 
Am Donnerstag 10 Juni 2010 18:39:25 schrieb Jameson Rollins:
I asked them what this is about several days ago.
They told me that some ... had registered one ore more email addresses at several mailing lists and now they got all these emails. Sounds like an address with changed forwarding target after registration. Impossible to protect against that for a list owner I guess.
This ticket system does NOT send its replies via this list (it couldn't) but sends it directly to you. So taking "their" email address off this list is probably all our list admin could do.
These guys seem not no be of the very clever kind as they see from which mailserver they get the unwanted emails so that IMHO they could have solved that with that MTA's admin or could have blocked that MTA.
It would help to know when this has started ? in case that the registration timestamp is stored. If not then it may be possible to send a few test mails, to half of the left possible addresses in order to find out which address causes these replies.

@_date: 2010-06-16 09:46:05
@_author: Hauke Laging 
@_subject: Fwd: [Full-disclosure] Introducing TGP... 
Am Mittwoch 16 Juni 2010 00:20:37 schrieb M.B.Jr.:
So it's more or less the same like GnuPG where you can export your keys and use symmetric encryption with a strong password for that file.

@_date: 2010-06-16 21:26:11
@_author: Hauke Laging 
@_subject: auto refresh-keys 
Am Mittwoch 16 Juni 2010 19:10:17 schrieb Daniel Kahn Gillmor:
A different approach might save even more bandwidth:
Most keys do now change often. It is useless to download a key that has not Thus the client could send a list of all keys it wants to check and the server could respond with a list of fingerprints and modification timestamps.
If the server wants to do its job (without TLS) especially well then it signs this list and solves a today unsolved problem by that. This way you could even check whether a key update of yourself has reached a (non-TLS) key server.
It would have to be decided whether this key server time stamp refers to the newest time stamp of a signature in the respective key (then the time stamp would be the same from all key servers and the client could check the local key to find out whether it has the current key) or to the timestamp of the last update on the key server (which would require the client to store the timestamp of the last key download for every key server).

@_date: 2010-06-17 22:14:55
@_author: Hauke Laging 
@_subject: auto refresh-keys 
Am Donnerstag 17 Juni 2010 21:23:40 schrieb MFPA:
My aim was not to prevent the first unnecessary download but the others. Download it once from every keyserver and store the timestamp for every Something I forgot: The keyserver should not update the timestamp for a key just because of a new upload. The timestamp should be modified only if the key is modified somehow.
As I was talking about a keyserver feature I just don't care about non-
keyserver scenarios. In general it might be possible to create similar optimizations for other transport (application) protocols.
If it's an http URL then gpg might store the etag or timestamp and use If-
None-Match or If-Modified-Since in the request. But isn't this a rather exotic case? How many keys are configured that way? Are their owners to be freed from unnecessary traffic...?
I would advise to care about the keyservers first.
If your keyservers don't support TLS (I have no idea whether the important ones use it) then you are open to a MitM attack when checking them. If the response is signed then you are not (if you are sure about the signing key :-) ).
One more advantage: The signed response could be distributed among several systems of the same user or several users with similar keyrings. This would result in omitted or smaller requests (containing just those IDs not covered by the response). Several users might even combine their ID wishlist so that only one of them has to ask the keyserver.
MitM again. If you upload a changed key you cannot be sure (without TLS) whether it has arrived at the keyserver or just at one of the bad guys.
Right. So the keyserver would use the timestamp of the latest change at it
Look at it the other way round: The more keys there are in the keyring the more bandwith is saved. I am convinced that users with large keyrings have enough local storage for that...

@_date: 2010-06-18 09:13:52
@_author: Hauke Laging 
@_subject: auto refresh-keys 
Am Freitag 18 Juni 2010 02:10:22 schrieb MFPA:
but this is about the share of file URLs in the keyring not the number of file URLs against the number of alternative key servers.
Another point: With a good auto refresh infrastructure less people might feel the need to use such a file URL.
You are missing the kind of attack. The WoT prevents you from being attacked by modified keys. It does not prevent you from being "attacked" by non-updated keys. The attacker can send you the file you already have. This is more a DoS attack with security implications for revoked and added keys and organizational implications if you need more signatures to verify a key.
Yes but it seems to me that none of that is equally convenient to simply passing the timestamp file to the other systems. OK, I admit that I have just considered the case that no keys have to be updated. It makes sense to create a singed bulk download option, too. First you request the timestamps, next you request all keys you need to update. That would allow to avoid server accesses completely by simply passing both signed files (timestamp list and key Yes. That would be kind of a caching proxy service. Privacy protection could be reached by taking "secret" IDs off the list for the "proxy guy". Unrevealed IDs would be checked directly. If gpg was to be extended by an option to create an ID list I would suggest the feature to mark keys as not to be revealed by such update lists.
Sending to several keyservers does not help if the MitM attack point is on your side.
How large is your keyring file? I assume that for ten checked keyservers the file for storing the last timestamp for each key and keyserver would not even have the size of the keyring.
And if there are only 40 KiB of space left on the device then IMHO you simply have to face the truth: That the wrong device it used for the application

@_date: 2010-06-20 02:14:59
@_author: Hauke Laging 
@_subject: auto refresh-keys 
Am Samstag 19 Juni 2010 13:36:15 schrieb MFPA:
 "If your keyservers don't support TLS (I have no idea whether the important ones use it) then you are open to a MitM attack".
So in order to be safe you need additional CPU load either for TLS or for signing. Signing is superior IMHO because it allows reuse of the data (one crypto action (covering less data) for several users vs. one for each user with TLS) and makes more sense because you don't need a second crypto system (X.509) to protect the first (OpenPGP).

@_date: 2010-06-22 20:03:30
@_author: Hauke Laging 
@_subject: local signatures: should they be importable by default in some 
Am Dienstag 22 Juni 2010 19:29:32 schrieb David Shaw:
Thanks for the explanation; this wasn't clear to me (too) before.
Doesn't it make sense to put this (or a hint where to find such an explanation) into the man page? :-)

@_date: 2010-03-22 05:11:36
@_author: Hauke Laging 
@_subject: using a smartcard without keytocard 
I have just bought a gnupg smartcard, copied my subkeys to it, and it works. I have been using a key on several computers. Now I want the other systems to use the smartcard, too, so that I can delete the private keys there. The content of the smartcard is shown by --card-status and I could even use the authentication key for an SSH connection.
For SSH connections gpg-agent looks at tha smartcard by default but it does not for normal key lookup. I just get an error message (something like "no private key found") if I delete the private keys.
Is there an "official" way to tell gpg to use the smartcard? Anything except copying the keys to the card again (executing keytocard on all systems)?
I had the idea that exporting the secret keys on the system which initialized the smartcard might work. But for convenience I decided not to use the smartcard at home so I imported the secret keys there...
BTW: Does it make sense that the smartcard number is stored with the secret key stub after the keytocard command? I haven't tried but I guess that copying the same key to another card wouldn't work.

@_date: 2010-03-22 14:17:47
@_author: Hauke Laging 
@_subject: Delete secret key without public key 
Am Samstag 20 M?rz 2010 15:17:55 schrieb Andr? Ludwig:
I think this solves your problem:
gpg --keyid-format long --edit-key ...

@_date: 2010-03-29 13:57:58
@_author: Hauke Laging 
@_subject: gpg on open file 
Am Montag 29 M?rz 2010 10:04:13 schrieb Fabrice RAFART:
I don't think that there is any solution within gpg, simply because gpg cannot (easily) prevent other processes from modifying the file while it reads it.
I see two solutions, a usable one and the perfect one:
a) Use mandatory locks. That's what I wanted to suggest first. But a short look at the documentation make me think that this may easily become terrible. So better look at
b) Create a snapshot volume This requires the file's filesystem to reside on a block device that is handled by the device mapper. Locking a whole volume in order to emulate a reliable file lock looks a bit like overkill but without better solutions... This requires superuser privilege, of course (in contrast to (a)).
c) One more comes to my mind: Given that the file resides on a suitables file system (like ext{2,3,4} and probably more) you could make the file immutable (chattr), execute the next step and remove the i bit then. Again: Superuser The snapshot's advantage is that is causes the shortest block (if the file has a relevant size) and that applications do not notice this action. If an application is not prepared for being denied access due to mandatory locking or the immutable bit, additional problems may arise.

@_date: 2010-05-07 04:43:09
@_author: Hauke Laging 
@_subject: Wrong signature hash detection? 
I have created signatures with different keys for a JPEG file. You can find both the graphics file and the signatures on this web page:
If I check the signatures, gpg2 2.0.15 (and at least .14, too) returns the wrong hash (unless I misunderstand something):
start cmd:> LC_ALL=C gpg --verify --verbose organspende.7f637e7b.1.sig  Version: GnuPG v2.0.14 (GNU/Linux)
gpg: armor header:
gpg: Signature made Fri May  7 03:48:42 2010 CEST
gpg:                using RSA key 0x7F637E7B
gpg: using PGP trust model
gpg: Good signature from "Hauke Laging (Dieser Schl?ssel ist wirklich sicher) gpg: Signature policy: gpg: binary signature, digest algorithm SHA1
It says SHA1 though according to my understanding
is obviously not an SHA1 signature. The check deliveres the correct result for the signature of the other key (which I created immediately before on the same start cmd:> LC_ALL=C gpg --verify --verbose organspende.eccb5814.2.sig  Version: GnuPG v2.0.14 (GNU/Linux)
gpg: armor header:
gpg: Signature made Fri May  7 03:49:11 2010 CEST
gpg:                using RSA key 0x3A403251
gpg: using subkey 0x3A403251 instead of primary key 0xECCB5814
gpg: using PGP trust model
gpg: Good signature from "Hauke Laging "
gpg:                 aka "Hauke Laging "
gpg:                 aka "Hauke Laging "
gpg: Signature policy: gpg: binary signature, digest algorithm SHA512
There are two differences between the keys: ECCB5814 has a DSA primary key and an RSA subkey for signing. This key is stored in my normal keyring. 7F637E7B is on a smartcard. Due to some configuration error during key creation the primary key is for signing, too:
start cmd:> LC_ALL=C gpg --edit-key 7F637E7B
pub  2048R/0x7F637E7B  created: 2010-03-04  expires: 2015-03-03  usage: SC
Up to now I don't think that any real problems arise from this. It seems to be a "cosmetic" problem. Is this a bug or have I made any mistake?

@_date: 2010-05-07 05:47:49
@_author: Hauke Laging 
@_subject: Wrong signature hash detection? 
Am Freitag 07 Mai 2010 05:15:10 schrieb Daniel Kahn Gillmor:
Yes. :-)
OK. Thanks. So RSA signatures have the same size for different digest

@_date: 2010-05-12 17:31:40
@_author: Hauke Laging 
@_subject: published key security levels 
do you think it would be useful to integrate some information about the "usage security" of a key into the key?
Keys are used differently. The one I use to sign this email is my key for nearly everything. It is (or rather: was) stored on several PCs which are rather comfortable than high security systems (KDE). Offline security is high but few applications only are denied access to ~/.gnupg (by AppArmor). It is not probable but far from impossible that this key is compromised. That is OK for me because I believe that it is most important to have reasonable security available everywhere. Somebody wrote here today: "RSA is better than nothing". That's the point.
Of course, it is not a problem to generate several keys for different levels of security. I would not want this key to be accepted for important contracts. For different level keys to be useful the users of public keys have to be enabled to recognise this level (with cryptographic security).
My idea is to define some levels which can be added e.g. as signature notations to the key:
0: unknown
1: for testig purposes; private key available to several people
2: low security: key is used on non-trustworthy systems (e.g. for using webmail services from public systems)
3: medium security; key is used on trustworthy systems only
4: hardware security; key is used on smartcards only (including offline 5: paranoid: the key is on a smartcard; signatures and certifications are made on systems which are "guaranteed" to be non-compromised (booting from DVD, not network connection) only.
The main problem IMHO is: This information needs to be covered by certifications to be really useful. If it is not, this could happen: A low security key becomes available to an attacker. The attacker is capable of changing the notation. A communication partner gets the changed key with valid signatures and regards it as a high security key.
Is there any possibility to get such additional key parts signed without changing the key format (or putting that into the comment field)?
An interesting question is: What am I supposed to do if somebody wants me to sign his key at level 4 or 5 if I know that this key is or has been used in other ways, too? ;-)
The currently discussed problem of selecting the the right subkey(s) would grow to selecting the right (primary) key, of course. This could be solved by defining global and per addressee levels. If a certain message needs higher or allows lower security then the appropriate key would have to be selected How would this affect the usage of gpg? I tried to make an organization support the usage of gpg by educating its members and offering certification. One of the arguments against this was: "People cannot read their emails on their mobile devices any more then."
This is not only a technical problem. It should be up to the sender to decide which level of privacy he demands for his message. So the sender could decide that it is OK for him that the recipient will not be able to read the message everywhere but only in a reasonably secure environment (thus often later). If a message is to not be readable in certain circumstances then it is not an agument that it isn't. It's not a bug, it's a feature.
On the other hand the sender could decide that he does not want to send a postcard security level message but that webmail access is OK for him. He would use a level 2 key (too) then.

@_date: 2010-05-13 01:03:50
@_author: Hauke Laging 
@_subject: published key security levels 
Am Mittwoch 12 Mai 2010 20:29:18 schrieb Joel C. Salomon:
The main problem is: How do people recognise your high security key as such? By the comment only?
The next problem: (AFAIK) You cannot prevent people from signing your keys.
Furthermore this feels a bit strange to me. The basic rule is: The more signatures, the better. And now a feature shall be based on avoiding signatures? :-S

@_date: 2010-05-13 16:15:07
@_author: Hauke Laging 
@_subject: published key security levels 
Am Donnerstag 13 Mai 2010 09:16:56 schrieb Hagen F?rstenau:
These two problems are not connected.
I don't think that people will like to write an individual description into their comment field. Thus a category standard seems necessary to me. This standard need not be bound to technical, it can be "legal" instead. How big may the loss be you are willing to bear due to a forged signature or revealed confidential information?
0: undetermined (zero)
1: zero
2: low
3: medium
4: high
5: unlimited
Everyone can determine for himself then how he translates this into technical and organizational requirements for himself. Another possibility is to allow both statements.

@_date: 2010-05-25 16:07:33
@_author: Hauke Laging 
@_subject: Crypto Stick released! 
Am Dienstag 25 Mai 2010 15:21:05 schrieb James P. Howard, II:
What is the gpg version you use? IIRC You need 2.0.13 or 2.0.14 for 2048 bit keys on a smartcard.

@_date: 2010-05-26 02:05:31
@_author: Hauke Laging 
@_subject: smartcard signing does not work in VM (in contrast to decryption and 
I experience a strange problem. I have bought a smartcard in order to have my keys available at work without storing my keys there.
I can decrypt files using the smartcard and I can log into my home system via SSH and the smartcard but if I try to sign a file then I get an error message after entering the PIN at the card reader.
I don't have the shell output available as I just tried this at home. Using the same smartcard and the same cardreader I can sign files so it seems not to be a hardware problem.
This is from the log file, in German though:
2010-05-19 15:15:13 gpg-agent[4920] Handhabungsroutine 0xb786fa58 f?r den fd 8 2010-05-19 15:15:35 gpg-agent[8699] Handhabungsroutine 0xb78a3b60 f?r fd 8 2010-05-19 15:15:35 gpg-agent[8699] new connection to SCdaemon established gpg-agent[8699.9] DBG: -> SERIALNO openpgp
gpg-agent[8699.9] DBG: <- S SERIALNO D27600012401020000050000047B0000 0
gpg-agent[8699.9] DBG: <- OK
gpg-agent[8699.9] DBG: -> SERIALNO openpgp
gpg-agent[8699.9] DBG: <- S SERIALNO D27600012401020000050000047B0000 0
gpg-agent[8699.9] DBG: <- OK
gpg-agent[8699.9] DBG: -> SETDATA 7AB58F01073D0FC253E898F06D9B22...
gpg-agent[8699.9] DBG: <- OK
gpg-agent[8699.9] DBG: -> PKSIGN gpg-agent[8699.9] DBG: <- INQUIRE POPUPKEYPADPROMPT ||Bitte die PIN eingeben%0A[Sigs erzeugt: 0]
2010-05-19 15:15:47 gpg-agent[8699] starting a new PIN Entry
2010-05-19 15:15:47 gpg-agent[8699] DBG: connection to PIN entry established
gpg-agent[8699.9] DBG: -> END
gpg-agent[8699.9] DBG: <- INQUIRE DISMISSKEYPADPROMPT
gpg-agent[8699.9] DBG: -> END
gpg-agent[8699.9] DBG: <- ERR 100696113 Eingabe-/Ausgabefehler gpg-agent[8699.9] DBG: -> RESTART
gpg-agent[8699.9] DBG: <- OK
"Eingabe-/Ausgabefehler" (last line but two) is "I/O error". That is approximately the shell error message.
I use 2.0.15 on both systems, openSUSE 11.2 each. The most obvious difference is that my home system runs on hardware and the work system in VMware 2 (host system openSUSE 11.1).
Thus USB timing may be slightly different but resulting in failure does not make any sense to me. Luckily decryption and authentication are the two features I really need there... ;-)  But perhaps somebody has an idea how to let me sign there, too.

@_date: 2010-11-10 16:21:21
@_author: Hauke Laging 
@_subject: Problems with two active encryption subkeys 
Am Mittwoch 10 November 2010 15:38:39 schrieb Sven Klomp:
AFAIK gpg takes the (compatible) subkey which is valid for the longest remaining period. Unfortunately you cannot even force gpg to use a certain subkey (directly): Giving a subkey ID as encryption target triggers a strange process: gpg looks for the main  key of this ID and then selects the subkey as if the main key ID had been given...
If you really want to force it then you can export the subkeys to a different keyring (call gpg with --no-default-keyring and --keyring and import the key), delete all other subkeys and start the normal encryption afterwards.

@_date: 2010-11-10 20:20:13
@_author: Hauke Laging 
@_subject: Problems with two active encryption subkeys 
Am Mittwoch 10 November 2010 19:52:00 schrieb MFPA:
I created some more subkeys to check that...
For 2.0.15 you are right in one point and wrong in the other. It is the newer creation date which is chosen not the longer remaining validity period. But the newer key wins against the longer one:
start cmd:> LC_ALL=C gpg --edit-key 71FDC5CB
pub  1024D/0x71FDC5CB  created: 2010-02-25  expires: 2011-02-25  usage: C
sub  2048R/0xDA63AFDA  created: 2010-11-10  expires: 2011-01-09  usage: E
sub  1024R/0x1860836B  created: 2010-11-10  expires: 2010-12-10  usage: E
gpg --encrypt --recipient 71FDC5CB test.html
encrypts for 1860836B not for the both longer and longer valid DA63AFDA.
Funny. That's even explained in the man page. What other secrets may wait there for discovery...

@_date: 2010-11-11 12:58:26
@_author: Hauke Laging 
@_subject: Problems with two active encryption subkeys 
Am Donnerstag 11 November 2010 09:50:30 schrieb Sven Klomp:
This conclusion cannot be drawn from the gpg behaviour, of course. You have to look at the standard. After that you know whether gpg conforms to it or not. Why should any problems arise from that? As long as the sender can encrypt and the recipient can decrypt... Doesn't matter which subkey is used, does it?

@_date: 2010-10-12 03:25:03
@_author: Hauke Laging 
@_subject: Confirmation for cached passphrases useful? 
I just had the idea that it might be a good countermeasure against malicious software not to use a cached passphrase without any user interaction (and thus without user notice). A good compromise would be to open a dialog which does not ask for the passphrase but just for the confirmation that it's OK to use the passphrase. The dialog could mention the process accessing gpg-agent.

@_date: 2010-10-12 11:10:31
@_author: Hauke Laging 
@_subject: Confirmation for cached passphrases useful? 
Am Dienstag 12 Oktober 2010 06:34:48 schrieb Robert J. Hansen:
"going to", yes.
I think that it is not useful to equalize unpriviledged and root access. This seems to me a bit ignorant of people trying to get their systems secure. :-)
There are ways to prevent this. E.g. I protect important and hardly ever changed files like ~/.gnupg/options with root priviledge (chattr immutable on ext3). My most threatened processes (browser, IM) are covered by AppArmor profiles which hevily restrict access to $HOME but not to /tmp. These cannot access the secret keys, of course. But due to the new design of GnuPG 2.1 this may change.
As Daniel already pointed out: Few people do but there are possibilities to harden your system. It would seem strange if of all things a security software put a limit to such efforts. Thus gpg should offer improvements even if these do not make much sense ALONE (which should be mentioned in the documentation).

@_date: 2010-10-12 11:14:47
@_author: Hauke Laging 
@_subject: Confirmation for cached passphrases useful? 
Am Dienstag 12 Oktober 2010 09:05:56 schrieb Daniel Kahn Gillmor:
But this may change in the future. On the one hand you are free to have X clients running untrustedly (which should make that impossible) on the other hand I read rumores about the SELinux people heading at changes to their LSM in order to address the (more than obvious...) X problem.

@_date: 2010-10-15 01:45:32
@_author: Hauke Laging 
@_subject: Confirmation for cached passphrases useful? 
Am Dienstag 12 Oktober 2010 04:44:41 schrieb Daniel Kahn Gillmor:
I am not familiar with X details (let alone that other one OS). Does grabbing the mouse prevent other processes from knowing where the click occurs? You could use a dialog differen from just an OK button. You could display a ten times ten array and the user hat to click a certain number. This is similar fast to clicking the OK button and easy to remember (always the same number) but makes abuse improbable (of course, that is not the level of probability we usually have when attacking gpg...).
If other processes cannot read the content of the dialog window then other means are possible: Use a blank area with a randomly positioned mark to click And react to failures.

@_date: 2010-10-15 12:55:22
@_author: Hauke Laging 
@_subject: Confirmation for cached passphrases useful? 
Am Freitag 15 Oktober 2010 12:28:33 schrieb Werner Koch:
That's why we try to restrict the access of malicious code, isn't it?
Following your pessimistic attitude there would hardly be any reason not to work as root.

@_date: 2010-10-16 01:05:11
@_author: Hauke Laging 
@_subject: Confirmation for cached passphrases useful? 
Am Samstag 16 Oktober 2010 00:23:04 schrieb Robert J. Hansen:
This implies the strange claim that it will forever be possible to do that. As I already mentioned you can run X clients untrustedly today and SELinux is going to be extended by features for X access restriction.
But, of course, you can deny all applications that never use gpg keys access to both the files and the socket by means of the LSMs even today. And if an application gets hijacked that has to access the key files and the socket then an attacker can wait until the next intended operation occurs. So the user would not notice the abuse of his key.
The process of informing the user could be more clever than a simple "gpg-
agent access, please click OK" window. An obvious option is to allow the user to configure a program and allow or deny access based on the exit code; we saw proposals what such a check program could do here in the discussion. I just don't like the idea that access to the agent is "not noticed by design".
Somebody mentioned an "inconvenience for the user". I would make this behaviour an option (for people understanding the merits and limits) not the default. Thus no inconvenience for anyone.

@_date: 2010-10-30 01:12:10
@_author: Hauke Laging 
@_subject: key not trusted when secret main key missing 
I have (had) a strange problem which I cannot even reproduce. To make it worse, I use version 2.0.15.
I have created a key on a secure system, exportet the public keys, the secret keys and the secret subkeys to three files and imported the public and subkeys on another system.
I could not configure this key for the use in KMail (without any error message). Thus I tried to make a signature. Verifying the signature led to this output (in German and as I cannot reproduce the problem...):
start cmd:> gpg --verify test.html.BBEA218E.sig test.html
gpg: Signatur vom Fr 29 Okt 2010 22:31:49 CEST           gpg:                mittels RSA-Schl?ssel 0x95C20EF1     gpg: Korrekte Signatur von "Hauke Laging (Offline-Hauptschl?ssel) ...
gpg: Beglaubigungsrichtlinie:                  gpg: WARNUNG: Dieser Schl?ssel tr?gt keine vertrauensw?rdige Signatur!
gpg:          Es gibt keinen Hinweis, da? die Signatur wirklich dem vorgeblichen Besitzer geh?rt.
Haupt-Fingerabdruck  = AFF8 7529 66BE F70C A514  9618 650F 4F91 BBEA 218E                        Unter-Fingerabdruck  = A65D A538 6A73 21E0 01F3  C2BF F78C 4FD6 95C2 0EF1
It says: This key has no trustworthy signature. There is no hint that the signature belongs to the claimed owner.
Then I read the comments in the config file which says:
"GnuPG ultimately trusts all keys in the secret keyring."
I have the secret keys ? except for the main key. I can create a signature with this key.
I then put both this key and the one which has signed it in the config file:
trusted-key 650F4F91BBEA218E
After that the warning disappeared (and KMail accepted the key). I thought that the reason was the missing secret main key (which would not make sense and would be considered by me as a bug). Just for fun I removed the "trusted-
key" entries. And even though this should be the same configuration as before the warning did not appear again. Thus I cannot (easily) reproduce it.
There are other keys without secret main key which do not cause this problem. The reason may be that my normal key is configured as default key and the other ones are signed by it.
However, I do not understand why the problem is "solved" now. Does gpg note anywhere (trustdb?) that a key was valid so that the secret main key checking is skipped?

@_date: 2010-10-31 18:01:10
@_author: Hauke Laging 
@_subject: Restoring a backup key 
Am Sonntag 31 Oktober 2010 17:50:10 schrieb Osama Khalid:
Have you imported the public key before?

@_date: 2011-04-07 19:26:04
@_author: Hauke Laging 
@_subject: Set key to be default to sign/encrypt 
Am Donnerstag 07 April 2011 14:26:50 schrieb Csabi:
You ask the wrong question. The question is not how to make an unusable key the default but how to get this key working.
What happens if you try to sign something with this key?
gpg -u 12345678 --detach-sign file

@_date: 2011-04-07 20:55:57
@_author: Hauke Laging 
@_subject: gpg: encryption failed: public key not found 
Am Donnerstag 07 April 2011 13:36:31 schrieb 123098:
And "I" is root?
This uses the standard keyring nothing else.
There is a difference between a process being capable of accessing something and a process trying to. Do you think root-gpg tries all keyrings it has access to automatically?
The easiest way to solve this should be to import the public key as root and mark it as "trusted-key" in the config file.

@_date: 2011-04-07 21:22:48
@_author: Hauke Laging 
@_subject: gpg: encryption failed: public key not found 
Am Donnerstag 07 April 2011 21:08:44 schrieb Daniel Kahn Gillmor:
I must admit that I haven't checked what happens during batch processing. If root does not have an own key for signing the public key in its own key ring then a warning occurs in interactive operation. If the untrusted public key is used anyway in batch mode then it is not necessary to mark it as "trusted-
I don't see any problem there. Either root has its own key then this would be used for signing the public key instead of marking it as "trusted-key" or root does not have an own key then it is improbable that validity calculations are made by root gpg.
But the better solution would be to sign it with the user key, import the public user key to the root key ring, import the signed other public key and mark the user key as "trusted-key".

@_date: 2011-04-07 21:26:54
@_author: Hauke Laging 
@_subject: Set key to be default to sign/encrypt 
Am Donnerstag 07 April 2011 21:10:45 schrieb Csabi:
Wrong question again. What HAVE you done wrong i.e. what have you done to your secret key?
After key generation the secret key is shown by
gpg --list-secret-keys
So you must have deleted your secret key. Or the generation failed at all. So you either "find" your secret key somewhere or you generate a new key pair.

@_date: 2011-04-18 13:05:03
@_author: Hauke Laging 
@_subject: --s2k-count: correct value in config file needed? 
is the value of --s2k-count written to the key somehow? If not, can you use a key only if the correct value is given in the config file (or command line)? Does a key become kind of useless if you have forgotten the value which was used during the last passphrase change?

@_date: 2011-04-18 13:21:07
@_author: Hauke Laging 
@_subject: A better way to think about passwords 
Am Montag 18 April 2011 12:53:12 schrieb Faramir:
That does not make sense to me because you do not increase the key space by that. If you try to defend against somebody who knows what you do then it is no protection.
My wish is to have a secure, small, cheap smartcard-like device which stores a salt, takes a passwort and gives you a hash then. The salt makes this secure. Your "password" can even be the name of the organization to which the account belongs. "bank xy". Easy to remember and completely safe thus because the hash is created over
"OJD5jLP1L8Wa0a19qtgRH4dlzA7aeZTobank xy"
And if you are asked to change the password, over
"OJD5jLP1L8Wa0a19qtgRH4dlzA7aeZTobank xy2"
"OJD5jLP1L8Wa0a19qtgRH4dlzA7aeZTobank xy3"
Such an device would also allow easy but secure CRAM logins ? even by phone.

@_date: 2011-04-20 10:26:04
@_author: Hauke Laging 
@_subject: Batch gpg encryption : prompt 
Am Mittwoch 20 April 2011 05:03:17 schrieb Daniel Kahn Gillmor:
By --trusted-key  if you don't want (or can't) (l)sign the keys.

@_date: 2011-04-28 15:11:37
@_author: Hauke Laging 
@_subject: No, it is not. 
Am Donnerstag, 28. April 2011, 14:49:30 schrieb Robert J. Hansen:
That's not what he wrote. My understanding of his argument is that with increasing need of reliability of encryption the need for hiding the communication partners increases.
I would add that above a certain level of encryption security or connection hiding it probably becomes important to hide that you use this technology at all (at least if you don't do it just for fun). Unpleasant people might have wrong thoughts otherwise.

@_date: 2011-04-29 20:41:56
@_author: Hauke Laging 
@_subject: signing non default key 
Am Freitag, 29. April 2011, 20:04:40 schrieb Yard, John:
--local-user 0x12345678

@_date: 2011-04-29 21:23:36
@_author: Hauke Laging 
@_subject: Centralizing Private and Public Keys From Multiple Boxes with 
Am Freitag, 29. April 2011, 20:56:49 schrieb Ted Zatopek:
That is correct except for the detail that the option is --local-user or -u.
In order to prevent writing nonsense I checked what "-user" produces. I used this command:
gpg --detach-sign -user eccb5814 index.html
I was surprised by the result. gpg created a signature using a key with no obvious relation to the command. Additionally I got an error message that "eccb5814" was not found (meaning: as a file).
I finally understood by myself that "-user" is interpreted as "--local-user ser". Many keys have "ser" in their UIDs.
Does it make sense to accept a parameter for --local-user which is not unambiguous? Of course, it says what it is going to do but aborting with a clear error message would be user protection IMHO.

@_date: 2011-08-05 00:14:47
@_author: Hauke Laging 
@_subject: Card only available to root user 
Am Freitag, 5. August 2011, 01:49:21 schrieb Luis de Bethencourt:
Is this an access rights problem with the card reader device file? Different defaults with Gentoo and Debian maybe?
Of course, this explanation does not make sense if pcsc_scan can access the device. Is pcsc_scan installed with SUID or SGID?

@_date: 2011-08-05 01:07:19
@_author: Hauke Laging 
@_subject: Card only available to root user 
Am Freitag, 5. August 2011, 03:02:07 schrieb Luis de Bethencourt:
I have no certain problem in mind. My general advice is to check with strace what's going on. Often the problem can easily be seen shortly before the program abort. If not you may compare the outputs of the root and user calls.

@_date: 2011-08-11 22:56:31
@_author: Hauke Laging 
@_subject: Trust model - trust level 1 and 2 
Am Donnerstag, 11. August 2011, 20:05:55 schrieb Jerome Baum:
For keys with "high" security requirements the policy should also be signed by the ones who signed the key as it would be easy to write and sign a high security policy for a compromised low security key.

@_date: 2011-08-12 13:45:31
@_author: Hauke Laging 
@_subject: How to validate encryption 
Am Donnerstag, 11. August 2011, 15:47:40 schrieb Yadav, Amarjeet:
Why? In order to prevent the usability of GnuPG exploits?
If you trust the sender (and his systems) then the simple answer is: Have the sender sign the encrypted file. I hope that would not result in "we would like to check its validity before we check the signature"...

@_date: 2011-08-18 14:10:22
@_author: Hauke Laging 
@_subject: OpenPGP parts and plain text in the same email 
probably all of you know the problem that users of that one ******* kind of mail client tell you that they cannot read your emails like the ones from other people. There was just an "attachment" which they have to open in order to read the text. And of course, that other one attachment with nonsense This is more an email question than a GnuPG question: Mail clients are capable of sending both an HTML and a plain text version of the content within one email. I wonder whether it is possible to send emails in the same way with a plain text part and an alternative PGP/MIME part. "Solving" the outlook problem this way might increase the acceptance of OpenPGP.

@_date: 2011-08-30 20:44:28
@_author: Hauke Laging 
@_subject: Migrating to Smartcards 
Am Dienstag, 30. August 2011, 17:54:32 schrieb Richard:
Citing the documentation (--edit-key):
Transfer  the selected secret subkey (or the primary key if no subkey has been selected) to a smartcard.
At least no serious ones. You will probably have to make gpg read the card content by --card-status or --card-edit. At worst you would have to "delete" the secret key before.

@_date: 2011-12-18 00:24:30
@_author: Hauke Laging 
@_subject: How to select a particular public key when verifying a signature? 
Am Samstag, 17. Dezember 2011, 15:22:28 schrieb Vladimir A. Pavlov:
1) Create a directory for each key, e.g. /tmp/gpg-aaaaaaaa
2) Import the key:
gpg --homedir /tmp/gpg-aaaaaaaa --import aaaaaaaa.asc
3) Check the files:
gpg --homedir /tmp/gpg-aaaaaaaa --trusted-key AAAAAAAAAAAAAAAA \
--verify file.sig
The solution is to use different gpg calls for the two keys.
I would like to add that you are doing something strange: Usually crypto is used to unambigiously connect data to a person. You are trying to do this the other way round: You are using whatever to find out whether the crypto information is correct. See the problem? If somebody is capable of faking your signatures why shouldn't he be able to fake anything else (which you take as a proof of origin) like sending an email from the other ones account?

@_date: 2011-12-28 03:23:10
@_author: Hauke Laging 
@_subject: --trusted-key 
Am Mittwoch, 28. Dezember 2011, 03:08:15 schrieb John A. Wallace:
See --export-secret-subkeys.
(gpg main key offline) as input for your favorite search engine answers possibly remaing questions.

@_date: 2011-12-29 16:16:36
@_author: Hauke Laging 
@_subject: How to sign my own public key? 
Am Donnerstag, 29. Dezember 2011, 16:08:08 schrieb Stayvoid:
That's right for keys which have been created by GnuPG. you can check that by
gpg --list-sigs
See --allow-non-selfsigned-uid (in the block "Doing things one usually doesn't want to do."...)

@_date: 2011-12-30 01:24:08
@_author: Hauke Laging 
@_subject: How to sign my own public key? 
Am Donnerstag, 29. Dezember 2011, 19:47:36 schrieb Stayvoid:
For subkey. The signature given above refers to the public subkey. It would be useless to sign private keys.
See --ask-cert-level
I think that GnuPG always uses 3 for UID self signatures and never gives such a statement for subkeys (maybe that's not even possible), wouldn't make sense Mail cannot be encrypted by secret keys at all. Public keys are for encryption and signature verification, private keys are for decryption and signature It probably makes sense that you have a look at some beginners tutorial.
It will automatically use the right one. Great, isn't it? I.e. in this case first your private key for the signature and then the recipient's public key for the encryption.

@_date: 2011-02-03 16:07:50
@_author: Hauke Laging 
@_subject: Add/remove recipient without re-encrypting 
Am Donnerstag 03 Februar 2011 15:38:12 schrieb Alphazo:
Not an answer but a proposal:
I have read this question several times on this list. I know that this is possible today but complicated (and AFAIK not part of the gpg documentation). I prefer an easy solution within gpg. Thus I suggest the feature that recipient packets can be stored in a seperate file. Thus only a small file has to be changed (extended or partially erased).
A solution with better compatibility would be: The session key of the content file is the encrypted content of the recipients file. Thus implementations with a feature like --override-session-key can still access the content file (with some manual assistance) if they don't support such an extension file.
That could look like this:
gpg --encrypt --recipient 11111111 --recipient 11111112 file.txt
would change to
gpg --encrypt --recipient 11111111 --ext-rec-file  --recipient 11111112 \
with all recipients given after --ext-rec-file (or --ext-rec-file=filename) being written to the extension file.
If this is not implemented and we stick to "you would need to write the tool yourself" then it might be helpful to add the option to write some dummy recipients (just to have enough space in the file which can be overwritten).

@_date: 2011-02-04 00:16:47
@_author: Hauke Laging 
@_subject: moving user ID Comments to --expert mode 
Am Donnerstag 03 Februar 2011 23:22:38 schrieb Jameson Rollins:
Perhaps it makes sense to extend the output of --gen-key by a hint like "Additional features are enabled by the option --expert. Have a look at the This is independent of this discussion, though. It took me several years to notice this option... ;-)

@_date: 2011-02-27 02:53:39
@_author: Hauke Laging 
@_subject: SCR3310 reader working for root, but not scard group 
Am Sonntag 27 Februar 2011 01:45:26 schrieb Todd A. Jacobs:
I had the same problem. My problem was that $DEVICE does not point to /dev but to /proc. You can easily check that by putting
ls -l "${DEVICE}" >> /root/gnupg-ccid.log
into the script. My script looks like this:
chgrp "${GROUP}" "${dev_device}"
chmod g+rw "${dev_device}"

@_date: 2011-02-28 13:39:53
@_author: Hauke Laging 
@_subject: Security of the gpg private keyring? 
Am Montag 28 Februar 2011 12:47:24 schrieb Guy Halford-Thompson:
All that is contained in the public keyring.

@_date: 2011-01-02 05:09:48
@_author: Hauke Laging 
@_subject: Is self-signing necessary? Basic questions. 
Am Sonntag 02 Januar 2011 04:30:53 schrieb takethebus at gmx.de:
The key IDs are a small part of the key (SHA-1) hash value. Thus they are part of the public key but I don't know whether explicitly or just implicitly.
There are four key capabilities:
C: certification
S: signing
E: encryption (and decryption)
A: authentication
The main key is the only one which is used for key certifications (both for its own subkeys and for other main keys) because only the main key is identified by key certifications. The main key does not need any other capability. Not to use the main key for anything other than certifications allows you to keep that key offline (see --export-secret-subkeys). It is not necessary but makes sense to deny the main key all other capabilities if intended for offline use only.
You can create subkeys with one or several capabilities (except for certification). In theory you could have a main key for certification and encryption and a subkey for signing. Subkeys can be created with a limited validity time. An offline main key can easily be valid for a long time (or even forever).
Yes. The fingerprint refers to the key material itself and thus does not change when UIDs or subkeys change. Everything else (UIDs, subkeys, key configuration) is checked indirectly by checking the validity of the main key's signature for this data.
You verify only the main key itself by the fingerprint but you always sign the key together with a UID. gpg --list-sigs shows this to you: The root entry is pub, the uids are the next level ("connected" to pub) and the signatures refer to UIDs.
A key must have at least one UID (at least with gpg) but need not have any You have to explicitly sign UIDs. AFAIK it is not possible to sign the raw key Not demand but it seems to not make sense, see --allow-non-selfsigned-uid:
"Allow the import and use of keys with user IDs which are not self-signed. This is not recommended, as a non self-signed user ID is trivial to forge."
But I do not understand the practical problem: What sense could it make for an attacker to modify UIDs if the user of the public key verifies the I don't know but you can try. :-)
Yes, that is easily possible:
1) --edit-key
2) if needed: uid ...
3) delsig
You get warned if you try to remove selfsigs. UIDs and subkeys can be changed by commands like addkey delkey, see the man page for --edit-key.

@_date: 2011-01-02 18:04:53
@_author: Hauke Laging 
@_subject: Is self-signing necessary? Basic questions. 
Am Sonntag 02 Januar 2011 13:27:23 schrieb MFPA:
The same statement like a signature of a useless UID (without useful name and email address) like "fubar". Leaving out a useless UID can hardly change The formal statement is "I had access to this key and I had some reason to sign it". As with signing normal UIDs the real statement does not come from the signature itself but from the certification level statement and the certification policy which is described in a signed document (signed by the certifiers of the key, too...) whose URL is contained in the signature... (see

@_date: 2011-01-02 18:18:59
@_author: Hauke Laging 
@_subject: Signing 
Am Sonntag 02 Januar 2011 17:36:52 schrieb takethebus at gmx.de:
By a self-signature. Same for the subkeys (with the difference you already noticed that you officially cannot delete the signature).
Sure. You can easily copy "Hauke Laging " from my "key", add it as UID to your key and sign it. Extracting the original signature would not make sense as it would not match the new public key and thus not be accepted.

@_date: 2011-01-02 20:29:13
@_author: Hauke Laging 
@_subject: Signing 
Am Sonntag 02 Januar 2011 19:36:02 schrieb takethebus at gmx.de:
Together is the opposite of seperately. The combination is signed. The one signature is not valid for the key or the UID alone, only for both together.
The signature is accepted if it signs the combination of key and UID.
Correct. "Self-sign" refers to the key making signatures for its own components in contrast to signing other keys.

@_date: 2011-01-11 17:44:42
@_author: Hauke Laging 
@_subject: Organizing GPA public key list into favourites groups???? 
Am Dienstag 11 Januar 2011 17:35:57 schrieb Bo Berglund:
I don't know about the GUIs but gpg has the option --group.
--encrypt-to in the config file.

@_date: 2011-01-12 14:21:35
@_author: Hauke Laging 
@_subject: What is the benefit of signing an encrypted email 
Am Mittwoch 12 Januar 2011 06:52:59 schrieb David Shaw:
That may be a difference to crypto but I doubt that it is a difference to the user... Solutions are better than excuses. And here the solution is simple, it's "just" the usual problem of having to extend an existing standard.

@_date: 2011-01-12 14:25:46
@_author: Hauke Laging 
@_subject: What is the benefit of signing an encrypted email 
Am Mittwoch 12 Januar 2011 11:48:39 schrieb Werner Koch:
Which is simultaneously a solution for the spam problem (and an improvement against attacks by malicious content) in all thoses cases in which this kind of privacy is not required. For the (probably few) exceptions the other way (E/S/E) could be used.

@_date: 2011-01-12 17:08:53
@_author: Hauke Laging 
@_subject: What is the benefit of signing an encrypted email 
Am Mittwoch 12 Januar 2011 16:57:27 schrieb Robert J. Hansen:
More often "I have no confidence they keep their secret keys strictly under their control" might be the relevant objection.
You mix up the (current ? key validation can be done after the communication, too) absence of a guarantee with being worthless.

@_date: 2011-01-12 17:39:00
@_author: Hauke Laging 
@_subject: What is the benefit of signing an encrypted email 
Am Mittwoch 12 Januar 2011 17:15:48 schrieb Daniel Kahn Gillmor:
Thus it makes sense to use different keys for
a) usual ("not thought about") email, just as a first hard line of defense against forgery
b) serious, valuable signatures
That's why I would like to have a standardized description for keys which tells the other one what they are used for (and what not...) and in what kind of environment:
1) testing
2) webmail (used on untrusted systems)
3) used on normal-security but generally trusted systems
4) smartcard
5) used in a high-security environment only
This category would have to be certified, too, of course.

@_date: 2011-01-12 18:10:49
@_author: Hauke Laging 
@_subject: What is the benefit of signing an encrypted email 
Am Mittwoch 12 Januar 2011 17:44:48 schrieb Daniel Kahn Gillmor:
If only one person is capable of making a signature then it's not important whether he "thinks" he made it.
Let's take this email as an example. I write it on my PC which may be more secure than the average system but has all the weaknesses of a system which does all the daily work.
I mean: It is POSSIBLE to steal my secret key but it is not EASY. For normal email communication I regard this as enough. For signing treaties or other keys I use other keys (and a different environment).

@_date: 2011-01-18 12:36:51
@_author: Hauke Laging 
@_subject: What is the benefit of signing an encrypted email 
Sorry, just found this one in my spam folder :-)
Am Mittwoch 12 Januar 2011 17:49:10 schrieb Robert J. Hansen:
OK, I was not very clear about what exactly I meant. There are different types of attack. I thought about securing the real communication. If I regularly write emails to somebody and once he gets a mail that is not signed then he is to be distrustful. This is not about convincing someone that a certain email has not been written by me (as in your example) but to assure him that you have written certain emails.
It is perfectly OK that GnuPG solves only one of these two problems. Incapability of solving the first is not an argument against solving the So why would somebody who cares about not being blamed for the content use an email address that refers to him? Somebody who cares about security?
Just in the case that this individual message is known by the receiver to be In my opinion non-signing requires the receiver to be distrustful about the But in a non-technical way. Everyone is used to the concept that cars, houses and mailboxes have locks of different quality.

@_date: 2011-01-19 20:06:31
@_author: Hauke Laging 
@_subject: What is the benefit of signing an encrypted email 
Am Mittwoch 19 Januar 2011 19:29:35 schrieb Werner Koch:
I have asked for that before. At the last Linuxtag in Berlin noone from KDE or the BSI (which has paid for the crypto integration of KMail) accepted this as a problem which should be solved...
In addition to what you just described I would like to have standardized dummy entries for the to and from field (probably seldom used but little effort to cover them, too) and the subject. That way you can also encrypt the headers.

@_date: 2011-07-08 21:06:24
@_author: Hauke Laging 
@_subject: Check that s2k-count has changed 
Am Freitag, 8. Juli 2011, 20:35:57 schrieb Chris Poole:
The count is coded into a one-octet number using the following formula:
     EXPBIAS 6
    count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);
The above formula is in C, where "Int32" is a type for a 32-bit
integer, and the variable "c" is the coded count, Octet 10.

@_date: 2011-06-12 19:35:57
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Sonntag, 12. Juni 2011, 15:23:19 schrieb MFPA:
Why should that be a misapprehension? For which law does that not have There is no reason to assume that you are less bound by the timestamp than by the signature itself. The timestamp can be fake. So what? So can be the signed data. You don't have to have a look at what you are going to sign. You can sign the output of /dev/urandom. Nothing of that makes your declaration of intent invalid. At least not in Germany. The relevant perspective is that of a neutral third party. How toes it look like to them?
You can claim that the signing system has been compromised and that the act of signing has been rigged. That may work. But a statement like "The key and the signing system are both valid. Just don't care abour the timestamp." will not be successful. Take that legal risk if you like.
Funny theory. Either you trust all or nothing. How should you draw the line in That is simply wrong. A signature refers to the supplied timestamp. That is usually the current time. Even if you fake that it would just by chance be the time of sending (but noone would expect it to be that). A signature is made at a certain moment. It does not matter at all when the signed data gets sent. The time of sending cannot change the signature. You would have to create a new signature at a time that happens to be nearly the time of sending.

@_date: 2011-06-13 17:39:25
@_author: Hauke Laging 
@_subject: Generate digest and signature seperately 
Am Montag, 13. Juni 2011, 17:15:59 schrieb Dan McGee:
I just realize that this does not solve the "you don't know what you sign" argument at all. Whether you sign a file or the hash of that file is usually not a difference to the user in the statement (just in convenience).
This is about "Shall you be able to 'sign' remote data", not so much about how you do that. Let alone that downloading (and even compiling) source code before signing does not guarantueee that you sign what you think you are signing. You are just protected from signing something completely different.
Another point: One should not assume that somebody knows what he signs just because there is a "direct" signature. What a signature means should be taken solely from the signature policy.
I would like to have the possibility to pass the hash to be signed.

@_date: 2011-06-14 01:33:08
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Montag, 13. Juni 2011, 22:07:07 schrieb MFPA:
By that standards: What does a signature mean at all? As a parallel discussion on this list shows, it does not even guarantee that the signer had access to the signed data.
You should tell apart who has to prove something. Your argument is valid if the signer has to prove that he has made the signature at (or before or after) a certain date and time. His own signature is no proof in that case as he can easily fake the timestamp.
If a third party has to prove that and when the signer has signed a document then the signature timestamp is perfectly OK.
The rest of my former mail was probably a misunderstanding. I thought you were talking about local signatures but your reply shows that you meant additional signatures by a timestamp server.

@_date: 2011-06-14 14:25:51
@_author: Hauke Laging 
@_subject: Generate digest and signature seperately 
Am Dienstag, 14. Juni 2011, 13:51:10 schrieb Jerome Baum:
Does that matter and why?

@_date: 2011-06-15 00:34:48
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Dienstag, 14. Juni 2011, 21:25:06 schrieb MFPA:
First: That is no contradiction to what I have said. Have a look at the offline world: You never(?) sign anything in order to be able to prove that you have done or have to do something. You sign in order for others to be able tp prove that you have done or have to do something.
Second: I really doubt that your case is a practical problem. As I said: The other one's interest is usually to be able to prove that you have signed and not that you haven't.
A treaty is signed by both parties. So if you have not been fooled into a faked signature by the other party then you have a signature with a timestamp close to yours.
And even if you were "accused" of having signed with a faked system time: So what? This accusation is very dangerous, BTW. Everyone can easily get trustworthy timestamps for his documents or signatures. So you present a "proof" that the other one has manipulated and he has a better proof that your "proof" is fake? Faking such a proof is probably much worse than faking a timestamp for a normal signature.
An idea: I suggest a standardized signature notation like "timestamp". It would indicate that you don't make any statement about the signed content (which even may be encrypted, even against you) but just confirm the time of existence. That would solve (or reduced) the recently mentioned problem "You don't know what you sign".
The real problem is IMHO that keys can be revoked (without any bad intention). If you don't have a third party timestamp or something similar to prove that the signature has been made before the key was revoked then the signature is nearly worthless.
That's why I think it would be a good idea to add a signature to all signed incoming emails. Then at least you know that those signatures can be trusted. Better would be a third party confirmation. The ISPs could do that. Store the hash of each delivered email and send you a signed hash list from time to

@_date: 2011-06-15 02:59:21
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Mittwoch, 15. Juni 2011, 01:35:45 schrieb Jerome Baum:
Because signature notations are supposed to be standardized. There aren't any yet though. Nobody suffers from defining a string to mark timestamp-only signatures. That is easily parsable both for software and for humans. Timestamps are an important application. I don't think that there is any equal Furthermore this might make signature notations more popular. IMHO they are a very useful nonetheless nearly unused feature.
To repeat myself again: I also hope that in a not so far future there will be signature notations which can give detailed (and parsable) information about the signature policy.

@_date: 2011-06-15 10:56:21
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Mittwoch, 15. Juni 2011, 03:16:16 schrieb Jerome Baum:
A good procedure.
Shall I repeat the proposal, or is that a question to Werner? :-)
"The signer makes no statement about the content of the signed data (may not even have been able to read it) but only confirms its existance at the time of the given timestamp."

@_date: 2011-06-15 12:36:33
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Mittwoch, 15. Juni 2011, 12:23:40 schrieb Jerome Baum:
What would that refer to? You don't have to confirm the current time, do you? I don't think that there is a need for high precision time stamps. A statement about the accuracy might be part of the signature policy.

@_date: 2011-06-15 17:39:47
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Mittwoch, 15. Juni 2011, 17:07:22 schrieb Daniel Kahn Gillmor:
Is it possible to create such signatures with GnuPG? How?

@_date: 2011-06-15 21:30:38
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Mittwoch, 15. Juni 2011, 21:10:45 schrieb David Shaw:
Even if the next GnuPG version allowed to do that it might be almost useless if the older and other implementations do not show it (cannot show it at all). But I don't know how they react to such a signature packet.
Notations can be seen (and set) in old and other implementations (are not shown by default, though).
However this may be done: It makes sense that GnuPG prints a hint/warning if such a standard notation is used even if notations are not shown.
How is this a problem? Does it matter for that purpose (or any other) how a signature is encoded (does "text signature" mean --armor?)?

@_date: 2011-06-15 23:58:31
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Mittwoch, 15. Juni 2011, 23:19:33 schrieb David Shaw:
It should at least change the message from
"Good signature from ..."
"Good timestamp-only signature from..."
in order to help the user avoid a misunderstanding. It is good if you can show that you acted correctly (used this notation) and someone has misunderstood what you did. It is better to prevent the other one from misunderstanding it at all.
I support that. A non-critical timestamp signature is technically usable on "all" systems, a critical one would be usable on few only. That's IMHO a much bigger problem then the non-recognition of the feature. After all the correct understanding of a signature is up to the recipient anyway (impossible without the signature policy). This notation allows you to skip checking the policy.
I would like "popular" notations to be mentioned in the GnuPG documentation. I guess that will not take much space. :-)  Or at least a document describing those should be given.
You also might consider introducing --timestamp-only (easy to remember) or similar as an alias for --sig-notation timestamp-only at gnupg.org=default.

@_date: 2011-06-16 00:58:09
@_author: Hauke Laging 
@_subject: Problem with faked-system-time option 
Am Mittwoch, 15. Juni 2011, 23:54:17 schrieb David Shaw:
Maybe both intentions (alert and compatibility) can be combined at another level: Isn't it possible to create two signatures, one with the notation marked critical the other one not? Except for the problem that some old PGP version crashes when seeing more than one sig... Recognizing implementations would give notice of two valid signatures (and maybe supress one), the other ones of one valid and one invalid. Thus users of the latter would have both a valid signature and a reason to check what's up...
Something like that. A hint at the documentation (like "(see --timestamp-
only)") could be added but I guess that the output shall be kept to minimum This one does not have the problem you mentioned for 0x40 (cleartext)? Because it refers to an (unambigious) signature instead of to (ambigious) data?
That is simultaneously the nice and the bad thing. The bad part is that this cannot be the only implementation of this feature as it is limited to signatures. A timstamp service should sign anything, not just signatures. There may be reasons not to reveal a signature (with the key ID) but rather to get a signed timestamp anonymously.

@_date: 2011-06-16 13:21:09
@_author: Hauke Laging 
@_subject: timestamp notation @gnupg.org (was: Problem with 
Am Donnerstag, 16. Juni 2011, 09:14:43 schrieb Werner Koch:
Especially as it is at least three threads with a common subject...
OK but GnuPG is an infrastructure tool and not so much about personal preferences, isn't it? ;-)  So the relevant questions should be:
a) Is signed timestamping an important feature for cryptography?
b) Do we want to enable easy "cloud timestamping" (on the lines of the web of trust) or do we leave this up to certain services (on the lines of a CA)?
c) Who should set a pre-standard (for a testing phase)?
That's right but not the web of trust idea. Putting such a feature into GnuPG (even if its just a non-IETF standard notation and the documentation) will raise awareness for the problem to be solved.
This notation is a more compatible alternative to the signature type 0x40. So its explanation could be used:
"Timestamp signature. This signature is only meaningful for the timestamp contained in it."
I would add for clarity: "The signer makes no statement about the signed data (including that he has read it or at least could read it at all) except that it existed at the time given in the signature timestamp."
It would be used by people who want to securely timestamp data without introducing new (unambigious, like those of a timestamping service) keys for it. The timestamping services may use this, too, for third parties to more easily understand what the signature is about.

@_date: 2011-06-16 16:27:12
@_author: Hauke Laging 
@_subject: timestamp notation @gnupg.org 
Am Donnerstag, 16. Juni 2011, 14:56:32 schrieb Werner Koch:
Perhaps you have misunderstood the intention: This is not about changing data formats. This is not about changing gpg code (could be for convenience but is not necessary).
This is primarily about a uniform understanding of already available features so that the usage of these features gets easier (and more common).
If anyone is not happy with the OpenPGP timestamp format (which I haven't noticed yet) then that would be a completely different discussion.
Nobody said it was not possible at all. The discussion is about making it much easier. The easy of use has (at least) two parts: Accessibility of the information and a uniform format.
Of course, it would not make sense to make a standard for every possible information that could be contained in a signature policy. But this is a very basic statement (possibly extended by a policy URL) for a feature which has been mentioned by several GnuPG related RfCs, which is offered by commercial and free services and even covered by crypto law.
There is no need to use  as a test phase name space; it just makes sense IMHO. But if you prefer to limit gnupg.org to the code that's perfectly OK. This question is not even related to this timestamp discussion:
Do you want to promote the uniform usage of notations (perhaps later taken over into IETF namespace) via this mailinglist and an officially maintained list of notations in the gnupg.org namespace or not?
If you want to avoid notations in gnupg.org then the discussion is finished

@_date: 2011-06-16 20:40:51
@_author: Hauke Laging 
@_subject: what does a timestamp signature mean? 
Am Donnerstag, 16. Juni 2011, 19:37:02 schrieb Daniel Kahn Gillmor:
So don't I. By my understanding the result of the discussion was there are situation in which a third party timestamp is necessary to prove a signature Then the discussion moved to problems of timestamping. As timestamping (for other ones) is useful it should be as simple and risk free as possible. There was the argument that there is an unpleasant ambiguity if there are two meanings of signatures (normal signatures which refer to content and timestamp and timestamp signatures which shall not make any statement about the content) but no technical difference. Strictly speaking you always have to consult the signature policy to know the intention but that is not easily done (let alone the fact that many signatures (and keys) do not have a policy URL).
I would describe it so: The aim is an explicit reduction of trust (in order to avoid misunderstandings instead of perhaps painfully solve them afterwards). My wish is a reduction to the timestamp. Jerome also wants a standard statement of the possible timestamp error. I don't think that is important but there is no namespace problem so I don't care. My argument about the last point is that you immediately see the timestamp of the third party signature and have to react if its wrong. After all a statement about the assumed clock precision does not prevent clock problems.

@_date: 2011-06-18 00:21:12
@_author: Hauke Laging 
@_subject: timestamp notation @gnupg.org 
Am Freitag, 17. Juni 2011, 23:23:34 schrieb MFPA:
To me that is quite clear not a problem of the FORMAT of the timestamp.

@_date: 2011-03-01 02:15:32
@_author: Hauke Laging 
@_subject: Security of the gpg private keyring? 
Am Dienstag 01 M?rz 2011 01:32:05 schrieb Grant Olson:
Can you explain what custody chain means in this context?
My simple thought about that is that one of the keys has a newer time stamp and that this one in synchronized and overwrites the older ones.

@_date: 2011-03-03 21:24:25
@_author: Hauke Laging 
@_subject: Exporting a private Key 
Am Donnerstag 03 M?rz 2011 11:52:03 schrieb Bairi, Chandra Shekar:
You cannot. Exception: You generate the key on a smartcard. In that case you are asked whether you want to make a backup (IIRC). For secret keys stored in a keyring:
--export-secret-keys / --export-secret-subkeys
See the documentation.

@_date: 2011-03-09 14:46:53
@_author: Hauke Laging 
@_subject: hashed user IDs [was: Re: Security of the gpg private keyring?] 
Am Mittwoch 09 M?rz 2011 14:11:16 schrieb Ben McGinnes:
This discussion has been there before (initiated once by me).
There are several advantages:
1) You don't reveal the social connections by signing keys. If you want to validate a key by its signatures and see a signature of an unknown key then there is (IMHO) no reason why you should know who has certified this key. This information can easily be abused. The perfect web of trust would be the perfect source of information which should be considered private (who knows whom). This problem is hardly reduced by the fact that there are signatures (from key signing parties) from people without real social or commercial 2) For people in countries where authorities' rights and actions are not as easily ruled unconstitutional like in Germany (or not at all) it is useful if not only the content of their communication is hidden but also the identity of the communication partners (even of those in free countries). This is, of course, more complex than hashing a key ID, thus I am not sure how important this feature would be (as you have to hide the partner's email address or the connection to the identity and these email addresses have both to be kept secret (because you can easily hash all "publicly available" addresses) and to be complex enough not to be guessed; this may result in greatnesses like sqq8ctpmbf81yucw8nzwbaod at hauke-laging.de).
In general it is useful for a web of trust to have long living keys. Email addresses are more easily changed than keys.
3) You prevent spammers from using keyservers as a source. Yes, I am aware that certain people on this list don't accept this as an argument (for different reasons). The most important point for this question is probably that the infrastructure has to be safe BEFORE it gets so big that it becomes interesting for spammers.
According to a new study it has the best worldwide image of all relevant countries worldwide. However. :-)

@_date: 2011-03-10 01:03:14
@_author: Hauke Laging 
@_subject: hashed user IDs [was: Re: Security of the gpg private keyring?] 
Am Mittwoch 09 M?rz 2011 14:39:35 schrieb Robert J. Hansen:
As we all know you love anecdotal evidence, here's mine: You are probably right but consider two points:
1) Today there is no use in obeying the (2) rules. If such a feature is implemented then those who are interested in using it will consider creating new email addresses according to (2). Nonetheless the number of interested users may be small (but increasing with increasing public attention to privacy problems besides reading mail contents).
2) gpg offers a lot of features which I guess are used (and even known) by a small share of its users. Nonetheless they got implemented. Obviously the main argument is not the number of users but the quality of the software. There is a whole section "Doing things one usually doesn't want to do." in the man page. I guess it contains more than 80 options.
I have never done that. I cannot iamagine why this should be important to anyone. You know which email address you are going to write to, don't you? OpenPGP should not prevent new features because somebody abuses the infrastructure as a kind of address book.
More important: Not everyone is going to do this. Those people who regard it important to protect their addresses and names really don't care about convenience (if the alternative is omitting the feature).
It might make sense to print a warning if a user activates this hashing feature for a UID with an email address which is obviously not brute force And in contrast to Werner I do believe that signatures are going to kill the spam problem one day. :-)

@_date: 2011-03-10 10:57:46
@_author: Hauke Laging 
@_subject: hashed user IDs [was: Re: Security of the gpg private keyring?] 
Am Donnerstag 10 M?rz 2011 04:42:25 schrieb Ben McGinnes:
A little practical advantage: If gpg had such a feature then the documentation may mention everything that is needed additionally (depending on the targetet opponent: spammers, facebook-alikes, secret police) or useful. Then people in a bad situation (which are probably no security experts) had a trustworthy source of information for planning their communication strategy.

@_date: 2011-03-10 11:23:56
@_author: Hauke Laging 
@_subject: hashed user IDs [was: Re: Security of the gpg private keyring?] 
Am Donnerstag 10 M?rz 2011 06:17:25 schrieb Robert J. Hansen:
Of course, you can create a key with UIDs without name and email only but such keys are not very comfortable to have in your keyring ("What's that?"). Of course, you can add a UID annotation feature without having the hashing But not having the hashing feature makes it more difficult to get the key (and key updates). Keyserver access is pretty anonymous. If you put keys on a website (the address of which the one can have given you who gave you the non-
public email address) then that is another way to try to reveal the identity of the communication partner.
I appreciate your effort to consider the problem as a whole. It would be a pity to create something that turns out to be useless in the end. But that is not a problem here any longer: Those people who just want to protect their social connections by signing other keys without revealing their identity to those who don't know it already have no need to cover their target addresses because the marketing people and "just curious" normal ones are not capable of reading their email traffic. So there already is a use case. Your objections for the high security cases are very good to raise awareness but point outside the gnupg sphere.
You made a brute force calculation. Why should keyservers allow brute force searches for hash IDs? If you use millions of remotely controlled idiot PCs simultaneously for that then it may be hard to track them but then we are close to a DoS, aren't we?

@_date: 2011-03-10 13:56:53
@_author: Hauke Laging 
@_subject: Signing signature policies required for safe key usage? 
this is not gnupg specific (though one could think of new feature making this point more comfortable, of course...).
I often read on this list: "You need a valid signature of a validated key. Everything else is more or less useless." I would like to push this a bit further by questioning the worth of a valid signature.
A signature itself does not say much except that the one who created it had access to the secret key. The biggest threat to the security of OpenPGP is the security of the secret keys and obviously there is a wide range of key security. This "must" be the case as security is strongly related to Different signatures are supposed to offer different levels of security (against the secret key to be compromised). In order to reliably use OpenPGP you need to know the security level a certain key has. As long as there is no standardized way to express this (you may remember my occasional statements about that which never get any response...) this can be done by publishing the respective signature policy only. Fortunately OpenPGP makes this easy by adding a policy URL to a signature.
Probably every signature policy document is signed by the key it refers to. Why should you trust it otherwise?
After this foreword now my point: Such a document (signed by the respective key only) is IMHO useless for any security requirement above minimum level. Why? If the key becomes compromised (which is quite possible for minimum security keys) then the attacker can easily write and sign whatever signature policy he wants. "This is a low security key which I use for signing all my emails and reading encrypted mail from public systems." becomes "This key is stored on a smartcard and used in a high security environment only."
Thus I think that we should not only certify other people's keys but also sign the respective signature policy document. You trust the key because it has valid signatures by other keys you trust. You can analogically trust a policy document because an attacker would not only have to steal the respective secret key but also all secret keys for the signatures you demand to accept the policy document as valid.
Maybe anyone wants to comment on that... :-)

@_date: 2011-03-10 21:09:58
@_author: Hauke Laging 
@_subject: hashed user IDs [was: Re: Security of the gpg private keyring?] 
Am Donnerstag 10 M?rz 2011 14:34:13 schrieb Robert J. Hansen:
That's the technical situation today. But it is no use to announce that to the whole world. It is required only for those people who use your signature in a validation chain. Everyone else does not need (and probably not use) the signature so there is no benefit for exposing the connection (though unclear) between the key owner and the certifier.
I want to deploy this technology because
a) this is in my strong opinion not what people WANT (it's just what they DO because there is neither much awareness for the problem nor a usable b) nobody who really wants to inform the whole world is in any way affected in doing that.
May be a language problem, sorry. I'll try with an example:
You have validated my key (among others) and I (among others) have validated Ben's. Now you want to validate Ben's key indirectly. Ben's key has ten signatures, the one by my key is the only one usable for you. The next person who tries to validate find another signature useful. It's perfectly OK for me that you can see that I have signed Ben's key but why should others know that? Why should you be able to find out who are the other ones who have made signatures for Ben's key?
I would make a local signature if I would not want to let anyone know that I have verified the key. But in that case you could not verify Ben's key what I am willing to enable. The motto is: Don't reveal more than necessary. You have to reveal something in order to make the whole thing work but you don't have to reveal all.

@_date: 2011-03-13 01:21:19
@_author: Hauke Laging 
@_subject: hashed user IDs [was: Re: Security of the gpg private keyring?] 
Am Sonntag 13 M?rz 2011 00:06:14 schrieb Robert J. Hansen:
Your arguing pretends that somebody is to be fooled. That is not the case. Nothing prevents gnupg (and I even suggested to do that) from warning that this feature seems to just be used for an email address which is does not make sense to be used with (for the reason you explained very convincingly).
When offering this feature it should be clearly said that it not worth much for most existing addresses. It isn't, too, for new addresses which are simple. As a user you should decide to take both or none: a safe email address and a safe UID or a normal address and a normal UID.
This would not be snake oil. But a tool that requires certain knowledge and awareness. Just as today's gnupg itself.

@_date: 2011-03-13 01:41:14
@_author: Hauke Laging 
@_subject: hashed user IDs [was: Re: Security of the gpg private keyring?] 
Am Freitag 11 M?rz 2011 14:54:57 schrieb Robert J. Hansen:
I meant "not useful".
As MFPA mentioned: This would not prevent mapping. It would (if noone fails) help limiting the access to the identities in the map to those who are supposed to be able to do that by the decision of the respective identity The access to signatures is not limited. Everyone decides himself which ones he needs. But the owner of the identity decides whom it is revealed to.
No. You just control who can make the next step: Mapping keys to UIDs.

@_date: 2011-03-21 14:54:01
@_author: Hauke Laging 
@_subject: Deniability 
Am Montag 21 M?rz 2011 06:48:07 schrieb Jerome Baum:

@_date: 2011-03-21 16:02:04
@_author: Hauke Laging 
@_subject: Deniability 
Am Montag 21 M?rz 2011 15:48:39 schrieb Jerome Baum:
You know that. And the archive of this mailinglist now knows that you have once claimed to do that. So one may assume that the only recipient is you but that is not a strong technical conclusion from the message itself.

@_date: 2011-03-22 01:44:10
@_author: Hauke Laging 
@_subject: hashed user IDs 
Am Sonntag 20 M?rz 2011 19:31:49 schrieb Ben McGinnes:
They would probably not.
1) A good implementation of such a feature would allow the storage of additional data (like in trustdb.gpg). In listings this info would be shown (probably with a hint) instead of the hash.
2) If you search for a key on a keyserver then gpg would know what you have searched for. You want the key for hashid at hauke-laging.de. Then gpg first seaches for this string but without success. The it seaches for 3dcfba2bd001d14b56b8341965cdaa85 which results in a match. So gpg would download this key and automatically write "hashid at hauke-laging.de" as additional UID information info hashiddb.gpg or whatever.
3) If a key file with haded UIDs is imported as a file (not from a keyserver) then the user should be asked to add some comment. He need not do that, of course, but in that case he should not complain later about that.
That is true for gnupg as a whole. Or does anyone really claim that a relevant amount of new gnupg users has a clue about the need of protection the secret keys which are usually stored in rather unsafe environments? I assume that most new users believe: "Great technology. Now my data is really safe."
Being consequent gpg without --expert should ask during each key generation:
1) Are you REALLY sure you don't want to create this key on a smartcard?
2) You are running Windows / X / have network access / a kernel older than four days. Are you REALLY sure you want to create a key in THIS environment?
Think about appropriate warnings for entering a passphrase in an obviously unsafe environment.

@_date: 2011-05-02 17:19:38
@_author: Hauke Laging 
@_subject: Offline Master Key 
Am Montag, 2. Mai 2011, 16:47:31 schrieb patrickbx at lavabit.com:
You can create the master key without any capability except for certification. It is theoretically possible to use several keys (main key and subkeys) within one key for signing and give the signatures different meanings (e.g. "daily use" vs. "high security") but I think that most people would not notice the difference. So IMHO the only reason for having several simultaneously valid keys with the same ability in one key is compatibility: Use the strongest key (and have the others use it) whenever possible, otherwise use the worse I think it's a good idea to have signature and encryption keys of different quality but I would advice to use different main keys for that. That allows the others to understand the difference from a simple look at the UID (when using comments like "daily use" and "high security").
No. Subkeys are a normal feature. The default configuration creates keys with a subkey (not for signing though). Nobody except you should be able to realize whether your master key is stored online or offline.
No but it makes sense (independently of this question) to link it in your self-signature. See the option --set-policy-url though in the default configuration this URL is not shown (just hinted by a "P").
Yes, that's the concept of OpenPGP.

@_date: 2011-05-02 19:06:00
@_author: Hauke Laging 
@_subject: Offline Master Key 
Am Montag, 2. Mai 2011, 18:13:21 schrieb John Clizbe:
I told him that I was willing to do that (not on the list but after happening to visit his page). I haven't finished that yet but I now increase the pressure on my by making this public. :-) Should be done by the end of the week. And if the result seems worth it then the new page may be linked (or published on the GnuPG site).

@_date: 2011-05-05 17:07:27
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Donnerstag, 5. Mai 2011, 11:19:30 schrieb Werner Koch:
What is the difference between these two options with respect to the point of In my understanding people either refresh their keys often enough or not. If they do so then they have either old subkeys with renewed expiration date or completely new subkeys. In both cases the should not notice the update; the verification result is the same.
Are there people who check the subkey IDs of old and new signatures, get confused by a change despite of gpg saying it's all right (which IMHO demands they have not understood the concept of subkeys)?
BTW: Would it be a good idea for gpg to suggest the user to check for an updated version of the key (or do it automatically before if configured to do so) if it find an expired subkey? This would probably not work with the GUIs though (but might make the GUI developers offer a similar feature).

@_date: 2011-05-05 20:52:05
@_author: Hauke Laging 
@_subject: simple gpg syntax question 
Am Donnerstag, 5. Mai 2011, 20:40:03 schrieb Yard, John:
This is done by putting --encrypt and --sign into a single command.
This can be controlled by --output.

@_date: 2011-05-06 17:34:22
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Freitag, 6. Mai 2011, 09:47:57 schrieb Doug Barton:
That's not correct for subkeys and offline mainkeys as the good guys do it.
I admit that a subkey expiration date does not make much sense for low security mainkeys but it is quite useful for more secure environments.

@_date: 2011-05-07 04:05:18
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Freitag, 6. Mai 2011, 21:48:03 schrieb Ingo Kl?cker:
I am a bit disappointed that it seems not to be possible to change this by an option. It seems to me that you have to parse text output which is not intended for parsing. There is no --with-colons for --verify, or do I just not notice such a feature?
Several people have mentioned that a signature does not become invalid by expiration of the key. That is formally correct an describes the GnuPG behaviour. But with regard to content in such a case there has to be an additional proof that the signature has been made before the key expired. This is a formal rule in e.g. the German signature law. If you want to use legally accepted signatures for proving documents then you have to sign both the document and the old signature by a new key (i.e. one with a later expiration date) before the old key expires.
I would prefer GnuPG to work this way: Make a signature by an expired key fail by (configured) default and add an option like --ignore-key-expiration which can be used for a second gpg call (after an external verification that the signature has been made in time).
And I would like to have a verification option for output intended for We can have a long discussion about the interpretation of signatures by expired keys (apparently made before the expiration). But as there is IMHO no way to really make sure that you have the current version of a key (and thus all revocations) I regard an expiration date as a last line of defense. Thus I think that it does not make sense to (effectively) ignore such an expiration by default. Nobody is forced to set expiration dates. Newer subkeys are used automatically without the old ones being revoked or expired.
That didn't make any sense to me so I checked that. This seems to be wrong. I have not noticed any change in the verification output (or exit code) between a valid subkey existing beside the expired one or not.

@_date: 2011-05-07 04:33:24
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Freitag, 6. Mai 2011, 22:37:12 schrieb Doug Barton:
You have to tell apart two cases:
a) The mainkey is compromised.
b) The subkey is compromised.
If someone keeps his mainkey offline and well passphrase-protected then it is quite unlikely that the mainkey becomes compromised. If only the subkey gets compromised then it is not possible to change the subkey's expiration date. Thus your argument works for (a) only which can easily be prevented from That is a last line of defense as it is quite hard to be sure to have the current version of a key under normal circumstances. And it works for people who are lazy with key refreshing.
Of course, you cannot be sure when a subkey will become compromised. Probably you won't even notice. But a short life time limits the danger resulting from a compromised key.

@_date: 2011-05-07 13:54:16
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Samstag, 7. Mai 2011, 04:33:17 schrieb Grant Olson:
Whether you owe me money does not depend on signing any documents in general. :-)  Documents are usually just a proof.
You can still claim that somebody owes you money but the document does not have the same legal value. What courts decide is another question...
But the fiscal authorities don't accept digital bills (probably the most frequent use of legally qualified signatures here) which are signed by expired keys only. You need a chain of signatures which prove that there was a non-
expired signature at any point in time.
For the same reason it makes sense to have digitally signed documents signed by another key (not just the document but the document together with the signature) at once when you get them. Because you cannot know whether and if a key will be revoked in the future. The moment it is revoked and you cannot prove the signatures being older than the revoke all signatures are dead.

@_date: 2011-05-07 16:06:16
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Samstag, 7. Mai 2011, 15:54:21 schrieb MFPA:
You can very well if you don't claim that for all cases but use this assumption for distinguishung between a useful and a useless use if expiration dates. AFAIR noone here on the list has claimed that it makes sense (with respect to security) to use key expiration dates without offline mainkeys. That is an important point in the discussion.

@_date: 2011-05-08 04:34:52
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Samstag, 7. Mai 2011, 21:43:38 schrieb MFPA:
There is probability but no safety in this assumption. But it this relevant? How and whom is an expiration date supposed to protect? And what is the The user of a non-expired public key does not have to cope with any disadvantage by checking the expiration date. The alternative would be to accept the key in any case. That would obviously not be a security advantage.
One might ask: Do users who observe expiration dates refresh their keyrings less often on average (due to false trust in the expiration feature)? Does it make sense for an attacker to replace non-expiring subkeys with expiring ones in order to reduce the refresh frequency of the ones being attacked by forged signatures? ;-)
But there is security for the owner of the key. He knows that his mainkey is stored safely offline so that nobody will ever meet forged subkeys of this key. Thus he safely protects himself and his communication partners from the use of expired keys. I theory. In practice the key owner does not know whether his communication partners observe the expiration date. But he gives them the chance to do so. The theoretical model is safe. Reality usually suffers from worse security problems than that.
As you may remember I promote both an implicit and an explicit solution of this problem (not knowing enough about others' key handling) here from time to a) Write a key policy describing this, too. Make this document available online and put its URL in all your certifications (including your selfsig) and signatures (policy URL). Have everyone who certifies your key sign this document (because this cannot beforged by someone who gets access to your key). The problem: You have to read this document. GnuPG cannot do this for b) Define some standard notations which give this information. From time to time I give courses for OpenPGP beginners in an organization I am a member of. We create two keys for them, one for playing around and lerning to use GnuPG and a more secure one. When I certify these keys I add a notation "offline at ourdomain=yes". So anyone using our certifications and understanding both offline keys and notations (so probably noone) can know how these keys are used ? OK, nearly: How there were supposed to be used. There could be a different term for keys which have been created elsewhere but are claimed to be offline keys. "offline-claimed at ourdomain=yes" or something like that.
If there was a standard for this GnuPG could be extended to allow for a configuration  taking this into account. The extreme version: "Trust certifications of others only if they are offline keys."
And as I am dreaming: With a notation for identifying all subkeys (thus extending a certification from UIDs to subkeys) the first hurdle for getting GnuPG / OpenPGP compliant with German signature law (at least on the theoretical level) would be taken.

@_date: 2011-05-09 18:09:00
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Sonntag, 8. Mai 2011, 14:50:36 schrieb MFPA:
Right. The problem: Protection you don't know of. So seriously this additional protection will not be taken into account (unless you happen to have more information about the key handling).
That would be useless. The result would be that the attacked user (if he had imported the master key with the migrated subkey) would believe that a signature has been made by the attacker instead of the person whom he has stolen the key from. If an attacker wants somebody to believe that he has made a signature than he can trivially make one. No need to steal keys for that.
When encrypting  there would be no difference if you don't address the subkey directly but the main key or one of the UIDs.
Yes. That were not present or not signed. Like with UIDs.
That is correct but there would be no need for short-life subkeys any more. The problem is that German / EU signature law requires a legally fully trusted key to be created in hardware which he can never be read from. So the so called qualified signatures can be made with smartcards only. Thus the certification authorities are not allowed so certify today's mainkeys because you can create valid subkeys outside smartcards with them without the CA being part of that.
IMHO there are only two possibilities for making (a new version of) OpenPGP signature law compatible:
a) The CA creates a mainkey and subkeys. The mainkey is destroyed immediately afterwards. That might be legally acceptable but has not much in common with PGP any more.
b) It is made possible to prevent the transfer of the validity of a mainkey to a subkey. Either my disallowing subkeys at all (in the certification) or by requiring explicit certifications for subkeys. When certifying a key you would have to decide whether you make a certification of the old type (for the mainkey and then the mainkey is allowed to do everything) or of the new one. This new type of certification would not be allowed to be backward compatible. if it was then old software might regard an explicit subkey certification as a normal one and thus accept subkeys without explicit certification.

@_date: 2011-05-10 03:42:47
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Montag, 9. Mai 2011, 19:51:12 schrieb MFPA:
That would not work for several reasons which arise not from technical aspects but the circumstances:
a) Usually the contract mentions the partners. Mallory would have to claim that somebody else had signed that though that obviously does not make any sense. Furthermore this other one would deny that.
b) It would be obvious that the secret key of the subkey has been stolen. That would be a huge risk for the one who has stolen it. He would have to stand up in public and state: "Only two people can have stolen the key. One of them is me." I am not experienced with criminals but I really doubt that this sounds interesting to them.
c) Mallory cannot have created signatures before he stole the key. Bob usually has created a lot. Everyone who claims to have seen a signature of the key in question by Mallory  before the (probably unknown) date of theft is at serious risk to be proven to have lied in court. This would be possible with very new keys only.
This is not about the source of trust IMHO. I think that the major aim of the law is to prevent the stealing of keys because that would reduce the trust in digital signatures in an amount a modern society cannot afford. Thus the law requires hardware protection. Whether a hardware-protected key is certified by a CA or (strongly enough) by a WoT is less important.

@_date: 2011-05-10 15:26:30
@_author: Hauke Laging 
@_subject: Best practice for periodic key change? 
Am Dienstag, 10. Mai 2011, 07:10:42 schrieb Jerome Baum:
This is possible only if it is safe for old implementations. I see one option for that: A signature notation for this purpose could be defined and this notation could be marked critical. The standard says:
"If a subpacket is encountered that is marked critical but is unknown to the evaluating software, the evaluator SHOULD consider the signature to be in I don't understand whether this refers to the packet type or the packet content. If an implementation knows what a notation is (and shows it) but does not know the meaning of the new standardized notation what is it supposed to do according to RFC 4880? Generate an error saying "I don't understand what this notation is about" or signal success saying "I recognize this as a notation. (And I don't care about its content.)"?
If the recognition refers to the content then it's easy. There would be the practical problem left to check how the (relevant) implementations behave. It's no use if you are theoretically right but it is trivial to trick people into acceptance of wrong signatures because an often used software does not work right.
A safe solution should be to define a new packet type. That might be a generic "notation with critical content" type. This would behave like a notation with the difference that the recognition check is extended to the content (if this packet is marked critical?).
But if the standard is extended then it makes more sense to have subkeys certified explicitly instead of forbidding the acceptance of normal subkeys in In theory. The practice problem remains: Do "all" implementations behave that

@_date: 2011-05-10 16:04:32
@_author: Hauke Laging 
@_subject: PGP Help Require Basic 
Am Dienstag, 10. Mai 2011, 08:32:24 schrieb Aakash:
For the typical use of GnuPG you need two keys:
a) yours (consisting of a public key and a private key)
b) the one of your communication partner (public key only)
You have to import the public key oth the other one. And you have to create (or import) your own private key.
For information how this is done and how encryption / decryption is done after you got your keys working you should have a look at some documentation as you have been hinted at.

@_date: 2011-11-01 01:44:50
@_author: Hauke Laging 
@_subject: How to get the list of all keys to which the file has been 
Am Dienstag, 1. November 2011, 00:04:19 schrieb Veet Vivarto:
In case the data was encrypted normally and not with --hidden-recipient or But I don't know whether key servers allow the search for subkeys. If you don't have all the target keys in your keyring then it may be just an ID without any useful information to you.

@_date: 2011-11-01 13:44:11
@_author: Hauke Laging 
@_subject: small security glitches 
Am Dienstag, 1. November 2011, 13:35:11 schrieb Aaron Toponce:
But this isn't possible with email, is it?

@_date: 2011-11-18 23:10:48
@_author: Hauke Laging 
@_subject: Key File for GPG 
Am Freitag, 18. November 2011, 22:07:38 schrieb Andreea Diana Lucau:
import, encrypt, delete? :-)

@_date: 2011-10-14 01:08:12
@_author: Hauke Laging 
@_subject: adding text to detached signature files 
I am building a system at work for automatic creation of PDF files and sending them by mail. I am thinking about adding a signature file (not by the key of the sendig person but by  a key belonging to the mail system; similar to a gateway signing solution just not singing the whole mail (and not using S/MIME) but just adding a second attachment which is a detached signature.
Probably most of you have experienced the "What strange attachment have you sent to me in your email? I can't open that..." effect. In order to minimize that I think of adding some text to the file so that
This is a signature file. It allows you to verify that...
The additional text has no impact on the GnuPG verification. Is this going to work with most other OpenPGP software, too?
If so wouldn't it be nice to have an option to put some explaining text (either a default text pointing at the GnuPG site or including a file) into each ASCII armored signature file? In a batch process that does not matter but for all manually created detached signatures.

@_date: 2011-10-14 10:13:47
@_author: Hauke Laging 
@_subject: adding text to detached signature files 
Am Freitag, 14. Oktober 2011, 01:12:03 schrieb Doug Barton:
Thanks, that's what I was looking for.

@_date: 2011-10-14 10:15:48
@_author: Hauke Laging 
@_subject: adding text to detached signature files 
Am Freitag, 14. Oktober 2011, 01:53:12 schrieb MFPA:
Right, thus I am thinking of naming it file.pdf.asc.txt :-)

@_date: 2011-10-17 15:09:40
@_author: Hauke Laging 
@_subject: use key, not passphrase, in symmetric encryption 
Am Montag, 17. Oktober 2011, 13:51:03 schrieb sweepslate:
echo fubar | gpg --symmetric --passphrase-fd 0 --batch file.txt
Or use --passphrase-file

@_date: 2011-10-19 16:17:22
@_author: Hauke Laging 
@_subject: Expired keys 
Am Mittwoch, 19. Oktober 2011, 16:09:26 schrieb Jerry:
It would be helpful to know what you have done and what happened. Have you tried that with gpg or a GUI?

@_date: 2011-10-20 17:00:17
@_author: Hauke Laging 
@_subject: Expired keys 
Am Donnerstag, 20. Oktober 2011, 15:26:29 schrieb Jerry:
gpg --delete-key There is a confirmation in order to avoid removing the wrong ones. But you can give the fingerprint as identifier.
This removes public keys only so you can hardly cause real damage.

@_date: 2011-10-31 18:11:30
@_author: Hauke Laging 
@_subject: digitally signing contracts 
Am Sonntag, 30. Oktober 2011, 05:21:56 schrieb Eric Abrahamsen:
I think there are two points:
1) What exactly does a digital signature mean?
2) Can you prove that the signing key belongs to the person you have to sue in case of doubt?
to 1):
it is not obvious that a signature for a document means that the signer feels bound be that document. The signature can mean "I sign all documents so that the recipient can be sure it is from me (and unmodified)." This would not be the same like a signature by hand below a treaty (just like a signature on the back of a treaty paper probably would not be accepted by courts).
German signature law requires "to add the name to a document and sign it then by a (legally) valid key". I am not sure what that means. I think of a signature over two "files", the document and a file containing the name. But that has its risks, too. I guess that a signature over two files is just a signature over the combined files. So you would have to check that the document you sign (as usual) does not "happen" to contain your name at the end. Probably certain document formats (or rather applications) do not care about some data behind the recognized part and do not show that data.
This just inspires me: The meaning should be obvious by the signature itself. That is a good example for standardized signature notations. As long as the law does not, you have to make clear what signature is required for formally accepting a treaty (represented by a document). You could require a signature:
i_accept_this_treaty at mydomain.tld=yes. Or you require a signature by a certain key which is used for accepting treaties only (and thus cannot accidentally create signatures).
To be safe you need a treaty which makes clear the usage of digital signatures. I just catch myself: I have made such treaties before but not covered the problem I just described. :-)
to 2):
It is a difference whether
a) you can be sure that a key belongs to a person (which is easily done by checking the fingerprint)
b) you can prove in court that the key belongs to the person.
You either need a third party which is trusted by the courts (not your court but the one where you have to sue the other one...) or a treaty with a hand signature. This is easy:
"I admit to be bound by signatures by the key identified by this fingerprint until further notice (key revocation): ..."

@_date: 2012-04-05 04:50:58
@_author: Hauke Laging 
@_subject: pinentry 
Am Mi 04.04.2012, 14:03:26 schrieb auto15963931 at hushmail.com:
This does not happen here (Linux, though). I don't know how to tell gpg which key(s) to try first but if you use the command line then there's a work around: You may call gpg with
and point it at a file which contains one key only.
I assume that gpg tries the keys in the order in which they are in the keyring. Thus you may export all keys (secret and public), rename the keyring files and import the keys in the desired order. This may have to be repeated after changed to the keys (I don't know how the keyring files work).

@_date: 2012-04-28 22:36:53
@_author: Hauke Laging 
@_subject: fingerprint 
Am Sa 28.04.2012, 22:21:52 schrieb michael crane:
The "reason" is that the short and long key ID are defined as the last 4/8 bytes of the fingerprint. In other words: They are not attached to the fingerprint (which has 160 bits / 20 bytes) but simply part of it.

@_date: 2012-08-14 05:26:55
@_author: Hauke Laging 
@_subject: Using a different OpenPGP card/subkeys with same master key 
Am Di 14.08.2012, 01:11:52 schrieb Olivier Mehani:
But the solution given there does not work?
So you first imported the public key, read the card via --card-status then. What is the output of "gpg --list-secret-key" afterwards?

@_date: 2012-08-17 17:16:27
@_author: Hauke Laging 
@_subject: how vulnerable is "hidden-encrypt-to" 
Am Fr 17.08.2012, 09:56:56 schrieb auto15963931:
start cmd:> LC_ALL=C gpg --list-packets test.gpg
:pubkey enc packet: version 3, algo 1, keyid 8E75E2184AD27C5B
        data: [4095 bits]
:pubkey enc packet: version 3, algo 1, keyid 0000000000000000
        data: [2046 bits]
gpg: anonymous recipient; trying secret key 0x25D4FD8B ...
You need the private recipient key in order to find out that key ID. It's the use of this option that you cannot get this information in another way.

@_date: 2012-08-18 04:24:21
@_author: Hauke Laging 
@_subject: how vulnerable is "hidden-encrypt-to" 
Am Fr 17.08.2012, 21:05:32 schrieb auto15963931:
That is right. --hidden-encrypt-to needs other recipients. But you may use ??throw-keyids or --hidden-recipient instead.
That's a bug in my MUA which is triggered by the email being encoded as ascii:
This bug (or rather: problem) has been discovered here on the list ? it occurs almost only in English emails. I have added a non-ASCII char to my text signature thus forcing a charset different from ascii. Thus the signature of this email should be OK.

@_date: 2012-08-18 16:48:22
@_author: Hauke Laging 
@_subject: how vulnerable is "hidden-encrypt-to" 
Am Sa 18.08.2012, 10:36:21 schrieb Daniel Kahn Gillmor:
I think these hints should be added to the documentation.

@_date: 2012-08-19 06:25:51
@_author: Hauke Laging 
@_subject: output of --check-trustdb 
I am trying to understand how the trust calculations work and I think I have made serious progress in that... ;-)
There are at least two things I have not understood yet:
1) Is it possible to have the ownertrust value shown with --list-keys? Validity can be shown. I had expected a parameter like show-ownertrust for 2) I do not understand the "signed" column in the output of --check-trustdb. I read something about that but it doesn't make sense to me. It seems generally difficult to find good information about that.
start cmd:> LC_ALL=C gpg --check-trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:  17  signed:  26  trust: 0-, 0q, 0n, 0m, 0f, 17u
gpg: depth: 1  valid:  26  signed:   3  trust: 0-, 0q, 10n, 8m, 8f, 0u
gpg: depth: 2  valid:   3  signed:   0  trust: 0-, 0q, 0n, 1m, 2f, 0u
Before someone asks: Yes, of course, there are a lot of test keys.

@_date: 2012-12-01 19:11:15
@_author: Hauke Laging 
@_subject: Keypad support for PC/SC card readers? 
Am Sa 01.12.2012, 17:40:04 schrieb Selene Feigl:
Does this refer to setting / changing the PIN or to PIN entry for regular card usage? GnuPG does not support setting / changing the PIN via PIN pad. Whyever.

@_date: 2012-12-02 01:19:41
@_author: Hauke Laging 
@_subject: Keypad support for PC/SC card readers? 
Am Sa 01.12.2012, 22:47:17 schrieb Selene Feigl:
There is an option for scdaemon which prevents PIN pad usage:
Is that in the config file?

@_date: 2012-12-03 12:41:10
@_author: Hauke Laging 
@_subject: Seperate RSA subkeys for decryption and signing or one for both? 
are there arguments for preferring either
a) having one RSA subkey for decryption only and one for signing only
b) having only one RSA subkey for both decryption and signing?
Do any problems arise with the smartcard if the same key shall do different

@_date: 2012-12-03 12:53:40
@_author: Hauke Laging 
@_subject: Gnupg-users Digest, Vol 111, Issue 2 
Am So 02.12.2012, 21:59:11 schrieb Len Cooley:
What do you mean by keep? Not to delete the private keys?
If you have not needed these keys for years then it is improbable that you will need them in the future. But the other way round: Is there any good reason to delete private keys which have been used?
You should (if you haven't done so yet) create and publish revocation certificates for the oly keys stating that you have a new key (mentioning the new key ID at best).

@_date: 2012-12-04 14:14:34
@_author: Hauke Laging 
@_subject: Seperate RSA subkeys for decryption and signing or one for both? 
Am Di 04.12.2012, 13:19:11 schrieb Hubert Kario:
I remembered having read something like that. But does this refer to signing only? Are decryption keys not affected by that? The advantage of separate subkeys would be then that the non-used up key could keep active longer. That may be an argument against signing emails by default ;-)  or at least for longer signature keys.

@_date: 2012-12-08 18:28:37
@_author: Hauke Laging 
@_subject: corrupted trustdb 
Am Sa 08.12.2012, 10:07:28 schrieb Stephen Montgomery-Smith:
That sounds a bit strange to me. What exactly is "fails to work" supposed to mean? It's a huge difference whether
a) a key cannot create good signatures
b) a key (and thus its signatures) is not trusted
You can easily set the trust level for a key:
gpg --edit-key 0x12345678 trust
But that affects your local installation only. That gpg --export-ownertrust fails may be a hint that the file is corrupted. You could delete / rename it and run gpg --update-trustdb afterwards.

@_date: 2012-12-13 02:21:06
@_author: Hauke Laging 
@_subject: A few newbie questions, I'am doing this right? 
Am Mi 12.12.2012, 19:28:18 schrieb Roy Sindre Norangshol:
"Best practice" is often subjective.
I would add signing ability at any rate and (depending on the circumstances perhaps) even encryption. This allows you to make very secure signatures. This is very useful for a key policy document (--set-policy-url).
If you do not have another key another key which is more secure then your mainkey allows you encrypt data more safely which from time to time can be You can put your private mainkey on your website. A passphrase like 02NWL7YLKTa9uUhosA is harder than the key itself (at 2048 bit). Just never enter the passphrase in an unsecure system. And don't forget ist. :-)
Full disk encryption does not make a system secure. Get a safe boot medium. (And store it physically secure... ;-) )
Security is much better with a card reader which has a PIN pad.
This can be shown by extending the expiration date of existing keys, too. One argument for expiration dates is that they stop others from using your key if you have lost the private (main) key. I use a time limit of one year.
This has nothing to do with the expiration date, does it?
The real danger should be online attacks. I would not consider a system secure which is used for WWW or email.
Is roy.sindre at norangshol.no a private address? In general I would not mix private and business addresses within a key.
One more reason to create different mainkeys. Subkeys are not bound to UIDs. Both subkeys and UIDs are bound to the mainkey. And what if someone wants to send encrypted mail to your work account? I do not see any advantage in mixing the IDs (and environments), just problems.
Right. The WoT refers to mainkeys and UIDs only.
Further recommendations for a "proper setup":
? add a UID without email (just your name and a comment; this will be valid ? configure a preferred keyserver (--default-keyserver-url)
? configure a policy URL (even if you write the real document later; --set-
? configure your cipher and digest preferences (--default-preference-list)
? don't make non-local (lsign) certifications before you have finished your certification policy
? If you create two keys then create your work key with your personal key as designated revoker
? After key creation make small slips of paper with your name, email and fingerprint and always have some with you, like

@_date: 2012-12-13 10:43:56
@_author: Hauke Laging 
@_subject: Same key on different smart cards 
Am Do 13.12.2012, 08:43:53 schrieb Richi Lists:
I have not checked that but I don't think so. Wouldn't make sense. When using key A, why should gpg-agent care, where key B is stored?
What do you want? The signing key on one smartcard, the decryption key on the other? If so, why have you stored both keys on the same card?
That is a different problem. This is not directly supported by GnuPG but possible by a workaround: After changing the smartcard you can delete the secret keys and register the smartcard afterwards. Then the card reference is

@_date: 2012-12-13 13:10:35
@_author: Hauke Laging 
@_subject: A few newbie questions, I'am doing this right? 
Am Do 13.12.2012, 11:03:07 schrieb Roy Sindre Norangshol:
Sure you will. But that has nothing to do with my argument. There are arguments against giving the main key decryption capability (because you do not control what is encrypted for this key). But as you completely control which signatures you make I don't think there is any serious argument against signing capability.
OK but you unnecessarily limit your benifit of this higher security to certifications. Why?
I have a SCM Microsystems, Inc. SPR532 PinPad SmartCard Reader. I have never had problems with it. It seems to me that this is a popular product among GnuPG users. This is the only card reader I have used so I cannot compare it to others.
Doesn't replace a PIN pad...
They will not be able to steal the key from the stick, that's correct. But the attacker is capable of using the stick without limit.
Unfortunately (I don't know the reason for this policy difference) the same is true for PIN pads and encryption. But for signatures the damage can be I don't understand the question. The expiration date is relevant for the public keys only. OpenPGP applications refuse to encrypt for an expired key. But you can always use it for decryption.
Of course. That's why you create a key with subkeys which have limited security. That is perfectly OK. The key security has to meet the key usage and it should be well known to anyone who is affected. The aim of keys is not to increase the security requirements for the respective application.
You lose the certifications for this UID which may damage your position in the Web of Trust.
I don't see that risk. Why should you not use OpenPGP or use it less just because you have an additional UID? Or because your key has a policy URL, preference settings and a mainky with signing ability? The only possible problem I can imagine is that you fail in creating such a key (which is very improbable IMHO). But after creation all that does not make a relevant difference in everyday use.
No. You are capable of generating a new subkey for encryption but you cannot generate one which is dedicated to work. Usually the newest subkey (the one with the newest self signature) will be chosen by all senders (both to your private and work account). The UID bound preferences don't cover the subkey to be used, just the symmetric cipher.
I still suggest that because I promote all keys to have this structure. So even if especially you don't have to be afraid of problems you can still be an example for others.
I am not sure what you mean by "fetch signatures". You can have them verify and publicly certify your key, that's not a problem. And you can verify their keys and even certify them: either locally or regularly as long as you don't export your signature to anyone.
My general advice is to create a dedicated key for local signatures because it is quite unconvenient to always have to use the real mainkey in a secure environment. My strategy is: Use the lsign key for making other keys valid quickly (just for yourself) and use the safe mainkey for active participation in the Web of Trust.
I would guess that your thinking has not brought up a single good reason for sharing one key with personal use and work.

@_date: 2012-12-16 06:03:42
@_author: Hauke Laging 
@_subject: A few newbie questions, I'am doing this right? 
Am Sa 15.12.2012, 15:07:48 schrieb MFPA:
I don't think that makes sense. There is no general difference between a mainkey and a subkey. Why should there be a difference in the damage whether the one or the other is compromised?
The real difference is the security level, at least for those who use offline mainkeys. The security level is the amount of effort by an attacker in order to compromise your key. But why should one prefer a compromised subkey over a compromised mainkey if both are on the same security level? Think of two keys. One everyday key with a highly secure mainkey and one key which is completely kept at high security level. How is a compromised offline mainkey worse that a compromised high security subkey?
The practical difference is that probably most people don't have a high security key so limiting the mainkey's capability set limits their options (without increasing security). With a compromised mainkey it shouldn't be a problem to create a certificate with a modified capability set anyway. I don't know how keyservers and GnuPG react to such a change, though.
That's right but makes the whole thing even more complicated ? without explaining what the advantage should be. And complicated is bad as understanding is critical to the practical value of crypto. The concept of a more secure mainkey is relatively commonly known.
That was not precise enough by me. That (I though) obviously referred to decryption. Once unlocked the OpenPGP card does as many decryptions as you want. I do not see any reason for that. It cannot be the precious storage of one more flag. And nobody would be forced to use this feature.
That's true for Germany, too, but I would not call such a "depricated" name "invalid". The person can still be identified by the old name.
In that case it makes sense IMHO only if the certification procedure (for the "real" key) is somewhat complicated because the key owner follows a good certification policy.

@_date: 2012-12-18 01:06:07
@_author: Hauke Laging 
@_subject: A few newbie questions, I'am doing this right? 
Am Mo 17.12.2012, 23:37:33 schrieb MFPA:
No. Allowing(!) you to do so would be convinience. Even making this the default may be considered such. Forcing(!) you to act this way is far from a positive attribute like "convenience". Enforcing a reduction of security is in a security context strange at best.

@_date: 2012-12-20 23:04:47
@_author: Hauke Laging 
@_subject: signature state wording: good, valid, trusted 
I just tried to check what the "correct" (i.e. established) wording for the difference between successful signature validation and the (trust related) validity of the signing key is.
My guess was "correct signature" vs. "valid signature".
I had a look at the /usr/share/doc/packages/gpg2/DETAILS file. And now I am confused. It says that both GOODSIG and VALIDSIG refer to the success of the purely technical signature validation with the public key. So "valid" in the context of signatures seems to mean something different from "valid" in the context of keys. Which is not good in general but however.
The I read in that file:
TRUST_UNDEFINED TRUST_NEVER     TRUST_MARGINAL  [0  []]
TRUST_FULLY     [0  []]
TRUST_ULTIMATE  [0  []]
    For good signatures one of these status lines are emitted to
    indicate the validity of the key used to create the signature.
which is coherent to what I wrote above. But at the end of that block it says:
Note that we use the term "TRUST_" in the status names for
historic reasons; we now speak of validity.
OMG. Now the term "valid" / "validity" refers to both verification success and the trust state of the signing key? I guess that is really bad in terms of understanding. And the whole OpenPGP subject is already hard enough to understand for new users. I am writing information documents for new users thus I am very interested in getting this right.
The best explaination for all I know now (and have stated above) is that the term VALIDSIG simply was quite a bad choice (but impossible to change) and that "valid" ? despite of the exception VALIDSIG ? is used for the trust state both with keys and with signatures. So we have (besides bad and expires signatures, of course) "good" signatures which can be "valid" signatures. Can you confirm this?
BTW: It is probably not a GnuPG specific term but I consider "ownertrust" to be a bad choice, too, because it simply isn't that. The value is key dependant and may vary between keys with the same owner (due to the key's security level or the respective key's certification policy).

@_date: 2012-12-23 19:23:42
@_author: Hauke Laging 
@_subject: OpenPGP Authentication Protocol? 
Am So 23.12.2012, 12:01:25 schrieb Nicholas Cole:
SSH? :-)

@_date: 2012-12-23 22:42:20
@_author: Hauke Laging 
@_subject: OpenPGP Authentication Protocol? 
Am So 23.12.2012, 16:31:01 schrieb Daniel Kahn Gillmor:
Is that different from "pure" SSH keys or even X.509 client certificates? Why should a session protocol define which keys a user should trust?

@_date: 2012-02-01 16:47:12
@_author: Hauke Laging 
@_subject: PGP/MIME use 
Am Mittwoch, 1. Februar 2012, 01:04:57 schrieb Robert J. Hansen:
Of course not. I just don't believe that there are many examples of this type out there. To me a serious user is one who actively signs, encrypts, and/or verifies data and knows what he is doing. He has created a key and verified at least one. Everything else seems like special use to me.
That's not what I would call a serious user. Counting that way some big distributors would just have to add Enigmail to their (graphical) default installation and to you the numer of Enigmail "users" would get boosted by a factor of 100 without any real change.
That's not true for a certain quite popular OS. How many Windows users install GnuPG without Enigmail? Given the huge difference in Linux and Windows users this affects the calculation a lot.
Knowing is not the point to me.
The world (at least the part I am familiar with) relies (implicitely) even more on the integrity of a message than on trust. If you get an important information, question or order and have doubts about the integrity of the message then you will do some checks, no matter how much you trust. Of course, doubts are much lower today than they should be. That's how a part of online crime works.
On the other hand is the proof of the integrity of a message often enough even if you do not know the person. Quite often people have to make manual signatures without being knows to the person who demands for that. Often the content is less important than the possibility to hold someone responsible for Another point: I get most of my (both private and professional) emails from people I know.
Right. I would put it this way:
A signature cannot raise the trust in a message content above the trust in the sender / signer. But a missing signature can (and usually will) lower the trust in the message content below the trust in the (non-proven) sender.
And which of these scenarios is more probable? Who will after starting to sign emails start to send emails to people he is not familiar with? The first szenario is an improvement for you, the second does not make a difference (except for some wasted bandwith). Leaving out the cost it would not make sense to do without signatures.
Which is BTW not so easy. Many people use webmail. And there are reasons for not importing private keys onto work PCs. I am often too lazy to plug in the smartcard reader. But in the signature I apologize for not signing the mail. ;-)  And if the content was important I would use the smartcard, of course.
You probably wouldn't even have to because everyone who is in regular contact with you would know that. On the other hand: Signing in a web forum seems kind of extreme (and unsafe with respect to breaking the signature by automatic text formatting). :-)
Would not make much sense to use the name but not sign it, though.
The ability to hold someone responsible for his messages (which usually requires a signature but a signature is not enough to ensure that) is not the same like trust but an important point, too.

@_date: 2012-02-01 22:14:33
@_author: Hauke Laging 
@_subject: PGP/MIME use 
Am Mittwoch, 1. Februar 2012, 19:37:56 schrieb MichaelQuigley at theway.org:
And you perfectly fit the description I gave for "serious users" from my I don't doubt that. I just don't understand why someone who has understood the concept and is capable of validating keys of others, encrypting, decrypting and signing should not use that technology for his email (neither professional nor private). The people I know who are interested in security technology are generally interested in spreading this technology (not limited to OpenPGP).
Thus I assume that you are an exception, whatever your reasons may be.

@_date: 2012-02-01 23:34:12
@_author: Hauke Laging 
@_subject: PGP/MIME use 
Am Mittwoch, 1. Februar 2012, 23:19:43 schrieb MFPA:
I give training courses about cryptography in a German party and am involved in the discussion whether and how we should use it in our administration. Thus I have some experience with (mostly) "normal" people (no IT geeks). My experience is that
a) most people don't care at all (which probably everyone here can confirm...)
b) the other ones say that it's a useful technology but they do not use it due to either their software not supporting it or (more important) their personal lack of knowledge
c) I have never encountered someone saying something like "I know how it works, I use it for software distribution and backups but I have never used it for email".
The probable main difference to your "plenty of things" is that this is considered useful (for email!) by many people (many more than capable of using it). Thus it seems quite improbable to me that among those few who are capable of using it there are many who do not find it useful (for email).

@_date: 2012-02-01 23:53:12
@_author: Hauke Laging 
@_subject: PGP/MIME use 
Am Mittwoch, 1. Februar 2012, 17:19:08 schrieb Robert J. Hansen:
My description does not select for email users only but also covers your examples. We are not talking about "primarily" but about "only".
Depends on what you are thinking about. Of course, it is interesting to know how many kernels are out there. But it is also interesting an deserves being looked at seperately how many people have an "active", "planned" interaction with their kernel. Something like compiling it themselves, compiling modules for it, deactivating or configuring modules, configuring the kernel via command line parameters, saving an old kernel version as fallback.
I apologize if anyone had the impression that I used your quote wrongly (but why should I?). The point is that you said nothing about Windows which due to its market share cannot be ignored. And that has no relation to the context of your quote.
I do not see how relevance could be bound to knowing what happens if this has no influence to what happens at all. Users who need a software (whether they know that or not) are relevant to me, too. But those users are relevant for GnuPG's verification feature only because they never use anything else.
To me it's important for the assessment of a user whether ot not he causes any data in the world to be changed (because he signs something, encrypts something, something is encrypted for him). One groups makes just a quantity difference to IT, the other one a quality difference.
The reason why most people do not use Enigmail (or something similar) is *not* the installation of GnuPG. You can easily install GnuPG without any clue how to use it. The main reasons are the lack of felt need (whether those people on average feel a need for update rpm signature checks?) and the lack of knowledge. Thus only comparing the GnuPG users with knowledge to the Enigmail users makes sense to me.
I already did so:
However, we are not discussing something important. You said that Enigmail users were just a small share of GnuPG users. This share depends on the part of GnuPG users considered. Obviously our opinions about that part differ but the decision who is "right" has no consequence at all.
But you don't send email to this list *because* you sign your email. You don't even sign your email to this list.
Right. But for nearly none of those cryptography is the reason for contaction others. In other words: If email cryptography becomes more common there is no reason to expect more email from unknown people (due to this effect).
OK but if someone considers his opinion about something he is not familiar with superior to the uniform opinion of some who are familiar then I would consider him an idiot (not stating that idiots cannot be a problem for someone innocently accused).
That's the sense of non-signing. What's the sense of using your name? Creating problems for yourself? Accepting those problems in order to make the offense more interesting to the public?

@_date: 2012-02-02 00:08:32
@_author: Hauke Laging 
@_subject: PGP/MIME use 
Am Mittwoch, 1. Februar 2012, 22:38:57 schrieb Robert J. Hansen:
I knew that paper (due to one of your emails). I read it again now. It has quite little to do with my "question".
My question was NOT "Why do so few people use email cryptography"? But that is the question this paper wants to answer.
Some points from the paper:
? It is (mainly) about people not familiar with GnuPG in some context different from email.
? One of the two most IT capable people being interviewed does not even know how to make signatures.
? Most or even all of those users did not have an environment which creates signatures or encrypts automatically. I have not read how they did it; I assume they used some program not integrated into their email software and had to use the clipboard for transferring the data.
? Most of the paper is about encryption. None of the interviewed people denied the sense of encryption in certain cases.
I do not see how to get valid conclusions from non-IT people using bad software for IT people free to chose their software.

@_date: 2012-02-02 01:30:45
@_author: Hauke Laging 
@_subject: PGP/MIME use 
Am Donnerstag, 2. Februar 2012, 00:27:04 schrieb Robert J. Hansen:
You are so right. You like quotation contexts, don't you?
See the ""?
That's not even nearly the question they are answering. For none of the users they mention that he uses GnuPG-like software in a context different from email. At most one of them "understands the concept" (as a whole, not just a part of it, i.e. encryption). They don't say that explicitly but we have to assume that everyone else has neither understood the feature signing nor is using it.
How much do these people have in common with admins and lawyers in your I have never heard or assumed something different.
Thus we have no reason to assume that any of them is familiar with GnuPG. Our point is people familiar with GnuPG who do not use email cryptography. This is the other way round: People using email (most of them) with no information about their other background.
No, it also makes sense reading "He did not see a problem in not having a tool for automatic processing as he would not have used it anyway as he distrusted such plugins".
Furthermore "available" is not the same like "using".
There are other quotes which make sense only if such plugins are NOT "He (Abe) estimated that encrypting every e-mail message would
add another hour to his workday unless it was automated."
"He (Abe) ?gured this man has an automated system for encrypting e-mail"
"I (Jenny) think he probably has some automated system. That everything he sends gets encrypted automatically. I can?t believe he?s encrypting manually every time. But to me, it?s like?OK, if it?s automated??ne."
"If it was encrypted on his computer and he sent to my computer, automatically
encrypted or decrypted it??ne. Then, encrypt everything you want."
"Arguably, some of the stigma associated with using encrypted e-mail was tied to the overhead of the system ActivistCorp used. Where appropriate, some of the process can be removed or automated."
The same one saying "most people see this as more work and want things
simpler" and "I?m actually considered a ?techie?". "Simple" is in the eye of the beholder. It may even have referred to the point that he just encrypts financial data which he regularly synchronizes with others.

@_date: 2012-02-22 13:53:27
@_author: Hauke Laging 
@_subject: verify TrueCrypt 
Am Mittwoch, 22. Februar 2012, 10:15:50 schrieb Marco Dorigo:
That description contains an "error". And you misunderstood something:
"Sign the imported key with your private key to mark it as trusted". "To" mark ist trusted, not "and" mark it trusted. The trust you have set is something completely different (regarding the web of trust).
The "error" is: "If you skip this step and attempt to verify any of our PGP signatures, you will receive an error message stating that the signing key is The error message just tells you that this key is not considered valid yet. It does tell you that the signature has been made by that key. And that's all you need. It usually does not make much sense to sign a key which you have not checked. My advice: Either delete the signature or use the signing key for "worthless" signatures only (and in a way that makes sure you are not I guess that the signature file is broken. Download it again. If the signed file were broken then the error message should say that the signature is What is the size of the signature file and what is the type of the signing key? I assume that if the signature file is incomplete then somebody here can tell already by the length.
We need the output of
gpg --list-keys
(for the TrueCrypt key only)

@_date: 2012-02-29 04:27:57
@_author: Hauke Laging 
@_subject: trust, ownertrust, secret keys, --status-fd, --trusted-key 
after playing around with unfamiliar gpg features for hours I am confused now. You may already have guessed from the subject...
Those hours ago I believed to have understood the concept of trust and ownertrust. I don't use the WoT thus I never cared much about ownertrust. Important to me was only that gpg considered keys valid when checking signatures. My understanding was that keys are valid if
1) you have their secret key
2) they are marked trusted by --trusted-key (important to me due to offline mainkeys and smartcards)
3) they are signed by a trusted key
4) their ownertrust is set to ultimate
My confusion started when playing with --status-fd and reading the DETAILS file. It says:
TRUST_UNDEFINED TRUST_NEVER     TRUST_MARGINAL  [0  []]
TRUST_FULLY     [0  []] TRUST_ULTIMATE  [0  []]
For good signatures one of these status lines are emitted to
indicate the validity of the key used to create the signature.
Now the problems arise. To me these are ownertrust values. But a signature can IMHO be valid or invalid only (depending on its key's signatures and the configuration). What is needed for a valid signature, TRUST_ULTIMATE? This is what I get with successful verifications.
LC_ALL=C gpg --list-options show-uid-validity --list-sigs
shows me [ultimate], [  full  ] and [ unknown] only (and [ expired]). That may be caused by me not using the WoT. Is this "full" the same as with ownertrust? If --completes-needed is set above 1 then a key can be signed by a fully trusted user and is then what? "[  full  ]" but not valid?
Perhaps you can point me at some good online recource for understanding this. I had a look at gnupg.org but the explanation I found was not in much detail.
I just noticed that calling gpg once with --trusted-key writes to the trustdb. If you leave out that option in the next call the key still has ultimate trust (even if the secret key is not available). That does not make sense to me. If I want a permanent change then I change the trustdb (or put this option in the config file). Furthermore I consider a verification a pure read-only operation. If this behaviour is not considered a bug then I recommend a suitable hint (read: warning) in the documentation.
There's another problem with --trusted-key or its documentation. It says:
"Assume  that  the specified key (which must be given as a full 8 byte key ID) is as trustworthy as one of your own secret keys."
Due to this description it does not make sense to me that this option changes the calculated trust for a key which has a secret key available. Perhaps this is not intended but just a result of the empty trustdb (--check-trustdb doesn't change that though). Either the documentation should be changed or the secring be checked (in addition to the trustdb).

@_date: 2012-01-07 03:30:39
@_author: Hauke Laging 
@_subject: Encryption with key ID 
Am Samstag, 7. Januar 2012, 01:41:48 schrieb Remesh_Chandra at dell.com:
gpg --encrypt --recipient 5XXXXX11 file.txt
gpg --encrypt --recipient "ABC DEF GHI" file.txt
gpg --encrypt --recipient D44C6A5B71B0427CCED3025CBD7D6D27ECCB5814 file.txt
(with the key's fingerprint instead of mine, of course)

@_date: 2012-01-21 16:41:29
@_author: Hauke Laging 
@_subject: 1024 key with 2048 subkey: how affected? 
Am Freitag, 20. Januar 2012, 21:15:29 schrieb Chris Poole:
Yes. If the main key is compromised then
a) certifications for other keys can be forged (of course, anyone being attacked by that could see that the key whose certification he is going to rely on is that short)
b) new subkeys for that key can be created
If the attacker is capable of a man-in-the-middle attack then he can send the compromised key when the attacked person makes a keyserver update. This way noone would notice the manipulation (not even the key owner when checking what's on the keyservers). Afterwards data would be encrypted to the wrong key and signatures by the attackers subkey would be accepted.
Another attack szenario is that the whole key can be revoked when you need it. People do not send you important, urgent information because they do not have a valid key to encrypt to. Or you have to sign something in time but do not have a key which is accepted be the recipient.

@_date: 2012-01-22 00:10:11
@_author: Hauke Laging 
@_subject: Using root CAs as a trusted 3rd party 
Am Samstag, 21. Januar 2012, 19:12:15 schrieb Aaron Toponce:
IMHO that does not make sense. In the end you just certify that you trust the CA. Your certification makes a difference just to those who do not trust the root CA (or do not know this certification path because the key servers don't know it).
The clear solution would be that you certify the root CA's certificate.

@_date: 2012-01-25 01:17:44
@_author: Hauke Laging 
@_subject: Forcing use of software pinentry instead of hardware pinpad 
Am Dienstag, 24. Januar 2012, 22:45:10 schrieb gnupg at lists.grepular.com:
scdaemon knows the option --disable-keypad

@_date: 2012-01-25 02:24:16
@_author: Hauke Laging 
@_subject: Using root CAs as a trusted 3rd party 
Am Dienstag, 24. Januar 2012, 22:10:35 schrieb Faramir:
You completely change the semantics and use of the web of trust. IMHO that cannot be good.
Charly can check all keys of the unknown signatures. After downloading Trent's key he finds Bob's signature and can make a decision about the trust path.
Network systems like the web of trust can only work of all (or: most) people act in the same way. Do you suggest that every key gets 90 instead of (I guess) today's 10 because everyone signs his (trustedly) indirect contacts? Without any chance to tell direct and indirect signatures apart?
What about revocations? Let's assume that Trent revokes his signature for Alice. Is Bob going to check that regularly? Probably not. Then Charly would trust the key due to Bob's signature though Bob himself does not trust it any more! At least not when thinking about it. And as Bob's signature does not even tell a third party which direct(?) signature made him certify the key, the third party cannot check whether the respective certification has been This behaviour would kill both trust depth and signature counting. A configuration like "Trust the key if it has five maginally trusted certifications" does not make any sense any more if one signature can become five that easily by everyone making indirect certifications. How can Bob know whether Trent has really verified the key or just certified it because he found a signature by Peter?
This is neverending. In the end probably every key in the wild would be certified by ALL active keys. Why? Because most OpenPGP users should be connected somehow (no matter how many levels in between) and the result of such behaviour would be a flat signature space. Terrible. The value of a signature would drop to nearly zero (without checking for a policy URL and the policy description there).
Is that what you want?
This would not be a problem at all if the meaning of a certain signature would be clear. As I mentioned several times in earlier threads I would love to have a standard set of detailed signature notations for explaining the meaning of a certification (because applications could be configured to treat standardized notations differently). One of the notations could be direct vs. indirect.

@_date: 2012-01-25 13:52:27
@_author: Hauke Laging 
@_subject: Creating a key bearing no user ID 
Am Mittwoch, 25. Januar 2012, 05:10:34 schrieb John Clizbe:
I think your description of the situation is not correct.
IIRC there is no single technical issue which is regarded as a problem about which it is unclear whether it can be solved.
The dispute is mainly about the interpretation whether is makes sense to offer such a feature given the amount of addresses that cannot be protected: This would only work for addresses which cannot be found by enumeration. Such addresses are not "nice". mailinglisten at hauke-laging.de need not be protected that way. This feature would require something like mailinglisten--noenum-yvsYiP9y at hauke-laging.de against spammers,
mailinglisten--noenum-zTTgFzNHU3RnkFyAxJuYMbs7 at hauke-laging.de against real threats (government agencies in e.g. China).
The technical questions would have to be answered but could be rather easily. But why write specs if noone is willing to implement it, why write code if it would not be accpeted, why point at IETF though the other way round is expected there?
You may be right in that it makes little sense to endlessly repeat something. But is it a serious difference whether this refers to an unsolved technical problem or to an opinion.

@_date: 2012-01-30 22:03:38
@_author: Hauke Laging 
@_subject: Clearsigning on Windows 
Am Montag, 30. Januar 2012, 21:57:41 schrieb Belleraphone:
You are probably the only one who knows which file(s) you want clearsigned.

@_date: 2012-01-30 22:49:03
@_author: Hauke Laging 
@_subject: Clearsigning on Windows 
Am Montag, 30. Januar 2012, 22:12:13 schrieb Belleraphone:
I am not sure whether I understand what you mean.
--clearsign is usable for text files only not for binary files. Those need
--sign or --detach-sign.
It seems not to be possible to make a single signature for several files at once whose names are read from STDIN (or a file). But you can give several files on the command line:
gpg --armor --output signature.asc --detach-sign file1 file2 file3
The result can be checked by
gpg --verify signature.asc file1 file2 file3
In that case you have to check all files simultaneously.
If you have a big lot of files to be signed then you can a) either create an archive file (by whatever archieve application you like and which supports reading file names from a file) and sign that single file
b) use scripting (which I don't know anything about under Windows) to
1) either create the long command line
The Linux (bash) way would be:
gpg --armor --output signature.asc --detach-sign $(cat filelist.txt)
2) call gpg for each file (which makes sense only without a passphrase od with passphrase caching (gpg-agent)
The Linux (bash) way would be:
while read filename
  do
  gpg --armor --detach-sign "$filename"
done < filelist.txt

@_date: 2012-01-30 23:02:55
@_author: Hauke Laging 
@_subject: Clearsigning on Windows 
Am Montag, 30. Januar 2012, 22:53:56 schrieb Belleraphone:
"It doesn't work" without any explanation what exactly you have done and what "It doesn't work" means precisely does not make it easier to help you. You have already been told the necessary command by Werner.

@_date: 2012-01-31 20:25:44
@_author: Hauke Laging 
@_subject: PGP/MIME use 
Am Dienstag, 31. Januar 2012, 19:46:05 schrieb Robert J. Hansen:
Do you mean "hidden" installations (used unnoticedly by a distribution's update tool in the background) or actively planned instattations ("I need It is hard for me to believe that a serious user of GnuPG does not use it for email. I use it at work for administration purposes (so without email) but for most people I know it's the other way round: They use it for email only.
I admit that I do not use Thunderbird but is it's share among GnuPG users so much smaller that among all users altogether?
But you admit that this depends on the current situation (described by: hardly anyone uses it)?
I hope that the law will pledge big companies in the near future to sign their emails and offer encryption at no additional cost. Then most normal users will encounter cryptography regularly and thus the number of people who use it should increase a lot.

@_date: 2012-07-06 21:05:55
@_author: Hauke Laging 
@_subject: Documentation error: --allow-freeform-uid not needed? 
I just noticed that it is possible to create UIDs without an email address without giving the option --allow-freeform-uid. The man page says:
Disable  all  checks  on the form of the user ID while generating a new one. This option should only be used in very special environments as it does
not ensure the de-facto standard format of user IDs.
Google did not solve my confusion. This seems not to be related to --expert (I tried with --options /dev/null)

@_date: 2012-07-09 14:26:38
@_author: Hauke Laging 
@_subject: Documentation error: --allow-freeform-uid not needed? 
Am Mo 09.07.2012, 09:57:42 schrieb Werner Koch:
OK but what does --allow-freeform-uid do then? Makses sense to add this information to the documentation IMHO.

@_date: 2012-07-09 23:56:11
@_author: Hauke Laging 
@_subject: why is SHA1 used? How do I get SHA256 to be used? 
Am Mo 09.07.2012, 17:45:37 schrieb Sam Smith:
Your key tells others what to do. For what you do yourself ("when I sign a message") you have to edit the config file.

@_date: 2012-07-10 00:53:43
@_author: Hauke Laging 
@_subject: Slightly OT: PGP/MIME verification fails with new KMail2 and 
I was just pointed at the problem that for the last months all of my signatures are supposed to be bad. I use KMail which shows both the emails I have sent and those I receive via this list as correctly signed. I just used Thunderbird (13.0) to check and TB claims even (most but not all) of the emails in my IMAP sent folder to have bad signatures. TB doesn't even recognize the received emails as signed (just shows an "attachment").
The problem seems to be newline-related. I do not waste time by filing a bug report for the wrong software... Thus maybe one of the MIME experts here can tell me who's wrong. The KMail behaviour seems to have changed from KMail to KMail2. KMail2 successfully verifies the TB emails.
Thunderbird puts one more empty line between the body and the MIME seperator:
PGP: D44C 6A5B 71B0 427C CED3 025C BD7D 6D27 ECCB 5814
PGP: D44C 6A5B 71B0 427C CED3 025C BD7D 6D27 ECCB 5814
I can manually successfully verify emails from both clients. So obviously one of them feeds the wrong data into gpg (during signing or verification).

@_date: 2012-07-10 14:23:11
@_author: Hauke Laging 
@_subject: Slightly OT: PGP/MIME verification fails with new KMail2 and 
Am Di 10.07.2012, 08:43:55 schrieb Branko Majic:
A checksum is not neccessary, it's obviously not the same. KMail stores the files with \n line endings instead of \r\n. In order to successfully verify the signature I had to convert the KMail file to \r\n and to remove the \r\n (both) on the last line until I added a \n to my text signature.
I just checked the files after the conversion to \r\n. There were more differences (probably not relevant for this problem). The KMail file has an addidional line at the beginning:
Furthermore the KMail file has \r\n at the end of the last line, the TB file does not. But the signed part and the signature are stored identically.

@_date: 2012-07-10 16:19:18
@_author: Hauke Laging 
@_subject: why is SHA1 used? How do I get SHA256 to be used? 
Am Di 10.07.2012, 08:26:14 schrieb Sam Smith:
As Rob already mentioned: You need --personal-digest-preferences (which is just personal-digest-preferences in the config file). You put your favourite first, e.g.:
personal-digest-preferences SHA256,RIPEMD160,SHA1

@_date: 2012-07-10 17:15:55
@_author: Hauke Laging 
@_subject: why is SHA1 used? How do I get SHA256 to be used? 
Am Di 10.07.2012, 16:39:20 schrieb Laurent Jumet:
Yes, I do. Just tried.
Two possibilities come to my mind:
1) I created a signature using gpg only. Did you do that, too, or did you use some GUI or calling program (MUA)?
2) Are there conflicting statements in your config file? Maybe you can check by calling
gpg --options /dev/null --personal-digest-preferences SHA256 --detach-sign...
gpg --options /dev/null --personal-digest-preferences SHA256,RIPEMD160 ...

@_date: 2012-07-11 01:22:42
@_author: Hauke Laging 
@_subject: very cautious :-) 
gpg --options /dev/null --keyserver hkp://keys.gnupg.net --search-keys ...
gpg: external program calls are disabled due to unsafe options file

@_date: 2012-07-11 17:09:06
@_author: Hauke Laging 
@_subject: scope of standard authority (was: Re: How to "activate" gpg.conf 
Am Mi 11.07.2012, 16:54:27 schrieb Kristian Fiskerstrand:
Does it make sense that a standard overrides a user's decision to prefer security over compatibility (sure, you can still check afterwards what has happened but that can be difficult especially if gpg is not used directly but called by a MUA e.g.)? As someone stated here recently, he would rather not make a signature at all than one which he considers unsafe.

@_date: 2012-07-11 18:18:22
@_author: Hauke Laging 
@_subject: scope of standard authority 
Am Mi 11.07.2012, 11:13:46 schrieb Robert J. Hansen:
IMHO the second sentence effectively rewrites the first to:
"The entire point of a standard is to ENFORCE interoperation."
I don't see the benefit of forcing someone to something in a security context if the direction is not to more but to less security. The two cases are:
a) I try to send an email or sign a file. This fails with the hint that I have to correct my configuration. I then can decide whether to do that or not.
b) I believe to make signatures of type X or Y only. But in rare cases such a "standard feature" (which maybe not more than a tiny share of the users know about) makes me unawarely create one of type Z.
Who would choose (b) for himself and how big would the damage of getting there via (a) be for those?
It seems to me that --digest-algo does have its use case and that the documentation is wrong:
--digest-algo name
[...] --personal-digest-preferences is the safe way to accomplish the same
It's obviously not the same.

@_date: 2012-07-11 20:18:17
@_author: Hauke Laging 
@_subject: scope of standard authority (was: Re: How to "activate" gpg.conf 
Am Mi 11.07.2012, 13:57:58 schrieb David Shaw:
Is there any reason why known recipients should not be considered when signing only? I just noticed that gpg issues a warning if a recipient is given when signing only. But instead the public key could be used for hash selection. To avoid ambiguity this could fail if for any of the recipients the keys is missing. The calling application could check in advance which recipients have a key locally and only give those as recipients for the signing operation. As this is already done for encrypted signatures the required code should already be there.

@_date: 2012-07-12 06:09:44
@_author: Hauke Laging 
@_subject: why is SHA1 used? How do I get SHA256 to be used? 
Am Mi 11.07.2012, 23:13:00 schrieb vedaal:
So what?
A signature over a broken hash alone is worthless no matter what its timestamp says. If you want to prove anything by a signature at a time when the hash is considered broken you have to prove that the signature existed before that time. And this proof can obviously not be based on the broken hash.
Thus you have to sign all signatures you want to be able to use after the announcement that they are broken (which can, of course, come surprisingly) by another hash or rather you have to get them signed by a trusted third party if you want to use them against someone.

@_date: 2012-07-12 14:05:30
@_author: Hauke Laging 
@_subject: why is SHA1 used? How do I get SHA256 to be used? 
Am Mi 11.07.2012, 22:10:11 schrieb Daniel Kahn Gillmor:
But that is a problem only in that case that a collision algorithm is capable of creating (mostly ? some "random" data may be hidden in comments) useful data, isn't it?
I am not familiar with the collision algorithms. Is all the effort useless if the reasonable document is slightly changed? I guess so. Does it make sense to require every document which one is to sign to be slightly changed (even if it's just a "typo" but this change would have to be determined by oneself not by the other party) before signing?
But the problem of collision-resistance can be addressed organizationally, pre-image attacks cannot.

@_date: 2012-07-12 17:32:27
@_author: Hauke Laging 
@_subject: cert-digest-algo clarification 
Am Do 12.07.2012, 11:27:03 schrieb Sam Smith:
Why don't you simply have a look at the documentation?
--personal-digest-preferences string
Set the list of personal digest preferences to string.  Use gpg2 --version to get a list of available algorithms, and use none to set no  preference at all.  This allows the user to safely override the algorithm chosen by the recipient key preferences, as GPG will only select an algorithm that is usable by all recipients.  The most highly ranked digest algorithm in this list is also used when signing without encryption  (e.g.  --clearsign  or --sign).

@_date: 2012-07-12 17:58:20
@_author: Hauke Laging 
@_subject: cert-digest-algo clarification 
Am Do 12.07.2012, 11:39:44 schrieb Sam Smith:
And sets the value for non-encrypted signatures.
Into new keys. Existing keys need --edit-key 0x... setpref...
Yes. Overrides the order (but cannot make missing elements available).
 This information is (or rather can be) embedded in a key. Either by default-preference-list being defined at the creation time of the key or by --edit-key setpref.
Have you read the documentation about --default-preference-list?
--default-preference-list string
Set the list of default preferences to string. This preference list is used for new keys and becomes the default for "setpref" in the edit menu.
I don't find that unclear.
The personal-digest-preferences setting in the configuration of *other* users may override the setting you may have made in your key. Your personal-digest-
preferences setting is irrelevant for the signatures of others.
You should read the documentation for the commands showpref and setpref, try them (in combination with --default-preference-list) and see what happens.

@_date: 2012-07-12 18:39:19
@_author: Hauke Laging 
@_subject: cert-digest-algo clarification 
Am Do 12.07.2012, 12:11:11 schrieb Sam Smith:
"Appear"? Is that what the documentation says? Do you prefer telling us your guesses over reading the neccessary information?
This is true only if setpref is called without arguments.
Do you read what we tell you? How does this question fit to my statement (which you even quote)?
The personal-digest-preferences setting in the configuration of other users may override the setting you may have made in your key. Your personal-digest-
preferences setting is irrelevant for the signatures of others.
Stop trying to understand it from reading, you obvously have problems with that. Take two keys, give them different preferences, make encrypted signatures with different settings of personal-digest-preferences and have a look at the results.
As you have been told several times by several people (let alone the clear documentation): personal-digest-preferences is not to be seen by others.
--personal-digest-preferences is used with
--default-preference-list is used with

@_date: 2012-07-15 15:47:36
@_author: Hauke Laging 
@_subject: key search does not work with gpg2 
Am So 15.07.2012, 15:37:16 schrieb Klaus Layer:
gpg2 --keyserver hkp://109.230.243.87 --search-key 0xB973BA7B
I can't tell you whether that's a bug or a feature.

@_date: 2012-07-15 19:40:58
@_author: Hauke Laging 
@_subject: proposal: signature usage for offline mainkeys (secure policy 
until yesterday I considered the capabilities (signing, decrypting) of an offline mainkey irrelevant as it is usually never used for these operations and thus recommended to create offline mainkeys without explicit capabilities. This attitude has just changed. I would like to tell you why. I hope this is a new thought and useful to some readers (don't hesitate to let me know :-) ).
As some of you may remember I consider it important for a security infrastructure to know the meaning that a user gives its crypto tool(s). I can see that someone has e.g. a 2048 bit RSA key but I usually don't know whether this is an offline key (used in a highly secure environment only), a key on a smartcard or even a key which has been uploaded to a server for e.g. using crypto webmail.
AFAIK today there is no standardized way of describing the security and usage of keys and signatures. The best you can do is write a signature policy, sign it (with limited validity) and put its URL in your signatures (--set-policy-
url). But how can you be sure that the policy document is valid? Think of such a document for an insecure key. The document says something like "This key is rather insecure". The key gets compromised (without the owner noticing), the attacker writes a new document ("This is a very secure smartcard key."), signs it and replaces the old one by it.
My previous consideration was that the only solution for this problem was to have the others sign not only your key but your policy document, too. This has, of course, the serious drawback that is becomes quite hard to change this document. Then it came to my mind that offline storage of the mainkey usually creates two different levels of crypto actions which the mainky is capable of. By allowing a mainkey to sign (and encrypt) you get interesting new If the policy document is signed by the offline mainkey (by using 0x12345678! instead of 0x12345678) then its signature is very trustworthy. So you could create two documents: One describing the signature policy (which may change and easily be signed again by the mainkey) and one describing the key security which should never be changed (as this usually does not make much sense) and gets signed by those who certify the key (at best by their mainkey ;-) ).
On the other hand this offers the possibility of a higher security level for encryption thus reducing the need for a second key. But IMHO this introduces a serious risk of confusion so I do not generally recommend that.
Besides this possibility which is available by todays's tools I would love to see some standard there (for making this information machine readable): A simple XML definition and a corresponding set of signature notations which allow statements of useful precision about the usage and security of a key.

@_date: 2012-07-17 11:37:35
@_author: Hauke Laging 
@_subject: getting gnupg keys from old computer to new 
Am Di 17.07.2012, 12:15:29 schrieb Mika Suomalainen:
Was my first idea, too, but Rob's suggestion is much better as this covers neither the trustdb nor the configuration files or log files. There's not much useless stuff in that directory. Doesn't make sense to copy single files.

@_date: 2012-07-25 18:33:08
@_author: Hauke Laging 
@_subject: old vs new gnupg - encrypting files 
Am Mi 25.07.2012, 10:37:54 schrieb Chris Clifton:
Have you tried encrypting the file to the other one and your own key simultaneously? That might allow a better comparison of the difference between the two systems.

@_date: 2012-07-25 19:16:33
@_author: Hauke Laging 
@_subject: old vs new gnupg - encrypting files 
Am Mi 25.07.2012, 12:48:57 schrieb Chris Clifton:
You can give several recipients. The data is encrypted symmetrically (by AES e.g.) by a random key. This random key is asymmetrically encrypted to all recipients (or even to a passphrase). Thus an additional recipient increases the size of the resulting file slightly only.
gpg --recipient 0x12345678 --recipient 0x87654321 --encrypt ./my/file
See --encrypt-to.
This way you can check whether you can decrypt the data yourself at least.
Furthermore it would have been a lot more useful to get the full error message of your recipient instead of a simple "cannot".

@_date: 2012-07-25 21:42:04
@_author: Hauke Laging 
@_subject: GPG key to authenticate to SSH? 
Am Mi 25.07.2012, 21:19:08 schrieb Werner Koch:
Thus those few people who really have so many A-keys would simply not use this wildcard. Or they use both the wildcard and the current configuration so that they can tell gpg-agent which keys are the most often used so that these are tried first. Does gpg-agent currently care about the order of the entries?

@_date: 2012-07-26 00:48:06
@_author: Hauke Laging 
@_subject: old vs new gnupg - encrypting files 
Am Mi 25.07.2012, 17:17:15 schrieb Chris Clifton:
Do the same on the other system and have a look at the resulting encrypted files via
gpg -v --list-packets filename.dat.pgp
and check for differences in the outputs. I don't have a real idea yet what could be the problem but perhaps we are lucky with this general checking.

@_date: 2012-06-03 18:19:43
@_author: Hauke Laging 
@_subject: GnuPG 2.1 Windows 7, pinentry does not allow paste, 
Am So 03.06.2012, 07:46:41 schrieb L G:
man gpg-agent

@_date: 2012-06-04 17:22:05
@_author: Hauke Laging 
@_subject: no password needed to export secret-keys? 
Am Mo 04.06.2012, 10:27:00 schrieb Sam Smith:
The exported file is protected by the passphrase. That is similar to copying the secring.
If you want the exported file to have a different passphrase then you have to (make a backup of the secring and then) change the passphrase (--edit-key), export the secret key afterwards and then either change the passphrase back or overwrite the secring with the backup.

@_date: 2012-06-04 18:06:08
@_author: Hauke Laging 
@_subject: no password needed to export secret-keys? 
Am Mo 04.06.2012, 11:56:22 schrieb Sam Smith:
Please take care that you reply to the list.
You obviously have a completely wrong idea what a passphrase is used for.
A passphrase is (if used) needed for crypto operations which need the private key (the numbers). The passphrase just encrypts the key material, not the whole exported file. Importing and exporting are not crypto operations.
If you want to prevent others from importing or exporting keys then prevent them from accessing the files (a very common IT task that is not related to

@_date: 2012-06-16 19:54:46
@_author: Hauke Laging 
@_subject: GPG with GPUs 
Am Sa 16.06.2012, 08:15:05 schrieb Aaron Toponce:
Are these files huge? It's hard for me to believe that this takes seconds. What I would easily believe is that the system gets an entropy problem. The delay would not be related to CPU performance then. So maybe a hardware RNG improves your situation.
This reminds me of something I never dared mention of this list because obviously certain people may freak out...
If the same file is quite often encrypted, decrypted, encrypted again one might question the value of generating new session keys every time.
I would really like a feature like --override-session-key but not for decryption but encryption. OK, this alone would not solve your performance problem. Additionally it would be required that the session key packet could be reused. This raises the question whether it is possible to create just the encrypted data packet (without the pubkey enc packet). This is not possible by gpg I guess but perhaps by gpgme. Shouldn't be hard to add an option which does this to gpg as no new operation is required but just the leaving out of If you get the data part created you can combine it with the old pubkey enc packet. Symmetric encryption can easily be optimized for such hardware but considering how many MiB per second you get through a simple CPU based hard disk encryption I really doubt that this may be a bottleneck.
So you would save the time waiting for entropy and the time of the asymmetric encryption. This would leave optimization potential for the signing process (if you sign the files).

@_date: 2012-06-17 19:26:27
@_author: Hauke Laging 
@_subject: GPG with GPUs 
Am So 17.06.2012, 08:04:09 schrieb Aaron Toponce:
start cmd:> time gpg --encrypt --sign 200k-file Sie ben?tigen eine Passphrase, um den geheimen Schl?ssel zu entsperren.
Benutzer: "Hauke Laging "
2048-Bit RSA Schl?ssel, ID 0x3A403251, erzeugt 2010-03-04 (Hauptschl?ssel-ID real    0m0.143s
user    0m0.086s
sys     0m0.008s
start cmd:> time gpg --encrypt 200k-file real    0m0.024s
user    0m0.013s
sys     0m0.005s
This are the result (with a caches passphrase, of course). It's the same for a zeros file and a urandom file. And this is on a power efficient CPU... (E-450, which I guess doesn't have AES acceleration) probably without parallelization.
So there's obviously a serious problem with your setup. A problem slowing the process down two to three orders of magnitude which will hardly be solved by adding a GPU.

@_date: 2012-06-18 07:07:54
@_author: Hauke Laging 
@_subject: conditional config file entries (bound to e.g. sender and recipient 
has there already been a discussion about it whether it would make sense to have conditional entries in the gpg config file (like e.g. SSH for different Depending on the key to which is encrypted, the key by which is signed and maybe even the application which calls gpg different settings may be selected. This is quite obvious with the policy url setting. If no single document covers all keys then it is preferable to set this value in dependency of the signing key.

@_date: 2012-06-19 00:38:16
@_author: Hauke Laging 
@_subject: decryption trouble - primary/subkey confusion, 
Am Mo 18.06.2012, 15:37:27 schrieb Michael Hannemann:
That means nothing. I can send you an encrypted file without even having a key Have they signed the encrypted files they have sent to you?
This is the error message they sent to you?
That's not the question. The question is whether you encrypt to the correct key (and how you KNOW it's the correct one).
What is the output of
gpg --with-colons --list-keys 0xTpTpTpTp
? This is about the second but last field for pub and sub only. Output for my key for example:
These are the keys' capabilities. The main key can certify (always), sign and authenticate. The subkeys can be used for encryption, signing and authentication, each one only. If you encrypt to the ID of the main key then gpg recognizes the encryption subkey and uses it instead.
If your (main) key is really correct then I guess there is a problem with the subkeys. Maybe you have an old version of the key containing a subkey they don't (and can't) use any more. So you should check that you have the newest version of the key.
You can enforce the usage of the main key though:
gpg --encrypt --recipient 0xeccb5814\!
(the \ is due to history expansion in the shell; I am not familiar with that, maybe the quoting is not necessary)
This works only if the main key has the encryption capability.
When reading my mail just before sending I noticed that your above output reveals that the main key has no encryption capability (as usual).
This can be easier done by
gpg --fingerprint 0xeccb5814
gpg --fingerprint --fingerprint 0xeccb5814
shows the subkeys' fingerptints, too.
Your key has most probably nothing to do with this problem.
Ask them for the output of
gpg --with-colons --fingerprint --fingerprint --list-keys 0xTpTpTpTp
on the system which does (tries) the encryption. And ask them to export the public key on that system and send that new version of the key to you:
gpg --armor --export 0xTpTpTpTp > 0xTpTpTpTp.asc
And you may ask for an encrypted file which they can decrypt.

@_date: 2012-06-19 05:21:11
@_author: Hauke Laging 
@_subject: way to see what cipher/algo was used to create your key? 
Am Mo 18.06.2012, 19:30:44 schrieb Sam Smith:
May it be you mix up things? The key is just a random number. It can be used with ciphers but you don't use ciphers to generate a key. Neither a symmetric nor an asymmetric one. There are algorithms (no ciphers) which determine whether a random number is suitable as asymmetric key but that's probably not what you mean.
You mean except for putting cipher-algo in your config file...?

@_date: 2012-06-19 07:50:09
@_author: Hauke Laging 
@_subject: decryption trouble - primary/subkey confusion, 
Am Di 19.06.2012, 01:03:26 schrieb Michael Hannemann:
This seems not to leave any room for ambiguity: One key only which can be encrypted to. Does the long ID (field 5) match the value you get on your Even if so. Isn't the sense of all this that you can give the encrypted data to just anyone without havong to be worried? 8-)
But they may, of course, encrypt some dummy data to themselves for giving to you. They shall just check that they can decrypt it.
That has nothing to do with the passphrase. " indicates a stub (key has been there but kind of removed; --export-secret-subkeys), ">" indicates that the key is on a smartcard.

@_date: 2012-06-19 15:59:11
@_author: Hauke Laging 
@_subject: way to see what cipher/algo was used to create your key? 
Am Di 19.06.2012, 09:05:41 schrieb MichaelQuigley at TheWay.Org:
The key type is shown even by the most simple form of --list-keys:
start cmd:> gpg --list-keys
pub   1024D
sub   2048g
sub   2048R
sub   2048R
sub   2048R

@_date: 2012-03-03 22:23:31
@_author: Hauke Laging 
@_subject: Using Smartcards without it's public key 
Am Samstag, 3. M?rz 2012, 22:14:12 schrieb Werner Koch:
But it the public key technically necessary to decrypt data? I checked what happens if the public key is unavailable (but the secret key in its keyring). The secret key is listed but gpg aborts when decrypting, complaining about the missing public key.

@_date: 2012-03-04 01:20:56
@_author: Hauke Laging 
@_subject: Using Smartcards without it's public key 
Am Sonntag, 4. M?rz 2012, 00:20:11 schrieb Todd A. Jacobs:
IIRC you need both: First import the public key, then make the existence of the secret key on the card known by --card-status.

@_date: 2012-03-04 23:29:30
@_author: Hauke Laging 
@_subject: invalid gpg key revocation 
Am Sonntag, 4. M?rz 2012, 22:13:58 schrieb auto15963931 at hushmail.com:
The interesting question about that is not about you publishing the public key but about how the person could get access to your private key. It is not possible to revoke a key without the private key. That answers your question how to prevent that: Pay attention to it that nobody gets access to your private keys.

@_date: 2012-03-05 19:53:14
@_author: Hauke Laging 
@_subject: invalid gpg key revocation 
Am Montag, 5. M?rz 2012, 18:12:24 schrieb auto15963931 at hushmail.com:
IMHO that requires at least that
1) you have generated the key in a secure environment, i.e.
2) and either
which has been accessible by an insecure environment afterwards
been used in an insecure environment
3) the key has been generated by a well known software about which no respective bugs (like the SSL key space disaster) are known
Can you confirm that?
It is hard to make good assumptions about the motivation and aims of unknown people. You don't even know whether the one got access to your private key by planned action or rather incidentally.
Even if it was planned the motivation may have been to show you your limits (or the other one's superiority), not to cause damage (=becoming really I do not know whether there is any data in such a revocation signature that differs from system to system. Even the timestamp can easily be faked.

@_date: 2012-03-06 00:13:43
@_author: Hauke Laging 
@_subject: invalid gpg key revocation 
Am Montag, 5. M?rz 2012, 22:36:42 schrieb Ingo Kl?cker:
I assume that ist possible only if the main key has been required for the action during which the passphrase has been cached. So having subkeys for encryption and signing should protect from this "problem".

@_date: 2012-03-06 21:14:56
@_author: Hauke Laging 
@_subject: invalid gpg key revocation 
Am Dienstag, 6. M?rz 2012, 19:36:07 schrieb auto15963931 at hushmail.com:
I do not see any possible user error during key generation which might lead to this except for the generation of very short keys. AFAIK gpg offers a minimum of 1024 bit now and 512 bit has been possible earlier. 512 bit could have been This is not primarily meant as physical access.
Anti-malware software ist usually easy to circumvent. You create malware and play with its compilation parameters until none of the 10 most popular scanners can detect it any more.
Chances are better to limit the access of hijacked software to critical data. And that doesn't help against kernel bugs.
You really should.
If there is a valid revocation signature out there it does not make any sense not to revoke the local copy of the key.
How can a user ID identify a key as being revoked? I don't use key servers often. What I know from regular discussions here is that most key servers don't implement crypto functions. Thus they may show a key as revoked because they have not realized that the revocation signature is invalid.
There are not "a good one" and "a bad one". There's an updated one and an outdated one (your local copy).
You can always delete signatures locally. Besides you can make a backup of your key, import the revoked one, have a look at it and at worst delete the key and import your backup.
I am interested in software security (not an expert, though) but I would never consider the key I use to sign this email being safe. I mention that in my signature policy. I have different keys for different security levels.
You probably don't even use a seperate user account for key handling.
You don't have to be paranoid but you should accept the consequences of security compromises.
You cannot fix your machine in a way that you can be sure this will not happen again. You have to determine the risk and effort you are willing to take. Maybe a smartcard is an improvement for you (and no, using a smartcard does not guarantee that unwanted signatures cannot be created).
I guess you won't find many on this list who share that view.
How do you want to reproduce attackers' behaviour? If your next key does not get revoked by someone else then you are sure it is safe?
You may create a new key (in a secure environment) with an offline main key with a secure and individual passphrase (hard task not to forget it). That would give you a lot of security that your key is not revoked by someone else. But it will not make your subkeys safer (and thus your signatures more Most probable signatures can be faked and data encryped to this key can be decrypted. New subkeys and UIDs can be created. The preferred key server can be changed so that people "never" see the revocation.
Above you refused to do so because it was too much effort for you.

@_date: 2012-03-06 22:31:35
@_author: Hauke Laging 
@_subject: Separate user account (was Re: invalid gpg key revocation) 
Am Dienstag, 6. M?rz 2012, 22:00:05 schrieb Peter Lebbing:
So don't I.
That certainly depends on the way you use the system.
AFAIK there is nearly no skill level required in order to get into an average user account. There is software which creates malware. You don't have to write it yourself. Just wait for the next exploit in a widely used (or known to be used) software.
That's obviously something one shouldn't do then.
Not being an expert I consider user switching safe both under Windows and Sure, but there's cool stuff on the other side, too. A user need not be capable of installing software. A processes capabilities can be limited (I run my Internet software under AppArmor profiles). The access to X can be limited.
I see the biggest problem in hijacking a running process by feeding in data that exploits a bug and thus being able to read and write data locally and over the Internet with the biggest threat (on a well configured system) being a privilege escalation bug in the kernel which can be triggered from the hijacked process.
Some time ago I suggested on this list to add an option to gpg-agent which would open a message box every time a cached passphrase is used. I don't like the idea that I don't know what gpg-agent is doing. This suggestion was denied with the argument that the overall security level was so low that there were many possibilities to deactivate (or even manipulate) such a feature and thus it would just give a false feeling of security...
Then I misunderstood him. I remember that he objected to the idea of having completely seperate environments as a reliable key protection.
What do you have to to to be "really" safe?
1) Boot the system from a read-only medium.
2) Read the data from the unsafe medium.
3) Create the signature.
4) Take the key and signature out of the current environment.
5) The fun part (for most data types): Check (on as many different systems as "seems" necessary) whether the data is correct (how do you search for unknown 6) Make the signature available to the unsafe world.

@_date: 2012-03-08 00:52:39
@_author: Hauke Laging 
@_subject: invalid gpg key revocation 
Am Donnerstag, 8. M?rz 2012, 00:39:11 schrieb Faramir:
The statement "Only your private key can generate the revocation certificate" is not wrong, at least not in a useful understanding which is: "It is impossible to revoke a key without using the private key." As you need the private key to add a designated revoker just in the same way as you need the private key in order to add/revoke UIDs, subkeys and so on.
You need the command --edit-key and in its menu the command addrevoker.

@_date: 2012-03-13 13:36:18
@_author: Hauke Laging 
@_subject: Symmetric encryption - options? 
Am Dienstag, 13. M?rz 2012, 13:15:26 schrieb Robert J. Hansen:
Would you explain that? Do symmetric algorithms never have an MDC or does just CAST5 not (why is it the default then)?

@_date: 2012-03-15 20:26:36
@_author: Hauke Laging 
@_subject: comments on uid 
Am Donnerstag, 15. M?rz 2012, 18:54:28 schrieb freejack at is-not-my.name:
--cert-notation / --cert-policy-url may be what you're looking for.
But you need --list-options show-notations / show-policy-urls to see them. And, being more precise, that is not a comment on a UID but on one of the signatures of the UID.

@_date: 2012-05-05 00:48:25
@_author: Hauke Laging 
@_subject: secret key not found 
Am Fr 04.05.2012, 12:18:40 schrieb Rupali Chitre:
Does the application run under the same user ID or in a chroot environment?

@_date: 2012-05-22 20:26:14
@_author: Hauke Laging 
@_subject: Some people say longer keys are silly. I think they should be 
Given the frequency of this discussion and the amount of effort takes by the participants: Wouldn't it make sense to make this a FAQ entry?

@_date: 2012-05-22 21:50:40
@_author: Hauke Laging 
@_subject: Some people say longer keys are silly. I think they should be 
Am Di 22.05.2012, 14:46:03 schrieb Kevin Kammer:
No, but I don't see that as a problem. I think the question / proposal would come up at about the same frequency but would end in one reply pointing at the FAQ entry instead of now (do you want to count...?) emails.

@_date: 2012-05-22 23:52:51
@_author: Hauke Laging 
@_subject: Testing GPG EMail encryption 
Am Di 22.05.2012, 23:37:46 schrieb Robin Kipp:
I am happy for him but obviously this approach doesn't scale well. :-)
I don't know how much the demand is (or could be) but perhaps it would help make more people use OpenPGP to have a round-robin email contact system. Whoever is willing to help new users (like in this case) registers his email address with the languages he's capable of communicating in. A new user could send a mail to
de at newusers.gnupg.org
en at newusers.gnupg.org
and the mail would be forwarded to one or two people. OpenPGP-Addons for email software (like Enigmail) could hint the user at this service.

@_date: 2012-05-24 01:03:13
@_author: Hauke Laging 
@_subject: Draft of nine new FAQ questions 
Am Mi 23.05.2012, 12:18:49 schrieb Robert J. Hansen:
The reason I suggested a FAQ addition is not covered :-)  At least not by the headlines. There should be a paragraph "Why does GnuPG not support more than 4096 bits?".
@ "Why does GnuPG use 2048-bit RSA by default?":
Does the g10 smartcard not count as a reason for RSA default?
@ "Has GnuPG ever been successfully attacked?"
That sounds like there has never been a security problem. El-Gamal signatures, anyone? Furthermore:

@_date: 2012-05-25 15:59:29
@_author: Hauke Laging 
@_subject: Secret key not available 
Am Fr 25.05.2012, 13:39:27 schrieb DUELL, BOB:
You need the link to the FAQ?
When I try to decrypt such a file then this happens:
start cmd:> LC_ALL=C gpg --decrypt --output /dev/null \
 test.html.unavailable_key.gpg
gpg: encrypted with 2048-bit RSA key, ID 0x12345678, created 2012-05-22
      "foo bar "
gpg: decryption failed: No secret key
So it has obviously been encrypted for key 0x12345678.

@_date: 2012-05-29 16:55:07
@_author: Hauke Laging 
@_subject: problem signing public key, ----- gets converted to - ----- 
Am Di 29.05.2012, 06:15:35 schrieb anotst01 at fastmail.fm:
As Werner already said: Signing your key does not make sense. So the solution is simple: Exclude the key out of the signed text, insert it before or

@_date: 2012-05-29 17:17:04
@_author: Hauke Laging 
@_subject: getting an encrypted file to show what public key was used 
Am Di 29.05.2012, 11:02:03 schrieb Robert J. Hansen:
What can you see that from?

@_date: 2012-05-29 17:31:40
@_author: Hauke Laging 
@_subject: getting an encrypted file to show what public key was used 
Am Di 29.05.2012, 09:45:48 schrieb Steven Lefevre:
Was this try in the same GnuPG environment like the encoding or was one within PHP and the other one as your regular user account?
GnuPG does not report UIDs if the key is not available in the keyring. The error message tells us that the key which you have encoded for (0xF1940956 (or its main key), "Different Public Key ) is part of the decoding system's keyring but only the public key. So you encode for the wrong key.
You have to import the respective key in order to get that information.
No, just the (long) ID of the used key (i.e. possibly a subkey).
You can search the keyservers for subkeys, too.
gpg --keyserver pool.sks-keyservers.net --search-keys 0xF1940956
I am confused by Robert's short ID collision hint but my remarks should be correct anyway.

@_date: 2012-05-29 17:36:25
@_author: Hauke Laging 
@_subject: getting an encrypted file to show what public key was used 
Am Di 29.05.2012, 11:28:36 schrieb Robert J. Hansen:
Looks like a nice possibility for checking how serious the handling of keys by your partners is: Create a key with a short ID collision for a key available on the keyservers and give them the short ID... 8-)

@_date: 2012-05-29 18:02:59
@_author: Hauke Laging 
@_subject: changing the default for --keyid-format [was: Re: getting an 
Am Di 29.05.2012, 11:51:06 schrieb Daniel Kahn Gillmor:
A smaller change which should "solve" most of these problems could be to change the error message. If gpg is operating with the short format then a respective hint could be added:
"gpg is currently operation with short ID format. This prevents short ID collisions from being easily detected. You may want to run gpg with the option '--keyid-format long' to check the long IDs."

@_date: 2012-05-29 22:02:35
@_author: Hauke Laging 
@_subject: getting an encrypted file to show what public key was used 
Am Di 29.05.2012, 21:29:51 schrieb Werner Koch:
You probably mean: "Among the readers of this list." How much known may it be in the wild...?
I don't think so because giving --with-colons, --batch, and --status-fd is not the problem. Making this easier should not have a big effect on the problem.
The problem is knowledge (and discipline). So the aim should be to spread the knowledge. This could be done by printing a warning to stderr when stdin and stdout are not terminals and these options are not given:
"You are probably running gpg non-interactively. In order not to break scripts it is strongly encouraged to use scripted output of gpg only with the options --with-colons, --batch and --status-fd. See

@_date: 2012-11-05 15:47:26
@_author: Hauke Laging 
@_subject: Is the signature encrypted 
Am Mo 05.11.2012, 09:39:52 schrieb David Shaw:
But not for the (MUA integrated) use with email, can you?

@_date: 2012-11-05 16:29:24
@_author: Hauke Laging 
@_subject: Is the signature encrypted 
Am Mo 05.11.2012, 10:01:02 schrieb David Shaw:
Why? What critical information is exposed by the signature, assuming I do not forge the from address?
The virus-checking mail gateway may want to at least be sure about the sender (which does not assure it of the sending system being non-compromised and not My personal reason is that I (in contrast to one well-known member of this list...) believe signatures to be the only solution against spam and do not want the filters be forced into the the mail client. This could be done by other means than the data signature though. I don't understand why PGP/MIME does not define a seperate signature for the relevant sender created headers (from, to, subject, date). That would protect the headers and allow filters to check the sender without exposing the data signature.

@_date: 2012-11-05 17:31:00
@_author: Hauke Laging 
@_subject: Is the signature encrypted 
Am Mo 05.11.2012, 16:47:40 schrieb Johan Wevers:
Comparing the legacy headers and signed headers is not the only option. Much easier would be: If the legacy headers are mangled with anyway then just replace them by the signed ones (the last MTA or the MDA would do that) and perhaps mark them as corrected. The MUA could even do that itself.
This approach would even easily allow to hide the real subject by just setting some dummy value.
The main problem is, of course, to get crypto more widely used. Otherwise things like this are just luxury problems. But if someday more people have started using crypto then such signature errors due to header mangling would soon become a problem for the respective ISPs. You do not need a technical solution for everything; sometimes the market does. :-)
Given the amount of problems that can arise from spam and malware I am surprised that the Western governments seem not to do anything about securing this meanwhile critical infrastructure.

@_date: 2012-11-07 03:58:16
@_author: Hauke Laging 
@_subject: Is it possible to create additional signatures for subkeys? 
subject says it all...
UIDs can be revoked and reactivated by a newer signature. But I have not found a way to create new signatures for subkeys. There are at least two reasons to do that:
1) Like with UIDs, correcting an unwanted revocation.
2) What really happened to me: The subkey signature can have unwanted components (caused by --cert-notation).
Technically I do not see a difference between UIDs ans subkeys which would explain this asymmetry. But gpg offers to create new signatures for UIDs but seems not to offer that for subkeys (the same for signature deletion).
There is also no equivalent to --allow-non-selfsigned-uid for subkeys. I used gpgsplit to get rid of the revocation signature. But this is of no use if the revocation signature has escaped into the public. I also stripped off the subkey self-signature but then the subkey does not get imported at all (I had hoped for a repair option).
I have to admit that I have not checked the RfC. Does it prevent the existence of several subkey signatures? Or is there no fundamental reason against this but due to lack of demand this has not been implemented?

@_date: 2012-11-07 20:44:43
@_author: Hauke Laging 
@_subject: SSH key and PGP key 
Am Mi 07.11.2012, 16:48:41 schrieb Connie Rodriguez:
--edit-key expire
SSH-Keys do not expire AFAIK. You can use OpenPGP-Keys (with authentication capability) if you use gpg-agent as replacement for ssh-agent. Without a smartcard this is not easy (unless you use gpg 2.1); you may have a look at gpgkey2ssh and at monkeysphere.
If you do not want/need to use an OpenPGP key for SSH then you can create SSH keys with ssh-keygen.

@_date: 2012-11-07 22:08:24
@_author: Hauke Laging 
@_subject: Is it possible to create additional signatures for subkeys? 
Am Mi 07.11.2012, 03:58:16 schrieb Hauke Laging:
The question by someone else how to adapt the expiration date gave me the idea how to create a new signature for a subkey. This can indeed be done by --edit-
key expire, it is not even necessary to strip off the revocation signature in advance. But in contrast to UIDs gpg does not use the newest signature. Despite of the newer self-signature the subkey is still treated as invalid.
Just for info in case someone is interested. I don't know whether this is a bug or a feature, though. As long as the mainkey is not revoked this behaviour does not make sense to me.

@_date: 2012-11-08 05:47:16
@_author: Hauke Laging 
@_subject: How can certifications of revoked keys be detected? Invalid key shown 
I just made some tests to find out how gpg reacts to the listing of signatures if a key is revoked. Unfortunately I cannot find any difference. I ran --check-trustdb after the revocation, but the certification of the revoked key is still listed as
--edit-key check
does not show any difference either. I do not even find something about that in the documentation. It says for --check-sigs:
?A "!" indicates that the signature has been successfully verified, a "-" denotes a bad signature and a "%" is used if an error occurred while checking the signature (e.g. a non supported algorithm).?
Is a signature of a revoked key a "bad signature"? If not, how is that status displayed? I have not found any information about that in the documentation.
Even worse: The validity of the key was calculated wrongly because the certifications were treated like ones from a valid key:
start cmd:> gpg --list-keys 0x756A032D
pub   1024R/0x756A032D 2012-11-07
uid         [ vollst.] import this uid
uid         [ vollst.] unsigned uid
("vollst." is German for "complete"). I had set the ownertrust level for this key to "marginal" (it's a test key for which I have the private key). Then I deleted the signatures of the revoked key. After that the key validity was shown as "unknown" ("unbek." in the German output):
start cmd:> gpg --list-keys 0x756A032D
gpg: "Trust-DB" wird ?berpr?ft
pub   1024R/0x756A032D 2012-11-07
uid         [  unbek.] import this uid
uid         [  unbek.] unsigned uid
Is the web of trust really supposed to "work" this way? :-/
My Google search showed me a similar discussion, four years old:
The there mentioned --no-sig-cache didn't make any difference either.
start cmd:> gpg --version
gpg (GnuPG) 2.0.18
libgcrypt 1.5.0

@_date: 2012-11-09 19:33:10
@_author: Hauke Laging 
@_subject: ownertrust level of imported secret keys 
I noticed a behaviour which could be improved. If a key is generated then its ownertrust is set to ultimate. But if a secret key is imported the ownertrust keeps unchanged.
I guess that the idea behind this may be that you can be sure that noone else can create a signature by a key you have generated but that the import of a secret key can mean that someone else has shared his secret key with you which does not make signatures of that key more trustworthy.
As I think that people should be advised to use offline mainkeys so they should not be bothered with unnecessary problems arising from that. Thus I suggest to output a warning / hint if a secret key is imported. Something "You have imported a secret key. It may be useful (probably if you are the only owner of this secret key) to set the trust level of this key to ultimate (see --edit key trust)."
Or even ask and do it.

@_date: 2012-11-09 19:34:43
@_author: Hauke Laging 
@_subject: difference in validity states 
in /usr/share/doc/packages/gpg2/DETAILS there is a list of validity states:
n = The key is valid
m = The key is marginal valid.
f = The key is fully valid
u = The key is ultimately valid.
What is the difference between the meaning of n and f?

@_date: 2012-11-13 00:08:15
@_author: Hauke Laging 
@_subject: gpg-agent partitioning between sessions? 
Am Mo 12.11.2012, 15:59:40 schrieb Pete Ashdown:
What prevents an attacker from connecting to the socket of another running ssh-agent in your opinion?

@_date: 2012-11-14 06:17:26
@_author: Hauke Laging 
@_subject: Anyone interested in preparing and improving training courses? 
after having given training courses earlier (voluntarily) for small groups of non-IT people I have just given my first OpenPGP / GnuPG course at the Berlin Linux user group. My plan is to establish this as a permanent service.
The most important information I learnt from this training course is that it is extremely important to have a good plan what to put into such a course (even for people assumed to be IT-related). I think it's safe to assume that my technical skills exceed my teaching skills a lot. Don't laugh about my course now...
I hope that doing this on a regular basis will help me to improve the course content, the course slides, the attendee preparation and so on. Now, that I have explained my situation, my question: Is anyone on this list interested in a regular exchange of experiences with and ideas for GnuPG training courses? Someone who has already given such courses or is planning or at least willing to do so?
Obviously my material and web page are in German so understanding German would be helpful. But the knowledge how to make a good training course should be language independent.
A similar problem: How can more be people be interested in learning GnuPG. My current approach is to teach the BeLUG members first and the make them take their non-BeLUG contacts to a later course.
Perfect would be somebody interested and experienced in this and living in Berlin, of course. ;-)  But input from everyone else is welcome, too. Contact my by email or XMPP (hauke.laging at googlemail.com).

@_date: 2012-11-16 06:02:54
@_author: Hauke Laging 
@_subject: setting primary UID of other's keys and allowing direct UID 
I just noticed that I cannot set the primary UID of a key for which I don't have the secret key. From the perspective of an official certificate that makes sense but for the usage of a public key it does not IMHO.
The primary UID has technical implications and is the only shown in several cases. The key owner has his reasons for chosing this UID as the primary but these reasons need not make sense for some users of his key.
The primary UID may not even contain the name or not an email address. I created my new key with a primary UID which consists of my name and a comment only. This may seem stupid or disturbing for someone who has imported several of my keys.
I see absolutely no reason why the key owner should force the decision which UID is shown on the key user (the more as he probably doesn't even want to). Deleting the unwanted UIDs is not an option because they come back with every key(ring) update. Nor would this approach be very elegant...
But this is not just about visual appearance. Key information like preferred keyserver, policy URL and cipher/hash preferences are bound to the UIDs. It says in the documentation that these pieces of information are taken from the respective UID ? IF the key is addressed by the UID. This is not a good idea if there are several keys with matching UIDs. I admit I was too lazy to check but I doubt that the email clients use the email address for key selection. The two programs I know (KMail and Thunderbird / Enigmail) ask you for the key to be used if you add someone to the addressbook or define a recipient rule. But they show you the key ID so I guess they select the key by its ID, too (which makes perfect sense in general). But if they do then the data of the primary UID is used because gpg doesn't even know which address the data is sent to. AFAIK it is not even possible to use both a key ID and a UID simultaneously to select a key. But this would be necessary for the intended Thus I would like to suggest two changes to gpg:
1) Allow a configuration (external to the key like the ownertrust) to set the UID to be used as primary UID in the local system. In order to get the current behaviour a new option would be necessary, something like:
It seems to me that you need --list-options show-sig-subpackets to get an explicit statement of gpg which is the primary UID. I don't think that normal applications do that. Probably they consider the first UID output by gpg to be the primary (this formal status is not relevant to applications anyway).
Could be covered by (1) mostly but would be nice anyway:
2) Allow a combined key ID - UID addressing scheme. As even the email address can occur in several UIDs a clean solution would be to use "UID IDs" along the lines of key IDs. Internally the UIDs are already hashed anyway (and shown: field 8 of --with-colons output) so just take the last 32 bit of that hash as UID ID. Key selection could look like this then:
gpg --recipient 0x1A571DF5/0x7AAE70CD --sign --encrypt
That would be a simple change for the email clients.

@_date: 2012-11-20 07:45:44
@_author: Hauke Laging 
@_subject: Authenticating info on a "compromizable" system 
Am Mo 19.11.2012, 22:57:13 schrieb Jean-Fran?ois Dagenais:
I think it is as you describe: Easy but of limited protection (depending on the possibility to compromise your software or its keyring or the contained gnupg). And, of course, it does not prevent an attacker from copying a signed configuration from another system.
A passphrase like gslLThmk8DlrZR1Me6 offers protection similar to that of a 2048 bit key (see --s2k-count, too). So disclosing the safely encrypted secret key would not be a problem. How such an observation might influence the opinion of your customers and partners about your work is a different question, of course...
trustdb.gpg just stores the ownertrust level of keys. It just tells someone which (but not necessarily all) keys you have in your keyring and how much you trust them.

@_date: 2012-11-21 18:46:36
@_author: Hauke Laging 
@_subject: making (future) OpenPGP cards without PIN pad safer 
I am not familiar with smardcard hardware especially not with the way how the passwords are checked on the smartcards. From this naive perspective this just came to my mind:
I have a card reader with PIN pad but there are several card readers without one. I never liked the idea of connecting a smartcard to an unsafe system but I understand the cost argument.
The card already has additional storage for private use (if I have understood the documentation correctly). The idea: Wouldn't it be rather easily possible to allow the use of the card by
a) either the real password (like today) b) or one of several one-time passwords (TANs) which you can load into the card by supplying the real password (or the admin password)?
This reduce the risk of using the card with systems of unknown security a lot (without increasing the cost of the card).

@_date: 2012-11-21 21:45:31
@_author: Hauke Laging 
@_subject: making (future) OpenPGP cards without PIN pad safer 
Am Mi 21.11.2012, 20:42:38 schrieb Michel Messerschmidt:
That is more expensive than my proposal but not safer. The only advantage is that card usage is not blocked if you need more crypto operations than you have TANs available. But that is mainly a question of storage (i.e. no

@_date: 2012-10-03 07:07:32
@_author: Hauke Laging 
@_subject: collision vs. preimage attacks: policy for signing data created 
Am Mo 24.09.2012, 19:06:17 schrieb Hauke Laging:
Oh no ? I am responding to my own email...
But I happened to find and answer to my question. In a seven and a half years old article about a collision attack against SHA-1. It's in German, though:
("Grunds?tzlich ist es eine gute Idee, vor dem digitalen Signieren eines Dokuments immer noch selbst eine kosmetische ?nderung vorzunehmen.")
It says: It does in general make sense to make a small change (that does not change the meaning) to a file before signing.
I have another question about hashes:
Given two different files that have the same hash value. If some data is appended (or prepended) to both files do the resulting files still have the same hash value?

@_date: 2012-10-05 01:13:54
@_author: Hauke Laging 
@_subject: collision vs. preimage attacks: policy for signing data created 
Am Do 04.10.2012, 22:09:27 schrieb Hubert Kario:
Probably. So the question could be changed to: For which hashes does the value change and for which not? Limited to the hashes relevant for GnuPG operation.
Is different data with the same hash value publicly available? In that case I could just try it myself. :-)

@_date: 2012-10-05 01:56:44
@_author: Hauke Laging 
@_subject: what is killing PKI? 
Am Do 04.10.2012, 19:22:07 schrieb Robert J. Hansen:
That is probably something that everyone has to say for himself: "If I promote XY then probably the (or: my) world gets better." The alternative is something like "I don't care what happens if I don't" like in "I don't care if the WWW gets f*cked up if more people start using IE" years ago.
Sure? 8-)
There is not necessarily a contradiction. And the second works only for those (in some cases: the few) who are willing to make an informed choice.
I might say even GnuPG combines both: There are many default values (:="What you should do (if you don't know better or don't care).") but the program and the documentation allow to make a (more or less) informed differing choice. Who would say that default values are bad?
The line between "tell what to do" and "inform" can be thin.

@_date: 2012-10-05 03:55:24
@_author: Hauke Laging 
@_subject: spam and crypto (was: Re: what is killing PKI?) 
Am Fr 05.10.2012, 02:00:36 schrieb MFPA:
They don't have to. They don't even have others to spend this CPU time. The point is that a spammer would not encrypt to protect the contained information but because he is required to adhere to the format rules of encrypted messages in order to get his mails read.
So the CPU effizient spammer
1) encrypts all messages with the same session key. This forces him to send identical messages but that is hardly a problem. This frees the spammer from doing the symmetric encryption of the message but still causes that CPU load of asymmetrically encrypting the session key to each of the recipient keys.
2) stores the "encrypted session key" packet for each recipient so he can send other spam messages without per-recipient CPU consumption
3) if we try to detect spam by detecting reused session keys (by e.g. storing the hashed of all session keys) then the spammer can still save a lot of CPU power by not using the same but just similar session keys, differing just in the last byte. If I understand asymmetric encryption correctly then most of the encryption effort could be shared then between the keys. The spammer would have to transmit the encrypted session key block along with the recipient email address. That is a multiple of the data amount of just the addresses but still not much.
And if we go even further and check not just for equal but for similar session keys then the spammer still has the possibility to better use his resources by preparing session keys and encrypted sesseion keys packets for future.
IMHO the solution of spam is not encryption but signatures. The better solutions are not even crypto related. If the US and EU governments started treating foreign spammers the same way like "terrorists" we would soon see no more spam. A less violent option is the creation of a second email infrastructure. Make (by law) certain addresses (subdomains) accessible only by ISPs who fight spam (e.g. have to pay for spam from them). Then anyone can decide whether and how many email accounts he wants to have in the "Do what you like, get what you don't like" and the clean mail nets. Done (with small

@_date: 2012-10-06 16:15:21
@_author: Hauke Laging 
@_subject: Is it possible to construct a GPG Certificate from an existing 
Am Sa 06.10.2012, 15:53:25 schrieb Melvin Carvalho:
How do you have these key pairs? Are they part of a GnuPG keyring? What is

@_date: 2012-10-07 02:47:56
@_author: Hauke Laging 
@_subject: [gnupg-users] Decrypting file encrypted for multiple recipients 
Am So 07.10.2012, 02:34:41 schrieb Jaime Fern?ndez:
Is the file encrypted with hidden recipients?
If one private key can decrypt alle the files then you have the possibility to export this private key to another keyring and call gpg for decryption with this keyring as the only one. See

@_date: 2012-10-14 14:02:07
@_author: Hauke Laging 
@_subject: Smartcard With Pin Pad Better Security? 
Am Sa 13.10.2012, 20:14:41 schrieb Jonathan:
Depends on your definition of "golden right". :-)
Even a smartcard PIN pad combination can be abused, not as easily though. After you have entered the PIN an attacker controlling your system can decrypt as much data as he likes and perhaps (depending on the card configuration) even sign as much as he likes. Until you pull out the card (reader).
Even the single signature can be abused (you don't control what data gets Thus a smartcard does not offer more security by itself than a secure system (offline hardware booting from a safe medium). Reaching the paranoia level: It is possible to extract a key from a smartcard. It is quite expensive and requires certain skills though. Recovering a key which is protected by a sufficient passphrase can be considered impossible.
number). But this scenario is not governed by software rules but by hardware rules: The smartcard does not allow you enough tries. It "destroys" itself after a few.

@_date: 2012-09-13 18:37:00
@_author: Hauke Laging 
@_subject: encryption/decryption without files 
Am Do 13.09.2012, 11:47:06 schrieb vedaal at nym.hush.com:
There is a limitation in comfort...

@_date: 2012-09-21 17:40:45
@_author: Hauke Laging 
@_subject: Newbie: Commandline still prompting for passphrase? 
Am Fr 21.09.2012, 10:33:05 schrieb John Morris:
For gpg-agent the helper program gpg-preset-passphrase can be used.

@_date: 2012-09-24 16:46:07
@_author: Hauke Laging 
@_subject: Main encryption subkey 
Am Fr 21.09.2012, 13:49:17 schrieb Dmitry Dzhus:
Yes but this is not enforced by the standard. So it would be OK for another implementation to do differently.

@_date: 2012-09-24 19:06:17
@_author: Hauke Laging 
@_subject: collision vs. preimage attacks: policy for signing data created by 
not a GnuPG specific problem but perhaps relevant to GnuPG users.
Given the much bigger difficulty of preimage attacks, would a rule make sense not to sign a document that someone else has created (and thus been given the opportunity for a collision attack)? The solution would be to change the file in a way that does not affect the meaning (e.g. an additional space somewhere) and can easily be detected to match this condition. There could even be a field especially for a random modification by the recipient.
Often documents have to be signed by both parties. How can the sender be safe against a collision attack by the recipient's modification? One aspect is time. If you get the document back within days it seems very hard to get the attack done in that time. But perhaps it also helps to have certain requirements for the modification; requirements which make a collision attack a lot harder (but are easy to check). I can just guess what that may be. Perhaps the combination of a random value and its hash:
ACAM: JIu1ZmRJdYFH9wVspZr9 a6dd2f422f95606ff3e1de4ccb662f5f3a876d92
There could be one such Anti Collision Attack Modification field for each party. It would make sense to require a hash algorithm with heavy CPU load for this. But perhaps this is exaggerated and the additional space serves just as well? :-)
Of course, this is not intended as a possibility to continue using hash functions with known collision attacks but as a precautionary measure as you can never be sure that you know all your attacker knows (who need not even be the one you want to make a treaty with). Probably not even the majority of OpenPGP users is immediately aware of the publishing of new attacks.

@_date: 2012-09-27 06:49:34
@_author: Hauke Laging 
@_subject: key specification by word match does not work as expected 
ijust read this in the man page:
By word match.
All  words  must  match exactly (not case sensitive) but can appear in any  order in the user ID or a subjects name.  Words are any sequences of letters, digits, the underscore and all characters with bit 7 set.
+Heinrich Heine duesseldorf
So I tried:
start cmd:> gpg --list-keys ="Hauke Laging "
pub   1024D/0xECCB5814 2005-09-05
uid         [ uneing.] Hauke Laging start cmd:> LC_ALL=C gpg --list-keys +"Hauke Laging"
gpg: error reading key: No public key
Right before sending this mail I noticed that it is the quotes:
start cmd:> gpg --list-keys +Hauke Laging
pub   1024D/0xECCB5814 2005-09-05
uid         [ uneing.] Hauke Laging I find this strange because non-quoting of arguments is generally unusual. Furthermore key selection can occur in the options part of the command line though I admit that word match is probably mostly used for finding a key instead of for specifying it in another command.
Next step of insight:
Leaving out the quotes does not solve that problem but makes it worse:
+Hauke Laging
without quotes is not understood by gpg as "Find all UIDs which contain the words 'Hauke' and 'Laging'" but as an OR relation of "Find all UIDs that contain Laging" and whatever.
Even stranger:
start cmd:> gpg --list-keys +lalala Laging
works (finds all the UIDs with "Laging") but doesn't the other way round:
start cmd:> LC_ALL=C gpg --list-keys lalala +Laging
gpg: error reading key: No public key
start cmd:> LC_ALL=C gpg --list-keys +Hauke
gpg: error reading key: No public key

@_date: 2012-09-28 23:38:57
@_author: Hauke Laging 
@_subject: key specification by word match does not work as expected 
Am Do 27.09.2012, 17:03:36 schrieb Werner Koch:
No big problem, the few cases in which that may be needed can easily be covered externally. But wouldn't it make sense to take this feature out of the documentation then and maybe issue a warning if this mode is encountered?

@_date: 2013-04-01 12:00:13
@_author: Hauke Laging 
@_subject: Why does gpg use so much entropy from /dev/random? 
Am Mo 01.04.2013, 10:53:02 schrieb Philip Potter:
None that I know of. Doesn't make sense elsewhere IMHO, too.

@_date: 2013-04-01 20:39:34
@_author: Hauke Laging 
@_subject: The Lord of the Keys 
Am So 31.03.2013, 13:41:59 schrieb Ken Kundert:
You probably need gpg-preset-passphrase for that. But I have never used it so I cannot give you details.

@_date: 2013-04-02 22:15:18
@_author: Hauke Laging 
@_subject: Export just one subkey? 
Am Di 02.04.2013, 07:53:17 schrieb Jack Bates:
[...] --export-secret-subkeys 6E0282A9\! [...]
The \ is just for the shell and not always necessary.

@_date: 2013-04-03 22:45:33
@_author: Hauke Laging 
@_subject: Create subkey that will expire in 10 hours 
Am Mi 03.04.2013, 09:54:29 schrieb Jack Bates:
AFAIK there is no official way to do that. gpg seems to always take the time from the creation timestamp of the respective (sub)key. So the only chance to get that done (without changing the source code) is to create a key. In this sense you are lucky.
1) Set back the system time (al least for gpg) to yesterday and the target 2) Create the key with one day expiration date.

@_date: 2013-04-04 12:37:45
@_author: Hauke Laging 
@_subject: Create subkey that will expire in 10 hours 
Am Do 04.04.2013, 11:12:51 schrieb Werner Koch:
That seems not to be part of the documentation...

@_date: 2013-04-11 00:28:49
@_author: Hauke Laging 
@_subject: Reading key capabilities information before importing a key 
Am Mi 10.04.2013, 22:57:53 schrieb Branko Majic:
Two possibilities:
gpg --list-packets hauke__0x1a571df5.asc
:public sub key packet:
        version 4, algo 1, created 1352000413, expires 0
        pkey[0]: [2048 bits]
        pkey[1]: [17 bits]
        keyid: 486B17AB3F96AD8E
:signature packet: algo 1, keyid BF4B8EEF1A571DF5
        version 4, created 1352000413, md5len 0, sigclass 0x18
        digest algo 2, begin of digest c1 78
        hashed subpkt 2 len 4 (sig created 2012-11-04)
        hashed subpkt 27 len 1 (key flags: 02)
Subpacket class 27 is the key capabilities.
       First octet:
       0x01 - This key may be used to certify other keys.
       0x02 - This key may be used to sign data.
       0x04 - This key may be used to encrypt communications.
       0x08 - This key may be used to encrypt storage.
       0x10 - The private component of this key may have been split
              by a secret-sharing mechanism.
       0x20 - This key may be used for authentication.
       0x80 - The private component of this key may be in the
              possession of more than one person.
2) You import the key but direct it to a different keyring, see

@_date: 2013-04-11 10:18:59
@_author: Hauke Laging 
@_subject: Backing up Private Keys 
Am Do 11.04.2013, 15:05:46 schrieb Ashley Holman:
You can compare the exported files and will notice that those with the private keys are larger.

@_date: 2013-04-12 03:00:22
@_author: Hauke Laging 
@_subject: Reading key capabilities information before importing a key 
Am Do 11.04.2013, 23:43:39 schrieb Werner Koch:
That is an inconsistent explanation. If --list-packets "can" show data from signatures without checking the signatures then obviously --with-colons "could" do that as well. The only valid argument I can think of is that --
list-packets may be defined as "stupid dump" and --with-colons is defined as showing only validated data. But the latter is obviously not the case. So if subkeys and UIDs are shown without checking signatures why not show unverified signature data like the key capabilities?
Whether that would be worth the development effort is a different question, of

@_date: 2013-04-14 02:55:58
@_author: Hauke Laging 
@_subject: Using smartcard as RNG 
Am So 14.04.2013, 00:18:09 schrieb Henry Hertz Hobbit:
Would that make sense? I tried to buy one moths ago. Ordered it via their web page (and Google) and never heard of them. Not even when asking what's up.

@_date: 2013-04-14 06:00:45
@_author: Hauke Laging 
@_subject: Using smartcard as RNG 
Am Sa 13.04.2013, 13:04:31 schrieb Pete Stephenson:
I did (if I did not just dream it). And as even I don't find that (neither via Google nor in my MUA) you are completely excused. :-)
I was told then that this was possible but not the solution to all randomness problems. Hardware can have defects, and in case of RNGs it is especially difficult to be sure that there are no problems. You need know what the hardware errors can be in order to be able to search for the right traces in the output. Otherwise non-trivial failure of a hardware RNG may keep

@_date: 2013-04-16 05:28:19
@_author: Hauke Laging 
@_subject: Backing up Private Keys 
Am Mo 15.04.2013, 23:15:19 schrieb Robert J. Hansen:
--s2k-cipher-algo name
Use name as the cipher algorithm used to protect secret keys.  The default cipher is CAST5.

@_date: 2013-08-03 14:51:25
@_author: Hauke Laging 
@_subject: key management & APG 
Am Sa 03.08.2013, 12:16:56 schrieb ix4svs at gmail.com:
You should consider using two keys for the same identity and very obviously give them different security levels.  IMHO that's what we all are going to do in five years.
Then the sender can decide how confidential the information is (or how reliable the signature must be).
There is no need to export the keyring. Just export the whole key:
gpg --armor --export-secret-keys 0x12345678 > 0x12345678.secret-mainkey.asc
export the subkeys only
gpg --armor --export-secret-subkeys 0x12345678 > 0x12345678.secret-subkeys.asc
delete the secret keys
gpg --delete-secret-key 0x12345678
and import the subkeys only
gpg --import 0x12345678.secret-subkeys.asc
It's not important where you store the offline mainkey. You may even put it on your web site. Just make sure that your passphrase is cryptografically safe (16+ chars [a-zA-Z0-9] and never entered on an insecure system).
To me this seems to be a really strange article. My advise is to ignore that.

@_date: 2013-08-04 17:21:58
@_author: Hauke Laging 
@_subject: key management & APG 
Am So 04.08.2013, 10:00:49 schrieb Philipp Klaus Krause:
You may sign them with each other.
If you sign them with each other and both signing keys are high security (the one as a whole and the offline mainkey of the other) then everyone would have to sign one only. In general it would be enough to sign the highest security key of a person but this may break the web of trust because that unfirtunately does not make a difference between your own keys and those of others.
For the future I suggest a five step scale:
1: test key (publicly available) or used on untrusted systems
2: key available to trusted other systems (e.g. webmail) or smartphones
3: normal PC (email, web surfing)
4: hardened normal PC (noone else is using it; technical protections)
5: secure environment (e.g. verified Linux live DVD)
I guess anything above that can hardly be standardized (and need not).
When I create keys for Germans I create a UID without email but with this "Alltagsschl?ssel mit sicherem Offline-Hauptschl?ssel und policy URL"
This is:
"Everyday key with secure offline mainkey and policy URL"
The safe way is to have a key policy (not just a certification policy!) which is signed by a secure offline mainkey. But, of course, you must know for sure that another one's key has a secure offline mainkey. You easily realize that the current WoT is useless.
No but if more people start using crypto then the demand for usable solutions will arise quickly and result in the tools getting this ability. This could be done by signature notations (for both self-signatures and certifications by

@_date: 2013-08-14 16:10:19
@_author: Hauke Laging 
@_subject: self signed keys 
Am Mi 14.08.2013, 09:55:41 schrieb Henry Hertz Hobbit:
This sounds like the usual mix-up of (certification) trust and validity.
I just checked that. Surprisingly gpg shows non-selfsigned UIDs of ultimately trusted keys as valid. Doesn't make sense IMHO (as trust refers to the mainkey itself and not to the UIDs) but this is a very special case thus I am not sure whether this behaviour is intentional or rather coincidental.
But: What is the argument for not self-signing a key?
You could. You just wouldn't make them valid by it. :-)  (unless they are valid by other means and have marginal or complete trust).
One more mix-up of validity (=to "be" someone) and trust (assumes quality of certifications). You may create an unsecure test key (quite probably that you already have). There is absolutely no reason to assign positive certification trust to an insecure key, no matter how sure you are about the identity of the

@_date: 2013-08-18 01:49:43
@_author: Hauke Laging 
@_subject: Issue with --sign option 
Am Sa 17.08.2013, 06:56:45 schrieb Tiwari, Ashish:
There is a dash typo.

@_date: 2013-08-22 16:05:12
@_author: Hauke Laging 
@_subject: Serpent? 
Am Do 22.08.2013, 09:56:51 schrieb Robert J. Hansen:
The wording "GnuPG extends" seems inappropriate to me as it is indeed an RfC that extends 4880 in this way:
Thus your
is still perfectly right.

@_date: 2013-08-26 03:26:10
@_author: Hauke Laging 
@_subject: --gen-random ignores SIGPIPE 
start cmd:> gpg --version
gpg (GnuPG) 2.0.19
libgcrypt 1.5.3
I would expect that "gpg --armor --gen-random 1" does not follow the documentation statement "If count is not given or zero, an endless sequence of random bytes will be emitted." unconditionally as this doesn't make any sense gpg --armor --gen-random 1 30 | dd if=/dev/stdin of=/dev/null bs=10 count=1
terminates but
gpg --armor --gen-random 1 | dd if=/dev/stdin of=/dev/null bs=10 count=1

@_date: 2013-12-03 20:55:03
@_author: Hauke Laging 
@_subject: Windows command line to decrypt multiple files 
Am Di 03.12.2013, 12:21:26 schrieb bj:
passwort is (implicitly) defined in the keyring. The secret key is stored encrypted. You need the passphrase in order to use the key. You must know the passphrase, you cannot get it from the GnuPG installation.
I am not familiar with that DOS / Windows stuff. Just a few comments:
1) You do not need a passphrase when you encrypt files. You need the passphrase for signing and decrypting.
2) ECHO Password|
gpg --passphrase-fd 0 --batch -o "..." --decrypt %%F
should do.

@_date: 2013-12-03 23:44:20
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Di 03.12.2013, 08:22:28 schrieb Eric Poellinger:
What exactly did you do? Did you mark the subkey before and did you save the changes to the keyring after the expire command?
gpg> key 1
pub  3072R/0x711D8152  created: 2013-11-27  expires: 2014-11-27  usage: SCE                        trust: ultimate      validity: ultimate
sub* 2048R/0x48C7F0CD  created: 2013-11-27  expires: 2015-12-03  usage: S   gpg> save
You can.
Expiration serves two purposes:
1) Passively revoke a key if you have lost access to the secret mainkey (i.e. to the key itself or to its passphrase).
2) Force your communication partners (people are lazy) to update your certificate from time to time (requires some understanding on their side).
The length of the validity period is a compromise between higher "security" and less inconvenience (your own, too).
I am not sure whether I understand correctly what you mean by "renewing". You can prolong the validity of subkeys and you can replace subkeys. It's not a big difference for your communication partners. Replacing subkeys for security reasons makes real sense only if you use a secure offline mainkey.
Usually you upload your certificate (public key) to a key server (or more) from where everyone can get updates of your certificate.

@_date: 2013-12-04 00:20:10
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Mi 04.12.2013, 00:00:21 schrieb Johannes Zarl:
This is the security against the possibility that
a) the key has been compromised and revoked and you don't know that (because your last certificate update was before the revocation publishing)
b) the key has been compromised and cannot be revoked (because the owner has lost access to the secret mainkey and has neither a revocation certificate nor a (usable) designated revoker)
Imagine a certificate which is always prolonged for just one day. If this gets compromised then it will not be prolonged any more (at least not by its owner but we all love our highly secure offline mainkeys, don't we?) so everyone will notice that within hours.
On the other hand imagine a certificate which never expires and a lazy user (who seldom uses that key). Even a year after its revocation the lazy user may not have noticed the revocation yet. And thus encrypts critical information to the compromised key. Or worse (because the key owner wouldn't notice): Uses it to validate software.

@_date: 2013-12-04 00:59:53
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Mi 04.12.2013, 00:39:46 schrieb Johannes Zarl:
He could but he would need the secret mainkey for that operation and...
...keys without offline mainkey on insecure systems are a security joke It may be possible to prevent someone from seeing the revocation certificate. Certificate distribution is a lot less secure than the keys themselves. But you cannot trick someone into using an expired key.
And besides security: It allows detection of dead keys on the keyservers.

@_date: 2013-12-04 01:49:21
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Di 03.12.2013, 19:26:09 schrieb Robert J. Hansen:
That's really easy: In order to get access to the subkey which will sign this email you just need online access to the system on which I write this email. A system which is used to read a lot of email, for IM and for accessing the WWW.
It may (should) be harder to crack this system than it would be with the average system but it is without doubt possible (in the usual sense).
Compromising the respective mainkey is more difficult by several orders of magnitude. You would have to compromise at least the boot medium (CD/DVD) or the hardware I use.
Of course. But these risk models are incompatible with the requirements of crypto usage in a business environment. They are even incompatible with a real Web of Trust.

@_date: 2013-12-04 01:53:46
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Di 03.12.2013, 19:03:13 schrieb Robert J. Hansen:
Sure but it makes little sense to play best practice in one part of key management (expiration) and simultaneously worst practice (online mainkey) in a much more important part of key management.

@_date: 2013-12-04 02:31:34
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Di 03.12.2013, 20:10:32 schrieb Robert J. Hansen:
That's why crypto best practices should be extended to "what hardware to buy". Of course, then the point is approaching where your next argument kicks in: Complexity which limits the usage to 1% of the population.
But this is what the chipset-based write protection for flash has been invented for long ago. That, of course, doesn't exclude the possibility to hack the firmware on boot by some bogus NVRAM content... Unfortunately it seems to be impossible to ensure that a (normal) system is incapable of storing data. Disconnecting the disk just limits the available storage.

@_date: 2013-12-04 02:45:50
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Di 03.12.2013, 20:20:07 schrieb Robert J. Hansen:
Oh, recently I involuntarily proved that I do: I "managed" to DoS myself (what a luck nobody uses crypto) by letting my certificate expire over two days because I was to lazy to do the effort of prolongig it "securely".
Many people (not including you?) would be surprised where the "so complex" border is. When people attend to my courses and use their firmware-hacked systems to security pretendingly boot from ro media then I give them sheets of paper with the most important information. One of them is for writing their secure passphrase down (how about hacking keyboard firmware?). On that sheet it says: "This is NEVER to be entered on an insecure (te-hee) system."
Recently a computer science Ph.D. student attended to my course. Guess what he did first after he had imported the subkeys onto his normal system and something didn't work the way he expected it to...
But I am sure that this border does not have an absolute position. It depends on the security culture. If we manage to make crypto an everyday technology and most people around you are doing it right (te-hee) then you will probably do it right, too, even though you wouldn't today.
In such a culture systems with a firmware hardware combination which allows overwriting the firmware from the OS level could not be sold any more. A better world is possible.

@_date: 2013-12-04 03:58:25
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Di 03.12.2013, 18:32:53 schrieb Eric Poellinger:
It would have been more helpful to see the exact steps for the operation that does NOT work...
Meaning what? As you are obviously doing something wrong this very general description isn't helpful at all. Maybe you just believe it's for the subkey.
Thus I gave the commands and (part of) the output:
gpg> key 1
pub  3072R/0x711D8152  created: 2013-11-27  expires: 2014-11-27  usage: SCE
                       trust: ultimate      validity: ultimate
sub* 2048R/0x48C7F0CD  created: 2013-11-27  expires: 2015-12-03  usage: S
After "key 1" the respective subkey is marked as "active" by the "*".
A certificate update takes seconds only (and you can run it when the main process has just finished). Or just a share of a second if you suppress the trustdb calculations (or the keyring is small).
You can make the changes to the certificate on another system so that yours running this process doesn't have any downtime but just the one second import of the new certificate.
I do not see how this is related to the technical questions we can answer. We know nothing about this paperwork. I am not even sure what your question is. If key updates are difficult then do not update the keys (more often than really necessary). This leads to the next recommendation: secure the keys. Use them in a very limited environment only.
It may make sense to create separate keys for each business contact (or at least one for each "paperwork business contact") in order to minimize the effects of activities not related to this contact to the key for this contact.
Another idea: It may help to have a separate certification key (like your own CA) which is used in a "very secure" environment only. Your contacts can make a trust signature (tsign) for this key so that new (main)keys with email addresses in your domain become valid automatically. But whether this causes more or less paperwork depends on your contact's policy.

@_date: 2013-12-04 22:25:56
@_author: Hauke Laging 
@_subject: confused 
Am Mi 04.12.2013, 08:10:54 schrieb Otto Hamlin:
No, OpenPGP is a standard not a software and thus cannot be installed on your system (just be supported by it). You probably have gpgtools installed. Thus your question is not a GnuPG question but a gpgtools question:
There is probably an easier way but you can open a terminal, have a look at the available keys
gpg --list-keys
and export yours to a keyserver (assuming one has been defined in your config gpg --send-keys 0x12CF0B88
gpg --keyserver my.preferred.keyserver --send-keys 0x12CF0B88
The key 0x12CF0B88 (which has signed your email) is already available on the

@_date: 2013-12-05 19:47:57
@_author: Hauke Laging 
@_subject: Renewing expiring key - done correctly? 
Am Do 05.12.2013, 19:30:07 schrieb Ingo Kl?cker:
You misunderstand the attack. If you completely control the system time (which is not realistic for big discrepancies, of course) then you can prevent the certificate from becoming invalid: You never reach the expiration date.
BTW, OT: May I point you at this?

@_date: 2013-12-05 22:57:34
@_author: Hauke Laging 
@_subject: Promoting the usage of OpenPGP (was: Re: Renewing expiring key - 
Am Do 05.12.2013, 21:38:50 schrieb Ingo Kl?cker:
That's OK but I think its obvious that in the current situation (i.e. some public attention for the subject but still ridiculously small numbers of new users with no prospect of real change) we have to at least try *everything* that seems to make sense and can be done at nearly no effort. The resources are VERY limited. The "let someone else do that" attitude simply does not work This is the archive of the international Cryptoparty mailinglist:
Does that look like a lot is going to happen beyond small groups who organize events? Not to me. I am extremely ? the diplomatic wording would be: ? disappointed about it how many people and organizations (quite related to the subject) do not even give the support which they could deliver at nearly no effort. I guess we need both a public hall of fame and a hall of shame which the media can be pointed at every time they call.
It seems like a joke to me that I get hardly any feedback from the IT and political community (let alone positive feedback; thus even though that wasn't a positive response it already made you a positive exception) but good feedback and support from the cultural community. WTF?

@_date: 2013-12-08 22:11:25
@_author: Hauke Laging 
@_subject: determine the source(s) of validity 
I want to find out what makes a key valid (and with which certification level): a certification by one of the systems keys or one or more certifications from the WoT. I think that it is important that applications show this information in key selection dialogs.
IIRC this has been discussed here a while ago and there is no way to get this information from GnuPG. I would like to know whether there is already software available which does this; no need to reinvent the wheel.
If there isn't any I would do this (but maybe there is a better approach):
1) Find all keys which have ultimate trust. BTW: I noticed that a key becomes invalid if its certifying key expires and has complete trust. But if it has ultimate trust then the expiration does not make the certification invalid. Is this intentional?
2) Import all these keys plus the key to be checked (with import-clean) into a new keyring (with a separate trustdb).
3) If (the key was valid in the normal keyring and) the key is not valid in the check keyring then it is validated via the WoT. Otherwise I can look for the signature with the highest certification level (I am interested in this Another, related question:
I was surprised to read the recommendation to create a local certification for keys which have been validated via the WoT. But the one who wrote that seems extremely competent to me with respect to OpenPGP. Is there a general concensus on that? What are your opinions?

@_date: 2013-12-09 04:26:54
@_author: Hauke Laging 
@_subject: Holiday giving 
Am Fr 06.12.2013, 23:16:57 schrieb Robert J. Hansen:
And to make that easier I add the URL:
Furthermore I would like to encourage everyone to spread the mailinglist archive link to Rob's mail (together with the one above) via your blog, social network profile and so on:

@_date: 2013-12-10 23:15:54
@_author: Hauke Laging 
@_subject: Importing new subkeys 
Am Di 10.12.2013, 15:42:40 schrieb Phillip Susi:
There is a technical restriction which prevents merging secret keys or secret key components from different sources. This is not going to change before 2.1.

@_date: 2013-12-11 01:57:59
@_author: Hauke Laging 
@_subject: a maximally simplified GUI for OpenPGP (no code) 
some time ago I had a discussion about what a really simple crypto GUI should look like. This is the result:
It's just an HTML page which allows you to jump from screen to screen (for most suggested features) via internal links. Maybe this is interesting for

@_date: 2013-12-11 05:35:30
@_author: Hauke Laging 
@_subject: gpg-agent: pinentry-mode 
I have just been reading the man page of gpg-agent and found this:
Allow clients to use the loopback pinentry features; see the option pinentry-
mode for details.
That made me curious so I wanted to do just that but: That is the only occurrence of "pinentry-mode" in the man page...

@_date: 2013-12-11 08:38:04
@_author: Hauke Laging 
@_subject: change passphrase in batch mode 
Am Di 30.07.2013, 14:28:49 schrieb Werner Koch:
Took me some time to give that a try but...
That works, thanks a lot. I added
        if [ "pid" = "$rest" ]; then
                echo "D $$"
        fi
        echo "OK"
This simple example works if just one passphrase is needed (e.g. signing). The problem is that pinentry is called three times when the passphrase is changed. I could put both the old and the new passphrase in PINENTRY_USER_DATA. Unfortunately it is not obvious for pinentry (or rather: me looking at the communication) which of the three calls is the current one. That may be detectable but seems too complicated. My solution is that I let the wrapper read the data from a FIFO. Before gpg --passwd is called the three passphrases are written to the FIFO.
I wonder why none of these commands (GETPIN, GETINFO, not even BYE) are explained on

@_date: 2013-12-11 23:30:39
@_author: Hauke Laging 
@_subject: gpg-agent: pinentry-mode 
Am Mi 11.12.2013, 10:51:16 schrieb Peter Lebbing:
That must be new. It's not in my gpg2 man page (2013-10-06; gpg-agent man page from the same day).

@_date: 2013-12-12 18:33:29
@_author: Hauke Laging 
@_subject: a maximally simplified GUI for OpenPGP (no code) 
Am Do 12.12.2013, 14:24:18 schrieb Bernhard Reiter:
may be. But I didn't know that (or that this knowlege is already available; and is it public so that people can assess and discuss it?) when this became a relevant question for me. I do not believe that "a nice and usable gui" has to be "as simple as possible" in any case. I am quite sure that this depends a lot on the targeted user category. What I did is targeted at people with absolutely no clue about the subject; people who are confused by the amount of options and operations of e.g. Enigmail or kleopatra. My approach was: "Show less, require more clicks (selection steps)"
I do not think that this is a big difference. Furthermore: The GUI doesn't care whether it belongs to a limited (key management) application which is completely covered by it or whether it is part of a larger application and covers just a certain part of it. Does it? You could even use the same GUI twice (both for the key management application and as part of a bigger one).
Mine was intentional. Without having the benefit of your discussion I guess that "key" is good enough for the no clue target group. I wanted to avoid everything (as far as possible) that would probably confuse this kind of user. BTW: I went very slowly through the whole process (together with a friend who was not familiar with crypto at all): installing Gpg4win, installing Enigmail, configuring Enigmail. I am quite sure that I have reached a certain above-
average level of OpenPGP understanding so it was kind of fun to notice that the normal key generation with Enigmail lead to a question / option which not even I understood... (but that's made by people who think it's clever not to show any certificates by default, WTF...)
Really? Importing leads you directly here:
And: This is a two-level import (using an additional keyring) so that keys do not become available to applications before the user has
1) either stated that he has verified the key
2) or stated that he doesn't care
And even in case (2) shows in a very simple way that the key has not been verified yet.
Compare that to 1) gpg not showing the UID (or overall) key validity by default
2) Enigmail not even being capable of showing it
3) the nightmare GUI of kleopatra
In all these applications import and certification are independent steps (i.e. certification has to be started separately). In my proposal they are linked

@_date: 2013-12-13 21:05:59
@_author: Hauke Laging 
@_subject: show-uid-validity default to yes 
Am Fr 13.12.2013, 15:37:59 schrieb Werner Koch:
Strange argument IMHO. Would you say the same about Linux? 99% of the desktop users don't know that there is a shell / console layer thus it's not important whether Linux has a good shell?
I think in both cases the 1% are much more important than their tiny share implies because it is mostly the users who are very familiar with a software who care about spreading it.
On the other hand we should support the development of pure users to users with relevant knowledge. This development is supported by a better console tool. Thus I believe that it does make sense to think about it how
1) gpg can be made easier to use
2) gpg can help the users understand the situation better.
Maybe. But it is trivial to check whether gpg runs as part of a script, isn't it? It already does so today. I have forgotten where it is done but some output formatting is changed depending on whether the output is written to a tty or not.
And if someone writes a script with such tricks that the script environment cannot easily be detected and then even complains about that then my reaction would probably be non-verbal.
It might be easier to decide to have some changes if these are not planned for future versions of 1.4 or 2.0 but for 2.1 only. There have been output format changes from 1.4.x to 2.0.x, too.
And to avoid a situation wich such arguing in the future (i.e. 2.1.x) it might be a good idea to "enforce" avoiding the use of non-script output for scripts by making small changes (irrelevant to the human reader) in the output format in every version.

@_date: 2013-12-14 00:05:48
@_author: Hauke Laging 
@_subject: Revocation certificate for sub key? 
Am Fr 13.12.2013, 22:56:07 schrieb adrelanos:
--edit-key 0x12345678
key 1

@_date: 2013-12-15 02:54:43
@_author: Hauke Laging 
@_subject: Revocation certificate for sub key? 
Am Sa 14.12.2013, 17:01:23 schrieb adrelanos:
It does create a revocation certificate. But it imports it automatically. There is a simple solution, maybe (matter of taste) easier than dkg's Make a backup of the key (i.e. export both secret and public key), do the above, export the certificate (public key), delete both secret and public key and import your backup. The exported certificate contains the revocation You may reduce the file by deleting all but one UIDs and all other subkeys after the backup and before the revkey.

@_date: 2013-12-17 22:31:40
@_author: Hauke Laging 
@_subject: encryption algorithm 
Am Di 17.12.2013, 15:57:54 schrieb Daniel Kahn Gillmor:
There are non-technical arguments against your position. No, Rob, I don't have a scientific study for that but I guess (and invite everyone to follow mw with this) that using something above the minimum but below the maximum serves an educational purpose.
I believe there is a broad agreement that you need to *learn* what good crypto is (involving the whole process containing crypto, not just the small crypto element) to get "security". One more wild guess: 99.9% of the systems on which GnuPG is *actively* used do not even provide the "equivalent" of a 73-bits If the 99.9% get 2048 bit by default then they ask: "Why not more?" That can be kind of annoying here but at least they ask and get told. And some probably understand. That's a security gain. If they notice "I have maximum security now" because the default is raised to 4096 then they will not ask but often make stupid assumptions about their overall security.
Effective use of crypto mandatorily demands for some understanding. It is trivial for everyone with this understanding to select the key size. So what real-world problem is going to be solved here?
And what could be the "expected key strength" for users with no clue about I support dkg with respect to the digests, though. And I think that GnuPG really needs an option like personal-digest-disallow. Sende-recipient negotiation all well and good, but it must be possible to say: Not me! Even against the RfC. With such a command line option an application can easily limit that to certain cases (though the validity calculations must be configured globally, of course). We should not expect the applications to filter disallowed digests. Often the crypto knowledge of application developers is limited.

@_date: 2013-12-18 13:02:15
@_author: Hauke Laging 
@_subject: Synchronize UID lists on public and private key -- how? 
Am Di 17.12.2013, 10:40:21 schrieb Doug Barton:
I can reproduce the problem but it doesn't make any sense to me. Why are UIDs stored in the secring...?
But it is possible to sync pubring and secring (i.e. the answer to the OP's question is yes, not no; whether it's fun...):
mkdir split-pub split-sec
cp public.gpg split-pub
cp secret.gpg split-sec
cd split-pub
gpgsplit public.gpg
# looks like this:
cd ../split-sec
gpgsplit secret.gpg
# looks like this:
cp ../split-pub/000004-013.user_id ../split-pub/000005-002.sig .
cat 00000* >secret.split.gpg
gpg --delete-secret-key 0x12345678
gpg --import secret.split.gpg

@_date: 2013-12-22 06:44:01
@_author: Hauke Laging 
@_subject: Viewing a key revocation reason 
Am Sa 21.12.2013, 19:24:51 schrieb Dionysis Zindros:
Not much better ;-)
gpg --list-options show-sig-subpackets --with-colons --list-sigs |     grep ^spk:29:

@_date: 2013-12-23 21:07:08
@_author: Hauke Laging 
@_subject: Bug: --list-packets ignores second public key 
I was just in a slightly embarrassing situation: I had a look with gpg --list-packets
at the certificate(s) on
This is the (shortened) output:
 :public key packet:
:user ID packet:
:signature packet:
:signature packet:
:user ID packet:
:signature packet:
:signature packet:
:user ID packet:
:signature packet:
:signature packet:
So I told the site owner that there was (in contrast to his statement above) just one certificate on the page. I had to realize that gpg sees both public keys when importing the block instead.

@_date: 2013-02-05 15:52:26
@_author: Hauke Laging 
@_subject: GPG Decryption Issue 
Am Di 05.02.2013, 17:19:38 schrieb Kamalakannan N:
1) either the application runs as a different user so that the secret key is not contained in the application's keyring
2) or there is a problem with gpg-agent (the key is protected by a passphrase and gpg-agent does not know the passphrase)

@_date: 2013-02-06 11:37:30
@_author: Hauke Laging 
@_subject: More secure than smartcard or cryptostick against remote attacks? 
Am Mi 06.02.2013, 10:28:13 schrieb Peter Lebbing:
That seems easy to me: Except for small amounts (secure device's display capacity) of very simple data (plain text) you have the problem that the PC which you need to create (and view) the data to be signed sends a blob to the secure device which is opaque to you.
The problem is not to forge a signature but the difficulty to force that only data with checked integrity gets signed. How are you going to do that with a The only possibility I see is that the secure device shows you the hash of the data to be signed. IIRC unfortunately OpenPGP does not sign the data hash but the hash of the combination of the data and signature metadata which really doesn't make this easier. So you would need a secure device which you can give both the data and the metadata so that it can show both (in case of the data: just the hash) to the user. Then you can (safely...) copy the data to several PCs and have them show you both the file hash and the document (in that order). Hoping that at least one of the PCs is not compromised.
I really hope that the next version of OpenPGP will sign data and metadata separately (and allow for multiple hashes of different types in the same signature) to get rid of this annoyance.

@_date: 2013-02-06 12:55:16
@_author: Hauke Laging 
@_subject: GPG Decryption Issue 
Am Mi 06.02.2013, 13:10:32 schrieb Kamalakannan N:
prompt ,CMD say's that my keys are already in keyring . but as fare i knew there is two different ID for different keys. Unfortunately I cannot see how you have cared about what I wrote you. You just repeat your statement. How shall that help?
You have to ensure that both your command prompt call and the call by the application use the same file.
1) The application could run as a different user.
2) The application could run chrooted.
3) The application could be restricted in its access rights by some LSM (Apparmor, SELinux or similar).
Thus do this:
a) Compare the output of
gpg --list-options show-keyring --list-secret-keys
from both the command prompt and the application
b) Is the secret key protected by a passphrase?

@_date: 2013-02-07 08:02:57
@_author: Hauke Laging 
@_subject: GPG Decryption Issue 
Am Do 07.02.2013, 10:28:29 schrieb Kamalakannan N:
Take the passphrase off the key and check whether the batch file works then.
batch file through Datastage Application . output E:\Data\qfbi\Navtech\Working\NJS170203YBBNA.xml --decrypt E:
\Data\qfbi\Navtech\Input\NJS170203YBBNA.gpg Put this into the batch file for testing:
1) gpg --list-options show-keyring \
--output E:\Data\qfbi\Navtech\Working\keyring.txt \
2) copy E:\Data\qfbi\Navtech\Working\passphrase.txt \

@_date: 2013-02-12 21:30:12
@_author: Hauke Laging 
@_subject: migrate to offline gpg master key 
Am Di 12.02.2013, 16:01:02 schrieb refreshing at tormail.org:
That statement is too wide. The main key should never be *used* (or: usable) on an insecure system. If it is protected by a secure passphrase ([a-zA-
Z0-9]^18) which is never entered in an insecure system then there is no relevant risk.
Get a safe system (or a safe boot medium for your normal system). There you import the key (or unlock it) and do what's necessary. Any specific questions? It boils down do export the public keys or the secret subkeys on the safe system afterwards and import them on the insecure system.
In case you understand German (it's not comprehensive yet, though):
In the context of smartcards this is mentioned on the FSFE site:

@_date: 2013-02-12 21:31:04
@_author: Hauke Laging 
@_subject: how to use invald e-mail? 
Am Di 12.02.2013, 16:20:16 schrieb refreshing at tormail.org:

@_date: 2013-02-13 11:55:59
@_author: Hauke Laging 
@_subject: Unable to access Crypto Stick with gpg2 
Am Mi 13.02.2013, 07:46:31 schrieb Jan Ignatius:
I think this is the relevant problem with thr rest being the result of that. What are the access rights for the reader? Can your user account access it? Perhaps you need a suitable udev rule.

@_date: 2013-02-13 23:32:29
@_author: Hauke Laging 
@_subject: Unable to access Crypto Stick with gpg2 
Am Mi 13.02.2013, 20:16:01 schrieb Jan Ignatius:
That's easy:
lsusb shows you the bus and device number.
ls -l /dev/bus/usb/002/
for all devices on bus 2 or
ls -l /dev/bus/usb/002/006
for a single device, the 6th e.g.
I think that means that you have connected the device to bus 2 which is a USB 1.1 bus. The kernel has given the device the number 5. This is not always the same. If you disconnect and reconnect it will probably have the next number. No idea whether there is an overrun after 999 ;-)
So you should see the access rights with
ls -l /dev/bus/usb/002/005
You may configure udev so that a symlink is created (/dev/cryptostick-0 or the like) and that the device rights are set accordingly. But that is not GnuPG-

@_date: 2013-02-14 18:51:13
@_author: Hauke Laging 
@_subject: Unable to access Crypto Stick with gpg2 
Am Do 14.02.2013, 19:38:05 schrieb Jan Ignatius:
The daemon group has... But is this group in the list of groups of the scdaemon process? That's not a SUID/SGID binary. So if you are not in this group then scdaemon started by you (or by gpg-agent started by you) won't be

@_date: 2013-02-21 16:53:51
@_author: Hauke Laging 
@_subject: Bug in documentation? --gpg-agent-info 
my man page (for GnuPG 2.0.19) says both
              This is dummy option. It has no effect when used with gpg2.

@_date: 2013-02-26 15:16:17
@_author: Hauke Laging 
@_subject: Revocation certificate creation 
Am Di 26.02.2013, 14:37:49 schrieb Olav Seyfarth:
I am a big fan of hints, too. If these get improved / extended an option like
  --no-hints=all
  --no-hints=noencryptionkey,norevocationcertificate,...
may be offered for those who feel bothered as a very easy, trivial to maintain feature. Or
  --no-long-hints=...
in case the short texts get longer. These hints should contain the URL of the respective gnupg.org doc page, too. IIRC this is already done for non-cross signed signing subkeys.

@_date: 2013-01-15 17:10:06
@_author: Hauke Laging 
@_subject: Problem with keys 
Am Di 15.01.2013, 18:49:43 schrieb Leo Treasure:
This is the expected behaviour. Why don't you want to use your subkey?
You can force the usage of the mainkey:
--local-user  0x1a571df5\!
--default-key 0x1a571df5\!
(the \ is for the shell and not always necessary)
The main key should not be available for normal usage. The keyword is: offline

@_date: 2013-07-06 21:52:51
@_author: Hauke Laging 
@_subject: GPG keys for multiple email accounts 
Am Sa 06.07.2013, 19:00:47 schrieb atair:
That's a strange argument for several reasons. The most important being: Why should just one key be compromised if they are used on the same system?
Wouldn't it make more sense to put the saved effort for creating 19 additional keys into securing the system, making it less probable that the key gets Even with the default settings a 19-digits passphrase (upper and lower case ASCII letters and digits) is as hard as AES (without flaws). If the passphrase is completely random then it is ridiculous to make it longer than 19 chars (unless you store it in two halves (with about 18 chars each) in different You need only one good passphrase for all your offline-mainkeys. It makes little sense to protect a key with a huge passphrase in the system on which the key is used (unless the system does not have disk encryption). The real threat to keys in this situation are online attacks. And if someone manages to break into your system then he probably manages to read your keyboard input, too. gpg-agent (as a running process) is not really protected by default, too.
You can write a script which reads the passphrase once and loads it into gpg-
agent for several keys.
That doesn't make sense. User IDs belong to email addresses. Subkeys belong to their mainkey only (on the same level as user IDs belong to a mainkey).
My recommendation:
Separate keys by email address type:
a) private (one group)
b) each business separate
c) each organization separate
Also separate the private addresses by
a) security level (some may not need OpenPGP at all; some may be read via webmail others only on systems you control)
b) seriousness (hauke.laging at example.org maybe should not be grouped with superman123 at rpgchat.example.net)
You should NEVER use mainkeys outside a safe environment (boot from CD/DVD). Only subkeys should be used on normal systems.
That's not the problem. The problem is that you have others to verify all your keys. If all your contacts use just one of your addresses each then that is not a big difference though. But you should always have some slips of paper with your fingerprint with you. That may be a bit annoying for 20 separate Why should the risk of losing the private key be higher than the risk of losing access to the LUKS volume? If your key is protected by an 18-chars passphrase then you can put a backup on your web site.
Problems like not being taken seriously?
Says who?
If you do not trust the channel (SSH, USB stick) then you make sure that the passphrase is hard enough before you copy it.

@_date: 2013-07-07 05:11:21
@_author: Hauke Laging 
@_subject: GPG keys for multiple email accounts 
Am Sa 06.07.2013, 19:53:16 schrieb Tim Chase:
I often help people create high quality keys and even try to educate future instructors ( I was forced to think about that a lot...
That's a new situation for me; I am not aware of resources which cover that. But what comes to my mind: Is it really necessary that each of these addresses becomes a user ID? Technically it is not a problem to send an email to foo at example.org but encrypt it to the key with the single UID bar at example.org. You just have to configure the mail client that way. And the mail client wants (at least once) a confirmation for the key to be used anyway. Whether this is an option probably depends on the precise circumstances how you use these You may even create ten UIDs but publish only one of them. For every address you create a version of the public key (certificate) which contains the main UID and the one for that address. Due to "stupid" keyservers and users it can happen though that the recipients of these keys upload them to a keyserver so that these UIDs appear in the public unwantedly.
The relevant key word is "offline mainkey". Ask your favorite search engine. I have written a few articles for the KDE userbase wiki which cover that:
There are English tutorials for this. I can offer mine in German only:
I have written a quite comprehensive bash script for the generation of good keys (with an offline mainkey, of course). Up to now this is in German only, We really need the GUIs to get better.
That is completely wrong. A keyring is not unlocked. Single keys are decrypted (and cached). And "single keys" means that a mainkey and all of its subkeys have to be "unlocked" separately. I am not sure but I guess that gpg-agent does not cache the passphrase but the decrypted key instead. Thus even though gpg cannot set different passphrases for different components of the same key, you have to enter the same passphrase three times if you have two subkeys and first decrypt something then sign something and at last certify something.
The mainkey is in danger if its passphrase is ever entered on an insecure system (if it is not physically really secure). Thus the mainkey should have a passphrase different from that of the subkeys. The mainkey passphrase should be cryptographically secure (16+ chars). As long as you never enter this secure passphrase in an insecure environment you can even store the secret mainkey in the same keyring as the subkeys (which requires some tricks and is of no use at all).

@_date: 2013-07-07 14:24:34
@_author: Hauke Laging 
@_subject: GPG keys for multiple email accounts 
Am So 07.07.2013, 09:42:59 schrieb Heinz Diehl:
You're missing several important points:
1) AES is considered a lot stronger than AES-256 meanwhile as the latter is down to 99,5 bit.
2) GnuPG has a default setting of 65535 iterations.

@_date: 2013-07-07 18:50:16
@_author: Hauke Laging 
@_subject: GPG keys for multiple email accounts 
Am So 07.07.2013, 10:18:46 schrieb atair:
The mainkey is primary for certification (this refers to key components), not really for signing (which refers to (other) data). Signing with a mainkey makes sense in certain situations though. One important example is the document with your key policy.
I let both my mainkeys and subkeys expire after one year. You don't have to throw them away afterwards. You can simply create a new signature / certification with an expiration date later in the future.
You always have one. You probably meant "no second".
I recommend to have one UID without an email address. Just your name and a comment, something like "key for private addresses; secure offline mainkey".
That is done automatically when you add UIDs.
You have to publish a complete certificate. You cannot leave out the public mainkey. Without it neither the fingerprint nor the UIDs or subkeys could be verified by the importing application. The fact that you have an offline mainkey does not influence your certificate ("public key") in any way (except for maybe mentioning this fact). The sending application automatically selects the subkey for encryption. OK, to tell the truth: GnuPG does that. I am not even sure whether the RfC demands that. If you want to be sure you may create the mainkey without the flag for encryption (--expert --gen-key). But this would prevent you from using the mainkey as a high security key (useful if you don't have a separate one).
Pseudonyms may make sense. I don't think there is a case in which an illegal email address does. Of course, that somebody believes that you haven't understood OpenPGP does not mean that he knows more about it than you... These are rather social than technical problems. You alone have to handle them, your point of view is the relevant one.

@_date: 2013-07-07 19:26:35
@_author: Hauke Laging 
@_subject: Do we need / want (or already have) a mascot for OpenPGP? 
for the first time in history(?) cryptography has become a subject for mainstream media. Over the last weeks my web page got a visitors increate of 600+% for the key word "openpgp".
That's nice but crypto still has a "rather low" fun factor. I don't claim that the fun factor is the decisive part of a possible "success" of mainstream crypto but it may make the work of some promoting people easier. And maybe we can get this without much work.
Linux has its cuddly penguin, BSD its devil, openSUSE the chameleon... Whether the GNU gnu increases the fun factor is a difficult question... ;-)
I guess it would be good to have something like that for OpenPGP. Something that people both like and recognize. Something that both instructors (OpenPGP courses) and private people, companies and other organizations which use it can put on their web pages in order to create awareness.
I would prefer something with a strong appearance, a smiling rhino or gorilla maybe. :-)
I am a total artistic black-out so I can hardly do more about that than say "I would like to have it". But if it turns out that there is a broad agreement (above all among those who publicly promote crypto) that it would be nice to have something like that then we might search for talented volunteers in the

@_date: 2013-07-08 06:38:00
@_author: Hauke Laging 
@_subject: Do we need / want (or already have) a mascot for OpenPGP? 
Am Mo 08.07.2013, 04:30:32 schrieb Henry Hertz Hobbit:
I didn't write "mascot for GnuPG". I don't want people, companies and other organizations to say "We use GnuPG" (though it may be appreciated if they do) but I want them to say "We support OpenPGP". So that's not really the same.

@_date: 2013-07-12 12:53:56
@_author: Hauke Laging 
@_subject: Do we need / want (or already have) a mascot for OpenPGP? 
Am Do 11.07.2013, 09:41:21 schrieb Burkhard Schroeder:
The Cryptoparty mailinglist loves their idea of using a turtle. I like that because it would be a symbol (even more than a hedgehog) for:
"It takes some time to get things done securely"

@_date: 2013-07-13 15:39:11
@_author: Hauke Laging 
@_subject: Error verifying encrypted and signed message 
Am Sa 13.07.2013, 15:28:41 schrieb Thorsten Steinbrenner:
That is impossible. In order to check a signature you must first be able to read it (and, of course, the data it refers to).
But you can decrypt it and throw the data away:
gpg --output /dev/null file.sig+enc.asc

@_date: 2013-07-13 19:36:46
@_author: Hauke Laging 
@_subject: OpenPGP goes TV in Germany 
this may be interesting for some of the readers of this list:
Monday and Wednesday next week (15th, 17th) my OpenPGP course at Berlin Linux User Group
will be visited by three or four German TV crews plus one Ukrainian. So you at least don't have to be (too) afraid that technical nonsense gets broadcasted... ;-)
The first report will be on air in the ARD Nachtmagazin on Monday, part of the tagesthemen probably the next day. I do not know yet when N24 and ZDF are going to broadcast this. But I will announce that when I know it here:
The rather strange reason for that is that they actually wanted to shoot at Cryptoparties but their paranoid organisers (slightly misunderstanding their own aim of making the general public familiar with crypto) didn't allow that.
We jump at the chance and change my "once per month with small group" OpenPGP-
only event to a complete Cryptoparty offer with one real event per week (with rotating subjects, only one per event).
Furthermore we (or at least me for OpenPGP) will offer to teach future instructors for other events and offer them to gain (supervised) experience with our course before they give one on their own. This should help getting more people willing (and qualified) to do that.
Obviously I am not really neutral in this assessment but I consider OpenPGP the lead technology for making the public familiar with all the Cryptoparty stuff (crypto on the one hand, anonymization on the other).
I will use the remaining time to improve my site
       But anyone who understands German is invited to have a look at it and make suggestions for improvements befor it gets hit by the big wave next week...
Heading at ten million OpenPGP users in Germany in ten years...

@_date: 2013-07-26 00:39:41
@_author: Hauke Laging 
@_subject: Why trust gpg4win? 
Am Do 25.07.2013, 18:31:17 schrieb Robert J. Hansen:
No. That is a question that can easily be answered by the public (in both directions) and already has been answered here. Not the "why" is up to him but the final "whether" is. :-)

@_date: 2013-07-30 01:02:06
@_author: Hauke Laging 
@_subject: change passphrase in batch mode 
is it possible to change a passphrase in batch mode?

@_date: 2013-07-30 12:57:08
@_author: Hauke Laging 
@_subject: change passphrase in batch mode 
Am Di 30.07.2013, 09:28:24 schrieb Werner Koch:
I am limited to the content of Knoppix (which is 1.4.x). Is it possible to write a pinentry wrapper in shell code (again: limited to what Knoppix has) or does that require more sophisticated programming?

@_date: 2013-07-30 21:54:49
@_author: Hauke Laging 
@_subject: gpg-agent: What is a keygrip? 
I just had one of these unpleasant moments when you realize that you haven't understood something you believed to have understood for quite a while... :-/
gpg-agent identifies keys by their keygrip. But gpg-agent cares about secret keys only. So by my naive understanding the application talking to gpg-agent cannot know the keygrip of the key material itself. Because gpg-agent does hide this key material from the application.
Is the keygrip computed over the passphrase-protected key material (which the application knows)? I.e. does the keygrip change if the passphrase changes?
Or does gpg-agent use only pairs of secret and public keys and the keygrip refers to the public key?
Another gpg-agent problem:
It seems to me that you can only check for keys which you know. Is it possible to get a list of the known keygrips from gpg-agent? I create keys in an account with an empty keyring thus getting only one keygrip would be

@_date: 2013-07-31 03:05:31
@_author: Hauke Laging 
@_subject: Different passphrase for subkey 
Am Di 30.07.2013, 22:58:37 schrieb atair:
What you are probably looking for is an offline mainkey (see --export-secret-
subkeys). But the answer is: yes. gpg-agent does not care about the connection of keys. It asks you even for the same passphrase several times (for different components of the same key).
But GnuPG does not support this directly.
1) Export the secret key (--export-secret-keys without --armor)
2) change the passphrase
3) Export again (to a different file, of course)
4) Use gpgsplit on both files (in different directories). The result looks like this:
5) Now you mix the components of the two groups:
mkdir combined
mv a/000001* a/000002* a/000003* combined/
mv b/000004* b/000005* combined/
cd combined/
cat * > different_passphrases.gpg
6) Delete the key from secring: --delete-secret-key
7) Import the new one: gpg --import different_passphrases.gpg

@_date: 2013-07-31 03:09:07
@_author: Hauke Laging 
@_subject: "Certify" only master key 
Am Di 30.07.2013, 23:10:54 schrieb atair:
You give the answer yourself:
But that is not your case. You have a signature subkey. I.e. you must force GnuPG to use the mainkey for signing. GnuPG would never try to use it under normal conditions.
So you can if the mainkey can sign, too.

@_date: 2013-06-08 00:49:23
@_author: Hauke Laging 
@_subject: Recommendations for handling (multiple) user IDs - personal and 
Am Fr 07.06.2013, 13:22:04 schrieb Doug Barton:
The interesting point is: Has it worked well for them, too? Or was just the pain of retiring the key (to separate the roles later) too heavy? ;-)
Meanwhile I am convinced that most OpenPGP users don't think a lot about what their key should look like before they generate / publish it.

@_date: 2013-06-08 00:54:40
@_author: Hauke Laging 
@_subject: Recommendations for handling (multiple) user IDs - personal and 
Am Fr 07.06.2013, 22:09:01 schrieb Branko Majic:
With backup? If not: Are you sure this card is going to survive for 15 years?
In addition to what Doug has said: I recommend to have one UID without email address. Just your name and a comment (like "everyday key on smartcard with offline main key; see policy URL". There is no risk of losing the certifications for this UID just because you don't have an email address any

@_date: 2013-06-08 17:22:00
@_author: Hauke Laging 
@_subject: How do you show a list of cached keys in gpg-agent? 
Am Sa 08.06.2013, 10:42:51 schrieb Peter Lebbing:
I am afraid that is not what the OP wants to know. "Cached keys" in the sense of "ssh-add -l" are keys whose passphrase is cached. But gpg-agent gives you a list of all keys it knows (however). I remember having read that it is explicitly impossible to get a list of the keys with cached passphrases from I just tried the command (for the first time) and something strange happens. I get a list of five entries. Four of which seem to belong to keys on smartcards. None contains a fingerprint. Then I opened an encrypted email, was asked for a passphrase (which was cached: I could open other encrypted emails afterwards) but the output of "KEYINFO --list" didn't change at all! There is only one instance of gpg-agent running...

@_date: 2013-06-08 21:21:17
@_author: Hauke Laging 
@_subject: Recommendations for handling (multiple) user IDs - personal and 
Am Sa 08.06.2013, 13:03:06 schrieb Daniel Kahn Gillmor:
Crypto is NOT about comfort but about security. The point is: Does a certification make sense? Most certifications I see do not.
They come without a certification level, without a policy URL, usually have no (especially not a reliably signed) key policy and are usually not made by offline main keys (or similar). In the end: more or less worthless. The WoT in its current form is occupational therapy for people who refuse to do crypto right (or rather: don't know what that means).
Who cares? The question is: Does such a UID make the key better (with or without the WoT)? And if the answer is "It does", who would dare argue against that with the vague definition from the RfC?
A comment may be a statement about the function of the key owner in an organization and thus is an important part of the identity. This is explicitly intended by signature law! Such a comment should be certified by the organization's certification key only. That it does not make sense that everyone signs a comment does not make the comment useless or bad in any way.
You have to read the comment statement and its certification right. It obviously doesn't mean "I have checked that this is true" as everybody immediately understands that it is not possible for the certifier to check this. Instead it means: "I testify to it that the key owner makes this statement about the certified key." And statements about keys are damn important. You cannot do secure crypto without them.
You are right insofar as in a perfect world this information might better be placed elsewhere (standardized, machine readable signature notations). But in this world and this time not even policy URLs are shown by default. Thus for maybe the next five years it is definitely a good idea to put the most important information about a key into a UID.
Sorry but the example you use on that page is ridiculous. It doesn't prove anything about UID comments except for the trivial fact that it is possible to use them for ridiculous purposes. You really should not leave that online.
If someone makes a statement about the security of his key and decides to change this statement for the same key (no matter in which direction) that would be self-sabotage. Stupid behaviour but not nearly an argument against statements about key security. And such statements are useless if they are not certified. It would make sense that the certifier demands that statement on paper with a manual signature.

@_date: 2013-06-10 05:14:05
@_author: Hauke Laging 
@_subject: Recommendations for handling (multiple) user IDs - personal and 
Am Sa 08.06.2013, 16:16:18 schrieb Daniel Kahn Gillmor:
This is much more about understanding the connections and seeing what's necessary to achieve a certain goal. And understanding which is the right goal in every single case. I remember the professor in my first computer science course: "Many people talk about reducing the complexity of a problem. That's nonsense. You cannot reduce the complexity of a problem, that is a fixed value. You just can work on the problem in small pieces."
I see people doing stupid things with crypto all the time. Why? Because they don't understand the connections. You cannot throw Enigmail and GPA at clueless people and pretend they were capable of using OpenPGP seriously now just because it *looks* simple to *them* now.
I tell the people who attend to my courses: "For get the Web of Trust. That is not for beginners. You neither need it now nor understand enough of the subject to use it well." But I tell them to have a look at my key policy template. So that they get an impression what is important about keys.
You mean like GnuPG itself (including all GUIs)? What I want does not make OpenPGP more complicated (in the usual sense). The GUI would ask you a few simple questions. That requires time but not deep understanding. You don't even have to understand what an offline main key is in order to testify to the key owners claim of having one.
What do you think how many people who use OpenPGP today wouldn't use it if the WoT didn't exist? The WoT is a playground for statistics but for whom is it a killer feature? And who would use it for really serious purposes (high security demand)? I don't see any reason to consider the current WoT as a big success which would be exposed to danger by what I promote.
The reason hardly anybody uses crypto is not that its usage was complicated (I know, I a minute Rob will post his usability study link and ask for my sources...). It isn't. Not the basic operations if you have a working configuration. And for the rest the users can ask for help.
The reason that most people do not use crypto is the most trivial one: They don't think they need it.
But if you think you need it and if you understand the connections would you really accept the low security level ot the WoT just for some comport? Probably not. You would not use the WoT for important issues.
You are aware that I strongly critizise the current state?
There is no relation between the precision of a key and UID verification and the social contact.
I wouldn't agree that you argue there. I read a lot of opinion. I would prefer facts and connections which support an opinion.
That is my long term aim. But until there is a widely used standard we will need human-readable text at least in parallel. It doesn't make sense to have to read something that can be made machine-readable. Noone is interested in reading 30 key policies after a key signing party.
The complicated mess is going to be hidden by the GUI.
I am (but how should you have known...):
But there isn't much yet as I am busy with my courses project.
It's not at all. Nobody would prevent a user from doing certifications like today. But my aim is to make most users take the WoT security not seriously any more.
My approach is a chance. To leave the low, hardly useful level of the current WoT behind. And there is another chance: If enough people use OpenPGP someday then you don't need a big amount of signatures any more. If you have 20 highly trustworthy signatures (from your family, long term friends and the like) that will be enough. And all the saved time which you use for another 100 signatures today can be used for making the certifications better.
It is not "too complex" in an absolute sense. We are not talking about rocket science. It is "too complex considering there is no demand to do it right". If more and more people use crypto then social pressure will arise. 15 years ago it wasn't a problem in Germany not to have an email address. Nobody would have considered you and idiot or otherwise strange person if you didn't have one. This has changed. And it will change similarly for crypto. In another 15 years it will not be possible not to use crypto without being laughed at.
But if I promote a system for the whole population then it must be good enough for that task. It must be capable of delivering (in practice!) security and transparency on a level similar to what the crypto laws demand.
The OpenPGP userbase is ridiculously small. And BTW: The WoT knowledge even among people actively involved with OpenPGP is ridiculously low. You don't even find the relevant details in the documentation on gnupg.org. When I was writing about the WoT (which I had not used at that time) on my OpenPGP page I didn't find a single really good source about the subject. After acquiring the knowledge myself through intense testing I found a dozen errors on the probably best German OpenPGP resource. If I talk to people who organize key signing partys it turns out that none of them is familiar with the details. Thus I consider the WoT a joke meanwhile.
There is obviously no public usefulness of OpenPGP as a whole given the irrelevant user base. So how can the WoT be a great feature if not even the base technology is?
We must teach the public about the need and benefits of crypto for them but also about the complexity. Either you need security or you don't but you will not get it for free. The aim is not to pull everyone on a high security level. My aim is to have a system which fulfills the needs of different types of No, you misunderstood me. This is basically your argument: It doesn't make sense to certify certain statements because you cannot verify them. If the statement is "This person is the CEO of that company" then this is a plain fact (which is going to change over time though) but hard for most people to assess. Thus only the company (and maybe an authority where the CEOs must be registered) should certify such a statement. Everybody else should certify the name and email address only (which the current OpenPGP does not offer you unless there are separate UIDs).
This information can be put elsewhere. But today that would make little sense as hardly anybody would notice. Who knows what a key policy is? Those who don't will certainly not look for it. But if someone reads "offline mainkey; see policy URL" in my UID comment then he may get curious about that, learn something about crypto and use it better in the end.
But I don't see any reason to avoid that in a UID. There is not just one identity "Hauke Laging" (even if noone else has that name). There are "Hauke Laging, private person", "Hauke Laging, employee", "Hauke Laging, founder of an OpenPGP teaching project" and these identities are quite separate from the perspectives of people who are in contact with me in those different areas. So why should such an additional information in a UID not help those who use the key? It may help them even if the certification becomes more difficult for I mainly think that the default should be that everbody has one. If nearly noone has, why should they be shown?
The interface can get better. The problem is IMHO not the interface, not at all. The problem is that the people do not learn crypto like they learn other things. Most people do not have someone they can ask. If everyone learnt that at (e.g.) school then nobody would consider that complicated any more. At least not more complicated than using email, making web pages or office That's one of the really important questions. I thing I already mentioned it above: I want EVERYONE to use crypto (not all on the same level, though). But I am convinced that this is primarily about
a) convincing people that they need it
b) teach them well
I don't think that the "visible complexity of crypto" should be stripped down so that everyone believes he can use it after having seen a 10 minutes video and done a few clicks. We should go for a consensus about what crypto users should know / have understood. In parallel we should make the system better so that it suits the needs of more people. And most important: We have to teach others. One of my better recent ideas:
I want software which supports crypto but is used without it, too, to point its users at crypto teaching resources.
I wasn't aware of that but that is not an argument against comments but an argument against stupid comments. This would not happen if most users did not create their keys by themselves but with professional help. You can do so much wrong when generating a key. You cannot demand from a new user to understand all that in advance. The more as key generation is rather useless knowledge for him. Thus: Get potential users into courses and we automatically get rid of most of the stupid UIDs.
I agree with that. If I suggest changes Werner always says: "The GUIs should handle that." But is there a single good graphical key generation tool available? One that gives you all the information you need? One that is at least capable of creating offline mainkeys? I am not aware of one. The GUIs have to become a lot better. Fortunately I am in contact with a KDE developer who intends to work on the crypto part of KMail and KGpg. I am sure that even with little development effort big improvements are possible.
That makes sense only if this document is signed by others, too (those who certify your key). And even if they did: The result would be invisible for most users today.
Maybe not. But nobody would be forced to do it that way. Why should experts and newbies make the same kind of certification? Why limit the experts?

@_date: 2013-06-19 00:10:58
@_author: Hauke Laging 
@_subject: gpg --fingerprint show only fingerprints and nothing else? 
Am Di 18.06.2013, 20:34:50 schrieb adrelanos:
gpg --with-colons --fingerprint | awk -F: '$1 == "fpr" {print $10;}'
It won't (it's designed not to change).

@_date: 2013-06-19 02:41:54
@_author: Hauke Laging 
@_subject: wishes for improved digest handling 
1) I just noticed that you can enforce the sender to make a SHA-1 signature (if he also encrypts the message) by clearing the digest preferences (or setting it to SHA-1 only). I am aware that this is done in compliance with the RfC. I just want to suggest that a warning is issued if a digest is used which is not listed in --personal-digest-preferences.
2) I would also like to suggest to allow the usage of --recipient with --sign (without --encrypt) because it makes sense. The digest compatibility checking is not related to the encryption so IMHO it doesn't make sense not to allow it without encryption. If recipients are given for a signing operation then the result should be that a digest is chosen which is explicitly compatible with all intended users of the signature. The code is already there. Even the case "--recipient without --encrypt" is detected. Thus this should be a quite small change to the code (replace the warning by calling the digest selection).
3) Last wish: I would like to have an option for explicitly forbidding the use of certain ciphers or digests. This affects only those which are defined in the standard as fallback (a mistake which should be avoided in the next OpenPGP version). I don't see any sense in optimizing a crypto application for compatibility instead of security.

@_date: 2013-06-19 14:19:51
@_author: Hauke Laging 
@_subject: cleartext signature: digest determination 
in RfC4880 I read this:
?If the "Hash" Armor Header is given, the specified message digest    algorithm(s) are used for the signature.  If there are no such headers, MD5 is That doesn't make sense to me. I checked a cleartext signature with gpg --list-packets and got this:
:signature packet: algo 1, keyid 4CB66C1B33FB59FC
        version 4, created 1364174035, md5len 0, sigclass 0x01
        digest algo 2, begin of digest a1 0d
        hashed subpkt 2 len 4 (sig created 2013-03-25)
        subpkt 16 len 8 (issuer key ID 4CB66C1B33FB59FC)
        data: [4093 bits]
This looks like a normal signature packet to me, and it does contain the used digest algo. So why should it be necessary to write the used digest into the cleartext part? Is that a compatibility issue with older OpenPGP versions? Usually that is mentioned but not in the text I quoted.

@_date: 2013-06-26 15:30:25
@_author: Hauke Laging 
@_subject: subkeys on smartcard? 
Am Mi 26.06.2013, 15:10:19 schrieb Daniel Pocock:
That has little to do with smartcards. Mainkeys should always be stored and used safely ("offline"). Smartcards are typically used in an unsafe environment. If the mainkey is on the card then it can easily be accessed by an attacker. The key cannot be stolen but be abused.
Highly secure mainkeys are the last line of defense. If even they are potentially compromised there is nothing left to trust.

@_date: 2013-03-04 03:01:06
@_author: Hauke Laging 
@_subject: gpg and double quotation mark problem 
Am So 03.03.2013, 15:39:49 schrieb Shaoping Xie:
This is not strange at all as you encounter the same behaviour with more or less all programs (i.e. this problem is not related to GnuPG at all). Usually a program requires so see --arg1 and --arg2 as seperate options. "" makes the shell pass both as one string. That usually doesn't make sense to the program (and even worse: if it does then it's most probably not the intended sense).

@_date: 2013-03-26 17:46:48
@_author: Hauke Laging 
@_subject: Dump all the properties of a key? 
Am Mo 25.03.2013, 15:30:23 schrieb Jack Bates:
gpg --list-options show-policy-urls,show-notations,show-sig-expire,\
show-unusable-subkeys --with-colons --list-sigs $KEYID
gpg --list-options show-policy-urls,show-notations,show-sig-expire,\
show-unusable-subkeys --list-sigs $KEYID

@_date: 2013-03-28 02:44:30
@_author: Hauke Laging 
@_subject: Non-interactively create subkey? 
Am Mi 27.03.2013, 10:15:11 schrieb Jack Bates:
echo addkey$'\n'8$'\n'e$'\n'q$'\n'2048$'\n'1y$'\n'save$'\n' |   LC_ALL=C gpg --expert --batch --passphrase foo --command-fd 0 \
    --edit-key $x_short_id

@_date: 2013-03-31 04:46:55
@_author: Hauke Laging 
@_subject: How insecure is using /dev/random for entropy generation? 
Am Sa 30.03.2013, 20:50:48 schrieb Anthony Papillion:
gpg uses /dev/random. That's why key generation usually blocks due to lack of entropy if you do it right and boot a secure medium for key generation.
The kernel fills /dev/random from e.g. key strokes, disk accesses, and (if available and configured) internal CPU state (havaged) or a real hardware number generator. The kernel should take care that the entropy in /dev/random is "perfect".
The amount of available entropy can be seen in
To my knowledge it is not possible (without source code change) to make gpg use another source than /dev/random. But I don't know whether it checks just the path or the device number... ;-)

@_date: 2013-03-31 19:33:19
@_author: Hauke Laging 
@_subject: Why does gpg use so much entropy from /dev/random? 
Am So 31.03.2013, 10:45:54 schrieb Philip Potter:
I don't know the gpg source, the following (3) is just a guess.
1) If you don't do anything special then two keys are generated (mainkey and 2) A 2048 bit RSA key is supposed to be as secure as a 112 bit symmetric key. I don't know whether you can map a 112 bit symmetric key directly to RSA key values. You need find primes after all. Maybe the algorithm to do that consumes additional entropy.
3) Who knows how random the /dev/random output really is? I guess that the entropy quality can be increased by consuming more ("make one good bit from 16 bad bits").
strace -e trace=open,read gpg --armor --gen-random 0 16
open("/dev/urandom", O_RDONLY)          = 3
read(3, "\332\376J\314\1[\357\n7ee\303\372\3555h", 16) = 16
strace -e trace=open,read gpg --armor --gen-random 1 16
open("/dev/urandom", O_RDONLY)          = 3
read(3, "\3471=\307+n\3656\204\31!\232\270\303\324[", 16) = 16
(Strange. Werner, have I found a bug? :-)  )
strace -e trace=open,read gpg --armor --gen-random 2 16
open("/dev/random", O_RDONLY)           = 4
read(4, "\1\362P\231..."..., 300) = 128
read(4, "+7m\2314|\353..."..., 172) = 128
read(4, "\233\272~\237\..."..., 44) = 44
So we see: If high quality entropy is required then gpg reads (128+128+44)/16=18.75 times as much entropy from /dev/random as demanded.

@_date: 2013-05-02 23:41:17
@_author: Hauke Laging 
@_subject: determine encryption key without trying to decrypt 
how can I determine the key(s) for which a file has been encrypted without gpg trying to decrypt the file? I don't understand why --list-packets tries to decrypt it anyway. --batch and --no-tty do not solve the problem.
I don't consider my two ideas very elegant:
1) Call "gpg --status-fd $whatever --list-packets file.gpg", get the info from --status-fd and kill gpg
2) Start another gpg-agent, this one with --batch, and let gpg connect to this I cannot imagine that this cannot be done with the gpg call alone so I hope I just don't see the good solution.

@_date: 2013-05-02 23:53:54
@_author: Hauke Laging 
@_subject: determine encryption key without trying to decrypt 
Am Do 02.05.2013, 23:46:41 schrieb Kristian Fiskerstrand:
Yeah, that's it. Still dark corners in man gpg I am unfamiliar with... And what a response time, serverfault-like. :-)

@_date: 2013-05-18 03:35:29
@_author: Hauke Laging 
@_subject: Public sign-only RSA key not restored when importing armored 
Am 17.05.2013 19:52, Tim Friske schrieb:
How do you know that, from "gpg --list-keys" or from
"gpg --list-packets ~/.gnupg/pubring.gpg"?
Probably the real question is: Why is it not shown? Please try
gpg --list-options show-unusable-subkeys --list-keys
I have to admit that this seems incompatible with my theory.

@_date: 2013-05-26 17:12:11
@_author: Hauke Laging 
@_subject: [OT] Why are you using the GPG / PGP keys? 
Am So 26.05.2013, 16:36:00 schrieb Eray Aslan:
But will they use more or less email after college? The kind of communication changes over time. It did not change that much for earlier generations because there was nothing like Facebook from what the users could have turned to E-Mail will still be there in ten years. Nearly nobody (no person, no organization) is capable of abandoning email (i.e. not having the capability of receiving and sending email).
What will Facebook be in ten years? Nobody knows.
A "tying tech" is not the same as "a tech past its peak". I would not claim that email is the best tool for every application so it seems pretty normal to me that it loses market share if tools that do certain jobs better become As long as you need an email address to register at Facebook and not a Facebook user name in order to register for an email account I doubt that Facebook is the more established service.

@_date: 2013-05-27 13:58:46
@_author: Hauke Laging 
@_subject: unattended signing key 
Am Mo 27.05.2013, 13:38:08 schrieb Lema KB:
You may use --passphrase-fd, --passphrase-file, or --passphrase; see the man Or gpg-preset-passphrase as an alternative (if you manage to find out the

@_date: 2013-05-27 14:02:45
@_author: Hauke Laging 
@_subject: gpg-preset-passphrase: cache id 
I quote from the man page:
gpg-preset-passphrase [options] [command] cacheid
cacheid is either a 40 character keygrip of hexadecimal characters identifying the key for which the passphrase should be set or cleared. [...] Alternatively an arbitrary string may be used to identify a passphrase; it is suggested that such a string is prefixed with the name of the application (e.g foo:12346).
How is a passphrase with a cache id like foo:12346 used? Is it tried for all keys which do not have a keygrip entry?

@_date: 2013-11-05 23:13:58
@_author: Hauke Laging 
@_subject: bug-like: strange behaviour of addrevoker 
I have created another key for me (higher security level) so its user ID has obviously the same name like the ones of my old key. I did this with Knoppix 7.2 (i.e. gpg 1.4.x).
After key creation I wanted to add the keys to each other as designated revokers. But that didn't work as expected. After entering the command "addrevoker" I was asked to enter the user ID of the respective key. Why the user ID and not the key ID or fingerprint? Does that make any sense?
However, gpg has a quite strange user ID matching behaviour here. If I enter the complete user ID
Hauke Laging (Standardadresse) then it is not found. If I enter just "Hauke Laging" I get a clever error message that a key cannot be its own designated revoker... Neither 1a571df5 nor 0x1a571df5 works. Even worse: The email address doesn't work either (both hauke at laging.de and ).
So I had to create a new user id (and throw the others away in order to avoid changes to the other key). With the new name it worked.
I assume this is a bug as you would expect it to happen quite often that there are several keys with the same name. Probably this feature is rarely used.

@_date: 2013-11-12 18:29:19
@_author: Hauke Laging 
@_subject: subkey comments? 
Am Di 12.11.2013, 15:50:10 schrieb adrelanos:
The main question is: What do you mean by "comments"? You probably refer to the comment part of a user ID. But it has not been determined what exactly that refers to.
A key comment in a technically more correct sense would be a signature notation (which you can see with --list-sigs only and you also need --list-
options show-notations).
You can create these notations with --cert-notation. You must call gpg once for every key then:
gpg --expert --cert-notation comment_en at openpgp-notations.org="mainkey" \
gpg --cert-notation comment_en at openpgp-notations.org="encryption subkey" \
--edit-key 0x12345678 addkey
gpg --cert-notation comment_en at openpgp-notations.org="signature subkey" \
--edit-key 0x12345678 addkey

@_date: 2013-11-13 01:52:24
@_author: Hauke Laging 
@_subject: subkey comments? 
Am Mi 13.11.2013, 00:34:38 schrieb adrelanos:
I mean: It is difficult to say "A UID comment refers to the mainkey" or "A UID comment refers to the subkey" (and make sense). A user ID is simply a string describing some person or other entity. If the comment is "CEO of Example Inc." how should that be related to the mainkey other than to a subkey?
There are other situations: I use (abuse?) an additional user ID to make statements about both mainkey and subkeys (by stating that the mainkey is offline and how secure the subkeys are).
For several reasons. A notation is a subpacket (i.e. some additional information) to a signature (self-signature in this case). The UID comment ist just text between round brackets.
Self signatures are used to bind both user IDs and subkeys (and some other stuff) to a mainkey.
You can have a comment in the user ID and a notation in the signature. They are independent of each other. All four cases are possible.
You (as most people) have not understood how mainkey, user IDs and subkeys are related. And it seems that I haven't figured out yet how to explain that well.
Both subkeys and user IDs are related to a mainkey. In this sense user IDs and subkeys are on the same level. There is no such thing as a subkey user ID or a user ID subkey. User IDs are just "names" for a mainkey. You can add and remove user IDs and subkeys. They do not affect the other group.

@_date: 2013-11-16 00:48:45
@_author: Hauke Laging 
@_subject: ENISA Recommendation for Crypto processes 
Am Fr 15.11.2013, 15:40:30 schrieb Juergen Polster:
That is a strange paper. The text is not even consistent:
"We have focused on 128 bit security in this document for future use recommendations; clearly this offers a good long term security gaurantee. It is plausible that a similar recommendation could be made at (say) the 112 bit security level (which would correspond to roughly 2048 bit RSA keys). The line has to be drawn somewhere and there is general agreement this should be above the 100-bit level; whether one selects 112 bits or 128 bits as the correct level is a matter of taste. Due to the need to protect long term data we have taken the conservative choice and settled on 128 bits; with a higher level for very long term use."
"Thus in recommending key sizes we make two distinct cases for schemes relevant for future use. The first cases is for security which you want to ensure for at least ten years (which we call near term), and secondly for security for thirty to fifty years (which we call long term)."
"For near term use we recommend AES-128 and for long term use AES-256."

@_date: 2013-11-17 14:36:34
@_author: Hauke Laging 
@_subject: AES attack calculations (money and time) 
from time to time someone asks how secure (a)symmetric crypto really was and then our math and physics teacher Rob has his performance.
Somebody just pointed me at this:
Of course, they say "No practical impact due to reliance on related keys" because they had to stay below 2^100 but considering that they refer to real hardware whereas here the theoretical lower energy limits are used I am a bit surprised.
Is this paper correct? I am not an expert in these areas. The only point that came to my mind is that if you need energy of the magnitude of the US overall electricity consumption than you cannot ignore the energy costs. :-) Not even the impact on the prices for oil, gas and uranium at the world market. They calculated the price for chip fabs but not the one for power plants.
So what may be the upport bound there: The NSA will never have access to more than 1% (or rather 10%?) of the US electricity consumption? IIRC then electricity generation costs is supposed to be about 4ct (Euro cent) per kWh in Germany. Lower for the old nuclear plants but even higher if you build new ones. So the 4TW mentioned in the paper would result in about four billion (10^9) EUR per year for electricity if I calculated that correctly.
So maybe the rising energy prices turn out to at least protect our privacy... Another question as I am not familiar with crypto attacks: They are talking about plaintext there. Does that mean they need both plaintext and ciphertext to tun this kind of attack? If so then I assume the real computational effort is higher by orders of magnitude because you have to check whether each key is the right one. Is that correct?
OpenPGP key generation on European TV again (starting at 28:30, 33:20 in German: in French:

@_date: 2013-11-17 19:09:05
@_author: Hauke Laging 
@_subject: unable to use gnupg on a read-only filesystem 
Am So 17.11.2013, 19:02:12 schrieb Martin Vegter:
That is a lock file. Try --lock-never

@_date: 2013-11-19 05:02:57
@_author: Hauke Laging 
@_subject: article about Air Gapped OpenPGP Key 
Am Mo 18.11.2013, 17:21:22 schrieb adrelanos:
That's wrong. The default is a mainkey for signing and a subkey for I would not put it that way. If it is just lost then the key will expire (if it has an expiration date as it should) as you cannot extend its validity time. So you need a new key. That is unpleasant but usually not as unpleasant as compromised decryption or signature keys. If you state something like that I think you should explain it.
That argument doesn't make any sense for a key "copied to your every day operating system".
I have never understood why people seem to believe that they cannot safely store a key backup (including the passphrase if necessary) but can safely store a revocation certificate.
Why should one remove this file?
And it it really a good idea to use the same passphrase for both mainkey and No, it means that the mainkey has been replaced by a stub.
We are talking about a secring.gpg in RAM as the key is generated on a secure system running some live Linux CD/DVD?
But it sees the mainkey's passphrase...
It will take me some time to translate this in English but I have written a bash script which creates a new key with two subkeys and outputs a set of files (with different passphrases) and two directories and even allows you to easily certify other keys and create mainkey signatures immediately after key explained here:
Or download the whole script collection here and run ./start.sh:

@_date: 2013-10-11 03:32:11
@_author: Hauke Laging 
@_subject: First steps with GPG, am I off to a good start? 
Am Fr 11.10.2013, 01:25:50 schrieb Robin Kipp:
It seems to me that the more accepted recommendation here is to have separate subkeys for signing and encryption.
I know of no good reason for creating a mainkey without expiration date.
Furthermore it would be nice to have a UID without email address but with a comment which explains the security of the key. Something like
   "Robin Kipp (normal security level subkeys with offline mainkey)"
This should be explained in more detail in a key policy which you should make publicly available and put its URL into the self signatures (see --set-policy-
url) for the UIDs (and maybe even the subkeys). You should also set your preferred key server in the selfsigs (--default-keyserver-url).
One may call that the best sequence of steps but one... ;-)

@_date: 2013-10-11 07:24:14
@_author: Hauke Laging 
@_subject: standardized security levels 
a few mails ago dkg asked what the use of key policy documents was. That is obviously limited for several reasons. But the conclusion cannot be that we do completely without anything like that. It must be that we solve the problem in a reasonable way. If we don't then we seriously limit the quantity and quality of crypto usage.
I have been considering this a problem for years and yesterday I finally made my first step in solving it:
The text is in German, though. But have some fun with the Google translator if you like... :-)
The idea is to reduce the complex multi-dimensional security of a system to a limited number (about 10) of typical and useful cases. This should allow people who do not consider IT as one of their hobbies to much better assess the situation of their IT and their data.
My OpenPGP specific aim is that such a standardized list would be implemented in OpenPGP applications, probably as a signature notation. The typical user would have several keys (for the same address) at different security levels. Thus the sender could select the security need of the data to be sent and the system could automatically select the most suitable key (or fail if none such is available).
This may sound like making IT even more complex but I am convinced that the opposite it true. Achieving the same situation is much more difficult today. In fact these considerations are simply ignored by most people today. And then they are surprised that their money is stolen via online banking...

@_date: 2013-10-12 01:10:16
@_author: Hauke Laging 
@_subject: First steps with GPG, am I off to a good start? 
Am Sa 12.10.2013, 00:53:30 schrieb Robin Kipp:
It is a very strange assumption that only such things should be certified that can be "verified". The certifier makes a statement. This is
a) "I have seen a passport or similar document and compared that to the person I met"
b) "The person I met has claimed that the mainkey of this certificate is used in a secure offline environment only"
What makes the one statement better than the other? You usually cannot prove that a certain person has shown you a certain passport-like document. And without a manual signature you cannot even prove that the person has claimed that a certain key belongs to him or her.
The WoT will stay close to useless if we do not get a system for certifying such status information. And what do you lose if someone does not certify this UID? Nothing. On the other hand many people who were not aware of the feature learn that there is something called an "offline mainkey" and thus may learn something very important about crypto keys.
For that problem the local signature (lsign) was invented.
I set eu.pool.sks-keyservers.net as the preferred keyserver for all keys which I create or help create. Why should that be a problem? Because we don't know whether some technical failure may occur?

@_date: 2013-10-12 04:22:29
@_author: Hauke Laging 
@_subject: First steps with GPG, am I off to a good start? 
Am Fr 11.10.2013, 19:09:19 schrieb Doug Barton:
So avoiding the "I'm an idiot" message is not a good idea but not teaching people simple tasks is. I beg to differ.
I don't care much about people who are not willing to learn how to use the tools right. The tools can be made easier, information can be made easier to access, the number of people who can be asked should anyway be increased by orders of magnitude (unfortunately, that's the hard part).
If someone is neither willing to do it right nor willing to ask somebody then I will certainly not reduce security or convenience for the other ones just to do him a favor. The aim of my recommendations is to make the whole crypto environment better not to please single people.
If there is a real threat then it is probably rarely going to happen. But the point is: Threats are not the only argument for crypto recommendations.

@_date: 2013-10-14 07:12:15
@_author: Hauke Laging 
@_subject: standardized security levels 
Am Mo 14.10.2013, 06:41:25 schrieb NdK:
That is a strange question because normal certifications do not include any statement about how much you trust the key's certifications. Two reasons for that come to my mind immediately:
1) Public information may create social pressure. Nobody wants "Why don't you trust my certifications???" discussions.
2) Why should others care about your assessment in this category?
There is no need for what you want. And AFAIK it is not possible. The closest feature to that are trust signatures but they carry positive trust only.
That is correct. My proposal does not affect trust.

@_date: 2013-10-16 01:30:32
@_author: Hauke Laging 
@_subject: better handling of importing local signatures 
I think it would be a good idea to change the handling of local signatures. I suggest to import local signatures even without
        --import-options import-local-sigs
if the local signature is by one of the secret keys in the local keyring. That would make the handling of offline mainkeys easier: It would allow the user to avoid putting "import-options import-local-sigs" in the config file (which he is otherwise heavily tempted to do in order to avoid problems).
I do not see any reason why the import filter should affect your own

@_date: 2013-10-16 03:52:16
@_author: Hauke Laging 
@_subject: better handling of importing local signatures 
Am Di 15.10.2013, 21:43:14 schrieb David Shaw:
Great, once again solving problems I invented.
Then I would like to change my request to adapting the documentation

@_date: 2013-10-22 23:38:48
@_author: Hauke Laging 
@_subject: Selecting your own key with Enigmail 
Am Di 22.10.2013, 23:21:28 schrieb Johan Wevers:
DSA cannot encrypt.
gpg --edit-key 0x12345678 quit
shows you the keys' capability flags.

@_date: 2013-10-23 00:17:10
@_author: Hauke Laging 
@_subject: trust your corporation for keyowner identification? 
Am Di 22.10.2013, 18:01:46 schrieb Robert J. Hansen:
Even worse: "exceeding your threshold of certainty in that moment"
I am afraid this assessment changes for most users over time (which is not bad per se; the problem is the lack of transparency about that). Thus I demand a standardized scale for that so that we can easily know what the others are talking about.

@_date: 2013-10-23 00:34:35
@_author: Hauke Laging 
@_subject: Selecting your own key with Enigmail 
Am Di 22.10.2013, 23:45:28 schrieb Johan Wevers:
It seems to me that this is an EnigMail problem and not a gpg problem. Probably you have configured the wrong key there.

@_date: 2013-10-24 03:44:50
@_author: Hauke Laging 
@_subject: add a request for advocating crypto to the crypto tools 
due to its rather little visibility for the average user this affects GnuPG less than its GUIs (the mail clients in particular). It may well be used in the GnuPG documentation (man, info, www). But I assume that many GUI (or more general: crypto tool) developers are on these lists.
We need everyone we can get for help in advocating the usage of crypto tools. Currently probably even most crypto users are not aware of the opportunities they have for doing that (even at nearly no effort). Thus I suggest that the crypto tools get somewhere (configuration windows) a link to a page which tells them.
I created a page in the KDE userbase wiki (which has the advantage that it is going to be translated) for this purpose (based on my German page And I have created according wishlist entries (PLEASE feel free to vote for them ;-) ) in the bug tracker for KMail and KGpg:
 (KMail)
 (KGpg)
This may not just raise the interest in crypto but also the donations for the

@_date: 2013-10-24 04:36:14
@_author: Hauke Laging 
@_subject: add a request for advocating crypto to the crypto tools 
Am Mi 23.10.2013, 21:20:24 schrieb John Clizbe:
That's nice but not what I was talking about (sorry if I didn't manage to make myself clear enough). That is "Use non-crypto tools to advertise crypto"; important, too, and I had this idea some time ago (probably even mentioned it here on the list), not limited to web sites but the applications themselves:

@_date: 2013-10-26 18:16:32
@_author: Hauke Laging 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
Am Fr 25.10.2013, 23:45:50 schrieb Johan Wevers:
This means that every single key is secure over that time. It means that after 25 years organizations with huge resources may be able to crack a *single* key in a lot of time (rather a year than a day). So even within the next 35 years THEY have to make a very small selection which keys they want to break as then there will be a few million 2048-bit keys around. And that requires that the law doesn't change within that time, forcing the agencies to delete most of the stored encrypted data. The US government is just realizing that their current approach causes costs beside those in the budget.
And we have not even talked about the different security levels of keys. The default setting of gpg should be suitable for normal keys i.e. keys for everyday communication. If you need a high security key then you need to know a lot about IT security anyway because the keys are the strongest part of the system. Those who know how to do the rest right obviously know whether and how to increase the key size.
Why should anyone 25+ years from now spend a huge amount of resources in order to read a tiny part of today's everyday communication (or a big part in 40 years)? That makes absolutely no sense. How do you want to explain that in a democracy, "hunting terrorists"?

@_date: 2013-10-27 15:54:49
@_author: Hauke Laging 
@_subject: thread links in the FAQ 
The two curerent discussions ? one about the FAQ, the other one with "we discussed that back then" statements ? make me guess whether it makes sense to link such threads in the FAQ.
BTW: Where is the FAQ? I hope this question does not seem too stupid... The one one gnupg.org calls itself outdated. Some search engine pointed me at the mailing list archive where  is mentioned (2012) but that does not load here.

@_date: 2013-10-30 16:34:05
@_author: Hauke Laging 
@_subject: Quotes from GPG users 
Am Mi 30.10.2013, 11:58:56 schrieb Sam Tuke:
I don't understand what that is supposed to be good for. Is there any serious competition between GnuPG and whatever other product? Nearly everyone who uses OpenPGP in a private environment is already using GnuPG. Or is my impression What we need is awareness for crypto, not for a certain crypto tool:

@_date: 2013-10-31 22:02:53
@_author: Hauke Laging 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
Am Do 31.10.2013, 16:31:02 schrieb Daniel Kahn Gillmor:
There is one point I don't understand:
[3.6 Recommendations]
"there is general agreement this should be above the 100-bit level"
"for long term use AES-256"
But this  (mentioned by the German Wikipedia article for AES) claims that AES-256 was down to 99.5 bits.

@_date: 2013-09-08 18:55:15
@_author: Hauke Laging 
@_subject: Recommended key size for life long key 
Am So 08.09.2013, 11:07:21 schrieb Robert J. Hansen:
Once more I feel enlightened (and I am sure I am not the only one). From time to time it seems appropriate to me that someone says thank you. So this time I do that.

@_date: 2013-09-11 17:56:07
@_author: Hauke Laging 
@_subject: --list-options show-notations does not work with --with-colons 
Am Mi 11.09.2013, 10:07:30 schrieb Daniel Kahn Gillmor:
show-sig-subpackets is your friend.

@_date: 2013-09-12 00:16:45
@_author: Hauke Laging 
@_subject: Is it possible to remove capabilities from an existing key? 
Am Mi 11.09.2013, 23:42:30 schrieb Philip J?genstedt:
It's of limited use to make a former online mainkey an offline mainkey. You should create a completely new key (on a secure system).
May be possible (it surely would be with patching GnuPG) but is not necessary. It makes perfect sense to have signing (and even encryption) capability on an offline mainkey.
If there is a subkey then it is used always. I do not know though whether this is a direct effect (defined that way) or an indirect one: The creation date (and the selfsig date) of a subkey should always be after the creation date of the mainkey.

@_date: 2013-09-12 15:07:39
@_author: Hauke Laging 
@_subject: Is it possible to remove capabilities from an existing key? 
Am Do 12.09.2013, 14:53:29 schrieb Philip J?genstedt:
gpg --armor --export-secret-keys "$mykeyid" > key.secret-mainkey.asc
gpg --armor --export-secret-subkeys "$mykeyid" > key.secret-subkeys.asc
gpg --delete-secret-key "$mykeyid"
gpg --import key.secret-subkeys.asc

@_date: 2013-09-12 16:29:31
@_author: Hauke Laging 
@_subject: OpenPGP presence on the web 
I'd like to motivate you to do something (at least passively) I have started There are some (both private and commercial) web sites which have a statement and link like this on their contact page: "And here you can download my PGP Most of them (at least of the German ones) do not contain any information about OpenPGP though. Neither as text nor as links. This doesn't make sense.
Thus I have started searching such pages and asking their webmasters (who are usually interested in more people using OpenPGP) to add links to both informative sites and such with teaching events (this, of course, is probably much easier in Germany than elsewhere with the Cryptoparty movement having taken off that stongly here). A relevant share of them does that.
(The immoral part is, of course, that I give them two example links, one of them to my site ;-) )
This way we both get more people (who have not searched for them) to good OpenPGP resources and improve the search engine ranking of them (which helps those who actively search for information).
Thus: Write a short text for such cases so that you can just C&P it if you happen to encounter such a page. And if you spend some time searching for such pages ? even better.
Below you find my (German) text. Feel free to copy or change it.
Dein Beitrag zur h?heren Verbreitung von OpenPGP
es ist l?blich, dass Du auf Deiner Kontaktseite darauf hinweist, dass man die Kommunikation mit Dir ?ber OpenPGP sichern kann. Es sollte deshalb in Deinem Interesse liegen, dass sehr viel mehr Leute als bisher sich diese Technik aneignen. Du kannst mit vernachl?ssigbarem Aufwand einen dauerhaften Beitrag dazu leisten:
Erg?nze den Verweis auf Dein OpenPGP-Zertifikat um einen oder mehrere Links auf Seiten, die sich als Anlaufstelle f?r Leute eignen, die nicht wissen, was das ist. F?r solche Leute sind nicht nur reine Informationsseiten n?tzlich, sondern auch solche von Schulungsangeboten, insbesondere den kostenlosen der Informationen: Schulungsangebote: Weitere Anregungen, wie Du mit mehr oder weniger Aufwand OpenPGP unterst?tzen kannst, findest Du hier:
Wenn Du diesen Vorschlag aufgreifst, freue ich mich ?ber eine entsprechende R?ckmeldung. Auch f?r eine Diskussion dieser Problematik stehe ich nat?rlich gern zur Verf?gung.

@_date: 2013-09-16 00:37:33
@_author: Hauke Laging 
@_subject: How to find and verify a trust path? 
Am So 15.09.2013, 21:11:04 schrieb Philip J?genstedt:
The question does not make much sense IMHO because this is not only about importing keys but also about assigning certification trust to the keys along the path.
In order to seriously assign certification trust to a key you have to know the key owner, the certification policy (for that key) and the security level of the mainkey. Why should you not already have imported a key if you have all these pieces of information available? Sounds to me like you are willing to assign certification trust to unknown keys just because you have to in order to advance in the signature path.

@_date: 2013-09-17 16:29:08
@_author: Hauke Laging 
@_subject: How to find and verify a trust path? 
Am Di 17.09.2013, 10:17:11 schrieb Daniel Kahn Gillmor:
Thus quite some time ago somebody (not me) asked for a new feature (without success): Keys should be grouped by their owner so that each person's certifications are counted once only.

@_date: 2013-09-19 05:36:54
@_author: Hauke Laging 
@_subject: Where does this signature come from? Some magic around 
I have tried to export the secret keys only (i.e. without the user IDs) in order to avoid importing old user ID signatures when importing the secret key I had the idea to delete the selfsig on the UID before exporting. Thus it could not be exported or imported. But due to some magic gpg exports even an "officially non-existent" signature:
LC_ALL= LC_MESSAGES=C gpg --edit-key foo at bar check 2>/dev/null
Secret key is available.
pub  3072R/0x5D266D4E  created: 2013-09-19  expires: never       usage: SCEA
                       trust: ultimate      validity: ultimate
sub  2048R/0x9B681F49  created: 2013-09-19  expires: 2014-09-19  usage: S
sub  2048R/0xB42B66D3  created: 2013-09-19  expires: 2014-09-19  usage: E
[ultimate] (1). Hauke Laging uid  Hauke Laging 1 user ID without valid self-signature detected
gpg --armor --export-secret-keys foo at bar > secret.asc
# you cannot import secret keys if there is one already
gpg --delete-secret-key foo at bar
gpg --import secret.asc
LC_ALL= LC_MESSAGES=C gpg --edit-key foo at bar check 2>/dev/null
Secret key is available.
pub  3072R/0x5D266D4E  created: 2013-09-19  expires: 2014-09-19  usage: SCE
                       trust: ultimate      validity: ultimate
sub  2048R/0x9B681F49  created: 2013-09-19  expires: 2014-09-19  usage: S
sub  2048R/0xB42B66D3  created: 2013-09-19  expires: 2014-09-19  usage: E
[ultimate] (1). Hauke Laging uid  Hauke Laging sig!3   PN   0x5D266D4E 2013-09-19 never       [self-signature]
WTF? gpg-agent is not running for this user so the signature cannot be created on the fly. Is there a secret selfsig storage which is used for exporting This does not happen when exporting the public key! gpg --list-packets shows the difference, too.
I played around with gpgsplit and noticed that a secret key file is not imported if the UID is missing completely. But it is happily imported if there is a UID without selfsig... :-)
gpg --version
gpg (GnuPG) 2.0.19
libgcrypt 1.5.3

@_date: 2013-09-24 03:41:22
@_author: Hauke Laging 
@_subject: Best Practice, subkeys and subkey cross-certification. 
Am Di 24.09.2013, 00:21:09 schrieb Chuck Peters:
Would you explain that in more detail? I am not sure whether that makes sense.
You should consider not only storing the key offline but using it in a safe environment only. Besides managing your own and other keys it makes sense to use it for signing very important data (like your key policy).
GnuPG can use keys with subkeys which have different passphrases but it cannot create such keys (at least not with "normal operation"). This is not a bug, just a missing feature.
Don't care about that, it's handled automatically.

@_date: 2013-09-27 15:39:00
@_author: Hauke Laging 
@_subject: Use of two private/public key pairs, Sign only and Encrypt only 
Am Do 26.09.2013, 16:17:37 schrieb Hank Ivy:
You can have a single mainkey with separate subkeys for signing and encryption (and with different passphrases though that requires some tricks) so that it would be enough to give away the decryption key. I doubt that anywhere in the civilized world you can legally be forced to enable the police to forge your signature. You could even export just that key in advance.
On the other hand most of us have learnt a lot about the real state of the world quite recently...

@_date: 2013-09-27 16:20:01
@_author: Hauke Laging 
@_subject: Use of two private/public key pairs, Sign only and Encrypt only 
Am Fr 27.09.2013, 09:56:03 schrieb Robert J. Hansen:
Is that your interpretation or in any way official? My respective search engige efforts were not successful.
This point of view would have quite strange consequences: For how long shall you be forced to keep a key? Even longer than before (if you change subkeys regularly)? Why should you have to accept that police can read future data of yours, data which they do not have a warrant for?
Unfortunately for quite a while we have seen that there is a lot more between UK and the rest of (continental) Europe than just water. Maybe we will finally see the EU shrink for the first time.

@_date: 2014-04-16 16:14:23
@_author: Hauke Laging 
@_subject: signatures for other people's emails 
this is not GnuPG-specific, not even crypto-specific in the sense that I guess no real change to any crypto tool or standard would be necessary. Technically it's about a new MIME container usage but crypto-related. I hope here are the right people to comment on that. Somehow I prefer getting slammed here over the openpgp working group mailing list...
This idea came from a real experience a few days ago. I am trying to get crypto usage on a large scale to one of Germany's biggest universities (FU Berlin). The CS and math departments organize a small (but official) information event. I give four real courses (inofficial but supported by the dean;  As this is mainly about peer pressure for the freshman students I wanted to teach some of the Ph.D. students crypto first. We invited about 30 people, none even reacted.
I was told that this effect was less about the offer itself but more about the point that this was "one more email from a stranger to a group of people". I.e. probably not even read by many of them.
That was the example, now the idea:
With a small change to the PGP/MIME standard this would have been possible: I write the email but do not send it to the intended recipients but to the dean first. He makes a signature (some easy one-
click feature maybe with a comment) about the email (or about my signature) and sends it back to me. Then I add his signature to my email and send it to the recipients. Now this happens: The recipients still see an email from a stranger to a group of people but now their mail client tells them that their dean (and maybe even more people) supports this email.
Of course, you have noticed that a crypto feature does not work in a mail which shall make people start using crypto but you get the idea. This would be possible without crypto, too, but I guess to easy to abuse for being accepted.
I guess it would be enough to replace the signature container by a multipart container with several signatures. Somehow the real sender signature would have to be marked (or rather: the support signatures should be marked as such, either implicitly by being a signature over the sender signature or explicitly by a notation).
I don't want to be too optimistic but I guess this could be so useful that it might actually become a reason for the not so small "I have nothing to hide" group to start using crypto.

@_date: 2014-04-16 18:37:56
@_author: Hauke Laging 
@_subject: signatures for other people's emails 
Am Mi 16.04.2014, 18:21:16 schrieb Peter Lebbing:
That is indeed possible but has disadvantages:
a) It does not work with more than one supporter.
b) The supporter becomes more involved in the communication than he wants to: He appears as the sender and may receive answers (even bounces and autoresponders).
c) The real sender does not have the mail in his sent mail archive thus breaking the usual communication structure. In case of doubt he does not even know whether the mail has already been sent by the supporter.
d) The same for the recipients: They cannot simply search for a mail from the real sender.
e) The supporter must handle the recipients in that case. That may be a complicated procedure; he may not even have all the addresses yet.
I guess you agree that the procedure you suggest is possible but would be used only due to the lack of something better and not because it was the best (or even a good) way of doing that.
The practical question is: Would you vote / argue against the development of such a new feature because of the existing possibilities?
A general remark: Some time ago we had a discussion here about the future of email. Who's still using it and for what and the like. I think with this background it makes sense to consider how email can become

@_date: 2014-04-21 17:33:00
@_author: Hauke Laging 
@_subject: signatures for other people's emails 
Am Mi 16.04.2014, 13:28:02 schrieb Mark H. Wood:
That's obviously not what would happen in typical situations. A mail client which implements such a feature would notify the user about this point; even if the user marks the mail just for deletion. Mails from strangers are usully "actively not read": You see it and decide not to (really) read it; or to have a loot at it but not really care about it. Mails from strangers are not filtered out on the mailbox server before they reach the MUA.
It might help to define an additional X-header which marks the mail as having support signatures so that an IMAP client can notice this without looking at the "attachments".

@_date: 2014-04-22 12:56:52
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Di 22.04.2014, 12:25:04 schrieb Nicolai Josuttis:
The better question is: "Is it a useful term?"
I consider this confusion a huge problem. I guess hardly anyone outside this list get these two concepts right. There is even an OpenPGP GUI which mixes up these two (claims to show trust but shows validity...).
Using "trust" for both cases is probably the best way to ensure that normal users will never understand this. I strongly advise against the use of the term "trust" in a validity context.
"consider a key as valid"

@_date: 2014-04-22 13:56:03
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Di 22.04.2014, 13:36:23 schrieb Nicolai Josuttis:
"Self describing" is a hard requirement if the person who shall feel that way is not familiar with the technical concepts. It the concepts are clear then there is no risk of confusion by terms.
Kgpg. Bug report has been made.
You involuntarily show the next terminology problem: owner trust. This is not about the owner, it is about the key. This can easily be seen from the facts that (a) the same owner can have several keys and (b) there are scenarios in which you will not assign the same trust to these keys. Thus I recommend to call this "certification trust". The owner is an important part of it but not all.
Back to your point: The problem is that most people do not learn crypto in a straight, high-quality way. Most people just download the software and see what happens. That you could have explained that well in theory does not change the practice.
You could say the same about other aspects of crypto. But: That's not the reality we see.
The subject is not easy. Period. You cannot make it easy by wrapping. The only thing you can achive that way is an illusion of security.
I am not a native speaker but "valid" seems quite self-intuitive to me. At least about the general idea, not about the technical details, of course. But they will never be self-intuitive, they must be learnt.

@_date: 2014-04-23 00:49:37
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Di 22.04.2014, 23:40:40 schrieb Peter Lebbing:
We do agree that crypto is by its nature difficult (I don't mean the math I mean the organizational envorinment) and that a serious part of this difficulty is more or less hidden by current tools (in order not to scare the users away), don't we?
The answer seems to point to the wrong direction as, of course, having only one (active) key (per address) which is probably the situation for the majority of OpenPGP users, is just another problem as you cannot cover the spectrum of common security needs with just one key. You can even see that on this list where several people do not sign their email. In at least one case due to the rather strange argument that this would imply a higher "security" of the message than it really has. The reality is that this ignores the real problem: The lack of transparency of the security level (German only:
Thus we should head for most users having several keys. But as dkg has just pointed out (his suggestion to handle groups of keys belonging to the same person or organization has already been on this list years ago): We are technically not yet equipped for handling this. On the other hand: The current WoT is of little use anyway. But if this is supposed to change in e.g. five years we have to start to change something now.

@_date: 2014-04-23 01:03:05
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Mi 23.04.2014, 00:50:24 schrieb Nicolai Josuttis:
"A user"? LOL
The developers did. This is the default setting (hidden in the experts settings and "hidden" by not showing the key validity by default; OK, by default they don't show any keys at all so why bother...). IMHO an absolutely crazy decision. The worst possible organizational failure. And the MacOS GPGTools don't show you the fingerprint when certifying a key. That's where mainstream crypto software is going currently. Welcome to the world of easy crypto...

@_date: 2014-04-25 04:49:30
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Do 24.04.2014, 11:13:22 schrieb Peter Lebbing:
I second that. "Ownership" is much to close to "ownertrust".
But I would also point out that "authenticity" sound very much like "this key is authentic" which is a problem for at least two reasons:
a) Many keys are certified without being verified. This is IMHO not so much a problem if this is transparent. Think of --ask-cert-level. BTW: I really don't like the --min-cert-level default to be 2 because this forces the users to either ignore this level (setting 0) or to "lie" which also reduces the "authenticity".
b) There are user IDs with which it becomes strange to speak of "authenticity". E.g. if it is only an email address (sevgseuiuzh at example.org).
Certifying a key (especially if locally only) is more a technical decision than a proof of "authenticity. But I doubt that "validity" vs. "authenticity" makes a difference in this regard. The German term for valid does not sound like that to me.
Thus I would like to offer "accepted" as a possible alternative. I guess that shows the user decision. Maybe even as a combination: "authenticity Another point:
Is it a good idea to use the same terms for both the key itself and user IDs? The terminology should make sense to non-technical people especially from the perspective that a "valid" key (certificate) can contain "invalid" user IDs.
As different keys (especially fake ones) can contain exactly the same user ID it seems strange to me to apply the term "authenticity" to a user ID. The key is authentic for this user ID (in contrast to other keys which may have the same).
Even worse: Even an invalid (but formerly valid) key is still "authentic". At least from my understanding of language. "Accepted" does not have this problem (neither "valid").
We could say: An accepted user ID makes a key valid. Certain additional steps during accepting (certifying) ? like --ask-cert-level or (yet to be defined) signature notations ? MAY make the key not only "valid" (technical part) but also "authentic" (organizational part).
In order to help people use crypto right the terminology should help the people become aware of important differences ? like validity and authenticity. Speaking of "authenticity" only may support the creation of an illusion of security.
Maybe we are not even the right group to discuss that. Maybe that should be discussed by new users after being told about the technical and organizational states which the language shall easily understandably

@_date: 2014-04-25 06:38:15
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Mi 23.04.2014, 20:32:27 schrieb MFPA:
a) You always want to use fingerprints instead.
b) You do not need any reference to a key anyway because it is absolutely clear which keys this statement refers to if one key signs c) I would like to handle that with an generic notation. I see a strong need for an expression about the relation of the signer to the owner of the signed key. It makes a big difference whether I say "This is some foreigner which has shown me some ID (see separate notation for details)" or "This is my sister". Thus I would like to have a notation "relation which would in this case have a value like "identity" or "self", maybe with some additional information like "self: business".

@_date: 2014-04-25 06:43:27
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Do 24.04.2014, 15:22:20 schrieb Doug Barton:
That's exactly the problem: If you say something explicitly which is not always the case then you must not make this explicit statement the only possible one.
Many keys get signed without being verified. IMHO this forbids calling valid keys "verified keys".
Verification is a subset of accepting. I would really like to make "verification" part of this terminology but only as an optional part, clearly telling "accepted keys" and "accepted and verified keys" apart. Otherwise we just create the next problem.

@_date: 2014-04-27 04:07:31
@_author: Hauke Laging 
@_subject: Fwd: Re: Re: A few newbie Qs 
Am Sa 26.04.2014, 22:02:11 schrieb Robert J. Hansen:
At least I do. This has already been discussed recently.
That's a possibility, too. I thought that spammers might actively subscribe to mailinglists for this reason.

@_date: 2014-04-28 21:15:30
@_author: Hauke Laging 
@_subject: hash email addresses / directory privacy enhancement 
Am Mo 28.04.2014, 16:49:30 schrieb John Wofford:
Yeah, I was the last one.
Short answer: It would not work with typical email addresses because their "key space" is too small, enumeration and hash checking would be The real weapon against spammers would be a "transport web of trust" i.e. a "transport signature" by a key which is considered valid for delivering email. But that is ten years from now.

@_date: 2014-04-29 11:13:46
@_author: Hauke Laging 
@_subject: hash email addresses / directory privacy enhancement 
Am Di 29.04.2014, 10:51:35 schrieb Peter Lebbing:
That is interesting but if it is supposed to be an answer then I guess from the perspective of the "average" user it answers the wrong question. The answered question is: "Does uploading my certificate to a public key server cause a spam problem for me TODAY?" This answer is no.
But the reason is not that keyservers are kind of spam-safe but that this address source is not interesting enough for spammers (maybe they ? non-crypto users ? are not even aware of it) due to its limited size and the kind of users you may expect behind these addresses.
But: Those of us who do not like to regularly throw their email addresses away will usually be more interested in the answer to a slightly different question: "Will uploading my certificate to a public key server cause a spam problem for me someday (not in the far future)?" Nobody knows. Especially as you don't get the addresses off of the We wish for the success of crypto (in usage share). But if it ever comes (I am working hard on it...) then it will have unpleasant side effects.

@_date: 2014-04-29 21:34:27
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Di 29.04.2014, 20:22:52 schrieb MFPA:
I don't understand that.

@_date: 2014-08-10 16:44:45
@_author: Hauke Laging 
@_subject: Error - bad passphrase 
Am So 10.08.2014, 08:13:12 schrieb david at gbenet.com:
I have no idea why the upgrade may have caused this.
Does the file exist?
I don't know what the reason for the change is but I have a suggestion for a work-around:
You can put
in the config file gpg-agent.conf. If you do that and gpg-agent is not running (which you may check every few minutes via cron) then you can simply restart it:
gpg-agent --daemon
Due to the config file setting the applications will connect to the new gpg-agent as they would have connected to the old one.

@_date: 2014-08-10 16:49:01
@_author: Hauke Laging 
@_subject: Why is the gpg-agent PID part of GPG_AGENT_INFO? 
echo $GPG_AGENT_INFO why is the gpg-agent PID part of GPG_AGENT_INFO? I just made a test: I killed gpg-agent and started it again. The applications still connect to it though the PID is obviously wrong then.
The only effect I can see is that you can (relatively certainly) determine whether gpg-agent has been restarted. But is that of any use? Or what is the "official" reason?

@_date: 2014-08-10 18:05:24
@_author: Hauke Laging 
@_subject: Error in ASSUAN description: GET_PASSPHRASE 
I think there is an error in the description of GET_PASSPHRASE on
The synopsis is:
GET_PASSPHRASE [--data] [--check] [--no-ask] [--repeat[=N]] [--
qualitybar] cache_id [error_message prompt description]
which would mean that "cache_id" is the only mandatory parameter which is consistent with the description:
"cache_id is expected to be a string used to identify a cached passphrase. Use a X to bypass the cache. With no other arguments the agent returns a cached passphrase or an error."
But with gpg-connect-agent I get:
ERR 67109144 IPC Parameterfehler  - no description given
OK XXXXXXXXXXXXXXXX
start cmd:> gpg --version
gpg (GnuPG) 2.0.22
libgcrypt 1.5.3

@_date: 2014-08-10 21:48:38
@_author: Hauke Laging 
@_subject: Error - bad passphrase 
Am So 10.08.2014, 20:39:26 schrieb david at gbenet.com:
You obviously have not set
in the config file gpg-agent.conf

@_date: 2014-08-12 09:17:52
@_author: Hauke Laging 
@_subject: Error - bad passphrase 
Am Mo 11.08.2014, 09:10:23 schrieb david at gbenet.com:
What happens if you try this command in the shell?
What is in line 6 of gpg.conf? debug-level basic?
Can you avoid the error by commenting out the line which causes the problem and fixing the permissions for ~/.gnupg/?

@_date: 2014-08-13 04:03:13
@_author: Hauke Laging 
@_subject: automatically add the passphrase for other (sub)keys of the same 
I just got more familiar with gpg-agent and had the idea that it might be nice (i.e. in this case: I should be capable of doing that myself) to have a background process which notices that gpg-agent has a new passphrase in it's cache. This process could determine the certificate to which this passphrase belongs and check whether it has more keys. If so (and they are not blacklisted in the configuration of this helper program) then the passphrase could be added for these other keys. That should not be a problem at least as long as GnuPG does not allow to set different passphrases for different certificate components. Most users I see don't accept that they have to enter the passphrase twice for "the same" key.
My question:
Is this maybe a bad idea for reasons I don't see?
I noticed one problem: This process would have to take precautions so that the caching time is not affected (if the user gives the passphrase for key A and the process adds it for key B then it may not add it for key A, too, if it has expired but not yet expired for B).

@_date: 2014-08-13 12:30:00
@_author: Hauke Laging 
@_subject: Seeking clarification with a few GPG concepts 
Am Mi 13.08.2014, 11:57:12 schrieb pzeudo at hushmail.com:
"The UID" is not the packet data in the OpenPGP certificate but the string "Alice " i.e. the same string is the same UID and cannot be created twice in a certificate.
You can create a different UID by changing a single char though (e.g. add a comment).
But it is possible to reactivate the old UID. You can delete the signature (i.e. the revocation) and create a new one. The signature is newer than the revocation thus the UID is valid again. Unfortunately you cannot rely on this as the RfC does not enforce using the newest signature but GnuPG behaves this way.
If you reactivate a UID then you have the old third party signatures again (if they haven't expired yet).
That does not make sense, at least not with the current version of Signing and decrypting are key operations not UID operations. Subkeys belong to a certificate as UIDs do. You cannot enforce an association with a certain UID.
It is a bad idea to mix e.g. private and business addresses in the same certificate anyway. That should be done with "equal" addresses only to (also) avoid such problems.
Usually the valid subkey (if there is one) with the newest self-
signature. But the RfC does not enforce this.
No. Though ? again ? I think it would not violate the standard. But usually there is only one valid subkey at a time anyway.
You can enforce the usage of certain (sub)keys but this is not going to work with current mail clients:
gpg --armor -r 0x12345678! -r 0x87654321! --encrypt
This is IMHO an urgently needed feature but not possible (i.e. there is no standard for it) today. I have written a German article about that:
You can replace subkeys or extend their validity period.
Subkeys and third party signatures are not related (today ? one more problem). The signatures are made over the combination of public mainkey and one of the UIDs.

@_date: 2014-08-13 12:37:38
@_author: Hauke Laging 
@_subject: Seeking clarification with a few GPG concepts 
Am Mi 13.08.2014, 12:23:24 schrieb Peter Lebbing:
Give it a try...
Not the last created but the last self-signed one (may differ e.g. after

@_date: 2014-08-13 15:21:58
@_author: Hauke Laging 
@_subject: Seeking clarification with a few GPG concepts 
Am Mi 13.08.2014, 14:54:40 schrieb pzeudo at hushmail.com:

@_date: 2014-08-14 00:17:10
@_author: Hauke Laging 
@_subject: Seeking clarification with a few GPG concepts 
Am Mi 13.08.2014, 22:43:41 schrieb MFPA:
Because of that OpenPGP (at least in a useful form) is not compatible with (probably not only) German signature law. I know that this will be replaced by new EU law in a few years but I don't know whether that makes any change to the current requirement that the key which has a "qualified certificate" must be stored on a smartcard (i.e. inaccessible even to the key owner).
This problem could be solved by adding a critical signature notation which contains the fingerprint(s) of the key(s) which the CA has created on a smartcard. That way the key owner could create new subkeys which would not be recognized as part of a "qualified certificate".
If you want to use OpenPGP today then the CA would have to create the private mainkey for you and throw it away after signing the subkeys. That would render OpenPGP quite useless.

@_date: 2014-08-19 21:40:59
@_author: Hauke Laging 
@_subject: So on & so forth 
Am Di 19.08.2014, 14:49:37 schrieb Robert J. Hansen:
Without additional assumptions this is wrong for the simple reason that cert-digest-algo renders the self-signatures unreadable, too. A certificate with (valid) self-signatures using an incompatible digest is completely useless to the other party.

@_date: 2014-12-21 00:20:47
@_author: Hauke Laging 
@_subject: Different subkeys and the use of a SmartCard 
Am Sa 20.12.2014, 19:20:23 schrieb Christopher Beck:
That is possible but AFAIK only via gpg command line parameters. I am not aware of any configuration file magic which would enforce this if gpg is called by another program (mail client) or gpgme is used.
If 0x11111111 is the old subkey and 0x22222222 the new one and 0x88888888 the main key then you would usually call gpg this way:
gpg --local-user 0x88888888 --sign file
Instead you can do this:
gpg --local-user 0x11111111! --sign file
Please note the "!".

@_date: 2014-12-21 01:16:26
@_author: Hauke Laging 
@_subject: Different subkeys and the use of a SmartCard 
Am So 21.12.2014, 00:46:40 schrieb Christopher Beck:
I noticed that too late: You shall always reply to the list. Usually I demand a list reply first before I answer.
That is hard to believe for the simple reason that applications (even shell scripts) don't see shell aliases.
You would have to either replace the gpg binary with a wrapper script (which would be overwritten by every update) or put the wrapper script earlier in the PATH (for the relevant applications). The wrapper script would have to detect and replace
--local-user 0x11111111
in all variants (-u, long ID, fingerprint) and pass the changed parameter together with the unchanged rest to gpg.
I have suggested some time ago to make the config file conditional. There was little enthusiasm about that. For these rather simple case a new option would be sufficient:
--key-replace sign 0x88888888 0x11111111
But my suggestions are seldom turned info effect. Make a big donation. Interesting idea. But I assume that leads to each (i.e. not only those requested from 0x88888888) signature being not replaced but being extended by one from 0x11111111.

@_date: 2014-02-04 04:55:56
@_author: Hauke Laging 
@_subject: making the X.509 infrastructure available for OpenPGP 
I would like to say first that my X.509 understanding is orders of magnitude lower that that of OpenPGP. So I hope this makes sense to This idea came to my mind while I was wondering why several CAs offer free (but rather useless...) certificates for X.509 but not for OpenPGP. Whatever they do with X.509 can be done with OpenPGP, too (e.g. setting an expiration date for the signature). How much effort can it be to offer both?
Then I realized that they could do that but that a CA signature for an OpenPGP certificate is rather useless in today's situation: Most of the value of an X.509 certification is the pre-installed root CA pool. A certification by a non-pre-installed CA is typically less useful than an OpenPGP certification.
Now my point: Keys can be converted from one format to the other. The fingerprint changes but obviously the keygrip doesn't. I believe it would make a lot of sense to create a connection between gpg and gpgsm and point gpgsm to the OS's and / or browser's root certificate pool. Then a CA could offer its certificate in OpenPGP format (even conforming to some new "standard" which makes it easier to detect this special kind of certificate e.g. by using a comment or signature notation pointing to the related X.509 certificate), and GnuPG could easily realize that it is the same key. This would relieve the user from the hard decision whether a certificate is valid (the CAs OpenPGP certificate in this case). The user would just have to decide (like with any other OpenPGP certificate) whether he wants to trust this CA (and how much).
By doing so the pre-installed CA pool would become valuable for OpenPGP, too, and it would make sense for the CAs to offer certifications for OpenPGP certificates, too.
Maybe there are other reasons for some CAs, too. But I assume this would be rather little effort and could close much of the gap to S/MIME's

@_date: 2014-02-04 18:36:52
@_author: Hauke Laging 
@_subject: making the X.509 infrastructure available for OpenPGP 
Am Di 04.02.2014, 11:09:42 schrieb Daniel Kahn Gillmor:
Interesting, I didn't know that.
Why wouldn't the fingerprint and the DN not be enough? The whole approach is based on the assumption that the X.509 certificate is already available.
You have misunderstood me: I said (or: tried to say...) quite the same. Because the CA key is in the root store the user need not care about it being valid or not. And this covers the OpenPGP variant of the key, too, of course. Thus the OpenPGP verification step could be skipped. The trust step could be skipped, too, but I would prefer to keep a question "This CA's key has already been verified. How much do you want to trust this CA?" That would reduce the risk of pre-installed certificates and remind users of it that they must decide whom to trust. With OpenPGP certifications it would also make perfect sense to set a CA to marginal Using a different key would not make sense. And without OpenPGP being capable of using the X.509 CA store it makes little sense for the CAs to make OpenPGP certifications. So why should they be willing to do something obviously useless? The OpenPGP community has to make a technical change first (or at least to offer making that change) before the question whether the CAs are willing is useful.
That's my opinion, too. And exactly that can be taken over to OpenPGP. Integrated deployment is already there, we just need the technical bridge from X.509 to OpenPGP. And afterwards the OpenPGP certifications by the CAs, of course.

@_date: 2014-02-05 04:11:36
@_author: Hauke Laging 
@_subject: making the X.509 infrastructure available for OpenPGP 
Am Di 04.02.2014, 19:38:07 schrieb Peter Lebbing:
And will probably "never" be.
That is not what I suggest. You can assign certification trust to any key. Why should this of all keys not be done with certain CA keys?
In contrast to the X.509 approach I would not skip the user's trust decision. And an important difference is that you could limit the CA to marginal trust.
There is an advantage even if you do not assign positive certification trust to the CA key: You see a valid CA signature on the certificate to be verified and can make it valid yourself.
Of course, it would be nice if you did not have to make a completely independent signature on the UID but could sign this one CA signature, thus empowering the CA signature to make the key valid. The advantages would be that
1) the CA cannot make keys valid without your explicit approval
2) in contrast to a signature by your own key this signature would become invalid if the CA revoked it. The RfC defines signatures over signatures but I guess this currently is not used (except for

@_date: 2014-02-05 04:15:53
@_author: Hauke Laging 
@_subject: making the X.509 infrastructure available for OpenPGP 
Am Di 04.02.2014, 21:05:10 schrieb Werner Koch:
Wow. Does that mean that PGP can verify OpenPGP keys with X.509 certificates (in combination with a related OpenPGP certificate)? Or is this just a "theoretical" feature?
Are there reasons (beside the obvious effort and work budget) for not having implemented this in GnuPG?

@_date: 2014-02-06 03:48:31
@_author: Hauke Laging 
@_subject: making the X.509 infrastructure available for OpenPGP 
Am Mi 05.02.2014, 11:23:24 schrieb Werner Koch:
I think that is not correct. It is today but not from the perspective of my proposal.
a) If a CA uses the same key in both formats then we can get the advantage which I have explained first: Enabling an X.509 CA to make useful OpenPGP certifications.
b) If normal users convert their X.509 certificate to OpenPGP then the respective CA could automatically create a signature for it as Peter has explained. I didn't think of that when starting this thread. Some detail questions arise: Which keys shall be the same? Doesn't make sense to demand that an X.509 key is the same like an OpenPGP offline mainkey. Doesn't make sense to demand avoiding offline mainkeys, too. So the best way would probably be to require just a subkey to be the same. I assume the current conversion tools are not capable of that yet but that would not be a problem for long. In most cases being reachable via both standards is an advantage. That is valid for both current OpenPGP-only users and S/MIME-only users.
c) The other way round ? an OpenPGP certificate is converted to X.509 ? would probably affect less people but would have the analogous advantage like the one above: If somebody uses OpenPGP only and gets a certification by an X.509 CA for it (made possible by (a)) then he could open his communication to the S/MIME world easily if the CA offers to certify the same key in both formats. In the S/MIME world this would have an advantage (for the contacts of this user) over getting an independent certificate because (only) the OpenPGP version probably has more certifications than just the one by the CA so the authenticity becomes more probable. That is a less radical version of dkg's remark: Using OpenPGP's certification capabilities in the S/MIME world.
Nobody would be forced to trust any CA. The CA problems would be avoided. But the one single important argument for using S/MIME would be destroyed. I believe that the OpenPGP community must be interested in getting this argument ? ease of use (with respect to key verification) ? out of the way. More or less the whole official German computer science community at the universities is preaching S/MIME for exactly this a) The DFN offers X.509 service only.
b) The Fakult?tentag Informatik has published a statement about a crypto culture at the universities after Snowden:
c) The GI (Gesellschaft f?r Informatik) is preparing a very similar A CS professor at Berlin's biggest university (more or less the biggest one in Germany) has even told me that he doesn't want me to organize OpenPGP courses there! That is the situation.
Does anyone here dare claim that we can get the majority of the people to use crypto (read: OpenPGP) without the help of the universities? That we can get the schools teach OpenPGP if the universities manage to make most crypto-using students use S/MIME?
From the perspective of spreading OpenPGP it seems quite dangerous to me to ignore the CAs (for "political" reasons or whyever). Of course, using OpenPGP does not morally oblige someone to help spread it. But I think it would be fair not just to say something like "I don't care about CAs" but to add "I don't care whether OpenPGP or X.509 gets the new crypto users". Of course, someone could both not care about CAs and be interested in spreading OpenPGP but that attitude would rise some very interesting questions.

@_date: 2014-02-06 03:56:26
@_author: Hauke Laging 
@_subject: making the X.509 infrastructure available for OpenPGP 
Am Mi 05.02.2014, 00:03:23 schrieb Daniel Kahn Gillmor:
That is correct but this argument doesn't make sense in the context of my proposal: You have to look for the X.509 certificate in the root CA store anyway because being part of the root CA pool is the core of my Using a different key for an intermediate CA would not be a problem at all. Just the root certificate (which is pre-installed) must be the

@_date: 2014-02-12 11:19:13
@_author: Hauke Laging 
@_subject: Trying to understand the bond between master and subordinate key 
Am Mi 12.02.2014, 07:02:51 schrieb Faru Guredo:
Signing (data) is not the relevant aspect of a mainkey. Certification (i.e. signing key components) is. You can create mainkeys which are not capable (i.e: not allowed) of signing data at all.
All public keys must be available to the public. (You cannot even prevent that from happening.) The public mainkey is necessary for the verification that the subkeys belong to this mainkey. Furthermore it is needed for the fingerprint check.
These two components are not related at all. These should be two distinct questions.
The mainkey binds the subkeys by signing them. Signature subkeys have to sign the mainkey, too, in order to become valid.
OpenPGP considers signatures by a subkey as equivalent to those by a mainkey. But if everyone understand what this means (and how it can be checked) then you can use the protected mainkey for more secure signatures (if you do not have a more secure other key). You can use it for more secure encryption, too (again: If everyone involved understands how to do that).
They are, technically. They could even be exchanged. But the OpenPGP key format marks one as the mainkey and the other ones as subkeys.
That's not the way keys are used. You tell the application to use the key 0xAAAAAAAA. That always refers to a mainkey. The OpenPGP subsystem (GnuPG) then selects the appropriate key: either the mainkey of a subkey. Your contacts only verify 0xAAAAAAAA. Possible subkeys are verified automatically (you cannot prevent that). Signatures are shown to be made by the mainkey.
More precise: GnuPG does show you the subkey which made the signature but I don't believe any GUI does (in a way useful to beginners). You can even force GnuPG to use a certain subkey (if technically possible) or the mainkey and thus override the automatic selection. But I have never seen a higer-level application offering that.
That is not a useful assumption.

@_date: 2014-02-13 15:45:59
@_author: Hauke Laging 
@_subject: Subject: openpgp card and basiccard RNG 
Am Do 13.02.2014, 14:32:56 schrieb Peter Lebbing:
How do you want to create a key on the card without an RNG?

@_date: 2014-02-19 11:55:46
@_author: Hauke Laging 
@_subject: How to verify revocation? 
Am Di 18.02.2014, 23:19:33 schrieb Tadas Slotkus:
That probably refers to the point that the keyservers don't do crypto checks. It means: There is a packet which looks like a key revocation but it could be forged. If an OpenPGP application downloads the key from the server then it does a signature check.

@_date: 2014-02-23 17:06:31
@_author: Hauke Laging 
@_subject: Size of main key... 
Am So 23.02.2014, 16:54:46 schrieb Laurent Jumet:
There is no way of changing the key without a fingerprint change at all. If there was one then the whole system would be dead. And even then it would not work as expected by you.

@_date: 2014-02-24 13:42:43
@_author: Hauke Laging 
@_subject: Size of main key... 
Am Mo 24.02.2014, 13:32:34 schrieb Peter Lebbing:
That's probably intentional. People always use the newest certificate, don't they...?  :-o

@_date: 2014-02-26 06:08:41
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
I just got asked: "How do I know that GnuPG in distro XY is not The answer to this question is long and unpleasant.
Thinking about that I had an idea ? once more I can just hope it's new.
One of the worst problems is that key generation might be compromised. I think this is the worst case because THEY would not even have to steal your key any more. And clever modifications to random data are hard to I suggest to add a new key generation mode. The only difference would be that the random input is not read from /dev/random any more (and that random_seed would not be used or newly initialized) but from an explicit source: --random-source /path/to/file. With that (I guess very small) change every GnuPG installation should generate the same key material (of course, the timestamps would have to be given, too).
Then people who need a very high level of security could create a pool of random data (e.g. by reading from /dev/random) and use this data and the same timestamps with different Linux distros, even with Windows. ;-)
If the generated keys are exactly the same on all systems then it is very improbable that the key generation has been compromised (or all is lost anyway).
This would be much easier (and thus available to normal people) than attempts to audit a distro.

@_date: 2014-02-26 06:33:55
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
Am Mi 26.02.2014, 00:19:17 schrieb Daniel Kahn Gillmor:
I thought about that when writing the mail but...
...I came to a conclusion quite different from yours: The aim is getting a non-compromised key. Whether the non-compromised key is generated by a compromised GnuPG is a different question and does not affect the security of the key itself!
Of course, damage can be caused later: Clean asymmetric crypto doesn't protect against compromised session keys e.g.
Thus such a feature should not be bound to key generation (would be even less work then). If this was a general "switch the entropy source" feature then checks could be applied to encryption and signing (not needed for RSA).

@_date: 2014-02-26 22:07:06
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
Am Mi 26.02.2014, 08:56:17 schrieb Werner Koch:
I had a look at that but I am not sure what you want me to read. Could you be more precise about that?
One thing came to my mind reading that: It may not be enough to "redirect" /dev/random as more entropy sources are used. I don't know though when they are used. Probably not for the generation of asymmetric and symmetric keys.
It seems to me that in the worst case three different inputs have to be supplied (for the different quality levels).

@_date: 2014-02-26 22:08:42
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
Am Mi 26.02.2014, 21:01:40 schrieb MFPA:
How is it going to do that if (a) it's running on an offline system and (b) its output is compared with that of other GnuPG "versions"?

@_date: 2014-02-26 23:04:03
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
Am Mi 26.02.2014, 22:29:46 schrieb Peter Lebbing:
Trivial to prevent in comparison to the task of verifying a distro.
This attitute doesn't help though considering that we meanwhile face a situation in which it has become more or less impossible to build a system which is known non-compromised.
Your point is valid towards people who are just too lazy (or uninformed) to do what can be reasonably done. In that case a wish towards GnuPG could be simply replaced by improving the environment in which it is going to be used. My perspective is that what can be reasonably done at the system level may not be enough any more (at the upper border of Furthermore while you cannot fix security problems in the outer system by the inner system (which I assume is the main part of the answer you mentioned) please mind that this is not what I suggest. I want to enable users to create another layer of control outside their system.
Thus I consider an improvement which is both easy to implement and easy to apply by the users a clear advantage. It is not enough to make ciphers and digests "NSA-proof" if that's not the attack vector they are going to use anyway.

@_date: 2014-02-28 15:42:29
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
Am Do 27.02.2014, 08:38:37 schrieb Michael Anders:
I am talking about a szenario in which everything which can be reasonably done already has been done. I am not talking about "Here's my system at which I click on every link I see. How can I make GnuPG more I.e. we are talking about offline systems here (yeah, I remember the discussion about USB sticks being dangerous...) thus a keylogger would not be a problem.

@_date: 2014-02-28 15:58:12
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
Am Do 27.02.2014, 10:28:10 schrieb Doug Barton:
Thanks for paying attention and thinking about this but I already explained why I consider the argument you (probably) refer to as valid in general but invalid in the special case I am talking about. I am not simply ignoring well-meant advice.
That is correct. But your argument does not cover two important cases:
a) Maybe I was not clear enough about that but I do not suggest this as a "Set the flag once (and do the other stuff) and after that you are safe forever" feature. This feature would have to be used for every encryption, too. (I guess it would be easily possible with RSA signatures today i.e. without changes to GnuPG.)
Thus your "when you're not using that flag" point is never reached.
b) This is not a problem if you just receive encrypted data. In that case you just must be sure that your key is clean. (The sender obviously has the problem how to be "sure" that his system is non-compromised.)
Sure. Thus I don't claim absolute security for my case but "only" that an attacker has to compromise more systems. Or central components (Kernel, GnuPG itself). I don't even have the slightest idea how safe the key is which signs the GnuPG packages... If I were the NSA then I would consider the software which Werner(?) uses for calculating the digests a valuable target... ;-)
Not at all. After all most people would even consider my proposal paranoid, wouldn't they?

@_date: 2014-02-28 16:05:55
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
Am Do 27.02.2014, 22:30:01 schrieb Robert J. Hansen:
As usual I can agree only.
But what does that mean in practice? Does that mean we don't aim for improvements any more, not even those which are easy to implement?
Why are we talking about something like SHA-3 at all if "all is lost to THEM" anyway? (Please note that I am not implying this was your Besides the obvious development resource limit I guess the point should be: How much more security would one get from a certain action and how much effort would it be?

@_date: 2014-01-02 23:39:02
@_author: Hauke Laging 
@_subject: Bug: --list-packets ignores second public key 
Am Do 02.01.2014, 18:11:33 schrieb Peter Pentchev:
Thanks for checking. I use 2.0.19 but that is not the point. For some strange reason it works now here, too. I am not aware of changes. Strange.

@_date: 2014-01-03 06:35:28
@_author: Hauke Laging 
@_subject: sign encrypted emails 
this is not a GnuPG problem. GnuPG is capable of doing what I want. But I am interested in your opinion.
I just noticed that you can easily be deluded about an email being encrypted: That you receive an encrypted mail does not mean that it was sent encrypted. An adversary may encrypt a non-encrypted message (which he has intercepted) in order to create more trust in the message for the recipient: If you receive critical information and are aware that it has not been encrypted then you may react differently from the case where you are sure that is was encrypted.
Or similar: A message is encrypted to a low security key which has been compromised (unnoticed by the recipient). The adversary decrypts the message ans reencrypts it to a more secure key.
This can be detected by asking the sender (which noone would do every time) or by signing the encrypted message (this may mean that you sign it twice: once before and once after encryption).
I would like to ask mail client developers to add this feature. But before I would like to hear opinions whether that makes sense.
need another level of nesting. Maybe the mail clients are not even prepared for reading such messages. That would not surprise me but would not be an argument against one client implementing this as the first one. I am interested in general arguments for and against this.
I have tried to create a test file. Unfortunately I am not sure whether I have done that correctly. I am familiar with checking MIME signatures with gpg directly but creating a message is a different story:
KMail ignores the outer signature layer in its main window but shows the structure correctly in the lower part of the window. That could mean that my file is correct but KMail not prepared to display it correctly.
Enigmail tells me that might be a signed message but doesn't show anything.
If I encrypt some text manually and paste it as body content in a PGP/MIME mail which gets signed and encrypted then KMail shows all three layers in its main window. This could indicate that KMail is capable of handling three layers but that my test file is incorrect.

@_date: 2014-01-03 09:59:26
@_author: Hauke Laging 
@_subject: sign encrypted emails 
Am Fr 03.01.2014, 00:33:51 schrieb Doug Barton:
I am quite sure you have misunderstood something. Sorry if I didn't make myself clear.
Do you agree that it is (or, depending on the content, can be) an important information whether a message was encrypted by the sender (and for which key)? How can it make little sense to provide this information?
Whether it is more important to encrypt a message or to sign it differs a lot with the content. Thus I do not understand your explanation of importance.
This is similar to SSL/TLS without client negotiation: The client knows (or: can know) whether it is encrypting for the right server. But the server cannot know whether the legitimate client has started the connection or an MitM attacker. If the server demands certainty about that then it has to require the use of client certificates.
But currently there is (AFAIK) no such thing as an analog for the client certificate in the OpenPGP world. The certificate itself is already there, of course, but it is not yet used in a way providing security for the recipient about the confidentiality of the message.

@_date: 2014-01-03 10:50:35
@_author: Hauke Laging 
@_subject: sign encrypted emails 
Am Fr 03.01.2014, 01:13:13 schrieb Doug Barton:
That's not what I am talking about. I am talking about the recipient having keys with different security levels. So there are keys I (insecure) and S (secure). By insecure I mean a key like the one which signs this email: Being used on a normal system (i.e. an insecure one; oh no, in a moment Rob will notice that I used "secure" and "insecure" If data is so important that it shall not be encrypted for my key I but for my key S only then I want to be sure that it has been encrypted by the sender for S. That the message which arrives at me is encrypted for S does not ensure this. Anyone can encrypt messages for my key.
As I said: If a normal user (i.e. one with nearly no security clue at all) starts an email conversation without encryption (or with weak encryption) and I notice that (because the message arrives unchanged) then I will tell the sender to change his behaviour. He will probably to that and the communication becomes secure.
It is in the interest of an adversary to prevent the communication from becoming secure.
In my opinion it is very unlikely that this would be revealed. There are people who like to get everything encrypted and those who prefer to get only important data encrypted. Every serious adversary will know what type his target is. This is more or less a public information.
So if somebody wants everything encrypted why should he ever ask or mention that? It is possible, yes. "Thanks for encrypting your messages." Who does that? And how many senders unfamiliar with crypto would understand from that that their message has been modified? Maybe a nice feature of their great ISP? Even worse with asking such a sender whether he has used the right recipient key. Probably he will not even understand the problem or misassess the situation.
And if the recipient expects only important data to be encrypted then the adversary would encrypt only important data (which may be hard to decide automatically though but who would notice a minute delay under normal circumstances?).
And why should the adversary not risk being detected? We encrypt because we assume that there are adversaries.
Yes. But why should the sender care? The sender can be sure about doing it right! The recipient is the one who cannot. And why should we bother writing that in every mail if there is a simple automatic solution to it? You cannot even be sure that the information is correct! People make I do not doubt that in any way but my argument isn't about validity at all. It is about guaranteed confidentiality! That is a big difference.

@_date: 2014-01-03 10:57:43
@_author: Hauke Laging 
@_subject: sign encrypted emails 
Am Fr 03.01.2014, 04:28:38 schrieb Robert J. Hansen:
Would you explain how that shall be avoided?
You send an email to me. You encrypt it to the key which I want you to encrypt it to. Then you sign the encrypted data.
If I receive an email from you which is not encrypted and signed (as the outer layer) then I go on red alert. Like today I might if the message is not encrypted or not signed.
How shall THEY create an encrypted-signed message if you have e.g. sent it without encryption? The adversary needs your signing key.

@_date: 2014-01-03 11:28:28
@_author: Hauke Laging 
@_subject: sign encrypted emails 
Am Fr 03.01.2014, 10:02:28 schrieb MFPA:
That's exactly why I want signatures. But I do not only want a signature which guarantees the data integrity, I want a(nother) signature which guarantees the (correct) encryption.
Yes, that is the more complicated case.
No, it wouldn't. The reason is that the signature is created the same way in the two cases encrypted and non-encrypted. Thus you can apply encryption later with the recipient having no chance at all to determine who encrypted.
It is better with respect to ensuring the encryption. It has disadvantages, though, otherwise we wouldn't do it the other way round. Proving the authenticity becomes more difficult if there is no signature within the encryption because a third party cannot encrypt the data. You would need to give them the session key. Who is capable of doing that? Furthermore you cannot know whether an encrypted message has been signed within. That may be an advantage in certain situations. You can send an encrypted message anonymously. That is not possible with my proposal (you would have to add a fourth layer... not difficult though).
But I do not suggest to make my configuration the default. I just want to be able to use it. Sometimes it's best to send a signed cleartext message, sometimes to send an unsingned encrypted message, sometimes a first signed then encrypted message and I want to stress that sometimes it's best to send a first encrypted then signed (or signed-encrypted-
signed) message.
The problem is the same with signed and unsigned messages.
I don't understand that statement.

@_date: 2014-01-03 11:41:02
@_author: Hauke Laging 
@_subject: How to do pinentry in same screen as gpg 
Am Fr 03.01.2014, 01:14:22 schrieb Dan Mahoney, System Admin:
Do you start gpg-agent before gpg2? I would expect the behaviour to be the same like gpg if gpg-agent is not running.
You can write a wrapper around pinentry. This wrapper could start pinentry in a different console. See:
I assume this is much more a screen problem. Some time ago I tried to create a pipeline between two processes running in different screen windows. I didn't manage to do that. But maybe there are tricks unknown to me. Maybe that can be done with redirecting stdin and stdout to a socket with socat or something like that.

@_date: 2014-01-05 04:31:49
@_author: Hauke Laging 
@_subject: keysigning: lsign and offline master key 
Am Sa 04.01.2014, 21:41:32 schrieb nb.linux:
--export-options export-local-sigs
Not necessary for import if the importing system knows the signing key as secret key (no matter whether the mainkey is available or not).

@_date: 2014-01-05 04:38:58
@_author: Hauke Laging 
@_subject: sign encrypted emails 
Am Sa 04.01.2014, 22:28:26 schrieb Johannes Zarl:
That would be possible for an attacker but not make any sense: If the recipient expects the outer signature (only then this feature is a protection like signing is a protection only if the recipient acts differently on signed vs. non-signed messages) then the attacker is discovered without any advantage.
There is another reason for creating this fourth layer: Some people want to hide the metadata (who made the signature).
You are aware that is doesn't make any sense to make this claim without any argument after the opposite has been claimed with an argument (a very strong one)?

@_date: 2014-01-05 11:15:54
@_author: Hauke Laging 
@_subject: sign encrypted emails 
Am So 05.01.2014, 10:35:44 schrieb Peter Lebbing:
There are two different meanings of "whether encryption is applied" which we must tell apart here:
1) The message arrives encrypted.
2) You know that the message has been sent encrypted.
(1) follows from (2) but not the other way round. What I say is:
a) It makes sense to act differently depending on (2).
b) It does not make much sense to act differently depending on (1).
Do you agree on (a) and (b)?
Today you hardly ever have (2). That's what I want to change.
I replied to: "One should certainly not act differently depending on the encryption of a message."
Maybe there is a misunderstanding (maybe even between the one I replied to and the one he replied to). In an earlier mail I have explained (a). It seemed to me that he said (a) was wrong without giving any reason for that claim. Maybe he meant (b) but that would not have anything to do with the discussion I started as (b) is the reason for me starting it.
In my understanding this term refers to problems which are better solved socially than technically. But that simply isn't the case here. Why should I write "I will encrypt this message to 0x12345678" in every mail which is boring, easily forgotten and error-prone if the problem can *easily* be solved technically with much better results? Why should people prefer to have to change their behaviour (social solution) over not having to change their behaviour if the second option delivers better results with less effort?
There has been an argument of the kind: "There is another solution to the problem than yours." OK. But that's not the point. The point is: Which is better? This is about technical guarantees. How can a social approach ever be better than a technical one in that area? GnuPG doesn't teach people to create huge keys it prevents it technically. Solving a social problem with a technical solution? And if so: Is that a problem?

@_date: 2014-01-05 17:07:08
@_author: Hauke Laging 
@_subject: sign encrypted emails 
Am So 05.01.2014, 10:15:51 schrieb Robert J. Hansen:
That is neither trivial nor reliable nor the best approach to deliver this information.
Like verifying fingerprints? 8-)
As I said in my first mail in this thread this isn't about changing GnuPG at all because a) this problem is one level above GnuPG
b) GnuPG already has all the capabilities necessary to do this.
As I also said the reason why I have asked this here is the availability of people who can make useful comments on that (and are probably interested in such general discussions).

@_date: 2014-01-06 01:51:50
@_author: Hauke Laging 
@_subject: sign encrypted emails 
Am So 05.01.2014, 16:41:11 schrieb Doug Barton:
Let me guess: Modifying the mail client so that it automatically removes the word "not" would be illegitimate because for some strange reason that would be "solving social problems by technical means"...

@_date: 2014-01-06 03:24:10
@_author: Hauke Laging 
@_subject: isolating the signature from encrypted data (was: sign encrypted 
Am Mo 06.01.2014, 01:47:39 schrieb MFPA:
That is correct. I am not aware of a possibility to get the data and the signature from GnuPG. But that doesn't mean it's not possible. AFAIK there is no difference in the signature in both cases. So it should be easy to patch GnuPG in order to get this data (if there isn't another OpenPGP implementation which offers this action).
Use both ways (one step, two steps) to sign and encrypt a file and have a look at the result with gpg --list-packets.

@_date: 2014-01-06 12:30:05
@_author: Hauke Laging 
@_subject: "no valid subkey" 
Am Mo 06.01.2014, 11:09:55 schrieb Erik Josefsson:
Not surprising:
pub   4096R/0xB240C11D 2010-12-10 [expires: 2014-11-11]
uid         Erik Josefsson uid         Erik Josefsson (ehj) sub   4096R/0x0971954D 2010-12-10 [expired: 2013-12-09]
                                   ^^^^^^^^^^^^^^^^^^^
You must extend the validity period of the subkey. This may be easier with a GUI (GPA cannot do that but Enigmails key management can).
In the console it's this:
gpg --edit-key 0xB240C11D
_ > key 1
_ > expire
_ > ...
_ > save

@_date: 2014-01-10 09:44:16
@_author: Hauke Laging 
@_subject: Question Regarding Passphrases When Signing 
Am Do 09.01.2014, 20:51:04 schrieb Jim Ernst:
You must define the signing key:
gpg --local-user 0x12345678 --detach-sign file
or shorter
gpg -u 0x12345678 --detach-sign file

@_date: 2014-01-15 14:02:12
@_author: Hauke Laging 
@_subject: Windows editor destroys gpg.conf 
when I help Windows users create keys then my script converts the Linux version of gpg.conf (after some editing) to the Windows line endings. This works.
But if I edit the file with the Windows editor (unfortunately I have forgotten the Windows version) then gpg crashes with an error message like "error in gpg.conf:1". I have experienced that several times in the past already.
Unfortunately I both don't have Windows at home and have forgotten to make a copy of the damaged file so that I cannot have a look at it.
A wild guess is that the editor adds a UTF-8 BOM at the beginning of the file (but that wouldn't affect XP, would it?).
Two concerns:
1) Does anyone know what the problem is and/or whether I can avoid it by using another program which is part of Windows (or widely used)?
2) Would it make sense to make gpg work with such config files...? 8-)

@_date: 2014-01-16 12:31:56
@_author: Hauke Laging 
@_subject: Any way for two correspondents to set up gnupg within a few 
Am Do 16.01.2014, 05:34:34 schrieb Don Warner Saklad:
Ask an "expert" to do the setup. After that usage is simple.

@_date: 2014-01-17 13:28:50
@_author: Hauke Laging 
@_subject: Reusing signed user ID or attribute 
Am Fr 17.01.2014, 11:44:55 schrieb Daniele Ricci:
I am afraid that depends on the implementation. The RfC isn't clear on that (if I understand it correctly).
It says about self-signatures (a revocation is not a self-signature in this sense, though):
"An implementation that encounters multiple self-signatures on the same object may resolve the ambiguity in any way it sees fit, but it is RECOMMENDED that priority be given to the most recent self-signature."
About revocations it says:
"0x30: Certification revocation signature
       This signature revokes an earlier User ID certification signature
       (signature class 0x10 through 0x13) or direct-key signature
       (0x1F).  It should be issued by the same key that issued the
       revoked signature or an authorized revocation key.  The signature
       is computed over the same data as the certificate that it
       revokes, and should have a later creation date than that
       certificate."
IIRC then GnuPG accepts a later self-signature (overriding the revocation). IMHO that makes most sense. As long as the mainkey isn't revoked or expired why shouldn't one "change one's mind"?
I haven't tried now but IIRC you have to delete the revocation first before you can create a new signature.

@_date: 2014-01-17 23:02:38
@_author: Hauke Laging 
@_subject: Reusing signed user ID or attribute 
Am Fr 17.01.2014, 20:03:15 schrieb Johannes Zarl:
That's why we all use only the super-secure (haha) offline mainkeys.

@_date: 2014-01-19 17:14:58
@_author: Hauke Laging 
@_subject: Reusing signed user ID or attribute 
Am So 19.01.2014, 15:55:51 schrieb Daniele Ricci:
My first thought is: Why should it make sense to put this data into a Use a simple file with a simple signature. Let the signature expire every few days (or hours, whatever you need).
You may put the URL of the file into the certificate using a notation.

@_date: 2014-01-21 17:30:07
@_author: Hauke Laging 
@_subject: Any way for two correspondents to set up gnupg within a few 
Am Di 21.01.2014, 16:06:36 schrieb Michael Anders:
Unfortunately that's not a reliable guide.

@_date: 2014-01-22 13:58:12
@_author: Hauke Laging 
@_subject: Spam sent in response to GnuPG-users messages? 
Am Mi 22.01.2014, 13:52:09 schrieb Pete Stephenson:
Once, accidentally maybe:

@_date: 2014-07-01 18:43:42
@_author: Hauke Laging 
@_subject: howto revoke a key that has no secret key 
Am Di 01.07.2014, 09:29:57 schrieb eMyListsDDg:
Your question is unclear (at least to me).
1) You cannot remove a certificate from a keyserver. Not even with the private key.
2) You can delete a key from your keyring but without the private mainkey you cannot revoke the key. Guess what the consequences would be if everyone (i.e. those without the private key) could revoke a key...

@_date: 2014-07-01 23:37:32
@_author: Hauke Laging 
@_subject: Calculating the Private Key 
Am Di 01.07.2014, 17:28:36 schrieb Robert J. Hansen:
Yeah, but someone told us (pointed us at) here some time ago that breaking RSA was NOT the same like breaking RSA... ;-)

@_date: 2014-07-04 06:04:12
@_author: Hauke Laging 
@_subject: Key distribution via NFC 
Am Do 03.07.2014, 23:54:39 schrieb Robert J. Hansen:
I don't even have a smartphone... but
1) might it be possible to combine several of these storage devices (reading them one after the other) to add up their capacity?
2) wouldn't it be enough to transfer the mainkey? Or even a fingerprint? The rest could be safely taken from the keyservers.

@_date: 2014-07-07 00:53:18
@_author: Hauke Laging 
@_subject: Encrypt directly to keyfile 
Am So 06.07.2014, 23:18:20 schrieb Matthias Fischer:
Why should a feature be added that can so easily be emulated by a simple test -d "$gpgdir" && rm -r "$gpgdir"
gpg --homedir "$gpgdir" --import KEYFILE
KEY_ID="$(gpg --homedir "$gpgdir" --with-colons --list-keys | awk -F: '$1 == "pub" {print $5;}')"
gpg --homedir "$gpgdir" --recipient "$KEY_ID" --encrypt FILE
rm -r "$gpgdir"

@_date: 2014-07-08 10:08:58
@_author: Hauke Laging 
@_subject: Fwd: Help, batch mode not working for --edit-key option ? 
Am Di 08.07.2014, 07:04:05 schrieb Hugo Almeida:
It does work. You can have a look at my script which does that:
The script is in German only yet. But you can search for addkey and see how it works.

@_date: 2014-07-09 18:54:36
@_author: Hauke Laging 
@_subject: how to do 
Am Di 08.07.2014, 14:41:36 schrieb J. David Boyd:
That is right.
And that is wrong.

@_date: 2014-07-14 06:17:06
@_author: Hauke Laging 
@_subject: How to add secondary uid? 
Am So 13.07.2014, 21:06:50 schrieb Schlacta, Christ:
The answer is simple: You cannot "add a secondary UID" to a certificate. You can "add a UID" only.
The new one does not become a "primary UID" in a technical sense. It is just shown first because it has the newest self signature.
You have to explicitly mark one as primary:
gpg --edit-key 0x12345678
gpg> uid 2
gpg> primary
gpg> save

@_date: 2014-07-14 17:44:19
@_author: Hauke Laging 
@_subject: email bot for PGP/MIME PGP/Inline conversion 
first I admit that this is not a GnuPG problem.
AFAIK the smartphone OpenPGP clients are incapable of handling PGP/MIME yet. Wouldn't it be nice to have a mail service where you can send a  PGP/MIME mail to and get it back in PGP/Inline format (or more general: in the other format)?
If the message is encrypted then there would not even be a privacy Unencrypted mail could be forwarded (and sent back) encryptedly. The service provider could read it though.
If such services become established (of course, after so much time the smartphone apps should finally be fixed...) then the mail providers could offer this service themselves. They already know the mail content

@_date: 2014-07-14 18:12:05
@_author: Hauke Laging 
@_subject: email bot for PGP/MIME PGP/Inline conversion 
Am Mo 14.07.2014, 18:06:37 schrieb martijn.list:
...with emails which have an attachment.

@_date: 2014-07-18 01:09:15
@_author: Hauke Laging 
@_subject: Different passwords for subkeys 
Am Do 17.07.2014, 23:39:53 schrieb MFPA:
That doesn't help as you don't have to export secret keys but have to import them.
For some reason it is not possible (with 1.4.x and 2.0.x) to import secret components for a key which is already part of the secret keyring. Thus you have to a) either change the passphrase of single components within the secret keyring (which GnuPG doesn't support)
b) or import a secret key file which already contains components with different passphrases.

@_date: 2014-07-18 02:03:24
@_author: Hauke Laging 
@_subject: symmetric email encryption 
is there any OpenPGP mail client which supports symmetric encryption?
I think that would be a nice feature for recipients who don't have an asymmetric key (those 99%). Many new communication systems have a fallback option for symmetric encryption in case the preferred way is unavailable. And, quite important: It would not require serious development effort as this possibility is built-in with GnuPGP. Anyone using Linux (and a mail client with OpenPGP support) could use that directly. The others would just have to install e.g. Gpg4win and Enigmail but would not have to configure it.
Is there any reason *not* to support symmetric-only encryption in a mail

@_date: 2014-07-18 03:13:38
@_author: Hauke Laging 
@_subject: symmetric email encryption 
Am Do 17.07.2014, 21:02:06 schrieb Robert J. Hansen:
You haven't understood whom I want that for. People who have a certificate usually would not use this with each other, of course. But even the majority of people who "use" GnuPG (without being aware of that) don't have one: The Linux users who have GnuPG installed because the package manager needs it. And the 99% aren't even GnuPG users.
My claim is that it is easier to make someone just install GnuPG and e.g. Enigmail than to make him do that plus care about certificates. I would not advise using OpenPGP without certificates but often it may end up as "take this or nothing".

@_date: 2014-07-18 17:20:27
@_author: Hauke Laging 
@_subject: symmetric email encryption 
Am Fr 18.07.2014, 15:40:34 schrieb Ingo Kl?cker:
That is easily possible. But what would have to be done (at least)?
a) You need a new button.
b) Pressing this button would replace
--recipient 0x12345678 --encrypt
in gpg terms ? I am not familiar with gpgme but for obvious reasons it has to be quite similar.
Of course, there is. Otherwise you would not be asked for a symmetric password for certain messages, would you?
"gpg --symmetric" is not a GnuPG extension. The OpenPGP RfC covers the case of "symmetric" encryption (which still is hybrid).
I would be satisfied with a single one.
Which I can easily ignore as it is out of the scope of message handling. How have users ever successfully exchanged encrypted ZIP archives without ZIP providing an infrastructure for key exchange...? Why does OpenPGP cover symmetric encryption without providing an infrastructure for symmetric key exchange...?
Users are capable of exchanging sheets of paper or having phone calls. The typical ways for safe fingerprint exchange are safe enough for password exchange, too.
This is not about offering a great new concept to the public but about making an already existing (on the file level) and easily understandable feature available for email with very little effort.
I not only read it but I think that I gave a quite precise reply to There are many features which would be nice to have. What do you think how many orders of magintude this one is more effort to implement than my proposal?

@_date: 2014-07-18 19:21:05
@_author: Hauke Laging 
@_subject: symmetric email encryption 
Am Fr 18.07.2014, 09:46:14 schrieb Doug Barton:
If I have understood everything right then this is not the same But I am really surprised that you ask why you should communicate via email with someone "though" you e.g. meet him once per month. Or with someone whom you could call instead. Is that really your question?
Symmetric keys and fingerprints have to be exchanged through a secure channel only once.

@_date: 2014-07-19 03:46:56
@_author: Hauke Laging 
@_subject: symmetric email encryption 
Am Fr 18.07.2014, 13:49:54 schrieb Robert J. Hansen:
Are symmetric keys more probable to be compromised than asymmetric ones? Who even on this list makes a keyring update at least every three days?
I guess this discussion does not go well because of a misunderstanding or wrong expectations.
You and Ingo are talking about "real crypto" issues.
BTW: I had thought that meanwile my image here should be that I take key management (and other stuff) too seriously instead of not seriously enough. Usually I suggest something and the reaction is something like "Let's not make it more complicated; who is supposed to use it yet?"
What I am suggesting is neither an alternative to regular OpenPGP encryption nor meant as "real crypto" at all.
I think we all can agree that those 99% have decided not to use e2e crypto at all. Let alone real e2e crypto. Snowden has caused only a small change to that. I could tell you stories (a few days old) from German universities and IT security associations which would probably make you cry. So nobody knows if, when and why this may change. Maybe Ingo's suggestion does the job. Haven't herad about STEED for quite a while though. And I appreciate every effort in this area. But I don't think that it can be implemented only if mine is not...
I am talking about a feature for those who don't care to use crypto *at all*. I would like to offer something easy to these people. Not "easy" in a "You have 30 contacts and have to send 5 emails to each" scenario or even in a "well calculated" sense but "easy" as in
a) "You just have to install a software" (people are used to installing software and not afraid of it) and "You need not configure it"
b) "You just need a password." Everyone knows what a password is and isn't afraid of using one. Nobody knows what key pairs are and why you should authenticate them.
This is not a replacement feature for people who often encrypt mails. This is supposed to be for people who want to encrypt a single mail or a few of them. And these "I have no clue" people most probably do not expect the same security level from such an ad hoc solution like from real crypto technology - which they would have to understand and learn first. Thus IMHO it does not make sense to discuss possible security glitches about this because they are not an issue for the group of people who would otherwise not use crypto at all.
Like vedaal I assume that people who use this feature often would probably change to asymmetric crypto.

@_date: 2014-07-19 04:37:56
@_author: Hauke Laging 
@_subject: symmetric email encryption 
Am Sa 19.07.2014, 01:42:19 schrieb Ingo Kl?cker:
Yeah and this works the other way round, doesn't it? Doing nothing about the GUI will finally magically improve the situation...
(Please not that this was written before the Cryptoparty community became well known.)
Yes, until someone decides to combine this with kwallet...
That is quite easy to understand though: As the handling of asymmetric keys is easier (and the "encrypt symmetrically" feature would point the user at this fact every time) there is a certain pressure upon the user to switch to asymmetric keys.
Is there any easier solution with symmetric encryption? Sometimes poeple are told to use encrypted ZIP archives. I have no idea how often this is done. But this is a "how big is your desire to encrypt this email?" problem. If the user wants it encrypted then he will enter the password.
If people who are not prepared to use asymmetric crypto (those 99%) want password encryption in a certain situation then I don't want them to have to use something different from OpenPGP. I don't want them to have an "This big thing can't even handle password encryption" experience. I want them to have a "This can handle password encryption but it can do better and more convenient if you spend some time learning how" It does work. It seems not to work with Thunderbird/Enigmail though. But maybe I have done something wrong. The Enigmail console output looks good to me...
I have prepared a mail file for those who want to give this a try:
The only thing I want to prevent them from doing is using some other technology for symmetric encryption. I am not going to advocate this as "the way to go". It seems to me that you (and Rob) are completely missing the intention.
Same answer: This is for users who don't need any threat model consideration. What do you think what the computers of people who didn't care to create a key pair yet look like? Stronger crypto is the last thing they need. Even bad crypto is the most secure part of their digital life.
I don't want to achieve anything technical by this. I want to achive something social by this. I want to exploit people's familiarity with passwords for pushing them in the right direction.
Doesn't make any sense to me. If I encrypt data for myself then I encrypt it for my own key. The exception to this rule is data which may be needed on systems which don't have my private key installed. And that's precisely the same for my proposal: It's for encryption for people who don't have a private key at all.
And you are probably right if the number of emails or contacts exceeds a certain value. But this is probably not how users act. They will not try to understand both systems in order to calculate what is easier (in the long run). They will compare
a) install software and do something I understand (password)
b) install software, configure software which I don't understand and do something I don't understand (asymmetric key handling).
I bet the majority of the 99% prefers to start with (a). This is a smaller step which prepares them for the next one (which has become smaller due to their getting familiar with encryption).
I am in no way trying to prevent you from developing that. I don't understand what this comparison shall be good for. That would be relevant if using resources for implementing mine would prevent yours from being done. But the resources used for this thread already would probably be enough for implementing mine.
You didn't understand that my remark was a reply. I wouldn't dare to ignore Robert's questions anyway...
His question ? as I understand it ? was completely unrelated to my proposal as he criticized something that would never happen. He argued with the behaviour of a group who is not supposed to use this feature at OK when will it be there? Five years from now? Mine could be there tomorrow. How many new users would be generated by my proposal over the next five years?
I don't even believe that using crypto must become easier. Using it on average level is already easier that more or less everything you learn at school. I guess the solution is educating the people. Not because of technical difficulties but because of laziness and group effects. even if your idea is ready one day then people will still have to learn to do it the right way.

@_date: 2014-07-19 05:09:31
@_author: Hauke Laging 
@_subject: symmetric email encryption 
Am Fr 18.07.2014, 22:51:13 schrieb Robert J. Hansen:
A factor of two is "immense" to you...?
Furthermore it seems to me that you ignore the fact that in a typical scenario you need only one of the asymmetric keys in order to be able to read the whole communication between two (or even more as long as all are part of it) people as the default behaviour is to encrypt for the recipient's key and also for the sender's key. Thus every mail can be read by each of the private keys.

@_date: 2014-07-19 23:02:19
@_author: Hauke Laging 
@_subject: symmetric email encryption 
Am Sa 19.07.2014, 22:37:24 schrieb Ingo Kl?cker:
I guess the typical case would be that either the sender or the recipient wants the communication encrypted (probably uses real crypto himself) and would use symmetric encryption as the fastest and easiest way to enable the other one to do that (or the only way the other party accepts at that moment).
Furthermore: Usually when people start using a new tool or new technology they don't use it right. Probably at least 90% of the OpenPGP users use OpenPGP in a way I would not consider good. They do it because it's OK for them. They probably haven't put much consideration into that ? as you have to know a lot about the area to make these considerations. Noone cares about that with normal crypto. Why should this be a hard criterion in this case?
I haven't seen the new Enigmail 1.7 yet but the default settings of 1.6 are a nightmare. GPGTools takes worst practice to a new level by doing the same like Enigmail ? but without the (easy to find?) option to change it. And even more showing off on the bad side: Certifying keys *without* showing the fingerprint! GnuPG doesn't tell you at which (maximum) level a certain key has been signed. There is no transparency in authenticity, no transparency in key security (part of that: no transparency about PC security, see (German)  no trancparency in key usage, the current WoT is crap because it offers nearly none of the information you need... That is the current crypto reality. And people are talking about security problems and thread models for symmetric encryption, fighting for good crypto usage? Really?

@_date: 2014-07-29 21:35:57
@_author: Hauke Laging 
@_subject: crypto code of conduct ("Crypto-Knigge") 
I would like to abuse this list for something IMHO important though slightly off-topic...
I think we (and "we" is "the Internet users" not just "those who write on gnupg-users"...) are missing a culture of secured communication (which can mean encrypted, signed or anonymous or a combination of that) and that an accpeted (by "those who write on gnupg-users" ;-) ) code of conduct (my German term: "Crypto-Knigge") would be quite useful to get there (or at least nearer).
I am not talking about technical recommendations but about "organizational" (behaviour / attitude) recommendations. It's not the reason for the selection but I assume that it's easier to get a concensus in that area... :-)
I have written a draft for that. And now it's getting even more off-
topic: It's in German; thus this mainly addresses the Gerrman speaking (i.e. understanding) people on this list who might be interested in The idea is not OpenPGP- / GnuPG-specific but for obvious reasons my view is...
But if there is enough interest from people who don't understand German then I would try to make a good translation.
I wrote it in German because (a) most of my crypto-related articles are an German and (b) something big (compared to former crypto stuff affecting the general public) is going to happen in Germany later this year which could help a lot to make this more common.

@_date: 2014-07-29 22:22:30
@_author: Hauke Laging 
@_subject: crypto code of conduct ("Crypto-Knigge") 
Am Di 29.07.2014, 14:04:13 schrieb Mirimir:
Sure but not on this list; I don't want it to be flooded by an OT discussion. Those who want to contribute should send me an email. Depending on the number of people I would move that to a dedicated mailing list or something more suitable.

@_date: 2014-07-30 00:17:20
@_author: Hauke Laging 
@_subject: crypto code of conduct ("Crypto-Knigge") 
Am Di 29.07.2014, 21:25:07 schrieb Smith, Cathy:
Both communities because they would require different reactions by me.

@_date: 2014-06-01 16:17:52
@_author: Hauke Laging 
@_subject: Why create offline main key without encryption capabilities 
Am So 01.06.2014, 12:54:30 schrieb Suspekt:
I do :-)
There are certain risks using the same RSA key for encryption and signing. If you make a blind signature over data someone supplied then you unintentionally decrypt the data (and send it back).
There are legal and organizational arguments, too:
1) If you are forced to give a decryption key to the authorities then it is an advantage if they cannot use this key to forge signatures.
2) If a signature key has expired then you may delete the private part. You should usually never throw away a decryption key, though, as it can happen that you have to decrypt data long after the public part has I say: Everyone needs keys at different security levels (German):
E.g. the key which is going to sign this email is not suitable for handling really important data. But as long as hardly anybody has a complete high-security key it seems useful to have at least the mainkey as a last resort.
Technically you could use other subkeys for higher security levels ? but who would understand that? Seems very dangerous to me, more dangerous than using the mainkey.

@_date: 2014-06-01 21:26:47
@_author: Hauke Laging 
@_subject: Why create offline main key without encryption capabilities 
Am So 01.06.2014, 21:12:49 schrieb Suspekt:
I just remembered that and didn't read it again before mentioning it. It seems I have misunderstood it so that this is not a real-world problem (as NdK pointed out).
I don't see any legal approach in Germany to force somebody to give his decryption key to the police. Don't forget that the police would not even need the decryption key to decrypt a certain message. You can give them the session key for this message.

@_date: 2014-06-02 17:38:29
@_author: Hauke Laging 
@_subject: Why create offline main key without encryption capabilities 
Am Mo 02.06.2014, 17:30:15 schrieb Suspekt:
What can possibly go wrong...

@_date: 2014-06-08 20:34:35
@_author: Hauke Laging 
@_subject: Docs central, with 'Email Self-Defence' 
Am So 08.06.2014, 18:51:39 schrieb Suspekt:
There are recommendations you can discuss for quite a while but there are also (and that's probably the majority of cases you mean) statements which are stupid or plain wrong.
"Before you can use a key you have to make it valid. In order to get this done just set the owner trust to ultimate"...
And incomplete information:
"After creating the key create a revocation certificate, too." I still have to be told why it shall be possible to have a safe backup of the revocation certificate but impossible (or less possible) to have a safe backup of the secret mainkey...
When I encounter such statements (more or less limited to German pages) then I contact the author or leave a comment on that page. As they all make the same mistakes I meanwhile have a list of text blocks which I can use with copy&paste...
I even offer to check articles before or after publication:
I recommend that all qualified people do the same when encountering bad articles. It seems important to me to increase the quality of information out there.

@_date: 2014-06-10 01:56:34
@_author: Hauke Laging 
@_subject: Docs central, with 'Email Self-Defence' 
Am So 08.06.2014, 20:59:41 schrieb Peter Lebbing:
That would be a good explanation of this aspect but that is usually not what you read there.
I understand the guess but that is at least not my experience. If I tell authors about their mistakes they are usually happy that I help them improve their article.
Maybe the main reason for writing is not feeling qualified but the wish to help. Or they feel there are people even less qualified than they themselves and write for those but do not believe that they are close to the upper end of knowledge. Maybe the reaction depends on how they assess the knowledge of the one who tries to correct them. The from address of those of my emails may help there. ;-)
I suggest: Just give it a try.

@_date: 2014-06-17 07:18:19
@_author: Hauke Laging 
@_subject: Changeing the expiry date of a sub key 
Am Mo 16.06.2014, 20:04:14 schrieb john s.:
The command is just "expire".
And as you did not select the subkey with "key 1" before, the expire command refers to the mainkey.
This does not change anything as the mainkey was already valid for five days before the --edit-key.

@_date: 2014-06-17 12:58:14
@_author: Hauke Laging 
@_subject: mascot_p 
Am Di 17.06.2014, 11:36:11 schrieb Werner Koch:
But something similar to a mascot.
I would like to point at this:
That wasn't about GnuPG specifically but about OpenPGP in general though (which seems much more useful to me).
And for those who understand German (or consider the Google translator This is even more general and IMHO the biggest chance to really change the game (especially with little effort) ? in contrast to a project or even standard logo. I have the promise of the c't editorship to support this ? if somebody else gets it done.

@_date: 2014-06-17 14:24:11
@_author: Hauke Laging 
@_subject: mascot_p 
Am Di 17.06.2014, 13:51:05 schrieb Werner Koch:
That's what my first remark referred to.
I guess you have misunderstood the linked text: That is not specific to GnuPG, OpenPGP or any other standard or tool at all.

@_date: 2014-06-24 19:57:12
@_author: Hauke Laging 
@_subject: riseup.net OpenPGP Best Practices article 
Am Di 24.06.2014, 09:50:04 schrieb Nex6|Bill:
That depends on it whether you need security or the illusion of security is enough for you.
IMHO it is one of the main problems that hardly anyone cares about telling protection levels apart. "Security" is a really wide spectrum, for some beginning at "random six letter passwords". You cannot say in a useful sense what is a good recommendation without looking at what is needed in the respective situation.
Thus I advocate a standardized set of security levels for data, keys and systems. And authentication on the other hand:
(German only)

@_date: 2014-06-26 22:35:40
@_author: Hauke Laging 
@_subject: riseup.net OpenPGP Best Practices article 
Am Do 26.06.2014, 16:06:25 schrieb Robert J. Hansen:
You mean except for that you must be capable of forging a mainkey signature (if you don't control the sending system anyway in which case you don't need the key any more)?
I would say that if you think it's OK to just assume that signing is really broken why not also just assume that encryption is really broken (i.e. not offering those 112 bit by far)?
But I strongly support your main point. Whether anyone cares or not... ;-)  I would like to put it (or one of the consequences) this way: Educating users is much more important than changing default settings. When I teach people I tell them that as a rule of thumb
10% of the overall security they get are provided by technology
60% of it come from their own knowledge
and the last 30% come from the discipline to really (not) do what you know you should (not) do.

@_date: 2014-03-03 04:16:44
@_author: Hauke Laging 
@_subject: key generation: paranoia mode - explicit random input 
Am Sa 01.03.2014, 08:40:56 schrieb Daniel Kahn Gillmor:
Probably. But this is not a proposal for "users" but for the kind of people who regularly write on this list. People who know what they are Security improvements never(?) come for free.

@_date: 2014-03-03 13:49:00
@_author: Hauke Laging 
@_subject: Removing Policy URLs 
Am Mo 03.03.2014, 12:24:39 schrieb Khelben Blackstaff:
I have tried that some time ago and didn't find any way to do that. I guess that is due to the fact that hardly anybody uses this feature so that its support is probably limited.
It is possible with UID signatures but in that case with tricks only, too. And these tricks are nor available for subkeys.
Thus I am afraid this is not possible with the official version of

@_date: 2014-03-08 21:12:28
@_author: Hauke Laging 
@_subject: marking offline mainkeys / smartcard keys in --edit-key toggle 
I have just been pointed at the fact that --list-secret-keys does mark offline mainkeys but --edit-key toggle doesn't.
The same effect occurs with smartcards.
The one who complained about that (not some noob but a CS student) considers this confusing. I never had this problem myself but I agree that this doesn't make sense.
Thus I suggest the small change of being consistent over the different ways of key display.

@_date: 2014-03-13 15:31:06
@_author: Hauke Laging 
@_subject: Multiple Subkey Pairs 
Am Do 13.03.2014, 11:44:08 schrieb Martin Behrendt:
This is not possible in a useful sense and furthermore it doesn't make much either (in today's technical situation; this could change).
The main problem is that (in a kind of normal scenario) you don't control which keys other people use for encrypting data to you.
Similarly bad is the point that you make keys which are of quite different quality look equal. That is the opposite of what we need.
In theory this transparency could be achieved within a certificate by marking subkeys differently (signature notations) but today you should use separate certificates at any rate.
gpg --recipient 0xD4BC64B8\! --recipient 0x7CDBED88\! Not explicitly. There is no --encrypt-to-all-subkeys option.
I guess that would be quite complicated. I am not even aware of such a feature in the mail clients on the certificate level.
Unfortunately my proposal for conditional blocks in gpg.conf was declined... That would allow for such a feature:
"If it is an encryption operation to 0x12345678; then
encrypt-to 0xD4BC64B8\!
encrypt-to 0x7CDBED88\! Good luck...
We need transparency of the security level of keys (not just in (German only, sorry)

@_date: 2014-03-13 23:38:00
@_author: Hauke Laging 
@_subject: Multiple Subkey Pairs 
Am Do 13.03.2014, 22:17:08 schrieb MFPA:
That has nothing to do with GnuPG it is for the Shell.
man bash:
"History expansions are introduced by the appearance of the history expansion character, which is ! by default. Only backslash (\) and single quotes can quote the history expansion character."
"Several characters inhibit history expansion if found immediately following the history expansion character, even if it is unquoted: space,  tab,  newline, carriage return, and =.  If the extglob shell option is enabled, ( will also inhibit expansion."
Thus the \ is not necessary in this case. But because I often forget which characters inhibit history expansion I got used to always escape If history expansion is active in your shell (bash: "echo $-" contains "H") compare
gpg --recipient 0xD4BC64B8\!
gpg --recipient "0xD4BC64B8!"

@_date: 2014-03-16 18:41:38
@_author: Hauke Laging 
@_subject: problem encrypting with someone else's key 
Am So 16.03.2014, 15:48:18 schrieb Charles Spitzer:
It is difficult to debug this if you don't tell us how exactly you did this encryption. Did you encrypt on the command line?
Run this for the encrypted file:
gpg --list-only --list-packets tmp.txt.gpg
You should get output like this:
:pubkey enc packet: version 3, algo 1, keyid 764311F281F06169
        data: [2045 bits]
:encrypted data packet:
        length: 1703
        mdc_method: 2
If it looks like this, run
gpg --list-keys 764311F281F06169
Is that the key of the recipient?
You may have made a public signature for the key which, of course, was not part of the certificate you imported. Or the import file contains signatures gpg ignores when importing (or at least when exporting): Useless and old signatures (replaced by newer ones) may be ignored.
The same way:
gpg --list-packets import_file
gpg --list-packets export_file
May help to know the exact error message they get.
They may get a better error message if they try to decrypt in the gpg -vvv your_file.gpg

@_date: 2014-03-17 02:29:28
@_author: Hauke Laging 
@_subject: problem encrypting with someone else's key 
Am So 16.03.2014, 23:21:45 schrieb Charles Spitzer:
They are never the same because of the session key which is unique for each encryption operation. Furthermore the compression configuration may be different. I am not familiar enough with RSA padding; maybe length differences can result from that, too.

@_date: 2014-03-17 05:28:28
@_author: Hauke Laging 
@_subject: locale bug in 1.4 
I may have found a locale bug in 1.4.12. I am aware that this is not the current version but I cannot easily install 1.4.16 now. 1.4.12 is the version in Knoppix 7.2.
I have problems with non-ASCII characters when I use batch mode. The funny part is that this problem does not appear when I generate a mainkey (from a batch config file). It appears when I add UIDs later:
echo adduid$'\n'"$name"$'\n'"${email}"$'\n'"${comment}"$'\n'save$'\n' |   LC_ALL= LANGUAGE=en gpg --batch --passphrase foo \
  --command-fd 0 --edit-key Hauke
The man page says about --display-charset:
"If this option is not used, the default character set is determined from the current locale."
What you would expect.
locale looks like this:
gpg --expert --gen-key
leads to a message:
"You are using the `utf-8` character set."
The batch pipeline leads to:
"You are using the `iso-8859-1` character set."
Which IMHO pretty well explains the umlaut problems. But it doesn't make sense to me. Why does GnuPG guess it's not UTF-8 any more just because of the pipeline? Adding --display-charset utf-8 solves the problem. It does not occur with 2.0.22 (and some versions before).
BTW: Unfortunately I have no clue about internationalization. Is it correct that LANG and all the LC_ variables have content of this kind LANG=de_DE.UTF-8 but that LANGUAGE has neither the _ part nor a character encoding?

@_date: 2014-03-23 17:37:21
@_author: Hauke Laging 
@_subject: How to create GNUPGHOME 
Am So 23.03.2014, 15:21:05 schrieb wish at dumain.com:
export GNUPGHOME=/foo/bar
mkdir --mode=700 -p "$GNUPGHOME"
gpg --list-keys
unset GNUPGHOME
mkdir --mode=700 -p /foo/bar
GNUPGHOME=/foo/bar gpg --list-keys

@_date: 2014-05-02 03:45:30
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Fr 25.04.2014, 11:20:08 schrieb Peter Lebbing:
Of course, it does:
start cmd:> LANG=en gpg --edit-key 0x1a571df5 quit
pub  4096R/0x1A571DF5  created: 2012-11-04  usage: SCE                        trust: ultimate      validity: ultimate
This is a statement about the key, not about some UID.
start cmd:> gpg --with-colons --list-keys 0x1a571df5
2. Field:  A letter describing the calculated validity.
The key itself must have such a state for the simple reason that you can select an encryption key via the UID but you (usually) cannot know "which UID" has made a signature. You just know the (sub)key. The WoT is calculated over key validities not over UID validities.

@_date: 2014-05-02 04:02:30
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Fr 25.04.2014, 12:47:46 schrieb Daniel Kahn Gillmor:
That is not a crypto-related argument. I would never suggest to build key management software in a way that forces people to reveal this information. But I strongly argue against making the decision for the users what information they may offer and which not.
I am not a privacy expert but I assume that for most of the Internet users it is not difficult to find out who their family members or their close friends are. If this information is available anyway then it makes little sense to "protect" this information in the OpenPGP area.
I am convinced that future crypto software will have to attribute both security and authenticity assessments with keys. Currently most users are just playing crypto (or rather: playing IT security; crypto is not the weak part of it; its organizational handling is). There will be limits similar to --min-cert-level which restrict the accepting of signatures (for certain security levels).
Let's not try to protect the users against themselves even in non-
technical contexts. Your opinion about leaking social information is not better that that of somebody who likes to leak it. The result should not be you making that impossible for him but quite simple: He leaks, you

@_date: 2014-05-02 04:23:25
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Fr 25.04.2014, 12:58:03 schrieb Daniel Kahn Gillmor:
I completely disagree with that article. And I consider your statement
?I don't think there is a satisfactory answer to the question "how will specifying the level of identity certification concretely benefit anyone REALLY strange. It is hard for me to believe that someone at your level of crypto understanding is serious about that.
You claim
?So there is no functional gain in declaring the difference between a "normal" certification and a "positive" one?
and ? if I understand you correctly ? the only argument for that is the current behaviour of GnuPG. The correct view is that the current GnuPG behaviour (i.e. not offering the possibility to ignore level-0 sigs) is a serious problem, really limiting the use of WoT calculation. Are you really going to tell me that a generic certification was more valuable than a persona certicifation though the first contains the second? I hope not. 90% of the current WoT is just the illusion of security.
I once wrote an email to somebody who had written a terribly wrong article about OpenPGP on his web site. He answered me, thanked me for  "I have signed your key and attached it. Perhaps you want to sign mine, too."
That's what the majority of level-0 signatures means: "I have no idea what I am doing here."
That is exactly what happens. And thus I like the term.
The context is the respective keyring. Who "owns" it and for what My opinion as a non-native speaker is less relevant in this case but I feel like you seem to indicate: That "acceptable" easily leads to the question "Why? By which standards?". "Accepted" seems to avoid that by "You have (not yet) accepted it. You must know why (not)". To me "accepted" seems more personal, "acceptable" more general. But that may just be a lose language feeling.

@_date: 2014-05-02 04:30:40
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Fr 25.04.2014, 18:43:53 schrieb Bernard Tyers:
That doesn't make sense before the users have understood the problem.
Crypto is becoming a more important subject (OK, that wasn't so difficult) at universities. At least in Germany. Not in the sense that they did what I feel they are ("morally") obliged to ? making sure that most of their (at least math, CS and engineering) students learn it ? but more professors seem to consider that something important now.
Thus I guess it should be rather easy to throw some theses (rather not in CS, though) at this question.
I know a German professor teaching in Belgium who has already offered a kind of "Why don't the students attend to or organize Cryptoparties?"

@_date: 2014-05-02 04:38:17
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Sa 26.04.2014, 13:43:32 schrieb MFPA:
This may be a language problem (on my side) but in my understanding you do exactly that: You accept a key for usage. Whether you verify it before is your decision. And thus I prefer "accept" over "authenticate" because "authentication" is an opinion (not only in the quality you do that but also in whether you do it at all or not) but "accepting" is a simple fact. Facts are easier to handle than opinions.
As more than one year has not been enough for me to write a certification policy for my new key all my certifications are local ones. I hope you don't misunderstand the feature: Local signature is not meant as "rather useless signature" but just as "not for the public".
I have local certifications at cerification level 1 (your case) and 3.

@_date: 2014-05-02 05:49:16
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Do 01.05.2014, 23:34:30 schrieb Daniel Kahn Gillmor:
This is a clear mix up of cause and effect.
You don't discuss a new technical solution but you point at the rather trivial (because always given; otherwise no change would be necessary) fact that the *current* technical solution limits the use of this information. From that you conclude that no change is necessary. To me that is quite the opposite of your own demand.

@_date: 2014-05-02 07:35:10
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Do 01.05.2014, 23:48:08 schrieb Daniel Kahn Gillmor:
That is correct. But there are two groups of decisions:
a) how to do it
b) whether it can be done at all or not
That may be true but there is a level of complexity below which the infrastructure (of a complex problem) becomes useless. That is about the current state of the WoT.
Crypto is about protecting information. The level of required protection depends on the (kind of) information. In order to decide whether a key is suitable to protect a certain data you mandatorily need certain information about the key. Most of which cannot be taken from the certificate. That is not an opinion but a simple but broadly ignored fact. Ignored in order to protect the users from too much complexity...
That is correct. But there is a difference between "supports" and Disagreements are not a problem per se. It's perfectly OK to disagree on the recommendation whether to publish such information or not. And it is OK to debate how to present (or hide) this information to the user (e.g. via ??expert in gpg or "expert settings" in some GUIs).
That is a noble intention and I don't doubt it. But if ensuring turns into disabling then a line is crossed.
In my courses I tell the crypto newbies to forget the WoT. Not forever but until they have a firm understanding of the technology. That is a useful way. Crippling the technology isn't.
That would probably be a good idea if there is only one road. In contrast to rather expensive mountain roads we can build a second road more or less for free. I guess there wouldn't be a concensus that the better road should not be built just because some unqualified driver might use it though he has been told not to do so. If somebody deliberately endangers himself ? so be it. That possibility is no reason to prevent those users with a brain from improving their situation.
I repeat myself:
Crypto is about protecting information. The level of required protection depends on the (kind of) information. In order to decide whether a key is suitable to protect a certain data you mandatorily need certain information about the key. Most of which cannot be taken from the certificate. That is not an opinion but a simple but broadly ignored fact. Ignored in order to protect the users from too much complexity...
"help users use these tools" not in the sense of "making the current use easier" but in the sense of "using the tools for applications which are today not (or hardly) possible".
Added complexity would not even affect unqualified users (if well

@_date: 2014-05-03 23:47:22
@_author: Hauke Laging 
@_subject: UI terminology for calculated validities 
Am Sa 03.05.2014, 22:33:14 schrieb MFPA:
Then let's extend your knowlege: --min-cert-level
It's even explained in dkg's article which you point to.

@_date: 2014-05-05 07:05:51
@_author: Hauke Laging 
@_subject: improving validity calculation: external program 
from time to time when changes to GnuPG's behaviour (about validity and trust) are suggested, Werner responds kind of: "No, that should be done on top of GnuPG." This attitude makes sense but in the current situation I would ask: How? How shall that be done on top of GnuPG without causing a huge mess of adaption need in the higher layer applications?
Thus I would like to suggest that ? similar to gpg-agent's option "pinentry-program" ? an option is added which disables gpg's internal handling of --check-trustdb / --update-trustdb and has the configured external program be called for that. This would more or less be a modified version of --import-ownertrust.
This way it would become easy to test and offer other validity calculation strategies. Simple cases:
a) The WoT could be easily disabled for newbies by configuring a validity calculator which ignores it.
b) Ignore level 0 certifications.
Less simple case:
a) The calculator could be configured to treat different keys as one (because the owner is the same); we recently discussed this need.
I don't want to distract you from the general idea by offering complicated suggestions which will never even come close to concensus... A nice extension would be to define an output format (or database format for gpg to read the data from) so that
a) this calculator can show for each certification if and how much it contributes to the validity of another key (or: UID); IIRC this is currently not possible
b) levels for security and authenticity could be added. Today we have "valid" and "invalid". But the real world is not a dichotomy: Different kinds of information have different requirements for both security and authenticity (or the combination of both). We must map this spectrum to key selection somehow (or at least create the possibility for others to easily do so).

@_date: 2014-05-14 09:55:19
@_author: Hauke Laging 
@_subject: encryption information in a signature 
I would like to suggest a probably easier alternative to my proposal "sign encrypted emails":
The purpose is that the recipient can be sure that the message has left the sending system encrypted (and: encrypted for a certain key) ? as it is easily possible for a MitM to encrypt an unencrypted message without being noticed, deluding the recipient about the confidentiality of the Nearly the same effect as that by my former suggestion may be reached by defining a notation which says: "This message is sent encrypted only. It will be encrypted for this key / these keys: ..." There is no reason not to trust the sending system about that.

@_date: 2014-11-05 00:20:52
@_author: Hauke Laging 
@_subject: Error on GPG file encryption 
Am Di 04.11.2014, 15:14:55 schrieb Kanchan Gobari:
Then you should have subscribed to the list before writing. Would have saved you 12 hours...
What is the command line in the script causing the error?
What is the output of the following command?
ls -l /dev/tty

@_date: 2014-11-06 14:16:07
@_author: Hauke Laging 
@_subject: problem with the archive for gnupg-announce 
on there is a link to the archive
but that does not work; it's a strange redirect to

@_date: 2014-11-09 01:57:58
@_author: Hauke Laging 
@_subject: some -- are broken in the HTML FAQ 
there is a common problem (usually with CMS) in the FAQ:
There are three ocurrances of  "?"; all of them are destroyed "--"s. They are correct in the plain text version.
Actually Google pointed me to the outdated version (which has the same problem on a higher level):
Is there any reason for keeping this document online instead of making a redirection to the new one?
And one remark to the content:
  Using these two principles (the [Landauer bound] and the
  [Margolus?Levitin limit]), we can determine quite accurately how much
  heat would be released by a computer that brute-forced a 128-bit
  cipher.  The results are profoundly silly: it?s enough to boil the
  oceans and leave the planet as a charred, smoking ruin.
IIRC this would happen only if this operation was done in a certain, short amount of time so I guess this restriction is missing in the text.

@_date: 2014-11-09 03:03:33
@_author: Hauke Laging 
@_subject: some -- are broken in the HTML FAQ 
Am Sa 08.11.2014, 20:49:24 schrieb Robert J. Hansen:
It is correct if an em dash is meant. It does make absolutely no sense to use a "?" when code is involved where only "--" works. This is about
?? BEGIN
instead of
instead of
No, it doesn't. In 47 of 49 cases it uses "--". I did not want to suggest to replace the dash in "Margolus?Levitin".

@_date: 2014-11-13 23:42:01
@_author: Hauke Laging 
@_subject: Help needed 
Am Do 13.11.2014, 22:33:31 schrieb david at gbenet.com:
It is unclear to me what exactly you are talking about.
The terms "export" and "import" usually refer to the commands
gpg --export[...]
gpg --import
But it also sounds like you have copied the whole directory ~/.gnupg/
If you have copied the directory then maybe the file permissions have not been preserved. Check whether secring.gpg has 600. And delete the file random_seed.
If you have exported and imported instead then you are missing the trust database. You should either copy trustdb.gpg or export and import this data, too:
gpg --export-ownertrust
gpg --import-ownertrust

@_date: 2014-11-21 22:52:46
@_author: Hauke Laging 
@_subject: correct usage of gpg param 'throw-keyid(s)' ? 
Am Fr 21.11.2014, 12:16:39 schrieb grantksupport at operamail.com:
And what do you consider the conflict?

@_date: 2014-11-21 23:19:14
@_author: Hauke Laging 
@_subject: correct usage of gpg param 'throw-keyid(s)' ? 
Am Fr 21.11.2014, 13:58:19 schrieb grantksupport at operamail.com:
That's just a typo. The correct name for the option is "throw-keyids". You do not have to write the complete name. It is enough to have so many chars that the option or command is unambiguous.

@_date: 2014-11-22 16:01:02
@_author: Hauke Laging 
@_subject: Update existing key to ECC? 
Am Fr 21.11.2014, 20:17:38 schrieb Patrick Schleizer:
You can change the subkeys (encryption, signing) easily but not the mainkey (the one the fingerprint refers to). But hardly any GnuPG out there can use ECC now.

@_date: 2014-10-03 07:40:10
@_author: Hauke Laging 
@_subject: WARNING: This key is not certified with a trusted signature! 
Am Do 02.10.2014, 22:38:56 schrieb Chris:
If you have not restored the whole GnuPG directory (~/.gnupg under Linux) but imported the keys only then the problem is that your keys have lost their absolute trust.
You can restore that with gpg --trusted-key 0xE372A7DA98E6705C --list-keys 0x98E6705C
gpg --edit-key 0x98E6705C trust

@_date: 2014-10-07 02:01:37
@_author: Hauke Laging 
@_subject: OpenPGP understanding test (German) 
a few days ago at a Cryptoparty I noticed that it is not only important to teach people. Determining how much they have understood is important, too. After all, the overall security you get from real world crypto is technical in nature only in a minority share. More important is that you know what you are doing.
Thus there should be online tests which allow people on different levels of knowlege (beginners, experienced users) to find out how much they have really understood.
As I am not aware of something like that I did it myself:
The first version is for beginners and in German only. Translating that should not be too much work thus I will probably make an English version myself (if noone else does before me). But maybe someone here likes the idea and does something like that for another language (if so then I would like to be noticed so that I can set a link to the other The Germans here may find it useful if they teach others how to use OpenPGP. I am interested in the experiences you gain with it (for improving the test).

@_date: 2014-10-13 00:35:20
@_author: Hauke Laging 
@_subject: Renewal of revocation certificate required after adding a new 
Am So 12.10.2014, 23:35:16 schrieb Dr. Peter Voigt:
To the fingerprint (or: the key data itself).
0x1F: Signature directly on a key
       This signature is calculated directly on a key.  It binds the
       information in the Signature subpackets to the key, and is
       appropriate to be used for subpackets that provide information
       about the key, such as the Revocation Key subpacket. [...]
BTW: You can test this. You don't kill the key / certificate as long as you do not upload the revocation certificate to the keyservers. Just make a backup of the public and the private keys (maybe not even necessary but may be easier).
As long as you import the rev cert just locally you can delete it. Or delete (and restore from backup) the whole key if the rev sig cannot be deleted alone.
Something else, doesn't have anything to do with your question but may be of interest as you work at a university:

@_date: 2014-10-13 05:53:10
@_author: Hauke Laging 
@_subject: OpenPGP understanding test (now in English) 
Am Di 07.10.2014, 02:01:37 schrieb Hauke Laging:
And there it is:
I hope many of you find that useful (for new users, not for yourselves).

@_date: 2014-10-19 00:56:09
@_author: Hauke Laging 
@_subject: new helper program for configuration import / export 
I am often asked whether (and how) it is possible to use OpenPGP on several systems with the same keys. You are probably aware that this is also asked here, not often but regularly. And then the "copy everything except random_seed" fun begins again.
I just noticed how strange it is that there is no function for an easy export (and import) of the whole configuration (including the key rings). Strange because this is on the one hand vital as it is not just for configuration and key synchronization but the same for backup and on the other hand contains risks (random_seed; having secring.gpg with rather weak passphrases on a cleartext backup volume). And is so extremely easy to solve.
Thus I would like to emphaticly suggest rather not to extend gpg but to add a very small helper program to the GnuPG suite. There is already gpg-zip. It may be enough to write a wrapper around that. The result shall be a program with only two commands:
a) save the complete configuration (optionally protexted with a passphrase) to a single file
gpg-backup --with-passphrase --save /path/to/targetfile
b) restore the complete configuration from a single file (with the option to overwrite or import)
gpg-backup --overwrite --restore /path/to/sourcefile
This could be easily added to the GUIs as they would just need a new menu entry and a file dialog. Doesn't makse sense that they invent their own backup / sync features.
I could do this myself ? but as a script only (which would not be portable). But if it helps then I would write that so that there is something to lookt at what the result would look like and play with.

@_date: 2014-10-19 03:39:05
@_author: Hauke Laging 
@_subject: new helper program for configuration import / export 
Am Sa 18.10.2014, 21:08:30 schrieb Robert J. Hansen:
I am aware of that. The first point is that I am much more familiar with bash than with Python (but I would get that done). The more important point is that I guess that GnuPG currently has no dependency to Python and that this probably shall not be changed. I.e. this would not work under Windows. Is it possible to compile Windows binaries from Python code (something like a Python to C converter)?
But most probably someone would volunteer to port that to C I assume.

@_date: 2014-10-19 15:32:36
@_author: Hauke Laging 
@_subject: new helper program for configuration import / export 
Am So 19.10.2014, 13:26:55 schrieb Peter Lebbing:
I am quite sure that this is the opposite of easier. Why?
a) Because you have to change the passphrase of each secret key.
b) Because you have to change them back after exporting.
c) Because "make sure" is generally a bad idea for a certain group of users ? at which this tool is targeted.
See (c)...
I was rather thinking of a whitelist (excluding e.g. editor backup I must admit that I didn't know that. I hardly use 1.4.x.
What does that mean? Can 1.4.x and 2.0.x not operate on the same secret key ring? Is it converted automatically (in which direction)? I guess this problem does not affect exporting secret keys.
Maybe you have a pointer for this problem.

@_date: 2014-10-19 22:08:01
@_author: Hauke Laging 
@_subject: new helper program for configuration import / export 
Am So 19.10.2014, 21:10:20 schrieb Peter Lebbing:
A good passphrase doesn't help against online attacks. The usual protection against offline attacks is volume encryption. Thus a strong passphrase (and who wants to enter that often?) is useful for those people without volume encryption only. But my experience is that many people do not use a good passphrase even without volume encryption. We have to accept that. But it seems to me to make sense to suggest a better passphrase at least for key files which are send via email or stored on USB sticks.
No. Why should that be better / easier than encrypting the whole archive? Especially as there may be other information in ~/.gnupg which you don't want to become public.
1) Select the files.
2) Create the archive.
3) Encrypt the archive. (I just realize that gpg-zip does not encrypt the whole archive)

@_date: 2014-10-25 20:09:13
@_author: Hauke Laging 
@_subject: auto refresh for expired certificates 
I would like to suggest a new option for GnuPG (mainly intended for the config file) which would automatically try to import an update for the certificate if it has expired (both from the standard key server and from the preferred one if set).
I guess that many users don't understand that in case of certificate expiration it is often the solution to just refresh the certificate. This feature would avoid problems for these users (and encourage the use of expiration dates which IMHO is useful). Of course, this could be done in the GUIs but this seems to be a trivial extension and would avoid having to wait for all GUIs to care. And it's not on "high GUI level" but relevant for console usage, too.
In the long term each certificate should get a timestamp entry in trustdb for the last update check. With that a new option could be defined which causes gpg to check for updates of a certain certificate if it is to be used and has not been checked for updates for more than x days. Refresh discipline seems to me to be a serious problem. And just checking the whole key ring every x days would be a waste of resources (especially on the key servers).

@_date: 2014-10-26 12:56:05
@_author: Hauke Laging 
@_subject: auto refresh for expired certificates 
Am So 26.10.2014, 08:19:28 schrieb NdK:
I do admit that this may be interesting for certain people but I guess that this tool does not do "that" but solves a completely different problem.

@_date: 2014-10-26 15:28:30
@_author: Hauke Laging 
@_subject: auto refresh for expired certificates 
Am So 26.10.2014, 14:14:25 schrieb Peter Lebbing:
And who is "you"?  8-)
THEY do know anyway that you (really you in this case) encrypt to a certain key as long as SMTP is used (as usual) and the target key ID is not hidden (as usual, too).

@_date: 2014-10-26 16:19:03
@_author: Hauke Laging 
@_subject: auto refresh for expired certificates 
Am So 26.10.2014, 16:12:15 schrieb Peter Lebbing:
Kind of important for your argument.
The statement "that you are about to encrypt to that key" does not make much sense if (like in this case) the "you" is a Tor connection.
Unless you meant (what I doubt) that the problem was to know that a certain recipient will get an encrypted message (from an unknown

@_date: 2014-10-28 19:06:08
@_author: Hauke Laging 
@_subject: Terminal asks for passphrase even when passphrase is cached by 
Am Di 28.10.2014, 22:06:36 schrieb Sudhir Khanger:
You probably mean that Kgpg asks just once. KMail isn't capable of creating symmetrically encrypted mails thus I don't know what you mean I have created a wishlist entry to change that:
That is not possible AFAIK because a passphrase used in symmetric encryption is not a passphrase in the usual gpg-agent sense. gpg-agent is used for asking those just because it's already there.
You can call gpg in batch mode (which probably is what Kgpg does):
gpg --batch --passphrase foo --symmetric file.txt
Note that this way everyone on the system can see the passphrase in the argument list. You may use something like
echo -n foo | gpg --batch --passphrase-fd 0 --symmetric file.txt
instead (where echo is a shell builtin or something else that does not show its arguments in the process list).

@_date: 2014-10-31 00:33:13
@_author: Hauke Laging 
@_subject: Is gpg-agent passphrase status query possible? 
Am Do 30.10.2014, 23:14:12 schrieb Cpp:
Yes and no.
There is an easy way to find out whether a certain passphrase (make sure to distinguish between mainkey and subkeys!) is currently known to gpg-
: gpg-connect-agent "GET_PASSPHRASE --data --no-ask 4F7E9F723D197D667842AE115F048E6F0E4B4494 t1 t2 t3" /bye
D fubar
But that doesn't tell you for how long gpg-agent will cache it yet. It may be that the passphrase has just been deleted from the cache even if you use the key immediately afterwards.
If you know for sure for how long the entries are cached then you may write a small "daemon" which checks for the passphrases every few seconds. Then it knows with reasonable precision when a passphrase was added to the cache and can calculate when it will be dropped.

@_date: 2014-09-10 14:36:24
@_author: Hauke Laging 
@_subject: ssh-add -l like command in gpg 
Am Mi 10.09.2014, 13:20:01 schrieb Sudhir Khanger:
I am working on a Python script which does that as preparation for its main task. You could probably easily adapt it to your needs. Of course, it does not (cannot) solve the race condition Werner mentioned).
The general approach is to read the fingerprints of all available secret mainkeys and subkeys
gpg --with-colons --fingerprint --fingerprint --list-secret-keys
and check for each entry whether gpg-agent knows the fingerprint:
gpg-connect-agent "GET_PASSPHRASE --data --no-ask "\
"4F7E9F723D197D667842AE115F048E6F0E4B4494 t1 t2 t3" /bye

@_date: 2014-09-10 15:47:11
@_author: Hauke Laging 
@_subject: ssh-add -l like command in gpg 
Am Mi 10.09.2014, 15:35:46 schrieb Werner Koch:
Not at all or just not this way?
I think there really should be a way for syncing the passphrase cache within a certificate. If that is not possible externally then gpg/gpg-
agent should provide an internal solution.
Users don't understand why they have to enter the same passphrase twice. And indeed it doesn't make sense that they have to.

@_date: 2014-09-13 15:19:36
@_author: Hauke Laging 
@_subject: Automated Batch Subkey Creation 
Am Sa 13.09.2014, 16:53:09 schrieb Sam M:
Try this (shell code, bash):
echo addkey$'\n'8$'\n'e$'\n'q$'\n'${subkeylength}$'\n'"$expire_period"\
$'\n'save$'\n' | LC_ALL= LANGUAGE=en gpg --expert --batch --display-charset utf-8 \
--passphrase "$PASSPHRASE" --command-fd 0 --edit-key $short_id
Adapt the input after "8" to the capability flags you need.
I use that in my (German) script for creating offline mainkeys:

@_date: 2014-09-13 16:38:23
@_author: Hauke Laging 
@_subject: Automated Batch Subkey Creation 
Am Sa 13.09.2014, 16:20:42 schrieb Werner Koch:
Since more or less the first version of the script there is this line:
# TODO:
#       - status-fd/command-fd driver handler (statt echo That's not the point here. The question is: Is adding subkeys in batch mode regular business?
I have pointed askers here once or twice to my script. How many may be out there if it's asked once every six months? I have no idea.
This is not about subkeys only. Maybe the former questions referred to UIDs. It might be easier and a suitable solution to either provide a script with GnuPG which does that (both for subkeys and for UIDs) or put some example code in the man page (like there is already shell code in the gpg-agent man page) or the DETAILS file.
If you have not written such a script yet: I have to do that anyway.

@_date: 2014-09-15 03:05:18
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
after filing a bug report for my mail client because it does not allow me to encrypt to an expired certificate (neither does Enigmail) I was surprised to notice that I didn't manage to encrypt to an expired certificate with gpg in the console (2.0.22).
Is this not possible (what about gpgme?) or am I just not aware of how to get that done?
I would consider not being able to encrypt to an expired key a severe security flaw because it may force the sender to send the message unencrypted. It is OK to warn the user but it must be possible to override this warning. Expiration is not a security problem (let alone a severe one).
It does not even work with --encrypt-to. And the man page says about this command:
"No trust checking is performed for these user ids and even disabled keys can be used."
Non-valid keys are OK, disabled keys are OK but the least severe case expiration is not OK?

@_date: 2014-09-15 14:10:32
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Mo 15.09.2014, 09:48:47 schrieb Nicholas Cole:
This is not about opportunistic encryption (which I do not use BTW). It is about being capable at all to encrypt in a certain situation.
[quote order changed]
Do you think these two statements are consistent?
I don't object to "a key should not be used", BTW. I object to "a key must not be used" / "a key cannot be used". Those are very strong assumptions which are hardly ever justified.
In particular this is not a decision for a low level tool like GnuPG. A low level tool (usually directly used by experts) shall give the GUIs the information they need (in this case: the key is invalid because it is expired) and let them decide what to do.
There is a whole section
"Doing things one usually doesn't want to do."
in gpg's man page...
How is that possible without anything encrypted to this key before the expiration date becoming insecure, too? If a key has become insecure then it is to be revoked.
I agree with that. I just disagree with translating "respect" to "not allow any override at all" (for this problem only, allowing overrides for all other kinds of worse problems...).
I don't think that any UI (I know) encourages people to do that. Allowing (after a warning and confirmation) is not encouraging.
I agree. But expiration does not necessarily mean "don't use at all". Expiration is not the same as revocation. This is not affected by the fact that revocation may be impossible (private key lost and The RfC is quite clear about revocations. It is not about expirations.
Expiration is a good feature. Handling expired keys in this way discourages using expiration dates, though.

@_date: 2014-09-15 16:03:02
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Mo 15.09.2014, 15:12:31 schrieb Martin Behrendt:
"Secure communication with noobs is impossible. Period." (or similar)
I have quoted this (offline) quite often. If you are communicating in a hostile environment then you must know a lot about email security and you must restrict your communication to people of this kind. It at least improbable that capable users under this circumstances have not etablished rules which cover this case. As security is more important than availablility someone it that situation would make sure that he can revoke the certificate (or that someone else can). And, of course, as the expiration date will not happen to match the compromise date he would tell his contacts about the problem and not just hope they will not feel like sending something before... You could try to create an even stranger scenario in which this is not possible but that would not affect the points that rules have been made and that such people would act very conservative (i.e. they need not be forced to) but another quote comes to my mind:
Rob has pointed out several times recently that "PGP" means PRETTY GOOD privacy not PERFECT privacy. It is OK that GnuPG is usable for quite high levels but those "1 in 1,000" cases can obviously not (and are not) the base for default settings ? and impossibility is much harder than a default setting.
Of course, the sender can know that. In most cases he doesn't, though. But he can make a much better guess than we.
Do you think it is not safe enough to warn the user? Does this have to be enforeced because of whatever? Only this protection but nothing else? Shall the software tell the user "In all other cases you know better than me but in this one I know better than you"?

@_date: 2014-09-15 18:13:22
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Mo 15.09.2014, 14:33:55 schrieb Nicholas Cole:
I doubt that this is the common interpretation of this feature.
One of the effects of expiration is that you can recognize (non-
compromised) dead keys. That is already easily possible: You can delete the revocation signature. That's it.
There are even cases in which I would consider that. If a revocation signature says that the key has been replaced then there is no reason to consider it unsafe. If I cannot verify the new key then it might be a good idea to use the revoked one.
However, that is not the point. As a revocation is a MUCH stronger statement than an expiration (key revocations are hardly superseded but it is normal that the key validity period is extended) you cannot reasonably argue that the same behaviour should be applied to both.
But the general rule applies here, too: A low level tool has to tell the user or higher level application what they need to know and has to let THEM decide how to react. A low level tool should provide every action that is possible. Not in the meaning that every possible action should be implemented but in that that nothing is absolutely prevented.
OK, reality check. The reason for this thread is that a friend has sent an encrypted email to me yesterday. I could not reply to that because his certificate has expired (two weeks ago, one year after creation, because I set this expiration date).
I have created his certificate. That is an offline mainkey and he is probably not capable (or willing) to extend the validity period. He is not going to replace the key. It is not considered compromised. We(?) even talked on the phone today.
It is far from a serious assessment of the situation to claim that the key owner want me not to use this key any more. And this situation is far less strange than the other ones offered in this thread.
If you set an expiration date (no matter whether with GnuPG or the well-
known GUIs) then the software does not tell you that senders were not allowed / not capable to use this key after that date. It says something about "How long shall it be valid?".

@_date: 2014-09-15 21:06:17
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Mo 15.09.2014, 09:47:21 schrieb David Shaw:
Where do you take that from? Neither the RfC uses this description nor GnuPG nor any GUI I know. It is OK (not meaning: being safe from getting criticized by the key owner for sending clear text instead) if you treat the expiration date this way. But it is absolutely not OK to enforce this really not obvious interpretation on others.
No. As nearly everything in the OpenPGP environment the definition of this statement is much too vague to justify this assessment.
Even if you get a contrary statement in person ("No problem, I just forgot to extend the validity period in time, use this key") you CANNOT do that. This behaviour makes using offline mainkeys (which should be strongly encouraged) more difficult.
a) It seems that nobody wants it disregarded. Regarding this information means: Tell the user about it. Narrowing "regard" to "prevent" is the second non-obvious interpretation.
b) As I have explained above there is no reason to assume that the average user understands "expire" the way you do. Indeed, he gave a "date", not a prohibition.
c) Because "we" disregard it everywhere else. GnuPG (and other very important parts of the OpenPGP environment) does not care about the key owner's statements in any other point in this absolute way.
"In general, you do not want to use this option as it allows you to violate the OpenPGP standard." Quote from the man page.
All made to override a key owner's statements (clearly RfC-backed statements in these cases). And, of course, the keyserver no-modify flag. Not GnuPG's fault, of course.
In other words: OpenPGP users are used to their statements being (easily) ignored.
d) It does not make any sense to "forbid" someone the use of a key if you cannot forbid him to send the information without any encryption instead. But it often makes sense to use an expired key for encryption. It does not make sense to assume that a key owner would prefer a clear text message over one encrypted for an expired key. It is a strange decision (to say it politely) to enforce a non-obvious interpretation which has a clear alternative (revocation) and does not make sense.
e) Today those users who want to make a strong statement can do that: They can revoke their certificate. They cannot do that in advance but that is not a problem (I would support future revocations in the next OpenPGP version though). In your interpretation those who just want to give a hint cannot do that. There are two distinct features. Why should they not be treated differently though they are obviously used differently and understood differently?
f) There is no change in security by reaching the expiration date. If there was one then nobody should encrypt information to a key if he wants this information to be secure after the expiration date, too. This is a pure formality which makes more sense with signatures than with encryption. Formality does not have priority over security.
g) I can show real-world damage. Can you show (similar) real-world advantage? (I.e. not just some unclear formality.)
The probably greatest point about OpenPGP is that it is so flexible. You can use it on the one side with users who hardly understand what they are doing using opportunistic encryption and on the other side you can use it for highly secure communication. The difference is about how to use GnuPG (and, as Rob just explained, policy which is not GnuPG's business). Due to this flexibility OpenPGP usually does not prevent users from doing stupid and dangerous things. If it does so in just one point and this point is even harder to justify than many things which are not done then this is a bug. You cannot explain the behaviour of GnuPG with a single rule. You need an exception for this case. And that is taste not logic.

@_date: 2014-09-15 23:01:12
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Mo 15.09.2014, 13:19:10 schrieb Robert J. Hansen:
Did you really mean that? I am not aware of any way how to do that within GnuPG (i.e. without faking the time which would affect a signature). This thread started with my question whether that was possible and except for this remark by you nobody has even indicated that it could be done.

@_date: 2014-09-16 00:59:55
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Mo 15.09.2014, 15:02:14 schrieb Doug Barton:
a) What period do you choose for that? A day, a week, a month, a year?
b) What prevents this hostile entity from extending the validity period?
You are under the control of a hostile entity but you are safe? Lucky What would happen in real life?
Someone in such a situation (personal safety at risk) would establish a policy for key usage with those contacts who send information to him of which the disclosure might cause severe problems.
In other words: Even if GnuPG allowed them to use expired keys (if expiration was considered a security means under this policy) they would not consider using them.
Und the other hand: Everyone who relies on expiration disabling being enforced (and seriously: Who does? Who even knew before this thread what the exact behaviour of GnuPG is? Not even I did. And I a quite sure that information which not even I have about GnuPG cannot be the base for an expectation motivated rule.) is dangerously stupid.
That does not seem like an argument to me for telling the user what is best for him.

@_date: 2014-09-16 01:33:23
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Mo 15.09.2014, 15:56:04 schrieb Robert J. Hansen:
It is quite similar to the certificate case. It is (if exceeded) a warning to the user: "Think well before you use it. Don't blame me if you do." And not "I will be really upset if you use it!".
For the milk we get here I guess most people would not consider it a problem if it has exceeded its expiration date by one or two days. For other food even weeks or months may not seem dangerous. But you can still access the milk without having to break additional locks.
The big difference between food and keys is that you know that food becomes bad. You do not exactly know when. The milk producer cannot make the milk in your fridge good milk by printing a later date on it. For keys this is common.
On the other hand I would handle certificates differently if one has expired two weeks ago and the other one two years ago. I would handle them differently if it was the first contact for one and I had regularly (and recently) used the other.
That's what I am asking for.
It seems that I would have to patch the code for that. Beside the fact that this would indeed affect security I do not want a solution for me only but an improvement for the OpenPGP environment.

@_date: 2014-09-16 18:06:29
@_author: Hauke Laging 
@_subject: Multiple Subkeys for different Uses 
Am Di 16.09.2014, 18:38:42 schrieb Sam M:
And that's the point: For some (strange...) reason it is impossible in 1.4.x and 2.0.x to import secret key parts if there are already secret key parts.
You can combine those files to a single file though and import them at once. You need binary files (without --armor) and the command gpgsplit for that. Then you just combine the needed parts with cat to a ned file and import that.

@_date: 2014-09-16 18:37:38
@_author: Hauke Laging 
@_subject: Automated Revocation Key Generation 
Am Di 16.09.2014, 20:36:03 schrieb Sam M:
You can use the "echo ... | gpg ... --command-fd" part you know from my script in order to delete the passphrase (and add it afterwards). Without a passphrase there should not be a problem even without --batch.

@_date: 2014-09-16 20:53:53
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Di 16.09.2014, 10:31:00 schrieb Doug Barton:
What I want would make life easier mostly for the contacts of those who don't manage their keys well.
Furthermore it seems proven to me now that even the elite of the OpenPGP users "don't understand what key expiry means".

@_date: 2014-09-17 00:38:47
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Di 16.09.2014, 12:03:20 schrieb Doug Barton:
I wonder why you made the above statement then.
I'm sorry if that is your impression. My impression is that we have seen that both opinions about the suitable interpretation are backed by several people. I.e. there is no concensus. And the majority of those who have commented supports my suggestion.

@_date: 2014-09-17 22:32:12
@_author: Hauke Laging 
@_subject: encrypting to expired certificates 
Am Mi 17.09.2014, 20:54:22 schrieb MFPA:
The mainkey expiration date is implemented via the UID expiration date. This is because you need a signature and the mainkey itself doesn't have one. The mainkey expires if all UIDs have expired. Thus usually all UIDs have the same expiration date.

@_date: 2014-09-27 18:00:29
@_author: Hauke Laging 
@_subject: Symmetric & Encrypt in One 
Am Sa 27.09.2014, 16:11:09 schrieb MFPA:
I quote the man page for "--passphrase-fd n":
"[...] Note that this passphrase is only used if the option --batch has also been given. This is different from gpg."

@_date: 2015-02-10 19:20:03
@_author: Hauke Laging 
@_subject: (bug?) Revoked keys and past signatures 
Am Di 10.02.2015, 13:01:17 schrieb Daniel Kahn Gillmor:
I support this attitude.
And who says that this is the statement? The RfC? I think that faking cannot be a good idea in a crypto context. What if the signing key was created after the revocation? What would that look like? It must be possible for people who have only newer keys to make a "the owner of this key is X" statement.
I don't see any problem with the syntax. The problem is the lack of semantic definition. The next OpenPGP version should address that at any

@_date: 2015-02-14 11:54:47
@_author: Hauke Laging 
@_subject: Tilde (~) in valid email address 
Am Fr 13.02.2015, 19:54:44 schrieb You need --allow-freeform-uid to disable this check.

@_date: 2015-02-15 17:04:28
@_author: Hauke Laging 
@_subject: MIME or inline signature ? 
Am So 15.02.2015, 16:12:01 schrieb Stephan Beck:
0xDE2FFC869AFA5165 is a subkey of 0xBA4909B78F04DE1B. Of course, when pointing at a certificate you address it by its mainkey.
That is wrong.

@_date: 2015-02-16 02:01:08
@_author: Hauke Laging 
@_subject: MIME or inline signature ? 
Am So 15.02.2015, 20:55:05 schrieb Matthias Mansfeld:
Let's hope that changes soon:

@_date: 2015-02-18 22:49:54
@_author: Hauke Laging 
@_subject: Double sign a document 
Am Mi 18.02.2015, 21:29:40 schrieb Xavier Maillard:
Of course. Would be strange if you could make a signature without the respective secret key.

@_date: 2015-02-27 11:59:14
@_author: Hauke Laging 
@_subject: German ct magazine postulates death of pgp encryption 
Am Fr 27.02.2015, 09:45:36 schrieb gnupgpacker:
Werner has replied to that (on gnupg-de at gnupg.org and here):

@_date: 2015-02-27 12:43:12
@_author: Hauke Laging 
@_subject: German ct magazine postulates death of pgp encryption 
Am Fr 27.02.2015, 12:27:40 schrieb gnupgpacker:
We need keyservers which are a lot better that today's. IMHO that also means that a keyserver should tell a client for each offered certificate whether it (or a trusted keyserver) has made such an email verification.
Work in progress by me about that (in German):
In addition to that I will soon publish a description of my idea how crypto life can become much easier (especially for those non-cryotp loving people) by using a keyserver proxy (one software suitable for all clients instead of improving all clients separately or GnuPG itself which is rather not going to happen) which can be configured for key selection policies.

@_date: 2015-02-27 22:25:16
@_author: Hauke Laging 
@_subject: trust paths (was: German ct magazine postulates death of pgp 
Am Fr 27.02.2015, 21:25:40 schrieb Christoph Anton Mitterer:
What could that be good for? If you do not make very strange assumptions that could be of any use only if you assign certification trust to unknown keys which would be completely crazy.

@_date: 2015-02-27 22:45:36
@_author: Hauke Laging 
@_subject: trust paths 
Am Fr 27.02.2015, 22:30:41 schrieb Christoph Anton Mitterer:
Once more we see the term that confuses nearly everyone:
You personally decide to trust a key ? for it's certifications. That is not in any way related to the intermediate certifications for this key.
The WoT makes a key *valid*. What is needed for that is your personal decision, too, but on another level: That is configured in GnuPG (with --completes-needed and --marginals-needed). Unless you decide not to use the WoT and make your own signature based on the ones you see.

@_date: 2015-02-27 23:13:38
@_author: Hauke Laging 
@_subject: German ct magazine postulates death of pgp encryption 
Am Fr 27.02.2015, 20:56:00 schrieb Werner Koch:
That is not true. The main difference between the two is not that OpenPGP keyservers must be irrelevant for certificate assessment. The IMHO most important difference is that OpenPGP is well prepared for keys being certified by several keys. As a result you can configure how a certificate becomes valid.
Taking information into account which is generated by keyservers would not change this paradigm. Of course, such a feature could be used in a wrong way. But what change would that be? From my observation the majority of OpenPGP users uses it wrongly. And even the current official version of the Windows world's "model implementation" Enigmail makes it a pain to use it correctly. (The development version finally got that right, incredible...) The GPGTools plugin doesn't even offer you (at least not via the normal configuration interface) to do it right.
The right way to select a certificate is:
1) Have a look at one or (if necessary) more (non-synced) keyservers and try to find a signature which makes one of the found certificates valid.
2) What now? If there is only one certificate on the keyservers then people will use it. Even if it is a fake because the address owner either doesn't use OpenPGP at all or wants to avoid the keyservers (as spam or privacy protection) and offers his certificate on his web site.
If there are two non-valid certificates left the only question (in reality!) is "Use one of them or send unencrypted?" There is no reason to ignore additional information like "this entity (which happens to be a keyserver) claims to have verified the email address". Of course, this information becomes useful only if there is reason to trust this particular keyserver (which does not look promising with a DNS round-
robin pool).
You could even do that today by manually checking the pool for a validated certificate first and in case of failure one ore more keyservers which you happen to know that they verify the email address (like the PGP company's one). I don't understand anyway why gpg cannot be configured to use several keyservers at once (especially if the first one has no match).

@_date: 2015-02-27 23:21:42
@_author: Hauke Laging 
@_subject: German ct magazine postulates death of pgp encryption 
Am Fr 27.02.2015, 23:05:07 schrieb Peter Lebbing:
He does have to do more: He has to intercept the messages or deceive you about the email address to use. Both is possible, both are non-triviasl tasks so that you also have to ask: If he can to that why assume that he doesn't just hack your system?
So would he with unencrypted messages. Certificate validation does not appear from nowhere. Either you have it or you don't. And in reality you usually have to send the message anyway.
IMHO we especially need education for the masses that they become aware that different messages require different security levels (in all areas: key security, authentication security and system security). OpenPGP is not a model technology in that regard, too.
As you can read German, at least slowly... ;-)

@_date: 2015-02-28 00:03:26
@_author: Hauke Laging 
@_subject: German ct magazine postulates death of pgp encryption 
Am Fr 27.02.2015, 13:11:33 schrieb Kristian Fiskerstrand:
That is not a higher truth which must not be breached. The other way round it is correct, though: It must be possible to run a keyserver without making any statements about the certificates.
I would consider taking that to court ridiculous (for several reasons, one being the (also ridiculous) class 1 X.509 certifications) but it makes obviously little sense for us to make a mandatory assessment for the whole world. That is a decision which everyone who runs a keyserver (or intends to) should make himself.
This need not be implemented by the keyserver making signatures. It would be enough if there were certificate attributes in the keyserver answer. That way these certificates could not easily become valid by some not so clever user giving full certification trust to the keyserver's own I could hardly agree more but it is easy to join the "People need to understand" game if you are on a mailing list. This becomes much harder if you have been working on spreading OpenPGP usage in the nasty real world for a while. Like I have. For more than two years I have been teaching people myself, seen what is done (and what isn't) at Cryptoparties, have tried to use universities and schools for gaining new users. So what do we talk about here if in good approximation nobody outside this mailing list gives a^W^W cares about that?
We are going to lose this if we don't make usable offers. And in case it is not already well known here: I am at the security extremist end of the spectrum. I think both OpenPGP and GnuPG are not good enough yet in supporting high level security. I am just not willing to ignore the other 99.3%.

@_date: 2015-02-28 13:23:14
@_author: Hauke Laging 
@_subject: LDAP-based Keyserver 
Am Sa 28.02.2015, 12:27:05 schrieb Neal H. Walfield:
Doesn't refer to your work but is a general question as I have never used LDAP:
Is there any advantage in using LDAP for this? Or is this a "We have the LDAP server anyway thus we add the keyserver stuff instead of using a separate keyserver" decision?

@_date: 2015-01-24 20:27:46
@_author: Hauke Laging 
@_subject: Talking about Cryptodevices... which one? 
Am Sa 24.01.2015, 18:14:01 schrieb Andreas Schwier:
The OpenPGP card does provide the opportunity to backup the on the card generated key material.
