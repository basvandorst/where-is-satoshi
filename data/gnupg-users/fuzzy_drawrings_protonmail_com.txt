
@_date: 2018-04-12 03:30:45
@_author: FuzzyDrawrings 
@_subject: packet syntax 
You were expecting the packet header to be written in the "new" format, but it is actually written in the "old" format (indicated by it beginning with "10" vs "11"). See RFC-4880 section 4.2.
Public key packets have a Tag ID of 6, and the "new" format isn't required unless the packet has a Tag ID greater than 15.

@_date: 2018-04-14 00:14:23
@_author: FuzzyDrawrings 
@_subject: packet syntax 
True. But the version 4 public-key packet specification only tells you what information will be contained in the packet, not the format used for the packet header.
- fuzzy

@_date: 2018-04-29 16:18:55
@_author: FuzzyDrawrings 
@_subject: Can not decrypt and verify CD's 
Have you tried changing the certificate's Owner Trust? Since you imported the private key (as opposed to generating it), the trust is unknown. Owner trust should probably be set to "full".

@_date: 2018-08-03 18:38:25
@_author: FuzzyDrawrings 
@_subject: cannot decrypt file symmetric encrypted 
When you hit the Enter key after typing your decrypt command, it might also be closing the pinentry dialog immediately before it can appear on screen. Make sure you don't hold down the Enter key at all - just tap it once as briefly as possible.

@_date: 2018-02-03 00:25:05
@_author: FuzzyDrawrings 
@_subject: draft-ietf-openpgp-rfc4880bis-04 
I don't know if this is an error in the documentation, but I cannot obtain the sha256 result here:
I can obtain m, no problem. But fail to obtain d as m's sha256 digest.
Instead I repeatedly get:
d: 30d3de39f655d86b516058ae8c483f1a2cc10f0048882794655d4ce910abb7d6
Can anyone check if they are able to get the result shown in the documentation? And if so, is there anything else in addition to m that is input for the sha256 hash?

@_date: 2018-02-08 21:18:56
@_author: FuzzyDrawrings 
@_subject: draft-ietf-openpgp-rfc4880bis-04 
It is definitely my error in the m value I was hashing, which I failed to notice was not the same given in the documentation. I somehow repeatedly overlooked the fact that my obtained m value was different and only noticed that d (the hash) mismatch. Oops. Looking more carefully, I see did not in fact get the same value for m and am missing its trailing six octets 04ff0000000c.
Mystery solved. :)
But another more involved problem presents itself:
The value m is obtained as explained under "5.2.3.  {5.2.3} Version 4 Signature Packet Format"
I can account for every part of that through the hashed subpacket data in the value m, but not in m's last six octets: 04ff0000000c
m: 4f70656e504750040016080006050255f95f9504ff0000000c
'4f70656e504750' is the text "OpenPGP" being signed.
'04' is the signature version
'00' is the signature type (Signature of a binary document)
'16' is the public-key algorithm (EdDSA)
'08' is the hash algorithm (SHA256)
'0006' is the length of following hashed subpackets (6 octets)
'05' is the length of the first hashed subpacket (5 octets)
'02' is the first hashed subpacket tag (Signature Creation Time)
'55f95f95' is the first hashed subpacket data (2014-08-19 14:28:27)
...and that's the end of hashed subpackets. That should be all that is hashed for the signature, yet there is the remaining octets in m:
 04ff0000000c
 I cannot figure out what information is contained in 04ff0000000c.  I'm sure the answer is some hilarious oversight on my part, but I'm stumped. :/

@_date: 2018-01-23 02:41:45
@_author: FuzzyDrawrings 
@_subject: Keys clean of all signatures except those made by others I trust 
Title says it all.
Say I import Bob's key with "--recv-key" from some keyserver. Bob's public key has been signed by a lot of non-serious User ID's and spam. However Bob's key may have been signed by Alice (whose public-key I have in my keyring).
I would like to clean the key of the spam signatures while preserving any signatures made by Alice (or anyone else I have trusted on my keyring). Does there exist a command/option to accomplish this in gpg2?

@_date: 2018-01-23 16:08:38
@_author: FuzzyDrawrings 
@_subject: Keys clean of all signatures except those made by others I trust 
I guess I had stopped reading about ' clean' after the first line:
...however the rest of the description indicates it does exactly what I need. Doh!
Many thanks!

@_date: 2018-01-24 21:26:58
@_author: FuzzyDrawrings 
@_subject: Subpacket 33 and GnuPG Specifics on RFC-4880 Tag ID's, 
?Hello, I am working to better understand the OpenPGP standard and how it is handled by the current implementation of GnuPG.
To this end I have created a Python program that reads ASCII-Armor and returns details about the encoded data within. This is purely for my own edification and understanding of how OpenPGP works and also learn Python in the process.  I'm at the point where I can parse ascii armor to display almost all of the information I could otherwise get using "$ gpg --list-packets", including calculate the actual key fingerprint (which took a lot of re-reading the section of RFC-4880 that explains all the data that must be hashed to produce the fingerprint).
Does anyone know what are the additions or changes there are, in terms of packet tags, signature types, subpacket types, and algorithm identifiers used in the current version of GnuPG but that are not defined in RFC4880?
I've figured out a few on my own: additional public-key algorithm identifiers like 18 and 19 (ECDH and ECDSA, respectively, as defined in RFC-6637). And it seems that 22 is the identifier for Curve 25517 and/or EdDSA.
One I haven't been able to figure out is signature subpacket type 33. The signature files for the downloads on gnupg.org contain this subpacket type, but it isn't defined in RFC-4880. Strangely, even my installation of GnuPG does not display anything but "(?)" for the meaning of this subpacket's content:
$ gpg2 --list-packets gnupg-2.2.4.tar.bz2.sig
# off=0 ctb=89 tag=2 hlen=3 plen=307
:signature packet: algo 1, keyid 249B39D24F25E3B6
# off=310 ctb=89 tag=2 hlen=3 plen=307
:signature packet: algo 1, keyid 2071B08A33BD3F06

@_date: 2018-01-24 23:43:03
@_author: FuzzyDrawrings 
@_subject: Subpacket 33 and GnuPG Specifics on RFC-4880 Tag ID's, 
After looking at the content of subpacket 33, it appears to be the signing-key's fingerprint prepended by '0x04'.
So I'm guessing subpacket 33 is to be a more robust version of subpacket 16 (Issuer)?

@_date: 2018-01-25 23:44:51
@_author: FuzzyDrawrings 
@_subject: Keys clean of all signatures except those made by others I trust 
I was able to get the results I needed by using the 'clean' command under --edit-key, and also '--import-options import-clean'.
'import-filter' option is unavailable to me as I use the GnuPG versions in Ubuntu repository. If I put either the blacklist or whitelist in gpg.conf, GPG 2.1.11 hangs while GPG 1.4.20 declares it an 'invalid option'

@_date: 2018-01-30 21:35:57
@_author: FuzzyDrawrings 
@_subject: Why do Key Fingerprints include Creation Timestamp? 
Wouldn't it make more sense to hash only the public-key's MPI value(s)? That way if an implementation's code fails to generate a unique key-pair, it will be known because the fingerprint will be the same as some other key.
But as it is, with the Fingerprint hash including the timestamp, any "colliding" keys will have different fingerprints and so will go undetected.
Is there a good reason for it to be this way?
