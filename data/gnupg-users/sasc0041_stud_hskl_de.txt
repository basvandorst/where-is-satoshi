
@_date: 2016-02-11 17:54:00
@_author: Sandra Schreiner 
@_subject: How can GPGME use GnuPG on Android 
Looking at gnupg-for-android I was wondering and amazed. How does a Android app manages to use GnuPG? As far as I understand the relationship between GPGME and GnuPG, GPGME gathers all necessary information from the app and sends the data to GnuPG in a 'command-line-based way' and receives the result. I know it is not that hard to use C++ libraries in Android (thanks to JNI and NDK). Therefore the connection between the java wrapper and the C++ part is no real mistery. I just can't imagine how this all works together with GnuPG. On a Linux pc there is a standard path for GnuPG, so GPGME can find and call it very easy. On Android - I guess - you have to bring your own GnuPG with the apk. But how does the C++ part of GPGME know where GnuPG is located? Does the whole communication work in the same manner as on a pc? Does the deviation of bionic and glibc affect GPGME and GnuPG in any way? I tried to understand how this is done in gnupg-for-android, however it seems like sorcery to me.
I would be very grateful if someone could help me to get a better basic understanding of the android <-> gpgme <->gnupg relationship. Many thanks in advance.

@_date: 2016-01-26 08:54:17
@_author: Sandra Schreiner 
@_subject: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey 
This is my first message to an e-mail list ever. I don't even know if this is the right e-mail list for me, please forgive me if I'm wrong, but unfortunately I didn't found a GPGME e-mail list.
Currently I'm trying to use GPGME in my C++ application with GnuPG for key-management and encryption. Sadly I'm not able to create a new key, because my code hangs at gpgme_op_genkey. I have gpg 1.4.18 and gpg2 2.0.26 and GPGME 1.5.1 on my 64 bit Debian VM system (version Jesse) available. This is how I initialize the library:
    gpgme_engine_info_t info;
    gpgme_error_t  error;
    const char * CONFIG_DIR = "/";
    // Initializes gpgme
    gpgme_check_version(NULL);
    // Initialize the locale environment.
    setlocale(LC_ALL, "");
    gpgme_set_locale(NULL, LC_CTYPE, setlocale(LC_CTYPE, NULL));
 LC_MESSAGES
    gpgme_set_locale(NULL, LC_MESSAGES, setlocale(LC_MESSAGES, NULL));
    error = gpgme_set_engine_info(GPGME_PROTOCOL_OpenPGP, NULL,
                                  CONFIG_DIR);
    if(error)
        return false;
    error = gpgme_new(&mContext);
    if(error)
        return false;
    // Check OpenPGP
    error = gpgme_engine_check_version(GPGME_PROTOCOL_OpenPGP);
    if(error)
        return false;
    // load engine info
    error = gpgme_get_engine_info(&info);
    if(error)
        return false;
    while(info && info->protocol != gpgme_get_protocol(mContext)) {
        info = info->next;
    }
    // set path to our config file
    error = gpgme_ctx_set_engine_info(mContext, GPGME_PROTOCOL_OpenPGP, NULL,
                                      CONFIG_DIR);
    if(error)
        return false;

@_date: 2016-01-26 11:02:09
@_author: Sandra Schreiner 
@_subject: AW: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey 
Von: Gnupg-users [gnupg-users-bounces at gnupg.org]" im Auftrag von "Robert J. Hansen [rjh at sixdemonbag.org]
Gesendet: Dienstag, 26. Januar 2016 11:43
An: gnupg-users at gnupg.org
Betreff: Re: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey
Welcome!  You're in the right place, and we'll be happy to help you out.
 You may wish to switch from HTML email to plain-text; that's the
standard for this list.
If it's taking your GnuPG setup ~15 minutes to generate a new
certificate, that indicates to me your GnuPG installation has a problem.
Let's tackle that one first before we start looking at your code.
Are you getting periodic messages about "Not enough random bytes
available.  Please do some other work to give the OS a chance to
collect more entropy! (Need 167 more bytes)" or something like that?
Gnupg-users mailing list
Gnupg-users at gnupg.org
Yes. You are right. These messages appear often.
Moreover I noticed that GPGME 1.5 may be outdated. I saw that e.g. the mode GPGME_EXPORT_MODE_SECRET is missing for exporting private keys. Therefore I would like to update GnuPG and GPGME together. Sadly there is no new version of them available
in the debian package manager. How can I manage to update them? I found the tarball of
GPGME 1.6 but don't know which version of GnuPG would match this GPGME version.

@_date: 2016-01-27 08:54:40
@_author: Sandra Schreiner 
@_subject: AW: AW: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey 
Von: Daniel Kahn Gillmor [dkg at fifthhorseman.net]
Gesendet: Dienstag, 26. Januar 2016 19:30
An: Sandra Schreiner; Robert J. Hansen; gnupg-users at gnupg.org
Betreff: Re: AW: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey
 ]
You said that you are running in a Jessie VM.  Depending on the type of
VM, it's possible that there are few events that are feeding the
kernel's entropy pool (no virtualized hardware or software or anything
similar).  GnuPG relies on the kernel's entropy to initialize the key
generation process, and it consumes rather a lot of it.
I don't know what kind of virtualization you're using, so i have no
concrete suggestions for how you could increase the entropy in the VM
you're using, other than the usual tricks of typing into keyboard and
wiggling the mouse.
you can see the state of the Linux kernel's entropy by looking at the
contents of the file /proc/sys/kernel/random/entropy_avail -- if that is
staying close to 0, it's likely that this is the problem.
For testing purposes only, you might be interested in using the
--debug-quick-random flag, which would avoid waiting on the kernel's
blocking RNG.
I note that you're passing the root of the filesystem as your preferred
      const char * CONFIG_DIR = "/";
This might be a mistake, because it's unlikely that a normal user can
write to the root directory, and you almost certainly don't *want* to
use the root directory as your gpg config dir.
gpgme_set_engine_info() accepts NULL as the HOME_DIR parameter, which
asks for the engine' default homedir to be used.
gpgme and gnupg are not intentionally tightly coupled.  I wouldn't try
to update them until you've figured out what's going on here.
If the delay is still happening for you even with a system with entropy
available, you might also try looking at the process table to see what
is going on -- if there's a backgrounded gpg or gpg2 process, you could
try attaching to it with strace ("strace -p $PID", where $PID is the
process ID of the gpg process) to see what it's doing.
        --dkg
This file is empty. So entropie problems might be the reason. I'm using
a 64 bit Debian Image (Jesse) provided by Virtual Box inside Virtual Box
VM Manager.
I don't know how and where I should use this flag. I tried to generate a
new key using GnuPG command line tool, but it doesn't recognize it:
user at PC-ID-0050a-vm:~$ gpg --gen-key --debug-quick-random
gpg: Invalid option "--debug-quick-random"
Also I can't pass it as a compiler flag in my c++ project. My compiler doesn't know the flag either. Where does this flag belong?
I removed the specific path of the directory, because it contains the
project and user name. Sorry, I didn't mentioned that earlier. However I also tried to use the default path and didn't get any
results from the key generation in the c++ application.
I would really like to test if I could generate a key with the --debug-quick-random flag and see if entropie is the only show-stopper here.
Could this entropie issue also stop the application from generating
a key on a freshly booted system, say a mobile phone or a  'normal' (not VM) pc system?

@_date: 2016-01-27 12:49:51
@_author: Sandra Schreiner 
@_subject: AW: AW: AW: Key generation with GPGME and GnuPG hangs at 
Yes, that was the problem. I installed haveged and it worked. But it seems
that the key generation in my C++ application will not work, if a custom passphrase callback is set. The key generation code is unchanged, but with the callback I get an GPG_ERR_GENERAL error. The init and callback code is as follows:
   // Initializes gpgme
    gpgme_check_version(NULL);
    // Initialize the locale environment.
    setlocale(LC_ALL, "");
    gpgme_set_locale(NULL, LC_CTYPE, setlocale(LC_CTYPE, NULL));
 LC_MESSAGES
    gpgme_set_locale(NULL, LC_MESSAGES, setlocale(LC_MESSAGES, NULL));
    gpgme_error_t error = gpgme_new(&mContext);
    if(error)
        return false;
    // Check OpenPGP
    error = gpgme_engine_check_version(GPGME_PROTOCOL_OpenPGP);
    if(error)
        return false;
    // load engine info
    error = gpgme_get_engine_info(&info);
    if(error)
        return false;
    while(info && info->protocol != gpgme_get_protocol(mContext)) {
        info = info->next;
    }     //callback for user passphrase
    gpgme_set_passphrase_cb(mContext, passphrase_cb, NULL);
And the callback (similar to gpgme++):

@_date: 2016-01-27 15:58:30
@_author: Sandra Schreiner 
@_subject: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey 
I can't get that work. I copy pasted you code in my project and executed your main, but I still get a 'general error'. In the meanwhile I upgraded my system from jesse to
debian 'testing'. I'm now using GnuPG 2.0.28 and GPGME 1.6 but the problem stays the
same. I build the application with QT Creator 3.6 without any specific flags for GnuPG.
Is there anything left I could check or try to figure out where the problem is?
Moreover I experience a very strange behaviour if i use my callback and a existing key for encryption.
I want to encrypt a string only for a specific lists of recipients, but I get a password request for a uid that wasn't even included in the recipients list. It is always the same key
with the uid 'dummy dummy...' (it was the first key ever created). The request is a window opened
by GnuPG Agent, which seems to ingore my custom password callback. The window will sometimes
just reopen periodically.  I thought GnuPG might include this dummy key by default so I tried to use the GPGME_ENCRYPT_NO_ENCRYPT_TO flag... but the result stays the same. I feel like I should
resign. The code for encryption is:
encrypt(const std::string &plaintext, std::set uids,
                                 std::string &ciphertext) const{       bool result = false;
    //create a null terminated recipients array including current user
    int recipientsCount = uids.size() + 1;
    gpgme_key_t* recipients = new gpgme_key_t[recipientsCount];
    int i = 0;
    for(auto const &curUid: uids){
        //this will return the first gpgme key with exactly the given uid
        if(getGPGMEKey(curUid.c_str(), recipients[i], false)){
            i++;
        }
    }
    recipients[i] = NULL; // null terminate the array
    gpgme_data_t plain;
    gpgme_data_t cipher;
    if(!convertStringToData(plaintext, plain) || gpgme_data_new(&cipher)){
        //todo error code: data allocation error
    }
    else{
        //at this point GnuPG Agents asks for 'dummy dummy' password
        if(gpgme_op_encrypt_sign(mContext, recipients, (gpgme_encrypt_flags_t)(GPGME_ENCRYPT_NO_ENCRYPT_TO), plain, cipher)
 gpgme_op_encrypt_result(mContext)->invalid_recipients) {
            //todo error code: encryption error
        }else{
            //now fetch the encrypted data
            if(convertDataToString(cipher, ciphertext)){
                result = true;
            }
        }
    }
    //release references and buffer
    //...
    return result;

@_date: 2016-01-27 17:12:26
@_author: Sandra Schreiner 
@_subject: AW: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey 
I figured out what the problem was. I went back to Jessie with the old GnuPG and GPGME
version and it worked fine, as you said. Unfortunately the other problem is not solved with the rollback to Jessie. Where does the 'unspecified' recipient come from? Does GnuPG use any defaults which can't be disabled by the flag GPGME_ENCRYPT_NO_ENCRYPT_TO?

@_date: 2016-01-28 08:35:32
@_author: Sandra Schreiner 
@_subject: AW: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey 
Thank you for this encouraging words. In fact I got solved another problem.
It seems that the reason GnuPG was asking for the dummy password, was
that this user was set as a signer in my context (as default). Now I use
before I encrypt/sign my string. The request for the dummy password disappeared. The only problem remaining is that the application still ignores my own password callback and uses the GnuPG default:
gpgme_set_passphrase_cb(mContext, passphrase_cb, nullptr);
I replaced my callback with your code:
gpgme_error_t passphrase_cb(void *hook, const char *uid_hint, const char *passphrase_info,
                            int prev_was_bad, int fd){
    std::string passphrase { "" };
    size_t written { 0 };
    std::cout << "Enter your passphrase: ";
    std::getline(std::cin, passphrase);
    if (passphrase.empty())
        return GPG_ERR_CANCELED;
    while (written < passphrase.size())
    {
        ssize_t bytesWritten = gpgme_io_write(fd,
                                              &passphrase[0] + written,
                passphrase.size() - written);
        if (bytesWritten == 0)
            break;
        written += bytesWritten;
    }
    gpgme_io_write(fd, "\n", 1);
    return GPG_ERR_NO_ERROR;

@_date: 2016-01-28 09:20:32
@_author: Sandra Schreiner 
@_subject: AW: AW: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey 
I guess I'm in real trouble now. The reason for this is a bit complex. My encprytion class is part of a framework, which shall be used on different plattforms. Therefore my
own 'GPGME wrapper' (and the framework as a whole) should be available in C++ and Java. Before I started with my implementation I found this wrapper of GPGME for Java (so I thought it should be generally possible to use GnuPG/GPGME in Java).
But we decided to not use the existing wrapper, because it is old, (seems) unmaintained and we would like to have simpler interfaces and one solution for both, the C++ and Java world. Means:
we just want to provide the simple and small interface in C++ and wrap this with JNI for Java.
So the problem boils down to this question: What would happen if my class would be called by an android application? Would the pinentry provided by GnuPG work in this case?

@_date: 2016-01-28 09:53:35
@_author: Sandra Schreiner 
@_subject: AW: Key generation with GPGME and GnuPG hangs at gpgme_op_genkey 
This will sadly not solve my problem. The GPGME interface is not the interface we would
like to use for our purposes, because not all of the GPGME features should be available in our framework (intentionally). Therefore I would have to write (actually I already wrote, beside the callback problem) a C++ wrapper for GPGME. And I would have to write another wrapper for the Java wrapper, for the same reason. The combination of this would lead to maintaining at least two wrappers: the one for Java and the one for C++. Moreover the license is GPL and we would need LGPG. Maybe this point could be solved with separate license negotiations. But for now I guess I'm back to my question: What would happen if I would rely on pinentry in android?

@_date: 2016-01-30 09:13:42
@_author: Sandra Schreiner 
@_subject: Default configuration of GnuPG preferred chiphers and hashfunctions 
Hello again,
I somehow can't get GPGME to work with a custom configuration directory for GnuPG. Every time I set a path any key generation fails with a GPGME_ERR_GENERAL afterwards. There is nothing special about how I set the path:
   gpgme_engine_info_t info;
    gpgme_error_t  error;
    const char* dir = "/home/myuser/crypttest";        // Initializes gpgme
    gpgme_check_version(NULL);
    // Initialize the locale environment.
    setlocale(LC_ALL, "");
    gpgme_set_locale(NULL, LC_CTYPE, setlocale(LC_CTYPE, NULL));
 LC_MESSAGES
    gpgme_set_locale(NULL, LC_MESSAGES, setlocale(LC_MESSAGES, NULL));
   //also tried this, but this didn't work either:
   // error = gpgme_set_engine_info(GPGME_PROTOCOL_OpenPGP, NULL,
   //                               CONFIG_DIR);
    if(error)
        return false;
    error = gpgme_new(&mContext);
    if(error)
        return false;
    // Check OpenPGP
    error = gpgme_engine_check_version(GPGME_PROTOCOL_OpenPGP);
    if(error)
        return false;
    // load engine info
    error = gpgme_get_engine_info(&info);
    if(error)
        return false;
    while(info && info->protocol != gpgme_get_protocol(mContext)) {
        info = info->next;
    }
    // set path to config file
    error = gpgme_ctx_set_engine_info(mContext, GPGME_PROTOCOL_OpenPGP, NULL,
                                      CONFIG_DIR);
    if(error)
        return false;
If I remove the directory in my init function and use a nullptr (for default), the same key generation succeeds. I don't know why this happens. I have read and write access to this directory and tried various other directories (also including the closing / at the end), but without luck.
Moreover I searched for information about the default (preferreed) order of GnuPG for ciphers and hashfunctions. But didn't found something. There doesn't seem to be any gpg.conf file on my PC. Neither on my windows system in %APPDATA%\gnupg or my Debian system (both have GnuPG installed). How can I figure this out?
Im using gpg2 2.0.26 and GPGME 1.5.1 in 64 bit Debian VM on Windows 7 64 bit Host System.
Many thanks in advance,
