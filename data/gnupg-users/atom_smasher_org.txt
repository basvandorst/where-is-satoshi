
@_date: 2005-04-16 09:23:51
@_author: Atom Smasher 
@_subject: Encrypt with public key from stdin/file possible? 
there's a better way to fake it... let's say you want to encrypt a message to me, and have my key in a binary file "D9F57808.key":
   gpg --no-default-keyring --keyring /path/to/D9F57808.key -er D9F57808
you may want to add "--trust-model always" to the command.
this only works with binary, not ascii, key files. keys in ascii would have to be converted into binary, or use the import method described by

@_date: 2005-04-19 02:06:07
@_author: Atom Smasher 
@_subject: Retrieving signature from message that was encrypted and signed 
there's no reason it can't be done, but i don't know of any application that can do it.
for now, the only way to do it is to extract the session key from the message (--show-session-key) and send that along with the encrypted message to your 3rd party. they can use "--override-session-key" to decrypt the message and verify the signature.
in most cases the session key should be encrypted (to your 3rd party), because anyone who gets a hold of the session key can read the message.

@_date: 2005-08-24 19:19:43
@_author: Atom Smasher 
@_subject: legal status of GnuPG in China? 
IANAL, but it seems that GnuPG/PGP would require a license for use. i would think that it would be easier to get a license (if any are actually issued) if the stated use was signing and authentication, rather than encryption (then encryption is merely a built-in feature, not a core feature for your use). then generate an RSA "signing" key that is capable of both encryption and signing, but do NOT create any encryption subkeys.
it really makes me sick that the US is doing everything it can to export jobs and money to china (my gripe is with the chinese govt, NOT the chinese people). just remember, next time you buy some piece of crap at wal-mart and it says "made in china", part of the money that you're spending is to buy bullets to shoot people who are caught using crypto (or practicing religion).

@_date: 2005-12-01 04:03:10
@_author: Atom Smasher 
@_subject: PK-Encrypt-only 
done all the time in email for, um, (somewhat) plausible deniability.
encrypting without signing can also be useful in automated encryption applications where it would not be beneficial to leave a signing key laying around. things such as writing data to a database or sending out an encrypted email can benefit from public key encryption; if the server is successfully attacked, the public key is compromised and can not aid the attacker in recovering encrypted data. adding a signing key (that's available to an automated application, and also an attacker) only adds a false sense of security as to the message's authenticity.

@_date: 2005-12-22 06:46:51
@_author: Atom Smasher 
@_subject: Create key's over 4096 bit ???? 
to paraphrase bruce schneier: what's more secure? a fence that's a thousand feet tall or a fence that's ten thousand feet tall?
that said, computers keep getting faster and attacks keep getting better. back in the early days of PGP(tm) a 1024 bit key would have been considered bigger than you'd ever need. history has shown that 1024 bit keys are now generally considered the smallest key you'd want to use, and may not be "safe" over the course of the next 10-20 years.
the thing to bear in mind, though, is that a 2048 bit key isn't *just* twice as strong as a 1024 bit key... (according to my math, please correct me if i'm wrong) it's this many times stronger:
17976931348623159077293051907890247336179769789423065727343008115773\ 26758055009631327084773224075360211201138798713933576587897688144166\ 22492847430639474124377767893424865485276302219601246094119453082952\ 08500576883815068234246288147391311054082723716335051068458629823994\ a 1025 bit key (if there was such a thing) would be [merely] twice as strong as a 1024 bit key. a 1028 bit key would be 16 times stronger. compared to a 1024 bit key, a 4096 bit key is stronger by a number that's represented by (about) 4624 decimal digits. since no one has publicly broken a 1K key i feel pretty safe using 2K keys for everyday stuff.
also, anyone considering huge keys should read this section from the diceware FAQ -  and remember that breaking a key is the hardest way to "break" pgp... there are a lot of easier methods, such as key-loggers and spy-cameras.

@_date: 2005-12-22 16:59:57
@_author: Atom Smasher 
@_subject: Create key's over 4096 bit ???? 
so, does that mean that a 2048 bit asymmetric key is (only) this many times stronger than a 1024 bit key(?):
???   sqrt((2^2048)/(2^1024))   ???
i never studied higher math, so apologies for any confusion that i'm adding to things.

@_date: 2005-12-23 16:27:48
@_author: Atom Smasher 
@_subject: Create key's over 4096 bit ???? 
maybe they can justify 4K keys for everyday use, although anything larger would attract attention.
even then, how hard is it to get a group of non-geeks, who didn't grow up with computers, to use pgp? i think they're more likely to use carrier pigeons than pgp.

@_date: 2005-12-28 14:31:39
@_author: Atom Smasher 
@_subject: Create key's over 4096 bit ???? 
it ~may~ be effective against password recovery in some forms of crypto: an attacker (torturer) would know when the password is revealed because a valid message is produced.
a courier with a photographic memory could give up countless "secrets", and none of them the ~right~ one. really, if you beat the crap out of someone long enough and hard enough, they'll admit to being osama bin off the top of my head, outguess  is the closest thing to a real crypto app with a decent "plausible deniability" feature.

@_date: 2005-02-03 17:20:37
@_author: Atom Smasher 
@_subject: RSA subkeys 
Hash: SHA256
gpg 1.4 is better. no comment on RH9.
why not update the expiration date on the subkeys, and keep them? if they're not compromised there's no reason to throw them away.
RSA support is optional in rfc2440. i've been using an RSA only key for a while with no problems, mostly with other gpg users.

@_date: 2005-02-03 17:25:35
@_author: Atom Smasher 
@_subject: Multiple files 
Hash: SHA256
       --multifile
  	This modifies certain other commands to accept multiple files for
  	processing on the command line or read from stdin with each
  	filename on a separate line.  This allows for many files to be
  	processed at once.  --multifile may currently be used along with
  	--verify, --encrypt, and --decrypt.  Note that `--multifile
  	--verify' may not be used with detached signatures.
second time that this has been asked recently. should it go in the faq?

@_date: 2005-02-03 19:54:23
@_author: Atom Smasher 
@_subject: RSA subkeys 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
ok, i guess that does have advantages under the UK's IPA(?). here in the states one is protected against govt abuse by not writing down their passphrase .

@_date: 2005-02-03 22:12:02
@_author: Atom Smasher 
@_subject: RSA subkeys 
Hash: SHA256
yeah, but they don't need evidence to do that, so crypto is largely irrelevant. in fact it could save someone from the gulag... if they *really* want to know what's encrypted they'll work out a deal. the guantanamo gulag is reserved for people who can't be convicted anyway.
sooner or later the civilized world will liberate us... or we'll collapse under our own weight.
huh? i'm not sure how that works... tell me more...

@_date: 2005-02-03 23:21:36
@_author: Atom Smasher 
@_subject: "Malformed User ID" 
Hash: SHA256
is the key publicly circulated? if yes, what is the key id?
have you tried specifying the key by key id? or user id?
 	gpg -e file -r test
 	gpg -e file -r 0x12345678

@_date: 2005-02-03 23:26:49
@_author: Atom Smasher 
@_subject: "Malformed User ID" 
Hash: SHA256
correction to self. that won't work.
i meant:
 	gpg -er test file
 	gpg -er 0x12345678 file

@_date: 2005-02-04 19:13:39
@_author: Atom Smasher 
@_subject: Signing a Key 
Hash: SHA256
      --ask-cert-level
      --no-ask-cert-level
 	When making a key signature, prompt for a certification level.
 	If this option is not specified, the certification level used is
 	set via --default-cert-level.  See --default-cert-level for
 	information on the specific levels and how they are used.
 	--no-ask-cert-level disables this option.  This option defaults to
 	no.
this used to default to yes. now you have to specify it explicitly. also check out "--default-cert-level". i have both in my config.

@_date: 2005-02-04 19:39:49
@_author: Atom Smasher 
@_subject: Signing a Key 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
i think too many noobs were being confused by the prompt. the theory now seems to be that if you know about levels, you'll figure out how to sign with a desired level. for everyone else, it defaults to 0x10.
IFIAK, PGP(tm) is still only capable of issuing 0x10 key signatures.

@_date: 2005-02-05 20:27:24
@_author: Atom Smasher 
@_subject: Signing a Key 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
i don't know about anyone else, but i reserve 0x13 sigs for people i *know*, usually for some length of time.
if i meet someone at a keysigning party and they show me some identification with a picture that looks like them, that earns a 0x12 from me. i have no idea who they *really* are, but they have gone through the trouble of showing me some identification that looks like them. OTOH if my brother, or someone who i've known personally for a several years wants me to sign their key, they're more likely to _earn_ a 0x13 sig from me.
to me, that fits the definition of "casual" and "extensive" verification. if i board a plane and they look at my identification, i wouldn't call that an "extensive" check.
of course, the system does encourage people to do what makes sense for them. there isn't necessarily a wrong way to issue sigs... as long as there's a defensible reasoning for it, everyone can choose for them self how to define "casual" and "extensive".

@_date: 2005-02-05 21:31:50
@_author: Atom Smasher 
@_subject: Howto multiple mail accts. 
Hash: SHA256
if it's no secret that all of the accounts belong to you, then a single key with multiple UIDs is probably the best thing. it's certainly the if you don't want people to immediately know that all of the accounts belong to you, then use multiple keys.
i have 3 keys that are publicly distributed. one for business and professional correspondence, one for casual correspondence and one for an address (read: identity) that i don't share with too many people.
on my casual correspondence key i have 2 UIDs. it's no secret that i control both of those mailboxes.
if your multiple accounts require your key(s) to be stored on machines that you don't own/admin (such as a company computer) then you should consider multiple keys/subkeys.
if you decide to use multiple subkeys this might help -

@_date: 2005-02-07 06:56:05
@_author: Atom Smasher 
@_subject: Strongest Key, Hash, and Cypher Algorithms 
Hash: SHA256
there are no weak algorithms in pgp/gpg. even the "weakest" algorithms should be fine against any attack that can currently be mounted against the strength of symmetric encryption is that you don't need to keep a key in a file. all you need to do is remember the passphrase and you will always be able to decrypt your data.
the strengths of asymmetric encryption are unattended encryption (you don't have to type a passphrase to encrypt) and secure communication across an insecure channel (such as the internet) between 2 or more diceware is good. more info on other techniques - hashing is rarely done with symmetric encryption (except as part of the s2k process). in a way, knowing the passphrase *is* authentication (and in another way, it isn't).
(all other factors being equal) the bigger the passphrase, the more protection. the question you should ask is "what size passphrase is sufficient for the secrets i want to keep?" check out these sections of the diceware FAQ -
 	How long should my passphrase be?
 	
 	What if I want a passphrase with full 128-bit security?
 	
the key types and algorithm preferences, if you don't use the defaults, should be based on your latest research and suspicions of what information you have. some people don't like 3DES... other people don't like BLOWFISH/TWOFISH... i don't like AES... at the end of the day, none of the algorithms are broken, or even close to being broken, but many of us have our favorites. only your research and/or crystal ball will dictate which algorithms you decide to trust most, or not at all.

@_date: 2005-02-07 22:32:43
@_author: Atom Smasher 
@_subject: Strongest Key, Hash, and Cypher Algorithms 
Hash: SHA256
there have been several succesful attacks against against RC4, but only when it's incorectly implemented. the lesson here is that some good algorithms are weakly implemented... some algorithms are difficult to implement correctly. i think elgamal for signatures falls into that  	Some cryptographers worry about the security of AES. They feel that the margin between the number of rounds specified in the cipher and the best known attacks is too small for comfort. The risk is that some way to improve these attacks might be found and that, if so, the cipher could be broken. In this meaning, a cryptographic "break" is anything faster than an exhaustive search, so an attack against 128-bit key AES requiring 'only' 2120 operations would be considered a break even though it would be, now, quite infeasible. In practical application, any break of AES which is only this 'good' would be irrelevant. For the moment, such concerns can be ignored. The largest publically-known brute-force attack has been against a 64 bit RC5 key by distributed.net.
 	Another concern is the mathematical structure of AES. Unlike most other block ciphers, AES has a very neat mathematical description [2] ( [3] ( This has not yet led to any attacks, but some researchers are worried that future attacks may find a way to exploit this structure.
 	In 2002, a theoretical attack, termed the "XSL attack", was announced by Nicolas Courtois and Josef Pieprzyk, showing a potential weakness in the AES algorithm. It seems that the attack, if the mathematics is correct, is not currently practical as it would have a prohibitively high "work factor". There have been claims of considerable work factor improvement, however, so the attack technique might become practical in the future. On the other hand, several cryptography experts have found problems in the underlying mathematics of the proposed attack, suggesting that the authors have made a mistake in their estimates. Whether this line of attack can be made to work against AES remains an open question. For the moment, as far as is publicly known, the XSL attack against AES is speculative; it is unlikely that anyone could carry out the current attack in practice.

@_date: 2005-02-07 23:49:34
@_author: Atom Smasher 
@_subject: Strongest Key, Hash, and Cypher Algorithms 
Hash: SHA256
i'm flattered that you like it so much, but i'm not a cryptographer. although i have a good understanding of the protocols i actually suck really bad at the math.
most of the information is out there, although a lot of it is dated.
i guess you could start here -
 	The PGP Attack FAQ
 	
 	PGP DH vs. RSA FAQ
 	
 	Practical Attacks on PGP

@_date: 2005-02-08 20:46:54
@_author: Atom Smasher 
@_subject: Strongest Key, Hash, and Cypher Algorithms 
Hash: SHA256
as i understand it a fast (polynomial time) attack against DH would necessarily apply to RSA, but a fast attack against RSA would not necessarily apply to DH.
to clarify for anyone who doesn't know, elgamal is a variation of DH.

@_date: 2005-02-08 21:26:06
@_author: Atom Smasher 
@_subject: GnuPG ME: How do we use the --keyring GnuPG option via GnuPG ME? 
Hash: SHA256
      --options file
 	Read options from file and do not try to read them from the
 	default options file in the homedir (see --homedir).  This option
 	is ignored if used in an options file.

@_date: 2005-02-11 22:00:24
@_author: Atom Smasher 
@_subject: [Announce] Attack against OpenPGP encryption 
Hash: SHA256
as is obvious by my questions, i don't understand the math.
  	Consequently, PGP Corporation, GnuPG, and Hush Communications are
  	all disabling the quick check for all public key-encrypted
  	messages and files. However, we are all presently leaving it in
  	for symmetric (passphrase) encrypted messages and files because we
  	believe the benefit of the quick check is greater than the
  	security risk from it. You will see this change in the next
  	software release from each group.
what about data that is encrypted with both a symmetric and asymmetric   	In our discussions with Mister and Zuccherato about their attack,
  	we asked if they thought we should revise the protocol to address
  	the problem. They told us they didn't think it was necessary-that
  	an explanation of the issue and how to avoid it was good enough.
  	As implementers of OpenPGP systems, however, we think we should
  	update the protocol. People trust OpenPGP because we handle issues
  	before they become real-world problems...
how could this "become" a real world problem? is it conceivable that it might be leveraged into a stronger attack?
  	We are suggesting in the working group that we amend OpenPGP so
  	there is a new symmetric encryption system that has a secure quick
  	check.
like using a strong hash for the quick check? wouldn't that also benefit symmetric encryption with no significant increase in computational

@_date: 2005-02-11 22:20:50
@_author: Atom Smasher 
@_subject: set-filename / use-embedded-filename 
Hash: SHA256
does the embedded file name info only apply to encrypted (and stored) data, but not signed data? in the rfc (2440:5.9) i don't see where it shouldn't apply to signed files.
verifying a signed file with "-v" i always see this line:
  	gpg: original file name=''
even if i use "--set-filename" when creating a signature.

@_date: 2005-02-12 03:52:13
@_author: Atom Smasher 
@_subject: set-filename / use-embedded-filename 
Hash: SHA256
ok... so if the signature is both clear and attached, i guess there's no need to include the original file name, huh?

@_date: 2005-02-12 23:44:15
@_author: Atom Smasher 
@_subject: Strongest Key, Hash, and Cypher Algorithms 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
there's nothing wrong with having all capabilities set in the primary key, but it's generally advisable to have an encryption subkey and possibly a signing subkey (and authentication subkey?).

@_date: 2005-02-14 18:14:22
@_author: Atom Smasher 
@_subject: How to encrypt attachments in MIME using inline-PGP 
Hash: SHA256
encrypt the file(s) you want to attach attach. then attach the encrypted

@_date: 2005-02-16 17:08:00
@_author: Atom Smasher 
@_subject: SHA1 broken? 
Hash: SHA256
there's more to it than that. openPGP specifies SHA-1 (and nothing else) as the hash used to generate key fingerprints, and is what key IDs are derived from.
a real threat if this can be extended into a practical attack is substituting a key with a *different* key having the same ID and fingerprint. it would be difficult for average users (and impossible for the current openPGP infrastructure) to tell bob's key from mallory's key that claims to be bob's.
it can also be used (if the attack becomes practical) to forge key signatures. mallory can create a bogus key and "sign" it with anyone's real key. this would turn the web of trust into dust.
the openPGP spec seemed to have assumed that SHA-1 just wouldn't fail. ever. this was the same mistake made in the original version of pgp that relied on md5. the spec needs to allow a choice of hash algorithms for fingerprints and key IDs, or else we'll play this game every time someone breaks a strong hash algorithm.

@_date: 2005-02-16 18:15:37
@_author: Atom Smasher 
@_subject: SHA1 broken? 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
agreed. my point is really that the fingerprint/ID hash algo shouldn't be carved in stone. like most other parts of the openPGP spec, it should be flexible and user defined (within certain constraints). as time goes by, strong algorithms are proven to be not as strong as originally thought. this has happened to MD5, is now happening to SHA-1, and will just as likely happen to the next generation of hash algorithms. the spec needs to adapt to this landscape, not be re-written every time a hash is broken.
the spec has it right where the digest and cipher algorithms are concerned, and that needs to be adapted to fingerprints and key IDs.

@_date: 2005-02-17 07:51:23
@_author: Atom Smasher 
@_subject: SHA-1 break - in perspective 
Hash: SHA256
this should help put the (alleged until proven otherwise) SHA-1 break into perspective. thanks to Sascha Kiefer for giving me the idea.
let's say that unbroken SHA-1 represents a 100 meter (328 ft) wall. if a break allows a collision to be found in merely 2^69 operations (on average), that would mean the wall has crumbled to 4.9 cm (1.9 in) tall. that's broken!!
OTOH, let's say that unbroken MD5 represents a 100 meter (328 ft) wall. comparing unbroken MD5 to broken SHA-1 means the wall would actually grow from 100 meters (328 ft) tall to 3.2 km (1.99 miles) tall. SHA-1, even if it's broken enough to find a collision in 2^69 operations (on average), is still stronger than MD5 was ever meant to be.
again, using unbroken MD5 as our reference of a 100 meter (328 ft) wall, unbroken SHA-1 would be a wall 6553.6 km (4072 miles) tall. SHA-1 was intended to be incredibly stronger than MD5.

@_date: 2005-02-23 16:39:29
@_author: Atom Smasher 
@_subject: gpg.conf 
Hash: RIPEMD160
it's all in the man page. just about all of the long options can be used in the config file, just leave off the two leading dashes.

@_date: 2005-01-17 01:54:05
@_author: Atom Smasher 
@_subject: Encrypt & Sign 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
as a practical matter, you're mostly correct. as a nitty-gritty technical and philosophical matter there's still a gap.
also, just because some of us use open source tools doesn't mean everyone does... and open source isn't magically secure. some people use gpg/pgp on shared machines, or machines that they don't have exclusive root access to. some people use public terminals to access their secure machine and their secret keys. there are plenty of things that could (in theory and practice) come between an individual and their key. it's the responsibility of key owners to make sure their keys aren't compromised. if keys are compromised then the responsible thing to do is revoke those

@_date: 2005-01-20 07:44:17
@_author: Atom Smasher 
@_subject: auto sign files 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
there seems to be something that's being overlooked in this thread... what key is being used to auto-sign with?
i personally have scripts that generate signed files without me typing a passphrase (this is facilitated by a key with no passphrase). normally this would be considered incredibly stupid, but there's one thing about it that make it OK by my standards: i'm not using *my* key.
sure, i'm using a key that's exclusively under my control, but that key is not part of *my* key (0xD9F57808) or the WoT. as a matter of fact, the key isn't even distributed publicly. the UID is meaningless to anyone who doesn't know what it is, and the key has no third party signatures.
if i have any reason to suspect that an auto-signing key is compromised i can replace it with a new key. assuming that the public part of that key is only being used by a small group of people it's probably overkill to formally revoke it... just replace it.
i would *NEVER* use _my_ key or any subkey for signing on auto-pilot, but for a key that's only used for a specific purpose it *can* increase overall security... one example is a remote IDS scan that's run from my desktop... every night it generates a report for each server that it scans, and then emails the report to my mail server. the report then sits on my mail server waiting to be read... but what if the mail server is hacked? a hacker could change the report before i see it. by auto-signing the report on my desktop before mailing it out, i will know immediately if the report was altered in any way (after leaving my desktop). IMHO the net effect is an increase in security.
and if my desktop is hacked? in that case i would have to consider *my* compromised, strong passphrase and all.
this reminds me of a true story: someone from an unnamed internet bank wanted a custom version of the "gpg_encrypt" php script that would add a signature to the encrypted email. i tried to explain that it would be creating a _sense_ of security, while probably not _actually_ increasing security. they insisted that they required the signature. i gave them what they wanted, and everything seemed fine on my end but they were having problems getting it to work on their end. after a few rounds of tests that i had them perform on their server, it turned out that they're running their internet bank on a SHARED SERVER that's maintained by their hosting company!!! they have *ZERO* control over the administration of the server! i tried to explain that this was not only the cause of their problems but also HORRIBLY INSECURE, but they just didn't get it. all of the strong crypto in the world can't keep their customers' banking information

@_date: 2005-01-21 08:38:06
@_author: Atom Smasher 
@_subject: Gpg and batch 
Hash: SHA256
i'm not sure what you're trying to automate with every command, but the details for "Unattended key generation" are in the "DETAILS" file installed with gnupg documentation. it includes a list of parameters.

@_date: 2005-01-22 06:24:44
@_author: Atom Smasher 
@_subject: Shell script question for GnuPG on FreeBSD 
Hash: SHA256
    --multifile
 	This modifies certain other commands to accept multiple files for
 	processing on the command line or read from stdin with each
 	filename on a separate line.  This allows for many files to be
 	processed at once.  --multifile may currently be used along with
 	--verify, --encrypt, and --decrypt.  Note that `--multifile
 	--verify' may not be used with detached signatures.
hehe... the man page is a bit of a bear... you have to know what your looking for.

@_date: 2005-01-29 07:50:24
@_author: Atom Smasher 
@_subject: How to automatically sign emails 
Hash: SHA256
i've never seen a perl script that wasn't strange.
look into ripmime. it can be used to take apart the different pieces of a MIME message. you can then sign just the text and re-attach everything else.
is that what you're trying to do?

@_date: 2005-07-27 09:22:36
@_author: Atom Smasher 
@_subject: I have the public key, but not the private... 
um... no. without the private key, you're beat. that's kind of the whole point of pgp/gpg.
if you discover a way to recover the private key from a public key before the earth is swallowed by the sun, we'd all like to know about it.
you did follow the instructions and created a revocation certificate, right? and stored it in a safe place?

@_date: 2005-07-30 07:40:09
@_author: Atom Smasher 
@_subject: Entropy in ascii-armored output? 
check out .
something like:
 	$ head -4 /dev/urandom | gpg --enarmor
will produce much better "random" output than encrypted output. encrypted output can be filled with  information that is not at all random, such as partial body length headers.
of course, base64 is limited to little more than half of the characters that you could be using on an english keyboard... let's say that there are 100 printable characters available on an english keyboard. (according to my math) a 10 character password using only base64 characters can contain up to 60 bits of entropy, but allowing 100 possible characters it can contain almost 66.5 bits of entropy. using 20 characters, it's 120 bits for base64 and almost 133 bits otherwise.
personally, i find diceware ~type~ passphrases easier to remember than

@_date: 2005-03-02 01:44:49
@_author: Atom Smasher 
@_subject: Create a Key using a script? 
Hash: SHA256
attached is a shell script that you can modify for your own key SHA1 (gen-key-batch.gz) = 68b79122814f8d2d920c61e3d59bdff20687a0ae
huh? you want to generate keys for people? why would they trust you? you could keep a copy of their secret key and cause trouble.

@_date: 2005-03-09 21:14:32
@_author: Atom Smasher 
@_subject: Encrypting SubFolders 
that's close to what i was thinking...
 	find /thisfolder -type f -exec gpg --encrypt {} \;
same thing, really... i can think of several variations for typing it.

@_date: 2005-03-10 01:48:46
@_author: Atom Smasher 
@_subject: Preventing temporary files? 
this might give you some ideas, or depending on what you're doing it might be what you need.

@_date: 2005-03-20 21:13:27
@_author: Atom Smasher 
@_subject: gpg over ssh... 
Hash: SHA256
this seems to work for me:
  $ ssh atom 'cat file1' | gpg | ssh atom 'cat - > file2'
note the quotes.
it reads an encrypted file (file1) from the server, decrypts it locally and writes the decrypted data back to a file (file2) on the server.
my secret key and password stay away from the server.

@_date: 2005-03-21 16:21:09
@_author: Atom Smasher 
@_subject: gpg over ssh... 
just shuffle around the commands and add some options/commands to the gpg question: if you wouldn't want to store your secret key or type your password on the server, why would you want to authenticate from your server to your desktop? if your server is compromised, someone would be able to steal your password for your desktop and secret key, then log into your desktop and steal your secret key.
the only way to avoid that is by logging in to your desktop using one time what you're trying to do seems to offer little advantage over using gpg locally on the server.

@_date: 2005-03-22 01:13:05
@_author: Atom Smasher 
@_subject: signature level 
--ask-cert-level
previously this was on by default. apparently it caused too much confusion, so now you have to specify it if you want it.

@_date: 2005-03-23 02:22:22
@_author: Atom Smasher 
@_subject: signature level 
me too... but you can add "ask-cert-level" to the config file and it'll work that way.
you can also add a "default-cert-level" line to specify what the default should be, if you find yourself issuing a certain level most often.

@_date: 2005-05-16 18:34:08
@_author: Atom Smasher 
@_subject: Difference "gpg --armor --store" Vs. "gpg --enarmor" 
one could also use base64 to armor a message. what makes enarmor nice for pgp hacking is that it adds a checksum (rfc2440:6) making it radix-64

@_date: 2005-05-23 17:48:57
@_author: Atom Smasher 
@_subject: 2 noob problems 
in many respects, a new self-sig is meant to replace and supersede an older self-sig, not augment it. although it can be argued that old self-sigs serve a historical purpose, i would argue that they just take up space and rarely serve any useful purpose.

@_date: 2005-05-24 16:52:55
@_author: Atom Smasher 
@_subject: Max compression 
the range is 1-9. 1 is the fastest, 9 is the best compression.
from the gzip man page:
 	Regulate the speed of compression using the specified digit  	where -1 or --fast indicates the fastest compression method (less
 	compression)  and -9 or --best indicates the slowest compression
 	method (best compression).  The default compression level is -6
 	(that is, biased towards high compression at expense of speed)
and bzip2:
 	Set the block size to 100 k, 200 k ..  900 k when compressing.
 	Has no effect when decompressing.  See MEMORY MANAGEMENT below.
 	The --fast and --best aliases are primarily for GNU gzip
 	compatibility.  In particular, --fast doesn't make things
 	significantly faster.  And --best merely selects the default
 	behavior.

@_date: 2005-05-26 19:10:25
@_author: Atom Smasher 
@_subject: Minnesota court takes dim view of encryption 
one would have to go out of their way to find a current web browser that doesn't support SSL/TLS. it could then be argued (by aspiring dictators) that anyone with a current web browser has intent to commit a crime... or intent to make a purchase... or intent to check their bank statement... or intent to log into their office securely... but probably (in the eyes of some) they're plotting the revolution.

@_date: 2005-05-26 19:44:09
@_author: Atom Smasher 
@_subject: Filesystem Encrytion with GnuPG ?! 
speaking of encrypted file-systems, does anyone know what happened to

@_date: 2005-05-27 16:48:50
@_author: Atom Smasher 
@_subject: Choice of Algorithm 
elgamal isn't used because the implementation was broken. as far as DSA being "The Standard" i don't think it's any more standard than RSA, although it is more common.
the common and widespread use of DSA instead of RSA for signatures seems to be a historical artifact of RSAs patent which, until it expired, forced open source crypto applications to use something else.

@_date: 2005-05-31 14:35:43
@_author: Atom Smasher 
@_subject: Choice of Algorithm 
DSA is "a" standard, but by no means "the" standard.
i suspect that DSA would not have been pushed along nearly as far as it has if not for the patent on RSA. of course, if they wait much longer before updating DSA to officially support larger keys and hashes we'll start seeing more and more use of RSA with larger keys and hashes... if that happens, DSA will become a much less relevant standard.

@_date: 2005-11-29 14:25:42
@_author: Atom Smasher 
@_subject: Forging fingerprints/KeyID? 
how feasible would it be for an attacker to create a small (512 bit?) v4 key with the same key id as a target key (irrelevant of the size and algorithm of the target key)?
it may not be practical today to do this with a fingerprint collision, but i subscribe to the theory that it doesn't hurt to check the size and algorithm of keys before signing them.

@_date: 2005-09-22 07:24:10
@_author: Atom Smasher 
@_subject: legally binding digital sigs 
does anyone know what makes a digital signature legally binding (or not) under US law?

@_date: 2006-02-02 03:48:33
@_author: Atom Smasher 
@_subject: key signing article in 2600 
the current issue of 2600 (winter 05/06) has an article i wrote, titled "pgp Key Signing Observations - Overlooked Social and Technical it should be of interest to many on this list.

@_date: 2006-02-04 06:13:50
@_author: Atom Smasher 
@_subject: gpg on cron task 
why are you using php for a cron job?
signing or decrypting non-interactively requires that you either have a key without a passphrase, or a passphrase stored in a file. neither of these are secure.
tell us a little more about what you're trying to accomplish, maybe we can help you figure something out...

@_date: 2006-02-15 09:05:56
@_author: Atom Smasher 
@_subject: bad keysigning by Geotrust 
this is what happens when someone signs a key that shouldn't be signed. it's based on an x.509 (hierarchical) trust model, not a pgp (distributed) trust model, but the consequences are the same: a certification signature that should not have been issued was issued. this is basically "mallory" collecting a good signature on a fraudulent key.
 	Now here's where it gets really interesting. The phishing site...
 	is protected by a Secure Sockets Layer (SSL) encryption
 	certificate issued by a division of the credit reporting bureau
 	Equifax that is now part of a company called Geotrust.
The New Face of Phishing

@_date: 2006-01-05 06:20:44
@_author: Atom Smasher 
@_subject: hard-copy backups 
has anyone given any thought to what would be the difference between carefully and carelessly making hard-copy backups of secret keys?
i mean, it would be stupid to print a copy of ones secret key (with a weak passphrase) and leave it lying on a table next to a window. OTOH, a printed copy of a secret key (with a strong passphrase) would probably be "secure" in a 10 ton safe.
so how strong should a passphrase be when printing out a secret key in the first place? what are the pros/cons of hiding versus securing a hard-copy? what other factors should be considered?
bear in mind, these are philosophical questions with philosophical answers... i'm not looking for absolutes.
btw, if anyone prints out their secret key for backup, here's a few lines of shell code that will print a (non-cryptographic) checksum for each line. this way if you have to recover your key from hard-copy, it's *much* easier to find mistakes. an example of the output looks like this    -----BEGIN PGP PUBLIC KEY BLOCK-----	3675205589 37
   	3515105045 1
   mQILBECkOvYBEADJfImYQNznN0PJxkwcGysohePmujLVJTsA30WV9tXrb6+4L5ib	2185591463 65
   Ed9zHilbvXEgmrLJbG949H7yAwbNAaEjfnlqxBO31BmIJjUDmnXxe3FN98fuKIcq	3919870367 65
   bVn8aqPOvGGvsJaWDwLyFSG3UT60htHFuh0I0Nco7AB6WTXBrwV/9JDkiy7p0fK5	1339170163 65
the code works on bsd (zsh) but may have to be slightly modified for other operating systems or shells.
while read n
         echo -n "${n}\t"
         echo "${n}" | cksum

@_date: 2006-01-05 20:06:56
@_author: Atom Smasher 
@_subject: hard-copy backups 
and then keep the printout in a very safe place? a very well hidden place? very safe, well hidden place?
hehe... the problem then isn't remembering the passphrase, but remembering where you put the paper ;)

@_date: 2006-01-06 00:12:42
@_author: Atom Smasher 
@_subject: hard-copy backups 
hhmm.... the first part is analogous to physically or cryptographically securing data.
the second part, taken to a cryptographic extreme, leads me to consider making a one-time-pad of two or more parts, and leaving the parts under the care of different "trusted" persons and/or in different "secure" locations... that's a backup scheme i hadn't considered...

@_date: 2006-07-11 06:56:58
@_author: Atom Smasher 
@_subject: Keysigning challenge policies/procedures 
pgp Key Signing Observations: Overlooked Social and Technical Considerations there's a few sections in that article that might be of interest.

@_date: 2006-07-25 08:28:18
@_author: Atom Smasher 
@_subject: Driving licence as identification and accepting signed keys 
no matter what anyone tells you is or isn't adequate, you have to decide for yourself. this may help you figure it out -

@_date: 2006-07-25 08:42:41
@_author: Atom Smasher 
@_subject: Driving licence as identification and accepting signed keys 
other than adding an extra step to the process, what is gained by signing a challenge instead of encrypting a key certification (key signature) to the recipient's public key?
assuming that the primary key is the signing key, the protocol outlined in the link, above, does NOT demonstrate that the recipient controls the private half of the encryption subkey.
if, instead, the signed key is encrypted to the recipient, the key signature is only useful AFTER the recipient has proven their control of the private encryption key... this protocol simultaneously demonstrates their control of the primary key (used to self-sign the UID and encryption subkey) and email address.

@_date: 2006-07-25 17:36:40
@_author: Atom Smasher 
@_subject: Driving licence as identification and accepting signed keys 
what form of ID cannot be forged, stolen or otherwise compromised? if everyone had govt issued tattoos, or RFID implants, would that be 100% trustworthy? what about biometrics?
to make things worse, we can't even trust multiple forms of ID (passport + DL + credit cards + library card + employee ID, etc) because fake IDs are often obtained/established using other fake IDs.
there are even cases where people have spent years being married to someone and the spouse wasn't who they claimed to be. other than my immediate family, is there anyone whose identity i can *really* be 100% certain of? can i even trust my immediate family?
given this, it's really somewhat hopeless to think that you can absolutely verify the identity of someone you just met... but even if you can't absolutely verify (earning a level 3 signature) someone's identity, you can still issue a level one or two signature based on your level of confidence that the person is who they claim to be.
if you follow the protocol outlined in the article you can at least demonstrate that the person controls the private key and email address. since legal names are not designed to be 100% unique (i know of several people named "george bush") we can, to a certain extent, blur the line between real names and pseudonyms... in sci-fi we can often think of identification as an absolute, but in the real world it's blurry.
my own current [informal] policy is that only people i have personally known for extended periods of time can get a level 3 signature from me (and i recognize that even this is not 100% accurate). if i just meet someone at a key signing party and they show me some ID that earns a level 2 signature. in no way am i implying that this policy is right and everything else is wrong... that's just the way i'm currently doing it. everyone needs to figure it out for themselves, and do what makes the most sense to them.

@_date: 2006-06-12 08:55:56
@_author: Atom Smasher 
@_subject: Corrupting files 
why not pipe the encrypted output of gpg through a captain midnight secret decoder ring? because it doesn't add any real security.
i can't give an authoritative answer on the security of this, but i can say this... bear in mind that a pgp encrypted message consists of one or more packets containing "header" information, such as the encrypted session key, symmetric algorithm, compression algorithm etc. there will be one of these packets for each recipient the message is encrypted to.
following the header packets, are the [symmetrically] encrypted data packet(s) which, AFAIK, don't have any inherent structure.
the data in the header packets is fairly well structured... using a text editor, it would be easy to make a change towards the beginning of the armored message that would be very easy to discover and correct. that would result in no real added security.
assuming that the decrypted data (plain-text) is structured in some way, a change to the armored message would corrupt all data after the change is made (the session key would have to be recovered to get this far). if an attacker has recovered the session key, and the decrypted data starts off having a certain structure and then turns to garbage, an attacker should be able to figure out what part of the armored message is corrupt, and fix it with trail and error.
so, if this were to add any security at all, the first step would have to be editing part of the armored file that corresponds to the beginning of the encrypted data packets.
again, i can't say that this *would* add any security... but clearly there are several ways to do it that would *not* add any real security.
btw, what's the threat model where this is advantageous?

@_date: 2006-03-08 01:34:55
@_author: Atom Smasher 
@_subject: Problem removing a public key whose private key is gone 
you can remove any public key from your keyring with:
 	gpg --delete-key {key-id}
if you have any doubts about doing it right, or if you're having a bad day, backup the keyring before trying to delete anything from it.
if no one else has a copy of the key, you're done. if the key is in circulation among key-servers (and if you don't have a revocation certificate) you're beat.

@_date: 2006-03-13 13:58:12
@_author: Atom Smasher 
@_subject: Problem removing a public key whose private key is gone 
how many noobs upload new keys on the command-line? how many use "-a --export" and then copy-n-paste into a web interface?
if more noobs opt for the former, your idea would spare the world of some useless keys. i suspect that more noobs opt for the latter, in which case the idea wouldn't help much.
maybe there needs to be a sandbox keyserver where users can upload keys for practice, but it purges itself of keys >1 year old and doesn't sync with "real" keyservers. if such a keyserver existed, it should probably be the default keyserver in the preferences.

@_date: 2007-02-01 17:14:22
@_author: Atom Smasher 
@_subject: 'sensitive' designated revoker -- are the keyservers still aware? 
if that's a concern... bob wants to designate alice as a revoker, but bob [or alice] doesn't want to reveal that alice is the desiganted revoker, even if his key is revoked. the solution is for bob to generate a revocation certificate, encrypt it to alice, and send it to alice with instructions about if/when to publish it. this basically serves the same purpose, but doesn't necessarily reveal that alice was the designated a variation could break the revocation certificate into shares, requiring any number of "secret revokers" to assemble the revocation certificate.

@_date: 2007-06-17 11:48:14
@_author: Atom Smasher 
@_subject: RSA 1024 ridiculous 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
if you're paranoid about RSA, then there's no reason to go to ECC since the math behind it is still young and uncertain. while a 1024 bit RSA key ~may~ not be secure for a long time, it's old age is due only to computing horsepower, not a "break" in the math behind it. as such, a larger RSA key buys time... and only time will tell if it buys "enough" time for a particular need.
gpg does support RSA-2048/SHA-256 (or even RSA-4096/SHA-512) which is what i've been using for a while now. i'll sign this email with RSA-2048/SHA-256 (my default on this key) just to show what it looks like. it's a big signature block, but not ridiculous and on a reasonably powerful computer it's hardly a noticeable delay to work with such keys.

@_date: 2007-06-18 00:04:11
@_author: Atom Smasher 
@_subject: RSA 1024 ridiculous 
regardless of the size of the message... if it's being signed/verified then you're signing/verifying a hash. if it's being de/encrypted you're de/encrypting a session key.
for all practical purposes the overhead of using larger keys and hashes doesn't get worse with larger messages.

@_date: 2007-06-18 00:23:21
@_author: Atom Smasher 
@_subject: RSA 1024 ridiculous / RSA 8192 sublime, and, possible with gnupg. 
maybe the above text, or something like it, should be included in the code as a comment just above the lines that get changed to increase the key

@_date: 2007-06-20 10:29:42
@_author: Atom Smasher 
@_subject: RSA 4096 ridiculous? 
just remember moore's law... a few years ago i got the cheapest palm-pilot i could find (original zire, ~$85). about a year later i again got the cheapest palm-pilot i could find (zire 22, ~$75). i spent $10 less, and the zire-22 runs circles around the original zire, most noticeably when i generate OPIE passwords.

@_date: 2007-11-02 15:27:59
@_author: Atom Smasher 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
1) weak passphrase on the key
2) no passphrase on the key
 may be more useful than it seems, if a key is very rarely used and there's a risk that the passphrase will be lost/forgotten. this would allow a way to distribute the secret to trusted parties and/or hidden places without a passphrase on the key.
of course the real questions: is there a need for that? would anyone use

@_date: 2007-10-28 19:51:51
@_author: Atom Smasher 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
seems like reasonable things to do...
i wouldn't count on it, but there might be a chance that you can read from it using dd, copy it to a file, then try to recover data from that. worth a shot, but in all likelihood, you're beat.
if that was feasible, pgp wouldn't be worth much.
other thoughts...
in theory, if you're *really* using a strong pass-phrase, you can publish your private key in a public place and rest secure in the knowledge that no known technology can break your 100+ character pass-phrase... and if a hard drive or several go up in smoke you can recover a copy from google's cache ;)
one thing i've thought about is using a one-time-pad to break a private key into 2 (or more) shares. then send (using secure channels) each share to one or more trusted persons who don't know each other. maybe put one of the shares in a bank safe. if all of your hard drives explode on the same day you can collect the shares and reconstruct your key.

@_date: 2007-10-28 23:05:55
@_author: Atom Smasher 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
and then inevitably forget what you used for the *really* secure 100+ character pass-phrase, because you never use it.
see above.
but this has me thinking... why not combine the "hidden in plain sight" part with the encrypted part using steganography... use a reasonably strong passphrase ("reasonable" depends on the needs of the end user) for your secret key, then hide it in a JPG and post it in a public place. if you use `outguess` (i'm not sure about other tools) you can even require a pass-phrase to get the data in/out of the image file, not to mention that outguess provides a plausible deniability feature.
i know... to many people on this list steganography, like one time pads, is more of a toy than a real crypto solution, but compared to posting a secret key in a public (or even an insecure non-public) place i'd say it's "better than nothing".
even with a reasonably strong pass-phrase i wouldn't want to walk around with my secret key on a flash-drive with my physical keys, but hidden in a JPG of family/friends/pets it would be easily overlooked if i lost possession of the flash-drive. and if all of my drives picked the same day to die, i'd have a recoverable copy of the secret key.

@_date: 2007-10-28 23:42:48
@_author: Atom Smasher 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
used for general purpose crypto; yeah, it sucks. as you mentioned the training and infrastructure required to deploy it make it impractical. but the only skill required to hold a share of a secret is to not lose it, and maybe to destroy it if needed. training and infrastructure issues don't 1) there are some very simple OTP applications that let you use your favorite random sources (lava-lamp, cosmic-ray detector, CCD camera watching traffic, etc) and generate cipher text. maybe someone is using an RSS from slashdot as a random source, but it's just as easy to use a decent source of entropy.
2) AFAIK the shamir secret sharing protocol is great in theory, but there just aren't any practical ways to use it (read: applications). i really don't want to do all that math by hand any time a want to break a secret into shares, or reassemble them.
i wouldn't generally advocate a vernam cipher for encrypting messages, but i think it is the best real-world-practical way to do secret sharing (at least until someone builds an application that ~uses~ a real secret sharing algorithm). the only practical drawback is that it doesn't support thresholds... if one share is missing the secret cannot be recovered. the only way around this is to make sure that each share is held by more than one person.

@_date: 2007-10-29 00:00:17
@_author: Atom Smasher 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
responding to self...
now this has me thinking.... take a picture with your digital camera; hide your secret key in it; put the image back on the camera's flash-card.
no one would ever think of looking for your key there. unless they're reading this thread. oh-well.

@_date: 2007-10-29 00:27:48
@_author: Atom Smasher 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
i wouldn't be any more concerned than i am now, with non-hidden cipher-texts coming in/out of my mailbox.
paranoia, maybe...? or just making sure that my secret key isn't low hanging fruit.
i'll agree that it's somewhat irrational, but it does give me a warm fuzzy feeling that my 2048/4096 bit secret keys are not only encrypted with a reasonably strong pass-phrase, but also stored on an encrypted file system and not publicly available, and all backup copies are also double regarding my faith in AES, just check out the preferences on my public

@_date: 2007-10-29 00:35:06
@_author: Atom Smasher 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
would that be the same PGP(tm) Corporation that, last i checked, made source code available for review but only licensed the use of pre-compiled binaries? i hate to sound paranoid (hhmm, actually i don't mind anymore) but where's the open source application(s) that do that? especially if it's so easy.

@_date: 2007-10-29 01:53:00
@_author: Atom Smasher 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
not having a particular aptitude towards higher math, and not being fluent at programming C are more reasonable criticisms of me. i have a very good understanding of most crypto primitives, protocol wise, but i often have to take it for granted the math does what it's supposed to.
i can pick from a few one time pad applications that do pretty much exactly what i want, and produce real-world verifiably and provably secure output. i'm not about to write an application that implements a secret sharing protocol, but if someone else writes one that's open source i'd be interested in checking it out.
in the meantime, i consider the vernam cipher a very reasonable and practical way to implement secret sharing.
you've mentioned, and i've agreed with you, several reasons why OTP sucks as an encryption algorithm. but other than referring to it as "James Bond gadgetry" you haven't given any reason not to use it for secret sharing, other than your own flavor of warm and fuzzy which seems to be that another algorithm was designed just for secret sharing and 4th graders can use it.
after a few minutes of googling - i'll check it out.
still, the _only_ reason not to use OTP for secret sharing is that it doesn't work as a threshold (t,n) scheme. the only way around that is to make sure that each share is held by more than one player... with shares A B and C; alice holds shares AB, bob holds shares BC, charlie holds shares AC. if any one of them gets hit by a bus, the secret can still be recovered. problem solved.
maybe some 4th graders can understand the math behind shamir's secret sharing but *i* can understand (and prove and verify) the math behind vernam's cipher... and understanding the math certainly adds to the warm and fuzzy feeling.

@_date: 2007-11-01 00:09:13
@_author: Atom Smasher 
@_subject: A note to Atom Smasher [WAS: Subkey DSA signature changes...] 
don't try this at home - it's an ugly hack, there's really no reason you should ever have to do it, and last i checked it didn't even work with gpg since 1.2.4.
it's been a while since i've dug through the RFC...
RFC2440:11.2. Key IDs and Fingerprints;  A V4 fingerprint is the 160-bit SHA-1 hash of the one-octet Packet Tag, followed by the two-octet packet length, followed by the entire _Public_ Key packet starting with the version field.
fingerprint are calculated using just the public parts of the [sub]key.

@_date: 2008-08-20 10:53:37
@_author: Atom Smasher 
@_subject: Securely delete files... 
you wouldn't use a hammer to put in screws, would you? there are tools for deleting files, but gpg isn't in the list. start with this one - or google for `secure delete` and add the operating system & file system that you're concerned about.
be aware that some file systems make the job of ~really~ deleting files difficult or impossible.

@_date: 2008-08-20 11:57:35
@_author: Atom Smasher 
@_subject: Securely delete files... 
this might be a better link if you're looking for a tool -

@_date: 2008-08-21 10:20:03
@_author: Atom Smasher 
@_subject: Securely delete files... 
that wouldn't surprise me, but is there a reference for it?
i would think the hard part would be finding all (enough?) of the pieces. was the platter actually shot? or just the case?
even then, some smart-ass will eventually come along and demonstrate how data can be recovered, even from the lump of metal ;)

@_date: 2008-08-21 10:30:21
@_author: Atom Smasher 
@_subject: Securely delete files... 
encrypted disks, and some random passes from dban makes me feel warm and fuzzy when i give away my old disks to computer reuse/recycle places.
to paraphrase from (IIRC) the diceware page, if you're disks are sensitive enough that you have to melt them with thermite when you're done with them, a more immediate problem is how well are you paying your armed guards ;)

@_date: 2008-08-21 16:27:01
@_author: Atom Smasher 
@_subject: Securely delete files... 
When Hard Drives Attack
also check out the Related Videos.
on the same topic, i was also thinking that cooking a HD above the platters' CP would also require adequate ventilation, and may render an oven not usable for food.

@_date: 2008-08-21 13:54:19
@_author: Atom Smasher 
@_subject: Securely delete files... 
i'll play the other side...
depending on your OS, FS, and choice of file-shredder: yes. you can make it impossible for anyone without an electron microscope to get you deleted but... are there copies of it in swap? temp copies by other names? that's an area where disk encryption wins. also check out thc's sfill.
to see for yourself, make a file, delete it the usual way, and try to find it with foremost (or similar). chances are very high that you will find what you're looking for. then, with another file, user a file-shredder and look again with your favorite data recovery tool. can you find the file?
repeat until you're happy with the results. a more in-depth analysis of the disk would require physical disassembly of the disk and tools that most home users just don't have access to. so, if you put a good effort into finding shredded files with software and can't do it, then it's reasonably safe to say that no one else can, either.
or how many layers of foil your hat is lined with ;)

@_date: 2008-08-22 10:13:56
@_author: Atom Smasher 
@_subject: Securely delete files... 
that's basically what sfill (part of the srm package from thc) does, per partition. the other way of doing basically the same thing:
   dd if=/dev/urandom of=/partition/tmp-file ; rm /partition/tmp-file
although sfill also scrubs the inodes, IIRC. that would make it hard to figure out the [former] names and [former] locations of the scrubbed repeat as necessary.
of course that's no substitute for strapping high explosives to the hard drive and blasting pieces of the platter into orbit, which it seems some people on this list would consider the only acceptable solution ;)

@_date: 2008-08-24 01:48:01
@_author: Atom Smasher 
@_subject: Securely delete files... 
test it!
fill a file with a few hundred copies of a random hash. as a control, delete the file the normal way and try to find it on the disk (i'd expect you can find it). repeat with a different hash, shred the file, and try again to find it on the disk.

@_date: 2008-02-28 21:52:22
@_author: Atom Smasher 
@_subject: Signing people with only one form of ID? 
ever seen a turkish passport? the real ones look like bad fakes. i'm sure that's not the only country that issues fake looking passports.
personally, the only way i'd issue a level 3 signature on a key is if i know the person in some capacity. if i just meet someone at a keysigning party the best they could hope for is a level 2 signature.

@_date: 2008-07-03 15:52:05
@_author: Atom Smasher 
@_subject: Recovering Encrypted Zip 
i haven't downloaded the file, but lemme guess... you encrypted a zip file with gpg? then you lost access to the secret key?
game over. you lose.
to put it in perspective -

@_date: 2009-03-04 12:04:33
@_author: Atom Smasher 
@_subject: surrendering one's passphrase to authorities 
i would think the FBI (presuming that they're involved) would be able to brute-force a pass-phrase in less than a year. they have the disk, so in all likelihood the weakest link in the chain is the pass-phrase (and that's assuming that there's no cache/tmp files that are not encrypted). does anyone know details about PGPDisk's string-to-key algorithm(s)?
kid porn makes this an interesting edge case, because people (judges and juries included) are more likely to ignore the established protections of the 5th amendment (which, IMHO, should apply even to alleged scum or it's meaningless). my suspicion is that authorities have already decrypted the contents of the disk (unless the guy was using a *really* strong pass-phrase) and the case is being pushed to make a precedent out of "sometimes it's ok to ignore the 5th amendment".

@_date: 2009-03-04 13:11:31
@_author: Atom Smasher 
@_subject: surrendering one's passphrase to authorities 
most people don't use pass-phrases that strong. in any case, we're talking about something that can realistically be broken in a reasonable amount of time (compared to several times the age of the universe) using real-world technology, not like trying to crack a messages that was intercepted on the wire, and encrypted with 4096 RSA or a 256bit twofish.

@_date: 2009-05-01 15:58:47
@_author: Atom Smasher 
@_subject: New results against SHA-1 
so... when is the open-pgp spec moving beyond SHA1 hashes to identify public keys? what's next? will it have to be a bigger hash?

@_date: 2011-02-25 03:39:10
@_author: Atom Smasher 
@_subject: Rebuilding the private key from signatures 
if an attacker has two messages signed with DSA, and they happen to use the same value of "k" then it's trivial to recover the private key.
a random "k" is the achilles heel of DSA and elgamal (and their ECC derivatives). if "k" is truly random (and reasonably large), the chances of getting a duplicate "k" approaches zero... if "k" is not reasonably large or there's a bias that can produce duplicate "k"s with the same value, you're hosed.

@_date: 2011-01-03 04:35:18
@_author: Atom Smasher 
@_subject: Encryting both file contents and file name with GnuPG 
just hash the file-name.
  SHA1 ("secret-1.txt") = d422b71f32b06168db114638fa9778c42d7d0f3c
  SHA1 ("secret-2.txt") = d0ab019ba1975dab7c100bc5b4efa020bcd86a5d
  SHA1 ("secret-3.txt") = 753b2bd68f7ff5fc44f9142245039375a3a5b2f8
use the hash as the encrypted file name. feel free to add a dot-suffix.
keep that reference in a db or text file and you can recover the original filename easily.
if you're concerned that the name and/or format of the original file names are too predictable, concatenate the filename with a "secret" before   SHA1 ("secret-1.txt:secret") = df3d0b4eb1034f7392c60baec6137c62a2d4579a
  SHA1 ("secret-2.txt:secret") = 39238faa73f2472e253d5f096b28c8b31c8e8a00
  SHA1 ("secret-3.txt:secret") = 9450a1f9cd93a47c8d3621cb7fc3ca0ec1df47b7

@_date: 2011-01-03 08:23:38
@_author: Atom Smasher 
@_subject: Encryting both file contents and file name with GnuPG 
depending on your [*nix or cygwin] shell, it ~can~ do that...
gpg -o $(sha1 -qs filename) -e filename -r keyid
the exact command is system dependent; the example above would basically work as-is on freebsd with zsh or bash. cygwin or linux would be *slightly* more complicated. the idea is that shells like zsh and newer versions of bash use '$(...)' as a form of command substitution. older shells (bash & bourne) use back-quotes but the concept is the same. all shells have some form of variables...
gpg -o ${file_name_hashed} -e filename -r keyid
in any case, if you also want to populate a db of some sort, whether a flat-file or DBMS, you'll probably need three lines in a script:
  1) calculate the hash
  2) encrypt the file -- gpg -o ${file_name_hashed} -e filename -r keyid
  3) add an entry to a db
the first line creates a variable (eg, $file_name_hashed) and the next two lines refer to it.
just make sure you're hashing the file-NAME, not it's contents. of course, if you don't lose your db, then there's nothing wrong with hashing the contents, or even a counter or random string. hashing the file-NAME is just an idea that makes recovery of the db possible if you know the format and range of the file-names (and any secret that may be used). the real trick is to just do something secure and consistent... sha1 does the job.

@_date: 2011-09-02 13:41:47
@_author: Atom Smasher 
@_subject: Decrypting WikiLeaks insurance file 
i'm not sure about TrueCrypt, but OpenSSL usually leaves this clue...
 	$ strings file.enc | head -1
 	Salted__

@_date: 2013-12-23 15:19:32
@_author: Atom Smasher 
@_subject: How did the NSA hack our emails? (Numberphile videos) 
How did the NSA hack our emails?
NSA Surveillance (an extra bit)

@_date: 2013-07-26 10:29:30
@_author: Atom Smasher 
@_subject: Why trust gpg4win? 
implicit in your question, you seem to think windows is secure against govt spying...
if you run windows, then gpg4win should be the least of your security windows doesn't get "infected" with spyware... it *IS* spyware. MS has long been known to be in bed with govt spy agencies. *ANY* software running on windows is vulnerable to govt (and other 3rd party) spying.

@_date: 2014-01-05 03:13:17
@_author: Atom Smasher 
@_subject: NSA seeks to build quantum computer that could crack most types 
worried? probably not.
concerned? maybe.
planning ahead? probably.
Post-quantum cryptography
