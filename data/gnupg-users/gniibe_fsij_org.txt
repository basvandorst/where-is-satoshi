
@_date: 2012-06-06 11:37:06
@_author: NIIBE Yutaka 
@_subject: scdaemon needs restarting after removing OpenPGP smartcard 
My changes are basically two areas in master branch.
(1) Fix of ccid-driver.c for partial support of extended APDU.
    This was needed for Gnuk (< version 0.16).
(2) Pinpad input enhancement for passphrase modification.
Besides, I know there is a problem in scd_update_reader_status_file,
which was repoprted the other day, but I haven't fixed yet.  I think
that access to the object of "struct slot_status_s" should be locked.
I'll lock into those for backporting.

@_date: 2012-06-08 13:38:26
@_author: NIIBE Yutaka 
@_subject: scdaemon needs restarting after removing OpenPGP smartcard 
I am currently backporting the SCD changes in master branch to 2.0.
For this particular issue, I believe that it has been fixed by the
following commit, which was included in 2.0.18 already.
commit 576de6e539646f021dafff8d4e3327c115a51ad4
Author: Werner Koch     Fixed problem with unplugging card readers.
    From Grant Olsons's mail to gnupg-devel
      This is three-quarters NIIBE and one-quarter me, but I though it would
      be easier to have a single complete patch that applies to
      STABLE-BRANCH-2-0 than two patches floating around.
      This is basically NIIBE Yatuka's patch here:
            Plus another check that closes down the reader explicitly if we get a
      SW_HOST_NO_READER error, so that an unplugged reader doesn't hold onto
      the first slot, preventing us from getting to the active plugged reader.

@_date: 2015-04-02 11:12:48
@_author: NIIBE Yutaka 
@_subject: decrypt luks with gnupg Card: determine if cardreader has pinpad 
You can use the output of lsusb -v.
If the card reader has pinpad capability, you can find something like:
        bPINSupport             3  verification modification
Well, I don't think pcscd (and libccid) is required if your gnupg is
new enough (2.0.23 or later).

@_date: 2015-04-02 11:40:39
@_author: NIIBE Yutaka 
@_subject: What is 'CA fingerprint 1' on Smartcard 
Well, I can't find a key with this fingerprint on key servers.
It seems that it's intended to be hold a fingerprint of OpenPGP, but
it is not clear what/how this fingerprint is used for.
using these data objects.  Even, I couldn't imagine valid usage of
these data objects.
Besides, I don't understand the reason why this data object was filled
by a specific value when shipped.
Sorry for not useful information, but, those are all I could say.
Still, it would make sense to share this info.

@_date: 2015-04-03 09:10:29
@_author: NIIBE Yutaka 
@_subject: Anonymous payment for hardware tokens 
Hello, George,
This message is a reply to the your post in February.
Just in case if you can visit Boston, FST-01 with NeuG 1.0.1c is now
available as GNU Gear: It comes with micro SD card which contains the copy of repositories at
git.gniibe.org, so that you can access to the source code with no
connection of the Internet.
Since the firmware installed is NeuG (instead of Gnuk), you need to
compile and install Gnuk by yourself, if you want.  But, I'm sure that
you will also want one with NeuG.
I don't know if it is possible to join FSF as an associate member
anonymously, but I'm sure you can get it anonymously by cash when you
visit the FSF office in Boston.
This arrangement is exactly intended for those who care, like you.
Although I don't know if it works for you, I hope so.

@_date: 2015-04-14 09:23:12
@_author: NIIBE Yutaka 
@_subject: Unusable secret key (adduid) 
I don't understand the reason why you could say "card works perfectly"
Please give us the output of 'gpg2 --card-status'.  If it is nothing,
it means that your card **doesn't** work well for GnuPG.
Please check your gpg-agent works well not interfered by
gnome-keyring.  If it's real gpg-agent, you can get the output like:
  $ gpg-connect-agent "help SCD" /bye
  # SCD   #
  # This is a general quote command to redirect everything to the
  # SCdaemon.
  OK
Sorry, I don't understand this sentence.  What's "it"?  Could you
please elaborate if this matters for your bug report?  I think that it
would be better to show us bigger picture to share your situation.
Sorry, no, it means that OpenPGP secret block of your private key is
available on your host PC.  It doesn't mean card is present or secret
key is on your smartcard.
If possible, please give us complete session log of yours, not
removing information by your interpretations (or hope).

@_date: 2015-04-14 10:06:33
@_author: NIIBE Yutaka 
@_subject: can not decrypt file suddenly 
Please let us know your configuration.  I think that it's
~/.gnupg/gpg.conf on Fedora.
Please include the version output of gpg --version in your report.
Is it complete session log of yours?  I mean, GnuPG should ask you
passphrase here.
Possible case: If you enable gpg-agent by the configuration of
use-agent, passphrase handling (and others) is done by gpg-agent.  And
when your gpg-agent doesn't work and returns "", and it is failed and
caused "bad key" error.  If so, please try with --no-use-agent.  To
investigate what's going on with gpg-agent, please also let us know
the output of:
    $ echo $GPG_AGENT_INFO

@_date: 2015-04-14 13:41:23
@_author: NIIBE Yutaka 
@_subject: can not decrypt file suddenly 
I see.
Thank you for the log.
Here, it seems for me that your file (j.pgp) is malformed.
Type=9 is the encrypted data packet, but its length is 0.
Since OpenPGP format for the encrypted data packet begins with a
block-size of random bytes.  So, length 0 should not be happened.
I think that this is the cause of your trouble.
Note that the length of the encrypted data packet is data before
decryption, passphrase doesn't matter here.

@_date: 2015-04-15 10:58:55
@_author: NIIBE Yutaka 
@_subject: can not decrypt file suddenly 
I don't think it's helpful and there's no such command line interface.
When a file were corrupted in such a way, blocks (of encrypted
content) were gone somewhere in the filesystem (not within a file).
You can examine the content of file by gpg --list-packets, or you can
see it by the command hd (or od), but I think that all you will get
is the wrong information when it's corrupted.
For applications (like gnupg), there is no way to recover such a
corrupted files.
Please fix your file system, by a tool like fsck, or debugfs.

@_date: 2015-04-23 10:39:25
@_author: NIIBE Yutaka 
@_subject: GnuPG 2.1.3 Fails to Compile OS X 
I think that there is a minor GnuPG problem here (not MacOS).
I haven't located the bug yet, but I could see the problem of
en at quot.po, when I build with git repo having old en at quot.po.
Note that in the release, we have po/en at quot.po which is correctly
updated and po/en at quot.gmo which is correctly generated.
In the git repo, we have an entry of po/en at quot.po in the .gitignore,
so, I think that it is not maintained in the repo.  When a developer
happens to have old po/en at quot.po, it will be merged by msgmerge and
it would result fuzzy entries with mismatches of newline.
For me, removing po/en at quot.po (so that it will be rebuild from
gnupg2.pot), it works fine.

@_date: 2015-04-23 16:34:09
@_author: NIIBE Yutaka 
@_subject: GnuPG 2.1.3 Fails to Compile OS X 
In my theory (which might be wrong), the scenario is like this:
  (1) A developer has his own en at quot.po for his working directory.
  (2) Werner periodically does POT and PO update (usually before the
      release) to the repository.
  (3) A developer pull from the repository.
  (4) When a developer invokes 'make', it tries to update en at quot.po
      by msgmerge (although we have a special rule in Rules-quot).
      Then, updated en at quot.po may have fuzzy entries.
If this is correct, I think that following patch fixes the problem.
diff --git a/po/Makefile.in.in b/po/Makefile.in.in
index eb68ea2..4f2849a 100644
--- a/po/Makefile.in.in
+++ b/po/Makefile.in.in
 -56,8 +56,7  XGETTEXT_ =  XGETTEXT_no =  XGETTEXT_yes =  XGETTEXT = $(XGETTEXT_$(USE_MSGCTXT))
-MSGMERGE = msgmerge --previous
-MSGMERGE_UPDATE =  --previous --update
+MSGMERGE =  --previous
 MSGINIT = msginit
 MSGCONV = msgconv
 MSGFILTER = msgfilter
 -192,9 +191,7  $(srcdir)/$(DOMAIN).pot:
 $(POFILES): $(srcdir)/$(DOMAIN).pot
 	 $@ | sed -e 's,.*/,,' -e 's/\.po$$//'`; \
 	if test -f "$(srcdir)/$${lang}.po"; then \
-	  test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
-	  echo "$${cdcmd}$(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot"; \
-	  cd $(srcdir) && $(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot; \
+	  $(MAKE) $${lang}.po-update; \
 	else \
 	  $(MAKE) $${lang}.po-create; \
 	fi

@_date: 2015-08-11 12:10:28
@_author: NIIBE Yutaka 
@_subject: Card reader success report (openpgp card v2.1) 
Thank you for your post.
I think that USB vendor ID and product ID are:
Please confirm that and please let me know IDs for those new products
of SCM SPR332 and Reiner SCT cyberjack go plus.
That's because I maintain pages:
        ... along with the scdaemon implementation.
Besides, if you can include information of your operating system and
its version, it helps other users.

@_date: 2015-12-01 12:13:25
@_author: NIIBE Yutaka 
@_subject: How important are Admin PIN and Passphrase in this scenario? 
I agree your argument in general.  I think that it depends on the
smartcard implementation, its strength against physical attacks,
and how you protect/detect your smartcard against possible steal.
If the implementation stores your private key as raw data with no
encryption (and use pin/passphrase only for authentication), complex
pin/passphrase doesn't matter, perhaps.
When the implementation stores your private key encrypted by
pin/passphrase and the hardware is relatively weak by physical
attacks, pin/passphrase with enough entropy still makes sense
Suppose I have a practice to use my token everyday and I always make
sure having it, so that I can know its non-existence.  Then, when I
lost my token, if I could believe that it would take a week (to break
the token phisically + to break encryption by brute force) by
complex passphrase, it makes sense for me.

@_date: 2015-12-01 13:16:51
@_author: NIIBE Yutaka 
@_subject: scdaemon lockup with Yubikey NEO 
It is not reproducible for me.  I'm using OpenSSH 6.9p1.
Do you have multiple gpg-agent when you encounter failure?  Or
multiple scdaemon?

@_date: 2015-12-02 12:07:12
@_author: NIIBE Yutaka 
@_subject: Provide user PIN to gpg-agent? 
Please note that I don't have any experience like that, and I don't
generally recommend such a usage.
In general, we can provide a special application specific pinentry
program for such a special purpose.
In GnuPG 2.1.x, there is allow-loopback-pinentry option.  When enabled
it by .gnupg/gpg-agent.conf or as an argument invoking gpg-agent, we
can do something like:
    gpg-connect-agent \
        "OPTION pinentry-mode=loopback"
        '/definqfile PASSPHRASE /tmp/passphrase-for-smartcard' \
        "SCD CHECKPIN " /bye
having a file /tmp/passphrase-for-smartcard, where  is the one
in the output of 'gpg --card-status' like:
Substitute  by D276000124010200F517000000010000.
Please try.

@_date: 2015-12-02 16:16:08
@_author: NIIBE Yutaka 
@_subject: scdaemon lockup with Yubikey NEO 
I don't use Yubikey.??I use OpenPGPcard with card reader and Gnuk
Token.??If you think your problem is Yubikey specific, it would be
good to ask Yubikey community.
I keep the SSH session when I remove my token, re-insert it and.??I
also tried with the setting of 'ForwardAgent yes' in .ssh/config and
used SSH to another remote host.??But I can't reproduce.
To debug your situation, please add 'verbose' in your
.gnupg/gpg-agent.conf and create a file .gnupg/scdaemon.conf with:
debug-level	guru
log-file	/tmp/scd.log
Before your experiment, please set your PIN by default one, because
the scd.log file will include your PIN information.

@_date: 2015-12-02 22:26:29
@_author: NIIBE Yutaka 
@_subject: scdaemon lockup with Yubikey NEO 
Thank you very much.
There are three connections from SSH:
? (1) handler 0x557c807ec310 for fd 8
? (2) handler 0x557c807eebb0 for fd 10
? (3) handler 0x557c807eeb80 for fd 10 (fd 10 re-used)
??????????????token removed
???(1) ------------------>
??????????????????******---- conflicting use
There are two connections from gpg-agent:
? (a) chan_7 from (1)
? (b) chan_9 from (3)
??????????????token removed
?????(a) ------------------>
???????????????????******---- conflicting use
The connection from SSH remains in gpg-agent by some reason.??This is
the reason why the connection from gpg-agent remains in Scdaemon,
which results conflicting use.
Anyway, when Scdaemon detects card/token removal, it could finish
existing connection(s).??I'll consider fixing this.
I don't know the exact reason why connection from SSH remains, though.
This is GnuPG issue, specifically, Scdaemon issue.

@_date: 2015-12-03 11:54:27
@_author: NIIBE Yutaka 
@_subject: scdaemon lockup with Yubikey NEO 
Thanks for your patience.
Not needed.  It's fixed in master.  I'm going to backport this to 2.0.
The commit is: f42c50dbf00c2e6298ca6830cbe6d36805fa54a3
Well, I found another bug with PC/SC.  Because of this bug, it is
sometimes (not always) possible for gpg not to raise the error of
"Conflicting usage".  So, it would be a workaround to disable internal
ccid driver of GnuPG and to use PC/SC.  (I don't recommend, though.)
Here is a backport patch which I'm considering to apply to 2.0.
Thank you again for your cooperation fixing this long standing bug.
diff --git a/scd/apdu.c b/scd/apdu.c
index f9a1a2d..acca799 100644
--- a/scd/apdu.c
+++ b/scd/apdu.c
 -3136,7 +3136,13  apdu_close_reader (int slot)
     return SW_HOST_NO_DRIVER;
   sw = apdu_disconnect (slot);
   if (sw)
-    return sw;
+    {
+      /*
+       * When the reader/token was removed it might come here.
+       * It should go through to call CLOSE_READER even if we got an error.
+       */
+      log_debug ("apdu_close_reader => 0x%x (apdu_disconnect)\n", sw);
+    }
   if (reader_table[slot].close_reader)
     return reader_table[slot].close_reader (slot);
   return SW_HOST_NOT_SUPPORTED;
diff --git a/scd/app-common.h b/scd/app-common.h
index e48db3c..ac2c2e9 100644
--- a/scd/app-common.h
+++ b/scd/app-common.h
 -44,11 +44,6  struct app_ctx_s {
      operations the particular function pointer is set to NULL */
   unsigned int ref_count;
-  /* Flag indicating that a reset has been done for that application
-     and that this context is merely lingering and just should not be
-     reused.  */
-  int no_reuse;
   /* Used reader slot. */
   int slot;
diff --git a/scd/app.c b/scd/app.c
index 742f937..380a347 100644
--- a/scd/app.c
+++ b/scd/app.c
 -190,9 +190,12  application_notify_card_reset (int slot)
   /* FIXME: We are ignoring any error value here.  */
   lock_reader (slot, NULL);
-  /* Mark application as non-reusable.  */
+  /* Release the APP, as it's not reusable any more.  */
   if (lock_table[slot].app)
-    lock_table[slot].app->no_reuse = 1;
+    {
+      deallocate_app (lock_table[slot].app);
+      lock_table[slot].app = NULL;
+    }
   /* Deallocate a saved application for that slot, so that we won't
      try to reuse it.  If there is no saved application, set a flag so
 -265,16 +268,6  select_application (ctrl_t ctrl, int slot, const char *name, app_t *r_app)
         return gpg_error (GPG_ERR_CONFLICT);
       }
-  /* Don't use a non-reusable marked application.  */
-  if (app && app->no_reuse)
-    {
-      unlock_reader (slot);
-      log_info ("lingering application `%s' in use by reader %d"
-                " - can't switch\n",
-                app->apptype? app->apptype:"?", slot);
-      return gpg_error (GPG_ERR_CONFLICT);
-    }
   /* If we don't have an app, check whether we have a saved
      application for that slot.  This is useful so that a card does
      not get reset even if only one session is using the card - this
 -506,15 +499,7  release_application (app_t app)
   if (lock_table[slot].last_app)
     deallocate_app (lock_table[slot].last_app);
-  if (app->no_reuse)
-    {
-      /* If we shall not re-use the application we can't save it for
-         later use. */
-      deallocate_app (app);
-      lock_table[slot].last_app = NULL;
-    }
-  else
-    lock_table[slot].last_app = lock_table[slot].app;
+  lock_table[slot].last_app = lock_table[slot].app;
   lock_table[slot].app = NULL;
   unlock_reader (slot);
 }

@_date: 2015-12-08 17:26:23
@_author: NIIBE Yutaka 
@_subject: Error message "gpg: Can't check signature: Broken public key" 
I don't think that GnuPG frontend or gpg-agent doesn't emit this
It could be libgcrypt which generates this error.  EdDSA key is
represented by a point on the Ed25519 curve.  When the point is not on
the curve (the key is invalid), it complains by this error.
I validate your e-mail by the key of 0x1712BC461AF778E4 with no error.
So, I don't think there is a problem in your key.  The local copy
of your public key in his computer would be a problem.

@_date: 2015-12-22 00:06:18
@_author: NIIBE Yutaka 
@_subject: gpgkey2ssh and Ed25519 key 
When you configure your gpg-agent properly (for your key), you can use
the SSH tool of ssh-add with option -L to show your public key in SSH
Thank you for using new feature.  I know that gpgkey2ssh is still
useful in some cases, but I think that you don't need it because we
can use 'ssh-add -L'.
Here is an example session to configure GnuPG for Ed25519 key.  In
this example, I'm adding an authentication subkey for me.  Here we go.
I invoke gpg 2.1.x with --edit-key option specifying my name.
An option of --expert is required for Ed25519 key, since it's
not yet in the OpenPGP standard.
    $ gpg2 --expert --edit-key gniibe
    gpg (GnuPG) 2.1.10; Copyright (C) 2015 Free Software Foundation, Inc.
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.
    Secret key is available.
    sec  rsa2048/4CA7BABE
         created: 2010-10-15  expires: never       usage: SC
         card-no: F517 00000001
         trust: ultimate      validity: ultimate
    ssb  rsa2048/084239CF
         created: 2010-10-15  expires: never       usage: E
         card-no: F517 00000001
    ssb  rsa2048/5BB065DC
         created: 2010-10-22  expires: never       usage: A
         card-no: F517 00000001
    [ultimate] (1). NIIBE Yutaka     [ultimate] (2)  NIIBE Yutaka These are my keys (on smartcard, in this case).  I'm adding a subkey
of Ed25519 by the subcommand of "addkey".
    gpg> addkey
    Secret parts of primary key are stored on-card.
    Please select what kind of key you want:
       (3) DSA (sign only)
       (4) RSA (sign only)
       (5) Elgamal (encrypt only)
       (6) RSA (encrypt only)
       (7) DSA (set your own capabilities)
       (8) RSA (set your own capabilities)
      (10) ECC (sign only)
      (11) ECC (set your own capabilities)
      (12) ECC (encrypt only)
      (13) Existing key
    Your selection? 11
I select "(11) ECC (set your own capabilities)" for authentication
key.  Then, put the capability of "Authenticate"...
    Possible actions for a ECDSA key: Sign Authenticate
    Current allowed actions: Sign
       (S) Toggle the sign capability
       (A) Toggle the authenticate capability
       (Q) Finished
    Your selection? s
Removed "Sign" capability, by typing "s" and RETURN.
    Possible actions for a ECDSA key: Sign Authenticate
    Current allowed actions:
       (S) Toggle the sign capability
       (A) Toggle the authenticate capability
       (Q) Finished
    Your selection? a
Added "Authenticate" capability, by typing "a" and RETURN.
    Possible actions for a ECDSA key: Sign Authenticate
    Current allowed actions: Authenticate
       (S) Toggle the sign capability
       (A) Toggle the authenticate capability
       (Q) Finished
    Your selection? q
Done (by typing "q" and RETURN).  Then, selection of the Curve...
    Please select which elliptic curve you want:
       (1) Curve 25519
       (2) NIST P-256
       (3) NIST P-384
       (4) NIST P-521
       (5) Brainpool P-256
       (6) Brainpool P-384
       (7) Brainpool P-512
    Your selection? 1
I selected "(1) Curve 25519" by typing "1" and RETURN.  The name would
be confusing, but this is the curve for Ed25519.
    gpg: WARNING: Curve25519 is not yet part of the OpenPGP standard.
    Use this curve anyway? (y/N) y
Yup, we know.  Confirmed by typing "y" and RETURN.
    Please specify how long the key should be valid.
             0 = key does not expire
            = key expires in n days
          w = key expires in n weeks
          m = key expires in n months
          y = key expires in n years
    Key is valid for? (0)
    Key does not expire at all
    Is this correct? (y/N) y
    Really create? (y/N) y
Answered "y", more times.  Then, I was asked for passphrase (two
times, not shown).  I inputted it by pinentry.
    We need to generate a lot of random bytes. It is a good idea to perform
    some other action (type on the keyboard, move the mouse, utilize the
    disks) during the prime generation; this gives the random number
    generator a better chance to gain enough entropy.
    sec  rsa2048/4CA7BABE
         created: 2010-10-15  expires: never       usage: SC
         card-no: F517 00000001
         trust: ultimate      validity: ultimate
    ssb  rsa2048/084239CF
         created: 2010-10-15  expires: never       usage: E
         card-no: F517 00000001
    ssb  rsa2048/5BB065DC
         created: 2010-10-22  expires: never       usage: A
         card-no: F517 00000001
    ssb  ed25519/9E350F4D
         created: 2015-12-21  expires: never       usage: A
    [ultimate] (1). NIIBE Yutaka     [ultimate] (2)  NIIBE Yutaka OK, I have the subkey of ed25519/9E350F4D.  Good.
    gpg> save
Saved.  We need the keygrip of this subkey to configure gpg-agent for
the SSH key.  I invoke the gpg to see the keygrip:
    $ gpg2 --with-keygrip --list-keys gniibe
    pub   rsa2048/4CA7BABE 2010-10-15
          Keygrip = 101DE7B639FE29F4636BDEECF442A9273AFA6565
    uid         [ultimate] NIIBE Yutaka     uid         [ultimate] NIIBE Yutaka     sub   rsa2048/084239CF 2010-10-15
          Keygrip = 65F67E742101C7FE6D5B33FCEFCF4F65EAF0688C
    sub   rsa2048/5BB065DC 2010-10-22
          Keygrip = 5D6C89682D07CCFC034AF508420BF2276D8018ED
    sub   ed25519/9E350F4D 2015-12-21
          Keygrip = 308EB1096486CF3694380875EDC4C2C9973CB000
OK, the keygrip for ed25519/9E350F4D (my Ed25519 key) is:
I put it in ~/.gnupg/sshcontrol.  If done by command-line, it would be:
    $ echo 308EB1096486CF3694380875EDC4C2C9973CB000 >> ~/.gnupg/sshcontrol
Well, I did edit the file by Emacs, though.  Then, invoke
gpg-connect-agent to reload the file (of sshcontrol).
    $ gpg-connect-agent RELOADAGENT /bye
    OK
Let's see if gpg-agent knows the new key.  I invoke ssh-add -L:
    $ ssh-add -L
    ssh-rsa
    ssh-ed25519
AAAAC3NzaC1lZDI1NTE5AAAAIL3u/YlGa9VfB/QdWCv8hOTonLpEoKoci2pCm/uI/XT7 (none)
OK, it is registered now (along with my old RSA key).  We can see that
it's shorter than the one of RSA.
I'm putting this new key to my remote host where I already have my RSA
public key.
    $ ssh-copy-id MY-REMOTE-HOST
    /usr/bin/ssh-copy-id: INFO: attempting to log in with the new
key(s), to filter out any that are already installed
    /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if
you are prompted now it is to install the new keys
    Number of key(s) added: 1
    Now try logging into the machine, with:   "ssh '******.****.***'"
    and check to make sure that only the key(s) you wanted were added.
OK, done.  My public key of ed25519/9E350F4D is registered onto the
~/.ssh/authorized_key of the remote machine.  I'm login-ing into the
machine to confirm my new key really works (removing my token which
has RSA keys)...
    gniibe at OrangePI:~$
Yes, I'm using Orange Pi PC these days.

@_date: 2015-02-04 17:56:25
@_author: NIIBE Yutaka 
@_subject: Anonymous payment for hardware tokens 
I'm afraid it's not practical for you...
You can buy Gnuk Token in Maebashi, Gunma, Japan by cash from me.
I can speak Japanese (native) and English, and I can read/write
Chinese a little.
Some people bought it in Tokyo by cash when I visited there.
When I join some conference and it is allowed, I can sell it by cash.
I am considering to join LibrePlanet 2015 and Debconf15, this year.
In case it is difficult for you to trust the product, you can compile
Gnuk 1.1.4 by yourself and install it to other supported hardware:
Olimex STM32-H103, STBee, or STBee Mini.  (Porting Gnuk to some board
of STM32F103 is not that difficult, too.)
In either cases, it is recommended to compile and install Gnuk to your
board by yourself, as there is some risk where some malicious
(possibly middle) person has installed fake firmware already.  (I
don't know some technology to prevent such an attack to MCU.  It would
be good if MCU has a built-in feature to show it's SHA256 hash somehow
for its program so that user can check it.)
When/if enough people can gather together, it would be great to have
some hands-on workshop for building Gnuk Token (hardware-wise and
compiling/installing the firmware) and/or one for using Gnuk Token.
Once, we had an event in Tokyo for using Gnuk Token (a session of two
hours) by FSIJ, and a handful people joined.

@_date: 2015-02-04 21:56:57
@_author: NIIBE Yutaka 
@_subject: Anonymous payment for hardware tokens 
Thank you for your insight.  Yes, if "show"-ing is by its program, it
could be also fake.
I meant, something in a JTAG/SWD protocol layer (not by user
program), built-in _hardware_ feature by semiconductor manufacturer to
show hash of flash blocks.
Scenario is like:
   (1) Firmware is written to flash ROM on MCU, by a firmware author.
       Possibly it's protected to be read.
   (2) It is possible for an end-user to send command to MCU by
       JTAG/SWD channel (even if flash ROM is protected).  Like:
       show_hash     (3) An end user can confirm that the hash is the correct one as the
       firmware author says.
Does it make sense?
Sorry, I should have written down clearly, in the previous mail.

@_date: 2015-02-05 00:07:42
@_author: NIIBE Yutaka 
@_subject: Anonymous payment for hardware tokens 
Thank you for your exact comment and discussion.
True.  For Gnuk, the code is not needed to be read-protected.
The reason why Gnuk is used with flash read-protection is that: the
granularity of flash protection of (cheaper versions of) STM32F103 is
all or nothing, and we use the read-protection for private keys.
In some sense, Gnuk users depend on the existence of (the practice of)
non-free software.  (This view matches our Buddhism view, by the
way. :-)
Yes, I'd rather do that for myself (with/without checking its hash).
Besides, I'd like to promote everyone has programmer (possibly with
free firmware).
My point of built-in hardware feature is not particularly for Gnuk,
but for general purpose.  It's OK not everyone checks its hash for
every product, but, it is important for an MCU to have this feature,
so that the existence of this feature can lower the possibility of
effective attacks.  The fact "we can validate the product" itself
makes sense, I guess.
Thank you for your interesting examples.  Morse code by piezo speaker
would be good for me, if not patented.
Well, I'm always wrong, but I believe that engineers in semiconductor
industry is clever in general, and silicon real estate is getting
cheaper to have some room for the feature.
No, I don't bet, though. ;-)

@_date: 2015-02-09 22:31:06
@_author: NIIBE Yutaka 
@_subject: Pin-pad on SPR332 smartcard reader does not work under OSX 
It means:
In order to use pinpad input, scdaemon asked PC/SC service to get code
of FEATURE_VERIFY_PIN_DIRECT and FEATURE_MODIFY_PIN_DIRECT, by
GET_FEATURE_REQUEST command.  But failed.
In this point, scdaemon had no way to use pinpad input.
I haven't got any report for OS X about pinpad input.
I think that scdaemon's apdu.c assumes using PC/SC-lite on OS X.
If not, I think that we need to fix the line 248-259 of apdu.c,
which defines CM_IOCTL_GET_FEATURE_REQUEST.
Could you please check your PC/SC service and version?

@_date: 2015-02-09 23:33:08
@_author: NIIBE Yutaka 
@_subject: Pin-pad on SPR332 smartcard reader does not work under OSX 
Thanks for the information.
In case of GNU/Linux, we have header files for PC/SC.  In those files,
we have definitions like:
      In gnupg/scd/apdu.c, we use that value (the reason not to include the
file is avoiding build dependency).
IIUC, the value would be different in OS X's PCSC Framework, or it's
not supported.

@_date: 2015-02-10 11:02:43
@_author: NIIBE Yutaka 
@_subject: Pin-pad on SPR332 smartcard reader does not work under OSX 
Thank you.  It seems for me that pcscd itself is modern and up-to-date
on OS X.  But, I'm afraid libccid is not so up to date on OS X.  And
I'm afraid if pinpad input is supported on OS X (not only for your
specific card reader, but in general).
I think that it is better to ask Apple if pinpad input is supported
(and update of libccid, if not).
Well, I don't think this is the matter of gnupg-users, but I'm writing
as an possible answer.  Sorry in advance, if it's irrelevant.
My script would help.
I wrote a Python script for testing pinpad input with OpenPGPcard
using PC/SC service.  By using this script, I have enhanced support of
some card readers into GnuPG.
   The script uses PySCard: I have no knowledge/experience if PySCard works on OS X, but
it works on GNU/Linux.
Please note that the purpose of my script is for testing card readers,
basically, and it's not for testing PC/SC service or operating system.
Usefulness depends.

@_date: 2015-02-12 10:03:01
@_author: NIIBE Yutaka 
@_subject: Purchasing OpenPGP cards, card-readers to support GnuPG 
Indirectly, I'd say.
I think that if you stay in Europe, being a FSFE member, you'll get
its member card with OpenPGPcard feature.  I'm sure that it will
improve the eco system around GnuPG, although it's not directly
supporting GnuPG development.  Besides, it gives her good opportunity
to consider the importance and difficulty of controling her own
computing, by a concrete example of card reader implementation and
card implementation.
Buying OpenPGPcard implementations (instead of other card
implementations of PKCS) also benefits GnuPG development indirectly.
Because OpenPGPcard specification is published, and its functionality
is clear enough.  Well, PKCS is published, YES... but supporting cards
other than OpenPGPcard specification is very difficult for free
software project, in general, because the standard practice assumes
non-free environment and the industry tends to be unfriendly to free
Buying original OpenPGPcard implementation would be better, so that we
can support publishing OpenPGPcard specification as free
Perhaps, you'd like more free implementation of OpenPGPcard, but
(partially) non-free implementation also works.
In the current situation, I never accuse users/developers of non-free
OpenPGPcard implementation.  It's not ideal, but it would be an
important step towards better control of our own computing.
Difficulty is... for card readers.  I only know one free (as in
freedom) implementation which connects physical card, that's
CryptoStick (now, new project name, Nitrokey), which combines
physical OpenPGPcard into a token.
Lastly and unlikely, if you stay in Japan, being a FSIJ member, you'll
automatically get the pressure of buying FST-01 as Gnuk Token (or NeuG
standalone). :-) I'm selling FST-01 so that I could have more time for
GnuPG development, and I'd like to invite more developers into this
area, while I'd like to encourage Chinese Industry for free (as in
freedom) hardware design.

@_date: 2015-02-13 08:55:50
@_author: NIIBE Yutaka 
@_subject: emulating smartcard with Nexus 5 
Let me record a bit of history.
In fact, Ueno (cc-ed) did something like that around 2007-2008.  It
was the precursor of Gnuk.  IIRC, he wrote a paper describing his
work.  If he still has the code, it would help you.
Since I didn't like smartphone (which is smart enough to cheat its
users, by my interpretation), I wrote the code for ATmega 20MHz to
implement OpenPGPcard functionality, inspired by his work.  It took
five second to sign RSA-1024.  I demonstraded this work at FSFS 2008
in India, then, I demonstrated "gpg --card-status" worked with ATmega
implementation in Japan Linux Symposium 2009, in Akihabara, Tokyo.
After that, around 2010, experts claimed that we should not use
RSA-1024 any more.  So, I gave up my ATmega work, and sought another
MCU candidate.
That's the start of Gnuk with STM32F103.
The ATmega implementation of RSA was done when I was an employee of
National Institute of AIST, Japan, and it was registered as the work
under AIST (perhaps, copyrighted by AIST).  I left the code there when
I left AIST in September, 2010.  If interested, please contact AIST
(not me).

@_date: 2015-02-14 18:36:07
@_author: NIIBE Yutaka 
@_subject: ilovefs: Thank you, Werner and GnuPG users and developers 
Hello, Werner and GnuPG lovers,
I'd like to share Matthias Kirschner's article today.
And I'd like to say, thank you to all in this opportunity.
Well, let me wrote something to celebrate In 1999, I met Werner when he visited Japan for FSF seminar in Tokyo.
Yes, we exchanged GPG public keys at that time.
Then, in 2004, when I visited Germany to join LinuxTag in Karlsruhe, I
visited FSFE booth.  IIRC, Werner gave me OpenPGPcard version 1.0
(That's _the_ cause which eventually resulted Gnuk).  In return, I
taught my invention of GDHProtocol:
    Perhaps, some people remembered that we played GDHP in front of the
FSFE booth.  This time, we exchanged the disks.
In the autumn of 2010, I started writing Gnuk, and it caused me to
join GnuPG development, so that I could improve scdaemon.  In 2011, I
signed contracts between FSF to assign copyright.  I remember that the
counter-part signer of GnuPG was Peter, and the one of Libgcrypt was
John, because of personnel changes in FSF.  At that time, I didn't
expect more involvement than scdaemon, but Werner was right.
Gradually, my involvement increased.  I happened to review or modify
routines in libgcrypt for public key cryptography or lower level
functions for that.  In 2013, I reviewed ECC code, and then, hacked
code for exponentiation to recover performance regression.  Now, I'm
trying to support Curve25519 in GnuPG.
This year, I plan to join Debconf 15 to meet Werner again.  If
possible, I'd like to play GDHP there.
Happy "I love Free Software Day 2015",

@_date: 2015-02-20 10:30:31
@_author: NIIBE Yutaka 
@_subject: gpg-agent does not authenticate ssh connections 
Well, you don't need to add this manually, for your smartcard.
One possibility is that it's gpg-agent which says "Bad PIN".  The
gpg-agent does its own check for pin length.  OpenPGPcard
specification requires minimum length of user's PIN to be 6.
gpg-agent checks if it's at least 6.  If not, it returns "Bad PIN"
It is not possible for OpenPGP card to have user's PIN with length of
less than 6.  Your user's PIN would be the factory default still.

@_date: 2015-02-21 13:22:22
@_author: NIIBE Yutaka 
@_subject: Help need to use truecryt + openpgp applet. 
I maintain Scute and Poldi packages in Debian.  I also do minimum
efforts for those software in the upstream.  Perhaps, it's better for
me to put my business on the service.html, but my environment is free
software only which won't match most potential customers' requests.
Well, please note that Scute or Poldi is not mature enough yet, and
somehow not well maintained these days.
I don't recommend using data objects on a smartcard for such a use,
because it's size is usually limited.  Say, 255-byte or so, at most.
Here, I explain a bit of existing code (of scdaemon, scute and poldi)
and OpenPGPcard v2.
We also have the data object of 0x7F21 "Cardholder certificate".  I
guess that it was intended to hold the X.509 client certificate in
OpenPGPcard v2, which corresponds to the authentication private key on
the card.  We have READCERT command in scdaemon to access this
specific data object.
However, this command and the data object itself are not used any more
by GnuPG, Scute, or Poldi.  Thus, it would be possible to use this
data object for your experiment.  This is abuse, so, I don't
recommend, in general, but only for your experimental usage.  This
data object is exceptionally large.  I don't remember how large it is
for the original OpenPGPcard, but I know it's 2KiB for Gnuk (if
enabled on compile time).
The access to the data object of 0x7f21 is not controlled by PIN.  It
can be accessed by anyone.  I think that it could be possible for the
host PC to encrypt the data to be stored, using card's encryption key.

@_date: 2015-02-26 09:43:39
@_author: NIIBE Yutaka 
@_subject: disconnected binding of sub and master keys 
I'd understand your point.  IIUC, you don't want to export "secret"
from an air-gapped machine by any chance.
The practice of having air-gapped master key is because of risk of
attacks.  In that practice, it is considered OK, having subkey on your
day-to-day machine.  But, your proposal goes further: creating subkey
on a day-to-day machine.  It worries me, a bit.
There would be some cases (or troubles) that an air-gapped machine
wouldn't have enough entropy (like using LiveCD or embedded).  But,
this particular issue should be fixed on that specific environment.
Other than this point, it is highly recommended, in general, to create
a key (master or subkey) on an air-gapped environment (if that's your

@_date: 2015-01-24 13:05:44
@_author: NIIBE Yutaka 
@_subject: Talking about Cryptodevices... which one? 
Thanks to dkg for Cc-ing me explicitly, it helps me to catch this
Perhaps, my answer would be a bit too technical for gnupg-users (and a
bit Zen-ish because of my background/culture), sorry in advance for
that.  It is not that I want to be unfriendly or unkind, but I
sincerely would like to share technical points and hopefully invite
more users and engineers to this field, and encourage its development.
Availability is one of important factors.  Good.  Furthermore, please
also consider other factors, when you put your own private key(s) onto
some device.  Imagine some cases where computing on the device is not
under your control, specifically, the possibility of honeypot device
to spy your private key and/or your crypto operations.
In my opinion, reproducible hardware product is a condition for such a
device, as well as a condition that whole firmware is Free Software
(not only glue code to access crypto engine).
Reproducible hardware product naturally would have good availability.
And I have expected that for my FST-01.  Unfortunately, our world is
not that simple, or it takes some time for the world to catch up.
I don't think there is an existing product which matches your exact
need/expectation.  But, something similar are there, and it would
be some way to seek future possibility.
Here we go.
(a) OpenPGPcard compatible device
With those devices which conform to OpenPGPcard specification, it is
possible to offer its users following features, using GnuPG and
related tools.
   (1) OpenPGP support
   (2) SSH support thorough gpg-agent
   (3) X.509 support
       S/MIME
       SSL/TLS client certificate authentication
Because those devices are intended to be used for OpenPGP, OpenPGP
support is superior.
But the support for  is somehow experimental.  Honestly, I don't use
those features with my device, but just do experiments time to time.
For OpenPGPcard compatible, we can check existing (or existed)
"manufacturer" list in the source code, specifically, the function
get_manufacturer in gnupg/g10/card-util.c.
(b) (Ab)using other devices with GnuPG
GnuPG has support of some existing smartcard/token not designed for
With those devices, I guess that OpenPGP support would be secondary,
but X.509 support could be considered superior.
We can check the source code, gnupg/scd/app-*.c (other than openpgp)
for those support.  There are:
... but I think that most are outdated, except the last one.
And when you use those devices, you should know that each application
has tendency to grab smartcard/token access exclusively.  At least,
GnuPG assumes access to smartcard/token exclusively, and when it grabs
its access, you can't use the device from other application (of X.509).
I don't use X.509 much.  I think that it's easily possible for us to
use gpgsm with scdaemon.  I maintain scute for Debian (not that
active, though) and its for SSL/TLS client certificate authentication.
I don't use scute daily, but I do some experiments occasionally.
Sometimes, people expect the device to have all.  I mean, not only
private keys, but also, public keys of higher layer.  In OpenPGP
public keys of higher layer = OpenPGP public keys (with signs), and
it's called "certificate" in X.509.
I'd understand such an expectation, which the device could be a sort
of portable ".gnupg".  But, existing technology is that mature, yet.
OpenPGPcard (and its compatible) usually doesn't have any public keys
of higher layer, because of its limited storage.
But, in the past, there was an experiment, to let have X.509
client certificate onto the OpenPGPcard v2.
We can find "CERT-3" data object in the souce code of
gnupg/scd/app-openpgp.c, and the functions like
do_readcert/do_writecert.  However, we don't use this data object at
all, by any GnuPG tools, any more.  The inted usage of this data
object was by scute for X.509 client certificate authentication (Thus,
the name CERT-3, "3" means authentication key in OpenPGPcard).
It seemed that poldi (PAM module with OpenPGP auth) also tried
to use it, but it's not now.
difficult to support, because of its length.  Because of that,
Gnuk has configure time option --enable-certdo, which encourage
not to use this feature of certificate data object support.
Once in the past, I also thought that it would be good idea to have
support of non confidential data onto a device.  Thus, FST-01 has a
chip of serial ROM on the board, which size is 4MiB.  But the size is
marginal to store OpenPGP public keys.  And I haven't implemented any
code to access this particular chip yet.  I also though that it would
be good to put the text of GPL onto this serial ROM to conform GPL
itself, but I realized that it costs when I ask doing that in the
production process.
It's design is free (as in freedom) to be reproducible.  When/if you
care some possibility of malicious/fake hardware, you can build it by
yourselves.  And it's encouraged.
Gnuk doesn't use any crypto accelerator, on purpose, but use general
purpose MCU.  In my theory, using general purpose small MCU would be
superior to avoid malicious/fake hardware features by semiconductor
vendor.  If it's very expensive hardware, specific for "crypto", there
would be more possibility, pressure from outside, or enough room of
silicon to have spy feature (and I don't have technology to check no
spy feature on hardware device).
Besides, Gnuk also supports board other than FST-01.  If it's
difficult for some country to import FST-01 or you like DIY
electronics, my article would help:
  Make Gnuk USB Token by STM8S Discovery Kit:
  Newest experimental version of Gnuk 1.1.4 doesn't support this
particular board officially because of its small flash size (of
64KiB), but, if you manually configure and limit its capability of key
algorithms, Gnuk can run on this board still.
Happy Hacking,

@_date: 2015-01-28 10:46:59
@_author: NIIBE Yutaka 
@_subject: Talking about Cryptodevices... which one? 
Thank you for your question.
Gnuk stores private keys encrypted by AES.  The data encryption key
(DEK) of AES is generated by a TRNG routine named NeuG.  This DEK is
then encrypted by another AES KEY generated by S2K (string to key)
function with passphrase.  Gnuk's S2K function is taken from OpenPGP
specification (and with SHA256).  It's default s2kcount is 192 as the
MCU is slow enough, but you can configure it at compile time (like
65535 for host PC, or more).
     On flash ROM: Private key encrypted ------\
                                                \
     On flash ROM: DEK encrypted --\           [AES]--> Private key
                                  [AES]-> DEK --/
   Passphrase --[S2K]--------------/
It's much like OpenPGP, but Gnuk has additional step, because
OpenPGPcard specification also allows admin to access user's private
key.  This would be a weak point of OpenPGPcard specification, so,
Gnuk has its original feature to disable "admin" role.
When we evaluate possible attacks, I think that it is very important
for us, OpenPGP users, who value the users control of their computing,
to understand the difference between:
For smartcard industry, "user" is actually the entity who purchases
the smartcard, and most of the cases, it's *not* the end user, but
it's a company who forces using smartcard to its customer/employee.
In this structure, "user" cares about the attacks by its
On the other hand, typical usage of OpenPGPcard is by the end user of
GnuPG.  I realized that people tend to talk with the assumption of
smartcard industry, without considering our specific usage.
For Gnuk, serious threat would be software vulnerabilities of itself.
There would be a possible hole to circumvent "three time failures" of
passphrase.  Even if we had such a hole, slow enough S2K function
tries to prevent access to raw private key.  There would be a possible
hole to access MCU's internal flash directly.  In this case,
dictionary attack would be most effective (Gnuk allows passphrase
length up to 127, though).  Given the NeuG's randomness is good
enough, breaking encrypted private key directly would be difficult.
There would be a possible hole to get access to raw private key when
it's loaded to MCU's internal RAM, or by its computation side channel.
Well, I do my best not to have such a hole.  It's not for Gnuk, but I
fixed some in libgcrypt/GnuPG, you can evaluate those, say, changes in
the RSA implementation.
The important point of using smartcard/token is to put your private
key under better control (as well as other points like portability,
etc.).  I think that it's better to use smartcard/token, than storing
the private key on disk of host PC.  Because it could be more simple
and solid.
"useful features".  I'm afraid that something like that simply means
inviting more vulnerabilities or risks.
People might like "powerful" processor.  But, "slow enough" is an
important factor in my own threat model.  It's interesting that card
readers tend to have more powerful MCU than FST-01, these days.

@_date: 2015-01-30 09:26:13
@_author: NIIBE Yutaka 
@_subject: Talking about Cryptodevices... which one? 
============================== START ==============================
You know (unconsciously, perhaps) and wrote "EEPROM", while it's Flash
ROM for Gnuk on FST-01.
192 is low.  That's somehow intentional artifact by me, so that people
can catch it to consider.  In our culture, it's not deliberately mean,
but a kind of communication tool.
Should we have configure time option for that, so that a person won't
need to edit manually?  Let's discuss on the gnuk-users mailing list.
For the data on some EEPROM, weaker key derivation function is on
active service, or even there is no key derivation function, I

@_date: 2015-07-08 17:02:00
@_author: NIIBE Yutaka 
@_subject: gpg-2.1.6 scdaemon: cannot disable OpenPGP application 
Thank you for your report.  I maintain scdaemon of GnuPG.
Since I don't have any experience with SmartCard-HSM, could you please
let me know how it worked and what version of GnuPG?
It is gpg frontend which submits request "SCD SERIALNO openpgp" (with
specific apptype=openpgp) to gpg-agent and gpg-agent relays it to
scdaemon.  The code is there since 2009.
The setting of 'disable-application openpgp' is only valid when the
command doesn't come with apptype.
IIUC, there was the error message, too.  It might be the stderr was
not to directed TTY in other versions, perhaps.
Are there any problems for the functionality?

@_date: 2015-07-08 17:10:22
@_author: NIIBE Yutaka 
@_subject: gpg-agent and putty/ssh agent bug 
It seems that your private keys are on smartcard.  And it seems that
card reader is not available.
If you are using smartcard and card reader, please let me know
specific product name for the reader.

@_date: 2015-07-09 08:59:00
@_author: NIIBE Yutaka 
@_subject: gpg-agent and putty/ssh agent bug 
Sorry, my understanding of private key retrieval was wrong.
You're right.  For SSH authentication, the function card_key_available
is always called before searching other entries (of keys on files) if
not disabled by "disable-scdaemon".  Source: gnupg/agent/command-ssh.c.

@_date: 2015-07-09 13:56:46
@_author: NIIBE Yutaka 
@_subject: gpg-2.1.6 scdaemon: cannot disable OpenPGP application 
Currently, in the source code of GnuPG, we have support of following:
Pardon my ignorance about smartcard other than OpenPGPcard compatible.
The driver for SmartCard-HSM is recently added.  Others looks quite
I see your situation.
I'm not sure, but it would be possible for SmartCard-HSM to be tested
very lightly, and it was not well tested as a whole GnuPG suite.  I
mean, it would not be tested with gpg frontend together.  Perhaps, it
was only tested with gpgsm.
If so, I think that the situation is somehow frustrated for users of
SmartCard-HSM who expect OpenPGP functionality.
I've examined the code of SmartCard-HSM driver.  There are most
functionalities.  However, the method of 'do_readkey' (of retrieving
public key information from card) is missing.  If it will be
supported, we will be able to use SmartCard-HSM for OpenPGP.
I need some help for this direction of development.
Well, for the first step, please help me.  I think that
    $ gpg-connect-agent learn "SCD SERIALNO" /bye
... works somehow with SmartCard-HSM.  Could you please confirm?

@_date: 2015-07-11 17:59:18
@_author: NIIBE Yutaka 
@_subject: gpg-2.1.6 scdaemon: cannot disable OpenPGP application 
It seems that the support of those cards (other than OpenPGP card) are
intended to be used with gpgsm (for X.509).
I don't think pkcs driver worked for OpenPGP since it doesn't have
READKEY method to access its public key.

@_date: 2015-07-16 09:09:15
@_author: NIIBE Yutaka 
@_subject: GNUPG / GPG / S3 / Duplicity gpg: no default secret key: secret 
It seems that your key is only primary key (which is for signing other
key and for signing data).  For encryption, you also need a subkey for
encryption (or primary key should have a flag for encryption).
You can add a subkey for encryption by 'gpg --edit 7E4B6B9B' or you
can create new key with primary key and subkey for encryption.
Default is "RSA and RSA", which means RSA primary key and RSA
encryption key.

@_date: 2015-07-17 14:07:37
@_author: NIIBE Yutaka 
@_subject: OpenPGP smartcard 
I answer what I know of.
The specifications and sample code are available from:
    See the page above.
I don't think so.
So, you have visited the page already.  Please read the page
carefully.  If you needed, please download the documentation and read
I'd like to ask you, how do you verify for your smartcard(s), in
I don't think the firmware is writable by a user of OpenPGPcard.
If you are speaking of OpenPGPcard, I don't think so.
I don't know.
Umm... you already read it, and still post questions...
Sorry, I don't understand this question of yours.  Perhaps, you read
the specification in different way.  I think that the specification
just explains there is no command or function defined in the
specification to read out secret data.  There is no guarantee for
non-existence of backdoor or vulnerability, by the specification
I understand that secret data should not be read out from smartcard.
It would be good to ask smartcard manufacturer, too.

@_date: 2015-07-17 14:48:00
@_author: NIIBE Yutaka 
@_subject: GNUPG / GPG / S3 / Duplicity gpg: no default secret key: secret 
I re-read your original post again, and found that you redefine the
environment variable "HOME" in the script, which is the cause of the
Please add two lines in your script:
export GNUPGHOME
Then, please try with new script.  By setting GNUPGHOME, gpg command
will access that directory.
(Please note that secret subkey for encryption is also needed.)

@_date: 2015-07-18 13:38:54
@_author: NIIBE Yutaka 
@_subject: speedo build of 2.1.6 failing on OS X 
I think that it is related to NLS (Natural Language support).
Please see the issue:
        Non-NLS build broken in 2.1.6
It is fixed in master branch.

@_date: 2015-07-29 09:25:01
@_author: NIIBE Yutaka 
@_subject: One Key, multiple Smartcards not working anymore 
Thank you for the report describing complicated issue.  Your
detailed description helps me understand the situation.
This is a bug in 2.0.  (I think it works well (or better) on 2.1.)
In gnupg/g10/card-utilc, we have a function card_status, which
corresponds --card-status option.  It goes to the block of line 590,
when there is no secret keys available but public key is available
(let's call THE CONDITION).  In this specific case, the function
auto_create_card_key_stub will be called to create the stub.
In your case, secret key stub is not available but public key is
available.  The calculation of THE CONDITION is somehow wrong
for subkeys sharing primary key when the subkey is not available
but another subkey is available.  This is because of the lookup
is basically based on primary key.
I'm going to look in detail, and I will fix.

@_date: 2015-07-29 13:02:58
@_author: NIIBE Yutaka 
@_subject: One Key, multiple Smartcards not working anymore 
I forgot to address some way to recover.
In this situation, you have a stub for RSA 4096-bit keys.
    4096R/9BE45ED0 -> Kartennummer:0005 XXXXXXXX
    4096R/B641DD11 -> Kartennummer:0005 XXXXXXXX
    4096R/CA02F8EA -> Kartennummer:0005 XXXXXXXX
With GnuPG 2.0, you can export stub (it's not possible for GnuPG 2.1).
$ gpg -a -o 9BE45ED0-stub.asc --export-secret-keys 9BE45ED0
$ gpg -a -o B641DD11-stub.asc --export-secret-subkeys B641DD11
$ gpg -a -o CA02F8EA-stub.asc --export-secret-subkeys CA02F8EA
When you have this configuration (' means no secret key),
import *-stub.asc by gpg --import.

@_date: 2015-06-01 14:05:33
@_author: NIIBE Yutaka 
@_subject: OpenPGP card: ERR 100663351 Invalid value <SCD> 
I understand your situation.
I think that the problem is pinpad related code in GnuPG.
Debug information is needed to identify the issue and fix the bug (if
Could you please put following configuration and test again?

@_date: 2015-06-12 09:34:26
@_author: NIIBE Yutaka 
@_subject: [Announce] GnuPG 2.1.5 released 
Please visit: And please follow the link "OpenPGP Card version 3.0", then you can
get the specification.
That's all I know of.
For ECC implementation of NIST P-256 curve, you can refer:

@_date: 2015-06-17 17:55:02
@_author: NIIBE Yutaka 
@_subject: gpg-agent unable to see yubikey until manually re-running `gpg 
Please pardon my ignorance, I don't have Yubikey at hand.
Is the following common use cases of Yubikey?
And... is the following to get version of Yubikey?
Yes, it only works after gpg --card-status or something.
In the current implementation, gpg-agent invokes scdaemon on demand.
(gpg-agent doesn't detect insertion of device or card.)
I don't understand from where "scd apdu 00 f1 00 00" came.
Could you please share the reason why you consider it works well?

@_date: 2015-06-17 20:36:21
@_author: NIIBE Yutaka 
@_subject: gpg-agent unable to see yubikey until manually re-running `gpg 
Thank you for clarification.  In that case, I think that adding
"learn" works.  Like:
  $ gpg-connect-agent --hex "learn" "scd apdu 00 f1 00 00" /bye
The "learn" command is something equivalent of "gpg --card-status"
I think you mean any direct commands of gpg-agent.  Or there is some
Gpg frontend certainly works well for --sign, --decrypt after you
remove your token and insert it again.  Please try:
(1) Insert token
(2) Run "gpg --card-status"
(3) Remove token
(4) Run "gpg --sign" or "gpg --decrypt"
SSH authentication also works well after removal/insertion.
Note that it all works for me with Gnuk Token or OpenPGPcard with a
card reader.
Yes, it does.
You can use "learn" command.  It fails if there's no smartcard/token.

@_date: 2015-06-19 10:10:02
@_author: NIIBE Yutaka 
@_subject: gpg-agent unable to see yubikey until manually re-running `gpg 
Thank you for more information.
This is not reproducible here.  The second SSH ( just works.
My environment is GnuPG 2.1.5 on Debian GNU/Linux, and I use in-stock
CCID driver (I don't install PC/SC service).
Please let me know if you have PC/SC service or not.  If yes, could
you please let me know the version of pcscd and libccid (if you are
using GNU system or Mac OS).
Are there any other programs which might access Yubikey?  Or, do you
have multiple gpg-agent(s) / scdaemon(s), by chance, when you get such
an error?

@_date: 2015-06-26 10:32:59
@_author: NIIBE Yutaka 
@_subject: Windows, GnuPG, ssh, github, ... 
Please correct me if I'm wrong, I am not a user of Gpg4win.
And... since I'm promoting use of card/token, my major use case is
In GnuPG 2.0.x, yes, the steps are required.  Well, I admit it's
complicated.  When done, private key material (I mean, RSA data) is
both in secring.gpg and in the private-keys-v1.d directory.  One is
used by gpg frontend for OpenPGP operation and another is used by
gpg-agent for ssh, S/MIME, and gpg-connect-agent.
In GnuPG 2.1.x, private key is under control of gpg-agent, and it's
(only) in the private-keys-v1.d directory.  And IIUC, those additional
steps are not required with GnuPG 2.1.x.
That's because the design of programs were changed, so that the GnuPG
suite can provide better user's control of operations.
The reason why the steps is not required for smartcard in 2.0.x is
that private key is not on the host and gpg frontend of 2.0.x has to
talk to gpg-agent to access smartcard.  It was a kind of side effect.
In short, there were major design change from 2.0.x to 2.1.x.

@_date: 2015-03-07 09:44:56
@_author: NIIBE Yutaka 
@_subject: Trezor - Could this be the model for a PGP crypto device? 
Do you mean the curve of secp256k1?
GnuPG modern 2.1.x with development version of libgcrypt support
Development version of Gnuk also supports secp256k1.
It was introduced to GnuPG and Gnuk, so that we can sign the
transactions of Bitcoin with GnuPG (and using Gnuk Token, if you
have).  That was the intention.
I also asked Kristian for SKS server.  And the support was added.
I considered some enhancement to existing Bitcion client (such as
Electrum), so that it can ask signing to GnuPG.
However, nothing more happened beyond these lower level implementation
Perhaps, there wouldn't be enough demand (other than my own hack
I had to stop my development for Bitcoin, because of infamous
"BITTOKOIN" fraud in Japan.  After all, their customers had no idea
about controlling their own private keys and their computation by
themselves, it could never be the potential market of Gnuk Token (or
... and I think that there is some interoperability issue(s) for
handling of secp256k1 key in GnuPG implementation which doesn't
support the specific curve (or ECC at all) and/or some? keyservers.
I got report that my key on keyservers are huge, and it seems because
of the subkey of secp256k1.  I haven't examined the detail of this
issue yet, and I don't know the cause of this trouble.
So, I never recommend to join the experiment of secp256k1, now.
If some people still want this direction, a person can check my subkey
of secp256k1 (available in keyservers) with GnuPG modern and
development version of libgcrypt.  Then, he can see my Bitcoin address
by a tool I posted last year (gpgkey2bc) [0].  And if he really wish
to do so, he can send some Bitcoin to that address.
When the amount of Bitcoin into the specific address will be much, it
will be perhaps enough pressure to move my development to this area,
back again.
Well, I don't believe the device with good UI, in general.  UI is (or
can be) most complex component in a system.  If there is a better UI,
it means (for me, at least) that the system is more complex to make
audit more difficult.  And, in general, the hardware (MCU) requirement
from good UI is rather bigger than the one from ECC itself.  If a
system will have a much power, power will corrupt.  We could learn
from the architecture of phone (with better UI).
[0] gpgkey2bc: Generating address of Bitcoin from public key:

@_date: 2015-03-10 11:41:38
@_author: NIIBE Yutaka 
@_subject: Suggestions for a Practical Scheme to Manage Multiple Identities? 
I had an experience that one of my family members took my portable
flash drive for his/her own purpose (and it took hours/days for me to
realize the fact).
This might be another risk.
With this experience, I abandoned adding the feature of storage to
Gnuk, even if I know the usefulness.
If it's useful for you, it would be also useful for them, that might
be a risk.
P.S.  I maintain Gauche, a Scheme interpreter, in Debian.  Since the
site is named "Practical Scheme" [0], at first glance, I completely
misunderstood your subject.
[0] Practical Scheme:

@_date: 2015-03-10 13:35:27
@_author: NIIBE Yutaka 
@_subject: Trezor - Could this be the model for a PGP crypto device? 
Thanks for your explanation.  I see your point.
Confirmation push button would be a good idea, and I have been
considering how we can enhance the OpenPGPcard specification so that
we could do something like that for future implementation(s).
Still immature, but my current idea is something like following.
Basically, OpenPGPcard requires another authentication (confirmation)
to get the result of signing/decryption.
    Host PC                               OpenPGPcard
           command: PSO =>
                        <= response: 0x61
               command: VERIFY with 0x84 or something different ==>
                        <= response: 0x9000 OK
           command: GET_RESPONSE ==>
                        <= response:  of result of PSO
I don't know if this kind of nested transaction is allowed or not in
ISO 7816.  If it's not allowed, there would be another way to do that.
My point is that: if it's ok protocolwise, the confirmation feature
can be implemented by OpenPGPcard using existing cardreader with

@_date: 2015-03-10 14:45:58
@_author: NIIBE Yutaka 
@_subject: GPG4Win 2.2.3 Smart card support 
This is second time for me to receive the message like:
I can't answer to a message saying like this.  Perhaps, so can't
everyone (and that would be the reason why you didn't get reply).
Thus, this is not the reply, but a monologue of mine.
In January, I wrote a message to this list:
    It may help somehow, but it should be just a coincidence.

@_date: 2015-03-11 14:04:50
@_author: NIIBE Yutaka 
@_subject: Trezor - Could this be the model for a PGP crypto device? 
Good point.
Yes, it is possible to implement "ack" button in a way you describe.
But, technically, it's not good for the underlying layer to impose
this kind of "snatch".  It is better for Host PC to know the
Besides, when possible, I don't want a feature to be implemented only
for Gnuk.   I don't want to differentiate, but to collaborate.
Well, I realized that my idea of yesterday was not good.  According to
ISO 7816-4, no command is allowed before GET RESPONSE.
So, we could consider something like this:
    Host PC                               OpenPGPcard
           command: PSO =>
                        <= response: 0x9F
           command: VERIFY with 0x84  ==>
                        (or something different than 0x81, 0x82, or 0x83)
                        <= response: 0x9000 OK
           command: GET DATA on some pseudo Data Object  ==>
                        <= response:  of result of PSO
It seems for me that we can use 0x9F to let host PC the length
of data.  (while 0x61 expects succeeding GET RESPONSE.)
This can be done with smartcard + cardreader with pinpad.

@_date: 2015-03-15 17:47:51
@_author: NIIBE Yutaka 
@_subject: Making the case for smart cards for the average user 
I think that smartcard is _not_ the "must", and having private keys on
host PC as files are good, given the condition where user keeps
computer safe.  If a user is good at administrating POSIX system (or
whatever operating system) and managing specific files, it would be
safer than using unfamiliar hardware.  And... users should keep their
computer safe from the beginning, you know.
Well, when I needed to make copies of private keys (for multiple
computers), I felt anxious.  This is a major reason why I started
using OpenPGPcard, and then, I started to develop Gnuk.
For myself and for the one of release keys of GnuPG, I use Gnuk
However, please note that the situation is not that perfect.
Please note that I have been doing my best to improve GnuPG's
smartcard support (especially about its stability), now, it only
supports basic smartcard things.  For example, you can easily find a
lack of multiple cards / tokens support.  We need more improvements
here (and there).
I'm happy that I can see people discuss about using smartcard/token
for GnuPG nowadays.  I interpret it as the stability/usefulness of
scdaemon.  If not, please file a bug report or two. :-)
The culture/practice around smartcard, especially the industry (in
Japan), is not friendly to free software development.  Basically, they
require NDA here and there.  Although many engineers just say "we
support FLOSS", there are conflicts in practice, when they try to give
technical information to outside.
In general, for free software, it is difficult (or simply no way
sometimes) to support existing smartcards.  It is mostly similar for
smartcard readers, although the situation is better than the smartcard
When I started Gnuk on 2010, I had expected it were the (last)
missing piece.  I soon realized that I was wrong.  And we still have
many things to do in 2015.
I worked and I am working for:
    * Firmware as free software: Gnuk
    * TRNG implementation: NeuG
    * Reference hardware: FST-01
    * Software improvements on host PC: scdaemon
... while I highly depend on:
    * Improvements of development environment: GCC, OpenOCD, KiCAD, etc.
... and I would like to do something around:
    * Improvements on OpenPGPcard specification
Well, I'm afraid... the situation around smartcard for GnuPG is not
yet mature enough to invite average users.
My focus is on the development of those things, and my work is
supported by the sales of FST-01.  Since the situation is not mature
enough (for me), I am caught in a dilemma: I want to sell more FST-01,
but selling more FST-01 now means more possible troubles (to me).
If someone is a user of GnuPG already, I could invite him to use Gnuk
Token.  I mean, I could sell FST-01 with Gnuk to him, and I would say
that the access using SSH could be also safe and easier.
However, if it is the first time for him to use any tool of Free
Software, it would be difficult for me to help him effectively.  When
I need to start from the explanation of the difference of proprietary
software and free software, I would hesitate in some occasions.  Yes,
I _do_ or I try to do so (not always, but most cases), but my physical
body and my hours are limited.
Or, if it is the first time for him to use any smartcard/token on his
system, it would be difficult for me to help him effectively.
Because of this situation, I don't advertise FST-01 much to general
public, while I believe Gnuk Token would be better solution in many
cases.  I think that it's ready for the evaluation by developers and
experienced users of Free Software.

@_date: 2015-03-30 10:17:30
@_author: NIIBE Yutaka 
@_subject: SSH CA and OpenPGP card 
Scute is a shared library for NSS (Network Security Services) with
scdaemon (of GnuPG) which provides PKCS interface.
But, I'm afraid it doesn't work for OpenSSH.  I mean, the library
interface of NSS doesn't match to the one of OpenSSH.
Well, I think that it's possible for us to write a script using
gpg-connect-agent which asks generating signature by authentication
key of GnuPG.  Then, the script can be used for certificate generation
of OpenSSH (instead of ssh-keygen).
I generated *-cert.pub by ssh-keygen, and examined its content.  It
seems that it's simple concatenation of:
We can use SIGKEY, SETHASH, and PKSIGN commands of gpg-agent to
generate signature and other part can be written by, say Python, or
Ideally, ssh-keygen would have better to talk ssh-agent to ask
signing, though.

@_date: 2015-03-30 17:21:17
@_author: NIIBE Yutaka 
@_subject: Unsupported certificate error 
If I understand correctly, your gpg-agent is not the real one, but
gnome-keyring.  "Unsupported certificate" is the typical error message
when gnome-keyring takes over.
How to fix this issue depends on the specific version of gnome-keyring.
Please see:
    I think that nobody asked gnome-keyring to do that, and nobody expects
gnome-keyring to do that.

@_date: 2015-05-13 09:29:51
@_author: NIIBE Yutaka 
@_subject: [Announce] GnuPG 2.1.4 released 
Thanks for your report.
The message "unknown" is new in 2.1.4.
These options have been unknown for GnuPG 2.1.  The change makes
inform users about these unknown options:
The options 'tls', 'verbose' and 'include-disabled' are options for
keyserver helper programs of GnuPG 1.4 and 2.0, which are irrelevant
for GnuPG 2.1.  For 'verbose', I think that you'd specify it in
dirmngr.conf if needed.
I think that auto-pka-retrieve was renamed to honor-pka-record in 2006.
I think that we need to review g10/options.skel and doc/gpg.texi for
GnuPG 2.1, as they still have an entry for 'include-disabled'.

@_date: 2015-05-27 11:46:57
@_author: NIIBE Yutaka 
@_subject: Random Seed for Generating PGP Keys 
Well, in my I HWRNG implementation (named NeuG), I don't use coins or
dice.  The source is sampling of analog inputs by A/D converter (the
inputs itself doesn't matter much).  When you generate a key on Gnuk
Token, it goes directly from NeuG.
Actually, I thought similar thing.  Here is a post of mine in
September, 2013:
    At that time, I considered that I could control more reliably with a
specific "raw" interface to feed entropy to an application directly.
But, currently, I think that it is rather good for GnuPG/libgcyrpt not
to have such an interface but just use system /dev/random (if
When we are using GNU/Linux system or some UNIXen, it goes like this
with HWRNG (with GCRY_RNG_TYPE_STANDARD configuration):
   HWRNG --> /dev/random --> CSPRNG [of GnuPG/libgcrypt] --> GPG key
Note that within HWRNG design itself, thre is usually CSPRNG component
to remove bias from its entropy source.  Further, it's also there in
the design of system /dev/random.
Thus, it is common to have many components of CRRNG in sequence, which
sounds pretty much redundant.
After all, the problem to solve here is: we want the random number
sequence under *none*'s control, so, it would be OK to have another
redundant CSPRNG or two.  That's my opinion.
BTW, now, my HWRNG is available in US, too.  Please visit:

@_date: 2015-05-27 12:08:56
@_author: NIIBE Yutaka 
@_subject: Random Seed for Generating PGP Keys 
Modern RNGs (HWRNG or Pseudo RNG) are (usually) tested heavily by
empirical statistical testing.  Famous free software are:
    TestU01:
        PractRand:
    Well, Dieharder is available in Debian, but it is somewhat older than
those two.
Statistical testing is not sufficient to make sure the random number
sequence is under none's control or none's knowledge.
I believe that free software for the firmware and reproducible
hardware design are also important requirements for HWRNG.
Unfortunately, I banned out from Wikipedia when I added a link to
gniibe.org in the page of HWRNG (the reason was: the link URL included
the string of my login name), so, I cannot edit the page any more.
Lessen was: Wikipedia is(was) not friendly to DIY hardware/software
people to link there useful information.

@_date: 2015-05-27 17:36:00
@_author: NIIBE Yutaka 
@_subject: Ohhhh jeeee: can't encode a 512 bit MD into a 608 bits frame 
It seems for me that this key has subkey of ECC, and that's the cause
of your trouble.
I think that we need to implement some compatibility feature in GnuPG
2.0 (and 1.4).
Last month, I did a fix, but I think that more is needed.
    g10: fix cmp_public_key and cmp_secret_keys.
    I'll look into detail.

@_date: 2015-05-27 22:05:29
@_author: NIIBE Yutaka 
@_subject: Ohhhh jeeee: can't encode a 512 bit MD into a 608 bits frame 
Thank you for more information.
I think that 2.0.22 has this problem.  I checked 2.0 series commit logs.
I think that It was handled by the commit:
    commit 1f842011f611625c8a5fd852d5a2b4bd13e4b563
Author: Werner Koch     gpg: Kludge not to bail out on ECC if build with Libgcrypt 1.6.
    * g10/misc.c (print_pubkey_algo_note): Map the algo.
    (openpgp_pk_test_algo, openpgp_pk_test_algo2): Ditto.
    (pubkey_get_npkey, pubkey_get_nskey, pubkey_get_nsig)
    (pubkey_get_nenc): Return 0 for ECC algorithms.
    --
    Libgcrypt 1.6 features algorithm 18 (generic ECC).  Because of the
    missing mapping and no real support for the OpenPGP ECC format, this
    led to parsing errors of ECC packets.  We better better explicitly
    tell gpg that we ECC is not supported.
    Signed-off-by: Werner Koch It was done soon after 2.0.22.  I think that 2.0.23 or later doesn't
have this issue.  The signature check is just skipped as unknown algo.
I think that it occurs because it has SHA512 signature.  I guess that
other keys with ECC subkeys in your keyring has SHA256 signature.

@_date: 2015-05-28 10:12:06
@_author: NIIBE Yutaka 
@_subject: Random Seed for Generating PGP Keys 
I'd understand your point.  I interpret it as: you would like to
control your computing, especially around cryptography, specifically
your PGP key.
I also would understand your (a kind of) frustration not being able to
get direct answer.  People say different opinions.
I think that more knobs for finer control/tuning doesn't work well
here (the risk of bad configuration would be huge), and that would be
a reason why GnuPG/libgcrypt has an interface to replace its random
generation process by an external input.
I think that modern HWRNG implementations should be more than "rolling
a thousand non-biased coins by a no-biased person".  The generation
speed of HWRNG is far better than an experiment by a person, and it is
(usually) tested by modern empirical statistical testing.  Modern
empirical statistical testing checks/requires Giga bytes of random
number sequence, at least, or Tera bytes.  I don't think it is
practical for an experiment by a person to ask generating even Mega
bytes of sequence to test.
I think that if your point is bias of correlations, no person can beat
modern HWRNG.
The question here is the likeliness of back door(s).  Even if the
sequence is tested by modern empirical statistical testing by Tera
bytes and it says no bias and no correlations, it is possible someone
else has (more) knowledge than a user and can guess the sequence
(forward or backward).
Although I don't recommend to do it, you can modify the file:
.gnupg/random_seed (the binary file).
Alternatively, you can feed to /dev/random to stir the system random
pool.  Then, you can indirectly feed your entropy for the generation
of GPG key.
In my Debian GNU/Linux, I can do:
    $ cat > /dev/random
    Hello,
    ...
    ^D
In this way, I can enter anything (say, the result of coin experiment
in any encoding, in any language, in any format) to stir the system
random pool.  No, this doesn't increase the value of
If you would like better control of it, please see the manual of
random(4) to write a program using ioctl with RNDADDENTROPY.  Then,
you can increase /proc/sys/kernel/random/entropy_avail.
Besides, there is a file /var/lib/random-seed (in my Debian).  You can
edit this file (by root) if you really would like to do so.
The reason why I don't recommend modifying /var/lib/random-seed or
.gnupg/random_seed directly is that there will be more chance to make
errors for the modification (than getting better result).
I don't know any HWRNG products with manually entered seed, but in the
standard document, it is addressed that keyed hash/encryption can be
used (instead of normal hash/encryption) as conditioning component.
(Conditioning component is the component to remove bias).
So, in theory, it is possible to add such a feature.
No, I don't think so.
Alternatively, you can feed to /dev/random from any random number generator.
If you don't want to use /dev/random and GnuPG implementation to
generate GPG key, I think that it is still possible to write a small
program to generate OpenPGP key.
Do you mean something like:
    A PRBG that passes the next-bit test (possibly under some
    plausible but un-proved mathematical assumption such as the
    intractability of factoring integers) is called a
    cryptographically secure pseudorandom bit generator (CSPRBG).
in Chapter 5, Pseudorandom Bits and Sequences of HAC [0]?
Please note that it is for Psudorandom generator, but we can
consider similar criteria.
Any modern HWRNG, system's /dev/random, or the structure of GnuPG's
random generation process all use similar component to prevent
possible attacks to guess its random number sequence.
[0] Menezes, P. van Oorschot, and S. Vanstone, Handbook of Applied
    Cryptography, CRC Press, 1996.

@_date: 2015-05-29 10:26:34
@_author: NIIBE Yutaka 
@_subject: Ohhhh jeeee: can't encode a 512 bit MD into a 608 bits frame 
While I'm learning Debian package management by examples, dkg kindly
opened the bug in Debian BTS: (I didn't have an idea to open a bug in Debian BTS.  Well, I
am learning, since I have been not-so-active in Debian.)
I believe that fix will be included in Ubuntu LTS too, eventually,
since Debian and Ubuntu share packaging and information.

@_date: 2015-05-29 21:55:29
@_author: NIIBE Yutaka 
@_subject: OpenPGP card: ERR 100663351 Invalid value <SCD> 
For some reason, invocation of "pinentry" seems to be failed.
To change name, lang, sex, url or passwd, SCDaemon requires pinentry
program to input pass phrase, but there is some problem around
Could you please check your installation?

@_date: 2015-11-02 11:04:35
@_author: NIIBE Yutaka 
@_subject: Generating 4096 bit key fails =?windows-1252?Q?=96_why=3F?= 
Thank you for the attachment.
It failed when gpg frontend tried to change the key attribute for RSA-4096.
Do you happened to have (and run) old scdaemon of 2.0?
In 2.1.x, this particular protocol has been changed to support ECC.
It was in the format (in the syntax of scanf):
It was number, because we only supported RSA.
Now, it's in the format:
It is now string, because we supports RSA and ECC.
The error seems to be occurred because of this format change.
Since SETATTR command uses percent-and-plus escaping, having '+' is no
problem (it means space).

@_date: 2015-11-04 11:09:45
@_author: NIIBE Yutaka 
@_subject: Generating 4096 bit key fails =?UTF-8?B?4oCTIHdoeT8=?= 
Thank you.  It found it's my mistake.
I reproduced this bug in my environment.  I don't know the reason why
it worked well for me, perhaps I tested with spare space between
arguments when I did with gpg-connect-agent.
Here is a fix.  It will be in the next release.

@_date: 2015-11-10 10:53:14
@_author: NIIBE Yutaka 
@_subject: SmartCard decryption issues 
I think that 2.0.14 doesn't work well for RSA-4096 decryption on card.
It was 2.0.20 (in 2013) which fixed this problem.  (The error message
was not kind enough, it's not correctly describe the issue.)
The problem was, in short, the size of data.  Smartcard was designed
to handle "small" data, but RSA-4096 is a way big for old design
assumptions.  In case of signing, because the signature is not that
big, it works well.  It doesn't work for decryption, since the data
size is 4096-bit (= 512-byte).  Traditionally, smartcard was designed
with the assumption of 256-byte is considered "big", and host software
for smartcard assumed data size is less than 256-byte.

@_date: 2015-11-12 11:44:19
@_author: NIIBE Yutaka 
@_subject: Java library for OpenPGP 
Yes, it's not the same.  In my own opinion, it's better.  I mean, a
wrapper is (far) better for handling private keys, if our major
purpose is privacy.  If the purpose is learning technology or
education, this would be different.
Crypto computation with private keys by some runtime environment with
garbage collector and/or virtual machine is... considered difficult,
or wrong in some cases, perhaps.
While I'd understand a wrapper is a bit difficult (say, debugging, for
example), I recommend a wrapper in general, so that real computation
is done by some real implementation.  YMMV.  I provide a view point.

@_date: 2015-10-01 15:06:06
@_author: NIIBE Yutaka 
@_subject: Local PAM authentication with OpenPGP Card (was Re: PAM 
Thank you for explanation.  I could imagine the use case for
OpenPGPcard authentication for local sudo (or remote sudo).  I guess
that this can be done by pam module for SSH authentication by
ssh-agent.  If really needed, we could write new pam module doing
similar by connecting gpg-agent (instead of socket for ssh).
Although I have a bit of experience with Poldi, frankly speaking, I
don't quite understand the need for local login authentication with
OpenPGPcard.  For me, if I do some access control for my own PC, it
would be better to consider removing keyboard from a PC, or securing
access to the room where I have a PC.
Anyway, I do understand now, there are some needs for local login
authentication with OpenPGPcard.
Thank you, again.

@_date: 2015-10-01 20:07:58
@_author: NIIBE Yutaka 
@_subject: Non-interactive PIN not accepted, gpg hangs 
While the discussion proceeds, I can't determine which post I should
reply.  Well, I think I reply to this post.
I think that Nitrokey series would be a right solution, both for
hardware-wise and their perspective.
As Peter suggested, I feel that your use case is not directly related
to OpenPGP.  It seems that you just need simple (non-interactive)
public key authentication.
IIUC, I believe that Nitrokey community would be best place for such a
use case.  I guess that they are open to diverse use cases other than
OpenPGP, while I have narrow/tight perspective for my Gnuk Token,
specifically limited to OpenPGP.
I think that it is not that technically difficult to write an
application to access Nitrokey (something) for simple non-interactive
public key authentication.  If you say you made a mistake, it's just
that it has not been directly supported by existing tool of GnuPG and
its friends.
OpenPGPcard compatible assumes it's users who control their computing.
This can be done by reasonable cost, because there are less conflicts.
Most smartcard/token applications assume that it's a company (or other
entity) who should control "consumers"' computing.  This is a
different problem to solve, and some expensive solution is only to be
expected, naturally, --- no wonder.

@_date: 2015-10-13 15:06:40
@_author: NIIBE Yutaka 
@_subject: cv25519 subkeys not sent in recv-keys or shown in search-keys 
I think that once newer libgcrypt will be released, cv25519 subkey
will be popular.  For sks keyserver, I submitted an issue as an

@_date: 2015-09-02 15:33:21
@_author: NIIBE Yutaka 
@_subject: GnuPG modern can't genereate keys on my Windows 
This is different issue, I believe.
To create key for Curve25519 encryption, you need development version
of libgcrypt (from git.gnupg.org).

@_date: 2015-09-10 10:13:13
@_author: NIIBE Yutaka 
@_subject: Smartcard power-down 
I'm sorry, now, "gpgconf --reload scdaemon" doesn't work in GnuPG 2.0,
because of a bug.
For a while, please do:
   $ gpg-connect-agent "SCD KILLSCD" "SCD BYE" /bye
This stops scdaemon.
I've just committed the fix to 2.0 branch.
    gpgconf: Fix scdaemon reload.
    * tools/gpgconf-comp.c (scdaemon_runtime_change): Add "scd bye".
    --
    In GnuPG 2.0.x, it doesn't require newer libassuan which has
    ASSUAN_FORCE_CLOSE feature.  We need to send "scd bye" to let
    the control finish from command loop.
diff --git a/tools/gpgconf-comp.c b/tools/gpgconf-comp.c
index 2454f93..69d160e 100644
--- a/tools/gpgconf-comp.c
+++ b/tools/gpgconf-comp.c
 -1064,7 +1064,7  scdaemon_runtime_change (void)
 {
   gpg_error_t err;
   const char *pgmname;
-  const char *argv[6];
+  const char *argv[7];
   pid_t pid;
   /* We use "GETINFO app_running" to see whether the agent is already
 -1077,8 +1077,9  scdaemon_runtime_change (void)
   argv[1] = "GETINFO scd_running";
   argv[2] = "/if ${! $?}";
   argv[3] = "scd killscd";
-  argv[4] = "/end";
-  argv[5] = NULL;
+  argv[4] = "scd bye";
+  argv[5] = "/end";
+  argv[6] = NULL;
   err = gnupg_spawn_process_fd (pgmname, argv, -1, -1, -1, &pid);
   if (!err)

@_date: 2015-09-10 11:01:08
@_author: NIIBE Yutaka 
@_subject: Scdaemon log 
Please note that SCDaemon only supports OpenPGPcard and its
compatibles for the operations of gpg frontend.  We have app-p15.c for
some PKCS cards, and it would work with gpgsm frontend.
This is correct.  I think that you also need to add a line of:
  disable-application openpgp nks
in ~/.gnupg/scdaemon.conf when you try to use PKCS cards.
You can test if it works by following command:
   $ gpg-connect-agent "SCD SERIALNO p15" /bye

@_date: 2015-09-11 10:11:54
@_author: NIIBE Yutaka 
@_subject: OpenPGP card v2.1 and Cherry ST-2000U - Only 1024-bit keys are 
I think that you are using some Unix Operating System.  Could you try
to use PC/SC service, by installing pcscd (and libccid)?  If it works,
I think that it's the issue of timeout management of internal CCID of
I'm afraid there is some firmware issue of the card reader.  Or, it's
because of bad interaction between scdaemon and the card reader.
While most commands and their responses are finished in a second or
so, key generation takes much time (like several minutes, if key size
is larger).
There is a protocol defined in CCID (host <-> reader) and card<->reader
to extend the time out.  The interaction is like following.
Usually, it's just like:
    Host           Reader         Card
        command ->
                         command->
                                   [some processing done by card]
                         <-response
        <-response
If it takes much time, it goes like:
    Host           Reader         Card
        command ->
                         command->
                                   [some processing done by card]
                         <-"please wait"
        <-"please wait"			
        [...]
                         <-"please wait"
        <-"please wait"			
                         <-response
        <-response
Host or Reader should not give up while it sees "please wait" message.
Here, there is a possibility that Host or Reader gives up earlier than
the receival of "please wait" message.  If it's Host side, we can
change the timeout value of internal CCID of GnuPG.
Your testing with pcscd will be much appreciated.  Thanks in advance.

@_date: 2015-09-11 18:50:22
@_author: NIIBE Yutaka 
@_subject: Gnupg 2.1.7 can't decrypt using smartcard key. 
Could you please try 'gpg --card-status' and see 'General key info'?
In my case, it's like:
General key info..: pub  rsa2048/4CA7BABE 2010-10-15 NIIBE Yutaka sec>  rsa2048/4CA7BABE  created: 2010-10-15  expires: never
                        card-no: F517 00000001
ssb>  rsa2048/084239CF  created: 2010-10-15  expires: never
                        card-no: F517 00000001
ssb>  rsa2048/5BB065DC  created: 2010-10-22  expires: never
                        card-no: F517 00000001
It shows the connection between stub on host PC and key on the card.
I guess that there is some problem in your situation, and
you can see what's going on by the --card-status.

@_date: 2015-09-13 10:27:57
@_author: NIIBE Yutaka 
@_subject: Gnupg 2.1.7 can't decrypt using smartcard key. 
I think that there must be something broken.  It shows that all of
keys on your card are same (37AA8068).
As I showed in the previous mail, each key should have different
In another command of the following, I can check:
$ gpg-connect-agent "KEYINFO --list" /bye
S KEYINFO 5D6C89682D07CCFC034AF508420BF2276D8018ED T D276000124010200F517000000010000 OPENPGP.3 - - - - -
S KEYINFO 101DE7B639FE29F4636BDEECF442A9273AFA6565 T D276000124010200F517000000010000 OPENPGP.1 - - - - -
S KEYINFO 65F67E742101C7FE6D5B33FCEFCF4F65EAF0688C T D276000124010200F517000000010000 OPENPGP.2 - - - - -
It shows that I have three different keys on a card.
Could you check it?
Or, did you intentionally register a single key to multiple slots?  I
think that this kind of use case is not supported by GnuPG.  It
assumes that each key on card is different.  In that case, I'd
understand the reason why it returns an error of "Invalid ID".

@_date: 2015-09-14 11:05:32
@_author: NIIBE Yutaka 
@_subject: Gnupg 2.1.7 can't decrypt using smartcard key. 
Let me answer a point by a point.
Firstly, let me check about the support situation of GnuPG about this
specific usage of same key on smartcard for singing, decryption, and
I'm sure that current code of GnuPG 2.1.x doesn't support the usage of
same key on smartcard.
In my opinion, OpenPGPcard specification doesn't encourage users to do
this specific usage, too.
In GnuPG 2.1.x, access by gpg-agent to scdaemon is done with KEYID of
"OPENPGP.1", "OPENPGP.2", or "OPENPGP.3" (see the function
ask_for_card in gnupg/agent/divert-scd.c), by accessing .key
file under ~/.gnupg/private-keys-v1.d.
I think that this situation is same in GnuPG 2.0.x.
In GnuPG 1.4.x (when configured with no agent), access is done with
SERIALNO.  IIUC, it is possible for GnuPG 1.4.x to allow the usage
of same key on smartcard.
Setup of this specific usage requires quite a cumbersome interactions,
I believe.  It requires multiple invocations of 'gpg --edit-key',
invocation of subcommand of 'keytocard' and then, quit without saving.
Secondly, GnuPG's default key generation is generating primary key and
encryption subkey.  Primary key has capability of Signing (to message)
and Certification (signing to key), while the subkey of encryption has
capability of Encryption.  IIUC, this was because of historic reason
originally, but, it makes sense too (since usage (especially
revocation) is different and key life-time would be different).  And
then, if you need, you can add Authentication subkey (for SSH) by
'gpg --edit-key' and invoking subcommand addkey (specifying the
Authentication capability).
If you don't have enough reason to use a single key material for
multiple slots of smartcard, it is recommended to follow the default.

@_date: 2015-09-15 16:29:23
@_author: NIIBE Yutaka 
@_subject: OpenPGP card v2.1 and Cherry ST-2000U - Only 1024-bit keys are 
Thank you for your confirmation.
Well, I'm going to fix ccid-driver of GnuPG scdaemon to support
OpenPGPcard v2.1 correctly.
Currently, ccid-driver's timeout is 5 seconds.  If I calculate it
correctly, the timeout for OpenPGPcard v2.0 is (3.3 + 1) = 4.3 seconds
by pcscd+libccid.
I think that timeout for OpenPGPcard v2.1 would be different.  If
possible, could you please show us the ATR string of the card?
It's in the debug log of scdaemon.  It's like the like:
slot 0: ATR=xx xx xx xx xx xx xx xx ...
This ATR string defines the timeout of communication.

@_date: 2015-09-16 18:57:53
@_author: NIIBE Yutaka 
@_subject: OpenPGP card v2.1 and Cherry ST-2000U - Only 1024-bit keys are 
Thanks.  Timeout should be more than 13 second.  I'll use this value.
    ccid-1.4.20/src/ifdhandler.c:T1_card_timeout

@_date: 2015-09-21 16:35:11
@_author: NIIBE Yutaka 
@_subject: Smartcard reader disconnects 
How do you conclude that "smartcard reader apparently disconnects"?
Did you see any error message or something?
What's the output of "lsusb" when you encounter this?  Do you still
see valid entry of your card reader?
When your 'gpg' is GnuPG 1.4.x and it's not configured using agent, it
is possible that there is gpg-agent and scdaemon running with your
card reader and GnuPG frontend of 'gpg' tries to access the card
reader directly and fails.

@_date: 2015-09-22 22:07:28
@_author: NIIBE Yutaka 
@_subject: Decryption fails with 4096bit key on SmartCard 
Thank you for the dump.  There are fingerprints and timestamps
registered on the card.  But, it failed decryption with "No Record".
Usually, it means there is no key on the card.
Well, it's inconsistent.  After writing private key onto the card,
fingerprint and timestamp are registered.
What's the output of 'gpg --card-status'?
By invoking 'gpg --card-status', scdaemon tries to access public key
on card.  If it fails, I think that there were some troubles when you
wrote decryption key onto card (but it proceeded without notifying the
error, thus, having fingerprint and timestamps for decryption key,
I think that it's worth a try to run scdaemon with disable-ccid flag.
Please include a line:
=============== .gnupg/scdaemon.conf
It disables internal CCID driver and use PC/SC.  If it works, there
is some bug in internal CCID driver.

@_date: 2015-09-24 09:46:45
@_author: NIIBE Yutaka 
@_subject: Decryption fails with 4096bit key on SmartCard 
Thank you.  Other than the particular error of decryption failure,
everything looks fine.
When you wrote your private key to the card (with gpg --edit-key and
its sub-command "keytocard"), gpg sent your private key to the card.
After that, gpg sent fingerprint and timestamp to the card.  Public
key is generated by the card from private key.
Could you please try following commands (with debug option in
.gnupg/scdaemon.conf enabled) to see what's going on?
    $ gpgconf --reload scdaemon
    $ rm     $ gpg --card-status
The scdaemon accesses public key information on the card.
You'll see the debug dump of following line:
    raw apdu: 00 47 81 00 02 B8 00 00
This is to read public key (of decryption) from the card.
It should have valid response of public key as a response of
this command.
In my case (of RSA-2048 key), it's like:
2015-09-24 09:22:40 scdaemon[5848] DBG:       dump:  7F 49 82 01 09 81 82 01 00 94 9D ED 4A 70 67 E0 6F 4E C4 90 59 BF 8C C5 AD 71 CB FB D8 1D
B8 A8 D4 EE 24 5C 74 42 01 81 C7 3E 7F D8 3D 9E D8 9F D7 9F 93 96 C9 86 C8 0F C0 90 68 A7 7C 4F 91 3F A0 43 DA 3B 8B AF A8 5E 7B 32 46 33 A7 29
88 3F 6B 97 2F FF FE A4 78 33 DF CA 99 05 02 8C 60 BE 65 E6 7A 63 2B E5 43 5F 42 D9 BC F2 4C 3C DF 69 41 26 86 B2 23 68 CB 66 59 D0 15 18 4E 2E
C3 5B 79 4A 51 85 F2 3A 5B CC 98 90 89 79 AD 0B D3 5E 78 C0 00 53 E8 6B E6 AD 83 5F AC E4 C7 40 AE E6 CA 29 23 0A B6 70 77 C3 17 85 6A CF 67 CB
EF B0 B9 14 B0 5A CB 80 03 21 E4 01 34 32 A9 1F BF 46 79 A8 C7 C9 89 F6 A1 C2 19 B1 59 A8 B4 F5 AF DF D4 DA 12 C9 AD 83 7C DD DF D8 16 B3 95 23
3E 3D C0 4A 6B C5 22 C3 FF FC EC 8B 0D 9C 22 4E 0D DA D2 DA D0 BC 5A 68 EF CD 78 69 A3 F9 89 16 F2 CE 7A 7F D1 D6 E8 8E B6 C6 01 82 03 01 00 01
2015-09-24 09:22:40 scdaemon[5848] DBG: chan_5 -> S KEYPAIRINFO 65F67E742101C7FE6D5B33FCEFCF4F65EAF0688C OPENPGP.2
'7F 49 82 01 09 81 82 01 00' is a header for the public key.  Then,
raw RSA public key of 256-byte.  Followed by '82 03 01 00 01', which
is public exponent.
65F67E742101C7FE6D5B33FCEFCF4F65EAF0688C is a keygrip of my decryption
key.  "OPENPGP.2" is the name of decryption key of the card (2 means
second key on the card; first key is for singing, third key is for
If you will see success of this public key retrieval from your card, I
think that your private key is on your card correctly, but something
was going wrong for decryption operation.
If you will see failure of this public key retrieval from your card, I
think that your private key is not on your card correctly.  Something
was going wrong when you invoked "keytocard" sub-command, but it was
not reported so (and proceeded to register fingerprint and timestamp).

@_date: 2015-09-28 16:03:59
@_author: NIIBE Yutaka 
@_subject: Decryption fails with 4096bit key on SmartCard 
It is also correct.  Short form is 02 and extended form is 00 (the prefix)
and two-byte (00 02).
That's no problem.  It is correct for RSA-4096 key.
Thanks.  It looks no problem at all (other than the specific error of
Yes.  I think so, too.
The error code of 6A88 is a kind of strange for me.  If it's
OpenPGPcard v3.x with AES symmetric key decryption support, I think
that we could see the error of 6A88, though.
It would be possible this error occurs on other Nitrokey Pro (or other
OpenPGPcard v2.1 implementation), if this were firmware issue.

@_date: 2015-09-29 11:44:17
@_author: NIIBE Yutaka 
@_subject: An update on poldi? [was: Re: unlock keychain with pam 
Thank you, dkg for Cc-ing.
Poldi works with smartcard, specifically OpenPGPcard compatible.  It
doesn't work without OpenPGPcard compatible smartcard.
I maintain Poldi and Scute for Debian.  Since those two projects are
orphaned by upstream, I only do small changes.
Last year, I did small changes for Poldi, when a person asked me if
Poldi can still work on Fedora.  Those changes are in the repository:
    He said that he would be able to have a little budget for further
development of Poldi, but it seems that my unpaid work of last year
was just enough for him, and it didn't proceed further.
Personally, I think that the use case for Poldi for login
authentication is fundamentally different than the use case of
OpenPGPcard for SSH authentication.  I tend to assume ownership of
computer and OpenPGPcard is by its users, but in some (or most) cases,
Poldi is used in the situation where computer owner is a company and
OpenPGPcard owner is also a company (and a company let employees use
their computers).  Who controls what, is different.
Thus, in my opinion, Poldi is an experimental project, just for
seeking the technical possibility, which doesn't go anywhere.
For authentication of sudo on remote machine, I think that we can use
pam_ssh_agent [0] together with GnuPG, if we can configure correctly.
I don't have any experiences, though.  It would be good if we can also
do similar thing directly by gpg-agent remote access.
[0] pam_ssh_agent:

@_date: 2015-09-30 08:39:26
@_author: NIIBE Yutaka 
@_subject: Non-interactive PIN not accepted, gpg hangs 
As far as I know, you can't provide a PIN by command line.
You can provide passphrase from file for symmetric encryption, though.
Instead, you can unlock your smartcard beforehand, interactively.
$ gpg-connect-agent "SCD CHECKPIN D276000124010200F517000000010000" /bye
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Please change this to your Application ID.  gpg --card-status shows it.
BTW, I got a report that RSA-4096 decryption doesn't work well on
Nitrokey Pro.  If you are using RSA-4096 decryption on Nitrokey Pro
successfully, please let us know.

@_date: 2015-09-30 09:17:10
@_author: NIIBE Yutaka 
@_subject: PAM authentication with gpg or ssh key 
Yesterday, I included my answer to your question to a different
thread.  I should have replied to this post.
I think that your question is relevant to GnuPG community.
My answer was:
For authentication of sudo on remote machine, I think that we can use
pam_ssh_agent [0] together with GnuPG, if we can configure correctly.
I don't have any experiences, though.  It would be good if we can also
do similar thing directly by gpg-agent remote access.
[0] pam_ssh_agent: I think that it's good if a user can consolidate his private key
management under GnuPG (possibly with OpenPGPcard compatible).
Besides, it would be good if OpenPGPcard can have more authentication
keys (for different purposes), too.
Perhaps, if there are some demands, I should write U2F module using
gpg-agent (and revive Scute, accordingly).  I believe that this is a
way to go, for those users who want to consolidate things cleanly.

@_date: 2016-04-28 09:23:16
@_author: NIIBE Yutaka 
@_subject: gpg and smartcard on ubuntu 16.04 
Good, Ubuntu has GnuPG 2.1 (eventually, gpg will be GnuPG 2.1).  Out
of curiosity, does it has libgcrypt 1.7.0?
I think that this is the issue of GPG_AGENT_INFO variable, which was
used before 2.1.
How about set those environment variables, like?
     export GPG_AGENT_INFO=$HOME/.gnupg/S.gpg-agent:0:1
     export SSH_AUTH_SOCK=$HOME/S.gpg-agent.ssh
After setting those variables, does gpg work correctly?
In my environment of Debian, those variables are set by:

@_date: 2016-08-09 09:05:11
@_author: NIIBE Yutaka 
@_subject: GPG smartcard shrinks in size 
No worries.  I think that you can just generate keys of 4096 or put
keys of 4096 by keytocard.
OpenPGP Smartcard supports multiple key length.  Since the card
protocol only supports a single information of key length per key, a
card looks like as if it only supports a specific key size.  (There is
no way in the protocol to represent multiple key length information.)
When a user invokes "generate" or "keytocard" command, GnuPG will
adjust the key attribute of a card to a specific size of key length.
Once it is generated or written by keytocard, you will see it's 4096.
Or, do you have a specific problem when you say "unable to use it for
4096 keys anymore"?  Please describe the problem.

@_date: 2016-08-09 09:39:43
@_author: NIIBE Yutaka 
@_subject: several GPG smartcards connected at the same time 
Currently, this configuration is not supported by scdaemon.  I don't
know any portable technical solution (supporting GNU/Linux, Windows,
and MacOS X, etc.) to handle multiple card readers (and/or cards)
simultaneously by a single application.
Now, GnuPG 2.1 internal CCID driver has migrated to newer libusb.  So,
I think that we can consider a solution by the internal CCID driver,
supporting multiple card readers (or card) simultaneously by a single
application.  I don't know how a possible libusb solution is portable,
In fact, I am using multiple tokens daily for gniibe at fsij.org; ed25519
with 249CB3771750745D5CDD323CE267B052364F028D, rsa2048 with
124124BD3B4862AF7A0A42F100B45EBD4CA7BABE.  It annoys me somehow.
If there is no token inserted, it fails.  If a correct token is inserted,
it goes well.  If a different token is inserted, GnuPG asks a user to
remove a different token and to insert another token.  This is the current
There is a small problem yet.  When GnuPG sees an encrypted message
for both of E267B052364F028D, 00B45EBD4CA7BABE, it handle a possible
key in a sequence (as listed in an encrypted message).  Suppose key
list is: E267B052364F028D and 00B45EBD4CA7BABE, and I already inserted
a token for 00B45EBD4CA7BABE in my computer.  GnuPG asks me to change
a token when it finds E267B052364F028D in an encrypted message, even if
the message can be decrypted by the token inserted already.

@_date: 2016-08-18 14:22:21
@_author: NIIBE Yutaka 
@_subject: [Resend] Assistance with decryption failure, gpg unable to find 
In libgpg-error/doc/errorref.txt, it says:
In the code of GnuPG, this error occurs when decryption by your
private key is finished to get the secret session key, but the result
of the secret session key is found malformed.
I'm reading gnupg/g10/pubkey-enc.c.

@_date: 2016-12-15 10:35:04
@_author: NIIBE Yutaka 
@_subject: Smartcards and tokens 
I think that the OpenPGP card (the physical smartcard) is included in
Nitrokey Pro USB Token.  So, it's exactly same from the view point of
When you want to use a smartcard, you need a card reader to access the
card.  And the card reader you use would bring another attack vectors.
In this point, Nitrokey Pro USB Token is the best approach, I suppose.
IIUC, Yubikey products are JavaCard implementations and somehow emulate
OpenPGP card protocol by "app", and they work as CCID card reader +
OpenPGP card.
In Nitrokey Start USB Token, there is no OpenPGP card physically, but it
is implemented by Gnuk, the software.
This is the point.
The hardware OpenPGP card in Nitrokey Pro USB Token could be replaced by
man in the middle (or its vendor).  The hardware MCU chip in Nitrokey
Start USB Token could be replaced, too.  The software (Gnuk) in Nitrokey
Start USB Token could be replaced (with JTAG/SWD debugger), too.  Or, we
should consider possibility of backdoor of OpenPGP card.  Well, I don't
know about Yubikey.
When it is replaced to be malicious one to enable an access by others
(to your private keys), or it already has a backdoor in the first place,
it kills the purpose of USB security token.
Here, the question is: how can we build up such a "trust"?
It seems for me that there are two different approaches; (1) physical
difficulty (for example, plastic molding for "protection"), (2)
reproducibility and transparency/openness.  Note that some method of
former makes latter difficult.
For myself, I take (2), and I did my best to make my product as
reproducible.  (Since I don't manufacture semiconductor things,
reproducibility is not 100%, and this part of manufacturing and
technology is not open at all.)  And I intentionally deliver my product
in a style of "transparent" or "open".
Distribution channel is also difficult.  I do in person, and I ask FSF
for my TRNG.  Are there any good method?
Obvious drawback of the apporoach (2) is that people with enough
concern/attention have tendency to do it under their control.
Reasonable.  Since it's reproducible (somehow), it's possible, by
definition.  And then, I can't sell many.

@_date: 2016-12-15 20:58:39
@_author: NIIBE Yutaka 
@_subject: Changing comment in userID 
Please note that modifying user ID (even if it's a comment in user ID)
makes different user ID.  And when people certify your key, signature
is about user ID.
You don't need to create new key.  You can add new user ID to existing
key by: gpg --edit-key YOUR-KEY and "adduid" sub command.  You can
also revoke an old user ID by "revuid" sub command, if you want.
Then, you can upload updated key to keyserver.  There is also "deluid"
sub command but it only affects key on your PC, since keyservers never
support deletion of record.
You need to get your user ID certified again.
Thus, it would be simpler starting with new key with new user ID.

@_date: 2016-12-16 09:25:05
@_author: NIIBE Yutaka 
@_subject: Smartcards and tokens 
Exactly, that's my point.  This is the reason why my approach of Gnuk
and NeuG tries to avoid specialized things.  Even, I avoid using crypto
accelerator, which (many of) experts say mandatory.
I think that an approach using commodity hardware makes sense.  My
theory is that if it's simpler and cheap enough, difficulty putting
backdoor would increase.  I don't know if this is true, but I considered
opposite must be likely; With enough space of silicon and enough
complexly in design, attackers can do something more.
Is it audited?  I didn't know that.  For me, audit by an expert (or two)
is not enough.  It should be possible by anyone, or at least, by any
user who purchases it.  It's sad for me that Nitrokey is not easy to
open physically.  I mean, opening the device to examine the board.
I don't know about the former, it depends on country.  For the latter,
it is real concern for me now.
I make the hardware design as simple as possible so that inspection by
human eye can be effective against replacing/adding chip.
Difficult part (for me) is to assure initial firmware flashing in
a factory.
In (most of) factory environment, proprietary operating system
dominates.  I'm not sure if this is the weakest link, but this could be
weaker point.  When an attacker replaces the firmware to be written,
it affects all devices to be shipped.
Perhaps, it would be good if an MCU has a feature of reporting hash of
its content of flash memory (even if flash is protected and it is not
possible to read out its content).  Then, an end user could examine
the hash code.
I think that the better current practice is: purchase commodity hardware
and flash at the user side.

@_date: 2016-12-16 15:12:46
@_author: NIIBE Yutaka 
@_subject: [Announce] Libgcrypt 1.7.5: secmem trouble 
I think that you need to debug libgcrypt to locate the bug.  If you are
familiar with GDB, run gpg under GDB with a break point at main, and
then a break point at lock_pool_pages.
Well, please show us the information in which architecuture/OS you runs
GnuPG.  Are you using GnuPG 2.1.x or another version?
I'm afraid you are using libgcrypt 1.7.4.  In version 1.7.4, there was
a bug in configure script, which might cause such a trouble.

@_date: 2016-02-23 10:08:04
@_author: NIIBE Yutaka 
@_subject: Email Self-Defense 
While we translate the "Email Self-Defense" guide into Japanese, I
have a thing (or will have more) to clarify.
In this section 5b, it says:
        When using GnuPG, make a habit of glancing at that bar.  The
    program will warn you there if you get an email encrypted with a key
    that can't be trusted.
"The program" here means Enigmail with GnuPG, I suppose.
I think that it's quite rare to encounter this particular case; a user
would need to have a revoked or expired key (of themselves).
If it means an email with signature (encrypted or not), it makes more
sense to me.  I think that it would be better to explain more likely
How do you think?

@_date: 2016-01-07 20:48:48
@_author: NIIBE Yutaka 
@_subject: Obtaining SSH Key format from OpenPGP public certificate without 
Exactly, this is very useful.  In the past, I wrote an article:
   Alternatively, we have openpgp2ssh utility in monkeysphere.
   I think that it's worth to keep gpgkey2ssh in GnuPG and to enhance it
to support ECC.

@_date: 2016-01-12 09:53:44
@_author: NIIBE Yutaka 
@_subject: compile 2.1.10 with libgcrypt 1.7.0-beta300 
GnuGP and libgcrypt development version build successfully on my
32-bit ARMv7l.
Good, you have the libgcrypt development version installed.
How do you install the libgcrypt on your system?
If it's /usr/local/lib, you would need LD_LIBRARY_PATH setting.
    $ export LD_LIBRARY_PATH=/usr/local/lib
For me, with LD_LIBRARY_PATH, it goes:
    $ gpg2 --version
    gpg (GnuPG) 2.1.11-beta67
    libgcrypt 1.7.0-beta298
    NOTE: THIS IS A DEVELOPMENT VERSION!
    It is only intended for test purposes and should NOT be
    used in a production environment or with production keys!
    Copyright (C) 2015 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.
    Home: ~/.gnupg
    Supported algorithms:
    Pubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSA
    Cipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,
            CAMELLIA128, CAMELLIA192, CAMELLIA256
    Hash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224
    Compression: Uncompressed, ZIP, ZLIB, BZIP2
Please note that you need to invoke gpg-agent with LD_LIBRARY_PATH, too.

@_date: 2016-01-12 10:11:09
@_author: NIIBE Yutaka 
@_subject: compile 2.1.10 no bzip2 ? 
It seems for me that you don't have libbz2-dev package installed.
   $ sudo apt-get install libbz2-dev

@_date: 2016-01-21 16:50:37
@_author: NIIBE Yutaka 
@_subject: problem signing with a smart card 
In the above example, you have a primary key and four sub keys.  How
three keys are on your card?  Please don't omit the output of gpg2
--card-status.  That's mostly important to answer your question(s).
It seems that you would confuse the capability of OpenPGPcard.  It has
three key slots, but the usage is defined as: sign, decrypt, and
     When you store your private key to signing slot, you can sign.
     When you store your private key to decryption slot, you can decrypt.
     When you store your private key to authenticationslot, you can
     authenticate (say, with SSH).
I mean, you can only store a single signing key on your card.

@_date: 2016-01-25 10:33:40
@_author: NIIBE Yutaka 
@_subject: 2.1.10 with libgcrypt 1.7.0-beta300 
Well, it seems terminology issue.  I mean, to start, to kick the service,
and to run the service.
In general, there are multiple ways.  In my case on Debian, I have a
startup script, /etc/X11/Xsession.d/90gpg-agent, which invokes
Exporting library path is also needed for gpg-agent.
This can be done with libgcrypt 1.6.4.
I know.  The problem is the version of libgcrypt of gpg-agent.
Public key handling is the role of gpg frontend, while secret key
handling is done by gpg-agent.  With no newer libgcrypt, gpg-agent
can't handle CV25519 keys.
If you can check the process's memory maps of gpg-agent, you can see
the maps to libgcrypt.  In my case, I can see the entries in
    b7617000-b76d5000 r-xp 00000000 08:01 35743      /usr/local/lib/libgcrypt.so.20.1.0
    b76d5000-b76d9000 rw-p 000bd000 08:01 35743      /usr/local/lib/libgcrypt.so.20.1.0
    b76e7000-b76ef000 rw-p 00000000 00:00 0

@_date: 2016-01-25 21:07:31
@_author: NIIBE Yutaka 
@_subject: Problems with 4096 keys on 2.1 card 
I think that GnuPG 2.0.22 itself should work well.
However, please note that many card readers have problems with larger
APDU.  Generating keys on card should be ok, but importing keys would
be failed with bad reader.  Signing should be ok, but decryption would
be failed with bad reader.  That's because of length of APDU.

@_date: 2016-01-26 10:06:19
@_author: NIIBE Yutaka 
@_subject: Problems with 4096 keys on 2.1 card 
Please note that GnuPG 1.4 supports up to 3072-bit.  This is because
of internal library limitation.
I believe that "gpg" in Ubuntu is GnuPG 1.4.  It is "gpg2" when we
want to use GnuPG 2.0.
Besides, generating a key with off-card backup is actually done by two
  * generating a key on host PC
  * importing that key to card
If your choice is "Yes" for the question above, the key for encryption
is not generated on card, but generated on host PC.
Unfortunately, I don't have specific information (if card reader works
with RSA-4096 or not), either.  I maintain this list for internal
    According to this list, SCR3500 works well with the internal driver of
In general, the list by PCSC-lite helps.
    Looking the device info, both of SCR335 and SCR3500 work with TPDU
level exchange.  Thus, I believe that both works well for RSA-4096
I think that it's "Extended APDU level exchange"?  There are two level
exchanges; one is TPDU level exchange (lower layer) and another is
APDU level exchange.  For longer APDU with original OpenPGPcard (i.e.,
in the communication of RSA-4096), the reader should support:
    TPDU level exchange
    or
    Extended APDU level exchange with enough dwMaxCCIDMessageLength
If the reader only support short APDU level exchange, original
OpenPGPcard doesn't work well for longer APDU.

@_date: 2016-01-27 08:52:32
@_author: NIIBE Yutaka 
@_subject: Problems with 4096 keys on 2.1 card 
Yes.  GnuPG 1.4 works here, but it doesn't work for RSA-4096 keys.
I guess that you don't configure GnuPG 1.4 to use gpg-agent.
In that setting, gpg tries to connect your reader directly.
This is different thing.  It is the problem of smartcard, not specific
to RSA-4096.
I think you are using GNOME keyring.  Old versions of GNOME keyring
had a feature to try to replace a part of functionality of gpg-agent,
it was a kind of emulation of gpg-agent.  And it doesn't support
any commands for smartcard, and it resulted mysterious errors like
It had been difficult to configure GNOME keyring (to stop the feature
of gpg-agent) properly.  Here is some info:
    In the days of GNOME 2.x, it was gconftool-2.  In the days of GNOME
3.0, it was gnome-session-properties.  For GNOME 3.1 or later, we
need to change the way how to invoke gnome-keyring.
Fortunately, I've heard that gnome-keyring is fixed now.  I, for
myself, gave up with GNOME and currently using XFCE4.  However, I
encountered another:

@_date: 2016-07-19 11:18:44
@_author: NIIBE Yutaka 
@_subject: SSH hangs when using GPG2 + Yubikey on OS-X 
I'm not sure the symptom; which is the result and which is the cause?
I mean, scdaemon hangs because of SSH hung sessions?
Well, SIGHUP doesn't work for scdaemon.  scdaemon can be killed by:
    $ gpgconf --reload scdaemon
This is a bug of scdaemon.  I just fixed this.  This is due to the
race conditions where release_application could be called multiple
But, I think that this "Ohhh jeeee" results the process of scdaemon
(PID=32523) aborted.  Do you mean, you needed to kill the another
scdaemon of PID=32745 in this case or the one of PID=32523?

@_date: 2016-07-19 17:54:55
@_author: NIIBE Yutaka 
@_subject: SSH hangs when using GPG2 + Yubikey on OS-X 
Are you using some other tools for Yubikey?
People sometimes do or write a script with
  gpg-connect-agent "SCD RESET" /bye
(to reset PIN auth state) but this only works well if we have a single
connection from gpg-agent to scdaemon.  Having ssh-sessions (with
forwarding), we have multiple connections from gpg-agent to scdaemon.
This could be a cause of troubles.

@_date: 2016-07-20 11:57:06
@_author: NIIBE Yutaka 
@_subject: SSH hangs when using GPG2 + Yubikey on OS-X 
I think that the problem occurs when we do "SCD RESET" above or
removal/insertion of token during the use of SSH.
It seems for me that OpenSSH client (7.2p2, in my case) keeps the
connection to ssh-agent even if it doesn't use forwarding.  So, it is
likely that we encounter this problem.
Today, I fixed this issue by:
Please try it out.

@_date: 2016-07-21 11:21:49
@_author: NIIBE Yutaka 
@_subject: Yubikey + GNUPG 2.1.14 + GPG Agent Forwarding + Mutt 1.6.0 (gpgme 
encryption key
What do you mean by the term "prepopulate"?  Do you invoke
"gpg --card-edit" command line, to invoke the
subcommand "verify"?
In this message, I explain standard pinentry (not loopback mode).
It is gpg-agent which invokes pinentry.  It is not the client program
of gpgme.
Here are steps and the interaction.
(1) here are the processes
 [gpgme]----[gpg]====[gpg-agent]----[scdaemon]
                  ^--- possibly by forwarded socket
(2) A client program (Mutt, in your case) asks decryption through gpgme
       decrypt
 [gpgme]--->[gpg]----[gpg-agent]----[scdaemon]
(3) it goes to scdaemon
               decrypt
 [gpgme]----[gpg]--->[gpg-agent]----[scdaemon]
                              decrypt
 [gpgme]----[gpg]----[gpg-agent]--->[scdaemon]
(4) if the token is not authenticated yet,
    scdaemon asks a user PIN back through gpg-agent
                               "PIN please"
 [gpgme]----[gpg]----[gpg-agent]<---[scdaemon]
(5) Then, gpg-agent invokes pinentry.
 [gpgme]----[gpg]----[gpg-agent]----[scdaemon]
            [pinentry]<---/
(6) pinentry pops up GUI dialog window to user.
 [gpgme]----[gpg]----[gpg-agent]----[scdaemon]
  User <----[pinentry]----/
(7) User inputs PIN by the dialog.
 [gpgme]----[gpg]----[gpg-agent]----[scdaemon]
  User ---->[pinentry]----/
        PIN
 [gpgme]----[gpg]----[gpg-agent]----[scdaemon]
                          ^
            [pinentry]----/
                      PIN
                                PIN
 [gpgme]----[gpg]----[gpg-agent]--->[scdaemon]
(8) scdaemon sends the pin to the token to authenticate.
                                              PIN
 [gpgme]----[gpg]----[gpg-agent]----[scdaemon]-->[token]
(9) Token is ready to decrypt, now.
    scdaemon sends encrypted message to the token.
                                              decrypt
 [gpgme]----[gpg]----[gpg-agent]----[scdaemon]-->[token]
(10) token replies back by decrypted message.... to gpgme.
                                            decrypted
 [gpgme]----[gpg]----[gpg-agent]----[scdaemon]<--[token]
                                decrypted
 [gpgme]----[gpg]----[gpg-agent]<---[scdaemon]
                 decrypted
 [gpgme]----[gpg]<---[gpg-agent]----[scdaemon]
       decrypted
 [gpgme]<---[gpg]----[gpg-agent]----[scdaemon]
You can configure gpg-agent to emit debug message to file.
Here is an example configuration
======================== .gnupg/gpg-agent.conf
debug-level guru
log-file /tmp/gpg-agent.log
 (or /run/user//gpg-agent.log )
Prepare the file, and type following command line:
  $ gpg-connect-agent RELOADAGENT /bye
Then, try to decrypt.  You can figure out the place where thing's
going wrong.
It sounds for me that gpg-agent fails in the step (5) in the figure
above, for some reason.
I have an experience pinentry-gnome3 fails soon after it is execed,
while pinentry-gtk works well.  In some cases, we need to update
environment variable of gpg-agent (like DBUS_SESSION_BUS_ADDRESS and
DISPLAY) to notify change of terminal/desktop, so that gpg-agent will be
able to spawn pinentry on the particular terminal/desktop.  The
command line to update the envvars is:
  $ gpg-connect-agent UPDATESTARTUPTTY /bye
Well, I fixed a bug of UPDATESTARTUPTTY, and it is in 2.1.14.

@_date: 2016-06-10 08:03:30
@_author: NIIBE Yutaka 
@_subject: Forwarding scdaemon over SSH - is it possible? 
You don't need to do that.  Instead, you need to use forwarding of
gpg-agent's socket.  Note that it is gpg-agent which gpg frontend
connects to, and it is gpg-agent which connects to scdaemon.
Once gpg-agent' socket is forwarded, you can access your local
scdaemon, like:
  gpg frontend      --> [by forwarded socket] --> [by normal socket]
  remote your server    local gpg-agent           local scdaemon
It works for me with Gnuk Token, and I don't think it's hardware

@_date: 2016-06-17 13:17:42
@_author: NIIBE Yutaka 
@_subject: How to sign a PDF using a DNIe 
I'd recommend to seek other software instead.
Simply, general smartcard is not supported.  It seems that you have an
illusion that GnuPG and its scdaemon can support any smartcard in
general.  No, we can't.
Fundamentally, while OpenPGPcard can be under control of its user,
general smartcard is designed in the situation that it is under
control by its issuer ( card is usually not a user's property ).
The scdaemon basically supports OpenPGPcard and its compatible only.
For X.509, we have gpgsm and we have drivers for
however, other than SmartCard-HSM, it's outdated.
Technically speaking, following the way of SmartCard-HSM, it would be
possible to support some smartcard for X.509.

@_date: 2016-06-20 08:31:00
@_author: NIIBE Yutaka 
@_subject: OpenGPG Smart Card v2.1 - unable to create key - card error 
I fixed a problem of internal ccid-reader fo this specific reader.
The problem was that decryption didn't work (for RSA-2048 key, I
guess).   FYI, please see: I think that it should work with RSA-1024 and RSA-2048.  I'm afraid
the reader doesn't work for RSA-4096.
I suggest try using with PC/SC service.  It's pcscd and libccid on
GNU/Linux.  There is a little possibility it works fine.  If it works,
please let us know.
Let me explain the situation.
The problem is the buffer size of the card reader.  The descriptor
          Auto configuration based on ATR
          Auto activation on insert
          Auto voltage selection
          Auto clock change
          Auto baud rate change
          Auto PPS made by CCID
          Auto IFSD exchange
          Short and extended APDU level exchange
        dwMaxCCIDMsgLen       272
It supports extended APDU level exchange, good.
However, the size of message is limited by dwMaxCCIDMsgLen=272.  So,
larger message has to be divided into multiple packets.
GnuPG/scdaemon will use larger message for receiving decrypted result,
and/or sending private key to card.  Please note that sending private
key to card occurs for decryption key when "generate" command.
The internal CCID-reader didn't support that multiple packets until
last year.  It was implemented when I handled the issue1947.  I think
that it works now for RSA-2048.
I don't know for RSA-4096.
Please note that I only fixed the driver part.  Still, there is a
fundamental (the card reader's) firmware limitation of the buffer size
of APDU.  In the original CCID class specification, there is no way to
know the buffer size of APDU of the card reader.  So, all that a user
can do is try if it works or not.  It is likely that the supported
APDU size is not so large.
Well, RSA-4096 is considered "huge" from the view point of smartcard.

@_date: 2016-06-27 17:47:28
@_author: NIIBE Yutaka 
@_subject: Tamper Resistance of SmartCards -- NitroKey Pro/ KernelConcepts 
IIUC, NitroKey Pro uses ZeitControl smartcard for crypto computation.
So, it is same as a chip.
I think that the term "tamper resistance" is usually used for a chip,
if it has some counter measure against some sort of physical attacks.
Please note that it doesn't directly mean it can be safe device as a
whole.  I think that we also need some "tamper resistance" in
different level(s).
Well, the combination of smatcard chip + USB MCU (which works as a
card reader) is a kind of practice for a token.  And people discuss it
is good as it's has "tamper resistance" feature (in the chip level).
I think that the combo is generally good thing, but we also know that
this could have a different type of attack vector.
Suppose that an attacker has enough time&budget to manufacture similar
looking device, and it is possible for the attacker to access to my
device multiple times (say, at nights).  Then, there is a scenario
(1) he steals my device when I sleep.
(2) he extracts the smartcard chip from my device.  Then, using the
    chip, he makes a token replacing MCU or MCU's firmware.  The card
    reader part will have a special malicious feature recording PIN of
    mine in the communication.  And he puts back the device to me,
    before I wake.
(3) I just keep using my device.  I don't notice the change because
    "it just works".
(4) he again steals my device, at another night.
(5) Since PIN is recorded in the MCU, my private keys are under
    control by him now (even if the chip itself is "secure").
I usually recommend implementing some counter measure as a device by
customizing your own device.  Here are examples:
            I don't know if it's an effective counter measure or not.  Anyway, I
If it's an effective counter measure, do we need chip level counter
measure?  That's my question.
Already, I know that an effective counter measure is never sleeping.
Please don't suggest this method. :-)

@_date: 2016-06-28 11:16:03
@_author: NIIBE Yutaka 
@_subject: How to sign a PDF using a DNIe 
Last week, I was asked in person, about the possibility of using a
smartcard issued by Japanese government, with GnuPG for OpenPGP and
SSH.  So, I add my comment more.
In my opinion, it's not relevant to use such a card in order to
protect our privacy, even if the technology of the device were great,
even if the availability were good and cost were cheap.
For the specific card, for example, it is issued at a public office
for citizen and we need to enter PIN with a computer in the office
when a key is generated (I don't know if it is really generated there
or not, but they claim so).
Even if the device were great, I don't want to use such a private key
generated by those environment, for myself, for use of GnuPG to
protect my own privacy.  That's because the environment is not
controlled by me at all.  Thus, it is impossible for me to ensure the
private key is only available in the card securely, or my PIN is not
recorded.  On the other hand, I happened to know that the computer has
full of proprietary software (as usual), which no one (at least, no
one at the public office) can control.
The structure is: It's not my device, but someone's; They let me use
the card.  It would be considered healthy for me to think about the
likelihood of honey-pot/trap or other kinds of attack vectors, when I
try to use the card for other purpose.
I think that I only use such a card only when it is mandatory by the
I think that it is opposite way what we should make it possible.  Let
a government accept signature which is generated by our own
smartcard/token with free software.  Or let a governor certify our own
public key, where the private key is in our own smartcard/token.

@_date: 2016-06-29 08:42:48
@_author: NIIBE Yutaka 
@_subject: libgcrypt install problem~~help me 
============================== START ==============================
I think that it is same bug which is reported at:
    Thanks for your description, I think that I found a bug in
If possible, could you try following patch?
diff --git a/cipher/sha1-avx-amd64.S b/cipher/sha1-avx-amd64.S
index 062a45b..70efe95 100644
--- a/cipher/sha1-avx-amd64.S
+++ b/cipher/sha1-avx-amd64.S
 -31,8 +31,8   (defined(HAVE_COMPATIBLE_GCC_AMD64_PLATFORM_AS) || \
      defined(HAVE_COMPATIBLE_GCC_WIN64_PLATFORM_AS)) && \
-    defined(HAVE_GCC_INLINE_ASM_BMI2) && \
-    defined(HAVE_GCC_INLINE_ASM_AVX2) && defined(USE_SHA1)
+    defined(HAVE_INTEL_SYNTAX_PLATFORM_AS) && \
+    defined(HAVE_GCC_INLINE_ASM_AVX) && defined(USE_SHA1)
  __PIC__
 #  define RIP (%rip)

@_date: 2016-03-16 11:14:37
@_author: NIIBE Yutaka 
@_subject: How to make "gpg --card-status" forget an old card 
You are talking about GnuPG 2.1.x, right?
IIUC, for now, there is no way to remove secret key stub by GnuPG.
We can identify the keygrip by:
    gpg-connect-agent 'KEYINFO --list' /bye
I can see something like:
    S KEYINFO 79709FD2793C6A95E0CEF2D6B347CD68FC35B671 T
D276000124010200FFFE872549450000 OPENPGP.1 - - - - -
Then I can remove the file
No, I don't claim this is the way to remove secret key (stub) for
smartcard.  I am only explaining current situation.
I'll consider for improvement.   At least, I think that
    gpg-connect-agent "DELETE_KEY
79709FD2793C6A95E0CEF2D6B347CD68FC35B671" /bye
should be supported.

@_date: 2016-03-16 11:40:08
@_author: NIIBE Yutaka 
@_subject: Getting rid of key stub when moving key to new smart card? 
Possible situations would be:
    (1) Secret key stub was created automatically by --card-status
        with old card after --delete-secret-keys before keytocard.
    (2) The imported secret key (backup) was actually a stub.
For (2), you can check by gpg --list-packets.  If it's real secret
key, you can see something like following.
    :secret key packet:
"skey[2] [v4 protected]" means that it is real secret key.
On the other hand, if it's a stub, it's something like:
    :secret key packet:
"gnu-divert-to-card S2K" means it's a stub.
You can check by "gpg --edit-key YOURKEYID".  When secret key is
there, it says "Secret key is available." and show you the secret key
For 2.1.x, we have a problem; you need to remove the file manually.
For 2.0, --delete-secret-keys should remove the stub.
After removal of the stub and having real secret key, it should be
able to be done.
If you will have encounter any problem, please let me know.

@_date: 2016-03-16 12:58:35
@_author: NIIBE Yutaka 
@_subject: How to silence gpg-agent? 
It is not gpg-agent which outputs this message, but gpg frontend
itself, as it says "gpg:".  GnuPG checks trustdb periodically.
You can stop it by --no-auto-check-trustdb option.

@_date: 2016-05-04 20:37:55
@_author: NIIBE Yutaka 
@_subject: Reiner SCT cyberJack Secoder 2 / PIN pad support? 
If I understand correctly, this device is not CCID (the USB standard
for smartcard reader) compatible.
It seems that it is supported by another library to PC/SC.
    Thus, scd/ccid-driver.c is irrelevant for this device.  All that GnuPG
could do is through PC/SC.
I maintain this list:
    For pinpad input support, please see here:

@_date: 2016-05-06 17:58:06
@_author: NIIBE Yutaka 
@_subject: Batch key creation curve25519 not working in version 2.1.12 
I got success with this:
$ gpg2 --list-key chuji
pub   ed25519/3265921F 2016-05-06 [SC]
uid         [ultimate] Chuji Kunisada sub   cv25519/7CB539CD 2016-05-06 [E]
The Key-Type should be eddsa (not ecdsa).

@_date: 2016-05-07 11:12:39
@_author: NIIBE Yutaka 
@_subject: Batch key creation curve25519 not working in version 2.1.12 
No, it's not a workaround.  It is the correct way to specify the
algorithm.  Well, my description in the previous mail had been bad.
Let me explanation in detail.
In the (forthcoming) OpenPGP standard, we will have a specification
for new key with EdDSA, which has its own algorithm number (= 22).
New algorithm number is required because it's a different thing.  Not
only the curve is different, but also the algorithm is different.
On the other hand, Curve25519 ECDH encryption is considered as an
extension of existing algorighm of ECDH with the specific curve.
Theoretically speaking, we could consider ECDSA with the curve of
Ed25519.  If people really wanted to use it, I'd say, it would be a
bug of GnuPG.  The priority of fixing this (as a bug) is not that
high, though.

@_date: 2016-05-09 10:34:22
@_author: NIIBE Yutaka 
@_subject: Speading up key generation 
If there is no other sources, it is good to use haveged.  I think that
haveged implementations depends on CPU and something like High
Precision Event Timer (HPET), but user would just use haveged with no
HPET system, or even on a VM.
While harvesting CPU-internal data is convenient, it would be
controversial.  It would be easier for attackers to maliciously
control the key generation when it's not external source.
I use my own TRNG for my key generation.
    Let's Make "NeuG USB Device" by STM32 Nucleo F103, together:

@_date: 2016-11-17 09:37:44
@_author: NIIBE Yutaka 
@_subject: TRNG (was: Specifying entropy source) 
I work for my own TRNG implementation.  I realized that the point is:
    We should collectively control things so that none can control a
    sequence of random bytes.  --- (*)
Second "control" in (*) includes guessing, predicting, or knowing, not
only manipulating directly/indirectly.
Things include software, hardware, and the process of making software,
hardware, etc.
I observed that people have tendency to prefer an exotic noise source,
but it is not that important matter for me.  Rather, if a TRNG device
depends on some exotic technology, I count it as a weakness because it
makes it difficult to be reproducible and transparent.
In general, OpenPGP card implementations have a random number
generator.  I mean, it's not only the feature of Gnuk.  It is
accessible by gpg-connect-agent.  Here is an example.
$ gpg-connect-agent --hex "SCD RANDOM 32" /bye
D[0000]  F8 04 49 F3 BA D9 85 44  47 54 F5 89 B5 49 EA E7   ..I....DGT...I..
D[0010]  46 20 1E 09 15 AC 38 7E  9E 50 0E D7 28 19 64 15   F ....8~.P..(.d.
I think that this is useful when a person installs an OS into a new
machine, or when people use machines for clean boot with fixed media
like CD.  Feeding those random bytes to /dev/random can make the
barrier higher (against guessing, predicting, or knowing).
Thank you, Diego, for the introduction.  The device is available at:
I think that "completely open" is not achieved, yet.
Although I tried my best making it free, reproducible and transparent
(I use the tube on purpose to demonstrate its transparency), it's not
perfect; While firmware is Free Software assuming Free Software
development environment only, and the PCB design is free and the
design assumes Free Software development environment only, it still
depends on the MCU chip (manufacturer and its distribution channel)
and the manufacturer of PCB assembly.
Suppose that there were a proprietary TRNG device by some alien (I
mean, an external entity).  As a gift, the alien deliberately left the
TRNG which generation of randomness cannot be controlled by anyone in
this planet.  In this case, this TRNG is useful for us, perhaps.
Given no such a gift on earth, I believe that we need free,
reproducible and transparent one even not perfect.
Well, I think that the TRNG device is very good for a gift to hackers.

@_date: 2016-10-07 11:56:14
@_author: NIIBE Yutaka 
@_subject: using with su/sudo 
One possible way is invoking gpg with an option
 --pinentry-mode=loopback.
I confirmed this issue with TTY.  The cause is that pinentry cannot
open the TTY in question in the situation of its owner is original
user.  It's EACCESS (Permission denied) to TTY device when pinentry
tries to open the TTY.
I created a ticket at the bug tracker.
    With the situation of gpg-agent's allow-loopback-pinentry is default
now, perhaps, it would be the best (from the user's viewpoint) that
gpg-agent automatically fallbacks to loopback mode.
On window system, I think it doesn't work either...

@_date: 2016-10-13 08:27:46
@_author: NIIBE Yutaka 
@_subject: using with su/sudo 
Thank you.  Actually, I have a problem like that, everyday (literally).
Yes, this is the same error for me, too.
In my case, I do:
    $ gpg-connect-agent updatestartuptty /bye
to fix the situation.
My case is that, I configure systemd to start up gpg-agent.  In this
case, gpg frontend works well with its session environment, but ssh
doesn't work.
In this configuration, gpg-agent starts with no env defined, like:
    $ gpg-connect-agent "getinfo std_startup_env" /bye
    OK
    $
Then, the command "updatestartuptty" can fix the situation.
I think that gpg-agent is unkind enough (for error message, at least),
it could/should know pinentry doesn't work well with not proper TTY
ownership, no GPG_TTY.
In the case of su/sudo, I would consider automatic fallback to
loopback mode, or argue about file discriptor passing of UNIX domain
socket.  I have no idea how gpg-agent with null std_startup_env can do
for SSH...

@_date: 2016-10-18 17:58:31
@_author: NIIBE Yutaka 
@_subject: reviewing wiki / shortlist PIN-pad readers 
Sorry, I didn't have time to reply your call the other day.
I think that Gemalto Shelltoken Card Reader, which is available
at  is good one.
Please note that OpenPGP card requires specific card readers.  Its
users usually use RSA-2048, RSA-3072, or RSA-4096.  For those key
sizes, the communication is somewhat difficult for old standard of ISO
7816.  (For RSA-1024, most smart card readers work well.)
I recommend TPDU readers, because readers which support extended APDU
level communication tend to have issues for larger size communication.
I implemented the pinpad input support in scdaemon.  While I know some
claims that it is good feature, I, for myself, don't think it's worth
to have.
I don't think the attack to USB communication could be mitigated by
pinpad card reader.  If such an attack is possible, a user already
would be defeated.
It is common for such card readers to have only numeric pads.  That
limits the entropy of passphrase, considerably.  And, as far as I
know, I don't know any implementation of card readers in the market,
which firmware is Free Software.  With user interface like pinpad
input, it is more difficult for me to trust an implementation of such
a card reader.

@_date: 2016-10-19 08:36:27
@_author: NIIBE Yutaka 
@_subject: smartcard reader 
Ah...  This is not a card reader.  It is the project of Free Software
Initiative of Japan (FSIJ) since 2010.  FSIJ acquired USB vendor ID,
specifically for this project.  Please visit:
    Card reader products are more complex than the hardware requirement of
Gnuk.  If you like KISS philosophy, you might prefer Gnuk Token.
It is sold as an evaluation board.  It happened to have Gnuk 1.0.1
installed.   It is an implementation of reader+card.
This has TRNG implementation (NeuG 1.0.4), instead.  The source of
noise is not that exotic, though.  You can replace the firmware to
Gnuk by yourself.  The upgrade process doesn't require JTAG/SWD
debugger, but having JTAG/SWD debugger is highly recommended to
control your computing (or just in case when failure of upgrade).
Hardware is same (sans cover).  The support page is here:
    I tried to sell the hardware widely as possible with help by Seeed and
FSF, but my capability is limited.  Selling hardware product means
we need to follow regulations.  That's difficult for me.
For Europe, I heard that Nitrokey Start runs Gnuk 1.0.4.  Availability
of this product is better, I suppose.
I think that Nitrokey Start and Nitrokey Pro is based on the hardware
design of mine (although I was not involved).  I got a report to Gnuk
Mailing list about firmware upgrade of Gnuk doesn't work well on
Nitrokey Start.  If someone can investigate the cause and possibly fix
an issue, it will be great.
I gave a talk of Gnuk at There is a link to my slides.

@_date: 2016-09-09 13:16:39
@_author: NIIBE Yutaka 
@_subject: smart card no longer works 
Please use the standard scdaemon from GnuPG.
PC/SC service is optional.  In-stock CCID driver of GnuPG just works
well in most cases.  Only when it doesn't work, please try
to install pcscd and libpcsclite1.
For PKCS things, we (GnuPG team) do totally in different way by
Scute, when people want to use the PKCS API.  I don't think
gnupg-pkcs11-scd works, these days.
Packaging in Debian had been changed.  Now scdaemon is in a package of
"scdaemon" (used to be in "gnupg2" package).

@_date: 2016-09-10 13:27:47
@_author: NIIBE Yutaka 
@_subject: :-(( Re: smart card no longer works 
I don't have any experience with this error behavior.  Please describe
the situation and the interaction; Did you input passphrase and push
[OK] button, and then gpg failed?
Please try again with pinentry-curses and/or pinentry-tty.  Does it work?

@_date: 2016-09-20 18:15:28
@_author: NIIBE Yutaka 
@_subject: Smartcard reader Precise Biometrics 200 MC 
For the reader, I found this discussion in 2010:
It seemed that it became "unsupported" by PC/SC lite.  So, it is
highly likely not working with GnuPG.
Well, I maintain this list:
    Please install scdaemon.  Your operating system may require some
other permission settings.  For example, Debian GNU/Linux has:
    /lib/udev/rules.d/60-scdaemon.rules
If your reader is not listed in such a file, you need your own

@_date: 2017-04-10 11:49:56
@_author: NIIBE Yutaka 
@_subject: Passphrase cache w/Yubikey varies: sign vs auth 
It is not misconfiguration.  It is expected behavior.
Please note that there is no passphrase cache on host side for
smartcard.  It is the OpenPGP card which has the "authenticated" status.
Once it gets authenticated by PIN, a user can ask crypto operations.
And there are two different authenticated statuses for a user.  We call
them CHV1 and CHV2, where CHV means Card Holder Verification.  One for
signing (CHV1) and another for others (= decryption and authentication,
For OpenPGP card itself, CHV1 and CHV2 are independent (for v2 and
By using GnuPG, they are not independent.  When a user authenticate for
CHV2, CHV1 is also authenticated automatically (provided the flag of the
card for "Signature PIN" is "not forced").  When a user authenticate for
CHV1, CHV2 is not affected.
I agree this is a bit confusing.  I don't know why it is so.  Perhaps,
we had some compatibility issue with older OpenPGP card.
I don't think we have an easy way to avoid being asked PIN for SSH after

@_date: 2017-08-03 07:00:04
@_author: NIIBE Yutaka 
@_subject: Bitcoin private key from GnuPG secp256k1 secret key? 
I don't know about secret key conversion.
In the past, I did something for public key:
    However, soon after this scripting, it occurred the Mt. Gox incident in
Japan.  And I learned that most "users" don't control their private key
for Bitcoin at all, just like general citizen don't control printing of
paper money.  So, no further development for my side.  It was not
committed to GnuPG repo.  (I only have a transaction with the address.)
If someone will make transaction to that address for some amount, I
would resume the development again. :-)

@_date: 2017-08-03 16:24:05
@_author: NIIBE Yutaka 
@_subject: Bitcoin private key from GnuPG secp256k1 secret key? 
Sorry about my vague description.
As a subkey of 0x00B45EBD4CA7BABE, I have a key of secp256k1.  And the
private key is controlled by me, on a Gnuk Token.  But I have no
"wallet", yet.  This is the situation.
My idea was that we can use WoT of OpenPGP to check Bitcoin address.
It seems that people don't buy this idea.

@_date: 2017-12-04 18:20:21
@_author: NIIBE Yutaka 
@_subject: Performance regression, 2.2.3/recent? 
It seems that pubring.kbx is accessed recursively (something by depth 3,
by fd: 4, 7 and 10 (fd 3 is to check the file type, I guess)).
Could you please try with --no-expensive-trust-checks option, if it
changes the behavior?

@_date: 2017-02-09 15:02:13
@_author: NIIBE Yutaka 
@_subject: Non-deterministic behavior using GnuPG and a smart-card 
I think that it is deterministic; The cause is that the RSA keysize is
not the one in the set of: 1024, 1536, 2048, 3072, 4096.  When data to
be decrypted is padded, scdaemon can't decrypt, I suppose.
I am not sure the exact reason why scdaemon only supports limited set of
keysize for encryption.   But we have this handling of padding in the
current code:
           /* We might encounter a couple of leading zeroes in the
          cryptogram.  Due to internal use of MPIs these leading zeroes
          are stripped.  However the OpenPGP card expects exactly 128
          bytes for the cryptogram (for a 1k key).  Thus we need to fix
          it up.  We do this for up to 16 leading zero bytes; a
          cryptogram with more than this is with a very high
          probability anyway broken.  If a signed conversion was used
          we may also encounter one leading zero followed by the correct
          length.  We fix that as well.  */
       if (indatalen >= (128-16) && indatalen < 128)      /* 1024 bit key.  */
         fixuplen = 128 - indatalen;
       else if (indatalen >= (192-16) && indatalen < 192) /* 1536 bit key.  */
         fixuplen = 192 - indatalen;
       else if (indatalen >= (256-16) && indatalen < 256) /* 2048 bit key.  */
         fixuplen = 256 - indatalen;
       else if (indatalen >= (384-16) && indatalen < 384) /* 3072 bit key.  */
         fixuplen = 384 - indatalen;
       else if (indatalen >= (512-16) && indatalen < 512) /* 4096 bit key.  */
         fixuplen = 512 - indatalen;
       else if (!*(const char *)indata && (indatalen == 129
 indatalen == 193
 indatalen == 257
 indatalen == 385
 indatalen == 513))
         fixuplen = -1;
       else
         fixuplen = 0;
Perhaps, it was due to support all existing OpenPGP card
implementations, I mean, somehow historical, and it was easier to list
up specific keysizes.
This should be fixed.

@_date: 2017-02-14 11:33:10
@_author: NIIBE Yutaka 
@_subject: SmartCard v2.1 : factory reset fails 
Since I got 2.1 card last week, I will test with it.  For time being,
I say something what I know of.
Umm... This error message can be only happened at setting the Reset
Code.  Strange.
The length of the Reset Code should be more than or equals to 8.  If it
is shorter, it fails.  What is your case?

@_date: 2017-02-15 18:42:27
@_author: NIIBE Yutaka 
@_subject: Aw: Re: SmartCard v2.1 : factory reset fails 
Hello, again,
I found a bug in GnuPG 2.1.18 for factory-reset command handling (it's
not in 2.1.17 or older), I fixed it today.
Then, I tested my OpenPGP card 2.1.
Let us fix a thing one by one.  First, the Reset Code handling.
For my OpenPGP card 2.1, the Admin PIN is "12345678" (no 9).
I can successfuly set the Reset Code.
I confirmed that with wrong Admin PIN, I got the message "Error setting
the Reset Code: Bad PIN".
Please test with 12345678.

@_date: 2017-02-16 11:48:45
@_author: NIIBE Yutaka 
@_subject: Aw: Re: SmartCard v2.1 : factory reset fails 
Let us show more info about your key.  I'm afraid your key size
is not the one OpenPGP card supports.  I tested RSA-2048 with
OpenPGP card version 2.1, it works fine for me.

@_date: 2017-02-17 09:00:00
@_author: NIIBE Yutaka 
@_subject: Aw: Re:  Re: SmartCard v2.1 : factory reset fails 
Thanks a lot for your report in detail, in the style which I can replicate.
I'm afraid you are facing same issue what I encountered in 2011.
CHANGE REFERENCE DATA (OpenPGP card specification 2.0):
IIUC, this protocol is due to smartcard practice and standard.  I had
asked Achim (the author of OpenPGPcard specification) if this could be
changed.  No positive answer, but I think that the problem is clear
Yes.  Now, New Admin PIN is *9smartcardrocks*.
I understand your expectation.  It was exactly same of mine.  But, new
Admin PIN is *9smartcardrocks*, which is totally confusing.
Yes.  The bug (from my point of view) is still there.
No, I don't have an idea to keep this problem forever.  I am currently
considering KDF generation scheme by host side.  I'm going to send my
proposal to Achim.  In this new scheme, the length of string for PIN is
fixed.  And then, this problem will be no longer valid.  That's my
development now.

@_date: 2017-02-21 11:32:46
@_author: NIIBE Yutaka 
@_subject: Problems with cert validation via CRL 
Please note that my knowledge of gpgsm and X.509 is pretty much limited.
Do you have .gnupg/trustlist.txt on Ubuntu machine?  It can be created
when you answer dialog of gpgsm by pinentry interaction.

@_date: 2017-02-22 11:31:54
@_author: NIIBE Yutaka 
@_subject: Problems with cert validation via CRL 
Hello, again,
Reading the code of dirmngr, I think that --fetch-crl (or dirmngr-client
--load-crl) doesn't work well for a CRL which is not signed by system CA
directly.  When dirmngr doesn't know the issuer, it inquires back to the
client, and it fails as:
When it is gpgsm which asks dirmngr to validate a certificate, I think
it works.
I think that you once successfully did that on this box:
And the CRL is cached.  Thus,
This is gpgsm asking if your X.509 client certificate is valid or not.
Here, I think that the CRL for your X.509 client certificate is cached
and checked.  dirmngr does not ask about anything about your X.509
client certificate or its issuer.
dirmngr inquires back to gpgsm if the root issuer is trusted.
    CN=AddTrust External CA Root,OU=AddTrust External TTP Network,O=AddTrust AB,C=SE
    fingerprint=02FAF3E291435468607857694DF5E45B68851868
then, gpgsm asks to gpg-agent.
It is trusted.  Then, gpgsm replies back to dirmngr.
It's trusted.
Then, dirmngr answers OK for the validation of your X.509 client certificate.
This is gpgsm asking if the intermediate certificate of following is
valid or not:
    CN=COMODO SHA-256 Client Authentication and Secure Email CA,O=COMODO CA Limited,
    L=Salford, ST=Greater Manchester, C=GB
    fingerprint=59B825FC08860B04B392CC25FEC48C760753B689
Similar interactions between gpg-agent<->gpgsm<->dirmngr.
I don't know the exact reason, but gpgsm again asks gpg-agent.
And gpgsm shows your X.509 client certificate:
On the other hand, on your Windows...
Here, gpgsm asking if your X.509 client certificate is valid or not.
And then, dirmngr inquires back to gpgsm about the certificate.
Then gpgsm sends it to dirmngr.
And then, dirmngr inquires back to gpgsm if the root issuer is trusted.
    CN=AddTrust External CA Root,OU=AddTrust External TTP Network,O=AddTrust AB,C=SE
    fingerprint=02FAF3E291435468607857694DF5E45B68851868
then, gpgsm asks to gpg-agent.  It is trusted.  Then, gpgsm replies back to dirmngr.
But, dirmngr says no CRL known for your X.509 client certificate.
I don't know what's going on here.  You can enable debug option of
dirmngr (debug-level, log-file, debug-all) in your dirmngr.conf.
This is the interaction for the intermediate certificate.  Nothing wrong here.
You can check your X.509 client certificate by
    $ gpgsm --verbose --dump-cert 0x2F5900E9
to see its CRL or more information.

@_date: 2017-02-28 08:28:21
@_author: NIIBE Yutaka 
@_subject: How U2F works 
Let me ask a question about U2F.  Or, more generally, possibility to
enhance GnuPG for web authentication.
While I maintain scdaemon of GnuPG and develop Gnuk (an OpenPGPcard
implementation), I sometimes am asked about U2F support, these days.
(I think that this is due to Yubikey.)
IIUC, major use case of U2F is web authentication.  It seems for me
that it doesn't fit directly to OpenPGPcard use case.
Anyhow, it would be possible for Gnuk to add U2F support (somehow
limited, because of available resource on board).  Also, it would be
possible for scdaemon (or other application) to emulate U2F protocol
(just like Scute does emulate PKCS
Well, I have two concerns for U2F.
(1) Atterstation key
In the document of U2F:
It explains about Atterstation key.
If it were common for services to do this Atterstation key check, U2F
emulation or free U2F implementation will be no real use with no private
key of the vendor.   (It reminds me the old days when Apache couldn't
serve https because no certificate authority issued certificate for servers
with Apache.)  I wondor if Atterstation key check is common or not.
(2) JavaScript
It seems for me that there are special JavaScript(s) to offer access API
to U2F.  I don't quite understand how it works to the physical device.
I don't like nonfree JavaScript which may interfere user' control.
Is it easy for free script (as in freedom) to integrate a script for U2F
access?  Any such example scripts or any such services which do so?
Here, my concern is that if it is all for proprietary world, I am
reluctant to consider seriously about U2F.
And finally, if web authentication is important, I would like to use the
infrastructure of GnuPG to manage my own crypto computation and my own
private keys.  Currently, we can use GnuPG for SSH authentication by
its ssh-agent emulation.  I would like to extend this.
Any thoughts?  Thanks in advance.

@_date: 2017-02-28 19:04:08
@_author: NIIBE Yutaka 
@_subject: How U2F works 
============================== START ==============================
Thanks a lot for your explanation.
I see.  I read the spec. again, IIUC, the generated keys in token will
be all signed by the attestation key.  I think that it is better for the
server side to check the signature so that it can detect possible MitM
attack.  I don't think it can be "optional" in real fields.
It would be possible to arrange a vendor attestation key of U2F for
Gnuk.  We did in a different level; We got USB vendor ID for our
However, with the OpenPGP background, I feel that it sounds wrong to
allow such an idea of a single secret shared among many devices.
If we do something like that (to assure authentication key generated
by a specific device), possible method for OpenPGP would be:
(1) Gnuk will have a feature of "device specific key".
(2) As initialization procedure, a distributor let a token generate
    "device specific key" when they ship the device to a customer.  They
    record the public key of each "device specific key" of customer.
(3) The distributor signs a public key of the "device specific key".
(4) When Gnuk generates authentication key, a signature by "device
    specific key" is also generated.
(5) It is up to a user to use distributor's generated "device specific
    key" and their signature.  A user can let a token generate new
    "device specific key", and anyone can sign the public key of
    "device specific key".
(6) Servers can check if an authentication key is signed by "device
    specific key" which is signed by trustworthy distributor.
Well, probably, description above would be a different attestation key
for each device, in terms of U2F.
I see.  I was afraid that a user has to accept nonfree JavaScript
from server when she wants to use U2F authentication.
It is because of a simple reason.  I can't check the hardware and the
firmware in the current implementations of U2F devices.  I would like
to control my crypto computation in a way I can examine.

@_date: 2017-01-18 08:21:18
@_author: NIIBE Yutaka 
@_subject: Feature request: treat missing smartcard reader as missing 
Good point.
In the development branch, I'm currently working for multiple card/token
support (currently only with internal CCID driver).  And I also happened
to notice this difference this month.
Now in the repo (master), signing and decryption work well with multiple
card/token and a user is prompted when there is no relevant card/token.
This is just a lucky coincidence, but I'm glad to see the development of
GnuPG goes well.
Thank you for your support of GnuPG.  Your support encourages me
(hopefully, all of us) fixing bugs and adding feature(s).

@_date: 2017-01-20 08:17:02
@_author: NIIBE Yutaka 
@_subject: spr332 vs spr532 
I wrote this page, when I added the support of pinpad input to scdaemon.
Since Werner has SCM SPR 532, it was tested and listed.  Please note
that the list is not for recommendation (as of today); Vasco DigiPASS
920 (which I have) worked, but it only supports key length <= 1024-bit
of RSA.  Gnuk Token is listed, but it has no hardware pinpad, in fact.
Some other readers were listed because they requires special handling to
work around issues of their firmware.
I think that: if you need a tested reader, go for the 532.  If you have
time and energy, go for the 332 and please let us know if it works or
not.  I guess that it is likely work well with PC/SC and we need a bit
of change for the internal CCID driver of GnuPG.  If it will work, I'll
put it on the list.  That will be a great contribution to GnuPG

@_date: 2017-01-26 11:07:44
@_author: NIIBE Yutaka 
@_subject: Smartcard working completely with GPG2 and incompletely with 
Thank you for your report in detail.
gpg 1.4 can use gpg-agent by the option use-agent.  I think that you
enable this option in .gnupg/gpg.conf.
Yes, gpg 1.4 can be used with the gpg-agent of GnuPG 2.0, this usage is
supported well.
scdaemon in GnuPG 2.1 has been enhanced to support ECC, and the particular
protocol of KEY-ATTR has been changed.  This is the cause of the issue.
While I'm sure scdaemon 2.1 doesn't work well with gpg 1.4 by protocol
incompatibility, I'm not sure how gpg 1.4 can be used with the gpg-agent
of 2.1, in general.  In my opinion, I don't think this usage is
well supported in the current development of GnuPG.
Let us see.
Are there any reason why the combination of gpg 1.4 and gpg-agent 2.1 is

@_date: 2017-01-27 09:58:57
@_author: NIIBE Yutaka 
@_subject: Smartcard working completely with GPG2 and incompletely with 
I located the cause of this issue.  It is not the issue of scdaemon
incompatibility of GnuPG 2.1, which I addressed yesterday.
With GnuPG 1.4 for smartcard can't work well for RSA 4096-bit keys.  (I
think that it can also occur with the combination of GnuPG 1.4 and GnuPG
In the code of g10/cardglue.c, the buffer length is 1002-byte by the
definition of ASSUAN_LINELENGTH [0], but this length is not enough for
the checking at [1].  (To represent encrypted value of 4096-bit itself,
it requires 1024-byte by hex string.)
[0] [1]

@_date: 2017-07-05 09:23:06
@_author: NIIBE Yutaka 
@_subject: scdaemon does not "see" card insertion 
Right.  Scdaemon only watches the event of card removal and card reader
In the past, once, scdaemon implementation in 2.0 partially tried to
support watching insertion, too.  The name "scdaemon" would have implied
that, perhaps.  We couldn't go this road well, because a card reader is
shared resource and there are valid use cases for other cards.
Then, the development of scdaemon evolved as openpgp-card-helper for
This focus could stabilize the use case for GnuPG, and it resulted
less conflict for other use cases for card and card reader.
IIUC, system level service like devd can only handle the event of card
reader insertion, not card insertion.  I may be wrong here.
I think that it is good for your use case to use PC/SC daemon
and its related tool.
I found a tool named card_eventmgr in:
    This may help.  (No, I don't have any experience with this tool.)

@_date: 2017-03-06 12:17:55
@_author: NIIBE Yutaka 
@_subject: How U2F works 
Thanks a lot for the information.
Well, I concluded that it is not worth (for me) to try to integrate U2F
feature into Gnuk.  If some free software friendly network service sites
ask me a possibility to use such a method to authenticate their users,
firstly I would propose better method which can respect users' computing
better instead, secondly I would propose developing as a separate
firmware implementation (possibly re-using Gnuk lower-level code) as
The reason is:
    The use cases are so different: The model who/how controls crypto
    computation is so different.  (I mean, Gnuk vs. U2F)
I had been somewhat naive when I saw U2F specification at first.  I was
considering like:
  * While U2F uses X.509 certificate by the attestation key (in the
    specification), it could be OpenPGP certificate.
  * Free Software implementation of U2F would be nice thing.
but, I leaned the reality.
In my opinion, the attestation key is a "key", literary and it is not
wise for network service providers not to check certificates (say, to
avoid MitM attack).
Here is my understanding.
I think that U2F offers network service providers a method of device
authentication and those who can trust the device vendor can use this
method to augment their user authentication.
Here is a picture, explaining the method.
    [ Network service provider: A ]  --------------\ Trust
  protocol for remote use of token  |
         [ User: U ]===having a token T1 by [ Device Vendor: D ]
  protocol for remote use of token  |
    [ Network service provider: B ]  --------------/ Trust
Note that U2F itself is not user authentication.  User authentication is
composed at network service provider side by traditional
username+passphrase AND the fact a user has the device (which can be
made sure by U2F device authentication).
In the design, the device is assumed to be shared among different
network service providers.
U2F is the protocol to offer remote crypto computation by network
service providers.
Users are... offering electric power to the device.  Users help network
service providers so that the U2F authentication can work effectively
(say, by providing their fingerprint).
In such a scheme, network service providers don't hesitate to send
nonfree JavaScript to their users, because the purpose is doing remote
use of the vendor's token (I don't say, it's user's token, even if
user is a "holder" is the token).

@_date: 2017-03-07 08:52:04
@_author: NIIBE Yutaka 
@_subject: How U2F works 
Scalability, and some (or the) trust model which supports that.
The common practice for (X.509) user certificates is they are issued by
a specific network service provider, and it's useless for another
network service provider.  Users have to install each certificate issued
by each network service provider.  And this is not easy to manage such a
Ideally, we would have a good method to handle user certificates on
client machines, and have a practice using X.509 user certificates
by..., say, with "root CA"s.
OpenPGP community would say, it could be done reliably in a way of
distributed mechanism by OpenPGP certificates, right now.  Right,
technically, it's true.  The question is: How about in practice?
I think that user certificates (either, by X.509 or by OpenPGP) won't
work well than something like U2F.  I think that here, U2F offers a
"solution", in clever and practical way.
Well, let me explain from another angle.
I live in a small town.  In some cases, I buy things based on mutual
trust, directly or indirectly.  I use cash (or even credit card in some
specific cases), but shop owners are basically trust me.  We use money,
Japanese Yen.  But in a few cases, it is not needed in that form.  For
our own rice (most important food), I don't have to pay in the form of
money.  I live in such a town, intentionally.
I used to live in Tokyo for many years.  Shop onwers trust some credit
card service company and Japan Bank as an issuer of paper money.  They
don't necessarily care about me or anyone, who is buying their
products/services, as long as they can get paid.
Money scales.  Credit card scales.  That's because they don't require
direct mutual trust between a shop and a stranger who visits a shop.
All that shop owner needs is... to trust money.
That's my understanding.
I think that most important factor is not users, here (it is related,
Using U2F might be easier for a network service provider, when other
network service providers have introduced such a feature in their
service already.  For an engineer or an administrator around web
services, it would be just "easy", like installing a few modules,
probably, while preparing X.509 user certificates requires complex and
difficult things.

@_date: 2017-03-25 21:01:32
@_author: NIIBE Yutaka 
@_subject: Generating RSA-4096 on Nitrokey Pro 
I have read the log which you attached on Monday.
I think that the CCID driver has a bug for TPDU handling for time
extension from the card.
This problem never occurred when a reader handles a time extension from
card and changes into the request of time extension from the reader.
I'll check how it works with my reader and OpenPGP card 2.1.  I will fix
the CCID driver.
Nitrokey Pro also can handle the card's request of time extension to
chang it to reader's request.
Anyhow, scdaemon of GnuPG should be fixed.

@_date: 2017-03-27 11:40:30
@_author: NIIBE Yutaka 
@_subject: Generating RSA-4096 on Nitrokey Pro 
I confirmed that the problem can be reproducible with Gemelto card
reader (TPDU exchange).
The problem is that OpenPGP card (2.0 or 2.1) needs time out detection
of 43 seconds or so, and its BWI request value is 100 (which is quite
The internal CCID driver doesn't handle block waiting time (BWT)
correctly according to the card protocol, but uses fixed timeout value
of 13-second.
I put a kludge to handle this special case in the internal CCID driver.
Fixed in 0848cfcce738150b53bfb65b78efc1e6dc9f3d26.

@_date: 2017-03-28 08:24:23
@_author: NIIBE Yutaka 
@_subject: Homedir & scdaemon 
For your information, this is fixed in 2.1.  If you will have a chance,
please try version 2.1.

@_date: 2017-03-29 08:21:59
@_author: NIIBE Yutaka 
@_subject: Homedir & scdaemon 
Sorry, I should have offer more information.
Umm... it is better to have libgcrypt 1.7 for GnuPG.
Specifically, it was fixed by following commits.
I confirmed that --homedir works fine with 2.1.16 and later.

@_date: 2017-03-31 16:21:44
@_author: NIIBE Yutaka 
@_subject: How U2F works 
============================== START ==============================
While I am open to discussion, my current position is that it is better
for Gnuk not to integrate the U2F feature.  I'd rather prefer separate
implementation of U2F, if needed, possibly reusing code of Gnuk (crypto,
USB, etc.).  I mean, by separate device.
My reasons are:
* The nature of two use case (OpenPGP private key vs. authentication for
  network service providers) are quite different.  Generally, Gnuk users
  don't want to allow other new additional attack vectors, because of
  adding "new feature" (and U2F would come with them).  OpenPGP private
  key is so important for Gnuk users.  U2F key is just a thing to enter
  web service which is owned by a device vendor.  For me, it is not wise
  to invite possible attacks just for some usefulness of
  not-so-important thing.
* Resource on physical board is quite limited (20KB RAM and 128KB ROM).
  For code space, we will need some features of Gnuk if we integrate
  U2F or other features.
* Unfortunately, currently, both of Gnuk and U2F uses same protocol of
  USB CCID.  In a host system, it is the practice of CCID on host side
  to access the device exclusively to mitigate some attacks (changing
  while using).  For example, GnuPG's scdaemon requires exclusive access
  to Gnuk Token.  I think it is also same or similar to browser access
  to U2F device.  I think that a single CCID device can't serve two
  different programs on host simultaneously.
Well, we can manage and consider possible solutions for the latter two
technical problems.  The first problem is most important, I suppose.
Keep adding things, it will become a system like host system,
eventually.  The purpose to separate out the management of OpenPGP
private key to a dedicated device is: make it simple and easier to
achieve better security.

@_date: 2017-05-16 16:24:00
@_author: NIIBE Yutaka 
@_subject: command 'LEARN' failed: No inquire callback in IPC 
What's the configure option?  Did you enable smart card support with
This is not the scdaemon from GnuPG.
Please install scdaemon of GnuPG and try again with that.

@_date: 2017-05-17 15:31:44
@_author: NIIBE Yutaka 
@_subject: command 'LEARN' failed: No inquire callback in IPC 
No, scdaemon doesn't support it.
Well, I think that gnupg-pkcs11-scd is not supported by GnuPG, 2.0 or
2.1.  It is a kind of... independently developed program, unfortunately.
It was just coincidence (from my view point) it worked with GnuPG 2.0.
It would be good if someone around gnupg-pkcs11-scd shares developement
information with GnuPG.
Well, it's the detail of protocol between gpg-agent and scdaemon.
INQUIRE NEEDPIN from scdaemon is not expected by gpg-agent when LEARN
--force is issued.  This situation is same in GnuPG 2.0.
We don't know how gnupg-pkcs11-scd works, according to your log, it
breaks the protocol for LEARN.
gpg-agent only delegates back the INQUIRE NEEDPIN request to gpg when it
is prepared: PKSIGN, PKDECRYPT, WRITEKEY, and generic SCD.
For gpg-connect-agent with SCD command, it is prepared, thus it works.
I think that it would be good to check why gnupg-pkcs11-scd called back
with INQUIRE NEEDPIN for LEARN command.

@_date: 2017-05-18 19:27:24
@_author: NIIBE Yutaka 
@_subject: Did exit codes change in 2.1.21? 
This is due to my badness.  I wrongly assumed everyone uses smartcard.
Here is my fix:
   Please try this patch.

@_date: 2017-05-31 10:12:35
@_author: NIIBE Yutaka 
@_subject: scdaemon coredumps 
Thank you for your report.
There are two things here.  The selection of default key by gpg frontend
was not good.  It was fixed in:
    fbb2259d22e6c6eadc2af722bdc52922da348677
    g10: Fix default-key selection for signing, possibly by card.
And by your report, scdaemon core dump is fixed in:
   5c33649782bf255af5a55f16eac5e85f059b00bf
   scd: Handle a failure of libusb_init.
   8defb21d34410d000c8b776e0e3a1edd04762638
   scd: Fix error code on failure at usb_init.
I don't know what's going here.  Let's see...

@_date: 2017-11-06 08:56:37
@_author: NIIBE Yutaka 
@_subject: Cannot control GnuPG from shell (IPC parameter error) 
Please update your installation.
IIUC, you are talking about (old version of) gpg4win, which is based on
GnuPG 2.0.x, and you are trying to use new feature(s) of GnuPG 2.2, like

@_date: 2017-11-21 18:50:18
@_author: NIIBE Yutaka 
@_subject: Using the OpenPGP Card on Unix && Win7 
You have five card readers (the last one looks strange, though).
GnuPG's scdaemon select the first one as default.  IIUC, you want to use
'Identiv uTrust 3512 SAM slot Token 0'.
In .gnupg/scdaemon.conf, you should have something like:
reader-port "Identiv uTrust 3512 SAM slot Token"
... to select the token.

@_date: 2017-11-24 09:48:43
@_author: NIIBE Yutaka 
@_subject: Encrypt to a key without importing it to keyring 
AFAIK, such a usage is not supported by GnuPG.
Well, I would imagine some use cases when we want to avoid any
dependency to specific user's configuration, keyring, and trustdb, of
his own.
Approximation would be using ephemeral GNUPGHOME.
I mean, starting your GnuPG session (or script) with:
   $ export GNUPGHOME=$(mktemp -p /run/user/$(id -u) -d)
   $ chmod og-rwx $GNUPGHOME; echo $GNUPGHOME
and remove the $GNUPGHOME after its use.
This is very useful for testing GnuPG, for example.

@_date: 2017-10-24 15:15:08
@_author: NIIBE Yutaka 
@_subject: gpg-agent UI when waiting for smart card touch? 
Some change in the protocol is required to implement this feature.
Most easy change would be adding a new flag into Slot Status register
in the CCID specification 1.1.  See page 55 of the specification for
the Table 6.2-3 Slot Status register.
Say, using bit-2 as: waiting user interaction flag, when Time extension
is required.
With that flag, the device will be possible to notify scdaemon (then,
gpg-agent) to pop up dialog.
Since we already have a flag in the card feature (in OpenPGPcard
specification v3), we can distinguish if a card supports this feature or
That is just a idea.  I'll try with Gnuk Token, perhaps.

@_date: 2017-10-25 16:03:22
@_author: NIIBE Yutaka 
@_subject: Importing an off-card backup of the encryption key of a Nitrokey 
If you want to know the detail, this means that the encryption key is
generated on the host and it is imported to the card.  Generating on
card and extracting is not possible.
No.  It doesn't work, because the file is just the raw private key of
the encryption subkey.
Yes.  It's "gpg --edit-key" which can be used for this file and it's
"bkuptocard" sub command to import the private key to the card again.
In such a case, why not do that straight?  I mean, generating keys on
host and manually importing to device by "keytocard" of "--edit-key"?
You can control your key better.
The sk_26D728A8F09033F1.gpg is written in the OpenPGP format, but it is
not intended to be used by "--import" command; Even if it is created by
the data of subkey, the file uses PKT_SECRET_KEY type.
So, to achieve what you want, I guess, you need to write a small program
to handle this file to recover your private key on host.

@_date: 2017-09-14 14:26:07
@_author: NIIBE Yutaka 
@_subject: Unable to sign or decrypt with card 
Not much.  It fails just after sending a command to the card.  It seems
that there is some communication problem between host and card reader.
How 'gpg --card-status' works?
You can try to debug scdaemon by having .gnupg/scdaemon.conf:
debug-level guru
log-file /run/user/1000/scd.log
Here is what we can see in your log.
gpg-agent started.
And then, scdaemon started after PKDECRYPT command from gpg to gpg-agent.
Card works fine to answer its serial number.
gpg-agent asks PKDECRYPT command to scdaemon, and scdaemon inquires PIN
for the authentication.
This is interaction between pinentry and gpg-agent.
SIGUSR2 (it means: a card is found) comes from scdaemon to gpg-agent,
because scdaemon periodically checks if card is inserted.
gpg-agent sends the PIN to scdaemon (until "END"), and I think that
scdaemon sends command to the card through card reader.  But it fails.
There are two ways to access card reader for GnuPG.  One is through
PC/SC, and another is internal CCID driver of GnuPG.  If it doesn't work
well with PC/SC, it's worth to try the internal CCID driver (or vice virsa).

@_date: 2017-09-16 00:19:48
@_author: NIIBE Yutaka 
@_subject: Unable to sign or decrypt with card 
Thank you.
As far as I can see, it looks like no problem of scdaemon, but card
Here is the decrypt operation started:
Since it's long command, it is devided into two blocks, (1) and (2).
This is the first block (1):
                                                                    ^
The first block has "more"-bit --------------------------------------
Then, this is the reply asking next block:
This is the next block (2):
This block is final with no "more" bit.
The expected behavior is the card reader returns text after decryption by card.
But, card reader returns only three bytes, where more than four bytes
are expected at least.
So, it is interpreted as lower-level communication error.
Sending APDU, the command is somehow aborted.
This part is a little buggy, though.  The error code of GPG_ERR_CANCEL
is not that appropriate, I suppose.  Because of erroneous
GPG_ERR_CANCEL, gpg-agent wrongly send "CAN" (cancel) command to
scdaemon, which is unknown by scdaemon in this stage.  I'll fix this
I don't know the reason why card error occurs.

@_date: 2018-04-02 09:10:39
@_author: NIIBE Yutaka 
@_subject: Again: Writing DER certificates to ZeitControl Cards 
Most likely, the length of certificate matters.  If you can minimize
your certificate, please try.  I don't know the limitation for the card.
In case of my own implementation, I can only support data less than
FWIW, let me explain my opinion.  This might be irrelevant to the
implementation on ZeitControl Card, though.
The feature is one of the most difficult parts for an implementer of
OpenPGP card.  For my own implementation, I cannot implement it fully,
because of the possibility of larger size.  So, users of Gnuk Token have
to use special tool to write certificate, while reading is OK.
Since the feature is questionable for me (no real good use case), I even
put a compile time option for Gnuk to disable it, and that's the
default now.

@_date: 2018-04-25 09:43:57
@_author: NIIBE Yutaka 
@_subject: Wrong Keygrip (gpg2 --card-status --with-keygrip) 
Thanks for your report.
It's a new feature introduced in 2.2.6, and I did not review the patch
Just fixed and pushed in 71903eee8.

@_date: 2018-01-15 10:47:57
@_author: NIIBE Yutaka 
@_subject: BUG report gnupg-2.2.4 (or npth) 
I think that you have some different Pthread library in /usr/local.
  ^^^^^^^^^^^
I wonder if you have installed GNU Pth.  Please try without Pth.

@_date: 2018-07-04 11:05:27
@_author: NIIBE Yutaka 
@_subject: dirmngr cygwin resolv.conf 
That's not for Cygwin on Windows, but for GNU/Linux.
In dirmngr, the DNS resolver using Tor assumes that it returns
ECONNREFUSED when Tor doesn't run at 9050, then, it tries to the port
There was a bug of the DNS resolver.  When there are multiple
"nameserver" in /etc/resolv.conf, it should try all.  It was fixed, but
this fix had a side effect for ECONNREFUSED fallback mechanism for using
Tor.  This was fixed on Monday.
For the particular issue for Cygwin, it seems that connect(2) in Cygwin
environment may return EPERM instead of ECONNREFUSED.  I suspect this.
We can add the case of EPERM for Cygwin for workaround...

@_date: 2018-07-04 16:11:15
@_author: NIIBE Yutaka 
@_subject: dirmngr cygwin resolv.conf 
I am considering a patch like following.  If you can build GnuPG for
Cygwin, you can try.  Or, you can ask Cygwin's package maintainer for
The patch is: Don't try to look the error code, but fallback TOR_PORT2
diff --git a/dirmngr/dns-stuff.c b/dirmngr/dns-stuff.c
index ffac816f9..88a4fce5c 100644
--- a/dirmngr/dns-stuff.c
+++ b/dirmngr/dns-stuff.c
 -735,13 +735,12  libdns_res_open (struct dns_resolver **r_res)
 static int
 libdns_switch_port_p (gpg_error_t err)
 {
-  if (tor_mode && gpg_err_code (err) == GPG_ERR_ECONNREFUSED
-      && libdns_tor_port == TOR_PORT)
+  if (tor_mode && libdns_tor_port == TOR_PORT)
     {
       /* Switch port and try again.  */
       if (opt_debug)
-        log_debug ("dns: switching from SOCKS port %d to %d\n",
-                   TOR_PORT, TOR_PORT2);
+        log_debug ("dns: switching from SOCKS port %d to %d (%s)\n",
+                   TOR_PORT, TOR_PORT2, gpg_strerror (err));
       libdns_tor_port = TOR_PORT2;
       libdns_reinit_pending = 1;
       return 1;

@_date: 2018-06-01 11:57:26
@_author: NIIBE Yutaka 
@_subject: Problem signing git commits with smartcard key 
If I understand correctly, you put:
In this configuration, the OPENPGP.2 key on card is only for decryption.
You can't sign with that, even if its capability is specified Sign,
Encryption, and Authentication.
In OpenPGP card specification, three keys are different.
You can have a subkey with Sign capability and put it to OPENPGP.1 key
on card.

@_date: 2018-06-05 09:37:19
@_author: NIIBE Yutaka 
@_subject: STM32F103 flash ROM read-out service 
While learning Chinese language, I found this service (in Chinese):
    IIUC, It's a company in ShenZhen, which offers a service reading out
from protected STM32F103, even if it uses anti-tamper feature with a
I was aware of similar services for PIC18 or ATmega (in different
country).  This is new for me, specifically for STM32F103.
I don't know the detail of this service, but it seems that it's not that
expensive (from not-confirmed information by my friend).
Well, I encourage Gnuk users to new use KDF-DO feature with newer GnuPG.

@_date: 2018-06-22 11:41:38
@_author: NIIBE Yutaka 
@_subject: Won't recognize my secret key 
Thank you for your report.  I think I located the issue of migration.
For the problem of importing secring.gpg directly, we have a task:
Basically, secring.gpg only has the information of expiration when it's
created.  After changing expiration, it is only recorded in pubring.gpg.
So, it is recommended to do somthing like:
   $ gpg --homedir ~/.gnupg.old --export-secret-keys | \
(instead of doing --import ~/.gnupg/secring.gpg directly.)
However, in gnupg/g10/migrate.c, GnuPG itself does that (!).  This
should be fixed.

@_date: 2018-06-29 16:30:37
@_author: NIIBE Yutaka 
@_subject: dirmngr cygwin resolv.conf 
Only "use-tor" is needed, then, dirmngr connects to localhost:9150 for

@_date: 2018-06-29 20:28:14
@_author: NIIBE Yutaka 
@_subject: Choice of ECC curve on usb token 
Why not Curve25519, if you use ECC?
Quite interesting opinion.  I wonder what kinds of side channel attacks
are discussed there.  Well, it's the first time for me to hear such an
opinion.  Are there some confusions?
Curve25519 is designed against side channel attacks in mind.  Also, it
comes with a reference implementation.  Even if an implementation
doesn't use the methodology directly, it is a bit harder to write weaker
implementation (against side channel attack), if an implementer
understands Curve25519 correctly.  <-- this is my own opinion.
I wrote Curve25519 implementation for libgcrypt.  So far, libgcrypt
doesn't have field specific methods, but libgcrypt 1.9.x will have those
for Curve25519.  If we compare curves in libgcrypt, I think that
Curve25519 is good one.
I also wrote Curve25519 implementation for Gnuk.  Well, I also wrote
ones of NIST P-256 and secp256k1 for Gnuk.  I believe Curve25519 is the
best among those (and RSA).  Gnuk runs on STM32F103 @ 72MHz (or GD32F103
@ 96MHz).  This is an embedded device, of my daily use.

@_date: 2018-06-29 20:40:52
@_author: NIIBE Yutaka 
@_subject: dirmngr cygwin resolv.conf 
Sorry, my explanation was not accurate.  In the Tor-mode of dirmngr, it
uses the port 9050 at first.  And there is some code to fallback to the
port 9150.  It's like:
    libdns_switch_port_p (gpg_error_t err)
    {
      if (tor_mode && gpg_err_code (err) == GPG_ERR_ECONNREFUSED
          && libdns_tor_port == TOR_PORT)
        {
          /* Switch port and try again.  */
          if (opt_debug)
            log_debug ("dns: switching from SOCKS port %d to %d\n",
                       TOR_PORT, TOR_PORT2);
          libdns_tor_port = TOR_PORT2;
          libdns_reinit_pending = 1;
          return 1;
        }
      return 0;
    }
I suspect the error detection is not working well.  If it works,
you should see the debug message of "dns: switching from SOCKS port...".
I tested with the port 9050, my dirmngr works fine.

@_date: 2018-03-01 09:14:15
@_author: NIIBE Yutaka 
@_subject: Fwd: gnupg SmartCard V3.3 
If possible, I recommend to use GnuPG's in-stock driver to access
smartcard.  It is direct access by libusb, not using PC/SC service.
For GNU/Linux, if you don't have any other use of PC/SC service, please
uninstall it, or disable the service, and try again with GnuPG's
in-stock driver.
For the driver, I maintain this list:
    For macOS, I think that it still uses old PC/SC and libccid library.
I'm afraid that new readers (with new features like pinpad support)
don't work well, or don't work at all.
I need macOS developers who build GnuPG with libusb.  Currently, GnuPG
scdaemon uses PC/SC service on macOS and Windows.  On GNU/Linux, people
can use both ways (in-stock driver or PC/SC).
  02.... Short APDU level exchange
Because of this limitation, this reader cannot handle larger APDU (~=
packet), which is needed for recent RSA key size.  You can still use it
with RSA-1024.
  bPINSupport: 0x03
     PIN Verification supported
     PIN Modification supported
I'm afraid it doesn't work on macOS.
I had a bug report with this reader:     I think it now works fine by GnuPG's in-stock driver on GNU/Linux.
Please test.
It seems that this reader has a problem in PC/SC service, and it's not
supported by PC/SC-lite + libccid.
   Supporting users' freedom on computing (for their privacy in digital
world), I need have/collect/maintain knowledge of those hardware.
But... when there is a problem, it tends to be because of bad firmware
implementation, which is proprietary.  In the proprietary world, the
practice is... to be "fixed" in the proprietary driver (than the
firmware).  But that "fix" has tendency not to be published to users or
developers of free software.
For me, it's a pity that I somehow need to have knowledge around those
proprietary firmware.
Perhaps, someday, in free software, I will write CCID reader
implementation which accesses smartcard, by free software (I mean,
development environment), for free software (= GnuPG maintenance); Then,
we can proceed to free firmware of smartcard itself.
# About ten years ago, I didn't take that approach but a short cut, that
# was Gnuk.  The reason was that it was difficult to find hardware
# vendors which allowed developing free firmware implementation of
# smartcard.
Having free CCID reader implementation still makes sense, to encourage
free firmware implementation of smartcard.  I'd like to work for some
part this year.

@_date: 2018-03-13 18:54:25
@_author: NIIBE Yutaka 
@_subject: OpenPGP card bricked 
If it's really hardware problem, I can't help, but...
I believe that GnuPG's in-stock driver just works fine with this reader,
because it runs at TPDU level exchange.
Please try without PC/SC-lite, and see how it goes.
With following ~/.gnupg/scdaemon.conf, you can get debug log.
================ ~/.gnupg/scdaemon.conf
debug-level guru
log-file /some/where/scdaemon-debug.log

@_date: 2018-03-14 13:03:16
@_author: NIIBE Yutaka 
@_subject: OpenPGP card bricked 
It seems that your smartcard is not working at all.
Possibly, bricked.
The log says (I removed the timestamp and process name):
The host PC asks the reader (RDR) to power on the smartcard.
Then, the reader's interrupt transfer notifies to the host for change of
card status.  Host keeps the interrupt transfer, so, submit the transfer
to the USB host controller again.
The reader responds it fails to power on the smartcard.
The host asks again to the reader.
Same failure.  Host gives up.
And the host asks power off.  The reader replies.
The host cancels interrupt transfer which watches card status change.
After the failure of internal CCID driver, it tries PC/SC.

@_date: 2018-03-15 09:41:14
@_author: NIIBE Yutaka 
@_subject: OpenPGP card bricked 
All that I can say is:
The reader has features which should work well for OpenPGP card with GnuPG:
(I like TPDU reader, btw.  The simpler is the better.)
When scdaemon asks the reader to power on the smartcard, it fails.
So, it's not something complicated.  Just it doesn't work from the beginning.
Given the situation (the card should be OK and the reader should be OK,
possibly the machine is also OK), most likely, I suspect the contact
between the reader and the smartcard.

@_date: 2018-03-28 09:00:02
@_author: NIIBE Yutaka 
@_subject: git commit signing: Asked for smartcard as it's plugged in 
I think that this is related to the bug report:
    I found that there are (at least four) different issues; Device firmware
problem, GnuPG scdaemon problem, PC/SC problem for GNU/Linux, and Linux
kernel problem.
Since your case is on macOS, latter two are not relevant.
I think that Yubikey somehow doesn't work well for USB suspend.  For
this problem, please contact the manufacturer.
I fixed a problem of GnuPG scdaemon and implemented work around for
device problem.  It will be in 2.2.6.  With the fix and the work around,
scdaemon tries to reset device after such a failure.  So, you won't need
to manually re-plug your device, but PIN input will be required, since
the device will be reset.
For GNU/Linux, I'd recommend to use internal CCID driver, instead.  It
seems that PC/SC development doesn't have an interest for suspend/resume.
The kernel problem is here:
    Since it is a kind of corner case which has been there long time, I
could not expect fix will be included soonish (or even getting
attention).  Thus, I changed scdaemon using pipe instead of signal (in
forthcoming 2.2.6).

@_date: 2018-10-03 08:53:23
@_author: NIIBE Yutaka 
@_subject: GPG 2.1.0 Compatibility Metrix(Solaris/Linux/HP Unix) and 
For GNU/Linux, distributions offer binaries for GnuPG.  These days,
GnuPG 2.1.x/2.2.x is available.
For Solaris, I checked OpenIndiana, but it only offers GnuPG 2.0.x
(yet), while libraries (except npth) are available.
For HP-UX, I checked the HP-UX Porting and Archive Centre [0], situation
is similar.  Since all libraries are available (including npth) there,
building GnuPG is not that hard, I suppose.
I, for myself, do my best to keep supporting those (older) systems, in
our development.  However, we don't actively develop GnuPG on those
systems.  Only occasionally, when needed.  Well, since I don't have any
access to HP-UX system any more, so, it depends on bug reporters.
Last month, in libgpg-error development, I learned that such older
Unixen tend to use ksh (variant) for /bin/sh.
I encourage users on Solaris and HP-UX to migrate GnuPG 2.2.
[0]

@_date: 2018-10-30 13:08:40
@_author: NIIBE Yutaka 
@_subject: PGP Authentication with gpg4win+ssh 
Your authentication subkey should be listed in .gnupg/sshcontrol, while
it is automatically supported for Gnuk Token and OpenPGP card.
For detail, I found this post:

@_date: 2018-09-03 15:36:33
@_author: NIIBE Yutaka 
@_subject: "gpg: signing failed: Invalid length" when use brainpool512r1 
Not reproducible here (similar on Debian Stretch).
I tested with no configuration.
Is it reproducible under no configuration?
I tested with:

@_date: 2019-12-11 16:44:06
@_author: NIIBE Yutaka 
@_subject: v2.1 openpgp smartcard -- packing in after a `key to card' 
Unfortunately, your log only includes information _after_ the failure.
So, I could only guess about failure.  I guess that "key to card" was
failed for some reason.
While you have three card readers...
What you were using was "OMNIKEY AG CardMan 3121", which only supports
short APDU level exchange.
It is listed in this list: It should work for 1024-bit key.
However, I'm afraid that probably, it doesn't work well with recent
PC/SC lite, because readers with short APDU level exchange only are
getting uncommon.
SCM SPR 532 works better, because it supports TPDU level exchance (lower

@_date: 2019-12-16 10:47:32
@_author: NIIBE Yutaka 
@_subject: pinentry-gtk-2 dialog doesn't appear before getting input 
I think that it's related to window manager.  For testing, you can
manually invoke pinentry like:
   $ pinentry                 # run pinentry by command line (-gtk2 or any)
   confirm                    # shows a dialog box
   bye                        # finish the session
   $ Doing this makes it easy to identify a problem (from complicated
interaction of gpg <-> gpg-agent <-> pinentry).
It seems for me that:
You can somehow control the behavior of the window manager.
In its configuration by "Focus" tab in "Window Manager Tweaks":
    And/or the first entry of "Accessibility" tab which says "Raise windows
when any mous button is pressed".
Or "Focus" tab in "Preferences":
    Looking the commit log of xfwm4 (about "stacking"), it appears something
has been changed.

@_date: 2019-11-04 19:15:29
@_author: Niibe Yutaka 
@_subject: gpg-agent only checks for smartcard not for local keys 
When gpg-agent works as ssh-agent, it always checks (possible)
authentication key on smartcard, so that the authenticaiton key (when
available) can be used.
Specifically, SSH client askes ssh-agent about available keys by
REQUEST_IDENTITIES command.  When gpg-agent (as ssh-agent) gets
REQUEST_IDENTITIES command, it checks scdaemon about possible
authentication keys.  Let's call those key(s) "active smartcard key(s)".
There are also keys recorded under ~/.gnupg/private-keys-v1.d/.  Let's
call those keys "recorded keys".  Those "recorded keys" can be private
keys on disk, or keys on smartcard (reference to smartcard, not private
key secret).  For response to REQUEST_IDENTITIES command, gpg-agent
answers SSH "active smartcard key(s)" + "recorded keys".
(Here, "recorded keys" may include "active smartcard key(s)".)
After that, SSH server + client negotiate about keys and select a key.
Then, SSH client asks gpg-agent (as ssh-agent) a challenge-response
authentication by signing with SIGN_REQUEST command.
With --disable-scdaemon, gpg-agent should stop accessing scdaemon.
Do you reload setting (gpgconf --reload gpg-agent) after changing
your gpg-agent.conf?

@_date: 2019-10-14 13:17:58
@_author: Niibe Yutaka 
@_subject: Cannot decrypt from smartcard using gnupg-2.2, can from 2.0 
This means that something goes wrong in your private key file for
your token, I suppose.
You can see more information, by following command line:
    $ gpg-connect-agent "KEYINFO --list" /bye
This doesn't reveal secret (but your serial number).
The example output (of mine) is like:
$ gpg-connect-agent "KEYINFO --list" /bye
S KEYINFO A97A7983102513844456E5B687E46B936B14155C D - - - P - - -
S KEYINFO 65F67E742101C7FE6D5B33FCEFCF4F65EAF0688C T D276000124010200F517000000010000 OPENPGP.2 - - - - -
S KEYINFO 101DE7B639FE29F4636BDEECF442A9273AFA6565 T D276000124010200F517000000010000 OPENPGP.1 - - - - -
S KEYINFO 5D6C89682D07CCFC034AF508420BF2276D8018ED T D276000124010200F517000000010000 OPENPGP.3 - - - - -
The third column is a keygrip.  The fifth column is an application ID
(vendor id + serial number) of the card.  The sixth column is the key
The key identifier "OpenPGP.2" is used for decription process.
I suspect you have some different string there, for some reason.

@_date: 2019-10-18 20:50:21
@_author: NIIBE Yutaka 
@_subject: SSH CA + gpg-agent + gnuk => error 
Just FYI, for smartcard, adding a keygrip in sshcontrol is not needed,
if it is OK for your gpg-agent to just fail for signing request when
smartcard is not available.
I don't think it is related to OpenSSH certificate.  For some reason,
possibly a bug, smartcard singing failed.  You can configure
.gnupg/scdaemon.conf with something like:
debug-level guru
log-file /run/user/1000/scd.log
to see what's going on.
Here is another information, related.
OpenSSH certificate authentication doesn't work well with gpg-agent
(yet).  Ideally, OpenSSH certificate should be under control of
For detail, you can see:
        Protocol-wise, for gpg-agent, it is expected that the ssh does:
  * ssh askes ssh-agent (in our case, gpg-agent) to get OpenSSH
    certificate by REQUEST_IDENTITIES command
  * (only after) REQUEST_IDENTITIES command, ssh askes ssh-agent
    challenge-response by SIGN_REQUEST command
But the first part does not occur by current OpenSSH client.  The client
by itself answers back to the server using the certificate on disk
(under .ssh/), without asking ssh-agent.

@_date: 2020-08-06 14:10:55
@_author: NIIBE Yutaka 
@_subject: Clearing cached PIN for Yubikey 
Clearing the authentication status is supported in scdaemon (in the
lower level), but there is no good way by command line.
If you don't care about using a kind of develper's tool
(gpg-connect-agent), you can do following.
For signing, type:
    $ gpg-connect-agent "SCD PASSWD --clear 1" /bye
For decryption/authentication, type:
    $ gpg-connect-agent "SCD PASSWD --clear 2" /bye
Perhaps, using a tool for users would be more relevant.  Then,
    $ gpgconf --kill scdaemon
could be used to clear all authentication status.

@_date: 2020-02-25 12:27:02
@_author: NIIBE Yutaka 
@_subject: command "SCD SERIALNO openpgp" not answered correctly 
Good.  You are using the internal CCID driver to access your card reader.
Most likely, it is a problem of permission of your usb device.
Please check your /dev/usb/* (in your old system and in your new

@_date: 2020-06-12 17:49:28
@_author: NIIBE Yutaka 
@_subject: agent_genkey failed: Invalid flag 
The error is from libgcrypt.  I think that libgcrypt is too old
to use Ed25519/Curve25519.
When generating Ed25519/Curve25519 key/subkey, gpg uses three flags:
        comp
It seems that some flag(s) is not supported by libgcrypt in the user's
comp: compact format
      (only use x or y-coordinate to represent an EC point)
eddsa: use for EdDSA
djb-tweak: specify bits of secret is tweaked DJB's method;
           MSB is set, LSBs are cleared.

@_date: 2020-09-30 14:57:48
@_author: NIIBE Yutaka 
@_subject: SSH CA + gpg-agent + gnuk => error 
No, not at all.  It's completely normal.
You need to locate the place where it fails.
FYI, we have a ticket for signing SSH CA by Gnuk Token.
    This problem is... (for me) because of bad design of digital signature
for SSH CA.  If it's not larger, Gnuk 1.2.16 works.
I think it is possibly related to your issue.
