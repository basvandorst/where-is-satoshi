
@_date: 2016-12-08 19:40:04
@_author: Teemu Likonen 
@_subject: An attempt at backporting 2.1.16 from Debian sid to Debian jessie 
Thanks. I'm not brave enough to try it yet. I wonder what is the status
of official backport. There's a Debian bug report about that:
Quote 2016-10-06:
    It'll happen soon, i promise :)
          --dkg

@_date: 2016-12-10 08:49:30
@_author: Teemu Likonen 
@_subject: What is pubring.kbx? 
I just noticed that a couple of days ago a new file ~/.gnupg/pubring.kbx
had appeared (or last modified). Who made it and what is it for? I'm
using GnuPG 2.0.26 and its manual doesn't seem to tell anything about
this file. Obviously I have ~/.gnupg/pubring.gpg too.
$ gpg2 --no-default-keyring --keyring ~/.gnupg/pubring.kbx --list-keys
gpg: [don't know]: invalid packet (ctb=00)
gpg: keydb_search_first failed: Invalid packet

@_date: 2016-12-10 09:39:25
@_author: Teemu Likonen 
@_subject: What is pubring.kbx? 
Indeed. I recently verified someones S/MIME message. Man page of
gpgsm(1) 2.0.26 says:
    pubring.kbx
        This a database file storing the certificates as well as meta
        information. For debugging purposes the tool kbxutil may be used
        to show the internal structure of this file. You should backup
        this file.

@_date: 2016-02-07 07:16:54
@_author: Teemu Likonen 
@_subject: Documentation format 
With \usepackage{fontspec} (etc.) and "xelatex" compiler you can use
UTF-8 and Opentype fonts. No special composing for characters. See the
fontspec package fro more info: . They
should be included in any Texlive distribution.

@_date: 2016-02-24 13:46:42
@_author: Teemu Likonen 
@_subject: How to prevent emacs from unencrypting my files 
Emacs can cache passphrases and expire them automatically. The related
configuration variables have changed quite recently but check these:
    password-cache
    password-cache-expiry
    mml2015-cache-passphrase
    mml2015-passphrase-cache-expiry
    mml-secure-cache-passphrase
    mml-secure-passphrase-cache-expiry

@_date: 2016-11-24 16:27:49
@_author: Teemu Likonen 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
Keys with authentication capability can be used with ssh, and GnuPG
2.1's command --export-ssh-key will export the ssh public key. Right?
Unfortunately I have GnuPG 2.0.26 (as packaged in Debian 8). Can it be
told to export ssh public keys?

@_date: 2016-11-24 17:59:41
@_author: Teemu Likonen 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
That works if the key is already known to the gpg-agent but it seems
that gpg 2.0 has also a problem in making A-capable keys known to ssh
agent protocol. I believe that file ~/.gnupg/sshcontrol should contain
key's keygrip but how do I get the keygrip when there's no
--with-keygrip option in 2.0?

@_date: 2016-11-25 16:45:35
@_author: Teemu Likonen 
@_subject: Is --export-ssh-key functionality possible with GnuPG 2.0? 
Not too pretty but it works. Thank you.
Since it creates a separate key which is not tied to my secring.gpg the
case left me wondering what will happen when I upgrade to gpg 2.1 in the
future. I mean I'll run gpg 2.1 someday and it will convert my
secring.gpg to some KEYGRIP.key files, including my A-capable key. Will
the authentication key be the same and technically compatible with the
key that I just created with openpgp2ssh and ssh-add commands?
Just wondering. It's not that important. Some manual work is probably
necessary anyway at the first upgrade.

@_date: 2016-10-02 21:59:06
@_author: Teemu Likonen 
@_subject: Confusing options for --tofu-(default-)policy= 
First a quote from the gpg 2.1.15 man page:
    --trust-model pgp|classic|tofu|tofu+pgp|direct|always|auto
        [...]
            In the TOFU model, policies are associated with bindings
            between keys and email addresses (which are extracted from
            user ids and normalized). There are five policies, which can
            be set manually using the --tofu-policy option. The default
            policy can be set using the --tofu-default- policy policy.
            The TOFU policies are: auto, good, unknown, bad and ask. The
            auto policy is used by default (unless overridden by
            --tofu-default-policy) and marks a binding as marginally
            trusted. The good, unknown and bad policies mark a binding
            as fully trusted, as having unknown trust or as having trust
            never, respectively. [...]
So there's a mapping from tofu policy to trust: auto=marginal,
good=fully, unknown=unknown, bad=never. But why use different names? Why
not use the same names for tofu policy and trust?

@_date: 2017-04-04 20:27:37
@_author: Teemu Likonen 
@_subject: Smart card 
Considering possible threats is useful or even extremely important but
here's another point of view. Perhaps it can be just "I'm interested in
security technology and want to study smart cards. Thus, I'll buy one
and learn how it works. Maybe it will turn out useful or even

@_date: 2017-04-08 16:48:05
@_author: Teemu Likonen 
@_subject: Smart card 
But Nitrokey, Yubikey and maybe some other smart "keys" are actually
handy. Using them don't cause pain in any part of my body.

@_date: 2017-04-30 09:14:54
@_author: Teemu Likonen 
@_subject: Trouble installing Version 2.1 on Debian Jessie 
I suggest using "testing" instead of "experimental" because testing is
the direct upgrade path from stable. Actually I'm not brave enough to
try even that (i.e., mixing stable and testing) but I'll give a direct
answer to your question anyway.
So, in your problem the package manager prefers the stable (jessie)
repository and tries to load some libraries from there. However, your
experimental gnupg packages require versions that are not in the stable.
Possible solutions:
  - Add those unmet dependencies to your "apt install -t experimental"
    command line.
  - Use "aptitude" command and its dependency solver interactively. It
    suggests different solutions. Choose the one that suggest loading
    all necessary packages from the experimental repository.

@_date: 2017-08-05 18:30:12
@_author: Teemu Likonen 
@_subject: TOFU db corruption detected 
Before the developers give you more educated answers I'll point out that
the tofu database is a regular Sqlite database file. So you can do:
    $ sqlite3 ~/.gnupg/tofu.db
and then execute any SQL commands. Interesting SQL command could be
"vacuum" which, in Sqlite, basically dumps the the database as SQL text
commands, then deletes the database and finally reads the SQL dump
again. If you want to try that, make a copy of your tofu.db file first.
Then start Sqlite like the example line above and:
    sqlite> vacuum;

@_date: 2017-12-09 15:17:02
@_author: Teemu Likonen 
@_subject: TOFU's encryption counter is not updated (a bug?) 
I have sent several encrypted emails to a friend and I'm using Gnus as
my email program. I'm using "trust-model tofu" but it seems that TOFU's
encryption counter is not incremented for the recipient's key. I queried
the TOFU info with a command like this:
    gpg --list-keys --with-tofu-info --with-colons KEY | \
        awk -F: '$1 == "tfs" {print $5}'
To me this is looking very much like bug. I'm using GnuPG
2.1.18-8~deb9u1 (Debian 9).

@_date: 2017-02-15 18:54:51
@_author: Teemu Likonen 
@_subject: Expanding web-of-trust with subkey 
19:02:08 -0800")
I don't personally know anybody who uses gpg. Even if I will meet
someone it's unlikely that signing keys will make me part of any web. So
web of trust is useless for me.
That makes things very simple, in a way. I use "trust-model direct" and
do some checking in web pages or check consistent use of signatures. If
the key seems ok I'll "--edit-key", type "trust" and assign marginal or
full trust for that key. That's it. And because I have no use for other
people's signatures I also have "keyserver-options import-clean" so my
keyring remains small.
When Debian 9 is released, with GnuPG 2.1, I'll try "trust-model
tofu+pgp" (trust on first use plus web of trust). It seems useful too.

@_date: 2017-02-16 16:31:18
@_author: Teemu Likonen 
@_subject: Expanding web-of-trust with subkey 
Yes. I have also considered (and used a little) local signatures for the
same use case: local-sign a key after checking it on a web page or in a
tofu-like manner. Local signature can obviously validate only selected
user ids but so far I've concluded that signatures are too strong
statement for not really checked "seems ok" keys. I know that there are
certification levels (like "--default-cert-level 1") but it's just
simpler to use "trust-model direct" and define the level directly.
Changing the decision later is also easier.
That has been my assumption. Thanks for verifying.

@_date: 2017-01-07 08:33:40
@_author: Teemu Likonen 
@_subject: Alternatives for Omnikey 
I don't know about official recommendations but I have Yubikey 4? and
Nitrokey Pro? and they work fine. Software packages scdaemon and pcscd
(libccid 1.4.20) are needed but otherwise the keys work out-of-the-box
in Debian GNU/Linux 8 (Jessie).
1. 2.

@_date: 2017-06-11 21:55:03
@_author: Teemu Likonen 
@_subject: changing the passphrase of the secret key stored in the GnuPG card 
"gpg2 --edit-key" is for normal keyrings. Your key is on the card so you
edit the card with "gpg2 --card-edit" and then change card's password(s)
with "admin" > "passwd".

@_date: 2017-06-13 14:30:05
@_author: Teemu Likonen 
@_subject: GnuPG card && using the backup secret key 
Command --edit-key edits a key in your keyring. I'd guess that you want
to import keys:
    gpg2 --import sk_61F1ECB625C9A6C3.gpg
Then you can edit them with --edit-key.

@_date: 2017-06-15 23:29:41
@_author: Teemu Likonen 
@_subject: modern GnuPG verify signatures 
Perhaps it can be seen as bug that there is the full fingerprint in some
places and long key id in other places.
I'm guessing that there are different code paths internally: In the
first example the trust level is calculated from web of trust (own key,
ultimate trust). In the second example there's also tofu trust model
involved because it shows statistics for verifying and encryption.
But those who know the code can answer.

@_date: 2017-06-16 10:06:38
@_author: Teemu Likonen 
@_subject: Revoking a certificate (--edit-key + revsig) 
My question is simple (kind of): In what situations would you revoke a
certificate that you have made on someone else's key? (Technically:
--edit-key + revsig.)
Background concepts: When we sign a key (--edit-key + sign) we certify a
particular user id, the link between the user id and person (or
sometimes group) identity. Something like that. It's difficult to put
this concrete enough but abstract enough to cover all cases but you know
what I mean.
But what would you say about conceptual meaning of revoking such
certificate (--edit-key + revsig)? Maybe the link between the key or a
particular user id and the actual person or group identity has been cut:
person lost his secret key or just password and can't control the key
anymore. So maybe by revsig a person gives a signal that he knows the
link has been broken and tell people to not rely on his certificate
anymore. Am I right?

@_date: 2017-06-21 14:36:48
@_author: Teemu Likonen 
@_subject: Key corruption: duplicate signatures and usage flags 
I've seen the message with other keys too, just after --edit-key. The
number of duplicate signatures varies. Next --refresh-keys command
downloads the signatures back.
I tried your key and got the same results.

@_date: 2017-06-21 22:12:51
@_author: Teemu Likonen 
@_subject: Revoking a certificate (--edit-key + revsig) 
Sure, thanks. This is what I thought. In the past I revoked one of my
certificates because the key's owner no longer remembered the password
and essentially had lost control of the key. Back then I didn't think of
the semantics of revsig that much but it seemed the right thing to do.

@_date: 2017-06-22 09:42:50
@_author: Teemu Likonen 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
Are TOFU statistics used for key's validity calculations or TOFU
conflict resolution?
Some background: The TOFU system keeps statistics about key's use. I'll
quote some lines from the DETAILS document.
About --with-colons --witt-tofu-info --list-keys:
    *** TFS - TOFU statistics
        This field may follows a UID record to convey information about
        the TOFU database.  The information is similar to a TOFU_STATS
        status line.
        - Field 2 :: tfs record version (must be 1)
        - Field 3 :: validity -  A number with validity code.
        - Field 4 :: signcount - The number of signatures seen.
        - Field 5 :: encrcount - The number of encryptions done.
        - Field 6 :: policy - A string with the policy
        - Field 7 :: signture-first-seen - a timestamp or 0 if not known.
        - Field 8 :: signature-most-recent-seen - a timestamp or 0 if not known.
        - Field 9 :: encryption-first-done - a timestamp or 0 if not known.
        - Field 10 :: encryption-most-recent-done - a timestamp or 0 if not known.
About --status-fd output's TOFU_STATS:
    *** TOFU_STATS         Statistics for the current user id.
        The  are the usual space delimited arguments.  Here we
        have too many of them to fit on one printed line and thus they are
        given on 3 printed lines:
        :           : [ [           : [ [ ]]]]
        Values for SUMMARY are:
        - 0 :: attention, an interaction with the user is required (conflict)
        - 1 :: key with no verification/encryption history
        - 2 :: key with little history
        - 3 :: key with enough history for basic trust
        - 4 :: key with a lot of history
It _seems_ to me that     - Field 3 :: validity -  A number with validity code.
is the same thing as SUMMARY in TOFU_STATS. Am I right?
And here's my question again: Does the SUMMARY field's value (0-4) have
effect on how key's validity is calculated or how TOFU conflicts are
resolved or presented to a user?

@_date: 2017-06-22 16:30:27
@_author: Teemu Likonen 
@_subject: Key corruption: duplicate signatures and usage flags 
There is similar cosmetic problem with --update-trustdb:
    [...]
    No trust value assigned to:
    pub   rsa4096 XXXX-XX-XX [SC]
          [...]
     Primary key fingerprint: [...]
    Please decide how far you trust this user to correctly verify other
    users' keys (by looking at passports, checking fingerprints from
    different sources, etc.)
      1 = I don't know or won't say
      2 = I do NOT trust
      3 = I trust marginally
      4 = I trust fully
      s = skip this key
      q = quit
    Your decision? 4
    gpg: depth: 4  valid:  17  signed:  13  trust: 0-, 0q, 0n, 3m, 14f, 0u
    gpg: next trustdb check due at 2017-09-09
And when the whole session is over gpg prints fingerprints of _all_ keys
that got their ownertrust updated.

@_date: 2017-06-22 20:32:48
@_author: Teemu Likonen 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
I didn't get answers yet but I'll speculate a bit on the subject. This
is all about "trust-model tofu" and assume that I have _not_ set
"--tofu-policy" manually.
Let's say that I have a key which has been used to verify a couple of
signatures. Then there comes another key with conflicting email address.
It seems that tofu goes to "ask" mode for _both_ keys (user ids). User
needs to decide and set the tofu policy for both.
Then let's say I have a key which has been used to verify hundred or so
signatures. In --status-fd's TOFU_STATS  it gets higher value,
say 4. Then the keyring gets a new key with conflicting email address.
Does gpg again set both keys (user ids) to tofu's "ask" mode or does
this higher number of good verifications automatically keep the first
key in "auto" mode and only the new key is set to "ask" mode?

@_date: 2017-06-23 13:45:39
@_author: Teemu Likonen 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
Thanks. So here's how my thinking has been as a tofu newbie.
 1. I assumed that the first key with particular email address would be
    automatically valid forever. Only new keys would go to "ask" mode on
    conflicts. That was my interpretation of "trust of first use". Well,
    I was wrong.
 2. New hypothesis: There needs to be enough history on verifying or
    encryption before the key is assumed automatically valid on
    conflicts. Then only new keys would go to "ask" mode on conflicts. I
    was wrong again.
I don't know whether my thinking is common but perhaps it would be
helpful if gpg's man page made clear that on conflict situation both
keys go to "ask" mode. A quote from my gpg 2.1.18 manual:
       --trust-model pgp|classic|tofu|tofu+pgp|direct|always|auto
              [...]
              tofu
                     TOFU stands for Trust On First Use. In this trust
                     model, the first time a key is seen, it is
                     memorized. If later another key is seen with a user
                     id with the same email address, a warning is
                     displayed indicating that there is a conflict and
                     that the key might be a forgery and an attempt at a
                     man-in-the-middle attack.
From that part I got the idea of getting warning only from new
conflicting keys. The first one would be trusted. The man page doesn't
say so but it was my interpretation.

@_date: 2017-03-07 22:03:33
@_author: Teemu Likonen 
@_subject: From Masterkey to subkey 
Interesting. It seems that the feature is not documented. I tested
version 2.1.18 in Debian testing and neither the man page nor
--edit-key's "help" command tells anything about the feature.

@_date: 2017-10-04 21:01:09
@_author: Teemu Likonen 
@_subject: auto-key-retrieve usefulness/annoyance 
A three-part recipe for small annoyance:
 1. "auto-key-retrieve" in gpg.conf
 2. Automatic signature verification in email client.
 3. The email I'm about to read was signed by a key that's not on
    keyservers.
The result: There's a delay of several seconds every time I open the
message and in the end my email client (Gnus) says:
    [[PGP Signed Part:No public key for B47D162E09E21476 created at
    2017-10-04T11:13:25+0300 using RSA]]

@_date: 2017-10-05 20:17:51
@_author: Teemu Likonen 
@_subject: auto-key-retrieve usefulness/annoyance 
Thanks. That helps noticeably. And yes, I use auto-key-retrieve anyway.
It's a nice feature. I have sometimes persuaded people to upload their
key to the server pool.

@_date: 2017-10-13 08:45:15
@_author: Teemu Likonen 
@_subject: auto-key-retrieve usefulness/annoyance 
Unfortunately "--refresh-key" doesn't work well with
"connect-quick-timeout 1" anymore, at least not through Tor network. It
seems that the timeout is too short. I'm back to the default settings
and the long delays when the key is not on servers.

@_date: 2018-04-28 19:04:26
@_author: Teemu Likonen 
@_subject: Practical use of gpgsm for verifying emails 
I read email with Gnus (Emacs) and from time to time someone has signed
his mail with S/MIME (X.509) system. My Gnus tries to verify signatures
automatically and it works nicely with PGP/MIME but S/MIME is more
When verifying an S/MIME message gpgsm (I think) asks whether I
ultimately trust some certificate authority to certify others and then
asks me to verify that a displayed fingerprint belongs to the authority.
How do I know? (So far I have pressed the "Cancel" button.)
I went to the certificate authority's web page but couldn't find
fingerprints. That's not how CA system usually works anyway. Usually we
are not supposed to go searching the internet. Usually some experts have
taught web browsers or operating systems to automatically trust certain
authorities. So signature verification is transparent.
Any suggestions or information for practically managing S/MIME messages?

@_date: 2018-04-30 21:30:01
@_author: Teemu Likonen 
@_subject: Practical use of gpgsm for verifying emails 
============================== START ==============================
As I requested a practical discussion I thought that there is some sort
of "practical trust" when verifying S/MIME messages like there usually
is for the web. For example I can point my web browser to my bank's web
site or your blog at fsfe.org and there is a friendly green lock symbol
in the browser. We normal people think that "this web site is safe"
without checking any fingerprints. Some people even know that the
browser automatically trusts certain authorities to make valid
certificates so that it's really my bank or fsfe.org. Somebody chose
that trust for us because we normal people can't judge.
So I thought that gpgsm would be the same: some root CA's would be
automatically valid and trusted to certify others and gpgsm would just
work like web browsers. I guess not. It forces me to judge and since I
can't judge CA's gpgsm is probably quite useless. I'm not complaining
about gpgsm. It's just that for a moment I thought it would be like web
browsers but for email.
OpenPGP is probably better for email because it's easier to track and
judge individuals separately with TOFU or web of trust model and assign

@_date: 2018-02-21 18:22:19
@_author: Teemu Likonen 
@_subject: Why Operating Systems don't always upgrade GnuPG 
It seems to me that there is an easy gpg.conf solution:
    default-key FINGERPRINT!
See the ! character which forces exactly that (sub)key for signing. Use
that option to select your old signing (sub)key.

@_date: 2018-01-07 16:11:15
@_author: Teemu Likonen 
@_subject: Import keys from .gnupg folder 
Gpg 2.0 uses secring.gpg file for its secret keyring. Gpg 2.1 uses
private-keys-v1.d directory for secret keyring but 2.1 automatically
converts the old secring.gpg to the new format.

@_date: 2018-01-17 15:10:24
@_author: Teemu Likonen 
@_subject: key distribution/verification/update mechanisms other than 
"Wed, 17 Jan 2018 09:58:21 +0100")
Not quite related but... I tend to think that on client side it would be
good idea to "clean" by default. (I like to do that.)
    keyserver-options import-clean,export-clean

@_date: 2018-01-23 18:16:33
@_author: Teemu Likonen 
@_subject: Keys clean of all signatures except those made by others I trust 
02:41:45 -0500")
For one key: "--edit-key" and "clean". To make it automatic for all
import operations you can use options in gpg.conf file:
    import-options import-clean
    keyserver-options import-clean
I like clean export too, so:
    import-options import-clean
    export-options export-clean
    keyserver-options import-clean,export-clean

@_date: 2018-03-06 11:30:02
@_author: Teemu Likonen 
@_subject: GPG is not working because of gpg.conf 
The feature is not documented in 2.1.18. Is it documented in newer

@_date: 2018-03-06 11:35:40
@_author: Teemu Likonen 
@_subject: GPG is not working because of gpg.conf 
That feature is not documented in 2.1.18 but it seems to work. (I tried

@_date: 2018-11-10 10:32:55
@_author: Teemu Likonen 
@_subject: Utilizing facts of homedir organization 
I found Parcimonie too bloated and complicated. I don't think it is a
good idea to use a daemon for this purpose.
So, like probably many others, I wrote a Bash script that refreshes just
one random key and remembers it. Next time it refreshes again a random
key from what is left. After all keys have been refreshed it starts the
round again. I run the script through systemd's user timer.
The script gpg-refresh, as I call it, is small so I will attach it to
this message. Hopefully it will come through. It is written completely
by me and I place it in the public domain so anybody is free to do
anything they wish with it.

@_date: 2019-08-01 20:18:23
@_author: Teemu Likonen 
@_subject: allow-non-selfsigned-uid issue with key from keys.openpgp.org 
To me this sounds very relevant use case and adds one more feature to
the general OpenPGP system. I hope future implementations support
exporting and importing (merging) also partial key block data.

@_date: 2019-02-09 11:23:35
@_author: Teemu Likonen 
@_subject: Keysigning party: after the event challenges 
Ockers"'s message of "Sat, 9 Feb 2019 09:06:43 +0100")
Your Bash shell uses characters "<" and ">" for input and output
redirection. Remove those characters:
    gpg --fingerprint 599C62A291810408

@_date: 2019-02-17 08:23:38
@_author: Teemu Likonen 
@_subject: Two utilities: gpg-tofu and gpg-graph 
I have made two utilities to help my usage of gpg. I think the
functionality of one of them should be part of gpg.
This program parses "gpg --batch --no-tty --with-tofu-info --with-colons
--list-keys -- [...]" output and displays human readable TOFU
statistics. An example:
$ gpg-tofu tlikonen at iki.fi
  [ultimate] Teemu Likonen     TOFU validity: (4/4) a lot of history for trust, TOFU policy: good
    428 signatures in 1 year 252 days, first: 2017-06-09 11:28:16, last: 2019-02-16 19:36:03
    404 encryptions in 1 year 244 days, first: 2017-06-15 14:41:30, last: 2019-02-14 19:25:41
In my opinion "gpg --with-tofu-info --list-keys" etc. (without
--with-colons) should display similar human readable TOFU info. Please
make my tool obsolete. :-)
This program parses "gpg --batch --no-tty --with-colons
--check-signatures -- [...]" and prints graph data for Graphviz for
drawing nice web of trust graphs.
$ gpg-graph [key1 ...] | dot -Tpng >wot-dot.png
$ gpg-graph [key1 ...] | neato -Tpng >wot-neato.png
$ gpg-graph [key1 ...] | sfdp -Tpng >wot-sfdp.png
I have seen one similar tool before (packaged in Debian) but it was
broken by design because it tries to parse the human readable output of
"gpg --check-signatures". It didn't work with the default --list-options
of gpg 2.1. Obviously it should parse machine readable --with-colons
output which my version does.

@_date: 2019-01-01 09:30:20
@_author: Teemu Likonen 
@_subject: Key storage 
-0900")
Secret keys are in directory ~/.gnupg/private-keys-v1.d and each master
key and subkey is in separate file named by key's keygrip (see "gpg -K

@_date: 2019-07-02 10:23:18
@_author: Teemu Likonen 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
Why not make "import-clean" and "import-minimal" strip key signatures
before importing a key? That would make "import-minimal" behave like
this new "self-sigs-only" and there would be no need for yet another
option. Who needs both "import-minimal" and "self-sigs-only"?
My opinion: make "keyserver-options import-clean" the default and make
it internally never import any unknown signatures.

@_date: 2019-07-03 10:38:26
@_author: Teemu Likonen 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
Daniel basically said that "first clean then import [to local keyring]"
and you confirmed that import-clean does exactly this.
But then...
...here you and the manual say that "first import [to local keyring]
then clean".
So there are conflicting messages. Which of the two happens?
I think everyone would prefer that import-clean would do all the
checking and cleaning before importing certificates to the local
keyring. The same thing with import-minimal.

@_date: 2019-07-03 14:26:11
@_author: Teemu Likonen 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
Good. So in principle it works well. Thanks you.
I downloaded (--receive-key) a poisoned key into an empty keyring using
two different keyserver-options. The duration was practically the same.
    import-clean:   1 min 28 s
    import-minimal: 1 min 25 s
I would expect import-minimal be much faster or actually both quite fast
as my test keyring was empty on both tries. Anyway, it works and those
options seem to protect keyring from getting poisonous certificates.
There is the DOS aspect of course as it takes quite long.
The same --receive-key without any keyserver-options hits gpg's limits
at 26 seconds:
gpg: key [...]: 4 duplicate signatures removed
gpg: key [...]: 54614 signatures not checked due to missing keys
gpg: key [...]: 4 signatures reordered
gpg: error writing keyring '[...]/pubring.kbx': Provided object is too large
gpg: key [...]: public key "[User ID not found]" imported
gpg: Total number processed: 1
gpg:               imported: 1
gpg:           not imported: 1

@_date: 2019-07-03 18:22:08
@_author: Teemu Likonen 
@_subject: keyserver-options: self-sigs-only, import-clean, import-minimal 
It seems that there is no better way than scripting it. My "--edit-key +
clean" script is below. It can be changed to "minimize".
gpg --batch --with-colons --list-keys | awk -F: '
$1 == "pub" {pub = 1}
pub == 1 && $1 == "fpr" {printf "%s clean save\n", $10; pub = 0}' | \

@_date: 2019-07-06 08:33:37
@_author: Teemu Likonen 
@_subject: SKS and GnuPG related issues and possible workarounds 
I don't maintain a list and such a list can be always outdated anyway.
Better option is to set protective settings right now in gpg.conf file.
    keyserver-options import-clean
    # maybe also:
    import-options import-clean
With option "import-clean" key import operations accept only key
signatures from already known keys. With poisoned keys the import
operation can take time but at least your local keyring is protected
from importing them.
The gpg(1) manual page for version 2.1.18 (Debian) is misleading,
    import-clean
           After import, compact (remove all signatures except the
           self-signature) any user IDs from the new key that  are
           not  usable.   Then, remove any signatures from the new
           key that are not usable.  This includes signatures that
           were  issued  by  keys  that  are  not  present  on the
           keyring. This option is the same as running the --edit-
           key command "clean" after import. Defaults to no.
It says "After import" but according to Werner Koch[1] it actually
strips unknown key signatures _before_ importing them to the local
keyring. The manual also says that "This option is the same as running
the --edit-key command 'clean' after import." This is also wrong or
misleading because it may lead user thinking that in import oprations
first all keys and key signatures are imported to local keyring and then
they are cleaned.
1.

@_date: 2019-07-07 21:59:32
@_author: Teemu Likonen 
@_subject: Testing WKD setup? 
message of "Sat, 6 Jul 2019 18:57:24 +0200")
Can't answer to those questions but I got your key via WKD and with the
kye verified your email. So, this test was success.

@_date: 2019-07-10 13:49:10
@_author: Teemu Likonen 
@_subject: How to delete flooded key 
There is no need to get rid of the itself key, just the key signatures
which are the "flood". The commands are --edit-key and then "clean" or
"minimize". It is a good idea to also set that operation to guard the
    keyserver-options import-clean
That and other protective settings are enabled by default in GnuPG
"[Announce] GnuPG 2.2.17 released to mitigate attacks on keyservers"

@_date: 2019-07-11 16:41:04
@_author: Teemu Likonen 
@_subject: wrong gpg-agent version running? 
+0200")
I believe it's because there is gpg-agent.socket unit which activates
gpg-agent.service which has the path /usr/bin/gpg-agent. To override
that create a unit "drop-in" file:
    # Filename:
    #   ~/.config/systemd/user/gpg-agent.service.d/my.conf
    # or
    #   /etc/systemd/user/gpg-agent.service.d/my.conf
    [Service]
    ExecStart=/usr/local/bin/gpg-agent --supervised
    ExecReload=/usr/local/bin/gpgconf --reload gpg-agent
Test if it's found with "systemctl --user cat gpg-agent.service". Maybe
also "killall gpg-agent" if you have something left from your previous

@_date: 2019-07-11 17:36:03
@_author: Teemu Likonen 
@_subject: wrong gpg-agent version running? 
It is not a good idea to edit that file directly; it's not a
configuration file. In systemd you should make your own changes in
    Example 2. Overriding vendor settings
    There are two methods of overriding vendor settings in unit files:
    copying the unit file from /lib/systemd/system to
    /etc/systemd/system and modifying the chosen settings.
    Alternatively, one can create a directory named unit.d/ within
    /etc/systemd/system and place a drop-in file name.conf there that
    only changes the specific settings one is interested in. Note that
    multiple such drop-in files are read if present, processed in
    lexicographic order of their filename.
    The advantage of the first method is that one easily overrides the
    complete unit, the vendor unit is not parsed at all anymore. It has
    the disadvantage that improvements to the unit file by the vendor
    are not automatically incorporated on updates.
    The advantage of the second method is that one only overrides the
    settings one specifically wants, where updates to the unit by the
    vendor automatically apply. This has the disadvantage that some
    future updates by the vendor might be incompatible with the local
    changes.
So in your case the first method (as descibed in the above quote) is to
copy file
    /usr/lib/systemd/user/gpg-agent.service
    /etc/systemd/user/gpg-agent.service
and then edit the latter. The former is not used anymore because the
only parts of it by creating a "drop-in"
    /etc/systemd/user/gpg-agent.service.d/my.conf
and define just the [Service] section and the settings one want's to
    [Service]
    ExecStart=
    ExecStart=/usr/local/bin/gpg-agent --supervised
    ExecReload=
    ExecReload=/usr/local/bin/gpgconf --reload gpg-agent
The empty ExecStart= and ExecReload= reset all possible previous

@_date: 2019-07-11 18:11:53
@_author: Teemu Likonen 
@_subject: wrong gpg-agent version running? 
What bug? We have not seen a bug in this message thread.

@_date: 2019-07-11 18:34:50
@_author: Teemu Likonen 
@_subject: wrong gpg-agent version running? 
We have not been discussing about Debian package upgrade. This message
thread is about additional local installation (/usr/local) which is
outside of Debian's package system.

@_date: 2019-07-11 21:40:22
@_author: Teemu Likonen 
@_subject: wrong gpg-agent version running? 
+0200")
Just remembered that there is also dirmngr.service for which you
probably want to the same thing as for gpg-agent.service.

@_date: 2019-07-14 09:21:12
@_author: Teemu Likonen 
@_subject: WKD auto-key-retrieve method 
I think you should add "--sender email at address" option so that your
signatures have information for WKD auto-key-retrieve method (and also
for TOFU statistics).
It is probably mail user agent's job to add "--sender" but maybe it is
also fine to have that in gpg.conf file.

@_date: 2019-07-14 14:47:40
@_author: Teemu Likonen 
@_subject: WKD auto-key-retrieve method 
(EEST)")
Now WKD lookup worked automatically when my mail client tried to verify
your signature. It seems that you added --sender somewhere.

@_date: 2019-07-23 07:52:43
@_author: Teemu Likonen 
@_subject: revoke last valid user ID 
Maybe you have previously revoked the whole key. Such key is shown with
all its user IDs revoked.

@_date: 2019-06-14 11:31:01
@_author: Teemu Likonen 
@_subject: New keyserver at keys.openpgp.org - what's your take? 
You should have added a link to information about this "latest new
keyserver" and its "different model" which you are referring to. Well,

@_date: 2019-06-14 17:25:05
@_author: Teemu Likonen 
@_subject: New keyserver at keys.openpgp.org - what's your take? 
+0200")
It may turn out to be a good choice to leave other people's certificates
(third-party signatures) out. It seems to solve the storage abuse
problem and probably doesn't harm too much communities who need web of
trust. Generally web of trust works only in tight communities who can
really verify each other's keys. Such communities can easily distribute
their keys through their web site or other common resources. For larger
audience it's probably enough to have an easy and automatic key
discovery and key update service, such as this keys.openpgp.org seems to
be. I think.

@_date: 2019-03-03 10:46:33
@_author: Teemu Likonen 
@_subject: Two utilities: gpg-tofu and gpg-graph 
I moved these utilities to a new combined repository:
    There is also a new tool gpg-cert-path which find the shortest
certification distance between two keys.

@_date: 2019-03-08 20:21:29
@_author: Teemu Likonen 
@_subject: Default trust-model TOFU 
Maybe you refer only to key signing parties as nerdy things but I think
the whole social web of trust concept is very nerdy. It's useless for
most people and I'd say that TOFU model would be better default. Do you
have plans for that, to set the default trust model to "tofu" or

@_date: 2019-10-12 10:13:59
@_author: Teemu Likonen 
@_subject: Future OpenPGP Support in Thunderbird 
I agree with that even though I have never really used Thunderbird.
But using a custom key storage and implementation (or do they use
Sequoia PGP library?) is an interesting choice in the world of Unix-like
systems. It's pretty much the normal way elsewhere, though.
PGP and GnuPG and the related communities have tried really hard to
build a system based on person's long-term identity keys. All that web
of trust thing relies on keys that are used relatively long time. But as
we know this doesn't work for most people. People are really bad at
maintaining long-term identity keys. I think this is the most important
reason why other software just auto-generate "device keys" or
"application keys" and exchange them. They just forget about the
identity part and keys' usage in the long term. Change your phone or
just reinstall the application and you'll have new keys. Keys come and
go and it's perfectly normal.
Thunderbird seems to be going to that direction and it is probably a
good thing. From the mindset of crypto nerds (like us) or Unixy tool box
this can be a barrier, obviously.

@_date: 2019-10-18 08:12:39
@_author: Teemu Likonen 
@_subject: FAQ: seeking consensus 
I think the FAQ should briefly discuss the attack and weaknesses of SKS
keyservers. The FAQ could then say that with GnuPG version user is quite safe. Then mention that there is also alternative,
keys.openpgp.org, with different features.

@_date: 2019-09-17 19:10:02
@_author: Teemu Likonen 
@_subject: Automatically delete old keys from servers 
That is the very purpose of invalid (revoked, expired) keys in the
server: tell people that the keys are invalid and not to be used. If the
keys were removed from servers (which won't happen) it would be more
difficult to share that important information.
A reminder email doesn't sound like a good idea: a key might be revoked
or expired because the owner's email address is no longer valid. The
server can't know if user wants to update key's expiration date or if
the key is expired or revoked for good.
keys.openpgp.org is different from usual SKS keyservers so there might
be different policies. My views in above paragraphs are about SKS

@_date: 2020-08-07 19:58:21
@_author: Teemu Likonen 
@_subject: keyoxide.org - new service for GnuPG users 
I think you should have written more content in your message: a
description of the service and perhaps some own thoughts about it.
Anyway. Keyoxide uses OpenPGP keys' certificate notations to prove that
certain social media profile or web site belongs to the key's owner.
That is interesting because there are no Keyoxide profiles at all. When
opening a (pseudo) profile the service just searches for an OpenPGP key,
checks if it has certain type of notations (URL) and goes to find the
following string from the URL:
    [Verifying my OpenPGP key: openpgp4fpr:FINGERPRINT]
"FINGERPRINT" is OpenPGP key fingerprint.
So the "profile" is managed entirely within OpenPGP key and those
external social media profiles.

@_date: 2020-02-24 21:41:45
@_author: Teemu Likonen 
@_subject: Bulk removal of expired keys 
For the primary goal of removing expired keys:
    gpg --list-keys --with-colons | awk -F: '
    $1 == "pub" && $2 == "e" {expired = 1}
    $1 == "fpr" && expired == 1 {print $10; expired = 0}' | \
        xargs echo gpg --batch --yes --delete-keys
Remove the "echo" when you are sure.

@_date: 2020-07-19 09:33:07
@_author: Teemu Likonen 
@_subject: Verify PGP signed email on the command line 
The MIME must be decoded first but gpg doesn't do that. It is email
client's job to extract the MIME part that was signed and the signature
itself. Those two are sent to "gpg --verify".

@_date: 2020-10-11 12:02:00
@_author: Teemu Likonen 
@_subject: Show that an encrypted message was signed, without decrypting it 
It seems that there is a visible signature packet in encrypted and
signed messages. See the output of this command:
    echo message | gpg --encrypt --sign --default-recipient-self | \
        gpg --list-packets

@_date: 2020-10-12 09:28:35
@_author: Teemu Likonen 
@_subject: Show that an encrypted message was signed, without decrypting it 
Thank you. I was surprised to see all the packets listed with "gpg
--list-packets" but trusted its output. It seems that my "gpg
--list-packets" command (see above) decrypts the message using the
cached secret key and then shows all the packets.
As you said "pgpdump" don't show any signature information. There is
just a public key encrypted session key packet and a symmetrically
encrypted message packet.
