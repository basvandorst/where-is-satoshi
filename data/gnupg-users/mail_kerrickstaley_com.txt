
@_date: 2011-06-12 16:15:04
@_author: Kerrick Staley 
@_subject: Generate digest and signature seperately 
Is it possible to generate the digest for a file, and then create the
signature from that digest later?
I'm making this inquiry because developers for the Arch Linux distribution
need a way to sign databases (lists of software packages) on the central
repository (package server) without having to copy those repositories to
their local computer and back. There is the option of hashing the databases
and signing the hash, but this introduces additional complexity which
shouldn't be necessary. Another option is copying secret keys to the server,
but this is a bad idea because all developers' keys would need to be revoked
in the event that the server is compromised; key revocation would be a huge
hassle which would be compounded with the need to audit the server's
So, being able to seperate the generation of digests and the generation of
signatures would be very useful, but I cannot find documentation anywhere on
how to do this. Can anyone help?
Kerrick Staley

@_date: 2011-06-12 18:00:06
@_author: Kerrick Staley 
@_subject: Generate digest and signature seperately 
I realize that this is a problem; however, it considered to be an
acceptable risk. The same problem happens if the developers sign a
SHA512 of the database. The only way for developers to verify the
database is to copy it to their computer, but this is considered to be
too much of a hassle.
-Kerrick Staley

@_date: 2011-06-12 19:52:01
@_author: Kerrick Staley 
@_subject: Generate digest and signature seperately 
The databases (lists) are not very large, as far as I understand, but
it wasn't my call ("repositories" in the 4th line is a typo; I meant
"databases"). I'm not an Arch Linux developer; I'm just contributing
to their effort to implement package signing.
Individual packages will be signed, but for complete security, the
databases must themselves also be signed; otherwise, an attacker could
use DNS spoofing to deliver a database listing outdated packages with
known vulnerabilities, and it would happily be accepted by end-users'
systems. The vulnerable packages would not be updated, but the users
would most likely not notice, since other packages would be updated.
-Kerrick Staley

@_date: 2011-06-13 10:12:14
@_author: Kerrick Staley 
@_subject: Generate digest and signature seperately 
OK, that answers my question. I think we'll go with the hash-signing
implementation. Thanks!
-Kerrick Staley

@_date: 2011-06-13 19:31:01
@_author: Kerrick Staley 
@_subject: Generate digest and signature seperately 
Just to make sure that I'm understanding this, a complete PGP signature does
not embed information about whether it is the signature of a file or the
signature of a certificate, so it's a bad idea to sign a remotely generated
-Kerrick Staley

@_date: 2011-06-14 12:16:31
@_author: Kerrick Staley 
@_subject: Aspects of trust 
This is to confirm my understanding of an important aspect of the way
GnuPG works:
When you decide whether to trust a signature, there are two questions
that must be asked:
a) Does the key used to make this signature really belong to the
person named in the certificates's UID?
b) Given that the key is valid, is the person trustworthy?
GnuPG and the web-of-trust concept only manage information related to
the first question. GnuPG provides no means of encoding or storing the
fact that a person is or is not trustworthy; it merely displays the
UID when verifying a signature, and the user is left to decide whether
the person should be trusted.
Am I correct in this?
Kerrick Staley

@_date: 2011-06-14 14:35:51
@_author: Kerrick Staley 
@_subject: Aspects of trust 
OK, I think I understand:
Validity and trust are separate, but GnuPG lumps "validity" and
"trust, for the sole purpose of signing others' keys" together into a
single value (which is one of "unknown", "never", "marginal", "full",
and "ultimate"). One can imagine situations in which a key's owner is
"never" trusted to sign others' keys, but one would still like to keep
track of how valid the key itself is ("unknown", "marginal" or
"full"). However, such situations are corner cases, and GnuPG doesn't
provide facilities for dealing with them.
Is this correct?
Kerrick Staley
