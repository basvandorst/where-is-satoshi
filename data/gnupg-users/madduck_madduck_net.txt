
@_date: 2001-06-19 02:45:01
@_author: MaD dUCK 
@_subject: key problems 
hi GPGers,
i have a key, which GPG reports as follows:
pub  1024D/A8FA196E  created: 2001-05-07 expires: 2002-06-17 trust: f/u
sub  2048g/E93FAECE  created: 2001-05-07 expires: 2002-06-17
(1)  Martin F. Krafft (2). MaD dUCK (3)  [revoked] Martin F. Krafft (MaD dUCK) however, whenever i sign someone else's key, my name appears as "MaD
dUCK" -- i guess that's why there is a '.' after the (2) in the
listing above.
is there any way to change that so that (1) is the main name of the
key, and (2) only an alternate user ID?
martin;              (greetings from the heart of the sun.)
  \____ echo mailto: ! "<*> mailto:" net

@_date: 2001-06-19 17:29:01
@_author: MaD dUCK 
@_subject: --allow-secret-key-import 
also sprach Daniele Russolillo (on Tue, 19 Jun 2001 04:59:09PM +0200):
make that   gpg --allow-secret-key-import --import file.asc
and gpg will not only display a key, but actually import it
martin;              (greetings from the heart of the sun.)
  \____ echo mailto: ! "<*> mailto:" net

@_date: 2001-06-21 09:34:02
@_author: MaD dUCK 
@_subject: key problems 
also sprach Markus Orlich (on Thu, 21 Jun 2001 08:51:03AM +0200):
except both UIDs will exist again when I update the keyserver...
martin;              (greetings from the heart of the sun.)
  \____ echo mailto: ! "<*> mailto:" net

@_date: 2009-07-06 10:21:05
@_author: martin f krafft 
@_subject: 8192bit RSA keys 
Hey folks,
Two years ago, there was a thread on this list, in which RSA key
sizes >2048 were discussed [0]. In these two years, the crypto-world
has been shaken up a bit, and computers got yet a bit more powerful.
0. I am trying to decide whether I want to create myself a new RSA key
and am looking at key lengths of 2k, 4k, and 8k. In theory, I'd like
to use the 8k variant, simply because I postulate that my machines
can handle it (I don't use GPG on a PDA/SmartPhone (yet)), but
I don't know if this makes sense in practice.
I understand RSA and I cannot imagine compatibility problems with
other implementations, but I'd still like to reopen the issue and
ask this list what they think about >2048bit keys, and 8192bit in

@_date: 2009-07-09 21:32:38
@_author: martin f krafft 
@_subject: 8192bit RSA keys 
also sprach David Shaw  [2009.07.09.2040 +0200]:
So they say key length up to 3k. Does that affect key generation
only? If not, why wouldn't those cards be able to handle larger

@_date: 2009-07-10 16:04:09
@_author: martin f krafft 
@_subject: 3072 bit keys, smartcards and bugs (was: 8192bit RSA keys) 
also sprach Werner Koch  [2009.07.10.1532 +0200]:
Could you give us a hint why GnuPG would need changing?
So 3072bit keys generated with GnuPG from Debian unstable are
unusable, or unusable with the SmartCard?

@_date: 2010-10-14 17:49:54
@_author: martin f krafft 
@_subject: Confirmation for cached passphrases useful? 
also sprach MFPA  [2010.10.14.0102 +0200]:
That's a great idea. I have started work on a Facebook applet to
automate this process, so that I can keep such vital information
with everything else that I care about.
Strangely appropriate, randomly selected quote below.

@_date: 2017-06-20 15:34:44
@_author: martin f krafft 
@_subject: Managing the WoT with GPG 
I've spent some time trying to figure out how to make actual use of
the web-of-trust (the "pgp" trust-model), and I am turning to this
list for some advice, related to a couple of questions:
1. My public keyring has several thousand keys and "weighs" almost
   500Mb. Every couple of runs, I'm told to run --check-trustdb,
   which takes several minutes to complete, then tells me that the
   next run will be in like 2 weeks, but three operations later, I'm
   again being asked to run --check-trustdb. The funny thing is that
   these operations are just message signing and authentication,
   sometimes decryption. However, parcimonie is running in the
   background, updating the keyring one key at a time. Is that the
   reason? If yes, is there any way to mitigate this? I've sketched
   out an idea under (3.) below, but maybe there's another way??
2. I've also tried running --update-trustdb, but it seems that this
   process is *endless*. I have no idea how many keys remain, and
   I also got the impression that I keep seeing keys I already
   processed. How do you approach this? Or does everyone just use
   tofu these days?
3. Is there a way to run --check-trustdb or --update-trustdb not
   over the entire key graph, but only traversing to a certain depth
   starting from a specific key? Then I could tell parcimonie to run
   --check-trustdb for every key it imports, or have mutt run
   --update-trustdb for every key I want to use. This would
   iteratively achieve the job with the benefit that no cycles would
   be wasted processing trust for keys I never use. I understand
   --edit-key can be used to change the ownertrust, but I don't
   think it recomputes the WoT on change, does it?
   If there's no way to do this yet, would this be a useful addition
   to the UI, assuming it's technically possible?
4. Is there a tool to visualise or explain the computed validity of
   a key? I.e. one saying that e.g. Werner's key is valid because
   Daniel signed it, and I fully trust Daniel? There's wotsap, but
   I want to analyse my own keyring, not a .wot file?
5. Has anyone come up with a smart way to keep pubring/trustdb
   synchronised between multiple workstations?
Thanks for any insights!

@_date: 2017-06-21 11:03:40
@_author: martin f krafft 
@_subject: Key corruption: duplicate signatures and usage flags 
My key on the keyservers is 0x55C9882D999BBCC4. If I download this
to a fresh keyring, I get some weird behaviours:
  % alias gpg='gpg --homedir=.'
  % gpg --recv-key 0x55C9882D999BBCC4
  gpg: keybox '/home/ssd/madduck/.tmp/cdt.p0R8ly/pubring.kbx' created
  gpg: /home/ssd/madduck/.tmp/cdt.p0R8ly/trustdb.gpg: trustdb created
  gpg: key 55C9882D999BBCC4: public key "Martin F. Krafft " imported
  gpg: no ultimately trusted keys found
  gpg: Total number processed: 1
  gpg:               imported: 1
  % gpg --list-keys !$
  gpg --list-keys 0x55C9882D999BBCC4
  pub   rsa4096 2009-07-06 [SC] [expires: 2020-02-01]
      	2CCB26BC5C49BC221F20794255C9882D999BBCC4
  uid           [ unknown] Martin F. Krafft   uid           [ unknown] Martin F. Krafft   uid           [ unknown] Martin F. Krafft (Debian)   uid           [ unknown] [jpeg image of size 2160]
  sub   rsa4096 2016-07-01 [E] [expires: 2018-02-01]
  sub   rsa4096 2016-12-01 [S] [expires: 2018-02-01]
  sub   rsa4096 2016-12-01 [A] [expires: 2018-02-01]
So far, so good. Do note the [SC] usage flags.
And then check this out:
  % gpg --edit-key 0x55C9882D999BBCC4
  gpg (GnuPG) 2.1.18; Copyright (C) 2017 Free Software Foundation, Inc.
  This is free software: you are free to change and redistribute it.
  There is NO WARRANTY, to the extent permitted by law.
  uid  Martin F. Krafft   sig!3        55C9882D999BBCC4 2009-07-06 never       [self-signature]
  sig!3        55C9882D999BBCC4 2017-06-07 never       [self-signature]*
              [expires: 2020-02-01 11:20:11]
  sig!3        55C9882D999BBCC4 2009-07-06 never       [self-signature]
    x-hkp://pool.sks-keyservers.net
  [?]
  sub  AD18B605905834CC
  sig!    P    55C9882D999BBCC4 2015-07-01 never       [self-signature]*
    Signature policy:               [expires: 2010-08-07 08:37:18]
  [?]
  key 55C9882D999BBCC4:
  24 duplicate signatures removed
That's a bit weird. Where do these come from?
But there's more: now the usage flag of the primary key has been
changed to just 'C' (which is what I uploaded), and ?
  pub  rsa4096/55C9882D999BBCC4
      created: 2009-07-06  expires: 2020-02-01  usage: C
      trust: unknown       validity: unknown
  [?]
? a subsequent save spews a weird list of "Preferred keyserver:"
text to stdout, but now the usage flag of the primary key is also
just [C] in the --list-keys output:
  gpg> save
  Preferred keyserver: Preferred keyserver: Preferred keyserver: Preferred keyserver: Preferred keyserver: Preferred keyserver: Preferred keyserver: %
  % gpg --list-keys 0x55C9882D999BBCC4
  pub   rsa4096 2009-07-06 [C] [expires: 2020-02-01]
        2CCB26BC5C49BC221F20794255C9882D999BBCC4
  [?]
Do you have any idea what might be going on here? Is this a problem,
or just cosmetic? Is it fixable? How?

@_date: 2017-06-21 13:55:52
@_author: martin f krafft 
@_subject: Managing the WoT with GPG 
also sprach Neal H. Walfield  [2017-06-21 11:53 +0200]:
It's gotta start somewhere, though, right? Can't it pick the leaf
where to start?

@_date: 2017-06-22 13:22:46
@_author: martin f krafft 
@_subject: Key corruption: duplicate signatures and usage flags 
Hey Justus, thanks for writing in. Here are the answers you wanted:
There were [SC] when I created it, but I've recently changed to
a signing subkey and removed the flag from the primary key.
Yeah could be. And while there's no way this can be fixed, it also
doesn't really harm, does it?

@_date: 2017-06-22 15:00:52
@_author: martin f krafft 
@_subject: Managing the WoT with GPG 
also sprach Neal H. Walfield  [2017-06-21 14:00 +0200]:
As far as I understand, the parameters --marginals-needed and
--completes-needed can be used to define a maximum search depth D,
so when I ask GPG to update the trustdb WRT key 0xdeadbeef, then I'd
envision it to
  1. enumerate all keys reachable within D steps
  2. iterate all these keys
  3. backpropagate the trust/validity level towards 0xdeadbeef
  4. update the nodes touched by this walk in trustdb
  5. do this for every key when it changes
  6. do this for every key upon use, such that missing information
     can be interactively provided, and expired keys pruned
     just-in-time.
  7. --check-trustdb could still be used to do overall cleaning at
     regular intervals.
Given how the keygraph is essentially a singly-linked graph with
keys containing pointers to other keys that signed them, while there
exists no such information implicitly about all the keys that have
been signed *by* a given key (e.g. one that's ultimately trusted),
the approach I've sketched actually seems more intuitive, don't you

@_date: 2017-06-22 15:34:59
@_author: martin f krafft 
@_subject: Managing the WoT with GPG 
also sprach Andrew Gallagher  [2017-06-21 15:57 +0200]:
Yeah, that'll do the job, except it blindly overwrites changes made
locally. It's unlikely this happens, but say I declared your key
trustworthy last night at home, forgot to run sync, and
not-trustworthy this morning at the office (sorry, this is just
a silly example?), and then ran sync, your key would be trustworthy
On the other hand, it'd be totally possible to export ownertrust
prior to the import, and then fire up vimdiff or the like on the two
versions. Not exactly a great UID at all.
It'd be better if trustdb would be journalled using a mergeable
And then again, something like jetring is far beyond overkill for
day-to-day usage?

@_date: 2017-06-22 16:06:03
@_author: martin f krafft 
@_subject: Managing the WoT with GPG 
also sprach Peter Lebbing  [2017-06-22 15:46 +0200]:
Yeah, that too.
That sounds like a worthwhile optimisation, indeed.
And so does this?

@_date: 2017-06-22 16:29:30
@_author: martin f krafft 
@_subject: Managing the WoT with GPG 
also sprach Neal H. Walfield  [2017-06-22 16:15 +0200]:
This would be handled upon use of such keys. In fact, rather than
updating the trustdb on update of key material, wouldn't it make
much more sense to compute the information just-in-time? Provided
we'd have a data format allowing for fast access like this?

@_date: 2017-06-23 06:55:15
@_author: martin f krafft 
@_subject: Key corruption: duplicate signatures and usage flags 
also sprach MFPA <2014-667rhzu3dc-lists-groups at riseup.net> [2017-06-23 00:33 +0200]:
Well, it somehow seems to work, apart from the fact that gnupg first
needs to clean up the key (using --edit-key) after downloading the
modified version from the keyservers.
It does this independently, yes.

@_date: 2017-06-23 10:02:44
@_author: martin f krafft 
@_subject: Key corruption: duplicate signatures and usage flags 
also sprach Werner Koch  [2017-06-23 09:40 +0200]:
So how does this explain
  % export GNUPGHOME=$(mktemp -d)
  % gpg --recv-key 55C9882D999BBCC4
  % gpg --list-key 55C9882D999BBCC4 | grep '^pub'   # [SC]
  % gpg --edit-key 55C9882D999BBCC4 save
  % gpg --list-key 55C9882D999BBCC4 | grep '^pub'   # [C]
Are you saying that gnupg 2.1.18 added the self-signature in the
wrong place?

@_date: 2017-06-23 15:35:05
@_author: martin f krafft 
@_subject: Managing the WoT with GPG 
also sprach Werner Koch  [2017-06-22 19:02 +0200]:
Obviously, one could work with caching here?
Running --check-trustdb in the background once a day is doable, for
I guess what I'd really like is a way to run --update-trustdb just
for a specific key, and a way to do that automatically when using
a key, e.g. to verify or encrypt to?

@_date: 2017-06-26 11:27:30
@_author: martin f krafft 
@_subject: Managing the WoT with GPG 
also sprach Peter Lebbing  [2017-06-23 17:56 +0200]:
I haven't heard that one in years. Lol. ;)
I've been doing that for a long time already, and yes, it mitigates
the issue a little bit. I still think that the interface doesn't
exactly invite people to invest time into the WoT, which directly
translates into lesser quality.
