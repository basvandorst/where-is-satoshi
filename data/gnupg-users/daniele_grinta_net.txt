
@_date: 2015-02-18 19:46:19
@_author: Daniele Nicolodi 
@_subject: Unattended signing 
I have a quite simple question on best practice for the use of GPG. I
haven't found an answer searching online. I hope this mailing list is
the right place for asking.
I have an automated process that collects some data and unattended sends
it via email. I want that data to be encrypted and signed. The
encryption part is easy as it requires only public keys of the
recipients. Signing, however, requires to make the private key used
available to the process.
I have a sufficient trust in the security of the server where the
automated process runs, but I would like to reduce to a minimum the risks.
What is the best practices in such cases?  I can imagine several
possible options: using a subkey of my key (is it possible to remove
passphrase protection from a subkey?), using a dedicated key, using a
subkey of a dedicated key and periodically rotate such subkey.
Ideas? Comments?
Thanks. Cheers,

@_date: 2015-02-21 17:42:40
@_author: Daniele Nicolodi 
@_subject: Unattended signing 
I haven't received any comment on this. Is ti because the question is
too dummy, I'm being too naive, or the context is not explained with
sufficient detail?
Thanks for your attention :)

@_date: 2015-02-23 23:51:48
@_author: Daniele Nicolodi 
@_subject: Surprising command line options handling 
I've been struggling quite a long while today trying to understand why
the following command does not do what I expected:
gpg --export-secret-subkeys 41E999D7! \
    --export-options export-reset-subkey-passwd
It does not reset the password on the exported subkey.
After some head scratching I recognized that gpg stop parsing arguments
when it encounters the key id and ignores what follows. This is probably
caused by the fact that whatever follows the first key id is also
interpreted as a possible key id, and that gpg by default does not error
out on invalid key ids. Please correct me if I'm wrong.
There is a reason why gpg does not choke on bad key ids? There is a way
to make the key id parsing strict and avoid surprises as the one above?
Thanks. Cheers,

@_date: 2015-02-24 00:59:07
@_author: Daniele Nicolodi 
@_subject: Surprising command line options handling 
In retrospect this is quite clear.
However, the ordering is not really enforced: this
gpg --export-secret-subkeys \
    --export-options export-reset-subkey-passwd --armor \
    whatever 41E999D7!
or this
gpg --export-secret-subkeys \
    --export-options export-reset-subkey-passwd whatever --armor \
    41E999D7!
appear to be valid command lines.
I find it surprising that unrecognized tokens are simply ignored.
Wouldn't it be preferable to error out, at least on unrecognized options?

@_date: 2015-02-24 01:36:25
@_author: Daniele Nicolodi 
@_subject: Unattended signing 
Hello Daniel,
thanks for your reply.
I was not very clear on this: the unattended signing is performed by an
application that collects some sensible data and sends them by email
encrypted and signed.
What do you exactly mean by "destroying"? Isn't setting a suitable
expire date enough?
Thanks. Cheers,

@_date: 2015-02-24 12:24:09
@_author: Daniele Nicolodi 
@_subject: Surprising command line options handling 
Hello Werner,
thank for your answer. Trying to better understand gnupg command line
argument parsing I found that the real confusing thing is that arguments
can be silently ignored:
gpg --list-keys foo
results in an error if there is no key matching "foo", however
gpg --list-keys 41E999D7 foo
does not result in an error and the fact that "foo" does not match any
is not signaled to the user, if there is a key that matches "41E999D7".
I see that in the 2.1 branch there is indeed a check and a warning for
arguments that look like options (start with "--") so I must not be the
only one that found this confusing :)
Why do not error out if an argument cannot be used to identify a key? I
think that signaling to the user that one part of the command line has
not been successfully interpreted is good practice.

@_date: 2015-03-04 11:25:23
@_author: Daniele Nicolodi 
@_subject: Thoughts on GnuPG and automation 
I have no idea about the Java tooling for interfacing to external
libraries, but (after seeing so many complaints on the mailing list)
I've recently started to work on Python bindings to GPGME using Cython,
and so far it has been an extremely smooth process and the resulting
Python API feels quite pythonic (I haven't started with the asynchronous
calls yet, those will probably be harder to map in a pythonic way).
The fact that writing the bindings is quite easy, is due indeed to the
fact that GPGME is a fine API for C (and to Cython to a large extent).

@_date: 2015-03-09 22:40:33
@_author: Daniele Nicolodi 
@_subject: cython wrapping gpgme WAS: Thoughts on GnuPG and automation 
Hello Hans-Christoph,
yes, I'm aware that there are other wrappers for GPGME. I cannot say
that I studied them in detail, but I can give you my reasons why I
started to work on a new one.   I'm doing this in my (quite scarce)
spare time, so the first requirements is that the development should be fun.
I knew this one. It is based on SWIG, and my experience with SWIG is
such that I want to stay as far as I can from that horrible mess.
I didn't know this one. It is interesting. However, it is written
directly in C using the CPython extension API and this makes development
quite tedious. There is probably something to learn from this project.
Those, as far as I know, work using the gpg command line, not the GPGME
library and are all based on the same code. Unfortunately the gpg
command line does not make some operations easy to script, therefore
those are quite limited.

@_date: 2015-03-26 00:38:25
@_author: Daniele Nicolodi 
@_subject: PGP/MIME (Was: One alternative to SMTP for email: Confidant Mail) 
The difference must be somewhere else: I use Thunderbird 31.5.0 and
Enigmail 1.8 (20150316-1815) and, while it recognizes the signatures,
I see the attachment "signature.asc" for all the PGP/MIME signed
emails I've checked.

@_date: 2015-10-27 11:22:32
@_author: Daniele Nicolodi 
@_subject: absolutely nothing to panic over 
If what makes you think that public key cryptography is insecure by
definition is the possibility to circumvent any key exchange protocol
via quantum computation, please note that the same quantum principles
allow for quantum key distribution, which is "quantum secure" key
exchange over an insecure channel.
In general I find broad and overly simplified statements on complex
matter very easy to confute, and I thus believe that they must not be
taken too seriously.

@_date: 2015-09-28 22:29:02
@_author: Daniele Nicolodi 
@_subject: Should I be using gpg or gpg2? 
Even assuming that this is true, there "most" in not all, thus there are
some improvements in the 2.0 ad 2.1 release series that are not in the
1.4 one. That alone is a good reason to move to the modern GPG
As much as I like conclusions based on anecdotal evidence, I don't
really see what you want to say with that statement. GnuPG 1.4 receives
all the bug fixes it needs based on known bugs, however, code
improvement and architectural changes that make the system more secure
are implemented only in 2.1 and partially in 2.0. I don't see anything
wrong or worrisome with that.

@_date: 2016-02-06 22:47:45
@_author: Daniele Nicolodi 
@_subject: Documentation format 
LaTeX handles utf8 encoded input files with \usepackage[utf8]{inputenc}
and on my system org-mode correctly produces utf8 encoded LaTeX files
using that directive. It works just fine for the non-ascii characters
contained in your examples a couple of messages up in the thread.
Can you be more precise in describing the problem?
I would also suggest to look into the org-entities facility as a way to
handle more complex cases:

@_date: 2016-07-18 15:03:52
@_author: Daniele Nicolodi 
@_subject: How to encrypt and sign with different keys 
You can select the key for signing with the --local-user option and the
key for encrypting with the recipient option.
That's most definitely the wrong syntax.
If you want to automate signing consider exporting a signing subkey
without a passphrase. The passphrase would have to be stored along with
the key anyhow.
Or better not.

@_date: 2017-08-12 20:15:31
@_author: Daniele Nicolodi 
@_subject: --export-options export-reset-subkey-passwd 
I have a workflow were I use this option to reset the subkey passphrase
during export to a remote system where the subkey is used for unattended
signing.  This option has been removed in GnuPG 2.1, and I haven't found
a way to obtain the same result.
Does anyone have any tip?
Thanks! Cheers,

@_date: 2017-08-13 00:17:16
@_author: Daniele Nicolodi 
@_subject: --export-options export-reset-subkey-passwd 
Digging a bit more, it seems that the functionality got dropped because
with GnuPG 2.x all key manipulations go through gpg-agent and it does
not (yet?) support password reset on expert.
Is there any plan to bring back this functionality?  I'm willing to
contribute code, but I would need guidance on the foreseen way to
implement this.

@_date: 2017-08-28 08:53:49
@_author: Daniele Nicolodi 
@_subject: --export-options export-reset-subkey-passwd 
Hello Werner,
I would like to help get this fix. What is the plan to implement it?
Thanks. Cheers,

@_date: 2018-01-22 10:31:25
@_author: Daniele Nicolodi 
@_subject: [OT] Re: failed to convert unprotected openpgp key: Checksum error 
Uh? As far as I know, the only characters not allowed are / and null.

@_date: 2018-01-22 12:46:01
@_author: Daniele Nicolodi 
@_subject: [OT] Re: failed to convert unprotected openpgp key: Checksum error 
Sorry, I should not be writing email before my morning coffee: I read
filenames instead than usernames.

@_date: 2018-01-28 17:37:40
@_author: Daniele Nicolodi 
@_subject: --export-options export-reset-subkey-passwd 
As a work around I come up with this simple script, which has the sole
problem of asking the secret subkey passphrase a few times too much, and
to require to explicitly enter an empty passphrase.
Let me know if it is excessively dummy or if there is a better way.
set -e
# make sure to have a "!" at the end of the key fingerprint to export
# exclusively the corresponding subkey and not the primary key
if [ "$KEY" == "${KEY%\!}" ]
    KEY="$KEY"\!
umask 0077
TMPDIR=$(mktemp -d)
trap "rm -r $TMPDIR; exit" 0 1 2 3 15
gpg --export-secret-subkey "$KEY" | gpg --home $TMPDIR --import
gpg --home $TMPDIR --change-passphrase "$KEY"
gpg --home $TMPDIR --armor "$ --export-secret-subkey "$KEY"
