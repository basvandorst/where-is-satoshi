
@_date: 2008-04-14 16:46:33
@_author: Herbert Furting 
@_subject: Miscellaneous questions 
Hi list.
I've got some questions...
1) When creating a new UID, why does gpg have a minimum size of 5
characters? This is not imposed by RFC4880? Where can I report this bug.
2) I have a key that is already published to keyservers. Unfortunately it
uses old SHA1 as hasing algorithm.
Now I want to recreate the selfsignature (but using SHA512) and mark the old
selfsignature(s) (the 0x13's on my UIDs) that they _can_ not longer be used.
Most OpenPGP would simply only use the newer self-sig (according to the
creation time) but RFC4880 says that an implementation might use any other
means to resolve ambiguites so just having to self-sigs published doesn't go
far enought for me. I want the old selfsigs revoked (btw: what would be a
good reason for revocation?) and have a new self-sig on the (same) UIDs.
Main reason for this is probably to prevent downgrade attacks or similar
While the standard seems to allow this,.. gpg does not (it won't sign a UID
when the a self-sig has been revoked before).
How can I solve this?
3) On an existing key,.. how can I change the key usage flags with gpg?
4) gpg stores most (all) of the preferences in 0x13 self-sigs. I know that
this could make sense for the preferred algorithms and the features but I
think that I prefer to have a sort of default preferences in an 0x1F
self-sig. e.g. I'd like to set the algorithm preferences globally on a 0x1F
and only set it "locally" for one UID if the environment where that UID is
used hast different settings.
The key usage and  key-server-prefs should be always on a 0x1F selfsig and
not und 0x13's because these are information about the key itself,... and
not a UID,... and they don't have that role-style as with the
algorithm-prefs and key features. Yes I know that RFC4880 allows key usage
flags and key server prefs on 0x13's,... but I think that's still not the
best idea.
How can I change this in gpg, that it puts these on 0x1F?
5) Last but not least,... when setting the algorithm preferences gpg always
automatically adds 3DES, SHA1 and uncompressed. I now that all of these are
must-implement algorithms. But RFC4880 does not say, that the preference
subpacktes must include them. It just says it's good behaviour.
I think the export mode should allow it to not have them set.
My reason therefore is this:
An OpenPGP implementation MUST implement these algorithms,... if they are
part of the subpackets or not.... so communication will work anyway. But
when I despite the good-behaviour stuff remove those algorithms from the
preference subpacktes, I make a statement like saying: I don't care what
RFC4880 says,.. I consider 3DES as unsafe for my needs and won't accept
anything using it... same idea goes with the hashing algorithms.
For the compression preference,.... you now that there are attacks that are
thwarted by using compression, right?
Well removing uncompressed from the list, could say something like: Although
I support uncompressed datapackets (of course every implementation does) I
don't want,.. that anybody sends me uncompressed data,.. because I fear
those attacks.

@_date: 2008-04-14 23:50:46
@_author: Herbert Furting 
@_subject: How trust works in gpg... 
Hi Peter.
Trust and signatures are different things (of course they are
You can change the trust on the key with the "trust" command when
editing his key.

@_date: 2008-04-14 23:22:59
@_author: Herbert Furting 
@_subject: Miscellaneous questions 
Hi David.
 Ah thanks,.. wouldn't it make sense to merge this with the expert flag?
Ah great,... and it will work with gpg,... I mean a layout like,
[pubkey packet]
[UID packet]
[positive user certification 1]
[revoc of positive user certification 1]
?[positive user certification 2 (with better algos)]
I know,.. but in the signatures,.. only the revocation key subpacket
uses it, right?
The signatures (even the certification sigs) are made directly on the
key (and additional data like the UID), right?
So as far as I understand,.. I should actually gain some security, at
least from the point that an attacker could no longer concentrate on
attacking my SHA1 sigs.
If he want's to do a downgrade attack (recreate an new SHA1 selfsig) he
would have to attack the signature algorithm itself (e.g. RSA) ... or
kick me until I gave him my private key ;)
So the only left areas where I should use SHA1 is hmm the MDC and the
fingprint right?
When I always make signatures (of course with "something better" than
SHA1) the SHA1 in the MDC is no problem at all...
And for the fingerprint,... in principle,... I could not rely on the
fingerprint (when singing other keys) but ask for a copy of the key
itself,.. when meeting someone.
Does this make sense?
btw: When is this going to be changed? i.e. the fingerprint algorithm?
Yeah,... I know this,... unfortunately (at least from my point of view)
gpg and this list, seems to be very conservative it such issues :-/
(don't want to offend you ;) )
Ok, if I modify it,.. and create a 0x1F with key usage, key
server-prefs, algorithm prefs, and so on... Will gpg understand this?
What will happen if I have both, e.g. a hash algo pref subpacket on a
0x1F and a 0x13?
Last but not least,.. I've already browsed through the source code...
could you please point me at the functions where I can put together the
bits for a (signature) packet (the type of the sig, date, hashed
subpacktes, and so on),... and the function that creates the actual
signature (MPI and so on) on this data and the (in case of an 0x1F) on
the key and UID?
Ah and,.. same question as to rjh,... (I hope you read my answer to his
mail,.. and share me your thoughts on my ideas :) )... why does gpg
make no use of them by default?
Yes of course,... but (hopefully) on the end of the _internal_ list.
btw: What do you think about my ideas on this issue,.. that I wrote down
in the reply to Robert?

@_date: 2008-04-14 23:03:19
@_author: Herbert Furting 
@_subject: Miscellaneous questions 
Uhm,.. apart from the answer from David (who told me the correct
parameter) I don't think that an implementation should forbid this
(making UIDs smaller than 5 characters).
OpenPGP is said to be open,... and the specification of the UID packet
only says, that the intended uses is a mail name-addr. It doesn't say
that it must be one.
I'd be happier if it would clearly say, that it's just an ID that
identifies the user (as the packet name says) but that most people use a
mail name-addr.
Imagine a closed software system that uses simply numbers for
identifying the participants. When it starts at 1, we have UIDs smaller
than 5 characters.
Hm why? I'd loose a lot of certifications and I don't see any security
problem with my approach (of course, as David said, SHA-1 is still used
in some other places).
Uhm,.. is there any reason why gpg doesn't support it?
I mean it exists,.. and there are several things (e.g. the examples from
my inital post) that would be better of with an 0x1F?
Why not? The RFC (and even the meaning of the name "preference packet")
say, that these subpackets are a way for the user to express his
preferences on alorithms. It does not say that they have to include
those fall-back-algorithms, it just says they should. So when a user
wishes not to include e.g. 3DES it should clearly mean,.. I don't like
that algorithm, despite the fact, that his implementation has to
support it.
What the authors of RFC4880 had probably in mind when saying this is a
best practise (at least I think so,.. David?! ;) ) was: As every
implementation has to support it,...put it in the list. But this packet
is not about specifying what an implementation is able to do, but what
the user would like to have. I think they were tempted by the fact,
that a preference list that contains the must-have algorithms could be
used easier for algorithm-negotiation.
Hm yes,.. but in all doing respect,... this practise is probably not
the best as it does not tell the users preference but a mix of the
users preference and the minimal algorithm subset.
But the implementation already knows about that minimal must-have
subset (because of the standard).
It's not necessary to mix it up with the users preference. See above.
Yes, but that's already the case because each implementation must
support 3DES, not because you or me put it in our lists.
Yes it will work (even if I said,... I don't like 3DES). But an
implementation could provide options to warn a user, if he receives
such messages.
Well then why does OpenPGP allow us to use newer algos? Why did we
change the fingerprint algo to SHA-1? Ok MD5 is much weaker than SHA1
(as 3DES is probably weaker than AES) but for "normal" people it should
still be impossible to forge MD5 hashes, and if an intelligence service
wants your data,.. they simply kidnap and torture you.
To be honest,.. I don't see your arguments above,... apart from the
fact, that I didn't asked about the pros and cons of algorithms. Why do
we make the whole crypto stuff,... if we stick with old algorithms
(probably weaker than newer ones).
Well,.. I have a fighter australian parrot ;-)
... again: If so,. why do we make all that effort? We could simply keep
using MD5/IDEA because for most cases that would be enough.

@_date: 2008-04-15 00:42:43
@_author: Herbert Furting 
@_subject: How trust works in gpg... 
Sorry,.. I haven't read your initial post correctly.
As David said in the meantime new UIDs are of course _not_ recognised
automatically (a user could simply add a completely wrong name). You
have to sign the UID (better said, key+UID).
You should only do so, if the name is the same (or if you know that the
key holder goes by that name).
If the new UID just contains a new email address, you should really
check if the keyholder "controlls" that email address.
You can do so, by sending him an encrypted challenge.
First of all,... you don't sign a key,.. you sign the UID for a key.
The trust stuff is there to let you recognize other keys as valid,...
that your directly signed people signed them self.
e.g. If you trust Bill, who signed Joe,.. you might (depending on which
trust, and your settings) consider Joe's signatures to,... and even
trust him ;)

@_date: 2008-04-15 02:31:07
@_author: Herbert Furting 
@_subject: Miscellaneous questions 
Well I don't want to go into such quibbling, but I've seen that gpg
complained for UIDs shorter than 5 characters,... I've seen that RFC4880
doesn't require this, and I've asked why.
Not more not less.
btw: as far as I remember,... zero-length UIDs are allowed by the
standard, aren't they?
While this doesn't make sense ("nothing" is bound to the key) it
wouldn't hurt either.
Of course it is,.. but as I've learned,.. this is not necessary because
it already works.
And please don't put my words into a light,.. that I tried to say
somebody or something might be stupid.
I just think, that an implementation should not forbid things, that are
allowed by the standard. Of course it makes sense to have things like an
expert mode or a beginners mode,.. to prevent people from doing thing
that are normally not so useful.
Did I? So probably I should burn my diploma ;)
Of course. But I didn't talk about this at all? Did you read my
arguments? I probably didn't explain it correctly (*not a native English
Preferred * Algorithm => Tells what the user prefers (and not what his
implementation support.
Neither does it strictly make sense to include these must-have algos in
the lists (because it is obvious that a conforming implementation will
support them), nor is it (or should it be) the intention of that packet.
And that's why I've argued, that one could use it to show up algorithms
that - even while supported - are not liked or accepted by a user.
If that breaks the best practise idea of the RFC,... it think - in all
doing respect - the RFC should be changed in that matter.
However... if my previous explanation were clear and you just don't like
my ideas, views (for whatever reason) we don't have to discuss it any
longer ;)
Of course it would, but why should it do so (apart from the
expert/beginners mode idea).
gpg is probably THE main implementation of OpenPGP (sorry to the
commercial PGP folks ;) ),... as such I think it should support most of
the stuff from OpenPGP, or not?
How many other major implementations are there? Not too much right? And
if none of these use all (or at least most) of the "features",.. why did
we included it at all? I don't talk just about the UID size (which is
already cleared) but also on stuff like the 0x0F sigs.
Is there an implementation the uses third party signatures? Or timestamp
sigs? Can I use the critical bit with gpg? etc. etc.
Please don't understand me wrong,... I'm _not_ saying "stupid Werner
Koch, stupid David Shaw and all the other developers,... go and
implement this!" ;-)
I know that this is opensource and all have their own lives and
business, but I have the felling that the attitude here is,.. most
average people don't need it,... it will perhaps break older/other or
even historical implementations (which ones ;) ) so don't even talk
about it or think about the idea the we could implement it.
Got the point?
Agreed,... well strict conformance should be meet in each case, this (as
you've said does however not mean that gpg can not implement just a
subset of the standard).
Interoperability,.. of course important,... but we should perhaps (at
least slowly) move to newer stuff (e.g. the sha512 sigs) or we won't
have any advancement at all...
Ease of use,.. of course important to,... but that does not mean,.. that
one shouldn't be able to use every little bit of the standard (=>
expert/beginner modes).
You're funny ;) You just said,.. an implementation can do what it want
(as long as it's meeting the lower mark) now you said it should not.
Of course it would be an interoperability problem,.. but not in a
totally closed (in the sense of autonomous) system.
... and of course I agree with you,.. that the default (non-expert mode)
should at least strongly suggest the user to use name mail-addr UIDs.
But it should not completely forbid to make something different. It's
GnuPG and not GNOME_PG (sorry folks *g*,... and no I use GNOME and not
KDE ^^)
Of course,.. that was clear,... but I'm not very happy with such really
old stuff. Of course it should receive an specific amount of support and
interoperability,... but I think it's more important to move further.
And to be honest,... it's not so difficult to update gpg ;)
However,.. all of this does not answer my original question,.. whether
it works and makes sense (from a security and not interoperability point
of view) do revoke the old SHA1 selfsigs and create new (e.g.) SHA512,
if it works with _current_ versions of gpg, if it's possible at all, and
which revocation reason one should use.
Ah,.. I waited for such a comment... this is the
you-dont-develop-so-you-dont-have-any-rights-to-ask-or-discuss answer...
So I translate your answer to: "No there is no reason, except that no
developer had the time to implement it, yet"
btw: are you a gpg developer? When looking at the prefered * algos it definitely makes sense to allow
putting them on UIDs, because one might e.g. have different locations
(home, work) with different implementations that support different
But I think that actually it _is_ better to make a global (key wide)
setting first (on a 0x1F) and just modify UIDs that really need other
settings. This is common sense in the world of computing, like you
have /etc/vim/vimrc with global settings first,.. and only create a
~/.vimrc if you relly need to do so.
But for the preferred * algo subpackets I agree that it is not really
necessary (although I think it would be cleaner).
But I consider other subpackets e.g. key usage to be really key and nod
UID related. So why putting them on 0x13 selfsigs if we have the
possibility to use the indented signature on key. (Yes I know that the
RFC allows it on all self-sigs, but I think that could be improved).
Could you please show me the place where it says, that those algorithm
IDs must be part of the prefered algorithm subpacktes?
But they should... otherwise this it would contradict the idea of the
user preferences of algorithms.
You understand the difference between what a user prefers and what the
implementation has to support?
This is only possible internally at all,.. (except when the preference
subpacktes would be in the unhashed subpacket data set).
A friend of mine (Christoph Mitterer) is going to do so these days,...
he's currently preparing a deep review and lots of questions to
But in the meantime I fear,.. that he will run against closed doors and
highly conservative (not to say narrow-minded) attitudes :-(
Fine. If mine has listed AES256 (and yours too) first and lacks 3DES gpg
should choose AES256,... if yours doesn't list it,.. it should choose
3DES (or of course another working match).
But imagine the following:
Yours: 3DES, AES256
Mine: AES256, 3DES
Which one is chosen now? But when I only include AES256 I can at least
somewhat control it. Because A user might think 3DES is unsafe for his needs.
I cannot discuss with you about algorithm details (have only little
knowledge about this)... but I know that e.g. NIST decided to replace
DES by AES and the only thing I can do is follow such hints,... to
decide which algorithm is currently "the best".
Hmm I should ask Christoph whether he can put a computer to one of the
cryostats at CERN... :P
Rijndael is AES (well not exactly but more or less ;) )
afaik,.. serpent was considered to be more secure,... however... deep
cryptoanaltics are probably missing. That's not completely true...
*g* who decides which sense matters?
Of course,.. but the quality of an alogorihtm doesn't depend on its key
length (see RSA vs. ECC).
Ok.... but if MD5 hashes are easily forgable,... it's perhaps not so
clever to keep using those keys...
You probably should "correct" the wiki on
 which claims "Finally, AES
offers markedly higher security margins: a larger block size and
potentially longer keys."

@_date: 2008-04-15 02:33:59
@_author: Herbert Furting 
@_subject: Miscellaneous questions 
That's a word.
Ok... while this doesn't answer my question,.. thanks for the advise.
I'll stop encrypting my data and just add a flag encrypted=true|
false,... but move my storage to a bunker...
Yeah... now I'm absolute secure,.. NSA can come for me XD

@_date: 2008-04-15 13:24:20
@_author: Herbert Furting 
@_subject: Miscellaneous questions 
Don't see why,.. but... however.
Yes why not,... but only in an expert mode.
Ah you think cryptography is engineering? Always thought it would be math.
However I never said that gnupg should suggest those unusual stuff,
but it does not make sense to forbid them. A user who whishes to make
a terbit key can simply modify the source.
I had hoped that gnupg neither shares the philosophy from Windows nor
that of GNOME,... keep as much away from the user as possible, in
other words, think he must be stupid.
In all doing respect,.. I hope there are really few. Otherwise we
really should consider "thorwing away" our current standard an release
only a small subset of it as new standard.
However,.. I didn't intend this as (nearly) a flame war.
 > How many other major implementations are there? Not too much right?
So much? Wow... really, thought there would be at best 5 or so.
Ok,.. but actually I'm no longer interested why you think so.
Yes,... but despite of the the only thing I hear from you is,.. don't
need this, don't need that, etc. etc.
I know about RFC2119, too.
Anyway,.. gpg isn't probably targeted as implementation for embedded
systems only. So of course an implementation doesn't have to implement
all that features,... but despite of that, I have the opinion that
gnupg should. Yeah I know,.. I haven't submittet patches...
Apart from that I had some discussions with Christoph and we both
think, that the RFC should be much stricter, especially in what is
I know that OpenPGP says, that it's "wishy-washy" style is a feature
but there are several places where I think that could be a security
e.g. afaik the RFC does not require to implement the reason for
revocation subpacket. If it get's a key with a revocation signature on
it, it may simply behave, as if the key was superseeded (the rfc
doesn't require that an implementation has to consider all signatures
by a key invalid, if it doesn't understand its reason for revoc
subpacket), but the keyholder might actually used the key was
compromised reason.
However,.. more on such ideas when Christoph has finished his text
(which he'll probably post to WG list).
Apart from the fact that most of such organisations probably use X509
(unfortunately),... what would they do if an security update to gpg is
Anyway if we always say that someone might have problems with new
features,.. we can never add them.
And for your specific example, no one forces the insurance company or
the bank to use the newer versions/features.
But as with every software, it makes only to some degree sense to
stick with historic reason. The applys to gpg as to the linux
Of course,.. but I still can make feature requests.
So perhaps let's ask David. He's both member of the WG (and even a
named author since 4880 :-) ) and gnupg developer. Why did he agreed
to the features in 4880 (as author) if (as developer) he thinks nobody
needs them?
So I'm right, or not? It doesn't have to be explicitly in the list.
And we already agreed that the proper place to suggest my (of course
only in my opinion) cleaner meaning of the (user) prefered algorithm
subpacktes, is the WG list, so we really don't need to discuss that
the standard implies a mixing of user preference and implementation
capabilities at this place.
Ah interesting,.. I actually thought you were trying to do so...
my 0,02?

@_date: 2008-04-15 13:39:43
@_author: Herbert Furting 
@_subject: How trust works in gpg... 
2008/4/15 Peter Lewis :
You'll "have" to sign his new UIDs, too.
What you could to is do issue a so called non-exportable (gpg uses the
term local, iirc) signature.
That means this signature is (better said should be) only recognized
by the signer (you) but not by other people.
Yes,.. but not always,.. for example gpg sets your own key
automatically to an unlimited trust ;-)
gpg uses a so called trust modell (there ary actually several
different), where you can each UID/key an specific amount of trust.
You can give:
                 n         Never trust this key.
                 m         Marginally trusted.
                 f         Fully trusted.
                 u         Ultimately trusted.
and you'll also see:
                 -         No ownertrust assigned / not yet calculated.
                 e         Trust  calculation  has  failed; probably due to an
                           expired key.
                 q         Not enough information for calculation.
(I've stole that from the manpage,.. so credit should go to Werner or
some of the other developers ;) )
Depending on how much you trust a user you normally give him n (e.g.
your little brother who signs every key/uid without validating it, m
or f and rarely perhaps even u (your wife, which you fully trust
*g*.... or not).
u means that you automatically recognize the key/UIDs that keyholder
made as valid
completes-needed specify how many trust-paths you need to a key from
keys you trust fully.
marginals-needed is the same for marginally trusted keys.
suppose you are A and have signed following key/UIDs with following
trust values:
Now your gpg gets the key F, which you haven't signed yourself, but
the others have, thus you'll have the following trust-paths:
Suppose marginals-needed=3 and completes-needed=2:
The two paths
are not enough the recognize F as valid, because you'd need tree ?(m)
paths, but the two other pathes are enough.
( others,.. was that correct?)

@_date: 2008-04-15 15:10:47
@_author: Herbert Furting 
@_subject: How trust works in gpg... 
First of all,... unfortunately Chris forgot to CC the list (at least
it seems so). So I post his answer again:
Well this is partly true as everybody can loose or change an email
address. So the process of validating that a key-owner has "controll"
over an email address does not say that this will last forever (btw:
this also applies for the real name,.. imagine someone marries).
But apart from that I think it still makes sense to really validate
the email (e.g.  via challenge response).
Imagine Werner Koch (from GnuPG) who has wk at gnupg.org... and another
Werner Koch who works at uhm perhaps Mikrosaft,...he has the email
werner at mikrosaft.com.
Both are really named "Werner Koch" and people validate this e.g. via
their passports when they meet one of the two Werners in person and
sign their key/UIDs.
After some time the Werner Koch from Mikrosaft becomes evil and adds a
new UID "Werner Koch "... and he asks his previous key
signers to sign his new ID because he no longer goes by his "old"
eMail address.
If the signers say just,.. oh well the name is the same and I don't
have to check if the evil Werner Koch actually has access to the
eMail,... a lot of people might believe that he is our good
gpg-programming Werner.
To say it short: In my opinion every information that you sign/certify
should be actually validaded.
It probably makes even sense to check if a keyholder specified all of
his given names,... and perhaps one shouldn't sign UIDs like "Geroge
W. Bush" if the W. is an abbreviation, while "Harry S Truman" would be
ok,.. as the S wasn't an abbreviation (iirc).
Does this answer your post?

@_date: 2008-04-15 15:21:26
@_author: Herbert Furting 
@_subject: Miscellaneous questions 
I thought gpg already implements the MUSTs very well (ok sometimes
there are security problems but this will probably never go away with
any software).
He's still writing ;-)
Unfortunately I see a general trend to use the simpler but weaker
hierarchical model of X509.... :-(
Like the German national authorothy for digital signatures.... they
only offer X509.
btw: Some time ago I've asked them where I could met one of their
officials to securely get the root certificate...they told me that
this is not possible, and that the root certificate is only available
via an ldap server... LOL
(You must know,.. in Germany there are no man in the middle attacks,
so this is actually secure *G*)
Why? Just because new (perhaps incompatible) features are added in
newer versions,... nobody has to use that newer versions, right?
Best wishes,

@_date: 2008-04-15 15:44:30
@_author: Herbert Furting 
@_subject: Miscellaneous questions 
1) This is the cost of advance...
2) btw: I've never said that one mustn't provide backward compatibility.
Of course there are things that would break that (e.g. use something
else than SHA1 for fingerprints) but my ideas about how to interpret
the standard, and where to put some subpacktes wouldn't break the

@_date: 2008-04-15 15:38:19
@_author: Herbert Furting 
@_subject: How trust works in gpg... 
Well but if Peter Lewis  adds a new UID "Stan
Tobias " you obviously can't sign it, because the
keyholder is Peter Lewis and not Stan Tobias.

@_date: 2008-04-15 21:36:04
@_author: Herbert Furting 
@_subject: How trust works in gpg... 
Well I think it's generally better to always use only full names,...
that helps to prevent collisions like if my name would be "David
Something Shaw". Of course I say that it only helps,.. it doesn't fully
solve this.
Anyway it is a matter of policy,... the stricter the policy is, the more
likely it is, that it will require to include all official names.
See for example the certificates of the German signature law... IIRC it
is not allowed to skip names or switch names like "Hans-J?rgen" into
"Hans J?rgen".

@_date: 2008-04-15 23:03:43
@_author: Herbert Furting 
@_subject: How trust works in gpg... 
Yeah,.. I just try to browse to the sources to find out how to generate
my custom self-sigs,... however it seems that I can't find my way... :-(

@_date: 2008-04-15 23:42:30
@_author: Herbert Furting 
@_subject: How trust works in gpg... 
Yes but ok let me explain what I want or would like to have ;-)
My current key has the following layout:
***[Pub key packet]***
?***[0x13 selfsig (SHA1), with cipher-, hash-, compress- algo prefs, key
flags, features, key expiration time and of course stuff like signature
creation time]?***
What I would like to have is probably (I'm actually not yet sure ;) ):
?***[pub key packet]?***
?***[0x1F selfsig]?***
I assume that would be inserted here?
I think it should probably contain, key expiration time, key flags
because as far as I understand this information is clearly bond to the
key (would it make sense to have different key expiration times, or key
flags for different UIDs/roles?)
And perhaps even the algo prefs the and the features (if they are the
same for all UIDs).
Now here I'm note yet sure and I still discuss with Christoph.
If the algorigthm preferences and features should be considered as
role-preferences,.. the proper place would always be the 0x13 (because
these are for the roles, which are effectively the UIDs).
But if not, it could make sense to put them on a 0x1F, when they're the
same for each UID(/role).
I still could add them to single UIDs if some of them have different
settings because of their environment.
Hmm could one image to have different key-server-uri's per UID?
Does this make sense?
(And just to prevent any unnecessary discussion,.. I know that this is
not the way gpg does handle this stuff (now), and that it is not
necessary implied by the standard. I just think that this could make
So especially for Robert, please wait until Christoph finishes his paper
and post it to the WG.)
then the UDIs+0x13's
?***[the 0x13 selfsig (SHA1)) from above]?***
?***[that sig nature revoked]?***
(you remember my last mail where I asked you if that makes sense, and
you just told me that I still use SHA1 in some places),.. but I still
haven't thought about the best fitting reason for revocation
[new 0x13 selfsig(SHA512) perhaps with some of the subpackets from above
(the algo prefs),.. or not, depending on whether the above makes sense).
?***[ the same for other UIDs ]?***
So just changing the prefs via setprefs doesn't do this :-(
I've already found the make_keysig_packet which is called from main
keyedit.c to create the selfsig,... but the I got stuck,..
I think what I wish to do needs too much in depth knowledge of gnupgs
Is there perhaps a tool that simply allows to edit every aspect of
OpenPGP keys, and that then recreates the selfsigs as desired? Including
lenght calculation of the packets, the hash contexts and the signature
Perhaps something like a counterpart to pgpdump (I love that tool XD).
Ah and perhaps on last question (for now ;) ) if I have your attention
right now.
Does it make sense to put policy URI's on selfsigs? Could you imagine a
possible meaning of such a thing?
Thanks a lot,
btw: If anybody here thinks I'm a barrater,... blame Christoph,.. he
brought me to read the RFC ;)
