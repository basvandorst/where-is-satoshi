
@_date: 2016-08-07 14:35:41
@_author: Carola Grunwald 
@_subject: Standard gnupg folder created despite --homedir parameter 
Migrating a Windows encryption tool from 1.4.20 I need help with GnuPG
Though using the --homedir parameter, with certain gpg commands a gnupg
folder is created in %APPDATA% (C:\Users\%USERNAME%\AppData\Roaming). Is
there a reason for having that folder or is it just a bug?  Any chance
to avoid that?
I'm addressing this rather unimportant 'feature' 'cause I'm maintaining
a portable application and don't want the host system to be altered in
any way.

@_date: 2016-08-09 00:37:09
@_author: Carola Grunwald 
@_subject: Standard gnupg folder created despite --homedir parameter 
I'm sure the GPG devel team has an understanding of the implications for
people in an authoritarian society being compromised by such needless
data residues of their purportedly hidden correspondence.
Kind regards,

@_date: 2016-08-09 23:23:32
@_author: Carola Grunwald 
@_subject: Standard gnupg folder created despite --homedir parameter 
Hello Werner,
many thanks for your involvement in this discussion.  GPG 2.1 took big
steps towards becoming a truly portable application.
May I ask how that translates into the Windows world?  Is it a way to
get rid of the ...\AppData\Roaming\gnupg folder?
I have all executables in my gpg main folder and call gpg.exe
exclusively from that directory with a '--homedir "...\gpg"' parameter,
while that gnupg folder still gets created.

@_date: 2016-08-10 22:22:20
@_author: Carola Grunwald 
@_subject: Standard gnupg folder created despite --homedir parameter 
Many many thanks Werner & Peter,
You made my day!
It works great the way you told me.  Please excuse my slow-wittedness
concerning the unixoid folder names.  Marvellous support here.
Keep on with your important work!

@_date: 2016-08-27 22:07:57
@_author: Carola Grunwald 
@_subject: Decryption with suppressed key ID (--throw-keyids) different in 2.1 
the next problem with my 1.4 -> 2.1 (2.1.15) migration (Windows 7).
Is there a reason why decryption of data with the recipient's key ID
suppressed now requires the --try-all-secrets option?  It took me some
time to realize that difference.
Kind regards,

@_date: 2016-08-27 21:46:03
@_author: Carola Grunwald 
@_subject: Decryption with suppressed key ID (--throw-keyids) different in 2.1 
the next problem with my 1.4 -> 2.1 (2.1.15) migration (Windows 7).
Is there a reason why decryption of data with the recipient's key ID
suppressed now requires the --try-all-secrets option?  It took me some
time to realize that difference.
Kind regards,

@_date: 2016-12-04 20:59:23
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
You can do it either way. For several years now I myself run the proxy
server on my laptop computer, holding a few dozen nyms for different
It's not about planning, the proxy system is in use for years.
I started the project in 2006, for a short time with PGP 6.x DLLs, then
moved to GnuPG 1.4, which, apart from the missing --faked-system-time
option still works great, very reliable, extremely stable. Three months
ago I thought it was time to adapt it to GnuPG 2.1, and the problems
began. Just at the moment I have seven (!) gpg-agent.exe entries sharing
the same HomeDir listed in the Windows Task-Manager, six of them frozen,
one hopefully still alive. The system is up now for no more than 48
hours. You can't run a server this way. Users ask what's going on. I'm
in trouble, seriously considering to return to 1.4.
I don't use the GPGME interface, rather call gpg.exe directly. I don't
think it makes any difference concerning performance. On program
shutdown I terminate gpg-agent.exe based on its ProcessID.
So first of all I have to give every keyring its separate homedir to
avoid the side effect of unintentional secret key deletion across
keyrings, and to address the passphrase caching flaw I even have to keep
each single secret key isolated in its own directory.
Full ACK. User accounts usually are LAN accounts, not that much under
attack as the encrypted message, which needs a strong key and
Works fine with 1.4.
I'm not sure whether gpg.exe can handle the concatenation of dozens of
'--try-secret-key A7DD28F363B0924E3B735F22A49104AD3835E227' parameters
and stop using keys not on that list even with their passphrases in the
Right. Revocation certificates are irrelevant.
If it were that simple. Every user account can hold an unrestricted
number of nym and WME accounts. When the mail client starts a POP3
request mail is retrieved from different sources. That may be a normal
POP3 account as well as anonymous newsgroups repositories like
alt.anonymous.messages from where incoming messages are downloaded, if
necessary decoded, then sent to the client in one go.
Don't get me wrong, but wasn't it just indolence to do without a
separate sec key folder for each keyring?
Exactly. For a user it looks like he has a key pair listed on one
keyring, and when he adds and removes that key pair from a completely
different keyring the secret key is removed from both.
I think a different agent for each of my current keyrings may be an
option I could deal with. But ending up with dozens if not hundreds of
agents around, working or frozen? I hope you understand that I don't
like to bear responsibility for such a freaky scenario. It's a small
tool running as a background task residing in the system tray.
Your correspondent doesn't even have to know about your nym's key, which
first and foremost is used to secure your proxy - nym server
communication. He can use your nym's address as a normal mailbox without
any encryption at all. But if you think client-to-client encryption is
necessary then create and send him an additional key. IMHO no issue at
all, the user rules.
It's a transparent proxy server not caching any message. When the client
sends a message, a '250 Ok' isn't returned before the proxy
forwarded it to the Internet. How could the client otherwise get
knowledge of processing problems. So, apart from wasting time by adding
hours of latency at the sender just to get a different signature
timestamp, your client would time out and drop the connection. Or think
of someone who got the chance to send nym mail immediately through an
open WLAN access point away from home. For him waiting is not an option.
With random time of yesterday (Day-1) for signatures or the day before
(Day-2) for key creation, all UTC, it's secure.
Sure you have to do all your timestamp calculations in UTC. Otherwise
you'd even leak your timezone.
Of course that's a feature, an important feature protecting privacy,
worth to be backported to v1.4. There always are situations where you
want to prove the Who but not the When, which can be faked anyway.
That's correct.
Many thanks for your profound considerations.
Kind regards

@_date: 2016-12-11 01:48:30
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
If I only had a --faked-system-time option ...  :-(
That was the only reason why I migrated to 'modern' v2.1 - and slipped
into a disaster.
But what do you mean by 'deprecated for server use'? Where in
 is GnuPG 2.1
restricted to a single-user scenario? I only found
which is only about a more complex deployment, not about security risks.
In my view crypto software that leaks information, for example caches
passphrases for unauthorized access, doesn't qualify for any kind of
Btw, a spelling error on page 102 line 15:
      ^^
I addressed my problems at the devel list.
Initial problems with new software are okay as long as they can be fixed
when they arise.
Nevertheless the user has to get knowledge of such an attack, which is
why a header entry reporting the decoding status is added to the message
forwarded to the client:
I now added --try-secret-key to all asymmetric decoding calls, which
made processing a bit faster and possibly counters the passphrase cache
weakness with asymmetric decryption.
But there still remains the possibility of a symmetric decryption even
with an invalid passphrase when the correct one is in the cache. And
that will remain undetected, as there's no key-ID indicating the
deviation from the given passphrase.
When finally, what I still hope, the instabilities of the Windows build
are cured, I think about running separate agents dedicated to the
keyrings that hold secret keys, which I then would combine with pure
public keyrings used for encryption and signature checks. That still
adds a lot of complexity, but prevents erroneous secret key removal.
It's not the user, it's the application that has to care about the
structure and integrity of key storage. It's hard to tell users about
the purpose of different key families when all of them are lumped
together in one basket.
That's only critical with a common secret key depository.
Who would use a single secret keyring with different public keyrings?
For security reasons currently all gpg calls are chained to avoid any
No, I don't, as a user can hold multiple nym accounts and WME related
addresses, which e.g. with a POP3 download are processed in common.
Sure. It's upon the user how to deploy the software, either locally on
his private computer or in an enterprise environment.
With your interpretation of 'holder' gmail is the holder of all the mail
accounts hosted there. In my view the one who is allowed to use an
account is its holder. My software only adds the mechanisms to interact
with nym servers in an easy way, which has to include to be in control
of the nym acccount's key to prove one's identity when sending server
commands. But this key does in no way have to be used for end-to-end
encryption between dialog partners. The nym holder doesn't even have to
know about the key's ID.
In fact it's the proxy server resp. its administrator. The mail message
you send to the nym server when creating an account includes your nym's
public key, which then is used to check signatures authorizing further
mail you send to the server.
With standard mail it's always up to you to care about end-to-end
encryption. No system can know about the capabilities of your mail's
recipients. You may agree on WME or normal OpenPGP encryption or no
encryption at all. Nyms only provide anonymous/pseudonymous delivery.
Of course users have to know that only the route between the proxy and
the nym server is secured.
Nope. It's the sender who won't understand why to waste time while
getting rid of his message. Delay on the way to the recipient is a
bothersome though extremely important characteristic of anonymous
delivery. But delay at the sender is more of a hindrance than a help.
I think we are agreed that delay in a conversation, though indispensable
for anonymity, can't be infinite. You now have to make a decision,
either to burn much of the time you have to invest at your computer, or
to fake signature timestamps and send the message immediately through a
significantly longer remailer chain.
And remember, without a faked timestamp, no matter how long you wait,
your signature still unveils that you had access to a computer at the
time you signed the message. Allow an opponent who suspects you as the
nym holder to gather a few of your nym's timestamps and you're toast.
I hope I gave convincing reasons now.
But I do, as there's no other way to tell the proxy account holder
whether local message processing succeeded.
You're at the client site, where it's only about forwarding messages as
fast and convenient as possible without revealing any important
information. Chaum mixes as realized in the Mixmaster remailer network
are much better in using time efficiently.
After all that discussion you still think suppressing the true timestamp
of a message is 'abuse', possibly even fraud?
As already discussed in the 'Proof for a creation date' thread you have
to adopt other measures to provide solid evidence for the validity of a
signature timestamp, which on its own is of now value at all. No sacred
cow worth being protected at all hazards.
I have to thank all of you to render projects like mine possible.
Kind regards

@_date: 2016-12-11 19:58:57
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
I see. Thanks for that clarification.
[brilliant car analogy removed]
With 'problems' i referred to the GenKey bug/feature I reported a few
hours ago and the IPC instabilities I experienced. Sure, the
single-sec-keys-depository : multiple-pub-keyrings configuration is a
design decision, though one I don't quite understand.
I hope it at least plugs the security hole of a key in the sec keys
folder different from the one defined with --try-secret-key being used
together with a passphrase from the cache to decrypt data without any
You mean --try-secret-key doesn't overrule the key parameter that comes
along with the encoded material?
--try-all-secrets doesn't look at the possibly 'bogus key ID' (page 61)
and the manual doesn't say anything different concerning
That's only because v2.1 forces me to do so, which is what I complain
about, a common secret key depository.
The only alternative to avoid ambiguities with v2.1 would be to confine
oneself to a single public keyring for everything, in my case
- WME keys (pub/sec)
- nym account keys (pub/sec)
- nym server keys (pub)
- remailer keys (pub)
For a more complex application such a restriction means chaos.
 provides some insight.
With 1.4 I have a one-to-one sec:pub keyring relationship, where such
ambiguities don't matter, and where it's foreseeable what happens when I
delete a key pair from such a single keyring pair.
User login/logoff represents in no way crypto task granularity, as a
user may hold several nym accounts and WME related addresses and so on.
If I'd take your proposal seriously the agent would have to be restarted
with nearly every en-/decoding call to clear the passphrase cache. Is
that what you have in mind?
So the maintainer of the proxy is the owner, right?
Which is the account holder, who has the proxy login credentials.
When he logs into the proxy to send a nym message (From:
myaccount at mynymserver.org) the proxy checks whether the account holder
also holds the respective nym account and, if that's the case,
transforms and forwards the message to the nym server. The same holds
true for signing the message of a WME supported From address.
I see that differently. The nym service consists of two parts, the proxy
represents the local non-anonymous one, the nym server is the remote
part in anonymity land, both separated but also joined by the
anonymizing message transfer cascade. Those parts can't do without each
other, only together they function correctly, which is why they have to
be seen as an indivisible unit.
The same goes with a proxy account.
Me as the proxy administrator? Well, the situation is similar to a GMail
administrator, who can also use any GMail account to send messages. He's
the admin, he's God.
When the observer sits in your LAN you're doomed anyway. It's only about
an external adversary controlling the Internet.
I'm not sure what you mean by delay in a conversation vs. between
What you need is delay between forwarding the message to entry remailers
(multiple copies to increase reliability) and the delivery by the exit
remailer either to the nym server or directly to the final recipient.
Delay at the sender's LAN adds nothing to anonymity.
Bad enough.
With each signature creation step my application running with admin
rights temporarily changes system time on a random basis.
No, no, it's okay.
Let me add that I truly mean no harm though my remarks may sometimes
sound eager or even offensive. For me open discussions are important to
get rid of mindcuffs.
The possibly short proxy user's passphrase is different from the key's
passphrase, which is randomly created.
Even the client-server interaction in a corporate LAN environment has to
be assumed secure.
So key 'Creation-Date' (page 84)
a v1.4 and v2 'feature', is abusive as well? I see no 'testing only'
phrase in that explanation.
It depends on what you're aiming at. Sure, PGP/GnuPG was initially
developed to provide privacy by protecting contents. And it does a great
job in this respect. But times have changed. We can no longer ignore
that surveillance also concentrates on metadata resulting in a worldwide
sociogram of the population, making social networks transparent to
intelligence agencies, multinationals and whomever else. The knowledge
of relationships between individuals, groups and organizations opens the
way to social engineering and political oppression. That's why anonymity
including the obfuscation of temporal connections isn't a negligible
gimmick but a crucial measure, which IMHO GnuPG should also be obligated
to. So why not reconsider the 'only useful for testing' statement and
see timestamp invalidation as an important anti-surveillance strategy?
Support is in no way less important than development.
Being the instigator I take full responsibility for that. ;-)
Kind regards

@_date: 2016-12-12 03:06:55
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
You're right, unbelievable. I specify --try-secret-key with a
[GNUPG:] ENC_TO 0000000000000000 18 0
message and gpg still tries out two dozen WME keys with a passphrase not
valid for them. What a waste of time!
Today I added symmetric dummy encodings to my application, performed in
5 minute intervals to keep gpg - agent IPC alive. So far no more
259/$103 GPG_ERR_ASS_CONNECT_FAILED (IPC connect call failed) errors.
Let's see. I can't believe that I'm the only one who has to deal with
such problems.
No confusion. The proxy server just assembles mail from different
sources, which are a normal external POP3 account and a local repository
of newsgroups, where nym replies are stored for being downloaded
anonymously by the nym holder, e.g. alt.anonymous.messages.
The nym server doesn't know who you are nor, with additional end-to-end
encryption, will he know about the data you exchange. He can only cease
his service for whatever reason, which doesn't mean any security risk.
And there is the user, who is in complete control of the sending
machinery. It's only about whom you see as the user. If it's an
individual who acts on his own responsibility he has to deploy the proxy
within his sphere of influence, e.g. on his computer side by side with
the mail client. When it's a corporation on behalf of which the proxy is
used it won't matter whether the corresponding employee and the proxy
admin are different persons, as both are bound to the company's rules to
act in concert.
See my comments above about business rules. For a corporation it's
important to centralize communication and to keep the ordinary user of
its infrastructure from having access to crucial information like
communication keys.
I see no relevant difference between a client - proxy server connection
within a LAN and through the Tor network to the proxy's .onion address.
With some Tor cover traffic on the client and proxy side an adversary
won't have a chance to detect the mail message transfer via the Tor
It's better than nothing. Nevertheless it's a compromise I see no reason
for when otherwise there's a chance to manipulate the timestamp directly
and avoid any latency between the client and the entry remailer(s).
Btw, apart from regular remailer messages the proxy sends randomly dummy
messages to invalid addresses to disguise true communication.
No. The proxy user logs i with jdoe:PaSsWoRd, the nym / WME key's true
passphrase, stored at the proxy, looks like
??? It's about the protection of data in transit, not about securing the
proxy server. With compromized keys a single passphrase for different
nyms is a solid proof for a similar origin.
TLS isn't very expensive, it's active here even with localhost
connections. And connections to Tor hidden services at home can be seen
as anonymous VPN connections, not much worse than true LAN connections.
Don't get me wrong, but what I see here is the difference between
enlightened thinking and servile obedience overinterpreting the wording.
Tools have to serve purposes, and if they are imperfect in doing so they
have to be adapted, at least as long as the author(s) have no objections
to the given purpose, which here means anonymous communication. So I'll
immediately shut up in case Werner says Internet anonymity is a bad
Kind regards

@_date: 2016-12-13 00:43:13
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
Removing all cached passphrases sounds great. But does that mean I have
to invoke the agent directly using the Assuan protocol? And what would
be the way to get a list of all valid cache_ids?
That's what I actually do:
There's the id of a secret key with its passphrase, but if decoding
doesn't succeed with that key-passphrase combination or if the key
doesn't exist there are decryption attempts with all other secret keys
in the private-keys-v1.d folder, which only waste time:
AFAICS it always uses the same given passphrase with all the keys, which
is good:
What I need here is the restriction to just the given key.
I appreciate every hint I can get on my way back to a fully operational
stable system. :-)
Many thanks and
kind regards

@_date: 2016-12-18 19:25:37
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
Obviously not (see 'INQUIRE PASSPHRASE' below).
Isn't there a gpg SETKEY option for decryption? AFAICS --default-key is
only for signing, --recipient for encryption. Is --try-secret-key the
SETKEY equivalent for decryption? Can a developer shed light on this?
Kind regards

@_date: 2016-05-04 22:55:34
@_author: Carola Grunwald 
@_subject: 'No pinentry' error (--pinentry-mode loopback with 
I need help with GnuPG 2.1.12 migrating an encryption tool from 1.4.20.
I'm trying to run the --delete-secret-and-public-key command with the
passphrase entered through stdin, which doesn't get activated ('delete
key failed: No pinentry').  With --export-secret-keys I was successful
this way (also added below).  Or can I use --passphrase somehow?

@_date: 2016-05-07 10:59:14
@_author: Carola Grunwald 
@_subject: 'No pinentry' error (--pinentry-mode loopback with 
Nobody here with an idea how to solve my problem, to tell me whether a
GnuPG bug prevents success or if it's worth to keep on trying?  I once
thought '--pinentry-mode loopback' is kinda compatibility mode to
simplify transition from 1.4 and allow embedded usage.  I'm stuck.

@_date: 2016-05-07 15:32:13
@_author: Carola Grunwald 
@_subject: 'No pinentry' error (--pinentry-mode loopback with 
Hello Dashamir,
Thanks for your reply.
You're right, there's no passphrase request with
But that way a 'Pinentry' window opens, which I have to avoid:
followed by
Kind regards

@_date: 2016-05-10 07:47:34
@_author: Carola Grunwald 
@_subject: 'No pinentry' error (--pinentry-mode loopback with 
Hello Dashamir,
Meanwhile I'm sure it's a bug similar to
GnuPG 2.1 isn't ready for embedded usage yet.
It's still experimental, so we have to wait.
That's not future-proof.
When GPG caches file system data it may fail.
Kind regards

@_date: 2016-05-10 23:20:54
@_author: Carola Grunwald 
@_subject: 'No pinentry' error (--pinentry-mode loopback with 
When an application creates a key it also has to get it deleted.
With the 1.4 branch I interacted with the GnuPG process completely
unattended through standard-I/O pipes, which now are replaced by the
pinentry mechanism, where redirections fail.
Many thanks.  But I'm on Windows, dependent on binaries.  Without
nightly builds I have to wait for the next release, or try to
crosscompile it in my Debian VM, which I doubt to manage.
Kind regards

@_date: 2016-11-20 20:37:40
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
The silence makes me believe that what I described is intended behavior,
not a 2.1 design flaw. I'd like to know whether that's correct. Any
response would still be appreciated.
Kind regards,

@_date: 2016-11-20 21:11:50
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
is adding
to gpg-agent.conf the official way to deactivate passphrase caching
completely and make GnuPG only use the term transferred with the
--passphrase option?

@_date: 2016-11-20 21:18:14
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
is adding
to gpg-agent.conf the official way to deactivate passphrase caching
completely and make GnuPG only use the term transferred with the
--passphrase option?

@_date: 2016-11-21 14:20:04
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
Hello Werner,
thanks for your fast reply.
It's about a multi-user mail/news server, where multithreaded message
processing for all user accounts is done by a single gpg agent. As for
each single decryption task only a defined passphrase is allowed to be
used it's essential to have caching, which implicates the risk of
unauthorized passphrase usage, strictly deactivated.
Kind regards

@_date: 2016-11-22 01:54:22
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
Hello Werner!
IMHO for several reasons there has to be some method to structure larger
key depositories.
Just to name a few ...
- Performance drops with the number of available keys, especially when
data lacking a key-ID (--throw-keyids) have to be decrypted.
- In a multi-user environment the key owning recipient has to be granted
access to the private key with some sender being restricted to only use
the public key no matter whether there's any chance s/he guesses the
correct passphrase.
- There's no reason to have keys used for different tasks together on a
single keyring, as key management gets chaotic with such a hodgepodge.
And confusion would increase even more trying to mimic v1.4 by running
multiple GPG Agents dedicated to tasks which have to be separated.
Even if there's no chance to return to completely separated keyrings,
which without doubt have stood the test of time in GnuPG 1.4, I think
there at least has to be a method to group public as well as private
keys in some way to allow the selection of only one or a few of these
subsets to take part in processing. Currently for example apart from the
accidental deletion of private keys I earlier described I don't see any
concept of dealing with orphaned files in the private-keys and
openpgp-revocs directory. An Agent managing all lists of key subsets
would gain the information needed to solve all these problems, for
example delete the private key file when all list entries associated
with that privat key are removed.
Though not very familiar with GnuPG internals I hope I made my concerns
somewhat clearer.
Good night, and good luck

@_date: 2016-11-22 16:20:26
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
They don't have any system account at all. These are users of a
messaging system, only allowed to access its POP3, SMTP and NNTP
They don't have direct access to any key. Nevertheless by using someone
else's cached passphrase with 2.1 and its all-embracing keyring they may
succeed in decoding data not meant for them.
Kind regards

@_date: 2016-11-22 18:17:10
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
You seriously recommend to run a dedicated gpg-agent instance for each
of dozens if not hundreds of mail service users? You have to consider
that these gpg-agent services are meant to persistent beyond the initial
data processing call. Compared with my current single-agent approach
with task-queuing not really resource-efficient, is it?
Kind regards

@_date: 2016-11-23 02:28:36
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
Sure, I like v1.4's small footprint and its reliability. But as the
--faked-system-time option, important in my application for privacy
reasons, wasn't backported to v1.4, I had to migrate to v2.1. I'm still
not very confident in EC cryptography's strength nor am I interested in
dealing with just another background service, which freezes every now
and then and actively has to be stopped with my application to keep it
There's server access control through a username/password combination,
access to the corresponding PGP key is given by a usually unique base64
encoded 256-bit random number dedicated to the account.
But if for decryption a cloud of unpredictable valid passphrases is used
Well, I didn't know that GnuPG follows a single-user strategy. Now I do.
I'm truly sorry, no harm intended.
Kind regards

@_date: 2016-11-23 03:48:19
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
Hi Andrew, hi Robert,
many thanks for your replies.
But why does a person have to be in control of a signature key? Why not
a server in the name of a company resp. its employees.
Talking about mail, when transmitting messages we currently have two
encryption principles in common use. There's server-to-server security
provided usually by SSL/TLS, where nevertheless the communication
partners can't influence the all-knowing servers building the route. And
there's true end-to-end cryptography done by PGP/SMIME at the client
applications, which also leaks valid (envelope) information thinking of
message size and structure and the enormously talkative header section.
Now let there be a corporate server, which 'cleans' the header of
outgoing mail, adds some nonsense data of random size and encrypts the
result into a single PGP message block, which it finally forwards after
adding the recipients' mail addresses as the only header line. The
message block's signature only documents the identity of the sender who
logged into the server, and, btw, with --faked-system-time doesn't even
leak whether it was processed at business hours or at midnight. At the
recipient's corporate server that mail is decrypted using the
recipient's key, the original mail structure restored, a line
representing the signature status added to the header and the result
delivered to the POP3 client.
This concept of an enhanced transport security layer offers external
adversaries least possible information while it doesn't preclude the
sender from adding another inner encryption/signature layer created with
a key she herself controls.
Hope that helps to understand what I'm aiming at.
Kind regards

@_date: 2016-11-23 08:46:57
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
Of course.
With GnuPG 1.4 I had no agent. And, in case it is, I've no idea why with
2.x such a passphrase cache with all its risks has to be mandatory.
Kind regards

@_date: 2016-11-23 17:26:28
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
Pardon me when I disgress too much from the original problem, but my
system carries a TLS certificate database of all external servers it
ever contacted, and, based on the certificate's fingerprint, you can
choose from that list which host connections you allow.
Kind regards

@_date: 2016-11-23 17:54:27
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
I implemented Whole Message Encryption in 2006, the year when Facebook
went public beyond students. And how old is Memory Hole?
Which relevant information does the single Received: header, describing
the recipient MTA's interaction with the exit remailer, leak?
Not real-time Tor but remailers providing latency. You got it.
TLS is a real-time server-to-server connection protocol, which PGP
isn't. You can send your PGP message to and fro around the world through
as many servers as you like hiding all your traces thus removing sender
metadata. With TLS you can't.
I'm talking about Whole Message Encryption including the complete header
DKIM doesn't hide the sender's identity from external adversaries who
try to analyse message flow.
Sounds great.
- In a TLS session the communication partners' IP addresses are public,
moreover the sender domain is published by the receiving MTA by
retrieving its public key from the DNS in order to verify the DKIM
signature. OTOH with my kind of Whole Message Encryption combined with
an asynchronous message transfer providing latency e.g. through
remailers adversaries have no chance at all to link sender with
- A DKIM signature isn't as robust as an ASCII PGP block. A tiny
in-transit MIME recoding and it's invalid.
- A DKIM signature doesn't take care of the complete message including
all header fields, which WME does.
- The TLS+DKIM combination taken by itself can't fake the size of a
message, WME with random dummy load can.
And so on.
Kind regards

@_date: 2016-11-23 23:09:16
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
When you deal with pseudonymity you have to avoid similarities of your
aliases. So the WME keys they use to secure their messages have to be
Going into details there are several scenarios where WME can help
protect privacy. One of them is easy to explain.
Think of two partners who strive for absolutely hidden communication
though they know about their identity. Alice's ordinary mail client
sends a standard mail message to her proxy server, where it gets PGP
encoded, which makes up the body of the WME message, with only a To:
header containing the destination's pure address and possibly a hashcash
token and further dummy headers to surpass spam filters added. This
message is now converted into a remailer message and sent through Tor to
the entry remailer. When Bob's counterpart receives the message it
decrypts it, checks the signature and adds a header about its status on
top of the net message, and forwards it to his mail client.
With Tor involved for an adversary it's very hard if not impossible to
detect that Alice sent mail. Concerning Bob he can only see that a
remailer message with a single PGP block including no key-ID arrives
from nowhere.
In case Bob also has to hide that he receives any messages he has to use
a pseudonymous remailer through Tor.
If now both only know their addresses at pseudonymous remailers
individual anonymity is secured in all directions. And that's where you
really need individual WME keys, each reflecting the holder's address at
the respective nym server.
First of all I see no reason to do without TLS. Then with remailing only
the address of the next hop is visible, the final destination is
protected by multilayer encryption up to the exit remailer. Another
advantage of WME compared with MIME acrobatics is that the recipient
even without running a proxy server can easily decrypt the WME layer to
get a complete RFC compliant message ready for manual import into his
client software.
I anyway have to encrypt the message. So for me it seems natural to
simply add a signature here instead of thinking of something completely
With PGP the encryption layer protects the signature, which is why only
the final recipient with his key/passphrase combination gets hold of it.
Kind regards

@_date: 2016-11-23 23:25:52
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
No, that isn't correct. Dependent on the length of the remailer chain
and the individual latency of the involved hops there may be hours, even
days between the signing process at the sender and the final message
transfer from the exit remailer to the recipient's MTA. And you have to
be aware that at each hop the message envelope (including some Received:
header line) is completely removed and replaced by nothing but the next
hop's address.
Different from TLS with my PGP layer solution it doesn't matter how many
MTAs are involved in the delivery process and how long that takes.
Kind regards

@_date: 2016-11-24 00:18:30
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
What are your objections to an option to deactivate that caching
feature, which, as I explained, under certain circumstances may turn
into a severe security risk? Are there any technical reasons why GnuPG
absolutely can't do without a cache? Or is it merely user convenience
you trade security for?
Think of a single-user configuration, where that guy enters a (wrong)
passphrase, GPG uses a different one from a cache of unknown contents
and decrypts his data, at worst without telling him about that
substitution required to complete the task. The user tries to memorize
his allegedly valid passphrase. And next time, same key, same
passphrase, but the cache no longer in favour of him - hard luck!
Is that correct? Or is there any chance for the user to get knowledge of
that passphrase substitution?
And which Open Source OpenPGP engine have you in mind that suits my
Please don't underestimate the complexity of your proposal. It isn't
only about starting and shutting down a service with every single mail
server connection, which by itself would be bad enough. You also have to
deal with the creation and manipulation of lots of keyrings, one for
every private key, with multiple public key copies of potential
recipients added and removed. And each instance has to have its own home
directory. What would that mean for my test environment, where I
currently manage way more than a hundred identities. Horrible!
Kind regards

@_date: 2016-11-24 13:16:36
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
WME combined with nym server usage for example requires an individual
WME key for each account, as otherwise at least the recipient, who may
communicate with different aliases is able to link them based on their
common signature key-ID.
Concerning faked timestamps you have to imagine that an adversary may
observe your Tor connections. When he sees high activity shortly after
the signature's timestamp you may have transmitted the respective
message. And with each positive correlation on follow up messages the
connection between you and the anonymous sender becomes more and more
certain. That's just one example.
I know, but unfortunately this thread became more and more a discussion
about my project, which I didn't intend, and not the problem why I
started it.
Kind regards

@_date: 2016-11-24 13:34:12
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
No, I wasn't aware of Confidant Mail.
I have a different approach to transmit bulk data anonymously.
Sending a larger mail message through the remailer network is a lengthy
process, as it is transferred in uniform 4 kB mail packets, from which
the exit remailer reconstructs the original message. But as my system
incorporates Tor, it offers another solution to that problem.
Apart from hidden services, which allow to contact the integrated POP3,
SMTP and NNTP proxy from all over the world without having to deal with
DDNS services you can also set up HTTP hidden services to allow others
to download files anonymously. Send the recipient anonymously the .onion
address of the file you offer and after installing a Tor Browser he's
able to download it through the Tor network. You yourself remain
anonymous, which is why that's a tool whistleblowers can use to forward
larger documents.
Compared with standard Tor communication a custom made protocol may
stand out and be easily detectable by an adversary.
So I'm not sure how CM can help to improve my system. But I'm always
open to suggestions.
Kind regards

@_date: 2016-11-24 23:03:01
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
Let's just say I hold two nym accounts at different nym servers
and send WME encapsulated mail through both of them to a single
recipient making him believe he talks to two different persons.
In this case the From: address of the message sent by my mail client
tells the proxy that it's nym mail. In addition to that the From: and
the To: address can be found in the WME participants list with 'Sign'
activated for the From: entry.
That's why the proxy clears the message header section, WME encrypts the
whole message for the recipient signing it with its individual WME key
(which can be the nym server account key), encrypts it for the nym
server signed with the nym server account's key and sends the result
through the remailer network to the nym server, which removes the nym
server encoding layer checking the account signature and sends the
resulting WME message to the recipient.
If now both of your nym accounts alice at nymserva.net and bob at nymservb.org
sign with the same WME key the recipient, to whom that similarity
becomes apparent, may wonder whether the obviously single author of
these messages suffers from dissociative identity disorder.
Simple answer: You never know who your opponents are. How can you be
sure the recipient of your mail isn't one of them? Or his network
infiltrated and his computer compromised?
A pinch of paranoia helps develop solid anonymity software.
Act as if there's no one out there you can trust.
Kind regards

@_date: 2016-11-26 01:17:31
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
WME encoding, remailing and nym handling are done completely at the
proxy. You can use any, even the most primitive PGP-unaware MUA to send
and receive standard mail and Usenet messages, crypto and anonymization
capabilities are provided by the proxy.
By signing all WME messages of all your nym accounts with an identical
key, your imaginary proxy server key, you disclose that all of them
originate from the same server. That means on one hand you try to avoid
all potential similarities between your nyms, from writing style to
(day)time patterns of message creation, and on the other all your
messages' signatures scream out loud 'We belong together!'.
You see the discrepancy? Or what's your point here?
No problem to add another inner PGP encryption layer created locally by
the MTA with a key controlled by the user. But MUAs don't have my
proxy's header filtering, header and MIME boundary delimiter
normalizing, nym formating and crypto capabilities that make it so easy
to use remailers and nym servers in a secure way.
Which MUA can restore a WME encrypted message?
In my example the message follows the path
MUA > proxy (SMTP) >
Tor network (3 nodes) > remailer network (1..20 hops) > nym server >
POP3 server > proxy (POP3) > MUA
And as I earlier tried to explain a standard PGP message leaks lots of
information which a WME message doesn't.
Kind regards

@_date: 2016-11-27 17:15:55
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
Werner, thanks for your reply.
But no, unfortunately it's a Windows server application with GnuPG, Tor,
Mixmaster and Hamster embedded. And in a server environment it's
problematic to switch system time back and forth, which this proxy
nevertheless is forced to support though you get problems like this Tor
which by itself leaks information to the Internet.
I'm stuck.
Kind regards

@_date: 2016-11-28 23:00:51
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
Leaking what to whom? I don't quite understand what you mean.
Do you mean the raw message the client sends to the proxy server?
But that's within the LAN and protected by a direct SSL/TLS encrypted
MUA-proxy connection. And if you're outside your LAN with your client
then you may use an end-to-end encrypted Tor .onion connection to your
proxy's service.
And at the proxy your messages' metadata are cut down to what's
mandatory to transfer the information.
I hope that's addressed above.
No problem to set up a local webmail system and connect it with the
outer world through the proxy's SMTP and POP3 server.
Btw, nearly all proxy parameters relevant for message processing can be
controlled by adding certain custom headers to the message itself
(normal vs. anonymous routing, remailer chain length, WME activation,
message header items that have to be removed, whether the WME or nym
public key have to be added to the header section and so on).
If you need to remain anonymous towards your communication partner you
have to involve a nym server, which holds your pseudonymous mailbox and
provides your mail address. Replies sent there are PK-encrypted with
your nym's key (signed with the nym server's key), then sent through 1+
Cypherpunk remailers (the first one at the nym server's location) to its
destination, which can be either your true mail address or, more secure,
a newsgroup (preferably alt.anonymous.messages) from where you can
download it anonymously e.g through the Tor network. Each of the
Cypherpunk remailers the message passes adds a symmetric encryption
layer. The remailer routing and the passphrases they have to use were,
defined by the nym user, packed into a so called reply-block and sent to
the nym server with the initial nym creation message as described in
Kind regards

@_date: 2016-10-16 01:22:50
@_author: Carola Grunwald 
@_subject: Implications of a common private keys directory in 2.1 
my next problem with 2.1.15 on Windows 7.
I add a pub/sec keypair to two different keyrings
  '--import ... --keyring a.kbx', then '--import ... --keyring b.kbx'.
Following this I delete that key from one of the keyrings
  '--delete-secret-and-public-key ... --keyring a.kbx',
which unfortunately as a side effect also removes the secret key
associated with the other public keyring (b.kbx), as for both public key
items there's only one single secret key file stored in the common
private-keys-v1.d directory.
Is there any chance to get that disentangled, maybe by defining a
separate secret key directory for each public .kbx keyring in use?
Kind regards,

@_date: 2017-01-29 05:27:40
@_author: Carola Grunwald 
@_subject: How to prevent passphrase caching in 2.1 
Many thanks for the hint, but unfortunately it doesn't influence GnuPG's
time retrieval.
still signs with the host system's timestamp.
Thanks anyway!
And please excuse the late response, as I didn't have much time lately
to care about that project.
Kind regards
