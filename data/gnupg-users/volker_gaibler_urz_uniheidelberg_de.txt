
@_date: 2002-04-23 04:13:01
@_author: Volker Gaibler 
@_subject: Revocation problem with keyserver 
I wanted to change my encryption subkey and therefore revoke my old
subkey. I read the hints given in earlier questions but it doesn't work. GPG doesn't accept my public key being imported for revocation
as Steve Butler wrote on Thu, 7 Mar 2002. I get the following
error message:
  gpg: requesting key 86ECAC0B from wwwkeys.eu.pgp.net ...
  gpg: key 86ECAC0B: no valid user IDs
  gpg: this may be caused by a missing self-signature
  gpg: Total number processed: 1
  gpg:           w/o user IDs: 1
But the key on the keyserver was created by GPG 1.0.6 and so is
self-signed by default. (my key id is 86ECAC0B) Trying to add the new subkey to the keyserver via gpg --send-key
results in an ok message but the key on the keyserver is not updated.
Adding via web interface shows
  Key block in add request contained no new
  keys, userid's, or signatures.
  Your key block contained 1 format errors,
  which were treated as if the erroneous elements
  hadn't been part of your submission.
  The last error was on key 0xa82a9e56:
  Key block corrupt: more than one signature on subkey
Can this be a keyserver problem or am I doing something awfully wrong?
Thanks in advance.

@_date: 2002-04-25 01:22:02
@_author: Volker Gaibler 
@_subject: Revocation problem with keyserver 
That's quite funny because I thought that the 2048bit subkey is not
included in the corrupted key entry. GnuPG with --list-packets shows
just 1024bit keys for the keyservers (wwwkeys.eu.pgp.net,
 ...)
Volker

@_date: 2002-12-05 22:12:03
@_author: Volker Gaibler 
@_subject: Robot CA at toehold.com 
But why use encryption at all in that case? Slightly simplified:
If someone can read your unencrypted mail (sysadmin or somebody sniffing
network traffic) - and that's what you want to prevent - also can create
bogus-but-signed keys.

@_date: 2002-12-05 22:12:10
@_author: Volker Gaibler 
@_subject: Robot CA at toehold.com 
I think it is really dangerous to give people that feeling of security.
Someone who doesn't understand the basics of encryption will not be able
to use it an a secure way. I'm not talking about mathematics but about
the meaning and implications of a exportable signature, a local
signature and assigning trust - just as examples. The most vulnerable point of encryption is the interface key <--> person. Just as people get used to accepting all certificates when using SSL.
And granny will not be aware of the fact that only email address is
checked - at least not in every-day business. And the will be astonished that their sysadmin cannot only read their
email but can also forge signatures.

@_date: 2002-12-06 16:26:02
@_author: Volker Gaibler 
@_subject: Robot CA at toehold.com 
What kind of security is that when you don't care just because you've
got no solution? Common but not secure. Security is a little bit different of usual
engineering. It's not about "do it that way and if we find no problems
that'll be ok". The important thing about security is that you have to
be aware of the cases that did not happen yet - or at least nobody knows
about it.
As example: If your encryption isn't good (in this case: your signatures
aren't reliable) you will probably _never_ know that it was broken. How?
Mallory won't tell you he broke your encryption. So a good amount of
paranoia is necessary (peer review just isn't something different) to
minimize the risk.

@_date: 2002-12-10 02:18:02
@_author: Volker Gaibler 
@_subject: setting owner trust 
Is there also possibiliy to show a list of assigned trust values i. e.
the human readable content of my trust db or should I do this via shell script? Would be nice to check what I've set and if I still like this.

@_date: 2002-12-12 01:27:02
@_author: Volker Gaibler 
@_subject: Bad signature (was: Re: GPG support in Mahogany) 
No, Ingo's message shows a GOOD signature for me.
 Volker Gaibler                                 contact:
                    mail
 OpenPGP key: 0x86ECAC0B
 get my public key from website above=20

@_date: 2002-12-12 01:29:03
@_author: Volker Gaibler 
@_subject: Bad signature (was: Re: GPG support in Mahogany) 
It's ok. And Brian Minton's mail was also verified ok for me.

@_date: 2002-07-08 10:46:01
@_author: Volker Gaibler 
@_subject: PGP =?iso-8859-1?Q?Schl=FCsse?= 
well, first, this is an English list so please write in English.
I tried this (2047 bit key) with PGP 7.0.3 and it took horribly long
(well, in fact it did not complete because I cancelled), much much
longer than a normal 2048 bit key generation. I don't know why PGP
behaves like that (without giving an error message), but there is really
no reason to use such odd numbers as 2047 bit. This won't increase the
security - and 2048 is really enough. So just don't do it.
 Volker Gaibler                                 contact:
                    mail
 OpenPGP key: 0x86ECAC0B
 get my public key from website above=20

@_date: 2002-07-29 17:13:02
@_author: Volker Gaibler 
@_subject: Exact timestamps may be bad 
either way there would be the possibility of a replay attack.
So Trent should sign Alices mail (also signed by herself without
timestamp) to confirm that he got the encrypted message (with timestamp)
from Alice that date. The communication from Alice to Trent is encrypted and so there must be
TWO timestamps inside the encrypted message: One to prove to Trent that
the mail really came from Alice (with timestamp to prevent replay) and
one inside this "Trent-signed"-message without timestamp for publication
in the public forum. The encryption and "Trent-signature" are something
like an envelope to the without-timestamp-signed message to be
When using more remailers then everything has to be sent with timestamps
except the innermost signature for the public - assuming that the
remailers are trustful enough to give them the timestamp information in
the envelope, but I think we're assuming that anyway.

@_date: 2002-07-30 01:28:02
@_author: Volker Gaibler 
@_subject: Exact timestamps may be bad 
It is not designed to protect against replay, but signed timestamps
could do something like that. But of course your're right and I never
thought about checking signed timestamps before (just don't know how I
should do this at the moment)

@_date: 2002-07-30 01:38:04
@_author: Volker Gaibler 
@_subject: Exact timestamps may be bad 
so have I, but in case you really want to use anonymous remailers you
have to trust the remailers. They can surrender your identity and crypto
won't help.
The timestamp would be a counter now. No objections at the moment.

@_date: 2002-06-01 16:03:01
@_author: Volker Gaibler 
@_subject: Can't transfer old secret subkey to 1.0.7 secring 
Hello everybody,
switching to GnuPG 1.0.7 I tried to copy my old encryption subkey (from
old 1.0.6 secring) to my new secret keyring. Until now I have used the old subkey by using an additional secring in
the options file.
sec  1024D/86ECAC0B 2001-12-05 Volker Gaibler ssb  1024g/490CC343 2001-12-05
When I now export the old subkey 490CC343 via
gpg -a -o secold.asc --export-secret-keys --secret-keyring secold.gpg 490CC343
and import it to the new secring via
gpg --verbose --import secold.asc
I get the error message
gpg: armor header: Version: GnuPG v1.0.7 (GNU/Linux)
gpg: sec  1024D/86ECAC0B 2001-12-05   Volker Gaibler gpg: key 86ECAC0B: already in secret keyring
gpg: Total number processed: 1
gpg:       secret keys read: 1
gpg:  secret keys unchanged: 1
The same happens when exporting with --export-secret-subkey
Shouldn't the subkey be added to my new secret keyring?
Or is there any other way to copy the old subkey to the new keyring?
I found a quite similar question by Frank Ollig (Wed, 24 Apr 2002) but no answer to this in the list.

@_date: 2002-06-11 03:58:01
@_author: Volker Gaibler 
@_subject: double encryption 
Hello Andy and Ryan,
I think you're wrong assuming that the cascaded cipher would be of
"double" strength (that means that key length would increase by a
factor of 2, resulting in a key size of 2*n). There is a classical
example to show this - for symmetric encryption:
A DoubleDES cipher (encrypting two times with SingleDES and two
different keys) has an effective key size of only 1 bit more than
SingleDES. This is not really stronger than the single
encryption - and DES is a really good cipher (only it's key size is much
too small). There are even (theoretical!) examples where cascaded
encryption can weaken a cipher. But that's really theoretical.
So you can be quite sure that double encrypting doesn't help
you much more. Possibly encrypting three times (with two or three
different keys) could improve your effective key size significantly. Of course Ryan is right when he says that this all is a pointless act.
Good 128bit ciphers are really strong enough for the next decades even
for intelligence agencies and triple encryption would be complete
overkill and waste of time.

@_date: 2002-06-11 20:23:01
@_author: Volker Gaibler 
@_subject: double encryption 
Yes, 3DES is DES 3 times (many implementations do
encryption-decryption-encryption) but with 3 different keys. DES has a
keylength of 56 bit, so for 3DES there is 168 bit keylength for the
three parts. I don't know, how it's implemented in GnuPG. But triple encryption is thought of increasing the effective key length
significantly - even there is no proof yet. So 2DES is not really worth
more than DES, but 3DES is still very secure. It has an effective key
size of about 110 bit - and about 80 bit is supposed to be the maximum
for intelligence agencies to be crackable.

@_date: 2002-06-12 01:59:01
@_author: Volker Gaibler 
@_subject: double encryption 
Hello Adrian,
This is mentioned roughly in the presentation, Ryan referred to (Tue, 11 Jun 2002 10:34:54 -0500) and many crypto books write about that. It's called Meet-in-the-middle-attack. What you need for that is one known 8 byte plaintext/ciphertext pair P/C
(what is a really low requirement in cryptography). We use two different
keys K1 and K2 for 2DES.
You encrypt the plaintext P by all possible keys K1 and store it in a
hash table with the output you get when encrypting the known plaintext P
with K1. Then you decrypt the known ciphertext C by all possible keys K2
and always look at once, if the output is in the table (output of
encryption). If you find it you know the key K2 and you know K1 from the
table. This needs 2^57 en/decryptions and storage of 2^56 encrypted
blocks. If you draw a diagram, you'll easily see this.
The computation time is absolutly no problem, only the storage is a
little bit huge. But there are time-memory-tradeoffs to save storage by
computing a little bit longer. Don't understand this wrong: It's still
not very easy, but 2^57 units of computing time is desasterous for a
112bit cipher as 2DES and therefore absolutly insecure.
Hope that this helped you a little bit understanding it.

@_date: 2002-11-12 18:09:01
@_author: Volker Gaibler 
@_subject: conventional encryption with passphrase remaining blank? 
Do you mean "gpg --armor --sign file.pdf"?
That's armored signing. It verifies without any questions and lets you
save the original (unsigned) file. What's wrong with it?  ;-)

@_date: 2002-11-16 02:46:01
@_author: Volker Gaibler 
@_subject: Cannot import public key 
That's the reason: "this may be caused by a missing self-signature".
"gpg --list-packets key.asc" shows
   :public key packet:
        version 3, algo 1, created 917538640, expires 0
        pkey[0]: [768 bits]
        pkey[1]: [5 bits]
   :user ID packet: "PHH Vehicle Managment Services"
There is no self-signature on the user ID. You can force GnuPG to accept
the key with the option "--allow-non-selfsigned-uid" when importing and
encrypting to it (see man page) but you should better not do this.
Please note that "this is not recommended because a non-selfsigned user
ID ist trivial to forge". Better ask the key owner to sign his key -
that's not too much work ;-). Some old PGP versions didn't do that by
Your PGP version accepts non-selfsigned uids - GnuPG does not by

@_date: 2002-09-24 01:41:02
@_author: Volker Gaibler 
@_subject: export private key 
Hello Norbert,
in case this is not clear enough, I'd like to add this remark to Johans
The thing that is exported by gpg when exporting the private key is the
passphrase-encrypted private key. It's contained in secring.gpg. So if
the attacker doesn't know your passphrase, he can't get the "real"
(decrypted) private key that is needed for signing, etc.
As you see, the strength of the passphrase is crucial here. In nearly
all cases the passphrase is by far the weakest point - if the system is
compromised / the attacker got the encrypted private key. But in that
case you also have to be aware that the attacker could install
keyloggers, etc. and get the passphrase that way. So keep your system
secure - the passphrase is rather a sheet-anchor.
 Volker Gaibler                                 contact:
                    mail
 OpenPGP key: 0x86ECAC0B
 get my public key from website above=20

@_date: 2003-02-11 16:14:01
@_author: Volker Gaibler 
@_subject: Newbie -> trusting public key via batch method 
Hello Steve,
I guess that this isn't a problem about ownertrust as set in
--edit-key because the ownertrust (shown in --edit-key  as the
first value of "x/y") is about the trust in the owner only to sign keys
he checked carefully. This is not about the question if the key is valid
or not. Just as an example: You've got my key in your keyring, downloaded from a
keyserver, so you don't know if that's really MY key or a forged one. To
make the key trusted, one way is to check the fingerprint in direct
contact with me (fingerprint of the key in your keyring should be
identical as the fingerprint the real owner, me, tells you). Then you
know that the key is valid and you sign (or lsign) it by --edit-key
volker sign ("sign" means you testify that you checked the key carefully
to belong to the stated owner). In your case this would be probably the
solution you're looking for. Use "lsign" if you don't want your
signature on the key ever to be exported e. g. in case you didn't check
it carefully enough but still want to see it valid on your own risk.
If you assign full ownertrust to me, using --edit-key volker trust 4, all keys I signed will be trusted if my key in your keyring is signed by
you. The ownertrust just say who trustworthy somebody is to correctly
introduce you to other people (how trustworthy I am to check my
signatures carefully). The web of trust is built with this ownertrust
and can help you make more keys valid indirectly, but you don't have to
use it because you can also just rely on signing keys after checking
them personally.
So use --edit-key  lsign.
By the way: Please don't steal threads i. e. "reply" to other mails,
change the subject and ask about other things but start a new thread via
"send mail to" or something like that.
                    mail
 OpenPGP key: 0x86ECAC0B
 get my public key from website above

@_date: 2003-01-14 00:41:02
@_author: Volker Gaibler 
@_subject: elGamal Keys to Sign+Encrypt 
Don't know too much about security issues for ElGamal keys, but I can
just agree with the status "deprecated" because they're *really* slow
and when you want to use them to verify emails your readers won't be too
happy. I just deleted one because waiting for more than one minute just
to verify a signature is not too comfortable. Of course this doesn't
mean you should not certify them.

@_date: 2003-01-15 02:43:11
@_author: Volker Gaibler 
@_subject: What kind of key do I have? 
just a short note: Take care that your key has one subkey only
because they manage the keys via a keyserver (with the well known bug
that mangles the keys) - at least that happened with my key last year.=20
So if you've got more than one subkey, maybe you should send them a copy
without the other subkeys. When you get the key back their signature
will be merged into your complete key.
 Volker Gaibler                                 contact:
                    mail
 OpenPGP key: 0x86ECAC0B
 get my public key from website above=20

@_date: 2003-05-31 16:17:02
@_author: Volker Gaibler 
@_subject: Is a secret key compromised by known cleartext? 
No. Your public key is not secret and so is available to everybody (or
could be, if you decide to publish it). So everybody can choose a
cleartext and find the correspondent ciphertext. This is always possible
with public key crypto and so the algorithm always has to resist this kind
of attack. So finding lot's of plaintext-ciphertext pairs is no threat to
