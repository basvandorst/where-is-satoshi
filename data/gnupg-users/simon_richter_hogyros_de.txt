
@_date: 2010-04-28 21:44:16
@_author: Simon Richter 
@_subject: smart card with 4096 bit keys 
The key length is limited by the card firmware. For each crypto
operation, a data block with the same size as the key needs to be
transferred to the card, which needs to have buffer space available for
the data.
While the crypto processor itself can handle 4096 bit keys, the code
running on the card that implements the card "file system" and prods the
crypto unit to work cannot handle that (and a bug in the decryption code
also precludes using 3072 bit "encryption" keys).
You can use the card for subkeys only.
   Simon

@_date: 2010-04-29 16:38:51
@_author: Simon Richter 
@_subject: Encrypting/decrypting large amounts of data in parallel using 
For a SmartCard setup, yes. There may be other HSM solutions that have
higher performance, but these are not as tamperproof as a SmartCard.
   Simon

@_date: 2010-08-04 13:55:31
@_author: Simon Richter 
@_subject: Gnupg good for big groups? 
Obviously you cannot revoke access to something people have already
decrypted, because they can always keep a copy.
In principle, the rest would be possible, as the data is encrypted using
a session key, which is then attached encrypted for each individual
recipient, so all that is needed is a way to decrypt one copy of the
session key and reencrypt it for the additional recipients. As said,
removing a copy of the session key is nonsensical, but if the contents
of the file change, it needs to be reencrypted anyway.
As far as I know, there are no readymade commandline tools for your use
case. Some of these would be generally useful for other uses as well:
 - take an encrypted file and add new recipients: you'd need to be one
   of the original recipients, that is, able to decrypt any of the
   packets containing the session key.
 - remove recipients from an encrypted file: can be done by selectively
   throwing away packets; I think this would also be useful in some
   email setups.
Not really -- you need to have access to the clear text data somehow to
extend the list of people who have access. This access can be realized
by having a special "recipient" for the web frontend, and by
manipulating the gnupg packet stream, the actual data need not be
decrypted, but all you gain is speed, not security, as you still need
the same information as if you were to decrypt the data. And, obviously,
that is a good thing.
You can remove the packet containing the session key, but if they
already have the session key, they will continue to have access. Given
that they also have had access to the clear text, this is not really an
There are mailing list managers that support encrypted mailing lists --
i.e. you encrypt the message to the list bot, and the bot reencrypts to
the then-current set of recipients. That doesn't solve your archive
problem though, and the revocation issue is unsolvable with any crypto
   Simon

@_date: 2010-08-12 09:41:27
@_author: Simon Richter 
@_subject: Accessing the 2nd card reader 
on a related note: I have two cards, one is full sized, one SIM sized,
and two different readers, one of which is an USB stick that is inserted
only when needed. Using such a setup is a serious hassle, because I need
to reconfigure the reader-port everytime I want to use the other card.
Can the system be adapted to scan all readers when looking for a
specific card, and to rescan for new readers when it prompted the user
to insert a card?
   Simon

@_date: 2010-08-20 15:09:53
@_author: Simon Richter 
@_subject: gnuPGP Setup 
Essentially, yes.
It is usually advisable to use plain text files (i.e. files containing
just the raw text, without any formatting), as these can be used from
gpg directly.
If you use gpg on the command line, the easiest way is to use the
"--output" (or "-o") option, e.g. in order to export a key:
  gpg --output mykey.txt --export --armor 12345678
where you replace "mykey.txt" with the name of the file you wish to
contain a copy of your public key, and 12345678 with the ID for your
You can import such a file using
  gpg --import mykey.txt
(again, replacing the file name).
He needs to import the key using --import. For this it is vital that the
key be available as plain text. If you have a Word file, you should
copy and paste the text into Notepad, and import from there.
Note that the communication channel you used to transfer the public key
is not secure -- while an attacker could not use the key data for
anything other than sending you an encrypted message, a man in the
middle could swap the key for another one. Therefore, it is recommended
that after importing, you list the contents of the keyring using the
  gpg --fingerprint
which will then show you one block for each known key, starting with
"pub" then followed by a number and letter, a slash, then the key id and
creation date, then in the next line listing a string of numbers. You
should verify that these two lines are the same for both you and the
recipient, if they are, then the key has not been tampered with in
You can then use
  gpg --sign-key 23456789
(replacing 23456789 with the other's key id), and follow the
instructions there to sign their key using yours; with this, you amend
the other's key with a signed note saying that you have verified their
identity, as the note is signed it cannot be forged, and your local copy
of gpg will then know that it is safe to use this key (otherwise it'll
warn that the key is "untrusted" whenever it is used).
The same thing as your party does with your key.
   Simon

@_date: 2010-09-24 15:36:14
@_author: Simon Richter 
@_subject: multiple keys vs multiple identities 
That depends on your use case mostly. I use a single key with multiple
identities, because it is easier to build a strong web of trust this
It'd be nice if there was a signature notation that specifies which
UID(s) this signature would be valid for.
Indeed, especially if you use subkeys for actual day-to-day use.
   Simon

@_date: 2010-09-24 16:30:56
@_author: Simon Richter 
@_subject: multiple keys vs multiple identities 
Of course. I was talking about data signatures, i.e. "I'm signing this
with my work hat on".
The main use case I have is my Debian work -- when I sign a .changes
file, the Debian archive will accept it, even if the package in question
was really intended for another repository (where I use the same key for
As my main key is well-established in the WoT, I'd like to use the
existing connections to get a trust path; however using the key directly
leads to the problem that the signature can be interpreted in multiple
   Simon

@_date: 2010-09-27 13:37:49
@_author: Simon Richter 
@_subject: multiple keys vs multiple identities 
Yes, although you should probably limit it to two or three keys at the
most, as verification of key fingerprints takes time and most keysigning
party modes are only as fast as the slowest pair. If you have a "main"
key, it is usually best to make sure it is well-connected by presenting
it at every key signing party during the official part, and negotiating
individual signings for the other keys unofficially.
It all depends on the circumstances at the party though.
   Simon
