
@_date: 2016-04-05 11:37:29
@_author: Paolo Bolzoni 
@_subject: Translate to dutch 
Wait? What? I am missing one important detail, a part of slightly
obnoxious advertisement in this mailing list, how do you plan to
attract people to use your bash scripts?

@_date: 2016-04-24 20:01:37
@_author: Paolo Bolzoni 
@_subject: Help needed 
You are strongly advised to read the gpg frequently asked questions,
here is the link:
Here a particularly relevant question:

@_date: 2016-04-25 15:06:50
@_author: Paolo Bolzoni 
@_subject: Paper backup 
I did something similar for the revocation certificate. I used LaTeX
preparing this template for the students:
I think paper backup are a good idea. For example, I keep mine with my
passport, if my passport (and so revocation certificate) get stolen I
have bigger problems than someone revoking my key.
Besides the QR encoding make easy to copy text, even long to computers
(with maximum redundancy you can store up to 3000 ascii chars).
The only disadvantage I see is that some applications read the code in
unexpected ways. For example instead of showing you the text they will
open random websites.
I tried to look around for a "standard" way to state that a QR
contains only plain text, but with no avail.
However, even if not standard starting the text with "TEXT:" seems to
stop many apps from "tupidly interpret the text.
Honestly I don't really get this egpg for reasons we already
discussed, but LaTeX template for sharing the key or keeping the
revocation information are indeed a good idea.

@_date: 2016-04-26 09:38:38
@_author: Paolo Bolzoni 
@_subject: Paper backup 
Just don't forget that any machine-readable format like QR should put
togheter with a human readable one. Because your cannot be sure how
easy it to read a QR when you need it.

@_date: 2016-04-26 10:46:12
@_author: Paolo Bolzoni 
@_subject: Is there a foolproof tutorial to start with gpgme? 
Dear list,
gpgme is very interesting, but it appears quite daunting to start from
the documentation alone.
There is some ready to comple example somewhere with easy tasks like
signature checking or compiling?

@_date: 2016-04-27 12:00:08
@_author: Paolo Bolzoni 
@_subject: making a Debian Live CD for managing GnuPG master key and 
Since the thread is already quite lost I chip in with a question.
What is the matter with top posting? Is my client that is weird
showing the text from the beginnig, where what I want to read is? Top
posting sounds even more ad-hoc that bottom posting where you have to
scroll down to find what you want to read...

@_date: 2016-04-28 11:02:30
@_author: Paolo Bolzoni 
@_subject: Top-posting 
I think this text (or variants) are old as email itself and actually,
while funny, makes little sense.
When you follow an email thread you do not read everything, you just
read the new email and it makes little difference if it is in the top.
Besides most email clients actually put an indentation in the quoted
text so it should look like:
A: Because it messes up the order in which people normally read text.
That with one-liners looks strange, but it makes clear with long texts.
However, I agree there is not need to keep clutter in the bottom of emails.
So while I still don't see the big deal with top-posting. I agree that
is much better (A) to trim and answers to single points or (B) simply
make a clean email.

@_date: 2016-04-28 11:49:21
@_author: Paolo Bolzoni 
@_subject: Top-posting 
The modern editors are indeed part of the problem. Don't get me wrong,
I am all for fancy screens, pleasant colors, GUIs, and modernity. But
what I do not understand why break down and remove what it does work
already.  Another example that sometime drive me crazy is the lack of
regular expressions in "Search" functions.
However, you can move around with keyboard even in "modern" mua. When
using normal keyboards I think you are exagerating a bit. The problem
is indeed annoying with limited keyboards, though.

@_date: 2016-08-26 09:13:22
@_author: Paolo Bolzoni 
@_subject: Please unsubscribe me form your mailing list. Thank you. 
The world would be a much better place if we could ban signatures and
non pure-text emails. Alas...

@_date: 2016-08-26 09:12:40
@_author: Paolo Bolzoni 
@_subject: Attacks on encrypted communicxatiopn rising in Europe 
I think you can say this sentence with the one that try break a Daesh
hacker and the awful people being american soldiers.
I personally think that's the point, to be in the safe side you have
always to assume you are the awful people for someone. It does not
matter how real, or absolute the thing is.
Try to break is fine, forcing people to use broken products is bad.

@_date: 2016-08-26 16:39:33
@_author: Paolo Bolzoni 
@_subject: Please unsubscribe me form your mailing list. Thank you. 
(1) and (2) Did you read the word "alas"?  Of course it's not
possible. Secondly the fact business policy mandates something does
not make it a good idea, in this case it does not at all.
(3) Study the meaning of the word "Encoding." Plain-text has nothing
to do with what characters you can represents. Nowadays UTF-8 is
fairly popular for many reasons.
(4) "*forbidding a capability* considered a feature" is something you
said. I simply said the world would be better, because the
disadvantages are more than the advantages. If the format is important
for any reason, just write a .pdf or create few pictures and attach

@_date: 2016-03-21 10:44:06
@_author: Paolo Bolzoni 
@_subject: Should always add myself as recipient when ecrypting? 
Dear list,
The subject pretty much says it all already, I am using GnuPG 2.1.11
(with libgcrypt 1.6.5) and I was wondering if I should always add
myself as recipient when encrypting a file, of course, in addition of
the real recipient.
Is there a reason not to?

@_date: 2016-03-22 11:40:10
@_author: Paolo Bolzoni 
@_subject: EasyGnuPG 
And besides, it's much easier to build a GUI app in front of a C API
than a command line application.

@_date: 2016-03-22 10:54:18
@_author: Paolo Bolzoni 
@_subject: EasyGnuPG 
I totally agree, Dashamir I really think you should focus on what you
think is hard in gnupg? And why?
Are you sure a new program (and not a simple patch) is the best answer?
At the moment you are showing us strange defaults, an implementation
that can break at any time, and I am not really sure how much it is
easier anyway.
For example, I find strange and needlessy difficult that the keys have
a duration and not an expiration date. So when one wants the key to
last until the end of the year or to his birthday one has to make a
date difference manually.

@_date: 2016-03-22 14:16:22
@_author: Paolo Bolzoni 
@_subject: EasyGnuPG 
My real question is: what do you think in gpg is not easy enough?

@_date: 2016-03-22 15:53:22
@_author: Paolo Bolzoni 
@_subject: A better interface to the GnuPG-Framework (Re: EasyGnuPG) 
I guess we should start from the desired use case.
We want a GUI for what? Encrypting? Signing? Managing the web of
trust? SSH login? Everything?

@_date: 2016-03-23 17:49:47
@_author: Paolo Bolzoni 
@_subject: Verification via the web of trust 
There is a way to know how many "hops" are a key from anything I trust
and see the path?

@_date: 2016-03-23 18:14:07
@_author: Paolo Bolzoni 
@_subject: Verification via the web of trust 
Sigh.. it seems I am not yet part of the strong set.
Thanks anyhow!

@_date: 2016-03-24 11:21:37
@_author: Paolo Bolzoni 
@_subject: Force textual pinpad 
Dear list,
It is possible to simply use the terminal to input my password when
using gpg from the command line?
I often use the computer with two screens, one that the students see
and the one in front of me. So, it's kinda a problem when the pinpad
appears in the "wrong" screen as it seems to abuse the window manager
and refuse to move, lose focus, or do what you expect from a window.
So to make it easier, what about simply use the terminal? Is that possible?
Yours faithfully,

@_date: 2016-03-24 12:01:08
@_author: Paolo Bolzoni 
@_subject: Force textual pinpad 
To unset DISPLAY env var works really well, but I'd prefere something
I can setup in the gpg options.

@_date: 2016-03-24 12:28:24
@_author: Paolo Bolzoni 
@_subject: Force textual pinpad 
I don't have a $GNUPGHOME/gpg-agent.conf file, I can simply create it
or I have to assume something is terribly wrong in my system?
On Thu, Mar 24, 2016 at 12:26 PM, Damien Goutte-Gattat

@_date: 2016-03-24 12:50:42
@_author: Paolo Bolzoni 
@_subject: Force textual pinpad 
I works fine, thanks everyone. I wrote down the whole procedure for
the men of the future with the same problem:
1- Ensure that pinentry is installed in your system,
2- See what options you have writing pinentry- in your shell and pressing tab,
  (The textual choices are pinentry-curses and pinentry-tty)
3- Edit $GNUPGHOME/gpg-agent.conf, if $GNUPGHOME is unset it means
~/.gnupg, and if the gpg-agent.conf file does not exist you can create
4- Add the following configuration line (here for example is curses)
  pinentry-program /usr/bin/pinentry-curses
  double check the file path.
5- Restart the agent:
  $ ps aux | grep gpg-agent # to get the pid
  $ kill -2   $ gpg-connect-agent /bye
6- Test if you like it
  $ gpg --symmetric

@_date: 2016-03-24 16:56:46
@_author: Paolo Bolzoni 
@_subject: Force textual pinpad 
Yes, the pair
$ gpg-connect-agent killagent /bye
$ gpg-connect-agent /bye
works fine too and it is probably prettier than CTRL-C the agent.
However, I think restarting the agent manually is very useful even
without SSH. The reason is possible errors in the configuration, if
the command fail you immediately know something is wrong and you can
fix. I learnt from experience as I forgot the hyphen in ``no-grab''
and seeing the agent not working I double checked outright.

@_date: 2016-03-30 11:31:19
@_author: Paolo Bolzoni 
@_subject: How do you think the FBI managed to get the clear text of the 
Dear list,
I am aware it is out topic, but still I assume as we are security
oriented people (otherwise why being part of this email list?)
I think it is interesting food for thought.
As far as I understood the situation is:
The iPhone uses AES (256?) to encrypt the storage.
The phone owner, probably the only person who knew the password,
is dead.
To access the phone storage there is a Trusted Platform Module
(TPM) chip that should force the access to the storage through a
well known path: the Apple software FBI asked to change.
The TPM contains the AES key protected with the password, the
things FBI asked to change were:
1- removing the feature that the key is destroyed after 10 wrong
2- remove the forced delay between every wrong password attempt,
3- allow machines to try a password.
I far as I can see the only possible weak point is the TPM, it
should not be possible to workaround it. But it sounds even less
plausible to break AES directly or ask the dead person.
What do you know about this case?
Yours faithfully,

@_date: 2016-03-30 20:04:34
@_author: Paolo Bolzoni 
@_subject: What am I missing? 
Actually I thought there is a TPM that is needed to "talk" with the
storage. If one fails to input the password enough times, the TPM
destroys the key.
You can say that it is false that the storage get destroyed but, since
it AES encrypted, after destroying the key it is pretty much the same.
If it was only software, where the AES key is stored? And why not copy
the storage?

@_date: 2017-03-16 23:47:01
@_author: Paolo Bolzoni 
@_subject: Simple program to get sha256 hash 
Dear list,
Today I wanted to play a bit with libgcrypt and I wanted
to make a small program to return the sha256 hash of a
string passed as argument.
The program compiles, links, and gives an output.
However, the output is different than what I get using
sha256sum from coreutils!
Here is what I see in my shell:
$ gcc -o ssha  ./hash.cpp -lgcrypt
$ ./ssha blablabla
$ sha256sum <<< 'blablabla'
a5edca3a5b8fb54ae61d236a5274626ba6a38781573e02202000158faa707191  -
hash.cpp contains the code I copied in the bottom of the email.
What am I missing? Isn't expected to have the same hash code?
Yours faithfully,
---------- >8
  int main(int argc, char** argv) {
    if (argc < 2) return 1;
    gcry_md_hd_t context;
    gcry_md_open(&context, GCRY_MD_SHA256, 0);
    char* c = argv[1];
    while (*c != '\0') {
        ++c;
        gcry_md_putc(context, *c); }
    unsigned char* csha  = gcry_md_read(context, GCRY_MD_SHA256);
    for (int i = 0; i < 32; ++i) {
        printf("%02x", csha[i]); }
    printf("\n");
    gcry_md_close(context); }

@_date: 2017-03-18 09:18:59
@_author: Paolo Bolzoni 
@_subject: Simple program to get sha256 hash 
Thanks everyone, it's dead on!
$ echo -n 'blablabla' | sha256sum
492f3f38d6b5d3ca859514e250e25ba65935bcdd9f4f40c124b773fe536fee7d  -
$ ./a.out blablabla
using echo -n "blablabla" gives indeed the same result!
The flipped gcry_md_putc and ++c happened somewhat while I copied the
code in the email, but indeed was another problem.
Thanks again,
