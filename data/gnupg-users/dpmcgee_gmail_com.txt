
@_date: 2011-08-22 08:27:04
@_author: Dan McGee 
@_subject: Which release should we be using? 
So you're enforcing policy via disabling copy and paste? This is
extremely shortsighted. Any password management program like Keepass
makes transfer via the clipboard easy and relatively safe (clearing it
after 10 seconds), so that doesn't sound like the safety of "no
passphrase at all".

@_date: 2011-08-25 12:42:46
@_author: Dan McGee 
@_subject: Marking a key as "don't export"? 
Is there any way to mark a key as local-only, similar to an
lsign-created local signature?
I'm asking because I plan on generating a master key to be used by a
piece of software where ultimate trust can be rooted, and there is
really no need to have even the public half of this key ever leave the
machine. The only operation it will ever be used in is lsigning
various other public keys.

@_date: 2011-12-01 11:37:52
@_author: Dan McGee 
@_subject: Gnupg file formats 
The pgpdump source code may be a bit more easy to grasp if you just
want to understand the file format.

@_date: 2011-07-28 15:49:42
@_author: Dan McGee 
@_subject: Creating a quickly expiring signature 
I wanted to test behavior of an application with an expired signature,
but using `--ask-sig-expire` don't seem to be granular enough. The
minimum I can specify is either 1 day, or an absolute date (e.g.
2011-07-29), which is still 8+ hours away for me right now. Am I
missing something? Decimal values are not accepted, nor seconds,
minutes, or hours.

@_date: 2011-07-28 17:21:38
@_author: Dan McGee 
@_subject: Creating a quickly expiring signature 
Thanks! This worked. Now why isn't this documented anywhere to be
found? What other secret helpful options does gpg not advertise?
 while I appreciate your suggestion, I do not find setting my
system clock (controlled by NTP) to an invalid time to be even
remarkably a valid solution to this problem, especially if I am
writing an automated test suite that generates signatures and keys,
for example...

@_date: 2011-06-01 17:41:13
@_author: Dan McGee 
@_subject: Working with a system-shared keyring 
We're trying to get a full implementation of package and database
signing going for Arch Linux using gpgme/gpg, and have run into a few
small hiccups. The goal was to actually use the web of trust features
rather than relying on gpgv and trusting everything in a given
keyring, as it seems every other distro using singing has done.
However, gpg is very particular about permissions, locking, and
ownership, and when layering gpgme on top of this, it becomes even
harder to work within the bounds of what is available.
A quick console session is shown below. Basically the idea is the
system GPG homedir used by the package manager is located at
within. There will never be private key information in this location.
So my questions are:
1. Does anyone else have experience with a shared among users keyring?
2. What is best/secure practice when it comes to this? Outside of
--lock-never, yum does something that seems silly, but works- make a
user-owned copy of the entire keyring directory and then uses that.
3. gpgme doesn't allow us to bypass the trustdb.gpg locking; is there
any possibility of allowing gpgme to run with --lock-never in a
read-only mode?
Any feedback is welcome, thanks in advance!
$ sudo gpg --homedir /etc/pacman.d/gnupg --verify
gpg: WARNING: unsafe permissions on homedir `/etc/pacman.d/gnupg'
gpg: Signature made Tue 17 May 2011 09:13:06 AM CDT using DSA key ID F53A76ED
gpg: Good signature from "Dan McGee "
gpg:                 aka "Dan McGee (Developer) "
gpg:                 aka "Dan McGee (Jabber) "
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: A5CA 9D55 15DC 2CA7 3DF7  48CA 5C2E 46A0 F53A 76ED
$ gpg --homedir /etc/pacman.d/gnupg --verify
gpg: WARNING: unsafe ownership on homedir `/etc/pacman.d/gnupg'
gpg: Signature made Tue 17 May 2011 09:13:06 AM CDT using DSA key ID F53A76ED
gpg: failed to create temporary file
`/etc/pacman.d/gnupg/. Permission denied
gpg: fatal: can't create lock for `/etc/pacman.d/gnupg/trustdb.gpg'
secmem usage: 1408/1408 bytes in 2/2 blocks of pool 1408/32768
$ gpg --lock-never --homedir /etc/pacman.d/gnupg --verify
gpg: WARNING: unsafe ownership on homedir `/etc/pacman.d/gnupg'
gpg: Signature made Tue 17 May 2011 09:13:06 AM CDT using DSA key ID F53A76ED
gpg: NOTE: trustdb not writable
gpg: Good signature from "Dan McGee "
gpg:                 aka "Dan McGee (Developer) "
gpg:                 aka "Dan McGee (Jabber) "
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: A5CA 9D55 15DC 2CA7 3DF7  48CA 5C2E 46A0 F53A 76ED

@_date: 2011-06-03 10:10:15
@_author: Dan McGee 
@_subject: Working with a system-shared keyring 
Perhaps I phrased this bad- I more meant "accessible to multiple
users". When using this keyring, no other keyring will ever come into
play, as $GNUPGHOME is set to this shared directory
Importing to where, and trust levels as well? The idea here is we are
using this keyring for one purpose only- the system-defined keyring
and trust levels used to verify downloaded and to-be-installed
packages and metadata. Having user-specific keyrings/trustdbs for this
stuff doesn't seem to make much sense unless I'm overlooking
Aha, didn't think about this, but it makes sense- thanks. Of course if
the user that does have write permissions on these files (root) runs
gpg, then the --lock-never would be unwanted but maybe we have to live
with that.
Yes, we are doing this already and are setting the home directory to

@_date: 2011-06-13 10:15:59
@_author: Dan McGee 
@_subject: Generate digest and signature seperately 
I'll speak up as a developer here. I was the same one that asked about
a system-shared keyring last week if that helps bring it into context.
The actual issue isn't with package databases at all; those are, as
several people indicated, small enough to be copied, signed, and
uploaded as necessary. We're talking 50-500 KB or so here.
Our real issue revolves around signing very large packages. Take for
example, sage-mathematics [1]. This package clocks in at 306.3 MB
compressed. If this was built remotely on some build server and the
packager wanted to sign it, the current GPG signing workflow would
require to copy it locally where his secure keyring is located, sign
it, and then upload the signature file. The package itself could be
uploaded from either location.
With all that said, does anyone see a reasonable and secure workflow
for this? I did suggest [2] signing package hashes as one possible
option, after looking into agent forwarding and discovering that
doesn't seem to be a workable option at this point.
[1] [2]

@_date: 2012-01-05 16:19:42
@_author: Dan McGee 
@_subject: Short ID Collision 
Just discovered keyservers are still totally crappy on this front.
Check this out when using a subkey ID to try to fetch a key; the
following is a request produced by GPGME gpgme_get_key() that returns
no matches (note that this is a subkey ID):
Subkey lookup, broken in first URL:
        Public key lookup, both work:
        This is totally unacceptable in my opinion, why do we have such broken
infrastructure that it cannot support a simple lookup like this?
