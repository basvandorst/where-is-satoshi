
@_date: 2014-04-10 18:03:17
@_author: Nicolai Josuttis 
@_subject: GPG and BCC 
Recently I was reading
  However, I don't know how old this article is and whether we still have
a conceptional or concrete problem using encryption and bcc with GPG.
I also found no answer on this in the FAQ you "startpaging" (using
startpage.com) the terms.
Can anybody answer/explain whether there is or might be a problem or
risk if using encryption combined with bcc addresses with GPG?
And if so, what should I do/avoid to run into this problem?
I am especially interested in an answer which helps me to understand
WHY there is or might be a/no problem.
In fact:
- Does GPG reveal the number of BCC rcipients?
- Does GPG reveal BCC identities (partially)?
If the answer depends on the browser or other components, please tell me.
The reason I ask is because for a UI to be programmed on top of GPG
I want to understand which warnings I should raise or
what I should deny
when users try to send encrypted emails also to bcc receivers.
And if there is a place discussing and answering that please tell me.
I didn't find one.
Thanks a lot.

@_date: 2014-04-12 11:00:16
@_author: Nicolai Josuttis 
@_subject: PGP and GPG and bcc 
Thanks a lot for all answers regarding my question regarding GPG and bcc.
Allow me to summarize what I learned for both:
- double checking that I understood everything correctly
- documenting this for others
  (I found no place where it is explained;
   therefore also the change in the subject)
In general,
if sending emails encrypted (or in general sending cipher-text)
then the usual approach is that this text contains the identity
of those who should receive the message.
This is to help to find the place where the key for that identity is
stored (note that there might be multiple receivers).
That means:
- In general, adding the "usual key" for a bcc receiver
  would reveal the identity of this receiver.
  Thus, a bcc receiver becomes more or less a cc receiver.
  Or:
  ===
   In general, the concept of BCC is BROKEN
   when sending encrypted emails
   with keys for the bcc recipients.
To deal with that, mailers have multiple options
when users try to send encrypted emails to bcc recipients:
- Don't allow that (or only with strong request for confirmation).
- Don't add keys for bcc recipients at all.
  This probably only makes sense if bcc recipients can use
  one of the other of the keys in the message.
- Don't add the identities for the keys of bcc recipients
  - with GPG you can e.g. use --hidden-recipient instead of --recipient
    (see also --throw-keyids)
  Then, however, recipients might have to try to use their key
  against any of the passed key without identity
  (slows down decryption with multiple bcc recipients).
- Split the email, sending it to each bcc recipient separately.
Note that mailers should take into account not only for
sending bcc to others but also for the common case
where senders (always) bcc to themselves
(using a different but may be secret email address).

@_date: 2014-04-22 12:25:04
@_author: Nicolai Josuttis 
@_subject: UI terminology for calculated validities 
please allow me to raise an issue I'd like to have harmonized among all
web mail frontends using PGP and GPG.
The reason I ask is because I am currently adding a feature for
auto encryption to enigmail.
The question is which terminology shall we use IN FRONTENDS
if we use the web of trust and want to signal
which keys can be used and which not.
According to doc/DETAILS we have the following validity entries:
That means, a key is "valid" if it is not
disabled/expired/revoked and has no unknown validity.
But everything else is valid.
That raises first questions:
- What does 'n' exactly stand for
  (seems to be "less than marginal valid")?
  Is this accepted if trust-model is "always"?
- My understanding is that even with always
  encrypted is not allowed if the validity is
   i/d/r/e.
  Is this correct?
Then there is the question how to present this
to user-interfaces for non-expert(!) user.
Intuitively, people would assume the following terminology:
- a key is "valid" if it is not expired, revoked, or disabled.
- we should send emails if we "trust a key"
  (i.e. a key is trusted if the calculated validity
   is enough to send the email encrypted)
Now "trust" for a key (or the associated uid) might be a problem,
because we use the term "trust" usually for ownertrust only.
But do we?
Note that the terminology is even used in the GPG 2.0 manual:
So the next question is:
Is "trust a key" a valid term?
And if so, which of the calculated validity values fall under it?
If "trust a key" is fine I could describe the effect of trust-model
always as something like:
- "Always trust all keys (except disabled/expired/revoked)"
If you don't like the term "trust a key" what else intuitive terminology
do you suggest?
(note: ideally all mailer should use the same in their UI's)
 Nico

@_date: 2014-04-22 13:36:23
@_author: Nicolai Josuttis 
@_subject: UI terminology for calculated validities 
May be, that's a clear sign that the technical terms don't fit well.
In the non-technical world you can't just define some terms
and expect that people take time to understand them.
For this reason, the terms have to be self describing.
If if they are not, you need different terminology.
I am asking for "permission" or "acceptance" or at least feedback
regarding also to do that. ;-)
BTW, which one is it?
(remember I want to establish common terminology for GUIs)
What is so confusing about trust for different thing?
One thing is:
- Do I trust a person (that he/she signs carefully)?
Another thing is:
- Do I trust the computed validity of a key?
  Or in short: Do I trust a key?
And s the computed validity is derived from a trust model,
it is in effect the answer to the question of
whether I can trust a key.
And even PGP use the term "trust the key".
May be the whole confusion is raised because we constantly
you try to use all these technical details when they should
be hidden.
For anybody sending encrypted emails the whole point is
only one question:
- Can I trust this key I got so that it is safe to use it?
And I can easily explain that using the term "trust" for both:
To trust this key, you have to trust the owner that signed it
(or trust indirectly marginal trusted owners).
That's so simple to explain and I doubt that this is hard to
understand (although still hard to remember).
And the whole model behind is so hard to explain.
Explaining that a key is "valid" if it is "not only valid
(expired/revoked/disabled), but also trusted according to the web of
trust" is a nightmare.
Don't get me wrong.
It is important to have this fine grained model behind the scenes.
But it is also important to wrap it by something really easy.
As I said, I need some self-intuitive wording for
what technically is "valid".
 Nico

@_date: 2014-04-23 00:22:01
@_author: Nicolai Josuttis 
@_subject: technical question: effect of trust-model always and what validity 
Before we continue to discuss "trust" and "valid",
allow me again to raise some technical questions regarding
GPG options and values, which I at least didn't understand
by reading docs and (roughly) source code
(but I need a clear understanding to program a frontend on it).
a) What is the effect of --trust-model always in detail?
Does it mean that when sending emails the
calculated validity is completely ignored
(so that even 'e' and 'r' count as "valid")
or does it "only" mean that '-', 'q', and 'm' count as valid
as 'f' does with the default trust models?
b) What does the calculated validity 'n' means and when
   is it created?
- doc/DETAILS says:
   n = The key is valid
- the GPG manual says:
   n Never trust this key.
- In the source code, it seems to be created
  in combination with GPG_ERR_NOT_TRUSTED:
   >       else if (gpg_err_code (rc) == GPG_ERR_NOT_TRUSTED)
   >         *truststring = 'n';  /* No, we do not trust this one. */
c) IF 'n' means "never trust this key",
   why is it "higher rated" than unknown?
What I mean is: In code and doc there is always the following order:
This leads to the impression that the order is from minimal
to maximal trust.
However, that's not how I would sort it.
For me not knowing whether I can trust is better
than knowing that I can not trust.
Thus, IMO, the order should be
 n
 -/q
 m
 f
 u
Am I missing something?

@_date: 2014-04-23 00:50:24
@_author: Nicolai Josuttis 
@_subject: UI terminology for calculated validities 
First, thanks to all for helping to clarify the issue (for me)
Here is an example of a real world novice problem based on the current
terminology and what we discuss (a real example from today):
In enigmail a user enabled the option "trust_model always"
(it's currently named there as "Always trust people's keys" ;-) ).
When I asked why, the user told me:
 If I don't do that, I always get error messages.
So the dialog between me and the user ("he") continued
roughly as follows:
 me: so the keys are missing
 he:   no, I downloaded them from keyserver xy
 me: oh, but you need trust for the keys
     (meaning they have to be valid)
 he:   yes, it works if I assign ultimate trust to the key
       (he meant the owner)
 me: no, no, don do that.
     ultimate is if you created the key
 he:   so what?
 me: you either can sign the key
     or trust somebody else who signed the key
     (such as pgpca at ct.heise.de)
 he:   Oh, I even registered my email/key there
       but what else is missing?
 me: load the key for pgpca at ct.heise.de
 he:   done, but trust is still missing
 me: oh, yes, you also have to express trust for this key/owner
Then it worked ...
That's a summary of learning step by step what has to be done
to benefit from the web-of-trust
(and BTW "he" was even an IT guy).
BTW, the dialog would have been different
     if I would have used "valid" instead of "trusted".
E.g. as follows:
 me: oh, but you need valid(!) keys
 he:  but they are! Look, neither expired or revoked!
 me: no, no, valid in the sense that you can trust them
 he   ah, I need to trust the keys ...
The essence, we have to teach is:
- create a key
- and then either
  - exchange the key
  - and sign then key you got
    (after validating the fingerprint)
  or
  - load the key for pgpca at ct.heise.de
    or other central "trust agencies"
  - AND express trust for that key/owner
Thus, I am really surprised that you suggest to teach "validity"
instead of "trust".
And I agree that "owner" make things unnecessary complicated.
I am more and more convinced that we simply always should
talk about trust:
- If I trust the key/owner that/who signs other keys,
  I can trust these keys and safely use them
Note that although we can skip the term "owner" we need
the term trust, because without trusting any owner
the trust model doesn't work.

@_date: 2014-04-23 01:18:01
@_author: Nicolai Josuttis 
@_subject: UI terminology for calculated validities 
Hash: SHA512
This discussion is part of my trial to make things better
(but now I know why I also had it turned on ;-) ).
We can change that easily BUT
we MUST AVOID to FRUSTRATE first-time-users.
I was also thinking about a general non-expert option,
switching between safe and unsafe mode.
(The unsafe mode is very important to send more
 encrypted emails to help those who really need encryption).

@_date: 2014-04-26 10:17:21
@_author: Nicolai Josuttis 
@_subject: UI terminology for calculated validities 
Being off for some days and after reading all these emails
(very happy that there is progress!),
some thoughts:
First of all, MFPA raised:
For some reason, this for the first time gave "valid" a useful
intuitive meaning for me, saying something like
 "good enough for GPG to send encrypted emails"
So I wonder whether some confusion can be avoided by
 The key is valid for encryption
instead of just saying
 The key is valid
But still we'd have to distinguish between
 marginally valid for encryption
 fully/complete valid for encryption
 ultimate valid for encryption
Among all the alternatives suggested,
"authenticated" seemed to count most compelling.
This term is close to trust but different, so it goes
into my original direction (and is probably even better).
So, we could use "authenticated" or "authenticity"
in (G)UI's, while using the technical term
"valid" in details such as tooltips.
So, let's phrase some sentences with it for UI's:
Column: "Key authentication" (instead of "Key Validity")
 would have the following values:
  ultimate, full, marginal
 hmmm, what shall we use for "not valid" ('n')?
Regarding option --trust-level always:
("valid" instead of "usable" or skipping "usable at all).
a) "never (except according to recipient rules)"
b) "if we have authenticated keys for all email addresses"
    with tooltip
    "auto send encrypted if all keys for all email addresses
     are technically valid"
Does it sound useful/intuitive?
I will probably provide a new test version of enigmail
with the option "auto send encrypted",
where I can use this new wording for test purposes.

@_date: 2014-04-27 13:11:35
@_author: Nicolai Josuttis 
@_subject: UI terminology for calculated validities 
Well, the "users" I asked were just ordinary people in my family
(typical smart phone users).
The funny thing is, today I discussed this again with one.
The outcome was surprisingly a renaissance of the term "valid"
but in a slightly different sense.
Valid meaning "validated by me or other people I trust".
And the result was to provide three "trust model" options
in a mailer:
With the following tooltips:
a) only keys validated/signed by me personally
  Tooltip:
      This option is provided to deal with the danger of faked keys,
      not trusting anybody else.
      Validated keys are keys either signed by you or
      signed by other people you trust.
b) only keys validated/signed by my or others I trust
  Tooltip:
      This option is provided to deal with the danger of faked keys,
      trusting other people you categorized as trustworthy.
      Validated keys are keys either signed by you or
      signed by other people you trust.
c) all keys that are neither disabled nor expired nor revoked
  Tooltip:
      This option forces encryption whenever you have
      a key that is not disabled by you or revoked/expired by the owner.
      Because these keys are not necessarily validated
      by you or people you trust, there is a risk
      that you use faked keys so that others than the
      requested receivers can read the content of the encrypted email.
Some of these policies would then be supported by GPG directly,
but I might have to implement one or two in enigmail directly:
a) This would allow only keys where the user locally signed the key
   with at least casual checking
   - Is there an option I can use to have this policy?
b) This would allow keys valid according to the WoT.
   As the current implementation seems only to check the first key
   for an email address, the workaround would have to be implemented
   in enigmail directly.
c) b) but also allow unknown.
   This would match --trust-model always
We might even split option a) in:
a1) allow keys where I personally signed with casual verification
a2) allow keys where I personally signed with extensive verification

@_date: 2014-12-31 14:20:35
@_author: Nicolai Josuttis 
@_subject: The praise of GnuPG @31C3 and why it is important (was: Guys please 
for those who didn't have time to see the talk at 31C3
as a whole and therefore wondering why this is an important talk,
let me point out and quote some content from
with the timepoints to be able to see/hear/double-check it yourself
and some add-ons in [...] to understand the context.
All quotes except the last by Jacob Appelbaum.
26:33 :
 PPTP, ipsec, SSL, TLS, SSH are broken by NSA
31:23 :
 we found that they [NSA] consistently break various different
 types of encryption
33:40 :
 we want to show one PRISM record
 (the record contains:
  "no decrypt available for this OTR encrypted message")
34:22 :
 basically everyone that uses cryptography is broken
 except for two things: OTR and PGP (36:06)
37:08 :
 the sad part is that not everyone is using it
 but the good news is that when you use it it appears to work
 (when you verified the fingerprint for example)
37:38 :
 they [NSA] themselves find that they are blinded
 when you use properly implemented cryptography.
37:46 :
 GnuPG and OTR are two things that actually stop the spies
 from spying on you with PRISM
40:11 :
 if you use redphone and signal,
 if you use something like TOR and GnuPG
 with a properly sized key ...
 if you use OTR
 if you use jabber.ccc.de ...
 if you use encontered together
 you blind them
42:41 :
 Werner Koch [GnuPG], ... could you stand up?
 ...
 Ian Goldberg [OTR], ...
 ...
 Christine Corbett [Signal],
 stand up and keep standing
 ...
 These people without even knowing it and without
 even trying they beat them!
43:55 :
 Laura Poitras:
 Last night I screened my film Citizenfour here ...
 Somebody ask what an they do to support the work that Snowden has done
 and the Journalists.
 ...
 Everybody should fund the work that you guys do ...
 because literally, my work would not be possible without
 the work that you do.
 So, I would like it if everybody in this room when they leave here
 in the next week to reach out and fund these projects
 because without these projects the journalism
 that Glenn [Greenwald] and I and Jake have done
 would literally not be possible
Am 30.12.2014 um 00:51 schrieb MFPA:

@_date: 2014-12-31 16:55:07
@_author: Nicolai Josuttis 
@_subject: The praise of GnuPG @31C3 
Sorry guys, I first wrote these emails as part of another thread.
(Not enough sleep over the last days of 31C3 ...)
But because IMO this is something important for this list,
please allow me to redistribute it as separate thread, again.
For those who didn't have time to see it yet,
there was an important talk at 31C3
about the social and technical status and consequences of
encryption by Jacob Applebaum and Laura Poitras.
As a side effect it covers GnuPG significantly.
So, please watch it completely at:
For those not having enough time let me point out and quote some content
from the talk with the timepoints in the video
to be able to see/hear/double-check it yourself.
I also added sometime some add-ons in [...] to understand the context.
All quotes except the last are by Jacob Appelbaum.
 PPTP, ipsec, SSL, TLS, SSH are broken by NSA
 we found that they [NSA] consistently break various different
 types of encryption
 we want to show one PRISM record
 (the record contains:
  "no decrypt available for this OTR encrypted message")
 basically everyone that uses cryptography is broken
 except for two things: OTR and PGP ([36:06])
 the sad part is that not everyone is using it
 but the good news is that when you use it it appears to work
 (when you verified the fingerprint for example)
 they [NSA] themselves find that they are blinded
 when you use properly implemented cryptography.
 GnuPG and OTR are two things that actually stop the spies
 from spying on you with PRISM
 if you use redphone and signal,
 if you use something like TOR and GnuPG
 with a properly sized key ...
 if you use OTR
 if you use jabber.ccc.de ...
 if you use encontered together
 you blind them
 Werner Koch [GnuPG], ... could you stand up?
 ...
 Ian Goldberg [OTR], ...
 ...
 Christine Corbett [Signal],
 stand up and keep standing!
 ...
 These people without even knowing it and without
 even trying they beat them!
43:55 :
 Laura Poitras:
 Last night I screened my film Citizenfour here ...
 Somebody ask what an they do to support the work that Snowden has done
 and the Journalists.
 ...
 Everybody should fund the work that you guys do ...
 because literally, my work would not be possible without
 the work that you do.
 So, I would like it if everybody in this room when they leave here
 in the next week to reach out and fund these projects
 because without these projects the journalism
 that Glenn [Greenwald] and I and Jake have done
 would literally not be possible
