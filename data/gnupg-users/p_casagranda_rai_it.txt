
@_date: 2001-01-11 09:41:14
@_author: Paolo Casagranda 
@_subject: Batch symmetric ciphering? 
I re-post my question (second and last time, I promise).
My question is: How can I cipher with SYMMETRIC keys in batch mode? (To
automate the task, under MS Windows)
Does anybody know how can be done?
Thank you in advance for any suggestion
 Paolo

@_date: 2001-01-12 08:46:31
@_author: Paolo Casagranda 
@_subject: Batch symmetric ciphering? 
Thank you VERY MUCH for your suggestions. I succeeded in automating
symmetric ciphering under Windows NT (I've heard that under W2000 it's the
I send the lines of code I used, maybe they could be useful to someone.
Automating gpg through pipe WinNT:
 SECURITY_ATTRIBUTES saAttr;
 BOOL fSuccess;
 HANDLE hChildStdinRd, hChildStdinWr;
 HANDLE hSaveStdin, hChildStdinWrDup;
 DWORD dwProcessId;
 // Set the bInheritHandle flag so pipe handles are inherited.
 saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
 saAttr.bInheritHandle = TRUE;
 saAttr.lpSecurityDescriptor = NULL;
 // The steps for redirecting child process's STDIN:
 // 1. Save current STDIN, to be restored later.
 // 2. Create anonymous pipe to be STDIN for child process.
 // 3. Set STDIN of the parent to be the read handle to the
 // pipe, so it is inherited by the child process.
 // 4. Create a noninheritable duplicate of the write handle,
 // and close the inheritable write handle.
 // Save the handle to the current STDIN.
 hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);
 // Create a pipe for the child process's STDIN.
 if( !CreatePipe(&hChildStdinRd, &hChildStdinWr, &saAttr, 0) )
 {
  TRACE0( _T("Stdin pipe creation failed\n") );
  return FALSE;
 }
 // Set a read handle to the pipe to be STDIN.
 if( !SetStdHandle(STD_INPUT_HANDLE, hChildStdinRd) )
 {
  TRACE0( _T("Redirecting Stdin failed\n") );
  return FALSE;
 }
 // Duplicate the write handle to the pipe so it is not inherited.
 fSuccess = DuplicateHandle(GetCurrentProcess(), hChildStdinWr,
 GetCurrentProcess(), &hChildStdinWrDup,
 0, FALSE, // not inherited
 DUPLICATE_SAME_ACCESS );
 if( !fSuccess )
 {
  TRACE0( _T("DuplicateHandle failed\n") );
  return FALSE;
 }
 CloseHandle(hChildStdinWr);
 // Now create the child process.
 PROCESS_INFORMATION piProcInfo;
 STARTUPINFO siStartInfo;
 // Set up members of STARTUPINFO structure.
 ZeroMemory( &siStartInfo, sizeof(STARTUPINFO) );
 siStartInfo.cb = sizeof(STARTUPINFO);
 siStartInfo.dwFlags = STARTF_USESTDHANDLES;
 siStartInfo.hStdInput = hChildStdinRd;
 ///////////////////////////////////////////////////
 // Create the child process.
 BOOL ret = CreateProcess( NULL,
 "d:\\exe\\gpg.exe --yes --batch --passphrase-fd 0 --output
d:\\prove\\encrypted.cfr --symmetric d:\\prove\\d24_final.doc", //
applicatin name
 NULL, // process security attributes
 NULL, // primary thread security attributes
 TRUE, // handles are inherited
 DETACHED_PROCESS, // creation flags
 NULL, // use parent's environment
 NULL, // use parent's current directory
 &siStartInfo, // STARTUPINFO pointer
 &piProcInfo); // receives PROCESS_INFORMATION
 if( ret )
 dwProcessId = piProcInfo.dwProcessId;
 HANDLE hProcessHandle = piProcInfo.hProcess;
 // After process creation, restore the saved STDIN and STDOUT.
 if( !SetStdHandle(STD_INPUT_HANDLE, hSaveStdin) )
 {
  TRACE0( _T("Re-redirecting Stdin failed\n") );
  return FALSE;
 }
 // After process creation, restore the saved STDIN and STDOUT.
 if( !SetStdHandle(STD_INPUT_HANDLE, hSaveStdin) )
 {
  TRACE0( _T("Re-redirecting Stdin failed\n") );
  return FALSE;
 }
 // Passphrase...
 char *lpBuffer = "zuzzurro\n";
 DWORD dwwt;
 BOOL b =WriteFile(
   hChildStdinWrDup,                    // handle to file
   lpBuffer,                // data buffer
   9,     // number of bytes to write
   &dwwt,  // number of bytes written
   NULL
 );
 if(b) MessageBox("OK");
 else
 {
  DWORD dwErr = GetLastError();
  CString str;
  str.Format("Error %lu", dwErr);
  MessageBox(str);
 }
 ::WaitForSingleObject(hProcessHandle, INFINITE); // Wait for process to end
----- Original Message -----
Sent: giovedì 11 gennaio 2001 9.54

@_date: 2001-01-11 09:41:14
@_author: Paolo Casagranda 
@_subject: Batch symmetric ciphering? 
I re-post my question (second and last time, I promise).
My question is: How can I cipher with SYMMETRIC keys in batch mode? (To
automate the task, under MS Windows)
Does anybody know how can be done?
Thank you in advance for any suggestion
 Paolo

@_date: 2001-01-12 08:46:31
@_author: Paolo Casagranda 
@_subject: Batch symmetric ciphering? 
Thank you VERY MUCH for your suggestions. I succeeded in automating
symmetric ciphering under Windows NT (I've heard that under W2000 it's the
I send the lines of code I used, maybe they could be useful to someone.
Automating gpg through pipe WinNT:
 SECURITY_ATTRIBUTES saAttr;
 BOOL fSuccess;
 HANDLE hChildStdinRd, hChildStdinWr;
 HANDLE hSaveStdin, hChildStdinWrDup;
 DWORD dwProcessId;
 // Set the bInheritHandle flag so pipe handles are inherited.
 saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
 saAttr.bInheritHandle = TRUE;
 saAttr.lpSecurityDescriptor = NULL;
 // The steps for redirecting child process's STDIN:
 // 1. Save current STDIN, to be restored later.
 // 2. Create anonymous pipe to be STDIN for child process.
 // 3. Set STDIN of the parent to be the read handle to the
 // pipe, so it is inherited by the child process.
 // 4. Create a noninheritable duplicate of the write handle,
 // and close the inheritable write handle.
 // Save the handle to the current STDIN.
 hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);
 // Create a pipe for the child process's STDIN.
 if( !CreatePipe(&hChildStdinRd, &hChildStdinWr, &saAttr, 0) )
 {
  TRACE0( _T("Stdin pipe creation failed\n") );
  return FALSE;
 }
 // Set a read handle to the pipe to be STDIN.
 if( !SetStdHandle(STD_INPUT_HANDLE, hChildStdinRd) )
 {
  TRACE0( _T("Redirecting Stdin failed\n") );
  return FALSE;
 }
 // Duplicate the write handle to the pipe so it is not inherited.
 fSuccess = DuplicateHandle(GetCurrentProcess(), hChildStdinWr,
 GetCurrentProcess(), &hChildStdinWrDup,
 0, FALSE, // not inherited
 DUPLICATE_SAME_ACCESS );
 if( !fSuccess )
 {
  TRACE0( _T("DuplicateHandle failed\n") );
  return FALSE;
 }
 CloseHandle(hChildStdinWr);
 // Now create the child process.
 PROCESS_INFORMATION piProcInfo;
 STARTUPINFO siStartInfo;
 // Set up members of STARTUPINFO structure.
 ZeroMemory( &siStartInfo, sizeof(STARTUPINFO) );
 siStartInfo.cb = sizeof(STARTUPINFO);
 siStartInfo.dwFlags = STARTF_USESTDHANDLES;
 siStartInfo.hStdInput = hChildStdinRd;
 ///////////////////////////////////////////////////
 // Create the child process.
 BOOL ret = CreateProcess( NULL,
 "d:\\exe\\gpg.exe --yes --batch --passphrase-fd 0 --output
d:\\prove\\encrypted.cfr --symmetric d:\\prove\\d24_final.doc", //
applicatin name
 NULL, // process security attributes
 NULL, // primary thread security attributes
 TRUE, // handles are inherited
 DETACHED_PROCESS, // creation flags
 NULL, // use parent's environment
 NULL, // use parent's current directory
 &siStartInfo, // STARTUPINFO pointer
 &piProcInfo); // receives PROCESS_INFORMATION
 if( ret )
 dwProcessId = piProcInfo.dwProcessId;
 HANDLE hProcessHandle = piProcInfo.hProcess;
 // After process creation, restore the saved STDIN and STDOUT.
 if( !SetStdHandle(STD_INPUT_HANDLE, hSaveStdin) )
 {
  TRACE0( _T("Re-redirecting Stdin failed\n") );
  return FALSE;
 }
 // After process creation, restore the saved STDIN and STDOUT.
 if( !SetStdHandle(STD_INPUT_HANDLE, hSaveStdin) )
 {
  TRACE0( _T("Re-redirecting Stdin failed\n") );
  return FALSE;
 }
 // Passphrase...
 char *lpBuffer = "zuzzurro\n";
 DWORD dwwt;
 BOOL b =WriteFile(
   hChildStdinWrDup,                    // handle to file
   lpBuffer,                // data buffer
   9,     // number of bytes to write
   &dwwt,  // number of bytes written
   NULL
 );
 if(b) MessageBox("OK");
 else
 {
  DWORD dwErr = GetLastError();
  CString str;
  str.Format("Error %lu", dwErr);
  MessageBox(str);
 }
 ::WaitForSingleObject(hProcessHandle, INFINITE); // Wait for process to end
----- Original Message -----
Sent: giovedì 11 gennaio 2001 9.54
