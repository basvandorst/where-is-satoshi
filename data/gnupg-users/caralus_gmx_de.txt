
@_date: 2010-01-15 10:24:30
@_author: Tobias 
@_subject: weird behavior of symmetrically encrypted file 
Hi there,
I have a symmetrically encrypted gpg file I want to decrypt. It seems I
have forgotten the passphrase, because none of the ones I'd usually use
for such a file will work. So I wrote a python script that tries to find
the correct passphrase by brute force. I didn't put much hope in it, but
hey, better to do something else other than agonize about the correct
passphrase, right?
So imagine my surprise when after only a couple of hours my script says
it has found the correct passphrase. I try it and hooray, gpg doesn't
throw the "decrpytion failed: bad key" message. Unfortunately, it still
doesn't decrypt the file. It simply does nothing at all.
# gpg --no-use-agent --passphrase "3ity" usbkey-howto.txt.gpg
gpg: CAST5 encrypted data
gpg: encrypted with 1 passphrase
gpg: WARNING: message was not integrity protected
# ls usbkey-howto.txt
ls: cannot access usbkey-howto.txt: No such file or directory
Why do I get a passphrase ("3ity") which I can't remember having ever
used in my life? Why does gpg regard it as correct but still not decrypt
my file? And apart from these somewhat academical questions: Is there a
way I can use the half-correct passphrase to refine (which means, speed
up) my search for the truly correct one? If I can use it to
significantly reduce the set of possible passphrases, it may save me
some decades worth of blind guessing.
I'm using GnuPG 1.4.9 on Ubuntu 9.04. The encrypted file is attached for
reference. Glad for any help!

@_date: 2010-01-17 03:03:34
@_author: Tobias 
@_subject: weird behavior of symmetrically encrypted file 
Hi Daniel,
thank you for your answer, it helped me a lot. The quick check does
explain the behavior I described in my earlier mail. Your guess is also
good: I have a 6 bit entropy per character. Therefore it is more than
likely that I stumbled into a false positive passphrase within a four
character range.
The next question is whether I can use this to speed up my brute force
attempt. Is it possible to utilize the false positive passphrase for
finding other positives, false or not? My idea is not to try and decrypt
the file with each new passphrase, but to perform the quick check on it
and then compare the result with the result of the false positive. This
way I should be able to rule out negatives fast - at least faster than
by having gpg try every passphrase from scratch (although I'd still have
to see whether it's fast enough to make the brute force attempt
The thing I'm unsure about is which parts of the decryption process I'd
have to apply in order to safely discriminate positives from negatives.
As far as I understand the RFC, it should suffice to compute the
decryption key from the current passphrase and compare it to the key
from my false positive. Is that correct, or am I missing a step here?
