
@_date: 2000-12-08 09:50:55
@_author: explorer@flame.org 
@_subject: Cleaning bad signatures 
I've started using gpg after a long no-pgp break.  Way too long
in fact.  While I generally like gpg more than pgp 5.x under
NetBSD, I have some questions.
One, does --check-sig actually remove bad signatures?  If
not, what does?  I'm getting tired of seeing warning
messages on my screen.
It would be a nice feature to _always_ be able to import
public keys when one has the secret key.  When I moved
things from pgp by importing my secret ring then my
public one, one key I had revoked a very long time ago
was not self-signed.  gpg didn't import it, which was
rather annoying.
It might be handy to have a --assign-ownertrust or
--show-ownertrust command that will scan the public keyring,
and for each key that is verified allow the ownertrust to be
assigned (if not already there) and to show the values
Lastly, do people see the need for a key server that allows
more control over how keys are presented to the outside world?
I'm considering writing one in my non-existant spare time,
and even though I'm largely to blame for the existing
keyserver key management, I think I can do it better if
I find the time.  :)

@_date: 2000-12-08 08:56:57
@_author: Michael Graff 
@_subject: Cleaning bad signatures 
I at least think it would be useful.  Are they at least marked as
bad in some database so they can be skipped when needed?
I was going to use a combination of --list-keys and --with-colons to
dump into a Perl script, but alas, that is _very_ slow.
I know I should Use the Source, but does GPG cache public keys in
memory rather than having to look them up constantly?
Just a quick and dirty dump of the signature tree (assuming that bad
signatures can be marked as such) should not take hours with under
2,000 keys.  PGP is much, much worse in this area.
I may start digging into the source when I can spare the time and
add a few more raw file dumps, either as commands within gpg or
as external tools.

@_date: 2000-12-08 09:50:55
@_author: explorer@flame.org 
@_subject: Cleaning bad signatures 
I've started using gpg after a long no-pgp break.  Way too long
in fact.  While I generally like gpg more than pgp 5.x under
NetBSD, I have some questions.
One, does --check-sig actually remove bad signatures?  If
not, what does?  I'm getting tired of seeing warning
messages on my screen.
It would be a nice feature to _always_ be able to import
public keys when one has the secret key.  When I moved
things from pgp by importing my secret ring then my
public one, one key I had revoked a very long time ago
was not self-signed.  gpg didn't import it, which was
rather annoying.
It might be handy to have a --assign-ownertrust or
--show-ownertrust command that will scan the public keyring,
and for each key that is verified allow the ownertrust to be
assigned (if not already there) and to show the values
Lastly, do people see the need for a key server that allows
more control over how keys are presented to the outside world?
I'm considering writing one in my non-existant spare time,
and even though I'm largely to blame for the existing
keyserver key management, I think I can do it better if
I find the time.  :)

@_date: 2000-12-08 08:56:57
@_author: Michael Graff 
@_subject: Cleaning bad signatures 
I at least think it would be useful.  Are they at least marked as
bad in some database so they can be skipped when needed?
I was going to use a combination of --list-keys and --with-colons to
dump into a Perl script, but alas, that is _very_ slow.
I know I should Use the Source, but does GPG cache public keys in
memory rather than having to look them up constantly?
Just a quick and dirty dump of the signature tree (assuming that bad
signatures can be marked as such) should not take hours with under
2,000 keys.  PGP is much, much worse in this area.
I may start digging into the source when I can spare the time and
add a few more raw file dumps, either as commands within gpg or
as external tools.

@_date: 2002-02-21 17:10:02
@_author: Michael Graff 
@_subject: Getting a key from a keyserver.. 
Hash: SHA1
It was good for me too, using Mailcrypt under Emacs with GNUS.
Evolution has problems it seems -- it also cannot verify things I
sign, even though pine, mutt, etc. all manage it fine.

@_date: 2002-02-21 17:26:01
@_author: Michael Graff 
@_subject: trust values and trusted keys 
Hash: SHA1
 From my ancient PGP memory, I remember there are two things that
control how one trusts a key.
One, the validity of the key, as defined by enough marginal or
complete or ultimate signatures on a given key.  Two, how much you
personally trust that person not to do something foolish.
With PGP 2.x, once a key became valid, it would prompt for trust
settings.  This was a real bother, and I'm glad GPG does not do this.
However, it would be nice to have a way to:
        (1)  list keys with their validity and trust settings
        (2)  scan the list of these for valid keys with unassigned
             trust settings, so one can assign them a trust easily, if
             desired.
Are there tools for this already, and I've just not looked deeply

@_date: 2002-02-21 19:58:01
@_author: Michael Graff 
@_subject: trust values and trusted keys 
Hash: SHA1
While I agree that this works, it is hardly something I'd be able to
tell a non-geek friend to do.  :)
Is the 1.0.6 version of this command basically a no-op?  It _does_
exist, but seems to do little.

@_date: 2002-07-10 02:15:02
@_author: Michael Graff 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
Hash: SHA1
Cool.  A key server DDOS attack is in your future.  :)
That said, it's a good idea, and I considered writing one years ago,
but before EDNS0 there was no real use...
Remember that the max payload (and max rdata size) is still 64k -
headers, so you'll have to handle broken up data even over TCP.

@_date: 2002-07-10 17:51:01
@_author: Michael Graff 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
Hash: SHA1
One of the popular DDOS attacks is to use a multiplier of some sort.
For example, AOL used to have about 26 or so MX records, which just
fit in a 512 byte response packet.  Attackers would forge a source
address on a packet to be some poor victim machine, and send a request
for "aol.com. mx" -- a 63 byte (or so) packet would multiply into a
512 byte packet.  So, the attacker needed but 1/8th the bandwidth of
the target to get this trick to work.
What you're proposing (and I still like the idea, mind you :) is even
worse -- nearly a 1000x increase.  I send you a small packet as a
request, and you send me back up to 64k of data.
Then your server won't hold the most popular keys.  :)
I'd say reserve a flag somewhere in the returned data that means "more
data" and they can just tack on .0 on the end.  And then .1, .2, .3,
etc.  That way, while less efficient, it will work for even large
BTW, remember also that a 64k UDP packet will be fragmented over
nearly every type of wire, and if even one of those fragments are
dropped, the entire packet is lost.
It may be better to limit the EDNS0-sized responses to perhaps 1400
bytes of payload, and use some sort of chaining method to get the full
key data.  Of course, this is not atomic.
You can see why I never actually wrote the thing.  :)
What I was considering was to split the signatures up, and return each
signature in a different packet.  One packet would be the self-signed
key (if it is self-signed, the bare key otherwise) and each following
request would return one signature.  It would stop when it was told to

@_date: 2002-07-10 19:33:02
@_author: Michael Graff 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
Hash: SHA1
Well, a 64k UDP packet will be chopped up into more than 40 packets.
If you're going to do that, why use DNS?

@_date: 2002-07-10 20:16:01
@_author: Michael Graff 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
Hash: SHA1
There is no negotiation.  The sender says "I can receive up to X bytes
in a UDP reply" and the sender will use up to X bytes to reply, or set
the truncated bit.
BTW, I'm one of the authors listed if you do a
        dig authors.bind. chaos txt
to a bind9 server.  :)
