
@_date: 2005-08-03 12:25:33
@_author: Peter Pentchev 
@_subject: Protecting signing key 
I can't speak about EFS, since I'm not familiar with it at all, but that
statement does not have to be necessarily true.  You *can* get by
without storing even a hash of the password on the disk, and it's
actually pretty easy - just encrypt a known-plaintext magic sequence of
bytes using a key derived from the password and store the encrypted
result.  There is also the possibility of generating a random magic
sequence and storing that on the disk in plaintext, too, thus "salting"
the authentication in a different way every time.
Okay, so, come to think of it, this could be called hashing in a way,
and it is still vulnerable to dictionary attacks on the password.

@_date: 2005-08-08 11:29:01
@_author: Peter Pentchev 
@_subject: validate_key_list failed 
FWIW, I've been getting the same with the FreeBSD port of gnupg-1.4.2.
I've reverted to using 1.4.1 for the present.
Peter Pentchev	roam    roam    roam
PGP key:	
Key fingerprint	FDBA FD79 C26F 3C51 C95E  DF9E ED18 B68D 1619 4553
This sentence was in the past tense.

@_date: 2005-10-18 09:47:44
@_author: Peter Pentchev 
@_subject: Encrypt from memory to disc? 
Pipe the data to "gpg -r recipient -e -o outfile.gpg"
The recipient may be specified as either a key ID or an e-mail address
(if it is unique in the public keyring).

@_date: 2005-09-04 17:41:25
@_author: Peter Pentchev 
@_subject: Signing MS-Excel spread sheets 
Hate to point out the obvious, but unfortunately, it just might be that
Berend canNOT control whether his coworkers also use OpenOffice or MS
Excel, in which case the problem of a coworker opening a signed
spreadsheet and invalidating the signature still stands.

@_date: 2005-09-05 21:33:46
@_author: Peter Pentchev 
@_subject: OpenPGP Card 
Hate to jump into this discussion, but isn't this *exactly* why Werner
always keeps mentioning *shared* libraries? :)

@_date: 2006-02-07 23:48:05
@_author: Peter Pentchev 
@_subject: Password length paranoia 
Errr... only for very small values of 95, I'd say ;)  Namely, only
if 95 equals 2... which it doesn't quite seem to :)
Oh, ooookay, so it's more like (95^16 - 1^16) / (95 - 1), which is
only 94 times less than your bid.  But still... :)
Errrrrr... what?!
Straight from bc's mouth:
Okay, so it might not be quite in the feasible range - I'll leave
that for others to judge - but it does seem pretty dramatic to me.

@_date: 2007-08-31 12:29:20
@_author: Peter Pentchev 
@_subject: How to use GnuPG to generate sha512sum hash? 
...or, certainly, echo -n "some string" if you want just the string
without the terminating newline :)  At least on most POSIX-like systems,
that is.

@_date: 2007-12-08 02:42:56
@_author: Peter Pentchev 
@_subject: Validating encrypted files 
[snip more need to know if a file is encrypted or signed correctly]
If you only want to check if the file is encrypted and to what key(s),
you can use --list-packets --list-only; this will list the outermost
packets in the OpenPGP message without doing any decryption.
Among the results there will probably be a packet that looks like this:
:pubkey enc packet: version 3, algo 16, keyid 921EB6497074473C
        data: [1022 bits]
        data: [1024 bits]
You can fish this line out with something like either of the following:
  sed -ne '/^:pubkey enc packet:/ { s/.* keyid //; s/ .*//; p;}'
  perl -nle '/^:pubkey enc packet:.* keyid (\s+)/ and print $1'
The catch with this approach is that it does not actually do any
decryption; the --list-only option takes care of that.  Thus, you cannot
see if the decryption will succeed, you cannot even see if the encrypted
message has been signed before the encryption - the signature packets are
within the encrypted data, --list-only will not analyze them.
If you want to analyze the message within, too, then it would seem the
logical thing that dropping --list-only would achieve some kind of goal;
however, from my limited testing it does not seem so.  A simple invocation
of "gpg --list-packets file.gpg" only shows a "compressed packet" and then
a "literal data packet" line, no signature checking in sight.  Of course,
if the "compressed packet" and "literal data packet" are present, the
decryption was *most probably* successful... but ICBW, and it is much too
late at night for me to actually check the GnuPG source to see if it is
possible for it to display a "literal data packet" and only then notice
that the decryption has failed.

@_date: 2007-12-13 12:37:11
@_author: Peter Pentchev 
@_subject: Backdoor? 
Even if it did have any, do you seriously expect anybody would come out
and say "Yes!" on the official public mailing list? :P
Humor aside, the answer ought to be "no" - although all that I can say
is "almost certainly no", since I have not myself done a full review of
the GnuPG code.  Still, there are lots and lots of people who *have* -
maintainers of GnuPG packages on all kinds of operating systems and
distributions, security researchers hoping for a quick claim to fame,
serious security researchers really interested in the risks of deploying
GnuPG in various kinds of environment...  Since nobody has come up with
anything so far, I personally am confident enough that, no, GnuPG does
not have any backdoors.
And just by the way, it really ought to be "backdoor", not "trapdoor",
when you are speaking about cryptography - because, strictly speaking,
GnuPG *does* implement various trapdoor algorithms, but that is actually
a very, very good thing :)

@_date: 2007-02-08 17:51:03
@_author: Peter Pentchev 
@_subject: gen-key non-interactively 
If you are trying to do this as part of a bigger program, you might
want to check out the gpgme and libgcrypt libraries.
Otherwise, the gnupg manual page mentions an experimental method for
using --gen-key non-interactively, which is described in the DETAILS
file in the doc/ subdirectory of the gnupg source archive.  Thus, you
need to download the gnupg source (either 1.4.x or 2.0.x, depending on
which version you're using anyway), read the doc/DETAILS file, and see
if the method described there works for you.  I just tried it with
GnuPG 1.4.6, and it worked just fine here.

@_date: 2007-02-08 17:01:30
@_author: Peter Pentchev 
@_subject: Keyrings for websites 
It ought to be both possible and trivial.
ISTR several discussions on this mailing list, where people mentioned
using PGP keys (or rather, uid's) with only names, no e-mail addresses.
You could either use such keys with the hostname (or the full path to
the web application) placed directly in the "name" part of the user ID,
or develop some kind of machine-readable encoding to represent a host
name, application path, application name, or any level of detail you
feel comfortable with, and then place those in the "name" or the
"comment" part of the key's user ID.  After that, proceed as usual -
sign the user-ID with the key itself (GnuPG should do that as part of
the key generation anyway), sign it with your own key, and send the
public key to the others.  They should generate keys for their web apps
too, sign them with their own (developers') keys, and send them to you.
Then each of you establishes his own trustdb, places trust in (some of)
the developers' keys, and off you go.

@_date: 2007-02-14 10:22:19
@_author: Peter Pentchev 
@_subject: Compiling GnuPG 2.0.1 on MacOS X 
Is there any reason for not using execv(3)?
(disclaimer: not tested on PPC or MacOS X or, really, anything besides
FreeBSD/i386 and Debian/i386...)
   __unused
 defined(__GNUC__) && !defined(__INTEL_COMPILER)
 __unused	__attribute__((unused))
	/* __GNUC__ */
 defined(__INTEL_COMPILER)
 __unused	__attribute__((__unused__))
	/* __INTEL_COMPILER */
 __unused
	/* __INTEL_COMPILER */
	/* __GNUC__ */
	/* __unused */
 APP	"/Applications/pinentry-mac.app/Contents/MacOS/pinentry-mac"
int main(int argc __unused, char * const argv[])
Of course, you may skip the whole __unused dance if you know that you
are only ever going to compile it on a single OS/arch/compiler - or if
you don't care about compiler warnings :)
The above will take care of passing command-line arguments; the executable
location might be handled by a symlink or something.

@_date: 2007-11-01 10:54:31
@_author: Peter Pentchev 
@_subject: GPG fails to encrypt 
Try getting an actual error message - that should help point to an
actual problem :)
There are several ways you could look for an error message, and most of
them involve writing a simple shell script wrapper for gpg and having
Vitria invoke the script instead of the gpg binary itself.  Maybe
something like the following could help (and yes, I'm aware of all the
security problems within - predictable filenames, file/directory
permissions and stuff):
set -e
$GNUPG "$ > "$STDOUT" 2>"$STDERR"
echo "The GnuPG process's exit code is $errcode" >> "$STDERR"
exit "$errcode"
To use it, create a directory /tmp/gpg writeable by the user that Vitria
should run as, then make Vitria execute it instead of the actual gpg
binary.  As a result, each time Vitria tries to run GnuPG, you'll get
two files in the /tmp/gpg directory containing the data that gpg sent to
its standard output and its standard error streams, and the exit code.
If this does not help a whole lot, you could put an strace or ltrace or
something like that in the script for further information gathering.
Hope that helps!

@_date: 2008-12-12 15:53:28
@_author: Peter Pentchev 
@_subject: How to Append an Encrypted file with new data(file). 
This was discussed on this list last month; the short answer is,
"you can't do this".  A slightly longer answer is "you might be
able to do something like that by ASCII-armoring the separate files
(encrypted) and then appending them to the .gpg file".  This ought
to be doable even with MS-DOS batch files, if they have grown
the capability to test if a file exists; granted, I've not looked at
the extensions to the MS-DOS batch file language since sometime
around version 4.0 or so, and my memories are a bit stale.
For the full discussion, take a look at

@_date: 2008-07-11 13:38:59
@_author: Peter Pentchev 
@_subject: key generation in a script or non interactive mode? 
I usually do something like "find / -print0 | xargs -0 cksum", but that,
of course, assumes that the kernel will gather entropy from the disk.
Aye, this is a good article indeed, worth reading by both sysadmins and
everyone else who is interested in randomness :)

@_date: 2008-07-11 13:35:28
@_author: Peter Pentchev 
@_subject: make data available for a certain amount of time 
Errr, that's a bit off-topic, but it is *much* easier to do that with
shar (in the base system on most OS's, or in a package named sharutils
or similar on most Linux distributions).
Of course, shar wants to encode the binary data and thus makes the file
a bit bigger than just a binary blob, but this is actually a good thing
in view of all the weird and wonderful (not!) ways that various shells
treat "special", "graphical", and other interesting characters.

@_date: 2008-07-24 13:53:27
@_author: Peter Pentchev 
@_subject: so how do you get others to sign your key? 
And then there are things like  ... :)
But let's not feed the troll any more :)

@_date: 2008-06-11 23:55:18
@_author: Peter Pentchev 
@_subject: LD_PRELOAD attack 
Nope.  None of these is true.  If an attacker has access to *your*
account, he has perfectly good access to your shell startup files,
and he is perfectly capable of changing your PATH to include
a directory of his choosing where he may place any binaries he
wants to - and your shell will happily execute them instead of
the real system binaries.
Or maybe you are in the habit of auditing your .*shrc and .*sh_profile
files after each and every login?  And then auditing the pager or
editor that you audited them with?  If so, my hat's off to you, Sir,
but this is a level of paranoia that I'm not quire comfortable with :)
This, too, is true.
True, too, except that an attacker with access to your account really
does have at least seven ways (that pop up in my mind without even
thinking too hard) of replacing the gpg or pinentry or whatever
binaries without you noticing *at once*.

@_date: 2008-06-30 13:56:48
@_author: Peter Pentchev 
@_subject: Problem in case decrypting large file size 
Assuming you meant two *giga*bytes, not two kilobytes, I think
the most common work-around is to pass the encrypted data on
gpg's standard input and read the decrypted data from its standard
output.  That is, instead of doing something like:
  gpg -d file.txt.enc
and expecting to get a file.txt after a successful decryption, do this:
  gpg -d < file.txt.enc > file.txt
Of course, the exact invocation depends on your programming language,
libraries and stuff (you may invoke a shell and pass it this command
with the redirections, or you may fork off a process and reopen its
file descripts 0 and 1, or...), but that's the general idea.
Hope that helps.

@_date: 2008-05-10 11:37:19
@_author: Peter Pentchev 
@_subject: how long should a password be? 
[snip Sven Radde's explanations about the salt]
It seems that you are missing another important point about the salt -
it is generated randomly each and every time something needs to be
encrypted :)  There is no such thing as "the salt value for this user";
every time this user wants to hash a password, the system generates
a random salt value and hashes this particular password, just this once,
with this value.
Hope that helps :)

@_date: 2008-10-06 12:35:48
@_author: Peter Pentchev 
@_subject: Bypass Invalid Public key 
I'm not sure that what you're asking would be such a good idea; after
all, it boils down to "let GnuPG report success even if it did not
really do most of what you asked it to, with no real way of knowing
which parts it did do and which parts it didn't" :)
IMHO, an alternative would be to actually *ask* it which keys it does
have before attempting the encryption; you can do something like:
  gpg --list-keys --with-colons 16194553 87E057BE 5DBFAB91
...and then look for the lines beginning with "pub".  If this is
a Unixish environment, you could try filtering the output through
  awk -F: '$1 == "pub" && $12 ~ /E/ { print $5 }'
..or, of course, just use your programming language's text processing
capabilities to extract the fifth field of the "pub" lines that contain
an "E" character in the twelfth field :)  All of them will identify
valid public keys that GnuPG can actually encrypt to (the uppercase 'E'
signifies exactly that, according to the doc/DETAILS file in the GnuPG
Hope that helps :)

@_date: 2008-10-06 13:33:09
@_author: Peter Pentchev 
@_subject: Bypass Invalid Public key 
Oookay, okay, I know, I know, I know - you *can* try running GnuPG on
the *encrypted* file later and find out which keys it is actually
encrypted to, but in my book, that goes under "nonsensical effort".
[almost snip my "--list-keys --with-colons output processing" suggestion]
That part still stands :)

@_date: 2009-04-08 16:10:35
@_author: Peter Pentchev 
@_subject: Help Solicited to implement a new pgp key server 
Is there a reason why you can't use any of the existing keyserver
Avoided: Preferred: If you need it in C/C++ for better integration with your application,
that's another thing.  Still, even in that case, you might want to
take a look at the SKS source to see how things are done.

@_date: 2009-04-17 16:01:45
@_author: Peter Pentchev 
@_subject: syntax for encrypting only the string passed in an argument 
I don't think GnuPG supports this syntax; however, you can do it
somewhat indirectly by:
  echo $variableY | gpg -e -r Joe -o var_y.txt.gpg
You could even write a simple program (or shell script, or Perl script,
or something) that uses the mktemp() or mkstemp() standard C library
functions, or the mktemp(1) command-line utility, creates a temporary
file, has GnuPG output to it, displays it, and removes it.
Actually, come to think of it, here's a shell script and a Perl script
that do that - down there, right after the signature.  Hope you can
at least read the code to see the ideas if you can't use them directly :)
Caveat emptor: the shell script does not deal very well with recipient
names containing whitespace or special characters!  Also, the use of
"echo ... | gpg" makes it susceptible to a "ps awwfux" attack whereby
somebody who runs a "ps" command on the right server at the right time
might see the arguments to the "echo" command in the process list and
learn what you want to encrypt.
Hope that helps!

@_date: 2009-04-22 22:27:38
@_author: Peter Pentchev 
@_subject: Further thoughts on Windows Install 
No.  That's what --export does by default.  He would just have to
add --export-secret-keys to *also* get his own secret keys :)
No.  That's what --export-ownertrust does.
Yes, that's true.  However, this could lead to problems if some day
the format of GnuPG's keyring files should change, and especially
if it should change in some architecture-specific way.
Well, the config file could be copied, it's plain text.  The issue
here is that the keyring files are not guaranteed to be in any kind
of format that is compatible with anything else, including a GnuPG
version on any other architecture or even another GnuPG version on
the same architecture.  Well, of course, it would be a pain if
a future GnuPG version would not be able to read the current version's
files, but it *could* happen one day.  Of course, I'm NOT speaking
for the GnuPG developers in any way!  It's just what I gather from
the glaring lack of any mentioning of the format of the keyring files
in any official documentation - IMHO, that's on purpose, and it's
completely understandable and a good thing, too :)
The only guaranteed, portable way to transfer one's keyrings is
by running GnuPG three times:
  gpg --export --armor > pubkeys.txt
  gpg --export-secret-keys --armor > seckeys.txt
  gpg --export-ownertrust > ownertrust.txt
...then copying those files over to the other installation and
importing them there with the --import, --import-secret-keys, and
--import-ownertrust options.
Still, for the present, all keyrings on all versions of GnuPG seem
to be compatible, so, *for the present*, it is easier to just copy
the files over.  The whole point is, that's not guaranteed to work
forever :)

@_date: 2009-04-29 16:40:47
@_author: Peter Pentchev 
@_subject: How easy would it be to create (and prevent the creation of) a 
...like, for example, your OpenPGP-powered Jabber client suddenly
needing to reconnect after something happened to the network and
you simply didn't notice? :>

@_date: 2009-02-05 13:45:29
@_author: Peter Pentchev 
@_subject: gpg: failed to create temporary file 
And then, of course, it's possible that this is a Linux system which
has bash installed as /bin/sh :)  And then, of course, it's possible
that this is a *reasonable* Linux system with something else, e.g.
dash or ash or something, installed as /bin/sh, in which case Joseph's
recommendation holds.
This is also true.
Yep, this is the only way to be sure.

@_date: 2009-02-07 17:34:34
@_author: Peter Pentchev 
@_subject: Need a command to suppress 
I think what Ingo meant was that these greps might do both more and
less than you actually intend them to.
More: if those grep's are done on the full output of, say, gpg --decrypt
or something similar, then they could also remove *actual text*, not just
gpg's status output.  This could be... well, let's just say "bad" :)
Less: have you actually bothered to check the result of either
"gpg --verify ... | grep -v" or "gpg --decrypt ... | grep -v" ?
In both cases, gpg sends the status information to the standard error
stream, NOT the standard output stream, so "grep" does, erm, nothing
with it :)
Both of those issues are addressed by Ingo's idea of using --status-fd
or, even better, --status-file instead.

@_date: 2009-07-20 13:08:52
@_author: Peter Pentchev 
@_subject: gpg -u problem 
That should be "gpg -k 5E95FE19 -d 00poap/gpg", not "-u".
Either use -u 'Real Name' or -k keyid; in this case, 5E95FE19
is the key ID, not the user ID attached to this key.

@_date: 2009-06-05 01:32:41
@_author: Peter Pentchev 
@_subject: gpgshell and gnupg 2.x? 
Errr, unless I'm badly mistaken, gpg-agent doesn't come with GnuPG 1.4.x
and to build and use it, you need some of those component libraries.
And, at least for me, gpg-agent is a very, very comfortable and
convenient tool.

@_date: 2009-06-24 16:59:19
@_author: Peter Pentchev 
@_subject: Any UNIX API for GPG available? 
What exactly are you looking for?
If you want to encrypt, decrypt, sign, or verify OpenPGP messages
from a program you are writing, and you want to use GnuPG for
this, you may take a look at the "GnuPG Made Easy" library -
Once you download and install it, there will be a gpgme.info file
which you may examine through any texinfo browser, such as
the "info" or "pinfo" command-line tools.
If that's not what you mean by "UNIX API documentation for GPG",
you'll have to explain a bit better what you are looking for :)
Hope that helps.

@_date: 2009-05-22 00:04:23
@_author: Peter Pentchev 
@_subject: Checking for interactive shell sessions [Was: Re: Can't enter 
Just BTW, a *much* more reliable way to check for an interactive
session, which will not fail in many common cases (PS1 set in system-wide
config files, PS1 also set in .bashrc, PS1 set in the environment of
the calling shell, etc.), is the following:
# First, set up all variables for both interactive and non-interactive
# sessions.
# Then, do this:
case "$-" in
        *i*)
                echo 'Setting up interactive shell params..'
                stty erase ^H
                ;;
Of course, substitute your own commands for the "stty" and the assignment :)
Bear in mind that this only applies to Bourne-style shells;
for tcsh, you might need to resort to testing for ($?prompt), indeed.

@_date: 2009-11-25 13:44:35
@_author: Peter Pentchev 
@_subject: how to properly verify a signature from a program? 
That's pretty much what you should do, with just one addition:
add --status-fd=1 to the GnuPG command line.  When you do that, gpg
will output something like the following to file descriptor 1 (stdout):
[GNUPG:] SIG_ID eLbkcOT0G/i0ugaTvtB5kkRMJc0 2009-11-25 1259148663
[GNUPG:] GOODSIG 651EEFB02527DF13 Peter Pentchev [GNUPG:] VALIDSIG 2EE7A7A517FC124CF115C354651EEFB02527DF13 2009-11-25 1259148663 0 4 0 1 10 01 2EE7A7A517FC124CF115C354651EEFB02527DF13
[GNUPG:] TRUST_ULTIMATE
Of course, the output *will* be different in your case, what with dates,
key ID's and such :)  Also, of course you can use a different value for
the file descriptor (like 2 for stderr, but then this output will be
mixed with the rest of GnuPG's freeform messages), just make sure your
program can read what GnuPG writes to that fd :)
Hope that helps.

@_date: 2009-11-25 13:49:47
@_author: Peter Pentchev 
@_subject: how to properly verify a signature from a program? 
And then again, if you're writing in C, C++, or any language that can
invoke routines in a shared library described in a C header file, there
is also another way to do it - use the GPGME (GnuPG Made Easy) library.
It provides functions that will verify a signature and return a list of
signature structures, each of which will contain the fingerprint of
the signing key.

@_date: 2009-09-04 09:49:34
@_author: Peter Pentchev 
@_subject: UI enhancement request 
But he still has to issue the same command several times after
selecting each and every UID in turn.  "uid *" could indeed be
a useful feature, although it might be not too easy to implement.

@_date: 2010-08-31 14:36:36
@_author: Peter Pentchev 
@_subject: Encryption with no recipient 
Is "gpg -c filename" (or "gpg --symmetric filename") useful to you?

@_date: 2010-07-12 10:58:39
@_author: Peter Pentchev 
@_subject: Decrypting file encrypted for multiple recipients using a 
A possible workaround would be to create a separate secret keyring that
only contains user B's secret key.  I agree, it's not perfect, and it would
entail explicitly specifying "--no-default-keyring --secret-keyring ..."
and maybe also "--keyring ...".
Alternatively, you could create a different ~/.gnupg/ directory and
symlink all files *but* the secret keyring to your "real" ~/.gnupg/, then
create a minimalistic secret keyring there containing only user B's key.
This would mean setting GNUPG_HOME each time you want to use this keyring,
so it's still not perfect.
It's quite possible that there are simpler ways, I just can't think of them
right now :)

@_date: 2010-07-20 11:55:58
@_author: Peter Pentchev 
@_subject: setuping local/standalone keyserver 
Start from I don't know if anybody has made an RPM of that; probably somebody has,
but I'm not familiar enough with the various RPM distribution channels
to check :)

@_date: 2010-06-30 13:58:18
@_author: Peter Pentchev 
@_subject: Digitally Sign a key 
Take a look at the gpg2 documentation - the manual page says and even has
an explicit example of using both the -s and the -e options:
       gpg -se -r Bob file
              sign and encrypt for user Bob
Of course, you can point to a more specific recipient's key by giving either
an e-mail address or, better yet, a key ID instead of "Bob" to the -r option;
and you can specify which key to sign with using the -k option if you have
more than one secret key on the GnuPG installation where you're running this.
Hope this helps.

@_date: 2010-03-15 12:58:27
@_author: Peter Pentchev 
@_subject: Restarting gpg-agent 
A good idea, and well written :)  Just one minor thing...
In this way, you risk a false positive if gpg-agent has died (or not
been started at all, but a .gpg-agent.info file has been left over)
and there is another process with the same process ID.  This *can*
happen, whether by random chance at system startup, or by random
chance on a long-running system with PID's wrapping around.
A slightly better (if somewhat more convoluted) way could be
something like:
if [ -n "${GPG_AGENT_INFO}" ] && [ -r "$GA_INFO_FILE" ]; then
if [ -n "$gpg_agent_pid" ] &&
   expr "x$gpg_agent_pid" : 'x[0-9]*$' > /dev/null; then
if [ -n "$gpg_agent_running" ]; then
Please don't take this as criticism, just an idea :)  And, of course,
it assumes that the OS has pgrep(1).

@_date: 2010-05-13 11:59:14
@_author: Peter Pentchev 
@_subject: Encryption to key with multiple subkeys 
Just for the record: no, the encrypted message will not be much larger.
The way OpenPGP encryption works is that a new, random, once-only
session key is generated each time you want to encrypt a message to one
or more recipients; the message itself is encrypted using a symmetric
algorithm, and only the session key is encrypted using the asymmetric
algorithm specified by the users' OpenPGP encryption keys.  Thus, only
the session key (a couple of hundred bytes at most, and usually just
a couple of dozens of bytes) will be encrypted over and over again
for each recipient's encryption key - and, in the case discussed, for
each encryption subkey of each recipient's key.
Well, of course, if you're encrypting a single-byte message,
the overhead might be detectable... :)

@_date: 2010-11-09 09:57:50
@_author: Peter Pentchev 
@_subject: How to send encrypted data in an xml file 
The ASCII-armoured message format is defined in section 6 of RFC 4880;
it always includes newlines.
Have you thought about including the ASCII-armoured signature in
a CDATA section of your XML file?  Or, alternatively, "simply" encoding
the line break characters as  and  as specified in section 2.11
of the XML 1.0 specification?
If neither of those is possible, you could always try to encode
the signature in some other way - e.g. take a binary signature and represent
the string of octets as text in some way... of course, that would mean
the recipient would have to know exactly how to decode it.

@_date: 2010-10-08 10:41:22
@_author: Peter Pentchev 
@_subject: batch file automation -Nearly There! 
Erm... on this line, where are you telling GPG to actually encrypt the %F file?

@_date: 2011-04-16 21:00:25
@_author: Peter Pentchev 
@_subject: [OT] passphrases Was: Re: Allowing paste into pinentry-gtk-2? 
Uhm, somewhat off-topic (so marked in the subject line), and... I really
don't want to start a flamewar here, but there really, really *is* a bit
of a middle ground between a "short, insecure passphrase" and a "long,
randomly-generated one that simply must be copy/pasted" - namely, a
long, non-randomly generated one that can be written out "by hand" :)
Mine, for instance, is over 30 characters long and, while it is derived
from a couple of phrases, none of its components would be found by any
reasonable brute-force or even dictionary attack, even by people who
know me (please note that I did say "reasonable" WRT resources).

@_date: 2011-04-18 12:07:51
@_author: Peter Pentchev 
@_subject: GPG not retrieving keys when verifying 
...and you really, *really*, REALLY don't want to do this automatically
and recursively :) (okay, so you fetch the keys that signed this key, now
what about the signatures on them - do you fetch them too? and the sigs
on those again? when do you stop?)

@_date: 2011-04-18 14:24:30
@_author: Peter Pentchev 
@_subject: --s2k-count: correct value in config file needed? 
For questions like this, it's always best to look at the authoritative
source for the format of various OpenPGP data - RFC 4880 :)  From the way
I read section 5.5.3 (Secret-Key Packet Formats) and then Section 3.7.1
(String-to-Key (S2K) Specifier Types) it would seem that the answer to your
question is yes, the S2K count is stored in the secret key packet.

@_date: 2011-08-27 02:45:26
@_author: Peter Pentchev 
@_subject: Which release should we be using? 
Yep, I was just going to comment that it's obvious that Randall Munroe
reads this list :)

@_date: 2011-03-11 12:54:24
@_author: Peter Pentchev 
@_subject: non-exportable OpenPGP certifications [was: Re: hashed user IDs ] 
All the GnuPG command-line commands and options may be abbreviated to
a unique, unambiguous starting part of their names.  Try gpg --clearsi
or gpg --cl, for instance :)

@_date: 2011-03-11 20:30:30
@_author: Peter Pentchev 
@_subject: Compression used in an encrypted message 
If the file has been encrypted to you (or, more specifically, to
one of the secret keys currently accessible to you), then, yes, you
most probably can - "gpg --list-packets filename" should tell you
what compression algorithm has been used, then it's just a matter of
looking it up in RFC 4880 :)
If the message has been encrypted to someone else's key, then you
most probably won't be able to examine it - at least GnuPG does
the compression before the encryption, so that the information about
the compression algorithm used is contained within the encrypted data.
You may still give it a shot with --list-packets, but don't expect
too much :)
Hope that helps.

@_date: 2011-03-21 10:17:42
@_author: Peter Pentchev 
@_subject: Keyservers 
And (as pointed out even on this thread), lately, also GMail and
its default settings.

@_date: 2011-05-12 13:07:37
@_author: Peter Pentchev 
@_subject: How do I list all recipient of a message (including myself)? 
Well, there's always gpg --list-packets --with-colons, which outputs
something like:
:pubkey enc packet: version 3, algo 1, keyid 08D014DED0B337AA
        data: [4095 bits]
:pubkey enc packet: version 3, algo 16, keyid 921EB6497074473C
        data: [1024 bits]
        data: [1021 bits]
:encrypted data packet:
        length: 69
        mdc_method: 2
:compressed packet: algo=2
:literal data packet:
        mode b (62), created 1305194688, name="foo.txt",
        raw data: 4 bytes
...so just look for the "pubkey enc packet" lines, get the key IDs and
possibly pass them through another round of "gpg --list-keys --with-colons"
or something.

@_date: 2011-09-20 23:04:53
@_author: Peter Pentchev 
@_subject: Posting rules for the gnupg-devel@ mailing list 
Not necessarily.  I believe that this is just greylisting in action -
In short, if your mailserver is well-behaved and retransmits the message
within a reasonable timeframe (usually a couple of hours would be enough,
although most mailservers will retry in less than an hour), the gnupg.org
server will accept your message and everything will be just fine.
Of course, the gnupg.org mail admins are free to jump in and correct me :)

@_date: 2013-04-05 11:50:46
@_author: Peter Pentchev 
@_subject: Fingerprint of the subkey just created? 
If *you* want to see the fingerprint, that's fine.  If you want to
write a *program* that needs the fingerprint, then --with-colons is
pretty much mandatory, since it avoids all the issues of changing
messages, localized messages, weird characters that might be mistaken
for parts of messages, etc.
Of course, for writing programs that interface with GnuPG, it's best
to go all the way and use GPGME, but for some simple tasks the output
of --with-colons is exactly right.
I didn't know about --fixed-list-mode; thanks!

@_date: 2013-05-01 15:44:09
@_author: Peter Pentchev 
@_subject: random_seed - no locks available 
Werner already replied on this one - len == 0 has a special meaning and
should indeed be correct here.
Actually this would be my first question to the original poster - is
there any chance that your home directory is remotely mounted using NFS
or some other remote filesystem protocol for which your kernel does not
really support file locking?  (I have seen quite some usage of user home
directories exported via NFS in shared environments, e.g. universities)
If it is NFS, you might want to look into enabling file locking using
something like the "nfslock" service, rpc.lockd or something similar on
both the client and the server, just in case.

@_date: 2013-05-02 03:09:54
@_author: Peter Pentchev 
@_subject: random_seed - no locks available 
Just in case it wasn't clear, by "you" in these two paragraphs I am
referring to the original poster, M Russell, and not to Henry Hertz

@_date: 2013-10-03 14:33:32
@_author: Peter Pentchev 
@_subject: GPG2 encryption options 
If the contents of the keyfile "looks like" a single line of text (e.g.
a passphrase), then you can use gpg --symmetric (or -c for short) and
pass the file in using the --passphrase-fd option.  The simplest way to
do it is to pass the file on the standard input and specify 0 as the
number of the file descriptor for the passphrase:
  gpg -c --passphrase-fd 0 somefile.doc < keyfile.txt
This command should create a somefile.doc.gpg file that you may later
decrypt by:
  gpg -d --passphrase-fd 0 somefile.doc.gpg < keyfile.txt
Of course, you do not have to use the standard input for this; some
shells will allow you to open a new file descriptor for reading from a
  gpg -d --passphrase-fd 7 somefile.doc.gpg 7< keyfile.txt
Hope this helps!

@_date: 2013-10-03 14:35:34
@_author: Peter Pentchev 
@_subject: GPG2 encryption options 
But then, of course, everything that Peter Lebbing said about caching
the passphrase or using a smartcard that caches the PIN for a limited
amount of time is true.  I personally have never found it much trouble
to have gpg-agent prompt me for my passphrase after a couple of minutes.

@_date: 2013-09-25 17:14:52
@_author: Peter Pentchev 
@_subject: Magic numbers for keyring files? 
AFAIK, a GnuPG keyring (as well as a PGP Inc. keyring) is just a
concatenation of the (binary representation of the) public/private keys
stored there.  Thus, the file format you're looking for is the file
format of an OpenPGP key as defined by, yeah, you guessed it, RFC 4880
Of course, I could be wrong, but I really don't think that GnuPG stores
anything more than that - and an easy way to test that is to point
Bernhard Link's gpg2txt -  or
 - or Kazu Yamamoto's pgpdump -
 - at your secring.gpg or
pubring.gpg file; they will display a sequence of packets comprising one
or more OpenPGP keys.
So what you need to look for is sequences of bytes matching the OpenPGP
format; this usually means packets of type 5 for private keys or 6 for
public ones.  Unfortunately the first bytes will vary with 1. the format
version and 2. the packet (key) length, so there is no exact marker.
Still, file(1) does it somehow; you might want to look at file's source,
at its magic database, to see the heuristics it uses.
In general I would guess it could be something like (all in hex):
- 94 xx: xx bytes of private key data, tag 5, old format packet length
- 95 xx yy: xx*256+yy bytes of private key data, tag 5, old length
- 96 xx yy zz: xx*65536 + yy*256 + zz bytes of the same
- C5 xx: xx (less than 192) bytes of private key data, tag 5, new length
- C5 xx yy: (xx-192) * 256 + yy bytes of private key data, tag 5, new
- C5 FF xx yy zz tt: up to 4 GB of private key data, tag 5, new
- 98 xx: xx bytes of public key data, tag 6, old format packet length
- 99 xx yy: xx*256+yy bytes of public key data, tag 6, old length
- 9A xx yy zz: xx*65536 + yy*256 + zz bytes of the same
- C6 xx: xx (less than 192) bytes of public key data, tag 6, new length
- C6 xx yy: (xx-192) * 256 + yy bytes of public key data, tag 6, new
- C6 FF xx yy zz tt: up to 4 GB of public key data, tag 6, new
Then you should match the first bytes of the packet itself; it would
probably start with a 04 (version) xx yy zz tt (timestamp), algorithm,
Hope that helps :)

@_date: 2013-09-26 00:02:28
@_author: Peter Pentchev 
@_subject: Generation of key ID's 
Of course, I cannot speak for the designers of the PGP and later OpenPGP
key format, but...  Um.  When assigning identifiers to pieces of data
created randomly by independent parties all around the world with no
means of communication or synchronization, it makes perfect sense that
the identifier would be some kind of hash over both information supplied
by the person generating the piece of data and information generated
randomly, that is, part of the data.  So it makes perfect sense that the
identifier should be some kind of a hash over parts of the PGP key
Furthermore, the identifier should not change when the key owner makes
modifications to the key itself, so it may not include user IDs or
signatures made either by the owner or other people after the key has
been generated.  What does not change in a PGP key?  Well, obviously,
the key parameters themselves: the algorithm, the numbers comprising the
key (be they primes or curve specifiers or whatever).  In addition, a
key may only be created once, so the creation time is not supposed to
So there you have it - a long, long time ago, in a galaxy far, far away,
the V3 key fingerprint was formed by hashing only the key parameters;
they obviously characterize this key and they obviously will not change
with time as this key is being used.  Then, in V4 of the format, more
information was included, but once again, all of it is not supposed to
change with time.
As an additional benefit, hashing the public key material also provides
a quick and quite reliable way to make sure that the public key itself
has not been damaged in transit.
Note: in this text I repeatedly referred to "PGP keys" and not "OpenPGP
keys" because, unless I am gravely mistaken, both the V3 and V4 key
formats were designed before (okay, V4 was almost at the same time as)
the OpenPGP Alliance was formed.

@_date: 2013-09-27 17:33:59
@_author: Peter Pentchev 
@_subject: GPG Private Key Export Question 
It's part of the secret key packet.  If you run gpg --list-packets with
--debug=2 (or with --debug-all), so that it shows you the actual numeric
data in the key representations, you'll see that skey[0] and skey[1] in
the secret key packet are exactly the same as pkey[0] and pkey[1] shown
when you --export | --list-packets (so GnuPG shows you the public key).

@_date: 2013-09-27 17:40:10
@_author: Peter Pentchev 
@_subject: GPG Private Key Export Question 
Also, if you're really writing software for parsing and extracting data
from OpenPGP keys or messages, then you absolutely *must* start by
reading RFC 4880, then reading it again, then bookmarking it and keeping
it always open in a browser window or a text pager, so you can refer to
it as often as you *will* need to :)

@_date: 2014-01-02 18:11:33
@_author: Peter Pentchev 
@_subject: Bug: --list-packets ignores second public key 
Hm, which version of GnuPG are you using?  With both 1.4.15 and 2.0.22
on my Debian GNU/Linux system I can see a second 'public key packet':
[roam at straylight ~/tmp/v/roam/pgp]$ gpg --list-packets foo.txt | egrep -ve '^[[:space:]]'
:public key packet:
:user ID packet: "Christian Westphal (always use together with 0x73C0BB28) "
:signature packet: algo 1, keyid 1AC1BFC93FFF6951
:signature packet: algo 1, keyid A642416973C0BB28
:user ID packet: "Christian Westphal "
:signature packet: algo 1, keyid 1AC1BFC93FFF6951
:signature packet: algo 1, keyid 1AC1BFC93FFF6951
:user ID packet: "Christian Westphal "
:signature packet: algo 1, keyid 1AC1BFC93FFF6951
:signature packet: algo 1, keyid A642416973C0BB28
:public sub key packet:
:signature packet: algo 1, keyid 1AC1BFC93FFF6951
:public sub key packet:
:signature packet: algo 1, keyid 1AC1BFC93FFF6951
:public key packet:
:user ID packet: "Christian Westphal "
:signature packet: algo 1, keyid A642416973C0BB28
:user ID packet: "Christian Westphal (always use together with 0x3FFF6951) "
:signature packet: algo 1, keyid A642416973C0BB28
:signature packet: algo 1, keyid 1AC1BFC93FFF6951
:public sub key packet:
:signature packet: algo 1, keyid A642416973C0BB28
:public sub key packet:
:signature packet: algo 1, keyid A642416973C0BB28
[roam at straylight ~/tmp/v/roam/pgp]$ The 15th line of the output is ':public key packet:'.

@_date: 2014-11-21 09:56:02
@_author: Peter Pentchev 
@_subject: problems with pinentry-0.9.0 (Werner Koch) 
If you need to build programs with GTK+ 2.0 support, the package that
you need to install is usually named something like libgtk2.0-dev on
Debian-like systems.
This information is actually available if you have "deb-src" lines in
your /etc/apt/sources.list, so that Apt can download information about
source packages; then you can try the following:
apt-cache search -n pinentry
(see that it shows a pinentry-gtk2 binary package)
apt-cache show pinentry-gtk2 | less
(it will tell you "Source: pinentry")
apt-cache showsrc pinentry
It will give you a list of packages in the Build-Depends field; those
are packages that the Debian package of pinentry needs so that it can
build properly with full support for all the backends.  You might
consider installing at least some of them.

@_date: 2014-10-26 12:42:35
@_author: Peter Pentchev 
@_subject: auto refresh for expired certificates 
(although I'm having some trouble connecting to the webserver right now)

@_date: 2014-09-16 18:04:41
@_author: Peter Pentchev 
@_subject: encrypting to expired certificates 
Uh, and come to think of it, I'm truly sorry if the above sounded a bit

@_date: 2014-09-16 17:21:28
@_author: Peter Pentchev 
@_subject: encrypting to expired certificates 
Uhm, are you sure that you really mean to say "incredibly contrived" as
in "you guys must have tried your imagination really hard to come up
with these examples, none of which will happen in the real world", or do
you really mean "highly unlikely except in isolated use cases"?  Because
what people are showing you are real use cases, ones that have happened
with real people in the real world.  "Unlikely" and "isolated", yes, but
I wouldn't use "contrived" in this case.
The tools exist.  The issue - in most of the cases here - is that
sometimes people don't use all their PGP keys all the time and sometimes
it may happen that a key will be unused for months and the owner will
honestly not notice that (the system that the key resides on may not even
have been powered up for months).

@_date: 2020-07-29 10:51:23
@_author: Peter Pentchev 
@_subject: Protecting encryption server 
Quick question: how do you send data out? It cannot be via TCP
connections, since those require a handshake and acknowledgements
flowing both ways. It cannot be via any kind of TLS-based protocol for
the exact same reason. In theory you might be able to devise some
one-way protocol based on e.g. UDP or your own datalink layer and add
some kind of signing into it, but that would require a security audit in
its own right, and then there is the issue of dropped packets. So, as
described in Rob's paper, the sending server has to continuously send
the data over and over again, with no idea whether the receiving server
has received any of it, parts of it, or the whole of it.
Also, hm, here's a possibly stupid question: how do you keep the system
time synchronized between the sender and the receiver? You cannot use
any kind of time synchronization similar to NTP or even SNTP, since that
would require incoming data and programs that process that incoming data
and possible avenues of attack via (possibly still undiscovered)
problems in those programs. So at some point, time drift will start to
cause problems in the verification of the cryptographic signatures of
the data the server sends.
I am not saying that any of those problems is unsolvable, but it seems
to me that devising robust solutions to all of them (and to all of
the others that will come up along the way) will make the system much,
much, *much* more complicated than "just a single one-way comm device".
At some point the question would arise whether all these complications
and all these newly-devised communication protocols are indeed worth it.
Once again, not saying that the answer is always "no", but, well...

@_date: 2020-05-07 18:00:38
@_author: Peter Pentchev 
@_subject: Maximum keypair length... 
[formatting fixed; top-posting considered weird]
Leaving aside the fact that I agree with Konstantin about the pure
futility of using 8K RSA keys (but, well, if you're asking from
the standpoint of "this is something that somebody who wants to use
my program at some point in the future may want"... but even from
that standpoint, there may also be people who build their own
versions of cryptography tools with even crazier limits, so even
8K might not be enough)...
...so leaving all that aside, when you speak of field lengths,
you do realize, don't you, that the raw key material is only
a part of even the information that is stored in the keyring,
not to mention the information that is exported as a certificate
(what most people think of when they say "my public key")?
There are user IDs, there are self-signatures, there are
signatures from other parties that let you actually trust
the key... and most of these do not really have a fixed
count, limit, or length. Then there is the export format,
the fact that if you want to transmit the key and certificate
through a text medium, you'll have to encode it and make it
even larger...

@_date: 2020-05-08 21:51:36
@_author: Peter Pentchev 
@_subject: Maximum keypair length... 
[formatting fixed, top-posting still considered weird]
Um. You asked about keys that GnuPG supports. This indicates to me
that you intend to use GnuPG as an implementation of OpenPGP to
encrypt/decrypt/sign data using OpenPGP keys. I really do not
understand how you would go about accomplishing that without
the 'signatures or "bloat"' :) If by 'export the "sec" file' you
mean the GnuPG keyring that contains the secret key data,
it does indeed contain user IDs, signatures, and everything else.
If by "export" you mean "export in some kind of text format for
transmission through a text-only medium", this does indeed invole
the armoring that I mentioned in my last sentence.

@_date: 2020-05-15 22:33:11
@_author: Peter Pentchev 
@_subject: keys require a user-id 
And the answer has been given: because those blocks violate the OpenPGP
standard and, as I understand Robert J. Hansen (and I apologize to him
if I'm putting the wrong words into his mouth), his position is that
there is no reason for this violation to exist at all, there is no
reason for UID-less key blocks to exist at all, so GnuPG is quite right
in following the OpenPGP standard and not accepting them.

@_date: 2020-05-15 22:34:19
@_author: Peter Pentchev 
@_subject: keys require a user-id 
...and he actually said pretty much that in
06a65d70-6d01-6de0-ec03-c841d64c829b at sixdemonbag.org :)

@_date: 2020-05-16 01:12:31
@_author: Peter Pentchev 
@_subject: keys require a user-id 
OK, but *how* is it an enrichment? What does a UID-less key provide over
a randomly-generated UID? Why go to the bother of supporting a new
special case when you can get the same result in another way, with zero
additional code in any of the existing implementations and only a couple
more lines of code in the special client that will have to generate
a random UID?

@_date: 2020-05-16 16:55:11
@_author: Peter Pentchev 
@_subject: keys require a user-id 
Is it though? It is not part of the OpenPGP standard, is it? It is
available for users of software that implements the OpenPGP standard
*with some local extensions*, which is a bit different.
GnuPG users can interact perfectly well with people who use OpenPGP
software :) As Robert J. Hansen said, if you (or somebody else) want to
extend the standard, there is an IETF working group and mailing list for
The way I see it, there are two types of standards:
- ones that are discussed and written before being implemented, so that
  all the implementors have the same idea and nobody comes up with, say,
  using the same magic numbers for completely different purposes or
  having a function accept one more argument than anyone else and break
  if it is called with fewer arguments
- ones that standardize existing behavior, like the POSIX standard for
  operating systems, system calls, libraries, command shell, etc.
Now, I've been on the POSIX mailing list for well nigh 20 years now, and
let me tell you, trying to standardize something when different
implementors have come up with *all kinds* of slightly different ways of
doing *almost* the same thing can be... crazy. Insane. Amazingly,
astonishingly, horrifyingly weird, and very time- and nerve-consuming.
It seems to me that the people involved in developing the OpenPGP
standard did, at one point, decide to go the other way: yes, sure, start
with the existing PGP and GnuPG and other implementations, but then,
when thinking about future work, decide to discuss things before
implementing them (recent threads on the OpenPGP mailing list
notwithstanding), so that it is sorta kinda expected that once various
implementations gain the new features, they *will* be able to
interoperate. That sounds... kind of reasonable to me.

@_date: 2020-05-16 16:57:30
@_author: Peter Pentchev 
@_subject: keys require a user-id 
Just one more point that I forgot to write: *of course* it's fine for
people to implement experimental things to see if they'll work... within
reasonable bounds, of course, like not implementing new algorithm
identifiers outside the space reserved for experimental ones. But it is
also fine for other people to say "okay, sure, you have your
experimental features, but I'll wait until they're standardized until
I do the work on implementing them myself; also, let's discuss whether
they are even needed."
