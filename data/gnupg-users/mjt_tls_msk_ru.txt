
@_date: 2002-05-25 17:47:01
@_author: Michael Tokarev 
@_subject: gpg --decrypt AND --verify ? 
Hello all, this is my first post here.
Gnupg has two commands (in fact more than two) that may be used together,
and this is cleanly noted in manpage and FAQs.  It's --sign and --encrypt
(together with -files variants, thus more than 2).  Now I wonder why there
is no similar --decrypt --verify command available (given two together,
gpg complains about conflicting options).  The quiestion is - why, ofcource.
If an input is signed and encrypted, one can not use --verify alone: gpg
tells about unexpected block format and aborts.  So the only way to ensure
that encrypted data is signed is to check signature at decription time.
I think it is worth an effort to allow using both --decript and --verify,
to mean *require* valid signature (just like --verify alone does) AND
decript, and to return 0 (success) ONLY when both decription and verification
was ok.  Currently, with --decript, verification stage is optional and
works only if there is a signature in data AND it is valid (i.e. --decript
will tell you if there is a valid (good) signature if it is, but decript
regardless on that, and exit with 0 in case *decription* was ok).
This will be very useful for many applications, especially automatic
processors.  For example, one may use signed+encrypted data packets to
transaction exchange (e.g. from remote buisiness app).  Before processing,
data should be verified as it belongs to real owner etc, and decripted.
There is no need to do something if either stage fails.  For this, it
is very convient to call `gpg --decript --verify' and check exit status.
Currently, one need to parse gpg's output (maybe using --status-fd) in
order to find if the signature was correct and the like.  But this is
only half-a-solution.  For example, GOODSIGN message may be followed
by e.g. TRUST UNKNOWN (I don't remember the exact message), or may be
not.  It's not a *very* trivial task to parse gpg's output in proper
way - since there may be in fact numerous possibilities.
Currently, such task was "solved" here for my needs this way:
 o read output from `gpg --batch -q --decrypt' and check exit code
 o check that LAST LINE (there should be exactly 2 lines of output) is
   in a form:
     gpg: Good signature from "(.+)"
(first line is "gpg: signature made ...")
I don't know if this is a guarantee that the message was signed by a
known signature (ok, ok, I explicitly reset LC_* before calling gpg! ;),
and I don't know how to deal with --status-fd messages either.
Comments, anyone?

@_date: 2002-09-30 01:32:02
@_author: Michael Tokarev 
@_subject: Point of view regarding LISA 2002 
Yeah - learn users to encrypt their emails and there will be
many problems with viruses who will try to use encryption too
thus making it impossible to detect in-transit...  Oh well... ;)

@_date: 2003-12-08 00:01:14
@_author: Michael Tokarev 
@_subject: gnupg feature request 
There are 2 different types of string values in WinNT+'s registry
(Win95+ has only one type, string).  Namely, string WITH and
WITHOUT variable substitutions.  I guess type of the above
variable should be changed from "string" to "string with variable
substitution" (whatever it is called) and everything will just
Note also that variables in command line are substituted by a
shell (cmd.exe/whatever), so gpg will see complete path.
But all the above are just IMHO - last time I used Win* was
more than 5 years ago.

@_date: 2013-06-21 11:50:37
@_author: Michael Tokarev 
@_subject: encrypting to a user, "There is no assurance this key belongs to 
Recently I upgraded a Debian machine from squeeze to wheezy,
which lead to upgrading gnupg from 1.4.10 to 1.4.12.  And
immediately noticed that many automated tools I used stopped
working, refusing to encrypt with the error indicated in the
$ gpg --batch -q --encrypt --recipient rconf < foo > foo.enc
gpg: 468E35BC: There is no assurance this key belongs to the named user
gpg: [stdin]: sign+encrypt failed: unusable public key
$ gpg --list-sigs       (names edited)
pub   1024R/A8983CE7 2005-01-27
uid                  f0501
sig 3        A8983CE7 2005-01-27  f0501
sub   1024R/8BB2CB48 2005-01-27
sig          A8983CE7 2005-01-27  f0501
pub   1024R/DC42DA4C 2005-01-27
uid                  rconf
sig 3        DC42DA4C 2005-01-27  rconf
sig   L      A8983CE7 2013-06-21  f0501
sub   1024R/468E35BC 2005-01-27
sig          DC42DA4C 2005-01-27  rconf
(I tried to re-sign rconf key with my f0501 key locally which
resulted in A8983CE7 - it was signed before the same way, back
in 2005, -- but it made no difference).
This error message is referenced alot in the 'net, google finds
many examples, including gnupg mailinglists.  And there are
basically two solutions:
Users suggested to [l]sign the key in question.  As you see, it
is already signed and has been signed for many years, so this
does not work.
Users suggested to indicate ultimate trust to the key in question.
This works, I verified that, but this seem to be wrong.  As asked
by --edit-key `trust' subcommand:
 Please decide how far you trust this user to correctly verify other users' keys
 (by looking at passports, checking fingerprints from different sources, etc.)
I do NOT trust that other party with their verifications of other
user's keys, at all.  It never verifies that trust, it is a robot
which collects files sent to it by other robots, and there's no
trust at all in it.  So I don't want to build my trustdb based on
However, I really want to send encrypted data to that robot, even
if I don't trust its decisions in verifying users.
So it looks to me like in 1.4.12 at least, this trust model is used
wrongly -- it should not disallow encrypting data to users who's
users verification I don't trust.  I already signed their key and
thus indicated that I know who that other party is, and I want to
send encrypted data to that party -- for this, there's no need to
verify my trust to them, it is their business what they will do
with that data -- I already indicated my wish to send that data
to them, and just want it to be out of reach of spies while in-
Yes I know there's --always-trust (or --trust-model always), but
again, this - to me anyway - looks like the wrong place to use
this option, I'm not verifying someone else's signature, I'm
just sending them encrypted data.
Do I misunderstand something?

@_date: 2013-06-21 14:13:30
@_author: Michael Tokarev 
@_subject: encrypting to a user, "There is no assurance this key belongs 
Well.. I didn't think this might be relevant.  As I wrote further
in my original email, the problem goes away when I mark this
key as 'trusted', so it didn't look like marking some key as
trusted will help gpg to establish relationship between that
key and its name.
Actual command line and keys are (domain name replaced with
 $ gpg --batch -q --encrypt --sign --recipient '' < test > test.sign
 $ gpg --list-sigs | sed 's/domain/example.com/g'
 pub   1024R/A8983CE7 2005-01-27
 uid                  f0501.example.com (main key)  sig 3        A8983CE7 2005-01-27  f0501.example.com (main key)  sub   1024R/8BB2CB48 2005-01-27
 sig          A8983CE7 2005-01-27  f0501.example.com (main key)  pub   1024R/DC42DA4C 2005-01-27
 uid                  rconf receiver  sig 3        DC42DA4C 2005-01-27  rconf receiver  sig   L      A8983CE7 2013-06-21  f0501.example.com (main key)  sub   1024R/468E35BC 2005-01-27
 sig          DC42DA4C 2005-01-27  rconf receiver Note that gpg mentions 468E35BC which is a subkey of DC42DA4C, as
far as I can understand.
Well, quite expectedly it doesn't work... ;)
Using either DC42DA4C, or DC42DA4C, as --recipient, makes no difference,
it still complains as in $subject unless I also use --trust-model=always.

@_date: 2013-06-21 14:34:08
@_author: Michael Tokarev 
@_subject: encrypting to a user, "There is no assurance this key belongs 
It says "validity: unknown"
pub  1024R/DC42DA4C  created: 2005-01-27  expires: never       usage: SC
                     trust: undefined     validity: unknown
sub  1024R/468E35BC  created: 2005-01-27  expires: never       usage: E
[ unknown] (1). rconf receiver That's why I tried to re-[l]sign it so that --list-sigs shows todays
signature, but it didn't help.
Well, an obvious detail is that these keys are rather old -- note the
date, it all has been created in 2005.  Indeed, I can't reproduce this
on a fresh keyring either, -- maybe the key(s) are somehow broken?
(the files hasn't been changed since their creation in 2005, only
today I tried to re-sign it and changed).  I have several other
keyrings like that which also stoped working after upgrading from
1.4.10 to 1.4.12.
Well.  For added fun, the complete command line also includes
--no-config, because it was intended to run by a robot in a
known-clean environment (just to be "extra-sure", so to say :).
And there's no config files in the gpg home directory, either:
-rw------- 1 root root 2375 Jun 21 09:46 pubring.gpg
-rw------- 1 root root 2375 Jun 21 09:46 pubring.gpg~
-rw------- 1 root root  600 Jun 21 12:16 random_seed
-rw------- 1 root root 1360 Jan 27  2005 secring.gpg
-rw------- 1 root root 1440 Jun 21 09:46 trustdb.gpg
Maybe I should just re-create the keys.  However that will require
me to update the keyrings on many machines which are exchanging
stuff.  Not a quick task, even if I wanted to do that for a while
already :)
Thank you!

@_date: 2013-06-22 12:52:12
@_author: Michael Tokarev 
@_subject: encrypting to a user, "There is no assurance this key belongs 
That was it.
$ gpg ... --edit-key A8983CE7
Secret key is available.
pub  1024R/A8983CE7  created: 2005-01-27  expires: never       usage: SC
                     trust: unknown       validity: unknown
sub  1024R/8BB2CB48  created: 2005-01-27  expires: never       usage: E
[ unknown] (1). f0501...
After setting trust to it:
pub  1024R/A8983CE7  created: 2005-01-27  expires: never       usage: SC
                     trust: ultimate      validity: ultimate
sub  1024R/8BB2CB48  created: 2005-01-27  expires: never       usage: E
[ultimate] (1). f0501...
and it now does not complain anymore when encrypting data to other
keys, without re-signing anything.
Thank you very much for this, awesome guess.
I think in quite some other cases when users had to trust _other_
keys to be able to encrypt data to them the actual problem was the
same as in my case.
And it's interesting that this prob only manifested itself now after
upgrade from 1.4.10 to 1.4.12.
I think I've seen similar issue myself before in other situation, it
was very much like that, so I too had to indicate ultimate trust for
other keys like that.  But it was several years ago.
Thanks you guys!
