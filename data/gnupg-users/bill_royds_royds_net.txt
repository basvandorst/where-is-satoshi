
@_date: 2008-04-20 00:40:51
@_author: Bill Royds 
@_subject: Naming of GnuPG 
Which is why they should have different names, rather thtn just  different version numbers.
the present GNUPG 2.x line should be called GNUPG-SMIME y.x
While the GNUPG 1.x line should be GNUPG-OpenPGP y.x
They are different so they should have different names.
Bill Royds

@_date: 2008-05-02 17:55:17
@_author: Bill Royds 
@_subject: playing with cryptography... 
Yes, it was signed, by the Thawte issued signature.
Basically a PKI-509 type signing is a tree of trust relationship,  where the root of the tree is a set of certificate issuers that your  browser or email program trusts whether you do or not. These then  issue certificates to others who can issue certificates to more people  etc. It is simpler because you leave the issue of who do you trust up  to Microsoft or Mozilla or Apple.
FOr example, your certificate was issued by Thawte whose certificate  was embedded in the Apple Mail program that I use. So trusting your  certificate means that I trust Apple (for embedding Thawte) and Thawte  (who issued your certificate). The signature verifies that the sender  is who he/she claims but does not verify that the contents of the  message have not been altered.
  The PGP (GPG) model is that one only trusts certificate that come  from someone you already trust or from someone that is trusted by  someone who you trust etc. There is no implicit trust so it takes more  effort to get that trust. It also verifies that the message has not  been altered as well as providing a signing for the sending.
I think the GPG model is more secure, but the other model is more  profitable for the issuers. That is why it is implemented in browsers  and email readers.
Your Thawte certificate  reads Signed (ramon.loureiro at upf.edu)
Bill Royds

@_date: 2008-05-10 12:11:10
@_author: Bill Royds 
@_subject: how long should a password be? 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
But this begs the question of how to add the salt properly when  verifying the password against stored values.
To be able to authenticate against a password, it needs to be  available, in some form, as required. Normally that form is in a table  of hashed passwords, where the hashed value is a hashed combination of  the actual password and the salt Hash(Password,salt). The  authentication routine has the password, but where is the salt stored?  If it is stored along with the password, then it is available to the  cracker who has the hash table, which is necessary for brute force  cracking so adds no more security. It can't be generated each time  because it has to be the same as used in creation of the hash table.  So storage of the salt becomes its own security problem.
Bill Royds
