
@_date: 2001-12-08 05:58:02
@_author: Mike Touloumtzis 
@_subject: Recursive Encryption 
Or, to preserve the directory structure while encrypting the files:
$ find -type f -exec gpg -e -r mykey '{}' \; -exec rm -f '{}' \;

@_date: 2001-12-10 20:09:01
@_author: Mike Touloumtzis 
@_subject: Email Focus 
Which is better, to have every random tool implement recursive
functionality in mutually incompatible ways, or to have a few general
purpose tree walking tools like 'find', which you can use to make any
tool recursive?
Incorporating unrelated functionality like recursion is a symptom of
a weak command line environment.  The recursive 'find' command line I
posted here earlier isn't a hackish workaround, it's a best practice.

@_date: 2001-12-10 20:53:01
@_author: Mike Touloumtzis 
@_subject: Email Focus 
Well, life is hard :-).
Seriously, there are lots of microoptimizations you could make to the Unix
command line.  'ls' would be faster if it were integrated into the shell.
The question is: are people willing to give up cleanliness for speed?  I
don't think most tree walking operations are performance critical.
Multiple arguments != recursive behavior, at least in terms of tradition.
Lots of questions come up with recursive behavior that just aren't
there for simpler cases.  Do you follow symlinks?  Do you cross device
boundaries?  How do you exclude that big 'cache' directory which you
don't want to encrypt?
I _do_ think gnupg should be able to encrypt multiple files in one
invocation, which it doesn't seem to be able to do now.  That way, if you
want to amortize startup time for a tree walk which really is performace
critical, you can pipe find's output to 'xargs -n  gpg'.
man 3 ftw
man 3 nftw
Lack of library support isn't to blame :-).

@_date: 2001-12-10 21:27:01
@_author: Mike Touloumtzis 
@_subject: Email Focus 
Whether an optimization is O(n) or O(whatever) has nothing to do with
whether it's a microoptimization.
If it speeds up a 3 hour process by 1 second, it's a microoptimization.
If it speeds up a command line invocation by 1 millisecond, it's a
You could speed up drawing in Linux by moving X into the kernel.  This
gives you an O(n) speedup, where n is 'number of drawing primitives'.
Yet you still won't be able to convince people it's a good idea.
Both of these problems are exactly what xargs -n is designed to solve.

@_date: 2002-04-10 03:13:01
@_author: Mike Touloumtzis 
@_subject: key security 
It depends on the amount of entropy represented by the passphrase (and the
hash or other technique used by GPG to convert the passphrase to a key).
Assuming GPG's hash is sound: If a passphrase consists of _truly_ random
characters from, say, a set of 64 printable characters such as the ones
used for Base64 encoding, then each character contributes log_2(64) ==
6 bits to the entropy of the passphrase.  So a 22-character passphrase
using this approach represents 132 bits of entropy; thus at this point
the passphrase is not the weak link in a 128 bit cryptosystem.  You can
generate passphrases like this very easily: just base64 encode chunks
of /dev/random:
$ head -c 22 /dev/random | uuencode -m -
In practice, though, it's easier to remember a much longer passphrase
made up of words than a short one made up of random letters--but in a
longer passphrase you have to be careful about whether what you're adding
actually makes the phrase harder to guess.  If you know that the beginning
of my passphrase is "It was the best of times, " then the rest of it
is not contributing a whole lot :-).  Passphrase selection algorithms
should reduce or eliminate the redundancy present in natural language.
The system you use to select a passphrase need not be kept secret if it
incorporates enough truly random choices.  In practice it's hard to pass
up the extra bits of entropy you get by keeping your selection method
a secret :-).
Here are some messages on this subject which I posted to linux-crypto
last July:
No one contradicted them at the time and I still believe the information
given to be correct (corrections welcome, of course).  The third message
implements a simple passphrase generation program in C.
A quote from one of the above messages sums it up:
"Generating strong passphrase data is easy; just choose a truly random
value N bits long.  The challenge is in constructing a useful mapping
from the space of N-bit strings to the space of character strings which
can (a) be typed, and (b) be memorized."
Another quote re practical passphrase storage considerations (lots of
the recommendations in this area come from very hardcore crypto people
who are unwilling to even consider writing down a passphrase):
"You can have as many bits as you want if you're willing to use a long
enough passphrase.  At a certain point you'll have to start writing them
down, though.  This is probably OK if you're the average forgetful Joe and
the risk of irrevocably losing your data outweighs the risk of someone
violating the physical security of your home, office safe deposit box,
etc. order to get the passphrase.
It's not a good idea if you're a hard-core cypherpunk, are at risk of
law enforcement investigation or intrusive subpoena, or are just playing
with crypto because it's fun and don't have any important data under
encryption :-)."
Finally, remember that crypto can turn big secrets into little ones.
One option is always to keep a file containing all your passwords and
passphrases, and encrypt that file using a key which can be unlocked
by your One True Passphrase (something you _know_ you'll never forget).
Mailers with GPG integration are handy for this: every time you sign up
for a Web service or acquire a server password, mail the account info
(including password) to yourself, with all messages encrypted to your
master GPG key.  File them all in a folder and you're happy.

@_date: 2002-04-11 18:53:02
@_author: Mike Touloumtzis 
@_subject: key security 
To correct an error: this should be "head -c 16" (as another poster
suggested as well) for 128 bits of passphrase randomness.  We want to
measure the randomness by what comes out of /dev/random, not what comes
out of uuencode.

@_date: 2002-04-11 19:07:02
@_author: Mike Touloumtzis 
@_subject: key security 
To clear up a possible misconception: the passphrase doesn't come into
play if someone only has messages you sent.  The passphrase is used
to protect your private key on disk, and it comes into play if someone
manages to steal the private key from your keyring.  The passphrase is
an important security measure in preventing some types of compromise
(such as accidental disclosure or browser bugs that allow malicious
file uploads), but if someone cracks into your computer to get the
private keyring they may be also be able to capture your keystrokes,
thus obtaining your passphrase.
The symmetric "session" keys used for messages you send are randomly
generated and have nothing to do with your passphrase.  To break into
your correspondence without the private key, an attacker would need to
(a) break a >= 128-bit symmetric cryptosystem with a randomly chosen key
and only one message's worth of text, or (b) attack the public key (e.g.
by factoring).  (b) is much easier, but is still considered impossible for
keys >= 2048 bits.  Recent developments suggest that breaking 1024-bit
keys is conceivable, although it would require a multibillion-dollar
computing expenditure and many cryptographers still aren't sure it can
be made practical at all.
These are just the cryptographic methods of breaking in.  It's much
easier to the grand scheme of things to break into your computer, or
even to break into your house and bug your keyboard.

@_date: 2002-02-22 22:17:01
@_author: Mike Touloumtzis 
@_subject: reasons for needing --allow-secret-key-import? 
Does the mere presence of a secret key cause the corresponding public
key to be axiomatically trusted?

@_date: 2002-02-25 22:49:02
@_author: Mike Touloumtzis 
@_subject: Using gpg on multiple systems 
I ended up using one key for work and another key (not just a separate
key ID) for home.  They are mutually signed.  This way, in the nightmare
subpoena scenario, I could surrender the key I use for all work-related
mail without endangering the privacy of my personal mail.
I didn't have an overwhelming argument in favor of this approach, so
I'm also curious to hear what others have done, and their rationales.

@_date: 2002-02-25 22:57:01
@_author: Mike Touloumtzis 
@_subject: Using gpg on multiple systems 
I have a work mail address and a personal mail address; I want mail
sent to the work address to be encrypted to one subkey, and mail to
the personal address to be encrypted to another (this type of setup is
required by the thread's original poster due to his greater concerns
about workplace security).
When someone sends me mail, how do they choose which subkey is used?
Can I associate a subkey with an ID?  Or is using two completely
different OpenPGP keys (which I do now) the only way to get this result?

@_date: 2002-02-27 06:45:02
@_author: Mike Touloumtzis 
@_subject: let the flaming begin or Factoring Breakthrough? 
Diffie-Hellman is based on discrete logarithm, not on factoring.
I'm not an expert and I am also certainly curious to know what effect
this discovery has on D-H and on ElGamal OpenPGP keys; there has been
a bunch of discussion on elliptic curve crypto but none that I've seen
yet on algorithms more relevant to this list...

@_date: 2002-01-23 22:12:01
@_author: Mike Touloumtzis 
@_subject: Several questions as feedback on gnupg 
The email address is unique, though; this is what makes a global Web of
Trust work.  It piggybacks on a global infrastructure (DNS) for allocation
of unique IDs.  Otherwise there's no objective yardstick for signature
semantics (only "I know this person is really named Johan Andersson").
So far the PGP/GPG community has been small and tightly connected enough
that the issue of name clash has been mostly ignored IMHO.
This is why you should probably verify email address as well as real
name when you sign a key.  For example, encrypt the signed public key
to itself and mail it to its _own_ listed email address.  The widely
used keysigning party protocols don't do this, which is why I consider
many signatures in the current Web to be useless.  They are essentially
mechanically generated (following a protocol), but the protocol doesn't
confirm the more-unique part of the key.
Note that it's actually technically _easier_ for someone to adopt your
name (by legally changing theirs to match) than it is to adopt your
email address.  A name change in the courts would require a pretty
dedicated attacker, though.

@_date: 2002-01-23 23:28:01
@_author: Mike Touloumtzis 
@_subject: Several questions as feedback on gnupg 
Is this somehow more secure than just encrypting the signed key to itself,
then mailing it to the email address in the signed UID?  Given that your
random text approach is much more complex and adds work, I'm trying to
figure out if it adds any security.
More specifically, your protocol guarantees that _all_ of the email
addresses in the key you're given to sign are controlled by the key's
owner.  My approach could make the same guarantee by splitting the key
into several messages (using a secret splitting algorithm) and mailing one
part to each email address.  However, this stronger guarantee shouldn't
be necessary if I understand the OpenPGP key format correctly.
Once you have verified that I control all 17 email addresses in my key
and sign it, there's nothing to stop me from adding an evil 18th UID
and getting my goofball non-OpenPGP-understanding friends to sign it.
I could have already had this evil UID, in fact; maybe I just stripped
it from the version of the key I sent to you.

@_date: 2002-01-24 02:56:01
@_author: Mike Touloumtzis 
@_subject: Several questions as feedback on gnupg 
Yes.  This variant is equivalent to the secret splitting approach if
and only if the UIDs are truly independent, which I believe they are
(or should be, given that they're at least _partly_ independent :-).
And given that they are, I believe we should use protocols which don't
mislead people into thinking that key verification is an all-or-nothing
affair.  I wonder if the phrase "key signing" is itself misleading?
"UID binding" probably describes the operation better: binding a UID
to the key material.
That is irrelevant to this discussion; I could add the UID after you
sign the others, and re-upload.
Personally, I distribute my keys "by hand" all the time, although
they're also present on the keyservers.  I expect the need for personal
distribution (e.g. via a Web page) may go up once more people start
using OpenPGP and discover the obvious DoS potential of a keyserver
network which allows unrestricted additions to keys and which never
deletes anything.
I can't see how getting my key from a keyserver is any safer than getting
a "specially prepared key" from me.  I can upload whatever I want to
the keyservers.  Can you explain why you believe downloading from the
keyservers is safer?  Is there material which is relevant to the signing
process, not covered by the fingerprint, and not visible in the UID?

@_date: 2002-01-25 02:04:02
@_author: Mike Touloumtzis 
@_subject: Several questions as feedback on gnupg 
How is it "dangerous"?  Because others can see that I attempted to trick
you?  Anyone can upload a key to the keyservers with any UID they want.
There is no authentication of uploaders.  Thus how can it be dangerous for
me to upload a malicious key?  I can just tell you someone else did it.
You could upload a key with UID "Mike Touloumtzis "
right now.  I can't prove you did it, thus there is no risk to you to
try and spoof me.
I'm still not convinced.  I believe there is no security difference
between sending you my key directly or via the keyservers.  Obviously
the _fingerprint_ must be verified via another channel, though.
As I see it, because keyserver uploads are deniable, this problem has
nothing to do with distribution and everything to do with the fact that
your friends signed a UID without verifying it.  Your friends shouldn't
be trusted unless they know to verify _each_ UID independently.

@_date: 2002-03-04 03:33:02
@_author: Mike Touloumtzis 
@_subject: duplicate keyid survey results 
Jason's list includes 5 duplicate 64-bit Key IDs too :-).
