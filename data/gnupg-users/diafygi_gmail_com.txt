
@_date: 2015-08-16 07:12:56
@_author: Daniel Roesler 
@_subject: protecting pub-keys from unwanted signatures 
No, the keyserver pool does not reject any signatures, even if the
signature itself is invalid. When you receive a public key from the
keyserver pool it's the job of the client to clean/reject invalid or
unknown signatures. I've argued a bit that keyservers should start to
play a role in policing the pool, but it's a controversial topic.
Unfortunately, that leads to trolls tagging notable public keys (such
as Facebook and Adrian Lamo) with unseemly material, but these will
just be ignored by gpg when you fetch that public key.

@_date: 2015-07-02 09:59:30
@_author: Daniel Roesler 
@_subject: Secure Private Key Synchronization (RFC) 
Will the proposal require support private subkey stubs generated from
gpg --export-secret-subkeys?

@_date: 2015-07-03 11:05:43
@_author: Daniel Roesler 
@_subject: Secure Private Key Synchronization (RFC) 
SKS keyservers accept lookups for both short and long key ids,
fingerprints, and word searches on user ids[1]. Perhaps the Message-ID
should be the fingerprint + user ids (i.e. "0xf75be... Daniel Roesler
"), so that a client can easily index/search their
mailbox for the keys they want to use (I might have multiple private
keys for work and personal). It might be a bit of an issue with UTF-8
user ids, though. Can a Message-ID be UTF-8?
Also, it looks like OpenPGP.js doesn't support gpg
--export-secret-subkeys files yet[2].
[1]: [2]:

@_date: 2015-07-23 13:47:57
@_author: Daniel Roesler 
@_subject: Python GPG libraries 
There appears to be two main forks of the wrapper. I'm not sure on
what the differences are, but they appear to be pretty well
maintained. I'd recommend using one of these wrappers.
(what runs (what runs I also have a super-duper experimental and completely unfinished and
unsafe OpenPGP parser[1] that I use to learn the format and to dump
the sks-keyserver pool to json[2].
[1]: [2]:

@_date: 2015-05-02 16:02:46
@_author: Daniel Roesler 
@_subject: --with-sig-check silently ignored when used with --import and 
Hash: SHA1
Howdy all,
I've been playing around with key signatures and ran across an interesting
situation. For some reason, --with-sig-check is silently ignored when used with

@_date: 2015-05-04 08:58:49
@_author: Daniel Roesler 
@_subject: --with-sig-check silently ignored when used with --import and 
Gotcha. Would it be possible to throw an error when --with-sig-check
is included with --import or --recv-keys? When silently ignored, it is
very easy for a user to assume that the signature checks passed.

@_date: 2015-10-05 07:22:54
@_author: Daniel Roesler 
@_subject: Sign/verify openssl RSA signatures 
Not exactly what you're asking, but I was able to verify signature packets
on an OpenPGP public key using openssl.
In order to learn the format better, I've been hacking together a very
rough OpenPGP parser in Python without using gpg. To verify signatures with
only openssl, you need to extract and convert the raw public RSA key to
pem  format, then dump the raw signature and data payload concatenation.
My code is really terrible, but feel free to read through it to see how I
calculate the public key pem (without an ASN.1 parser) and raw data
payload. Maybe that can give you some ideas on how to make gpg signatures
compatible with openssl.
this list before giving up.
are compatible with openssl?
rsa_pss_saltlen:-1 -sign priv.pem -out test.txt.sig test.txt
rsa_pss_saltlen:-1 -verify pub.pem -signature test.txt.sig test.txt
signatures in python (pycrypto). Verifying a RSA (PKCS1 PSS) signature
requires just the public key which makes it easy to use especially when
verification of the signature must be done in a daemon.
its easy to use with smartcards (e.g. a yubikey). So my perfect setup would
be to be able to create signatures with gpg that can be verified with
openssl/pycrypto in my daemon.

@_date: 2015-10-08 08:48:59
@_author: Daniel Roesler 
@_subject: Just published a browser-based PGP tool 
It looks like this is just a barebones unhosted OpenPGP interface. All
the others you listed try to do more (email, mobile apps, etc.). If I
just want to quickly encrypt/decrypt/sign/verify a file, this let's me
do it in seconds without any sort of signup or trouble.
Ideally, you could just download the source and open it locally for a
quick, cross-compatible OpenPGP user interface without having to
install anything or get admin privileges. I should work anywhere you
can open it in a browser (which is what I love about unhosted apps).
Really sad to see it isn't open source yet...
An email app, not a straight

@_date: 2015-09-26 10:11:56
@_author: Daniel Roesler 
@_subject: Facebook and OpenPGP 
I asked a while back, and they are considering it.

@_date: 2019-07-08 18:45:36
@_author: Daniel Roesler 
@_subject: Third-Party Confirmation signature? 
Is there a way to create a "Third-Party Confirmation signature"[1]
using the gnupg command line interface?
[1]:  (see "0x50:
Third-Party Confirmation signature.")

@_date: 2019-07-09 10:10:15
@_author: Daniel Roesler 
@_subject: Third-Party Confirmation signature? 
Hmmm, ok.
Yes, I am considering ways of letting a user "whitelist" signatures on
their public key, and using the Signature Target subpacket[1] seemed
like a way to do that.
However, if gpg doesn't support a way of adding that subpacket, then
creating easy-to-copy-and-paste commands for users to use to approve
signatures becomes difficult.
What about using the Notation Data subpacket[2] to provide a pointer
to a target signature that is "approved"? I noticed in the edit-key
interface there is an option for setting notations[3]. Could a user
use gpg's edit-key to create a signature on their key that has a
notation specifying the whitelist of approved third party signature
[1]: [2]: [3]: Thanks for the reply,

@_date: 2019-07-09 15:55:21
@_author: Daniel Roesler 
@_subject: Third-Party Confirmation signature? 
Correct, a keyserver would need to validate signatures before
including them in the public API. However, when gossiping with peers,
they could still included the hashes of non-verified signatures so
they stay in sync with each other.
While adding the ability for 0x50 signatures would be nice, I would
still like to explore ways of users self-limiting signatures within
the existing gpg command line, since most users will be just using
whatever version is in their operating system repo or whatever version
they downloaded at the time of installation.
So it seems like Notation Data subpackets may be the way to go instead
of 0x50 Third-Party Confirmation signatures, since notations can be
added in the existing gpg edit-key interface.
I'll begin playing around with this interface to see what kind of user
experience is possible.
Thanks for the prompt responses!
