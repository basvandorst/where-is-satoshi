
@_date: 2014-11-17 17:08:37
@_author: Damien Goutte-Gattat 
@_subject: card is permanently locked! 
According to the specification [1], yes, but it involves resetting the
card completely.
Once the card is ?permanently blocked? (which is indicated by the fact
that the retry counters for both User and Admin PIN are at zero), it is
possible to send to the card a ?TERMINATE DF? command to put it back
into the initialisation state, then a ?ACTIVATE FILE? command to reset
all stored values (including PINs) to their default values.
With gpg-agent and scdaemon running, you should be able to do that with
the following commands:
$ gpg-connect-agent
Disclaimer: I?ve never actually tried that, but that?s what I would do
in such a case after reading the specs. I guess that with a ?permanently
blocked? card, one does not have much to lose?
[1]

@_date: 2014-11-18 11:18:17
@_author: Damien Goutte-Gattat 
@_subject: Encryption on Mailing lists sensless? 
PGP/etc. between mail servers, and TLS/SSL to the user.
Why use PGP between mail servers? SSL/TLS can be used for that, too.
Actually, opportunistic server-to-server TLS is supported by many mail
server software, and is becoming more and common.
Using PGP for anything less than end-to-end encryption seems pointless
to me. Particularly if it distracts mail server administrators from
enabling server-to-server TLS, which we need anyway to protect the
metadata (headers) that are *not* encrypted by PGP.

@_date: 2014-09-23 17:15:28
@_author: Damien Goutte-Gattat 
@_subject: help: state machine is DEAD. Reset the card first. 
You must first encode the PEM certificate in DER format:
$ openssl x509 -inform PEM -in file.crt -outform DER -out file.der
Then you can import the DER-encoded certificate onto the card.

@_date: 2015-08-15 08:50:53
@_author: Damien Goutte-Gattat 
@_subject: gpg-agent as default ssh-agent on linux macines 
I wrote a short blog post on that topic a few months ago:
   If it still does not work, please provide more details about what you tried and what happened.
Hope that helps,

@_date: 2015-08-15 17:25:15
@_author: Damien Goutte-Gattat 
@_subject: gpg-agent as default ssh-agent on linux macines 
It is certainly possible.
You can have a look at the pem2openpgp tool (provided by the Monkeysphere project [1]), which converts a RSA key in PEM format into an OpenPGP key.
[1]

@_date: 2015-08-31 20:31:09
@_author: Damien Goutte-Gattat 
@_subject: How large is the EEPROM of OpenPGP Card v2.1? 
It will depend on the specific implementation used.
The implementation distributed by Kernel Concepts is based on the BasicCard ZC7.5 from ZeitControl [1], which has a 32K EEPROM [2].
[1] [2]

@_date: 2015-02-15 17:11:36
@_author: Damien Goutte-Gattat 
@_subject: MIME or inline signature ? 
Well, the 0xDE2FFC869AFA5165 key is a signing subkey of Xavier?s master key 0xBA4909B78F04DE1B. Indicating the master key (which is the one everyone needs to know about and sign) instead of the signing subkey is the correct thing to do. By downloading the master key from a keyserver, you will automatically fetch the signing subkey as well.
You seem to have misinterpreted Enigmail?s error message. When it says:
   Error - signature verification failed
   Public key DE2FFC869AFA5165 needed to verify signature
   BAD signature from Xavier Maillard the second line does not imply that the indicated key is not available. Enigmail displays such a line everytime a signature verification fails, even when the indicated key *is* present in your keyring (which is somewhat misleading).
The important line is the third, which tells that Enigmail was in fact able to perform the verification (meaning it has the right key).
Now, I don?t know why the verification failed, but I do note, quite ironically, that this is an inline signature, while a previous message from Xavier, with a PGP/MIME signature from the same key, was verified

@_date: 2015-02-15 22:45:38
@_author: Damien Goutte-Gattat 
@_subject: GNUPG 2.* and AIX - questions 
The gpg program is always CLI-only, both in GnuPG 1.x and GnuPG 2.x.
As far as I know, the available GUI frontends can work with all versions (that?s at least the case for GPA and the Enigmail plugin).
What?s missing in GnuPG 1.x includes:
* elliptic curve-based cryptography, which was introduced in GnuPG 2.1;
* all the X.509 and S/MIME stuff?GnuPG 1.x deals with OpenPGP only;
* support for SSH authentication;
* the GnuPG Agent, only provided with 2.x (although GnuPG 1.x *can* use an Agent if one is available and running);
* Maybe some other things, but I guess those are the most important.
Overall, and ignoring the above features only present in 2.x, one of the main differences between 1.x and 2.x is that GnuPG 1.x is quite monolithic while GnuPG 2.x is more modular (with many functions delegated to auxiliary programs outside of the gpg binary, such as the GnuPG Agent, the Smartcard Daemon, Dirmngr...) and has more dependencies. As you have experienced yourself, this can make GnuPG 2.x more difficult to compile on some platforms.

@_date: 2015-02-16 00:01:04
@_author: Damien Goutte-Gattat 
@_subject: MIME or inline signature ? 
You provide GnuPG with only the *signature*. You need to also give it the *signed data* (the message) so that it can perform the verification.
If you want to do that manually (something you don?t usually do with PGP/MIME signatures, since it?s quite cumbersome): In addition to what you have already done (saving the signature itself in ?signature.asc?), you must also extract the MIME part that was signed.
In the message source, look for a line like the following:
   Content-Type: multipart/signed; boundary="XXXXXX"
and note the ?XXXXXX? boundary string. The signed data will start after the first line starting with ?--XXXXXX? and will end with a blank line followed by another line starting with ?--XXXXXX?. That?s what you need to extract and save to a file (say, ?message.txt?).
Do not include the boundary lines themselves, nor the last blank line before the closing boundary line. For example:
   --XXXXXX
   Everything from this line
   ...
   up to this one is the signed message to verify.
   --XXXXXX
Then you can ask GnuPG to verify the message:
   gpg --verify signature.asc message.txt
(You understand now why nobody does that manually, and leaves that to Enigmail or any other PGP/MIME-enabled mail client.)

@_date: 2015-02-23 01:44:22
@_author: Damien Goutte-Gattat 
@_subject: X509 CSR signed with card key 
Yes, you can use the gpgsm(1) tool for that.
Make sure your card is in the card reader, then:
   $ gpgsm --armor --output mycsr.pem --gen-key
You?ll be prompted to select what kind of key you want, choose ?Existing key from card? (make sure your card is in the reader). Then select which of the card keys you want to use (the signing key, the encryption key, or the authentication key) and the intended use of the future certificate.
At the end of the procedure, you?ll be prompted for your PIN in order to sign the CSR.
The documentation of Scute [1] has a complete example (it uses gpgsm-gencert.sh, a deprecated helper script, instead of the above command, but the procedure is almost the same).
[1]

@_date: 2015-02-25 10:06:24
@_author: Damien Goutte-Gattat 
@_subject: how to disable pinentry 
You could use a console-only pinentry, such as pinentry-curses or pinentry-tty. Add the following line in your ~/.gnupg/gpg-agent.conf:
   pinentry-program /usr/bin/pinentry-tty
You cannot avoid using GnuPG Agent with gpg 2. As stated in the man page, gpg 2 always requires the agent, and the use-agent option has no

@_date: 2015-01-13 21:33:54
@_author: Damien Goutte-Gattat 
@_subject: More strangeness. 
It could be the same problem as the one reported last month by Ximin Luo That problem only occurs when the public keys are stored in the new keybox format, which would be your case if you were ?starting from an empty GnuPG 2.1.1 installation?.
Until the bug is fixed, a possible workaround is to force GnuPG 2.1 to use the legacy pubring format, e.g. by creating an empty pubring.gpg file in GnuPG?s home directory, prior to importing any key.
[1] [2]

@_date: 2015-01-25 11:48:55
@_author: Damien Goutte-Gattat 
@_subject: GPA fails to verify certain .asc files 
It looks like bug 1637 [1], which indeed affected gpa-0.9.4 but has been fixed in gpa-0.9.5 and later versions.
[1]

@_date: 2015-07-29 13:34:00
@_author: Damien Goutte-Gattat 
@_subject: Use Private DOs 
Private DOs  and  are only readable once the User and Admin PIN, respectively, have been verified.
So to show the contents of Private DO  :
   $ gpg --card-edit
   gpg/card> verify
   [enter your User PIN when prompted]
   gpg/card> list
And to show the contents of Private DO  :
   $ gpg --card-edit
   gpg/card> admin verify
   [enter your Admin PIN when prompted]
   gpg/card> list
As for the deleting the contents of one of those fields, I don't think you can specify an empty value (gpg's card editor won't let you do that anyway, as you have seen). What you *can* do is replacing the contents by any non-significant value, such as "none", "0", or even a non-breakable space character (a normal space character won't do, because it will be trimmed by gpg).

@_date: 2015-06-17 00:30:26
@_author: Damien Goutte-Gattat 
@_subject: Teaching GnuPG to noobs 
I would say: all the stuff related to the concepts of "key validity" and "owner trust".
Particularly, the fact that the validity of a given key is automatically determined by looking at the key's signatures.
I have seen several new users complaining that they could not find how to set the validity of a key, because they didn't understand that you do that indirectly by *signing* the key.
Typically, the user would ask me something like this: "OK, I got your public key, I have checked the fingerprint you gave me so I'm sure it's your key. But Enigmail says that the validity and ownertrust are both 'unknown'. How do I set the validity to something else? There is a 'Set Owner Trust' button, but no 'Set Validity' button..."

@_date: 2015-03-05 19:26:09
@_author: Damien Goutte-Gattat 
@_subject: where can one find an official gnupg project statement on the 
Well, if you plan to work on Scute and release a new version, please consider applying your own patch for support of TLS 1.2. You posted that patch on the gnupg-devel list some months ago [1], but it never made its way to the public repository.
This patch is not only useful for TLS 1.2, it also makes Scute work with Thunderbird to apply S/MIME signatures to emails, and even with LibreOffice to sign OpenDocument files (well, with LibreOffice it only works if the card PIN has already been verified; otherwise LibreOffice crashes, but I don?t think this is Scute?s fault).
And although I didn?t have the chance to test, I suspect that with this patch, Scute could also work with GNOME Evolution.
May I remind you also of a patch I posted in january [2], which fixes a bug that caused Scute to fail to sign anything in some occasions (only when used with GnuPG 2.1, not 2.0).
[1] [2]

@_date: 2015-03-13 23:31:08
@_author: Damien Goutte-Gattat 
@_subject: bugs.gnupg.org TLS certificate 
The fact that they are called ?proposed standards? does not really mean anything. Many widely deployed and successful IETF protocols are still officially considered ?proposed standard? and not ?Internet standard?, that does not make them less official.
DNSSEC and DANE are as much ?official standards? as, for example, OpenPGP (RFC 4880) and the X.509 PKI system (RFC 5280).
I don?t have any more insight, but I?d say that the main downside of both DNSSEC and DANE is that almost no TLS client implements them?
As far as I know, most if not all of the DNS resolvers immediately available on a client system don?t perform DNSSEC validation.
Even if we assume that the system DNS resolver is DNSSEC-capable, I don?t know of any browser (or any other kind of TLS client software) that care about DNSSEC and/or TLSA records. For Firefox, you have to install a third-party extension [1], and for Chrome, support of DANE is not on Google?s agenda [2] (they prefer to rely on Certificate Transparency [3] instead, which in my opinion does not solve any of the main problems of the PKIX system, but this is another subject).
I am, too, very interested in DANE, and in fact I have great hopes in it (all my TLS servers have TLSA records, and my browser can check them). But we are very far from the point where nobody would need to rely on ?trusted? external CAs.
[1] [2] [3]

@_date: 2015-03-17 23:53:42
@_author: Damien Goutte-Gattat 
@_subject: Defaults 
Some of the defaults you propose are already there. If I look at a freshly generated key pair with GnuPG 2.1, the default preferred algorithms are:
Cipher: AES256, AES192, AES, 3DES
Digest: SHA256, SHA384, SHA512, SHA224, SHA1
So, AES256 is already the default symmetric cipher (CAST5 and IDEA are not even in the list and must both be explicitly requested by the user), and SHA256 is already the default hash algorithm.
Do you mean signatures in general, or key signatures (certifications)? For key signatures, SHA-1 is still the default for RSA keys, but signatures on (EC)DSA keys will use up to SHA-512 depending on the key size (SHA-256 for a Brainpool-256 key, SHA-512 for a BrainpoolP512 key).

@_date: 2015-03-18 01:12:16
@_author: Damien Goutte-Gattat 
@_subject: Defaults 
Actually no, it is not. My mistake.
SHA-256 is the default cert-digest-algo since GnuPG 2.1.0.
I meant *on*, but now I realize I was only thinking about *self* signatures, where the signing key and the signed key happen to be the same.
In the more general case you are right of course: the default hash algorithm is determined by the type and size of the *signing* key, not of the key that is about to be signed.

@_date: 2015-03-18 13:12:29
@_author: Damien Goutte-Gattat 
@_subject: Defaults 
I don?t think that ignoring the recipient?s preferences should be the default behavior. The recipient?s choices should be honored by default *unless* you explicitly decide against it.
If you want to ignore a particular cipher, you could use the --disable-cipher-algo option. Disable CAST5 and it will never be selected by GnuPG even if it appears on the recipient?s list.
Not anymore, it?s already done. :) I was wrong on that point, SHA-1 is no longer used by default for certifications since GnuPG 2.1.0.

@_date: 2015-05-14 21:00:33
@_author: Damien Goutte-Gattat 
@_subject: Creating a new Identity 
I would note that this document is obsolete on several points.
* First and foremost, it suggests using GnuPG 1.4. Even in 2013, there were already no reason to prefer that version over GnuPG 2.0; a fortiori there is no reason today to prefer it over GnuPG 2.1. Actually, ?creating the perfect GPG keypair? is much easier with Modern GnuPG.
* I also disagree with the advice of always ?using the highest possible values for key length?, although I reckon that this point is controversial [1]. I?d rather stick to 2048-bit for the subkeys (they can be changed at anytime, if we were to learn that attacks on 2048-bit RSA become practical), even if I do recommend 4096-bit for the *master* key only.
* There is no more need to ?strengthen hash preferences?.
* GnuPG 2.1 already creates a revocation certificate (stored in ~/.gnupg/openpgp-revocs.d) when creating a new key pair.
* With GnuPG 2.1 removing the master private key from the keyring is now much easier, as you don?t need to go through the whole process of exporting the private subkeys, deleting all the private keys, then importing back the subkeys only.
Instead, get the ?keygrip? of your master key:
    $ gpg2 --with-keygrip -K
    /home/alice/.gnupg/pubring.kbx
    ------------------------------
    sec   rsa4096/CB2F38F25B491A54 2014-12-31 [SC] [expires: 2017-12-30]
          Keygrip = D4DF0C35D3E22FA6AC37DA2E54FB03F73616A3CB
    uid               [ultimate] Alice     [?]
You will find the file containing the private key in ~/.gnupg/private-keys-v1.d/KEYGRIP.key. Move this file to any secure place you want. When you will need your private master key, just put the file back in the private-keys-v1.d directory (do not change its name).
I?ve splitted it in 2-of-3 shares using libgfshare [2]. One share is left on my computer, the other two are offline on two USB sticks.
You could either:
* sign your new keypair with your old key;
* write a transition statement and sign it with both your old and your new key.
[1] [2]

@_date: 2015-09-29 23:07:11
@_author: Damien Goutte-Gattat 
@_subject: adding card keys and make them non exportable 
It *looks like* a valid key block, but--if the keytocard operation was indeed successful--it's actually only a "stub" that does not contain any private material.
You can check the actual contents of the exported data with the --list-packets option:
   $ gpg --list-packets your_exported_private_keys.gpg
Look for the following lines in the output:
   :secret sub key packet:
           [...]
           gnu-divert-to-card S2K, [...]
           serial-number:  You should see those lines once for each subkey that you moved to the card.

@_date: 2016-04-06 12:48:40
@_author: Damien Goutte-Gattat 
@_subject: Using gpg for ssh access 
Then if GPG Agent is up and running and configured to act as a SSH agent, it should automatically detect the authentication subkey and make it available to SSH clients.
First, could you please tell us which version of GnuPG you are using? Most importantly, we need to know if you're using 2.0 or 2.1.
Then, check whether SSH support is enabled in GPG Agent. You can use the following command:
   gpg-connect-agent "GETINFO ssh_socket_name" /bye
which should print the path to the SSH socket if SSH support is enabled, or give you an error message if it is not.
If SSH support is not enabled, enable it by adding the following line:
   enable-ssh-support
in the configuration for GPG Agent (~/.gnupg/gpg-agent.conf, you may need to create that file if it does not already exist), then kill the agent:
   gpgconf --kill gpg-agent
and re-run the first command again.
Once you have confirmed that SSH support is available from the agent, check the value of the SSH_AUTH_SOCK environment variable. That variable must point to the agent's SSH socket (as returned by the GETINFO command above) in order for SSH clients to know how to contact the agent.
Then, insert your card into your card reader and run `ssh-add -L`. If everything went fine, that command should print the public part of your authentication subkey, in a format suitable for inclusion into an authorized_keys file on your server.
If something did *not* go fine, please report any error message.

@_date: 2016-04-26 16:09:45
@_author: Damien Goutte-Gattat 
@_subject: Import a pkcs12 certificate chain 
I am not sure I understand your workflow and what you want to achieve
But, as a starting point, you must know that the gpg2 program only deals
with OpenPGP keys and messages. To manipulate X.509 certificates, you
need gpgsm (another component of the GnuPG project) instead.
Presumably, the command you need should be
$ gpgsm --import CertificateChain.p12
to import the certificate and key from the PKCS file into your
keyring. Then you would probably use the --export command to export back
the certificate only and send it to your third party.
Hope that helps somehow,

@_date: 2016-12-13 18:15:08
@_author: Damien Goutte-Gattat 
@_subject: gpg2 export-secret-key if no master key present 
In the former case (in the absence of the secret primary key), the --export-secret-keys command will still export a secret packet key corresponding to the missing key, but it will be marked as a "dummy key".
Try running the following command:
   $ gpg2 --list-packets secret-key
You should see (among other things) something like the following:
   :secret key packet:
           version 4 [...]
           pkey[1]: [xxxx bits]
           gnu-dummy S2K, algo: 0, simple checksum, hash: 0
The "gnu-dummy S2K" is the marker which will tell GnuPG that this file does *not* actually contain the secret key.
I would just use
   $ gpg2 --homedir=/my/save/place --export-secret-keys | paperkey | lpr
(the last command "| lpr" would send the output directly to the printer).
This would export both the primary key and all the subkeys. If you want to save with paperkey only the primary key, specify its ID and append a '!' at the end:
   $ gpg2 --homedir=/my/save/place --export-secret-keys '0xABCDEF10!' \
 paperkey | lpr
Hope that helps,

@_date: 2016-12-15 22:17:48
@_author: Damien Goutte-Gattat 
@_subject: Smartcards and tokens 
The token is normally not used to perform any *encryption*. You encrypt with the public key of your correspondant, which is stored on your computer, not on your token (there's no need to protect it since it is a *public* key). You use your token to *decrypt* messages that were sent to you--and at that time, even if the token is malicious there's nothing it can do to mess with the encryption.
What a malicious (or faulty) token *could* do is generate a weak key, that your opponent could break once and for all and then use to decrypt all messages sent to you. Smartcards generating weak keys have already been observed in the wild [1]. If you worry about that, simply generate your keys on a computer you trust, then load them onto the token, without ever using the token's own random number generator.
I'll admit readily that I am not an expert on this, but I don't see how that could be feasible without the help of the host PC--meaning your opponent would have to both (1) compromise your PC and (2) send you a malicious token. But if he could compromise your PC, he would have no need for a malicious token.
I guess your attacker could use a USB token as the mean to compromise your PC (names like "Bad USB" come to mind), but if you worry about such attacks, you should be wary of *any* USB device you buy (keyboards, mice, mass storage sticks... or even desktop missile launchers), not only cryptographic devices.
[1]

@_date: 2016-12-26 17:25:11
@_author: Damien Goutte-Gattat 
@_subject: Unable to import Private Key 
Your file seems to contain only a private *sub* key. I don't think GnuPG can import such a file (I've just tested with a similar file on my system with GnuPG 2.1.17, I got a similar result).

@_date: 2016-12-26 22:21:37
@_author: Damien Goutte-Gattat 
@_subject: Unable to import Private Key 
The problem here is not that you are missing the public key (the public key *is* derivable from the private key, and GnuPG would automatically extract the public key upon importing the private key).
The problem is that you are missing the secret *primary* key to which this secret subkey should be attached.
If you do not have a backup of that primary key, I am not sure you will be able to recover.
At least with GnuPG 2.1, it should be possible to re-attach the subkey to a new primary key (because GnuPG 2.1 allows to "create" a key from a pre-existing key if you know its keygrip), *but* the newly re-attached key would still have a different key creation time and thus a different key ID... meaning that it could not be used to decrypt messages encrypted to the original key.
As far as I know, the only way to export a subkey only is to explicitly specify that subkey by its key ID with an appended '!', as in the following example:
    $ gpg2 --output backup.gpg --export-secret-keys '0xDECAFBAD!'
Otherwise, GnuPG will always export the primary key and all its subkeys.
What are those "standard instructions" you are referring to? If you were instructed to backup only your secret subkey instead of your entire private keyring, I am afraid you have been badly misled.

@_date: 2016-12-27 11:29:35
@_author: Damien Goutte-Gattat 
@_subject: Unable to import Private Key 
That option would still generate a secret key packet for the primary key, it's just that this packet would not actually contain any key material.
Here, what has been generated is a file containing only a secret subkey packet (and the associated binding signature). That's not the result of using --export-secret-subkeys.

@_date: 2016-12-31 20:22:43
@_author: Damien Goutte-Gattat 
@_subject: Unable to import Private Key 
So gpg asks the agent for your secret primary key (69F91A22) but the agent cannot provide it. Then it asks for the secret subkey and gets it.
Next questions:
* What exact version of GnuPG are you using? It looks like you are using a version from the 2.1 branch, not 2.0. Please give the output of `gpg2 * Can you *use* your secret primary key? Try performing any action requiring the secret primary key (such as signing a message, assuming you do not have a signing subkey).
* If you can reproduce the issue at will, can you try exporting the private keys again, but with logging of debug informations?
Add the following lines to your ~/.gnupg/gpg-agent.conf file (create that file if it does not already exist):
   log-file /wherever/you/want.log
   debug 1024
Reload the agent (gpgconf --reload gpg-agent) and try exporting again.
It's starting to look like a communication problem between gpg and the agent. What problem exactly, I have no clue.

@_date: 2016-02-20 09:46:09
@_author: Damien Goutte-Gattat 
@_subject: How to configure Smartcard without 'toggle' 
You do not need the 'toggle' command to select the private keys. Using the 'key' command alone is enough:
    $ gpg2 --edit-key alice
    Secret key is available.
    sec  rsa2048/2EADF7D4
         created: 2015-06-05  expires: 2018-06-04  usage: SC
         trust: ultimate      validity: ultimate
    ssb  rsa2048/E3293B28
         created: 2015-06-05  expires: never       usage: E
    ssb  rsa2048/99E238AD
         created: 2015-06-05  expires: never       usage: S
    [ultimate] (1). Alice Notice that secret keys are already displayed.
Now to select the first subkey:
    gpg> key 1
    sec  rsa2048/2EADF7D4
         created: 2015-06-05  expires: 2018-06-04  usage: SC
         trust: ultimate      validity: ultimate
    ssb* rsa2048/E3293B28
         created: 2015-06-05  expires: never       usage: E
    ssb  rsa2048/99E238AD
         created: 2015-06-05  expires: never       usage: S
    [ultimate] (1). Alice Notice the '*'? It indicates the currently selected subkey. Now you can proceed with the 'keytocard' command.
In your first message you said ?the SmartCard rejects the key?, so I would say the SmartCard is definitively relevant. As would be relevant the exact error message that you got when you attempted the 'keytocard'

@_date: 2016-02-23 08:21:58
@_author: Damien Goutte-Gattat 
@_subject: Migration assistant 
There could be some more configuration files (one for each component):
* dirmngr.conf
* gpa.conf
* scdaemon.conf
* gpgsm.conf
I also have two more files for use with GpgSM:
* policies.txt
* trustlist.txt
and a script to handle smartcard events:
* scd-event
Starting from GnuPG 2.1.10, there could also be a TOFU database (either a directory tofu.d, or a single file tofu.db).

@_date: 2016-01-11 12:24:09
@_author: Damien Goutte-Gattat 
@_subject: basic identity mgmt 
If you are using the default trust model ("pgp"), no. In this model, the
validity of a key is only determined by its signatures.
If you are using GnuPG 2.1.10, you could have a look at the "tofu" or
"tofu+pgp" trust models, which allow you to do something like this:
    gpg2 --tofu-policy good 0xKEYID
to say that the specified key is fully valid.
Yes. "Signing" (or, more accurately, "certifying") a key roughly means
"I certify that this public key belongs to the person correctly identified in the User ID".
This is completely separate. Unfortunately, the word or verb "trust" is
sometimes used to refer to the *validity* of a key (as in the sentence "I *trust* that this key belongs to the person specified in the User ID").
"Unknown" means that no trust has yet been explicitly assigned to the
key; "undefined" means you explicitly said that you didn't know how much
to trust the key. Both values imply that any certification emitted by
this key will be ignored.
Yes. In the "classic" or "pgp" trust models, the validity of a key is
calculated by looking at the certifications carried by that key.
By signing the key, you add to it a certification emitted by your own
key; since your key has ultimate trust, that certification is enough to
fully validate the target key.

@_date: 2016-01-28 09:03:35
@_author: Damien Goutte-Gattat 
@_subject: BAD signatures for GnuPG Stable 
Is the old libgpg-error-1.21.tar.bz2 (the one you downloaded before, with the wrong size) still present in the same directory? (I assume it is, based on the '(1)' suffix that has been appended to the new file you have just downloaded.)
If that's the case, what happens when you call gpg like this:
   $ gpg --verify libgpg-error-1.21.tar.bz2.sig
is that gpg will assume the signed file to verify is libgpg-error-1.21.tar.bz2. (Recent versions of GnuPG print a warning in situation like this, but older versions are silent about that assumption.)
Either get rid of the old file, or explicitly tell gpg which file it should verify:
   $ gpg --verify libgpg-error-1.21.tar.bz2.sig libgpg-error-1.21(1).tar.bz2

@_date: 2016-07-05 20:07:02
@_author: Damien Goutte-Gattat 
@_subject: Migrating key to smartcard 
In your case, the simplest way would be to migrate your master key into
the signing slot and the encryption subkey into the encryption slot.
You may leave the authentication slot empty if you do not plan to use
your smartcard for authentication purposes (e.g. authentication to a SSH
I would indeed recommend to generate a new signing subkey. You would
then send it to the signing slot of the smartcard, and not put your master key on the smartcard at all.
Regarding the authentication subkey, you have to do that only if you
actually have a need for it (you seem to believe that you MUST fill all three slots of the OpenPGP card; it's not the case).
The fact that your encryption subkey is "well-known" is irrelevant. The
master key is the only one which needs to be "known". It's one of the
benefits of using subkeys: you can change the subkeys anytime without
having to re-introduce the new subkeys into the web-of-trust.
That being said, I agree with reusing your existing encryption subkey.
Unless you believe it may have been compromised, there is no reason to
generate a new one.
Not sure of what you mean by "moving the identity". The card can only
contain the private keys. Your UIDs (and the associated signatures)
would still be stored in your *public* keyring.
GnuPG will automatically remove the private subkeys from your keyring
when you migrate them to the smartcard, you do not have to that
explicitly yourself.
No, only the master key can sign other keys. But since signing keys is
normally something that you don't do everyday, that should not
discourage you from storing your private master key offline. You would bring it back online only on those (presumably rare) occurences when you need to sign a key.
Hope that helps,

@_date: 2016-07-06 10:25:58
@_author: Damien Goutte-Gattat 
@_subject: Migrating key to smartcard 
According to the standard, any key with the "Certify" flag set can be used to sign other keys. And unless I'm mistaken, the standard does not explicitly restrict this flag to master keys only.
So, I guess it should be possible (at least in theory) to have a subkey with this flag, and to use it to sign other keys. But I don't think GnuPG allows to do that (or any other OpenPGP implementation).
True enough. In my case, I try to minimize the risk of human error by using a script which automatically brings the key online (from its offline USB storage), executes a single GnuPG command, then remove the key again.
If you are interested, I've written a blog post [1] in which I give an example of such a script.
[1]

@_date: 2016-07-06 21:03:11
@_author: Damien Goutte-Gattat 
@_subject: That blog post, factual error or not? 
Hi Peter,
Yes I did. That's how I found out this behavior actually.
If you want to check by yourself, have a look for example at the function agent_pkdecrypt (in the agent/pkdecrypt.c file), which implements the agent's PKDECRYPT command. One of the first thing this function does is to call agent_key_from_file (defined in agent/findkey.c), which *inconditionnally* reads the key from its file storage. The key is freed at the end of the agent_pkdecrypt function, without having been cached anywhere (only the passphrase is cached, in the function unprotect.c in agent/findkey.c).
The agent_pksign function, which implements the PKSIGN command and needs the signing (sub)key, behaves similarly.

@_date: 2016-03-17 10:40:27
@_author: Damien Goutte-Gattat 
@_subject: Using gpg for ssh access 
If I may, I wrote two blog posts on this subject:
*  (for GnuPG 2.0)
*  (for GnuPG 2.1)
I hope you?ll find them useful. If not, do not hesitate to ask for   From what you said, the step you probably missed is to use gpg-agent as a drop-in replacement for ssh-agent.

@_date: 2016-03-19 19:26:35
@_author: Damien Goutte-Gattat 
@_subject: using master key from usb 
You can use the --keyring option to add your normal public keyring (containing the key you want to sign):
   $ gpg --homedir /media/myusb/gnupg --keyring ~/.gnupg/pubring.gpg ...
If you?re using GnuPG 2.1, an easy and (IMHO) elegant way is to create a symlink pointing to your master key on the USB stick:
   $ ln -s /media/myusb/gnupg/private-keys-v1.d/XXXXXXX.key (where XXXXXX is the *keygrip* of your master key, which you can learn with the --with-keygrip option when listing keys).
You can then call gpg as usual, without needing to change its home directory. When you are done, just remove the symlink and unmount your USB stick.

@_date: 2016-03-24 12:26:58
@_author: Damien Goutte-Gattat 
@_subject: Force textual pinpad 
You can configure the agent to use the TTY version of Pinentry. Add the following to your $GNUPGHOME/gpg-agent.conf:
   pinentry-program /usr/bin/pinentry-tty
(Adjust for the location of the pinentry-tty binary if needed.)

@_date: 2016-10-02 09:52:22
@_author: Damien Goutte-Gattat 
@_subject: recording and retrieving "secrets" into gpg files 
Then you might have a look at the secret-tool program (in the libsecret-tools package), which is a command-line client (so, it should be scriptable with bash) to the secret service [1].
(The "secret service" is the service responsible for managing the keyrings. Seahorse is only a client for that service, it does not manipulate the keyring itself.)
E.g., to store a secret into the default keyring:
   $ echo -n "mysecret" | secret-tool store --label="A secret" \
     hostname where "mysecret" is the secret to store, "A secret" is the name that will be displayed in Seahorse, and "hostname  is a key value pair that you can later use to search for this secret.
To retrieve this secret:
   $ secret-tool search hostname You will not have to use GnuPG. In fact, as far as I know GnuPG is not involved anywhere --- the secret service daemon encrypts the keyring itself, it does not use GnuPG for that.
Hope that helps,
[1]

@_date: 2016-10-10 14:09:03
@_author: Damien Goutte-Gattat 
@_subject: Key-Grip unknown in --gen-key --batch 
To manipulate X.509 certificates (and related concepts such as CSRs), you should use the gpgsm program instead of gpg2. gpg2 is for OpenPGP material, gpgsm is for X.509/SMIME.
The Key-Grip keyword is recognized by gpgsm (see sm/certreqgen.c).

@_date: 2016-09-01 20:25:22
@_author: Damien Goutte-Gattat 
@_subject: TOFU support in GnuPG 2.1 
You're probably missing the development files of SQLite (depending on your distribution, they're probably in a package called sqlite-dev or To confirm, look at the output of the configure script for the following    Building without SQLite support - TOFU disabled
Install the missing package and run the configure script again.

@_date: 2016-09-12 14:16:46
@_author: Damien Goutte-Gattat 
@_subject: Local-signing without (offline) private master key 
I think so. Marking the binding between your correspondent's key and its email address with a "good" TOFU policy (something that does not require your private primary key) would be equivalent to locally signing the key: it's a private statement (only available to yourself) that you regard that key as valid, i.e. as belonging to the User ID it carries.
This does not prevent you from continuing to use the Web-of-Trust if you're so inclined, as the "tofu+pgp" model allows you to use both TOFU assertions and WoT certifications to validate a key.
If you're already using GnuPG >= 2.1.10 (with support for the TOFU model), I would argue this is your best option.

@_date: 2016-09-13 08:17:58
@_author: Damien Goutte-Gattat 
@_subject: [Linux/OS X] Identiv SCR3500 A working with OpenPGP Smartcards 
I am successfully using it with an OpenPGP Smartcard v2.0 (not 2.1), under Slackware Linux with GnuPG 2.1.15.
It works both with Scdaemon's internal CCID driver and with the pcscd/libpcsclite stack.
If you don't plan to use your reader for anything else than GnuPG, you may use the internal CCID driver. In that case, there's not much to do; about the only thing you may have to take care of (if it's not already done on your system) is to make sure that your own user account is allowed to access the reader.
(That's for GNU/Linux; as for OS X, I have no clue.)

@_date: 2016-09-13 15:54:24
@_author: Damien Goutte-Gattat 
@_subject: DANE-OpenPGPkey lookup with GnuPG 
I think the --search-keys command is specifically meant to retrieve keys from keyservers.
To retrieve a key using the auto-key-locate mechanisms, use the --locate-keys command instead:
   $ gpg2 --auto-key-locate dane --locate-keys info at mail.de
   gpg: key 94206060: public key "info at mail.de " imported
   gpg: Total number processed: 1
   gpg:               imported: 1
   gpg: automatically retrieved 'info at mail.de' via DANE
   pub   rsa4096/94206060 2015-03-11 [SCA] [expires: 2020-03-09]
   uid         [ unknown] info at mail.de    sub   rsa4096/8113910E 2015-03-11 [E] [expires: 2020-03-09]

@_date: 2016-09-13 22:41:55
@_author: Damien Goutte-Gattat 
@_subject: Serve up ssh key *and* gpg key? 
You don't need to do that. Just load the key into the agent using the ssh-add tool, as you would do if you were using the "regular" ssh-agent.
As long as gpg-agent is started with the --enable-ssh-support option, any program capable of talking to the "regular" ssh-agent can talk to gpg-agent. That's why you can just use ssh-add to load your key into the

@_date: 2016-09-29 15:23:35
@_author: Damien Goutte-Gattat 
@_subject: Terminology - certificate or key ? 
No, you understood well. What we commonly call an "OpenPGP public key" should really be called, strictly speaking, an "OpenPGP certificate". And "signing a key" is really "certifying" the binding between a (true) public key and an user ID.
It seems there is, according to one of the authors of RFCs 2440 and 4880. Apparently, at the time they were told by the IETF to avoid speaking of "certificates" so that OpenPGP would not seem to rivalize with PKIX [1].
Network Associates did not have this concern, and in their "Introduction to Cryptography" [2] they clearly talk about "PGP certificates" instead of "PGP public keys".
[1] [2] ftp://ftp.pgpi.org/pub/pgp/6.5/docs/english/IntroToCrypto.pdf

@_date: 2017-08-17 16:05:57
@_author: Damien Goutte-Gattat 
@_subject: export secret subkeys 
Seemingly, yes. But actually, when using --export-secret-subkeys, the master private key is not really exported. The command does produce a "secret key packet" corresponding to the master key, but this packet does not actually contain the private key material.
Look for the "gnu-dummy S2K" line in the details of the secret key packet:
It's the clue indicating that this packet is actually unusable. And that's what the man page means when it says:
"The second form of the command has the special property to render the secret part of the primary key useless."
The purpose of this command is to create a situation where only the private subkeys are available on the machine, while the master private key is stored offline.

@_date: 2017-08-27 13:38:38
@_author: Damien Goutte-Gattat 
@_subject: Newbie Question: Creating a Key Server using GNUPG tools 
Not with GnuPG itself. The GnuPG project does not provide a keyserver Most keyservers out there are powered by a software called SKS (Synchronizing Key Server) [1,2].
For a local network, a LDAP-based keyserver may also be considered. The GnuPG wiki has a page on how to setup such a server [3].
Finally, with GnuPG modern (>= 2.1) you may choose to setup a Web Key Directory. This is a recently introduced approach to key distribution, for which GnuPG provides some tools and documentation [4,5].
Hope that helps,
[1] [2] [3] [4] [5]

@_date: 2017-02-08 10:17:03
@_author: Damien Goutte-Gattat 
@_subject: content of private-keys-v1.d 
This folder holds all the private keys. It was initially used only by gpgsm (for S/MIME keys), but since GnuPG 2.1 it is also used by gpg (for OpenPGP keys). The "v1" part in the name has nothing to do with the version of GnuPG.
Even when your private keys are stored on a smartcard, you would still have a corresponding file in the private-keys-v1.d directory. But this file is only a "stub", that is, it only tells GnuPG that the actual key material is stored on a smartcard.

@_date: 2017-02-08 13:31:25
@_author: Damien Goutte-Gattat 
@_subject: content of private-keys-v1.d 
Yes. The stub contains only the serial number of the smartcard on which
the private key is stored.
The stub is completely useless without the corresponding smartcard, yes.
If the key is not on a smartcard, then the file contains the whole
private key. Note, however, that the key is stored in an encrypted form,
which means that stealing the file is not enough: your attacker would
also need to know your passphrase to make any use of the key.
I don't think it has really been documented. I guess the source code *is* the documentation.

@_date: 2017-02-08 18:40:21
@_author: Damien Goutte-Gattat 
@_subject: content of private-keys-v1.d 
Obviously I had completely overlooked this file, my bad.
Sorry for the disinformation. It's good to know that the documentation is there.

@_date: 2017-02-19 15:58:56
@_author: Damien Goutte-Gattat 
@_subject: GPG, subkeys smartcard and computer 
Some time ago, I did some experiments with a RSA master key with two sets of subkeys: RSA subkeys and ECC-based subkeys (ECDSA for the signing subkey, ECDH for the encryption subkey).
The idea was to test whether such a setup could be used by someone wanting to use elliptic-curve cryptography, but at the same time not wanting to cut herself from people still using GnuPG 2.0.x (which has no support for ECC).
Let's say Alice and Bob both use GnuPG 2.1, but Charlie uses GnuPG 2.0. And Alice uses the setup described above, where the ECC-based subkeys were created *after* the RSA-based subkeys.
For encryption: When Bob wants to encrypt a message to Alice, his gpg program automatically selects the latest encryption subkey it can use, that is, the ECDH subkey. On the other hand, when Charlie wants to encrypt a message to Alice, his gpg program skips the unsupported ECDH subkey and automatically selects the remaining RSA subkey. So everything work, Alice and Bob can benefit from ECC support in GnuPG 2.1 while still allowing Charlie to use RSA.
For signing: Alice signs her messages with *both* her RSA subkey and her ECDSA subkey (using multiple --local-user options), allowing both Bob and Charlie to verify her messages even though Charlie is stuck with GnuPG 2.0 and RSA.
(Eventually, Charlie will upgrade to GnuPG 2.1, and Alice will then revoke her RSA subkeys.)
Disclaimer: I am not advocating such a setup, that I don't even actually use. I did those tests mostly out of curiosity (I stick to RSA keys even with GnuPG 2.1, so I have no need to worry about backward compatibility). But I guess it's a possible reason for wanting more than one set of subkeys.

@_date: 2017-02-28 00:35:31
@_author: Damien Goutte-Gattat 
@_subject: help 
It should.
Note, however, that Riseup's Best Practices [1] and proposed configuration file [2] are partially obsolete, *especially* if you are using GnuPG 2.1. Many of the proposed options and advices are not needed anymore, as GnuPG already does The Right Thing.
If you're using the sks-keyservers.net pool you no longer need to provide GnuPG with the CA certificate file, as it is now bundled with GnuPG (>= 2.1.11) and automatically used when needed. (And with GnuPG >= 2.1.16 you will no longer even need to explicity set the keyserver option, as hkps.pool.sks-keyservers.net is already the default.)
This option no longer exists, but I *think* that if you really want to, you can disable SRV lookups by explicitly specifying a port number when setting the keyserver, as in:
   keyserver hkps.pool.sks-keyservers.net:443
[1] [2]

@_date: 2017-01-06 14:52:57
@_author: Damien Goutte-Gattat 
@_subject: gpg-agent has to be restarted after GnuPG SmartCard pulled from 
For what is worth, I have two such readers, which are working flawlessly with the ccid driver [1] and with 2048-bit keys. I have not tried them with the internal driver.
I also have a SCM 3500 reader from SCM Microsystems (now Identiv), again working flawlessly with the ccid driver.
Instead of watching the log, you could use a feature of Scdaemon: if the file $GNUPGHOME/scd-event exists and is executable, it will be called on every card reader status change.
For example, to act upon card removal, you could have the following:
      case "$8" in
   NOCARD)
       # do something
       ;;
   esac
See doc/examples/scd-event in GnuPG's source for more details of what this script can do.
[1]

@_date: 2017-01-18 15:24:11
@_author: Damien Goutte-Gattat 
@_subject: Did I break my Ubuntu GPG installation? 
It looks like you didn't save and restore your trust database when you deleted your .gnupg folder (it's a file called trustdb.gpg). As a result, GnuPG does not know what level of ownertrust should be assigned to your key.
Your own key should normally be "ultimately trusted", and is the root from which all key validity computation are done. Without an ultimately trusted key, no key can be valid.
Editing your key and manually setting its ownertrust to "ultimate" (using the "trust" command in the key editor) should be enough.
Hope that helps,

@_date: 2017-01-18 16:39:27
@_author: Damien Goutte-Gattat 
@_subject: Trust signature domain 
I believe there's a bug in the handling of the regular expression associated with a trust signature. I've just submitted a patch to fix it [1]. With that patch applied, I get the expected result for step 10 (Blake's key is fully valid, not the others') and step 14 (Blake's key is fully valid, and so are Chloe's and David's keys).
For step 16, none of the keys are valid, but I think that's the expected behavior: you signed Introducer with a level 2 trust signature restricted to example.es, so the signature of Blake's key (which as an example.org UID) is rightly ignored. Blake's key is thus of unknown validity and his signatures on Chloe's and David's keys are ignored as well.
(Side note: you can use the '%transient-key' directive when batch-generating keys for testing purposes. This instructs GnuPG to use a less secure but faster random number generator, thus speeding up the generation process.)
[1]

@_date: 2017-01-25 22:25:45
@_author: Damien Goutte-Gattat 
@_subject: gnupg website 
The main problem would be its 64-bit block size. Apparently there's a "practical" attack against 64-bit ciphers as used in TLS [1].
That's probably reason enough to avoid 3DES whenever possible (when a 128-bit cipher is available).
[1]

@_date: 2017-01-26 11:20:58
@_author: Damien Goutte-Gattat 
@_subject: sha1 pgp fingerprint 
People *do* talk about this. But a change of the hash algorithm used for fingerprinting keys cannot be decided unilateraly by GnuPG developers. All OpenPGP implementations have to agree on such a change, that's why the discussions occur on the IETF OpenPGP mailing list.
See for example those threads:

@_date: 2017-07-02 21:29:13
@_author: Damien Goutte-Gattat 
@_subject: using GnuPG card for Firefox master password 
As far as I know, not as the master password protecting Firefox's own password store. But what you can do is make Firefox use *another* password store, one that relies on GnuPG.
pass [1] is a password manager which encrypts passwords with the user's GnuPG key. Several plug-ins are available to instruct Firefox to use pass instead of its own password storage system, such as PassFF [2] or BrowserPass [3]. (Disclaimer: I tried none of them.)
So, when Firefox will need a password it will ask pass, which will call gpg, which will in turn "call" your smartcard.
An obvious drawback of this method is that you need to migrate all your passwords from Firefox's own storage to pass. There is at least one script available for that [4], but again I did not try it.
Hope that helps,
[1] [2] [3] [4]

@_date: 2017-07-14 17:10:06
@_author: Damien Goutte-Gattat 
@_subject: [Announce] Scute 1.5.0 released 
The GnuPG Project is pleased to announce the availability of Scute
Scute is a PKCS module built around the GnuPG Agent and the GnuPG
Smart Card Daemon. It allows you to use your OpenPGP smart card for TLS
client authentication and S/MIME mail and document signing.
Noteworthy changes in version 1.5.0 (2017-07-14)
* Support for TLS 1.2.
* Support for S/MIME signing. This has been tested with Thunderbird (to
   sign e-mails) and with LibreOffice (to sign OpenDocument and PDF
   files).
* Support for 4096 bit RSA keys.
* Better support for GnuPG 2.1:
   - A communication bug between GnuPG Agent and Scute, leading to failed
     signatures, has been fixed.
   - Scute now relies on gpg-connect-agent to be able to always find the
     socket for GnuPG Agent, no matter where that socket is actually
     located.
* C_GenerateRandom function is implemented. This allows Firefox to seed
   its entropy pool using the OpenPGP smart card's random number
   generator.
Source code is hosted at the GnuPG FTP server and its mirrors as listed
as .  On the primary server the
source tarball and its digital signature are:
  ftp://ftp.gnupg.org/gcrypt/scute/scute-1.5.0.tar.bz2 (968k)
  ftp://ftp.gnupg.org/gcrypt/scute/scute-1.5.0.tar.bz2.sig
The same files are also available via HTTP:
    Scute is copyrighted by g10 Code GmbH ans licensed under the GNU General
Public License version 2 or later (GPLv2+) with the following exception:
   In addition, as a special exception, g10 Code GmbH gives permission
   to link this library: with the Mozilla Foundation's code for
   Mozilla (or with modified versions of it that use the same license
   as the "Mozilla" code), and distribute the linked executables.  You
   must obey the GNU General Public License in all respects for all of
   the code used other than "Mozilla".  If you modify the software, you
   may extend this exception to your version of the software, but you
   are not obligated to do so.  If you do not wish to do so, delete this
   exception statement from your version and from all source files.
The Scute manual is included in the source distribution and is also
available online at . For
community support, you may ask on the gnupg-users mailing list
If you need commercial support, check out
Maintenance and development of Scute and of GnuPG as a whole is mostly
financed by donations. Please consider donating via

@_date: 2017-07-31 18:38:09
@_author: Damien Goutte-Gattat 
@_subject: 'sign (and cert)' or just 'cert' on a master key with subkeus 
For what it is worth, I disagree.
The main problem I have with that document is that it implies the user should care about a lot of details that he actually should not have to care about, especially with a decently recent GnuPG version.
* Starting from GnuPG 2.1.16, the user has nothing to do to use the SKS keyserver pool, that's already the default. There's no need to manually download the CA certificate for the pool, either, because it is now included directly in GnuPG.
* There is no need to "ensure that all keys are refreshed through the keyserver you have selected"--the honor-keyserver-url option is already disabled by default.
* There is no need to generate a revocation certificate. GnuPG already does that when you create a new keypair. You need to do it yourself only if you generated your key some years ago, before automatic generation of revocation certificates was implemented (i.e. before GnuPG 2.1).
* There is no nothing to do to "have a separate subkey for encryption". When creating a new keypair, GnuPG automatically creates a primary key for signing and certifying, *and* a subkey for encryption. (I do not remember when GnuPG started to do that, but I am pretty sure this is not new at all.)
* Unless you generated your key a long time ago, you absolutely do not have to "make sure your key is OpenPGPv4". No recent or even not-so-recent version of GnuPG will ever generate a v3 key.
* Likewise, there is no need to check that self-signatures do not use MD5, unless your keys are *very old*.
* Likewise for SHA-1. I think GnuPG stopped using SHA-1 as the default hash algorithm sometimes in 2009.
So all of those advices could be replaced by a single one: "Use a recent GnuPG version. Ideally, use the most recent version available. At the very least, do not use a decade-old version."
The problem with recommanding unnecessary steps is that they will confuse the beginner and make him think that GnuPG is more difficult to use than it already is.

@_date: 2017-06-04 14:04:55
@_author: Damien Goutte-Gattat 
@_subject: scute / firefox: cannot connect to GPG agent 
Can you please check whether it is really the case? E.g., check that the socket indicated by "gpgconf --list-dir agent-socket" does exist?
Yes, GnuPG 2.1 does not use (nor set) that variable anymore. But Scute still needs it in order to locate the socket, especially now that the socket is no longer always located in $GNUPGHOME.
If I remember correctly, the problem goes like this:
1) Scute looks for GPG_AGENT_INFO
2) The variable does not exist, so Scute looks for the socket in $GNUPGHOME
3) The socket is not there (because it is now somewhere under [/var]/run), so Scute assume there's no running agent
4) Scute spawns a new agent with the --use-standard-socket option (which used to instruct the agent to create its listening socket in $GNUPGHOME, but which has no effect with GnuPG 2.1)
5) Scute still does not find the socket in $GNUPGHOME, and thus fails with "Cannot connect to GPG Agent"
To avoid this, you need both to set the GPG_AGENT_INFO variable and make sure that the agent is running before you start Firefox (simply calling "gpg-connect-agent /bye" is enough).
The GPG_AGENT_INFO variable must have the following form: "PATH_TO_SOCKET:PID:VERSION", where PID is the running agent's process ID and VERSION is the version of the agent protocol (which must be 1). Otherwise Scute will ignore the variable.
So try instead:
GPG_AGENT_INFO=$(gpgconf --list-dir agent-socket):0:1 firefox
(The PID can be set to zero because as far as I know Scute does not actually use that information.)
Hope that helps,

@_date: 2017-06-05 11:49:48
@_author: Damien Goutte-Gattat 
@_subject: scute / firefox: cannot connect to GPG agent 
I am not sure. Can you check that after starting Firefox, you still have only one GPG-Agent and one Scdaemon running?
If you run the following command:
   $ gpg-connect-agent "SCD GETINFO pid" /bye
(which returns the PID of the running Scdaemon), do you get the same PID than the one displayed in your error messages?

@_date: 2017-06-05 19:37:27
@_author: Damien Goutte-Gattat 
@_subject: scute / firefox: cannot connect to GPG agent 
OK, this is weird. 259 bytes seems too short for a X.509 certificate, especially one based on 4096-bit public key (for comparison, my own 2048-bit certificate is 1587 bytes).
Maybe an error occured when the certificate was stored on the Yubikey, and the certificate there is actually truncated?
Could you extract the certificate from the smartcard and have a look at it? Run gpg in card-edit mode, and at the prompt, use the (undocumented) readcert command to save the certificate to a file
   $ gpg --card-edit
   gpg/card> readcert 3 > file.der
   gpg/card> quit
Then inspect the contents of file.der, using e.g. openssl:
   $ openssl x509 -inform DER -in file.der -text
 > [...]
Did you import your new certificate onto the Yubikey? Because independently of what your gpgsm store may contain, Scute will always try to fetch the certificate from the token itself.

@_date: 2017-06-05 20:29:30
@_author: Damien Goutte-Gattat 
@_subject: scute / firefox: cannot connect to GPG agent 
You do not *have* to; Scute can fetch the certificate both from the token itself, or from the gpgsm store. But it will try first to fetch it from the token.
Storing the certificate on the token itself instead on relying on the gpgsm store allows you to use your token on a machine that is not your usual machine.
I don't pretend to be a X.509 or ASN1 expert (far from it!), but this does not look like a X.509 certificate at all.
Check the maximal size supported by the Yubikey:
   $ gpg-connect-agent 'SCD GETATTR EXTCAP' /bye
The output should be a line like the following:
   S EXTCAP gc=1+ki=1+fc=1+pd=1+mcl3=2048+aac=1+sm=0+si=5+dec=0+bt=0
The maximal size for the certificate to be stored on the token is indicated by the "mcl3" value (so, 2048 bytes in this example). Your DER-encoded certificate should not be bigger than that.
But if it happens that your Yubikey does not support 4096-bit certificates, and you still want such a certificate, then you could simply erase the (corrupted) certificate on the Yubikey. As I said above, Scute will fetch the certificate from the gpgsm store if it cannot find it on the token.
As far as I know there is no command in the gpg card editor to erase the certificate, but I *think* using the writecert command with /dev/null as input should do the trick (I have not tested).

@_date: 2017-06-06 14:08:54
@_author: Damien Goutte-Gattat 
@_subject: scute / firefox: cannot connect to GPG agent 
You may also try the patch below. It should allow Scute to ignore the
data read from the token if it does not look like a proper DER-encoded
certificate. It's not a fool-proof check, but it should already catch
a lot of cases (including yours).

@_date: 2017-06-12 13:28:28
@_author: Damien Goutte-Gattat 
@_subject: changing the passphrase of the secret key stored in the GnuPG card 
You would have to import your backup key into your private keyring using gpg's --import command.
First, remove the private key stubs:
   $ rm ~/.gnupg/private-keys-v1.d/*.key
Then, import your backup:
   $ gpg2 --import backup.gpg
You will then be prompted for the passphrase you choose when the backup was created.
At this point, it's as if you had never used a smartcard.
Once you have a new smartcard to replace your lost one, you may move the restored keys to the new smartcard using the keytocard command.
(Note that depending on what happened to your original card, you may prefer to *revoke* those keys and generate new keys.)
Copy your current .gnupg directory to a temporary GNUPGHOME:
   $ cp -r .gnupg ~/testbackup
   $ export GNUPGHOME=~/testbackup
Then you can test the above procedure:
- Remove the key stubs:
   $ rm ~/testbackup/private-keys-v1.d/*.key
- Import your backup:
   $ gpg2 --import backup.gpg
At this point, you will know if the passphrase works correctly.
And if you want to change the passphrase of your backup:
   $ gpg2 --edit-key Matthias passwd
   $ gpg2 -o backup-with-new-password.gpg --export-secret-keys
Once you are satisfied, you can wipe the testbackup directory out.
Hope that helps,

@_date: 2017-06-12 13:45:18
@_author: Damien Goutte-Gattat 
@_subject: changing the passphrase of the secret key stored in the GnuPG card 
I forgot an important detail:
This command will delete *all* your private keys. You should use it "as is" only if *all* your private keys are stored on a smartcard.
If you have other private keys in your keyring that are not stored on a smartcard, do *not* delete all files in ~/.gnupg/private-keys-v1.d! Instead, get the keygrip of each of your card keys
   $ gpg2 --with-keygrip --list-secret-keys
and delete only the corresponding files under ~/.gnupg/private-keys-v1.d.

@_date: 2017-06-16 11:32:15
@_author: Damien Goutte-Gattat 
@_subject: How to join pubring.kbx and pubring.gpg? 
Well, there is the Monkeysphere's pem2openpgp tool [1], but AFAIK it only works with *private* keys, not public keys.
No. You would generate an OpenPGP-encrypted message that your partner won't be able to decrypt using their S/MIME software. They would need an OpenPGP implementation (be it GnuPG or any other one).
You seem to be confused between OpenPGP certificates and X.509 certificates, and I think this is the root of your problem.
Let me try to explain.
There are two completely independent standard for e-mail encryption and signing: OpenPGP and S/MIME.
Each standard uses its own formats. OpenPGP uses OpenPGP certificates (which are called "public key" out of habit, but they really are certificates), and S/MIME uses X.509 certificates.
Both partners in a conversation have to use the same standard, either OpenPGP or S/MIME (of course they can use *any* software implementing the same standard, because that's what standards are all about).
Now what you got from your partner is a X.509 certificate, which means that said partner is using S/MIME, not OpenPGP.
There's no many options here: you and your partner must agree on the standard you use for your communications. Either you convince your partner to switch to OpenPGP when he is communicating with you, or you switch yourself to S/MIME when you're communicating with him.
Thunderbird already supports S/MIME and X.509 certificates natively, you do not need Enigmail for that.
[1]

@_date: 2017-05-16 10:10:28
@_author: Damien Goutte-Gattat 
@_subject: Using a GnuPG CCID card in another computer (follow-up) 
The card only contains the private keys. GnuPG also needs some informations that are only contained in the public parts, such as the User IDs associated with the key and the bindings between a primary key and its subkeys.
So while you no not have to move *all* the files below .gnupg, you at least need to import your *public* key onto your other workstation.
(That's why the card editor of GnuPG has a "fetch" command. The idea is that you put your public key in a publicly-accessible location, and make the "URL" field of your card point to that location. With that, upon arriving onto a new computer--with an empty or inexisting .gnupg--, you can get a working setup just by inserting your card, firing up the card editor, and using the "fetch" command".)
They normally contain the private key themselves. When the private keys are stored on a smartcard, they are "stubs", whose purpose is to inform GnuPG that the keys are on a smartcard (notably, they contain the serial number of said smartcard).
GnuPG should normally re-create those stubs automatically if they do not exist when you run the --card-status command, so you should not have to copy them over manually.
What is troubling in your experience is that you said there was "no key in the card" when you first run "gpg2 --card-status" on the new workstation. I have no explanation for that.

@_date: 2017-05-31 01:22:15
@_author: Damien Goutte-Gattat 
@_subject: Obtaining sig2 and sig3 signatures 
Well, no one. You rely on the ability of the signer to distinguish between a real ID-card and a fake ID-card. Of course, not everyone can spot a well-crafted fake ID (I certainly cannot).
That's one reason why some people actually object to key-signing parties where participants are required to show an ID-card. Another reason is that requiring an ID-card is equivalent to trusting the government emitting those cards, and not everyone is OK with that (after all one of the goals of the web-of-trust is to avoid the need for centralized I think that, for most users, certification levels are actually useless due to the fact that the different certification levels don't have an universally recognized meaning.
The OpenPGP standard (RFC 4880) says nothing about the meaning of certification levels 2 and 3. It is up to the signing user to decide what is a "casual certification" (level 2) and what is a "positive certification" (level 3).
With the meaning of a sig2 or a sig3 depending on the certification policy of the signer, the whole feature is quite pointless in my opinion.
(Maybe certification levels can still be useful when OpenPGP is used in a closed, controlled setup--e.g. within an organization which can define its own rules, to be followed by all its members. Maybe.)
Incidentally, I also think that many users will be much happier with the TOFU trust model, where they won't have to care about all this "key signing stuff" (unless they want to). Discussing about certification levels will likely be irrelevant when TOFU will become the default trust

@_date: 2017-10-10 14:27:11
@_author: Damien Goutte-Gattat 
@_subject: Is there some writeable memory on the OpenPGP-card 
The OpenPGP Card specification defines "Private Use Data Objects" that you may use to store arbitrary data.
You can write to those DO using the "privatedo" command of the GnuPG's card editor. For example, to send the contents of the test1.txt file to the private DO    $ gpg --card-edit
   gpg/card> privatedo 1 < test1.txt
Caveats to be aware of:
* In versions 2.0 and 2.1 of the OpenPGP Card specification, private DOs are limited in size to 254 bytes each. (In version 3, there is no upper limit fixed in the specification.)
* Private DOs are optional and not all implementations support them. (Yubico's Yubikey NEO does not, for example).

@_date: 2017-10-29 22:08:28
@_author: Damien Goutte-Gattat 
@_subject: Impact of ROCA (CVE-2017-15361) in subkey vs. private key? 
There is no mathematical link between a primary (or master) key and a subkey. A subkey is linked to a primary key only through a "subkey binding signature".
If a subkey is compromised (meaning an attacker somehow managed to know the private key, be it through the ROCA vulnerability or any other method), this has *no impact* on the primary key. The attacker won't be able to infer any information about the primary key.
This is also true the other way around: knowing the primary private key does not allow to deduce the private subkey(s).

@_date: 2017-09-05 10:58:45
@_author: Damien Goutte-Gattat 
@_subject: Documentation of trust model 
As far as I know, not really. Certainly not in the OpenPGP RFCs. RFC4880 and its predecessors never defined any trust model, they only defined some ?tools? that can be used by a trust model (such as the different certification types or the trust signature packet). But the trust models themselves are left to the implementors.
I seem to remember that someone on the IETF OpenPGP mailing-list evoked the idea of writing a complementary, informational RFC to describe routinely used trust models, but I don?t think it has ever been done.
As for the ?classic? and ?pgp? trust models as used by GnuPG, very  briefly:
In the ?classic? trust model, GnuPG determines whether a given non-expired, non-revoked OpenPGP public key is valid by looking at the signatures (?certifications?) carried by that key. The key is fully valid, marginally valid, or of unknown validity depending on the number of certifications emitted by trusted keys in the user?s keyring.
The key aspect of the ?classic? trust model is that it only determines the *validity* of a key. *Ownertrust* (the value associated with a key and which indicates if certifications emitted by that key are taken into account) is always manually set by the user. (This is something that is frequently misunderstood.) A ?classic? signature only means something like ?I certify that this key belongs to its stated owner?.
By contrast, in the ?pgp? trust model, users can emit ?trust signatures?, which carry both validity and ownertrust information. A trust signature means ?I certify that this key belongs to its stated owner *and* I regard its owner as trustworthy.?
To illustrate the difference, let?s consider the following (from the point of view of Alice):
a) Alice signs Bob?s key and fully trusts Bob;
b) Bob signs Carol?s key and fully trusts Carol;
c) Carol signs David?s key.
In the ?classic? trust model, only Bob?s and Carol?s key are valid (Bob?s key because it is signed by Alice?s own key, and Carol?s key because it is signed by Bob?s key, which Alice fully trusts). But David?s key is of unknown validity because Alice never assigned an ownertrust value to Carol?s key. The fact that Bob fully trusts Carol is irrelevant; actually, Alice does not even know that Bob fully trusts Carol.
In the ?pgp? trust model, and assuming that Alice and Bob emitted trust signatures instead of simple signatures (I ignore, for simplicity?s sake, the notion of trust depth and the possibility to assign marginal ownertrust), Carol?s key has full ownertrust in the eyes of Alice even though Alice never explicity assigned an ownertrust value to it. Consequently, David?s key is valid.
Obviously there would be much more to describe, but I hope the above helps a little bit.
For what it?s worth, I wrote a document attempting to describe more thoroughly the various trust models used by GnuPG (including the new TOFU models) [1]. Unfortunately, it?s in French. :( I wanted to write an English version but never found the time nor the motivation?
[1]

@_date: 2017-09-10 19:47:07
@_author: Damien Goutte-Gattat 
@_subject: [Feature Request] Multiple level subkey 
The OpenPGP specification already has some support for a hierarchical system, in the form of "trust signatures".
(Hereafter, I will use "trust-sign" as a verb to refer to the act of emitting a trust signature.)
For a 3-levels hierarchy as you describe, you could do the following:
a) You sign your level-3 key(s) with your level-2 key;
b) You trust-sign your level-2 key with your level-1 key, with a trust depth of 1.
c) Your correspondents trust-sign your level-1 key, with a trust depth of 2.
If your level-1 key is compromised, you revoke it, generate a new one and sign it with the level-2 key. The new level-1 key will be automatically valid for your correspondents.
If your level-2 key is compromised, you revoke it, generate a new one, tsign it with the level-1 key, and use it to re-sign your level-1 key (although if the level-2 key is compromised, you may want to assume that the level-1 key is compromised as well, and generate a new one). Again, the new level-2 key will be valid and trusted by your correspondents, since it bears a trust signature from the level-1 key.
The problem you may have with this method is that it depends on your correspondents *trust-signing* your level-1 key. If they use a normal signature instead (or a trust signature with a trust depth < 2), no ownertrust will be assigned to the level-2 key and therefore the level-3 key will not be considered valid. So you have to tell your correspondents to *trust-sign* your level-1 key, but you cannot force them to do so.
This is kind of a design feature of OpenPGP, by the way: the user is always free to choose whom he wants to trust, and to what extent. This is by contrast with the X.509 world, where the fact that a certificate can only be signed by *one* authority gave rise to an ecosystem of CAs that are "too-big-to-fail" (or "too-big-to-choose-not-to-trust").
Slightly off-topic, but using a NFC-enabled token might be an easier way to deal with that particular concern. I know of at least two such tokens: the Yubikey NEO [1] and the Fidesmo Privacy Card [2].
[1] [2]

@_date: 2017-09-10 20:39:04
@_author: Damien Goutte-Gattat 
@_subject: [Feature Request] Multiple level subkey 
Sorry, I did mix level-1 and level-3 keys in the first sentence you're quoting. What I meant was:
If your level-3 key is compromised, you revoke it, generate a new one and sign it with the level-2 key. The new level-3 key will be automatically valid for your correspondents.

@_date: 2017-09-10 21:50:03
@_author: Damien Goutte-Gattat 
@_subject: [Feature Request] Multiple level subkey 
You revoke the level-2 key, that will be enough to invalidate the signature on the level-3 key.
Assuming the level-1 key is not on that device, then no.
I merely pointed out what is already feasible with the current state of the OpenPGP specification and the GnuPG implementation.
I do not really care for this "user is an idiot, we cannot trust him/her to do the right thing so we should do it for him/her" approach.

@_date: 2017-09-11 00:01:24
@_author: Damien Goutte-Gattat 
@_subject: [Feature Request] Multiple level subkey 
No it cannot.
And to be more precise, in the situation where the level-2 key is compromised, you actually do not revoke the level-2 key itself (using the corresponding level-2 private key), you revoke the trust signature on the level-2 key (using the level-1 private key). The level-2 will then cease to be valid in the eyes of your correspondents.
So you want to bring privacy to the housewife while at the same time make her rely on someone else (the "son/trust person" you mentioned) to manage her privacy? But is it still privacy then?
If I had to trust someone else with my privacy, I think I would rather trust the faceless algorithms running in a Google datacenter than a person close to me and who keep telling me "don't worry, I'm taking care of everything, just relax."
(If you think that your son or your "trust person" cannot betray you, well, by definition you can be betrayed *only* by someone you trust.)
GnuPG (and free software in general) should empower users to take privacy in their own hands, not incite then to rely on a "trust person".
That's only my opinion, of course.

@_date: 2017-09-18 18:00:07
@_author: Damien Goutte-Gattat 
@_subject: Extending expiration date and SSH 
No. The expiration date of the subkey is not part of the key material itself, it is stored in the subkey binding signature. A modification of the expiration date has no effect on the public key as seen by SSH.

@_date: 2018-04-02 13:43:52
@_author: Damien Goutte-Gattat 
@_subject: Again: Writing DER certificates to ZeitControl Cards 
I don't know for the v3.3 card, but v2.1 cards allow for a 2048 bytes certificate (at least mine does, but maybe this has changed between different production runs?).
One way of finding the max allowed size is the following command (here tested with a Yubikey NEO):
$ gpg-connect-agent 'SCD LEARN --force' /bye | grep '^S EXTCAP'
S EXTCAP gc=1+ki=1+fc=1+pd=0+mcl3=1216+aac=0+sm=2+si=0+dec=0+bt=0
The value you are interested in is "mcl3". In this example, it says that the Yubikey NEO allows for a 1216-bytes certificate.

@_date: 2018-04-19 09:16:46
@_author: Damien Goutte-Gattat 
@_subject: Semantics of WOT and Subkeys 
For most purposes, the use of subkeys is "transparent" from the user's point of view. Users only need to be concerned about their correspondants' master (or primary) key.
In particular :
Yes [1].
Unless Alice played with GnuPG's source code, she can only use her master key to sign Carol's key.
Signing a key ("certify", to use the proper term), in OpenPGP, is a special form of signing which requires a key with the "Certify" capability instead of the "Signing" capability. Only the master key has that capability. As far as I know it is not possible to generate a certification-capable subkey.
Hope that helps,
[1] Assuming the subkey is correctly bound (with correct signatures) to Alice's master key. But this is something that not even Alice should have to care about, this is all taken care of by GnuPG when she generates her new subkey.

@_date: 2018-04-22 21:27:17
@_author: Damien Goutte-Gattat 
@_subject: Backup .gnupg using git 
Can't really tell anything without knowing your adversary (is it Mossad or not-Mossad? [1]), but here are a few remarks.
You do not say which version of GnuPG you are using. Assuming you are using the latest available version on your system (which you should), most of the options you put in your gpg.conf and dirmngr.conf are useless, as they are already in the default settings (something many authors of those "create a perfect keypair" howtos seem to ignore).
Also, your gpg.conf contains the following:
   # Avoid information leaked
   [...]
   export-options export-minimal
If the goal here is to avoid revealing who signed your key (this option tells GnuPG to remove all third-party signatures on your key), then this is completely defeated by the fact that you upload your entire public keyring to a world-readable Github repository!
Combined with the trust database that you *also* upload, this is a pretty serious information leak IMO, as anyone can learn not only who signed your key, but also which keys you collected over time, which keys you signed (even if you only signed them locally), and how much you trust the owners of all those keys. Are you fine with that, or didn't you realize the implications of uploading those files?
Finally and as a general rule, if you are not sure of what you are doing, I am strongly of favour of following only those two advices:
* Use the latest GnuPG version available on your system. In particular, if you invoke `gpg`, make sure this is GnuPG >= 2.1 and *not* GnuPG 1.x.
* Use the default settings.
[1]

@_date: 2018-08-14 09:26:44
@_author: Damien Goutte-Gattat 
@_subject: Public vs Private Fingerprint 
Actually there's no such thing as a private key fingerprint.
Fingerprints are only calculated on public keys.
(Theoretically you *could* compute a fingerprint on a private key, but
as far as I know that's never used in OpenPGP.)
Even when GnuPG is displaying a private key (e.g. with the
--list-secret-keys command), the fingerprint is the fingerprint of the
corresponding public key.

@_date: 2018-08-14 13:43:21
@_author: Damien Goutte-Gattat 
@_subject: Public vs Private Fingerprint 
Maybe not in GnuPG's manual, but it is explicitly documented in the
specification of the OpenPGP format (RFC 4880, ?12.2 [1]):
[1]

@_date: 2018-08-23 16:50:00
@_author: Damien Goutte-Gattat 
@_subject: gpg not able to find my secret key 
GnuPG >= 2.1 does not use ~/.gnupg/secring.gpg anymore. Secret keys are
now stored in the ~/.gnupg/private-keys-v1.d folder (one file per key).
When you say you "moved ~/.gnupg directory from old machine to new one",
did you make sure to include the private-keys-v1.d folder?
Related question: Do you have a file named "gpg-v21-migrated" in your
.gnupg directory?
Waiting for your answers, I suspect the following happened:
* You were using GnuPG < 2.1 before (1.4 or 2.0), with your private keys
in the secring.gpg file.
* At some point you upgraded to GnuPG 2.1; GnuPG automatically migrated
your keys from the secring.gpg file to the private-keys-v1.d folder
(leaving the gpg-v21-migrated file as a marker that the migration occured).
* When you moved your .gnupg folder, the private-keys-v1.d folder was
somehow left behind (maybe because you didn't know about it). So
gpg-agent cannot find your private keys.
* Even though you still have a copy of your private keys in the
secring.gpg file, GnuPG will not even look at this file, since the
gpg-v21-migrated file tells it that the private keys were already migrated.
If that's what happened, then simply removing the gpg-v21-migrated file
should be enough to trigger a new migration and allow you to get your
private keys where the agent expects to find them.
I am, however, a little bit concerned by the following:
gpg-agent should be started automatically by gpg as soon as it is needed
(such as when you ask for a listing of the secret keys). The fact that
the agent is *not* running could indicate a problem in your GnuPG
installation, independently of the presence or absence of the
private-keys-v1.d folder.

@_date: 2018-08-24 12:38:08
@_author: Damien Goutte-Gattat 
@_subject: gpg not able to find my secret key 
When you say that you have two keys, do you mean two *primary* keys? If
so, each primary key probably has an encryption *subkey* (automatically
generated by GnuPG, that has been the default behavior of GnuPG for a
very long time), so you end up with four private keys.
As for the fact that you see "different hashes", that's because `gpg
--list-keys` prints out the *fingerprints*, whereas gpg-agent's keyinfo
command prints out the *keygrips*.
A fingerprint and a keygrip are both hashes of a public key, but they
are computed differently and don't serve the same purpose. Fingerprints
are specified by the OpenPGP format and uniquely identify an OpenPGP
key. Keygrips are used internally by gpg-agent to uniquely identify a
key independently of any protocol.

@_date: 2018-12-10 14:56:54
@_author: Damien Goutte-Gattat 
@_subject: Garbled data in keyservers 
As far as I know, most keyservers nowadays no longer accepts key
submission by e-mail. Those that still support the e-mail
interface only do so to allow *querying* the keyserver, not
*adding* any key; that is, they only support the INDEX and the GET
commands, not the ADD command.
- Damien

@_date: 2018-12-11 18:11:03
@_author: Damien Goutte-Gattat 
@_subject: Smart cards 
I know of at least one NFC-enabled OpenPGP card, the "Fidesmo
Card" [1].
I never tested it, but from what I remember when I delved into
their site, the OpenPGP feature of that card is provided by the
same JavaCard applet than the one used in the Yubikey NEO. Which
means, among other things, that it does not implement version 3 of
the OpenPGP Card specification (so, no ECC keys), and does not
support RSA keys larger than 2048 bits.
Another provider of NFC-enabled OpenPGP cards was Sigilance [2],
but they have since ceased all operations. Their cards were also
based on the same JavaCard applet, with the same limitations.
I am not aware of an available implementation of the OpenPGP Card
v3, with support for ECC keys and RSA 4096-bit, on a NFC-enabled
- Damien
[1] [2]  (warning: expired certificate)

@_date: 2018-12-31 12:45:44
@_author: Damien Goutte-Gattat 
@_subject: gpg - difference --encrypt-to and --recipient 
You do realize that, in the case of e-mail, the communication paths are
already disclosed by the SMTP protocol (command "RCPT TO") and the mail
headers ("From", "To", and the like), which both are outside the scope
of OpenPGP protection?
Using --hidden-recipient only protects against an hypothetic attacker
who is somehow only able to obtain the email body (the OpenPGP message
itself) without the surrounding metadata.
- Damien

@_date: 2018-02-22 16:14:53
@_author: Damien Goutte-Gattat 
@_subject: enigmail with pgp 2.2.4 
You installed GnuPG 2.2.4 in /usr/local, but you still have an older version in /usr.
Everything works fine in the terminal because your shell finds the newer can see in the error message, which includes the exact command used to invoke gpg).
You must configure Enigmail to use /usr/local/bin/gpg (in the "Preferences" dialog, "Basic" tab, override the default setting).

@_date: 2018-01-02 16:04:14
@_author: Damien Goutte-Gattat 
@_subject: trouble listing keys in my private-keys-v1.d directory 
My first guess would be that pass was using gpg2, while you started using gpg which on your system is probably gpg 1.4.
The location of both the public and private keys has changed in the history of GnuPG (basically: public keys were stored in pubring.gpg in GnuPG <= 2.0, and in pubring.kbx from GnuPG 2.1, while private keys were stored in secring.gpg in GnuPG 1.x, and in private-keys-v1.d from GnuPG 2.0+). If gpg is gpg 1.x on your system, this could explain why you don't see your pass private key when you call gpg --list-keys.
Can you check precisely which version(s) of GnuPG are available on your    $ gpg --version
   $ gpg2 --version
As for pass complaining about the "unusable public key", that could be the result of the trustdb having been updated by gpg 1.4 (which did not know that the private key for 89F615FB was available, and therefore has marked the corresponding public key as untrusted instead of having ultimate trust).
If that's the case, the best option would probably be to stop using the old gpg 1.4 and use only gpg2.

@_date: 2018-01-10 11:39:54
@_author: Damien Goutte-Gattat 
@_subject: is there a preferred order to building dependencies for gnupg2 
Libgpg-error should be built first as it is required by all other libraries except npth.
Apart from that, there is no dependencies between the other libraries and they can be built in any order.
For example, when I compile GnuPG for Slackware, I do this (on a fresh VM with a "vanilla" Slackware):
1) Build libgpg-error and npth (in any order).
2) Install libgpg-error.
3) Build libgcrypt, libassuan, and libksba (in any order).
4) Install npth, libgcrypt, libassuan, and libksba.
5) Build gnupg.
(This should be suitable for any GNU/Linux system beyond Slackware. However, I don't know about building GnuPG on/for other systems.)

@_date: 2018-06-06 23:08:09
@_author: Damien Goutte-Gattat 
@_subject: STM32F103 flash ROM read-out service 
For what it's worth, STMicroelectronics claims that the attack described
in this paper "affects only the STM32F0 and is not successful in all
other series" [1].
Whether you believe them or not is up to you. Of note, the authors of
that paper themselves do not claim the attack works on anything else
than the STM32F0.
(But of course, just because *this* attack (presumably) does not work on
the STM32F103, it does not mean that nobody can ever come up with a
successful attack on that chip...)

@_date: 2018-06-11 13:04:20
@_author: Damien Goutte-Gattat 
@_subject: Expire a single UID 
This is probably the best option in my opinion, since you will no longer
use that key with this email address.
Revoking a UID is not the same as revoking a key, and does not imply
that the associated secret key has been compromised (if a key has
been compromised you should revoke the key itself, not the UID). Most
often it simply means "I no longer use that UID". Note that when
revoking the UID you will have the option of specifying a reason for the
With regard to your old key, they don't have anything to do. Your
revocation of the UID takes precedence over their signatures.
With regard to your new key, you might want to ask them if they could
sign it. One way to do that is to send them an email signed by both the
old key and the new key, so that they know you control both keys.
Here's another possibility: Have you considered using an OpenPGP card?
This would allow you to keep your private keys under your control, even
when you use them on your employer-provided system.
Hope that helps,

@_date: 2018-05-11 12:17:22
@_author: Damien Goutte-Gattat 
@_subject: Where to send a "patch" to scute. 
Patches should be sent to gnupg-devel at gnupg.org, prefixing the subject with a "[PATCH scute]" tag. Same for feature requests.
Alternatively, you may also create a Task in the GnuPG project's bug tracking system at As the maintainer of Scute, I am. :)
I just had a cursory look at the patch. Although I kind of like the idea, my main concern with it is the duplication of the entire src/slots.c file. I will not merge anything like that.
Right now, my first idea would be to avoid duplicating src/slots.c and instead use info.grip1 or info.grip3 depending on the value of the ENABLE_SIGKEY flag. But I have to give it a little bit more thoughts.
In the meantime, you might want to bring the topic to the gnupg-devel list, which is more appropriate for development-related discussions.

@_date: 2018-05-20 20:16:35
@_author: Damien Goutte-Gattat 
@_subject: A postmortem on Efail 
For information, for the problem at hand, two things have been done in that direction:
In GnuPG itself: GnuPG will now error out when attempting to decrypt *any* message that is not integrity-protected, *unless* the --ignore-mdc-error flag has been set. This has only been done in the master branch of GnuPG (to be released as GnuPG 2.3 at some point), *not* in the current stable 2.2 branch.
In GpgME: GpgME will return a failure when attempting to decrypt *any* message that is not integrity-protected, inconditionnally and even if GnuPG itself only emits a warning.
What this all means is that all clients using GpgME will lose the ability to decrypt old, unprotected message upon the next GpgME release (i.e., those clients will be completely immune to Efail even if they currently ignore the no-MDC warning). Users will still be able to decrypt such unprotected messages by calling gpg directly (with the --ignore-mdc-error flag, if needed).
Clients that spawn gpg themselves without using GpgME will still be able to decrypt unprotected messages (and therefore, be potentially vulnerable to Efail if they don't pay attention to GnuPG warnings) until GnuPG 2.3 is released.
And more generally on the backward compatibility problem: to decrypt all kind of "legacy" messages there will always be the option of using GnuPG 1.4.x, which is still maintained especially for compatibility with 1990-era PGP (it notably retains support for things like PGP 2.6 keys or the MD5 hash algorithm).

@_date: 2018-05-20 21:32:36
@_author: Damien Goutte-Gattat 
@_subject: A postmortem on Efail 
There's no plan to terminate the 1.x branch. It will not gain any new features, but as stated by Werner Koch a few months ago, it "will be kept alive for use with PGP 2 encrypted and signed data" [1].
Support for PGP 2 has already been dropped from the current stable branch, I don't think it will ever be brought back. But the 1.4.x branch *is* maintained, even if only for critical bugfixes.
[1]

@_date: 2018-05-21 09:53:22
@_author: Damien Goutte-Gattat 
@_subject: Breaking changes 
That one at least is already done. The 2.0 branch reached EOL with the
2.0.31 release on December 29, 2017. I believe Werner stated clearly
enough that there will be *no* further point release on that branch, not
even for critical security fixes. If a distro is currently shipping a
2.0.x version, backporting any such security fix will be left to the
packagers/maintainers for that distro.
The last release of the 2.0.x branch is not even listed anymore on
gnupg.org's download page.

@_date: 2018-05-21 09:54:46
@_author: Damien Goutte-Gattat 
@_subject: A postmortem on Efail 
No, I do mean that support for all PGP 2-related stuff has been dropped
from the current stable branch. Modern GnuPG (? 2.1) can neither read
nor write anything that has been generated by PGP 2.x. Compatibility
starts with PGP 5, which dates back to 1997.
Well, that's already not the case. If you have pre-1997 data, you need
to use GnuPG 1.4, which again *is* still supported precisely for this
use case. (You could also, in theory, use GnuPG 2.0.x, but *that* branch
is explicitly no longer supported.)

@_date: 2018-05-22 10:27:56
@_author: Damien Goutte-Gattat 
@_subject: Relocating pubring.kbx in gpg.conf 
You can use the keyring option as well, which works both for the old
keyring format (.gpg) and the new keybox format (.kbx). You might want
to combine that with the 'no-default-keyring' option, to prevent GnuPG
from systematically create the default $GNUPGHOME/pubring.kbx.
Note, however, that with GnuPG ? 2.1 the 'secret-keyring' option no
longer has any effect. Modern GnuPG no longer uses a secret keyring
file, private keys are handled by the Agent which always store them in
Given that in your current configuration your private keys are *not*
stored where you think they are (because 'secret-keyring' is ignored as
stated above), this is indeed as far as I know your only option.

@_date: 2018-11-05 17:03:41
@_author: Damien Goutte-Gattat 
@_subject: OpenPGP key verification + legal framework 
From what they say on the home page [1] this is expected: your key is
supposed to have only one user ID whose email component must match
the email address of your Google account...
... which, by the way, is a big "no" for me. :/
[1]

@_date: 2018-11-05 20:54:08
@_author: Damien Goutte-Gattat 
@_subject: OpenPGP key verification + legal framework 
Both, even though the requirement of using only one user ID would
be more acceptable if the address did not have to be associated
with a Google account.

@_date: 2018-11-06 12:54:43
@_author: Damien Goutte-Gattat 
@_subject: Most secure GPG combination for Mac OS X 
First, a warning: I am by no means a "security expert" and I have
very little experience with Mac OS X, which I only use at my
workplace (and only because my employer didn't let me use a
GNU/Linux workstation...).
However and for what it's worth:
There's a third possibility, which is the one I use: install the GnuPG
provided by the MacPorts project [1].
Install MacPorts and then simply run:
  $ port install gnupg2
MacPorts packagers seem keen to provide the latest versions and to
update their ports quickly when upstream publishes a new release.
For example, Libgcrypt was updated to version 1.8.4 the day after
that version was released.
I tried to build the Mail.app plugin from the gpgtools project,
but failed. I don't remember what the problem was, just that I
gave up.
I am currently using alternatively Neomutt (also installed through
MacPorts), which natively supports GnuPG, and Thunderbird with
Enigmail. Everything is working fine, including smartcard support.
Whether this is a "better integrated" solution than using Mail.app
I cannot tell.
Hope that helps a bit.
[1]

@_date: 2018-11-08 15:21:58
@_author: Damien Goutte-Gattat 
@_subject: Update FAQ about revocation certificates? 
Hi GnuPG folks,
The current version of the FAQ recommends creating a revocation
certificate at several places.
? 7.17
  "We recommend you create a revocation certificate immediately
   after generating a new GnuPG certificate."
? 8.5
  "What should I do after making my certificate?
   Generate a revocation certificate"
? 10
  "What are some common best practices?
   [...] Generate a revocation certificate"
However, since GnuPG 2.1 a revocation certificate is now
automatically generated by GnuPG at the same time a new key pair
is created, and stored in $GNUPGHOME/openpgp-revocs.d.
Therefore the above recommendations should either be removed or at
the very least amended to explain that they are only necessary
with GnuPG < 2.1.
FWIW, I believe they should be removed completely. Rationale: It
has already been decided three years ago not to mention GnuPG 1.4
in the FAQ [1]. Since then, GnuPG 2.0 has been end-of-lifed and so
in my opinion should not be mentioned either.  Thus the FAQ should
only focus on "modern" GnuPG (>= 2.1). And with modern GnuPG there
is no need to recommend to generate a revocation certificate.
On the same topic, the answer to the question "How do I generate a
revocation certificate?" (? 8.5) should be amended to explain that
such a revocation certificate may already have been generated.
("May", because it is possible the user asking this question has
generated his or her key a long time ago, using an older version
of GnuPG.)
Comments are welcome.
[1]

@_date: 2019-12-08 20:54:53
@_author: Damien Goutte-Gattat 
@_subject: Partial/fragmented decryption keys 
The OpenPGP RFC [1] seems to acknowledge this possibility by defining a flag that can be set on a public key to indicate that the corresponding private key ?may have been split by a secret-sharing mechanism? (? 5.2.3.1). But it does not provide any details about how that feature should be implemented, leaving that entirely to the implementations (which makes sense, I guess, since what an implementation does with a private key is not supposed to have an impact on interoperability, and so does not need to be specified).
I don?t know about early (or even more recent) PGP versions, but GnuPG does not have such a feature. If you are interested the topic has been discussed a few years ago on the -devel mailing list [2].
- Damien
[1] [2]

@_date: 2019-12-15 02:07:57
@_author: Damien Goutte-Gattat 
@_subject: Modern gnupg.conf setup 
I don?t know which tutorials exactly you?re referring to, but I have seen several of them myself, and I have always had the feeling that they were written by people who couldn?t be bothered to check what GnuPG?s default configuration actually is before deciding it needed to be Not needed, those are the defaults.
That?s up to you. Note, this does not actually ?strengthen? anything.
For information, the default is not to display any key ID (either short or long) but to display the full fingerprint instead (which makes displaying the key ID quite irrelevant).
Setting keyid-format to either ?short? or ?long? however has the effect of forcing GnuPG to display the key ID of *subkeys*, so if that?s something you need, you may keep that line.
Already enabled by default.
The default is AES256, AES192, AES128, 3DES. Note that you cannot remove 3DES which is mandatory as per the RFC 4880 (that?s the only algorithm which is guaranteed to be supported by any compliant OpenPGP implementation): even if you do not include it, GnuPG will silently add it back.
By removing AES192 and AES128, you?re actually increasing the risk that GnuPG will have to fallback to 3DES if AES256 is not supported by the other party. I don?t think this is what you want.
The default is SHA256, SHA384, SHA512, SHA-224, SHA1, with SHA1 being mandatory. Same problem as above: by limiting GnuPG?s options, you are increasing the risk of having to fallback to SHA1.
This is almost exactly the default list, except that the default list does not include TWOFISH.
You are basically bypassing the whole preference-based mechanism used to select algorithms compatible with your recipients? implementation.  Almost certainly a bad idea unless you are operating in a context where you know you don?t need to care about interoperability (e.g. if you are only encrypting files for yourself).
3DES and SHA1 are mandatory as said above. The other algorithms are already not used by default.
The default S2K mode is already 3 (iter+salt). As for the S2K count, for information the default is a value automatically determined by GPG Agent so that, on your computer, running the S2K algorithm will take ~100ms.
Overall I?d say most of your configuration is either uneeded or even counterproductive. I?ll quote GnuPG?s FAQ [1]:
- Damien
[1]

@_date: 2019-12-15 18:49:17
@_author: Damien Goutte-Gattat 
@_subject: Usability of OpenSSL vs GNUPG 
OpenSSL definitely has its detractors. They were for example very vocal back in 2014 in the aftermath of the Heartbleed bug.
For what I have seen, most of the criticisms against OpenSSL are directed at the code and/or the API rather than at the command line tools. This may reflect the fact that OpenSSL is probably more often used as a programming library than as a set of command line tools. That being said I have seen complaints about the command line OpenSSL tools as well.
(I?ve heard a crypto-nerd once telling me that the only way to correctly generate a certificate signing request using OpenSSL?s req command was to type the command while sitting in a demonic circle after having sacrificed at least a dozen of chickens?or two dozens if the CSR is for a ECC certificate.)
I am not sure I?d buy that. All the criticisms I have seen against either GnuPG or OpenSSL came from very technical-minded people.
By contrast, in my experience non-technical people showing up at cryptoparties are very much willing to use the software as it is, learning what they need to learn instead of complaining that the software should be simple enough that they shouldn?t have to learn (Of course those are the people motivated enough to attend a cryptoparty. They may not reflect the larger group of users.)
- Damien

@_date: 2019-01-02 09:47:47
@_author: Damien Goutte-Gattat 
@_subject: NIST 800-57 compatible unattended encryption? 
Actually yes, that?s exactly what happens. The data (in your
case, the contents of your file) is symmetrically encrypted using
a randomly generated ?session key?, and *that* key is
asymmetrically encrypted using the RSA public key.
- Damien

@_date: 2019-01-09 23:13:33
@_author: Damien Goutte-Gattat 
@_subject: gpg > addphoto 
Not quite. If you look at the code?s history, you?ll find that the 16MB
limit is actually from 2014 [1]. There was no limitation on the size of
user attribute packets before that.
It is wise to be careful when you abruptly introduce a limitation that
did not exist before; 16MB was chosen because it is big enough to avoid
breaking any existing key with a legitimate user attribute packet, while
still preventing DoS attempts with deliberately oversized packets.
Of note, the OpenPGP RFC does allow arbitrary large attribute packets,
which means that strictly speaking, GnuPG is already "wrong" to reject a
packet larger than 16MB.
- Damien
[1]

@_date: 2019-06-14 11:56:03
@_author: Damien Goutte-Gattat 
@_subject: New keyserver at keys.openpgp.org - what's your take? 
For what it's worth, my main concern is that it is a centralized This puts whoever is running keys.openpgp.org in a uniquely good position to do Bad Things?. Of course I don't expect they would, but the point is, they could (or they could be forced to).
That being said, I have nothing better to propose and overall I welcome any attempt, however imperfect, to make OpenPGP slightly easier and/or more comfortable to use. (And I do note that Hagrid developers "plan to explore options for a distributed service in the future" [1].)
- Damien
[1]

@_date: 2019-03-10 14:50:28
@_author: Damien Goutte-Gattat 
@_subject: Several GnuPG instances, with their corresponding agents 
A Gpg-agent is tied to a specific home directory (as specified in the
GNUPGHOME environment variable or through the --homedir option of gpg),
so all you have to is to make sure you use a separate home directory for
each version you want to use.
For example, assuming you have installed version X of GnuPG under
$HOME/myprogs/gnupg-X, create a directory to use as the home directory
for that version (say, $HOME/gnupg-homes/X), then you can start using
that version by running the following:
  PATH=$HOME/myprogs/gnupg-X/bin:$PATH
  export GNUPGHOME=$HOME/gnupg-homes/X
  $SHELL -i
You'll start a new shell in which all GnuPG invocations will use the
binaries from the X version and the keyrings and other associated files
from the indicated home directory. Simply exit that shell to use again
your system-provided GnuPG in the normal home directory.
Hope that helps,
- Damien

@_date: 2019-05-27 12:14:19
@_author: Damien Goutte-Gattat 
@_subject: Encryption Algorithm for GnuPG? 
There?s no single symmetric encryption algorithm. OpenPGP allows a set of algorithms: 3DES, IDEA, CAST5, AES, Blowfish, Twofish, and Camellia [1,2]. GnuPG supports all of them.
All patents on IDEA have now expired and IDEA is supported by GnuPG.
Rijndael was actually designed by a team of Belgian cryptologists. NIST evaluated it amongst the other candidate ciphers of the AES competition and eventually selected it as the winner, but was not involved in its design. [3]
- Damien
[1] [2] [3]

@_date: 2019-10-12 20:26:31
@_author: Damien Goutte-Gattat 
@_subject: Future OpenPGP Support in Thunderbird 
Slightly off-topic for this list, but on unix-like systems, you can force Firefox to use the system store of X.509 certificates (in libp11-kit.so library from the p11-kit project [1,2].
This also works with Thunderbird and with LibreOffice.
- Damien
[1] [2]

@_date: 2019-10-15 23:14:36
@_author: Damien Goutte-Gattat 
@_subject: FAQ October 2019 update 
A while ago (I can?t find the e-mail anymore) I suggested a few changes that somehow didn?t find their way to the FAQ and then I forgot about them. Allow me to submit them again.
Those changes are all related to the fact that modern (? 2.1) GnuPG automatically creates a revocation certificate whenever it creates a new key pair, and stores it in $GNUPGHOME/openpgp-revocs.d.
In section 7,17 (What?s a ?revocation certificate??), it?s no longer recommended to create a revocation certificate immediately after generating a new GnuPG certificate. Instead, this section may state that GnuPG already creates one when creating a GnuPG certificate, and that it can be found in $GNUPGHOME/openpgp-revocs.d.
Similarly, section 8.5 (?What should I do after making my certificate?) should no longer say to generate a revocation certificate, but again may indicate where to find the one automatically generated by GnuPG, and advise to store it in a safe place.
In the same section, the subsection ?How do I generate a revocation certificate? could be moved elsewhere, as it is no longer something you ?should do after making [your] certificate?.
In section 10 (?What are some common bast practices??), the advice ?Generate a revocation certificate and keep it safe? should be removed and optionally replaced by ?Keep your (automatically generated) revocation certificate safe?.
- Damien

@_date: 2019-10-27 20:40:17
@_author: Damien Goutte-Gattat 
@_subject: Question about symmetric AES cipher in GnuPG 
Simply put, gpg and openssl enc don?t use the same file formats.  Different formats may encode the same data differently, so you can?t expect the two outputs to be similar or to be of a similar size.
In GnuPG?s case, the format is the one defined by the RFC 4880 standard [1]. I don?t know what is the format used by OpenSSL, but some of the differences with GnuPG?s format include:
* GnuPG adds a ?Modification Detection Code? to the encrypted data;
* GnuPG also adds some metadata, including the name of the original   file.
Those differences alone already explain easily why the file generated by GnuPG is bigger.
- Damien
[1]

@_date: 2019-09-11 15:36:32
@_author: Damien Goutte-Gattat 
@_subject: Scute 1.6.0 released 
The GnuPG Project is pleased to announce the availability of Scute Scute is a PKCS module built around the GnuPG Agent and the GnuPG Smart Card Daemon. It allows you to use an OpenPGP or a PIV smart card for TLS client authentication and S/MIME mail and document signing.
Noteworthy changes in version 1.6.0 (2019-09-10)
* PIV cards are now supported in addition to OpenPGP cards.
* Key selection is delegated to GpgSM, resulting in faster operations.
* The license has been changed to the GNU Lesser General Public License, version 2.1 or later.
* Scute now requires at a minimum the current stable version of GnuPG (2.2.0); advanced PIV card support needs the current GnuPG development Release-info: Source code is hosted at the GnuPG FTP server and its mirror as listed as .  On the primary server the source tarball and its signature are:
  ftp://ftp.gnupg.org/gcrypt/scute/scute-1.6.0.tar.bz2
  ftp://ftp.gnupg.org/gcrypt/scute/scute-1.6.0.tar.bz2.sig
The same files are also available via HTTP:
    Signing key
The tarball is signed by the maintainer's key:
  rsa4096 2014-03-14
  Key fingerprint = 4FA2 0823 62FE 73AD 03B8  8830 A8DC 7067 E25F BABB
  Damien Goutte-Gattat That key is available via a WKD lookup:
  $ gpg --locate-key dgouttegattat at incenp.org
Scute is copyright by g10 Code GmbH and licensed under the GNU Lesser General Public License version 2.1 or later (LGPLv2.1+). The full text of the license is included in the COPYING.LESSER file of the source Note that this is a change compared to previous releases of Scute, which were licensed under the GNU General Public License version 2 or later with an additional exception.
The Scute manual is included in the source distribution and is also available online at . For community support, you may ask on the gnupg-users mailing list If you need commercial support, check out Maintenance and development of Scute and of GnuPG as a whole is mostly financed by donations. Please consider donating via Happy hacking!

@_date: 2019-09-11 15:36:32
@_author: Damien Goutte-Gattat 
@_subject: [Announce] Scute 1.6.0 released 
The GnuPG Project is pleased to announce the availability of Scute Scute is a PKCS module built around the GnuPG Agent and the GnuPG Smart Card Daemon. It allows you to use an OpenPGP or a PIV smart card for TLS client authentication and S/MIME mail and document signing.
Noteworthy changes in version 1.6.0 (2019-09-10)
* PIV cards are now supported in addition to OpenPGP cards.
* Key selection is delegated to GpgSM, resulting in faster operations.
* The license has been changed to the GNU Lesser General Public License, version 2.1 or later.
* Scute now requires at a minimum the current stable version of GnuPG (2.2.0); advanced PIV card support needs the current GnuPG development Release-info: Source code is hosted at the GnuPG FTP server and its mirror as listed as .  On the primary server the source tarball and its signature are:
  ftp://ftp.gnupg.org/gcrypt/scute/scute-1.6.0.tar.bz2
  ftp://ftp.gnupg.org/gcrypt/scute/scute-1.6.0.tar.bz2.sig
The same files are also available via HTTP:
    Signing key
The tarball is signed by the maintainer's key:
  rsa4096 2014-03-14
  Key fingerprint = 4FA2 0823 62FE 73AD 03B8  8830 A8DC 7067 E25F BABB
  Damien Goutte-Gattat That key is available via a WKD lookup:
  $ gpg --locate-key dgouttegattat at incenp.org
Scute is copyright by g10 Code GmbH and licensed under the GNU Lesser General Public License version 2.1 or later (LGPLv2.1+). The full text of the license is included in the COPYING.LESSER file of the source Note that this is a change compared to previous releases of Scute, which were licensed under the GNU General Public License version 2 or later with an additional exception.
The Scute manual is included in the source distribution and is also available online at . For community support, you may ask on the gnupg-users mailing list If you need commercial support, check out Maintenance and development of Scute and of GnuPG as a whole is mostly financed by donations. Please consider donating via Happy hacking!

@_date: 2019-09-16 13:41:00
@_author: Damien Goutte-Gattat 
@_subject: Which version of GnuPG to use? 
The latest version available for your system, which should in any case be a version from the 2.2 branch. (If your system is Windows, that would be Gpg4Win 3.1.10, which provides GnuPG 2.2.17.)
You should *not* use GnuPG 1.4.x unless you have some very specific needs (such as working on a "exotic" system or having to interoperate with PGP versions from the mid-1990s), and you should *not* use any version from the 2.0 or 2.1 branch which are not supported anymore.
This doesn't matter, really. You may use gnupg directly on the command line if you're familiar with it, but you don't have to.
The usual recommandation is to stick to the default setting proposed by GnuPG (which currently and if I remember correctly is to generate a RSA-3072 master key for certifying and signing and a RSA-3072 encryption Note that modern versions of GnuPG do not ask you anymore to specify the type and/or size of key you want unless you explicitly request it.
- Damien

@_date: 2019-09-17 18:16:39
@_author: Damien Goutte-Gattat 
@_subject: Which version of GnuPG to use? 
No. The secret key data remains on the smartcard and is *not* sent to the host computer. The host computer sends the data to be decrypted to the smartcard, the smartcard does the decryption itself then sends the decrypted data back to the host.
(Actually the "data" sent to the card is not an entire OpenPGP message, just the asymetrically encrypted session key which the hosts then uses to decrypt the bulk of the message. But this is a detail which does not change the fact that the host never sees the secret private key.)
- Damien

@_date: 2020-02-05 23:37:05
@_author: Damien Goutte-Gattat 
@_subject: Revoking a Lost Key 
The revocation certificate needs to be signed by the private key, so without the private key it is indeed not possible.
It is possible to ask a third party to revoke your key in your stead, but only if you have previously made said third party a "designated revoker" (something that needs to be done in advance, when you still have the private key).
Since you cannot revoke, the only thing you may try is asking some of the people who certified your lost key (if any) to revoke their certification of your key.
- Damien

@_date: 2020-01-06 22:43:51
@_author: Damien Goutte-Gattat 
@_subject: Changes in GnuPG 
Files under the $GNUPGHOME/private-keys-v1.d directory are named after the *keygrips* of the keys.
A keygrip is similar in principle to an OpenPGP fingerprint, but is computed on a data structure that is independent of any protocol (contrary to an OpenPGP fingerprint, which is computed over an OpenPGP GnuPG, which since its version 2.0 implements both OpenPGP and S/MIME, uses keygrips internally to refer to a key independently of the protocol with which the key is to be used.
You can use the --with-keygrip option when listing keys to have GnuPG display the keygrips, and check that they match the filenames you see in the $GNUPGHOME/private-keys-v1.d directory.
The OpenPGP standard dictates how compliant implementations interoperate. It says nothing about what the implementations shall do Keygrips are strictly an internal implementation detail of GnuPG. When it interacts with the outside world (e.g. when exporting a key), GnuPG still follows the OpenPGP standard.
- Damien

@_date: 2020-01-30 23:14:15
@_author: Damien Goutte-Gattat 
@_subject: private data objects on smartcard 
You can use the (undocumented) command "privatedo" from GnuPG's --card-edit menu. For example, to write into the private DO   $ gpg --card-edit
  gpg/card> privatedo 1
  Private DO data: [enter whatever value you want to store into the DO]
Or, to write the contents of a file into the private DO   $ gpg --card-edit
  gpg/card> privatedo 2 < [filename]
Yes. If a private DO contains a value, it will be listed in the output from the --card-status command.
First, note that private DOs are an optional feature of the OpenPGP smart card; not all implementations support them.
You can use the following command to check if an OpenPGP smart card supports private DOs:
  $ gpg-connect-agent 'SCD LEARN --force' /bye | grep EXTCAP
  S EXTCAP gc=1+ki=1+fc=1+pd=1+mcl3=2048+aac=1+sm=0+si=5+dec=0+bt=1+kdf=1
Here, "pd=1" means the card does have private DOs. "pd=0" would indicate that private DOs are not supported.
When private DOs are supported, there are four of them. For cards compatible with versions 1.x or 2.x of the specification, they have a size of 254 bytes. For 3.x cards, the size of the private DOs is defined by the implementation (the OpenPGP smart card from FLOSS Shop [1] has indeed 2048-bytes private DOs).
- Damien
[1]

@_date: 2020-01-30 23:57:28
@_author: Damien Goutte-Gattat 
@_subject: private data objects on smartcard 
Neither of those. It's the maximum length of the "Cardholder certificate DO". This is another data object available on a OpenPGP smart card, intended to store a X.509 certificate.
You can write to that DO using the (undocumented) writecert command. For example, assumimg the cert.der file contains a DER-encoded X.509   $ gpg --card-edit
  gpg/card> writecert 3 < cert.der
GnuPG allows to write into that DO but does not actually use it. As far as I know the only component that makes use of the Cardholder certificate DO is Scute [1], for TLS client authentication (and even for that the DO is actually dispensable: if Scute does not find the desired certificate in that DO, it will obtain it from GpgSM.)
The Cardholder certificate DO was added in version 2.0 of the specification, so nothing surprising here.
- Damien
[1]

@_date: 2020-01-31 00:06:43
@_author: Damien Goutte-Gattat 
@_subject: private data objects on smartcard 
Only Private DOs  and  are readable without any PIN. Reading the private DO  requires the user PIN, and reading the private DO  requires the admin PIN.
If no PIN has been verified, the --card-status command will only ever print out the contents of private DOs  and While we are at it, *writing* to the private DOs  and  requires the user PIN, and writing to the private DOs  and  requires the admin You can find the details about those DOs and all the other features of the OpenPGP smart card in the specifications for the different versions, which are all available on GnuPG's site [1].
- Damien
[1]

@_date: 2020-07-27 23:24:26
@_author: Damien Goutte-Gattat 
@_subject: WKD question 
Unless I missed something, I believe Enigmail will only attempt to automatically fetch a key from a Web Key Directory when *composing* a message (if there?s no key for the recipient in the local keyring), and *not* when checking a signature on a received message.
See that excerpt from Enigmail 2.0 changelog [1]:
You can force GnuPG to try to fetch a missing key when verifying a signature by enabling the --auto-key-retrieve option (please read the note about the ?web bug? in gpg?s man page before doing so?that option is disabled by default for a reason.)
- Damien
[1]

@_date: 2020-05-08 14:48:02
@_author: Damien Goutte-Gattat 
@_subject: Performance of Yubikey fw >= 5.2.3 and Curve25519 in OpenPGP 
I have the following tokens:
* a Yubikey NEO with a RSA-2048 key;
* a Yubikey 5 with a Ed25519 key;
* a FST-01G/Gnuk token with a Ed25519 key.
I have not done any proper benchmark, but from my usage, my feeling is that the Yubikey 5 and the FST-01G have similar performances, and that they both outperform the Yubikey NEO with the RSA-2048 key.
A quick decryption test seems to confirm that impression:
* Yubikey NEO, RSA-2048: 0.795s ? 0.011s
* Yubikey 5, Ed25519:    0.096s ? 0.005s
* FST-01G, Ed25519:      0.075s ? 0.006s
Note that the comparison between the RSA-2048 key on the Yubibey NEO and the Ed25519 key on the Yubikey 5 probably tells a lot more about the difference between the two generations of Yubikeys that it does about the difference between RSA and Ed25519. With the Yubikey NEO, even listing the card?s contents (with `gpg --card-status`) already takes ~0.7s, compared to ~0.05s with the Yubikey 5.
- Damien

@_date: 2020-05-13 10:54:12
@_author: Damien Goutte-Gattat 
@_subject: Comparison of RSA vs elliptical keys 
No you don?t.
You can simply use `gpg --gen-key` and let GnuPG create a keypair with the default algorithm (which is currently RSA 2048). Only if you call GnuPG with the `--full-gen-key` command will you be asked to explicitly choose which type of key of want.
If their software does not support Curve 25519, yes.
You encrypt messages to your correspondants with *their* public keys, so the type of *your* key does not matter for that purpose. But they won?t be able to verify your signatures.
Yes. That being said, most modern implementations do seem to support curve 25519. As far as I know, it is supported at the very least by
* GnuPG (? 2.1)
* OpenPGP.js
* Sequoia-PGP
* RNP
? which should already cover most of the OpenPGP user base. Of note, it is *not* supported by Symantec PGP, though [1].
Not yet. Officially, only the NIST P-256, P-384, and P-521 curves are part of the standard (since RFC 6637). The first mention of Curve 25519 for OpenPGP was in a draft by Werner in 2014 [2]. The draft never made it to a RFC but the 25519 curve is now part of the draft for RFC4880bis, the next revision of the OpenPGP standard [3].
- Damien
[1] [2] [3]

@_date: 2020-05-16 22:07:22
@_author: Damien Goutte-Gattat 
@_subject: keys require a user-id 
I?d like to point out that the options you are referring to are actually enabled by default nowadays (since 2.2.17). So from an user?s point of view, the judicious thing to do is simply to use the latest GnuPG version available.
I am pointing that out because people could interpret your comment as meaning that GnuPG requires some tinkering of its options in order to be safely usable with regard to the SKS spamming issue. That?s not the case; the default configuration is fine.
- Damien

@_date: 2020-05-24 13:52:21
@_author: Damien Goutte-Gattat 
@_subject: Backup of Keys 
No, it?s not.
I?m assuming you are using GnuPG 2.2 on Windows here (based on your Everything that needs to be saved is in GnuPG?s home directory, which on Windows should be `C:\Documents and Settings\\Application Data\gnupg`. In that folder you should save:
* the private keys (in the `private-keys-v1.d` subfolder;
* the public keys (the `pubring.kbx` file);
* the trust data (the `trustdb.gpg` file, plus the `tofu.db` file of you are using the TOFU trust model);
* any configuration file (`*.conf`);
* if you are using GpgSM, the `policies.txt` and `trustlist.txt` files.
For the private and public keys however, instead of saving the files directly I?d recommend exporting them from GnuPG:
% gpg -o private-keys.gpg --export-secret-keys
% gpg -o public-keys.gpg  --export
The rationale for doing so is that the exported files are in the standard OpenPGP format, from which you can re-import them without worrying about changes from one GnuPG version to another. To restore:
% gpg --import private-keys.gpg
% gpg --import public-keys.gpg
(You can also do that with a graphical interface, of course.)
Of note, there is also a much simpler option which could replace everything above: use the Sherpa tool [1], which does exactly what you need. It backs up a complete GnuPG profile into an archive and later allows you to restore it. Do mind the warning about Sherpa not being ?ready for regular users?, though. For what it?s worth, I?ve used it a few times and never had any issues with it.
Hope that helps,
- Damien
[1]
