
@_date: 2020-12-10 17:21:31
@_author: cqcallaw 
@_subject: Christmas giving 
Ah, the Elon Musk crypto scams. We really ought to preserve these as part of Internet history :)
??????? Original Message ???????

@_date: 2020-12-20 21:12:34
@_author: cqcallaw 
@_subject: Browser extension to verify PGP-signed dWebpages 
Hi folks,
Slightly off-topic, but in case anyone's interested, I've built a browser extension to verify PGP-signed dWebpages: The extension won't (intentionally) leak private data, but constructive criticism and user feedback is welcome.

@_date: 2020-11-20 19:13:22
@_author: cqcallaw 
@_subject: Signing decentralized websites 
Hi all,
I want to sign my decentralized website, hosted on IPFS + Ethereum Name Service (ENS). PGP detached signatures for every published file seems to be the correct solution. Inline signatures would make validation of HTML documents difficult and binary files would become invalid. Signing the root IPFS CID might work, but would require substantial updates to ENS or an external Ethereum smart contract. Signing a subset of files isn't enough, because corrupted or inauthentic unsigned files could be bundled together with the signed subset and published as authentic.
Assuming folks agree with this analysis, I have two additional questions:
1) What's the best way to sign multiple files in parallel? I have 16 CPU threads and would like to take advantage of these (mostly idle) threads to speed up the signing process. GNU parallel and Python's multiprocessing module are behaving oddly, though; when they run gpg in parallel, I'm prompted for my PGP key's password multiple times. I'm running gpg-agent, so I'd expect to be prompted for my password only once. I also observe intermittent memory allocation errors. The --lock-once and --lock-multiple CLI options don't seem to change the behavior. Is there some implementation issue with running multiple gpg signing operations in parallel?
2) Are there any tools to verify detached signatures in the browser? As a user, I'd like my browser to check for a signature file and verify any discovered signatures with any available trusted keys. If a trusted key isn't found, I'd like my browser to check for a pubkey in some known location (e.g. /pubkey.asc) and allow me to trust the bundled pubkey if I so desire. I'd expect browser security considerations to necessitate a separate key store for keys used in the browser, but that's an acceptable solution for me if a key import workflow exists. Does anything like this exist?

@_date: 2020-11-22 01:06:53
@_author: cqcallaw 
@_subject: Signing decentralized websites 
??????? Original Message ???????
Many thanks. I've written a Python script ( to handle the parallel signing; I'll look into the browser options shortly.

@_date: 2020-11-23 07:22:19
@_author: cqcallaw 
@_subject: Thunderbird / Enigmail / Autocrypt 
??????? Original Message ???????
At my job, I frequently send out summary charts and graphs surrounded by text.
Attachments simply do not work; my audience cannot spend the mental energy to
context-switch between text and attachments, and my reports become unusable.
I also provide hyperlinks in my reports. Sharing hyperlinks in plaintext emails
is possible, but verbose and unfriendly to the viewer.
In such circumstances, plaintext email is not human readable; I must use HTML.

@_date: 2020-11-27 22:52:27
@_author: cqcallaw 
@_subject: =?utf-8?Q?[cross_post]_Why_does_verification_of_a_detached_signature_result_in_a_=E2=80=9CMessage_digest_did_not_match=E2=80=9D_error_for_OpenPGP.js=3F?= 
Hi folks,
This is an OpenPGP.js question, but I've gotten no answers from Stack Overflow, so I'm widening the cast of my net in hopes a relevant expert is lurking about.
I couldn't find any community policy that such a cross post might violate, but if I missed something, please feel free to (gently) inform me of that fact.
I can sign and verify a test file through `gpg` without issue, but verifying the signature through OpenGPG.js fails with the error, "Message digest did not match." Why is this?
$ gpg --armor --quiet --batch --yes --detach-sig index.html
$ gpg --verify index.html.asc index.html
gpg: Signature made Wed 25 Nov 2020 08:26:34 PM PST
gpg: using RSA key C361FDC3F93B9E8F8BD7E08D5F873051B2D6C347
gpg: Good signature from $ node sandbox.js
{ signatures:
[ { keyid: [Keyid],
verified: [Promise],
signature: [Signature],
valid: false,
Error: Message digest did not match
at Signature.verify (/home/caleb/src/islands/node_modules/openpgp/dist/openpgp.js:41176:11)
at process._tickCallback (internal/process/next_tick.js:68:7)
at Function.Module.runMain (internal/modules/cjs/loader.js:834:11)
at startup (internal/bootstrap/node.js:283:19)
at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3) } ],
data: 'Test!\n' }
sandbox.js (based on [the OpenPGP.js example](
openpgp = require('openpgp');
fs = require('fs');
async function sandbox() {
path = './'
let msg_data = fs.readFileSync(path + "index.html", 'utf8');
let sig_data = fs.readFileSync(path + "index.html.asc", 'utf8');
let pubkey_data = fs.readFileSync(path + "pubkey.asc", 'utf8');
let msg = await openpgp.cleartext.fromText(msg_data);
let sig = await openpgp.signature.readArmored(sig_data);
let pubkey = await openpgp.key.readArmored(pubkey_data);
message: msg,
signature: sig,
publicKeys: pubkey.keys
}).then(function(verified) {
-----BEGIN PGP PUBLIC KEY BLOCK-----
-----END PGP PUBLIC KEY BLOCK-----
`npm list` shows openpgp at 4.10.8.

@_date: 2020-11-28 20:54:10
@_author: cqcallaw 
@_subject: =?utf-8?Q?Re:_[cross_post]_Why_does_verification_of_a_detached_signature_result_in_a_=E2=80=9CMessage_digest_did_not_match=E2=80=9D_error_for_OpenPGP.js=3F?= 
??????? Original Message ???????
Excellent, adding --textmode to gpg's command line resolved the issue.
