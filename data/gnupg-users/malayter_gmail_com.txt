
@_date: 2005-08-01 09:56:56
@_author: Ryan Malayter 
@_subject: throughput of GnuPG symmetric ciphers 
I was going to use GnuPG for encrypting some very large backup files
on disk (~200 GB). However, the symmetric ciphers in GnuPG seem to be
fairly slow. Using the Windows build of 1.4.2, I only modest
throughputs piping GPG output from a fast 7200 RPM disk to >NUL (the
Windows equivalent of /dev/nul). (See table at end of email).
The process is not disk bound, since it uses 100% CPU and the
different algorithms take different times. Compression was turned off.
I have seen references on the net to fast software implementations of
AES that are an order of magnitude faster than GnuPG on a P4 (~1.5
Gbps). See Has anyone made a GnuPG patch that includes faster implementations of
the core symmetric algorithms?
What other tools are people using for encrypting backups in datacenter
operations (as GnuPG seems to be too slow for this task)?
Thanks for any help,
  Ryan
Tests encrypting a 1 GB file on a 2.4 GHz Pentium 4.
Cipher Algorithm   Speed (Mbps)
CAST5              153.39
BLOWFISH           59.24
AES                102.26
3DES               64.59
AES-256            81.81
TWOFISH            124.49

@_date: 2005-08-01 19:44:07
@_author: Ryan Malayter 
@_subject: throughput of GnuPG symmetric ciphers 
I'm reposting this because it never appeared on the list for some
reason, even after 12 hours.
CAST5              153.39
BLOWFISH           59.24
AES                102.26
3DES               64.59
AES-256            81.81
TWOFISH            124.49

@_date: 2005-08-03 00:44:36
@_author: Ryan Malayter 
@_subject: Protecting signing key 
Windows doesn't have whole-disk encryption yet, only per-file and
per-folder encryption.
That said, everything I've read indicates that the encrypting file
system (EFS) in Windows 2000+ is reasonably well implemented. However,
the user's password is still the weak link, as it is used to protect
the private key that EFS needs for decryption.
Because you can get the hash of this password from the disk in some
way (you always have to be able to, otherwise you could not
authenticate), the password is the weak link. Unless the password was
very long and full of entropy, brute forcing it from the NTLMv2 hash
would be easy for a government organization. And if the Al-Queda dude
neglected to turn off the generation of the weak LANMAN hash, it would
be even easier. (LANMAN hash generation is off by default in newer
versions of Windows).
Microsoft is putting whole-disk encryption into Windows Vista
including card/token and RSA secureID support. Similar (hopefully
better?) functionality is already available for 2000/XP/2003 from a
host of vendors, including PGP Corp & PC Guardian.

@_date: 2005-08-03 19:03:54
@_author: Ryan Malayter 
@_subject: throughput of GnuPG symmetric ciphers 
I actually found an open-source tool, 7-zip, that includes AES-256
encryption functionality. For whatever reason, it runs several times
faster than GnuPG in software.
Fast enough, in fact, that the removable hard disk devices have become
the limiting factor in the system (the 7-zip process only uses 70% CPU
on a 2.4 GHz P4). The code is open-source, and it uses a salted +
iterated SHA256 hash to produce the AES key from a pass phrase. The
AES implementation is Gladman's well-known and fast C++ code.
Looking at the source, I haven't figured out whether it uses ECB or
CFB mode yet; the 7-zip code is rather light on comments. I am
assuming ECB, which should be fine for my application.
See  for more details.
Thanks for all the help.

@_date: 2005-08-04 15:05:56
@_author: Ryan Malayter 
@_subject: throughput of GnuPG symmetric ciphers 
My test show 7-zip yields ~228 Mbps on a 2.4 GHz P4. The only cipher
available with this program is AES256 in (I believe) ECB mode.
I presume this performance is the result of the efficient Gladman code
and a P4-specific compiler optimizations used when building 7-zip.
Still, it seems a bit odd that this program generates AES-256
throughput 2.78 times faster than the AES-256 implementation in
GnuPG/libgcrypt on the same machine. I suppose those large lookup
tables in the Gladman code really speed things up. (I would not think
the extra XOR operation used in GnuPG's CFB implementation would
account for so large a difference).
Gladman's very fast GPL-compatible code (as used in 7-zip) is
available at He has C, C++, and x86 assembly implementations. You might want to
take a look.
Gladman's code uses large tables, which presumably makes it vulnerable
to the recently publicized timing attacks. That should not be an issue
for GnuPG, but might be for other programs that use libgcrypt.

@_date: 2005-08-10 19:50:08
@_author: Ryan Malayter 
@_subject: Forgot the key passowrd 
Using the supplied figure of 200 keys per second, and using only the
95 "printable" ASCII characters:
(95^8)/200 seconds. Or about 1.1 million years!
Obviously, if you know something about the structure of the password
(inlcudes words, is mostly lower case, etc.), you can trim that way
down. But 200 trials per second just isn't going to be verry effective
for a brute force attack.

@_date: 2006-04-02 16:36:44
@_author: Ryan Malayter 
@_subject: ElGamal: key length vs performance 
This is very true. In my tests, for example, AES implementation in
GnuPG runs far slower than the implementation used in TrueCrypt, 7zip
or a number of other x86-specific programs.
I mentioned this speed difference to Werner a while back, and he
explained GnuPG has to work on many platforms, so using code optimized
for x86 - even if it is C-code optimized for x86 - isn't going to
happen. Which makes sense.
The easiest way to test is to simply encrypt the same file several
times using different --cipher-algo parameters on the command line. My
tests on Pentium 4s showed CAST5 to be the fastest algorithm in GnuPG
on that platform, but your own hardware is different, you should run
your own tests.
See this discussion at:

@_date: 2006-03-22 19:12:53
@_author: Ryan Malayter 
@_subject: Network Neutrality 
I think you're ignoring the fact that Cox can throttle your connection
simply based on analysis of traffic volumes. They don't have to do any
crypto at all, or inspect any packets deeply. Throttling rules would
be set up that say "hey, here's one client getting data at high speed
from a bunch of other folks simultaneously, and sending data quickly
upstream to a bunch of people at the same time."
Such a rule would be fairly straightforward to implement by tracking a
few simple counters per client. I imagine Packeteer and the other
traffic-shaping vendors already have something along those lines
Such traffic-pattern throttling wouldn't step on VPN or SSL
connections, as they're typically from a single host to single host.
Basically, BitTorrent has a very unique traffic pattern that makes the
encryption at best a temporary roadblock to traffic shapers. The vast
majority of BT traffic is from copyright violators, so it's not like
the imapcted users will complain about the throttling in any official
capacity. As for the impact on "legitimate" BT traffic like Linux
distros... well, I'm sure Cox doesn't care one bit. It's not like the
Ubuntu project is going to sue Cox over BT traffic shaping.
   RPM

@_date: 2006-11-03 16:17:52
@_author: Ryan Malayter 
@_subject: Summary: Windows GUI recommendation for USB disk 
When encrypting to a *.7z file, 7-zip uses AES-256 in CBC mode, with a
passphrase-to-key function based on SHA-256. This is actually stronger
than most cipher preferences on OpenPGP keys. It is not the same as
the weak "winZip"-derived encryption. Of course, these files can only
be read by 7-zip, but it is free and open source. (It also compresses
a lot better than standard ZIP's DEFLATE algoritm, if more slowly).

@_date: 2006-10-25 17:57:18
@_author: Ryan Malayter 
@_subject: gpgdisk campaign 
There are two major reasons we're using the commercial PGPdisk here
instead of TrueCrypt.
1) Manageability - PGPdisk offers centralized deployment, policy
management, key escrow, etc.
2) TrueCrypt's inability to encrypt the boot disk on any platform.
The first is a failing that many open source software have; management
is usually accomplished through scripting. That adds lots of
flexibility, but makes the product far less attractive to IT
departments that just want to make it work quickly.
The second is more of an architecture problem with TrueCrypt. PGPdisk
and other whole-disk encryption products do some very low-level,
OS-dependent stuff, like loading from the boot sector and then handing
off to an OS-specific device driver. These are the sorts of things
that are difficult to accomplish without heavy involvement from the OS
This is also why a "GPGdisk" is probably unworkable. GnuPG is designed
and strives for platform independence, and thinks like disk drivers
are inherently platform specific.
I would think that improving TrueCrypt, perhaps stealing the OpenPGP
smart card support from GnuPG, is the "best bet" for full-featured,
open-source whole-disk encryption program.
Finally, let's not forget the 800-pound gorilla: Microsoft already has
per-file encryption (with decent key management in the OS), and has
added whole disk encryption to Vista. If those solutions work well
enough, practical Windows users will not see the benefits of an open
source disk encryption solution outweighing the complexity of their

@_date: 2006-10-25 18:07:45
@_author: Ryan Malayter 
@_subject: gpgdisk campaign 
There are two major reasons we're using the commercial PGPdisk here
instead of TrueCrypt.
1) Manageability - PGPdisk offers centralized deployment, policy
management, key escrow, etc.
2) TrueCrypt's inability to encrypt the boot disk on any platform.
The first is a failing that many open source software have; management
is usually accomplished through scripting. That adds lots of
flexibility, but makes the product far less attractive to IT
departments that just want to make it work quickly.
The second is more of an architecture problem with TrueCrypt. PGPdisk
and other whole-disk encryption products do some very low-level,
OS-dependent stuff, like loading from the boot sector and then handing
off to an OS-specific device driver. These are the sorts of things
that are difficult to accomplish without heavy involvement from the OS
This is also why a "GPGdisk" is probably unworkable. GnuPG is designed
and strives for platform independence, and thinks like disk drivers
are inherently platform specific.
I would think that improving TrueCrypt, perhaps stealing the OpenPGP
smart card support from GnuPG, is the "best bet" for full-featured,
open-source whole-disk encryption program.
Finally, let's not forget the 800-pound gorilla: Microsoft already has
per-file encryption (with decent key management in the OS), and has
added whole disk encryption to Vista. If those solutions work well
enough, practical Windows users will not see the benefits of an open
source disk encryption solution outweighing the complexity of their

@_date: 2007-04-18 07:23:16
@_author: Ryan Malayter 
@_subject: Quantum computing 
This page represents a reasonable snapshot of the state of the art in factoring:
One must assume that a governmental entity like China's Ministry of
State Security can factor significantly larger numbers than the 640
bit factorization done by academic researchers. Which is why you often
see recommendations for 1500+ bit RSA keys.

@_date: 2007-04-18 06:41:23
@_author: Ryan Malayter 
@_subject: Quantum computing 
Robert was referring to a 256-bit key space, which refers to symmetric
encryption, such as AES,
Factoring, on the other hand, applies only to public-key RSA
encryption. There "bits" mean something totally different; a bit of
RSA key length is "worth less" than a bit of symmetric key length.
Numbers have already been factored in the ~600 bit range, so at least
1024 bits are recommended for RSA, and 2048 bits is a good idea.
The "keyspace" size of RSA is roughly equivalent to the
O(exp(64/9b)^(1/3)(log b)^(2/3)) that you quote; That is the number of
operations that must be performed to break the algorithm by brute
force. For strong symmetric algorithms,like AES or Twofish, the number
of operations required is simply two to the power of the number of
bits in the key,
Note that breaking Diffie-Hellman and other discrete logarithm based
algorithms is thought to be nearly equivalent to factoring, but has
not been proven to be so.
I suggest you borrow a copy of Bruce Schneier's _Applied
Cryptography_; it is a very good primer.

@_date: 2007-12-04 10:03:43
@_author: Ryan Malayter 
@_subject: Decrypt problem with large file 
Our solution for backup encyption has been to use 7zip, since it
encrypts faster and supports segmentation, per-file checksuimming, and
other useful backup-oriented features.
What our scripts do is:
1) generate a random hex symmetric key in memory
2) pipe that imput to GnuPG to encrypt that key (as ascii) into a
small key file on our destination disk disk.
3) Use 7-zip with 2 GB file splits and the random symmtric key to
compress and encrypt the backup files in .7z format from the source to
the destination disk. We use the lowest (fastest) compression
settings, and the 2 GB file splits because reading and writing to 4+
GB files is slow on NTFS and most other UNIX-type file systems. This
is why VMware et. all use 2 GB file splits by defuault.
4) Pad most of the remaining disk space with PAR2 files, for extra
protection against bad disk blocks. We use a very large block size for
par2 - something like 128 Mb, IIRC.
We do over 1 TB of backups per night to removable HDDs with this
setup, and have never had a restore fail. We'eve never even had to use
the par2 files in a real-world restore, but we do test "bad media"
scenarios with them by deleting one of the 7z split files and using
par2 to recreate it.
Backups aren't worth much unless you test restore them to be sure that
they will work. We test all of ours weekly.
As a side note, we looked into using the new encryption options in the
new version of Symantec NetBackup, but we don't have budget for that
upgrade just yet. It would be nice to have it all in one step (even
though NetBackup is closed souce, so trusting the vendor is an obvious

@_date: 2007-12-06 10:41:51
@_author: Ryan Malayter 
@_subject: Decrypt problem with large file 
We actually tired TrueCrypt first, but the problem wasn't performance.
We actually didn't get that far. The issue we had was getting the
automatic mounting of the removable HDDs to work well. Disks would
either not auto-mount at all, or would be assigned the wrong mount
point. This was before TrueCrypt 4 came out, so maybe those issues
have been fixed. What we have is wokring okay for us, so we havne't
gone back.
Actually the biggest performance issue with 1 TB backup sets isn't the
large files, it's backup of millions of small files. The volumes with
little files take up 80% of the backup run time, versus the other 600
GB of Exchange and databse data that takes just a few hours. We think
this is an NTFS problem, but it seems that most Linux filesystems have
similar issues. We'll have to give ResierFS a shot next time we
migrate our file server data.

@_date: 2007-12-13 22:53:34
@_author: Ryan Malayter 
@_subject: Backdoor? 
Also make sure your compiler is open source as well. Inspect the code
for that, too. And you have to translate that into machine language by
hand, just to be safe!

@_date: 2007-06-21 14:16:17
@_author: Ryan Malayter 
@_subject: RSA 4096 ridiculous? (was RSA 1024 ridiculous) 
Huh? Why would you try to use bzip2 AFTER encrypting?
Strongly-encrypted data is not compressible. And GnuPG uses gzip
compression by default *before* encryption anyway.
I suppose you could be using bzip to compress an ascii-armored GnuPG
output, but that is pretty silly (just use binary output from GnuPG

@_date: 2007-05-11 12:47:13
@_author: Ryan Malayter 
@_subject: Secure text editor? 
It seems you really want/need a *full-disk* encryption solution, so
that any temporary files and system pagefiles are also encrypted. We
use the commercial PGP solution for that, but there are other options
for Windows. The solutions are very OS-specific, though; on Linux
there are quite a few free choices of varying complexity and quality.
Truecrypt is somewhat cross-platform, and makes good encrypted file
containers, but it won't encrypt the pagefile, or your system's
security databases/password files (Linux or Windows).

@_date: 2007-05-14 17:15:05
@_author: Ryan Malayter 
@_subject: Secure text editor? 
The same option exists in all versions of Windows NT, but you have to
change the system options to run with no pagefile and then reboot. We
run most of our development virtual machines this way, to decrease the
size of the virtual disk files.

@_date: 2007-05-14 17:11:54
@_author: Ryan Malayter 
@_subject: Secure text editor? 
I'm certainly no expert, but I can offer a link, as I was just looking
into this myself. Locking seems to be page-based on Windows NT
systems, so I think it is only heap memory that can be locked. There
is also the complication of the nonpaged pool in Windows having a
smallish fixed size (a restriction mitigated by newer versions of
Windows I believe).
See

@_date: 2007-05-15 06:35:52
@_author: Ryan Malayter 
@_subject: Secure text editor? 
LocalLock() and GlobalLock() do indeed seem to be for synchronization,
but VirtualLock() seems a different beast entirely. It seems its
purpose is for performance and/.or security. But again, I have little
experience in this area, and I am just regurgitating what I read on

@_date: 2007-05-15 09:07:35
@_author: Ryan Malayter 
@_subject: Printing Keys and using OCR. 
We've used PDF417 for conference attendee badges in the past. They
work well, and there seems to be quite a bit of hardware and software
out there to support them.
However, using *any* secondary encoding technique mroe complex than
base64 is going to make recovery of the key that much more difficult
down the road. Have you ever tried to recover a 15 year old file from
floppy or tape? Just figuring out what the file format *is* can be a
I would suggest using plain old base64 ASCII and a large version of a
font like OCR-A or OCR-B. You can include par2 information, also
base64 encoded, but finding software to use that data for recovery may
be difficult many years in the future. Simply printing multiple copies
of the page for OCR and diffing for errors would probably be easier.
Finally, consider the paper and ink/toner you use... some cheaper
paper is very acid, and some toner flakes over time.

@_date: 2007-05-16 22:24:51
@_author: Ryan Malayter 
@_subject: Printing Keys and using OCR. 
I believe the originally posted question centered around long-term key
storage, for which magnetic and optical media are inadequate. Popular
media would require continual maintenance, such as burning to new
discs every 5-10 years, or upgrading the tape format to LTO-1600 in
2013. Whether or not the private key is protected by a strong pass
phrase doesn't really matter; how to store and recover a key from
paper is the challenge.
This discussion does raise in my mind another issue: if you're worried
about being able to read CD/DVD or other media at some distant point
in the future, shouldn't you also archive the GnuPG source code so you
can compile a version for some future architecture for which there may
be no OpenPGP software? We know ASCII, HTML, and PDF will last
forever, but OpenPGP is probably not guaranteed immortality by its

@_date: 2007-05-17 09:28:32
@_author: Ryan Malayter 
@_subject: Printing Keys and using OCR. 
Theory and practice are often far apart. The price of CD media has
dropped so low that quality is often an issue. CDfreaks has many
articles about this topic.
Also, who is to say that a CD or DVD drive will even be available
decades from now to read the discs? Could you read 8" floppy media on
any equipment you have or can buy today? Could you find a paper tape
machine to read data archived in the 1950s?
Anything but printed characters on paper will likely require some form
of archive maintenance over a decade timeframe.

@_date: 2007-05-17 09:41:33
@_author: Ryan Malayter 
@_subject: Secure text editor? 
The documentation clearly states:
"These pages are guaranteed not to be written to the pagefile while
they are locked."
Assuming the documentation is accurate, VirtualLock() should be safe
for security applications.

@_date: 2007-11-03 00:19:11
@_author: Ryan Malayter 
@_subject: New OpenPGP standard published 
Is there an FAQ or other document which highlights only the changes
and improvements since 2440? The output of "diff rfc2440.txt
rfc4880.txt" didn't help me, and such a document isn't prominent on
the OpenPGP WG pages.

@_date: 2007-11-27 17:59:08
@_author: Ryan Malayter 
@_subject: WinXP problem with large files was: Re: Decrypt problem with 
My recollection is that the file size issue was fixed years ago, as it
was a limitation in the MinGW layer or something that was remedied. I
never followed up much, though, becuase GnuPG's encryption was very
slow compared with alternatives (7-zip). When I used GnuPG, encryption
was CPU-bound, even with compression turned off. When I use 7-zip,
encryption of our 500 GB backup files is disk-bound.
I also recall that Werner stated the AES code in GnuPG wouldn't be
optimized for a number of reasons, becasue of security (timing
attacks), and also a desire to keep GnuPG architecture-agnostinc. The
faster AES code used by 7-zip pretty much assumes a 32-bit x86
processor is the target. It's C, not assembler, but the data alignment
in 7-zip's code is very architecture specific.

@_date: 2007-10-15 06:26:08
@_author: Ryan Malayter 
@_subject: PGP messages getting flagged as spam 
Another problem: automatically adding negative score to PGP data would
make that an attractive tactic for spammers. If such a rule were
popular in SpamAssasin, you'd see a lot of base64 encoded HTML spam
with "fake" PGP headers, I imagine.
The real solution would be for SpamAssasin to check that the PGP
messages are well-formed, and verify signatures on any PGP message
before altering its score. A tad CPU intensive, I think, and it poses
a host of key management and trust management issues if the
SpamAssasin systems serves many users (which most do).

@_date: 2007-10-18 07:07:23
@_author: Ryan Malayter 
@_subject: professionalism, was Re: PGP messages getting flagged as spam 
Why wouldn't you set up a test lab with the Microsoft products as
well? They offer zero-cost trial and developer editions of their
products for that express purpose.
You should never rely on the word of a vendor if there is an
alternative. You can always find proprietary vendors that will give
you a trial of some sort. At my company, we've had months-long trial
installations of $1M+ vertical market software packages before signing
any agreement to purchase.

@_date: 2007-10-19 07:06:10
@_author: Ryan Malayter 
@_subject: PGP messages getting flagged as spam 
You advocate a
(x) technical ( ) legislative ( ) market-based ( ) vigilante
approach to fighting spam. Your idea will not work. Here is why it
won't work. (One or more of the following may apply to your particular
idea, and it may have other flaws which used to vary from state to
state before a bad federal law was passed.)
( ) Spammers can easily use it to harvest email addresses
(x) Mailing lists and other legitimate email uses would be affected
( ) No one will be able to find the guy or collect the money
(x) It is defenseless against brute force attacks
(x) It will stop spam for two weeks and then we'll be stuck with it
(x) Users of email will not put up with it
(x) Microsoft will not put up with it
( ) The police will not put up with it
(x) Requires too much cooperation from spammers
(x) Requires immediate total cooperation from everybody at once
( ) Many email users cannot afford to lose business or alienate
potential employers
( ) Spammers don't care about invalid addresses in their lists
(x) Anyone could anonymously destroy anyone else's career or business
Specifically, your plan fails to account for
( ) Laws expressly prohibiting it
(x) Lack of centrally controlling authority for email
( ) Open relays in foreign countries
( ) Ease of searching tiny alphanumeric address space of all email addresses
(x) Asshats
( ) Jurisdictional problems
( ) Unpopularity of weird new taxes
( ) Public reluctance to accept weird new forms of money
( ) Huge existing software investment in SMTP
(x) Susceptibility of protocols other than SMTP to attack
( ) Willingness of users to install OS patches received by email
( ) Armies of worm riddled broadband-connected Windows boxes
(x) Eternal arms race involved in all filtering approaches
( ) Extreme profitability of spam
(x) Joe jobs and/or identity theft
( ) Technically illiterate politicians
( ) Extreme stupidity on the part of people who do business with spammers
( ) Extreme stupidity on the part of people who do business with Microsoft
( ) Extreme stupidity on the part of people who do business with Yahoo
(x) Dishonesty on the part of spammers themselves
(x) Bandwidth costs that are unaffected by client filtering
(x) Outlook
and the following philosophical objections may also apply:
(x) Ideas similar to yours are easy to come up with, yet none have
ever been shown practical
( ) Any scheme based on opt-out is unacceptable
( ) SMTP headers should not be the subject of legislation
( ) Blacklists suck
(x) Whitelists suck
( ) We should be able to talk about Viagra without being censored
( ) Countermeasures should not involve wire fraud or credit card fraud
( ) Countermeasures should not involve sabotage of public networks
(x) Countermeasures must work if phased in gradually
(x) Sending email should be free
( ) Why should we have to trust you and your servers?
( ) Incompatiblity with open source or open source licenses
( ) Feel-good measures do nothing to solve the problem
( ) Temporary/one-time email addresses are cumbersome
( ) I don't want the government reading my email
( ) Killing them that way is not slow and painful enough
Furthermore, this is what I think about you:
(x) Sorry dude, but I don't think it would work.
( ) This is a stupid idea, and you're a stupid jerk for suggesting it.
( ) Nice try, assh0le! I'm going to find out where you live and burn
your house down!

@_date: 2007-09-07 08:15:13
@_author: Ryan Malayter 
@_subject: RSA or DSA? That's the question 
I disagree. DSA is more popular - perhaps - for the narrow use case of
OpenPGP keys. But RSA is the *far* more popular public-key algorithm,
used in everything from SSL/TLS to secure military communications
devices.  A general technique which allows RSA to be broken is far
more valuable than a general break in DSA or ElGamal.
If you were a government spending money to crack crypto, wouldn't you
like to be able to impersonate and read the traffic from every
"secure" website on the planet? Oh, and read the mail of foreign
militaries and diplomats as a bonus?
Or would you want to read Werner Koch's mail and that of a few other
crypto enthusiasts? Despite its standardization and patent-free
nature, DSA isn't really that popular in my experience.
