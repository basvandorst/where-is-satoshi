
@_date: 2001-06-07 15:35:02
@_author: christopher.a.feathers@accenture.com 
@_subject: Perl, GPG, and --passphrase-fd 
I saw a few postings in previous months that posed the question:
"How do I invoke decryption with a passphrase and avoid getting prompted
for a passphrase?"
Browsing through the gpg.man page I found an option of:
       --passphrase-fd n
                 Read  the  passphrase from file descriptor n. If
                 you use 0 for n, the  passphrase  will  be  read
                 from  stdin.     This  can  only be used if only
                 one passphrase  is  supplied.   Don't  use  this
                 option if you can avoid it.
That is great! - but I cannot seem to figure how to get at the file
descriptor that Perl is looking to use.  Has anyone used this option?
Thanks a bunch.... this is driving me crazy.

@_date: 2001-06-18 17:00:02
@_author: christopher.a.feathers@accenture.com 
@_subject: Decryption using GnuPG:Interface and Perl 
I am trying to wrap some of the GnuPG functions in Perl so I can enforce
some logging (an a few other reasons).  l am running into a problem when I
attempt decrypt an pass in a bad passphrase - a scenario that is quite
possible.  I get a "Broken pipe" printed to STDOUT and my script cannot
continue.  Is there a way to catch the fact that the passphrase was bad
before attempting to print the encrypted file's contents to stdin as given
in the GnuPG::Interface examples?
Here is the code with a comment where I am getting the broken pipe
sub decrypt_input_file {
     $input = IO::Handle->new();
     $output = IO::File->new( ">$output_file");
     $errfile = IO::File->new( ">>$TEMP_STDERR");
     $passphrase_fh = IO::Handle->new();
     $handles = GnuPG::Handles->new(stdin=>$input, stdout=>$output, stderr
=>$errfile, passphrase=>$passphrase_fh);
     $handles->options( 'stdout' )->{direct} = 1;
     $handles->options( 'stderr' )->{direct} = 1;
     $gnupg = GnuPG::Interface->new();
     $cipher_file = IO::File->new("<$input_file");
     $pid = $gnupg->decrypt(handles=>$handles);
     print $passphrase_fh $passphrase;
     close $passphrase_fh;
     # The next line is the one that gives me the problem if the passphrase
is bad
     print $input $_ while <$cipher_file>;
     close $input;
     close $cipher_file;
     close $errfile;
     waitpid $pid, 0;
     close $output;
     return (1);
 -Chris

@_date: 2001-06-19 17:31:01
@_author: christopher.a.feathers@accenture.com 
@_subject: Decryption using GnuPG:Interface and Perl 
Can't seem to get  to work - do you have an example?
            Frank Tobin                                                                                                                     To:     Christopher A. Feathers                                                                           cc:     GnuPG Users List                                        06/18/2001 04:52 PM          Subject:     Re: Decryption using GnuPG:Interface and Perl                     I am trying to wrap some of the GnuPG functions in Perl so I can
    some logging (an a few other reasons).  l am running into a problem
when I
    attempt decrypt an pass in a bad passphrase - a scenario that is quite
    possible.  I get a "Broken pipe" printed to STDOUT and my script cannot
    continue.  Is there a way to catch the fact that the passphrase was bad
    before attempting to print the encrypted file's contents to stdin as
    in the GnuPG::Interface examples?
Three things you can do, off of the top of my head:
1: Get the PID of the running GnuPG process (the return from "decrypt"),
and check if it's still running (send a signal of 0).
2: Read the status-fd from GnuPG; it would report a bad/good passphrase
before you had to send in the input.
3: Use the test_default_key_passphrase method of GnuPG::Interface to
pre-check the passphrase.
Frank Tobin

@_date: 2001-06-20 16:42:01
@_author: christopher.a.feathers@accenture.com 
@_subject: Verifying a detached file using GnuPG::Interface 
Is there a interface method for verifying a file with a detached signature
with GnuPG::Interface?
