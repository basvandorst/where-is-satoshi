
@_date: 2014-07-03 13:46:33
@_author: Neal H. Walfield 
@_subject: Analogien um das Prinzip von PGP zu =?UTF-8?B?ZXJrbMOkcmVu?= 
At Thu, 03 Jul 2014 12:50:50 +0200,
You might want to take a look a this:
    Email encryption, although cryptographically straightforward,
  appears too complicated for laypeople to understand.  In our
  project, we aimed to understand why this problem has eluded
  researchers for well over a decade and expand the design space of
  possible solutions to this and similar challenges at the
  intersection of security and usability.
  ...
  In PGP?s metaphors, each user posses two items, a private key and a
  public key.  Have you inferred how the protocol works yet?  Unless
  you have previous exposure to cryptography, likely not.  Why do I
  have two keys? What do these keys open? Aren?t all keys private?
  When you want to send a message to someone, you encrypt it with his
  public key, which is known to everyone.  The recipient can decrypt
  it with his private key, which only he possesses.  But can?t anyone
  use the public key to decrypt the message again?  Nope.  A public
  key can only encrypt, not decrypt.  Just trust us on that one.
  You?re probably starting to understand why secure email is so hard
  to use.  Bear with us for one paragraph longer.
  ...
  We decided to test whether better metaphors might be able to close
  this gap between security and usability.  Specifically, we wanted
  metaphors that represented the cryptographic actions a user performs
  to send secure email and were evocative enough that users could
  reason about the security properties of PGP without needing to read
  a lengthy, technical introduction.  We settled on four objects: a
  key, lock, seal and imprint.  To send someone a message, secure it
  with that person?s lock.  Only this recipient has the corresponding
  key, so only they can open it.  To prove your identity, stamp the
  message with your seal.  Since everyone knows what your seal?s
  imprint looks, it?s easy to verify that the message came from you.

@_date: 2014-06-17 12:04:20
@_author: Neal H. Walfield 
@_subject: mascot_p 
At Tue, 17 Jun 2014 11:36:11 +0200,
How about an Octopus?  As I understand it, they like to try and open

@_date: 2014-06-17 15:16:31
@_author: Neal H. Walfield 
@_subject: mascot_p 
At Tue, 17 Jun 2014 09:00:52 -0400,
That looks more like a cat...

@_date: 2014-06-17 15:29:08
@_author: Neal H. Walfield 
@_subject: mascot_p 
FWIW, I was thinking of a stylized version of something like this:
  (Found here:

@_date: 2015-04-21 10:42:24
@_author: Neal H. Walfield 
@_subject: wiki.gnupg.org theme? 
At Tue, 21 Apr 2015 10:26:19 +0200,
I like Solenoid, if only because it appears to impose a maximum width
on the main content, which is my main complaint with the current

@_date: 2015-04-28 16:06:59
@_author: Neal H. Walfield 
@_subject: Notes from the first OpenPGP Summit 
Hi Simon,
We've documented the problem at  .
At Tue, 28 Apr 2015 14:45:22 +0200,
The solution is to fix Gnome Keyring :).  I've spoken with Stef, the
main developer of GKR, and he confirmed that the only reason GKR MITMs
GPG Agent is so that it can intercept prompts for the password to
supply any cached value.  The solution is to enhance pinentry so that
if GKR is available it caches the password with GKR.  This requires a
few modifications to GnuPG proper as well as enhancements to pinentry.
I'm working on this and it should be done shortly.  The GPG Tools
people also need this functionality in GPG 2.0 so it will also be
backported.  We hope to coordinate with Debian to get the fixed
versions of GPG and GKR in the next point release of Jessie.

@_date: 2015-04-28 17:02:12
@_author: Neal H. Walfield 
@_subject: Notes from the first OpenPGP Summit 
At Tue, 28 Apr 2015 10:26:05 -0400,
I've added a checkbox to pinentry that asks: "Cache password with GKR"
and it is only shown if GKR is present.  So it's opt-in.
There are so many attack vectors that providing this opt-in hardly
seems to make a difference to me.  If we actually had process
isolation, I might agree with you.  But, as things stand, we don't.  I
wouldn't allow GKR to cache my passphrase either, but other people
disagree.  In particular, the maintainer of GKR, which is widely used
and practically a hard requirement even on Xfce.
I don't understand this "if".  GKR is implementing (a subset of) gpg
agent's protocol.
Actually, the secrets API is a desktop standard and I was told KWallet
speaks it.  So, this enhancement will work with KWallet as well.
Also, the GPG Tools people (Mac OS) do something similar to GKR (but
less invasive) so the modifications to the gpg core will help them as

@_date: 2015-04-28 21:20:34
@_author: Neal H. Walfield 
@_subject: Notes from the first OpenPGP Summit 
At Tue, 28 Apr 2015 17:38:53 +0200,
I can do this.  But, I'll do it as a separate patch.

@_date: 2015-12-07 10:04:58
@_author: Neal H. Walfield 
@_subject: [Announce] GnuPG 2.1.10 released 
TOFU depends on libsqlite, which you are probably missing.  If GnuPG
doesn't find it, then it disables TOFU.  Can you check whether this is
the case?
:) Neal

@_date: 2015-12-08 13:27:56
@_author: Neal H. Walfield 
@_subject: GPA - unsupported certificate 
The problem has been fixed in Gnome 3.18 (IIRC) and is already
shipping in the latest version of Fedora, for instance.  The fix will
appear in the next Debian version, but the changes are too large for
them to be considered a Jessie point release.
:) Neal

@_date: 2015-12-21 15:12:23
@_author: Neal H. Walfield 
@_subject: gpgkey2ssh and Ed25519 key 
On Mon, 21 Dec 2015 10:28:47 +0100,
gpgkey2ssh has been decprecated for a while.  In fact, it was only
intended as a debugging aid.  (See
:) Neal

@_date: 2015-12-22 14:41:24
@_author: Neal H. Walfield 
@_subject: pubring.kbx, no secring? 
Hi Matthias,
On Tue, 22 Dec 2015 13:28:28 +0100,
The short answer is that we are using a new format.
Note: GnuPG 2 will automatically migrate keys from secring.kbx to
.gnupg/private-keys-v1.d the first time it is run.
:) Neal

@_date: 2015-12-22 15:03:39
@_author: Neal H. Walfield 
@_subject: pubring.kbx, no secring? 
I don't really understand your question, but I'll try to answer what I
think you are asking:
secring is the old format; private-keys-v1.d is the new format.  GnuPG
1 doesn't know about the new format; GnuPG 2 only uses the new format,
but the first time it is run it will migrate any existing keys from
the old format to the new format.
:) Neal

@_date: 2015-12-22 15:22:42
@_author: Neal H. Walfield 
@_subject: pubring.kbx, no secring? 
v1 is the version of the format, which is independent of GnuPG's
format.  I can see how it would be confusing, sorry about that.
:) Neal

@_date: 2015-02-18 21:36:24
@_author: Neal H. Walfield 
@_subject: GNUPG 2.* and AIX - questions 
At Sun, 15 Feb 2015 12:16:58 +0100,
gpg2 is a more extensible rewrite of gpg classic.  gpg2 supports some
crypto algorithms that gpg does not support (e.g., ECC starting with
version 2.1).  gpg2 is still for the CLI and makes some CLI operations
easier than gpg.
npth uses cooperative threading rather than preemptive threading.
This has the advantage of simplifying code: if you don't explicitly
yield (or use a function that yields), then you can't be preempted.
This can significantly reduce synchronization bugs.

@_date: 2015-02-28 12:27:05
@_author: Neal H. Walfield 
@_subject: LDAP-based Keyserver 
Nearly a decade ago, Walter Haidinger posted a how to describing how
to setup an OpenLDAP PGP keyserver.
  In that time, OpenLDAP configuration has gotten a lot more
complicated.  I've modernized and significantly expanded his tutorial.
You can find it here:
  I did my best to provide a recipe that requires little prior knowledge
about OpenLDAP while also explaining the reasoning behind the actions
and high-level concepts.
I'd appreciate it if someone could try to reproduce the steps and
report any bugs.  I used Debian.  There are probably differences on
other platforms that are worth noting.
I'd also appreciate any improvements to the text.

@_date: 2015-07-27 14:15:57
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
I guess you mean this:
  The idea I have in mind is roughly as follows: if you upload a key to
  a keyserver, the keyserver would send an encrypted email to every UID
  in the key. Each encrypted mail contains a unique link to confirm the
  email address. Once all email addresses are confirmed, the key is
  validated and the keyserver will allow access to it just like with any
  regular keyserver.
This approach is not going to stop a nation state.  A nation state can
intercept the mail, decrypt it and follow the link.
For the same reason, it is not going to stop a user's ISP.  Given
Microsoft's et al.'s willingness to cooperate with the NSA, these are
not very good starting conditions.
The approach also has another problem: which key servers are going to
do this?  There are 100s of key servers.  I'm not going to reply to
mails from each one, sorry.
This also seems like a nice way to spam someone.  Generate a key,
upload it to a key server and they have a bunch of mails from the key
server.  Based on this, I suspect that it won't take long for the key
servers to be blacklisted?
Have you considered these issues?  Do you have any thoughts about how
to avoid these problems or do you think they are not real problems?
Regarding the design: personally, I wouldn't have the user follow a
link that includes a swiss number, but have the user reply to the
mail, include the swiss number and sign it.
I'd also consider having the key servers publish the validations.  If
you chain the validations (include the hash of the previous validation
in the current validation) you can detect if the key servers serve a
fake key to a specific user.

@_date: 2015-07-27 21:08:43
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
Hi Nico,
At Mon, 27 Jul 2015 19:21:10 +0200,
If this is not right please point me to the proposal.  The above is
just a quote from the single source in your original email.  After I
read that I will respond to your other questions / comments.
:) Neal

@_date: 2015-07-28 01:28:10
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
At Mon, 27 Jul 2015 17:51:56 +0200,
Sorry.  This was definately unclear.  What I meant is: a nation state
can create a "fake" key, upload it to the key server and intercept the
mail encrypted to the fake key thereby validating the fake key.
This is a worthy goal :).
:) Neal

@_date: 2015-07-28 09:22:23
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
Did you consider user a proof-of-work scheme?  For instance, the user
does a 1 week PoW, signs the result and attackes it to the key.  These
would be refreshed about once a year.
This eliminates the verification servers and the problems associated
with them (namely, people need to trust them and there can't be too
many of them).
It also increases usability: there are no emails.  This can be done
completely by, say, gpg-agent in the background.
gpg (or the email clients) don't need to know about special
verification keys / signatures.  They just check the proof of work and
sort the returned keys appropriately.

@_date: 2015-07-29 00:46:10
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
At Tue, 28 Jul 2015 19:22:29 +0100,
Of course.  A simple proof of work scheme is to find a hash that
starts with X zeros.  This requires 2^X steps.  In our case, the
prefix of the text would be the primary public key.
I'm not so sure.  Recall that we are not attempting to protect against
attacks by nation states.  As such, performing a week of computation
each year is going to be too much to maintain for those who upload
fake keys.  Moreover, this will automatically purge old keys (or at
least rank them very low in search results).  In other words, only
people who actually use a given key will bother performing the work.
What do you mean?  A PoW is just a few dozen bytes large...

@_date: 2015-07-29 14:07:21
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
At Wed, 29 Jul 2015 01:03:53 +0100,
It doesn't have to be per-email address.  It is sufficient to attach
it to the primary key.
Well, I don't like the CA model and that's what Nico is basically
proposing (with less rigorous checks).  Another huge disadvantage is
that user's have to actively participate by replying to emails /
visiting a link.
Using PoW, no human intervention is required and there is no central
authority.  PoW relies on the assumption that conducting an attack is
too expensive to do / maintain.
:) Neal

@_date: 2015-07-29 14:09:54
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
At Wed, 29 Jul 2015 02:30:47 +0100,
Personally, I think c is the killer in this plan: people aren't going
to bother to upload it (assuming they even get that far)!

@_date: 2015-07-29 15:16:55
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
At Wed, 29 Jul 2015 14:05:49 +0100,
I suspect that >95% of users won't bother.  This would defeat the
entire scheme, which requires widespread buy in to be successful.

@_date: 2015-07-29 15:22:52
@_author: Neal H. Walfield 
@_subject: Proposal of OpenPGP Email Validation 
At Wed, 29 Jul 2015 15:14:07 +0200,
Key signing parties are a surprisingly good example that demonstrate
my point.  Key signing parties are a bizarre geek ritual.  Most people
don't do it.  And, I think, most people won't use the validation

@_date: 2015-06-04 18:06:19
@_author: Neal H. Walfield 
@_subject: Parse LISTKEYS output 
At Thu, 04 Jun 2015 12:06:42 +0300,
Are you running:
  gpg --list-keys --with-colons
or doing something else?
If you are doing this from C then you should use gpgme rather than try
and parse the output yourself.  (If you aren't using C, then look to
see if there are any bindings to gpgme.)
If this isn't helpful, please try to describe your problem more
:) Neal

@_date: 2015-03-02 14:33:53
@_author: Neal H. Walfield 
@_subject: wiki.gnupg.org (Re: LDAP-based Keyserver) 
At Mon, 2 Mar 2015 12:35:30 +0100,
I was found out :)
wiki.gnupg.org has the potential to be a great resource.  But, it
needs a lot more content.  I think this would be a good place for
recipes, such as , how to generate keys offline [1] or key signing
related practices.
  [1]

@_date: 2015-11-01 18:41:28
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Sun, 1 Nov 2015 10:50:33 +0000,
This sounds like a good idea.  I'll add it.
:) Neal

@_date: 2015-11-03 15:38:04
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Tue, 3 Nov 2015 14:32:56 +0000,
In this case, we store the whole user id (lower cased).  Only if the
user id is the empty string do we not store a binding.

@_date: 2015-11-03 15:57:05
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
Hi Andre,
At Fri, 30 Oct 2015 13:23:14 +0100,
This could work if both keys are available locally.  If you need to
look up the new key, this is not so easy.
Another problem is that this assumes that the new key has the exact
same user ids.  Oftentimes some emails will have been dropped or the
person's name changed (e.g., marriage, new title, etc.).
:) Neal

@_date: 2015-11-03 16:29:02
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Tue, 3 Nov 2015 15:18:57 +0000,
The bindings are between user id and key.  So, a new binding will be

@_date: 2015-11-03 16:34:39
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Tue, 03 Nov 2015 16:10:24 +0100,
In the verify case, yes.  But what about the sign case?  We just see
that the old key has been revoked, but we don't know what the new key
:) Neal

@_date: 2015-11-03 16:38:37
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Tue, 3 Nov 2015 15:37:06 +0000,
It will only flag an error if there is a conflict.

@_date: 2015-11-03 20:05:12
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Tue, 03 Nov 2015 16:56:27 +0100,
You're correct, I meant the encrypt case.
Let's say you want to send an email to Alice and she has revoked her
key.  Best practice dictates that you should run something like
Parcimonie to keep your keyring up to date.  So, let's assume that
Parcimonie has also updated Alice's key.  Now, when you try to encrypt
an email to Alice, GnuPG won't let you, because the key is revoked.
The question then becomes: how do you discover her new key?  If we had
a machine readable field, as I propose, GnuPG could tell you the new
key id and even automatically fetch it for you.  If we are using
signature cross checking, then GnuPG can't help the user, because the
new key is necessarily available locally.
Note: the trust model is not relevant here.  The issue of determining
the new key is only relevant insofar as the TOFU code can suppress
spurious conflict messages if it has this information.
:) Neal

@_date: 2015-11-06 07:50:44
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Thu, 5 Nov 2015 17:29:22 +0000,
Sure :).  But, it was less important than implementing TOFU in GnuPG
:) Neal

@_date: 2015-11-27 12:57:58
@_author: Neal H. Walfield 
@_subject: gpg-agent prompt slow to show up 
At Fri, 27 Nov 2015 16:43:09 +0800,
First, how did you install GnuPG?  What OS / distribution are you
using?  What configuration options are you using (gpg-agent.conf and

@_date: 2015-10-05 23:46:57
@_author: Neal H. Walfield 
@_subject: Portable version of modern GnuOG 
At Mon, 5 Oct 2015 14:22:30 -0500,
GnuPG 2.x is still portable.  What platform are you targetting?  What
issues are you running into?
:) Neal

@_date: 2015-10-23 13:41:02
@_author: Neal H. Walfield 
@_subject: Direct signatures 
Hi Lachlan,
At Fri, 23 Oct 2015 10:58:22 +0200,
In theory yes, in practice no.  To generate an OpenPGP signature, the
OpenPGP implementation hashes the concatenation of the data and some
metadata.  That is, it computes: H(data || metadata).  Thus, to do
what you want you'd need to give GnuPG not the hash of the data, but
the internal state of the hash function before it appends the
metadata.  Unfortunately, the internal state is implementation and
platform dependent.  If OpenPGP computed signatures as follows:
H(H(data) || metadata), then what you wanted would be straightforward
to implement.
There are two ways around this:
 - You can run gpg on one machine / user account and gpg-agent on
   another.  (Look up the extra-socket option in the GnuPG manual.)
   Note: I briefly cover this in my "An Advanced Introduction to
   GnuPG" presentation, which was recorded at RMLL:
    - Have GnuPG sign the hash of the data.  That is, use something like
   sha256sum to compute a hash of the data, transfer the hash to the
   machine running gpg and sign that data.  This adds a level of
   indirection, which the person verifying the hash needs to deal
   with.
:) Neal

@_date: 2015-10-29 15:06:51
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
Last week, I checked in the TOFU code for GnuPG.  This code will be
part of the next release.  It would be great to get some additional
testing before this happens!
TOFU stands for Trust on First Use and is a concept that will be
familiar to anyone who regularly uses ssh.  When you ssh to a host for
the first time, ssh asks you to verify the host's key (most people
just say yes here).  When connecting to the same host in the future,
ssh checks that the key hasn't changed.  If it has, ssh displays a
TOFU for GnuPG works similarly.  When you verify a message from some
user for the first time, GnuPG saves the binding between the user id
(actually, the normalized email address) and the key.  When you verify
another message from that user, the saved bindings with that user's
address are retrieved.  If there is at least one such binding, but
none of them include the signer's key, then either the signer is using
a new key or someone is attacking you.  In this case, GnuPG displays a
warning and prompts you to verify the key and set an appropriate
policy (e.g., the key should be considered untrusted).
In contrast to the Web of Trust (WoT), TOFU's security guarantees are
rather weak.  When using the WoT correctly, you can have high
confidence that if GnuPG says a given key is controlled by a specific
user, then it probably is.  TOFU, on the other hand, is only able to
detect when the key associated with an email address has changed.  In
other words, TOFU detects inconsistencies.
Despite this, TOFU will be more secure than the WoT for most users in
practice.  This is because using the WoT requires a lot of effort.
First, you have to actively exchange fingerprints with other users and
sign their keys.  Most people can't be bothered to take the time to do
this.  Second, in order to actually use the WoT to verify keys that
you have not directly signed, you need to tell GnuPG how much you
trust other people to correctly verify keys the keys that they sign
(i.e., you need to set the owner trust).  In practice, even fewer
people do this.  But, even if you do do this, you can only confidently
set the owner trust for people that you've actually met.  Thus, the
WoT can only really be used to verify the keys of friends of friends.
This seriously limits the number of people you can securely
communicate with.
Happily you don't need to choose between TOFU and the WoT.  It is
possible to combine them using the tofu+pgp trust model.  In this
model, the trust level for a key under each model is computed and then
the maximum is taken according to the following ordering:
  unknown < undefined < marginal < fully < ultimate < expired < never
For users who want TOFU's ability to detect conflicts, but don't like
that TOFU assigns positive (marginal) trust to new keys without
prompting, it is possible to change the default policy to unknown or
to always prompt the user for the policy for new keys using the
--tofu-default-policy option.  When setting the default policy to
unknown, the WoT will be used for all trust judgments unless TOFU
detects a conflict.
In general, there is no reason to use the bare tofu model.  Instead,
tofu+pgp is the recommended model.  If you've never signed a key, then
this effectively degrades back to the tofu model.
To set the trust model to tofu+pgp, add the following to your
~/.gnupg/gpg.conf file:
  trust-model tofu+pgp
If you don't want TOFU to assign positive trust to new keys by
default, then you should also add the following to your gpg.conf file:
  tofu-default-policy unknown
These and a few other new options are described in detail in the
manual (search for tofu).
There isn't much more to do.
Verifying a message works as usual:
  $ gpg2 --verify EE37CF96-6.txt   gpg: Signature made Fri 18 Sep 2015 03:16:17 PM CEST using RSA key ID EE37CF96
  gpg: Good signature from "Testing (insecure!)" [unknown]
  gpg: Verified 5 messages signed by "Testing (insecure!)" (key: 362D 3527 F53A AD19 71AA  FDE6 5885 9975 EE37 CF96, policy: auto) in the past 42 minutes, 59 seconds.
  gpg: Warning: if you think you've seen more than 5 message signed by this key, then this key might be a forgery!  Carefully examine the email address for small variations (e.g., additional white space).  If the key is suspect, then use 'gpg --tofu-policy bad "362D 3527 F53A AD19 71AA  FDE6 5885 9975 EE37 CF96"' to mark it as being bad.
Here, the only change are a few additional messages.  First, some
statistics are displayed, namely, that we've verified 5 messages
signed by this key in the past last hour.  Further, a warning is
printed that the number of messages that we've verified is rather
small and we should be suspicious of this binding.  This information
is displayed to make it easier to recognize forged keys.
Unlike with ssh where the user types the name of the host to connect
to, an attacker is able to control the content of the user id field.
To work around the protections that TOFU offers, an attacker will use
a similarly looking, but different email address.  It's impossible to
reliably detect these forgeries.  Instead, we rely on the email client
to compare the sender with the signer and display a warning if these
don't match.  Further, we provide these statistics so that users will
become suspicious if suddenly GnuPG claims that it has only seen a
single message from a person with whom they are in regular contact.
Here we see what happens when GnuPG verifies a message and there is a
  $ gpg2 --verify BC15C85A-1.txt   gpg: Signature made Fri 18 Sep 2015 02:06:17 PM CEST using RSA key ID BC15C85A
  gpg: Good signature from "Testing (insecure!)" [unknown]
  Please indicate whether you believe the binding <439D 954F 18F7 9CC4 F71B  ED91 CACE D996 BC15 C85A, testing (insecure!)> is legitimate (the key belongs to the stated owner) or a forgery (bad).
  Known user ids associated with this key:
    Testing (insecure!) (policy: ask)
  Statistics for keys with the email 'testing (insecure!)':
    439D 954F 18F7 9CC4 F71B  ED91 CACE D996 BC15 C85A (this key):
      0 signed messages.
    362D 3527 F53A AD19 71AA  FDE6 5885 9975 EE37 CF96 (policy: ask):
      6 messages signed over the past 1 month.
  Normally, there is only a single key associated with an email address.  However, people sometimes generate a new key if their key is too old or they think it might be compromised.  Alternatively, a new key may indicate a man-in-the-middleattack!  Before accepting this key, you should talk to or call the person to make sure this new key is legitimate.
  (G)ood/(A)ccept once/(U)nknown/(R)eject once/(B)ad? g
  gpg: Verified 0 messages signed by "Testing (insecure!)" (key: 439D 954F 18F7 9CC4 F71B  ED91 CACE D996 BC15 C85A, policy good).
In this case, I've marked the key as being good.
I'd appreciate any feedback regarding this new feature (both positive
and negative!).  In particular, I'm interested in learning how well
this fits into your work flow and whether or not you'll use it.
Note: GpgME has not yet been extended to support TOFU so these
messages might not be shown.
:) Neal

@_date: 2015-10-29 22:28:54
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Thu, 29 Oct 2015 18:48:43 +0100,
Unfortunately, it doesn't.  This is because there is currently no
standard way to communicate the id of the new key.  I've proposed a
solution for this for the next OpenPGP version, which is currently
being work on.  There appears to be some interest, but unfortunately I
haven't had time to work on that recently.
:) Neal

@_date: 2015-10-29 22:38:40
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
Hi Peter,
At Thu, 29 Oct 2015 19:57:29 +0100,
I think this mostly reflects our thinking.  Thanks for the good
FWIW, we have thought of aging the data or just storing the hash of
the most recent X signatures.  But, we decided to defer that
discussion until later since it should be easy to add on.
To keep the code simple, I'd prefer to avoid adding options that few
people will use and are of questionable utility.  In particular, I
think if someone's security requirements are such that having a list
of the hashes of previously seen messages is too big of a security
risk, then they should probably just disable TOFU.  Indeed, TOFU
itself probably violates their security requirements.
:) Neal

@_date: 2015-10-30 12:51:27
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Fri, 30 Oct 2015 11:43:28 +0000,
Sure.  But your point is a red herring.  There is *currently* no way
to do this.  However, the next version of the OpenPGP spec should have
a way to do this.

@_date: 2015-10-30 13:09:51
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Fri, 30 Oct 2015 12:06:14 +0000,
The user ids are used.  These are authorative.  If there are N user
ids, then N bindings are maintained.
The primary key is always used in the binding.
:) Neal

@_date: 2015-10-30 22:08:25
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Fri, 30 Oct 2015 14:32:07 +0000,
It's not standardized.  Sure, GnuPG could use a particular notation
for this purpose, but we want to interoperability, which is why this
should be standardized in RFC 4880bis.

@_date: 2015-10-31 21:27:09
@_author: Neal H. Walfield 
@_subject: TOFU for GnuPG 
At Sat, 31 Oct 2015 11:57:05 +0000,
N is the number of unique signatures.  If you verify the message
signature multiple times, it will only count once.
I'm sure we could do something like this, but it sounds like adding
complexity, which doesn't seem justified.
:) Neal

@_date: 2015-09-22 19:39:53
@_author: Neal H. Walfield 
@_subject: default-ttl not honoured 
At Tue, 22 Sep 2015 11:07:22 -0400,
What version of gpg / gpg-agent are you using?

@_date: 2016-04-11 09:40:13
@_author: Neal H. Walfield 
@_subject: Perform only asymmetric encryption/decryption 
You can extract the session key using --show-session-key and set the
session key using --override-session-key
  $ echo | gpg2 --no-options -c | gpg2 --show-session-key -d
  gpg: session key: '7:7BF4443B3652BD25CEC2BA641135AC58'
The format of the session key is algorithm id and the hex-encoded
The created message has the following form:
  echo | gpg2 --no-options -c | gpg2 --list-packets
  # off=0 ctb=8c tag=3 hlen=2 plen=13
  :symkey enc packet: version 4, cipher 7, s2k 3, hash 2
  	salt 6E31D6F821C697BD, count 24117248 (231)
  # off=15 ctb=d2 tag=18 hlen=2 plen=54 new-ctb
  :encrypted data packet:
  	length: 54
  	mdc_method: 2
  # off=36 ctb=a3 tag=8 hlen=1 plen=0 indeterminate
  :compressed packet: algo=1
  # off=38 ctb=cb tag=11 hlen=2 plen=7 new-ctb
  :literal data packet:
  	mode b (62), created 1460360139, name="",
  	raw data: 1 bytes
That is, it has an SK-ESK packet and a symmetrically encrypted packet.
You just want the SK-ESK, which should be relatively straightforward
to extract.  Unfortunately, IIRC, if GnuPG doesn't have an encrypted
body, it won't show the session key when --show-session-key is used.
But, this can be changed relatively easily.
A more fundamental problem is that GnuPG will warn (or perhaps error
out?) if the provided session key is weak.
Good luck!
:) Neal

@_date: 2016-04-11 11:33:52
@_author: Neal H. Walfield 
@_subject: Perform only asymmetric encryption/decryption 
You're right.  If you are willing to modify GnuPG, this is easy to
change, however.  (Look at seskey.c:make_session_key and have it use
the contents of opt.override_session_key rather than generate a random
:) Neal

@_date: 2016-07-08 14:24:34
@_author: Neal H. Walfield 
@_subject: Decrypting multiple encrypted blocks on one stream using GPG 
You might be able to use gpg's --extra-socket feature to solve your
problem.  Using this feature, gpg could do the asymmetric crypto on
your small box (this just costs some KB of network traffic) and the
symmetric on some other box.
:) Neal

@_date: 2016-07-17 15:19:37
@_author: Neal H. Walfield 
@_subject: GPG and Mailinglists using IBCPRE 
On Sat, 16 Jul 2016 16:38:27 +0200,
There is some highly experimental support in a GnuPG branch for
mailing list support that doesn't require that the server access the
plain text.  You can read about it here:
  :) Neal

@_date: 2016-07-17 19:32:28
@_author: Neal H. Walfield 
@_subject: GPG and Mailinglists using IBCPRE 
Scleuder requires that the mail server decrypt the messages.  My
solution doesn't, which is what I think the OP was looking for.  Of
course, Schleuder is straightforward to deploy whereas mine is still a
:) Neal

@_date: 2017-04-02 21:00:46
@_author: Neal H. Walfield 
@_subject: some beginner questions 
At Sun, 2 Apr 2017 11:20:16 -0700,
Your main key is a unique global identifier.  It is what you write on
your business card and what you compare to validate a key.  If it is
compromised, then you need to revoke your main key and generate a new
one.  This means you have to throw away your old business cards and
inform all of your contacts that you have a new key.  If a subkey is
compromised, then you only need to rotate the subkey, not the whole
key.  In other words, you don't have to throw away your business cards
or inform your contacts that something has changed: their OpenPGP
implementation will automatically learn about the changes the next
time your key is refreshed.
In short, the main key acts as a level of indirection, which separates
your identity from your encryption/signing keys.

@_date: 2017-04-03 09:24:27
@_author: Neal H. Walfield 
@_subject: some beginner questions 
At Sun, 2 Apr 2017 18:23:14 -0500,
It would be good if you good show us what you are doing.
Specifically, what your key looks like (gpg -k KEYID), and the
commands you are using to sign a message, and the actual output.
Also, it might be helpful for us to know the version of the gpg and
what OS you are using.
:) Neal

@_date: 2017-08-07 12:06:45
@_author: Neal H. Walfield 
@_subject: TOFU db corruption detected 
Unfortunately, there isn't enough information in this report to
reproduce your issue.  If you feel comfortable sending me your TOFU db
and your pubring.gpg / pubring.kbx per private mail, as well as
telling me which key that is causing the problem, then I will take a
Key: 8F17 7771 18A3 3DDA 9BA4  8E62 AACB 3243 6300 52D9
:) Neal
On Sat, 05 Aug 2017 16:56:02 +0200,

@_date: 2017-07-06 21:19:23
@_author: Neal H. Walfield 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
At Fri, 23 Jun 2017 13:45:39 +0300,
I tried to improve the documentation in 243b2a570.  Thanks for the
:) Neal

@_date: 2017-07-12 15:57:48
@_author: Neal H. Walfield 
@_subject: OpenPGP Notations 
I'm collection examples of notations.  If you somehow use notations,
I'd love to hear how you are using them.  (If you prefer to remain
anonymous, please feel free to reply privately.)
Also, I'm curious if anyone has a good use for unsigned ("unhashed")
:) Neal
Key: 8F17 7771 18A3 3DDA 9BA4  8E62 AACB 3243 6300 52D9

@_date: 2017-07-24 13:15:41
@_author: Neal H. Walfield 
@_subject: Test symmetrically encrypted files for errors - make sure they 
At Sat, 22 Jul 2017 00:01:45 +0200 (CEST),
Probably the easiest solution is to sign and encrypt, and then verify
the signature.  If the encrypted data is somehow corrupted, then the
signature will be wrong.  This, of course, embeds the signature in the
OpenPGP message, which might not be desired.

@_date: 2017-06-21 11:53:49
@_author: Neal H. Walfield 
@_subject: Managing the WoT with GPG 
At Tue, 20 Jun 2017 15:34:44 +0200,
You figured it out: whenever your keyring is updated, 'gpg
--check-trustdb' needs to be run.  This is normally done on demand,
which is annoying for even moderately sized keyrings.  You can disable
this behavior by setting no-auto-check-trustdb in your gpg.conf file.
In that case, you'll want to run 'gpg --check-trustdb' periodically to
integrate new keys, expiry information, revocations, etc.  You can do
this in the background via e.g. a cron job.
Since I don't trust most people to sign keys correctly, I just invoke
'gpg --edit-key' (and use the trust subcommand) on the specific keys
that I want to have as trusted introducers.
This isn't easy given the current implementation: GnuPG doesn't store
the graph, but traverses the graph and only saves whether a particular
key is trusted.
See my answer to  this is not currently possible.
This is a pain.  Something along the lines of the following should
  gpg --export | ssh host gpg --import
:) Neal

@_date: 2017-06-21 14:00:30
@_author: Neal H. Walfield 
@_subject: Managing the WoT with GPG 
At Wed, 21 Jun 2017 13:55:52 +0200,
It starts with the set of ultimately trusted keys.  But let's say that
you start with key X, which is not ultimately trusted.  What should
GnuPG do with the result?  Or, let's say that X is ultimately trusted
and it decides that key Y is only marginally trusted, but Y would have
been fully trusted if you started with all ultimately trusted keys.
How do you intelligently merge that?

@_date: 2017-06-22 16:15:46
@_author: Neal H. Walfield 
@_subject: Managing the WoT with GPG 
I didn't say that it is not possible to have a better algorithm.  It
is possible.  But, it is not as easy as you suggest (and what you
suggest doesn't sound trivial).
For instance, adding or updating a key doesn't necessarily result in
equal or more trust.  An update could cause a key to be revoked.  In
that case, if 0xdeadbeef is marginally trusted, we now need to
identify keys that were considered valid because of 0xdeadbeef, but no
longer are.
:) Neal
At Thu, 22 Jun 2017 15:00:52 +0200,

@_date: 2017-06-22 20:31:41
@_author: Neal H. Walfield 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
At Thu, 22 Jun 2017 09:42:50 +0300,
TOFU influences validity.
By default, all known keys are marginally trusted in the TOFU model.
(This is more or less the "first use" bit of "trust on first use".)
In TOFU, the validity of a key is set to unknown if there is an
unresolved conflict.  The user can resolve a conflict either
positively (in which case the validity is full) or negatively (in
which case the validity is never).  Note: this means that it is
possible to make negative assertions when using TOFU, which is not
possible when using WoT.
The summary field in TOFU_STATS is a summary of the key's use.  The
basic idea is that in the absence of facts to the contrary, at the
limit (an infinite number of uses), a given key must have been the
right one (or is indistinguishable from the correct key, which is just
as good, because it means that nothing bad ever happened).  In other
words, a key that has been used for years is more likely to be the
correct one, then one that I've only used once.  In the former case,
I've had many more opportunities to detect a MitM attack.  The summary
field captures this using a simple scale that applications can then
somehow display to the user.  This is currently used by kmail and the
Outlook plug-in.
:) Neal

@_date: 2017-06-23 11:14:31
@_author: Neal H. Walfield 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
At Thu, 22 Jun 2017 20:32:48 +0300,
No, both keys are set to ask.  The key with a lot of observed
signatures could be bad.  This could occur, if there is a MitM, but
the MitM has a small lapse, because, perhaps, you've used an
unintercepted network path to retreive the "new" signature & key.

@_date: 2017-06-23 12:56:09
@_author: Neal H. Walfield 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
At Fri, 23 Jun 2017 12:52:48 +0200,
It's up to the GPG client to interpret it.  This document (authored by
Andre and me) has some recommendations for MUAs:
  :) Neal

@_date: 2017-06-23 13:25:31
@_author: Neal H. Walfield 
@_subject: Are TOFU statistics used for validity or conflict resolution? 
At Fri, 23 Jun 2017 13:22:23 +0200,
You're right: gpg also uses this information to display some

@_date: 2017-06-23 15:50:27
@_author: Neal H. Walfield 
@_subject: Managing the WoT with GPG 
At Fri, 23 Jun 2017 15:35:05 +0200,
Ensuring that a cache is consistent is *hard*.  I don't think we want
to add complexity (nevermind a cache!) to this security-critical

@_date: 2017-06-23 20:04:13
@_author: Neal H. Walfield 
@_subject: Managing the WoT with GPG 
At Fri, 23 Jun 2017 13:04:02 -0400,
gpg does it, yes.  See gnupg/g10/trustdb.c:validate_keys

@_date: 2017-06-25 20:09:13
@_author: Neal H. Walfield 
@_subject: TOFU 
At Fri, 23 Jun 2017 02:07:19 +0100,
Nope.  A MitM could have intercepted the message and replaced the body
with some other signed text (text that it possibly signed with a
"fake" key).
:) Neal

@_date: 2017-06-26 11:53:16
@_author: Neal H. Walfield 
@_subject: Managing the WoT with GPG 
At Mon, 26 Jun 2017 11:27:30 +0200,
I disagree that this is the bottleneck.  Two very strong arguments
against the WoT, IMO are:
  1. Key signing is too hard to do right.
  2. Key signing exposes the social graph.
1 means that people primarily interested in protecting their privacy
don't bother.
2 means that organizations like the Organized Crime and Corruption
Reporting Project (OCCRP) can't use the WoT, because it places their
reporters and sources in danger.
We could perhaps fix 1 by doing more red teaming (i.e., fake attacks
so that people see the actual utility of checking keys), but I'm not
sure that's the best way forward.
:) Neal

@_date: 2017-06-27 10:36:38
@_author: Neal H. Walfield 
@_subject: Managing the WoT with GPG 
At Tue, 27 Jun 2017 09:27:57 +0100,
These should now be disabled.
:) Neal

@_date: 2017-03-17 15:02:10
@_author: Neal H. Walfield 
@_subject: GnuPG 2.1.19 crashing when listing keys, 
At Wed, 15 Mar 2017 00:38:45 +0000,
Thanks for the report and the analysis.  I've just (hopefully) fixed
this in b1106b4.
Sorry about that!
:) Neal

@_date: 2017-10-11 09:14:19
@_author: Neal H. Walfield 
@_subject: FAQ and GNU 
At Tue, 10 Oct 2017 23:55:32 -0400,
I didn't realize that there was a vote.  FWIW, I agree with dkg,
although I'm not particularly passionate about it.
:) Neal

@_date: 2017-10-11 09:15:41
@_author: Neal H. Walfield 
@_subject: FAQ and GNU 
At Wed, 11 Oct 2017 08:26:21 +0200,
I'm aware of an effort that tried to port GnuPG to Android.  bionic
was a source of several problems.  As far as I know, the work is
currently stalled.

@_date: 2017-10-11 19:54:58
@_author: Neal H. Walfield 
@_subject: FAQ and GNU 
At Wed, 11 Oct 2017 17:47:29 +0200,
That's great to know, thanks!  Unfortunately, it appears that there
have either been regressions or the people that I spoke with made some

@_date: 2018-02-16 20:52:35
@_author: Neal H. Walfield 
@_subject: Expected behaviour setting TOFU policy 
At Thu, 15 Feb 2018 17:20:14 -0500,
If you don't explicitly set the trust model, then gpg uses the trust
model that is saved in the trust db.  Using --tofu-policy doesn't use
the trust db (it only updates tofu.db), but --verify does.  Hence
after calling --tofu-policy, the trust mode is not saved, but after
calling --verify it is.
In general, it is better to set the trust-model in your gpg.conf file
and never set it on the command line if only because rebuilding the
trust db is very expensive for large key rings.
I suspect that there are other bugs of this sort, and I'm not sure it
is worth fixing.
:) Neal

@_date: 2018-02-20 20:36:32
@_author: Neal H. Walfield 
@_subject: Why Operating Systems don't always upgrade GnuPG 
At Tue, 20 Feb 2018 16:08:35 +0100,
I'd rather not air dirty laundry, but I feel it necessary to correct
misinformation.  I did not leave g10code, because working on gpg was
"uncool".  I left because we (Werner and I) could not work well
together.  This is the same reason that Justus, Kai and Marcus left.

@_date: 2020-11-19 08:52:39
@_author: Neal H. Walfield 
@_subject: Avoid recipient-compatibility SHA1 
Hi Stefan,
A chosen-prefix collision attack works as follows: an attacker chooses
two message prefixes, and then uses near collisions blocks (in the
SHA-1 is a Shambles paper they needed about 10 such 512-bit blocks) to
align the internal state of the two hashes.  Since SHA-1 is a
streaming function, the attacker can also append a common suffix.
That is, we want:
  Hash(prefix  || near collision blocks  || suffix)
  = Hash(prefix  || near collision blocks  || suffix)
And the attacker can choose prefix  prefix  and suffix, but
cannot control near collision blocks  or near collision blocks One way to exploit this is to create a pair of colliding documents
(e.g., something benign and a will), and then convince Alice to sign
the benign one.  If successful, the signature can be transferred to
the other document, and it appears that Alice has sign it too!
This attack requires the attacker to hide the near collision blocks in
the documents.  This is often straighforward: most formats have
provisions for comments, or metadata, which the user does not see.
The difficulty is to get Alice to sign the first document: if she
modifies it (e.g., adds any context), then the hash will be different.
But, if Alice is a signing service, then this may be possible even if
Alice modifies the document as long as the modifications are
On Wed, 18 Nov 2020 14:30:12 +0100,
This is currently not possible.  What you describe is a preimage
attack, not a collision attack.  A preimage attack is when you can
create a document with the same hash as an existing document.  Right
now, it is possible to find two documents that collide, but you can
only partially control the content of each of them (i.e., you need to
add the near collision blocks to both to actually create the
:) Neal

@_date: 2020-10-11 22:47:01
@_author: Neal H. Walfield 
@_subject: Show that an encrypted message was signed, without decrypting it 
Hi Teemu,
On Sun, 11 Oct 2020 11:02:00 +0200,
The signature information is normally (that is, when doing sign then
encrypt) completely encapsulated by the encryption container.  What I
think you are seeing is gpg caching something.  If you replace 'gpg
--list-packets' with 'pgpdump', then you probably won't see any
signature information.
:) Neal

@_date: 2020-09-19 23:50:45
@_author: Neal H. Walfield 
@_subject: Which keyserver 
Hi Andrew,
On Sat, 19 Sep 2020 21:38:22 +0200,
This is not strictly true.
When we think about updating keys, there are two types of information
that can be updated:
  - Identity Information (User IDs)
  - Operational Information (Revocations, Subkey Rotations, Metadata
    (self-sig) updates, etc.)
Identity information in privacy sensitive, and we think people should
be able to control where their details are published, and have the
ability to retract them, if desired.  This requires some type of
Operation Information does not require the same protection, and can
and should be widely published.  It would be possible to create a
network of keyservers that synchronize this type of information in a
similar way to how SKS worked.  But, we know from experience with SKS
that this is not easy (the set of filters needs to be synchronized,
etc., which is a type of centralization).  So far, no one has taken
the time to think through this problem, and implement a solution for
Hagrid.  But, I think that we'd welcome a patch that adds such
:) Neal
