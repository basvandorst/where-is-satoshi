
@_date: 2014-04-29 11:11:23
@_author: martijn.list 
@_subject: Validation of User ID with invalid (non UTF-8) encoding 
Some keys stored on the public key servers have User IDs which seem to
be encoded with a different encoding than UTF-8.
For example the key with key ID 0xA8364AC589C44886 shows an invalid
character when viewed online:
gpg is able to validate the User ID
$ gpg --check-sigs 0xA8364AC589C44886
pub   1024D/89C44886 1999-09-30
uid                  Lasse M\xberkedahl Larsen sig!         89C44886 1999-09-30  Lasse M\xberkedahl Larsen sub   2048g/0CA36EF9 1999-09-30
sig!         89C44886 1999-09-30  Lasse M\xberkedahl Larsen My own Java based tool however fails to validate this User ID, i.e., the
calculated hash always returns a different value. Also PGP desktop
reports that the signature is incorrect.
Any idea why this User ID validates correctly with gpg but not with
other tools? Does gpg handle non-UTF-8 encoded User IDs differently?
Kind regards,
Martijn Brinkers

@_date: 2014-07-14 18:06:37
@_author: martijn.list 
@_subject: email bot for PGP/MIME PGP/Inline conversion 
Unfortunately this won't work. You cannot convert a PGP/MIME message
into a PGP/INLINE message and vice versa. With a PGP/MIME message, the
complete MIME structure is signed and/or encrypted. This includes
attachments etc. With PGP/INLINE every individual MIME part is signed
and/or encrypted.
Kind regards,
Martijn Brinkers

@_date: 2014-07-14 18:33:37
@_author: martijn.list 
@_subject: email bot for PGP/MIME PGP/Inline conversion 
Yes with a text only message it should work. But if you have a
multipart/alternative message (i.e., text and html part) you'll run into
But how? you can of course show the complete MIME structure but that is
not very informative I would think. Perhaps I'm missing something though.
With "unfortunately won't work", I meant won't work in the general case
:) Of course there will be cases where it will work. The problem is that
since the original message is encrypted, you cannot know for sure for
which message it will work and for which message it won't. But if
someone is happy with 80% reliability then you might make people happy
with such a service.
Kind regards,
Martijn Brinkers

@_date: 2014-06-08 21:03:36
@_author: martijn.list 
@_subject: GnuPG 2.1 exporting secret keys 
I'm trying to export the secret keys which were generated with the
latest GPG 2.1 beta.
I do however receive the following error:
~$ gpg2 -v --export-secret-key -a -o test.key 2BAD7887
gpg: NOTE: THIS IS A DEVELOPMENT VERSION!
gpg: It is only intended for test purposes and should NOT be
gpg: used in a production environment or with production keys!
gpg: writing to 'test.key'
gpg: key 2BAD7887: asking agent for the secret parts
gpg: key 2BAD7887: error receiving key from agent: Missing item in
object - skipped
gpg: key 2BAD7887/F1D5FF9D: asking agent for the secret parts
gpg: key 2BAD7887/F1D5FF9D: error receiving key from agent: Missing item
in object - skipped
gpg: WARNING: nothing exported
Any idea what I'm doing wrong or what might be the problem?
Kind regards,
Martijn Brinkers

@_date: 2014-06-09 14:30:48
@_author: martijn.list 
@_subject: GnuPG 2.1 exporting secret keys 
Hmm strange, it reports a different version
$ gpg-connect-agent 'getinfo version' /bye
D 2.1.0-beta704
I have used the following script to build it from GIT so I assumed that
it uses the latest release from git://git.gnupg.org since it basically
does a "git clone git://git.gnupg.org" for all the required parts
The script seems to clone the head and not a specific branch.
Kind regards,
Martijn Brinkers

@_date: 2014-06-09 15:43:06
@_author: martijn.list 
@_subject: GnuPG 2.1 exporting secret keys 
It seems that autogen.sh returns the wrong version.
The following command seems to return the correct version (this is from
$ git describe --match "gnupg-2.1.*[0-9]" --long
However piping it through awk (as done in autogen.sh) it returns an
empty string
$ git describe --match "gnupg-2.1.*[0-9]" --long  | awk -F- '$3!=0 && $3
!~ /^beta/ {print"-beta"$3}'
Because of this the following line is tried:
$ git describe --match "gnupg-2.1-base" --long | awk -F-
which returns
Since this part is a recent addition to autogen.sh could it be that
there is a problem with the new code in relation to the current tags?
Kind regards,
Martijn Brinkers

@_date: 2014-06-26 16:56:47
@_author: martijn.list 
@_subject: riseup.net OpenPGP Best Practices article 
While in principle I agree that 2048 bit key is strong enough for most
uses, comparing 3DES keys space (or any other symmetric encryption
algorithm) and RSA (or some other public key system) key space is a
bit like comparing apples and oranges. If you crack the 3DES
encryption of a message you have cracked that particular message. If
you crack the RSA key, you have cracked all messages. So the effective
key space of your public key should be larger then the key space of
the session key(s).
Kind regards,
Martijn Brinkers

@_date: 2014-05-22 19:04:30
@_author: martijn.list 
@_subject: How are primary key  binding signatures (0x19) handled by gpg? 
According to RFC 4880
"For subkeys that can issue signatures, the subkey binding signature
MUST contain an Embedded Signature subpacket with a primary key binding
signature (0x19) issued by the subkey on the top-level key."
The sub key of the following key (key ID 0549B8A5640444E6) is valid for
signing (RSA Encrypt or Sign) but it does not contain a primary key
binding signature:
Enigmail tells me that the sub key is valid for signing. It might be
that I misunderstand the requirement but it seems that in this case the
key should not be used for signing since it lacks the primary key
binding signature. I know that this requirement is relatively recent so
it might be that for this key the current behaviour is for backward
compatibility reasons. Is there some documentation on how GPG handles
signing sub keys without a valid primary key binding signature?
Kind regards,
Martijn Brinkers

@_date: 2014-10-14 11:25:15
@_author: martijn.list 
@_subject: emails snowden and poitras 
Just speculating but this question might help in case of a "gag order".
If Poitras was under a gag order, the best thing to do is to not reply
to that messages. By not replying you are not breaking the gag order
(not sure about that though). The sender however might infer from not
getting a reply that the answer was yes, "my keys were compromised".
Only by actively faking a signed and encrypted email, could the
adversary pretend that the keys were not leaked. It might be that there
are legal reasons why this is not allowed or it might be a little easier
to detect that this message was not from Poitras. Again, all speculation.
Kind regards,

@_date: 2015-03-25 21:06:53
@_author: martijn.list 
@_subject: PGP/MIME (Was: One alternative to SMTP for email: Confidant Mail) 
It looks like this is caused by the mailing list software (mailman).
Mailman adds a banner to the mail and therefore the mail is no longer a
valid PGP/MIME mail. I think mailman should be smart enough not to mess
with digitally signed mail (same thing happens with S/MIME signed email).
Kind regards,
Martijn Brinkers

@_date: 2019-10-16 10:46:38
@_author: Martijn Brinkers 
@_subject: Future OpenPGP Support in Thunderbird 
I actually spend a lot of time investigating the impact of EFAIL on
S/MIME and it's my opinion that the real impact has been overblown. In
all my experiments, and I can tell you I have done a lot of them, I have
not been able to force a mail client to actually forward the decrypted
content to a remote system.
The CBC attack is serious because modifying encrypted content is not
something you expect from a security point of view. But the real life
impact is not as big as they wanted us to believe (IMHO). I have asked
the EFAIL authors for examples on real life attacks (of the CBC problem
related to S/MIME) but I never got a real answer whether they were able
to use the attack in real life situation.
I think the problem with the paper was that they discusses two separate
issues. The issue with Efail-2 was serious but that was more an mail
client issue.
Kind regards,
