
@_date: 2015-12-15 18:27:06
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Can I pass the password from the command line? 
El 15/12/15 a las 17:21, Anthony Papillion escribi?:
I recall that there is an option "--passphrase-file", which can be used to pass the password programatically. Of course, make sure that the file has secure permissions since it's created (or at least, written to) to store the password.

@_date: 2017-08-16 21:48:14
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Is it possible to certify (sign) a key using a subkey? 
Suppose I would like to sign another user's key using one of my
secp256k1 subkeys, instead of my primary key, because it generates
smaller signatures. gpg does not appear to support this. If I try to
generate a subkey with certify capability ?gpg --expert --edit-key ...?
and then ?addkey?, the option to toggle capability is not shown. Also,
if I try to force gpg to use an *existing* subkey for signing another
key with ?gpg -u FINGERPRINT1! --sign-key ANOTER_KEY? (where
FINGERPRINT1 is the fingerprint of the subkey, and it is followed by ?!?
to try to force use of this subkey) it still uses my primary key.
Why is this behavior? I took a glance at RFC4880 and I could not find a
requirement that only primary keys are used for certifying, although it
is very possible that I just missed it.

@_date: 2017-08-17 07:42:06
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Is it possible to certify (sign) a key using a subkey? 
No, it does not have the certify capability. How can I enable this
If I add a subkey with  ?--expert --edit-key? no option is given to
enable certify capability (as mentioned in my previous message), only
sign and authenticate in the case of ECC keys and sign, authenticate and
encrypt in the case of RSA keys.
This is version 2.1.18 of GNU PG as shipped by Debian 9.

@_date: 2017-08-17 08:55:06
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: export secret subkeys 
It is my understanding that --export-secret-subkeys outputs a *dummy*
(not the actual key) for the private part of the primary key, hence the
output of --list-packets.
The ?gpg? man page says ?The second form of the command [i.e.:
--export-secret-subkeys] has the special property to render the secret
part of the primary key useless;?.

@_date: 2017-08-17 19:47:16
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Is it possible to certify (sign) a key using a subkey? 
I have chosen RSA as a ?known good? algorithm for the primary key
because if I chose a different curve or algorithm for elliptic key once
I have the required knowledge to make an informed decision it will be
more convenient to change only a subkey than to generate a new primary
key. For example, I can keep the signatures (certifications) that I
accumulate during that time on my key, supposing I have the opportunity
to go to a signing party.
Also, using a subkey for signing still has a size advantage. If you
have, say, 5 keys signed by my ECC subkey. there will be less size
Anyway, my question still stands: How can I enable the certificate
capability on a subkey with GPG?

@_date: 2017-08-18 09:16:45
@_author: Mario =?UTF-8?B?Q2FzdGVsw6Fu?= Castro 
@_subject: Is it possible to certify (sign) a key using a subkey? 
I really do not follow your argument (if any). Whether I sign with my
primary key or a subkey is a low level detail. There is no any additional
difficulty encountered by the user who verifies a certificate made by a
subkey, assuming he is using a capable OpenPGP implementation.
This is a low level detail that is for the most abstracted from the user by
the implementation (GNU PG), just as users need not know number theory in
order to use public key algorithms, they need not be concerned of whether
I use my primary key or a subkey for certifying.
In my own and other people's keyrings and in key servers.
Like I said in a previous message, even using ?gpg --expert
--edit-key? (GNU PG version 2.1.18 as shipped in Debian 9), I do not get
the option to toggle the certify capability when adding a new subkey, not
even if I choose the option ?choose your own capabilities?.
Hmm... it looks like I will have to do some programming. This is not good.
GNU PG should already have this feature.

@_date: 2017-08-27 08:14:02
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Newbie Question: Creating a Key Server using GNUPG tools 
If it is an isolated network, it is a small network. Maybe it will be
more convenient to simply export all the keys the ordinary way (?gpg
.--export KEY1 KEY2 ... KEYn? and distribute that through the network.
Linux is a kernel. You mean the GNU/Linux operating system

@_date: 2017-08-29 12:42:05
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Questions about particular use cases (integrity verification w/o 
Although elliptic curves are defined *over* a field, they are not
themselves a field (or at least, I am not aware of any way to define a
field over them).

@_date: 2017-08-29 13:01:38
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Questions about particular use cases (integrity verification w/o 
You can use hash(private_key_1) to seed a cryptographically secure
pseudo-random number generator (E.g.: AES in CTR mode with the seed as
the key), and then use that random stream to generate (private_key_2,
This is a method applicable in general. The algorithms of private_key_1
and private_key_2 need not be the same, nor do they need to be defied
over the same curve.
The only problem is that I do not know of a program to do they key
generation from a user-provided seed.

@_date: 2017-08-29 13:21:58
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: E-mail with deniable authentication 
We have OpenPGP/MIME to sign and encrypt e-mail, thus securing the
communication. It is my understanding that the other party can publish
the signature and the unencrypted message and thus prove that somebody
in the possession of the private key wrote (or at least signed) the message.
One way to do deniable authentication is to take a shared secret.and use
that as the key to a MAC function. However, this does not seem to be
implemented in OpenPGP, although it could be done as an additional layer.
Is there any existing, convenient way to do deniable authentication for

@_date: 2017-08-29 14:04:15
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: E-mail with deniable authentication 
Ha. OpenPGP-signed spam. That is a really amusing incident.
I want to note that I said ?somebody in the possession of the private
key?. I am aware of the ?somebody stole my private key? trick for
signature repudiation. I did not consider the possibility of malware
(thanks for bringing that into my consideration), but the problem is the
The problem is that credible repudiation of signatures done that way
requires that the legitimate key owner (that would be myself) stops
using that key and moreover claims that (at least) all the signatures
more recent (meaning the actual date ?for which in many cases only an
upper bound is known?, not by the date claimed in the signature) than
the one he wants to repudiate are illegitimate.
This is something undesirable. Ideally, there should be no need to throw
the key,

@_date: 2017-08-30 20:40:10
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: key_confusion 
Your message is very bad written and I can barely understand it. I will
answer what I have understood.
The main specification for OpenPGP (the format used by the ?gpg? command
line program) is this: .
*Apparently* it does not specify any file extension.
There are some *conventions* regarding file names. ?.asc? is used for
_ASC_II-armored OpenPGP files. ?.sig? is used for OpenPGP detached
signatures (generated with ?gpg -b?). I think that GNU PG uses ?.gpg? by
default for everything else (as long as it is in OpenPGP format).
Anyway, what matters is the content of the file, not the file name. You
can obtain a summary of the content of any OpenPGP file with ?gpg
--list-packets < FILE?.
I have no idea of what you mean by ?server_internal operation?. GNU PG
does not interfaces with e-mail at all. Many e-mail clients call GNU PG
in the background, but then GNU PG will do whatever the e-mail client
Some people use the word ?certificate? to refer to OpenPGP primary keys.
Primary keys should not be confused with ?revocation certificates?.
*Revocation* certificates are a type of signed message that say ?Do not
longer this key; it may have been compromised or it is not longer in
use? in a machine-readable way.
The act of signing a key (that is, giving your word that the key belongs
to whoever it claims to belong) is also called ?certification?, and the
resulting signature is called a ?certification signature? in RFC 4880.
GNU PG is the name of the software. ?gpg? is the name of one of the
command line programs that GNU PG provides. I do not understand the rest.
These are all misguided questions. The filename is irrelevant. The file
extensions are there for *you* to help you recognize the files, not for
GNU PG.
Look at the ?Documentation? page in the GNU PG web site
I am not a developer of GNU PG, but I assume that public-key algorithms
resistant to quantum computing will be standardized (by some standard
group like the IETF) and added to GNU PG *when* the need arises, just as
support for ECC was recently added.
*Currently* the factorization and discrete logarithm algorithms are
enough. Also note that symmetric encryption algorithms are minimally
affected by quantum computing. GNU PG implements, for example, AES-256
and SHA-512 which should be strong against quantum computers if they are
strong against classical computers.
Instead of worrying about quantum computers, worry about proper security
practices as the end user. The chain is no stronger than the weakest
link, and the user is almost always the weakest link.

@_date: 2017-08-30 21:48:50
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: E-mail with deniable authentication 
Apologies. The authentication code should not be signed either to keep
full deniability.

@_date: 2017-08-30 21:46:23
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: E-mail with deniable authentication 
According to  Bitmessage does
writer-receiver authentication (I do not know what is the standard term
for this public key operation; clearly it is not ?signing?) with HMAC
using a Diffie-Hellman key derived from the shared secret between writer
and recipient. Thus the recipient can not prove to any third party that
the writer wrote the message (because he also knows the shared secret
and thus he can also compute the authentication code).
But Bitmessage gives me the impression of an highly amateurish job. I
cite the absurd use of AES-256 along with a elliptic curve providing
roughly 128 bits of security (secp256k1). Moreover, anybody who cares to
do so can build an FPGA miner for Bitmessage proofs of work and perform
a denial of service given that many users have only a CPU to compute the
I would not trust my sensitive data to it.
?opmsg? gives me an even worse impression. It seems to be the work of a
single man, and I do not even see a specification of the format. Also,
from the readme.md
?The private part of the keys which are stored inside ~/.opmsg are NOT
encrypted. It is believed that once someone gained access to your
account, its all lost anyway?
I would not trust a person with this way of thinking to write my
cryptographic software.

@_date: 2017-08-30 21:35:49
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: E-mail with deniable authentication 
Hello. Thanks for your reply. I am aware of the first method as well as
a variation of the second (it had not occurred to me that they both can
use the same key!; I had thought that each correspondent used one key of
his own with a meaningless ID and used only for communication with the
other correspondent). The problem is that these are an extra layer, not
currently implemented in GNU PG or any other software I know of.
I was hoping that OpenPGP had a feature of ?deniable authentication of
[writer] to [recipient]?. It can be easily implemented with
Diffie-Hellman as follows.
Writer and recipient have a Diffie-Hellman key over the same group and
know each other's public key.
The writer computers the shared secret per the DH algorithm, and
processes it with a KDF. This is the key to a MAC algorithm (e.g.:
HMAC). The writer send the, the message (either encrypted or
unencrypted), the authentication code, and a nonce (if the KDF requires
it) to the recipient
To verify, the recipient computes the shared secret, the MAC key and the
authentication code of the message. The recipient knows (save for broken
algorithms or leaked private keys) that only the writer or him could
have computed the authentication code for the message. We assume that
the recipient remembers what he has written and what he has not written,
so he can discard himself, leaving the writer as the only option.
The recipient can divulge the message, but he can not prove that the
writer (as opposed to him) wrote the message, even if he is willing to
divulge his private key.
*Maybe* I will implement this scheme sometime in GNU PG as an OpenPGP
extension, if somebody doesn't do it in the meantime.
Alternatively, the writer can write an message encrypted to the
recipient public-key consisting of 3 parts: (1) A message signed by the
writer saying ?I am sending *somebody* a secret message authenticated
with MAC algorithm ... and key ...?. (2) The authentication code. (3)
The message itself. The signed message (1) should not include the name
of the recipient. Obviously (3) should not be signed. (2) can be signed
without deniablity implications, but is not necessary.
The most the recipient can do is to prove that the writer wrote ?I am
sending *somebody* a secret message authenticated with MAC algorithm ...
and key ...?, but he can not even prove that the writer wrote that to *him*.
Both of these methods require no prior agreement between sender and

@_date: 2017-08-31 08:24:35
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: please help "No pinentry" 
Hello. GNU PG version 2.* uses a program called ?pinentry? to ask for
passwords whenever it requires a password. There are several such
pinentry programs. You can install several of them but you just need one.
If you use GNU/Linux, search for ?pinentry? in the listing of package in
your package manager. There will be several such programs. The only
user-visible difference (as far as I know) is the way in which they ask
for password and the look and feel.
If you want a graphical window to ask you for password, install
?pinentry-gtk2?, ?pinentry-gnome? or ?pinentry-qt?. If you want to be
asked within the terminal emulator, install ?pinentry-curses? or
I have never used ?GPG Tools? so I can not provide any help in this regard.

@_date: 2017-08-31 08:45:24
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: please help "No pinentry" 
In my previous message I forgot to comment about this: There should be
no need to set ?pinentry-program? if you use your distribution package
manager to install a pinentry. If you install the pinentry program
manually, then possibly you need to specify here the path to the
executable, as installed in your computer (do not simply copy and paste
verbatim to the forum).

@_date: 2017-08-31 10:24:26
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: please help "No pinentry" 
When replying to a message from a mailing list list, please reply to the
mailing list instead of the sender only. Most e-mail clients have a
?Reply to list? button to do this quickly.
A pinentry program may or may not come with GNU PG. It depends on how
you install it. If you compiled from source (you would know if you did
that), then you need to install pinentry separately.
If you used a third-party software bundle that includes GNU PG, then it
depends on the choice of the developers of *that* software bundle.
For examples of pinentry programs, take the ones I mentioned in my
previous message.
The GNU PG project does not distribute any binaries for Mac OS X. As for
the people who ?download gnu pg and start using it?, I assume they
install a software bundle containing GNU PG. However, although such
bundle may include GNU PG, it is a third-party project, not part of GNU
PG itself.
Anyway, I recommend using GNU/Linux because unlike Mac OS X it is free
software.  Installing GNU
PG in any reasonable GNU/Linux distribution is trivial.
If you want to continue using Mac OS X you probably want to use one of
those bundled made by a third party.
*To summarize:* You are probably using an unofficial software bundle for
Mac OS X that includes GNU PG. The GNU PG developers in general are not
responsible for any such bundle. You must consult the documentation of
your bundle.

@_date: 2017-08-31 16:24:05
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: please help "No pinentry" 
Well, if the problem is solved then I am glad for you)))

@_date: 2017-11-14 17:17:26
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: question about determining the key length 
Gnu PG 1.4.5 was released in 2006. You should not use software so old,
especially cryptographic software. In that time, a lot of _known_ bugs
accumulate in nearly all pieces of software, including security
Using ?--list-keys? should display the information you want. It works
that way since as far as I have used it, and definitely including 2.0.
mario at svetlana [0] [/home/mario/hacking/hol]
$ gpg --list-keys 'mario'
pub   rsa3072/0642D919 2017-08-02 [SC] [expires: 2020-08-01]
      E053A25BCC302BBB2DADEC033003BEC50642D919
uid         [ultimate] Mario Castel?n Castro
sub   secp256k1/B92640D9 2017-08-02 [S] [expires: 2020-08-01]
sub   secp256k1/69F40765 2017-08-02 [E] [expires: 2020-08-01]
Here ?rsa3072? and ?secp256k1? are the key types. The RSA main key is
3072 bits long, as the string suggests. Some key types are fixed size
(for example, secp256k1 is always 256 bits long).
If you are still unable to find the key type, paste the output of ?gpg
--list-keys ? (where  is something used to narrow the
results. e.g.: the holder e-mail or part of his name).
Well, then I feel very fortunate to NOT to live in the US. ?

@_date: 2017-10-10 10:46:59
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: FAQ and GNU 
This is a fallacy. Windows *is* Microsoft Windows, the only thing called
?Windows? (as a proper noun) in informatics.
Not so with ?GNU/Linux?. GNU/Linux is not Linux. Linux is a kernel.
GNU/Linux is the combination of this kernel with software from the GNU
The word ?operating system? is too vague to have a reasonable discussion
of exactly what set of programs are part of an operating system. In any
case, it is clear that Linux is a kernel, not an operating system[1].
Also, the argument that GNU PG can be used on Linux without GNU is
invalid, for it can also be used without Linux. Several BSD variants
include GNU PG.
[1] I challenge anybody who replies with ?operating system?=?kernel? to
explain how this viewpoint is compatible with the practice of calling
FreeBSD, Windows, OS X (as a whole) and so on an ?operating system? and
not a ?kernel?.

@_date: 2017-10-10 10:49:44
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: FAQ and GNU 
Your argument is self-defeating. There is no reason to single Linux. It
is just another of thousands of programs without which a computer would
be useless exactly as the others you mentioned.

@_date: 2017-10-10 10:54:36
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: FAQ and GNU 
To me it appears hypocritical that you are speaking of ?respecting
community rights? where the aforesaid communities (more precisely, the
founding developers who are the ones that actually choose the name of
the distribution, not the later community) have stepped over the right
of recognition of the GNU projects.
The most important contribution of the GNU project is not the software
packages, but starting the free software movement. GNU/Linux
distributions are only possible because of free software.

@_date: 2017-10-10 10:55:42
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: FAQ and GNU 
To me it appears hypocritical that you are speaking of ?respecting
community rights? where the aforesaid communities (more precisely, the
founding developers who are the ones that actually choose the name of
the distribution, not the later community) have stepped over the right
of the GNU project to be given proper credit.
Recall that the most important contribution of the GNU project is not
the software packages, but starting the free software movement and
developing the most important licenses. GNU/Linux distributions are only
possible because of free software ideology, even though many such would
hate to acknowledge this.

@_date: 2017-10-10 14:20:53
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: FAQ and GNU 
In the previous message you said ?"Linux" can be the kernel or a
distro.?. But this is outright incorrect (Linux is not a distribution).
Thus I elided this part according to my practice of omitting irrelevant
text in a reply to keep the messages to a readable size.
The name ?Linux? was invented for the kernel for which Linus Torvalds is
known. Later, lazy people incorrecting began using the same word to
refer to basically any software bundle that include this kernel.

@_date: 2017-10-10 14:30:40
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: FAQ and GNU 
Nice straw man fallacy. I have never asked anybody to call ?GNU/*? all
free software projects, or anything similar, so your argument is unsound.
Moreover, there is no analogy between ?FreeBSD? and ?Linux?:
*The name ?FreeBSD? has always referred to a specific distribution. That
is how people use it. There is no problem here.
*The name ?Linux? refers to a specific *kernel* (from ?Linus?, the first
author of this kernel). If you use the name ?Linux? to refer to the
kernel, there is no problem, but using it for anything else is
incorrect, even if it *includes* Linux. Would it be correct to refer to
a car as an ?engine?, because it includes an engine?

@_date: 2017-10-10 14:36:57
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: FAQ and GNU 
Well, then blame this project for being undecided about what its own
name is. They use both ?GNU Privacy Guard? (which I abbreviate as ?GNU
PG?) and ?GnuPG?.

@_date: 2017-10-12 17:29:51
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: OT: FAQ and GNU 
Despite the bulk of your message, the only attempt at an argument is
?English is an evolving language?. The rest is completely irrelevant.
That English is a changing language is not a justification to misuse
words. The word ?Linux? meant a kernel when it was introduced to
informatics and it still does. The observation that one, some, many, or
all people use a linguistic construct in an incorrect way do not change
the fact that it is incorrect. Other examples: ?try and? (when it should
be ?try to?), ?wanna?, ?gotta?, ?electric current flows? (current may
flow; but most of the time this is erroneous and the phrase should be
?charge flows?).
If you reply with another iteration of the same fallacy or irrelevant
comments, I will ignore your message.

@_date: 2017-10-13 08:27:34
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: FAQ and GNU 
But one can not conclude that it is correct just because it is common.

@_date: 2017-10-13 09:05:52
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: OT: FAQ and GNU 
Your argument is unsound, because the inference is unjustified. The
possibilities that a language is regulated by an official body or
defined by majority usage are not exhaustive.
Since you are talking about the definition of the English language, and
noticed that there is no official definition, then I contend that there
is no _definition_ of the English language at all. However, from this
does not follow that one individual or a majority are allowed to
dispense of any rules and do as they please while claiming that they are
speaking English. Instead, one must apply the well-known rules of
English and use common sense in determining which words one will regard
as legitimate. Leaving this judgment to majority amounts to the ad
populum fallacy and to such blatant absurdities as regarding the words
?u?, ?gotta? and ?wanna? as valid synonyms of ?you?, ?got to? and ?want to?.
In the case of the word ?Linux?, my argument is that this word was
introduced (at least in informatics) for a specific use: To refer to a
kernel. For an operating system based on Linux, the phrase ?Linux-based
OS? is already accurate and unambiguous, and for one that includes GNU,
?GNU/Linux? is. Thus it is not necessity, but plain sloppiness what
explains it use as something else. Hence that I hold that any other use
should be rejected as illegitimate, in analogy with the sloppiness
behind the aforementioned aberrations (?u? for ?you?, et cetera).
As a point of contrast: in the case of mathematics, it is necessary to
either coin entirely new words or use a pre-existing words with new
meanings. However, in this case it is justified because coining a new
words for each concept would require possible hundreds of words specific
to mathematics. The consequences are bad on all sides: First this
abundance of words would be hard to remember. Second, mathematicians
would hardly agree on a single new word for each concept leading to
diverging terminology. Third, the abundance of strange words would
contribute to the perception of mathematics by the general public as an
intimidating and incomprehensible subject.
In short: Your argument "_many_ people use ?Linux? to refer to any
Linux-based operating system, therefore it is correct English? is a big

@_date: 2017-10-13 10:02:40
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: OT: FAQ and GNU 
I mentioned another possibility in my previous message: ?one must apply
well-known rules of English and use common sense in determining words
one will regard as legitimate?. The whole of my previous message is an
elaboration of this.
You are referring to an hypothetical individual who develops a language
reform. But that is not the case here. Here (the discussion is or was
around the word ?Linux?) we simply have a misuse of a word which is not
part of a proposal of a language reform and has no rationale. Since
these cases are very different, the reasoning for one case does not
necessarily applies to the other case.
In the case of misuse of the word ?Linux?, I have already given my
arguments. In the very different case of a well-made language reform, I
would immediately regard it a a legitimate variant of English. However,
it would be _inappropriate_ (not _incorrect_) to use it when it would
cause significant confusion or be an obstacle to communication.
?Popular culture? is not a good source of what is correct, precisely
because of aberrations like this. Many things that are socially
acceptable are factually or morally incorrect. These concepts should not
be conflated.

@_date: 2017-08-31 17:06:14
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: please help "No pinentry" 
I have heard about that. The premise is that explaining a problem
sometimes makes how to solve it evident, especially when explaining that
a program does not work. There is even a web page about something like
that: .

@_date: 2017-08-31 19:06:04
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Questions about particular use cases (integrity verification w/o 
You can use the same scheme that I described. The only difference is
that you use a hash (say, SHA-256) of the seed provided by the user as
the seed of the CSPRNG, instead of the hash of a private key (as I
originally described)
The only thing that is still missing is software that implements
deterministic generation of DSA and DH keys over secp256k1 given a seed.
You can either find one already written, write it yourself, or pay
somebody to write it for you (possibly as a modification of GNU PG).
Note that you will need to know the seed *and* the method of generation
so that you can re-generate the key in the future if it becomes
necessary. You can store the program used for the key generation in a
place where it will remain available in the future, for example, in the
same place where you store your backups, or print the source code. The
generation program needs not be kept secret. Only the seed needs to be
kept secret.
I can not comment on this library. I have never used it nor do I plan to
use it.

@_date: 2017-09-02 21:18:27
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: E-mail with deniable authentication 
Diffie-Hellman may be used interactively, but it is not necessary.
See the specification of Diffie-Hellman over an elliptic curve emplyed
for *encryption* in OpenPGP as described in RFC 6637
). There is a summary of
the protocol in page 8. Note how it requires no ?two-way
synchronization?. As described here, the sender generates an ephemeral
key. If the sender uses *his* ECDH key instead of an ephemeral one then
the shared secret can be used to derive the key of a MAC algorithm and
used for deniable authentication.
Obviously there is the requirement that the receiver knows that the key
used by the sender really belongs to the sender and not an impersonator.
This is a general requirement in public key cryptography also applicable
for digital signatures.
I am well aware of that. Although deniable encryption is not a panacea
it is an improvement. It gives less power to the correspondent to blackmail.

@_date: 2017-09-04 17:58:35
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Documentation of trust model 
Are the trust models ?classical? and ?pgp? as implemented in GNU PG
documented anywhere? In the manual I can only find this for ?pgp?: ?This
is the Web of Trust combined with trust signatures as used in PGP 5.x
and later. This is the default trust model when creating a new trust
database.?, which is a very unsatisfactory description. The situation is
the same for ?classical?.

@_date: 2017-09-04 19:35:51
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: Documentation of trust model 
Hello. It appears that you forgot to reply to the mailing list.
I have read this section of RFC 4880 already. It does not answer my
original question.
The trust model takes signatures and user-assigned trust levels and
outputs validity. Where is this documented for the ?pgp? and ?classic?
models of GNU PG? I can not find anything about it in RFC 4880 (note
that the section that you linked does not describe ?pgp?, ?classic? nor
any other any trust model).

@_date: 2017-09-04 19:45:55
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: "Insecure memory" (yes setuid set) and "get_passphrase failed" 
There seems to be 2 different problems here:
* That gpg (or gpg-agent) fail when calling pinentry. (the
?get_passphrase? fail.
* That memory pages can not be locked (?using insecure memory!?).
However, I do not know how to solve either.
My understanding is that ?insecury memory? means simply that gpg can not
lock memory pages so as to reduce the probability that they are written
to swap. This is only a security concern if an attacker can read the raw
disk device.
Are you sure that this is required in Solaris? At least in Debian
GNU/Linux there is no need to setuid the gpg binary to root. Root setuid
programs are a security problem. If an attacker can get control of this
program, he can operate with root privileges.
Look for what the requirement for locking pages are in the Solaris
?pinentry-program? is an option of gpg-agent, not gpg. If you want to
specify this option, you must put it in ?$HOME/.gnupg/gpg-agent.conf?.

@_date: 2017-09-06 08:26:09
@_author: =?UTF-8?Q?Mario_Castel=c3=a1n_Castro?= 
@_subject: How to encrypt using public certificate\key 
You can use the ?gpgsm? to operate over X.509 certificates (this covers
your use case).
