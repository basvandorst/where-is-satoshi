
@_date: 2013-04-17 14:32:16
@_author: Diego Zuccato 
@_subject: Privacy concerns 
Ave all.
IIUC, currently, whoever looks up a key for an identity, automatically
retrieves *all* user's identities!
That could easily be abused (spammers, people writing to personal mailbox
for work-related issues, etc), but even if not abused it's at least
"unpleasant" that all mail addresses gets mixed.
I've been thinking about that for some time, but couldn't yet find a
workaround. Except, maybe, some decoupling between signature key and
identities -- but no idea on how to implement it, keeping the current pros.
W/o having to use multiple different identities (that would mean more
smartcards to manage, for example).
I couldn't find related topics, but I think that's impossible that noone
thought about it before. Am I missing something obvious?
 Diego.

@_date: 2013-04-17 20:45:01
@_author: NdK 
@_subject: Privacy concerns 
Il 17/04/2013 18:22, Doug Barton ha scritto:
At least for now.
But spam is just one of the possible issues...
Anyway I can see that the easiest and more versatile solution is to have
different identities for different communities (one for work, one for
personal use, one for hacking communities, ...). Eventually all
Then, now, what's needed is a new implementation for OpenPGPCard that
supports enough keys :) But that's another topic that I'll open soon.
 Diego.

@_date: 2013-04-17 20:53:36
@_author: NdK 
@_subject: Privacy concerns 
Il 17/04/2013 19:09, Pete Stephenson ha scritto:
Seems the only reasonable thing... for now :)
Usually at office they give you a card with an x509 cert on it... And
you have to use it.
But sometimes they let you optionally use other means to sign your mails.
Ability to bind a specific UID with a subkey (implying having multiple
valid encryption keys) doesn't seem too useful...
 Diego.

@_date: 2013-04-20 14:18:11
@_author: NdK 
@_subject: Privacy concerns 
Il 18/04/2013 05:12, mirimir ha scritto:
That would be useful to improve the WoT, and it wouldn't "link" 'em more
than any other signature: signing a key means you are certifying that
that key belongs to that identity, not that other identity belongs to you :)
 Diego.

@_date: 2013-04-21 10:11:27
@_author: NdK 
@_subject: [OT] Re: Trust 
Il 19/04/2013 00:18, Jay Sulzberger ha scritto:
Just cryptographycally secure: the data you send "cannot" be read by
others except the server. That, obviously, tells you nothing about:
- who runs the server
- if the server has been hacked
- what will the "current owner" of the site do with your card data
When you trust a certificate, you're assuming that the CA that signed it
actually did some checks, but have you actually ever read a CA's policy?
The check could simply be that who is requesting the certificate can
read the mail associated with that domain in the DNS...
For example, you usually want to be able to read your mail "forever"
after you received it, but you aren't interested in "replying" a TLS
session (except for debug purposes in a controlled environment): if you
need to see the movements list on your CC, you just open a new
connection to the bank and get an updated page.
Just for mail "in transit": servers can use TLS to encapsulate mail
protocols instead of http. Mail remains cleartext when saved locally.
Or you can add another layer to achieve end-to-end security, given that
"somehow" you know other party's public key.
That "somehow" might be x509 certs or GPG keys or anything else, and the
level of trust you give it depends on many factors. But to know how much
you can trust it, you have to know roughly how it works -- every system
can be abused, and the friendlier the simpler to abuse.
Remember that even a registered commercial activity (that could pass
Extended Validation) can be a scam (recent first-hand experience...).
 Diego.

@_date: 2013-04-21 10:49:19
@_author: NdK 
@_subject: Developing JavaCard applet 
Hello all.
I'm planninng to start work on a "OpenGPGCard TNG" ( :) ) that allows:
- exportable keys only towards user-certified devices
- support for 2048 bit keys -- more if HW allows it
- storage for "many" (thought at least 18 to allow 1 key per year till
2030) encryption keys (current + expired ones), plus regular signature
and auth keys, plus an extra auth key for RFID auth.
What I'd like to achieve is that the user is in control of what to do
with his keys: choose if they're exportable or not, choose to allow
export only to other cards, choose if exported key can be re-exported,
etc. But that policy have to be chosen before generating/importing the
signature key: once a signature key is in-place, policy cannot be
altered any more.
That would allow the use of a single card/token per identity, with keys
that can be backed up but remain safe (well, technically the user could
choose to export against an insecure SW key container, but it's his
coice: why should I forbid it? And even if I'd forbid it, he would
simply generate the key in the SW key container then import to the card,
and sw RNGs are usually "less secure" than TRNGs in cards, or even alter
the applet to disable the check...).
The applet will (obviously) be open-source.
The target card is any GP 2.1.1 (no need for extended APDUs -- they will
be simulated) -- I'll test on JCOP41 72k and SmartCaf? Expert 144k.
Comments? Suggestions? Other missing features?
 Diego.

@_date: 2013-04-22 11:17:04
@_author: NdK 
@_subject: One Private Key for several users 
Il 22/04/2013 09:28, Lema KB ha scritto:
Crypto doesn't work this way.
The easiest (most versatile, less secure) solution: decrypt the files
and leverage win's ACL system to make 'em readable only by the right group.
The PGP-way of doing things (not easy but secure): treat the files as
mails to multiple recipients. Session key is re-encrypted with the
public key of every recipient. When you want to add a new user that can
read old files, you have to add him as a recipient. If you want to
revoke access, you have to delete the encoding of the session key under
his public key. For every file. And for every added/deleted user.
As you can see, the secure way is mostly "static": doesn't like changes
in who can read files. The other is much less secure but much more
"versatile" (no need to change old files when staff changes).
 Diego.

@_date: 2013-08-02 21:06:40
@_author: NdK 
@_subject: best practice for handing over the private key 
Il 02/08/2013 14:25, Martin T ha scritto:
Maybe (I don't know how RIPE database is handled) another, cleaner,
solution is possible.
Initially you "do your work" using your key (or a newly generated key).
When you're done, you replace your public key in RIPE db w/ client's one.
No secret keys need to travel and it's always clear who-did-what.
 Diego.

@_date: 2013-12-02 15:24:04
@_author: NdK 
@_subject: Any future for the Crypto Stick? 
Il 01/12/2013 20:09, Tristan Santore ha scritto:
Yubikeys would be interesting, if only it would be possible to develop
personal applets to load on 'em. Too bad some needed libraries (like the
one to access the button for OOB consent) are only available under NDA
from NXP (quite uncollaborative with hobbyists).
Moreover, their applet doesn't allow key import, only on-card generation!
Quite useless to review something you won't be able to compile and load
yourself, don't you think?
Another alternative is getting a SIM-cut Java card and a reader for it,
then load one of the OpenPGP Java applets you can find around.
You'll then be able to load code you compiled (and audited) yourself and
can import your 'old' keys if you like.
Who can you really trust? If you don't trust NXP, then you can't use any
of their JCOP chips... What would stop 'em from adding an undocumented
command to the card manager that dumps the whole memory?
PS: too bad all the Java cards I could get are limited to 2048 bit
keys... Only BasicCard supports longer keys, but I'm not using Basic
since Commodore-64 era :)
 Diego.

@_date: 2013-12-03 17:59:53
@_author: NdK 
@_subject: Any future for the Crypto Stick? 
Il 03/12/2013 15:30, Mark H. Wood ha scritto:
Unless the exploit could be categorised as "bug". Like the power glitch
that allows clearing fuses in some PICs (advertised as secure chips, at
the time... now they're saying it's secure unless operated outside
nominal values) w/o wiping the rest of the memory.
This way you'd have to use a non-standard reader to introduce a specific
error. Or, maybe, a protection layer that fails if frozen before
exposing it to oxygen, allowing the attacker to succesfully decap the
chip before it self-erases.
There are simply too many attack vectors to say the evaluation considers
'em all. It needs to stop somewhere saying "this chip is secure against
these attacks" since it can't say "it's secure against any attack you
could think of". And/or it places a budget limit on the attack: if it
costs more than that, the attack is worthless.
I've seen this tradeoff while studying openalarm, a (wannabe, still in
its early stages) burglar alarm system scalable from garage to bank: as
long as you can trust a producer and an installer, it's quite easy and
anything will do (if you need to protect your personal mail from your
nosy boss, FST-01 is more than enough). If you can't, you need
exponentially more resources to be able to pinpoint the black hat, be it
the producer of a node, of one of the management systems or the
installer trying to slip a backdoor in.
If you don't/can't trust a single smartcard manufacturer, you'd need to
use at least four (if you need to be able to say who is the misbehaving
one -- byzantine generals problem in case of 3 with one misbehaving agent).
So, for the vast majority of uses, the solution might be non-technical:
use a certified Common Criteria card and make sure to have evidence that
if the key is leaked then that certification is bogus. Quite unlikely
the NSA will reveal having a backdoor just to arrest *you* :)
 Diego.

@_date: 2013-12-08 19:13:52
@_author: NdK 
@_subject: Is there a chance smartcards have a backdoor? (was Re: Any future 
Il 08/12/2013 14:15, Mark Schneider ha scritto:
Why is everyone thinking 'BIOS' as backdoorable piece of sw? Why not the
hard disk?
Just another piece to think of when building a secure system...
 Diego.

@_date: 2013-12-13 13:47:16
@_author: NdK 
@_subject: Android and E2E security 
Hi all.
Seems someone is actively working on securing phones in an
user-effortless way...
I've only had a quick look at it and something yet doesn't "sound
right", but might be just an impression...
 Diego.

@_date: 2013-12-14 10:24:02
@_author: NdK 
@_subject: Revocation certificate for sub key? 
Il 13/12/2013 23:56, adrelanos ha scritto:
I can't see how it can be useful...
Since you still have your secure offline main key, you can revoke
subkeys yourself... Or am I missing something?
 Diego.

@_date: 2013-12-22 22:44:40
@_author: NdK 
@_subject: Possible to combine smartcard PIN with key password? 
Il 22/12/2013 04:13, adrelanos ha scritto:
That would be really useless: smartcardneeds the key to *do* crypto ops!
It's not a limited USB stick!
Since the smartcard is a really controlled execution environment, "we"
can say it's a "trusted environment".
Luckily. Smartcards are used to avoid exposing key material to an
untrusted environment, like a PC.
You have to trust the supplier. If you ordered 'em in significant
quantities, you could ask to have 'em with special keys so that every
step can be checked.
Or. more easily, you can buy blank java cards from diffetent
manufacturers, then compile an upload your carefully checked applet.
You can do many checks yourself: there are various OpenPGP Java
implementations around.
And how do you think the card could perform crypto ops on encrypted
keys? If you lose your card, it could be way easier to revoke the keys
on card. And that's why many people keep their master key offline, using
cards/tokens just to safely transport their keys.
No. It's simply impossible to do what you're asking. Unless you replace
the secret key with a *masked* version, leaving the unmasking key on the
PC, encrypted by PGP. But that would prevent checking on-card various
possible attacks, actually weakening the whole system.
 Diego.

@_date: 2013-12-23 22:08:15
@_author: NdK 
@_subject: Possible to combine smartcard PIN with key password? 
Il 23/12/2013 19:29, adrelanos ha scritto:
I'd like it was possible, but for other reasons: that would mean you
could instantiate an object in card's RAM, havina actually a
limitless-memory card: you'd simply have to send the encrypted key blob,
the password and the PIN. Too bad in all cards I know key objects can
only be stored in EEPROM/Flash, that have a quite limited number of
writes :(
But, as Peter pointed, that wouldn't bring you more security.
Try reading code of an applet. You can learn the basis of SC devel in an
afternoon, and that would be enough to understand how a well-written app
works. Then throw away what you learnt and ask if some expert already
looked at that code :)
If you want to be paranoid enough, you need to. That, or pay a lot of
money -- and who guarantees you that the staff is not paid by a TLA
agency? ]:)
Sure. Look at works by Ross Anderson, just for naming one expert in that
field. Maybe you want to hire him.
How much do you want to pay for that level of security?
Maybe, you should start reading the applicable certification procedures
(what does CC-EAL5 mean exactly?), to see what's already considered and
which level of examination each card mask have undergone. Then, if
that's not enough, you should contact a manufacturer and take steps to
have a custom-made mask examined by your enginering staff, then buy
enough cards. Or, simpler, ask the supplier to sign a contract where the
considered attacks are detailed.
Naive and error-prone.
Then you should use the (really heavy) shared RSA signature: to have a
valid signature, all N chunks from N parties are needed. Key generation
is a collaborative effort, too, so no single party can know the whole
secret key. That could be a good idea for a Ph. D thesis (probably a
hard one). I fear that current crypto support in JavaCards wouldn't be
entirely useable :(
 Diego.

@_date: 2013-12-24 06:55:22
@_author: NdK 
@_subject: Possible to combine smartcard PIN with key password? 
Il 24/12/2013 02:41, adrelanos ha scritto:
You're saying that he can lockpick your security door but can't break
the glass of the window nearby...
Just IMVHO...
 Diego.

@_date: 2013-12-24 10:43:48
@_author: NdK 
@_subject: Printing PGP Businesscard 
Il 24/12/2013 10:18, Ralph J.Mayer ha scritto:
Maybe using QR code? At least for the fingerprint, or a reference URL.
 Diego.

@_date: 2013-12-27 08:59:07
@_author: NdK 
@_subject: Possible to combine smartcard PIN with key password? 
Il 27/12/2013 01:42, adrelanos ha scritto:
You're assuming that breaking into a smartcard is something easy, while
it's the most expensive of the cited actions (except breaking encrypted
keys on file). It requires great skills and devices that aren't exactly
cheap (see Anderson's page at  and read
some of his papers about reliability of security systems). Hire someone
that plants a keylogger in your PC is probably cheaper than 2K$ (maybe
it's even free, if he can rob something while at it). You could even
find someone who does rubberhose "analysis" for fun... How much effort
is it, compared to breaking into a smartcard, that requires a
specialized lab?
 Diego.

@_date: 2013-12-31 15:07:45
@_author: NdK 
@_subject: deleting secret key not implemented 
Il 31/12/2013 14:49, Kristian Fiskerstrand ha scritto:
Maybe I'm missing something... What happens if keys are kept on smartcard?
 Diego.

@_date: 2013-12-31 18:44:43
@_author: NdK 
@_subject: ePGP extension for mobile 
Il 31/12/2013 17:11, vedaal at nym.hush.com ha scritto:
Since many phones already have NFC, why not use an RFID-capable Javacard
w/ openpgp applet? No extra reader to carry: just keep the card near the
rear of the phone while doing crypto ops.
 Diego.

@_date: 2013-06-11 21:54:35
@_author: NdK 
@_subject: Why OpenPGP is not wanted - stupid is in vogue right now 
Il 11/06/2013 16:10, vedaal at nym.hush.com ha scritto:
As long as decryption is done client-side (I've used JS libraries that
could do RSA2048 in a reasonable time) and "some" users check the JS
sources "often enough", then it should be quite doable.
Too bad interfacing to a smartcard from JS requires too much setup...
 Diego.

@_date: 2013-06-17 23:31:52
@_author: NdK 
@_subject: How do I make the private key on a OpenPGP smartcard non 
Il 17/06/2013 20:22, T L ha scritto:
The smartcard protocol of a standard OpenPGP card doesn't allow it.
MyPGPid card will allow a controlled export.
Roughly speaking, yes.
If the key is generated on-card, you have no way to backup it. No need
for "unexportable" flag: simply there's no command to export it.
The whole point of using a smartcard? :)
Since the key is never available to the host, there's no way a malicious
software can copy it.
 Diego.

@_date: 2013-06-22 15:03:21
@_author: NdK 
@_subject: How do I make the private key on a OpenPGP smartcard non 
Il 22/06/2013 09:35, Heinz Diehl ha scritto:
I quite disagree, here.
A smartcard could be useful anyway, at least as a "portable keyring" (if
it didn't need initialization on every machine...).
And key export could be controlled (like in MyPGPid card): private keys
can only leave the card encrypted under "certified" keys.
BTW, for the really "paranoid", readers with an integrated pinpad are
available: the PC never sees the PIN, so no installed sw can spoof it.
(even if what I'd prefer is a card w/ both a pinpad and a display...).
 Diego.

@_date: 2013-06-24 14:54:38
@_author: NdK 
@_subject: How do I make the private key on a OpenPGP smartcard non 
Il 24/06/2013 10:15, Werner Koch ha scritto:
Not really secure...
I don't want to migrate (move) it. I want to replicate (copy) it, to
have one or more controlled backups.
I leave sw patents to others... And the system I'm going to use should
have enough "prior art" to render a patent useless.
The card hosts public key of a "export-authorizing" CA (well, it's not a
real CA, since it doesn't do certificates at all... but call it that way
for clarity).
When I send to the card an export command w/ a public key signed
encrypted by the CA's private key, the card answers with the private key
encrypted under the signed public key (thinking about requiring a
signature w/ private key of the requesting card).
Plain old RSA, layered.
Well, a "paranoid" isn't paranoid enough unless he checks the pinpad
cannot be easily read from the PC. :)
I'm waiting for cards w/ integrated pinpad :)
 Diego.

@_date: 2013-06-25 06:24:39
@_author: NdK 
@_subject: How do I make the private key on a OpenPGP smartcard non 
Il 24/06/2013 16:01, Josef Schneider ha scritto:
Nope. Throwaway CA!
There's no need to be able to export CA key. Actually the recommended
way of using it (to limit key export) is:
- generate CA key on card
- "sign" all the needed keys
- destroy it
The CA key shouldn't last for long. It's not an X.509 CA.
Not needed at all. Neither SupeerSecureCA nor a key export control for
its non-existant key :)
First: I trust more the RNG on a card than a SW one
Second: maintaining an offline machine is not cheap (at least here in
Italy, you can't legally use a computer where there haven't been applied
security patches for more than 6 months)
Third: you have a potentially accessible copy of your key -- nothing
prevents your backup from being photocopied... Sure, it's encrypted but
bruteforcing it is possible, at least in theory, while the original is
apparently untouched. A smartcard would require physical possession of
the original for quite some time (IF you decide to keep the CA key).
What I suggest is something that "replaces" (being "a bit" more
versatile) an offline machine where you generate a key and store it to N
cards, then zap it.
 Diego.

@_date: 2013-06-25 12:32:36
@_author: NdK 
@_subject: How do I make the private key on a OpenPGP smartcard non 
Il 25/06/2013 09:55, Werner Koch ha scritto:
I'm referring to cards compatible with GlobalPlatform 2.1.1 (minimum),
that is the baseline for MyPGPid applet. That should be "recent enough"
to have a real RNG (if RandomData.ALG_SECURE_RANDOM is implemented).
Shouldn't RNG be subject to the various certifications the card have to
pass for CC and EAL ?
Dedicated applet that only returns random data?
Might be, but it's prone to a lot of possible attacks, too :)
 Diego.

@_date: 2013-05-03 10:18:12
@_author: NdK 
@_subject: Developing JavaCard applet 
Il 03/05/2013 09:53, Branko Majic ha scritto:
Hope so :)
I didn't yet start massive pgp use just 'cause those limitations.
How much memory do they have? I think that less than 64K won't be
enough... But you could start experimenting with "old plain" JCOpenPGP
(currently on Sourceforge) that we'll be using as a basis.
It's already documented (by Petr Svenda) and there's even a VM: see
 Diego.

@_date: 2013-05-03 14:51:39
@_author: NdK 
@_subject: Suggest please 
Il 03/05/2013 14:29, Lema KB ha scritto:
Then probably you don't need encryption at all. Or you only need
symmetric encryption (same key used both for enc and dec).
Possible, but stupid (IMVHO). If you think VM access control is enough,
then just use it and don't encrypt the file.
Submission can be handled with a correct ACL (in *nix it could be
rwxrwx-wx on a folder: only members of the group will be able to read
the files in it, but every user can put his file there -- we used this
method for lab projects).
Another way can be a web form that stores an uploaded file in a private
PGP is not a "magic bullet": he does what it's designed to do (and I
think it does it quite well), but won't prevent you from using it in
really insecure ways. *SECRET* keys are called that way for a reason.
 Diego.

@_date: 2013-05-03 15:09:24
@_author: NdK 
@_subject: Suggest please 
Il 03/05/2013 14:58, Lema KB ha scritto:
Then you could setup a (different!) machine with a mail robot that
receives those mails, decrypts 'em (with its own private key, *much*
better if stored on a token/smartcard) and then stores the plaintext
files in the drop-box folder where users can access 'em.
No user is involved with crypto, and what's sent to the mailbox
"magically" appears in the shared folder (they don't even need to know
that the decoding machine exists! It probably could be a Raspberry Pi
hidden in your server room :) ).
 Diego.

@_date: 2013-05-03 17:13:07
@_author: NdK 
@_subject: Suggest please 
Il 03/05/2013 15:44, Lema KB ha scritto:
Then just create "his" keypair and run it with a scheduler (like "once a
minute"). But how to do this, is really OT here.
 Diego.

@_date: 2013-05-03 18:14:51
@_author: NdK 
@_subject: Suggest please 
Il 03/05/2013 14:51, NdK ha scritto:
Just to be more precise, the setting as described have a behaviour that
could not be what one expects:
1) knowing the file name everyone can read it
2) knowing the file name, everyone can delete it
You can fix 1 by setting umask (on the filesystem, if dropbox is in its
own partition) so that actual file permissions are 0640 or 0660.
To fix 2 you should set the sticky bit on the folder. See
Tks to DKG for pointing this out. I'll try to be more precise next time.
 Diego.

@_date: 2013-05-05 08:43:43
@_author: NdK 
@_subject: Web of Trust in Practical Usage 
Il 05/05/2013 06:10, Daniel Kahn Gillmor ha scritto:
Even if you do: just add a NEUG token (or something similar) to the
system and you have pretty high quality entropy at a good rate.
But since the slow part of key generation is the primes selection, you
could speed it up just recycling primes from different keys.
N primes usually let you create N/2 keys, but you can generate N(N-1)/2
different keys.
 Diego

@_date: 2013-05-22 22:08:27
@_author: NdK 
@_subject: Rewinding signature counter 
If, recovering from a backup, I "rewind" the signature counter on my
master key, what happens?
In other words: is it just "decorative" (like knowing 'more or less' how
many signatures I did) or it serves some purpose I (yet) don't understand?
That would impact heavily the backup policy...
 Diego.

@_date: 2013-05-23 17:59:47
@_author: NdK 
@_subject: Keyring on external encrypted drive 
Il 23/05/2013 17:37, Zece Anonimescu ha scritto:
Nope. I heard of keyloggers that take a snapshot of the screen at click
time. If you are so concerned about security, use a smartcard inserted
in a reader w/ pinpad -- but I don't know if such a reader will work
with OpenPgpCard.
And even then, you'd need a patched card that accepts a single PSO for
every PIN entry...
 Diego.

@_date: 2013-05-23 20:25:24
@_author: NdK 
@_subject: Keyring on external encrypted drive 
Il 23/05/2013 18:22, Pete Stephenson ha scritto:
...as long your passphrase is numeric-only.
[OT] *great* support page: the links to the manufacturer expose the PHP
code! :)
Really useful, IMVHO. Unless you have to sign *a lot* of things...
That would probably be way less useful: once authenticated you want to
be able to read all your mails, or to stay authenticated while you
change the page you're browsing.
 Diego.

@_date: 2013-05-23 21:18:40
@_author: NdK 
@_subject: Keyring on external encrypted drive 
Il 23/05/2013 20:43, Peter Lebbing ha scritto:
Similar threads appeared on OpenSC ML too.
That's why I was investigating a "port" of OpenPGPCarf to Yubico token
(that offers a button that can be read by the Java code -- too bad it
requires a library available from NXP only under strict NDA :(
A less robust (against invasive attacks) option could be the GNUK token.
The host may cache it only if it ever sees it :)
There exists cards with button and display: having an OOB bidirectional
channel can give much more security...
Another option could be a HOTP code instead of a static PIN (maybe I'll
include this in MyPGPid :) ).
 Diego.

@_date: 2013-05-25 10:54:34
@_author: NdK 
@_subject: [OT] Why are you using the GPG / PGP keys? 
Il 25/05/2013 03:36, Henry Hertz Hobbit ha scritto:
Actually it seems the ideal use for OpenPGPCard: once you change DEC
key, you can as well delete all your old (encrypted) mails.
Using a card only to store a key generated on a PC is, IMVHO, plain
nonsense -- and that's why I'm working on MyPGPid: I want to generate my
keys on-card, backup 'em ONLY to other cards, and use a single card (per
identity) while being able to read all my old messages, even if I change
my DEC key once a year (in a test scenario I could store 40 keys on a
72k card, still have to test how many on a 144k one).
PS: for the really paranoid, it's not hard to have a dead-man-switch
against coercition: if you don't connect to some service for enough
time, it uploads a revocation of all your keys to the keyservers so
everyone is alerted that something happened to you.
 Diego.

@_date: 2013-05-30 17:06:52
@_author: NdK 
@_subject: [OT] Why are you using the GPG / PGP keys? 
Il 30/05/2013 13:17, Zece Anonimescu ha scritto:
That's why I don't like protocols requiring 'random' numbers: everything
'random' could actually be encrypted data to be used for a
steganographic side channel...
 Diego.

@_date: 2013-11-14 20:24:31
@_author: NdK 
@_subject: Does anyone use an NXP JCOP J3A smart card? 
Il 14/11/2013 17:42, Ruslan Sagitov ha scritto:
You have to load an OpenPGP-compatible applet to the card.
It's not too hard, since that card supports JC222 and GP211.
One such app is MyPGPID (available on GitHub) that (till I find some
time to develop it further) is mostly a basic OpenPGPCard applet.
Make sure the seller gives you the keys needed for loading the applet!
 Diego.

@_date: 2013-11-27 21:15:11
@_author: NdK 
@_subject: Smart card reader security 
Il 27/11/2013 08:36, Werner Koch ha scritto:
 Diego.

@_date: 2013-10-14 06:41:25
@_author: NdK 
@_subject: standardized security levels 
Il 11/10/2013 07:24, Hauke Laging ha scritto:
What I still couldn't understand is how I can sign a key saying "I'm
really sure of the owner's identity, but I don't really trust him
properly handling other signatures" (the typical example is "parents" :)
, but the same applies to a signing party... ).
IIUC your proposal doesn't address that aspect.
 Diego.

@_date: 2013-10-15 14:29:17
@_author: NdK 
@_subject: New GPLv3 OpenPGP card implementation (on a java card). 
Il 15/10/2013 11:41, Pete Stephenson ha scritto:
I'm 'more or less' (no time ATM :( ) working on extending standard GPG
card protocol to support user-controlled export of keys and ability to
keep 'n' old enc keys on the same card.
Try to find a Java card that supports longer keys...
I've only seen RSA (up to 2048bit) and ECC (some "small" fields only)
support in Java cards. Some BasicCards should support up to 4096bit (and
they're the ones used by offical GPG card, IIUC).
 Diego.

@_date: 2013-09-10 09:50:04
@_author: NdK 
@_subject: Why trust gpg4win? 
Il 10/09/2013 00:29, Pete Stephenson ha scritto:
I strongly disagree here.
First error: USB is *not* a peer protocol. It's master-slave. FireWire
is a peer protocol.
Possible yes. Useful no.
You'd be exposed nearly to the same attack vectors. Plus some more (the
ones that handle the extra layer), so you'd have to check more code.
 Diego.

@_date: 2013-09-10 15:18:51
@_author: NdK 
@_subject: Why trust gpg4win? 
Il 10/09/2013 14:19, Werner Koch ha scritto:
Uh? "Whithout you noticing"? For sure you know more than me, but to my
knowledge an USB keyboard only sends key scan-codes (not ANSI sequences,
that's why you need to set the keyboard language). And if you have an
open app chances are that you will see keystrokes there.
Sure, it could send a 'win' keypress+release event, but that wouldn't
work (or at least it wouldn't be "unnoticed") in every other SO.
Probably it's "easier" (or at least more effective and less
user-noticeable) to target the USB stack using non-conformant packets
(where buffer overflows might eist). That would give much more time to
try different vulnerabilities before getting caught.
PS: one of the ideas that could "easily" be implemented on FST-01 is a
TOTP password generator that auto-types the code when you press its button.
Sorry, I don't follow your reasoning here.
Pete proposed to use an USB-to-Serial interface to avoid attacks against
the USB stack on the PC. Why should an AVR be used to implement a flash
 Diego.

@_date: 2013-09-12 08:43:44
@_author: NdK 
@_subject: Why trust gpg4win? 
Il 11/09/2013 11:48, Pete Stephenson ha scritto:
Actually such a module exists, and is used to add flash disk access to
small microcontrollers: it's VDrive2 (VNC1L module) by Vinculum
I don't think it adds anything to security, but at least it's doable :)
If you are *so* concerned about key security, it's better to use an HSM.
 Diego.

@_date: 2013-09-12 22:03:27
@_author: NdK 
@_subject: Attacking an offline system 
Il 12/09/2013 19:07, Peter Lebbing ha scritto:
Nope. W/ Vinculum module you send it commands like "open mickey.txt" and
then "read 1024". The filesystem driver is in the module and your
interface only receives expected data.
You really should define your "security perimeter". Start by asking
yourself how much an attacker is willing to spend to access the data
you're handling. Once you have an answer to this question you can choose
how much you are willing to spend to defend your data.
Plain old password protecting a file is usually enough.
FST-01 token could be useful to have your key easily portable and (w/ a
little work) even add a button to confirm signing.
Smartcards are another good alternative if you need some "certification".
An HSM is much less portable but needed if you need both certification
and speed.
And this just to keep your keys safe. Keeping the whole system safe is a
careful compromise between functionality and security. But all depends
on the answer to the first question.
But rubberhose cryptoanalysis is usually *way* more effective :)
 Diego.

@_date: 2013-09-13 09:19:10
@_author: NdK 
@_subject: Why trust gpg4win? 
Il 12/09/2013 23:10, Marko Randjelovic ha scritto:
It's just a matter of trust (and speed). After all, you need to take the
system image from "somewhere". That's probably the weakest link. Or, at
least, it's the easiest to compromise.
PS: I'll tell you a secret: there are USB keys with a "write protect"
switch :)
And maybe there's a buffer overflow in the ISO9660 driver that can be
exploited . Hey, we're talking of the most tested codepaths (unless
you use some exotic filesystem)!
Maybe technical solutions for a social problem aren't always the right
You can *never* be 100% sure. No way. You can be "reasonably sure". You
can be "certifiably sure" (given that you define which kind of attacks
you think you'll be exposed to and find a standard to certify against).
I can be "reasonably sure" nobody will hack my machine just to read my
mail. Obama can be "reasonably sure" that *many* attackers will try. So
my scenario and Obama's one are "a bit" different, and require *greatly*
different solutions. I can't afford the costs and inconveniences of a
solution based on Obama's needs (and I'd be indeed quite stupid to try
to adopt it), and he can't afford the risk of a solution tailored on mine.
PPS: at least here in Italy a *completely offline machine* becomes
illegal after 6 months. Law dictates that every computer where personal
data is handled (and even a name and surname *is* "personal data")
*must* be updated *at least* every 6 months. And attacking your update
medium is probably easier than attacking the USB key.
 Diego.

@_date: 2013-09-13 14:05:03
@_author: NdK 
@_subject: Why trust gpg4win? 
Il 13/09/2013 11:33, Jan ha scritto:
Then you can't defend it. :) You can't even completely audit it, since
it involves a lot of "things" that aren't under your control.
What happens if one of your correspondents is willing to undergo the
whole procedure and he's an FBI agent? :)
You can be paranoid as much as you want, but you will never be paranoid
enough. If FBI (or, more realistically, your wife) wants access to your
data, there's nearly nothing you can do to avoid it...
You could use a Chinese smart card: quite sure it's not been tampered by
FBI :)
Well, that's one reason I don't like "random blobs" in crypto (like OAEP
requires): it could be quite easy yo use such a blob as steganographic
covert channel.
But for OpenBSD I'd be more incline to thinking that FBI stopped funding
since they couldn't have their backdoors installed.
Never heard of TEMPEST?
You boot from an accurately audited CD, decrypt your top-secret email
and as soon as you display it on the monitor it gets aired to that van
in front of your house :)
No. Side-channels are everywhere. You can't ignore 'em. If you want to
certify that your security perimeter is secure, you first have to
accurately define where it is and the threat model. And even then you
can only certify it's secure against the attacks you could think of.
Take OAEP signature as an example. *IF* the random bytes are really
random the signature is secure. But since they should be  random, you
can't say if they are truly random or just the output of a cypher that,
given the right password, is transferring your secret key
chunk-by-chunk. And against that, even manually encoding is useless: the
RSA encryption is done correctly, the key is the right one, the protocol
is followed, but soon someone else will have your key and will be able
to decrypt all your messages.
IVs are another potential channel, but they're needed to make many
encryption schemes secure.
No. You can only check if the protocol is followed accurately.
How can you check there isn't a weakness in RNG, for example? In other
terms, how can you tell apart a TRNG from a good cypher?
 Diego.

@_date: 2013-09-13 22:13:40
@_author: NdK 
@_subject: Why trust gpg4win? 
Il 13/09/2013 21:12, Jan ha scritto:
A good encryption algorithm should generate an output that you can't
tell is not purely random. That's why you have to compress the data
BEFORE encrypting it.
Then the output is usually "decorated" with data structures to make it
recognizeable and not attempt decrypting it the wrong way.
 Diego.

@_date: 2013-09-18 22:00:35
@_author: NdK 
@_subject: How to find and verify a trust path? 
Il 17/09/2013 22:01, Philip J?genstedt ha scritto:
I think "stability" is what most newbies (and probably experienced users
too) use.
If the same "identity" keeps using the same key while relating with
different users, it's "trustworthy". So if I have CDs from some years
ago and OpenPGP is signed with the same key used today, I can be "sure
enough" it's not been tampered with and the new file is trustworthy.
And often it's more important stability over "impossible" verifications
of "real life identity".
 Diego.

@_date: 2013-09-22 10:37:17
@_author: NdK 
@_subject: Question about a perfect private Key store for today's environment 
Il 21/09/2013 23:06, Aleksandar Lazic ha scritto:
Firefox+GreaseMonkey+script to interface to card?
 Diego

@_date: 2013-09-22 22:16:59
@_author: NdK 
@_subject: Question about a perfect private Key store for today's environment 
Il 22/09/2013 20:43, Aleksandar Lazic ha scritto:
Sure. Unless you want to trust someone else to handle your keys. But
then don't be surprised if who have something sensitive to tell, *not*
to tell it to you...
Then that user won't be able to use encryption. At least not on that device.
"I want to surf the web but I can't install a browser. How can I do it?"
 Diego.

@_date: 2014-08-15 09:57:54
@_author: NdK 
@_subject: OpenPGP card feature request: as many encryption-capable keys 
Il 15/08/2014 02:18, Peter Lebbing ha scritto:
That's exactly why I started MyPGPid project. Too bad I've had no time
to develop it further :(
Hope I'll be able to return on it soon... Unless another (paid) project
steps in...
Currently you have to generate your encryption key on the PC and copy it
to the card. So you have a copy to reuse.
Or just use multiple cards On a 144K javacard, IIRC, I've been able to store 13 RSA-2048 encryption
keys. Plus master, signature and two auth keys (one reserved for
contactless auth).
 Diego

@_date: 2014-08-15 19:25:18
@_author: NdK 
@_subject: OpenPGP card feature request: as many encryption-capable keys 
Il 15/08/2014 12:31, Peter Lebbing ha scritto:
That's what I was doing with MyPGPid: a 144k Javacard can host the
applet and many keys.
The "trick" is that it accepts the standard OpenPGPCard commands, plus
some extended commands to handle extra keys (like selecting current
enc/dec key, or safely export keys only towards user-certified devices).
This way you only need the standard GnuPG plus an helper program (can be
a simple script using opensc) if/when you need the extra functions.
 Diego.

@_date: 2014-02-13 21:36:24
@_author: NdK 
@_subject: Subject: openpgp card and basiccard RNG 
Il 13/02/2014 21:29, Peter Lebbing ha scritto:
I've been able to work on JavaCards w/o having to sign anything (except
the transactions to various online stores :) ).
I'd have been interested in developing for Yubikey, too, but that
required an NDA with NXP for their SDK, or I couldn't access the button
(and access to the button was the only reason I was interested in
Yubikey in the first place!).
 Diego.

@_date: 2014-02-14 06:42:03
@_author: NdK 
@_subject: Subject: openpgp card and basiccard RNG 
Il 13/02/2014 23:20, Werner Koch ha scritto:
Then where would you stop analyzing?
If you look at the OS code, there could be a backdoor in the CPU
microcode. Or in the chip firmware uploader (is there an HV programming
mode available? was it disabled or physically removed from the die?).
And these are just the most obvious. The best we can do is trust the
manufacturer and read the fine print on the datasheets. It will be more
secure than a sw only implementation that runs on a connected PC.
 Diego

@_date: 2014-01-03 19:02:10
@_author: NdK 
@_subject: sign encrypted emails 
Il 03/01/2014 11:28, Hauke Laging ha scritto:
I can't come up with a situation where sign, encrypt, sign again w/
*same* key used in the first signature gives more security than first
encrypt then sign. So two layers are enough.
I (partially) get your point: receiving an encrypted message could
mislead an uneducated user... But I doubt someone w/ access to top
secret material falls in that category :)
 Diego.

@_date: 2014-01-06 13:16:09
@_author: NdK 
@_subject: USB key form-factor smart-card readers with pinpads? 
Il 06/01/2014 10:34, Werner Koch ha scritto:
Is it just convenience or enforcing it (e.g. adding a "forcedecauth"
flag) would lead to usability issues (maybe because sometimes decryption
is called many times in sequence)? That would be the case for auth key,
I think: using it to auth against a web page would ask auth for every
sub-request of objects on the page.
 Diego.

@_date: 2014-01-07 12:02:02
@_author: NdK 
@_subject: using an OpenPGP card with Java (keytool and jarsigner) 
Il 07/01/2014 04:01, Hans-Christoph Steiner ha scritto:
IIRC there is an OpenSC "driver" for OpenPGP cards, that makes 'em
accessible throught PKCS
 at lists.opensc-project.org/msg06206.html
Seems it's quite old... Maybe if you want to take over developement...
 Diego.

@_date: 2014-01-30 07:59:49
@_author: NdK 
@_subject: Setting up shared access to gpg on a UNIX server 
Il 30/01/2014 02:14, DUELL, BOB ha scritto:
Every user in the group could "leak" the secret key. At least put it
into a smartcard/token connected to the server: they'll just be able to
*use* it.
 Diego.

@_date: 2014-01-31 14:35:11
@_author: NdK 
@_subject: Setting up shared access to gpg on a UNIX server 
Il 31/01/2014 01:29, DUELL, BOB ha scritto:
A token is a bundle of a smartcard and a reader, and usually looks like
an USB stick.
If you have a dedicated (non virtual) server, usually you can ask to
have a token plugged in. If you're using a virtual server, then it's
harder and there are other possible attacks against your key material,
as previously discussed on-list.
I don't know if such an agent exists.
 Diego.

@_date: 2014-01-31 15:02:14
@_author: NdK 
@_subject: MUA "automatically signs keys"? 
Il 31/01/2014 10:24, Steve Jones ha scritto:
I tried looking around for some tutorials about notations, but could
only find minimal information ("it's a string in 'tag at domain=value'
IIUC in *my* policy I could specify that when signing a key I use
"ndk at mydomain=X" notation and that X=0 means "just checked the person
can access the given mailbox", X=1 means "at least 2 other persons have
confirmed that the same user used that email address for the last year"
and so on.
Is my understanding right? When I sign a key and use a notation, am I
actually signing *all* the identities associated with that key? Or just one?
 Diego.

@_date: 2014-07-06 19:35:58
@_author: NdK 
@_subject: Key distribution via NFC 
Il 04/07/2014 05:54, Robert J. Hansen ha scritto:
Just place in the tag the URL where to retrieve your key.
Or, as suggested, use the whole phone as a smart tag, placing it in
"device mode" with a suitable applet that sends your whole key w/o the
limit of 400 bytes.
Too bad it's quite easy to reprogram the tags, IIUC, so the applet
method should be preferred. IMOP, such an applet should be able to use
bluetooth, too, to allow sending the key to non-nfc enabled phones (but
maybe a simple file manager could be enough for this? Maybe some file
managers already allow to send via NFC too)...
 Diego.

@_date: 2014-07-11 11:41:56
@_author: NdK 
@_subject: using different encryption key in evolution 
Il 10/07/2014 21:44, Richard Ulrich ha scritto:
Try putting the individual addresses in cc. While there's no key for the
main address, it should find others' keys and use 'em so that they all
can read it.
Just guessing, since I don't use evolution.
 Diego.

@_date: 2014-06-01 20:05:12
@_author: NdK 
@_subject: Why create offline main key without encryption capabilities 
Il 01/06/2014 16:17, Hauke Laging ha scritto:
Then you're using RSA the wrong way.
You should *never* apply RSA directly. Padding is important and *must*
be checked during process. Decryption and signature are the same RSA op,
but use a different padding so you can tell which op got applied.
And that poses a big problem for everyone that would like to use a
smartcard for decryption...
 Diego.

@_date: 2014-05-02 17:21:32
@_author: NdK 
@_subject: Signature without policy meaningless? (was Re: UI terminology 
Il 02/05/2014 17:12, Peter Lebbing ha scritto:
Too bad (IIUC) you can't say "I certify that this person is *really* the
one given in this UID, but I absolutely don't trust his identity
 Diego.

@_date: 2014-05-03 09:54:48
@_author: NdK 
@_subject: Signature without policy meaningless? (was Re: UI terminology 
Il 03/05/2014 01:10, Daniel Kahn Gillmor ha scritto:
Making WoT calculator avoid looking for keys signed by that user if
reached throught my certification.
They work: I'm *really* confused. :)
Well, if ownertrust answers that, it's what I need: a way to say "I am
sure this key belongs to X, but I don't want it to be used to introduce
more keys in the WoT".
No, it's not what I meant.
 Diego.

@_date: 2014-05-04 09:03:15
@_author: NdK 
@_subject: Managing Subkeys for Professional and Personal UIDs 
Il 03/05/2014 05:01, Robert J. Hansen ha scritto:
That practice is the same as asking you to sign blank sheets of paper so
they can later write on them what they like.
IMVHO it's an *illegal* practice, and actually I vaguely remember news
about a case where a female worker had to sign a blank sheet, that was
later used for her "resignation" when she asked for maternity leave.
IIRC she won the cause.
Signing cards, at least here in Italy, are bound to a person. If
multiple persons can sign the same kind of document (or if a "vice" is
needed), then there are more cards, each controlled by a different
person. That's why it's called "qualified signature" and it's (legally)
stronger than a plain one.
As already pointed out it could be different for encryption-only keys,
that could be escrowed under some circumstances.
 Diego.

@_date: 2014-05-04 09:21:24
@_author: NdK 
@_subject: Signature without policy meaningless? (was Re: UI terminology 
Il 03/05/2014 10:50, Nicholas Cole ha scritto:
Ah, OK. Now it makes more sense.
Tks for the clarification.
IIUC, *unless* I tsig it.
But if I use tsig I'm doing both an "identity" signature and a trust
signature. I see no way I can publicly say "I don't really know
real-world identity of this subject, but I trust him as an introducer"
(yep, might sound strange [*], but often a pseudonym is more meaningful
than RL name, but pseudonyms aren't "good" in WoT): if I tsig his key,
I'm cerifying his pseudonym -- that I shouldn't do since it's not on any
[*] well, not too strange in many cases, when it's "healtier" that a
pseudonym is *not* easily correlated to a RL identity.
Understandable/safer, but harder to bootstrap :)
 Diego.

@_date: 2014-05-04 15:05:34
@_author: NdK 
@_subject: Managing Subkeys for Professional and Personal UIDs 
Il 04/05/2014 14:43, Robert J. Hansen ha scritto:
Just 'cause the law lays *way* behind technology: when it was created,
they couldn't think of "autosign" machines, figure digital signatures!
ROFLASTC :)
 Diego.

@_date: 2014-05-25 22:26:30
@_author: NdK 
@_subject: what hardware entropy usb key equivalent Simtec entropy key take ? 
Il 25/05/2014 20:57, tux.tsndcb at free.fr ha scritto:
You could use gnuk (includes 'quite' secure openpgp card), or only its
TRNG NeUg:
Readily available on seeedstudio (pre-programmed with gnuk, if you only
want NeUg you need to flash it yourself).
Hope it helps.
 Diego.

@_date: 2014-11-14 12:47:39
@_author: NdK 
@_subject: Why the software is crap 
Il 14/11/2014 12:41, david at gbenet.com ha scritto:
I usually just lurk, but that's too much...
Surely you're doing it wrong, overlooking some passage. So don't blame others for something *you* are doing wrong.
(3) Do it the right way as everyone else and admit you were doing something wrong.
And that will be better for the whole community.
  Diego.

@_date: 2014-11-14 14:11:39
@_author: NdK 
@_subject: Why the software is crap 
Il 14/11/2014 13:24, david at gbenet.com ha scritto:
If all four times you did the same wrong thing, then it's obvious that you got the same wrong result.
Just to prove it's your error, I copied my .gnupg from one system (str957-142) to another (str957-004), with the most basic method I ould think of. I'm not an expert (probably I transferred more than what was needed!), but as you can see I succeeded at the first try!
diego at str957-142:~$ gpg --list-secret-keys
sec   2048R/F9B9D307 2014-11-14
uid                  Diego ssb   2048R/3A4AD1C0 2014-11-14
diego at str957-142:~$ tar cvfz GnuPG-backup.tar.gz --exclude random_seed diego at str957-142:~$ gpg --clearsign GnuPG-backup.tar.gz
? necessaria una passphrase per sbloccare la chiave segreta
dell'utente: "Diego "
2048-bit chiave RSA, ID F9B9D307, creata 2014-11-14
diego at str957-142:~$ ls GnuPG-backup.tar.gz*
GnuPG-backup.tar.gz  GnuPG-backup.tar.gz.asc
diego at str957-142:~$ scp GnuPG-backup.tar.gz diego at str957-004:/home/diego
Then on the other PC:
diego at str957-004:~$ tar xvfz GnuPG-backup.tar.gz
diego at str957-004:~$ gpg --clearsign GnuPG-backup.tar.gz
? necessaria una passphrase per sbloccare la chiave segreta
dell'utente: "Diego "
2048-bit chiave RSA, ID F9B9D307, creata 2014-11-14
diego at str957-004:~$ gpg --verify GnuPG-backup.tar.gz.asc
gpg: Firma eseguita in data ven 14 nov 2014 14:07:57 CET usando RSA, ID chiave F9B9D307
gpg: Firma valida da "Diego "
Done just now in Ubuntu. So there's an error on your side.
  Diego.

@_date: 2014-11-14 21:49:23
@_author: NdK 
@_subject: Why the software is crap 
Il 14/11/2014 18:24, david at gbenet.com ha scritto:
Then do what we've already done to try to help you: open a terminal on
the source machine, type the commands and cut&paste to the list.
Unless you do that, showing *exactly* what you've done, I doubt anybody
can help you: all our crystal balls are broken...
And I'm *not* going to try to help you again unless I see that
cut&paste. Wasted time.
 Diego.

@_date: 2014-11-18 20:21:08
@_author: NdK 
@_subject: Encryption on Mailing lists sensless? 
Il 18/11/2014 19:15, Mirimir ha scritto:
That you're sending to a *single* address that hides the others.
1) you should disclose the whole list of subscribed addresses (that's
really valuable metadata -- not to say a dream for spammers!)
2) you make mail headers and message size "explode"
Not good, IMVHO...
 Diego.

@_date: 2014-11-20 19:43:28
@_author: NdK 
@_subject: Backup of encrypted private key on uncontrolled disks 
Il 20/11/2014 18:33, Dave English ha scritto:
Could simply use different passphrases for regular use and backups...
 Diego.

@_date: 2014-11-26 18:14:07
@_author: NdK 
@_subject: Pros and cons of PGP/MIME for outgoing e-mail? 
Il 26/11/2014 15:30, Bjarni Runar Einarsson ha scritto:
Maybe including a mandatory proof-of-work that includes addressee
identity might mitigate at least the spam?
 Diego.

@_date: 2014-11-26 20:31:49
@_author: NdK 
@_subject: digest-algo SHA256, SHA-1 attacks 
Il 26/11/2014 20:15, Peter Lebbing ha scritto:
Well, IIUC with rhash you're giving the attacker another mean to tamper
with your message. Unless 'r' is chosen deterministically. But then it
can be predicted and could be accounted for... Maybe it could be more
effective to use two different hash functions, one to generate 'r' and
the other on the result?
 Diego

@_date: 2014-11-27 06:55:34
@_author: NdK 
@_subject: digest-algo SHA256, SHA-1 attacks 
Il 26/11/2014 20:39, Peter Lebbing ha scritto:
Sorry, I've been too concise.
I see two problems with randomizing crypto:
1) who guarantees that the 'r' seen by the receiving party is the same
generated by the signer? Since it's usually trivially combined with
source text, I feel it's a huge attack vector
2) it could be a side-channel for leakage (say a smartcard under some
control by some TLA that encrypts the used secret key and some really
random bytes and uses the result as 'r')
 Diego.

@_date: 2014-11-27 17:10:08
@_author: NdK 
@_subject: Randomized hashing 
Il 27/11/2014 11:28, Peter Lebbing ha scritto:
[Resending to list]
Well, I'm no expert, but it gives me the feeling of being potentially
dangerous, since once the attacker have your signature for a document
  s=E(Prk, H(RMX(M,r))) , r
(note that r is not signed, as the rhash scheme suggests and the paper
confirms!) he *might* be able to calculate r' so that RMX(M',r') ==
RMX(M,r) then 'recycle' your signature for M'. Remember that RMX is
proposed to be a simple block-xor! For very short (less than a single
hash block) messages it's trivial, if I'm not badly mislead by the
graphic description in the site:
RMX(0, 1) == RMX(1, 0)
Citing from the paper: "RMX can be used with any hash-then-sign scheme
by replacing the digest H(m) in the original signature scheme with H(RM
X(r, m)). In this case, the salt r is generated for each signature by
the signer and transmitted to the verifier together with the message and
signature[1]" and the footnote [1] is "In contrast to a previous
proposal by the same authors, the salt r does not need to be included
under the signature." . I haven't yet found out why he changed his mind.
At a first glance, it would be safer to have r *inside* the signature.
This way the attacker couldn't change it. But maybe that exposes other
To me it appears that *any* encryption of the message before hashing
would lead to analogue security properties. Say you generate 'r' and use
it as 'session key' to block-encrypt M then sign the hash of encrypted M
(IMVHO it's better if the signature includes r too). Maybe it's just a
performance issue?
BTW, some smartcards want you to feed 'em the hash state and the last
block of data so they can calculate the last hashing step by themselves.
And IMVHO it's better if the padding is generated by the card, depending
on the operation being performed: while the op is anyway 'RSA encrypt',
the padding should be different if you're signing an hash or exchanging
a session key. Failing to let the card do the padding could lead to
exposure of the private key, IIRC.
 Diego.

@_date: 2014-11-28 11:41:20
@_author: NdK 
@_subject: Randomized hashing 
Il 27/11/2014 14:45, Peter Lebbing ha scritto:
When it says that 'r' have to be sent separately. It's 'included' only indirectly in the hash calculation.
I don't understand you.
I said that if you have a short message (less than hash len) it's trivial for an attacker to fix a new M' and calculate a new r' value that satisfies r xor M == r' xor M' . It gets harder with longer messages.
Depends on how strict the checking is.
E.g., if the smartcard only uses the raw buffer you pass it (just adding the needed padding before signing) and is able to accept SHA-512, then you could just use SHA-256 and append 256bits of 'r' w/o having to change the smartcard: it sees 512bits and pads 'em like in SHA-512. That's one of the reasons I like the cards that do the last hash round more.
I didn't study OpenPGP card protocol enough.
Yup. Terminology slip. The RSA op involving the private key, so   Diego

@_date: 2014-10-26 08:19:28
@_author: NdK 
@_subject: auto refresh for expired certificates 
Il 25/10/2014 20:09, Hauke Laging ha scritto:
IIRC a tool exists to do that, in a way that makes it hard for keyserver
owners to extract "social" metadata (like "these keys are on a single
keyring"). Too bad I can't recall its name :(
 Diego

@_date: 2015-08-17 11:02:33
@_author: NdK 
@_subject: protecting pub-keys from unwanted signatures 
Il 16/08/2015 18:04, Einar Ryeng ha scritto:
The only problem I see is that you can easily get associated with the
wrong people. Like what happened here in Italy with Fidobust (about 25
years ago): some pirates' phone lines were being tapped, and since they
connected to Fidonet BBSs, those got tapped too... then their lines were
tapped and the other nodes they connected to became "suspects" and so
on. As a result, a lot of people have had their bedrooms (where they
kept the BBS PC) locked for the YEARS needed by "justice" to do its work.
That's why my skin crawls when Robert J Hansen says
Especially if one of those is a judge. When the average person have to
pay for a lawyer, (s)he has already lost.
 Diego

@_date: 2015-08-27 13:07:14
@_author: NdK 
@_subject: Multiple GPG public keys with one private keys 
Il 27/08/2015 08:02, Divya Vyas ha scritto:
You can have multiple identities associated with one keypair, eventually
using different subkeys for different purposes.
But this "links" all your identities together, that could be undesirable
in some situations.
The only alternative is to generate different keypairs to keep
identities "unlinked", like if they belong to different people (good
luck having 'em signed by others!).
 Diego

@_date: 2015-02-15 22:06:05
@_author: NdK 
@_subject: SSH generic socket forwarding for gpg-agent 
Il 13/02/2015 23:23, Daniel Kahn Gillmor ha scritto:
Who told, not so long ago, that if the attacker have control of the
machine you're using you've already lost?
The machine from where one is originating the ssh connection have to be
quite trusted. Else you need a smartcard with out-of-band authorization
for every operation.
 Diego

@_date: 2015-02-20 09:32:45
@_author: NdK 
@_subject: Whishlist for next-gen card 
Hello all.
What I'd like to see addressed in future card specifications:
1 - support for more keys (expired ENC keys, multiple signature keys)
2 - different PINs for different keys
3 - separate key for NFC auth (with its own optional PIN)
4 - HOTP PINs for signature/certification keys
5 - possibility to export private keys to user-certified devices
6 - support for out-of-band authorization (HW)
7 - support for more informative signing (requires a small display: HW)
3 to 6 should be under a "policy" object connected to the main key to
make it public and let relying parties evaluate how much trust to give.
Since smartcards have evolved (slowly...) and nowadays we have other
much-less-constrained alternatives (GnuK), I feel that many limitations
are just an heavy heritage that's becoming nonsensical.
The reasons behind my list, point by point:
1 - I'd like to roll the key used for reading mail every year, but
currently that would mean I'd have to use a new card every year or have
old keys on-disk, defeating the purpose of using a smartcard/token (from
my tests on actual smartcards, it's not hard to have room for 14 to 20
keys on an 80k smartcard, more than 30 on a 144k one, WAY more are
possible on GnuK)
2 - If I have to use my card to login on a possibly untrusted computer,
I don't want it to steal my PIN and sign/certify without me knowing it
3 - Since NFC readers often have no pinpad (or could have easily been
tampered with) I don't want to expose my main PIN nor the same key I use
for "wired" auth
4 - since HOTP changes at every use, it makes keyloggers nearly useless
and gives a third factor to the auth process (might be combined by
simple means -like digit-by-digit addition modulo 10- to the PIN)
5 - I know, it's debatable and many see it as dangerous... but is it
more dangerous than keeping an on-disk (or on-paper) copy of the key?
Key export should be protected by a "certificate" (policy object defines
an "allowed KeyID for export" and the private key is exported only
encrypted to that KeyID); might even set a "fuse" to mark the fact that
the key have been exported
6 - like in Yubikey NEO, a physical button to authorize some operations
can be useful (certification, signature, NFC PIN-less auth)
7 - malaware currently can replace the hash of the object being signed
and the user can't know it till it's late... a small display could be
used to report some metadata (file name type and size for signature,
keyID and owner data for certification, peer ID for auth...) to give the
user more feedback
What do you think? Complete BS or could something be considered for
PS: 1 is the main reason I'm not yet using GPG much, even if I started
using it since DOS & FIDO-BBSs era...
 Diego.

@_date: 2015-02-20 14:27:33
@_author: NdK 
@_subject: Whishlist for next-gen card 
Il 20/02/2015 11:36, Jonathan Schleifer ha scritto:
Wasn't it covered by
2 - different PINs for different keys
? :)
That's not "uncontrolled export", and in fact such a feature is
implemented in HSMs to avoid unsafe key generation (outside the HSM
itself) *and* the risk of key loss.
The idea is that *before* creating/importing the master key, you set the
policy, including the key ID (or IDs) that can ask for key export. Once
the master key gets created, you no longer can alter the policy. The
policy should be exported together with the key and override the
existing one while importing a key (so that you "can't" alter -actually
it's just "really hard", but doing that should invalidate signatures on
your master key!- the policy by exporting from a device and importing on
Nope. it's possible to have (at least I've seen one: my father does have
it!) smartcards with small displays, keyboards (1-2 keys could be
enough, but a full 4x3 keypad would be awesome!) and even
batteries/solar panels! The form factor is not the real problem. The
problem is that it's quite a close and secretive market, heavily relying
on security by obscurity (when I asked Yubikey how to access the "user
presence" key from a Java appled, they answered I'd have had to contact
NXP and sign an NDA!
So no need to trust the card reader :)
 Diego.

@_date: 2015-02-20 17:21:57
@_author: NdK 
@_subject: Whishlist for next-gen card 
Il 20/02/2015 16:07, Ville M??tt? ha scritto:
Yes, by someone who controls the trusted export key. On the other hand,
current method to generate on a "secure" system and move to card makes
it easy to lose control of the key.
Safe key recovery in case sc gets damaged. With the current system you
have to always generate new keys on the "secure system" and store the
backup in a safe place that is *not* a smartcard.
 Diego.

@_date: 2015-02-21 08:48:07
@_author: NdK 
@_subject: Help need to use truecryt + openpgp applet. 
Il 21/02/2015 03:01, Matthias-Christian Ott ha scritto:
Then maybe, a simple (disabled) SIM card from an old phone contract (I
usually have about a dozen around) could be better suited for the job,
since there's no on-card crypto involved. Just store the secret in an
SMS, with the "sender" set to the ID of the protected storage :)
Ok, end of OT.
 Diego

@_date: 2015-02-21 12:30:51
@_author: NdK 
@_subject: Help need to use truecryt + openpgp applet. 
Il 21/02/2015 12:26, Peter Lebbing ha scritto:
Exactly. Moreover, it's often "free" since you don't have to buy a new
card just for that use, just recycle an unused one.
 Diego

@_date: 2015-02-21 19:54:38
@_author: NdK 
@_subject: Whishlist for next-gen card 
Il 21/02/2015 12:51, Peter Lebbing ha scritto:
Yup. But if those are too generic, then it could be way cheaper to just
use a generic PKCS card (I've had some experiences with Aventra ones:
they've got space for many keys and 14 PINs... and are quite cheap!).
Yup. But on a device like GnuK space is really not the limiting factor.
I remember seeing an unused PIN object.
Twice the cost, twice the risk of losing one, twice the management burden...
I started implementing it on MyPGPid. From JavaCards it's quite easy to
differentiate between wired and wireless, since the applet receives the
protocol used to transmit the APDU.
There are dual-interface cards, and I think they're not so disjoint,
once you're using secure messaging.
Way more than EM4100 tags or MIFARE cards.
No need. Just an applet on the phone could do. At least if you aren't
using the same phone to do the crypto.
As I said, no need for a PIN on the HOTP device. The only important
thing is that it's a *different* device, better if air-gapped.
You're authorizing a *single* operation. As you noticed, malaware could
be smart enough to fool the user for decryption (where using HOTP would
be foolish: you'd have to continuously generate new codes just to scan
the mail), but signature is another beast. HOTP could be seen as a
stronger 'alwaysauthenticate' flag.
Unless you're doing something like SmartcardHSM, where each card gets
initialized with a device attestation key (generated on-card) and its
certificate, so you can choose to trust other cards as long as they're
certified. A more user-centric approach would require a "temporary" CA
(no need for long-term storage of its secret key) that the user uses to
certify keys generated on his own cards. Once the cards have been
certified, the CA key can be deleted. In the worst case, the user won't
be able to transfer his keys to other (newer) devices.
On the other hand I think a TRNG that accumulates entropy under user
control (like GnuK) can be trusted more than something relying on
software only.
Maybe its addition to the security is marginal, but can be *way* more
practical than having to reenter a complex PIN every time.
Well, on one hand the user could *choose* to use his own CA, thus being
free to do what he likes with the keys. On the other had he could
*choose* to trust another CA (the one managed by the card producer,
maybe) and in that case he won't be able to access his keys and other
users will know that.
Separate cards for separate identities is one thing, but separate cards
for separate roles of a single identity could quickly become too
cumbersome to manage.
For me it wouldn't be a problem to plug my card in a work PC, as long as
I can be "confident enough" that I'm in control of which keys are being
You're quite right. Maybe third factor is not the correct term. What I
meant was that the user had to have another object. Better if it's
something he's used to bring around and guard (like the phone).
If that info is embedded in the signature packet, it could add something
to the signature value (if the receiving party sees that signature is
about a txt file and the presented object is a doc, there's something
wrong and suspect).
BTW the card could even (randpmly?) ask to be passed the whole file
to-be-signed to compute on its own the hashing. If it's different from
the one presented in the "summary", alert the user. I know card
interfaces are quite slow, but I think it should be allowed anyway
because 1) you can have faster interfaces, if needed (see GnuK) and 2)
it's an user's choice (I never sign ISO files, and even if I did I can
stand that once in a while it takes some hours... if I signed ISOs
everyday I'd probably choose NOT to enable such a feature, or just use a
card/token without display).
That's the fingerprint ssh shows you. It should be computed from the
complete public key.
See above. In poker terms there's a chance that the card asks to see
your hand. And if you cheated the user is alerted.
I didn't mean it for decryption, just for signature/certification.
Well, currently it could simply cache your PIN and do *everything*. Do
you agree that developing the depicted attack costs *way* more than a
simple keylogger (about 5? for one that intercepts the PS2 connector, IIRC)?
Maybe it's just convenience that *eventually* adds some marginal
security. Can't see it doing harm.
 Diego.

@_date: 2015-02-21 20:26:00
@_author: NdK 
@_subject: Whishlist for next-gen card 
Il 21/02/2015 17:54, Daniel Kahn Gillmor ha scritto:
Or just sniff the PIN.
Well, at least that one would be a dedicated computer, with very limited
connection to the outside world.
And if the idea of a display gets implemented, at least the kind of
operation can be confirmed.
 Diego.

@_date: 2015-02-22 11:53:20
@_author: NdK 
@_subject: Whishlist for next-gen card 
Il 22/02/2015 01:46, Yuji -UG- Imai ha scritto:
The problem with off-the-shelf keyboards is that they usually radiate a
pattern that's recognizeable from some distance.
The usual scan on a matrix keyboard activates one column at a time in
fixed order, then checks the rows (possibly one at a time). A safer scan
activates all columns at once, senses the rows, then changes columns to
inputs and rows to outputs activating only the one where the pressed key
is and finally determining the corresponding column. This doesn't
generate a recognizeable pattern.
Uh? Neither do I. I never understood the reasoning behind IR receiver
for FST-01.
Yup. And it's easily snoopable.
That's good. But I'd avoid plastic in favour of aluminium :)
 Diego.

@_date: 2015-02-25 06:49:52
@_author: NdK 
@_subject: Unattended signing 
Il 25/02/2015 00:01, Peter Lebbing ha scritto:
Use a smartcard and generate on-card a new key that replaces the expired
one. So an attacker could still abuse the key (it's not protected) but
can not extract it to keep copies around.
I really like SCs for signature and authentication[*] keys since often
even if those keys are lost it's not a big deal as long as they can't be
[*] for auth, only if there's a centralized repository for the public
key, else updating all instances of the pub key stored in devices could
be a major hassle.
 Diego.

@_date: 2015-02-27 21:59:15
@_author: NdK 
@_subject: Whishlist for next-gen card 
Il 27/02/2015 19:43, Peter Lebbing ha scritto:
That the HOTP doesn't need HW support so it can be implemented in
standard smartcards.
Well, IIRC there are cards that require you to compute all but the last
round of the hash, then pass the last block of data and the current
state to let them compute the result (and maybe do the padding before
signing). Something similar could be used for this: the last block will
include the shown data just before the file len.
For auth it should be the hash of the host's pub key, the same SSH shows
you the first time you connect to that host.
Since the challenge have to be encrypted to the host's pub key, you can
display its hash. I'll have another look at the RFC tomorrow morning...
 Diego.

@_date: 2015-01-13 20:53:37
@_author: NdK 
@_subject: Vanity Keys 
Il 13/01/2015 16:34, David Shaw ha scritto:
What I don't understand (surely because of my ignorance of GPG inner
working) is what that should add to the security... IOW, if the private
key have been generated by a third party to have a certain fingerprint,
what's the purpose of adding that fingerprint to the signature?
 Diego.

@_date: 2015-01-22 22:28:06
@_author: NdK 
@_subject: Crypto device where I need to confirm every operation? 
Il 22/01/2015 21:08, Daniel Kahn Gillmor ha scritto:
I proposed to add a button to FST-01 ages ago (IIRC it still was just a
project on Seeedstudio...), as "user presence test", and am having a
look at implementing it. But I received the programmer too late and now
I have a more demanding (and really high priority!) project: my son! :)
But I'll try to implement it, even if really slowly.
 Diego.

@_date: 2015-01-29 20:39:36
@_author: NdK 
@_subject: Talking about Cryptodevices... which one? 
Il 28/01/2015 02:46, NIIBE Yutaka ha scritto:
Uh, I think this exposes a weakness: if the attacker "somehow" accesses
the EEPROM and reads encrypted key material, a low s2k count means he
can recover plain key material quite faster than with more iterations.
Luckily it's configurable. :) Power of open source!
 Diego.

@_date: 2015-07-11 08:24:45
@_author: NdK 
@_subject: gpg-2.1.6 scdaemon: cannot disable OpenPGP application 
Il 09/07/2015 06:56, NIIBE Yutaka ha scritto:
So I could use any pkcs card to keep GnuPG keys?
I searched a bit but saw no docs on what needs to be done...
 Diego

@_date: 2015-07-20 09:12:08
@_author: NdK 
@_subject: Optimal setup for corporate keys 
Il 20/07/2015 02:44, F Rafi ha scritto:
If possible, I'd go for the HSM route (openpgp card or FST-01). This
way, if a server gets compromised remotely, the attacker can not get a
copy of the key (but he'll be able to use it as long as his activity on
the server is not detected!).
If the attacker obtains physical access to the server, you're toasted
Just my .02 ...
 Diego

@_date: 2015-06-03 00:15:21
@_author: NdK 
@_subject: s2k-cipher-mode default 
Il 02/06/2015 20:37, Daniel Kahn Gillmor ha scritto:
What if by changing to AES-256 you end up saving one from the bus by
throwing all users under the train?
IIRC, I read (some years ago...) that AES-256 could be *weaker* than
AES-128 because some mathematical structures express some properties
only with the longer keys. I don't have the paper handy ATM, but I
vaguely remember that shocking conclusion.
 Diego.

@_date: 2015-06-09 15:38:39
@_author: NdK 
@_subject: Hardware Keyring 
Il 09/06/2015 10:19, Antoine Michard ha scritto:
That's the one I like most, given my security needs. Remember that it's
not as hardened as a smartcard if the attacker gains unsupervised
physical access to it for a long enough time. But it uses ommodity
hardware you can source where you prefer, so a backdoor is really *much*
less probable!
And the creator reads this list, too! :)
The only thing I really miss is that the trust db is not in the token,
but integrating it would require changes/extensions to the protocol.
 Diego.

@_date: 2015-06-12 19:32:50
@_author: NdK 
@_subject: [Announce] GnuPG 2.1.5 released 
Il 12/06/2015 02:34, NIIBE Yutaka ha scritto:
Really interesting!
Especially section 4.1.3: IIUC, that allows for out of band
authorization of the crypto ops.
I'll have to study better the code for GnuK and how to make that little
beast^H^H^H^H^H ARM handle inputs... :) Or maybe a display + buttons via
i2c (as the "display" capability is announced by b8 in sec 4.1.3.2 .
Too bad it seems still limited to the "standard set" of keys. No way to
store old dec keys (to keep using a single card to read all the old
mails, even if generating a new key every year).
A possible workaround would be a "parallel" application on the card that
when called changes the active DEC key together with the card serial no,
corresponding fingerprint in C5 DO and gentime in CD DO).
 Diego.

@_date: 2015-03-02 14:38:21
@_author: NdK 
@_subject: Whishlist for next-gen card 
Il 01/03/2015 21:54, Peter Lebbing ha scritto:
Because I didn't remember well the SSH protocol...
That gets verified during initial key setup.
Ok, just something to help the user avoid a verification step every time.
But the signature contains the session identifier (called H in RFC4257
sec 8), that is derived from the initial key exchange (that should then
be partially handled by the card as well). Luckily there's no need to
recalculate it when keys are refreshed (RFC4257, sec 7.2), so it's
one-time penalty.
So the "card" should receive (and handle) the key exchange, prompting
the user to accept the public key the server sent and then allow the
auth key to just sign data where the session id is the one it
calculated. Might be non-banal to handle concurrent ssh sessions with
overlapping key exchanges (card generates a "blob" --might be
symmetrically encrypted with a key only known to the card-- that's
"cached" by ssh and passed back to the card when a new auth signature is
requested for an existing session id?).
 Diego.

@_date: 2015-11-21 18:23:32
@_author: NdK 
@_subject: Crowdfunding USB Security Key for Email- and Data-Encryption - 
Il 21/11/2015 12:07, Peter Lebbing ha scritto:
I didn't look at the code (so this could be completely wrong and I'd be
happy!), but if the OTP key is decrypted using a key in the chip after
verifying that the card accepts the PIN, then it's even worse, since
that master key is in cleartext somewhere outside the smartcard. So,
with some efforts and a good lab the OTP keys can be extracted.
Nifty, indeed. Too bad PGP-card spec lacks decryption key archiving (so
that you can change your DEC key every year but keep using the same card
year after year).
 Diego

@_date: 2015-11-22 15:30:55
@_author: NdK 
@_subject: Crowdfunding USB Security Key for Email- and Data-Encryption - 
Il 22/11/2015 12:55, Peter Lebbing ha scritto:
The whole stick (and the current OpenPGP card spec) is not aimed at me,
since it lacks the "decryption key history" that I'd need :)
What I don't understand is why they did not use one of the private
objects in the card to store the master key: this way, if the card gets
swapped, the master key becomes inaccessible and the attacker can't use
the OTP secret since it's encrypted with an unavailable key. Sure, it's
not perfect (the master key gets loaded in RAM of the micro) but makes
any attack harder.
 Diego

@_date: 2015-11-23 09:42:27
@_author: NdK 
@_subject: Crowdfunding USB Security Key for Email- and Data-Encryption - 
Il 23/11/2015 08:56, Jan Suhr ha scritto:
Then, replacing the card replaces the OTP key. No?
 Diego

@_date: 2015-10-25 11:36:05
@_author: NdK 
@_subject: absolutely nothing to panic over 
Il 25/10/2015 08:40, listo factor ha scritto:
Unless you move to another family of algorithms based on
information-theoretic limits on what an eavesdropper can know. Some
methods I remember involve neural networks in the form of tree parity
machines with a hidden layer (mutual learning is provably faster than
learn-by-watching), others use noisy channels (say readings from a
distant radio-source in deep space), others put a limit on the amount of
data an attacker could store...
All those have in common is that they require quite large data transfers
(so they're quite impractical) and the success probability of an attack
is mathematically limited (though quite "high" compared to current PK
and SK crypto, but can be made as small as you like by iterating enough
times). *No* advance in computing power can break 'em, unless it makes a
brute-force attack possible.
If the problem is "just" the birth of quantum computers, then there
already are some practical algorithms that address the issue (NTRU and
McEliece, as already pointed out by others).
 Diego.

@_date: 2015-09-22 06:33:21
@_author: NdK 
@_subject: gpg agent forwarding (via ssh) totally broken with 2.1 and 
Il 21/09/2015 15:06, Werner Koch ha scritto:
Why isn't the hostname included in file name? This way shared
filesystems would have no problems..
 Diego

@_date: 2016-08-09 08:57:26
@_author: NdK 
@_subject: several GPG smartcards connected at the same time 
Il 09/08/2016 02:39, NIIBE Yutaka ha scritto:
Isn't it what PKCS is for?
If GnuPG supported PKCS it would open a whole new world, like the
ability to use generic cards.
IMVHO "fixing" GnuPG to handle multiple cards and readers would actually
create something really similar to PKCS
 Diego

@_date: 2016-08-09 10:34:41
@_author: NdK 
@_subject: several GPG smartcards connected at the same time 
Il 09/08/2016 10:27, Justus Winter ha scritto:
That's exactly the opposite: Scute allows a PKCS app to access an
OpenPGP card (but isn't it redundant, since OpenPGP cards are
supported[1] by native opensc driver?).
If GnuPG/scd supported PKCS you could tell it to use a key on any
non-openpgp card as a GnuPG native key (some configuration could be
[1]  Diego

@_date: 2016-08-24 14:58:21
@_author: NdK 
@_subject: Attacks on encrypted communicxatiopn rising in Europe 
Il 24/08/2016 14:11, Francesco Ariis ha scritto:
Instead of stupid backdoors, couldn't legislators simply say that if
encryption is used to try to hide a crime (that still have to be proven
by *other* means!) then it's like having used a gun in a robbery?
That would simpli make something wrong even worst, but allow for
rightful use of crypto.
Sure, it's way easier to outlaw any non-approved crypto, but then
outlaws will use strong crypto nevertheless...
 Diego

@_date: 2016-12-06 22:42:38
@_author: NdK 
@_subject: Proof for a creation date 
Il 06/12/2016 12:30, Roman Zeyde ha scritto:
To remain on-topic, I'd like to take the "footnote 3":
An interesting nuance to this is someone who has stolen a PGP key could
also create a revocation, and they could backdate it to deny access to
previously created signatures; there?s a lot of interesting design
questions about how to deal with this with random beacons and the like
that are beyond the scope of this blog post
That could actually reduce trust in any PGP signature, unless there's a
way to timestamp 'something' that says "as of 'now' this key have not
been revoked". Ideally that attestation should be included with the
signature itself.
 Diego

@_date: 2016-12-06 23:57:58
@_author: NdK 
@_subject: Proof for a creation date 
Il 06/12/2016 23:14, Andrew Gallagher ha scritto:
That's the idea, but in GPG trust model... Is it possible?
 Diego

@_date: 2016-12-07 06:50:40
@_author: NdK 
@_subject: Proof for a creation date 
Il 07/12/2016 00:27, Andrew Gallagher ha scritto:
The "stapling" part is the hardest, since with OCSP usually you need to
verify that something is valid "now", while with a GPG signature you
should be able to attest that something will be valid "forever".
The only way to obtain that (I can think of, and assuming no online
verification: online services come & go...) is having at least three
different kind of keys (RSA, EC, PQ) sign at least three different hash
function results *each*, so that even if an algorithm or two gets
cracked the signature remains valid.
That's good: this way most "implicit assumptions" must be explicited and
their security impatc must be evaluated.
 Diego

@_date: 2016-12-07 15:12:49
@_author: NdK 
@_subject: Proof for a creation date 
Il 07/12/2016 09:53, Andrew Gallagher ha scritto:
Well, "till the heat death of the Universe" can be enough for any
practical purpose :)
My aim is something that's still secure even if some big leaps happen.
Say QC becomes feasible: current pki methods (RSA and EC) are to be
considered insecure. Hence I included a PQ signature (maybe NewHope?).
Well, actually symmetric crypto could be used with a system like the one
used for one-time signatures: you sign both the (hash of the ) plaintext
and the hash of the cyphertext obtained encrypting that plaintext with a
(randomly generated, single use) secret key.
This system allows a single arbitration: you give the judge the secret
key used and he verifies that:
a) the hash on the plaintext matches the signed one (everyone ca do this)
b) the hash on the cyphertext matches the signed one (everyone ca do
this, too)
c) the hash of the plaintext encrypted under the given key matches b)
A timestamping service could easily generate such a key from a "really
secret key" (never disclosed) and the timestamp, maybe using a truncated
hash (to prevent a possible hash inversion attack to determine the
"really secret key") and remain able to disclose it to the judge without
compromising other signatures' security.
An attacker should be able to find another (meaningful!) messages that
hashes to the same value and whose cyphertext under an unknown key would
result in the other hash value.
H(Ek(p'))==H(Ek(p)) (for every k, since he does not know k)
IIUC, merkle trees remain secure only if they continue to "evolve". If
an attacker does have enough (more than 50%) computing power, he can
control the tree's growth. And possibly rewrite the history (IIRC
something similar happened not long ago, when a single group of miners
had had for some hours the needed "quorum").
I have to think about this a bit more... I'm not completely sure.
To be at least partially in topic, it should be possible to do the
signing (and the encryption) even with the current GnuPG version...
 Diego

@_date: 2016-12-11 13:40:43
@_author: NdK 
@_subject: Strange behaviour 
Il 11/12/2016 11:56, Matthias Mansfeld ha scritto:
I think it could even be realated to some HW issue. Are fans clean? Are
capacitors OK? Electrolytic ones, the tall cylinders, often tend to
"explode": they usually have an 'X' on the top and that should be flat
and clean, else the capacitor is surely bad. Did you run a RAM test? And
a CPU test?
I know, it's just a remote possibility, but given the "randomness" it
could be worth checking.
 Diego

@_date: 2016-12-27 22:54:23
@_author: NdK 
@_subject: ? Comments re key servers? re gpg-encrypted mail? re key servers 
Il 27/12/2016 22:09, Don Warner Saklad ha scritto:
Why do you find it strange?
Keyservers are just public write-only repositories that do not attempt
to verify the keys.
You have to verify the keys via the WoT (web of trust: "follow a chain
of signatures"), or by other means ("see gpg.html for my real key"), and
that's what Stallman says. Better do both: check that the chain
identifies the key given in gpg.html (must be retrieved via https).
 Diego

@_date: 2016-12-28 15:42:00
@_author: NdK 
@_subject: ? Comments re key servers? re gpg-encrypted mail? re key servers 
Il 28/12/2016 13:28, Miroslav Rovis ha scritto:
I can't say for sure, but maybe that's so so they can have an
"attestation key" to use for verifying signatures, without expensive WoT
checks. By loading your key, you're certifying it's yours. But it won't
actually give any more assurance than "you is you" than your credentials
(against GitHub): if someone steals your credentials, he can replace
your pub key and sign new commits in your name. They're using GPG just
as a frontend for signatures using self-signed certificates.
BTW nothing prevents you from uploading your key to the keyservers and
participate in the WoT -- that's the only thing that could assure who
clones your repo that *you* signed those commits.
Sometimes just "key persistence" is important (i.o.w. that the key that
signed all the commits has always been the same, and in this case GitHub
loaded key can be enough), other times it could be important to link the
key used for signing a commit to (the reputation of) a real person, and
in this case the WoT is needed.
Some reccomendations could be quite questionable (always use RSA 4096,
do not set an expiry on main key, no mention of generating a revocation
 Diego

@_date: 2016-02-20 09:48:13
@_author: NdK 
@_subject: Use of --passphrase-file 
Il 19/02/2016 15:17, Harman, Michael ha scritto:
What about using a smartcard? You supply the PIN only at boot, then it
stays unlocked ad long as the system is working. This way an attacker
couldn't steal the secret key even if successful at breaking in.
 Diego

@_date: 2016-02-26 14:31:31
@_author: NdK 
@_subject: gnupg-pkcs11 status & future 
Hello all.
Is gnupg-pkcs11 still maintained? Files on sourceforge are from 2011...
The idea of using a "standard" key container for GPG keys is appealing,
and it could solve my (very personal, I admit, but maybe others feel the
same) "problem" with having only 3 keypairs (for example I can't rotate
encryption key every year unless I'm prepared to have a different card
per year).
With nearly every card I could have a look at, I can keep at least a
dozen keypairs, so that would reduce to one smartcard every 10 years.
 Diego

@_date: 2016-02-26 20:40:26
@_author: NdK 
@_subject: gnupg-pkcs11 status & future 
Il 26/02/2016 16:02, Peter Lebbing ha scritto:
In my case: every year will have its own PIN, different from the one
used for signing, and *really* different from the one for certification.
Extreme case: a judge orders to hand over the key to a set of messages
('cause they won't trust your decryption). Rotating keys minimizes
exposure of other material.
Well, everybody can have his own perfectly valid reasons... Why limit
keys on smartcards more than technically necessary? Years ago cards had
space only for 3 keys, but a 144K Javacard can handle many more!
And if PKCS was useable, one could use as many keys as needed by his
Note that I really don't like PKCS but it's the de-facto standard to
access nearly every crypto-capable device.
 Diego

@_date: 2016-01-14 20:11:33
@_author: NdK 
@_subject: Key selection order 
Il 14/01/2016 18:04, Andrew Gallagher ha scritto:
I disagree.
TOFU is what many users do anyway: identity persistence is often more
important than "real" identity... And harder to fake by any opponent
(governments would have no problem creating "fake" identity cards,
passports or anything -- after all that's what they usually do for
"real" ones!). On the other hand, if you saw mails from a single address
signed by the same identity for years, chances are that it's the same
person, even if the name on the identity card is different.
 Diego

@_date: 2016-01-14 22:41:57
@_author: NdK 
@_subject: Key selection order 
Il 14/01/2016 21:06, Andrew Gallagher ha scritto:
As usual, it depends on your attack scenario.
If I have 10-years-old mails from someone I've never met, and all use
the same key, I can assume that either 1) that identity belongs to the
same person or 2) that an attacker MITMed *all* my connections (from
every device I've had wherever I was and to every service I used).
Occam's razor and my "exposure profile" make me think it's 1) :)
In other words, *time* can be considered an 'out of band' channel.
For others, very "high profile", it could be possible that such an
attack might be performed, even if it's quite unlikely, unless there's
*a lot* of money involved.
What I learnt from OpenAlarm is that there's always to balance cost and
security: over a certain limit, costs grow exponentially for marginal
gains in security. So the different options have to be weighted
carefully: you'll have to make different choices if you have to protect
a bank instead of a garage.
 Diego

@_date: 2016-06-28 10:42:48
@_author: NdK 
@_subject: How to sign a PDF using a DNIe 
Il 28/06/2016 04:16, NIIBE Yutaka ha scritto:
That would be great, but I think it's an orthogonal issue.
When you get to use a smartcard, you are already giving up a lot of
control on your key, trusting something you can't control and hoping
certifiers did their work correctly and the units being sold are
completely like the tested ones.
The support for generic cards could be useful for other reasons. Say I
have a smartcard that could host 15 keys. I'd like to use one for web
auth, another for NFC auth, another for signing documents, another as my
primary GPG identity (certification), one for GPG auth, one for GPG
signing and the others for GPG decryption (just not to lose access to
older mails). Currently it's not possible, unless I use quite a lot of
different cards.
IMO the "ideal" solution would be a FIDO-like system, where keys are
kept, encrypted, on disk and uploaded as "blobs" to the card that
decrypts 'em and only then become useable. That would remove the limit
on the number of keys that could be kept on a card. But it's not
feasible with Java cards, I think (at least I couldn't make it work w/o
writing to the flash memory). That would be completely feasible with
 Diego

@_date: 2016-11-10 18:42:52
@_author: NdK 
@_subject: PCI DSS compliance 
Il 10/11/2016 16:24, helices ha scritto:
Wouldn't a smartcard solve (at least partially) the issue?
Insert it in a pinpad reader and have the PIN shared between two
administrators. Both are required at system boot to unlock the card. If
the card gets removed, no single admin can unlock it.
Sure, an admin could just use it while connected to the server to
decrypt files (or simply read stored files) but as others said there's
no way to prevent that if the attacker have physical access to the system.
 Diego

@_date: 2016-11-16 19:12:11
@_author: NdK 
@_subject: Specifying entropy source 
Il 16/11/2016 15:55, Juergen Christoffel ha scritto:
Why not GnuK, that incorporates a TRNG too?
There's even a version that only includes the TRNG, and it's completely
 Diego

@_date: 2016-10-19 21:47:21
@_author: NdK 
@_subject: smartcard reader 
Il 19/10/2016 13:06, Werner Koch ha scritto:
Well, actually the situation is a bit better: the keys at rest are
stored encrypted, even if kdf function uses less rounds not to slow down
unlocking too much... So even if an adversary manages to get the token
and retrieve the memory contents, he still have to find the passphrase
to decode the keys. Quite like the situation where he somehow accesses
your privring from a powered down computer.
 Diego

@_date: 2017-04-07 19:09:44
@_author: NdK 
@_subject: Documentation about --list-secret-keys output 
Il 07/04/2017 11:51, mogliii ha scritto:
Shouldn't it be "exporting" instead of "exported"?
 Diego

@_date: 2017-02-23 18:25:32
@_author: NdK 
@_subject: Announcing paperbackup.py to backup keys as QR codes on paper 
Il 23/02/2017 11:00, Gerd v. Egidy ha scritto:
Well, when considering such a timespan there could be other (bigger)
issues... How long a today 'secure' key will remain secure? When will
quantum computers be widely available?
The only "guaranteed" crypto is information-theoretic one (neural
networks mutual learning, distant noisy sources, etc), where adversary's
probability of success is a function of the system parameters. But it's
quite impractical and AFAIK covers only interactive key agreement.
PS: in 100 years surely I won't (be here to) care if someone will be
able to read my mails or not :)
 Diego

@_date: 2017-07-11 10:14:26
@_author: NdK 
@_subject: Changing PINs of German bank card 
Il 11/07/2017 09:44, Binarus ha scritto:
If you routinely use your card twice a day, they can make two or four
guesses each day: every correct PIN you insert resets the counter.
The probability to guess the correct code during the 5-years life of the
card is definitely non-negligible.
Usually there are other, non-technical ways. For example they just go to
the bank with a death certificate.
Better use shamir's secret sharing, or just use LCD-segments characters
printed on two acetate sheets that need to be combined to be read.
Obviously the two sheets are to be given to two different people, in
sealed envelopes...
BTW the method you use is the same that was used for our mainframe's
master password. :)
 Diego

@_date: 2017-07-11 14:32:43
@_author: NdK 
@_subject: Changing PINs of German bank card 
Il 11/07/2017 12:32, Binarus ha scritto:
Say that's your wife/son that takes the card when you're at home...
Low prob, but possible :)
Been there...
Another reason to give the password before going with the documents
might be "a bit" illegal: just transfer the money to avoid paying taxes.
Why should heirs have access to social accounts? Paypal, otoh, is a bank
that have to follow the same rules of other banks...
My concern with a singl "cleartext" pass would be a burglar that steals
it together with other valuables...
Given that mechanical keys are often easier to open whithout the key
than with it...
 Diego

@_date: 2017-07-12 12:27:41
@_author: NdK 
@_subject: Changing PINs of German bank card 
Il 12/07/2017 12:01, Binarus ha scritto:
Even with 6-digits PIN it would take *seconds* to an attacker to brute
force hashed PINs once he gets the hashed database. Salted hashes would
multiply the needed time by the number of PINs (approx).
So keeping such a database would be a really stupid thing to do --
unless it's kept in a HSM.
Passwords have way larger key space (from 10^N for N digits of the PIN
to 64^N or more for the passwords -- considering uppercase, lowercase,
digits and symbols), hence salted hashes are quite secure.
 Diego

@_date: 2017-07-18 18:42:11
@_author: NdK 
@_subject: A Quick Supplement 
Il 18/07/2017 14:23, Daniel Villarreal ha scritto:
Security = confidentiality + integrity + availability
If you're not considering availability, you only can have partial security.
 Diego

@_date: 2017-06-06 14:39:56
@_author: NdK 
@_subject: Key management for archives 
Hello all.
I'd need to handle an archive with many big files (~200GB each). The
system receives "plain" files in a "dropbox" folder, then encrypts 'em
to a (set of) public key(s) (no corresponding private keys on this
system) and deletes source files.
Up to this point it should be OK (a cronnable script with a lot of
checks is mostly ready).
But my big doubt is how to handle archive reading in an efficient way.
The naive way would be to let an authorized user decode the file and
reencode it for the requester, but that would mean that this authorized
user should have quite a lot of space available (twice the dataset size,
at least).
Is it possible to "extract" the used session key, so that the requester
just ignores the asymmetric crypto and just uses the symmetric key to
decode the file? Drawbacks? Other ideas?
 Diego

@_date: 2017-06-06 22:03:09
@_author: NdK 
@_subject: Key management for archives 
Il 06/06/2017 20:13, Konstantin Gribov ha scritto:
Problem: the symmetric key (DEK) must remain in plaintext on the server.
It's a relatively secure setup, but I prefer *not* to risk. Even if that
means a slightly more involved process. If the server gets compromised,
the attacker can only access new datasets, at most, not the historic
Moreover, with your proposal, once I give an user access to one file,
he'll be able to decrypt *any* other file too.
If I keep track of who can access every dataset and some day I find some
datasets are being used "illegally", I can restrict the suspects.
Since encrypting to a public key generates a random session key, the
session key gives access only to that single file. Obviously that access
can not be easily revoked (the user could have saved a plaintext copy
anyway, so that's not a big issue).
That's the same of encrypting the DEK with multiple public keys.
The problem is that I don't know in advance the users that will need access.
IIRC there was some method to retrieve the session key and replace the
public key part with another recipient...
That would be a big problem: archives must remain static (to avoid
troubles with offsite replication).
Well, I handle the storage (currently 100TB, going to grow to 150TB
soon). I want to avoid that an attacker could gain access to the whole
archive if he succeeds in compromising the server. Clients are out of my
perimeter (= not my problem).
 Diego

@_date: 2017-06-06 22:54:14
@_author: NdK 
@_subject: Key management for archives 
Il 06/06/2017 22:40, Konstantin Gribov ha scritto:
There's a big misunderstanding here: the encryption must be automatic,
not done by an user. So, IIUC, the scheme you're suggesting given this
limitation is what GPG already does when encrypting to a recipient's pk:
generate a symmetric key, use it to encrypt the file, encrypt that key
with recipient's pk. And it (hopefully) does every step in the safest
possible way -- surely much safer than anything I could do from a script.
What I'd need is some way to "extract" that temporary key (using the
recipient's secret key, obv) and then immediately reencrypt it with
another recipient's pk. Or (that's equivalent) add another recipient to
the already encrypted file, w/o reencrypting the whole file.
As I said, that's not a problem: once he's had access to a file, that's
"forever" (I cannot avoid he saves the file in plaintext). But he must
not be able to decrypt other files from the archive.
 Diego

@_date: 2017-06-09 10:05:18
@_author: NdK 
@_subject: Key management for archives 
Il 09/06/2017 08:24, Werner Koch ha scritto:
Tks! That's exactly what I was looking for.
I'll probably put that in a script that immediately re-encrypts the
session key with the public key of the newly authorized user.
Then he'll decode the session key and use it to decrypt the archive.
 Diego

@_date: 2017-06-15 14:13:38
@_author: NdK 
@_subject: How to use a PKCS#15 with GnuPG? 
Hello all.
I'm trying to use an ePass2003 token (and possibly some Aventra MyID
cards) to have my keys around when I need 'em (especially for
authentication and signing). Both ePass2003 and MyID implement PKCS
so IIUC they should be usable.
Too bad I can't find the needed infos...
I generated some test keys on the token (ssh one is imported, for
another test):
$ pkcs15-tool -D
Using reader with a card: Feitian ePass2003 00 00
PKCS Card [NdK-test]:
PIN [User PIN]
Private RSA Key [SSH key]
Private RSA Key [Signature key]
Private RSA Key [Decryption key]
Public RSA Key [SSH key]
Public RSA Key [Signature key]
Public RSA Key [Decryption key]
$ gpg2 --version
gpg (GnuPG) 2.1.11
libgcrypt 1.6.5
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Home: ~/.gnupg
Supported algorithms:
Pubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSA
Cipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,
        CAMELLIA128, CAMELLIA192, CAMELLIA256
Hash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224
Compression: Uncompressed, ZIP, ZLIB, BZIP2
$ gpg2 --card-edit
gpg: OpenPGP card not available: Not supported
Well, actually it's not completely unexpected, but then I don't
understand why scdaemon is now locking my token, if it doesn't know how
to handle it:
$ pkcs15-tool -D
Using reader with a card: Feitian ePass2003 00 00
Failed to connect to card: Reader in use by another application
What am I missing?
 Diego

@_date: 2017-06-17 11:15:53
@_author: NdK 
@_subject: How to use a PKCS#15 with GnuPG? 
Il 17/06/2017 10:35, Werner Koch ha scritto:
Then I don't understand the reason for gpgsm (the "niche" it fills)...
opensc already supports many cards, and can even edit some. And (via
PKCS Firefox and Thunderbird (and many other programs, but only one
at a time) can use the cards for auth (and signing).
As usual. But even openpgp RFCs are often implemented with proprietary
I'll have a look.
 Diego

@_date: 2017-03-06 19:23:26
@_author: NdK 
@_subject: How U2F works 
Il 06/03/2017 16:10, Werner Koch ha scritto:
IIRC one of the selling points of U2F is that it should have been
"anonymous": an attacker that compromises multiple servers shouldn't be
able to determine if two users (on the two servers) are actually the
same person (or even if two users of the same site share a single token).
The only link would be the attestation certificate, but that should only
be checked during enrollment and not stored anywhere (once the user is
enrolled, the attestation cert is useless since only the site-specific
pubkey is needed).
With X509 (or GPG) certs the user's identity gets linked, for the joy of
nosy orgs.
 : the sites don't send "proprietary JS" to the browser to access
the token (needed code is public) but the browser must support U2F API.
That's native in Chrome, but Firefox requires a plugin (and I don't know
what's the status of other browsers).
PS: it's not clear what happens when the attestation cert expires: does
the token become useless for enrollment?
PPS: the "attestation CA" could even be the GPG 'C' or 'S' key, that the
server could check via WoT. That does not require 'C' or 'S' key to be
on the token: the attestation certificate can be generated on an offline
 Diego.

@_date: 2017-10-03 15:00:18
@_author: NdK 
@_subject: 1024 key with large sub key 
Il 03/10/2017 12:40, Werner Koch ha scritto:
At least they should have shared the bugfixes! :)
 Diego

@_date: 2017-10-05 22:11:24
@_author: NdK 
@_subject: auto-key-retrieve usefulness/annoyance 
Il 05/10/2017 21:06, Daniel Kahn Gillmor ha scritto:
But the mail client could flag the message "key retrieval failed". Then,
the delay is only on the first attempt. Unless the user un-flags that
 Diego

@_date: 2017-09-12 22:25:59
@_author: NdK 
@_subject: [Feature Request] Multiple level subkey 
Il 12/09/2017 19:39, lesto fante ha scritto:
Such a thing already exists, at least here in Italy: CIE/CNS. X509-based
certs. It's got its own set of weaknesses, but since you're thinking
about a trusted third party (the State), X509 is a better fit. Possibly
extended by another applet that handles service-tokens (actually wrapped
private keys + metadata). Anyway that's something that IMVHO does not
fit well with GPG.
Just my ?.02 ...
 Diego

@_date: 2018-02-06 10:12:14
@_author: NdK 
@_subject: OpenPGP card && exporting secret keys 
Il 06/02/2018 06:47, Matthias Apitz ha scritto:
Not possible by design.
What you can do is generate the key on the machine, then copy (not move)
it to the card. But if you already generated it on-card you're toast.
A possible workaround could be encrypting the password store to multiple
"recipients" instead on only one (the GPGcard). Those multiple recipents
can be everything you want: GPGcards, keys on disk, other people...
 Diego

@_date: 2018-06-06 18:56:29
@_author: NdK 
@_subject: [NIIBE Yutaka] STM32F103 flash ROM read-out service 
Il 06/06/2018 17:49, Tom Li via Gnuk-users ha scritto:
Because those are (at least should be) based on secure chips.
The only secure (even against decapping attacks) device I know of is a
very old parallel-port "key" a friend described me ~25y ago.
It was made of 3 silicon layers: the outer ones only contained interface
circuits and 'randomness' while the keys and the logic were in the
central layer. Trying to remove the outer layers destroyed the random
patterns that were used as 'internal master key', rendering the rest
completely useless.
IIRC some recent chips reused (partially) that idea, rebranded under
"Physically Unclonable" something.
Yep... Found:
(but looking for "physically unclonable chip" returns lots of results).
Those chips work on the same principle: decapping alters the silicon
layers and the 'random id' changes before the attacker have a chance to
read it.
Then we should all use RISC-V chips :)
Too bad neither ETECC508A nor ATECC608A support curve25519 :( Only some
NIST ones.
Well, at least some TPM 1.2 chips have already been cracked.
Yes, but you risk having very long delays, that could even be
unacceptable. Unless there's a way to parallelize the operations (say
'do more KDF iterations while the chip is decoding').
I'd bet it works as described in the offers.
 Diego

@_date: 2018-06-07 14:16:22
@_author: NdK 
@_subject: [NIIBE Yutaka] STM32F103 flash ROM read-out service 
Il 07/06/2018 02:01, Leo Gaspard via Gnupg-users ha scritto:
I think I've seen it. But IIRC it does not work with such a big slice
(whole depth of the silicon slice, ~200micron IIRC).
But now that you made me think about it, I remember I've seen another
article where the attack was carried out from "behind" the chip.
Fault-injection. But for cheap chips it's probably way easier to "just"
use FIB (or a laser) to change the state of the protection fluses
(usually just normal flash cells) then read the whole contents.
Hope so :)
But I stay cautious when trusting certification. See the ROCA
vulnerability in Infineon "secure" (smartcard) chips.
Then, instead of "this chip is secure" they should just say "this chip
can be cracked spending X in equipement (una tantum) and Y for every
chip"... Marketing would never allow that :)
As always it depends on the attack scenario.
GnuK IIUC targets all those users who think a targeted attack is quite
improbable or that rubber-hose cryptanalysis is end of game.
If I know that extracting my key from the token costs $500, then I can
choose what to do. But with a non-secure and open chip it's easier to
estimate that cost (being easier and cheaper, it's more probable it gets
used in universities by security students for their first attacks,
usually the most fantasious ones). Quite surely it will be lower than
the cost of attacking a secure chip, but probably by not that much.
 Diego

@_date: 2018-06-11 09:38:19
@_author: NdK 
@_subject: Hard to find alternate source of checksums 
Il 09/06/2018 19:08, Jeff Martin ha scritto:
Why not fetch some (unrelated) live distributions, possibly some older
ones and some newer ones?
GPG is usually included and you can use it to check the signatures.
 Diego

@_date: 2018-06-17 10:31:49
@_author: NdK 
@_subject: Hard to find alternate source of checksums 
Il 16/06/2018 19:48, Jeff Martin ha scritto:
You can just fire up a VM booting with an "old enough" distro that you
can assume has not been tampered with. Maybe one from an old CD.
Once you've bootstrapped the system, it all becomes easy :)
 Diego

@_date: 2018-05-18 12:48:42
@_author: NdK 
@_subject: AW: AW: AW: Users GnuPG aims for? (Re: Breaking MIME 
Il 18/05/2018 07:31, Fiedler Roman ha scritto:
Well, assume that who can publish to a repo you trust *is root* on your
machine. Even if you could pin the package, what prevents him from
adding a suid exe ?
That's exactly what ther're for.
 Diego

@_date: 2018-05-23 23:03:47
@_author: NdK 
@_subject: A Solution for Sending Messages Safely from EFAIL-safe Senders to 
Il 23/05/2018 04:35, Craig P Hicks ha scritto:
While that could be OK for human-readable files, it silently alters
every other content.
Say *m* is a binary file (say a tar.gz)  that needs automatic processing
and voil? -- you broke a perfectly good use case.
Say *m* is not decrypted "immediately" but archived for later use
together with other (pre-patch) files. That corruption could go
unnoticed for a very long time, and when it gets noticed it could have
damaged a lot of archived files...
IMVHO that's really bad. And all that just because a bug isn't fixed
where it belongs?
A security-conscious user must upgrade the programs he uses anyway. So
why apply dirty workarounds?
Efail is not a GPG bug, so why should it be fixed in GPG? Sure, GPG can
be more picky and throw an error instead of a warning, but please do not
corrupt files that will be around much longer than any buggy mail client!
 Diego

@_date: 2018-11-05 21:50:28
@_author: NdK 
@_subject: OpenPGP key verification + legal framework 
IMVHO You're just (badly) reinventing X509.
Then, again IMVHO, you should have registered in a country that's
supposed to *remain* in the EU...
CACert does have quite a lot of notaries, but they're still not enough
for an average user: I made a 600km trip just to meet one. It's simply
not good at the economic level: I can buy a smartcard with an already
legally recognized and binding signature for 3y at 50? (IIRC).
Moreover, if you just verify the mail address you're not identifying the
user, just "someone that currently controls that address". The same can
of worms faced by LetsEncrypt with DV certs.
 Diego
