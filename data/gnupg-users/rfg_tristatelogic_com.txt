
@_date: 2014-10-13 12:14:23
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
I have a program that will frequently need to store modest-size
chunks of of data on disk, perhaps 1-4kB per chunk.  The data is
sensitive, but not ultra top secret.  I would like to make a
reasonable effort to keep it from prying eyes.  After being stored,
the data will later on need to be read back in, perhaps by the
same program or perhaps by a different one, and will then need to
be decrypted.
I don't need anything facy here.  A symmetric-key encryption/
decryption would be just fine, I think.  Mostly I just need
something that will be simple for me to implement in my program,
even though I am by no means knowledgable about cryptography
generally.  (Most of what little I do know has been garnered from
with Wikipedia.)
So anyway, last night I spent a lot of time googling to try to
find some simple code examples which would illustrate Libcrypt
being used for simple tasks, such as the one I've just described,
but I didn't find any.  I also looked over the Libcrypt manual,
which promised near the start that there were some programming
example near the end, but I could not find those either. :-(
(In fact, a search of the whole document for the word "example"
turned up only one hit, i.e. on the part in the very beginning of
the manual where later examples were promised.)
So, can anybody point me at some _really_ simple examples of
how to use Libcrypt to so simple things, e.g. encrypt a block
of data and then decrypt it?
P.S.  On my FreeBSD system, un-updated as it may be, there seems
to be a crypt(3) in the standard C library.  I suppose that I might
just be able to use that, but here again, I'm not finding any simple
coding examples for that either.  And more importantly, the man page
for it gives this omnious warning:
     All routines are designed to be time-consuming.  A brief test on a
     Pentium 166/MMX shows the DES crypt to do approximately 2640 crypts a
     CPU second and MD5 to do about 62 crypts a CPU second.
Fortunately, I *do* have something that's a bit faster than A Pentium 166
:-) but I'm still rather baffled by the meaning of the phrase "designed
to be time-consuming" in this context.  I understand that encryption
generally is intended to be very time-consuming FOR AN ATTACKER WHO
DOESN'T KNOW THE KEY, but the quote above does not clarify that this
is the only party for whom use of the FreeBSD libc crypt(3) function
will be "time-consuming".  (If it ends up being time consuming *for me*,
then this could be real a problem.)

@_date: 2014-10-15 14:45:35
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
In message <543E3C8E.3030200 at digitalbrains.com>, I'm sorry.  It appears that I did not explain my requirements sufficiently
well for you to be able to immediately grasp that what you just proposed
is absolutely not a viable solution in the context of my application.
Let me try again.
I have a program.  It's written in C.  I intend to distribute it, in
binary form only, to other sites.  I do not and will not control how
any fo the local disks are configured at those other sites.
I think that you are making this far more complex than it has to be.
I stated what I needed to do, and it is quite simple.  The program
must write some small bits of data to a local disk. Ideally, these
small hunks of data should not be _easily_ decypherable.  The program
will later read the data back in, decypher it, then use it.
There *are* simply solutions to this rather trivial and common problem.
If worse comes to worse, I will cook up something rather rudimentary
myself.  But I would prefer to use something stronger.  I had hoped to
get some help with this rather simple task here, but obviously I hoped
in vain.
I should say that it seems to me rather entirely bizzare, preplexing,
and downright silly that *somebody* went to the trouble to write a
detailed, 134 page (PDF) manual for the library, and yet prospective
users of the library, such as myself, cannot find even a single modest,
real-world example of how to use the bloody thing.
If there exists a universe in which that makes sense, I'm obviously
not in it.
OK.  Swell.  Ignoring, for the moment, the personal condescension
implicit in your comments, and accepting your premise that I should
be using some ``higher level'' library, the question remains:  Which
I understand that you may have been attempting to be helpful, and for
that I am grateful.  However you've utterly failed to provide me with
any useful or actionable information.
P.S.  I'm still looking for the "examples at the end of the manual"
which were explicitly promised in Section 1.1 ("Getting Started")
of the Libcrypt manual.
Was that promise just inserted into the manual as some sort of cruel
joke, you know, to get naive people like me to waste a lot of time
looking for examples that aren't even actually in there?
If so, then it is working perfectly.

@_date: 2014-10-16 16:21:26
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
I'm sorry that I could not reply right away.  I was called to other
In message <8738aomjb1.fsf at vigenere.g10code.de>, I believe that I do indeed already have "basic" knowledge of the subject.
I understand why padding may be required, I'm not sure what you mean
by "IV", and as regards to the "mode", I think that I specified in my
original post that symmetric key would be just fine for my purposes.
(Did you mean something else by your use of the term "mode" in this
context?  If so, what?)
Ah!  Thank you.  Now *that* looks like it may in fact be a useful and
actionable bit of information.  I did not know about that alternate
library until just now.  I confess that missed it, when looking at this
  because it wasn't immediately obvious that this was even a library, as
opposed to a program.  (Even though this is a page decicated to listing
"libraries" I guess I was thrown off by the first entry on that page,
which appears to refer to something which I gather is most likely a
program, and not a library at all.)
I'm OK with "extra baggage".
The key will be embedded in the compiled binary of the program I'm building.
I hope not.  I want this simple.  There should be no pass phrase... just
a pre-manufactured key.
As I said, syymetric key will be just fine for me.  I most certainly
*do not* need public key cryptography.
And while we are on that subject please allow me to point out what may
perhaps be a deal-breaker for me when it comes to the GPGME library.
I'm looking at this page:
  and I am *not* seeing any mention of any symmetric key stuff.
Was that stuff just not considered sufficiently important to put interfaces
for it into GPGME?  (Correct me if I'm wrong, but there _is_ some syymetric
key stuff within Libcrypt itself, right?)
As per above, I don't know what you are referring to.
I will assume so until advised otherwise.
Did you mean to say "threat model"?  I'll assume that you did since,
in a subsequent posrt, I see that Peter Lebbing also asked about my
"threat model".
So, I'll do my best to try to respond to that question.
As I said at the outset, my current intention is to have/build a compiled
binary program which will be distributed to many sites and many parties.
(In fact it will most probably be available for free download.)  The
program in question will, when properly installed, provide some useful
functionality within the general "security" space.  (Anybody who googles
me for about 10 minutes will probably uncover my particular area of
interest, but that's not really important now.) The program's actions
and decisions will be driven by a set of external data tables, which
will be stored on disk and which will change over time.  The program
itself will be proprietary, i.e. I will not wish for either customers
or competitors to have ridiculously easy time determinding either what
it does, exactly, or how it does it.  More essentially, I will not want
it to be ridiculously easy for ``attackers'' to figure out what the
program does, exactly, or how it does it.  If they do, then the effective-
ness of the program itself will be rendered... in the words of Ronald
Regan...  "impotent and obsolete".
My assumption from the outset is that *any* seriously determined customer,
competitor, or attacker *will* be able to disassemble the program, recon-
struct its logic, and thus figure out entirely what it is doing and how
it is doing it.  I further assume that this possibility will not by
any means be limited to nation states.  (Note that under this scenario,
it would not even be necessary for the attacker to _completely_ disassemble
and reconstruct the entire logic of the program in order to see what it
is doing and how it is doing it.  If disassembly and analysis only went
deep enough to obatin from the program the embedded decryption key that
it uses to obtain the plain text version of the on-disk data file, then
this would be enough, by itself, to fully compromise the program, because
the data file, in plain text, would pretty much give away what the program
is doing and how it is doing it.)
An alternative attack which would not involve disassembly of the compiled
binary would be to for the attacker to simply decrypt the associated
on-disk data file.  I mentioned just above, the plain text of the data
file would itself pretty completely give away both (a) what the program
is doing and also (b) how it is doing it.  It is this precisely and only
this alternative attack scenario that I am keen to avoid, or at least
render equally as difficiult, or more difficult than the disassembly
approach (which itself is not really that hard).
In short, I do not need iron-clad or world-beating cryptography here.
Dissasembly of the binary will always be possible, and I cannot stop
that.  I just want some encryption applied to the data file which will
make the disassembly route the _easier_ route to breaking into the logic
of the program.  (I also do not want to use something so lame, in the
way of encrption, that I'll embarass myself in front of the potential
users of the program.)
I suspect that this may be the source of what I sense is a bit of a
disconnect between myself and other participants on this maling list,
perhaps including, but not limited to you.  I understand that
cryptographers generally are _not_ in the habit of producing tools
or methods that are ``just good enough'' for applications such a
mine, but rather are constantly striving to produce tools and methods
that are sufficiently iron clad to be entirely impenetrable, even to
nation states.  That is of course laudable, and as events of the past
year have shown, desperately needed by all of us, e.g. to protect our
privacy from extraordinarily well-funded adversaries.  But for this
one application, for the reasons I've described above, I really do
just need soething that is only just good enough.
Books are good.  I like books.  Schneier's are especially good.  But
I'm not looking for a course on cryptography generally.  I'm looking
for _specific_ information about how to use _your_ libraries, very
specifically.  Some modest examples would help.
Unless Schneier has written a book which describes the interfaces and
semantics of either Libcrypt or GPGME, his books won't help me.  But
you still could... with some trivial examples.
That appears to be the case.
Don't get me wrong.  I am quite completely sure, even from just briefly
skimming the manual, that it is, in the tradition of all GNU manuals,
well written, comprehensive, and exquisitely detailed in its description
of its subject matter.  Unfortunately, I'm sad to say, I just don't have
the time right now to read and comprehend 134 pages of technically dense
material, most of which is surely going to be new to me.  I'd enjoy
doing that, but I have a product to build.
Given my time pressure, I latched on to the following statement, which
appears in Section 1.1 of the manual:
   "Experienced programmers might want to start looking at the examples
   at the end of the manual, and then only read up those parts of the
   interface which are unclear."
As it happens, I do in fact qualify as an "experienced programmer", and
thus I had hoped to be able to do as advised (by the above quote).
That would almost certainly be helpful, however please don't feel in any
way obliged, either to wait until you can generate and perfectly format
some examples within the PDF, or INFO, or HTML versions of the manual,
or until you have time to develop some really excellent examples of how
to use each and every feature of the library.  Rather, I would be very
happy if you could just post a short example here, on list, and in plain
text, of a simple code snippet that would do just the one small thing
I need to have done.  (You can always go back and fix the manual at a
later time.)
Thank you for your fine library, for the generally well-crafted documen-
tation, and for your attention to my own unque and somewhat unusual use

@_date: 2014-10-16 16:44:21
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
In message <544005E3.2040901 at digitalbrains.com>, Please see the other reply I just now posted in this thread.  I believe
that should completely clarify the "threat model".
OK, to clarify, I made my first ever posting to this list.  In it I asked
(in effect) "How can I use tool X to achieve goal Y".  In your reply,
you said, in effect, "Using X is too complicated" and you suggested no
other alternatives.  I was left with the distinct impression that you
had concluded that I posses neither the requsite knowledge _nor_ even
the capacity to learn how to apply or use Libcrypt in any way that might
be useful to me.
I might be ignorant, and indeed, as I already myself confessed, I *am*
rather entirely ignorant, both of the deep underpinnings of modern
cryptography generally, and of Libcrypt's public interfaces specifically.
However my feeling is that anyone who jumps to a conclusion, based on
that, that I either cannot learn or cannot be taught is doing me a
profound disservice.  (And yes, I do tend to take such slights personally,
perhaps improperly so, particularly when it is late at night, when I am
tired and frustrated, e.g. by missing bits of documentation, and when
I find myself still in need of a solution, to which I seem to be comming
no closer.)
Apology accepted.
I construed and summarized your entire reply as being basically equivalent
   "You {Ron Guilmette} cannot use tool X to achieve goal Y."
In the absence of any suggestions, on your part, for alternatives, this
did indeed seem like a rather dismissive brush off, and most probably a
personal one.
If that was indeed not at all what you meant, then I also offer _my_
apology, i.e. for having misconstrued.

@_date: 2014-10-16 16:54:47
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
In message <54401557.1030105 at sixdemonbag.org>, This is helpful.  Very much so.  Thank you.  I will quite certainly
look into that other library.
(I am not at all ashamed to admit than in the realm of crypto generally,
I *do* most probably qualify as a "newbie", or perhaps at best a Padawan.)
Yes, I believe that I saw some public comments somewhere to that effect,
i.e. the part about DES being not-so-hot-anymore.
OK.  Thanks!  I got it.  So just as a literal reading of the man page
would suggest, the thing is indeed slow for *everybody* and not just an
That slowness is sure to be helpful in the context you elaborated, but
for my purposes it would definitely be entirely unhelpful.  Thus, as
you've helped me to understand, I best bet is to steer clear os using
that one within the thing I'm building.
Thanks again.

@_date: 2014-10-16 20:33:41
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
In message <5440196B.8070808 at sixdemonbag.org>, See my other post from today.  Yes.  I know.  I understand that my program
will be decrypting the data block, and that my program can be disassembled,
and thus, the lock effectively picked.  And I most assuredly do understand
that such disassembly & analysis doesn't even involve, as they say "rocket
Fortunately, I am not attempting to defend the data from nation states,
nor even from anyone who is seriously motivated, i.e. to do the disassembly
and subsequent analysis.  I just want to keep out those with ernest, but
not too intensely motivated curiosity.
Yes, and yada yada yada.  I get it.  In this case, breaking the security
wouldn't even be that complicated.  Just disassemble the bloody thing,
look for the routine that does the decryption and see what key is being
passed to that.  Easy.  I cannot prevent _any_ of the numerous scenarios
along these lines, and I'm not going to be trying to do so.
Security is all relative... relative to what you are trying to protect.
I just read this story the other day, which I suspect many others on
this list probably also saw, in one place or another:
   Do we think that everybody we read this story immediately threw out their
old combination lock safes?  No, of course not.  Nor has that become even
advisable in all cases.  If you have 20 full-sized bars of gold in your
combination lock safe, then yea, you might want to start thinking about
alternatives.  But if attackers only hope to pry from you your bottle of
Chivas Regal 25 and your favorite Reggie Jackson baseball card, then they
aren't going to bother _manufacturing_ one of those devices described in
the above news story, let alone babysitting it for up to four days while
it tries every combination until it gets the right one.
Alas, I don't have anything of equivalent value to a gold bar to protect.
Just some rather modest secrets.
I know.  I understand.  My program will be hackable.  I understand the
threat, I understand that it is real, and I have already accepted it as
part of the price for doing things the way I want to do them.  Now I
just need something that doesn't make the threat any _more_ real, in
practice, than it already needs to be, based on what I want to do and
how I plan to do it.  And I prefer not to invest too much time & energy
into this part of the project, precisely because I do know that the
program itself will always be hackable, e.g. to tease the key(s) out
Perhaps I understated my knowledge level, thereby leading you to the
conclusion that I have inadequate understanding of the risks inherent
in my plan.  However I do believe that I do understand those risks,
and that I've made an informed engineering decision to accept them, but
do not wish to make them any worse than they already need to be, based
on the plan (i.e. of embedding the decryption, including any and all
necessary keys, direcly into a binary which will then be released to
any old Tom, Dick and Harry).  I understand that this sort of thing
would never be recommended by any self-respecting cryptographer in this
day and age, because of the obvious and serious insecurities that would
thus be created.  However as I say, I am _not_ protecting anything as
valuable as gold bars here.  Just some modest secrets which I would
prefer that people not have unless and until they apply some talent and
at least a little ernest elbow grease to obtain them.
That is indeed appearing, more and more, as a self-evident truth.  But
I thank you for stating in plainly.
Thank you for the courteous way in which you've made this entirely salient
point, i.e. that I'm perhaps not the intended audience for the libcrypt
Quite right sir.
Believe me, when posting my question, I went out of my way to make no
pretense at being any sort of a crypto guru (which I am clearly not).
I selected the (technically) lowest-level list I could find, relating
to GnuPG and its libraries before posting my question.  If there had been
a libcrypt-for-newbies or libcrypt--for-dummies mailing list, I would
have posted my original question(s) there instead of here.  But this
list seemed to be the one most likely to be tolerant of non-guru-level
questions, so I posted here and hoped for the best.  I was thus perhaps
understandably dismayed when, after waiting a day, the only response I
got seemed to be along the lines of "This is too complicated for you".
That was, to say the least, not really satisfying.  But now I've gotten
several responses with useful pointers to other libraries that might
better suit my needs, so I'm a happy camper again.

@_date: 2014-10-16 20:48:26
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
In message ,
As stated in my other replies:  Yes, I know.
P.S.  Whereas at the outset of this thread, with all due and proper
modesty, I disclaimed deep knowledge of most things crypto, I am not
entirely unfamiliar with the tools, including gdb, that are available
for dissecting compiled code.  Indeed, once upon a time I worked on
such tools professionally.

@_date: 2014-10-17 11:38:42
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
In message <54409469.9090504 at sixdemonbag.org>, Yea, I'm starting to get that.
Thank you sir.
Not to disagree with your way of categorizing threat levels, but won't
those Zarbnulaxians have quantum computers which render all of our
current crypto stuff impotent?
I think you may want to add a middle category to your threat taxonomy:
1)  Motivated thirteen year olds.
2)  The NSA.
3)  Space aliens from Zarbnulax.
I suspect that most here would be satisfied with provably strong defenses
against 1 and 2.  (And, as I've mentioned, for my own rather specialzed
project at the moment, a decent defense against only category 1 will
be sufficient.)

@_date: 2014-10-17 11:46:00
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
In message <5440E5B8.4090309 at digitalbrains.com>, OK.  Yes.   I stand corrected.
However I think that you may understand (now) that from my perspective,
that was not a real alternative.  From where I was/am sitting, it was
almost as if I made a post saying that I needed to protect my money
and you told me to go and buy myself a bank vault.
In any case, I do apologize for my admittedly short-tempered response.
I've been cranky of late, for reasons having nothing to do with either
you or your response, and I'm sorry.

@_date: 2014-10-17 16:45:43
@_author: Ronald F. Guilmette 
@_subject: Libcrypt examples? 
In message <5441783E.1070108 at sixdemonbag.org>, Well, I'm damn glad I asked then.
I *had* invited a friend of mine from Zarbnulax over this weekend.
We *were* going to fry up some steaks, have a couple of beers, and
try out his new computer on a 256-bit cipher, but I'm emailing him
now and telling him that the barbecue is off for now... both our
little one, and also the earth-sized one.
Can't speak for anyone else, obviously, but I promise to keep my hinges
Well, you know what they say... You can't prove a negative. :-)
I'm with you.  I'll refrain from mentioning Bleep.Bleep.Bleep in
future. (I suspect that we're all gonna have our hands full with
looney Ebola conspiracy theories for the next couple of months at
least anyway, so yea, no need to add more fuel to the fire.)

@_date: 2014-10-19 12:21:39
@_author: Ronald F. Guilmette 
@_subject: Wind River 
I just saw this news story yesterday, and I wasn't sure if folks
around here already knew about it or not, but since the subject
of silly export restrictions had come up on this list recently,
I thought that I should share...
