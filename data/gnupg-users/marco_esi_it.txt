
@_date: 2001-08-20 11:25:01
@_author: Marco Colombo 
@_subject: multiple signing keys 
I need a little suggestion, I've read the FAQ but wasn't able to figure
out an answer.
Last year I created a key pair, with the only purpose of signing the RPMs
I make. I don't use it for e-mail, or other applications. At that time
I dediced to have the key expire in 2 years.
Now, I want to create a second key, and start signing new RPMs with that.
I'd like to know what is the best way to do that. I can think (being
a really naive user of GnuPG) of two ways:
- create a completely new key pair, and just stop using the old one;
- create a new signing subkey, and start using it.
My needs:
- I want the signature of a RPM to expire - the only way I'm aware of
  is to have the signing key expire;
- thus, once a year, I have to generate a new signing key;
- I want the RPMs to be signed (mostly) for the sake of an auto-upgrade
  program, which is able to validate a signed package (rpm had direct
  support for gpg signature, all you need is to import the public key
  of the signing entity on the keyring of the rpm user);
The first approach (creating a new key pair every year) has the
disadvantage I have to redistribute a new public key. While this is
still somewhat accettable (I can even think to automate it by
creating a RPM which installs the new key on the target system, this
RPMs being signed with the OLD key, of course), now that I'm less a
dumb GnuPG user (well, I've read the FAQ, at least), I'm seeking for
a better solution.
With the second approach, I should able to create signing keys that
espire, but with no need to redistribute a new public key every year
since the master signing key won't expire.
So, I think I need to:
- modify the expire date of the master key (with --edit-key);
- create a subkey (DSA, I suppose);
- start signing RPMs with the new key.
I've made some tests, and now I've got a few questions:
a) I believe I need to re-export the public key, since the expire date
   of the master key is changed. But I need to do this only once (now
   the expire is set to never). Is it true?
b) what it the correct way to select the signing subkey?
   --default-key  or -u  ?
c) do I need to generate a new encryption subkey? (I guess not)
d) is it correct that I can just wait for the old keys to expire, and
   then just delete them from my keyring, with no need to revoke them?
   If I understand well, revoking a subkey will just add something to
   my pubkey saying 'this  is revoked', but if the key has expired
   it's completely useless. I can remove it from the target public keyring,
   but that's just cleaning up. Is there a way with gpg to remove expired
   keys from the keyring (or does it do that automagically)?
Do you have other suggestions?
[ Please Cc: me since I'm not subscribed ]

@_date: 2001-09-06 15:32:01
@_author: Marco Colombo 
@_subject: multiple signing keys 
Thanx for your answer, Alex.
I see. So, generally speaking, it is not advisable to remove expired keys=
since they can be un-expired later. But if I delete the (private) key,
no one can un-expire it (not even me), true?
An example:
- I create a signing key, with expire 2002-01-01, and export it to the
  target hosts;
- On 2002-01-01, it expires.
- On 2002-01-04, I change the expire date, and sign something with it.
- I DO NOT re-export it to targets.
Do target hosts verify the signature as good or bad?  If it is good,
then I see the need to revoke the key, but then I don't understand what
'expire' means. If it is bad, then I guess I need to export the key
again to host targets. But if an attacker is able to do that
(and here the keyring on the target hosts is root's one) he can add
ANY key to the keyring.
      ____/  ____/   /
     /      /       /			Marco Colombo
    ___/  ___  /   /		      Technical Manager
   /          /   /			 ESI s.r.l.
 _____/ _____/  _/		       Colombo

@_date: 2001-09-07 13:41:04
@_author: Marco Colombo 
@_subject: multiple signing keys 
and
I know. But the key is used *only* for RPM signing. I don't really care:
there shouldn't be any message at all. Even the public key actually never
"goes public": it lives only in root's keyring on target hosts, and it
is placed there by hand - something like:
gpg --export -a  | rsh root gpg --import
 key
Oh, ok, now it makes perfect sense to me. That was the missing point.
I need rpm -K to fail when the key expires. I'll try and find a workaroun=
if needed.
So the signature is "good", but to be considered "invalid". I need to
check what rpm -K really does, if that happens.
Ok, I need to make it clearer. The application here is to protect the
target hosts, which use an automated update system, so that only signed
software gets installed. If an attacker is able to tamper with root's
keyring on a target system, he can already do any kind of damage, and
besides that, he can replace or add any (public) key. After that he's
able to have any software installed. The point is that he doesn't need
the private key at all.
I was under the impression that setting an expires helps if the key
is compromized, somewhat limiting the damage (in time). But if one is
able to change the expire date, it doesn't really fit the job.
If the attacker has the private key, he can change the expire date and
make other (valid) signatures with the same key. Or am I still missing
      ____/  ____/   /
     /      /       /			Marco Colombo
    ___/  ___  /   /		      Technical Manager
   /          /   /			 ESI s.r.l.
 _____/ _____/  _/		       Colombo
