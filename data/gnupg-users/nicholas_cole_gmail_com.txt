
@_date: 2007-08-09 07:36:21
@_author: Nicholas Cole 
@_subject: OpenPGP and usability 
In my experience, this is one of the biggest hurdles.  One of PGP's
problems from the beginning is that words like "sign" and "valid" have
always been used in several different contexts, and then introduced
all of them to the user at once.
What the (beginner) needs to be told is that, if he wants to tell his
software to use a particular key, he should sign (validate / mark as
genuine) it.  If he is at all unsure about the key he needs to check
the Fingerprint with his contact.  And that's all.
(As an aside: I note that all these social networking sites have a web
of trust of sorts, so the concept is not impossible to present to the
user in a very straightforward way).
Other concepts should be intoduced as features that help larger
organisations, not as something that the user needs to understand
before he even gets started.
The original PGP software also made the mistake of saying this like (I
forget the exact wording now) "This is a GOOD signature from an
Invalid key", which is just unhelpful to the new user.  What it meant
to say was "You have not validated the key that signed this message -
it may or may not be genuine." Or better words to that effect.
Best wishes,

@_date: 2008-07-31 21:30:10
@_author: Nicholas Cole 
@_subject: batch create DSA2 
Dear List,
A quick question about key generation using --batch --key-gen.
Am I right using the option --openpgp, a DSA2 key can be created just by using
Key-Type: DSA
and a key-size longer than 1024.  I.e. there is no specific Key-Type
for DSA2 keys?
Or is it the case that if DSA2 keys are enabled, even a 1024 length
key will be DSA2 (and use new hashes etc)?
Best wishes,

@_date: 2008-08-06 13:05:54
@_author: Nicholas Cole 
@_subject: --allow-multiple-messages in gpg 1.4.9 
I don't know if this is a bug, or my own misreading of the
documentation, but --allow-multiple-messages doesn't quite seem to do
what the documentation leads me to expect:
Allow  processing  of  multiple  OpenPGP messages contained in a
single file or stream.
If I create a file with two armored openpgp signed bocks, only the
first one appears to be processed by gpg, even with this option
provided.  The second is silently ignored.
The option appears to be ignored whether or not I read from the file
or provide the blocks on stdin and whether or not I use the explicit
--decrypt option.
Best wishes,

@_date: 2008-08-07 08:37:26
@_author: Nicholas Cole 
@_subject: --allow-multiple-messages in gpg 1.4.9 
The issue I was reporting was that this option doesn't seem to do
anything at all, at least for armoured messages. I haven't done any
further testing.  Are you saying that this is a dummy option?

@_date: 2008-08-07 18:36:45
@_author: Nicholas Cole 
@_subject: --allow-multiple-messages in gpg 1.4.9 
Thanks for the clarification.
I wonder if it would be useful if there were a flag that would tell
gpg to raise an error if it encounters data that it can't understand
or is ignoring.

@_date: 2008-02-19 12:28:17
@_author: Nicholas Cole 
@_subject: Corporate use of gnupg 
GPG does not implement ADK.  I think that, historically, it seemed too
much like the kind of key escrow systems that governments have from
time to time talked about wanting, although clearly there is a
I know that ADK can be circumvented by a determined attacker, but it
strikes me as a useful feature, and I have never quite understood the
opposition to it.  It would have made encryption more palatable in
corporate settings, which surely would have been a good thing!
But I'm not an expert, and I'm probably missing a point somewhere...

@_date: 2008-02-19 14:19:18
@_author: Nicholas Cole 
@_subject: Corporate use of gnupg 
Just to address the original point of the thread, though, could you
not use sub-keys to achieve the most of the effect you want?
Have everyone share an encryption/decryption subkey, but have their
own separate signing keys.  The disadvantage would be that anyone in
the group (ie not just an administrator or the like) could decrypt
anyone else's email - but in many settings that might be acceptable or
even advantageous.

@_date: 2008-02-19 14:54:07
@_author: Nicholas Cole 
@_subject: Corporate use of gnupg 
On Tue, Feb 19, 2008 at 1:23 PM, David Pic?n ?lvarez
This just simply isn't true.
Putting a line in a config file may be fine for internal mail, but
does nothing to help you to be able to decrypt mail sent from outside
your organisation.  It also locks everyone into using gpg - I thought
the whole point of gpg / opengpg was to be inter-operative.
Secondly, there might be any number of reasons why a user might not be
able to give you access to a key.  He might be incompetent, he might
be unexpectedly ill or worse.  And so on, and so forth.
But my real point is this: gpg in most areas says "This is a tool.
Your threat models will vary, and we give you a tool which you can
deploy".  But in the area of ADK, even when for years people have said
on this list and elsewhere, "ADK would help with the
threat/organizational model we have", GPG refuses to help.  "alter
your config file" solves (at best) half of the problem.
There may be very good technical reasons why ADKs are a bad idea, but
I've never seen them explained.  There was, I know, an attack on PGP
which relied upon them a while ago, but IIRC that bug was easily
Best wishes,

@_date: 2008-02-20 00:18:30
@_author: Nicholas Cole 
@_subject: ADKs (was: Corporate use of gnupg) 
Dear David,
Thank you for your long and clear reply.  I take the point about the
patent issues completely.
However, just for a moment assuming that the patent issue could be
solved in a way that would not upset PGP...
OpenPGP has done well in 'closed' environments (as you define them),
but has always stumbled in more potentially open settings.  This has
always seemed to me a huge shame.  There seem to be at least some
settings where ADK makes sense and would encourage the use of PGP.  Of
course, it is simply a 'request', but it is a reasonable request and
(as far as I can see) a much better way to handle these issues than
saying to people 'please always encrypt to my corporate key manually'.
The point about ADK being something that can be circumvented is not, I
think, a real issue.  It has always seemed to me that ADK is something
much more akin to all the other preferences already stored on a key -
a request to PGP-compatible programs to encrypt data in a particular
Since it would encourage the use of encryption in environments where
it is not currently used, I would see it as nothing but a good thing.
Although, of course, if there really are patent issues, it can't
happen, but perhaps PGP Corp would/could be flexible on this point.
Best wishes,

@_date: 2008-03-02 10:00:56
@_author: Nicholas Cole 
@_subject: Signing people with only one form of ID? 
On Sat, Mar 1, 2008 at 11:46 AM, Richard Hartmann
Well, let me attack this problem from another position.  :-)
I think we need to remember what the purpose of a signature on an
OpenPGP is.  It is there, first and foremost, to tell the computer
"Yes, you should be happy encrypting to this key", for the purpose of
avoiding Man in the Middle attacks.
(And - as an aside - the purpose of OpenPGP is to make email and other
electronic communication on the internet more secure).
One of the early mistakes I think the _documentation_ of PGP made was
to suggest that one day we might all live in a world where keys would
be selected automatically from keyservers, with no effort on the part
of the user, and with almost total security.  It is with such a dream
in mind that people set up key servers, go to key-signing parties and
the like, and start worrying about how many passports they need to see
before they sign a key.
Actually, such a world is probably not possible. But for private
users, most of the time, the most important thing is still to check
the fingerprint of the key with the intended recipient of secure
communications.  It is, actually, simple.
But that does not mean the web of trust is useless - far from it.
OpenPGP lets you represent all sorts of trust models: you can choose
trust the root key of a company, university or computer software
project, and thereby "trust" all of the people involved in that
organisation, for example.
But I've never been convinced that the search for the "right" level of
id to demand before signing a key is right, nor that going to random
keysignings is very useful.
OpenPGP can only represent "trust" that already exists.  And the truth
of the matter is that if I have just met a chap in a bar, I am
unlikely to "trust" him to sign any more keys for me, no matter how
much he tells me he always looks at passports.  So even if I signed
his key, I probably wouldn't then trust him to sign other keys that I
depended upon.
Sorry - that was rather more than I meant to write.  Take home
message: use OpenPGP to represent "trust" relationships that make
sense for your situation, and don't worry about an ideal standard,
because one doesn't exist, shouldn't exist, and probably couldn't ever
exist.  ;-)
(I am reminded of this cartoon:   )

@_date: 2008-10-01 12:32:38
@_author: Nicholas Cole 
@_subject: Probable cause of bad signature? 
I've just noticed a curious signature on my own key - apparently one
that I made myself a few years ago (2004), but which --check-sigs is
now listing as "bad".  It is the only signature on the key showing as
bad.  It probably doesn't matter at all, but I'm still curious to know
what might have caused it.  Does anyone have any ideas?  The signature
is class 10.  All of the other self-sigs seem to be fine.
Best wishes,

@_date: 2008-09-25 21:30:08
@_author: Nicholas Cole 
@_subject: OT: RFC 3156 question 
Apologies for a slightly OT question, since this is not gpg-specific,
but I thought it would be a good place to ask.
Section 4 of RFC 3156 (PGP/MIME) says:
"Before OpenPGP encryption, the data is written in MIME canonical
   format (body and headers)."
Am I right that an encrypted message should like:
with the part marked by '&' the data that is actually to be sent to
gpg to be encrypted?
Best wishes,

@_date: 2008-09-29 21:17:47
@_author: Nicholas Cole 
@_subject: guessing GPG_AGENT_INFO 
gpg-agent can tell whether gpg-agent is running, but if the
environment variable has not been properly set, there seems to be no
way to set it without killing the gpg-agent process and starting it
Is there any way to correctly 'guess' the settings for the
GPG_AGENT_INFO variable (for the case where gpg-agent has been called
with --use-standard-socket)?
It is very slightly frustrating that gpg-agent can report that it can
connect to a gpg-agent daemon, and then be unusable when gpg tries to
call it.... :-)

@_date: 2008-09-30 09:29:09
@_author: Nicholas Cole 
@_subject: guessing GPG_AGENT_INFO 
============================== START ==============================
Fantastic, Warner.  Thank you!

@_date: 2009-05-04 11:16:14
@_author: Nicholas Cole 
@_subject: New results against SHA-1 
How does GPG cope if two keys on the keyring have the same FP?  AFAICS
that would make things very difficult for most of the front-ends,
especially if they had been relying on the uniqueness (in practice) of
the FP to specify which key to operate on.

@_date: 2009-05-04 23:33:35
@_author: Nicholas Cole 
@_subject: New results against SHA-1 
On Mon, May 4, 2009 at 10:01 PM, John W. Moore III
Well, I'm just not that lucky! Or is that unlucky?  It is possible,
though, that someone, somewhere will be.  If the story reported
earlier in this thread is right, someone already has been.
Wouldn't a way around some of the (unlikely) problems be for gpg to
give each key on the keyring a guaranteed unique number (guaranteed,
for example, to be unique on that keyring), and allow users and
front-ends to specify a key by that number?  This might even be as
simple as a number generated by pre-pending the number of the key in
the standard --list-keys output to the fingerprint.

@_date: 2009-05-25 18:54:20
@_author: Nicholas Cole 
@_subject: RSA+RSA is now the default 
I completely agree for creating keys, for which there is the
batch-file approach.  Adding subkeys is another matter.
And while I have never written anything that 'lives in sin' in the way
you describe, I was just pointing out that if Warner was assuming such
things exist (I am sure they do) then there could be unfortunate
consequences as a result of the way this (entirely proper) change has
been made!

@_date: 2009-11-28 17:54:12
@_author: Nicholas Cole 
@_subject: GnuPG private key resilience against off-line brute-force attacks 
A very interesting website.  I followed the links, and found this document:
It seems that the NSA is moving away from RSA/DH etc. cryptography,
and now "only" approves their use for secret level material.  They are
instead pushing elliptic curve cryptography.  I hadn't realised that
there was such pressure to move away from traditional key exchange.
Is this about the fear of quantum computing, or something else?
EC in gpg is still some way off, it seems.

@_date: 2009-09-15 14:42:20
@_author: Nicholas Cole 
@_subject: Hash algo for signing - documentation 
Hi all.  This is a query mostly for my own interest, but I think it
might point to a change in the documentation being required.
I was slightly confused by this message
David suggests (as I read it) that an RSA key created with
--cert-digest-algo sha256  will continue to use sha256 whenever it
signs keys, whereas the documentation implies that you would have to
specify --cert-digest-algo every time a key is signed.  How does an
RSA key choose a hash algorithm for this purpose?
It might also be worth noting that (if I read
correctly) this option does not control what DSA2 keys use.
Or have I misunderstood?
Best wishes,

@_date: 2009-09-15 22:07:12
@_author: Nicholas Cole 
@_subject: Hash algo for signing - documentation 
Dear David,
Thanks for, as ever, excellent clarification.
Best wishes,

@_date: 2010-06-28 16:53:30
@_author: Nicholas Cole 
@_subject: Using gpg2 without pinentry? 
Can you start gpg-agent separately - ie. before the passphrase is
needed.  If so, you should be fine, I think, if I have understood your
problem correctly.
Best wishes,

@_date: 2010-06-28 23:35:44
@_author: Nicholas Cole 
@_subject: Using gpg2 without pinentry? 
Do none of the gpg-agent options such as:
       --xauthority string
       --keep-tty
       --keep-display
help in this kind of case?

@_date: 2011-04-21 12:09:50
@_author: Nicholas Cole 
@_subject: A better way to think about passwords 
Isn't the real problem that *any* policy (suggested or enforced)
reduces the complexity of guessing a password?  The moment you start
saying "pick three words separated by a space or dash" or "pick eight
random letters" or the like you make it easier to attack a password.
My employer insists on passwords that meet a defined and public set of
criteria.  I'm sure that in theory that actually makes them easier to
crack, since many millions of possibilities can be discounted.
In short: don't force a particular strategy on your users.  Much
better to explain to users the general problem, and then leave it up
to them to pick a password.

@_date: 2011-04-22 15:04:33
@_author: Nicholas Cole 
@_subject: A better way to think about passwords 
You know, I worded the above poorly, and for that I have only myself
to blame for the fact that you jumped on the obvious objection to a
complete free-for-all.
It probably is wise to have some sort of control in place to prevent
very stupid passwords.  Even in 1997 my university had a system in
place that prevented the use of dictionary-words (including Latin and
- IIRC - Greek words) or passwords that were merely dictionary words
with a number added at the end.
What I meant was rather this: there are several strategies that
produce good passwords.  Teaching them requires (at some employers) a
30 minute course or the reading of a web page.  However, forcing any
*particular* strategy onto users will dramatically reduce the time it
takes to guess a password, since knowing the strategy reduces the
number of possibilities dramatically.
I thought we were talking about this particular proposal (the "use
three dictionary words" one) and my point was that if everyone were to
use this its security would be dramatically reduced.  However, as one
of several strategies available to those selecting passwords, it
probably isn't a bad one in and of itself.

@_date: 2011-08-11 15:49:21
@_author: Nicholas Cole 
@_subject: Trust model - trust level 1 and 2 
Dear List,
Is there any difference in the standard trust model between marking a
key level 1 ("I don't know or won't say") and level 2 ("I do NOT
Best wishes,

@_date: 2011-08-11 21:24:18
@_author: Nicholas Cole 
@_subject: Trust model - trust level 1 and 2 
Thanks, David.  I had wondered if there was some difference in the way
they interacted with some corner case or with trust signatures and the
like, but since I couldn't see any documentation I assumed that they
had the same practical effect on the way gpg calculates key validity.
Best wishes,

@_date: 2011-08-26 22:18:11
@_author: Nicholas Cole 
@_subject: Signing multiple keys 
Dear Doug,
I don't mean this in a negative way, but I struggle to see the point
of such challenges.  The whole point of OpenPGP is the medium across
which email is transmitted is insecure, and there is a possibility of
a MITM attack.  I don't see how this sort of challenge-response does
anything other than confirm that the controller of a key that claims
to belong to a particular email address is also able to intercept and
send messages to and from that address.
The only scenario that it would protect against is where key A claimed
to belong to email address B, but actually did not, and the owner of
key A was actually unable to read messages sent to address B.
In that case, OpenPGP would be providing no security, but the security
of the email system itself would be such that OpenPGP was unnecessary.
To put it another way: if you trust the email network sufficiently for
your challenge to be useful, doesn't that mean you don't need
Have I missed something?
Best wishes,

@_date: 2011-08-26 22:29:04
@_author: Nicholas Cole 
@_subject: Multiple Keyrings WAS Signing multiple keys 
I know Warner has said all this before, but I sometimes think that too
few people chime in to say, "yes I agree".
The problem with multiple keyrings is that they introduce all sorts of
corner cases and unpredictable, ambiguous behaviour.  And actually,
gpg itself is very quick at handling even very large keyrings.
I know that their removal would mean that some people have to adjust
how they use gpg, but I am sure that the end of multiple keyrings
would actually be for the best, and I think removing them is right
thing to do.
In fact, just as at the moment the handling of multiple files needs to
be explicitly enabled, I would favour seeing an option to explicitly
enable or disable multiple keyrings in the current versions, just
because I think that unless users take particular care they can be
I *do* see the uses for them.  The debian keyring, for example is
huge, and it is useful to be able to selectively include it or not in
the gpg.conf file.  But there more I've thought about this, the more I
think that it would be better just to have entirely separate gpg home
directories for this sort of purpose.
For the case in question, there would be nothing to stop you having a
home directory made specifically for a key-signing party, for example,
importing your signing key into it and using it as your working
directory.  '--homedir', not multiple keyrings, seems to me to solve
the problem addressed by multiple keyrings for almost all real-world
Best wishes,

@_date: 2011-08-26 22:56:17
@_author: Nicholas Cole 
@_subject: Signing multiple keys 
I honestly did not mean to be critical.  I was just struggling to see
the security benefit.  After all, all security brings inconvenience,
but not all inconvenience brings security. :-)
Do you have a particular concern about orphan keys?
Best wishes,

@_date: 2011-08-27 14:12:20
@_author: Nicholas Cole 
@_subject: Signing multiple keys 
I see. So your procedure is to check that the name on the key matches
some ID, and THEN check separately that the key at least appears to
control the email addresses it claims.
Which does make a certain sense, I can see. :-)
Thank you for explaining.
Best wishes,

@_date: 2011-08-30 09:59:31
@_author: Nicholas Cole 
@_subject: --min-cert-level and --auto-check-trustdb 
Dear list,
Why is changing the --min-cert-level not enough to trigger an update
of the trust-db?  Should it be?
Supposing a scenario in which a user is prepared to accept lower-level
certifications for low value communications, but requires higher level
certifications for others.
At present the user can specify --min-cert-level on the command line,
but the trust database itself will not be updated for the purposes of
listing/editing keys, verifying signatures or encryption.
The user interface can become easily out of sync with the user's
explicit trust model settings.
The only solution is to explicitly order --check-trustdb.
However, this creates further problems and possible security risks,
because there is no guarantee that a temporary change will be reverted
when the user stops specifying the --cert-level on the command line.
I suspect this is little-used feature of gpg.  On the other hand, it
does look like an excellent way for the user to shoot himself in the
foot without even realising it.  (Senario to verify the problem at the
end of this email)
Best wishes,
To verify problem:
1. Sign a key with a level 1 certification
2. Do gpg --min-cert-level=1 --check-db
3. Edit the key you have just signed, or try to encrypt to it, and the
listing will show the uid as trusted EVEN if you do not specify the
low cert level on the command line, and are therefore using the gpg
default --min-cert-level=2.
This is looks a security risk to me.
(problem identified with gpg 1.4.11)

@_date: 2011-12-20 18:24:16
@_author: Nicholas Cole 
@_subject: GnuPG 2.1 beta 3 released 
I see that the man page still refers to the option --secret-keyring.
Presumably this option now does nothing?
Very exciting to see the new release!

@_date: 2011-12-23 18:29:09
@_author: Nicholas Cole 
@_subject: GnuPG 2.1 beta 3 released 
How will this interact with the --homedir option?  Will --homedir be
passed to gpg-agent or are the two entirely separate?
I ask because at the moment it is possible to keep separate keyrings
in different home directories, which might be useful to (for example)
keep the large debian keyrings separate from personal keys, or to keep
a set of keys for testing purposes separate from production keys.
Best wishes,

@_date: 2011-12-25 18:00:58
@_author: Nicholas Cole 
@_subject: GnuPG 2.1 beta 3 released 
Dear Werner,
It would be very good if there were still a way to completely 'sandox' (for
want of a better term) an instance of gpg, so that it uses its own key
rings and trust databases.  I certainly find that for testing purposes it
is very useful indeed.  On previous versions --homedir does this nicely.
I presume the new way will be to make sure that a separate copy of
gpg-agent is running and to pass in GPG_AGENT_INFO as an environment
variable, as well as specifying a --homedir.
Or will there be a better way?
Best wishes,

@_date: 2011-01-11 20:09:11
@_author: Nicholas Cole 
@_subject: What is the benefit of signing an encrypted email 
That is a really interesting paper.  Did the OpenPGP protocol ever
include a fix for the attack they describe?

@_date: 2011-01-12 10:01:17
@_author: Nicholas Cole 
@_subject: What is the benefit of signing an encrypted email 
That thread is clearly right about the bulk of the paper, which is
clearly an attack on the user of the crypto.  Signing ambiguous
messages is not a good idea!   But what about the suggestion they made
in section 1.2 about not signing crypt texts?  Am I right that openpgp
always encrypts signed text, rather than signing encrypted text, and
so is not vulnerable at all?
Best wishes,

@_date: 2011-01-18 18:12:00
@_author: Nicholas Cole 
@_subject: What is the benefit of signing an encrypted email 
It is, in fact, trivial to 'forge' email - that is to send email
pretending to be someone else.  All you need to do is tell your
computer to send out email with a different "From:" line.  Most smtp
servers will forward an email from an authenticated user (or from
anyone on the network) without checking that the From line matches
their approved email address.  This is, for the most part, a feature,
not a bug.  There are various schemes to prevent this from being
possible (or at least undetectable) and OpenPGP offers one way -
albeit one that places a great demand on the sysadmin or the user or
In fact, email is forged every day in just this way - but most of it
is such obvious spam that it is easier for the human eye to weed out
than it is to set up an OpenPGP, which is why so few people have ever
done so.
Back when I was a student a friend of a friend of a friend got very
drunk and started forging emails in this way pretending to be the
Dean.  But even these were such obvious forgeries, and the other email
headers were so detailed, that it did not require OpenPGP to detect
Best wishes,

@_date: 2011-03-23 21:12:13
@_author: Nicholas Cole 
@_subject: Group Membership Keyring 
Just to comment on this aspect of your proposal:
Debian, for example, does circulate a keyring file in this way.  But
managing multiple keyrings is not easy, and can lead to some nasty
corner-cases.  What if you are using multiple keyrings and different
versions of the same key exist on more than one keyring?
[ as an aside, I think there is a fairly good case that multiple
public keyring files are a menace rather than a help in most cases
because of this problem....  ]
It would probably be better for the membership secretary to circulate
a keyblock (i.e. the results of an --armor --export) containing the
members keys, which you could then import onto your own keyring.
Unless the group features many hundreds of members you should not
experience any noticeable slow-down at all.
Depending on the nature of your group there are two potential models:
- If memberships are renewed at regular intervals, the secretary can
simply sign all keys with signatures valid for the standard period of
membership and circulate the keyblock.
- If members enter and leave at different times, the membership
secretary will have to sign and revoke keys as appropriate (I'd still
put an expiry date on the signatures to be on the safe side) and
circulate the keys of all members who are current *or  former members*
(so that the revoked signatures are also circulated).
- As a refinement of the second option, if you make the signatures
only valid for a year, you would only need to circulate the keys of
former members for the period during which the original signature was
ever valid.
Best wishes,

@_date: 2011-11-26 17:25:22
@_author: Nicholas Cole 
@_subject: [gpgtools-users] [gpgtools-devel] Joint OpenPGP (JS) 
Dear Lists,
All these projects are very interesting.  Forgive a slightly off-topic
but important question that they raise, though.
What are the legal implications of contributing to these sorts of
wrapper projects?  Do such projects count as "export" of "dual use"
cryptography for the purpose of EU and USA laws?
In the past, such questions have caused open source projects no end of
The "crypto law survey" attempts to answer some of these questions.
Following the links for the UK and the USA, it looks to me as if *any*
project that facilitates the use of cryptography would have to take
legal advice, even if it is merely a wrapper for another program or
library, and would have to be careful about where it was hosted, and
who it accepted contributions from.
Is that correct?
The GPG project itself must have hit many of these issues.  Is there a
write-up anywhere of their conclusions?  Something like that might be
helpful for other people starting these sorts of projects.
Best wishes,
(I am not a lawyer...)

@_date: 2011-11-28 20:46:33
@_author: Nicholas Cole 
@_subject: [gpgtools-users] [gpgtools-devel] Joint OpenPGP (JS) 
The rules seem so complicated that even from the UK (that is, within
the E.U.) I can't work out what the rules for open source are!
What a mess!

@_date: 2012-08-27 20:32:29
@_author: Nicholas Cole 
@_subject: [NOOB] Export subkey 
--export exports your whole public key.  It probably doesn't make sense to
only export a public subkey -- public keys are supposed to be public  - and
various important bits of information are tied to the main key in any case.
 Your user id, for example, is stored on the main key.
Secret subkeys are another matter, and if you look at the man page you will
see there is a facility to export them.  You would want it if, for example,
you wanted to keep the main key on one computer and put only the secret
subkey parts on another.
But if you are new to gpg and just using it as an individual, my strong
advice unless you have very particular needs is to ignore the subkey
elements and treat them as part of the technical inner workings of the
maths side of Gpg  You almost certainly don't need to manipulate them for
I don't say this to be condescending.  One of the great strengths of
OpenPGP and of gpg is that they provide very a by flexible tool that can be
used in a huge number of situations.
Subkeys were introduced partly as a technical implementation detail: it is
bad security practice to use the same key for both signing and encrypting
(and with some algorithms impossible), so PGP needed a way to tie groups of
keys together and treat them as a single key.  They do, however, introduce
some benefits that can be useful in particular settings --- to occasionally
change encryption keys, for example.  The OpenPGP card can also be set up
to use only subkeys, which can be useful in preserving the web of trust if
a card is lost or damaged (though whether this is a good idea and worth the
complexity is going to vary from situation to situation).
I hope that helps.
Best wishes,

@_date: 2012-12-04 16:07:26
@_author: Nicholas Cole 
@_subject: Seperate RSA subkeys for decryption and signing or one for both? 
Do you have a reference for this? I thought the major reason to use
separate signing/encryption keys was that if a user could be persuaded
to sign a chosen encrypted text with the same key, the decryption key
would be revealed.
I've never read before that a key could be "used up" in this way.

@_date: 2012-12-04 19:11:18
@_author: Nicholas Cole 
@_subject: Fwd: Seperate RSA subkeys for decryption and signing or one for both? 
Meant to post this to the list. Blame gmail.
---------- Forwarded message ----------
I think the attack merely specifies a chosen text - but at any rate,
the point is that there might be a system (eg. a badly designed
time-stamping service) that might naively sign data supplied by an
attacker, and in those cases having a signing and encryption key that
are the same would be a Bad Idea.  Note, though, that PGP 2.6.3 did
use the same key for both; the attack is a (mostly) theoretical one.

@_date: 2012-12-04 19:12:03
@_author: Nicholas Cole 
@_subject: Fwd: Seperate RSA subkeys for decryption and signing or one for both? 
Ah. That's an attack on the Hash function, not the key.  And even
then, it seems far too difficult to be realistic, assuming that I read
it correctly and assuming it is correct!

@_date: 2012-12-23 12:01:25
@_author: Nicholas Cole 
@_subject: OpenPGP Authentication Protocol? 
Dear List,
Is there a protocol documented anywhere for using PGP Keys for
client-server authentications?  I assume that various naive approaches have
all sorts of serious problems.
Best wishes,

@_date: 2012-02-02 17:07:57
@_author: Nicholas Cole 
@_subject: GnuPG distribution signature 
I've long thought that one nightmare scenario for OpenPGP would be an
ISP or other network gateway that transparently scanned all data
passing through it looking for specific key ids and fingerprints and
which silently changed them in webpages, email etc to fraudulent
values.  I can't imagine that it would be that difficult, and it would
be difficult to detect as well as tripping up anyone who relied on
"well-known" keys.

@_date: 2012-01-04 10:21:22
@_author: Nicholas Cole 
@_subject: Trying to create auth key on GPF CryptoStick 
Quite frankly, I don't think most people need anything more than a 512
bit key. :-)
But all the same, to be serious, I suppose it is a bit (just a tiny
bit) unsettling that NIST is recommending that everyone move to either
very long keys for really secure data or else to ECC:
  (for example)
I know that the request for stupidly, idiotically long key sizes is as
old as PGP itself, but all the same, I suspect that these sorts of
requests will be more and more common until gpg is capable of
supporting the latest "state of the art".  Even then, it won't satisfy
everyone, but at least we'll be able to say "if it's good enough for

@_date: 2012-01-04 12:37:10
@_author: Nicholas Cole 
@_subject: Trying to create auth key on GPF CryptoStick 
I know - the gpg team is wonderful. :-)  I wasn't criticising them,
just suggesting that the pressure for longer/different keys was likely
to grow, even if it doesn't really make a lot of sense for most users.
Is there any plan to back-port the ECC support?

@_date: 2012-01-04 13:27:45
@_author: Nicholas Cole 
@_subject: Trying to create auth key on GPF CryptoStick 
That is a shame, although I do completely understand the resources
problem.  Though gpg2.1 has lots of wonderful features, it IS a much
bigger, much more complex package.  I've always liked the fact that
gpg1.4 can be built relatively simply, and the code-base looks
relatively easy to understand.  It really is a case of simply
downloading and building.  People using gpg2 often have to rely on
third-party packagers.
You said earlier that someone wanting really high security ought to be
prepared to audit the different elements of the system.  I'm no
expert, but I'd have thought that would be easier if deploying 1.4.
Perhaps that is wrong, and in fact people can have better confidence
in the new version.
I suppose I'd imagined that once the ECC code was written it would
effectively be a module that could be integrated relatively easily
into the old code.  I do understand if that's not the case, but there
are reasons why 1.4 is still so popular.  Do you think those reasons
are outdated and need to be confronted?

@_date: 2012-07-11 21:55:32
@_author: Nicholas Cole 
@_subject: why is SHA1 used? How do I get SHA256 to be used? 
A bleak but realistic assessment.
But one thing that might be helpful to explain is this: what needs to
be in the V5 key format aside from the change in fingerprint hash?
Aside from that issue, the V4 key format seems to have been resilient.
 What are the other issues that need to be addressed?

@_date: 2012-07-27 09:26:14
@_author: Nicholas Cole 
@_subject: Mac OS X 10.8 and OpenPGP Cards 
If it is any consolation, it is working for me (Gemplus GemPC Reader)
Have you installed the smartcard libraries?
Best wishes,

@_date: 2012-05-25 11:41:46
@_author: Nicholas Cole 
@_subject: Draft of nine new FAQ questions 
There's a slight confusion in these answers that I think it would be
really helpful to address in an FAQ.
On the one-hand, this new FAQ suggests that attacking a 2048 key is
already so unfeasible that to suggest that a 3072 key would provide
additional security is a nonsense.  On the other hand, there is a
sense that 2048 keys might only provide adequate security until the
mid-2020s / 2030.
Is that because the break-through that is anticipated by the second
statement is some kind of quantum computing success or some similar
advance that completely breaks RSA (and all PKI)?
In other words, what really is the status of a statement like "2048
RSA is believed safe until 2030"?  Back in the 1990s, such predictions
were based on a sense of increasing computing power, and it was
possible to predict with reasonable accuracy when (for example) 512
bit RSA would look possible to factor at imaginable cost.  Is the
"safe until 2030" prediction of a similar quality or just a guess at
when technologies that are currently science fiction might look
I only raise these points because this has become such a recurrent,
sometimes even tiresome theme on this mailing list, that I'd really
like the FAQ to be as comprehensive as possible.
To put the question in the form that sometimes comes up on this list -
what if one wants security until 2040?  Would a 3072 key make sense in
that case or not?
Not that I think my own security needs, by the way, need anything more
than a 512 RSA key, if that...  ;-)
Best wishes,

@_date: 2012-05-25 16:02:23
@_author: Nicholas Cole 
@_subject: Draft of nine new FAQ questions 
[ snip ]
Thank you for a really good and useful answer.  I hope some of that
can make it into the FAQ.
If I understand you correctly then the situation is this:
- if you want longer symmetric cyphers, then you are asking for
something that is a mathematical and physical nonsense.
- if you use longer RSA keys, you are being unduly paranoid, and
asking for something that would make life awkward for mobile devices,
etc, but not asking for something that is a complete nonsense -- just
unhelpfully paranoid.
I think it would be good if the FAQ managed to capture that.

@_date: 2013-08-16 12:10:21
@_author: Nicholas Cole 
@_subject: [Announce] [security fix] GnuPG 1.4.14 released 
Cancel that.  My fault ... I'd missed that I had some old libraries

@_date: 2013-08-16 11:54:59
@_author: Nicholas Cole 
@_subject: [Announce] [security fix] GnuPG 1.4.14 released 
For some reason I get the following error when trying to build on Mountain
Lion OS X:
gcc  -g -O2 -Wall -Wno-pointer-sign   -o gpg gpg.o build-packet.o
compress.o compress-bz2.o free-packet.o getkey.o keydb.o keyring.o seskey.o
kbnode.o mainproc.o armor.o mdfilter.o textfilter.o progress.o misc.o
openfile.o keyid.o parse-packet.o status.o plaintext.o sig-check.o
keylist.o signal.o cardglue.o tlv.o card-util.o app-openpgp.o iso7816.o
apdu.o ccid-driver.o pkclist.o skclist.o pubkey-enc.o passphrase.o
seckey-cert.o encr-data.o cipher.o encode.o sign.o verify.o revoke.o
decrypt.o keyedit.o dearmor.o import.o export.o trustdb.o tdbdump.o tdbio.o
delkey.o keygen.o pipemode.o helptext.o keyserver.o photoid.o exec.o
../cipher/libcipher.a ../mpi/libmpi.a ../util/libutil.a -liconv -lresolv
../intl/libintl.a -liconv  -Wl,-framework -Wl,CoreFoundation  -lz -lbz2
-L/sw/lib -lusb -Wl,-framework,IOKit -Wl,-framework,CoreFoundation
Undefined symbols for architecture x86_64:
  "_iconv", referenced from:
      _utf8_to_native in libutil.a(strgutil.o)
      _native_to_utf8 in libutil.a(strgutil.o)
      __nl_find_msg in libintl.a(dcigettext.o)
  "_iconv_close", referenced from:
      _utf8_to_native in libutil.a(strgutil.o)
      _native_to_utf8 in libutil.a(strgutil.o)
      _set_native_charset in libutil.a(strgutil.o)
  "_iconv_open", referenced from:
      _utf8_to_native in libutil.a(strgutil.o)
      _native_to_utf8 in libutil.a(strgutil.o)
      _set_native_charset in libutil.a(strgutil.o)
      __nl_find_msg in libintl.a(dcigettext.o)
ld: symbol(s) not found for architecture x86_64
collect2: ld returned 1 exit status
make[2]: *** [gpg] Error 1
make[1]: *** [all-recursive] Error 1
make: *** [all] Error 2

@_date: 2013-03-18 10:24:32
@_author: Nicholas Cole 
@_subject: Enterprise Key Management? 
It's clever.  Given careful management / dissemination it would allow a
group to share an encryption key but have separate signing key.  I don't
know if any software exists that operates in this way.
I do wonder if what the poster really meant, however, is not "subkeys" per
se but Trust-Signature certified keys.
I guess what is needed for most enterprise use is a system where the
company generates employee's keys and keeps a copy of them.

@_date: 2013-09-01 13:18:12
@_author: Nicholas Cole 
@_subject: Recommended key size for life long key 
One of the problems that this kind of discussion highlights is that moving
to new keys is a real pest.  People keep keys long after they really should
and are reluctant to change keys because getting a given key certified and
trusted is a pain - even with the web of trust.
In a more ideal world, no one would want a key to last longer than a few
years, and replacing keys at regular intervals would be the norm.

@_date: 2013-09-02 19:28:09
@_author: Nicholas Cole 
@_subject: AES256 & AES192. (Was: Can I revitalise an old key-pair?) 
I was curious about this. The wikipedia page mentions the "Related Key
Attack" on these cyphers, but is vague about whether they were ever
Does anyone know?
And did fixes make it into the version used by Gnupg?

@_date: 2013-09-03 14:39:40
@_author: Nicholas Cole 
@_subject: AES256 & AES192. (Was: Can I revitalise an old key-pair?) 
And if that were true, I presume that would mean that the "AES is
stronger than AES256" argument would also fall. Or have I

@_date: 2013-09-03 20:38:23
@_author: Nicholas Cole 
@_subject: AES256 & AES192. (Was: Can I revitalise an old key-pair?) 
While reading up on all of this I found this piece (concerning a very
widely used piece of software for Mac OS and iOS) on the switch to AES256.
I thought others would find it useful.

@_date: 2013-09-13 13:24:12
@_author: Nicholas Cole 
@_subject: lsign produces exportable signatures when used for self-sigs 
I don't think this is sensible.  What is the point of a UID that
cannot be used by someone else?  If the UID is shared with anyone else
(even privately), it must have a self-signature, and so that signature
must be exportable.  If gpg starts --exporting keys with
non-self-signed UIDs, this will be a step backwards.
I see what you are trying to achieve, but I don't think this is the
right way to do it.  The correct way would be to have keyservers
honour the no-modify flag, or perhaps have some notation on the ID
that prevents uploading to a public keyserver.  I myself would favour
the latter approach.

@_date: 2013-09-13 15:40:26
@_author: Nicholas Cole 
@_subject: lsign produces exportable signatures when used for self-sigs 
I'll admit your solution is ingenious. But all the same, I think you
are trying to overload one clearly defined feature of the openpgp spec
- a non-exportable signature - to try and force keyservers not to
store UIDs.  I really don't favour this approach at all.
Section 5.2.3.11. (Exportable Certification) of the openpgp spec very
clearly defines what "local" signatures are to be used for.  Your
solution works only because gpg provides a way to export even
non-exportable signatures, but that is not guaranteed by the spec.
If the no-modify flag is a dead-end, then (as I suggested) I think a
new notation that keyservers could honour is the the way forward on

@_date: 2013-09-13 16:35:00
@_author: Nicholas Cole 
@_subject: lsign produces exportable signatures when used for self-sigs 
Well. Why not trust your circle of contacts (because anyone using this
scheme must be in a small circle) not to upload the keys to
Perhaps if there is enough demand gpg could even have a "Never send
these keys to keyservers" option in the config file, taking a list of
Just a thought.  I'm against doing something that goes against the
standard when there are other ways to achieve it.

@_date: 2013-09-18 09:54:59
@_author: Nicholas Cole 
@_subject: Where is ECC in gpg2 (specifically gnupg-2.0.21 
If I understand correctly, the curve is used to create the
Public/Private Keypair.  So GPG probably needs to display clearly (in
the --with-colons output and in the user-facing output) the curve used
to create the key (if that is possible) so that people can make a
judgement about that kind of thing when they certify keys -- assuming
it matters to them.  Or have I got that wrong?

@_date: 2013-09-19 18:58:58
@_author: Nicholas Cole 
@_subject: Where is ECC in gpg2 (specifically gnupg-2.0.21 
That sounds ideal.  And I am sure you are right that for private use
it makes little to no difference.  But on the other hand, if gpg is
being used where people are trying to comply with different national
standards, it might be important that they know the curve being used.

@_date: 2014-04-19 15:46:47
@_author: Nicholas Cole 
@_subject: It's 2014. Are we there yet? 
I *thought* [citation?] that this problem was fixed with version 4 keys.

@_date: 2014-08-17 00:41:52
@_author: Nicholas Cole 
@_subject: Fwd: It's time for PGP to die. 
This was a terrific post.  Thank you, Robert.
I agree people are obsessed with this, and it is unhealthy. I think
the name doesn't help.  I've seen various definitions.
"This means that the compromise of one message cannot lead to the
compromise of others".  In the case of PGP, of course, it is true that
the compromise of the Public key would compromise all messages, but in
other ways PGP does help. It is possible, for example, to surrender
just the session key, in the case that it is necessary to do so to
comply with a legitimate law-enforcement request.  But I don't see how
PFS could really apply to something like email, as opposed to
something like an http request.
There are 25 years invested in making PGP work. Many subtle bugs and
security errors in the protocol and the gnupg implementation have been
worked out.   Throwing out PGP would be a bit like making this
That is true.  But perhaps it would be a start if email clients
actually put the actual email (with subject and references headers
etc.) as an attachment to a bare email that contained only the minimal
headers for delivery.  It wouldn't be a perfect solution, but it would
at least fix a certain amount of metadata analysis.

@_date: 2014-08-18 10:13:12
@_author: Nicholas Cole 
@_subject: It's time for PGP to die. 
But even if they weren't, the problem is that OpenPGP protects such a
small part of the problem that it is hard to justify the additional
time and effort to users.
If the revelations of the last year have proved anything, it is that
most computer systems are vulnerable at a very deep level to all kinds
of sophisticated attacks.  In that context, where the underlying
operating systems themselves are so vulnerable, OpenPGP really doesn't
solve very much for most users.
Supposing the following threat model (which I think corresponds to how
must people use email):
- physical security of hardware.
- the need for secure communication contents (but the fact of the
communication is not secret).
- connection of the computers to the internet.
- attackers who are interested in the content of the communication and
who are willing to launch electronic attacks to get it.
OpenPGP would be an ideal solution for the actual transmission in this
scenario -- except that there is simply no operating system that can
be trusted to be a secure platform upon which to run OpenPGP.  There
will always be a weaker link than the encryption, and so the right
solution for most users is not to send confidential information by
email at all.
Now, there are still plenty of uses for OpenPGP, but they tend to be
niche ones with particular threat models and especially motivated
users.  To expect mass-adoption of a tool with only niche uses is not
reasonable.  It doesn't mean that the project is a failure.

@_date: 2014-08-19 10:14:39
@_author: Nicholas Cole 
@_subject: So on & so forth 
They've made a fork? I hadn't realised that. Why on earth?

@_date: 2014-01-05 13:24:01
@_author: Nicholas Cole 
@_subject: V3 key lookup 
Dear list,
I've been implementing a local version of
for some experimenting.
I have a server working listening on local host and replying with the
correct formats to the defined requests.
Everything works fine with version 4 keys, but if gpg (version 1 or 2)
attempts to download a version 3 key, it simply exits with an error about
no valid data found.
The odd thing is that the request doesn't even show up in the server logs.
As far as I can tell, gpg doesn't even attempt the request.
What could be going wrong?  Is it that for some reason the v3 code doesn't
like a local host?

@_date: 2014-01-05 16:48:58
@_author: Nicholas Cole 
@_subject: V3 key lookup 
At the risk of answering my own question experiments on the console
(rather than using a front-end) revealed the helpful message:
gpg: requesting key ?v3 fpr? from hkp server localhost
gpgkeys: HKP keyservers do not support v3 fingerprints
gpg: no valid OpenPGP data found.
gpg: Total number processed: 0
gpg: keyserver internal error
Thanks Werner for making your error messages so clear.

@_date: 2014-06-06 09:13:23
@_author: Nicholas Cole 
@_subject: [Announce] A new Beta of GnuPG 2.1 is now available 
Dear Werner,
Congratulations on this.
I just wonder if anyone would have time to put together a HOW-TO for
people building GnuPG 2.1 and all of its associated libraries from
source.  For those of us who don't do this often, this is currently a
rather frustrating process, and a mini-how-to explaining what all the
pieces are and which order to build them would be really welcome.
Best wishes,

@_date: 2014-06-28 19:33:24
@_author: Nicholas Cole 
@_subject: card reader (was: riseup.net OpenPGP Best Practices article) 
I can't find a UK source for this, but it does look good.
Speaking of which, is there an alternative source for GnuPG
Smartcards?  KernelConcepts is out of stock until August.
Best wishes,

@_date: 2014-05-03 09:50:47
@_author: Nicholas Cole 
@_subject: Signature without policy meaningless? (was Re: UI terminology for 
But it doesn't work like that anyway.  Unless you are using Trust
signatures (and few people do) then a signature on a key does not
encourage a 3rd party to trust signatures made by that key.
Even if a key is recognised as authenticated/validated/certified for
association with a particular email address, the signatures made by
that key will not be trusted by anyone who has not made an active
decision to make a particular key a trusted introducer.
In fact, this is a reason (though one of many) why the web of trust
has never quite lived up to its promise.  No UI that I am aware of
sets even marginal trust by default on newly imported keys.  Most
users (I suspect) will only ever end up trusting keys that they
themselves have signed.  That is the default position.
It is interesting to speculate whether the WoT would have been more
effective if there had been a culture of marginally trusting new keys
by default, allowing users to make an active choice either to not
trust someone or to fully trust someone.  As it is, the inertia of the
system works against the idea of a web of trust.[*]
In any case - there is no need for what you are suggesting.  3rd
parties are not (by default) going to infer from your signature that
they should then trust the key you sign as an introducer.
[*] I'm aware there are problems with "marginal trust" related the
fact that the requirement of three marginally trusted signatures to
confer validity may in fact be fairly weak. The three signatures may
not, in fact, be made independently of each other (consider three keys
owned by the same person which all introduce a third key, for example,
or multiple signatures made a single key-signing party).

@_date: 2014-05-07 18:23:34
@_author: Nicholas Cole 
@_subject: Trust Signature REs 
If I tell gnupg to make a trust signature limited to the domain:
it converts this into <[^>]+[
I see the logic.
However, if I am trying to copy this re from one signature to another,
and I tell gnupg to limit a trust signature to "
<[^>]+[ ", it does not recognise this as a
regular expression, but instead converts it to "
Is there any way to tell gnupg that I am actually entering a raw re
and do not wish it to do any conversion?
Best wishes,

@_date: 2014-05-21 11:54:50
@_author: Nicholas Cole 
@_subject: Trust Signature REs 
Dear Werner,
Thanks for this.  The comment in the code was very helpful, and I used
it to construct a way to reverse-engineer the original domain and then
feed that back to gpg which works fine.  All the same, a leading way
to say |raw| would be even better.
Best wishes,

@_date: 2014-11-06 11:18:48
@_author: Nicholas Cole 
@_subject: [Announce] GnuPG 2.1.0 "modern" released 
Hi Werner,
Building on OS X using
make -f build-aux/speedo.mk native INSTALL_DIR=/usr/local
gets what looks like most of the way and then fails with the error
shown below.  Am I the only person experiencing this, or are others
hitting the same problem?
Best wishes,
Undefined symbols for architecture x86_64:
  "_default_errsource", referenced from:
      _parse_ber_header in libcommon.a(libcommon_a-tlv.o)
      _parse_sexp in libcommon.a(libcommon_a-tlv.o)
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[5]: *** [t-sexputil] Error 1
make[5]: *** Waiting for unfinished jobs....
make[4]: *** [all] Error 2
make[3]: *** [all-recursive] Error 1
make[2]: *** [all] Error 2
make[1]: *** [/Users/nicholas/Downloads/gnupg-2.1.0/PLAY/stamps/stamp-gnupg-02-make]
Error 2
make: *** [native] Error 2

@_date: 2014-11-09 20:51:43
@_author: Nicholas Cole 
@_subject: GnuPG 2.1.0 for Mac OS X Available 
Hi Patrick,
Thanks for this! It's a really useful resource.
Are you able to explain how you managed to get GnuPG-2.1 to compile?

@_date: 2014-11-10 11:02:06
@_author: Nicholas Cole 
@_subject: [Announce] GnuPG 2.1.0 "modern" released 
Is the point that you can have a signed file that makes you THINK you
have verified a file when in fact you haven't?  So the confusion is
that you have one single command that deals with verifying both a
detached signature and with a file that contains a signature?
Is the best fix for this to introduce two new commands
--verify-detached (requires two arguments)
and then to make everything that simply calls the old command --verify
break?  Or is that too radical?

@_date: 2014-11-10 11:52:44
@_author: Nicholas Cole 
@_subject: GnuPG 2.1 Unattended EC Generation 
Dear List,
How does unattended generation of elliptic curve keys work? As far as
I can see, that section of the manual has not been updated for the new
EC options, but I presume that it has to work slightly differently.
Am I right that key-length is now a no-op?  And how do you specify the
Best wishes,

@_date: 2014-11-10 11:53:58
@_author: Nicholas Cole 
@_subject: ECDSA vs EDDSA 
In the new gpg2 --version lists both ECDSA and EDDSA as supported
algorithms, but that doesn't seem to correspond to options in the
--expert --full-gen-key command.  I presume that --full-gen-key
creates an ECDSA by default.  Is that right?
Perhaps someone who knows about EC could write an FAQ on the wiki for
those of us who are confused by all the new options?
Yes, I know that for ordinary use we should all just use the defaults,
but I'd still like to know what is going on, for interest's sake.

@_date: 2014-11-10 12:00:11
@_author: Nicholas Cole 
@_subject: DSA key sizes 
Just out of curiosity: DSA key sizes are now rounded to one of 3
values, whereas RSA keys are available in a range of sizes between two
limits.  Why the difference?

@_date: 2014-11-10 12:03:41
@_author: Nicholas Cole 
@_subject: Detached signature ambiguity (was: [Announce] GnuPG 2.1.0 
Yes, Werner is very good at not breaking things that don't need to be
broken.  But in fact, it is the fact that scripts depend on this that
made me think that this might be a case where things *should* get
broken, because this is actually a serious security flaw, and the
scripts in question need fixing.  In many cases, no one is going to be
around to read the warning you suggest.
Just a thought.

@_date: 2014-11-11 06:38:28
@_author: Nicholas Cole 
@_subject: Detached signature ambiguity 
In my view, the long experience of bugs like this suggests that it is
better to live with the short-term pain of breaking things in order to
get a robust solution, than to fix a solution in various ingenious
ways that themselves introduce a whole series of corner-cases and
opportunities for exploitation.  I hate breaking backwards
compatibility normally, but this seems like such a fundamental problem
I don't know what to do about it.
I *suppose* a fix would be to:
- introduce two new commands along the lines I suggested.
- make the old verify command:
1. Refuse to verify a detached signature without a .sig extension
2. Refuse to verify a non-detached-signature contained in a file with
a .sig extension.
But I don't like the solution, really. It introduces code that has to
be maintained, and sill leaves users vulnerable to tricks involving
unicode etc., so that the security it provides is itself an illusion.
In my view it is much better just to break the old --verify command
completely.  Scripts that are maintained will have a simple fix, and
scripts that are not will no longer give a completely false sense of

@_date: 2014-11-11 11:56:59
@_author: Nicholas Cole 
@_subject: GnuPG 2.1 Unattended EC Generation 
Thanks Werner!
Two smaller problems.
Under previous versions, failing to provide a
would create a key without a passphrase.  This was useful for testing purposes.
Is that still possible?  In version 2.1, if no password is specified,
gpg2 tries to call pin-entry and ask for a passphrase.
The second problem is that if gpg is called with a non-standard
--homedir the whole thing fails with:
gpg: agent_genkey failed: No pinentry
gpg: key generation failed: No pinentry
I'm sure this means that I'm invoking the new gpg2 and gpg-agent
combination incorrectly.
Sorry for all the flood of questions.  gpg2 "modern" is very exciting,
but getting all the pieces to work as they used to (and making changes
for the new system) is going to take a bit of time!
Best wishes,

@_date: 2014-11-11 13:32:32
@_author: Nicholas Cole 
@_subject: GnuPG 2.1 Unattended EC Generation 
I'm so sorry, Werner. I thought I'd checked the manual. Huge apologies.

@_date: 2014-11-12 20:55:10
@_author: Nicholas Cole 
@_subject: GnuPG 2.1 and Mailpile (LWN comments) about GPGME 
I actually disagree with the assumption here.  The --with-colons
--command-fd --status-fd interface has been remarkably stable.  The
last major incompatible change was in 1.4.9 and 2.0.11 when the order
in which subkey algorithms were presented was changed.  Other than
that, it is an incredibly well-designed an easy to parse interface.
The only way in which it can trip you up is that you need to keep a
careful watch on whether you are expecting further data from gpg or
The stability and utility of this interface is one of my favourite
aspects of the gnupg project, and I really admire Werner for his work

@_date: 2014-11-14 11:34:27
@_author: Nicholas Cole 
@_subject: My Conclusions 
I'm sorry you are having problems, but I think this is just nonsense.
Of course people move keys between machines all the time.  I have done
it myself often.  I don't think that anyone deserves that level of
abuse -- certainly not someone who has put years of work into a
program that is an industry standard and released it for free.

@_date: 2014-11-14 17:30:41
@_author: Nicholas Cole 
@_subject: My Conclusions 
I've read most of your emails about this, and I don't see any
description of the command you have entered or the error you are
Trying to diagnose "it doesn't work" error reports is a little like
trying to type blind: you might get it right, but you'll probably just
frustrate anyone trying to read what you've written.  The standard way
to report errors is:
1. What are you trying to do?
2. What command(s) did you enter exactly?
3. What did you expect to see?
4. What did you actually see?
So far, I can only see the answer to question 1.

@_date: 2014-09-15 09:48:47
@_author: Nicholas Cole 
@_subject: encrypting to expired certificates 
Opportunistic encryption with a fall-back mode to plain text, which seems
to be your model, is dangerous.  Yes, it is always dangerous to have a
protocol that sends in plain text if encryption is impossible.
However, I don't think the fault is with GPG.  If a key has an expiry date,
GPG can be very very certain that that key should not be used after a
particular date.  In fact, I don't think that user interfaces should ever
have encouraged people to encrypt to 'not valid' keys at all, but if they
key itself says that it should not be used, then it really should not be
You can't make assumptions for the reason a key has an expiry date.  It
could be that after that date it would be insecure to send encrypted data
to that key.  I think that implementations should respect the expiry dates
on keys.

@_date: 2014-09-15 14:33:55
@_author: Nicholas Cole 
@_subject: encrypting to expired certificates 
I don't know.  If a key says on it "You can use this key for these
email addresses up until this date" I think that tools SHOULD NOT use
the key beyond that date or for other email addresses.  I think in the
case of the expiry date, I'd see a strong case for MUST NOT.  The
expiry date is there exactly so that users do not have to explicitly
revoke keys.  Or do you think one should be able to encrypt to revoked
keys too?
I do see a difference with merely NOT VALID keys, because those keys
might be checked using some external trust system, though it is bad
practice 99% o the time, I suspect.
I can't see any justification for encrypting to a key past its expiry
date.  Either your correspondent is in a position to update the key,
or he/she isn't.  In the latter case, the key should not be used.

@_date: 2014-09-15 17:47:15
@_author: Nicholas Cole 
@_subject: encrypting to expired certificates 
Respectfully, Hauke, we just disagree on this.  But your last comment
raises a crucial point that I think has bugged OpenPGP for far too
long: the software we use for OpenPGP has actually been far too
liberal about letting people use "not valid" keys. This has taken
pressure off the writers of user interfaces to find ways of
encouraging users to use the software properly, and at the same time
the web of trust has been shrouded in far too much mystique and
If a user sets up a key and sets the flag on the key that explicitly
means, "Do not use it after this point" I think the software should
enforce that.  I can see that it creates a (small?) potential for a
DoS attack, and I can see that there might be cases you want to
override it in special circumstances.  As it happens though, it isn't
exactly a strong protection for someone willing to delete revocation
signatures and so on to make things work. The work-around is simple:
wind your computer clock back and you'll be fine in this case.

@_date: 2014-09-15 18:25:47
@_author: Nicholas Cole 
@_subject: encrypting to expired certificates 
Sorry. I've confused too issues.  Yes, it is hard to enforce expiry
dates in a 'secure' way. I wasn't meaning to suggest it was something
openpgp should try to do.  I don't think we should make it easy to
ignore them, that's all.
No the other issue I was pointing to was that many users (probably)
never bother to certify the keys of the people they communicate with
and just ignore the fact that the keys are invalid.  Because it is
easy (though unwise) to use PGP/GPG in this way, I don't think
developers have really paid enough attention to encouraging users to
certify the keys they are trying to use or to use keys that are in a
web of trust (nb. a web of trust not The Web Of Trust).  Instead,
we've actually had endless threads about when to 'sign' keys (only if
three passports produced that have been certified by unicorns etc)
that are probably very off-putting to new users.

@_date: 2014-09-15 19:43:13
@_author: Nicholas Cole 
@_subject: encrypting to expired certificates 
I enjoyed that rant so much that I don't even mind that you have
misinterpreted what I said and attributed to me ideas I don't hold: for
which I'm prepared to take 50% of the blame!
Just for the record: all I've ever said in this thead is that I don't think
there is a compelling case to add an option to gpg to ignore expiration
dates. That's all. Although, gosh! It already lets users do so many silly
things perhaps one more doesn't matter.
Your rant was a good one. I agree with much of it. Frankly, as a community
we haven't developed the tools and culture that might have assisted users
to develop good policy and good practice.
I also despair a little. PGP made more sense, in some ways, in the
early 1990s when most home and business computers were offline most of the
time. Maybe not been then.  Nowadays, I'm not at all sure I would trust
openpgp to protect me if I were really worried about my privacy being under
any kind of targeted attack: frankly I can't think of an OS platform I
really trust to be secure, and if you can't trust the platform then a bets
are off. Even Apple, who have every incentive to do so and control of both
hw and sw, can't manage to keep their platforms secure.
Of course, an air gap might help, but that really is a very major hassle
and I don't have cause.
I'm interested in the user interface problems that OpenPGP presents. That's
kept my interest in it alive for all these years. I don't have any high
hopes it will ever be widely adopted though: for most people, most of the
time, there is limited benefit, if any.

@_date: 2014-09-16 06:01:24
@_author: Nicholas Cole 
@_subject: encrypting to expired certificates 
^ The six-real-user test should really be applied to all features in
all software!
Hauke, you make one strong case and one weak one. Yes, I agree that
GnuPG already lets you override so many things, why shouldn't it let
you override this?  It's not exactly logical (though I think that one
can reconstruct the logic).  But you are on weak ground when you try
to say that expiration dates are only a warning, or draw a distinction
between 'strong' and 'weak' statements that a key should not be used.
That maybe how you use them, and it may be that expiry dates on milk
are only warnings, but I have always read an 'expiry date' on a key to
mean 'Do not use after this date', just like an expiry date on an ID
card.  Yes, perhaps you do use them in other ways, but still.  I can
see you've hit a key-management problem. That is really the thing that
needs fixing, and if easy tools to do that are not available, then
they need to be.
Robert is right, I think. A little more 'policy', at least in the
sense of software assisting a shared sense of good practice, would
really help.

@_date: 2014-09-16 15:04:08
@_author: Nicholas Cole 
@_subject: encrypting to expired certificates 
Can anyone explain to me why one would want to continue using a key
and yet not simply change the expiry date?  I really find all of the
examples being given to be incredibly contrived.  It takes no time at
all these days to change the date and distribute the new key.  As I've
said, if the tools to do this kind of thing easily do not exist, they
need to be created.

@_date: 2014-09-16 20:12:06
@_author: Nicholas Cole 
@_subject: encrypting to expired certificates 
I'll admit that I hadn't actually realised how hard it is to make
GnuPG change the expiry dates of subkeys at the same time as changing
the expiry date of the main key.  What is the approved way to do this?

@_date: 2015-01-01 12:01:02
@_author: Nicholas Cole 
@_subject: photo-ID 
No. It is a realistic attack. Key servers might legitimately strip photo
ids if it were ever a problem, IMHO.
But in fact, a UID packet can contain arbitrary data anyway, can't it?
Isn't that just the same problem.

@_date: 2015-01-13 09:41:42
@_author: Nicholas Cole 
@_subject: Vanity Keys 
Or a new revision of the standard, I suppose.  But I think that one or
the other would be worth doing in any case given the way things are
moving.  It is best to be ahead of the game.
