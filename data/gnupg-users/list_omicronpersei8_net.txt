
@_date: 2005-04-21 15:03:03
@_author: Tyler Retzlaff 
@_subject: generating keys & entropy 
I'm having difficulty with keys not wanting to generate or taking a very long time to generate.  I suspect this is due to the source of entropy used to generate the key not being very active.  I notice I can "force" the process along by causing some extra network/cpu activity on the host I'm generating the key.  Is there a way to avoid having to do this?  I find it to be quite inconvenient since I am often generating keys for testing purposes.
Any suggestions welcome, thanks.

@_date: 2005-04-24 17:33:43
@_author: Tyler Retzlaff 
@_subject: gpgme & gpgme_data_write problem 
I'm using the following piece of code which is heavily derived from that found in the gpgme/test directory.  (With error checking removed for clarity, though in the real code all error checking is being done)
The problem is when I use gpgme_data_write() to enter the text into the plain text data buffer before encryption it doesn't end up being encrypted as a part of cipher text.  The resulting encrypted message is This doesn't happen if I initialize the plain data buffer with gpg_data_new_from_mem().  Am I using gpgme_data_new() and gpgme_data_write() incorrectly? Or is libgpgme at fault?  btw. using gpgme 1.0.1/gnupg 1.2.6 being used.
Advice is appreciated, thanks!
main(int argc, char **argv)
         size_t wbytes;
         gpgme_error_t e;
         gpgme_ctx_t ctx;
         gpgme_data_t plain;
         gpgme_data_t cipher;
         gpgme_key_t key[2] = { NULL, NULL };
         gpgme_encrypt_result_t r;
         gpgme_data_encoding_t enc;
         setlocale (LC_ALL, "");
         gpgme_check_version (NULL);
         gpgme_set_locale(NULL, LC_CTYPE, setlocale (LC_CTYPE, NULL));
         gpgme_set_locale(NULL, LC_MESSAGES, setlocale (LC_MESSAGES,
         NULL));
      gpgme_engine_check_version(GPGME_PROTOCOL_OpenPGP);
         gpgme_new(&ctx);
         gpgme_set_armor(ctx, 1);
     gpgme_data_new(&plain);
     gpgme_data_new(&cipher);
     gpgme_get_key(ctx, "93EE05A3D02C75B7B451AF1E6449D89A2D2C2204",
         &key[0], 0);
         wbytes = sizeof("This is the first line.\n");
         gpgme_data_write(plain, "This is the first line.\n", wbytes);
         fprintf(stderr, "wrote %d bytes\n", wbytes);
     gpgme_op_encrypt(ctx, key, 0, plain, cipher);
         r = gpgme_op_encrypt_result(ctx);
         print_data(cipher);
         gpgme_key_unref(key[0]);
         gpgme_data_release(plain);
         gpgme_data_release(cipher);
         gpgme_release(ctx);
         return EXIT_SUCCESS;

@_date: 2005-04-25 06:51:19
@_author: Tyler Retzlaff 
@_subject: gpgme & gpgme_data_write problem 
bah, have to gpgme_data_seek(plain, 0, SEEK_SET); before encrypting. Seems kind of obvious now, but maybe should have been documented.

@_date: 2005-04-26 02:18:29
@_author: Tyler Retzlaff 
@_subject: gpgme encrypting a buffer at a time (streaming) 
I previously saw a post that indicated encrypting a buffer at a time was
possible in the case the producer of the data being encrypted was streaming.
The algorithm went a little something like this:
while ((n_read = getdata( buffer )) > 0)
 write_data_to_gpgme (buffer);
 enc = get_encrypted_data_from_gpgme ();
 do_something_with_encrypted_data (enc);
My producer is a source of memory (a stream buffer infact).  So I tried
to do the following with no success.
gpgme_encrypt_op_start(ctx, keys, plain, cipher);
while ((wbytes = getdata(srcbuffer)) > 0) {
   gpgme_data_write(plain, srcbuffer, wbytes);
   while (gpgme_data_read(cipher, dstbuffer, wbytes) != GPGME_EOF) {
       gpgme_data_read(cipher, dstbuffer, dstbuf_sz);
       /* do something with dst buffer */
   }
I realize this isn't how it should be done, does anyone have an example
of how to do this without using the fd or file stream gpgme interface?
I'm dealing with strictly memory based producers and consumers and at no
time want anything in a file.
Example code would be greatly appreciated!
