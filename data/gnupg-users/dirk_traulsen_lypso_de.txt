
@_date: 2004-10-12 10:32:28
@_author: Dirk Traulsen 
@_subject: --textmode and signing/clearsigning 
after reading the gpg man page, I have four questions
concerning --textmode and signing.
A citation from the gpg man-page:
 -t, --textmode
       Use  canonical  text  mode.   If  -t  (but   not
       --textmode)  is  used together with armoring and
       signing,  this  enables  clearsigned   messages.
       This  kludge  is  needed  for PGP compatibility;
       normally you would use --sign or --clearsign  to
       selected the type of the signature.
1. What is a cannonical text mode?    I found no explanation in the man page or the gnu gpg handbook.    I only found in an introduction to gpg from Brian Hatch:
      --text             Using --text tells GPG that the file is ASCII text.
            When the file is decrypted on the other end,             end-of-line sequences (CR/LF vs CR, etc) will be
            automatically converted, which is convenient.    I assume, --text is the short of --textmode.
   Is his explanation correct and complete?
2. Why is there a difference between -t and --textmode?    Why should it matter to pgp, whether gpg accepts a -t as a    short form for --textmode?
3. Does this mean    (gpg -seat) is clearsigning the message, but
   (gpg -sea --textmode) is signing it?
4. The difference between signing and clearsigning is that with    clearsigning, the original text is preserved and fully readable
   even without a public key of the author and with    signing, it gets compressed and safed in binary form.
   When I encrypt a text, it gets compressed anyway.
   Why does it make a difference, whether I use signing or
   clearsigning on a compressed text?

@_date: 2004-10-13 23:30:35
@_author: Dirk Traulsen 
@_subject: file types for textmode and armor 
I have some more questions concerning --textmode and --armor:
1. --textmode specifies a file as textfile, so while decryption
   gpg can adjust the end-of-file characters fitting to the    actual system.
   What kind of files are candidates for --textmode?  2. When sent per e-mail, what kind of files could need armoring?
   How are they specified? 3. Does armoring a detached signature .sig file with    "gpg -ba file" make sense?
4. In the gpg man-page under EXAMPLES there is "gpg -sb  file".
   Why is it not just "gpg -b file"? Is there a difference?
5. Is there a place where I could find in-depth information
   about gpg? I read the man-page, the manual and what I could
   find on the net, but it is mostly for beginners.    (Still thinking of myself as one, but trying to learn more...)

@_date: 2005-03-31 08:26:40
@_author: Dirk Traulsen 
@_subject: Clarification on purpose of subordinate keys 
Am 29 Mar 2005 um 11:15 hat Werner Koch geschrieben:
This sounds interesting. Please help me to clarify it a bit.
After some tests and reading in my understanding it works like this:
1. add signing subkey to KEY
2. --export-secret-subkey KEY (without specifying the subkey)
      => key.sec.asc
3. --export KEY   => key.asc
4. nothing changes on system1
5. import the exported (crippled) secret key on system2
    --import key.sec.asc
6. import the signatures: --import key.asc
7. Result: On system2 I can use gpg normally and sign with the signing subkey, but the main key is deleted/crippled/deactivated(?) and not usable for signing. As I'm not able to sign with the main key, it is for example impossible to add a new uid, a new subkey or to revoke. When system2 would be cracked, an attacker would not have access to the secret part of my main key (really?).
But for me it would still be possible to go to system1 and
a.  change my passphrase
b.  revoke the compromised subkeys
c.  add new subkeys and start the cycle again without loosing all the signatures on my uid in the primary key, what would have been the case, if I had to revoke the complete key.
The only negative point is, that I have to go to system1 to maintain my key.
Is this correct?

@_date: 2005-11-03 20:12:45
@_author: Dirk Traulsen 
@_subject: Feature request: expand 'clean' to 'clean total' 
I started this thread to make a request for a change of the behaviour of the 'clean' option:
When there was some support for my idea, but no reaction from the developers, I tried to implement it myself and sent the code to the gnupg-devel mailing list. After some emails about the name and the concept David Shaw decided to go the KISS* way and implemented a change to 'clean' itself:
So, fortunately in 1.4.3, there will be a 'clean', which does exactly what 'clean total' should have done.
* KISS = Keep it simple, stupid!

@_date: 2005-10-26 10:24:25
@_author: Dirk Traulsen 
@_subject: clean sigs 
Am 11 Sep 2005 um 23:01 hat David Shaw geschrieben:
I gave the naming some thought. Witty and funny names aside, I think there are so many commands and options, that it would be better to expand the name and not take a new one.
. I suggest following solution: a new option 'clean [total]'.
This could be the new part in the man-page:
clean     Cleans keys by removing unusable pieces.  This com-
          mand can be used to keep keys neat and  clean,  and
          it has no effect aside from that.
          sigs      Remove any signatures that are not usable
                    by the trust calculations.  For  example,
                    this  removes any signature that does not
                    validate.  It also removes any  signature
                    that  is superceded by a later signature,
                    or signatures that were revoked.
          uids      Compact  (by  removing   all   signatures
                    except  the  selfsig) any user ID that is
                    no  longer  usable  (e.g.   revoked,   or
                    expired).
          total     Remove like above any  unusable signature
                    and UID,  but  also  remove any signature
                    for which the signing key is not present.
If  invoked  with  no  arguments,  both `sigs' and `uids' are
If invoked without `total', only signatures for which the signing key is present can be evaluted.
What do you think about that, David?
I would really appreciate such a function and I'm sure, that I'm not the only one. Please consider to implement it.
As I cannot do it myself, maybe I can help with this proposal.

@_date: 2005-10-27 12:05:55
@_author: Dirk Traulsen 
@_subject: Feature request: expand 'clean' to 'clean total' 
I first posted this under an old (but fitting) thread and got no response. Sorry, if you already read it.
Nowadays there are quite some keys, which have several hundred signatures on their UIDs. This is a good thing for the WoT, but it clutters the local keyrings, as normally you don't have most of these signing keys. If the keys on your keyring are completely trusted, you don't need the additional signatures. Until now there is the option 'clean sigs' under '--edit KEY', but it does only delete sigs, which can be verified by gpg through comparison with the corresponding signing key.
So here is my feature request:
Please make an option to delete signatures, for which there is no corresponding signing key on the local keyring.
I think there are so many commands and options, that it would be better to expand the name and not take a new one.
I suggest following solution: add a new option 'clean total' to the known options 'clean sigs' and 'clean uids'.
This could be the new part in the man-page:
===========Proposal for the man-page==============
clean     Cleans keys by removing unusable pieces.  This com-
          mand can be used to keep keys neat and  clean,  and
          it has no effect aside from that.
          sigs      Remove any signatures that are not usable
                    by the trust calculations.  For  example,
                    this  removes any signature that does not
                    validate.  It also removes any  signature
                    that  is superceded by a later signature,
                    or signatures that were revoked.
          uids      Compact  (by  removing   all   signatures
                    except  the  selfsig) any user ID that is
                    no  longer  usable  (e.g.   revoked,   or
                    expired).
          total     Remove like above any  unusable signature
                    and UID,  but  also  remove any signature
                    for which the signing key is not present.
If  invoked  with  no  arguments,  both `sigs' and `uids' are
If invoked without `total', only signatures for which the signing key is present can be evaluted.
===========Proposal for the man-page==============
What do you think about that, David?
I would really appreciate such a function and I think (hope), that I'm not the only one. Please consider to implement it.
As I cannot do it myself, maybe I can help with this proposal.

@_date: 2005-10-30 07:05:21
@_author: Dirk Traulsen 
@_subject: Feature request: expand 'clean' to 'clean total' 
Am 29 Oct 2005 um 2:25 hat Henry Hertz Hobbit geschrieben:
Yes, you do! This does not effect the keys on the keyservers! The keyservers always only add or merge the keys they are sent. This means, if there is already a key with that ID, they take the sent key apart and add the new parts (if there are any). 'clean total' would have absolutely no effect on the keyservers or the WoT.
The proposal is about all those [User ID not found] in the keys in your LOCAL keyring. My proposal would only have an effect on the keyringsize on your storage media. Even in my really small keyring, there are several thousand of unused signatures. Can you imaging the effect on local keyrings with hundreds of keys? Because you don't have the corresponding signing key in your local keyring, gpg cannot verify them, so these signatures are not useful for you. (With the exception, that you have a visual hint that there are more signatures on the keyservers.) This cleaning effect only lasts until the next '--refresh-keys', where you always get the complete keys with all signatures from the keyserver. If you had put the proposed option 'clean total' in your keyserver-options or import-options, then like 'clean' today, gpg would first import the complete key and after checking which signatures are still not usable, automatically clean the keys again.
I obviously think this to be a good thing to have, but I'm a little discouraged by the nearly total lack of interest of the list.
I would really appreciate a discussion of the proposed feature and change of the man-page. Please write if you think that it's a waste of time or preferably that you would like to have this feature.

@_date: 2005-09-07 18:39:37
@_author: Dirk Traulsen 
@_subject: clean sigs 
I loaded a new key from a keyserver and cleaned it in the '--edit-
key' shell.
When I controlled the result with 'gpg --list-sigs 08B0A90B',
I found a lot of expired signatures. If you look at the output at sigs from the key CA57AD7C, you see that there are 7 valid newer signatures from this key and a lot of older expired signatures.
I thought, that these sigs should be deleted, if there is a newer valid signature from the same key.

@_date: 2005-09-08 10:23:29
@_author: Dirk Traulsen 
@_subject: clean sigs 
Am 7 Sep 2005 um 19:23 hat David Shaw geschrieben:
As you can see, I did. I get the message 'already clean', but the sigs are still there.
In spite the output being partly in german, I think it will be ok for C:\>gpg --ed putty
gpg (GnuPG) 1.4.2; Copyright (C) 2005 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.
pub  1024D/08B0A90B  created: 2000-12-20  expires: niemals     usage:                      trust: unbekannt     G?ltigkeit: unbekannt
[ unknown] (1). PuTTY Releases (DSA) Befehl> clean sigs
User ID "PuTTY Releases (DSA) ": already clean.
Befehl> q
C:\>gpg --list-sigs putty
Schl?sselbund: C:\Dokumente und

@_date: 2005-09-09 00:32:01
@_author: Dirk Traulsen 
@_subject: clean sigs 
Am 8 Sep 2005 um 16:00 hat David Shaw geschrieben:
I did what you asked me to do and now I'm completely confused!
First I deleted my gpg.conf, the keyrings and the trustdb.
Then I fetched the key 08B0A90B from the keyserver 'random.sks.keyserver.penguin.de' and it was the same as yesterday: 47 sigs with a lot of old expired sigs from the same key (see output1 below) and 'clean' later removed just one self sig and all the old ones were still there. As 'clean' did the same as yesterday, it had nothing to do with my gpg.conf, keyrings or trustdb.
Now I have three additional problems:
1. The same key from the same keyserver just one day later, but if you compare it with my output in my mail from yesterday, you see that the sigs are in a completely different order! Why? Aren't they always in the same order in the key? 2. There is a line after the '--recv-key' which I don't understand:
'gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FA10 (my english translation: gpg: no ultimately trusted key 0022FA10 As you can see in the output, I didn't ask for this key. There are no keyrings or trustdb, as I deleted them before. I don't know this key and I couldn't find it at the keyservers.
Why did gpg try to find this key?
3. Because now I was irritated, I did the same again with a different keyserver 'keyserver.kjsl.com' and I got a completely different result! When I fetched the key 08B0A90B, here it didn't have 47 sigs, but only 15 sigs (see below output2). There was only a double self sig, which 'clean' removed later. How can this be, if the keyservers are synchronized?
I repeated this twice with the same outcome. The keys are different and 'clean' doesn't work on the larger one. My system is gpg 1.4.2 on WinXP Home with the latest updates.
David, I really hope, you can reproduce it now or at least get an idea what's going on.
++++++++++++++ Output1 +++++++++++++++++++
C:\DOKUME~1\Chef\Anwendungsdaten\gnupg>gpg -k
gpg: Schl?sselbund `C:/Dokumente und Einstellungen/Chef/Anwendungsdaten/gnupg\secring.gpg' erstellt
gpg: Schl?sselbund `C:/Dokumente und Einstellungen/Chef/Anwendungsdaten/gnupg\pubring.gpg' erstellt
gpg: C:/Dokumente und Einstellungen/Chef/Anwendungsdaten/gnupg\trustdb.gpg: trust-db C:\DOKUME~1\Chef\Anwendungsdaten\gnupg>gpg --keyserver random.sks.keyserver.penguin.de --recv-key 08b0a90b
gpg: requesting key 08B0A90B from hkp server gpg: key 08B0A90B: public key "PuTTY Releases (DSA) " imported
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FA10 gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1
C:\DOKUME~1\Chef\Anwendungsdaten\gnupg>gpg --list-sigs putty
pub   1024D/08B0A90B 2000-12-20
uid                  PuTTY Releases (DSA) sig          6A93B34E 2000-12-20  [User-ID nicht gefunden]
sig          CC350332 2002-06-17  [User-ID nicht gefunden]
sig          56C5DD90 2003-06-24  [User-ID nicht gefunden]
sig          ADEB818B 2003-07-04  [User-ID nicht gefunden]
sig          50376667 2003-07-04  [User-ID nicht gefunden]
sig          9DB2B5BC 2003-07-04  [User-ID nicht gefunden]
sig          677BA1EC 2004-10-26  [User-ID nicht gefunden]
sig          E213B692 2004-10-26  [User-ID nicht gefunden]
sig          5DC3F473 2004-10-26  [User-ID nicht gefunden]
sig          30B94B5C 2005-05-24  [User-ID nicht gefunden]
sig 2        66A9A510 2005-01-27  [User-ID nicht gefunden]
sig 2        348DA95A 2005-04-06  [User-ID nicht gefunden]
sig 3        08B0A90B 2000-12-20  PuTTY Releases (DSA) sig 3        08B0A90B 2000-12-20  PuTTY Releases (DSA) sig       X  CA57AD7C 2005-01-11  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-01-25  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-02-07  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-02-16  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-02-19  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-03-05  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-03-20  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-04-03  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-04-17  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-05-01  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-05-15  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-05-17  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-05-30  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-05-31  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-06-15  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-06-19  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-06-20  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-07-10  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-07-11  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-07-24  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-07-29  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-07-31  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-07-31  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-08-15  [User-ID nicht gefunden]
sig       X  CA57AD7C 2005-08-21  [User-ID nicht gefunden]
sig          CA57AD7C 2005-08-27  [User-ID nicht gefunden]
sig          CA57AD7C 2005-08-27  [User-ID nicht gefunden]
sig          CA57AD7C 2005-08-28  [User-ID nicht gefunden]
sig          CA57AD7C 2005-08-30  [User-ID nicht gefunden]
sig          CA57AD7C 2005-08-31  [User-ID nicht gefunden]
sig          CA57AD7C 2005-09-02  [User-ID nicht gefunden]
sig          CA57AD7C 2005-09-04  [User-ID nicht gefunden]
sig          66A14468 2004-10-26  [User-ID nicht gefunden]
+++++++++++++ Output2 +++++++++++++++++++++++
C:\DOKUME~1\Chef\Anwendungsdaten\gnupg>gpg -k
gpg: Schl?sselbund `C:/Dokumente und Einstellungen/Chef/Anwendungsdaten/gnupg\secring.gpg' erstellt
gpg: Schl?sselbund `C:/Dokumente und Einstellungen/Chef/Anwendungsdaten/gnupg\pubring.gpg' erstellt
gpg: C:/Dokumente und Einstellungen/Chef/Anwendungsdaten/gnupg\trustdb.gpg: trust-db C:\DOKUME~1\Chef\Anwendungsdaten\gnupg>gpg --keyserver keyserver.kjsl.com --recv-key 08b0a90b
gpg: requesting key 08B0A90B from hkp server keyserver.kjsl.com
gpg: key 08B0A90B: public key "PuTTY Releases (DSA) " imported
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FA10 gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1
C:\DOKUME~1\Chef\Anwendungsdaten\gnupg>gpg --list-sigs putty
pub   1024D/08B0A90B 2000-12-20
uid                  PuTTY Releases (DSA) sig 3        08B0A90B 2000-12-20  PuTTY Releases (DSA) sig 3        08B0A90B 2000-12-20  PuTTY Releases (DSA) sig          30B94B5C 2005-05-24  [User-ID nicht gefunden]
sig 2        348DA95A 2005-04-06  [User-ID nicht gefunden]
sig          50376667 2003-07-04  [User-ID nicht gefunden]
sig          56C5DD90 2003-06-24  [User-ID nicht gefunden]
sig          5DC3F473 2004-10-26  [User-ID nicht gefunden]
sig          66A14468 2004-10-26  [User-ID nicht gefunden]
sig 2        66A9A510 2005-01-27  [User-ID nicht gefunden]
sig          677BA1EC 2004-10-26  [User-ID nicht gefunden]
sig          6A93B34E 2000-12-20  [User-ID nicht gefunden]
sig          9DB2B5BC 2003-07-04  [User-ID nicht gefunden]
sig          ADEB818B 2003-07-04  [User-ID nicht gefunden]
sig          CC350332 2002-06-17  [User-ID nicht gefunden]
sig          E213B692 2004-10-26  [User-ID nicht gefunden]

@_date: 2005-09-09 16:16:16
@_author: Dirk Traulsen 
@_subject: clean sigs 
Am 8 Sep 2005 um 20:00 hat David Shaw geschrieben:
I can confirm, that 'clean' worked as you said, when I first fetched the keys for the obsolete sigs.
But why is it nescessary to fetch the key first? When there is a new, functional and valid signature from key 12345678 on a key, isn't it obvious from the originally 16 character keyID, that they were issued from the same key, whether I have it in my keyring or not?
Couldn't gpg delete the old obsolete signatures without the signing key itself?

@_date: 2005-09-09 16:16:28
@_author: Dirk Traulsen 
@_subject: gpg looking for strange additional key upon import (was Re: clean 
Am 8 Sep 2005 um 20:00 hat David Shaw geschrieben:
No, I didn't and I deleted the keyrings and the trustdb, so how could gpg know?
I tried a lot of combinations and found, that the message comes only, when a new (meaning not in the pubring) public key is imported directly or via keyserver and there is no ultimately trusted public key in the pubring. This does not depend on the existence of a secret key. It is independent of the used keyserver, the preferences and whether the imported key was made with gpg 1.0.7 - 1.4.2 or pgp.
This is true for gpg 1.4.2 under Win95 and WinXP. Until now I could not test it under Linux.
But the strange line comes not, when I generate new key pairs, export, transport the ascii files internally and '--import' them. It doesn't matter on which system (Win95, WinXP, Linux) or program (gpg1.0.7 -1.4.2, pgp) the keys are generated.
Interestingly there is a difference, whether I use '--import' to get a key from a 'key.asc' or '--recv-key' to import it from a keyserver.
It reproducibly asks for two different, not existing keys. On WinXP it is always 0022FB70 when a key gets '--import'ed and 0022FA10 when it is '--recv-key'ed. It is the same for Win95, but with other key IDs: 0080F760 for '--import' and 0080F8F0 for '--recv-key'.
+++++++ Output '--import' +++++++++++++++++++++++
C:\>gpg --import koch.asc
gpg: key 57548DCD: public key "Werner Koch (gnupg sig) " imported
gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FB70 +++++++ Output '--recv-key' +++++++++++++++++++++
C:\Dokumente und Einstellungen\Chef\Anwendungsdaten\gnupg>gpg --
keyserver keyserver.kjsl.com --recv-key 08B0A90B
gpg: requesting key 08B0A90B from hkp server keyserver.kjsl.com
gpg: key 08B0A90B: public key "PuTTY Releases (DSA) " imported
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FA10 gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1
+++++++ Output '--import' of a new generated key ++++++
C:\>gpg --import newkey.asc
gpg: key A6F74F00: public key "newkey " imported
gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1

@_date: 2005-09-10 14:19:37
@_author: Dirk Traulsen 
@_subject: gpg looking for strange additional key upon import (was 
Am 9 Sep 2005 um 10:29 hat David Shaw geschrieben:
Ok, I'll try.
First, I did this with gpg 1.4.2 under WinXP and confirmed my findings on another machine with gpg 1.4.2 under Win95. Your machine seems to be Linux. Unfortunately I cannot test gpg 1.4.2 under Linux at the moment.
The first output below is what I described the last two days. When there is not at least one public key in the keyring, which has ultimate trust, gpg tries to find non-existing keys upon importing or receiving (but not from new generated keys). See above for the constant key IDs.
Today I thought about it and concluded, it could be dependent on a read of the trustdb after a change and not specifically the import. I made some experiments and it seems to be true. When I set the trust-
model via gpg.conf to direct or always,  this line never comes. I tried to find the simplest situation for you. I hope, this is simple I deleted everything, added one public key (Werners :) ), set it to ultimate trust, set it back to full trust to have the change in the trustdb and issued --list-key. As you can see below, it brings up the And something new: When I ask for the secret keys after the same procedure, it asks for a new third key ID, which is always the same like the other two. And like before, it is the same on Win95, but with a different ID.  I hope, this will help you and that maybe somebody else can reproduce   (Delete keyrings and trustdb. I did not delete random_seed.   Does it matter? Made new gpg.conf with only one line for   shorter output: no-greeting)
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>del *.gpg
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>del *.bak
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>edit gpg.conf
  (Import previously exported key file =>
  gpg states: no ultimately trusted key 0022FB70 found)
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>gpg --import koch.asc
gpg: key 57548DCD: public key "Werner Koch (gnupg sig) " imported
gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FB70   (Next one is just to show, it has nothing to do with Werners key)
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>gpg --import binner.asc
gpg: key D86A0D19: public key "Stephan Binner " gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FB70   (Import a new generated, exported and then deleted key =>
  The line comes not!)
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>gpg --import koch.asc
gpg: key 57548DCD: "Werner Koch (gnupg sig) " not gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                             unver?ndert: 1
  (Fetch key from keyserver (tried several) =>
  gpg states: no ultimately trusted key 0022FA10 found)
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>gpg --keyserver random.sks.keyserver.penguin.de --recv-key 08b0a90b
gpg: requesting key 08B0A90B from hkp server gpg: key 08B0A90B: public key "PuTTY Releases (DSA) " imported
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FA10 gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1
  (Start again with deleting everything. Made new gpg.conf
  with only one line for shorter output: no-greeting)
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>del *.bak
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>del *.gpg
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>edit gpg.conf
  (As before: Import previously exported key file =>
  gpg states: no ultimately trusted key 0022FB70 found)
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>gpg --import koch.asc
gpg: Schl?sselbund `C:/Dokumente und Einstellungen/Dirk/Anwendungsdaten/gnupg\secring.gpg' erstellt
gpg: Schl?sselbund `C:/Dokumente und Einstellungen/Dirk/Anwendungsdaten/gnupg\pubring.gpg' erstellt
gpg: C:/Dokumente und Einstellungen/Dirk/Anwendungsdaten/gnupg\trustdb.gpg: trust-db gpg: key 57548DCD: public key "Werner Koch (gnupg sig) " imported
gpg: Anzahl insgesamt bearbeiteter Schl?ssel: 1
gpg:                              importiert: 1
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FB70   (Set trust to ultimate (I shortened the output))
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>gpg --ed koch
Befehl> trust
Please decide how far you trust this user to correctly verify other users' keys
(by looking at passports, checking fingerprints from different sources, etc.)
  1 = I don't know or won't say
  2 = I do NOT trust
  3 = I trust marginally
  4 = I trust fully
  5 = I trust ultimately
  m = back to the main menu
Ihre Auswahl? 5
Do you really want to set this key to ultimate trust? (y/N) y
Befehl> q
  (Set trust back to full => no ultimately trusted public key there
  (even further shortened output))
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>gpg --ed koch
gpg: "Trust-DB" wird ?berpr?ft
gpg: 3 marignal-needed, 1 complete-needed, PGP Trust-Modell
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
gpg: n?chste "Trust-DB"-Pflicht?berpr?fung am 2005-12-31
pub  1024D/57548DCD  created: 1998-07-07  expires: 2005-12-31  usage:                trust: uneingeschr?nkt G?ltigkeit: uneingeschr?nkt
[ultimate] (1). Werner Koch (gnupg sig) Befehl> trust
Ihre Auswahl? 4
Befehl> q
  (Now when I ask for the key-list, there is a look at the trustdb
  and gpg states: no ultimately trusted key 0022FB70 found)
C:\DOKUME~1\Dirk\ANWEND~1\gnupg>gpg -k
gpg: "Trust-DB" wird ?berpr?ft
gpg: kein uneingeschr?nkt vertrauensw?rdiger Schl?ssel 0022FB70 C:/Dokumente und Einstellungen/Dirk/Anwendungsdaten/gnupg\pubring.gpg

@_date: 2005-09-10 14:19:47
@_author: Dirk Traulsen 
@_subject: clean sigs 
Am 9 Sep 2005 um 10:46 hat David Shaw geschrieben:
Ok, now I understand. Maybe it would be helpful to write it in the man page, that you need the key for cleaning. I think, it would be a good thing to have, especially if you have  limited space. The name is funny too.
Thank you for your help

@_date: 2006-06-06 11:25:55
@_author: Dirk Traulsen 
@_subject: some questions.. 
Am 27 May 2006 um 19:55 hat J?rgen Lysdal geschrieben:
If you sent your key to a keyserver, then you are out of luck. There is no way to take something back you sent to a keyserver. You can only revoke things, but to add a revoker is unrevocable itself for security reasons. The only possibility for you is to revoke the key by yourself, but that is also the only damage a bad revoker can do to your key, so ...
As the addition of a revoker to a key is the addition of a signature, there is a non-trivial way to get rid of it, when and only when you kept the key for yourself. If this is the case, ask again and I will send you instructions.

@_date: 2007-04-23 11:42:01
@_author: Dirk Traulsen 
@_subject: UID changes (was Key Revocation) 
Am 21 Apr 2007 um 23:25 hat Henry Hertz Hobbit geschrieben:
Is it really necessary to generate a new revocation certificate if you only change the UID?
I thought a revocation certificate is calculated only directly on the key itself and so a change of the UIDs would not alter the revocation

@_date: 2007-07-28 17:22:49
@_author: Dirk Traulsen 
@_subject: GnuPG and PGP 5.0 compatibility problem 
Am 27 Jul 2007 um 10:31 hat Werner Koch geschrieben:
Is debug and its output format documented somewhere?

@_date: 2007-07-28 17:22:49
@_author: Dirk Traulsen 
@_subject: GnuPG and PGP 5.0 compatibility problem 
Am 27 Jul 2007 um 10:31 hat Werner Koch geschrieben:
Is debug and its output format documented somewhere?

@_date: 2007-06-22 08:52:10
@_author: Dirk Traulsen 
@_subject: Question about check command 
Am 4 Jun 2007 um 20:56 hat hs2412 at gmail.com geschrieben:
Hi Hardeep,
there are two answers to your question: A simple one and a difficult It's easy to answer why these three differ, but not trivial to find the answer why they have the exclamation mark in common. 1. Why are there signatures shown with nothing, 1 or 3 after the exclamation mark?
They are flags showing the certification check level or trust level the signer gave the UID and the key, while signing (certifying) it. 1-3 should be clear and zero is shown as sig! (not sig!0).
You can find the solution in the manual:
 --list-sigs
     For  each  signature  listed, there are several flags in between
     the "sig" tag and keyid. These flags give additional information
     about  each  signature. From left to right, they are the numbers
     1-3 for certificate check level (see --ask-cert-level), "L"  for
     a local or non-exportable signature (see --lsign-key), "R" for a
     nonRevocable signature (see the  --edit-key  command  "nrsign"),
     "P"  for a signature that contains a policy URL (see --cert-pol-
     icy-url), "N" for a signature  that  contains  a  notation  (see
     --cert-notation),  "X" for an eXpired signature (see --ask-cert-
     expire), and the numbers 1-9 or "T" for 10 and above to indicate
     trust signature levels (see the --edit-key command "tsign").
--default-cert-level n
     The default to use for the check level when signing a key.
     0 means you make no particular claim as  to  how  carefully  you
     verified the key.
     1 means you believe the key is owned by the person who claims to
     own it but you could not, or did not verify the key at all. This
     is  useful  for a "persona" verification, where you sign the key
     of a pseudonymous user.
     2 means you did casual verification of  the  key.  For  example,
     this  could  mean that you verified that the key fingerprint and
     checked the user ID on the key against a photo ID.
     3 means you did extensive verification of the key. For  example,
     this  could  mean that you verified the key fingerprint with the
     owner of the key in person, and that you checked, by means of  a
     hard to forge document with a photo ID (such as a passport) that
     the name of the key owner matches the name in the user ID on the
     key,  and  finally that you verified (by exchange of email) that
     the email address on the key belongs to the key owner.
     Note that the examples given above for levels 2 and 3  are  just
     that:  examples. In the end, it is up to you to decide just what
     "casual" and "extensive" mean to you.
     This option defaults to 0 (no particular claim).
2. What meaning has the exclamation mark?
This is a question originally targeted to the developers of gnupg as it is not documented anywhere. At least I did not find it. It is not even documented in the DETAILS file. This made me so curious, that I downloaded the actual source code and began searching for the Well, here is what I found:
The signature list is put together by two different functions in
g10\keylist.c -> list_keyblock_print and list_keyblock_colon,
depending whether you used --with-colon as option or not.
The flag directly behind the sig gives the result of the signature It is one of the following flags: [ ],!,-,%,?.
empty = no signature check
!     = successful check = good signature
-     = bad signature
%     = other error during check
and only when using the --with-colon option (why?):
?     = no or unusable public key
So, this is my analysis of the source code and I'm really quite confident that it is correct, but it should be confirmed by a developer of gnupg.
And I think, as this is part of the output, it really should get documented in the manual and at least in the DETAILS file.

@_date: 2007-06-22 08:52:09
@_author: Dirk Traulsen 
@_subject: errors in manual 
I found 3 problems in the manual:
1. In the new manual the following options are missing:
2. The manual has now strange gaps in it (at least under German Here are 3 examples:
   SYNOPSIS
   gpg [--homedir ___] [--options ____] [_______] _______ [____]
   --gen-random 0|1|2
          Emit _____ random bytes of the given quality level.
   --gen-key
          ...
          in batch mode. See the file `___________' in the source
3. Please see part 2 of my parallel mail "Re: Question about check The check sigs flags are not documented.

@_date: 2007-11-06 18:42:33
@_author: Dirk Traulsen 
@_subject: New OpenPGP standard published 
Am 2 Nov 2007 um 11:52 hat David Shaw geschrieben:
Congratulations for the new RFC!
But, since 2004, I report regularly at least once a year that the example for the Radix-64-Encoding in '6.5. Examples of Radix-64' on page 59 in the rfc is wrong.
With David Shaw on the board, I thought, it might be different, so I tried again and really... Am 13 Jun 2006 um 17:12 hat David Shaw geschrieben:
Now after all these versions there is a brand new rfc4880, but surprise, surprise, in this example embarrassingly 7 is still 0b1111, which leads to 0b100111, which is decimal not the correct 37, but 39.
The same old error since at least NINE years in an example how to use the standard.
Well, this gets really, really frustrating!
This is such a blatant error, which really cannot be disputed. If even such a simple error is never corrected, how would it be if I as no committee member really wanted to comment on something important in OpenPGP itself?
A totally pointless effort, I'm sure.

@_date: 2008-04-26 08:54:52
@_author: Dirk Traulsen 
@_subject: Naming of GnuPG 
Am 21 Apr 2008 um 9:43 hat David Shaw geschrieben:
As gpg2 seems to generate a lot of confusion, I second the renaming to make the different purposes as clear as possible.
The main and most important difference is the addition of S/MIME, so it should be part of the new name and command.
How about:
gpg   ==  GnuPG      ==  GnuPG Classic
gpgs ==  GnuPG+S  ==  GnuPG+S/MIME

@_date: 2008-04-26 12:24:31
@_author: Dirk Traulsen 
@_subject: Naming of GnuPG 
Am 26 Apr 2008 um 2:20 hat Robert J. Hansen geschrieben:
Funny, I first had exactly the same idea!
But I choose "gpgs", because besides being a bit longer to type, "gnups" has one point, which is not perfect:
It doesn't contain the well-known "gpg" in the name in spite of sharing the same code base for OpenPGP.
But I'm sure, either name gives less problems than GnuPG 2.0. If you keep this name, you will have to explain again and again and again...

@_date: 2008-02-25 09:59:36
@_author: Dirk Traulsen 
@_subject: How know who is a file encrypted for ? 
Am 8 Feb 2008 um 15:23 hat David Shaw geschrieben:
No, not really. gpg asks three times for the password for each recipient one after the other. If you are the third recipient, you have to give 6 times a wrong password until you can finally input the correct one. This gets real fun when there are ten recipients...
It would be nice, if 1. gpg would take the password and test it automatically with all recipients keys.
2. there would be a command --recipient-keys which would just list all recipient keys of an encrypted file, so I could see in advance whether my key is one of them.

@_date: 2008-02-25 19:27:56
@_author: Dirk Traulsen 
@_subject: How know who is a file encrypted for ? 
Am 25 Feb 2008 um 8:01 hat Tracy D. Bossong geschrieben:
No, it does not!
  does the same as  .
The only difference is that gpg gives additional packet information before asking the passphrases three times for each recipient. So the described problem for an encrypted file with several recipients stays the same.
C:\>gpg --list-packets file.gpg
:pubkey enc packet: version 3, algo 16, keyid F2A47460E192093D
        data: [4095 bits]
        data: [4095 bits]
You need a passphrase to unlock the secret key for
user: "Dirk Traulsen (dtl-2) "
4096-bit ELG-E key, ID E192093D, created 2005-10-21 (main key ID Please enter the passphrase:
Dirk Traulsen

@_date: 2008-02-26 08:48:57
@_author: Dirk Traulsen 
@_subject: How know who is a file encrypted for ? 
The two wishes I listed for gpg were:
1. If there are several recipients, test the given passphrase automatically for all secret keys in your keyring, so that you don't have to give for example 9 times a wrong one if you are recipient number four, which you even don't know beforehand.
2. A command which lists the recipients of an encrypted file.
The first proposal is much more interesting as it would remedy a nuisance if you regularly work with files with several recipients.
I really don't see a possible security problem here. Passphrases are to decrypt symmetrically the secret keys, nothing else. So we are only talking about secret keys in the keyring where
a. all keys belong to me or
b. some keys do not belong to me in a common keyring.
In case a. there is no problem, I just give the first asked passphrase. But in case b, where it is the nuisance I described, you could only be unsure whether someone could guess your password. This is a completely different problem but has nothing to do with my proposal as now gpg also asks you three times to give a passphrase for these keys. You see, nothing changes securitywise.
What I would like:
gpg encrypted_file.gpg
-> output nice list of the recipients with UIDs (ideally with
    indication, which one is in the secret keyring)
-> ask for passphrase if at least one is in the secret keyring,
    otherwise tell that you can't decrypt the file
-> test each secret key in the secret keyring with the passphrase
-> if there was a hit, tell so and decrypt
-> if not, give two more chances
For the second wish Tracy D. Bossong mentioned
as a solution, which goes at least a bit in the right direction as it lists all the keyids. Interestingly it lists nicely the keys for which there is no secret key in our keyring, like David Shaws in this C:\>gpg --list-packets --list-only file.gpg
:pubkey enc packet: version 3, algo 16, keyid 79F51929AC2E2384
        data: [4096 bits]
        data: [4096 bits]
:pubkey enc packet: version 3, algo 16, keyid E3B52841743DD3E2
        data: [4096 bits]
        data: [4093 bits]
:pubkey enc packet: version 3, algo 16, keyid AE2827D11643B926
        data: [2047 bits]
        data: [2046 bits]
:pubkey enc packet: version 3, algo 16, keyid 9166EB1E0B9DCED2
        data: [4095 bits]
        data: [4096 bits]
:encrypted data packet:
        length: 81
        mdc_method: 2
gpg: verschl?sselt mit 2048-Bit ELG-E Schl?ssel, ID 1643B926, erzeugt       "David M. Shaw "
What I proposed with --recipient-keys is an output of a nice list of all the recipient keys like the last one here. And why not by the way even highlight for which one you have the secret key in the keyring?
PS: Tracy, you seem to have a serious problem with your citing of other mails. You are citing them
per line. To be sure that it is no artefact on my side, I checked the archives.
See and compare to below. There is definitely something wrong on your side.
I stop copying here. This should be enough to show the problem.

@_date: 2008-02-26 10:49:16
@_author: Dirk Traulsen 
@_subject: How know who is a file encrypted for ? 
Am 26 Feb 2008 um 9:40 hat Sven Radde geschrieben:
You are completely right that this is nothing for a maximum security usage, not the scenario one would like to have and not what I have at But think of one computer which is used together by several people in a working group or a shared flat. As the computer itself is physically reachable to several people you have no other chance as to trust these people not to mess with the computer. In these cases where there is no high security possible, you don't really get more security by using different keyrings.

@_date: 2008-02-27 10:00:25
@_author: Dirk Traulsen 
@_subject: How know who is a file encrypted for ? 
Am 26 Feb 2008 um 9:55 hat vedaal at hush.com geschrieben:
You don't believe me to enter 9 times a complete passphrase, do you?
You are right, that it is possible to live with it, but why not implement something more comfortable if it doesn't lower the security What I meant, was something like this mockup:
============== C:\>gpg --recipient-keys ENCRYPTED_FILE.gpg
gpg: file ENCRYPTED_FILE.gpg was encrypted to the following keys:  gpg: encrypted with 2048-bit ELG-E key, ID 1643B926, created 2002-01-28
      "David M. Shaw "
gpg: encrypted with 4096-bit ELG-E key, ID E192093D, created 2005-10-21
      "Dirk Traulsen (dtl-2) "
gpg: secret key with ID E192093D in keyring
gpg: encrypted with 2048-bit RSA key, ID 85306D25, created 2000-09-05
      "vedaal nistar "
gpg: encrypted with RSA key, ID 710ACD97
gpg: encrypted with RSA key, ID 01B0C12D
==============  As you can easily see, there are 5 recipients: 3 in public keyring with 1 secret key in secret keyring, 2 not in keyring  This is the result, I get from your example:
  PGPdump Results
Old: Public-Key Encrypted Session Key Packet(tag 1)(268 bytes)
 New version(3)
 Key ID - 0x7DC4274AF9015496
 Pub alg - RSA Encrypt or Sign(pub 1)
 RSA m^e mod n(2047 bits) - ...
 -> m = sym alg(1 byte) + checksum(2 bytes) + PKCS-1 block type 02
Old: Public-Key Encrypted Session Key Packet(tag 1)(268 bytes)
 New version(3)
 Key ID - 0xA306C37B495CA15B
 Pub alg - RSA Encrypt or Sign(pub 1)
 RSA m^e mod n(2045 bits) - ...
 -> m = sym alg(1 byte) + checksum(2 bytes) + PKCS-1 block type 02
While pgpdump gives an really interesting output, it does not deliver what I asked for:
A nicely formated list of the recipients of an encrypted file.

@_date: 2008-02-27 18:55:28
@_author: Dirk Traulsen 
@_subject: How know who is a file encrypted for ? 
Am 27 Feb 2008 um 9:51 hat vedaal at hush.com geschrieben:
Oh God! You REALLY thought I am so stupid that I type in complete passphrases 9 times. I cannot believe it. I first thought you made fun on me. Do I really sound like a complete moron here?
1. I thought, it was self-evident that one just hits  to go through the questions, so I didn't mention it.
2. And to repeat myself:
The examples I described for wish number one, where not MY scenarios I LIKE to have at home! There I'm in control of the computer and I can setup everything logical and secure.
But when you are NOT in control of the computer you are supposed to work with and you experience a scenario like I described, then you just have to live with it. (Which might be a bit more comfortable, that's On to the obviously more realistic wish number 2: --recipient-keys
Thanks. So at least three people think it would be a good addition.

@_date: 2008-02-28 08:59:18
@_author: Dirk Traulsen 
@_subject: Sorting the recipeint keys (was: How know who is a file encrypted 
Am 27 Feb 2008 um 19:47 hat Werner Koch geschrieben:
Werner, please do it. Making decryption clearly more comfortable is a good thing and the better if you personally have a benefit of it.

@_date: 2008-02-28 09:33:30
@_author: Dirk Traulsen 
@_subject: How know who is a file encrypted for ? 
Am 27 Feb 2008 um 13:23 hat David Shaw geschrieben:
I want to list just some use cases, where you only need the recipients and not the encrypted file content. I'm sure there are many more.
1. control
Your coworker encrypted an important file and you want to control whether it has the correct set of recipient keys before sending or archiving it.
2. curiosity
You want to know who else is getting the information in the file because he is also able to decrypt the file (I know about hidden-
3. finding
You don't remember the exact name of the file. But you know it was encrypted to XYZ also.
4. sorting
You want to sort the encrypted files in an archive depending on the Cool. This is an interesting possibility to nearly get what I asked for, but not very user friendly. I now have this excellent tip from you, but I think it would be nice to have a clearly named command which people can find in the manual. --list-recipients would be an excellent name, I think.
Ideally additionally in a --with-colons format for easier scripting.

@_date: 2008-02-28 13:11:55
@_author: Dirk Traulsen 
@_subject: How know who is a file encrypted for ? 
Am 28 Feb 2008 um 10:04 hat Wilhelm M?ller geschrieben:
David didn't say he doesn't want this new command, but asked seriously for some use cases.
It kind of partially works. With --verbose it at least mentions your own subkeys, but still doesn't print the uids or the primary keyid. No nice consistent output and a 'somewhat hidden' command.
If you prefer not changing anything then Davids tip is much better.
