
@_date: 2003-10-02 03:19:01
@_author: Jacob Anawalt 
@_subject: Using GPG to create virtual email addresses 
Jacob Anawalt said:
Let me expand on this idea a little more. It seems that a signature must
have something that says what encryption was used and some info that
allows the unencoder to know who's signature it is and then an encoded
hash of the data it is signing. When I sign a lot of data the signature is
large. When I sign very little data, it is small. In either case there
seems to be a substantial amount of header data.
If we pre-agree on an algorithm and we know externally the claimed 'owner'
of the signature by looking at the MAIL FROM value, how small can the
signature be? Could it fit within (64 - size of GPG id + 1) and be only
local-part compliant data?
I would much prefer the double encrypted data idea, but if that is out of
the question then I would at least want a piece of signed data accessable
by the RCPT TO stage to help show the MAIL FROM was not forged.
There hasn't been a response yet so I wonder if I'm asking in the wrong
place or if people are reading this and rolling their eyes. Even a quick
note to say I'm way off base or looking in the wrong direction would be
appreciated. ;)

@_date: 2003-10-04 10:41:01
@_author: Jacob Anawalt 
@_subject: Using GPG to create virtual email addresses 
You're right. I don't know how I thought I saw what I did. My test signature seems to have 64 characters, CRLF, 24 characters, CRLF, five characters. I have no idea which part is the hash and which is the key, or if it is all a key of the hash. If there were no data to hash, how small could this be? Only 22/27 bytes smaller?
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
So at least 44 of the 64 total bytes are just for the session key. That doesn't leave much.
In my first email I said that protection of the data is not the issue. I don't really care if my username is hidden, infact it may be advantageous if it is not hidden. What I am looking for is a virtual username (email address local-part) that is unique per sender/reciever pair, and the identity of that pair is some combination of the two's GPG information. Short of that, I would like a virtual username that has the recievers identity and the assurance that the sender is who they say they are built into it before making the decision to send a 4xx/5xx or say 250 OK and accept the data portion of the SMTP transaction.
Somehow I would like to use or tie back into the PGP/GPG trust system. Maybe I need to think of some parallel system where virtual email mapings are stored and somehow those mappings are signed by the users.
This full scope of this document is a bit beyond my comprehension at the moment. That is why I asked on this list. I am having a hard time gleaning the answer to my question(s) from it. I did read that implementations should not assume that the key ID is unique, so I won't count on that.
Am I just hoping for something that isn't going to work?

@_date: 2003-09-29 01:02:02
@_author: Jacob Anawalt 
@_subject: Using GPG to create virtual email addresses 
I am interested in using GPG to create virtual email addresses such that:
* The address is unique for every sender/reciever pair.
* The address will change if the sender or reciever changes keys.
* The admin doesn't have to do anything for a new valid virtual address to work.
* The reciever can have different processing rules based on the trust the reciever has in the sender.
* The origional encoded data is not sensitive or directly used.
* The system should be easy to use (transparent if possible) in the MUA * The system should enable the MTA to make SMTP time decisions decisions to accept or reject delivery.
* The virtual address should be hard for a 3rd party to create.
Sender jacob sends to jacob+gpgonly but the address is changed to jacob+JPO/F?WE/ASDIOD before it is sent from the MUA to the sending MTA.
The destination SMTP server (cachevalley.com) does a lookup after the MAIL FROM and RCPT TO commands verifying that jacob+JPO/F?WE/ASDIOD is a valid address for jacob-gpgonly and it was sent from and encoded by jacob Direct mails to jacob-gpgonly may or may not be accepted based on other The receiving mail server doesn't need to have it's recipient's private key. It is enough for it to decode using the sender's public key and then verify that the result was encoded by the recipient's public key.
In many aspects GPG seemes like a good fit. GPG plugins are available to many MUA platforms. The security is enhanced by a trust metric. Users of GPG are able to revoke old public keys and submit new ones at any time, the other party just needs to have their software fetch the latest public key before processing the data.
The first obstacle to me seems to be the size of the encoded data. RFC2821, section 4.5.3.1 says that the maximum lenght of local-part is 64 characters. The local-part after encryption needs to be RFC email envelope  compliant.
My question to this group is this:
Is there a method of encoding available to GPG such that it could make the local-part restrictions target and still have enough data to validate that encoding was created using a combination of the sender's private key and the receiver's public key (possibly by having been encoded twice, in that order).
Perhaps I don't even need the jacob+ part of the local-part. If that was not necessary then all 64 characters would be available to GPG. If the identity is necessary, maybe it should be + for better length control.
As I mentioned in the requirements section, the encrypted 'data' isn't realy used, except as a target of the encryption. Maybe there is some 'light signature' option that would work better. I think it would be best if either party could change their current public key and have that change reflected in all future virtual addresses until the next change, and yet have the new address recognized shortly after the change is made.
If GPG cannot and will not accommodate this, is there some encoding scheme out there that does?
MUA - Mail User Agent (Mutt, Pine, Outlook)
MTA - Mail Transport Agent (Sendmail, Postfix, Exim)
