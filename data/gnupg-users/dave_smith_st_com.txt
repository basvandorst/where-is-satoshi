
@_date: 2006-11-03 17:05:59
@_author: David SMITH 
@_subject: Summary: Windows GUI recommendation for USB disk 
...at the moment.
One Xbox360 runs more FLOPS than the world's fastest supercomputer of
little more than a decade ago (a fact that I still find incredible).
Of course, encryption is more about integer performance than FLOPS, but
I suspect that integer performance has scaled in the same orders of

@_date: 2006-10-27 17:54:39
@_author: David SMITH 
@_subject: Can't propagate key through public keyservers 
Skipped content of type multipart/mixed-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 185 bytes
Desc: not available
Url : /pipermail/attachments/20061027/1aea61dd/attachment-0001.pgp

@_date: 2006-10-30 10:41:39
@_author: David SMITH 
@_subject: Can't propagate key through public keyservers 
I thought so. :-)
I suspected as much.  I was just a bit surprised, as I've propagated my key
through public keyservers before, and never come across this problem.
I guess it must not like my new subkeys.
Thanks (to you and the others) for the suggestions on which keyservers to
try; I'll try them when I get home (as we have a rather restrictive
firewall here at work).
Does anyone have any more details on exactly *what* is "broken" on the
pks keyservers?  I'm going to have to convince our IT department that it's
the keyserver that's broken, and not my key (since no-one else has the
problem, as they all use single subkeys), and I think it's going to be
an uphill struggle to persuade them to install a brand new keyserver
rather than just tell me to create a new set of keys.

@_date: 2007-12-20 12:12:35
@_author: David SMITH 
@_subject: how to create a key with two user ids and two number ids 
Create a key with one UID, then edit the key and add a second UID.
Some hints from gpg --help:
  --gen-key                 generate a new key pair
  --edit-key                sign or edit a key
   +-> adduid      add a user ID

@_date: 2007-06-06 15:48:45
@_author: David SMITH 
@_subject: decrypt : primary key or subkey ? 
IME it is normal to get this message when using subkeys.
If you do 'gpg --list-keys --verbose', does it list the subkey 0CC897B5?
What about when you do 'gpg --list-secret-keys'?

@_date: 2007-06-06 17:01:21
@_author: David SMITH 
@_subject: decrypt : primary key or subkey ? 
You can't "add" a secret key to a public one - otherwise, there wouldn't
be much point to public key cryptography...
You will have generated a secret key when you generated the public key -
they're generated together.  Somehow you've managed to lose the secret
key.  You need to look around in the places where you generated/stored
the key to see if you can find it.  If you can't find it, then I'm
afraid that you're stuffed - you won't be able to decrypt your encrypted
information (short of brute-force cracking it).
Sorry for being the bearer of bad news...

@_date: 2007-06-07 09:27:08
@_author: David SMITH 
@_subject: decrypt : primary key or subkey ? 
No, you should have a subkey for both 0x2E604D51 /and/ 0x0CC897B5.
Here are the details of my keys:
bris0085(23)% gpg --list-keys --verbose
sec   1024D/F13192F2 2002-02-12
uid                  David Smith (Home) uid                  David Smith (STMicroelectronics) ssb   1024g/FA5EA4A2 2002-02-12
ssb   1024g/BE299CC1 2002-07-20
ssb   1024g/C8D6DAB9 2003-01-18
ssb   1024g/B643FF36 2003-11-09
ssb   1024g/80454033 2004-05-17
ssb   1024g/F5FE6DF8 2004-12-07
ssb   1024g/0DD8A13F 2005-09-05
ssb   1024g/9249F278 2006-06-20
Note that my main (signing) key has both public (pub) and secret (sec)
parts, and each of my subkeys have public (sub) and secret (ssb) parts.
Compare this with yours:
% gpg --list-secret-keys -v  0x2E604D51
gpg: no secret subkey for public subkey 0CC897B5 - ignoring
sec   1024D/2E604D51 2006-06-11
uid                  Bruno Costacurta uid                  Bruno Costacurta uid       [ revoked] pubmb01 uid       [ revoked] Bruno Costacurta uid       [ revoked] pubmb02 uid                  Bruno Costacurta You seem to have managed to lose the secret part of your subkey, either
through a bug or data corruption, or through human error.
Unless you can find the secret part of your subkey again, the public
part is worthless, and should be revoked by publishing a revocation
certificate.  This does, of course, assume that you generated a
revocation certificate before you lost the secret part....

@_date: 2007-06-07 15:00:49
@_author: David SMITH 
@_subject: decrypt : primary key or subkey ? 
Do you mean that you have already generated the revocation certificate
previously, or that you have just generated one now?
You only have one passphrase to protect the primary key; this passphrase
automatically protects all of its subkeys.
(Actually, I think that the passphrase protects the keyring file rather
than the key, but ICBW).  The fact that you don't have a separate
passphrase for your subkey is normal and not a problem.
As I mentioned, you don't have a separate password.
Public and secret parts are always generated together; they cannot be
generated separately.
Public parts are always used for encryption, and private parts are
always used for decryption.  There is an exception to this, where some
keys are used for signing, but I am ignoring this since you are talking
about keys generated for en/decryption.
There is no point in generating a key for encryption but not decryption -
they are always generated as a pair - public for encryption, and secret
for decryption.  If you think about it, any other scheme is nonsensical.
For example, encrypting with the secret key would mean that anyone could
decrypt the encrypted message (since the public key is, well, public).
The secret key can't be generated from the public key, for obvious
Somehow I think you've lost the secret part of the subkey.

@_date: 2007-05-15 09:59:58
@_author: David SMITH 
@_subject: Old PC as Hardware Security Module? 
As someone who has just implemented a hardware SHA-1/256 engine, "hard
For a piece of hardware, it's pretty simple - just lots and lots of
shifts, rotates, XORs and modulo addition.  The operations are not
difficult to do, but you have to do them repeatedly.  Realistically,
you'd need a pen and paper (unless you're one of these people with
incredible mathematical brainpower), and I'd guess that it'd take
the average "clued up" person (i.e. someone who knows what XOR,
modulo addition, etc. is) about half an hour for a small block of
For SHA-1, you need to store five working variables (all 32-bit), plus a
message schedule of sixteen 32-bit numbers.
For each 64 bytes of input message, you need to do 80 iterations of the
loop, each iteration contains 1 x 5-way addition, plus a two or 3-way
XOR, plus some ANDing and inversion on some of the iterations.
For SHA256, you've got eight working variables, and you only have 64
loop iterations per 64 bytes of data, but the operations in the loop
are much more complicated.
If you want more info, FIPS180-2 is the document you're after.

@_date: 2007-10-22 11:33:33
@_author: David SMITH 
@_subject: Public/Private Keys - Consequences 
When you "submit your key to a keyserver", you only submit the public
part.  You keep the private part to yourself.  The private part is the
bit that you need to sign messages with your signature, or to decrypt
messages that have been encrypted with your public key.  You never give
your private key away.
By default, GnuPG's options are organised intelligently so that GnuPG
doesn't give away private keys without a fight - the normal "send" or
"export" commands will only send or export public keys.  Secret keys
can only be obtained using different options which make it clear that
you are dealing with secret keys rather than public ones.
e.g. compare the "--export" option with the "--export-secret-keys" one.
No, you need the private key to do that, which you don't give away.
To put it simply, the private key is used for generating signatures and
for decrypting messages encrypted with the public key.  The public key is
used for encrypting messages (that can then only be decrypted with the
private key), and for checking signatures that were generated with the
private key.
Sign messages as you, and decrypt all messages sent to you.  Don't give
it away.

@_date: 2008-08-07 15:57:31
@_author: David SMITH 
@_subject: recursive gpg, as in gzip -r 
find  -type f -exec gpg --encrypt-files '{}' --recipient  \;

@_date: 2008-08-07 17:28:17
@_author: David SMITH 
@_subject: recursive gpg 
Close, but if you've got lots of files, you'll hit the maximum command
line length limit.

@_date: 2008-08-08 11:59:26
@_author: David SMITH 
@_subject: Some questions 
"gpg --export-secret-key --armor" does not require a passphrase - you
can just run it, and it gives you the secret key.  I assume that this
secret key must be passphrase-encrypted.  Otherwise, what's the point
of having passphrase protection on the secret keyring, when you can
just export the secret key from the secret keyring unencrypted without
having to know the passphrase?
Maybe it's considered a security risk because it doesn't necessarily
have the usual UNIX (or other OS) permissions set to make it accessible
only by its owner?  Or maybe it's just there to discourage people from
transporting secret keys around?

@_date: 2008-08-08 16:01:00
@_author: David SMITH 
@_subject: Some questions 
In a nutshell, "yes".
Once they've got a copy of your secret keyring, there's no point in
changing the passphrase on your own copy of the keyring.  They can
brute-force the passphrase encryption to get your keys.  Changing
your passphrase doesn't change the underlying keys; you have to revoke
and regenerate for that.
The encryption algorithm of the "real" keys is intended to be
unbreakable[1] because the keys are truly random, and the key space that
needs to be checked is too large to be brute-forced.
The encryption used to protect the secret keys with the passphrase is
potentially weaker, though, as
 1. The key space will tend to be smaller - people are unlikely to choose
    enormously long passphrases
 2. People are stupid, and tend to use simple passphrases which are
    vulnerable to dictionary attack
 3. The encryption algorithm itself might be weaker, although I've no
    knowledge or evidence to back this up.  Frankly, I don't even know
    what algorithm is used, so my comment is purely speculation.
[1] subject to the usual discussions of key length, algorithm strength and
speed of development of computing hardware

@_date: 2008-08-08 16:44:35
@_author: David SMITH 
@_subject: Some questions 
Sounds like an interesting student project... :-)
Some keys certainly sound different; the space bar for one.  Shift, Enter
and Backspace all have distinctive sounds, especially as Shift is
depressed before pressing another key, and then released.  If a user is
using a passphrase made up of space-separated words, then knowing where
the spaces are reduces the search space considerably, as does knowing
when the shift key is pressed.
If the attacker is able to get two microphones set up in useful locations,
they might even be able to analyze the stereoscopic differences between
the two recordings to gain some idea of which area of the keyboard each
keypress is made.  Even if it's only "left half" or "right half", that
divides the search space by 2^number_of_keypresses.
The technique doesn't have to be absolutely perfect; just good enough to
reduce the search space down to something that can realistically be
Like I said, interesting project... :-)

@_date: 2008-07-18 13:17:58
@_author: David SMITH 
@_subject: --export/import-ownertrust 
Hi all,
Could someone please explain what the --export/import-ownertrust commands
actually do?  I have a colleague who is basically using it to exchange
key fingerprints - i.e. if Alice wants to tell her copy of GPG that
Bob's key is valid, then she gets Bob to run gpg --export-ownertrust,
send her the output file, and she then runs gpg --import-ownertrust on
that file.
I've searched on the net, but I can't find much about what the
--export/import-ownertrust do, beyond what is in the manpage.  What is
actually stored in this exported ownertrust database?
More importantly, I suspect that this is a bad thing to do.  What
problems does it cause?

@_date: 2008-07-19 11:33:22
@_author: David SMITH 
@_subject: [admin] What is top posting, and why should you avoid it? 
On that subject, and dragging things vaguely back to GnuPG...
Does anyone know of a way to get M$ LookOut to support PGP/MIME properly
(in particular, mails with attachments)?
I'm fed up of having to re-send mails to colleagues because they can't
read PGP/MIME.

@_date: 2008-07-22 09:11:36
@_author: David SMITH 
@_subject: so how do you get others to sign your key? 
Check the GNU Privacy Handbook; in particular the references to key
signing, and keysigning parties.

@_date: 2008-07-31 14:50:02
@_author: David SMITH 
@_subject: GNUpg Version 1.4.8 on Solaris 10 (Sparc) 
Why would you want to?
Surely you would want to encrypt it with their public key, so that they can
decrypt it with their own private key?  Otherwise you end up with the old
chestnut of key exchange problems (i.e. if you can't get the document to
them securely without encrypting it, how do you get the key to them
I suspect that the closest thing to what you want to do is to generate a
public/private keypair yourself, and then export the private key:
  gpg --armor --export-secret-key You can then give them this exported secret key.  Of course, you need to
be very careful about how you transport this secret key around.

@_date: 2009-08-13 14:30:01
@_author: David SMITH 
@_subject: Two convicted in U.K. for refusal to decrypt data 
You are, of course, assuming that the reporting is correct in its
implication that the defendants either admitted to having access to the
keys, or that it has been proven that they do have the keys.
I remember a lot of discussion at the time that the RIP bill was being
pushed through about the difficulty of proving that you don't have
access to a particular piece of information.
The RIPA is a particularly nasty piece of legislation in this respect.
David Smith        | Tel: +44 (0)1454 462380    Home: +44 (0)1454 616963
STMicroelectronics | Fax: +44 (0)1454 462305  Mobile: +44 (0)7932 642724
1000 Aztec West    | TINA: 065 2380          GPG Key: 0xF13192F2
Almondsbury        | Work Email: Dave.Smith at st.com
BRISTOL, BS32 4SQ  | Home Email: David.Smith at ds-electronics.co.uk

@_date: 2009-08-13 14:49:55
@_author: David SMITH 
@_subject: Two convicted in U.K. for refusal to decrypt data 
So the people who come on gnupg-users asking for help because they've
forgotten their passphrase or accidentally deleted their ~/.gnupg
directory don't exist?
I guess that's a new way of replying to them: "You don't exist".
Not forgetting the possibility of malicious intentions - trying to frame
someone by putting encrypted data onto someone's computer and tipping
off the authorities.

@_date: 2009-07-02 14:00:15
@_author: David SMITH 
@_subject: My public key block appears different on keyservers 
If you look at the two keys you posted, then the line lengths are
different.  However, they both contained the same text, The two
webservers just chose to break the lines at different places, and
I guess that the OpenPGP format allows the sender to vary the line
length when ASCII-armouring a key.
If you look at the two keys you posted, then the line
lengths are different.  However, they both contained
the same text.  The two keyservers just chose to break
the lines at different places, and I guess that the
OpenPGP format allows the sender to vary the line
length when ASCII-armouring a key.
^^^ See what I mean?
Because the data "file" you download from the keyserver is not just a
binary copy of the key - the key can be encoded in different ways, and
there could also be other information encoded in there.
For example: consider a file compressed with "gzip".  gzip allows the
user to specify the compression ratio required from -1 to -9 - the
larger the number, the better compression ratio that it achieves, but
the longer it takes to run.
If you look at each of the compressed files individually, they will
all look completely different (since they have been compressed in
subtly different ways), but if you uncompress each of them with
gunzip, they all end up producing the same result - the file which
was originally compressed.
The bottom line: Yes, the key arriving from the keyserver might not
look the same in its ASCII-armoured form.  Unless you see a problem
with the key once it's been imported into GPG, don't worry about it.

@_date: 2009-07-30 14:57:06
@_author: David SMITH 
@_subject: Public key crypto by hand 
Your answer implies that you are looking for something that you would
actually use, rather than just a pen-and-paper demo for instruction
In this case, whilst it's not exactly "public key cryptography", even
the simplest algorithms are cryptographically secure with a one-time pad.
Of course, you then have the key exchange problem.

@_date: 2009-06-26 16:02:49
@_author: David SMITH 
@_subject: Separate stdout and stderr 
Yes, this is a "feature" of UNIX filehandle buffering.
I guess it depends on what you're trying to do.
For example; assuming you are using Bourne shell, you can redirect stdout
and stderr separately:
  my_command 1> stdout_goes_here.txt 2> stderr_goes_here.txt
Otherwise, you need to be a bit more specific as to exactly what you want
to do (and which shell you're running in).

@_date: 2009-03-18 17:04:04
@_author: David SMITH 
@_subject: gpg: WARNING 
It means that you haven't signed the key that you are using to check the
signature, and GnuPG isn't able to validate the key with your web-of-trust.
Going back to basics for a moment...
You have got this signed file from somewhere.
You have also obtained the key which claims to be from the sender.  You
might have got the key from a public keyserver, or possibly from
somewhere else.
How do you know that the key really is owned by the person it claims?
Anyone can upload a key to a keyserver claiming to be from anyone.
I could upload a key to a keyserver with the id "president at whitehouse.gov"
and you would then download it.  You need to build yourself a
web-of-trust by doing some keysigning.
I suggest reading the GNU Privacy Handbook, on the GnuPG website, and
if you still have questions, come back and ask...

@_date: 2009-03-26 10:08:22
@_author: David SMITH 
@_subject: cloudy understanding of asymmetric cryptography 
Yes, this is what normally happens with typical usage of gpg.  It's
called a "hybrid" cipher system.
I believe that the reason is that symmetric ciphers are usually more
efficient on computing power than asymmetric ones, so you don't really
want to be encrypting/decrypting lots of data with an asymmetric
Typical usage for gpg will be ElGamal for the asymmetric public/private
key bit, and AES for the symmetric cipher.

@_date: 2009-05-05 21:17:17
@_author: David SMITH 
@_subject: problems with http://www.gnupg.org 
Works OK for me, so either someone's already fixed it, or it was a
transient problem.

@_date: 2009-05-14 11:36:37
@_author: David SMITH 
@_subject: Help! 
You appear to be describing GPA:
  Some friendly advice:
1. Be a bit more descriptive with your subject line. "Help!" doesn't
   really give any clue what you're after, and some people will just
   ignore that sort of mail.
2. Learn to ask "smart questions".  Include useful information - e.g.
   in this case, it would be useful to know what Operating System
   you're running (Windows (version?), Linux, Mac OSX).
   More info: 3. Huge disclaimers like this one have virtually no legal merit and
   just annoy people by wasting bandwidth and disk space.  In the "old
   days of the Internet", a 4-line, 72 characters per line signature
   was gnenerally considered to be an acceptable limit.

@_date: 2009-11-17 16:28:17
@_author: David SMITH 
@_subject: Is it possible to decide what is a gpg file? 
Depends on what you mean by "reliable"...
I'm sure if you read RFC-4880, you could work out a byte pattern that
would give a very good indication, for most practical purposes.
However, it would probably be possible for someone to generate a file
artificially in a deliberate attempt to fool the filetype detection
mechanism.  So, it's not "reliable" because it can be fooled
intentionally, but for most likely scenarii (i.e. where people aren't
deliberately trying to fool it), it would work.
If you're running on UNIX (particularly Linux), look at 'man file'.

@_date: 2010-08-06 13:51:02
@_author: David Smith 
@_subject: Gnupg good for big groups? 
Well, I've only just learned about it by reading the website, but...
Not really.
GnuPG and the "normal" WoT.
I think that the idea behind "GSWoT" is to create a number of "more
trusted" people that will actively go out and sign keys, and adhere to a
specified code of conduct when doing so.  They are hoping that, due to
their affiliation with the GSWoT organisation, that you will put more
trust in their ability to sign keys than you would in "Joe Public".  By
doing this, they hope that people who choose to increase their trust
level of GSWoT "introducers" will therefore be able to validate many
more keys than someone with standard trust settings.
However, it does not solve your problem.
IMHO, GnuPG is the wrong tool (overall) to solve your problem.  There
are ways in which you could shoe-horn it to force it to work, but it's
really not the appropriate tool.
The "mailing list" problem is solved relatively easily with GnuPG - as
others have said, the originator of each message sends his/her message
to the list server encrypted with the server's key; the server then
decrypts the message and forwards the mail to each list member encrypted
with each member's key individually; alternatively the server could send
the message to every member at the same time encrypted with everyone's
key, although that might have some privacy and bandwidth issues (since
you can tell who is on the list, and if there are many users, the
overhead of including the session key so many times might become
The main problem is with the archive; in particular, revoking access.
One way you could do it:
   Every document is encrypted using symmetric encryption with the same,
   randomly-generated session key. That key is then encrypted using each
   list member's key, and sent to every member.
   If a new member arrives, they are given the current session key
   encrypted with their key.
   Now, this is where it becomes nasty.  When a member is removed, the
   entire database must be decrypted and then re-encrypted with a new,
   randomly-generated session key which is then re-distributed amongst
   the remaining members.
Another way:
   The system automatically encrypts every document with every user's
   key, plus one key for the administrator.
   When a user is added, the administrator decrypts and then re-encrypts
   every single document using the new user's key
   When a user is removed, the administrator decrypts and then
   re-encrypts every single document without the removed user's key.
Neither of these solutions solve the problem where a user takes a copy
of the whole encrypted database before they are removed.
Both of these solutions are rather painful.  As others have suggested, a
much better way of doing this sort of system would be a client-server
architecture where the user is required to log in to the server, which
decides (based on the user's credentials) whether to provide the
document.  Obviously you now have to make sure that the server mechanism
itself is secure and cannot be successfully attacked.
You could use GnuPG to encrypt communication between the client and
server, but as you've already mentioned, we already have SSL/TLS for
this sort of thing.
I'd propose that your requirements are likely to be served by:
 o A web server running either a forum or a Wiki, which requires user
   logins.  An audit may need to be done to check the security of the
   forum.
 o Enforcing the use of HTTPS to connect to the server
 o If mailed notifications are required, use a forum/Wiki which is able
   to mail out postings/changes, and modify the mailing back-end to
   encrypt all messages to the intended users.  You could use one of the
   encrypted mailing list servers available as your back-end.
 o Depending on your threat model, you may want to encrypt the back-end
   storage; in the worst case this could be on-the-fly encryption of
   each file as it's written to disk using the server's key (although
   this does introduce the problem of keeping the server's key secure),
   or it could just be an encrypted disk partition using (e.g.) LUKS.
Note that there are no solutions that will prevent a user keeping a
decrypted copy of a previously-downloaded document, unless you use your
own custom-written browser and document viewer.

@_date: 2010-08-09 17:03:02
@_author: David Smith 
@_subject: Gnupg good for big groups? 
I'm afraid that my answer to both of your questions is "I don't know".
I suspect that there is a fundamental problem with trying to achieve the
"group" functionality that you want using standard crypto.  The problem
is that information cannot be created or destroyed.  Once someone has
the information required to decrypt the destination file, you cannot
prevent that person from decrypting the file at a future date, unless
you modify the encrypted file in some way (i.e. by re-encrypting it with
a new key).
I guess that there are some possible half-way solutions (for example, a
tool that could modify an existing encrypted file to add a new session
key encryption (thus giving a new user access to the file) or removing
an old session key encryption (thus removing a user's ability to access
the file) without re-doing the encryption of the target data itself; the
user doing this operation (the web server or admin) would need to be on
the recipient list of the file already.  Also, there could be other ways
of doing a similar thing within current tools by splitting the keys out
across different files.  I think it just depends on what level of
security you want - the above proposal still has potential problems -
for example, what if the user took a copy of the session key of every
file before leaving?

@_date: 2010-01-14 11:03:41
@_author: David SMITH 
@_subject: Installing Software 
More information required...
Which Operating System?
Which package are you trying to install?  Source or Binary?
It sounds like you've got a source package, and you're trying to install
on some kind of UNIX system.
It sounds like the problem is that it's looking for a C compiler (e.g.
gcc) and you haven't got one installed.

@_date: 2010-07-06 15:52:14
@_author: David Smith 
@_subject: GPG clarification 
(by default) GnuPG uses a hybrid encryption system.  The actual data is
encrypted using a symmetric algorithm (where the keys for encrypting and
decrypting are the same) using a randomly-generated "session" key, and
this session key is then encrypted using an asymmetric (or public-key)
algorithm.  In this case, you are being given the opportunity to use DSA
or ElGamal algorithms for the public-key encryption algorithm.
No. See above.  The algorithms used for encrypting the data are
typically AES or TDES, and the key length is normally much shorter -
e.g. AES-256.  The fact that the key is apparently shorter is not a
security risk - symmetric algorithms are much stronger for the same
Yes.  Public and secret keys in the same keypair have the same length.
In reality, they are each "halves" of the same key, as they are
generated together.
BTW, you don't have to censor the key ID (2D*****7) - it can safely be
made public without risk of giving away the key value itself.
Your "key" can actually contain multiple keys.  Typically, a user will
have one "master" signing key (which is used to prove their identity),
and multiple encryption subkeys.  The advantage of this is that each
subkey can be set to expire (become unusable for encrypting data) after
a certain period of time, at which point the user generates and
publishes a new subkey.  Because it is still a subkey of the master
signing key, the user does not have to prove his/her identity to all of
his/her correspondents, as it will be signed by the master key which
remains valid and unexpired
As I said, the public and secret parts are just two "halves" of the same
key.  The public part is given away to everyone so that they can use it
for encrypting data, you keep the secret part so that you can decrypt
the data they've encrypted.
"Secret sub".  Your "key" record in the keyring has a master key
(denoted by "pub" for the public part and "sec" for the secret part),
plus one or more sub-keys (denoted by "sub" for the public part and
"ssb" for the secret part).
The public halves of keys (both yours and everyone else's) are kept in
pubring.gpg; the secret halves are kept in "secring.gpg".  So yes, you
could remove secring.gpg if you wish.  However, if you want this level
of security, you might want to consider using a GPG smartcard.
Sorry, I don't know.  That's a question for the GPG maintainers.

@_date: 2010-07-06 16:06:46
@_author: David Smith 
@_subject: GPG clarification 
Some thoughts:
GnuPG is generally designed on the assumption that the "source" and
"destination" machines are not compromised.  Yes, the key is kept
encrypted, although I don't know how secure the encryption is.  There
are, of course, other attacks that could be mounted depending on how
badly the machine has been compromised - for example:
 o The attacker could install keystroke logging software or hardware.
 o They could install a compromised version of GnuPG which takes the
   passphrase you type in, uses it to decrypt the secret key, and then
   transmits the unencrypted key to the attacker.
 o They could compromise the OS to intercept system calls
If this is a serious concern, you may be better off with a GnuPG
smartcard, as then the key is kept in the card and is not copied to the
machine.  The card decrypts the session key and sends it back to the
computer which then uses that session key to decrypt the data.
Therefore, the host never sees the actual secret key.

@_date: 2010-07-23 11:48:00
@_author: David Smith 
@_subject: gpg --batch --yes --edit-key trust 
I think that you might be confusing "trust" with "validity".
If you want it to blindly encrypt data using a key that it's downloaded
from a keyserver without you having signed it (or without it being
declared valid by the web-of-trust), then you can use "--always-trust"
when doing the encryption.

@_date: 2010-06-17 17:15:23
@_author: David Smith 
@_subject: Can we use GNUPG with PGP for commercial use 
GnuPG and PGP are different tools.
PGP is a commercial tool, although some versions of it are free for
non-commercial use.
GnuPG is a FOSS (Free, Open Source Software) tool released under the GNU
General Public License (GPL), and it can therefore be used
free-of-charge for both commercial and non-commercial use.
GnuPG and PGP are generally compatible with each other (i.e. a file
encrypted with PGP can be decrypted with GnuPG and vice-versa), as they
both work to a publicly-defined standard.
HTH & HAND.

@_date: 2010-06-18 14:24:05
@_author: David Smith 
@_subject: AUTO: Richard Hamilton is out of the office (returning 06/24/2010) 
OK, Maybe "Precedence: list" is also a valid implementation; I haven't
looked in detail at the RFQs, etc. - I was just typing from memory.  The
basic method of operation is the same, though - the MLM marks the
message as a mailing list message using the "Precedence" header, and the
autoresponder interprets this header when deciding whether to respond.

@_date: 2010-06-18 14:31:20
@_author: David Smith 
@_subject: AUTO: Richard Hamilton is out of the office (returning 06/24/2010) 
Just checked the relevant RFC (3834), and it says (rather unhelpfully):
      (Because Precedence is not a standard
      header field, and its use and interpretation vary widely in the
      wild, no particular responder behavior in the presence of
      Precedence is recommended by this specification.)

@_date: 2010-03-11 15:43:32
@_author: David SMITH 
@_subject: Implications Of The Recent RSA Vulnerability 
Well, I've only read the "engadget" writeup, but assuming it's correct,
the attack only applies to systems where the attacker has physical
access to a system containing the private key.  As a general rule, when
using GnuPG you would keep your private key on your local system, so it
would only be a problem if your local system were cracked and the
attacker could download the private key from your machine, or if your
machine were to fall into the attacker's hands.
However, even if the attacker manages to get hold of your private key
file, they still need the passphrase to get the key so that they can use
it for the RSA encryption operation they want to attack using this
technique.  If they have both the private key /and/ the passphrase, then
the game is already over.
So, basically, it's highly unlikely that you're vulnerable to this
attack.  The sort of systems that are vulnerable to the attack are ones
where the RSA key is embedded inside such that the attacker, with
physical access to the system, can use it for the encryption operation
but not read it out.  This attack allows the cracker to determine the
embedded key.
In terms of whether it compromises the passphrase protection, no.  To be
able to use the attack, the attacker needs to run the RSA algorithm with
your private key.  To be able to do that, they need your passphrase in
the first place, otherwise, how can they get your private key to feed in
to RSA?

@_date: 2010-09-27 10:12:41
@_author: David Smith 
@_subject: how slow are 4Kbit RSA keys? [was: Re: multiple keys vs multiple 
Not truly "quantitative, but I notice a significant difference between
encrypting emails to people with 1024-bit keys vs people with 4096-bit
keys.  I'd say that the difference is in the order 3-6 seconds.
I'm running GnuPG 1.4.x on a Sun Ultra10 with a 500 MHz CPU and 1 GB
RAM.  Yes, I know it's old.  :-)
We're forced to use 4096-bit keys because some of our customers require it.

@_date: 2010-09-27 17:09:28
@_author: David Smith 
@_subject: how slow are 4Kbit RSA keys? [was: Re: multiple keys vs multiple 
Yes, that's partially true, although I thought that the symmetric cipher
is usually a 256-bit key (often AES-256).
I was talking about small emails (e.g. a couple of kB).  Since the
symmetric cipher is usually much easier computationally (that's one of
the reasons for going for a hybrid cipher system), the encryption of the
session key starts to dominate the operation, and in my case, there's a
noticable difference of the order of a number of seconds between the two
types of keys.
Most of my emails are short, between members of the team, some of which
have 1024-bit keys, some 2048, some 4096.  Adding on a 5-second delay to
the sending of every email can be a bit of an annoyance (although we
have to live with it...), and although the effect is less pronounced on
decryption, it's still noticeable and probably even more important.

@_date: 2010-09-28 13:16:59
@_author: David Smith 
@_subject: how slow are 4Kbit RSA keys? [was: Re: multiple keys vs multiple 
Whilst it's not something I've had to do, there's also the (potential)
issue of wanting to search a mailbox containing a number of encrypted
mails.  Those seconds can add up... :-)

@_date: 2011-02-03 13:31:38
@_author: David Smith 
@_subject: Crontab running gpg script =?UTF-8?B?Y2Fu4oCZdCBmaW5kIHNlY3Jl?= 
Which user ID is the cron script running under?  Is that user the same
one that owns the key?

@_date: 2011-02-07 19:50:19
@_author: David Smith 
@_subject: Symmetric cipher question 
Well, for a start, you're unlikely to get an output from AES that
exactly matches the number of bytes you put in, unless your input is an
exact multiple of 128 bits (16 bytes).  This is because AES is a block
cipher algorithm, in that it only works on 128-bit blocks.  If your
input (cleartext) is not a multiple of 128 bits, some extra stuffing
will be added to the last part-block to make it up to a full 128 bits
before the block is encrypted.
As for why you're getting 49 bytes, I'm not sure.  I guess GnuPG is
adding some extra metadata (e.g. the ID of the key that was used to do
the encryption), but I'm afraid the exact behaviour is beyond my
knowledge.  Perhaps if you were to post the precise gpg command line you
are running, it will give us more info.

@_date: 2011-01-11 11:09:30
@_author: David Smith 
@_subject: What is the benefit of signing an encrypted email 
Signing and encrypting serve different purposes.
Encrypting a mail ensures that only the intended recipient(s) can read it.
Signing a mail allows the recipient(s) to check that it really was you
that sent it, and not someone else masquerading as you.

@_date: 2011-11-01 11:55:11
@_author: David Smith 
@_subject: GnuPG decryption problem 
Remember that the passphrase is not the key.  The key is stored in a
file, and that file is protected by the passphrase so that only people
who know the passphrase can use it.
That is probably intentional, to stop someone seeing your passphrase by
looking over your shoulder.
Personally, rather than using --decrypt, I'd use --decrypt-file.  That
might help.

@_date: 2011-11-01 14:23:39
@_author: David Smith 
@_subject: GnuPG decryption problem 
Please remember to keep the GnuPG users' mailing list in copy in case
anyone else has any better ideas.
Is that it, or is there any more diagnostic information?

@_date: 2011-11-08 15:29:15
@_author: David Smith 
@_subject: Why is there a subkey and a selfsig in a new key? 
In my case, it's because I like to change my encryption key on a regular
basis (so that if an encryption key ever were to be cracked, it limits
the damage to a smaller number of files/messages), but don't want the
hassle of having to go around and get everyone to sign my new key every
time I issue a new one.
So, I have a master signing key with a long (or infinite) lifetime, but
an encryption subkey with a short lifetime.  When the encryption subkey
expires, I generate a new encryption subkey which is signed by the
master key, so all my contacts still consider it to be valid without
them having to sign it (at a keysigning party etc.)

@_date: 2011-10-04 10:11:35
@_author: David Smith 
@_subject: MS Exchange server corrupting PGP-MIME emails 
Possibly a bit off-topic, but...
Does anyone have any experience of using an MS Exchange server, where it
corrupts PGP-MIME emails by re-encoding the encrypted data in base64?
If I'm going to complain to our local IT about it, I need some hard
evidence about how it's breaking the PGP-MIME RFC.
I've attached an example of a mail before and after it's been through
exchange - I've put it in a .tgz to stop any modification by mailservers
en route.

@_date: 2011-09-02 08:59:23
@_author: David Smith 
@_subject: Decrypting WikiLeaks insurance file 
Perhaps it is just encrypted with the basic AES256 cipher with no
OpenPGP wrapping?  I'm not sure whether GnuPG can decrypt raw AES data,
but if not, you should be able to download an AES256 algorithm from the
net and compile it into an application.  There might even be
Perl/Tcl/etc. versions that don't even require compilation.

@_date: 2012-02-01 10:27:51
@_author: David Smith 
@_subject: Compiling GnuPG problem 
It looks like that you still need to install some more packages before
you can start on GnuPG proper.
On my system (RedHat Enterprise Server), zlib.h is in /usr/include, and
has come from the "zlib-devel" package.  Ubuntu might put it in a
differently-named package, but I doubt it would be too tricky to find.
My system also a few other files called "zlib.h", one is from the
"syslinux" package, and the other is in "kernel-devel".

@_date: 2012-09-13 17:16:29
@_author: David Smith 
@_subject: encryption/decryption without files 
OK, so here's a list of issues:
1. If you're going to write it exactly like that, then the plaintext
message is going to end up in lots of places where you won't want it,
like your shell command history file (unless you disable shell history),
(potentially) the output of "ps", etc.
2. On the other hand, you could just run gpg directly, and type your
message in on the console as stdin; however, the lack of editing
facilities might be somewhat inconvenient (unless you're able to type
almost perfectly and able to plan your entire message in your head
before you start typing).
3. If you're thinking of piping the output of an existing, unsecured
editor into gpg, then that's not going to work, as the "stdout" will
contain what it wants to print on the screen and the reactions to all
your keypresses, not the actual message.

@_date: 2013-08-23 09:37:20
@_author: David Smith 
@_subject: Why trust gpg4win? 
True, but I'm not convinced that closed-source software has any inherent
advantage in this respect, so if you're really that worried, then your
only other choice is to become a cryptography expert yourself and write
your own software...

@_date: 2013-01-07 16:05:32
@_author: David Smith 
@_subject: Paperkey 1.3 
True, but OTOH, whilst hardware devices do tend to become obsolete
relatively quickly, the algorithms tend to have more longevity.  For
example, you might struggle to find one of the earlier 1d bar code
reader pens that I remember from the 1980s around now, and even the
software used for reading and interpreting them will probably have
disappeared, but the overall mechanism is still widely used.
I would suggest that we are going to have "devices for scanning paper to
a digital image" for quite a few years yet (whether they are SCSI-based
ones from years ago, through USB-connected multi-function printers, to
digital cameras and beyond.  2d bar codes (and the algorithms needed to
process them) are well-specified, so even if the existing software
becomes unusable, it could be re-written for a new platform.
I'm not saying that there isn't a place for printing the key out in
ASCII; just that it might be a good idea to print it out as a 2d barcode
as well, so that if recovery were necessary and the appropriate HW and
SW were available, that could be used to recover substantially more data
(since the whole key record could be encoded in a relatively small
space), and then fall back on the ASCII version if the barcode is

@_date: 2013-06-12 12:21:20
@_author: David Smith 
@_subject: Clarifying the GnuPG License 
IANAL either, but that is also my understanding.
If you do ship GnuPG with a proprietary application under options 1 or
2, you also have to include the GnuPG source code (or an offer to
provide it on request).  Just providing a link to the main GnuPG site
(or a mirror) is technically not sufficent (unless you enter into an
agreement with the person that operates that site to provide the
downloads on your behalf).

@_date: 2013-03-06 09:23:24
@_author: David Smith 
@_subject: Public Keys not showing up in "Choose Recipients" 
Some reasons why the key may be unusable:
1. It may be expired.  Keys can be (and often are) generated with expiry
dates.  Even if the key has an expiry date in the future, there may be a
problem with the clock setting on the sending device - it could be set
to a date in the future, past the expiry date of the key.  Also, I
believe I am correct in saying that once gpg has noticed that a key has
expired, it marks the key as expired, which is a one-way process.  So,
whilst the clock may be correct now, it could have been wrong in the
past, causing gpg to mark the key as expired, and now the clock is
correctly set, the key is still marked as expired.  To fix this, you
could delete and re-import the key.
2. It may require the use of an algorithm which is not supported - for
example, the key may have been generated for use with the IDEA
algorithm, which isn't supported in many versions of GnuPG.
Outside of this, I'm not sure what to suggest. You've not said which OS
you're using; if you are using one of the Unix variants, I would suggest
running "gpg --list-keys " and then posting the
result to the list.  If you're running a different OS, then I'm not
entirely sure how you get to this information.
I'm also not entirely sure whether you're running GnuPG or not - maybe
the programs you are using are a front-end for gpg, maybe not.  You've
used the terms "GPG Keychain Access" and "PGP Keychain Access", so I
don't know whether you're using PGP, GnuPG, or something else
altogether.  Note that "OpenPGP" refers to the data format of the
encrypted file (and the algorithms required to produce and use it), not
any particular application, so the application(s) you are using may have
no relevance to GnuPG whatsoever.

@_date: 2013-03-26 09:57:46
@_author: David Smith 
@_subject: IDEA License 
Not quite.  Werner's implementation of IDEA (as included in GnuPG) is
copyrighted but released under the terms of the GPL, and therefore, if
you take his source code directly and copy it (or any part of it) into
your code, then you are restricted by the terms of the GPL.
The algorithm itself cannot be copyrighted, but can be patented (and
was).  The patent covered /any/ implementation (whoever coded it).
However, the patent(s) have now expired, so now anyone is free to code
their own version of the algorithm under any license they like, provided
they write their own version of the code, rather than just copying
someone else's.
Disclaimer: IANAL, you should get your own proper legal advice from a
real lawyer, etc.

@_date: 2013-03-26 11:00:34
@_author: David Smith 
@_subject: IDEA License 
Not necessarily.  If you write your own implementation of IDEA, you can
release it under any license you like.
If you include libgcrypt in your software, then it depends on how you
use it.  libgcrypt appears to be licensed under either GPL or LGPL[1],
so if you dynamically link against a separately-compiled libgcrypt
library, then you don't have to release your source because you can use
libgcrypt under the LGPL.
You can ship your own software and an LGPL-licensed library together
(e.g. in a tarfile), provided that the LGPL-licensed stuff is easily
separable from the proprietary stuff (i.e. in an independant library
which contains *only* LGPL code).
You do still have to include in your shipment information to state that
it includes libgcrypt licensed under the LGPL, and provide facilities
for your "customers" to get access to the libgcrypt source code.  If you
make any changes to the libgcrypt code to use for your application, then
you must make the source code for those changes available.
If you statically link libgcrypt into your software (i.e. compile it in
to the binary), then it is no longer easily separable from the
proprietary code, so you must release the source code to your software,
and furthermore, you cannot prevent anyone copying, modifying and
distributing your software and/or source code.
Again, IANAL, get your own professional legal advice, etc...
[1]

@_date: 2013-05-03 13:09:15
@_author: David Smith 
@_subject: Suggest please 
user_1, user_2 and user_3 each generate their own public-private
keypair.  So:
  Receiver_1 has public_key_1 and private_key_1
  Receiver_2 has public_key_2 and private_key_2
  Receiver_3 has public_key_3 and private_key_3
They then all send their public keys to a fourth user, "Sender" (who may
actually be one of the receivers, if you wish).
Sender then encrypts the file using the public keys of all the
Receivers.  For example:
gpg --recipient Receiver_1 \
    --recipient Reciever_2 \
    --recipient Receiver_3 \
    --encrypt-file file_to_be_encrypted
Each of the three recipients will then be able to decrypt the file using
their own private key.

@_date: 2013-05-03 15:10:46
@_author: David Smith 
@_subject: Suggest please 
No.  The whole point of public/private cryptography is to use asymmetric
(caveat: actually, this is an over-simplification.  In reality, gpg DOES
use symmetric ciphers, but in a way that makes it look like it is using
asymmetric ones).

@_date: 2013-05-22 11:22:28
@_author: David Smith 
@_subject: Keyring on external encrypted drive 
I think the answer probably depends on which OS you are using.

@_date: 2013-11-07 11:08:33
@_author: David Smith 
@_subject: question about public keys 
You have a number of options:
1. Edit the expiration date of the existing key, and then re-circulate
it.  Vendors with the old key will be able to carry on working, the new
one can use the key with the shorter expiration date.  As it comes close
to expiration, you can re-edit the expiration date to extend it.
However, this might not suit your new client's requirements.
2. Generate a new keypair with the same email address as the old one,
and only send it to the new client.  However, if it gets circulated to
other clients, it might cause confusion over which key to use.  You can
generate a new keypair with "gpg --gen-key".
3. Depending on what your new client's objections are, it might be
sufficient to generate a new encryption subkey within your existing
master key.  The new subkey can have a different expiration date to the
master key.  Most of your existing clients will continue using the
existing encryption subkey with a long expiration date; the new client
can specifically choose to use the new subkey with a shorter expiration
date.  When the new subkey expires, you can simply create another one
with a new expiration date.  You can add a subkey by running "gpg
--edit-key " and then running the command "addkey".

@_date: 2013-09-09 11:11:08
@_author: David Smith 
@_subject: Some doubts about signature procedure 
The signature is more than just the hash of the message.
The signing process consists of two steps.  Firstly, the message being
signed is run through a hashing algorithm like MD5 or SHA.  The second
step is that the output of the hashing algorithm is encrypted using your
secret key.
Anyone wishing to check the signature can then decrypt the hash using
your public key, run the same hashing algorithm over the message, and
check that the hash of the message is the same as the unencrypted hash
from the signature.
You are correct that an attacker can generate a hash of the modified
message, but they cannot encrypt it with your secret key, unless they
also have a copy of that key.
I've simplified the process somewhat for ease of explaining it, but
that's the general gist of the way it works.  So, provided your secret
key is kept secret, and your addressees verify that the public keys they
have really do belong to you, you can be confident that the signature
mechanism is safe.

@_date: 2013-09-10 15:33:38
@_author: David Smith 
@_subject: Why trust gpg4win? 
AVR is a semiconductor manufacturer who make microcontrollers (amongst
other things).

@_date: 2013-09-13 11:50:15
@_author: David Smith 
@_subject: Why trust gpg4win? 
No.  I work for a (different) semiconductor manufacturer (you can
probably work out which one from my email address...).  Actually, I
wasn't quite correct - AVR is a brand of microcontrollers made by
semiconductor manufacturer Atmel.  They are used in the Arduino project
among other things.
To answer your questions in order...
1. You've answered this question in the second question
2. Yes.
3. Yes.  If you get the microcontroller to tell the PC that it's a flash
drive, then the PC will believe it and treat it as such.  The USB spec
(and sub-specs) define how a flash drive should "look" to the host (the
PC), and provided the USB device behaves like this, the host will assume
that it really is a flash drive.
In reality, a lot of USB devices are built this way - the low-level USB
hardware interface is implemented by dedicated hardware, but the
higher-level parts (like defining what "sort" of device it is, and what
to do with the data that is transferred) is encoded in firmware.  In
fact, it wouldn't surprise me if some USB flash drives are implemented
this way.
