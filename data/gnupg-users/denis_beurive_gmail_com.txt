
@_date: 2020-07-28 14:24:08
@_author: Denis BEURIVE 
@_subject: Protecting encryption server 
What is the risk ?
Are you worried that somebody uses the server to sign
inappropriate documents ?
If you cannot trust the guy that administers the server, then I guess that
there is not much you can do to prevent him from signing
inappropriate documents. You may choose to dispatch the responsibilities,
so nobody has full administrator authorization. However, if you think that
the administrators may collaborate with each other, then there is nothing
you can do.
Are you worried that somebody steals the server private key ?
If you are only concerned by the theft of the secret key, then you can
externalize the signature process to a Secure Signature Creation Device (
Le mar. 28 juil. 2020 ? 12:19, Ayoub Misherghi via Gnupg-users <
gnupg-users at gnupg.org> a ?crit :

@_date: 2020-07-28 21:51:52
@_author: Denis BEURIVE 
@_subject: Protecting encryption server 
It all depends on what you want to do. Very secured technical solutions
exist. But these solutions may not be applicable to any situations.
Have you heard about data diodes ? If not, then you can read this document
Data diodes are unhackable because it relies on the law of physics : IT is
hackable. The laws of physics, on the other hand, are not. You cannot get
around the laws of physics, regardless of the amount of resources you are
ready to spend.
So, you may use a data diode to make use that nobody can infiltrate your
signing server from the Internet.
However, this solution is 100% bulletproof on the condition of your signing
server "only sends data," that is if it does not need to respond to
requests from the Internet. In this situation, your server does not expose
any network entry point. It only exposes an "unhackable  one way only" exit
If your signing server needs to respond to requests from the Internet, then
you can implement "air gap isolation" with another data diode. An (unsafe)
server receives a request. It extracts the data from the request, and send
it to the (secure) signing server through a one way only exit point (a data
Therefore, your secure signing server has two data diodes : one for the
reception of requests and the other for the emission of signed documents.
This solution is not 100% bulletproof since a carefully crafted request may
be used to hack the secure server (you use the technique known as "buffer
overflow" to inject malicious code). However, without direct feedback (the
data diode forbids feedback) and without knowledge of the server software
environment, doing so is really difficult. I doubt that it is practically
doable, although it theoretically is.
Thus, you could create a "practically" (as opposed as "theoretically")
unhackable (from the Internet) signing server.
Now, the question is : what can you do about the administrators ?
The response maybe : create a server that does not need to be administered
and protect it physically (place it in a safe, for example).
If your server only needs to sign documents, then it can be very "rustic
and cheap." A Raspbery Pi should be more than enough. You install a minimal
Linux distribution with only the bare requirements for your application. It
should not need to be administered. And if a problem occurs, don't bother
to fix it... just replace the server with a new one (ready to be used).
Le mar. 28 juil. 2020 ? 17:39, Ayoub Misherghi  a ?crit :

@_date: 2020-07-28 22:33:42
@_author: Denis BEURIVE 
@_subject: Protecting encryption server 
If your server only sends data through an "outgoing data diode", then it
does not expose any entry point (you just disable all services : no SSH, no
ping, no HTTP... nothing). There is no way you can establish a connection
to the server. How can you hack a server if you have absolutely no way to
access it from the outside ? It seems just impossible.
Now if you also use an "incoming data diode" to receive data, then you have
no direct feedback. The only feedback you get is through the "outgoing data
diode." It will be very difficult to get information about the server
internals in this condition. Imagine : you have a black box and you try to
model it from indirect feedback. Although it is theoretically possible, it
would be very difficult. All depends on the resources you are intended to
spend... Is the game worth the candle?
To make this task even harder, you can make the feedback very difficult to
analyze. For example, you can voluntarily introduce randomness. GNUNET does
it, for example. When you send a message to a node, you also send "fake"
messages to many other nodes (chosen at random). A spy (man in the middle)
could not distinguish between "fake" and "real" messages... You can
although randomly delay the responses : measuring duration between
responses won't give any usable information. These are just examples. You
can think of many ways to make life harder to a "malicious man in the
middle" that tries to reverse engineer your system by collecting and
analyzing data collected by observing your black box.
Le mar. 28 juil. 2020 ? 21:59, Robert J. Hansen  a
?crit :

@_date: 2020-07-28 23:45:07
@_author: Denis BEURIVE 
@_subject: Protecting encryption server 
I think of another way to make things harder for a hacker.
   - Use "data diode isolated" secure servers : one "incoming data diode"
   for requests reception and one "outgoing data diode" for document
   emissions. Make sure that each secure server is only connected to the
   exterior world by these two data diodes.
   - Introduce randomness in the "data diode isolated" secure servers :
   make it hard for a "malicious man in the middle" to "reverse engineer" your
   black box by the analysis of data collected from the observation of your
   "black box".
   - Design a distributed system : make your "data diode isolated" secure
   server exchange data with "dumb nodes." The "dumb nodes" do nothing except
   relay the responses (they act as proxies). When the secure server sends a
   response, it sends messages to many "dumb nodes" chosen randomly. Among all
   these messages, there is only one "real" message. Other messages are fake
   ones, but are indiscernible from the point of view of a "malicious man in
   the middle"). Thus, in order to "spy" your system (to collect data), you
   have to "spy" the entire "galaxy" of "dumb nodes"- and not only one server.
   This makes things much more difficult for "a malicious man in the middle,"
   especially if your "dumb nodes" are located in different countries which
   intelligence agencies are not known to collaborate easily (because cracking
   such a system would require a lot of resources). "dumb nodes" do not need
   to be particularly secured. An attacker could disrupt your system (by
   hacking the "dumb nodes"), but it cannot alter the signed document - unless
   it has a way to crack RSA - or whatever algorithm you use (but, in this
   case, just forget your project...).
Tell me what you think.
Le mar. 28 juil. 2020 ? 12:19, Ayoub Misherghi via Gnupg-users <
gnupg-users at gnupg.org> a ?crit :

@_date: 2020-07-29 15:54:54
@_author: Denis BEURIVE 
@_subject: Protecting encryption server 
*> Quick question: how do you send data out? *
This is not a problem. You connect the output of your data diode to a
computer that will send the data over the Internet using whatever
required protocol. Some commercially available "data diodes" include a
"bare data diode" and the necessary electronics required to send data over
the Internet using the TCP/IP stack.
You can create a data diode with 2 Raspberry Pi (connected through the GPIO
ports). The receiving Raspberry Pi receives data from its GPIO ports... and
nothing prevents it from sending the data over the Internet using its
Internet connection. It does so by using the TCP/IP stack. Therefore, it
knows if the receiving server receives the data or not (since the TCP/IP
stack allows bidirectional exchanges).
[image: rpi.gif]
You can hack the RPI connected to the Internet. But you have no way to hack
the second one since it is not connected to the Internet and since the data
diode is a one way only transmission.
*> Also, hm, here's a possibly stupid question: how do you keep the system
time synchronized between the sender and the receiver?*
That's a good question. However, there is a second question : do you need
to keep the system time synchronized ? If not, then there is no need to
worry about it.
However, if you need to get a very precise time, you can synchronize your
server using a radio-controlled clock (RCC). You can get the necessary
component for a Raspberry Pi, for example.
Below a suggested architecture for a signing server :
[image: server.gif]
Le mer. 29 juil. 2020 ? 09:51, Peter Pentchev  a ?crit :

@_date: 2020-06-05 14:14:53
@_author: Denis BEURIVE 
@_subject: Standalone signature (0x02) ? 
I am studying the RFC 4880 and I am using GPG as a tool to experiment.
I explored PGP signatures. You can find notes here :
I pretty much explore all types of signatures, except one : *Standalone
signature (sigclass = 0x02*).
In the RFC, you can read :
This signature is a signature of only its own subpacket contents. It is
calculated identically to a signature over a zero-length binary document.
Note that it doesn't make sense to have a V3 standalone signature.
This description remains mysterious. I looked for this signature in various
PGP documents but could not spot one.
*Is it possible to generate this kind of signature with GPG ?*
*What is this signature used for ?*
My intuition tells me that it may be used in association with hashed
subpackets. However, I cannot find any document to confirm this intuition.
Thanks for your help,

@_date: 2020-06-08 12:24:15
@_author: Denis BEURIVE 
@_subject: Standalone signature (0x02) ? 
Thank you Werner,
I'll look in the WG back in 1998 (for the "sake of completeness").
Le lun. 8 juin 2020 ? 11:25, Werner Koch  a ?crit :
