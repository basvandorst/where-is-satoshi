
@_date: 2006-02-11 15:05:52
@_author: lion@lion.leolix.org 
@_subject: Bad key - decrypting armoured symmetric message 
Hash: SHA1
$ gpg -vva
gpg: Go ahead and type your message ...

@_date: 2009-08-15 01:26:54
@_author: Philipp Schafft 
@_subject: Transferring GnuPG accounts 
let me guess: your USB stick is FAT formated?
maybe the access permittions of the files aren't as they should.
rename your .gnupg/ to something else, let's say .gnupg-old, then try:
gpg --import ~/.gnupg-old/pubring.gpg ~/.gnupg-old/secring.gpg
if you have a gpg.conf:
cp ~/.gnupg-old/gpg.conf ~/.gnupg/

@_date: 2010-11-21 16:54:17
@_author: Philipp Schafft 
@_subject: 10GB /var/log/messages.log 
I don't know much about pcscd, but maybe there is a loop which should
get a error counter.
did restarting the process help?
Do you use rsyslogd?

@_date: 2012-06-05 12:09:22
@_author: Philipp Schafft 
@_subject: Decryption problems using php 
If you do this the passphrase can be shown by any user on the system
(for example using the ps(1) command). The window for this is small yet
this adds an attack vector. This attack becomes more easy as you may
trigger it via your web application (don't know what kind of
webapplication this is so just gussing here).
Also if you store the passphrase in your scripts it is plain on your FS.
Anyone with FS access can read it. This also includes explits in your
and other software running on your webserver. Even worse: of your
webserver's config is broken at some point it may handle your files as
plain text or something and allowing remote users to just read your
passphrase with a web browser.
I suggest you to drop the passphrase from the key as it does not add any
security in this case but makes stuff like this more complex.
You can actually improve the security by only storing the needed
subkey(s) on your server and have the primary key protected off-side
(for example on your work/devel system). If you need only decrypting
on-side this will perfectly protect you from attacks doing signatures or
certificates (sigs on other keys) or changing the key's crypto material
or options. So if there was a successfull attack somewhere in the future
you can just revoke this subkey and add a new one so your clients can
update using normal keyservers/... without needing to pass fingerprints
around again.
Hope I was of at least some help :)
PS: another attack which is fully off-topic to this list is injecting
something in $unencrypted_file or $encrypted_file. You need to fully
trust the content of those vars.

@_date: 2013-07-16 14:06:03
@_author: Philipp Schafft 
@_subject: Several master keys vs. master key and subkeys 
So what's the point here? If he doesn't yet the concept it doesn't mean
it is bad. It's just a statement about him, not the standard. e.g. I
haven't got the concept of armoured concrete, yet I life in a house
build this way and it works great for me.
I have never seen any. There may be. But there may be also bugs for all
other parts of all other software.
To use really use the subkey you need to be abled to use it anyway. If
you are already be abled to use it (having a copy of the secret key
material, knowing the passphrasse...) there is no longer need to attach
it to a diffrent key. You can already use it.
To me this sounds like half-thought thingy: I don't understand the
concept fully so I consider it to have security problems.
For the few setups I used this before it worked for me.
Biggest problem to me with this (some used do it so it *is* a real world
problem to me): this breaks the Web of Trust. The normal calculation
doesn't work anymore as expected. Validity is calaculated wrong (as
those are leaf nodes in the WoT and have only one other node connected).
Also signing those keys isn't a better option: they are replaced yearly
or something. So as soon as the key is expired or revoked I would need
to re-sign the replacing key.
Also if I trust both keys in some way the person counts twice if he
signs some other keys. If he does that for some years he may have a sum
of keys I have signed and trust. If he un-expires them so they become
valid again he can sign some other key and that one becomes valid and
trusted to me with just that person as trust path. So the person can
'inject' a valid key as of the view of my gpg.
So for me that often leads to alterning the trustdb manully that adds
extra work and has some risks of it's own. See above.
You can always revoke any primary or subkey. You just need to be abled
to use the corressponding certification key (your primary key) or create
a revocation certificate (signature) after creating the key and use that
late. (there are more ways to invalidate a key but I don't want to
confuse you more than needed :).
Hope my post is of any help.

@_date: 2015-08-16 11:18:20
@_author: Philipp Schafft 
@_subject: protecting pub-keys from unwanted signatures 
Maybe you can explain your use case a bit.
Think about this:
You can easily create a little document with the fingerprint of the key
you want to sign, timestamp, maybe other notions and sign that. Then you
can publish this document. In fact the signature on a key is very
similar to such a document. Just that it has a machine readable
