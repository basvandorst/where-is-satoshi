
@_date: 2018-05-16 10:54:52
@_author: Randy Trinh 
@_subject: [GPGME] Repeated decrypt fails 
Hi everyone,
I'm fairly new to GnuPG and GPGME in general and I'm currently trying to
implement a process in which a file is uploaded from a website in which
case my program uses GPGME to decrypt the file returning true or false.
The first time I upload the file (a .tar.gz) and run
"gpgme_op_decrypt_start" and then "gpgme_wait", the file is decrypted
successfully in which case I can extract the contents, but if I upload the
SAME original file again or any amount of times after the first instance,
GPGME fails** to decrypt it. Is there anything I may be doing wrong?
**Fails:  GPGME returns an error of success and a "decrypted" .tar.gz file
that is empty -- The uploaded file in both instances can still be decrypted
by calling GnuPG from command line but the only way to get GPGME to
successfully decrypt after the first decryption is to restart my program.
(Is it also normal for GPGME to return an error of success for this
instance as it has clearly failed/produced a corrupted file? Similarly it
also returns an error result of success even when I upload a non-encrypted
.tar.gz whereas GnuPG outputs that no OpenPGP data is found and the decrypt
message has failed: eof)

@_date: 2018-05-17 14:48:01
@_author: Randy Trinh 
@_subject: [GPGME] Repeated decrypt fails 
The file is encrypted first by the user and then uploaded to which my code
subsequently decrypts it.
Certainly! I've provided the entire GPGME portion of the function below,
I'm not entirely certain if this is acceptable to call every time my
program decides to attempt a decrypt though (Feel free to highlight my
setlocale (LC_ALL, "");
gpgme_error_t err, stat;
gpgme_ctx_t ctx;
gpgme_decrypt_result_t decResult;
gpgme_data_t fileEncrypted, fileDecrypted, keydata;
int systemVal;
std::string tempFile = "TemporaryFile";
std::string newFileName = "Decrypted";
std::string newFileNameExt = newFileName + ".tar.gz";
const char* name = newFileNameExt.c_str();
err = gpgme_new(&ctx);
err = gpgme_engine_check_version (GPGME_PROTOCOL_OpenPGP);
if (boost::filesystem::exists(tempFile))
    boost::filesystem::remove_all(tempFile);
int fdEncrypt = open(fileName, O_RDONLY);
int fdDecrypt = open(name, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);
err = gpgme_data_new_from_fd(&fileEncrypted, fdEncrypt);
err = gpgme_data_new_from_fd(&fileDecrypted, fdDecrypt);
err = gpgme_op_decrypt_start(ctx, fileEncrypted, fileDecrypted);
ctx = gpgme_wait(ctx, &stat, 1);
std::cout << "Decrypt Status: " << gpgme_strerror(err) << std::endl;
gpgme_decrypt_result_t dResult = gpgme_op_decrypt_result(ctx);
if (dResult->unsupported_algorithm)
    std::cout << "invalid decrypt" << std::endl;
The version of GPG I am using is 2.0.22 (or 1.4.16) I have both installed
but I'm actually not entirely confident which one is being used by GPGME.
As for GPGME, I am using Ver 1.11.1.
Thanks for the reply! ?

@_date: 2018-05-18 12:31:54
@_author: Randy Trinh 
@_subject: [GPGME] Repeated decrypt fails 
Here you show the result of the start operation which is usuallay
success.  What you need to check here instead is STAT as returned by
Thanks for that! I just fixed that and now the error I get the second time
I upload is the "NO_DATA" error (which is reasonable as it decrypts anyways
with no data), Again the file that is obtained through the upload can still
be decrypted via the command line just fine.
Is there a reason why you use the asynchronous operaions and not the
synchronous?  Your code would not work with multiple threads because
gpgme_wait may only be called by one thread.
The only reason I have it as asynchronous would be because the file that is
being decrypted is then unzipped and its contents loaded elsewhere - but
rather than using a library (as of current), I just called a system() to
execute the zip and without this.
gpgme has a function to figure this out:
  /* Get the information about the configured engines.  A pointer to the
   * first engine in the statically allocated linked list is returned.
   * The returned data is valid until the next gpgme_ctx_set_engine_info.
  gpgme_engine_info_t gpgme_ctx_get_engine_info (gpgme_ctx_t ctx);
With this I can confirm its using 2.0.22.

@_date: 2018-05-18 14:59:54
@_author: Randy Trinh 
@_subject: [GPGME] Repeated decrypt fails 
I identified the error! I had called "gpgme_set_engine_info" in attempt to
get gpgme working on a different device earlier and did not remove this.
For some weird reason this changed the configured engine version from
2.0.22 to 1.0.0 only after the first instance.
Thanks for all the help everyone!

@_date: 2018-05-24 15:46:58
@_author: Randy Trinh 
@_subject: gpgme: environment variable not set 
I have recently cross compiled gpgme for a program I am working on but
gpgme fails to function as expected as I get an error saying an environment
variable cannot be found -- verbose in this case doesn't really elaborate
on what that missing environment variable may be.
This happens when I try to import a key and then decrypt a file -- the
import returns a success but I assume only the public key has been imported
because the decrypt error claims there is no secret key.
I have checked gpgconf --check-program and noticed that the scdaemon path
is incorrect but I both don't know how to change the path -- and whether or
not that will fix it.
Does anyone have any possible idea as to why I can't seem to access my
private-keys on my cross compiled device?
Thanks in advance,
