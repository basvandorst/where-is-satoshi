
@_date: 2002-04-10 01:54:02
@_author: Leigh S. Jones 
@_subject: key security 
The only real security for your encrypted data depends
on the quality of your passphrase, although to some
degree there may be some degree of physical security
that you can provide for your computer.  Computers at
a company are rarely secure, even when locked behind
doors.  If prying eyes really want to see your data,
they can get behind the doors and beyond the boot ROM
password, your computer can be booted from a floppy
or tape giving the invader root access to your whole
drive without even guessing a password.  Or your hard
drive can be unplugged and jumpered over to a laptop
that will soak up everything.  The whole job will be
over quickly and quietly without you ever knowing
anything happened.
You have, basically, 1 defense.  Forget removable
media for the secret key ring file, it will eventually
become such a nuisance to use that you give up on
securely storing it on a regular basis, or else your
secure storage will be insecure.  Unless you do nothing
that anyone would ever be interested in knowing about,
your highly secure password is your only defense.
Frankly, in the present electronic age this is quickly
becoming very important in many more ways than one might
at first imagine.  People don't have to do anything
spicy in their lives to have a very real need to keep
secrets.  Consider the credit card number.
In my business we do nothing that needs to be kept a
secret beyond the occasional intellectual property.  But
we will be using electronic signatures to replace
signatures on paper documents widely very soon, and in
an environment where secret keyrings must be widely
shared.  Password integrity becomes the only available
means for assurance that the system will work.
There's no sense in attempting password security that
exceeds the basic security of the underlying encryption
system.  For the most secure applications it should take
an attacker just a little bit less effort to break GPG's
underlying symmetric-key cryptography than to break your
own password by guessing.  There are ways to assure that
you've selected a password this random while still
making it possible for you to remember your password.
Research them, and but keep the method you use secret.
Don't recommend a method that you like on a public forum
like this one.  If you come on here and tell everyone you
used "head -c 16 /dev/random | mimencode" then
everyone knows how best to attack you.  Better to tell
them you used "head -c 24 /dev/random | mimencode" but
actually use the telephone number for your dead
grandmother that you remember from your youth plus your
dog's name plus two different negative descriptors you use
for your two ex-wives plus your favorite flavor...
----- Original Message -----
Sent: Tuesday, April 09, 2002 12:37 PM

@_date: 2002-04-10 03:28:01
@_author: Leigh S. Jones 
@_subject: key security 
GPG and PGP essentially use the same scheme.  A 128 bit symmetric-key
algorithm does the basic encoding, while perhaps a 2048 bit public key
encrypts the randomly generated 128 bit session key for transmission
the target, who uses his 2048 bit secret key to decode the session
So your password, if truly random, needs to be 128 bits.
That's why the "head -c 16 /dev/random | mimencode" suggestion
appeared here.  16 bytes times 8 bits per byte equals128 bits.  If you
get truly random numbers from your /dev/random (generally available
on linux) then you will get 128 bits of randomness in the mime output
from the output -- no more, no less.  Might seem pretty slick to use
that to generate a password -- if you can memorize it.  Honestly,
a quality 128 bit symmetric key algorithm should do a great job.
My calculator says:
3.04E+38 trys to check all combinations.
But don't tell everyone how to best attack your password.
----- Original Message -----
Sent: Tuesday, April 09, 2002 5:25 PM

@_date: 2002-04-10 18:51:02
@_author: Leigh S. Jones, KR6X 
@_subject: Multiple File Encryption  (Win32) 
OK; here's the finished C language wrapper program file for Borland C.  Or,
at least, partially finished.
Eventually I'd like to add some additional security, like taking file
ownership to assure privacy of the
password file during the many milliseconds that it is in existence.
Once again, the program that follows was tailored to applying signatures,
but could easily be adapted
to decryption under batch mode.  For this program, the command line
arguments include two file
names that will be used as the output file name (in this case the
clearsigned text file) and a "status" file
that will collect some output from the GPG program itself.  The batch file
calling this program must
create the file containing the password (remember that for security's sake
the password should not be
on the command line) and pass along the filename to this program.  The
program has a feature (that
can be disabled) that would check for a network time server immediately
prior to applying the
signature.  You wouldn't want any of that stuff for decryption.  My
application really wanted to know if
the signature had been successfully applied -- you might not care for some
of the error checking...
      int main ( int argc, char *argv[ ] )
   {
   int passphrase;
   int status;
   int error;
   int time_error;
   FILE *ptr;
   char buf[ 1024 ];
* argv strings represent:
* user_id
* passphrase
* target_file
* passphrase_file
* status_file
   time_error = 0;
   if ( ( argc != 6 ) && ( argc != 7 ) )
      {
      if ( ( strncmp ( "NULL", argv[ 2 ], 4 ) ) && ( argc > 4 ) )
         {
         passphrase = open ( argv[ 4 ],
                             O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                             S_IREAD | S_IWRITE );
         write ( passphrase, "12345678901234567890", 20 );
         close ( passphrase );
         unlink ( argv[ 4 ] );
         } /* end if ( strncmp ( "NULL", argv[ 2 ], 4 ) ) */
      return ( -1 );
      } /* end if ( argc != 7 ) */
   if ( ( argc == 7 ) &&
        strncmp ( argv[ 6 ],
        "NO_TIME_SET",
        strlen ( "NO_TIME_SET" ) ) )
      {
      if ( ( strncmp ( "NULL", argv[ 2 ], 4 ) ) && ( argc > 4 ) )
         {
         passphrase = open ( argv[ 4 ],
                             O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                             S_IREAD | S_IWRITE );
         write ( passphrase, "12345678901234567890", 20 );
         close ( passphrase );
         unlink ( argv[ 4 ] );
         } /* end if ( strncmp ( "NULL", argv[ 2 ], 4 ) ) */
      return ( -1 );
      } /* end if ( argc != 7 ) */
   if ( argc == 6 )
      {
      sprintf ( buf, "NET TIME /SET /Y" );
      ptr = _popen ( buf, "rt" );
      while ( !feof ( ptr ) ) fgets ( buf, sizeof ( buf ), ptr );
      time_error = _pclose ( ptr );
      } /* end if ( ( argc == 7 ) && ( ... ) ) */
* passing "NULL" as the password results in reading of the password file
* rather than creation of a new password file
   if ( strncmp ( "NULL", argv[ 2 ], 4 ) )
      {
* set up to pass the password in a temporary file
* first, open the temporary file for writing, checking for failure
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      if ( passphrase <= 0 )
         {
         return ( -2 );
         } /* end if ( passphrase <= 0 ) */
* write the password from the command line to the temporary file
      if ( write ( passphrase, argv[ 2 ], strlen ( argv[ 2 ] ) ) <= 0 )
         {
         close ( passphrase );
         unlink ( argv[ 4 ] );
         return ( -3 );
         } /* end if ( write ( passphrase, ... ) <= 0 ) */
* close the temporary file and reopen for reading
      if ( close ( passphrase ) != 0 )
         {
         passphrase = open ( argv[ 4 ],
                             O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                             S_IREAD | S_IWRITE );
         write ( passphrase, "12345678901234567890", 20 );
         close ( passphrase );
         unlink ( argv[ 4 ] );
         return ( -4 );
         } /* end if ( close ( passphrase ) <= 0 ) */
      } /* end if ( strncmp ( "NULL", argv[ 2 ], 4 ) */
   passphrase = open ( argv[ 4 ], O_RDONLY | O_TEXT );
   if ( passphrase <= 0 )
      {
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      return ( -5 );
      } /* end if ( passphrase <= 0 ) */
* open the temporary file for writing
   status = open ( argv[ 5 ],
                   O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                   S_IREAD | S_IWRITE );
   if ( status <= 0 )
      {
      close ( passphrase );
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      return ( -6 );
      } /* end if ( passphrase <= 0 ) */
* form and execute the command line that runs gpg
   sprintf ( buf,
             "gpg --passphrase %d --status-fd %d -u %s --batch --clearsign
             _get_osfhandle ( ( int ) passphrase ),
             _get_osfhandle ( ( int ) status ),
             argv[ 1 ],
             argv[ 3 ] );
   ptr = _popen ( buf, "rt" );
   if ( !ptr )
      {
      close ( passphrase );
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      close ( status );
      unlink ( argv[ 5 ] );
      return ( -7 );
      } /* end if ( !ptr ) */
   while ( !feof ( ptr ) ) fgets ( buf, sizeof ( buf ), ptr );
* close the pipe from gpg and check for nonzero exit status
   if ( ( error = _pclose ( ptr ) ) != 0 )
      {
      close ( passphrase );
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      close ( status );
      status = open ( argv[ 5 ], O_RDONLY | O_TEXT );
      read ( status, buf, sizeof ( buf ) - 1 );
* the first line of the status file should contain "USERID_HINT"
      if ( !strstr ( buf, "[GNUPG:] USERID_HINT" ) )
         {
         if ( error == 2 )
            {
            error = -111;
            }
         close ( status );
         unlink ( argv[ 5 ] );
         return ( error - 100 );
         } /* end if ( strncmp ( buf, "[GNUPG:] USERID_HINT", ... ) */
* the second line of the status file should contain "NEED_PASSPHRASE"
      if ( !strstr ( buf, "[GNUPG:] NEED_PASSPHRASE" ) )
         {
         if ( error == 2 )
            {
            error = -112;
            }
         close ( status );
         unlink ( argv[ 5 ] );
         return ( error - 100 );
         } /* end if ( strncmp ( buf, "[GNUPG:] NEED_PASSPHRASE", ... ) */
* the third line of the status file should contain "GOOD_PASSPHRASE"
      if ( !strstr ( buf, "[GNUPG:] GOOD_PASSPHRASE" ) )
         {
         if ( error == 2 )
            {
            error = -113;
            }
         close ( status );
         unlink ( argv[ 5 ] );
         return ( error - 100 );
         } /* end if ( strncmp ( buf, "[GNUPG:] GOOD_PASSPHRASE", ... ) */
* the fourth line of the status file should contain "SIG_CREATED"
      if ( !strstr ( buf, "[GNUPG:] SIG_CREATED" ) )
         {
         if ( error == 2 )
            {
            error = -114;
            }
         close ( status );
         unlink ( argv[ 5 ] );
         return ( error - 100 );
         } /* end if ( strncmp ( buf, "[GNUPG:] SIG_CREATED", ... ) */
      close ( status );
      unlink ( argv[ 5 ] );
      return ( error - 100 );
      } /* end if ( !ptr ) */
* close the temporary (password) file and delete it
   if ( close ( passphrase ) != 0 )
      {
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      close ( status );
      unlink ( argv[ 5 ] );
      return ( -8 );
      } /* end if ( close ( passphrase ) <= 0 ) */
   if ( unlink ( argv[ 4 ] ) )
      {
      close ( status );
      unlink ( argv[ 5 ] );
      return ( -9 );
      } /* end if ( close ( passphrase ) <= 0 ) */
* read back the status file written to by gpg and check for signs of failure
   close ( status );
   status = open ( argv[ 5 ], O_RDONLY | O_TEXT );
   read ( status, buf, sizeof ( buf ) - 1 );
   close ( status );
   unlink ( argv[ 5 ] );
* the first line of the status file should contain "USERID_HINT"
   if ( !strstr ( buf, "[GNUPG:] USERID_HINT" ) )
      {
      return ( -10 );
      } /* end if ( strncmp ( buf, "[GNUPG:] USERID_HINT", ... ) */
* the second line of the status file should contain "NEED_PASSPHRASE"
   if ( !strstr ( buf, "[GNUPG:] NEED_PASSPHRASE" ) )
      {
      return ( -11 );
      } /* end if ( strncmp ( buf, "[GNUPG:] NEED_PASSPHRASE", ... ) */
* the third line of the status file should contain "GOOD_PASSPHRASE"
   if ( !strstr ( buf, "[GNUPG:] GOOD_PASSPHRASE" ) )
      {
      return ( -12 );
      } /* end if ( strncmp ( buf, "[GNUPG:] GOOD_PASSPHRASE", ... ) */
* the fourth line of the status file should contain "SIG_CREATED"
   if ( !strstr ( buf, "[GNUPG:] SIG_CREATED" ) )
      {
      return ( -13 );
      } /* end if ( strncmp ( buf, "[GNUPG:] SIG_CREATED", ... ) */
   if ( time_error )
      {
      return ( -1000 - time_error );
      } /* end if ( time_error ) */
* exit with success status
   return ( 0 );
   } /* end main ( ) */
----- Original Message -----
Sent: Tuesday, April 09, 2002 17:45
Hi all-
I'm trying to come up with a way to encrypt batches of files... 10-15 at
most with varying file names.  I want the files to be encrypted into either
a single large file or in to multiple files, each replacing the
non-encrypted version.  The files are *NOT* ASCII text.  I want to then be
able to decrypt each of them to the original state with a single command
(batch file)
Now... after searching around the web for a while, I'm not having much luck.
Any thoughts?  I've got GnuPG downloaded and working.  I'm running Windows
XP... so this is a Win32 thing.

@_date: 2002-04-11 16:12:01
@_author: Leigh S. Jones 
@_subject: 1024 or 2048?? 
The 2048-bit key offers more security, but in a practical sense it
depends on just who is doing the snooping.  A 16 bit key will
keep your secrets safe from your wife.  A 512-bit key will give most
people certainty that the key will not be factored by your
employer in this decade.  A 1024-bit key will keep your credit card
relatively safe from crime for the next few years.  But, fly a
jetliner into a building in New York and you can bet that 4096 bits
will not keep your messages safe.
----- Original Message -----
Sent: Thursday, April 11, 2002 1:41 AM
in the
or is

@_date: 2002-04-12 05:53:01
@_author: Leigh S. Jones 
@_subject: 1024 or 2048?? 
Of course the reason that messages encrypted with 4096 bits of public
can be broken is that the NSA is equipped to brute force the symmetric
encryption after some time.
----- Original Message -----
Sent: Thursday, April 11, 2002 8:51 AM

@_date: 2002-04-13 01:49:01
@_author: Leigh S. Jones, KR6X 
@_subject: --command-fd 
To avoid forcing the user to put sensitive information onto the command line
(and thus compromising security due to the availability of commands such
as ps -ef or ps -aux on Unix/Linux systems that allow all users access to
command line contents) gpg accepts inputs that could be sensitive into
files, opening the files, and passing the file descriptors to the gpg
line as ASCII decimal integers.  The file descriptors could actually point
to an
open file or a memory buffer, but your ability to control read access to
disk files under Unix allows you to protect your sensitive data.
This could be used to protect your password, as in "gpg --passphrase --status-fd  -u [user] --batch --clearsign [filename]".  The file
 that follows --status-fd gets the text from the gpg status messages
would be outputted to the screen otherwise.  You must have the file open
when you execute the command.
If you use file descriptors like the zero that you've illustrated below, you
usually indicating keyboard input.  Isn't it zero for keyboard (stdin), 1
screen output (stdout), 2 for error (stderr) on many machines?  When the
--command-fd 0 is indicated on the command line, it is usually being used
to allow the command line calling the batch file to pass the command,
something like putting in the password with:
echo [password] | gpg --passphrase 0 -u [user] -d [filename]
Of course, you'd only do this on a single user computer that will not other
users to view your password, like a home computer running Linux that
isn't connected to the network.
----- Original Message -----
Sent: Friday, April 12, 2002 16:05

@_date: 2002-04-18 22:47:02
@_author: Leigh S. Jones, KR6X 
@_subject: Encrypt a whole directory in a single pass 
There are command-line implementations of gzip and tar that will
do the job under Microsoft operating systems, although there are
often limitations such as 8.3 filenames.
WinZip will open tarfiles and gzip files, but will not create them.
Generally, the "zip" format will be the format of choice on Microsoft
operating systems while tar and gzip or "compress"/"uncompress"
will be the archival method of choice on Unix and Linux.  There is
a "zip" implementation that is unique to Unix, producing files of a
different format from WinZip and other Microsoft implementations.
As of 1993, perhaps earlier, the zip implementation used widely on
Unix (SunOS and others) included the capability to produce files
that adhere to the zip formats from the Microsoft realm. More
modern is the "bzip2" zip format that produces tighter compression
yet but often seems to be available only on Unix/Linux computers
although I know of no reason that the program couldn't be compiled
under djgpp or similar to produce a Microsoft implementation.
WinZip hasn't been supporting bzip2 in the past nor "compress"/"
uncompress" outputs, although I haven't read the specs on the
latest release of WinZip to see what might be added in new
Frankly, for most kinds of files, the output produced by WinZip
will occupy more disk space than gzip or bzip2 files, with by
far the best compression performance marks going to bzip2.
Many of these tools provide for encryption as well as compression,
although I'd generally have more confidence in the gpg and
PGP encryption than in the zip tools if the security of the files
was at risk.
----- Original Message -----
Sent: Wednesday, April 17, 2002 22:34

@_date: 2002-04-20 01:23:01
@_author: Leigh S. Jones, KR6X 
@_subject: compiling win32 
I'm probably going to have to conquer this issue myself
pretty soon, so I'm curious what answer will arise.
But my guess would be that the issue isn't figuring out
which library you need to add, but instead figuring out
which configure options you need to invoke prior to
performing the "make".  I'd bet that a quick search of the
archives for this reflector would turn up an answer...
That issue aside, I'm not sure why you're compiling this
version for windows when it is available in a precompiled
binary.  Knowing that I'm going to need to compile it
myself in the future makes it easier for me to understand
that you may actually have a need yourself -- but it is
already available.
----- Original Message -----
Sent: Friday, April 19, 2002 14:23

@_date: 2002-04-22 16:07:02
@_author: Leigh S. Jones 
@_subject: 1.0.6e symmetrically encrypted signed message fails to decrypt 
Can you read this?
No problem.
----- Original Message -----
Sent: Monday, April 22, 2002 5:38 AM

@_date: 2002-04-22 16:12:02
@_author: Leigh S. Jones 
@_subject: tar, gzip etc. in Windows [was: Re: Encrypt a whole directory in a single pass] 
I've used cygwin to make/compile gnupg now.  Had to include a few
options on the "./configure" command line to make it all compile.  It
worked.  But, oddly enough, I needed to take care in its use.  The
win32 binaries that I'd placed in the C:\Winnt directory were being
called instead of the desired version, resulting in the use of the
keyrings.  Networking didn't work quite right.
----- Original Message -----
Sent: Monday, April 22, 2002 3:08 AM

@_date: 2002-04-25 16:11:01
@_author: Leigh S. Jones 
@_subject: keyserver access on Win2k 
I was having trouble making gpg for W32 talk to keyservers on both
winnt and win2k.  Probably would have had the same problem on
win9x.  Linux worked fine.  It's probably a protocol problem.  You
have to use http servers -- port 80 -- only, no LDAP, etc.  Worked
it out when I let WinPT take over for me calling gpg and suddenly
there were keyservers that worked...
----- Original Message -----
Sent: Thursday, April 25, 2002 2:21 AM
or a

@_date: 2002-04-25 20:12:01
@_author: Leigh S. Jones, KR6X 
@_subject: keyserver access on Win2k 
Thanks!  That's interesting information.
----- Original Message ----- Sent: Thursday, April 25, 2002 07:43

@_date: 2002-04-26 07:27:01
@_author: Leigh S. Jones 
@_subject: using the same key from PGP and GPG 
I don't seem to be having any trouble exporting keys from gpg 1.06
to PGP 7.03.  I think I blundered into setting up the gpg "options"
with a set of choices that allow me to export my keys -- both secret
and public -- from one to the other (either direction) and
encrypt/decrypt either direction and sign/verify either direction.
Admittedly, I've limited my testing to methods that I actually intend
using.  I do not "sign", I "clearsign".  I do not "encrypt", I
ASCII-armored".  I export my keys as ASCII-armored files.  This
does not mean that the other methods, just that I haven't tested
the other methods.
And, the substantial majority of my testing has been done using
Windows NT.  This has all been tested on a Sun system with
Solaris, on An HP system running HPUX, on a Cygwin bash
shell, on Linux, and on Windows 2000 as well, but generally
only a few tests were performed on each platform.  The
majority of the testing effort done was intended to verify that
the keyring files from one platform could be used on the other
platforms with simple replacement of files, and that text files
that have been clearsigned using gpg could be verified on PGP
7.03 under Windows NT.
Throughout the effort (which was necessary for a project at
my work) the only problem uncovered was difficulty
accessing keyservers using 1.0.6 Win32 binary versions,
and this problem was not important to the project.
A few tiny oddities were revealed:
Relating to the use of WinPT to view key properties, when
the keys exported from PGP included a photograph,
often the photograph title would apparently be taken by
WinPT to be a user ID.
But I'm presently enjoying the use of WinPT, and I'll
probably make the move to gpg.exe and WinPT.exe
complete with the deletion of PGP from my systems
soon.  The gpg/WinPT combination of software has
some limitations -- primarily that the level of integration
of PGP with e-mail tools like Outlook and Outlook
Express is very good and gpg doesn't quite meet this
standard -- but I generally prefer signing/verifying or
encrypting/decrypting the clipboard rather than in a
buffer within the e-mail tool.  This is probably a poor
practice when you're connected to a large windows
network because windows has features aimed at pulling
data off of the clipboard on one system and putting it
on another system, and I'm not quite convinced that
there isn't a security issue there.  Using a TCP
(forwarded) network eliminates this outside of the
local network because the windows stuff can't be
For me, --openpgp, sha1 hash, and --s2k-cipher-algo
3des, options were all called out in my successful options
file.  Unfortunately, I don't have a copy of the good
options file at the moment -- I'll have to put it on the list
tomorrow.  I think I abondoned the RFC1991 and
--force-v3-sigs options as being out of date, and used
CAST symmetric key encryption in PGP.
----- Original Message -----
Sent: Thursday, April 25, 2002 7:23 PM
GNUPG and

@_date: 2002-04-26 17:20:01
@_author: Leigh S. Jones, KR6X 
@_subject: (no subject) 
With gnupg you don't use your name to identify the key to be exported.
First use > gpg --list-secret-keys
and read the 8 digit number representing the key you want to export
(it usually follows "sec 1024D/" or similar)
then do > gpg -o secret_key.asc --armor --export-secret-key 0x
and while you're at it do > gpg -o public_key.asc --armor --export
----- Original Message -----
Sent: Friday, April 26, 2002 07:11
to import it The program do nothing....

@_date: 2002-04-26 18:02:01
@_author: Leigh S. Jones, KR6X 
@_subject: using the same key from PGP and GPG 
Here's the promised options file (the one that I've been using to allow keys and encrypted/signed data to interoperate with PGP 7.03. Clearly there
are some alternate choices -- you might use cipher-algo CAST5 in lieu of 3DES, or
s2k-digest-algo MD5 in lieu of SHA1, etc., and
still be able to interoperate with PGP.
compress-algo 1
cipher-algo 3des
s2k-cipher-algo 3des s2k-digest-algo SHA1 keyserver These won't work with the earlier versions of PGP
(<= 5), where the --rfc1991 option must be set instead
of openpgp and --force-v3-sigs.  There were really
a lot of different versions of PGP with different requirements.  There is information on some web
sites I've seen that is helpful with older versions of PGP, and some information in the gpg distribution
tar file that is also informative.  And, again, you'll probably need to encrypt to something other than idea in PGP (unless you're outside of the US where the American idea patent isn't in effect and have equipped your gpg with the idea plug-in) -- a good suggestion would be CAST -- and in windows you'd set this under (from the tray menu) (tab) .

@_date: 2002-04-26 20:38:02
@_author: Leigh S. Jones, KR6X 
@_subject: strange email 
I didn't pay much attention when I received it, but someone put a
message out purportedly from the list saying that the e-mail
addresses from users had been hijacked.  That being the case,
you've may possibly have received this message because
someone who wanted to publicize the Spice girls concert
impersonated you while sending a message to the list.  Without
impersonating a list member, the promoter wouldn't have a
chance of getting his message through.  Sounds like a case
for tighter moderation controls for a while.
----- Original Message -----
Sent: Friday, March 28, 2031 12:35

@_date: 2002-04-28 04:06:01
@_author: Leigh S. Jones 
@_subject: [Mark Wall <wall@chop.swmed.edu>] 
Hello Mark:
1 -- no
2 -- yes
3 -- no
Expanded answers:
1) Although gpg is a program written primarily for Gnu/Linux systems,
it has been laboriously adapted to multiple platforms.  Linux and Unix
systems are occasionally quite different, and there may be no
guarantee that a file image on disk that has been overwritten will
actually be overwritten.  On many platforms an update to a file will
be written to a new location on the disk, leaving the old image on
disk unchanged.  Overwriting a file with random data to obliterate
all traces of a file from the disk image has to be done by programs
that are written for particular platforms using very low level
commands.  Look for a program that is written for your particular
platform (Linux, Unix -- of a particular release, Windows, etc.)
that offers this capability.  For instance, because there may be an
interest in this capability, future releases of programs like WinPT
might include this feature (it doesn't include the capability right
now).  Of course, some platforms already include commands that
will obliterate all data from one file or another on disk already.
2) GnuPG doesn't care whether the file is text or binary.
3) Tough question.
Coming from the Unix/Linux world, GnuPG assumes a certain
level of sophistication among its users.  Unix/Linux users can
usually write quick scripts that satisfy the need to perform
multiple operations like this one very quickly.  To make this
possible, GnuPG's default encrypting/decrypting capability
channels input into it through "stdin" and channels output out
through "stdout".  This is like encrypting the keyboard entries
and sending the output to the screen.  Then the operating system
"pipe" and "redirect" features (usually the "|" and ">" characters
on the command line are used) will direct input and output from
whatever files are required.  Building scripts from "ls -1" and
"args" commands allows whole directories to be encrypted.
Decryption is more difficult.  For each file decrypted, GnuPG
will usually prompt for a password.  If it's not important to
decrypt whole directories at once, this might not be a problem.
But it would be a problem to be forced to enter your password
a few hundred times to decrypt a directory.
On Unix/Linux systems, the GnuPG Agent program can
sometimes help.  There are security problems associated with
GnuPG Agent on systems where shared use of the system is
part of the reality.  At my work there is an extensive network
of Sun systems.  Each system allows anyone to log on.  No
one needs to be at the particular system to log onto it.  Nothing
flags a user that someone else has logged onto his desktop Sun
system, except perhaps the response by the system to "who"
commands.  Almost all user data is written to a user's home
directory, and all user's home directories are on a server and
never locally stored -- in fact it nearly takes root privileges
to put anything onto your own Sun computer.  In such an
environment, use of GnuPG Agent would compromise a
password.  One might be able to get away with it, but it
wouldn't be wise.
Often add-in programs can help where the native capability
is weak.  For instance, on windows systems there is a
program named WinPT that can make it possible to
encrypt multiple files.  I wouldn't recommend using WinPT
for encrypting large directories at a time quite yet, but
perhaps a dozen small files at once is quite practical.  They
are still working bugs out of WinPT, but it's a great start
for making GnuPG a real good tool on windows.
Check the archives of the gnupg-users list for a program
I wrote for Borland C that interfaces with the windows
version of gpg to make multiple accesses of a password.
The program was written for signing, but decrypting
would only require a tiny rewrite.  A batch file could
call this program.
----- Original Message -----
Sent: Saturday, April 27, 2002 2:24 PM

@_date: 2002-04-30 16:04:02
@_author: Leigh S. Jones 
@_subject: Fw: [Announce] GnuPG 1.0.7 released 
Congratulations on this marvelous achievement, Werner!
----- Original Message -----
Sent: Tuesday, April 30, 2002 3:07 AM
"gpg --rebuild-keydb-caches"

@_date: 2002-04-30 19:40:02
@_author: Leigh S. Jones, KR6X 
@_subject: import public keys generated with PGP 7.0.3 
I've been successful importing both public and private keys from
PGP6 and PGP7 including 7.0.3 into gnupg 1.0.6 for some time
now.  My first suggestion is to set the preferred encryption
algorithm within PGP  to "CAST", perhaps
this might have to be done before creating your key (I'm not sure
of this) but certainly before exporting.  Export the key from
PGP-Keys by highlighting it and selecting .
Save file as type ASCII (*.asc).  If you need to export the private
key, check the appropriate box.
When you get the key into gpg, you may have to trim off some
user ID "images" with the command gpg --edit-key 0x
before the keys will be usable.  It's usually a good idea to remove
any user ID's you are not going to use as well, if there are multiple
IDs on the key.  WinPT seems to have a little trouble with extra
user ID's.  See the gpg man pages for info on using the --edit-key
command.  At least in 1.0.6 you started the --edit-key mode, then
selected a user ID number by typing "uid 2" or similar, then
performed a delete operation by typing "deluid".
Looks like my first "make" operation of gpg-1.0.7 was successful
on Sun Solaris 2.5 (sparc) with gpg and gnu make.  Now to test
the new release.
----- Original Message -----
Sent: Tuesday, April 30, 2002 08:49

@_date: 2002-07-01 18:42:02
@_author: Leigh S. Jones, KR6X 
@_subject: GnuPG 1.1.90 released ('diskperf -y' ) 
Keith -- I had come to regard this message as the real thing.  My
understanding was that statistics generated by 'diskperf -y' were
used in the random number generator to add entropy.  So with
the knowledge that 'diskperf -y' would slow my disk operations
(though perhaps imperceptibly) I've always enabled diskperf.
I'm not requesting specifics, but I'd regard this as a bug only if
'diskperf -y' has no positive effect on random number generation.
Is this your understanding?
----- Original Message -----
Sent: Monday, July 01, 2002 09:29

@_date: 2002-07-01 19:04:01
@_author: Leigh S. Jones, KR6X 
@_subject: GnuPG 1.1.90 released ('diskperf -y' ) 
When 'diskperf -y' is enabled I no longer see that message
on the WinNT and Win2K operating systems.  Does that mean that on these two operating systems the calls do not
----- Original Message ----- Sent: Monday, July 01, 2002 09:54

@_date: 2002-07-01 19:52:02
@_author: Leigh S. Jones, KR6X 
@_subject: GnuPG 1.1.90 released ('diskperf -y' ) 
I see.  The diskperf message then is not produced when
the RNG is used for encrypting?
----- Original Message -----
Sent: Monday, July 01, 2002 10:24
start at

@_date: 2002-07-02 17:42:02
@_author: Leigh S. Jones, KR6X 
@_subject: Safety questions (Michal Wencl) 
1. Is it better to encrypt (by symmetric cipher) plain file or a
compressed one? Does it even matter?
The level of security provided by gpg is so high that the
additional security provided by compression is a minor
issue.  But, yes, if someone were to attack your encryption
by "brute force", the compression provides an additional
impediment.  A brute force attack takes tremendous
computer resources and is more costly to accomplish than
your encrypted data is worth to the attacker.  Adding the
requirement of expanding a compressed file to this further
drains the computing resources of the attacker.
2. Is there a safety risk if an attacker knows the target file
type (structure), e. g. if he or she knows that the encrypted
file is a JPEG picture, HTML document, gzip archive, Windows
executable, Unix binary etc.?
This should not be considered a safety risk.  As in the case
of compressed data, many of these file formats are difficult
to recognize as the correctly unencrypted data.  For an attacker
it is more difficult to decrypt your data if he does not understand
the nature of the data.  If he looks for text, he will very likely be
searching for keys that turn the encrypted data into something
that contains a lot of spaces.  Spaces in text are an attackers
friend.  They occur much more often in correctly deciphered
data than they do in garbage.  It's not necessary to look for
words, only spaces.  JPEG files, gzip archives, etc., have
less spaces, so an attacker looking for text could overlook
them.  If you are an attacker who has to look for JPEG files,
gzip archives, plus text, then your computer doing the search
has to do more computing than the attacker who only needs
to look for text.  This is trivial to program, but takes time
when the attack is really underway.
3. If an attacker gets a plaintext and a ciphertext can he or she
find the passphrase?
This question is very vague.  In general, encryption with gpg
is not performed using a cipher that uses a passphrase.  The
passphrase is instead used to protect your secret key from
an attacker who has been able to gain a copy of your keyring
or of your exported secret key.  Symmetric key encryption is
available with gpg using a password, but the password itself
is passed through a "hash" which turns the password into a
small pseudo-random number.  Having both a copy of the
encrypted data and the associated unencrypted data for this
kind of encryption does provide an attacker with additional
information that would make it easier for him to attack the
cipher than it would be without the unencrypted data.  Rather
than revealing the password to the attacker, this would make
it easier for the attacker to discover the small pseudo-random
number used for the encryption that was based on the
It is probably safer to use public key encryption rather than
symmetric key encryption in applications where an attacker
can gain access to the unencrypted file associated with a
particular encrypted file.  But in either case there is some
loss of security when attackers have this kind of free access
to data on both sides of an encryption process.
----- Original Message -----
Sent: Tuesday, July 02, 2002 05:58
Hi everybody.
I have a few questions on how to use GPG or encryption in general:
1. Is it better to encrypt (by symmetric cipher) plain file or a
compressed one? Does it even matter?
2. Is there a safety risk if an attacker knows the target file
type (structure), e. g. if he or she knows that the encrypted
file is a JPEG picture, HTML document, gzip archive, Windows
executable, Unix binary etc.?
3. If an attacker gets a plaintext and a ciphertext can he or she
find the passphrase?
And the last one:
4. Is there a GNU replacement for PGPdisk?
Michal Wencl
 - Profesion√°lny webhosting
Gnupg-users mailing list

@_date: 2002-07-02 18:49:03
@_author: Leigh S. Jones, KR6X 
@_subject: feature request: --show-photos additions 
I wouldn't suggest using photo's present on a key
as a method of determining trust.  It's too easy for
a photograph to be copied from someone's real key
to a counterfeit.
GPG 1.0.7 has the features you mention.  For some
reason it doesn't work on my Windows NT implementations, perhaps it doesn't work on other Windows implementations, I'm not sure.  But you
can set Netscape up as your photo ID viewer and
then output the JPEG as a file from Netscape on
----- Original Message ----- Sent: Tuesday, July 02, 2002 09:02

@_date: 2002-07-03 18:00:01
@_author: Leigh S. Jones, KR6X 
@_subject: PGP 7.0.5 and GPG (Jeff Hall) 
I'm not really familiar with PGP e-Business Server 7.0.5, but PGP Desktop
PGP Desktop 7.0.4, and PGP Desktop 7.1.1 are all very capable of
with GnuPG.  You should know that presently GnuPG for Windows has no
release of the 1.0.7 product, but GnuPG 1.0.6/MingW32 (the latest official
of gpg for Windows) has good interoperability with PGP.
To improve the interoperability of gpg with PGP most of the required steps
placing certain options into the "options" file.  Primarily, the "openpgp"
provides the required information to gpg to let it know that a modern
version of
PGP is its target.  Earlier PGP versions -- 5.x and earlier -- had different
But you're using a late model of PGP.
Being familiar with the PGP graphical user interface makes it likely that
you will
find some comfort in using gpg graphical user interface front ends.  There
are a
variety of these.  I use WinPT.  You should be aware that the gpg GUI front
are a bit unpolished.  Many of them have bugs on one platform or another.
fact, gpg1.0.6 has a big bug on WindowsNT -- the protocol for talking to
keyservers is broken on WindowsNT and Windows2000.  But I'm told that it
with Windows98 and similar.  What this means is that you would use WinPT for
communication with the keyservers, or else you would use an HTTP keyserver
with a browser and cut and paste the keys from/to the browser window.  It's
little inconvenient, so I use the WinPT features for keyserver access.
WinPT's bugginess seems to center around WinNT's clipboard and active
window interface.  So with WinPT I end up having to use files for all
decryption, signing, and verification uses.  And for many functions such as
importing keys, creating and editing keys I use the command line gpg without
a GUI.
You may find, however that some of the GUI front ends for gpg work with your
operating system without any problems.  And, updated versions of gpg are
coming out all of the time, unlike PGP.
Within PGP you'd set your encryption preference to AES in lieu of IDEA for
maximum interoperability.  This is under   on the tray menu for PGP 7.0.3/7.0.4 and 7.1.1.  Also,
I suggest allowing all algorithms.
There may be some details that I'm leaving out here, but this should
reassure you
that PGP and gpg work together.
OK -- the options file for gpg1.0.6/MingW32:
----- Original Message -----
Sent: Wednesday, July 03, 2002 08:06

@_date: 2002-07-08 18:02:01
@_author: Leigh S. Jones, KR6X 
@_subject: www.gnupg.org unaccessible ? 
It does not appear to be online from my perspective.
----- Original Message ----- Sent: Monday, July 08, 2002 08:51
Hi there,
is  down or what happened ?
hopefully nobody will ever be able to hack and compromise
our beloved site...
<\paranoia mode>
[malte_gell ~ > traceroute traceroute to trithemius.gnupg.org (217.69.76.44), 30 hops max, 40 byte  1  217.5.98.152 (217.5.98.152)  59 ms  60 ms  60 ms
 2  217.237.156.182 (217.237.156.182)  59 ms  58 ms  58 ms
 3  F-gw12.F.net.DTAG.DE (62.154.17.194)  60 ms  59 ms  61 ms
 4  pos2-0-bb2-FFM1.de.cw.net (62.208.234.133)  67 ms  67 ms  68 ms
 5  ge9-0-bb1-FFM1.de.cw.net (62.208.234.33)  69 ms  68 ms  68 ms
 6  so-0-0-0-crj1-DUS2.de.cw.net (62.208.240.78)  73 ms  72 ms  72 ms
 7  openit-gw-DUS2.de.cw.net (194.221.44.242)  75 ms  72 ms  72 ms
 8  fe5.cr1.dus.openit.net (217.69.68.14)  74 ms  73 ms  74 ms
 9  * * *
10  * * *
11  * * *
Gnupg-users mailing list

@_date: 2002-07-08 19:19:02
@_author: Leigh S. Jones, KR6X 
@_subject: www.gnupg.org unaccessible ? (Adam Pavelec) 
If you are referring to web sites that allow HTTP (preferably HTTPS) access
to e-mail servers,
I was quite pleasantly pleased with one of the packages that is available
for use on Linux.  It
also provided POP3 and IMAP4 access to the same account.  I've also had a
working Microsoft
Exchange implementation with roughly the same features, but it was
incredibly expensive and
only offerred a small speed improvement over the free Linux implementation.
These software
packages have the advantage that your Netscape messenger can use the IMAP4
features when
you have a high speed connection from your home or office, or use the POP3
access when you
dial up your lap top from the hotel room over a modem, then when you are in
an internet cafe in
Paris and don't have your laptop along, their browser can access the web
mail version.  All 3
work seamlessly on the same e-mail accounts.
But I would never suggest that anyone should accept the limitations that are
inheirent with
most web-based e-mail services like Hotmail, etc.
On the other hand, if by HTML e-mail you are referring to HTML formatting of
e-mail contents,
I have come to equate this with spamming -- wanton self-absorbed abuse of
the freedom of
the internet.  The vast majority of the HTML formatted e-mail I receive, and
come to think of
it the vast majority of the e-mail bandwidth that I receive, is indeed
unsolicited and unwanted
commercial advertising.
Sent: Monday, July 08, 2002 11:51 AM

@_date: 2002-07-10 06:22:02
@_author: Leigh S. Jones 
@_subject: PGP 7.0.3 / GPG 1.0.6 compatibility. (Liam Farr) 
I can probably help you, but I cannot find your public key on the
keyservers to see what key preferences are listed.  I checked
for Liam Farr and for nz_liam
I've been able to overcome all of the interoperability problems
with PGP and gpg (various implementations) including moving
keys back and forth. In general the most frequently experienced
interoperability problems are:
1) Public key has IDEA listed as preferred encryption method
but GnuPG does not have IDEA capability (for keys created on
PGP and exported to GnuPG) resulting in encryption to IDEA
2) Trouble with decryption of password encrypted secret key.
With regard to  your top choices would include editing the
key preferences using GnuPG v1.0.7 or later.  This allows you
to put other encryption algorithms ahead of IDEA on the list.
The choice of AES is a very good one.
But since you are using GnuPG 1.0.6, another option would
be to add the IDEA algorithm capability.  This would require
that you add a file "idea.dll" on the directory "c:\lib\gnupg"
and add one line in your options file that loads the dll.
With regard to  let me make sure I understand:
Can I assume that your key pair was created on PGP and
exported, then imported to the gpg keyring?  Moving keys
the other way has a whole different set of obstacles.
It's possible that your problem is that you didn't successfully
import the secret key to your GnuPG keyring file.  One big
requirement that is sometimes overlooked by new users of
GnuPG is that a key pair (public and secret key) that is
imported using a command such as:
gpg --import [filename]
results in only the public key being imported.  To import
both halves of the key pair, you need to do this:
gpg --allow-secret-key-import --import [filename]
I don't suggest leaving important tasks like the creation
of keys or import/export of secret keys to GUI tools
with GnuPG.  Do these tasks using the command line.
Likewise, I haven't seen a GUI tool that implements
editing of keys adequately, especially since there have
been updates to the editing capabilities of the command
line tools in the past few months that the GUI tools haven't
caught up with yet.
Of course, it's unlikely that WinXP will allow 1.0.6 to
talk with the keyservers.  WinNT doesn't allow this.
Win95/98/ME does allow keyservers to be contacted by
GnuPG/MingW32 1.0.6, but the NT derivatives don't.
To talk with the keyservers you'll need to export the
public key back to PGP or you'll need to add WinPT
or follow some similar tactic.
One suggestion: if you are exporting a key created on one
of the softwares to the other, and things don't work right
for you, try changing the password of the key to a blank
password -- zero bytes -- before the export.  Change it
back on both softwares after importing, and be certain
not to allow the exported secret key file (with the blank
password) to survive.  Overwrite it.  Wipe it out.
So if you'd like to put the public key in question on a
keyserver somewhere, or even send it to the list or to me,
I'll look at it and see if I can come up with a suggestion.
There are a lot of other details that might need mentioning,
but I'd have to look up my notes on this before going very
----- Original Message -----
Sent: Tuesday, July 09, 2002 7:58 PM

@_date: 2002-07-24 07:22:02
@_author: Leigh S. Jones 
@_subject: GPG without any local files? (Gerben Wierda) 
Have you considered a "RAM disk" approach to this?  A buffer in
RAM memory is mounted and addressed in a fashion similar to a
drive partition.  A directory in the "RAM disk" becomes the home
directory.  Command-line options handle the details.
----- Original Message -----
Sent: Tuesday, July 23, 2002 1:19 PM

@_date: 2002-06-02 04:14:01
@_author: Leigh S. Jones 
@_subject: How to fetch all signing keys? 
I have been down this road.
You fetch one layer and the next layer needs
to be fetched.  Before long you'd have been better
off downloading the complete keyserver contents
to your keyring right from the beginning.  Which, of course, is really quite practical.  But, it can be relatively painful when you discover how long
keyring operations take after the keyring has grown.
And, you don't have to download the complete
keyserver contents to run into this problem.  I
placed the most frequently used signing keys that are referenced in signatures that appear on this
forum into my keyring.  Now WinPT adds 4-6
minutes to my computer reboot time while it
caches keyrings at startup.
----- Original Message ----- Sent: Saturday, June 01, 2002 6:42 PM

@_date: 2002-06-03 18:05:01
@_author: Leigh S. Jones, KR6X 
@_subject: 1.07 RSA support questions (Larry Ellis) 
I think perhaps that some of your primary questions have
gone unanswered here.  Surprising, because you've
been responded to by some people very important to
the gpg development effort.  Perhaps my understanding
of your question is wrong.  Was it:
1) How to select IDEA for certain encryption events
2) How to automatically use IDEA whenever an RSA
Legacy public key is used to encrypt
3) How to always use IDEA
----- Original Message -----
Sent: Monday, June 03, 2002 08:32

@_date: 2002-06-03 19:23:02
@_author: Leigh S. Jones, KR6X 
@_subject: 1.07 RSA support questions (Larry Ellis) 
I'd suspect that your answer is that IDEA is assumed to
be unavailable by the developers of GPG.  I'd guess
that none of the GnuPG team have any objections to the
security of the algorithm and all of them would favor full
interoperability with PGP.  But the legal issues override
these considerations.  Perhaps for legal reasons the
GnuPG developers must consider the plug-in algorithm
support to be a rogue element.
At the same time I was under the impression that 3DES
has been supported in most PGP implementations that use
RSA legacy keys.  Perhaps this is a non-issue, as 3DES
just might do a very good job for you.  It's certainly strong
enough to stop any corporate or organized crime attacks
for the next decade.  But, I'll admit that years ago when I
was a PGP 2 user I never paid much attention to the
algorithms that it used.  In those days the US federal
banking system was still using crypto devices that used
56 bit single DES and running modem connections through
the public telephone lines.  I was quite perplexed to learn
recently that the US system of ATM's still include many
using dial telephone modem connections...
----- Original Message -----
Sent: Monday, June 03, 2002 09:15

@_date: 2002-06-03 19:45:01
@_author: Leigh S. Jones, KR6X 
@_subject: To upgrade or not? 
Many of the development team are likely to disagree
with me.  I personally feel that the most compelling reason
to upgrade to 1.0.7 is the improved security of the
secret keyring file.  Secret keyrings that might be edited
by an attacker and replaced are most at risk -- in other
words the keyrings found on Windows computers are at
greatest risk, while UNIX/Linux computers are slightly
safer (but nonetheless are at risk).  The risk is the possible addition of an additional decryption key to your secret key without your knowledge, and the solution is a higher security checksum algorithm that is used by default on 1.0.7.  The new checksum algorithm unfortunately makes the process of exporting secret keys to another keyring (to PGP or to earlier implementations of gpg) slightly more complicated, but it's worth the effort.
The new version also implements a method for editing
your personal key to set algorithm preferences.  In earlier
releases this had to be done by editing the gpg source code and recompiling.
----- Original Message ----- Sent: Monday, June 03, 2002 10:29

@_date: 2002-06-03 21:03:02
@_author: Leigh S. Jones, KR6X 
@_subject: Question on IDEA 
I've always found it interesting that IDEA was invented in Europe but
the patent issues are primarily found in the US.  In this case the patent
owner wanted any US company that profits from the sale of products
that use the IDEA patent to pay royalties, where there is little concern
over use that is not for profit.  Nonetheless, the Gnu Public License
and patent infringement are mutually exclusive.
----- Original Message -----
Sent: Monday, June 03, 2002 19:43
Maybe this is off-topic, in which case I apologize. My question is the
Isn't it so that algorithms aren't patentable in EU? Or at least the patents
can't be enforced? If so, how come IDEA is patented? If not, could anyone
explain what the patent situation is or point me somewhere to find out?
Thank ou very much,

@_date: 2002-06-04 01:33:02
@_author: Leigh S. Jones, KR6X 
@_subject: Downgrade problem. (Jean-David Beyer) 
You will need 1.0.7 to fix the problem.  If you chose to
retain gpg 1.0.6, you will need to use someone's copy
of 1.0.7 to fix your keyring before it can be used by
To perform the fix, rename the existing keyring files
and options files for safe keeping.  Next, transport the
keyring files to be adjusted together with your options
file onto the ~/.gnupg directory being used.  Next,
temporarily disconnect the computer being used from
the network, for security purposes.  Edit your options
file, adding the line "simple-sk-checksum" at or near
the end of the file.  Now use the command:
gpg --edit-key to start the key edit function of gpg.  At the Command>
prompt enter "passwd".  Set your password to a zero
length blank password. At the Command>
prompt enter "save".  Do this once for each secret key
on your keyring.  Now copy your keyring file to a floppy
drive and keep it safe.  Blast away the copy of your
options file (edited) and the (now insecure) keyrings.
on the workstation, and rename the "safe keeping" files
to return the workstation to its original condition.
Reconnect this machine to the network.  Take the
keyring files back to your own version 1.0.6 machine.
Disconnect it from the network before proceeding.
Don't overwrite your existing (unusable) keyring files --
rename them for now -- just to make sure you don't
overwrite something you will need later.  On gpg1.0.6
you won't need the simple-sk-checksum option added.
Edit each of your secret keys to reintroduce your
password in place of the blank password.  Test
by signing a file to make sure the password is right
on each of your secret keys.  When everything is shown
to be working OK, reformat/wipe the floppy drive to
blast away the insecure keyring files.  Now you can
reconnect your computer to the network.
Sounds like it would be easier to build 1.0.7 again,
doesn't it?
----- Original Message -----
Sent: Monday, June 03, 2002 15:58

@_date: 2002-06-04 05:38:01
@_author: Leigh S. Jones 
@_subject: Downgrade problem. (Jean-David Beyer) 
Thanks for the supportive words, but where David Shaw
is concerned I'll have to point out that I'm a neophyte with
gpg next to him, and need to absorb from him anything I
can learn.
----- Original Message -----
Sent: Monday, June 03, 2002 7:32 PM
be a

@_date: 2002-06-04 05:57:02
@_author: Leigh S. Jones 
@_subject: Downgrade problem. (Jean-David Beyer, David Shaw  ) 
And thanks for the correction on the secret key checksum
algorithm. I was repeating word of mouth and I apparently
had the information wrong.
----- Original Message -----
Sent: Monday, June 03, 2002 8:47 PM

@_date: 2002-06-04 19:47:01
@_author: Leigh S. Jones, KR6X 
@_subject: Cannot encrypt/decrypt zip-Files correctly (Andreas) 
Don't be deceived by incorrect answers.
ASCII-armored outputs from encrypted binary files are perfectly OK.  They
the full 8 bit binary content of the input file converted to the text output
format.  The
method for doing this was long established before PGP/gpg were created.  No
data is lost or corrupted by stripping the high order bit from ASCII-armored
outputs; tarfiles may be damaged by transport in ASCII mode with ftp, but
armored gpg outputs are ftp safe, even if the original data is binary.  Your
lies elsewhere.
----- Original Message -----
Sent: Tuesday, June 04, 2002 09:18

@_date: 2002-06-05 03:58:02
@_author: Leigh S. Jones 
@_subject: Cannot encrypt/decrypt zip-Files correctly (Andreas) 
I haven't tackled this problem yet, but I can venture a guess.
GnuPG will allow a command line that contains the "--homedir
[directory]" option.
It also allows you to use a different option file from the usual one
with the command
line option "--options [filename]".  You can use a directory with
read/write privileges
for the user that your web server logs in as.
----- Original Message -----
Sent: Tuesday, June 04, 2002 6:28 PM
webserver and
run, it's
has no
what to

@_date: 2002-06-05 14:09:03
@_author: Leigh S. Jones 
@_subject: problems with trusting in key --recipient or --default-recipient 
GnuPG will give you those kinds of warnings because it wants
you to be aware that the mechanisms built into it are not sure
that the key actually belongs to the intended recipient.  Webs
of trust are important to the assurance that your encrypted
messages will not be decrypted by someone that you did
not intend to see the message.  Without this safeguard it
would be possible for someone to simply add a key with the
recipients name on it to your keyring and you might never
know it happened.
When you are certain that the public key belongs to a given
individual, as is the case when he hand delivers the key
to you, then you should sign the key after adding it to your
keyring.  Perhaps it will be helpful if you return the signed
key to this person.
Otherwise, it is possible to "edit" the key to add trust to
the key.  Unless it is your own key don't make it ultimately
trusted, choose a lower level of trust.  If you trust the key
marginally then gpg will not give you these warnings.
----- Original Message -----
Sent: Wednesday, June 05, 2002 3:10 AM
a reason
take --recipient:
did so,
correct to

@_date: 2002-06-06 21:00:02
@_author: Leigh S. Jones, KR6X 
@_subject: =?iso-8859-1?Q?Re:_Passphrase_and_swapfile_=28David_Pic=F3n_=C1lvarez=29?= 
Sent: Thursday, June 06, 2002 06:54
Imagine yourself acting from the attackers point of view.  The passphrase
might, and might not appear within the last overwrite of the swap file.  The
directory shows which sectors the swap file occupies.  A complete
replication of the swap file is achieved in Windows.  The encrypted
messages and the secret key file are in hand.  You, as the attacker, do
not know where in the swap file the password might exist.  You decide to
limit your search to strings in which bit 7 is not set.  Even though the
swap file contains both program and string data, the programs contain
large quantities of embedded strings.  It's difficult to map which bytes
may be the beginning of a password, although one might imagine that
the final byte will be a NULL.  Approximately 50% of the swap file contains
possible password strings, and the swap file is appropriately sized for a
512Mb RAM, so it may be a Gb long.   How many different permutations
of the swap file contents are possible choices for testing.
We are talking 1Gb of swap file here.  If you find a 20 character long
sequence enclosed by NULL characters, will you only try to use all 20
characters?  Or must you try many permutations?  Perhaps the last
11 characters?  Perhaps the last 9? Remember, an extensive dictionary
for an English dictionary search type attack is about perhaps 140K bytes,
and the permutations for that are already worked out in advance.  We're
talking about a swap file that presents a lot of permutations here.  If you
have a dictionary search tool for breaking the password, then will you
choose to try the dictionary search tool before you try cracking the
password out of the swap file?  The dictionary search might not produce
a match, but you have no way of knowing for sure that the swap file
will, either.  Suddenly the dictionary search starts to look like a pretty
good thing to try first.  Next, since you've already succeeded at
burglarizing this computer, will you begin to consider alternatives to
cracking the password from the swap file, such as trapping keystrokes
over the course of weeks with a tiny program you've added?  Let's face
it, a skillful attacker has many alternatives, and would prefer to use one
that yields consistent results.  Is the most recent overwrite of the swap
file really the greater risk to your security?  Isn't a brute force password
crack likely to be in the arsenal of the attacker?  Wouldn't the attacker
be equipped for that, too?

@_date: 2002-06-06 22:11:02
@_author: Leigh S. Jones, KR6X 
@_subject: =?iso-8859-1?Q?Re:_Passphrase_and_swapfile_=28David_Pic=F3n_=C1lvarez=29?= 
Actually, I think that most dangers come from attacks that can be
performed mindlessly.  If it takes an engineer thinking to perform the
attack then another attack will be used.  Unless, of course, the
engineer publishes thought processes in the form of a program
that can mindlessly perform the attack.  This has been done for
a number of attacks, and the results can be found on the Internet.
It's easier to "bug" a computer than might be expected.  Programs
for trapping keystrokes and sending them to a server are easier than
any of the swap file approaches.  And they can be written with
"removal" features for a clean get-away, and using innocent
intermediates to relay the data to make the task of tracing the
outbound data utterly impossible.  Much easier than seizing the
computer or swapfile for analysis.
----- Original Message -----
Sent: Thursday, June 06, 2002 12:25
I don't think things would be nearly as difficult for the attacker as you
imagine. If you know something about what the binary program code of the
encryption application looks like, you'll be able to find that code easily.
Typically, memory would be allocated in a similar fashion,
virutal-address-space wise, on every run of the encryption program. The
passphrase (or a pointer to it) will probably appear very near to, if not
exactly on, the same set of swap pages as the encryption program code. Even
if it wasn't nearyby, all you would need to do is discover something about
the virtual-to-physical address space mapping at run-time figure it out.
It wouldn't be easy, of course, and you'd need a lot of expertise in the
OS's memory-management, but it would be a heck of a lot easier than a
brute-force search.
Gnupg-users mailing list

@_date: 2002-06-13 06:44:01
@_author: Leigh S. Jones 
@_subject: compiling problems gpg 1.0.7 
I've got a couple of comments; it doesn't look to me as if the
responses on the list have gotten to the heart of the matter.
Bear with me, I could be wrong in my interpretation of the
First, most of the problems I see in the output from the
install script seem to be related to the absence of certain
entropy devices -- a.k.a. random number generators.
The tiger issue is a minor one, just a little used hash algo.
I think I'd interpret this as an install failure caused by the
failure of the tiger install portion of the script, though.
You'll probably find a completed, compiled gpg program
sitting in the "g10" directory.  If gpg manages to
connect to some usable random number generator then
you could probably begin to use it simply by moving the
g10/gpg file to the right directory.  If it can't find any
random number generator then you'll probably want
to fix the build.
I'd suggest going back first and attempting the ./configure
with a few command line options to correct the problem,
except for one thing.
There are pre-compiled implementations of gpg 1.0.7 out
there on the internet somewhere -- all set for Solaris 8,
for Sparc, Ultra Sparc, ix86, etc.  Complete with
real good entropy.  It might be more satisfying to get them.
I found them using google.com.  I bet you could, too.
And, some of the guys who compiled/built these
implementations described on their web sites what the
options for "./configure" were that they used.
Maybe some of those guys are on this list...
----- Original Message -----
Sent: Tuesday, June 11, 2002 7:11 PM
and it

@_date: 2002-06-14 00:29:02
@_author: Leigh S. Jones, KR6X 
@_subject: compiling problems gpg 1.0.7 (mike salehi) 
I have not heard back from you on the list, so I'll assume for the moment
that you are still working to compile your Solaris 8 version of gpg 1.0.7.
To that end, I've sent you a link to a resource addressing the random
number generator problem.
Perhaps the addition of this random number generation capability to
your Solaris 8 implementation, coupled with a ./configure option that
eliminates tiger from your build will allow you to get a complete
----- Original Message -----
Sent: Tuesday, June 11, 2002 19:11

@_date: 2002-06-14 15:39:01
@_author: Leigh S. Jones 
@_subject: GPG and PGP compatibility 
In order to get full compatibility between gpg and PGP it is
necessary to add the IDEA plug-in.  Keys created by PGP
can be exported to gpg and keys created using gpg can
be exported to PGP.  The updated gpg 1.0.7 is not yet
available in the "official" Windows (MingW32) version,
although there are unofficial releases of this software that
are available for windows.
Your PGP public keys contain a request for encryption
using the IDEA algorithm.  It is possible to change this,
if desired, but the effect of this characteristic of PGP
keys is that someone who uses your public key to send
you encrypted messages is likely to encrypt using IDEA.
As a result, your gpg installation should be prepared to
decrypt using IDEA.  Due to patent issues within the
USA, the IDEA algorithm plug in is not available on
the GnuPG.org web site, but it is widely available
You will probably want to add the pgp6 option to your
options file (assuming gpg 1.0.7) to improve the
compatibility.  If you want to edit keys preferences
using gpg and export your secret keys back to PGP
again, then you will probably want to include the option
simple-sk-checksum in your options file, or use the
command-line option --simple-sk-checksum when
you edit your keys immediately prior to exporting them
to PGP.  Note that the exported secret key is not as
secure wen using this option, but without it your secret
key is incompatible with PGP after editing with gpg
WinPT and other graphical user interfaces are quite
helpful with gpg.  Some of these products are not
fully polished.  The MingW32 implementations of
gpg don't access keyservers properly when used
with WinNT, Win2000, and WinXP, but should
work OK with Win98.  On WinNT, Win2000,
and WinXP the WinPT GUI fixes the keyserver
----- Original Message -----
Sent: Thursday, June 13, 2002 4:48 AM
possible to

@_date: 2002-06-14 20:09:02
@_author: Leigh S. Jones, KR6X 
@_subject: How do I supply a password and decrypt on NT 
Sent: Friday, June 14, 2002 10:38
This is a popular question on this reflector!
The following is old code; I no longer use this exact method, having
to using pipes.  It was written for the Borland C 4.51 compiler, and works.
the scheme below, the calling process (which could be a batch file) writes
password to a file that has been opened with appropriate security privileges
to protect the contents of the file from prying eyes.  The calling process
batch file) then calls this tiny "wrapper" executable which calls gpg.  Most
of the
code below is involved in deleting the password file as soon as possible and
as surely as possible.
But the code was tailored to clearsign text files rather than to decrypt
so you'll have to adapt the code to make it decrypt.
The most important thing to note here is that the --passphrase-fd option
used with the MingW32 implementation of gpg 1.0.6 (that was the current
release when this code was written) requires that the file descriptor be
converted to an OSF handle before being placed on the command line.
The example below uses files for all of the file descriptors, and as I noted
above, I now use pipes.  That requires the use of the MSVC6 compiler or
similar rather than the Borland compiler.  I was not able to make the MS
C library dll create pipes for me from within the Borland compiler, so I
now use a different compiler to get a more secure version of the program.
Of course, the Borland compiler can open executables as pipes, but cannot
handle both the input and output end of the executable as pipes and cannot
give me an open pipe with both ends free.
Note the use of low level file IO.  Some of that is not necessary, but it
      int main ( int argc, char *argv[ ] )
   {
   int passphrase;
   int status;
   int error;
   int time_error;
   FILE *ptr;
   char buf[ 1024 ];
* argv strings represent:
* user_id
* passphrase
* target_file
* passphrase_file
* status_file
   time_error = 0;
   if ( ( argc != 6 ) && ( argc != 7 ) )
      {
      if ( ( strncmp ( "NULL", argv[ 2 ], 4 ) ) && ( argc > 4 ) )
         {
         passphrase = open ( argv[ 4 ],
                             O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                             S_IREAD | S_IWRITE );
         write ( passphrase, "12345678901234567890", 20 );
         close ( passphrase );
         unlink ( argv[ 4 ] );
         } /* end if ( strncmp ( "NULL", argv[ 2 ], 4 ) ) */
      return ( -1 );
      } /* end if ( argc != 7 ) */
   if ( ( argc == 7 ) &&
        strncmp ( argv[ 6 ],
        "NO_TIME_SET",
        strlen ( "NO_TIME_SET" ) ) )
      {
      if ( ( strncmp ( "NULL", argv[ 2 ], 4 ) ) && ( argc > 4 ) )
         {
         passphrase = open ( argv[ 4 ],
                             O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                             S_IREAD | S_IWRITE );
         write ( passphrase, "12345678901234567890", 20 );
         close ( passphrase );
         unlink ( argv[ 4 ] );
         } /* end if ( strncmp ( "NULL", argv[ 2 ], 4 ) ) */
      return ( -1 );
      } /* end if ( argc != 7 ) */
   if ( argc == 6 )
      {
      sprintf ( buf, "NET TIME /SET /Y" );
      ptr = _popen ( buf, "rt" );
      while ( !feof ( ptr ) ) fgets ( buf, sizeof ( buf ), ptr );
      time_error = _pclose ( ptr );
      } /* end if ( ( argc == 7 ) && ( ... ) ) */
* passing "NULL" as the password results in reading of the password file
* rather than creation of a new password file
   if ( strncmp ( "NULL", argv[ 2 ], 4 ) )
      {
* set up to pass the password in a temporary file
* first, open the temporary file for writing, checking for failure
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      if ( passphrase <= 0 )
         {
         return ( -2 );
         } /* end if ( passphrase <= 0 ) */
* write the password from the command line to the temporary file
      if ( write ( passphrase, argv[ 2 ], strlen ( argv[ 2 ] ) ) <= 0 )
         {
         close ( passphrase );
         unlink ( argv[ 4 ] );
         return ( -3 );
         } /* end if ( write ( passphrase, ... ) <= 0 ) */
* close the temporary file and reopen for reading
      if ( close ( passphrase ) != 0 )
         {
         passphrase = open ( argv[ 4 ],
                             O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                             S_IREAD | S_IWRITE );
         write ( passphrase, "12345678901234567890", 20 );
         close ( passphrase );
         unlink ( argv[ 4 ] );
         return ( -4 );
         } /* end if ( close ( passphrase ) <= 0 ) */
      } /* end if ( strncmp ( "NULL", argv[ 2 ], 4 ) */
   passphrase = open ( argv[ 4 ], O_RDONLY | O_TEXT );
   if ( passphrase <= 0 )
      {
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      return ( -5 );
      } /* end if ( passphrase <= 0 ) */
* open the temporary file for writing
   status = open ( argv[ 5 ],
                   O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                   S_IREAD | S_IWRITE );
   if ( status <= 0 )
      {
      close ( passphrase );
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      return ( -6 );
      } /* end if ( passphrase <= 0 ) */
* form and execute the command line that runs gpg
   sprintf ( buf,
             "gpg --passphrase %d --status-fd %d -u %s --batch --clearsign
             _get_osfhandle ( ( int ) passphrase ),
             _get_osfhandle ( ( int ) status ),
             argv[ 1 ],
             argv[ 3 ] );
   ptr = _popen ( buf, "rt" );
   if ( !ptr )
      {
      close ( passphrase );
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      close ( status );
      unlink ( argv[ 5 ] );
      return ( -7 );
      } /* end if ( !ptr ) */
   while ( !feof ( ptr ) ) fgets ( buf, sizeof ( buf ), ptr );
* close the pipe from gpg and check for nonzero exit status
   if ( ( error = _pclose ( ptr ) ) != 0 )
      {
      close ( passphrase );
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      close ( status );
      status = open ( argv[ 5 ], O_RDONLY | O_TEXT );
      read ( status, buf, sizeof ( buf ) - 1 );
* the first line of the status file should contain "USERID_HINT"
      if ( !strstr ( buf, "[GNUPG:] USERID_HINT" ) )
         {
         if ( error == 2 )
            {
            error = -111;
            }
         close ( status );
         unlink ( argv[ 5 ] );
         return ( error - 100 );
         } /* end if ( strncmp ( buf, "[GNUPG:] USERID_HINT", ... ) */
* the second line of the status file should contain "NEED_PASSPHRASE"
      if ( !strstr ( buf, "[GNUPG:] NEED_PASSPHRASE" ) )
         {
         if ( error == 2 )
            {
            error = -112;
            }
         close ( status );
         unlink ( argv[ 5 ] );
         return ( error - 100 );
         } /* end if ( strncmp ( buf, "[GNUPG:] NEED_PASSPHRASE", ... ) */
* the third line of the status file should contain "GOOD_PASSPHRASE"
      if ( !strstr ( buf, "[GNUPG:] GOOD_PASSPHRASE" ) )
         {
         if ( error == 2 )
            {
            error = -113;
            }
         close ( status );
         unlink ( argv[ 5 ] );
         return ( error - 100 );
         } /* end if ( strncmp ( buf, "[GNUPG:] GOOD_PASSPHRASE", ... ) */
* the fourth line of the status file should contain "SIG_CREATED"
      if ( !strstr ( buf, "[GNUPG:] SIG_CREATED" ) )
         {
         if ( error == 2 )
            {
            error = -114;
            }
         close ( status );
         unlink ( argv[ 5 ] );
         return ( error - 100 );
         } /* end if ( strncmp ( buf, "[GNUPG:] SIG_CREATED", ... ) */
      close ( status );
      unlink ( argv[ 5 ] );
      return ( error - 100 );
      } /* end if ( !ptr ) */
* close the temporary (password) file and delete it
   if ( close ( passphrase ) != 0 )
      {
      passphrase = open ( argv[ 4 ],
                          O_CREAT | O_WRONLY | O_TRUNC | O_TEXT,
                          S_IREAD | S_IWRITE );
      write ( passphrase, "12345678901234567890", 20 );
      close ( passphrase );
      unlink ( argv[ 4 ] );
      close ( status );
      unlink ( argv[ 5 ] );
      return ( -8 );
      } /* end if ( close ( passphrase ) <= 0 ) */
   if ( unlink ( argv[ 4 ] ) )
      {
      close ( status );
      unlink ( argv[ 5 ] );
      return ( -9 );
      } /* end if ( close ( passphrase ) <= 0 ) */
* read back the status file written to by gpg and check for signs of failure
   close ( status );
   status = open ( argv[ 5 ], O_RDONLY | O_TEXT );
   read ( status, buf, sizeof ( buf ) - 1 );
   close ( status );
   unlink ( argv[ 5 ] );
* the first line of the status file should contain "USERID_HINT"
   if ( !strstr ( buf, "[GNUPG:] USERID_HINT" ) )
      {
      return ( -10 );
      } /* end if ( strncmp ( buf, "[GNUPG:] USERID_HINT", ... ) */
* the second line of the status file should contain "NEED_PASSPHRASE"
   if ( !strstr ( buf, "[GNUPG:] NEED_PASSPHRASE" ) )
      {
      return ( -11 );
      } /* end if ( strncmp ( buf, "[GNUPG:] NEED_PASSPHRASE", ... ) */
* the third line of the status file should contain "GOOD_PASSPHRASE"
   if ( !strstr ( buf, "[GNUPG:] GOOD_PASSPHRASE" ) )
      {
      return ( -12 );
      } /* end if ( strncmp ( buf, "[GNUPG:] GOOD_PASSPHRASE", ... ) */
* the fourth line of the status file should contain "SIG_CREATED"
   if ( !strstr ( buf, "[GNUPG:] SIG_CREATED" ) )
      {
      return ( -13 );
      } /* end if ( strncmp ( buf, "[GNUPG:] SIG_CREATED", ... ) */
   if ( time_error )
      {
      return ( -1000 - time_error );
      } /* end if ( time_error ) */
* exit with success status
   return ( 0 );
   } /* end main ( ) */

@_date: 2002-06-17 16:04:01
@_author: Leigh S. Jones 
@_subject: How do I supply a password and decrypt on NT 
I cannot hepl you by providing VB code, but the methods you
must use will be the same, given that you wish to do this using
GnuPG/MingW32. It is, of course, possible to call
osf_filehandle ( ) from within basic.
----- Original Message -----
Sent: Monday, June 17, 2002 5:45 AM
do any
available in

@_date: 2002-06-19 07:17:02
@_author: Leigh S. Jones 
@_subject: Recovery of PCSECURE files and bogus GnuPG algorithms 
"Your friend" encrypted a message to Phil Zimmerman, who has
been known to use PGP from time to time.  It makes little sense
for him to encrypt messages to PRZ using PRZ's keys but also
using ciphers that PRZ cannot be expected to decrypt.  This is
not about PRZ being on his "high horse".  "Your friend" was
playing stupid pranks sending messages using twofish and tiger.
Judging by the content of PRZ's responses your friend was
badgering him for help that he was not in a position to give.  If
"your friend" wants to correspond with PRZ then he should
consider taking the lines:
cipher-algo twofish
digest-algo tiger192
out of his options file completely and replacing them with:
Having been given the advice once, I'd also suggest your
friend heed PRZ's recommendations regarding PCSECURE,
and the unrecovered data.  If the data is valuable, hire a
----- Original Message -----
Sent: Tuesday, June 18, 2002 9:14 PM

@_date: 2002-06-20 15:27:02
@_author: Leigh S. Jones 
@_subject: Encryption and signing of a data file 
This can be implemented, but the encryption and signing by the
voter will be two distinct steps from the viewpoint of gpg.
of a
There's nothing preventing you from implementing this.  In fact, if
are capable of programming the mechanisms for automating the
actions of the trustees, then a fully automated voting system complete
with return notification of success or failure of the vote process is
quite possible.
I should think that the major problem with your scheme is that there
might be some resistance on the part of the voters to fully implement
the scheme.  Part of this would be due to the complexities of voting,
encrypting, signing, and sending, and part of this would be due to
the complexities of installing gpg itself.  How many different
platforms are your voters using?
----- Original Message -----
Sent: Thursday, June 20, 2002 1:20 AM
trustee 1
of a

@_date: 2002-06-22 02:00:01
@_author: Leigh S. Jones, KR6X 
@_subject: Suppressing passphrase prompt (Steven Handleman) 
I think I may be the guy who has the C solution for NT
previously mentioned here... you may already be onto
Let me know if you need any more assistance.
----- Original Message -----
Sent: Friday, June 21, 2002 08:18
(--sign --

@_date: 2002-06-23 08:19:01
@_author: Leigh S. Jones 
@_subject: 1 more week till gnupg 1.07 2 month anniversary 
I'd like to ring in my agreement with Gordon.
I'm excited and completely pleased with the progress being
made with gpg.  I'm pleased with the third party implementations.
Some of them have nearly obtained official release status.  I'm
more interested in seeing more progress with the WinPT and
similar front ends than with seeing an official MingW32 release.
And I'd like to see the gpg team freed to focus attention on the
important issues.  Applying pressure on the gpg team to focus
on 1.0.7/MingW32 is counterproductive considering the
proliferation of fine third party releases.
----- Original Message -----
Sent: Saturday, June 22, 2002 10:41 PM
showcasing the

@_date: 2002-06-26 22:33:01
@_author: Leigh S. Jones, KR6X 
@_subject: bad passphrase error passing it into GPG on Windows 98 using stdin 
This is the wrong way to use --passphrase-fd.  Even
if you're using Linux, the option:
--passphrase-fd 0
tells gpg that the actual passphrase will be passed into
the gpg program through a pipe to port zero; here
"passwordfile.txt" would have to be the actual passphrase
rather than the name of the file containing the passphrase.
And that's not necessarily the only problem.  Under
Windows with the Ming/W32 versions the file descriptor
"0" might not work as expected.  I'm not sure of this,
mind you, but it might be necessary to convert the
file descriptor 0 to an OSF file handle before passing it.
Perhaps that would be zero too.  Anyone know for sure?
----- Original Message -----
Sent: Wednesday, June 26, 2002 12:30

@_date: 2002-06-26 22:43:02
@_author: Leigh S. Jones, KR6X 
@_subject: bad passphrase error passing it into GPG on Windows 98 using stdin 
All the concepts below are consistent with the way it works
on a Linux box.  However, the MingW32 implementation (1.0.6)
requires that the file descriptors being passed to it with
--passphrase-fd, --command-fd, --status-fd, etc., be converted
from the file descriptor numerical value (usually very close to
4) to an "osf_filehandle" before being placed on the command
line as a decimal number string.  Maybe this is something that
Werner could change in future MingW32 implementations so
that there wouldn't be so much confusion among the Windows
Being a C programmer rather than a VB programmer I don't
know for sure what the easiest way for you to get the file
descriptor converted would be.  I do know that there is a
Visual C runtime library in every copy of Windows, so if there's
no VB function to do the job, then the option of calling the
function osf_filehandle in the .dll from VB is viable.
----- Original Message -----
Sent: Wednesday, June 26, 2002 11:52

@_date: 2002-06-26 23:21:02
@_author: Leigh S. Jones, KR6X 
@_subject: bad passphrase error passing it into GPG on Windows 98 using stdin 
Right.  Well, this kind of question comes up so often that
it really needs to be approached by Werner.  You should
be able to pass a handle to a pipe to the Ming/W32 gpg
the same way that you do to gpg on Linux, without doing
a conversion with osf_filehandle().
But I may just put a program up here on the list that will
help with that.  Perhaps a tiny program in C that takes
a command line argument of a file descriptor and returns
an "osf_filehandle ( )" converted to a string at it's stdout.
Then a script could redirect the output to a variable.
It would be worth the effort just to be able to stop
answering these same questions over and over again.
----- Original Message -----
Sent: Wednesday, June 26, 2002 14:03

@_date: 2002-06-26 23:54:02
@_author: Leigh S. Jones, KR6X 
@_subject: bad passphrase error passing it into GPG on Windows 98 using stdin 
Ahh, yes; I confused the b < a with a | b there.  Oops.
----- Original Message -----
Sent: Wednesday, June 26, 2002 14:27

@_date: 2002-06-26 23:56:02
@_author: Leigh S. Jones, KR6X 
@_subject: bad passphrase error passing it into GPG on Windows 98 using stdin 
er, I meant to say I confused b < a with echo "a" | b.
----- Original Message -----
Sent: Wednesday, June 26, 2002 14:27

@_date: 2002-06-27 04:08:02
@_author: Leigh S. Jones 
@_subject: osf_filehandle ( ) utility 
Here I've prepared two microprograms.  One was compiled using
Borland C++ 4.5 while the other was compiled with MSVC6.
These programs are my attempt to assist those who have been
requesting information regarding passing passphrases into gpg
programmatically but lack the compiler and/or expertise to do
the job in C.
All this program does is convert the number string representing
the file handle (the file must be open already) of the file containing
the password into an "osf file handle" and pass the new numeric
string out of stdout.  This is only useful for Windows programmers.
Here's what this is all about:
Werner used MingW32 (isn't this also a Werner creation?) to
compile GnuPG 1.0.6/MingW32.  One of the characteristics of
this combination is to make the Windows version of gpg fluent in
the "operating system filehandles" that Windows uses rather than
the file descriptor numbers that are returned by the functions that
open pipes, files, ports, etc.
If one were to write a passphrase to a file, then open the file for
reading in Linux using a low-level file handling function (as
opposed to a function that returns a file pointer, the low-level
functions return an integer representing the file), it would be
possible to pass the file descriptor integer to the Linux version
of gpg on the command line as text that follows the
--passphrase-fd option.  The file is then read by gpg to get
the passphrase (but it must be closed and perhaps deleted by
the calling process).
On Windows, the same thing happens, but the number being
passed on the gpg command line has to be converted.  Hence
the program below.
Well, this doesn't solve all of your programming problems.
These methods need to be recognized for their lack of
security and handled with the utmost of care in order to
avoid compromising your secret key.  And I'd like to
suggest that a C program that opens pipes and passes
osf file handles for the ends of the pipes is much more
The program does not accept piplining the input -- the
file descriptor number must be a decimal number on the
command line.
   int main ( int argc, char* argv[ ] )
   {
   int fdPassphrase;
   int osfPassphrase;
   if ( argc < 2 )
      {
      printf ( "-1" );
      return ( -1 );
      } /* end if ( argc < 2 ) */
   else
      {
      fdPassphrase = atoi ( argv[ 1 ] );
      }/* end else */
   osfPassphrase = _get_osfhandle ( fdPassphrase );
   printf ( "%d", osfPassphrase );
   return 0;
   }/* end main ( ) */

@_date: 2002-06-27 16:15:01
@_author: Leigh S. Jones 
@_subject: GPG Decrypt via PHP 
This question and it's variants appears on the list very
Your choice of PHP limits your options somewhat. In
the end, the --passphrase-fd option is the only option
that you have, and it's difficult to do in PHP.  I'd imagine
that you'll need to write a wrapper program to call from
PHP -- an executable created in C -- in order to
accomplish what you're trying to do...
----- Original Message -----
Sent: Wednesday, June 26, 2002 11:01 PM
Hi List,
I try to decrypt gpg files on W2K with PHP dynamicly. What I need is a
command that includes all infomation for the decryption incl. the
passphrase. I¬¥ve seen same parameter like --passphrase-fd, but I don¬¥t
how I can use these.
I hope anyboby can help me
best regards
Nils Rebhan
Gnupg-users mailing list

@_date: 2002-06-27 18:02:02
@_author: Leigh S. Jones, KR6X 
@_subject: Encrypting with a venders public key 
In order to encrypt a file, it is necessary to generate a random
number for use as an encryption key.  No, this is not the public
key that your vendor provided.  It's called a session key, and
is much smaller than the public key, often 168 bits for 3DES
or 128 bits for many other ciphers.  The session key is a
symmetric key, and it is encrypted with the public key and then
sent along with the encrypted file for use in decryption.  The
session key is decrypted using the secret key that matches
the public key, and then used to perform the actual decryption.
But if the session key is not generated with a good random
number generator then the quality of your encryption is poor.
Your message indicates that gpg hasn't found a high quality
random number generator.  It's been told to look for the random
number generator at `/home/meuser/.gnupg/entropy'.  The
solution is to place a random number generator at that location
or to place a link at that location to the actual random number
As for random number generators, there has been recent
discussion of the issue on the list.  But perhaps it would be
a good idea to look into the entropy gathering daemon, egd.
Or search the web (google.com?) for HPUX random number
generators.  The info is out there, and I'm sure that some of
the list members would be glad to reveal what they use and
where it can be found.
I'm running gpg1.0.6 on HPUX, but don't use it for encryption
or for the creation of keys -- it's only used to create digital
signatures.  So my own HPUX installation never had an
RNG installed to gpg -- never needed one.
----- Original Message -----
Sent: Thursday, June 27, 2002 07:35

@_date: 2002-06-27 21:05:01
@_author: Leigh S. Jones, KR6X 
@_subject: encrypting using a PGP 7.0 pubkey does not work (Malte Gell) 
I have created keys in PGP 7.03, then imported them into gpg 1.0.7
without any special methods.  GnuPG might give you an objection
about an untrusted key when you first import it. One possible problem
may be that the public key was corrupted before you loaded it.  This
would be quite a bit more likely if the key came to you via a keyserver,
because the key appears to have multiple user ID's, which many
keyservers mishandle.
I suggest using the --pgp6 option, but the symptoms you've described
don't relate to that.
----- Original Message -----
Sent: Thursday, June 27, 2002 11:15
Hi there,
just imported successfully a PGP 7.0 public key key into gpg 1.0.7, but
when trying to encrypt something with that key I only get "unusable
key", gpg --edit-key XXXXXX and showpref gives me that:
pub  1024D/xxxxxxxx  erstellt: 1997-07-24 verf√§llt: never
Vertrauen: -/f
(1)  xxx xxxxxxx      Cipher: CAST5, IDEA, 3DES
     Hash:
     Compression:
(2). xxx xxxxxxx      Cipher: CAST5, IDEA, 3DES
     Hash:
     Compression:
(3)  xxx xxxxxxx      Cipher: CAST5, IDEA, 3DES
     Hash:
     Compression:
Well, gpg 1.0.7 comes with cast, 3des and I also have loaded the idea
module, just the hash and compression fields are empty, I tried some
options like --openpgp --pgp2 or --pgp6 but none of them worked, does
that person who uses PGP 7.0 have to create his key in a special way so
it works with GnuPG or can I use that key with some options ?
Gnupg-users mailing list

@_date: 2002-06-28 00:44:02
@_author: Leigh S. Jones, KR6X 
@_subject: add to secret-keyring  { gpg} (Jomy Vellian) 
You add the secret keyring for a single invocation of gpg.
Next time you invoke gpg, the secret keyring has not been added
to your original keyring.
To combine secret keyrings, export one keyring and import it to
your other.
The message means that you didn't tell gpg what to do, and it's
the same message you get when you type:
The program is waiting for you to provide it with text to encrypt
or decrypt on stdin.
----- Original Message ----- Sent: Thursday, June 27, 2002 14:53

@_date: 2002-06-28 01:39:01
@_author: Leigh S. Jones, KR6X 
@_subject: add to secret-keyring  { gpg} 
When exporting from PGP, make sure
Add --allow-secret-key-import to the command line you are using to import the key to gpg.
gpg --allow-secret-key-import --import [viko].asc
----- Original Message ----- Sent: Thursday, June 27, 2002 16:18

@_date: 2002-06-28 01:42:01
@_author: Leigh S. Jones, KR6X 
@_subject: add to secret-keyring  { gpg} (Jomy Vellian) 
oops, left something out...
When exporting from PGP, make sure you check the box
for including the secret key in the export.
Add --allow-secret-key-import to the command line you are using to import the key to gpg.
gpg --allow-secret-key-import --import [viko].asc
----- Original Message ----- Sent: Thursday, June 27, 2002 16:18

@_date: 2002-06-29 00:55:02
@_author: Leigh S. Jones, KR6X 
@_subject: sign a key to the key ring 
Begin with gpg --edit [key ID]
I suggest using the 8 character hex key ID for the key.  GnuPG enters
the edit mode, asking you for commands.  Type help for a list of
commands available.  You can "sign" or "lsign".  "lsign" is non-exportable and will suit your requirements.  You may be able
to do what you want by setting the trust level to about 2 or 3 (command:
Note that you will probably have to set the active UID before "sign"-ing.  To do this, type "uid" then enter a number. The active UID will show up with an asterisk*.  It's possible to
select multiple UID's
Note that one of the tricks of the edit operations is to finish up by
also "changing" your password, by typing "passwd" and re-entering
your existing password.  (this only applies to certain operations on
the secret key)  When done, none of the changes have yet been placed into the database until you type "save".  "save" will also exit gpg.
If you "setpref", then you need to "updpref" before "save". ----- Original Message ----- Sent: Friday, June 28, 2002 15:27

@_date: 2002-06-30 17:21:02
@_author: Leigh S. Jones 
@_subject: file descriptor and windows 
Using Borland C++ 4.5 and the _get_osfhandle ( )
functions I've been successful at converting the file
handles returned by low level file handling functions
into values usable by gpg...
----- Original Message -----
Sent: Sunday, June 30, 2002 1:17 AM

@_date: 2002-05-01 01:44:01
@_author: Leigh S. Jones, KR6X 
@_subject: GPG 1.0.7 on Windows? 
Someone has already posted information regarding the availability
of a gpg 1.0.7 implementation for Windows on the list today.  I
checked it out, and have tested the binary, including many of the new key management features.  The resultant encrypted messages
and signatures were successfully decrypted with gpg 1.0.6 and with
PGP, so I've got a pretty good level of assurance that the nullify.org
people haven't rewritten the software.  I didn't execute their install
program (my reason for not doing this is basically one of security --
it avoids the possibility that the install program installs a virus or other undesirable feature to my computer.  I would have had to create a directory "c:\lib\gnupg" for installation of the "idea.dll", etc.,
extensions if I were installing it at home and wanted to load these
features through entries in the options file.  So I effectively could
not test the idea, tiger, etc. stuff, which is a very nice PGP compatibility feature in the nullify.org's distribution.  I simply put the
gpg.exe and gpgv.exe files into my directories where the originals
----- Original Message ----- Sent: Tuesday, April 30, 2002 16:13

@_date: 2002-05-01 17:23:01
@_author: Leigh S. Jones, KR6X 
@_subject: Signature problem GPG/WinPT <--> PGP 7.0.3 
I didn't have any trouble with your signature using PGP 7.0.3.
Found it on the server, and all.  See below:

@_date: 2002-05-02 00:33:01
@_author: Leigh S. Jones, KR6X 
@_subject: 1.07 and v3 rsa signatures 
I find this odd -- the original message suggests that if gpg1.0.6 encrypts
using a v3 rsa key that pgp couldn't  decrypt.  The short message below
decrypted fine (before my mail tool added >'s) with PGP7.03, but gpg107 can't handle it -- reporting "no data" (using WinPT 5.5 and
----- Original Message ----- Sent: Wednesday, May 01, 2002 10:59

@_date: 2002-05-02 01:08:01
@_author: Leigh S. Jones, KR6X 
@_subject: Cygwin and 1.0.7 
Last question: keyservers with Win32 versions don't seem
to be working, except with Win9x, per an earlier post not
attributable to me.  WinPT accesses keyservers directly
rather than calling gpg to perform keyserver interface, so
it works on windows versions where gpg/mingw32 can't
seem to talk to keyservers.
Other questions: I noted a strange reality using cygwin
bash shell.  After successfully compiling/installing gpg
on cygwin, I discovered that when I accessed gpg by
typing at the command line I'd get the gpg/mingw32
installation that resided in my C:\WinNT directory (by
my choice) and I'd see the keyrings at C:\gnupg\*.gpg
rather than the keyrings at ~/.gnupg/*.gpg.  Apparently
the path has C:\WinNT ahead of the "UNIX" path entries
so anything found on C:\WinNT gets executed ahead of
anything on /usr/local/bin.
So I'd suggest that you could possibly have told WinPT
the wrong location for your keyring.  Or WinPT accesses
a different version of gpg than you think it does.
Also, on several implementations of gpg 1.0.7 and 1.0.6
I have always received 'gpg: Invalid option "-kw"' in
response to "gpg -kw".  I do see that "gpg -k" results in
a listing of keys, although I don't seem to be finding that
one on the "man" page...
----- Original Message -----
Sent: Wednesday, May 01, 2002 11:24

@_date: 2002-05-02 01:35:02
@_author: Leigh S. Jones, KR6X 
@_subject: gpg - 107 
I'm not sure yet, but I may be seeing a slight problem with the gpg/mingw32
implementation from   I take it to be that some of the file
operations within gpg are built to use the unix standard forward slash where
the MS backslash is required.  Thus far it has only appeared as a problem
at times when other errors are being reported, such as:
gpg: unable to read external program response: No error
gpg: Warning: unable to remove tempfile (out)
No such file or directory
----- Original Message -----

@_date: 2002-05-02 07:14:01
@_author: Leigh S. Jones 
@_subject: gpg - 107 
Thanks!  I had no idea that I'd get the attention of the individual
compiled the nullify.org release through the list.  I'm pleased with
opportunity you've given me to upgrade to 1.0.7 early on my WinNT
machines with the nullify release.
----- Original Message -----
Sent: Wednesday, May 01, 2002 8:34 PM
the file
as a

@_date: 2002-05-02 15:20:02
@_author: Leigh S. Jones 
@_subject: gpg - 107 
C:\>dir c:\winnt/system32
Parameter format not correct - "system32".
C:\>dir c:/winnt/system32
Parameter format not correct - "winnt".
----- Original Message -----
Sent: Thursday, May 02, 2002 12:32 AM

@_date: 2002-05-02 16:09:01
@_author: Leigh S. Jones 
@_subject: Cygwin and 1.0.7 
I apparently misread the earlier post "Cygwin and 1.0.7", taking
"-kvv" for "-kw".  Most likely this was due to the default font
translations being performed by my e-mail tool at work.  Here
at home the vv looks like two v's.  I wasn't familiar with any
of the -k commands, because my experience with gpg started
with 1.0.6.
----- Original Message -----
Sent: Thursday, May 02, 2002 12:24 AM

@_date: 2002-05-04 01:37:02
@_author: Leigh S. Jones, KR6X 
@_subject: GnuPG 1.0.7 not compiling on Solrais 2.7 
I succeeded in compiling on a slightly earlier version of Sun
Solaris using gcc and gnu make on a Sun Ultra 1.
Our situations have some similarities.  I did not want the
make program to install the executable.  Instead, without
running ">make install", I produced the gpg executable in
the g10 directory.  No --prefix option was required in
make.  I actually had no reason to include any parameters
on the "./configure" line as the program configured and
compiled effortlessly.  But I didn't perform a "make install".
I just put the executable in the path.  This was possible due
to the intended use of the particular system on which I'm
1) no keys will be generated
2) no encryption will be performed
(these two factors combined mean I had no concern for
any issues regarding entropy)
3) only clearsigning of documents and verification to
known keys will be required
4) all keyring updates will be performed by transferring
copies of the keyring and trust data base files from
another system
(these factors combined mean no need for keyserver
The gnupg 1.0.6 installation that I replaced had been
communicating with the keyservers OK, while I notice
that the capability was not maintained by my upgrade.
I believe that some portions of the gpg program may
have been spun off into separate executables with the
release of gnupg 1.0.7 -- and I did not install the
separate executables properly.  This would be my
fault, but I have no need to fix it.
You might have some success with this approach
probably more than I did...
The line 226 error jumps out at you if you look at
the code.  And int * named sequence is passed as a
parameter, and an attempt is made to initialize the
value of an integer from the value pointed to by
sequence.  Perhaps gcc accepts this (creation of a
local variable and simultaneous initialization from
a variable) where other compilers would only
allow the initialization from a value that is known at
compile time.  If you change line 226 to two lines
that read:
int i;
i = *sequence;
then you'll be able to move on and see if other
similar problems exist with your compiler.
----- Original Message -----
Sent: Friday, May 03, 2002 15:23

@_date: 2002-05-04 20:45:01
@_author: Leigh S. Jones 
@_subject: key expiration 
You can freely extend the expiration date of your certificate.
gpg --edit-key 0x
Command> expire
follow the instructions.  Type, for instance, 2y.
Confirm and enter your passphrase.
----- Original Message -----
Sent: Saturday, May 04, 2002 9:54 AM

@_date: 2002-05-04 20:46:01
@_author: Leigh S. Jones 
@_subject: key expiration 
Remember to Command> save
----- Original Message -----
Sent: Saturday, May 04, 2002 9:54 AM

@_date: 2002-05-04 20:58:01
@_author: Leigh S. Jones 
@_subject: batch encrypting customer orders on remote secure server? 
Encryption does not require a passphrase.  Decription requires
a passphrase.  It's easy to encrypt by batching.  I'm assuming
your remote host will be appropriate for gpg (perhaps a Linux
machine?) and there is no objection to you running executables
on your directory.  And, gpg will not be a cgi program in this
case.  A cgi program is one that feeds outputs back to the
browser.  A number of your questions should be directed to
the individual or company that manages the host machine.
You'll need to talk to them about how to make and install
gpg on your web site.
----- Original Message -----
Sent: Saturday, May 04, 2002 9:30 AM

@_date: 2002-05-05 03:49:02
@_author: Leigh S. Jones 
@_subject: Automatic resyncing of keys? 
LDAP keyserver left for public use.
There are probably a whole lot of LDAP servers you
don't know about.  PGP produced a keyserver (software) for Windows that was free for non-
commercial use.  It gets the job done nicely, although a full replication of the world database
would probably occupy a few GB on a hard disk.
Many of these were synchronized with the PGP, Inc.
database, although they were also usable for sharing
public keys on a much smaller scale, such as keys
used for securing intra-family e-mail.  And, I'm sure
that some companies also used the PGP ldap server
software for storage of company keys -- although I
doubt that they had a realistic business plan for the
sales of this product.

@_date: 2002-05-05 21:18:01
@_author: Leigh S. Jones 
@_subject: batch encrypting customer orders on remote secure server? 
Yes, you will need to use /dev/random.  That would be critical.  My
application is automatically signing.  For that, entropy isn't
but the secret key password is.  But you have it easy -- you're
installing on a Linux machine and, I assume, Apache.  Should have
the flexibility to do everything you want.  It may take some
configuration tweaks, though, before they figure out how your
browsers can automatically execute the encryption script file.
If your Linux implementation is really similar to theirs then you will
probably have no trouble compiling on yours and simply copying
the executable gpg to the server.  For instance, if you both run
Red Hat Linux 7.2, then no problem.
But, if the implementations of Linux are different, such as
Mandrake and Red Hat, they might use different run-time
libraries and different locations for files.  The gnu make
program, the configure scripts, etc., work these things out for
you when the gpg program is built on your machine, but might
come to different conclusions about which will work for you
vs. what will work for your web provider.
Once gpg is built, it will execute from any directory that your
web provider wants you to put it in.  The gpgv program will not
be needed for your application, as I understand your application.
And, I think that in gpg 1.0.7 the keyserver access portion of the
program has been spun off into one or two external executables.
If the "make install" portion of the gpg INSTALL instructions is
executed, I'd assume that these external executables would be
placed into the appropriate directories.  Unless you figure out
where these belong and get your web service provider to drop
them there, then gpg would lose keyserver access capability.
As I understand your application, this would not be a problem.
You would need keyserver access only to check for updates
to keys, and you could easily encrypt to a public key without
checking for updates.
I haven't tested it yet.  I don't know for sure that the MingW32
compiler uses the same "OSF file handles" that it used at the time
that the program code that I put into the archives was tested,
i.e., when gpg.exe1.0.6-2/MingW32 was compiled.  It probably
does still work.  That program was written for Borland C, but
I checked and the Microsoft Visual C 6 compiler has the OSF
file handles functions available.  I'd guess that they work the
same.  These issues jump out at me, because lately I've been
programming extensively using National Instruments CVI
compiler that lacks both the OSF file handle functions and any
"pipe" functions.  Those pipe functions really come in handy
when you are trying to integrate gpg and other programs.
But, as long as you are willing to either:
1) enter the password once when each credit card number
file is decrypted
2) only do bulk decryption on a physically secure machine
with secret keys encrypted to a blank password
3) use gpg agent
of come up with some other method for avoiding the entry
of passwords multiple times when decrypting, then you will
be able to comfortably perform the decryptions without
anything like my program in the archives.  Of course, there
are a lot of other options.  For instance, PGP can be told
to cache the password for a few minutes, and WinPT has
multiple decryption capability.  I could go on.  Don't make
me.  This is boring enough for the rest of the list already.

@_date: 2002-05-06 18:21:01
@_author: Leigh S. Jones, KR6X 
@_subject: moving gpg to another PC 
Try this:
source-machine $ gpg -a -o secretkey.asc --export-secret-key 'X'
source-machine $ gpg -a -o publickey.asc --export 'X'
source-machine $ scp *key.asc  dest-machine:/myhomedir
On the destination machine, tickle gpg until it reports creation
of the keyrings, then
dest-machine $ gpg --allow-secret-key-import --import secretkey.asc
dest-machine $ gpg --import publickey.asc
dest-machine $ gpg --edit-key "X"
Command> uid1
Command> trust
Your decision? 5
Command> sign
Really for sure? You can't be serious, please reconsider... Danger Will
Robinson! y
Oh the humanity... What a world...
Command> save
----- Original Message -----
Sent: Monday, May 06, 2002 08:51

@_date: 2002-05-06 20:02:01
@_author: Leigh S. Jones, KR6X 
@_subject: Interoperability 
I hope very strongly that Mr. Zimmerman will find disagreement,
but at this point in time I have come to the conclusion that it is
unwise to take interoperability with PGP as a serious issue
moving into the future.  Certainly there are users of PGP who
will not change or upgrade.  But indications are that PGP will
die out and leave GnuPG as the only serious tool for encryption
and digital signatures.
Now, don't misunderstand me.  I realize that there are numerous
tools that have been developed for cryptography, in fact
hundreds have been through the validation process:
This is the list for digital signatures, there are others for the
cryptography validations.  But few of these have the public
attention that PGP and gpg have, perhaps because of price
issues.  And, Windows has a built-in capability that is largely
ignored because of the linkage between Windows encryption
and enterprises that charge for certificate signing and
certificate server services.
GnuPG is poised to dominate the field, and its developers
should consider the implications of creating the best possible
tool rather than the most compatible one.  The "idea" patent
has already set PGP and GnuPG widely apart from the
standpoint of interoperability, despite the promise of
compatibility that the OpenPGP standard presents.  Equipping
GnuPG with capabilities that extend its interoperability with
existing standards such as SHA-256 makes sense from the
point of view of interoperability, even if there is no support for
these standards in PGP7.1.
----- Original Message -----
Sent: Monday, May 06, 2002 10:24

@_date: 2002-05-07 22:49:02
@_author: Leigh S. Jones, KR6X 
@_subject: Interoperability 
I find a great deal of agreement with what you've written, perhaps that means our ideas are similar.  Maybe your reasons are different.  First, the "idea" patent only applies to the US, so you're in no danger of being sued.  The "idea" patent holders probably would only pursue a case if an American company (such as Network Associates) profits from selling their product without paying royalties -- then I think they'd believe they deserve a share of the profits.  Makes sense.  But it does prevent me from doing some things that I'd like to do, even if the patent holders stated position would be to allow me that freedom, because of company policy against ignoring patents or copyrights at my job.  My company wants to stop paying for shipment storage of 20 tons of new, automatically generated paperwork yearly, so it needs a secure digital signature capability. Looks like it will be done with gpg now, but I tried to license PGP command line first (the freeware product).  NAI's business plan wouldn't allow that, so they are out a few thousand of dollars, and coincidentally out of the PGP business.
Now I'm moving my old keys over from "idea" to AES (Rijndael) because the US government thinks it's a good cipher.  But, the OpenPGP standard should take care of interoperability.  Interoperability is a moving target.  Standards change.  It's best to equip yourself to hit the moving target.  If someone's keys say they prefer an SHA-256 hash, then you should probably send them an SHA-256 hash.  Maybe they like it because its a good hash.  Having the capability improves your interoperability rather than damaging it.  Sure, the OpenPGP standard doesn't negotiate algorithms for signatures, so vanilla signatures are sometimes a good idea.  But if you know that the software that will be used to verify a signature accepts SHA-256, then perhaps the SHA-256 hash would be better than alternative hashes.  At
my job I need to specify the verification software together with the signature software and options, then validate it all
together as a package.  Perfect agreement.  What if I'm running windows and someone
sends me a signature executed with SHA-256?  Enter sha2.dll.
Glad to have it.  Thanks, Keith.  Thanks Disastry.

@_date: 2002-05-07 23:15:01
@_author: Leigh S. Jones, KR6X 
@_subject: Making it simple 
Perhaps nothing.  If the encrypted data will be encrypted to your
keys, then GnuPG 1.0.7 allows you to select your preference
of encryption algorithms.  PGP 6.x or 7.x will encrypt to the
preferred algorithms on your key.  GnuPG will decrypt this data OK.  Thank you, OpenPGP Foundation.
Of course, if you created your keys on PGP, the preferred
algorithm on the key will be "idea".  You can export a key
like this from PGP to GnuPG and be able to send messages
one way only -- from GnuPG to PGP.  PGP will encrypt to
your "idea" preference, and you'll need to add "idea" to
your GnuPG installation to be able to decrypt.
But if you change the key preferences from "idea" to, say, AES, then "gpg -a --export " the public key back to PGP,
then PGP will start encrypting keys to AES.  Interoperability
restored.  Send the public key to the keyserver and everyone
with fairly up-to-date software revisions will be able to find
out which algorithm you prefer.
----- Original Message ----- Sent: Tuesday, May 07, 2002 13:42

@_date: 2002-05-08 16:10:01
@_author: Leigh S. Jones 
@_subject: interoperability 
Yes, and of course there are a number of people out there using
erlier implementations of PGP that produce outputs encrypted
to idea only.  Even with the modern implementations of PGP
using DSS/ELG-E keys the senders PGP key could be set up
to accept idea only and then the message encryption performed
both keys.
But Sahar Witt took his PGP generated DSS/ELG-E key to
gpg and his customer encrypted to idea using his PGP public
key's preference, prompting my response.
known and
not the
and took
this may be
both keys,

@_date: 2002-05-09 23:01:01
@_author: Leigh S. Jones, KR6X 
@_subject: GPG 1.0.7 problems 
The --pref and --showpref commands are used while in the edit mode, i.e.,
gpg --edit-key FFFFFFFE
Command> showpref
I'm having some trouble editing RSA keys myself,
or so it would appear.  I just tried generating one
and it's not working for me either.  Maybe you'd be happier with a DSA/ELG-E keypair?
----- Original Message ----- Sent: Thursday, May 09, 2002 13:27

@_date: 2002-05-09 23:04:02
@_author: Leigh S. Jones, KR6X 
@_subject: GPG 1.0.7 problems 
And, OH, BY THE WAY, REMEMBER TO Command> save
after editing anything, or the changes won't be recorded in the key database.
----- Original Message ----- Sent: Thursday, May 09, 2002 13:56

@_date: 2002-05-10 00:07:02
@_author: Leigh S. Jones, KR6X 
@_subject: Installing GPG on W2K 
This works fine.  No need to create the database before creating the
first keys.  Gnupg will take care of it.
Right.  Of course, you might have preferred to place gpg into the path.
If you use WinPT then you have to tell WinPT where gpg has been
placed ("C:\Gnupg" in your case), and if you don't use "C:\Gnupg" as
your database location, then you have to make other changes.  I'd
suggest placing a copy of gpg.exe into your C:\Winnt directory.  That
directory is always in the path.  If you do, make sure that the two files
"C:\Gnupg\gpg.exe" and "C:\Winnt\gpg.exe" are always the same --
update them at the same time.  Otherwise, add "C:\Gnupg" to the
path.  Then it will execute no matter what directory your "cmd" prompt
is in at the time.  It's OK to have multiple copies of gpg.exe on your
system if you don't try to use them at the same.
The options file contained in the gpg 1.0.6 distribution might help.
Using 1.0.6 you will probably want some options in there.  With 1.0.7
the default options are a little bit more like what you'd want than the
1.0.6 defaults.
Second to that, you should know that the information in the options
file is described when you type "gpg --help".
There are two things that might go on the command line:
Commands generally will need to be the last thing on the gpg
command line, such as:
gpg -d encrypted_file.asc
The command is -d, same as --decrypt, with a filename parameter.
Options are generally placed in front of the command:
gpg --armor --encrypt unsecured_file.txt > secured_file.asc
gpg -o secured_file.asc --armor --encrypt unsecured_file.txt
Placing options into the options file means you don't have to
type them into the command line.  If you need something
different from what the contents of your options file would
dictate, then you override the options by placing new
options on the command line:
options file:
(note: you don't put the "--" in front of the options in the
options file)
command line:
gpg --verbose -d encrypted_file.asc
Usually it's convenient to put things like local-user in your options file.
----- Original Message -----
Sent: Thursday, May 09, 2002 14:31

@_date: 2002-05-10 16:04:02
@_author: Leigh S. Jones 
@_subject: help needed!!! 
GnuPG for WinNT is also known as gpg/mingw32 or gpg/w32 and is available at the  web site.  It comes with the file compressed using
the "zip" format which is very commonly used for
all Microsoft operating systems.
If you cannot open the "zip" format, I suggest going to the WinZip.com web site and obtaining
the evaluation version of WinZip available there.
Install WinZip and use it to unzip the gpg archive.
Place the program gpg.exe into the directory
"c:\winnt".  Create a directory called "c:\gnupg", and place a copy of gpg.exe there also.
Open a command prompt.:  .  In the command prompt
window type:
gpg --list-keys
When you hit return, gpg will give you an error message.  Again type:
gpg --list-keys
This time you should get no error message, but
you'll get an empty listing of keys.  This tells you
that the key database has been created.
Now, if you have any PGP secret keys, old gpg secret keys, etc., import them into gpg.  Use
the command "gpg --import ".
If you don't have any PGP secret keys, etc.,
then that means you'll need to create some keys
for yourself.  gpg --gen-key
Answer the questions.  Use the default key type.
DSA/ElGamal.  I suggest a key size of 2048.
You may need to add an "options" file to get the performance details that you want.  I
suggest a minimum of "openpgp".  An example
of an options file is found in the gpg main distribution gpg1.0.x.tar.gz (use WinZip to open
it).  Match the version number you get to the version number for gnupg/w32 that you have.
Instructions for use of gpg are available:
gpg --help
If you type "gpg" at the command prompt, you'll
get a message from gpg that you should go ahead
and type your message.  That's the hard way to do this. Get out of that mode by typing Z.
Create text messages that you want to encrypt in
notepad.exe or similar and encrypt using:
gpg --
You may wish to go to  and
get winPT.    ----- Original Message ----- Sent: Thursday, May 09, 2002 10:47 PM

@_date: 2002-05-11 00:49:01
@_author: Leigh S. Jones, KR6X 
@_subject: Making it simple 
My PGP7.04 release produces keys with no hash nor
compression preferences listed either.  It's possible to
influence the first choice for symmetric cipher on this
PGP release.
I'd prefer to see AES(any) as the cipher default, based
on US government influences.  Regardless of cipher,
DSA + SHA1 are the choice for digital signatures.
----- Original Message -----
Sent: Friday, May 10, 2002 14:35
is for the sole use of the intended recipient(s) and may contain
confidential and privileged information.  Any unauthorized review, use,
disclosure or distribution is prohibited.  If you are not the intended
recipient, please contact the sender by reply e-mail and destroy all copies
of the original message.

@_date: 2002-05-11 00:57:01
@_author: Leigh S. Jones, KR6X 
@_subject: using keys with multiple users 
You have two choices:
1 - issue separate keys for each employee who will
sign/encrypt with under the role of support
and/or hostmaster in which case
each may keep secrets from the other but there could
be confusion on the part of your correspondents as to
which key to use 2 - issue copies of a single key to each employee, in which case the key name would be something like:
"MyCompany Corporate Support Key "
in which case there would be little confusion on the part of your correspondents but questionable legal value of a signature
A single key could have two or more user identifications associated with it, for instance one
key could play the role of both support
and hostmaster
My personal choice is a hybrid:
Issue each employee two keys: one personal key to be used privately for encryption and signing
unambiguously plus one copy of each "role" key that appropriately matches their job title. This, however, requires separate keyrings -- to
allow each employee to select his/her own passwords -- so keyring file ownership must be
arbitrated in the operating system.  This probably
means no Windows 95/98/ME for "role" keyholders.
----- Original Message ----- Sent: Friday, May 10, 2002 08:07

@_date: 2002-05-11 03:14:02
@_author: Leigh S. Jones 
@_subject: using keys with multiple users 
There's a difference between a situation where a single
individual can be held responsible for his actions and a
situation where a corporation can be held responsible
for it's actions.  Where an individual represents a
corporation by signing his own signature, the signature
is traceable to a single individual, who could, in theory,
attest to the signature or deny it as a forgery when
questioned under oath.
It's a big world, and there are many legal systems.  In
one legal system it is fair to assume that the decisions
made in courts will be different from the decisions
made in other systems.  The system of justice in the
USA is moving toward acceptance of the legality of
digital signature in certain circumstances, but in other
circumstances and other countries the digital
signature has more limited acceptance.
For instance, the value of a digital signature is only as
good as the trust that we place in the public key and
in the security of the private key.  If the veracity of a
digital signature can be attacked successfully in court,
then the digital signature would have little value.  For
instance, if I leave a copy of a signed will with a
lawyer but appear to recant the provisions of that will
and leave a new will on my computer drive before
expiring, but no trust can be placed in the digital
signature because it appears that I created a new
signing key immediately before executing the signature
on my deathbed, then it's clear that it will be difficult
to use the electronic evidence to challenge the first
will.  Too easy to forge that.
Read FDA document 21CFR Part 11 for an
example of one US government agency that will
not accept signatures that have been executed
by a corporate "role" in lieu of an individual.
----- Original Message -----
Sent: Friday, May 10, 2002 4:58 PM

@_date: 2002-05-11 21:15:02
@_author: Leigh S. Jones 
@_subject: Signatures and pub-key qustions... 
Old UID's on the server will be merged with new UID's for the same
You don't remove old keys from the server.  If you have the secret key
you can generate a revocation certificate and upload it to the server.
old key remains on the server, but revoked.  When someone who has your
key on their keyring updates your key from the server, then the
showes up in their keyring.  Without the old/revoked key on the
they wouldn't find out you've revoked your key -- unless you told them
----- Original Message -----
Sent: Saturday, May 11, 2002 9:40 AM
to public
download back
to remove
and one
Afterwards I
way to
which I
do I need
so others

@_date: 2002-05-13 04:45:01
@_author: Leigh S. Jones 
@_subject: Newbie Questions 
"I still don't know why I can't generate a new key."
Perhaps the problem is that your keyring files are owned by
root, and you don't have the privilege to write to them as
another user.  And perhaps the random seed file has not
been updated for the very same reason.
"... how I would import my current key pair (from windows)
so I can use it in GnuPG.  Or, since the key is not widely
dispersed, can I make a new key pair in GnuPG and have
my PGP in windows use it?"
Export the public key from PGP and send it to me, or
put it on a keyserver and send me the key ID so that I
can look at the preferences.  Tell me which version of
gpg you want compatibility with... I'll get you the answers
you need.
"Also, what I need to do so someone can verify my key
if I sign with GnuPG and they are using PGP in windows."
You won't need to make any changes to allow this.
"Are there any GUI interfaces, or anyway at all I can get
this to happen with GnuPG?  I'm using RH 7.2 and
Ximian Gnome."
----- Original Message -----
Sent: Sunday, May 12, 2002 3:55 PM
'su' to
new key.
it in

@_date: 2002-05-13 07:39:02
@_author: Leigh S. Jones 
@_subject: help needed!!! 
There are a few easy answers and some more
difficult ones that are available.
First, if you are using a Linux system, you can try
GnuPG Agent.  It retains your password through multiple operations, such as decryptions or document signings.
Second, if you are using a Windows system, you can try WinPT.  WinPT is an add-on
program for gpg on Windows.  There may be some practical limit to the number of files that can
be simultaneously decrypted.  Probably several,
but perhaps a dozen at a time would be a risk.
Third, PGP can retain a password for a predefined length of time.
If none of these will do the job for you, then
I've written a program in Borland C that illustrates how to pass the password along
from a program or batch file to gpg.  The program is in the gpg-user archives, but if you can't find it there, write me back and I'll
dig it up and send you a copy of the source
A word of caution: all of these methods have
security problems associated with them.  These
methods should only be used on a single user
system.  And only on a system that you have
physical control over.  You'll risk compromising your password otherwise.
----- Original Message ----- Sent: Sunday, May 12, 2002 9:40 PM

@_date: 2002-05-13 17:22:01
@_author: Leigh S. Jones, KR6X 
@_subject: What level of encryption does GPG use???? 
Here's the info:
CAST5     128
Twofish     256
Blowfish    128
3DES        ~112 with 168 bit key
AES           128, 192, or 256 available
Idea            128 (plug-in)
Although it's possible to manually select
which encryption algorithm will be used by
the use of options on the command line or
in the options file, most users will allow the algorithm selected by gpg to be used when
encrypting to be the first or second choice
on the list of preferences on the key used
for encryption.
3DES was once thought to have an encryption strength of 168 bits, but the
latest cryptographic attacks have effectively
weakened the effectiveness of this encryption method.  AES is also known
as Rijndael and is a good choice for security according to the US government,
plus it interoperates with both PGP and
gpg.  Idea is not provided with the base
release of gpg due to patent issues.  The
patent is a US patent that does not apply
to countries outside of the US, and the idea patent holder will not enforce it in
the US against private not-for-profit use.
Idea has been, however, the algorithm of
choice for PGP since it was written, although OpenPGP compliant versions
of PGP (PGP 2 is not in this category) will
use the preference list on the key.
----- Original Message ----- Sent: Sunday, May 12, 2002 23:58

@_date: 2002-05-14 01:29:01
@_author: Leigh S. Jones, KR6X 
@_subject: Verifying signatures via WWW interface 
Here are two options listed in the gpg.man file that might
be of some use to you.
--trusted-key long key ID
                 Assume  that  the  specified  key (which must be
                 given as a  full 8 byte key ID) is as  trustwor¬≠
                 thy  as one of your own secret keys. This option
                 is useful if you don't want to keep your  secret
                 keys  (or  one of them) online but still want to
                 be able to check the validity of a given recipi¬≠
                 ent's or signator's key.
                 Skip key validation and assume  that  used  keys
                 are  always  fully  trusted.  You won't use this
                 unless you have installed some external  valida¬≠
                 tion scheme.
----- Original Message -----
Sent: Monday, May 13, 2002 15:46

@_date: 2002-05-15 00:21:01
@_author: Leigh S. Jones, KR6X 
@_subject: What level of encryption does GPG use???? 
Classic Meet-in-the-Middle only requires a mere 512 petabytes...
  -- Keith

@_date: 2002-05-16 07:07:01
@_author: Leigh S. Jones 
@_subject: how to use Symmetric encryption 
Hello again Deepesh.  Were you able to successfully
decrypt multiple files on a directory as you desired?
gpg -a -o  --symmetric ----- Original Message ----- Sent: Wednesday, May 15, 2002 9:44 PM

@_date: 2002-05-17 15:18:02
@_author: Leigh S. Jones 
@_subject: please help 
Good morning from California.
Although GnuPG does have the ability to use
conventional password encryption, it's design
is really intended for "public key" In public key cryptography, each of the users
has his own keyset -- a public key that is to
be shared widely, and a private key that is to be kept absolutely and strictly secret.  The
public key is used to encrypt messages for
reading by the person who has the matching
private key.  For instance, at the bottom of this message is my public key.  If you were to create a file containing all the text between and including the -----BEGIN and -----END
lines, you could import that file into your
keyring (by typing:
gpg --import from the command line) then you could use my key to encrypt a message only I could
gpg -a -o  -r Leigh --encrypt This is the method of encrypting that will
allow the text of the encrypted file to be pasted
into an e-mail.
When I receive the e-mail, I'll type:
gpg --decrypt -----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.0.7 (MingW32)
-----END PGP PUBLIC KEY BLOCK-----
----- Original Message ----- Sent: Friday, May 17, 2002 4:46 AM

@_date: 2002-05-17 16:11:01
@_author: Leigh S. Jones 
@_subject: GPG WIndowss 
The verification that you've performed simply tells
you that the signature confirms that the contents of
the .iso file have not changed since the signature
was created.
Your confidence in the .iso file then depends on
whether you are convinced that the signature file
has not been created by a malicious person.
The process of performing this check has given
you one answer:  Was the file corrupted during
download?  No!  The contents of the file are
perfect as far as the creator of the signature file
is concerned.
This perhaps doesn't tell you that the .iso file
couldn't have been manipulated before the
signature was created.  All of the messages
from gpg regarding the trust placed in the key
point to the possibility that the file could have
been signed by the wrong person.  GnuPG is
not telling that the file was signed by the
wrong person, only that the software couldn't
tell.  In the case of downloads from a web
site, this is just about as good a result as you
can get.  Use the .iso file, it is uncorrupted.
----- Original Message -----
Sent: Tuesday, May 14, 2002 1:23 PM
conectiva and I

@_date: 2002-05-17 16:20:02
@_author: Leigh S. Jones 
@_subject: using a key without self-signature 
A couple of possibilities for you:
1) Place
into your options file
2) Create a script or batch file to use when
this public key is exercised.  To do this, you'd
create a small text file, for instance to encrypt:
gpg -a --allow-non-selfsigned-uid -o  -r
 --encrypt %1
The last couple of characters are specific to
the operating system -- this is a UNIX/Linux
You save the script file with execute permissions,
then type:
3) Ask your contact to self-sign the key so
you don't need this.  Of course, he might not
be able to.
----- Original Message -----
Sent: Wednesday, May 15, 2002 1:43 PM

@_date: 2002-05-17 19:49:01
@_author: Leigh S. Jones, KR6X 
@_subject: signing & encrypting 
S(E(m)) has a vulnerability in that you know who signed a message,
but you don't know who originally wrote or encrypted the message.
E(S(m)) has the vulnerability that you know who originally wrote and
signed the message, but you don't know who actually encrypted it and
sent it to you.
This may be true from the point of view of the software.  In the real
world we usually have reason to trust our signers.  If our contact
performs an E(S(m)), then we have a signed message when decrypted.  It may not be important to know who encrypted and sent the message because we trust the signature.
If we S(E(m)) then we should be able to trust our signer to know
what he has signed.  Would you sign an encrypted message
If we S(E(S(m))) then the identity of the sender has been
compromised.  In the case of credit card transactions for instance
this might possibly not be an issue, but since the early days of
my use of PGP and gpg I've learned that even honest, law
abiding people can have much reason to use caution about
revealing certain things.  For instance, if the recipient of the
message is a holiday resort, then the information contained inside might be a request for reservations.  A burglar with the
ability to monitor messages at some internet node could use
this information to profile his next victim.  He wouldn't need
to decrypt the message, only be aware that sensitive communications is taking place between Rich Guy and
Phoenix Phat Pharm.  Now he knows to watch for Rich Guy's
home looking like he's away for a few days.
In the real world it's much more likely that we will either receive
S(m) clearsigned messages that have no secret content, or we
will receive E(m) or E(S(m)) messages where the sender doesn't
wish to make his identity known to anyone besides the owner of the secret key.  E-mail return addresses make this more difficult to accomplish, but there are ways to get around this.
----- Original Message ----- Sent: Friday, May 17, 2002 08:18
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Tampering isn't the point. Check out that reference I posted earlier.
Basically, it summarizes as:
S(E(m)) has a vulnerability in that you know who signed a message,
but you don't know who originally wrote or encrypted the message.
E(S(m)) has the vulnerability that you know who originally wrote and
signed the message, but you don't know who actually encrypted it and
sent it to you.
S(E(S(m))) prevents both of these vulnerabilites, provided that the
inner and outer signatures are both valid and made from the same
private key. Most OpenPGP programs, while capable of S(E(S(m))),
don't do it in one step, on the encryption or decryption end.
Gnupg-users mailing list

@_date: 2002-05-18 00:57:02
@_author: Leigh S. Jones, KR6X 
@_subject: please help From: "HEMANT BAANDAL" 
On re-reading your first post, I see that I may
have misunderstood your question.  Forgive
Your secret key is stored in the secret keyring in encrypted format.  The entry of a passphrase is necessary to decrypt the
secret key for use.  When encrypting files
or verifying signatures you will be using
the other person's public key.  Public keys
are stored in the public key ring without
any encryption, so encryption and verification operations do not require any
passphrase entry (except in the case of
symmetric encryption to the hash of a passphrase with the --symmetric option).
If you set your system to be less secure,
for example if you store your key in the
secret key ring with a blank password, then you will compromise the security of
your cryptic system and risk revealing
your secrets.  However, for certain operations on a physically and electrically
secure machine it would be safe to use the blank password method for short periods, assuming that you will revert to the safe storage of your secret key after
you have finished your operations.
This kind of question is often asked:
"I want to use gpg to encrypt and decrypt
a large number of files.  Encrypting is easy,
but I don't want to have to enter my password once for each file that I must
On some systems the best solution is a
program named GnuPG Agent.  For some
the best approach is to write a program or script that automates the process.  But, again, whatever method you choose, you need to do it on a machine that is both
permanently physically secure (for example,
inside a locked room no one else will enter)
and electrically secure (for instance, one that is not connected to a network).
And, I suggest not compromising these
principles simply because you are certain
that the data (secrets) you handle cannot be used to harm you.  Increasingly the
digital signature is becoming a legally binding tool over time.  If you allow your
secret key to be stolen, it could be used to
defraud yourself or even defraud some
innocent third party.  It's like the risks of
driving a car.  If you take into account only
your own personal danger, then you will run
greater risk of endangering someone else when you drive.
----- Original Message ----- Sent: Friday, May 17, 2002 04:46

@_date: 2002-05-21 08:17:02
@_author: Leigh S. Jones 
@_subject: some(!) PGP / GPG compatibility question 
If you'll e-mail me your PGP public key I'll see if I can get
a notion about the problem.  It might be more practical to
use a DH/DSS key if you want fewer compatibility issues.
And, IDEA is not automatically included in the gpg releases
although it can be added -- AES might be a more
compatible choice.
Don't get the idea that DH/DSS is less secure than RSA.
A 2048/1024 bit DH/DSS keypair will keep you safe.
Or use a 4096/1024 bit DH/DSS keypair.  The 1024
bit key is used for signing only, while the 2048 or 4096
bit part is the assymmetric encryption key.
If someone wants to invade your privacy they will
probably prefer to sneak into your home and put a
program on your computer that traps your password
when you enter it.  The pricetag for a broken DH/DSS
keypair is many millions of dollars worth of computer time
while a quiet burglary costs perhaps a few hundred dollars.
Otherwise, most of the serious attacks that succeed will
succeed by the theft of your secret keyring and the
methodical computer aided guessing of your password.
And, if you go to the RSA web site you'll learn that they
are busy defending against allegations that the opposite
is true, that specially built hardware could attack RSA
Use HTTP://wwwkeys.us.pgp.net.  Revoke old keys
when you stop using them, and make sure that you
revoke them on the servers.  Never delete old keys;
always revoke, and save your old keys.
The encrypt to self option allows you to encrypt data
for only you to decrypt.  This probably accounts for
more than half of the use of PGP/gpg for encryption.
Too many questions.  I'll let someone else answer
them, and probably disagree with me on the answers
I've given...
----- Original Message -----
Sent: Monday, May 20, 2002 7:41 PM
my name
in the
and GPG
windows and the key should be compatiable with most of pgp / gpg
cracked by NSA, FBI and likes so is the above key safe from this type
of attack ?
this key allow all the data encrypted with my other key to be cracked
( other keys are 4096 and 2048 bits long ) ?
DH/DSS algo being less secure than RSA. Would this matter in the
generation of new key ( ie I should not generate a DH/DSS type of
key ) ?
( the original keyservers in PGP seem to be unstable )
that I have generated a new key and that they should stop using the
old key ( of course I will revoke it if required ) ? should I sign my
new key with the old key for this and put the key on a public
keyserver or should I not revoke the old key but instead change the
name in the old key to reflect the new keys ID and fingerprint and
urging them to use the new key ?
XXXX XXXX  XXXX XXXX XXXX XXXX XXXX
Until now I
Encrypting file
key /
system and
( any
Cert for
feature ?
on this
password I
a ADK in
that it

@_date: 2002-05-22 15:24:01
@_author: Leigh S. Jones 
@_subject: Plagiarism 
This is commonly done using postmarks -- you seal the printed text into a letter addressed to yourself,
mail it, and then don't open it on receipt.  Because
this form of protection has been defended in the
courts in some places with success in the past there
is some safety.
Assume clearsigning in all of the discussions below:
An alternative that probably has not been tested in
the courts is to sign the text with gpg, e-mail it to a friend (collecting impartial timestamps from the e-mail servers along the way in the headers).  Your friend then signs the e-mail (including the headers with time stamps) with gpg and sends it back to you (collecting more time stamps) for you to sign.
At this point, the smartest thing to do is to print out the complete text, print out your two public
keys, sign and date every page, and then mail it
all to yourself in a sealed envelope.  Werner's
idea about the public forum adds strength to the
mix also, assuming that the moderator of the
forum will allow the "garbage" to remain in the
Why use a friend?  If ever challenged in court he
can be called to testify to the truth of your ----- Original Message ----- Sent: Tuesday, May 21, 2002 9:50 PM

@_date: 2002-05-23 16:06:01
@_author: Leigh S. Jones 
@_subject: 2nd Try: --fd-status and stderr msgs from gpg 
Your solution is looking right at you:
If you do not get the "_OKAY" in your status_fd stream then your
operation has failed.  If you want to find out why, then capture
stderr and search the text for key phrases such as "key not found".
But if you would take no particular action if "key not found" was
present in the stderr stream, then don't searcy for it. Stderr is not
difficult to capture, just place a 2 >> [filename] on the command
line and read the contents of [filename].  Or pipe the stderr
straight into your program.
If you'd like quicker answers for questions like this, try telling us
what operating system you are running.  From your original post
it's difficult to tell if you are running Linux, Unix, or Windows.
----- Original Message -----
Sent: Thursday, May 23, 2002 5:13 AM
encrypted by gpg
present in
[GNUPG: ]
someone and
key not
know all
can give

@_date: 2002-05-23 17:22:01
@_author: Leigh S. Jones, KR6X 
@_subject: gnupg encryption (Eva Herskovicova) 
GnuPG is a command-line tool.  This means that
it does not have built-in ability to place buttons on
the Microsoft Outlook toolbar that will allow the
convenience of encryption/decryption that PGP
affords.  Instead, GnuPG is used to encrypt or
decrypt files outside of Outlook, and the contents
of the files are moved into and out of Outlook using
copy/paste capabilities.
Also, the GnuPG port for Windows will not properly
communicate with keyservers under Windows NT --
although it is rumored to work with Windows 98/ME.
There are some add-on tools for using GnuPG with
windows such as GPGShell and WinPT.  These
tools sometimes have difficulties as they are not
quite debugged yet.  They will work on one computer
then have some problem with another computer.
They are both worth trying to see if you can get them
to work on your computer.  Generally the ability that
they will add is the capacity to work with drag/drop
and button pressing rather than requiring that the
commands for all operations be entered at the
command line.  They interface with the clipboard
when they are working right, allowing you to quickly
copy to the clipboard, decrypt, then paste back from
the clipboard.  Not quite the same level of integration
with Outlook that PGP 6 has, but effective.
There are some small differences in the capabilities
of PGP 6 and GnuPG with regard to encryption that
must (and can) be overcome in order to allow PGP
users and gpg users to interract.  First, PGP has
used the "IDEA" symmetric encryption algorithm
(which is patented) as its first choice for encryption
for many years.  Although "IDEA" can be added to
gpg easily, it is not included in the official release.
Your PGP6 keys will work with GnuPG, but they will
tell your contacts to use the "IDEA" algorithm when
encrypting messages to you.  Either add "IDEA" to
gpg or change your keys so that they specify "AES"
or some other algorithm in order to get PGP 6 to
send encrypted messages that you can decrypt.
Next, the GnuPG 1.0.7 release has some "options"
that I recommend using in order to enable effective
key exchange.  In order to keep this message
short, I'll save the options information for a later
De : Eva Herskovicova
Envoy√© : jeudi 23 mai 2002 14:42
√Ä : 'gnupg-users
Objet : Reguest
Dear gnupg,
I'm using PGP FreeWare version 6.5.1, installed under Microsoft Outlook for
encryption/decryption of e-mails. We are at about to replace this product
with another one. Is it also possible to install your GnuPG product under
Microsoft outlook with the encryptio/decryption fonctionnality for user?
Thanks in advance for your answer.
-----Message d'origine-----
De : gnupg-users-request
Envoy√© : jeudi 23 mai 2002 14:39
√Ä : e.herskovicova
Objet : Welcome to the "Gnupg-users" mailing list
Welcome to the Gnupg-users mailing list!
To post to this list, send your email to:
  gnupg-users
General information about the mailing list is at:
  If you ever want to unsubscribe or change your options (eg, switch to
or from digest mode, change your password, etc.), visit your
subscription page at:
You can also make such adjustments via email by sending a message to:
  Gnupg-users-request
with the word `help' in the subject or body (don't include the
quotes), and you will get back a message with instructions.
You must know your password to change your options (including changing
the password, itself) or to unsubscribe.  It is:
  ikaser
If you forget your password, don't worry, you will receive a monthly
reminder telling you what all your gnupg.org mailing list passwords
are, and how to unsubscribe or change your options.  There is also a
button on your options page that will email your current password to
You may also have your password mailed to you automatically from the
Web page noted above.
Gnupg-users mailing list

@_date: 2002-05-24 15:51:02
@_author: Leigh S. Jones 
@_subject: AW: gnupg encryption (Eva Herskovicova) 
I tested the gdata plugin yesterday and couldn't
make it work with Outlook 2000.
----- Original Message -----
Sent: Friday, May 24, 2002 6:09 AM

@_date: 2002-05-24 16:01:01
@_author: Leigh S. Jones 
@_subject: Question... 
Encrypting a large number of files is relatively easy.  Signing
and decrypting would be more difficult because that step
requires the entry of a password -- 1 password entry for
each file.
It's likely that your best solution would be to use winzip to
bundle all of the files into a zip file, then sign and encrypt
the whole bundle at once.
The brute force method for encryption is:
dir /B > [filename]
Use a text editor on [filename] and turn it into a batch file
that does your encryption.
Believe it or not, on gnu-Linux systems and most Unix
systems you can condense all of those operations into
a little batch file that you could use over and over again.
But it's difficult on Windows systems because there is
no "args" command on the Windows command line.
On a computer over which you have complete control
(complete physical security) it is possible to set the
password on the key to a blank (zero length) password
and do the signing or decryption without re-entering the
password.  Then quickly change the password back.
Some of the features of WinPT allow you to do a
multiple file sign or decrypt with a single entry of the
password.  It's limited to perhaps 10 files at a time
for the present or else it crashes.
On PGP 7.03 Freeware you can do this by setting the
password retention time .
"Ghosty"  wrote in message

@_date: 2002-05-24 16:08:02
@_author: Leigh S. Jones 
@_subject: GPG for XP? 
Have you got a machine to test it on?
We'd all like to hear.
Chances are that it will work perfectly -- except
that there would be problems reaching keyservers
just as there are in WinNT and Win2K.
GnuPG doesn't work with Office XP, because it
doesn't try to...  but it works on files.  Simply
save the file as text and run gpg on the file.
----- Original Message -----
Sent: Thursday, May 23, 2002 3:28 PM
Does GPG run under Windows XP? Will it work with Office XP? I searched
the GnuPG archives for an answer to this, without luck. Please CC to
my address, as I am not subscribed to the mailing lists.
Thanks in advance.
Milton F. Lopez
Manager of Information Systems
Inter-American Tropical Tuna Commission
8604 La Jolla Shores Drive
La Jolla, CA 92037
Tel: (858) 546-7041, Fax: (858) 546-7133
email:  Web: Gnupg-users mailing list

@_date: 2002-05-24 18:45:02
@_author: Leigh S. Jones, KR6X 
@_subject: AW: gnupg encryption (Eva Herskovicova) 
Thanks!  That did the trick.
----- Original Message -----
Sent: Friday, May 24, 2002 08:09

@_date: 2002-05-25 02:55:01
@_author: Leigh S. Jones 
@_subject: --command-fd 
Note that stdin is not the command line.
Your program has paused waiting for you to enter a password.
If you want the password to be read from stdin, you need to
pipe it into gpg on --passphrase-fd 0 (stdin).
----- Original Message -----
Sent: Friday, May 24, 2002 5:42 PM
     trust: -/u

@_date: 2002-05-25 06:54:01
@_author: Leigh S. Jones 
@_subject: some more doubts (Aditya) 
My personal opinions below.  Your mileage
may vary.
Your top choices should probably be:
For Linux:
gpg 1.0.7 for Linux with appropriate add-ons
For Windows:
gpg 1.0.6/W32 with WinPT and IDEA
add-on for Win32 for international users and
corporate (commercial) use in the US (without
IDEA)(upgrade to gpg 1.0.7/W32 when
available at   The gdata
plug-in for Outlook is growing on me, but
doesn't form a complete GUI package.
PGP 7.04 Freeware (=7.03 plus two hotfixes)
if you are in the US and are a non-commercial
(home) user.  If you can find it.  Many will go
for PGP6.58, because there are free distributions
with source code available.  This software
is a pretty slick Windows package, where gpg
is primarily a command-line tool with the front-
ends (graphical user interface add-ons) in need
of a little polishing.
For DOS:
PGP 2.6x for MSDOS
DH/DSS keys are presently in vogue; RSA
(v3 or v4) are thought to be somewhat
outdated by many, although this is not really
related to the security of the cipher.  The
sha2 module won't get you much
improvement in functionality unless you are
anxious to test interoperability with that
hash experimentally.  Some European
versions (ckt) of PGP support it, but you
won't get anything encrypted or signed using
it unless you really ask for it.  The 8192 bit
key is overkill.  Using a key like that only
means you won't have compatibility with
anyone else.  I have a 4096/1024 DH/DSS
keypair and even that is overkill for this
----- Original Message -----
Sent: Friday, May 24, 2002 6:29 PM
download for

@_date: 2002-05-26 17:51:02
@_author: Leigh S. Jones 
@_subject: photo in gpg key (vedaal) 
I've seen this "temp files" issue before myself.  There are
a number of ways to bring up the temp files error
message.  I don't know how to overcome it.  It may be
a problem built into the application by the compiler.
----- Original Message -----
Sent: Sunday, May 26, 2002 7:20 AM

@_date: 2002-05-27 03:55:01
@_author: Leigh S. Jones 
@_subject: photo in gpg key (vedaal) 
I'd been attempting to use Internet Explorer as the
photo viewer, and yes, I'd included the option
--photo-viewer (with various parms) in my options
file.  GnuPG always answered that it was having
trouble opening the temp file, and always seemed
to know where the temp file was supposed to be
written (as defined in my environment variables).
The photo was not the only example of GnuPG
having problems with temp files, either.
----- Original Message -----
Sent: Sunday, May 26, 2002 2:42 PM

@_date: 2002-05-27 17:46:01
@_author: Leigh S. Jones 
@_subject: "--honor-http-proxie error" 
Go ahead and delete the "--honor-http-proxy" line by placing a pound sign in front of it like this:
# --honor-http-proxy
or change it to:
--keyserver-options honor-http-proxy
Then we'll have to find out what's missing on line 123.
----- Original Message ----- Sent: Saturday, May 25, 2002 12:49 PM

@_date: 2002-05-28 03:18:02
@_author: Leigh S. Jones 
@_subject: several questions about gnupg 
GnuPG will do this for you, but you must create the
key database directory with empty databases first.
First, create the ~/.gnupg_alternative directory,
then "touch ~/.gnupg_alternative/pubring.gpg", "touch ~/.gnupg_alternative/secring.gpg", and just for good measure "touch ~/.gnupg_alternative/trustdb.gpg", and "touch ~/.gnupg_alternative/groupdb.gpg".
Now go ahead and type your command.
Oh, gpg can create the basic database files for you gpg --homedir ~/.gnupg_alternative --list-keys (error messages follow)
gpg --homedir ~/.gnupg_alternative --list-keys (no error messages follow, just an empty listing)
----- Original Message ----- Sent: Monday, May 27, 2002 1:36 PM

@_date: 2002-05-28 16:14:02
@_author: Leigh S. Jones 
@_subject: Problem / Question with GnuPG and GData Gnu Pg Plugin with Windows 2000 Terminal Server 
I don't have gdata plugin on this computer to
experiment with although I've got it on a
computer at work.  Your question is one that
points up the weakness of Windows vs.
Unix-like systems.  If you were using Win9x
or ME you'd be out of luck.  With NT/2K/XP
there are some things you can try.
First thing to try is:
use environment variables
In NT/2K/XP each user has a different set of
environment variables and a set of unique
registry values (current user).  To set the user's
environment variables you go to  and enter values.  Choose
something like: GData_Dir
Then put %GData_Dir% in the slot in gdata.
More if that doesn't work...
----- Original Message -----
Sent: Tuesday, May 28, 2002 6:10 AM
separatly ?

@_date: 2002-05-28 20:42:02
@_author: Leigh S. Jones 
@_subject: Keypair created with gpg 1.0.7 
This question sounds like it could be about the
--simple-sk-checksum option.
For improved security, gpg has a new database
storage format for the secret key.  Exported keys use
the new format, which is incompatible with older gpg
versions as well as with PGP.  To make your exported
keys PGP compatible, you need to store the keys in
the database with the --simple-sk-checksum option
enabled.  You could put the simple-sk-checksum into
your options file if you are working on a computer
that you have complete control over including physical
The secure way to work with this is to:
1) gpg --simple-sk-checksum --edit-key [keyID]
Command> passwd
Re-enter your password without changing it.
Command> save
2) Export the key.
3) Edit and re-enter your password again, this
time without the --simple-sk-checksum option.
This puts you back into high security mode.
Treat the exported secret keys carefully and don't
allow them to be compromised.  Some people
prefer to change the password to a blank.  Then they
don't need to use the --simple-sk-checksum option.
I think this is a real security problem.
----- Original Message -----
Sent: Tuesday, May 28, 2002 7:32 AM
key and
nothing, just
Eudora+PGP-plugin, as I
only for

@_date: 2002-05-28 22:32:02
@_author: Leigh S. Jones 
@_subject: Keypair created with gpg 1.0.7 
Well, because I've overcome some of the obstacles and managed to
exchange keys between gpg and PGP (both ways), you can bet that
I've got some ideas.
First, here is an options file that I use with gpg 1.0.7 that
allows the exchange:
s2k-cipher-algo 3des
s2k-digest-algo sha1
compress-algo 1
load-extension idea
keyserver Frankly, the openpgp and pgp6 options override each
other plus the options that appear in front of them, and
the simple-sk-checksum is only there for the key
exchange.  I wouldn't use it if I thought that my
computer might be "visited".  There are probably other
overrides occurring.  In the US "load-extension idea"
option wouldn't be used at work.  And, it is necessary
to --edit-key [keyID] then "change" passwords and
save in order for the deprecated checksum to be used.
I also was successful with "s2k-cipher-algo aes" --
the "s2k-cipher-algo 3des" option was chosen in a
search for compatibility with Peter Guttman's CryptLib
3.1, with which I am playing.
Give these a try, then let me know if you are still
----- Original Message -----
Sent: Tuesday, May 28, 2002 12:52 PM
exporting the
method I
exporting and

@_date: 2002-05-29 01:36:02
@_author: Leigh S. Jones 
@_subject: gpg keyservers allowing photos in key-id's 
Most of the keyservers share the key contents among themselves.
If you add a key or make a change in your keys such as changing
encryption preferences or adding signatures (including photos and
other user ID's) then your changes will spread to the others in time.
If you want to find out if photo ID's are being deleted from keys
by a given server, see if you can find my photo ID key on the
----- Original Message -----
Sent: Tuesday, May 28, 2002 12:39 PM

@_date: 2002-09-23 18:53:01
@_author: Leigh S. Jones, KR6X 
@_subject: What is wrong here? 
This probably means that Erwan Gaugain is out of the office.
----- Original Message ----- Sent: Monday, September 23, 2002 09:48
