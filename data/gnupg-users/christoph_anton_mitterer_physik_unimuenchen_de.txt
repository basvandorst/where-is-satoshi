
@_date: 2008-04-15 21:27:26
@_author: Christoph Anton Mitterer 
@_subject: How trust works in gpg... 
Nicely illustrated,.. but let me please add (I know of course that _you_
know this) that the SIG is made only over the KEY+UID data,... thus the
keyholder can happily change his SELFSIG whenever he wants without
loosing the SIG's.
Best wishes,

@_date: 2008-04-15 23:16:34
@_author: Christoph Anton Mitterer 
@_subject: How trust works in gpg... 
Dear David.
Hm in my opinion this depends on how the User ID packet type is
interpreted (I'll try discuss that on the WG list in some days).
If it is actually only an ID in the sense to clearly differentiate all
keys I think the name is actually irrelevant, as names always have
But in that case the User ID packet type should be change (of course
this is heavily incompatible) to only contain an unique identifier like
an email adress, perhaps even DNS names, or UUIDs.
And the Name should be moved to a user attribute package.
You see what I mean? I consider the ID (which is by the meaning of the
word just something to differentiate objects) as a different class of
information than user attributes (like his name, birthday, birthplace,
or his picture).
Ok now back to the beginning: When the name in the UID would be just a
cosmetic addition to the actual ID (the e-mail address) I'd say it's
irrelevant if it's complete.
But if it's interpreted as Name + e-mail of a person, I think one should
only certify the whole name.
With a certification a signator says  is the keyholders name,
but in my case my name is neither "Christoph Mitterer", nor "christoph
mitterer", nor "Chris Mitterer" it is (even from a legal point of view
"Christoph Anton Mitterer".
See my point? I consider missing information as grave as wrong
Each signature on a file or email would not validate if I simply remove
something from the mail.
Best wishes,

@_date: 2008-04-16 01:19:17
@_author: Christoph Anton Mitterer 
@_subject: Miscellaneous questions 
Dear David.
I first must admit that it was my idea,... to use the preference
subpackets that way (I mean that they should only represent the
preference of the user).
But I also agree that this is not really implied by the standards (I'll
suggest the WG to consider a change of this), but on the other hand:
That would support my idea that it's only the user preference.
preferred listed first.  It is assumed that only >   algorithms listed
are supported by the recipient's software. That just says that no
algorithms are listed which the implementation does _not_ support.
While this is a good decision for the average user, it should not be
forbidden to list an algorithm, even if not supported by one's own
implementation. But it does not say that it has to contain the
must-have algos. Thus I think that my idea of the meaning of those
packets is not only possible, but (because of "Symmetric algorithm
numbers that indicate which algorithms the key holder prefers to use.")
even logical.
But of course there are the notes at the end which (in my opinion) lead
to the current usage of those subpacktes:
I think this passage is very strongly influenced from a developers view:
?Tacitly (implicit) at the _end_ simply says,... by putting 3DES at the
end we automatically have a fallback if no other algorithm is found,
without the need of any code.
What it all comes down to is, I agree with you that this section is a
hint for your cited use ("It contains what the user prefers **among the
algorithms that his implementation supports**."), but I still think that
my idea would be a cleaner approach as it separates different things.
I'll suggest this to the WG.
Even if those subpacktes would be used in my suggested way, each
implementation would know "Nanana, 3DES is a fallback, so in each case I
can find my algorithm match", but in addition to that a user could force
his implementation (via a non conforming switch) to ignore that fallback
stuff, and just look at the preference. If he'll have problems with this
(interoperability) it's his own problem.
And of course each implementation should (at least for the average user)
allow only to add algos that it supports (or at least make some heave
noise if the users decides to add unsupported algos).
What do you think?
While I don't want to disturb Herbert's questions I'm interested in
this, too:
Of course such a key might not work with some not conforming
implementations and is perhaps fools from that perspective. As far as I
understand, when the implementation fully conforms to the RFC this MUST
But I'd like to know it this leads to improved security or not:
If I understood it correctly all the selfsigs go directly over the
keymaterial (+UID or subkey material or so), right? As far as I
understood, e.g. SHA512 are considered to be better than SHA1 (meaning
it's not "so easy" to find collisions), right?
So it should be more
difficult to attack an SHA512 selfsig than and SHA1 selfsig?
One might argue that an attacker could still try a downgrade attack but
then he'd have to hack the signature algorithm itself (e.g. RSA) which
is the same for SHA1/RIPEMD160/SHA512/etc sigs.
So the danger of a downgrade attack is equal for all of them, right?
But if we hope that nobody is able to efficiently hack RSA, then
selfsigs with "better" hash function should be more secure against
attacks, or did (and if so what) I understand this wrong?
btw: I assume that this is the reason why Herbert would like to revoke
his SHA1 selfsigs, because as long as they're valid,.. the whole idea
brings of course nothing.
Ah nice to know,.. the WG list will probably the right place to discuss
if some of the subpacktes should be allowed only on some types of
subpacktes. So I hope to see you there (in a few days or a week or
so ;) ).
Ok in fact this belongs also to the WG,.. but (apart from the fact that
I'm really unsure if I like the idea of must have algos at all - in each
case they have some very practical use) it would be an idea, to change
them or at least add some other must haves.
As Robert already pointed out,.. one big advantage of AES is its speed.
So i assume that a lot of especially embedded devices will only support
AES,.. so this might become the de facto standard (or it even is it
Thanks in advance for your insight :-)

@_date: 2008-04-16 01:31:41
@_author: Christoph Anton Mitterer 
@_subject: Miscellaneous questions 
Ok this I've already asked everything in my previous mail :-)
Ah yes,.. BUT *G*,.. therefore we have keyservers, right? The place
where we not only distribute keys but also revocations on them.
If you now say everybody can always simply strip off (of course he can
but each user can get them again from the keyservers) any revocations
the whole idea of revocation would be non-sense (does this word exist in
*G* I hope you won't finish V5 keys until I've finished my
review/suggestions paper,... and convinced you with lot of ideas X-D
Perhaps the most important ideas about fingerprints in advance: We
should try to ban the use of fingerprints inside of as many packets as
possible when it goes about certifying keys (I think currently this is
only the revocation key subpacket, and the MDC packet).
They should only be used by the user, so that he doesn't have to compare
the whole key bit by bit.
Such discussions are always difficult,... it's good if everybody keeps
in mind that (normally) nobody means any harm :-)
Ah... is this by intention? Or just not yet implemented? To say it
differently,.. which subpacktes or understood on the 0x1F signatures?
Best wishes,... should go to bed now,

@_date: 2008-04-16 10:46:08
@_author: Christoph Anton Mitterer 
@_subject: Miscellaneous questions 
Dear Robert.
I'm not sure if the meaning of tacitly is something different in English
as its translation in German, but as my dictionary lists implicit as
synonym it is probably not.
So while I actually couldn't care about, why is it wrong why I say the
binary representation doesn't have to contain it, but it is
automatically added internally?
However I became bored of this... either read again what I've posted
(that big section where I tried to describe what I consider to be
improvable in the RFC) understand it or not, I don't care.
I think I've actually said this at least one time, didn't I?
Yeah,.. that part was about how I could think that current handling of
that stuff came into existence. It was not a "That's what the standard
says" it was a "I think that's the original reason". It was just a step
to justify my proposed changed.
Specs are moving,... and implementations do so, too. And as others have
already pointed out, there are several places where gpg is
non-conformant (or at least doesn't care about some SHOULDs), e.g. it
allows you to export non-exportable signatures.
And if you argue that way "GnuPG should support a nonconformant
extension to the spec", you should also condemn reasonable things like
GnuPG's default minimum size of UIDs.
We all agree that this makes definitely sense, but it is as if gpg would
add it's own rule to OpenPGP saying, "UIDs should be longer than 5
While this is not forbidden, it is _like_ an addition to the standard.
Imagine I'd say "Oh lets add zz to the ISO 3166 list because it might be
(btw: I think that it's good that gpg allows this)
Best wishes,

@_date: 2008-04-16 10:57:38
@_author: Christoph Anton Mitterer 
@_subject: How trust works in gpg... 
Dear Werner.
Could you please find the time to explain this further? Why would it
only work with an encryption subkey (or didn't you want to exclude
encryption primary keys - I know they're not supposed to be used for
This sounds interesting.
What would I now from a signing challenge? What is it exactly? Ask the
peer to sign my challenge?
Any why wouldn't it work with the primary (signing) key.
I do the same. Just out of curiosity, would you suggest that those
certification-only primary-keys use just the "C" flag (I forgot the
hex-code) for the key usage, to explicitly denotes "this key is only
used for certification"?
I've already thought about this, but you might such a certification-only
primary not only to sign OpenPGP keys, but e.g. to "certify" (in a human
readable form" your own X.509 (root) certificate, or perhaps symmetric
shared secrets, or OTR keys for the Pidgin IM.
If that makes sense, it would depend on whether the RFC means with the C
flag a general certification use (not only OpenPGP keys/UIDs) or only
certification of OpenPGP keys/UIDs.
In the later case one should probably stick with "CS"
What do you think?

@_date: 2008-04-16 15:04:28
@_author: Christoph Anton Mitterer 
@_subject: Miscellaneous questions 
Hmm I wonder if it's worth the effort to publish a review on the RFC,
would ideas be rejected simply because they change the current way or
sight on things.
What do you think?
Well,.. I didn't claim that it would do it by default ;)

@_date: 2008-04-16 17:20:25
@_author: Christoph Anton Mitterer 
@_subject: Miscellaneous questions 
Dear David.
Of course not :)
Yes you're absolutely right, but I think sometimes one have to make
changes even at the cost of backward compatibility.
Some of the changes I'd like to propose to the WG won't probably break
the binary format of the standard at all, and some of my semantic
changes won't even really hurt if an older implementation won't apply
those changes.
But I also have some drastic changes that would really break the current
way, and that is...
... where V5 keys come into the game.
So a lot of my ideas are actually targeted to V5 keys and the "redesign"
of OpenPGP that will or at least could come with them.
I think that a big redesign would especially important because I feel
like OpenPGP would loose more and more ground to X.509, which I consider
broken by design due to its hierarchical model.
Hm could you please explain me why? I always thought that completeness
is also important correctness?
Yes it would,... it would actually break all existing keys.
I was not about coming here and say,.. change all current keys to that
model, but I meant, if we ever have to start from scratch or at least
nearly from scratch (and I thought that would come with V5 keys), we
should reconsider all the historical grown stuff.
Perhaps it would even make sense to provide a XML based OpenPGP
format,... and a binary mapping just for stuff (embedded systems,
streaming) where size matters.
If we'd actually made such a big cut, e.g. between V4 and V5 keys, that
would not necessary mean that both cannot life side on side.
A V4 key could still sign (with little modifications) newer V5 keys, and
a V5 key could still sign V4's or even V3's.
And over time,... V4's might be phased out, just as currently V3 keys
are being phased out.
Hmm my main intention is probably to get a cleaner, more aesthetic
design, but of course this is probably not enough to convince everybody
to make such a big cut.
But I think there are also several points where we could increase
security and tidy things up (e.g. the separation of ID's from
attributes, describing a user, such attributes could be his name town,
ZIP-code or even his ebay account).
And I would like to see a redesigned standard much more stricter and
definite. The RFC itself says, that it uses a "wishy-washy" style, I
think that could lead to security problems.
Yes,.. but keep in mind,.. most of my sugesstions are targeted on a real
redesign, if it comes to a cut (like due to V5 keys).

@_date: 2008-04-20 03:42:08
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
Well,.. partly,... (at least when speaking for myself).
Of course it makes sense to provide security fixes for the 1.x branch,
but I always wonder why you don't switch to the 2.x for the main
development branch.
And two branches like this always provide the risk that fixes,
enhancements, etc. are not correctly applied to both, and that bigger
differences arise.

@_date: 2008-04-20 03:45:46
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
Well,.. that's what nearly each version naming model implies.
Of course those examples are different, however for all of them it is
supposed to use the newer versions if possible.
That's even true for different branches like Apache's http server. One
should probably only use the 1.x branch if using the 2.x is impossible
for some reason.

@_date: 2008-04-20 12:37:07
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
Dear Robert.
Uhm what I mainly wonder is,... what is the main difference between
those two? Ok CMS support but that's not a difference between the shared
codebase, is it?
So in my opinion there are only rare cases where it's justified to have
different continuing branches (which are actually like forks). One
example is perhaps flex and flex-old..
Best wishes,

@_date: 2008-04-20 12:40:04
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
One? You think Windows* are operating systems?? ;-)

@_date: 2008-04-21 15:42:52
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
I think that renaming would actually increase the confusion.
It would be better to consider to slowly phase out the 1.4x branch.

@_date: 2008-04-21 15:55:59
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
If both should continue to develop (on a long time view) why not:
1.4 == GnuPG Classic
2.0 == GnuPG

@_date: 2008-04-21 16:39:57
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
Well I did not ask to mark it deprecated... it's also ok to maintain it
for some time (probably one or two years?).
But in the end we'll either have two different gpg's (which could lead
to a lot of problems, even security related) or one of the two will be
phased out.
Yes,... but than I'd say, that it's even better to "simply" have two
different branches and make some explicit statement like "normally
everybody (wo has no specific reason against) could use 2.x, it contains
everything the 1.4.x has and even more, it will also contain all
features of future developments".. than using two different names.
Something like "classic/plus" could even more confuse the average user.
On the other hand,... if we actually want to spread the use of 2.x we
should perhaps suggest the distributors to use the 2.x branch as default
(i.e. the package named gnupg) and provide 1.4.x as something like
Current practise (at least in debian) is
package: gnupg
executable: gpg
package: gnupg2
executable: gpg2
Ok,.. but to backport nearly everything would make little sense,... in
that case we could simply add the CMS stuff to gpg 1.4.x and drop 2.x
completely ;)
What if ECC or V5 keys will finally come? Should they be backported?
Uhm,.. the only problem that I could see here are possible build
problems with 2.x (are there any?).
Any I never asked to stop security support for the 1.4.x branch, I just
suggested to let the main development take place in 2.x and to
explicitly state this.
Best wishes,

@_date: 2008-04-21 16:44:29
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
I've already thought that...
Well I don't have a problem too. The only things that I wanted to
suggest when I've entered this thread was:
- Don't use different names for different gnupg branches.
- Set up some place (perhaps in the FAQ and even in the download area)
where you just say all that, namely: New features will probably go to
2.x, both will have the same security support, for the places where both
provide the same stuff (openPGP) both provide exactly the same
features... etc.
Best wishes,

@_date: 2008-04-24 02:59:40
@_author: Christoph Anton Mitterer 
@_subject: Miscellaneous questions 
Quoting reynt0 :
Well regarding my opinion on certifications,... I think the list an I  won't come to the same understanding in that issue (and probably lots  of oter questions, too).
Apart from any of our rules or suggestions or whatever you call it,  nobody can force users (the signers) to do anyting, as everyone can  sign what he/she wants.
What I wanted to do, was a suggestion, namely: signers should look at  the completeness of the. And if the signer thinks the name is  incomplete, he/she should (IMHO) not sign at all, or at leas use  perhaps a "lower" signature type (perhaps 0x12 or so; btw: gpg ignores  this currently, doesn't it?)
Of course we could even discuss what's part of the name?! What about  academic titles like "Dr." or "PhD", stuff from monarchy (OBE, Sir,  Dame, HRH, Prince, etc.) religious "titles" like "PP", "Cardinal", etc.?
Despite of the fact, that it's difficutl to decide what's a complete  name, I (= my opinion) think, that signers should have a look on  The reason: As a mathematicion I consider incompleteness as  incorrectness, that's even what OpenPGP (and actually every digital  signature system) does: If you "just" remove something from the signed  data, signatures won't validate.
If that reason is to far away from the real world for anyone: Just  think if VeriSign or some govermental agency would give you a  certificate or some ID card with an incomplete name, e.g. only the  family name, or the given name, or even just the first of the given  names? Or would it give you a certificate of some ID card with the  family name that you had before marriage?
It would probably not (for - in my opinion - obvious reason).
Of course this doesn not solve problems of ambiguity, but at least it  helps a little.
That's the same with family names: When they were introduced (probably  in the middle-ages?!) one reason surely was to solve the problems of  ambiguity of given names.
Today there are millions of Christophs,.. but is this a reason to drop  the family names?
What it all comes down to,... I didn't want to offend anyone on the  list, when writing my ideas opinions (thought that this list was open  for all ideas and so on).
If my tone was a little bit rude, I apologize myself, but it's  somewhat frustrating, that (nearly) the only answers I get consist of  arguments like, "nobody needs this", "this would break this and that",  "be more conservative", "at no way try to possibly clean things up or  give part of the standard a cleaner semantics"....
I think OpenPGP is quite widespread, neverless it might (this is only  a might!!) face extinction.
X509/CMS is used more and more in a lot of areas, even gnupg implements it.
I think the reason for this is simply that the hierarchical trust  model of X509 is much easier for lazy people (lazy in terms of  Of course OpenPGP is mightier in that way (a hierarchical model is  only a subset of its web of trust), but this won't save it on a long  term view.
As OpenPGP will always be more difficult to use (if you want to build  a strong web of trust) I thought that we should concentrate to really  improve and perhaps redesign OpenPG from scratch.
Stuff like clean separation between IDs and attributes and epsecially  _more_ attributes than just name, email and photo are really needed by  the industry.
However... it seems nearly impossible to me, that such improvements  will find consent. :( ... that's why I'm frustrated....
Best wishes, *hoping that he has nobody offended again or started a  senseless discussion (Robert?! ;) )*,
This message was sent using IMP, the Internet Messaging Program.

@_date: 2008-04-24 14:13:33
@_author: Christoph Anton Mitterer 
@_subject: Miscellaneous questions 
Yes of course,.. and lots of other things in other countries and
I don't think so, because it is unspecified (and probably unspecifyable)
what attributes are part of an identity. You could even say things like
your ICQ-number, your eBay-Account or else are part of your identity.
That's true, that's why I suggested to move the User ID packet away from
holding user attributes and use it as a real ID (something the "should"
be unique, like and email, DNS-address, a "unique" number or string,
etc. etc.).
Instead every attributes should go to the User Attribute package, which
could be easily expanded for stuff like titles, birthday, brithplace,
etc. etc.
Ok that's strange ^^. But I know that this happens in Germany too, but
only on "lesser important" documents. AFAIK the personal ID card
(Personalausweis), the Passport and the certificate of birth always have
to contain the complete name.
First of all,... the key ID is only the last 8 octets of the fingerprint
(IIRC)... and are much easier to forge than the fingerprint.
However,.. the neither fingerprint nor the key ID are anything that the
user/keyholder is described by (I mean in the real world).
Best wishes,

@_date: 2008-04-28 00:44:08
@_author: Christoph Anton Mitterer 
@_subject: Naming of GnuPG 
I think renaming gpg would have the disadvantage of breaking with a well
known and traditional name.
It could even more confuse users because they might think it's an
unofficial fork or it's not as good as the "real" GnuPG.
Despite of this I like you idea, because, as you argue, gpg2 has more
than just OpenPGP.
However I would prefer a name like gnucrypt (and perhaps as shortcut gc
or gnuc).
"suite" sounds like "more", e.g. including an email client or so ;)
Best wishes,

@_date: 2008-02-19 13:00:51
@_author: Christoph Anton Mitterer 
@_subject: /dev/tty problem and other questions 
I'm writing a support script for using dm-crypt/luks for root-filesystem
encryption, that will be used from an initramfs.
The iniramfs-scripts parse /etc/cryptab which specifies the file that
contains the key. It also allows to specify a so called keyscript, that
is invoked with the keyfile as parameter.
Those keyscripts are used to support stuff like
ssl/openct/opensc-encrypted keys and are expected to write (only) the
key to stdout.
Unfortunately there is no finished script to support gpg encrypted
key-files and I'd like to write one, but I have some problems:
1) When using a basic test-keyscript like
gpg --decrypt "$1"
and I boot from the initramfs I'll get the following error:
gpg:cannot open /dev/tty: No such device or address.
and gpg doesn't offer a prompt to enter the passphares
Of course I've googled around but I found no practical solution.
The --no-tty --pasphrase-fd 0 is not a solution as it will print the
password in cleartext.
read -s only available in bash but not sh.
Any ideas here?
2) gpg creates some files in ~/.gnupg which is not a real problem in the
initramfs but I'd like to avoid this, so no files should be written to
disk at all.
Is this fully achieved by using --no-options or do I have to use other
stuff like --no-random-seed-file or something else?
3) As everything written to stdout is used as key, I must secure that
only the decrypted data is written to stdout.
I know the --batch option but it doesn't specify if it prints anything
(except the decrypted data) to stdout and it also disables promting for
the passphrase (see point 1).
Of course error meassages should still be printed, but are they always
written to stderr? What about informal messages (like no mdc detected)?
Are they written to stderr or stdout?
4) As I cannot check the return value of gpg if the decryption succeeded
(the output from the keyscript is piped to cryptsetup) I must have other
means to check whether the decryption was successful. Any ideas here?
And what does gpg write to stdout, if the decryption fails?
Thans and best wishes,

@_date: 2008-06-23 10:31:05
@_author: Christoph Anton Mitterer 
@_subject: (possible) feature request ;-) 
I'm writing a suite of scripts and a little frame work for the use
cryptsetup/dm-crypt within an initrd for Debian
This also includes a keyscript to decrypt (symmetrically) OpenPGP
encrypted dm-crypt keys.
I'm suggesting that such keys have the for-your-eyes flag set (because
it shouldn't be necessary to write them to disk).
gpg seems to always write that warning message (that the message is for
your eyes only) even when writing to stdout (where stdout is a console)
or when piping to a file.
Switches like --quiet or so doesn't change this.
Is it already possible to somehow suppress this message (without
suppressing others like no-MDC or so)? If not would you consider to add
a simple option?

@_date: 2008-06-21 21:46:34
@_author: Christoph Anton Mitterer 
@_subject: gpg unusable from within an initrd 
I have to use gpg from within an initrd.
But whatever I do gpg complains:
Without --no-tty it complains that /dev/tty isn't there (gpg: cannot
open '/dev/tty': No such device or address)
With it, in complains "gpg: Sorry, no terminal at all requested - can't
get input"
It doesn't even work to redirect /dev/console to gpg e.g. gpg --quiet --no-greeting --no-default-keyring --keyring /dev/null
--secret-keyring /dev/null --no-options --no-random-seed-file
--no-use-agent --decrypt file    < /dev/console > /dev/console 2>&1
(no matter whether with or without --no-tty)
When using /dev/console as --passphrase-file this broke my whole system
and the keyboard ... I hat to kill it... :-L
Any ideas?

@_date: 2008-06-23 13:30:18
@_author: Christoph Anton Mitterer 
@_subject: (possible) feature request ;-) 
Of course,.. with "key", I didn't meant any OpenPGP key,.. and of course
not the dm-crypt key itself,.. but the encrypted dm-crypt key...
There is no "sender" (at least from the classic point of view)... I
simply use gpg's/OpenPGP's symmetric encryption parts (to be exact: a
symmetrically encrypted data packet, with symmetrically encrypted
session key packets).
I set the flag, that nobody writes the key to disk (by accident) if he
uses gpg manually on the encrypted file.
But when I decrypt it in the intended scripts I'd like to suppres the

@_date: 2008-06-23 13:31:50
@_author: Christoph Anton Mitterer 
@_subject: gpg unusable from within an initrd 
Doesn't this disable any interactions like entering the passphrase?

@_date: 2008-06-23 13:33:09
@_author: Christoph Anton Mitterer 
@_subject: gpg unusable from within an initrd 
That's what I do right now (ok I use ln -s instead of cp ;) ) but I
considered this only as a workaround... as this could lead to problems
(when someone tries to access (the real) /dev/tty in the meantime or

@_date: 2008-06-23 16:40:44
@_author: Christoph Anton Mitterer 
@_subject: (possible) feature request ;-) 
Yeah,.. I know all this.
Ok,.. I'll remove it manually..

@_date: 2008-05-14 23:36:48
@_author: Christoph Anton Mitterer 
@_subject: Linux crypto killer apllication 
gpg is not intended and for disk encryption, which requires special
techniques (good IV initialisation method etc).
Current state of the art is probably XTS which is supported by recent
linux kernles (sind 2.6.24 IIRC) and dmcrypt.
gpg can create keys with a key size greater than 4096 but you have to
patch it manually.
I think it would be nice if the expert mode allows to create keys of any
length (at least for RSA).
Best wishes,

@_date: 2008-05-14 23:58:17
@_author: Christoph Anton Mitterer 
@_subject: Linux crypto killer apllication 
IIRC, OpenPGP sets the IV to 0?
Of course...
That's not a question of practical cases,..
Every now and then we get posts where people ask for this... right?
So allow it in the expert mode, thus normal users will be prevented from
doing it and people who think that they might get additional security
can simply use it (at their own risk)...

@_date: 2008-05-15 10:21:34
@_author: Christoph Anton Mitterer 
@_subject: Linux crypto killer apllication 
Yes,... moreover,... there are parts of the cryptosystem that are / will
be weak someday,.. where increasing the keysize won't help (e.g. the
hash algos)

@_date: 2008-05-15 10:22:46
@_author: Christoph Anton Mitterer 
@_subject: Linux crypto killer apllication 
Well I'm not sure if we should too much trust in Germanys BSI ;-)

@_date: 2009-04-24 20:39:54
@_author: Christoph Anton Mitterer 
@_subject: Help with encrypting using my PGP Public key 
Not really,... but with eMail,.. there mail be "additional" standards
used (PGP for MIME).

@_date: 2009-08-12 01:41:10
@_author: Christoph Anton Mitterer 
@_subject: pool.sks-keyservers.net connection error 
For me, pool.sks-keyservers.net seems to work right now:
$ dig any pool.sks-keyservers.net ; <<>> DiG 9.6.1-P1 <<>> any pool.sks-keyservers.net
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 11901
;; flags: qr rd ra; QUERY: 1, ANSWER: 10, AUTHORITY: 2, ADDITIONAL: 2
;; QUESTION SECTION:
;pool.sks-keyservers.net.	IN	ANY
;; ANSWER SECTION:
pool.sks-keyservers.net. 21515	IN	A	194.97.110.154
pool.sks-keyservers.net. 21515	IN	A	202.125.41.160
pool.sks-keyservers.net. 21515	IN	A	212.12.104.213
pool.sks-keyservers.net. 21515	IN	A	213.133.98.226
pool.sks-keyservers.net. 21515	IN	A	76.184.75.94
pool.sks-keyservers.net. 21515	IN	A	84.16.235.61
pool.sks-keyservers.net. 21515	IN	A	91.121.167.18
pool.sks-keyservers.net. 21515	IN	A	94.142.241.93
pool.sks-keyservers.net. 21515	IN	A	134.93.230.21
pool.sks-keyservers.net. 21515	IN	A	193.174.13.74
;; AUTHORITY SECTION:
sks-keyservers.net.	15558	IN	NS	ns1.kfwebs.net.
sks-keyservers.net.	15558	IN	NS	ns2.kfwebs.net.
;; ADDITIONAL SECTION:
ns1.kfwebs.net.		15558	IN	A	213.161.224.2
ns2.kfwebs.net.		15558	IN	A	84.215.42.117
;; Query time: 17 msec
;; SERVER: 84.16.235.61
;; WHEN: Wed Aug 12 01:40:07 2009
;; MSG SIZE  rcvd: 276
btw: This is not the IP of pool.sks-keyservers.net, it's the IP of
keyserver.gingerbear.net,... and just one of many A RRs of
pool.sks-keyservers.net .

@_date: 2009-02-03 12:04:21
@_author: Christoph Anton Mitterer 
@_subject: Keyserver question...again 
Has ever anyone tried to convince the Athena guys at MIT, to switch
their server?
Unfortunately it's still very well-known...

@_date: 2009-02-05 21:19:03
@_author: Christoph Anton Mitterer 
@_subject: GNUPG and PKI compatibility (?) 
gpg is a PKI, or better said, it's a client to be used with an PKI (the
OpenPGP PKI, Web of Trust, or however you call it)
You probably mean the X.509 PKI. OpenPGP and X.509 are incompatible, but
I'd suggest you to use OpenPGP, as it's more secure.
Depending on whether you mean X.509 you could use gpgsm, which is also
part of GnuPG.
gpg/gpg2 -> OpenPGP
gpgsm -> X.509

@_date: 2009-02-10 15:07:21
@_author: Christoph Anton Mitterer 
@_subject: gnupg on celeron and atom cpus 
Does anyone of you have an idea whether it could make problems to use
gnupg on Celeron or Atom CPUs?
I mean could this have an effect on the PRNG, e.g. that the entropy is
worse? Or something similar?

@_date: 2009-02-11 12:59:48
@_author: Christoph Anton Mitterer 
@_subject: Hibernation and secret keys 
A good workaround is to use disk encryption (dm-crypt or similar things).
Best wishes,

@_date: 2009-02-11 23:02:35
@_author: Christoph Anton Mitterer 
@_subject: Hibernation and secret keys 
Why? This IS of course possible...
Of course you need something secure (e.g. an USB stick) to boot from.
And one should prevent Suspend to RAM, due to well known colling

@_date: 2009-02-11 23:04:56
@_author: Christoph Anton Mitterer 
@_subject: Hibernation and secret keys 
Yep,... you're right =)
It should be really possibly to make this very secure, but one has to
know what one does. (As always ^^)

@_date: 2009-02-12 18:40:22
@_author: Christoph Anton Mitterer 
@_subject: Hibernation and secret keys 
He just meant that one has to now what one does in order to do it really secure, if I understood him correctly.
Of course. The idea is that you can encrypt everything but the kernel
+initrd, which is needed in order to decrypt the partition (better said,
to set up the dm-crypt mapping).
And an USB stick could be always with you.

@_date: 2009-02-13 17:00:06
@_author: Christoph Anton Mitterer 
@_subject: Hibernation and secret keys 
What do you mean?
But even this data is sensitive, as one could attack you if he replaces your kernel with a hacked one.

@_date: 2009-02-16 12:47:11
@_author: Christoph Anton Mitterer 
@_subject: Hibernation and secret keys 
Of course this is possible,.. but perhaps only for someone more
powerful. (NSA could perhaps even replace your CPU with one that has an
additional OS in it with wimax or s ;).
But anyway, I think it tightens security a bit more,... as "normal"
attackers, like Mr. Mehdorn probably have only access to normal
The boot manager would also be on the USB stick.
But of course you're right one cannot prevent attacks,...
Anyway,.. I think it still improves security, for "normal" attacks.
I mean we're trusting this security by obscurity in so many areas? e.g.
OpenPGPs private key encryption. Who prevents the friendly NSA worker
from torturing you to death in order to get you passphrase?
It's always a matter of how much "effort" an attacker puts into his
Best wishes,

@_date: 2009-05-04 19:33:16
@_author: Christoph Anton Mitterer 
@_subject: New results against SHA-1 
Ah,.. I've always thought this would be already the case ^^
When will we see this new format?

@_date: 2009-05-04 19:34:58
@_author: Christoph Anton Mitterer 
@_subject: New results against SHA-1 
Ok,.. but most people do not exchange they key-data and signs it,.. but
just the fingerprint....
So in practice this does not only affect the revocation signatures, does

@_date: 2009-05-04 19:40:05
@_author: Christoph Anton Mitterer 
@_subject: Use other hash than SHA-1 
Is there anything else than the fingerprint for the revocation
signatures and MDC?
What would you suggest for existing RSA/DSA2 keys that always used SHA1
for their self-sigs and cert-sigs on other keys?
Should those be recreated with the "better" hash algo?

@_date: 2009-05-05 23:21:14
@_author: Christoph Anton Mitterer 
@_subject: Use other hash than SHA-1 
I'm not sure if this leads to the same discussion that we had some time
ago on the WG-list (about explicitly revoking previous self-sigs),...
but if a key has self-sigs with different hash-algos,... does this
"allow" downgrad-attacks or that like?
Even when they see, that the self-sig with the "better" algo, has a
newer creation date?
Would consider this critical :/
Best wishes,

@_date: 2009-05-08 01:17:33
@_author: Christoph Anton Mitterer 
@_subject: Use other hash than SHA-1 
Nothing specific,... it was my question, whether there could be any
attacks,.. using the fact, that an older self-sig with "weaker" hash
algo is available.
Oops,.. of course you're right,.. but then it's possible,... that e.g.
the newer self-sig (with the newer hash algo) contains e.g. a key
revocation, or something else security relevant (e.g. important new
As the older signature is not revoked,.. and the newer is not understood
(thus ignored),... this could lead to problems, or am I wrong?

@_date: 2009-05-18 16:35:29
@_author: Christoph Anton Mitterer 
@_subject: Changing usage of master key 
In principle it is possible by issuing new self-sigs, but gnupg  doesn't support this AFAIK.
This message was sent using IMP, the Internet Messaging Program.

@_date: 2009-11-23 13:25:00
@_author: Christoph Anton Mitterer 
@_subject: GPG self signature missing error 
You simply should not use such a key (without signed UIDs),.. except you
really really know what you're doing.
The key is probably damaged, or it might be even an attack.

@_date: 2009-11-23 13:33:07
@_author: Christoph Anton Mitterer 
@_subject: GPG self signature missing error 
I'm not sure, but it's likely that the older version did simply not
check for this.
Using a key with UIDs that are not signed by that key is dangerous, as
anybody could have attached such an UID to the respective key.
I could for example take your publich key, which has about the following
public key packet
UID packed
signature on the UID packet
...strip of the UID and signature packet and add my own (evil) UID. But
I cannot forge the signature on the UID, well not easily at least ;)

@_date: 2009-10-30 15:10:09
@_author: Christoph Anton Mitterer 
@_subject: entering both, password and message via standard input 
I have a case where I need to enter both, the passphrase and a message  (that should be decrypted), via standard input.
(Well, in principle it another non-interactive way for the passphrase  would be ok, too, but not --passphrase-fd and neither --passphrase  It seems that the following works:
printf "%s\n%s" $passphrase $message | gpg --passphrase-fd 0 --decrypt
So I assume the first line is taken as passphrase, removed, and  everything else as the message.
Is this the intended behaviour and is it kept like that in future  versions,.. or is it just working like that "by accident"?
Should I add other options, like --batch or --no-tty?
This message was sent using IMP, the Internet Messaging Program.

@_date: 2009-09-11 00:11:07
@_author: Christoph Anton Mitterer 
@_subject: howto secure older keys after the recent attacks 
Hi folks.
Wahhhh .... will loose all my signatures *G*
Ok seriously: ...
This is _really_ nice (especially as there are Debian packages for
it :-D)
Anyway,.. I'm really not an randomness-expert so perhaps some questions:
1) Is this already supported by gpg?
2) If so,.. where would gpg use it? Only for symmetric keys? Or also for
3) One problem with such devices is,.. that one can never know (well at
least normal folks like me) how good they actually are.
If this company would be evil (subsidiary of NSA or so) they could just
sell bad devices that produce poor entropy thus rendering our (symmetric
and asymmetric) keys, signatures etc. "useless". Right?
So my question is basically,..
If gpg would use this,... does it only improve the already existing
entropy and randomness of the kernel PRNG? I mean that gpg somehow
"merges" the different sources?
Or is it more or less a,.. either use the kernel PRNG or the hardware
If there is such a "merging",.. how well does it work? I mean imagine
the device would be very evil (or just stupid) and produce only 0's or
1's or series of 0101's or something like this.
Would the "merging" produce entropy that's still as least as good as if
one would just have the kernel PRNG? Or would it yield in weaker
(sorry for my non-expert terminology here ;) )
I really wonder if you'll maintain both versions forever :-) ;)
Happy crypting,
Grid Monkey

@_date: 2009-09-11 00:32:39
@_author: Christoph Anton Mitterer 
@_subject: howto secure older keys after the recent attacks 
Hi folks.
 Wahhhh .... will loose all my signatures *G*
Ok seriously: ...
This is _really_ nice (especially as there are Debian packages for
it :-D) Anyway,.. I'm really not an randomness-expert so perhaps some questions:
1) Is this already supported by gpg?
2) If so,.. where would gpg use it? Only for symmetric keys? Or also for
3) One problem with such devices is,.. that one can never know (well at
least normal folks like me) how good they actually are.
If this company would be evil (subsidiary of NSA or so) they could just
sell bad devices that produce poor entropy thus rendering our (symmetric
and asymmetric) keys, signatures etc. "useless". Right?
So my question is basically,..
If gpg would use this,... does it only improve the already existing
entropy and randomness of the kernel PRNG? I mean that gpg somehow
"merges" the different sources?
Or is it more or less a,.. either use the kernel PRNG or the hardware
If there is such a "merging",.. how well does it work? I mean imagine
the device would be very evil (or just stupid) and produce only 0's or
1's or series of 0101's or something like this.
Would the "merging" produce entropy that's still as least as good as if
one would just have the kernel PRNG? Or would it yield in weaker
(sorry for my non-expert terminology here ;) )
I really wonder if you'll maintain both versions forever :-) ;)
Happy crypting,
Grid Monkey

@_date: 2009-09-11 00:32:58
@_author: Christoph Anton Mitterer 
@_subject: howto secure older keys after the recent attacks 
Hi Robert.
 I thought it (and SHA1 fingerprints) would only be used in designated
revoker signatures, and MDC?
Have workings on an 4880 successor already started?
Perhaps some of you (David?) remember the discussion that took place
here and on the WG list some time ago about things like:
- how criticality and critical bit could be handled much stricter
- potential problems that arise because conforming implementation are
only recommended to ignore signatures of an older time (especially
- some other places where OpenPGP could (and for security reasons
perhaps should) be more strict and demanding to (conforming)
- Ideas for much broader use of attributes (different types of names,
birth-dates, -places, sex, etc. etc.)
So I wonder who's doing the (main) work for the writing this time? And
is there perhaps a wiki or so, where one could collect such suggestions?

@_date: 2009-09-11 11:20:32
@_author: Christoph Anton Mitterer 
@_subject: howto secure older keys after the recent attacks 
Nice nice :)
Apart from that,.. I've just read that they support even having more of
those devices added,.. for an even higher entropy bandwidth :D
_Not at all_ ... But the problem is,.. how could I know? Nor would I
have the technical knowledge to verify their implementation,.. nor the
elecetron microscope that I'd probably need for the verification.
Well,.. as soon as I got a list,.. I promise that I'll tell you ...
EXCEPT... I'm already detained in Guantanamo, Diego Garcia,.. or
something like this ... for knowing that list ;)
But in this case we might probably meet anyway,.. as _all_ people I've
ever had contact to,.. will be detained, too ;)
So this basically means:
Use such devices (as much as possible), they practically can only
improve security, but not weaken?

@_date: 2009-09-11 11:23:55
@_author: Christoph Anton Mitterer 
@_subject: howto secure older keys after the recent attacks 
I was watching Armageddon yesterday evening... so watch out what you're
saying ;P (and never forget you anti-meteor-shower-umbrella)

@_date: 2009-09-11 11:25:53
@_author: Christoph Anton Mitterer 
@_subject: howto secure older keys after the recent attacks 
Ok,... now you've made me unsecure :-/ (on whether to use such a thingy
- ok I've already ordered one ^^ - or not)

@_date: 2009-09-11 11:28:57
@_author: Christoph Anton Mitterer 
@_subject: howto secure older keys after the recent attacks 
I think David already pointed me to this one some time ago,.. but
they're not yet selling it, right?

@_date: 2009-09-11 12:37:03
@_author: Christoph Anton Mitterer 
@_subject: howto secure older keys after the recent attacks 
Yeah I know,.. and if you remember, most of what I've mentioned before
was already discussed at that list... but with no very big support ;)
So either these ideas were not improving strictness, security or
functionality (as with the additional attributes)... or people are just
to scared to break existing things or do not want to put a too high
burden on the implementations.
Anyway,.. don't believe that much (if any) of the above would be added
in (near) future releases,.. and I don't wanna start the same
discussions again ;)
Best wishes,

@_date: 2009-09-11 13:31:38
@_author: Christoph Anton Mitterer 
@_subject: workings of trust signatures 
I just wanted to fresh up my knowledge on trust signatures and have it
confirmed whether I've understood it correctly.
So first of all, level 0 TSigs are identical to normal non-trust-sigs.
[my self] --normal sig--> [person A] +-normal sig--> [person B]
                                     `-trust5 sig--> [person C] --normal sig--> [person D]
=> I only trust A,.. but nothing "below" A (at any level).
Level 1 TSigs would mean, that I signed that key (as with normal
signing) but in addition I also trust (with the specified value 60 or
120 e.g.) keys he signed (regardless of whether he used a normal sig or
a TSig for that.
[my self] --trust1 sig--> [person A] +-normal sig--> [person B]
                                     `-trust5 sig--> [person C] --normal sig--> [person D]
                                     `-trust5 sig--> [person E] --trust2 sig--> [person F] --normal sig--> [person G]
=> I only trust A, B, C and E,.. but nothing "below" B, C or E (at any level) because of my own level 1 tsig to A.
If I give higher levels of TSigs... the level is always the maxmium number of hops that can occur,..
But only further Tsigs on the keys I've signed with it,... will make this usable,.. so it cannot jump over normal sigs:
[my self] --trust6 sig--> [person A] +-normal sig--> [person B] --normal sig--> [person C]
                                     `-trust5 sig--> [person D] --normal sig--> [person E] --trist1 sig--> [person F]
                                     `-trust1 sig--> [person G] --trust5 sig--> [person H] --normal sig--> [person I]
=> I trust
- A
- B (because of my trust5 sig to A)
- not C as, B signed it only with a normal sig
- D
- not E or F (even though my own trust to A and the trust from A to D
were H, but D didn't sign E with a trust sig, the fact. that E signed F
with a trust sig is irrelevant, as there was a "hole" in the chain
- G
- H
- but not I, as G was only given a trust1 sig by A
Right so far?
So the chain of trust sigs can be "aborted" at any level, by a signature
"before",.. even if signatures that came even more earlier specified a
high enough level.

@_date: 2009-09-11 14:04:23
@_author: Christoph Anton Mitterer 
@_subject: workings of trust signatures 
One additional question:
Is it possible to give multiple trust signatures to the same subject,
but with different levels and trust amounts.
[myself] +-trust 1 sig / value=120-+> [some person or trustworthy CA] --trust 1 sig --> [some sub CA, which is "less" trustworthy]
         `-trust 2 sig / value= 60-?
So I'd allow the CA to be trusted introducer with full trust,.. but being meta-introducer only with partial trust.

@_date: 2010-04-26 12:18:26
@_author: Christoph Anton Mitterer 
@_subject: Elliptic curves in gnupg status? 
Nice to read. I was just about to reply, that it might make sense to
start implementation in gpg even if standardisation has not yet fully
Implementation probably takes quite some time and effort, and in the end
phase of standardisation processes there's usually not that much what
And I guess, the earlier ECC is available in gpg, the better.
Sounds reasonable, especially as people can already start to "collect"
signatures then...
What rough timescale do you expect to have ECC productively available in
gpg? I mean including security audits, well done tests etc.?

@_date: 2010-08-12 18:30:23
@_author: Christoph Anton Mitterer 
@_subject: policy url is not set on selfsigs 
Just found out, that a policy _is_ actually set when using
--set-policy-urls when creating a key (--gen-key)....
But it seems there is no way of changing that later..
I've looked through the code but could not find the place why it's
ignored when just e.g. changing the keyserver/prefs/etc.

@_date: 2010-01-08 20:34:04
@_author: Christoph Anton Mitterer 
@_subject: 768-bit RSA factored 
So let's hope the ECC draft makes it soon to be finished :)
... and implemented in gpg ;)

@_date: 2010-03-11 13:03:33
@_author: Christoph Anton Mitterer 
@_subject: Off-The-Record Email 
I'd personally prefer having a real OpenPGP plugin for gpg,...
Wouldn't that be the real solution?

@_date: 2010-05-01 02:02:59
@_author: Christoph Anton Mitterer 
@_subject: Crypto Stick released! 
I thought it would be exactly like this? OpenPGP SIM card + USB reader?

@_date: 2010-11-10 18:53:46
@_author: Christoph Anton Mitterer 
@_subject: changing usage flags on a primary key 
That's fairly easy by hacking the code and resigning.
Have a look the the archive, it was mentioned before how it works.

@_date: 2010-11-10 21:49:39
@_author: Christoph Anton Mitterer 
@_subject: changing usage flags on a primary key 
It was suggested before, to ad such functionality, but declined IIRC.

@_date: 2011-01-26 22:07:08
@_author: Christoph Anton Mitterer 
@_subject: Future plans for implementation of other algorithms 
I know this won't happen,... but I'd rather see a roadmap to phase out
Maintaining to branches is not only a big effort but poses also a
constant risk wrt security/etc.

@_date: 2012-05-22 15:39:04
@_author: Christoph Anton Mitterer 
@_subject: Some people say longer keys are silly. I think they should be 
This pops up over and over again...
limitation,... at least it's not enough to change the max size in the
code,... there seem to be several buffers one would need to enlarge in
order to make bigger keys.
Personally I'd prefer if gpg wouldn't have that limitation.
I know all the arguments against larger keys.... which is why I'd
suggest to enable larger sizes only when --expert is given and even then
Most people will get quickly distracted from large key sizes anyway when
they see how long their generation takes ;)
Nevertheless I guess it could even help to find awkward bugs or other
issues that may not appear with the "moderate" key sizes.

@_date: 2012-05-22 19:34:42
@_author: Christoph Anton Mitterer 
@_subject: Some people say longer keys are silly. I think they should be 
While this could happen, I'd guess it would be rather vice versa....
And eventually larger key sizes may become common (as it always happened
so far) and then we'd stumble across such problems anyway... better now,
where larger key sizes are not yet needed....

@_date: 2012-10-09 00:20:40
@_author: Christoph Anton Mitterer 
@_subject: RNG: is it possible to spoil /dev/random by seeding it from (evil) 
Hi David.
Long time ago, the following[0] ;)
I recently stumbled across that question again,... when I deployed
haveged on our faculty's HPC cluster...
So I've asked[1] around at lkml, whether a malicious (or just bad)
entropy source could spoil the kernel's RNG.
Ted Ts'o, who currently maintains that part said (see the thread) he
wouldn't know any way how that could be done, but...
... your reply seems to somehow imply that it could...
So he (and I) wondered for the reasons :)
Thanks a lot,
[1]
