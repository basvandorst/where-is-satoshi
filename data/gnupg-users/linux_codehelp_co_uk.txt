
@_date: 2003-04-08 22:25:02
@_author: Neil Williams 
@_subject: [Fwd: Re: HKP and firewalls] 
Hash: SHA1
To solve my original query, I've just changed
keyserver x-hkp://keyserver.linux.it
keyserver x-broken-hkp://keyserver.linux.it
and now auto-key-retrieve works fine and all keys (on public keyservers) can be retrieved.
May work for others.
More of Mozilla being just plain greedy for resources?

@_date: 2003-04-13 20:11:07
@_author: Neil Williams 
@_subject: trying to export the sender key 
Hash: SHA1
If you use --homedir, you need to specify a directory for it to use. If you've followed the defaults, it'll be in ~/.gnupg/ and you won't need --homedir Use ls -a ~
to list the entire contents of your home directory and look for .gnupg/
Replace recipient with the keyid (or leave blank to get all keys).
If you only have your key in place, use:
gpg -a --export > export.asc
This will create a text file called export.asc containing the public key.
Because of the --homedir setting, gpg is misreading the -a option as a

@_date: 2003-04-13 20:16:02
@_author: Neil Williams 
@_subject: Expiry Date 
Hash: SHA1
Edit the key and use key to select the correct one first.
$ gpg --edit-key richard
key 1
You can't select the subkey just from the expire command, you need the key command first.

@_date: 2003-04-20 14:19:02
@_author: Neil Williams 
@_subject: --verify --always-trust --with-fingerprint broken? 
Hash: SHA1
If you have a secret key available, rather than using --always-trust to drop the warnings, would it be better to locally sign the key used in the signature file?
I've tested it on local systems and I agree, if no secret key is available, the only way to get an accurate fingerprint is to omit the --always-trust and just put up with the warning.
$ gpg --with-fingerprint gpgme-0.3.15.tar.gz.sig
gpg: Signature made Tue 18 Feb 2003 18:27:09 GMT using DSA key ID 87978569
gpg: Good signature from "Marcus Brinkmann "
gpg:                 aka "Marcus Brinkmann"
gpg:                 aka "Marcus Brinkmann "
gpg:                 aka "Marcus Brinkmann "
gpg:                 aka "Marcus Brinkmann gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Fingerprint: 1411 9889 4E27 D44F 7084  F098 C0A4 CBB9 8797 8569
$ gpg --always-trust --with-fingerprint gpgme-0.3.15.tar.gz.sig
gpg: Signature made Tue 18 Feb 2003 18:27:09 GMT using DSA key ID 87978569
gpg: Good signature from "Marcus Brinkmann "
gpg:                 aka "Marcus Brinkmann"
gpg:                 aka "Marcus Brinkmann "
gpg:                 aka "Marcus Brinkmann "
gpg:                 aka "Marcus Brinkmann gpg: WARNING: Using untrusted key!
Fingerprint: 0E07 7F87 83C2 06C6 02FD  7EF7 9323 84EE BAB6 B3BC
$ gpg --fingerprint 0x87978569
pub  1024D/87978569 1999-05-13 Marcus Brinkmann      Key fingerprint = 1411 9889 4E27 D44F 7084  F098 C0A4 CBB9 8797 8569
uid                            Marcus Brinkmann
uid                            Marcus Brinkmann uid                            Marcus Brinkmann uid                            Marcus Brinkmann sub  2048g/C3AF90C1 1999-05-13
So who's fingerprint is:
Fingerprint: 0E07 7F87 83C2 06C6 02FD  7EF7 9323 84EE BAB6 B3BC
It's not one of mine!
744C 978D 7AB8 F27B 3BA6  C101 93B0 D5AF A897 FD02
4CD4 6644 C105 48ED CA28  EC36 8801 094A 28BC B3E3
$ gpg --list-keys --with-fingerprint | grep "744C 978D 7AB8 F27B 3BA6  C101 93B0 D5AF A897 FD02"
     Key fingerprint = 744C 978D 7AB8 F27B 3BA6  C101 93B0 D5AF A897 FD02
 gpg --list-keys --with-fingerprint | grep "0E07 7F87 83C2 06C6 02FD  7EF7 9323 84EE BAB6 B3BC"
No output.
(With 94 keys in the public ring including Marcus Brinkmann, Werner Koch etc. and most of those on this list who use signatures in email.)

@_date: 2003-08-28 20:36:02
@_author: Neil Williams 
@_subject: out of memory on encrypt 
=2D----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
I know that, but using GnuPG properly at least helps me to know that the er=
message is real rather than an artefact of an incomplete/broken installatio=
Sorry, bad excuse!=20
It's their key?! Not yours?! Generating your own key on the target system i=
s a=20
much better test of the success or failure of the installation.
Seriously, it'll be much easier to know what it really happening when the=20
GnuPG setup is known to be good. This in turn is easier to know if you are=
using GnuPG properly. Errors like the ones I pointed out don't inspire much=
confidence that the rest of the installation is workable.
So, to solve your out of memory problem: First things first.
1. Can you generate new keys, list all your keys, import and export keys OK?
gpg --gen-key
(You can always delete this test key later, so don't be too fussy about the=
settings, just see if the defaults work.)
gpg --list-keys
Download  to your home directory =
gpg --import neilwilliams.txt
gpg -a --export 28bcb3e3
Now use:
gpg -a  -e neilwilliams.txt
Gpg will prompt you for the recipient key. Enter your newly generated keyid=
and then a blank line. This way you can decrypt the file later to make sure=
your new secret key is working.
gpg -a -e neilwilliams.txt
You did not specify a user ID. (you may use "-r")
Enter the user ID.  End with an empty line:=20
Compare the output and repost.
I've changed to inline signature for this email so you should also be able =
save this to a local file and use:
gpg --verify filename
Could be down to problems in your installation - the above tests should hel=
resolve the doubts. If all the above work, please post more details of the=
Now I can't help with the specifics of that last one, but by running the ab=
commands, any error messages will give everyone a solid base to find the=20
solution because all the steps are reproducible.
I'm sure this can be resolved, it just needs a little procedure.
=2D --=20
Neil Williams
=2D----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.1 (GNU/Linux)
=2D----END PGP SIGNATURE-----

@_date: 2003-12-01 20:22:09
@_author: Neil Williams 
@_subject: Weird scenario garbage key on keyserver can it be removed? 
Pretty much. The only difference would be to make and print a revocation certificate for the new key immediately after generation (as the documentation does recommend). (And find a storage medium immune to third-party variability!)
Without the old private key, you've lost any signatures that you collected on it. You'd have to use normal keysigning procedures all over again. If you stick a notice on a personal webpage, email all regular GnuPG contacts, stick a line in your email sig about your new key and put it on biglumber, that should cover most users.

@_date: 2003-12-03 20:35:57
@_author: Neil Williams 
@_subject: GPG Recipients List 
It is on a keyserver:
However, in general, if you get unknown keys, it's worth checking the full text of the email - there are reasons why some keys aren't on keyservers and Denis has put a comment line in his GnuPG signature giving the URL of the (Together with the reasoning.)
Others use a header, much like the ones added for the list or by spam filters.
Unfortunately, Denis' key isn't linked to the largest strongly connected set, as used with Wotsap and others,  , so it always comes up as untrusted and always gets deleted when I tidy up my keyring! So I keep having to remember where to find a fresh one after importing the backup. It becomes a habit after a while to check the source of the message for all keys that auto-retrieve can't find. I really ought to update the selected keyserver though - using keyserver.kjsl.com would avoid the problem entirely.

@_date: 2003-12-04 00:00:54
@_author: Neil Williams 
@_subject: public keyring management practices (was: Re: GPG Recipients 
It's not as irksome as it might sound, I have a little bash script that several people here helped to create (it'll be in the archives) that uses --with-colons, cut and grep to delete lots of keys in a second or two. Managing a keyring by deleting keys one at a time ain't fun.
Lengthy trust rebuilds do slow down the email client with new keys and also slow down KGpg when it opens. However, another reason is refreshing keys - you can't be sure about a key not being revoked unless you refresh it so I refresh quite often. Certainly before I verify packages or encrypt messages to occassional contacts.
Probably my main reason is that I keep the majority of my keyring purely for WoT purposes. Keys that are automatically retrieved - although useful at the time - have to be trusted before I'll let them stay in the keyring - I just find it easier to manage. Plus, on this list as on many others, there are so many people who join for a brief while and then leave - what's the point of keeping those keys?
To be honest, I'm not too fussed about delays on reading mail - my spam filters take more time and I'm always doing something else at the time, so I can just check back later.
(Yet another little job to do)

@_date: 2003-12-04 23:43:46
@_author: Neil Williams 
@_subject: GPG Recipients List 
gpg is waiting for an end-of-file signal which can be input manually as Following the examples in the rest of gpg.conf, yes - drop the -- when putting the commands into gpg.conf.

@_date: 2003-12-04 23:50:22
@_author: Neil Williams 
@_subject: GPG Recipients List 
Many firewalls allow you to make a connection to any port when that connection is created from inside the firewall. Try it and see:
$ gpg --keyserver keyserver.kjsl.com --send-key KEYID $ gpg --keyserver pgp.mit.edu --send-key KEYID If not, use the options in gpg.conf to use the broken-http-proxy options (the syntax depends on which version of GnuPG you are running, older ones used hkp-broken:// (IIRC), newer ones use broken-http-proxy in the keyserver Alternatively, use one of these keyserver websites:
(But only one is needed - keyservers do synchronise).

@_date: 2003-12-06 16:29:37
@_author: Neil Williams 
@_subject: GPGME 
It's being run as a user and has access to user configuration files.
Try running the script exactly as given to init - you'd run it as an ordinary user, so if it works, it's the /home/ configuration that it's losing.
Which user is running init? If it's root, root will need user configuration - perhaps not the best solution!
Can't you pass the recipient on the command line?
(What are you doing that uses automated encryption in init anyways? Sounds a tad like you might be reinventing the wheel.)

@_date: 2003-12-06 16:45:55
@_author: Neil Williams 
@_subject: CPAN GPG-0.06 Help - Secret Key Unavailable 
--homedir ./.gnupg caused problems with previous scripts like this, have you tried specifying the path as an absolute path, fully qualified?
./.gnupg is relative - but relative to where?
have you set your own key to ultimate trust in the keyring?
Can you decrypt successfully at the command line?

@_date: 2003-12-08 22:26:45
@_author: Neil Williams 
@_subject: Key Status From Command Line 
I haven't got any revoked or disabled secret keys, but have you tried --list-secret-keys --with-colons

@_date: 2003-12-15 19:40:38
@_author: Neil Williams 
@_subject: Change comments? 
The comment is part of the identity of the user and changing the comment is akin to changing the email or the name - those who had signed that UID would have every right to be upset. Create a new UID with the new ICQ UIN if and when needed. Revoke the old UID and, out of courtesy, request that each signatory refreshes their copy of your key.
But any change would also destroy the worth of signatures on that UID - the UID would be untrusted and all signatories would be obliged to re-validate the changed UID. Far clearer to revoke the old one and add a new, then everyone can see exactly what you've done and why.

@_date: 2003-12-16 20:03:42
@_author: Neil Williams 
@_subject: known plain-text attacks 
I know that no cipher is 100%, but if it's not vulnerable to plain text, how does a second vulnerability affect the first? If it's vulnerable by some secondary means, it doesn't mean that the first means is also vulnerable - otherwise all Elgamal keys would be affected by the vulnerability in encrypt+sign Elgamal. It's all a question of matching the level of protection against the perceived level of the threat. I don't use GnuPG to hope to attain 100% - I don't think anyone does - I use it because it is sufficient protection for my needs in as far as any software-only protection can be sufficient. I still use other software and non-software methods.
(If you don't lock the front door to your house, GnuPG can't protect the secret key on your computer!)
Which means, what?
Don't use SMTP, CC/BCC + encryption?

@_date: 2003-12-18 18:02:14
@_author: Neil Williams 
@_subject: Windows network path in gpg.conf? 
Have you tried:
keyring "\\MyMachine\gpg-sandbox\test-pubring.gpg"

@_date: 2003-12-19 17:32:47
@_author: Neil Williams 
@_subject: trust problem 
The first is to do with the number of marginally trusted signatures and fully trusted signatures. I see the second as an arbitrary limit on just how far the first condition can be pushed. If a key has been signed by three people you marginally trust, it can be fully trusted but if those three people are already a long way down the chain from your key, it makes it less worth trusting the final key so there needs to be a limit.
Blake's key shows as fully trusted to Peter because Peter has signed it.
If Peter sets the user trust on Blake's key to full, then Elena's key shows as fully trusted. From there on, the trust wanes because the chain is too weak.
How would peter fully trust simon? There would have to be secondary signatures (and a secondary/tertiary path) involving other people outside the chain described. For GnuPG on Peter's machine to fully trust Simon's key, one of two things would need to happen:
1. Peter would need to sign Alex's or Simon's key. (At which point the whole discussion becomes pointless).
2. Simon's key must be already signed by other users whose keys are in your keyring and who have a second path back to your key. If Peter manually sets the trust on Alex's key to full, it still doesn't mean that GnuPG will fully trust the key - the user value only affects it if the user trusts it less than GnuPG would normally set. That's why there are two trust values, user and generated. A trust setting of f/m (user, full; generated, marginal) is still only a marginal to GnuPG. A trust setting of m/f, however, renders a key signed by the m/f key only marginally trusted even though GnuPG is capable of using a higher trust. (The user trust setting affects keys signed by that key, not the key itself - you are asked to specify how much you want to trust a key signed by this key but not with your own key).
Take a look at a real relationship:
(If this gets mangled, got to:
and enter
As it stands, just from the diagram, I cannot trust Adrian's key. However, there's more to the picture. Martin Krafft and Michael Banck become fully trusted keys because of other signatures (in my case Peter Palfrader's signature makes a difference) and therefore Adrian's key shows as fully trusted to me ONLY once I've imported Peter Palfrader's key and a few others involved in the secondary path. Setting strong keys like this to full trust enables Adrian's key to be fully trusted.
The difficulty arises because to keep it simple to explain we need to talk about straight chains but in reality trust is a web and those keys that are arranged in a straight chain with no branches/connections are neither representative nor particularly strong.
In real environments, Simon or Peter would have probably signed either Elena's key or Chloe's key or signed JohnDoe's key who has in turn signed both Elena's and Chloe's. Either way, it circumvents the 5 link rule.

@_date: 2003-12-19 17:40:42
@_author: Neil Williams 
@_subject: Symmetric Encryption Requirement 
Then don't set a passphrase on the recipient key? As long as you have adequate secondary security measures to protect the data once unencrypted with such a Depends how much of this stuff you'll be receiving but could it be done with a client box or some kind of non-native virtual machine then transport the data using any suitable means from a fileshare to a bespoke socket?

@_date: 2003-12-19 20:08:37
@_author: Neil Williams 
@_subject: Key Ownership 
The key has not been signed by one of your trusted keys so there's no way to be sure that the key really belongs to the person who claims to own it.
It's not an error, just a caution for you to note that you need to verify the ownership of this key by different means.
You need to arrange/attend some kind of meeting of other users where you can exchange key data, verify photo ID and confirm email addresses (via correspondence) so that you can sign their keys and they can sign yours.
In due course, more and more keys will then show up as marginally or fully Try a listing on biglumber (link below), contact a local Linux User Group (link from the dclug site below) and sign your own emails - that at least publicises that you do use GnuPG and that you would be interested in any keysigning events in your area.
More info on keysigning at the dclug site:
and at

@_date: 2003-03-29 23:53:01
@_author: Neil Williams 
@_subject: HKP and firewalls 
Hash: SHA1
I've had recent problems with a new ISDN router that doesn't use a particularly easy firewall setup. All other outgoing internet connections are fine (HTTP,POP,SMTP,SSH,FTP,DNS etc) and the firewall appears to be dropping other packets as expected - it's a basic deny-all firewall with no internet services available.
However, I cannot get a reply from any keyservers using --recv-keys. I can send to keyservers fine (and I can test that the keyserver received the update using an SSH connection to a remote server with GPG installed) and I can receive all keys IF I use a dial-up modem connection instead of the router, so I can't see that it is a problem with ~/.gnup/options.
I've tried opening port 11371 but I get very confusing results. Once in a while (and only once each time) I can get a single key through - as if it has been cached somewhere - but the other 99 times gpg just waits and waits and waits. e.g. output
$ gpg --verbose --verbose --keyserver pgp.mit.edu --recv-keys 0x28BCB3E3
gpg: requesting key 28BCB3E3 from HKP keyserver pgp.mit.edu
gpg: armor: BEGIN PGP PUBLIC KEY BLOCK
gpg: armor header: Version: PGP Key Server 0.9.5
I also use keyserver.linux.it
My basic problem is that the router doesn't use the familiar iptables format and doesn't provide a full listing of the traffic. I can't tell where the packets are being dropped. I've tried using IP addresses for the keyservers and using hkp://pgp.mit.edu etc. Does HKP only use port 11371? (Could it be trying to send data back to a different port?)
The router is a D-Link DI-304
At present I'm reduced to using an SSH connection to a remote server to do the download of the key then an -a --export to a file ready for download and then

@_date: 2003-05-03 20:42:01
@_author: Neil Williams 
@_subject: GPG 1.2.2 released? 
Hash: SHA1
gpg --recv-keys 57548dcd
You need to have the corresponding key already in your keyring on your own Use --keyserver keyserver.linux.it if you haven't got a default keyserver gpg --list-keys 57548dcd will then give:
pub  1024D/57548DCD 1998-07-07 Werner Koch (gnupg sig) and the verify will be able to check the signature.

@_date: 2003-05-05 22:05:03
@_author: Neil Williams 
@_subject: Unable to recieve public key 
Hash: SHA1
Add the broken-proxy command to the keyserver option:
keyserver-options auto-key-retrieve,verbose,verbose broken-http-proxy
(Doesn't this option use spaces instead of commas? I think it should read:)
keyserver-options auto-key-retrieve broken-http-proxy

@_date: 2003-05-06 00:13:02
@_author: Neil Williams 
@_subject: Unable to recieve public key 
Hash: SHA1
Some people don't send their keys to keyservers out of preference.
Some people use subkeys and other bits that some keyservers can't handle.
Either way, the keyserver reports no key data found.
If you do want the key, sometimes people who have experienced problems with their own keys on keyservers add details of their keys to their ordinary text signature (keyid, website location, etc.) for manual import into your own In previous cases, I've just emailed the person concerned asking if they could let me know the location of a website or name of a keyserver that holds their key data.
Once imported, you won't have any further delays on that key.

@_date: 2003-05-06 00:27:02
@_author: Neil Williams 
@_subject: hi guys, i need som newbie help... 
Hash: SHA1
To encrypt you usually need to have signed the recipient key.
Although I thought GnuPG would have said so rather than just saying the key wasn't found.
I can't check because your keys aren't on a keyserver.
$ gpg --keyserver keyserver.linux.it --send-keys 664212cf 29966025
See if it is signed using:
$ gpg --check-sigs 664212cf 29966025
You should see a self-signature AND a signature from each of the two keys:
e.g. on my two keys:
pub  1024D/A897FD02 2002-01-27 Neil Williams (laptop) sig!3       A897FD02 2002-01-27   Neil Williams (laptop) sig!        28BCB3E3 2002-07-01   Neil Williams (CodeHelp) pub  1024D/28BCB3E3 2002-01-27 Neil Williams (CodeHelp) sig!3       28BCB3E3 2002-01-27   Neil Williams (CodeHelp) sig!3       A897FD02 2003-01-14   Neil Williams (laptop) You might also have to edit each key to set the trust level. You have to set one of your keys (the ones with a secret and public key) to ultimate trust - so that the mail client knows who you are. Check also that you have set a keyid to use in the configuration of the mail client. Trust can be a hard thing to get to grips with so be careful not to set a high trust level or sign other people's keys without personal contact and verification. (Don't sign my keys, for example, the info above is not enough to verify a key).

@_date: 2003-05-10 22:20:02
@_author: Neil Williams 
@_subject: gnupg encrypted mail and malware/spam 
Hash: SHA1
This isn't often a problem - a signed email is not attractive as a vehicle of spam - those who send spam want to be invisible not verifiably identifiable.
Encrypting the mail even without signing it is a MAJOR workload for spammers who need to send tens of millions of emails to even get a few responses. Each one would need to be individually encrypted. Even if a spammer used every single key on a keyserver, it really is not appealing.
There are spam filters that can be run within the mail client on manual action - - post decryption. At present, it is fiddly but it's also not exactly a priority. (SpamAssassin is one of the filters that can be run this way. It is only Perl and it would be easy to adapt the code to cope. A script could perform the steps required for SpamAssassin to receive the original plain I really can't see that this could even be a problem worth the effort.
? spam only affects the network itself when a spammer uses your domain to pretend to send from - the bounces overwhelm the victim server. How does it matter if the spam is one form or another? It's the sheer size that matters. Encryption doesn't add that much to the total traffic.
As above: Encrypting spam individually to tens of millions of users is not a trivial task! Compared to just using a database of email addresses, I can't see that it is at all appealing for a spammer.

@_date: 2003-05-11 15:30:03
@_author: Neil Williams 
@_subject: gnupg encrypted mail and malware/spam 
Hash: SHA1
When the spam filters can still operate on the decrypted message, I can't see that it would succeed. Encrypted does not have to mean unfiltered. It just changes the location from server to user. With an open source email client, you could even adjust the program source code to do this without intervention - - in between decryption and display.
Your basic problem is user training. You seem frightened that if the server filters are bypassed that users will open any attachment, run any program and visit any site listed inside the email. If this is the case, your only real recourse is training. Alternatively, move to a more secure filesystem like Unix/Linux where the root and system files are simply not visible to users, so limiting any possible damage to user files. Even then, users will still have to be taught the consequences of casual and irresponsible behaviour.
You cannot protect the users from themselves and IMHO GnuPG should not be twisted into a means to protect the careless from their own mistakes / Just how are you going to implement that??? Bounce every message until you get a valid account?? There are personal spam firewalls out there that can work that way but these can prove unpopular.
You mean a Trojan? Or a root-kit? Then use an intrusion detection system, you simply cannot cover every possibility that someone may use, to deliberately install something like this, any other way. Email is not the only way to get rooted - I wouldn't even think it was the most common.
The threat is nothing to do with GnuPG. You seem to be talking about a general network security issue that is more related to keeping the OS up to date with patches and general system maintenance. You are in danger of blaming the messenger. Have you excluded all other routes? Instant Messaging? IRC? Deliberate introduction by users? Known exploits? 'A sophisticated attacker' will not want to rely on a method that, in turn, relies totally on a user decrypting a message and launching the attachment. There would need to be some kind of inside knowledge that a specific user would be likely to ignore all the basic security rules and willfully compromise their own system. An attacker willing to put in that much work is not going to stop if that method fails. Other attackers wouldn't even bother with the encrypted route, there are far easier targets on a system.
Probably because they don't understand it and / or are anxious to read all outgoing mail. (Note lack of smiley - some companies would love to filter all outgoing mail and probably already do.)
Then it sounds like they don't understand the issue. Personal encryption can be as much about prevention of identity fraud as 'subterfuge'. I sign emails because I don't want anyone else to be able to pose as me. I encrypt personal data so that it cannot be used to allow an attack to proceed beyond the compromised machine. (There may be other ways for an attacker to get to the next machine but it won't be by finding copies of passwords etc. lying around on the system.) Encryption can be part of your security and can be used to halt an incursion that has been made using other methods. If all users encrypted their passwords and other personal ID data with their own personal keys, it could be made much harder for attackers to move from one compromised machine to the next. (Assuming of course, that the original passwords are half-way decent in the first place and not going to be cracked with a simple dictionary attack.)
No one program or principle can give you security - the point is to target the weakest link. Only worry about encrypted emails when all other targets are removed. In the meantime, get an intrusion detection program.

@_date: 2003-05-11 21:30:02
@_author: Neil Williams 
@_subject: [Q] key vs subkey. 
Hash: SHA1
I still can't find your key though. Have you sent it to a keyserver?
(also unique)
The fingerprint is a summary of the key that is used to verify that the key I eventually download from a keyserver is the same key as you are using. Each key has a unique fingerprint. The KeyID is used to identify the key - like a name, smaller and more memorable than an entire fingerprint.
Pass. Someone else here will undoubtedly know that.
Do you mean export? You have already generated the public key. To export the key, use 0FEBCEC3. (same whether you are exporting to a file or to a keyserver (hint)).
You already said the ElGamal is for encryption.

@_date: 2003-05-15 23:11:02
@_author: Neil Williams 
@_subject: Opportunistic Encryption [Was: Keys not trusted] 
Hash: SHA1
But then it's no longer anonymous. The key can be assigned to a particular user or more likely from your scenario, from a particular email account which we ASSUME is in use by one person. With no details in the key description to identify one unique individual it is also possible (even likely) that the anonymous key in question has a blank (or well known) passphrase and is in use by many people all operating behind the same email account. A kind of corporate key - like the keys that already exist and being used by e.g. RedHat and Mandrake.
So seeing as this ability already exists, where's the need?
But just what happens when hundreds or thousands of these anonymous keys build up? There would be no way of correlating how many people could be using them. I would not trust anyone using an anonymous key - I'd be tempted to treat all messages signed with such a key as spam!

@_date: 2003-05-16 00:20:02
@_author: Neil Williams 
@_subject: Merging keys? 
Hash: SHA1
With all this talk of using a private primary RSA key and then public subkeys, I created a third key to test some ideas and I began to wonder if it is worth considering if keys can be merged. If both secret keys are available and both passphrases given, is there scope to merge two keys?? The carefully built-up signature list could be retained - perhaps the merge operation could ask which key would be the new primary and 'attach' the second key as a new subkey? or a new UID?
It could offer a way to migrate older keys with long signature lists.

@_date: 2003-05-16 00:20:36
@_author: Neil Williams 
@_subject: Trouble signing (was: Trouble exporting keys) 
Hash: SHA1
I haven't revoked any keys, just started with a completely new one, generated exactly as above. 4096 RSA, 1024 DSA and 2048 ElGamal.  (I added a photoid for fun too but generating that 4096RSA took an age!!)
pub  4096R/48C5F366 2003-05-15 Neil Williams uid                            [image of size 4569]
sub  1024D/F3C504D8 2003-05-15 [expires: 2004-05-14]
sub  2048g/E819E0B7 2003-05-15 [expires: 2004-05-14]
(A test key only - this will never reach a keyserver or be used on public Did you mean signing documents / emails with the DSA?
gpg -u f3c504d8 --detach --sign lug.sql
gpg --verify lug.sql.sig
gpg: Signature made Thu 15 May 2003 22:49:03 BST using DSA key ID F3C504D8
gpg: Good signature from "Neil Williams "
gpg:                 aka "[image of size 4569]"
That works.
But I couldn't get it to work for keysigning. gpg -u f3c504d8! --sign-key a897fd02
gpg -u f3c504d8 --sign-key a897fd02
Makes no odds:
pub  1024D/A897FD02 2002-01-27 Neil Williams (laptop) sig!3       A897FD02 2002-01-27   Neil Williams (laptop) sig!3       48C5F366 2003-05-15   Neil Williams sub  1024g/4D6D2952 2002-01-27
sig!        A897FD02 2002-01-27   Neil Williams (laptop) Note the new sig by the primary RSA key 48c5f366 not f3c504d8 as in the (test sig on this key later deleted, again without updating a keyserver.)
Did I miss a stage?
If not, won't this cause confusion with regard to keysignings? The KeyID everyone has gotten used to on the mailings wouldn't appear in the list of signatures on keys. GnuPG can make sense of it, but it doesn't look very intuitive in the listings.
If the KeyID is the only identifier used (for anonymous keys) it'll be even harder to understand key signatures.

@_date: 2003-05-17 00:30:02
@_author: Neil Williams 
@_subject: [Q] How do I revoke my old key? 
Hash: SHA1
Import the revocation certificate on top of the key you want to revoke and send the changed key. Import the certificate like any other key.
Make sure the old key to be revoked is still in your public keyring.
Import the revocation certificate into your public keyring. That will overwrite the old key with the revocation certificate. The key is now revoked and can be sent to keyservers - causing the copies on the keyservers to import the certificate and show as revoked.
gpg --import revoke.asc
gpg --send-key keyid

@_date: 2003-11-01 22:00:56
@_author: Neil Williams 
@_subject: Expired keys 
A colleague has just changed the expiry date of his key to extend from 31/10/3 to never.  (keyid 0x8f455606)
--check-sigs now displays:
sig!3     X 28BCB3E3 2003-02-03   Neil Williams (CodeHelp) If I try to re-sign the key I get:
Command> sign
"" was already signed by key 28BCB3E3
Nothing to sign with key 28BCB3E3
The key still shows as fully trusted.
This is understandable, on reflection, but a little surprising initially.
It leaves me pondering - the signature has expired (the X in the check-sigs output) but because the key that was signed has been changed, the validity of the signature is preserved because it's still the same key.
Is this the expected behaviour? Is there any need / method for updating the signatures to reflect the new expiry of the main key?

@_date: 2003-11-04 23:05:50
@_author: Neil Williams 
@_subject: NO_SECKEY error message - Help 
NO_SECKEY would mean that GnuPG can't find the secret key to go with the 61650832 public key. The GnuPG errors list this as an ElGamal encryption key which would be impossible to decrypt without the secret key - I can't verify as the key isn't on a keyserver.
<11833-005>: | | | [GNUPG:] ENC_TO 0C37FF8561650832 16 0
<11833-005>: | | | [GNUPG:] ENC_TO 235A043D1B0051EE 16 0
Do you mean to encrypt to two keys? This could be the problem.
Can you be sure that what you are seeing as decrypted output isn't the unencrypted data from earlier in the process? Can the process be split into two stages, so that the encrypted block is written to a file and then read in a second instance?
Alternatively, what you may be seeing is the successfully decrypted output from the other key 1B0051EE and the errors from failing to decrypt 61650832.
That's what leads me to consider that the adapter is correct and what you are seeing as decrypted output is simply the output from the original variable that has not been reset/unset once encryption began.
Note that there is no log of getting the passphrase of 61650832, only for You've given GnuPG the secret key and passphrase for 1B0051EE but it needs the secret key and passphrase for 61650832, hence the failure.

@_date: 2003-11-06 19:32:41
@_author: Neil Williams 
@_subject: gnupg for a multiuser system 
One installation, each user with their own keyrings, options and secret keys - that would be a default install. Each user then runs gpg to create their own data. Haven't tried it on Win2k though.
In essence, it becomes just another application that any user can load, they create their own data, save it to their own filespace and each user operates the software independently of other users. Or are you looking for some kind of shared keyring? That can be done but it would depend on exactly why this would be necessary - each user can easily import certain 'essential' public keys because the key data is so small in comparison to other document types. Sharing secret keys is not exactly recommended so if users are expecting to encrypt or sign then each will require their own secret data anyway. If you have a lot of 'essential' keys, you could simply host the ASCII armoured export file on an intranet site and update the file regularly.
That probably reflects the Linux perspective - all programs are multi-user unless specified otherwise!

@_date: 2003-11-07 23:28:55
@_author: Neil Williams 
@_subject: importing a secret key 
from man gpg
A ' after the letters 'sec'
                 means that the secret key is not usable (for example,  if  it
                 was created via --export-secret-subkeys).
Oops. subkey instead of secret key!
--export-secret-keys [names]
      --export-secret-subkeys [names]
                 Same  as --export, but exports the secret keys instead.  This
                 is normally not very useful and a security risk.  The  second
                 form  of  the  command has the special property to render the
                 secret part of the primary key useless; this is a GNU  exten-
                 sion to OpenPGP and other implementations can not be expected
                 to successfully import such a key.
                 See the option --simple-sk-checksum if  you  want  to  import
                 such an exported key with an older OpenPGP implementation.
 --simple-sk-checksum
                 Secret  keys  are integrity protected by using a SHA-1 check-
                 sum.  This method will be part of an enhanced OpenPGP  speci-
                 fication  but  GnuPG  already  uses  it  as  a countermeasure
                 against certain attacks.  Old applications  don't  understand
                 this new format, so this option may be used to switch back to
                 the old behaviour.  Using this this option bears  a  security
                 risk.  Note that using this option only takes effect when the
                 secret key is encrypted - the simplest way to make this  hap-
                 pen  is to change the passphrase on the key (even changing it
                 to the same value is acceptable).

@_date: 2003-11-08 15:11:54
@_author: Neil Williams 
@_subject: list problem 
You mean Evolution is attaching the GnuPG signature as S/MIME (just as this one is S/MIME via KMail) - I'm afraid last time it was discussed, Evolution deemed this unworthy of fixing and you're stuck with S/MIME if you continue to use Evolution. The alternatives are Mozilla+Enigmail, KMail or Mutt. (I think Mutt does inline - can someone please verify?)
Mozilla Mail with the Enigmail plugin defaults to sending inline but can verify both. KMail (without plugin) defaults to inline but can't verify S/MIME without the plugin. Once the plugin is installed, S/MIME becomes the send default but individual messages can be set to inline.
You can't change Evolution to send inline.
Sorry. Won't do any good for this problem.

@_date: 2003-11-08 20:36:06
@_author: Neil Williams 
@_subject: list problem 
KGpg encrypt clipboard contents works fine, but the query was on a signature problem. KGpg can sign the data, I'm just not sure that the process is worth the effort:
Write the email, cut the text and paste into KGpg editor. Click Sign, enter passphrase, cut the text and paste back into the email editor. Is it worth Let's see if it works, anyways:
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
This is a signed portion using KGpg

@_date: 2003-11-13 21:59:49
@_author: Neil Williams 
@_subject: Expired keys 
(Been away, hence the time-lag).
Yes, there is just one. (An old sig that didn't use the 1,2 or 3 trust indication - is that why it's got no expiry?) It's the only sig, apart from self-sigs, that is still unlimited expiry.
Checked and Updated again today.
No, I'm still getting:
already signed by key 28BCB3E3
Nothing to sign with key 28BCB3E3
I have two keys and I used delsig in the --edit-key shell to delete the signature made by my lesser-used key. I was then able to re-sign the key and that sig is now showing up on my own keyring as unlimited.
Is there a better way of fixing the expired sig for my main key?
What will happen if I send this key to a keyserver?
What will happen if I refresh this key from a keyserver?

@_date: 2003-11-17 19:29:32
@_author: Neil Williams 
@_subject: Matching a key with other emails 
Does Mozilla/Enigmail do this if the public key is not found? (Assuming you use auto-retrieve in GnuPG). Certainly, key 0xCFAFB3DC comes up as unknown in KMail as it doesn't seem to be available to keyservers.

@_date: 2003-11-17 19:43:05
@_author: Neil Williams 
@_subject: Matching a key with other emails 
(Devil's Advocate mode)
Then how can you be sure it is the same person? It could be a properly signed message coming from a dubious account using a compromised key! Your nicely encrypted reply (seeing as GnuPG only asks for a receiving key when encrypting, not signing) could be going to the wrong person entirely!
GnuPG can't tell the difference, even if you might. Hotmail is hardly going to help you confirm it is the same person. The whole point of the web-of-trust is that it is easy to setup these secondary UID's, each one can be signed individually and it provides a level of trust in not just the key but the email account and the physical person. You really should reconsider encrypting to an account that is untrusted. (That's what GnuPG is trying to tell you via Enigmail.)
It's up to the key owner to amend the key, GnuPG can't assume that something can be trusted when it's just as possible to be a compromised key.
Without verification by the person concerned, how can you be sure? If you've got partial verification (he says it's OK), why won't that person do it

@_date: 2003-11-17 19:52:53
@_author: Neil Williams 
@_subject: Revoking a key with revoke cert 
gpg --list-sigs keyid
or if there are a lot of sigs by keys not in your keyring,
gpg --check-sigs keyid The top line will indicate [revoked].
Or, if you edit the key, the trust level will be indicated with R at the end.
trust: n/r
Try with:
It's a revoked key on the keyservers that once belonged to a friend of mine.
0x738FECB0 hasn't been exported as revoked yet, I can't check using that.

@_date: 2003-11-17 21:13:27
@_author: Neil Williams 
@_subject: Matching a key with other emails 
Your reply prompted me to investigate and this is why I can't validate the gpg: Signature made Mon 17 Nov 2003 15:59:12 GMT using DSA key ID CFAFB3DC
gpg: key CFAFB3DC: no valid user IDs
gpg: this may be caused by a missing self-signature
gpg: Total number processed: 1
gpg:           w/o user IDs: 1
gpg: Can't check signature: public key not found
No valid UID's on the key -> invalid key -> although the key has been imported, it might as well not have been as GnuPG tells KMail that the signature cannot be checked.
The keyserver shows the key as:
Type bits/keyID    Date       User ID
pub  1024/CFAFB3DC 1999/02/03 Thawte Freemail Member           Key fingerprint =  C3 90 71 E2 87 05 FB F4  81 2D 74 C1 7B 32 5C 58  CF AF B3 DC sig       DE46F54F             Personal Freemail RSA 1999.9.16
No UID. (email address removed from quote).

@_date: 2003-11-17 21:18:47
@_author: Neil Williams 
@_subject: Matching a key with other emails 
I can't retrieve your key though!
Can't find 0xE7CF64B0 anywhere - valid or invalid.
No sign of a helpful email header or GnuPG comment, no website specified in the email sig lines, where are you hiding 0xE7CF64B0 ?
Please make public keys public - if you're going to sign emails, it really is pointless if the people wanting to verify your signed email cannot retrieve your key!

@_date: 2003-11-25 20:46:41
@_author: Neil Williams 
@_subject: Migrating keys 
I've thought about that before and I've put a page on the DCLUG website that outlines what I hope is a decent method. Now's as good a time as any to ask if others think it'll work!
Can I transfer signatures to a new key?
If a key that has not been compromised needs to be revoked (or is due to expire soon), it is possible to transfer signatures onto a new key by sending encrypted details to each signatory, provided you still have the passphrase.
1.	Send an email warning / reminder about the imminent replacement of the key (signed with the old key because that's the key that people will recognise) to each signatory.
2.	Ask each signatory to send a SIGNED and encrypted reply to the OLD key containing some quote / random text. It's important that the reply is signed so that you can trust the quote / random text.
3.	Sign each key with your new key as the emails come in and make sure that all the recipient keys are updated on keyservers.
4.	Send an encrypted reply to each signatory, including the appropriate quote email is signed with your NEW key. Don't revoke signatures made using the old key - they are still valid as long as the old key has not been compromised.
5.	Recipients can update their own keys from keyservers, verify that the new key signature is on their own key and check the fingerprint of your new key. Recipients can also revoke their signatures on your old key at this point. Many recipients would then be willing to sign the new key as there has been an encrypted transfer of data requiring both of the secret keys involved to be available to you alone.
6.	Once you've sent out all the replies to signatories, you can revoke the old key (or just let it expire). Don't delete it from your keyring or you'll lose the ability to read encrypted emails sent to you before the new key was I'll update the page if there are omissions.
I've used the method once with someone I know very well and it was our discussions that raised the idea for the page. I'd appreciate comments on how it'll work for signatories who are not in continued, regular, contact - people you met at expo's etc.

@_date: 2003-11-26 20:05:33
@_author: Neil Williams 
@_subject: Migrating keys 
As I suspected, it's usable in a situation where both parties still have non-email communication on an ongoing basis? This could be used to confirm or replace one of the steps - preventing someone attacking the email address from knowing the entire process.
Agreed. I'll rephrase certain sections and add extra advice - although I can't do much immediately.
I could also phrase it so that it leans towards doing at least part of the process at a LUG meeting - after all, that allows for full keysigning procedures that anyone would be happy to follow.

@_date: 2003-11-30 10:03:05
@_author: Neil Williams 
@_subject: Migrating keys (fwd) 
From man gpg:
      --fingerprint [names]
                 List  all keys with their fingerprints. This is the same out-
                 put as --list-keys but with the additional output of  a  line
                 with  the  fingerprint. May also be combined with --list-sigs
                 or --check-sigs.                  prints of all secondary keys are listed too.
$ gpg --fingerprint --fingerprint 28bcb3e3
pub  1024D/28BCB3E3 2002-01-27 Neil Williams (CodeHelp)
     Key fingerprint = 4CD4 6644 C105 48ED CA28  EC36 8801 094A 28BC B3E3
sub  1024g/AD3CB326 2002-01-27
     Key fingerprint = 911E 399A 4033 0310 6152  582F A006 27FC AD3C B326
If Bob adds a UID, there's nothing to say you should sign it, just because you've signed another UID on the same key. It needs separate verification - usually using an encrypted email sent to the email address in the UID asking for some random text to be quoted back in a signed reply. Same with a new subkey - you'd need to repeat verification if you want to be sure about it. If the old encryption subkey is still usable, encrypt to that, asking for the fingerprint of the new subkey, as above. If not, keysigning procedures start all over again.
You don't - necessarily. If you are concerned, try to contact him by either the previous subkey or by secondary means.
GnuPG can - it's all in the man page.

@_date: 2003-10-07 23:15:30
@_author: Neil Williams 
@_subject: WARNING: unsafe permissions on homedir 
chmod 700
Files inside .gnupg should be chmod 600
Also check the ownership of the directory, it should be owned by the same user that will be running gpg at the command line. man chown These don't usually need to be changed - it's how GnuPG sets itself up. You've been fiddling, haven't you!

@_date: 2003-10-13 20:34:34
@_author: Neil Williams 
@_subject: non root users 
Missed the --homedir option? gpg will create an empty .gnupg/ directory in the home directory of that test user. As the test user, do:
$ cd ~
$ ls -a
Probably an easier way is to import the keyring into the .gnupg folder, that'll allow you to set options in the conf file (which is also reset per user). The warning about secmem should be solvable - I'm sure others here will help with that but you would be best providing more information on exactly how you have used chmod.
If the keyring is < 500 keys, it's not a problem to have duplicate keyrings - one for each user. You can either add the --refresh-keys to the lexicon used by ordinary users or leave the keyrings alone if the keys don't change often.
It's not usual for everyone to need the same keys, that's why GnuPG runs with a lot of configuration and all keyrings dictated by that user alone. There's not much for root to do, once installation is complete.

@_date: 2003-10-13 22:01:34
@_author: Neil Williams 
@_subject: Why isn't this old and very trusted PGP key accepted by GPG? 
Looks like the exported file is missing some data, perhaps it's old?
There's a perfectly valid public key for that ID at:
It's only the Victor_A_Abell.pgp file that has a problem/corruption.
Check the fingerprint (shown on the first link above), you should find it's the same key.
If there are missing signatures perhaps, try importing the valid one and then the file one, sometimes GnuPG is clever enough to fix import problems when it has something to work with.
Otherwise, contact the person directly and ask them to export the key again.

@_date: 2003-10-17 19:16:02
@_author: Neil Williams 
@_subject: verify after export/import of secret key 
If you want to empty the keyrings by force using rm, just delete ~/.gnupg/pubring.gpg (and possible secring.gpg) - by deleting the entire directory you are losing all GnuPG options and (the bit that matters for your query) the trust database. The trust is not stored in the keys themselves, it is entirely dictated by user input. Set your key to ultimate trust and keys you have signed should show as fully trusted, keys signed by those people show as marginal. (3 marginals on one key -> full etc.) GnuPG can delete keys from the keyring itself - much more cleanly than using bash and rm. (Sledgehammer vs nut ?)
Because you deleted the only file that tells GnuPG which keys it can trust - even your own. Just because you generate a key, does not mean GnuPG should assume that you want to deal with the trust, it may just be a temporary / testing key.
rm ~/.gnupg/* That's what was wrong.

@_date: 2003-10-17 19:29:14
@_author: Neil Williams 
@_subject: How to decrypt multiple blocks in one text file 
I'm using similar authentication processes but can there really be a need for one single file? It's very inefficient by the time you have more than 20 users - it's not indexed, finding user 5 still means reading the entire file into memory. You've got a database backend, why not create a second table?
create table webformtable (id int(10) not null primary key auto_increment,
reference in(10) not null,
content text);
One record per user, use reference to link to another table where other details of that user are stored and query using:
select content from webformtable,datatable where datatable.id = reference and reference = $variable;
However, if you trust the server enough to receive and encrypt the data in the first place, you might as well store the data as cleartext above the public_html/ folder (out of reach of any inquisitive browser) and let the security of the server be your protection. After all, if I was to crack the server, I could delete the encrypted content or insert new values (the public key must be present for you to encrypt so I can use the same key to encrypt malicious or random data). With the server cracked, your authentication is lost and the need to protect the dataset (which sound awfully like username/password combos) is lost too - you can't protect data on the server once the server itself is compromised without encrypting all sensitive data, not just the identification strings for authentication.

@_date: 2003-10-18 00:36:41
@_author: Neil Williams 
@_subject: How to decrypt multiple blocks in one text file 
And as you describe, all sensitive data is being encrypted, OK.
Clearly you must retain the context of the data (each dataset distinct from all others with no overlaps or mixing) so I tried experimenting with ASCII vs binary outputs, various line separations/append operations with the same errors. I've also tried encapsulating multiple encryption blocks in a single email and only when it was MIME encoded could all blocks be decrypted.
The solution was to encompass the entire group in one single encryption block - in effect re-encrypt the encrypted data. I can't demonstrate it to you as you snipped some vital content from the first message and didn't sign it - so I don't have access to a usable public key for you to decrypt.
Note: Sending using the inline PGP function within KMail (which does not use MIME) does not allow decryption of the included blocks despite the overlapping encryption of the group. Only sending via S/MIME allows decryption of all blocks.
This is sample output from an S/MIME test message to myself using KMail and the OpenPGP plugin to create the MIME boundaries.
Encrypted message
Encrypted message
test2   person2  account2 amount2  item2
End of encrypted message
Encrypted message
test1   person  account amount  item
End of encrypted message
End of encrypted message
So it's MIME or some form of scripting to split the file on a known marker - the same principle for each.
I know that's not what you wanted to hear, but there it is.
S/MIME is no easier to implement in your situation than a perl script but at least it does still retain one file. Perl could split the file on the key block markers, output one complete block to the GnuPG::Interface module in sequence and build the decrypted file block by block. Either way, there's a reasonable amount of work involved in building the script and handling errors. ASCII armoured key blocks lend themselves to regular expressions but you might want to avoid using join() to make the block into a single line expression because of line end problems on decryption. Test for the begin block, check each line following for end block and output to GnuPG::Interface as one unit block.
I suspect that this is exactly how S/MIME decrypts the sample message - isolate each block using MIME boundaries and build the whole from the component blocks.

@_date: 2003-10-19 21:56:40
@_author: Neil Williams 
@_subject: gpgv vs. gpg --verify 
trustdb is from editing the trust on the key. gpg --edit-key
I'd expect it to be related to this part of gpg.conf:
# If you have more than 1 secret key in your keyring, you may want to
# uncomment the following option and set your preferred keyid.
 621CC013
Just a guess.

@_date: 2003-10-31 21:38:30
@_author: Neil Williams 
@_subject: help needed desperately: gpg --decrypt waiting for EOF 
How are you passing the encrypted text?
If you use:
$ gpg --decrypt
then simply copy and paste the encrypted text in, then you must TELL GnuPG when the data is complete. It hasn't 'hung' it's 'waiting for input'. More precisely, it's waiting for you to say EndOfFile - EOF.
This stumped me for a while (and the answer is there in the archive but not in a form you might expect). GnuPG expects the EOF to be entered as:
To experiment, do the following:
$ gpg -a -r 58727399 -e
Now enter a simple test string:
testing decryption
End the string with Ctrl-D
GnuPG outputs a keyblock (in ascii armour because of the -a).
Now copy that block to the clipboard.
gpg -d
Paste the contents in, enter your passphrase when prompted.
Again, end the input using Ctrl-D
The encrypted test string will appear on the next line.

@_date: 2004-04-07 21:28:47
@_author: Neil Williams 
@_subject: Implementation questions 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Just specify more than one keyid on the encrypt command line:
$ gpg -ear keyid1 keyid2 keyid3 keyid4 keyidN
As atom hinted, you can specify recipient keys in gpg.conf and if you are in control of user gpg.conf files, as you claimed, you could specify the list Administrating this kind of system will require exponentially more input the more users you enlist.
Wouldn't an encrypted filesystem be an alternative?

@_date: 2004-04-09 12:26:37
@_author: Neil Williams 
@_subject: I have keys - now I want to encrypt a file 
Use the keyid for the recipient - what do you mean by keyname?
Matching by email address is possible but commonly ends up with more than one key available. e.g., I have two keys that would match my email address on keyservers and more that have not been used publicly. --encrypt-files is a special case:
from man gpg
The command expects the files to be encrypted
                 either on the command line or reads the filenames from stdin; each name must be on separate  line.  The
                 command is intended for a quick encryption of multiple files.
Normally, just use --encrypt or just -e
To send by FTP, it may be best to use ASCII armour and send as an ASCII The final command becomes:
$ gpg --recipient 0xDEADBEEF --armor --encrypt testfile
or just
$ gpg -ar 0xDEADBEEF -e testfile
Replace DEADBEEF with the keyid of the recipient, in my case 28BCB3E3.
Look for the keyid from this output:
$ gpg --list-key keyname
Unless the recipient is an automated script, it's best to also sign the encrypted file:
$ gpg -sar 0xDEADBEEF -r keyid
(to help your recipient have some confidence about the contents of the encrypted file).
You didn't specify a UID, you specified an email address that could match more than one UID or none at all.
Check the man page, learn how to specify a keyid.

@_date: 2004-04-14 22:13:58
@_author: Neil Williams 
@_subject: Problems importing public key 
You might be able to trust this file, but why should GnuPG? You've just imported a public key that has no relation to your own key, there is nothing for GnuPG to use to work out whether to trust the key. You comment that this is for sensitive data yet you seem prepared to take the key at face value. So all you really know about this key is that the email address matches the keyID. Is that enough? Can't be particularly sensitive data for encryption!
Oops. You've got the right key but something is wrong with the email.
Nothing, necessarily. There may be something wrong with the signed email If you import a new copy of the same key, it'll simply overwrite the old one. The only differences that will make any odds here are things like extra subkeys, extra signatures, extra UID's. If GnuPG accepts these two keys as the same, the public key in both copies is the same.
This is the separate trust issue. GnuPG cannot trust this key because you haven't verified the key. You would need to follow the keysigning procedure and then sign the key for GnuPG to be able to trust this key.
No, just that there is something that you haven't yet done.
Then you MUST verify the key properly. Usually, this involves meeting face-to-face to exchange GnuPG fingerprints and verify proof of photo ID AS WELL as verifying that the email address in the key is the right destination.
GnuPG cannot be expected to encrypt sensitive data if there no way of knowing if you are encrypting to the right person.

@_date: 2004-04-14 23:09:49
@_author: Neil Williams 
@_subject: Gnupg-users Digest, Vol 7, Issue 19 
At which point, all your effort in encrypting the transmitted data is lost! Everything that the server displays in the browser is sent in plain text - including the decrypted block!! Unless the block is decrypted locally, it will be pointless encrypting it in the first place! If you never encrypted it in the first place, the data would still be sent once in clear text, just like in your system.
The second problem is that the PASSPHRASE is sent in clear text too, so now the key is compromised too, or are you doing this over https:// ?
Umm, No. Sorry.

@_date: 2004-04-16 21:10:34
@_author: Neil Williams 
@_subject: Problems importing public key 
If his signed emails fail to verify, it's probably not the key that's at Can you view the same messages in mutt, Mozilla+enigmail or KMail?
Dennis' message on Tuesday 2:56:10 (Re: Use of public key servers) validates fine with key 0xF53BA904, he uses PGP/MIME to sign, like this one. It should validate in Evolution. (The signature is valid, but the key's validity is unknown - so I can't trust Dennis' key either.)
All messages on this gnupg-users mailing list in the last few months have validated in KMail - have any of mine not validated in your copy of

@_date: 2004-04-16 23:55:57
@_author: Neil Williams 
@_subject: Problems importing public key 
I thought the problems were with Evolution and INLINE - Evolution developers apparently said that inline sigs would never be supported by Evolution.
If PGP/MIME doesn't quite work and inline is unsupported, it doesn't look Your signatures have always verified perfectly in KMail and Mutt, like almost everyone else on this list. I've only had a handful of bad signatures and each of these was down to me fiddling with the maildrop features etc. because others were able to verify the same message OK.

@_date: 2004-04-18 00:46:32
@_author: Neil Williams 
@_subject: gpgme-smime.so not initialising in KMail 1.6.1 
I've got openssl and accessory packages installed and working on Debian sid (unstable) to allow other email clients to verify Thawte style messages, but II can't get gpgme-smime.so to initialise.
The message is signed, but the validity of the signature can't be verified.
Reason: Crypto plug-in "/usr/lib/cryptplug/gpgme-smime.so" is not initialised.
what might I be missing?
I had to create .gnupg/gpgme.conf as it didn't exist before.
It now only contains:
agent-program /usr/bin/gpg-agent
It doesn't seem like a KMail config problem, although it's only KMail that I've set to use this plugin. Should I transfer this query to the KMail lists?

@_date: 2004-04-18 20:33:08
@_author: Neil Williams 
@_subject: gnuPG: no valid OpenPGP data found 
You could check that the keyserver has actually accepted the key by using a web interface - that would prevent you losing the key.
What do you mean by local keyserver - does it synchronise with the other keyservers? Doesn't it have a web interface?
why? You've probably now lost the secret key too.
Yet another useless key on the keyservers that cannot be deleted or revoked!
This would only import the public key anyway - if you've generated this key, people searching the keyserver would be justified in hoping that you had the secret key for it!
So have you got the secret key stored somewhere because any keyserver will only ever return the public key.

@_date: 2004-04-22 00:30:40
@_author: Neil Williams 
@_subject: trust management script 
Just in case this is useful to anyone else:
(Replace 28BCB3E3 in line 11 with the keyid of your main signing key)
echo "Printing details of fully trusted keys that are set to FULL trust"
echo "but which do NOT carry your signature"
KEYS=`gpg --list-keys --with-colons | grep "pub:f:" | grep "::f:" | cut \ -d: -f5`
for check in $KEYS
        SIGS=''
        if [ "$check" ]; then
                OUTPUT=`gpg --list-key $check | grep "^pub"`
                SIGS="`gpg --list-sigs $check | grep 28BCB3E3`"
                if [ -z "$SIGS" ]; then
                        echo "$OUTPUT"
                fi
        fi
I wrote it to check that I hadn't inadvertently set a key to fully trusted for verifying other keys when I hadn't actually signed and therefore verified the key itself. I worked on the idea that if I hadn't verified the key, I probably had never met the person behind the key and therefore I was unlikely to be able to make much of a decision on how carefully that person would verify someone else's key. (Not having had the chance to see them verify my own key.)
It could be used alongside --update-trustdb which catches those keys with no user trust setting but a full GnuPG trust value.

@_date: 2004-04-26 19:39:30
@_author: Neil Williams 
@_subject: Introduction 
No, but there's an archive and plenty of documentation on the website:
There is no single group key for all users, perhaps because new users are using new keys which, by nature, are untrusted.

@_date: 2004-04-26 22:28:18
@_author: Neil Williams 
@_subject: group key? 
To clarify: Personally, I don't see the point of a group key for a mailing list - it's generally unworkable, more than a little pointless and unnecessarily exclusive. Lists are meant to be open and openly archived. However, the question of a group key is wider than just a list. There have been discussions about corporate keys on this list before, a group key is a similar idea.
Or, more simply, a single database would keep a tally of current keyids and encrypt all messages to a vast list of keys using the same session key. Not surprising that this doesn't sound good. At least it removes the need for a distributed private key AND it allows for user additions and removals. You would be able to exclude old keys from decrypting old messages and allow new keys to decrypt old messages, however, re-encrypting archived messages to the amended group would be too burdensome, (being recursive and all). This would, in effect, simply be a group of keys (or key group), not a group key. GnuPG can already do this and has group functionality in place. I don't think the group was ever considered to be of sufficient size for an entire As has been discussed elsewhere on this list today, encrypting to more than one person/key always renders the entire chain vulnerable to the weakest link - it has always been this way, no matter what tool is used to create any The problems and limitations of a group key are not technological but practical and social. It echoes other comments about using a key on a server to sign or decrypt messages automatically - the passphrase is either entirely absent or stored in a file on the server. Neither are particularly appealing because you substitute the security of GnuPG for the security of the server alone instead of adding. (If anyone can crack the server, they can obtain the private key + passphrase, if any.)
More feasible were ideas around corporate keys that had a single main key that had a private key only accessible to a named high-up bod. That key would sign subordinate keys and revoke signatures if the subordinate left the company. At no time would more than one individual ever have access to more than one private key in the corporate keyring and no one private key would ever available to more than one person. This is workable but is it worthwhile? The problem remains of controlling the signatures and what happens when the underlings get together and sign each other's keys thereby becoming trusted without the boss' signature? That's a procedural / management / policy issue. It also didn't address the issue of encrypting to everyone, just trusting the signatures / keys. Encryption would still use some form of key group - which leaves it right back at square 1.

@_date: 2004-04-27 21:17:41
@_author: Neil Williams 
@_subject: can you deny you sent a signed e-mail? 
Adoption will only move as fast as the trust. Signing with an untrusted key declares your willingness to use GnuPG/PGP but the crucial element here is about keysigning and trust.
Claiming a compromise when none occurred is deceitful, the costs of such lies will impact on the keyowner but how much depends on the web of trust. If the key is part of the strong set, i.e. if it's signed by other strong keys rather than a long list of nonsense keys, then there is a lot to lose by revoking the key. Denying a digital signature on such an email (like this one) is going to be costly in terms of the trust held in that key and it's Someone who habitually revokes keys is going to find it hard to get his key repeatedly signed by other strong keys, so far less people will end up trusting the new key.
A signature is much more than just anti-tamper - a valid signature from an untrusted key is not as useful as a valid signature from a trusted key. Anyone can create a new key that carries the same name and email address as an untrusted key. Until the key (and therefore the keyid) can be trusted, you can't know if this is a new key for an existing untrusted user or a new key from an unknown user.
Keyservers can also provide clues here, signatures can only be verified if the public key is public so each revoked key will show up on the keyserver. As these don't get deleted, a search for the user might shed some light if anyone has cause to doubt the sincerity of the claim of a compromise.

@_date: 2004-04-27 21:24:56
@_author: Neil Williams 
@_subject: trust management script 
True. I didn't say this in the first email, but I have also left some keys at full trust even though I haven't met the person - people like Werner Koch - for the same reason as you.
Very good point. Although the list doesn't help verify the key itself, it does help in getting to know the person and their attitudes towards their key(s). In that sense, it does allow for a more considered judgement than a single brief meeting. However, a lot of the keys I have signed are people from my local LUG and I meet and correspond with them on a regular basis. Even those I've met at Expo are mostly still in occasional contact.
I use encryption mostly for local files.
I agree.

@_date: 2004-04-27 22:02:30
@_author: Neil Williams 
@_subject: Moving from PGP to GnuPG and other questions ... 
Why compromise GnuPG with the patented IDEA? If you want to use free software, don't fund those whose patents would prevent the use of free software.
Free = free speech, not just free beer. You want free? Then help GnuPG STAY If you want to use the patent you'll have to pay the piper.
The best option is to not use IDEA and educate the PGP users.
Heard good things about Turnpike and Eudora but I'm GNU/Linux only.
Free does not mean not-paid! Free means liberty.
Free software can still require payment but never reduces your freedom.
Proprietary or patented software usually costs a fee and ALWAYS reduces your Please don't use 'paid versions' - what you mean is proprietary (or in the case of IDEA, patented). Free software (like Linux) can still be sold with a

@_date: 2004-04-27 22:58:56
@_author: Neil Williams 
@_subject: can you deny you sent a signed e-mail? 
That is a seriously difficult task - a completely separate signing network is easy - getting people in the strong set to trust it requires a lot of security-aware people to be duped.
You cannot make someone else's strong key appear sinister by adding and revoking signatures, you just make their key very cluttered. It's revoked KEYS that are important in denying a signed email. If you revoke your signature on my key, that does not affect the validity of my digital signature and it may even have no particular effect on the level of trust in my key because there are lots of other signatures on my key.
Have you misunderstood signing, perhaps?
If you sign my key, you can only revoke your signature on my key. That doesn't affect the validity of my key as atested by other signatures. So if you 'attack' my key, all that happens is that I get another nonsense signature added to the key. It doesn't invalidate the signatures made by others and in particular is does NOT make your key trusted - I have to sign YOUR key to make it trusted. That requires YOU to prove to me that you are the physical person declared in the key. I will not sign your key without full verification, so your key never becomes trusted.
A long collection of revoked signatures on a key is NOT the same as a long list of revoked keys by a single user. It again comes back to trust - how trustworthy are the signatures that remain? GnuPG disregards any revoked signatures as well as signatures by untrusted keys, when calculating trust.
You are free to revoke your key, but that alone cannot affect my key. That's the strength of the web of trust, it is a web, not a chain.
There is more than one path from my key to X key in the strong set, say Werner's.

@_date: 2004-04-28 10:51:26
@_author: Neil Williams 
@_subject: trust management script 
That will take a while!
In a keyring of 3,000 keys where 2,000 have multiple signatures, just how much speed is going to be gained over simply deleting the 1,000 keys?
Each time --update-trustdb gets new trust information, the entire trust database needs to be checked so the closer you get to that 2,000th multiple sig key, the longer the trust check takes.
Instead of a single trust update after deleting 1,000 keys with a script, you are using a recursively longer trust check 2,000 times.
Me thinks that would take longer than a simple find, identify, delete script.
You would have to have a very considerable speed improvement to justify the

@_date: 2004-04-28 14:07:45
@_author: Neil Williams 
@_subject: Moving from PGP to GnuPG and other questions ... 
PGP might want to prefer IDEA but what happens when you use PGP to try and encrypt to the GnuPG key? Preferred might mean preferred as a general rule rather than as a specific preference for this key.
Doesn't it depend on what the recipient key can use? PGP must be smart enough not to encrypt to a key using an algorithm that it knows the key does not

@_date: 2004-04-28 18:04:06
@_author: Neil Williams 
@_subject: re. Moving from PGP to GnuPG and other questions ... 
That's because no public keys are set as trusted. If you have your own secret key, import both the secret and public key and then use --edit-key to set your own key to ultimate trust. GnuPG will check through the other keys in the keyring and will only let you encrypt to those that can be trusted (without using command-line options intended for secure environments). These will be keys that you have already signed or keys that are signed by people you have signed, etc.
There's no sense allowing encryption of sensitive data to a key that cannot be trusted! If you override the GnuPG security using '--trust-model always' or similar, you must still verify the key in some other manner.
Trust begins with the secret keys - those are presumably yours so if you have the passphrase, these should be set as ultimate trust. I tend to consider ultimate trust as only for keys with a usable secret key. All other keys then have their trust calculated as starting from your ultimate keys, fully trusted (allowing encryption), marginally trusted (needing an override but still not recommended) or trust unknown (don't encrypt to these unless you *really* know what you are doing). Other trust factors like revoked and expired are hopefully clear in their meaning.
BTW. General question: will '--trust-model always' allow encryption to a revoked key? i.e. after you've imported/refreshed the key with it's revocation certificate. (I'd guess that it won't but haven't got any revoked keys to test against.)
If you can list keys then GPG is working. Issues about encryption are actually about trust.
shareware, proprietary, demo, trojan (!), virus, (!) . . .
Even shareware is proprietary - you don't generally have access to the source code and you are not free to redistribute the program with or without modifications either with or without payments - there are restrictions.
A free software program that requires payment is still free software.
Think of 'free software' as one term, not two words.

@_date: 2004-04-29 23:24:57
@_author: Neil Williams 
@_subject: re. Moving from PGP to GnuPG and other questions ... 
Keysigning is never advisable with partial data. Signing a key is a public declaration - you are publicly stating that you have no reason to doubt that the physical person who owns the secret key is precisely the same person identified in the key data. "Key data" in this sense should be defined as GnuPG itself deals with key data: The name, comment and email address are lumped together as one User ID which can have secondary UID's added as aliases for that one person.
In turn, I may want to rely on your verification of that person, in combination with other signatures, to be able to trust an otherwise unknown key. In practice, it's never good to trust a single link in the chain and I set most keys to marginal trust unless I know the person personally.
As mentioned elsewhere, signing = proof of your verification of that person and that key.
trust = your assessment of how carefully that person will verify other keys.
You need to be sure of all three components of a UID, although comments might not seem important, they can be used to express important details for some I always check:
1. The fingerprint - this is the basis of key identification - it's how you tell two similar keys apart if they have the same names and even the same/similar emails.
2. Photo ID - reputable and recognised source, not necessarily official or government but not easily forgeable or temporary. Must include the same name details as the key.
3. email verification, preferably off-list and using encryption.
4. comments: if the user specifically mentions a project or locality, perhaps a distinguishing facet - this should be checked during the face-to-face meeting to verify photo ID and key fingerprint.
No use whatsoever. The keysigning must verify all parts of the UID. If you cannot verify any part of a UID, do NOT sign that part of that key - use the uid command (uid 1 or uid 2 etc.) to select those UID's that you have been able to verify.
Take my key. If you are unable to verify me as webmaster of DCLUG for whatever reason, you should not sign that UID.
I don't sign keys without seeing photo ID, exchange of fingerprint and some verification of the email.

@_date: 2004-04-29 23:28:32
@_author: Neil Williams 
@_subject: first time gpg automation with perl 
Yuk. There are Perl modules available from CPAN that will interface with GnuPG on your behalf in a reliable and tested manner. I've used GnuPG::Interface and it allows complete gpg key management and use. (You'd be advised to think carefully about allowing secret keys on remote machines before considering signing / decrypting!)
Take a look at CPAN, there are other modules out there and they can all be installed in 'user space' even if your webhost doesn't like to install them. That's unlikely because if they've taken the time to install gpg as a package, they may already have installed a Perl module to use gpg. Check your webhost config, look for a perldiver.cgi script and try to find out which modules are already installed. Full examples are on CPAN.

@_date: 2004-04-30 00:15:39
@_author: Neil Williams 
@_subject: trustdb calculations 
gpg: checking at depth 0 signed=23 ot(-/q/n/m/f/u)=0/0/0/0/0/2
I understand this line to mean gpg found 2 keys set to ultimate trust (I have two keys of my own with matching secret keys) that have, in turn signed 23 other keys. Is that right?
gpg: checking at depth 1 signed=85 ot(-/q/n/m/f/u)=0/0/0/1/22/0
gpg: checking at depth 2 signed=224 ot(-/q/n/m/f/u)=0/0/0/60/16/0
That jump to 224 - is that expected? Have I perhaps been too generous 'as-a-rule'? I tend to set keys at marginal trust during a run of --update-trustdb - gpg only lists those that it can fully trust but which have no trust value set. Up until now, I've been happy to consider these as keys belonging to people who have a reputation for good key management (to collect the signatures from the strong set that allow my gpg installation to trust the key) and that it is reasonable to set these to marginal trust unless I have reason to set full trust or have reason not to trust.
Could this have led to an artificial increase in keys further down the chain becoming trusted when perhaps there isn't a good reason? i.e. it would enable someone to become fully trusted when 3 marginal keys have signed it, even though each of those 3 is as much as 3 links down the chain from me. The problem is that it is very hard to visualise these chains and to tell from the update-trustdb output just how far away you are from the key being I've got to the stage now that trustdb checks have to be run manually because my mail client was waiting many minutes for the results of importing a new key. Now I've set no-auto-check-trustdb in gpg.conf and I run update-trustdb once all mail has been previewed (and new keys imported).
Have I over-complicated my trustdb with trusted keys too far down the chain?
(possibly by over-zealous use of the KGpg function "import missing keys from keyserver" on a trusted Debian developer key? - it requests and imports all keys that have signed the selected key but which are not already in the keyring. Up until now, I've only done it with keys with 5-8 missing signatures. Last night I did it with a stronger key and imported a lot more keys, most of which also became trusted.)
Latest run of --check-trustdb gives:
neil date
Thu Apr 29 23:04:29 BST 2004
neil gpg --check-trustdb
gpg: checking at depth 0 signed=23 ot(-/q/n/m/f/u)=0/0/0/0/0/2
gpg: checking at depth 1 signed=85 ot(-/q/n/m/f/u)=0/0/0/1/22/0
gpg: checking at depth 2 signed=224 ot(-/q/n/m/f/u)=0/0/0/60/16/0
gpg: checking at depth 3 signed=224 ot(-/q/n/m/f/u)=0/1/0/113/11/0
gpg: checking at depth 4 signed=154 ot(-/q/n/m/f/u)=0/0/0/84/4/0
gpg: next trustdb check due at 2004-05-14
neil date
Thu Apr 29 23:09:22 BST 2004
Almost exactly 5 minutes. (This after a previous run of --update-trustdb and with no further changes to the keyring.)
neil gpg --list-key | grep -c pub
471 keys after running my usual 'untrusted/expired/revoked' clear-out script.
I'm now considering adding 'marginal' to the clear-out script - when a key is deemed by gpg to be of marginal trust, my email client still classifies it as untrusted. Am I right in thinking that until a key becomes fully trusted by gpg, it has no bearing on the trustdb calculations? If I delete all keys that are m/[m|-|n|q] will some of my fully trusted keys suddenly become untrusted?
If I delete these keys, will it improve the trustdb speed at all? I'd suspect that the speed is down to the sheer number of verifiable signatures on the trusted keys - is that correct? Some of these are currently only marginal trust (trust m/m).

@_date: 2004-04-30 00:28:00
@_author: Neil Williams 
@_subject: an we delete (our own) posts sent here earlier ? 
You can't. By the time you receive it back it's been sent to everyone else and has already been archived with all the others. I'm certainly not going to allow you to delete email that has already arrived in my inbox!
Too late. You might be able to sweet-talk to webmaster for some archives but techniques like that are not spammer-proof (which is presumably your concern) because newsgroup users have been doing this for some time and it's easy to write a script that will re-form the original email address. However, whether the gnupg archives are actually a target for spammers trawling for email addresses is open to doubt. Besides, the archive already declares your verified email address in this format: Neil Williams linux at codehelp.co.uk - whether you quote your email address in your message or not.
That message was only sent 12 minutes before this one and it's already in the public archive for the entire internet to read.

@_date: 2004-04-30 13:18:45
@_author: Neil Williams 
@_subject: Revoking Old Keys... my problem 
A passphrase (even if you could remember it) is useless without the secret key. If you don't have a backup of the secret key from that laptop, forget trying to remember the passphrase (if you follow) because you cannot use it to revoke this key.
If you also do not have a revocation certificate (GnuPG advice is to create one immediately after generating the new key, print it out (v.small) and delete the file) then this key is doomed to hang around on keyservers for ever with no realistic possibility of being revoked or deleted.
Correct procedure is to always have a revocation certificate stored somewhere v.safe in case you lose the use of the secret key. The certificate can be used by anyone, it just needs to be imported into a keyring that already holds the public key to be revoked - no secret key or passphrase is required to use the revocation certificate, which is why it must be kept safe! Then, the revoked key should be sent to the keyservers and the keyserver merge the two and show the key as revoked.
If you have no revocation certificate and no backup of the secret key, you haven't got a prayer. You can't really ask for the correct procedure now when you've already ignored the correct procedure that would have prevented the problem in the first place!
Tell them directly - and QUICKLY, they could be justifiably upset that you hadn't told them immediately the laptop was stolen! Explain that you were careless not to have the revocation certificate or a backup and that the old key must never be used again.

@_date: 2004-04-30 17:56:25
@_author: Neil Williams 
@_subject: Revoking Old Keys... my problem 
Why would GnuPG allow a forged key to be imported? It must break the self-sig on the key or it could be used to add a false UID to a genuine key!
from man gpg:
   --allow-non-selfsigned-uid
   --no-allow-non-selfsigned-uid
                 Allow  the import and use of keys with user IDs which are not self-signed.  This is not recommended, as a non self-signed user ID is trivial to forge.  --no-allow-non-selfsigned-uid disables.
I'd hope not!

@_date: 2004-08-02 21:49:08
@_author: Neil Williams 
@_subject: many questions 
Generating all the keys yourself is a bad idea - generating them all on one machine (each key generated by the final user) is a practical problem. You shouldn't expect people to trust a key generated by someone else! (Generating a key requires setting the passphrase and it isn't wise to use a key to which someone else has a passphrase. Even if the user changes the passphrase in their private key, what is to say that you haven't kept an old private key with your own passphrase? Multiple copies of private keys with different people should be avoided.
That much is plain from your first question.
Try reading these:
Yes. Each of those then needs to sign your key and be signed by your key. i.e. two way signatures, A signs B and B signs A. There are keysigning protocols for this:
Signatures are not something to be minimised, a keyholder often invests considerable time and effort in collecting as many signatures as possible - every signature strengthens the key and the overall web of trust.
No, it's signing. Setting the trust comes afterwards - GnuPG will ignore any user trust setting until the key itself is trusted. (In the --edit-key output, trust is shown as two values).
Just sign the 'super' key. However, to make the web of trust stronger, as many users as possible should verify and sign each other's keys.
Not necessarily, but you can set it that way. (There is no reason why any user MUST trust any key.)
Why create another one? Public keys are public and there's no harm in using a public keyserver - there is no security issue here, public keyservers are designed for public keys. Dump the windows mindset and embrace the community - share your public key as widely as possible, keep your private key absolutely private.
Why? You'd be surprised how limiting that could become. Someone in the keyring is almost certain to want to use the key to sign/encrypt outside the small group. Once users have their own keys (and passphrases), there's nothing to stop them signing and being signed by other keys. It should be encouraged - it strengthens the web of trust of the entire group.
I thought it was SKS that was most up to date (subkeys etc.)?

@_date: 2004-08-11 12:20:19
@_author: Neil Williams 
@_subject: Switching from Linux to Windows 
Mozilla Thunderbird?
Just because you are being forced to use windows, couldn't you slip Thunderbird on your workstation? Tell them you want to use clients at work that are compatible with the ones at home!
(Pretend you want to take your work home)

@_date: 2004-08-12 20:07:02
@_author: Neil Williams 
@_subject: OT Re: hush mail 
Try hushmail.com and read.
Then write to the user and ask for his/her public key.
There is a hushmail keyserver - follow the links from hushmail.com. It uses sessions so I can't post a URL.
This set of tools allows Hush users to sign in and encrypt, decrypt, sign, and verify text and files. It also allows users of Open PGP systems to upload and download public keys, providing an easy means of secure communication between Hush users and all other Open PGP users.
i.e. hushmail keys are not separate from GnuPG/PGP keys and won't show up as special. If the user has an existing GnuPG/PGP key , it is likely that it is already on keyservers. If not and hushmail produces one for them, it is up to the sender to make his/her public key known. Write to the user and complain.

@_date: 2004-08-12 20:18:18
@_author: Neil Williams 
@_subject: problem with newbies key attached sig 
so gpg is doing as pgp. However, you haven't set this key as trustworthy so it is unusable for encryption.
You need to verify and sign the key. Also check that your own key is set as ultimate trust and that you've done a gpg --update-trustdb.
If you want to force it without trust (NOT wise) or if you have a secondary method of trust, use --trust-model always.

@_date: 2004-08-17 20:46:35
@_author: Neil Williams 
@_subject: Unrevoke revoked uid 
Why would anyone trust such a UID? You can't remove the revoked UID from keyservers so it'll always show up. Adding exactly the same UID is only going to cause confusion - at least put something in the comment to explain why the revoked UID is now trustworthy again.

@_date: 2004-08-17 20:47:49
@_author: Neil Williams 
@_subject: IMPORT AND EXPORT KEYS 
You'll get more replies if you can post in English.
At a guess:
gpg --list-secret-keys

@_date: 2004-08-25 11:12:11
@_author: Neil Williams 
@_subject: Encrypting Cron job email output. 
Normally you'd use chmod 700 /home/simon/.gnupg/
If you are still running the cron job as root (is it possible to run it as a user and use SUID?), use
       --no-permission-warning
from man gpg
Only that the cron daemon will generate email to you if any task generates output like that.

@_date: 2004-08-25 14:53:02
@_author: Neil Williams 
@_subject: encrypted string always the same 
Try encrypting using a symmetric cipher.
from man gpg:
     -c, --symmetric
                 Encrypt  with  a symmetric cipher using a passphrase.  The default symmetric cipher used is CAST5, but
                 may be chosen with the --cipher-algo option.
Wouldn't 'crypt' do the same thing? SQL already handles this using the password() function. It's a one-way encryption that just compares the encrypted hash, as stored in a suitable varchar field.
select credit_card from subscribers where password = password(user_value);
In the same way as 'crypt' isn't invulnerable.
You obviously have to guard against someone obtaining the cipher text itself - which would normally be public with gpg defaults - as this could be used to sidestep your security.
select credit_card from subscribers where password = user_value limit 1;

@_date: 2004-12-13 16:34:14
@_author: Neil Williams 
@_subject: How to decide which private key to use? 
If one machine is decrypting all messages, why not have one passphrase for all three keys?
Why use three keys? The machine running the program has to be secure - otherwise you are exposing three keys to compromise instead of just one.
Any time you store passphrases for an automated process, it's as bad as having no passphrase at all. Anyone who gains access to the machine can locate the stored passphrase and the secret key file.
You wouldn't put a file 'root-password.txt' in your user directory.

@_date: 2004-12-13 16:36:14
@_author: Neil Williams 
@_subject: Signature in Attachment 
Why not post from home?
But old-style inline signatures are deprecated for very good reasons. PGP/MIME is the future of GnuPG/PGP signatures. You really ought to use a different email client. It isn't impossible, no matter what the corporate mentality, you could use Mozilla Thunderbird - on a USB stick if necessary.

@_date: 2004-12-13 16:36:28
@_author: Neil Williams 
@_subject: The parts of a key? 
The subkey below is the encryption key. The public key is a signature key. When someone encrypts to you, the encryption key is chosen.
When you sign a file, the signature key is chosen.
Different algorithms have different strengths.
This is different to the 'key-pair' - a term usually meaning the public key and the secret key.
You have a public key containing a signature subkey and an encryption subkey.
You have a secret key containing the corresponding secret subkeys.
A default key generation gives a strong signature key and a strong encryption key, but the keys themselves use different algorithms - playing to the respective strengths. Anyone encrypting to you using 379E6244 will always actually encrypt to E0BEF64A. It makes no odds, E0BEF64A is the encryption part of 379E6244 and your secret key for 379E6244 can decrypt the message.
You can add subkeys for other purposes - like a short expiry, preference for an algorithm, as well as adding UID's. Many keys are just like yours - one pub and just one sub.

@_date: 2004-12-13 16:36:44
@_author: Neil Williams 
@_subject: Signature in Attachment 
If Exchange can enable IMAP in the same way, it would solve this problem:

@_date: 2004-12-13 16:38:28
@_author: Neil Williams 
@_subject: PGP Global Directory 
Where can I find out some facts about this signing keyserver protocol? I've heard some rumours of what it's doing to 'verify' the uploaded key but what's the truth?
Keys uploaded to the new keyserver result in an email to the main email address of the key to see if the email address in the key actually exists and is functional and, if so, the key is signed by PGP's Global Directory Verification Key.
If that is truly all that happens, it's all but useless. All it's doing is sifting out dead keys - it is migrating all the keys on current pgp keyservers. From the FAQ: Every six months, everyone with an active key is now going to receive an email from PGP. Great, thanks. If you don't reply, your key will be deleted from the Global Directory. Somehow, I see a lot of active keys being wrongly marked as dead simply because of the email process.
If the message is encrypted to the key it might be something but IMHO this is BAD keysigning practice. There is no face-to-face fingerprint verification, no photo ID verification. Does it deal with subkeys?
Does it deal with photos?
It would take a lot more before I'd trust any signatures made by the PGP keyserver key.
There are some of these automated signing keys around already and I never trust them. Without verification of the physical person behind the key, what is the point?
I've tried the PGP Global Directory FAQ but it is thin on detail.
Although don't expect a lot more than is already in HTML here:
I've got no problem with the removal of dead keys from keyservers, but what bothers me is WHY they choose to sign the key rather than simply delete ones that can't be verified. When the signature is untrustworthy, why sign at all?
Simply because it purports to be 'from PGP' is not good enough.

@_date: 2004-12-20 11:56:40
@_author: Neil Williams 
@_subject: locally signed keys are not necessarily fully trusted any more 
sig 3: indicating very careful checking prior to signature.
sig 1: indicating casual checking.
Is GnuPG taking that into account?
Are the other locally signed keys sig 3?
At what LEVEL are you re-signing?

@_date: 2004-12-20 12:31:43
@_author: Neil Williams 
@_subject: Use of PGP to sign distributed files 
That's why packages on websites are often signed using GnuPG, so yes, it is suitable in general terms. You create a detached signature (gpg -ab) and post that alongside the file - it is given the same name with a .asc extension by Try downloading and verifying some packages yourself - to start you off, look Signatures can be verified automatically as long as the public key is available. Don't split the code - use it as it is and use the functionality from the program. Look at man gpg and the options:
gpg --verify  sigfile [files]
                 Verify the signature of the file but do not output the data. The second form is used for detached signatures,  where sigfile is the detached signature (either ASCII armored or binary) and [files] are the signed data; if this is not given, the name of the file holding the signed data is constructed by cutting off the extension (".asc" or ".sig") of sigfile or by asking the user for the filename.

@_date: 2004-12-20 15:14:57
@_author: Neil Williams 
@_subject: expire function 
You lose all your signatures and therefore trust.
One alternative is to issue a unlimited expiry main key with a subkey that expires. You need to then use updated keyservers and you'll get people asking why they cannot get/use your key.

@_date: 2004-12-27 11:36:56
@_author: Neil Williams 
@_subject: GPG wants to check trustdb every day 
When did you import 0x98645519?
From the keyserver output, it would seem that there is an oddity with the pub  1024R/98645519 1998-10-14 Jeremy Blosser
     Key fingerprint = 1D D8 8E 3C 3E 19 74 EB  2F 70 EA 79 4B 50 D3 B5
sig  0x10  98645519 1998-10-13  [selfsig]
uid                            Jeremy Blosser
sig  0x10  98645519 1998-10-13  [selfsig]
Does removing this key eliminate the check-trustdb problem?
Maybe if the keyholder edits the key (e.g. set the passphrase again (same one, just repeat it), his copy of gpg will put a new self-sig on the key to solve this problem?
I'd blame the key before gpg.

@_date: 2004-02-01 01:23:06
@_author: Neil Williams 
@_subject: Newbie: Choosing a user ID questions 
Generally there are far easier ways of harvesting email addresses than trawling through keyservers - the list of UID's may be clearly visible when you inspect a key via a keyserver www interface but using it to collect millions of addresses just doesn't seem practical when there is no list of all known key ID's. If spammers can't get a few million addresses, there wouldn't seem much point. (There are also quite a few dead keys on keyservers - people sometimes just stop using them or usually just forget the passphrase without generating a revocation certificate beforehand.)
Use a spam filter instead?
(Have you considered that this list is publicly archived - your email address is scrambled in a similar way by mailman but it is still retrievable. It all depends on the amount of effort required.)
This kind of thing is quite common on Usenet - that hasn't stopped usenet being a source of data for spammers.
Many of the more frequent signers use scripts to make verification easier and most are hand-crafted. It wouldn't help if your UID email address needs manual hacking.
Personally, I'd say the email address is expected if the key is going to become public. You can do what you like with a key only used locally but if you want others to sign it and trust it, I'd expect at least some people to be upset at such constructs.
When you ask someone to sign your key, you are asking them to verify the UID and the person. If the UID cannot be verified because it lacks a valid email address, I can see some people simply not signing the key. I probably wouldn't. After all, I would usually sign someone's key to enable encrypted communication via email - it adds another hurdle to have to verify an address that is not contained in the UID. Some email clients use the To: email address to find the best key to use for the encryption. Others will know for definite but I suspect it's just too much like hard work.
View it in a keyserver?
The export block itself isn't usually of human interest. Under what circumstances would you want to read it? If you've got the block, it's usually from a keyserver or website that would declare the full key details, including fingerprint, if requested.
If you want to store exported keys in text files (for some unknown reason), just use the name of the text file to identify the key(s) inside. (I do this sometimes for users whose keys keep getting mangled by keyservers.)

@_date: 2004-02-01 01:44:55
@_author: Neil Williams 
@_subject: GPG Key Photo Removal 
To get the key onto these keyservers (minus photo), I would use KGpg which has a nice feature to export a key without the photo UID. The block exported can then be put into any keyserver www interface. I can't remember the gpg command to do the same thing from the command line. (Send me your public key and I'll do it for you, if you don't have KGpg.)
To get the key onto keyservers that support photos, change your keyserver to hkp://sks.dnsalias.net or others based on SKS. www interface: You can also delete a uid but that won't remove the evidence from keyservers. As you've already sent your key to keyservers that have problems with photo UID's you will continue to get mild error reports with your key in the future. GnuPG will construct a valid key and it's not a huge problem. Look at ways of adding a comment to GnuPG signatures, email headers or email signatures that says 'this key has been corrupted by some keyservers, the complete key is available at  You can also revoke any secondary UID independent of the key itself. Edit the key in gpg and revoke the self-signature.
The OpenPGP specification does not support user ID revocation, but a user ID can effectively be revoked by revoking the self-signature on the user ID. For the security reasons described previously, correspondents will not trust a user ID with no valid self-signature.
You would still need to send the key to some keyservers without the revoked

@_date: 2004-02-03 22:53:24
@_author: Neil Williams 
@_subject: GPG Key Photo Removal 
Sorry, when will be updated?
OK, that's in GnuPG v1.2.4 - I'm still working with 1.2.1 so the option didn't appear either locally or in the online GnuPG documentation.
The option of using KGPG to send the key minus photo UID still exists for Steve to use - how is that replicated on the command line?

@_date: 2004-02-10 18:33:11
@_author: Neil Williams 
@_subject: Removing AES 
Hash: SHA1
Evolution can't do it.
Use KGPG or some other tool - copy and paste the entire text and verify that way. Or:
- From the command line, you can just use
$ gpg -v
Remember to press Ctrl-D to tell GnuPG that you are finished with entering It's so easy that it makes you wonder if the Evolution people can't just use a macro instead of complaining that it cannot be fixed in Evolution. Every other GnuPG client (not just mail clients) can do it, except Evolution.
(Using inline signatures again because I can't get gpg-agent to work on Debian

@_date: 2004-02-11 13:05:18
@_author: Neil Williams 
@_subject: change the location ~/.gnupg 
Remember that the amended homedir would have to be specified for all gpg
usage, including scripts, email clients and the like. If this is a
desktop / user system, that could be a real pain. homedir is more useful
for remote automated environments where the only execution of gpg is by
customised scripts etc. What are you wanting to accomplish?

@_date: 2004-02-11 20:54:53
@_author: Neil Williams 
@_subject: problems with TheBat inline pgp messages 
I used to feel the same, but KMail/Aegypten/KDE3.1 have defeated me on
Debian testing so far - hence I'm using a combination of inline sigs via
KMail or PGP/MIME in Mutt. KMail was just waiting too long for pipes and
filters so I moved the task to a separate mail server. Now it's just as
quick to use either KMail or Mutt.
One thing I like about Mutt is that it uses Vi as the composer (you can
select others), which gives me a full screen composing window without
the extraneous GUI stuff.
Whilst KMail remains broken, I need the plugin to validate PGP/MIME but
need to switch to inline for each email to send because gpg-agent won't
Ho hum, KDE3.2 will be on Debian soon.

@_date: 2004-02-11 23:23:34
@_author: Neil Williams 
@_subject: Storing keys under a different user... 
Copying the secret key file still requires knowledge of the password
that protects the secret key. How is this different to adding a
requirement to either know/crack the root or new user password?
With good reason.
No more or less secure than at present? A trojan:
a) isn't particularly useful if it only operates in user space (so isn't
particularly attractive to write)
b) would have to be uncommonly specific to go after secret keys - there
are a vast number of Linux/Unix boxes out there with no secret keys at
all. There's no real way of telling a workstation from a server until
you've at least got some kind of compromising access.
Compromising root is probably the only purpose of any *nix exploit. If
someone really is after secret keys, some kind of keyboard logging would
also be required. If the attacker can fit a keyboard logger then s/he has some kind of physical access to the box - and you have more than your
secret key to worry about.
Is obtaining secret keys en-masse really that attractive?
First you have to find a *nix exploit.
Then you have to disregard most boxes that don't have secret keys.
Then you have a limited window to use all those secret keys to
compromise what? What good is the secret key of someone you don't know?
What can you realistically do in the time before the key is revoked,
given that you obtain the key more or less at random and have no
knowledge of where or when encrypted content may be compromised?

@_date: 2004-02-12 00:04:58
@_author: Neil Williams 
@_subject: GPG encrypting form data 
Which language? Perl can do this via GnuPG::Interface, PHP can also do
it - there's a function written by a member of this list,
gpg_encrypt.php (sorry I haven't had more time to test it, Atom!)
See CPAN for GnuPG::Interface:

@_date: 2004-02-12 10:19:23
@_author: Neil Williams 
@_subject: GPG encrypting form data 
Via bash, you can just do:
echo "test text" | gpg -a -r 0x28bcb3e3 -e
That will output an ASCII armoured block to STDOUT - in this case, the
screen. You can pipe this to another command or to a file.
echo "test text" | gpg -a -r 0x28bcb3e3 -e | mail user
echo "test text" | gpg -a -r 0x28bcb3e3 -e > newfile
echo "test text" | gpg -a -r 0x28bcb3e3 -e >> appendedfile
Replace echo "" with the command/script that generates the output to be
encrypted. Anything the GnuPG can encrypt will do fine.

@_date: 2004-02-13 11:28:09
@_author: Neil Williams 
@_subject: question about the keys 
The content is complementary, not identical. The secret key must identify
itself as the other half of the corresponding public key so that might
give the impression that it is the same.
--list is only showing the basic summary information of the key, it's
not listing the actual contents of the keys. You could export the two
keys in ASCII armour to the console but that will only show you that the
two keys differ in size, depending on how many people have signed your
public key. That 'sec' is the critical difference. The rest of the list display is
concerned with identifying which 'sec' to use with which public key. Public and private act as a pair.

@_date: 2004-02-21 03:53:25
@_author: Neil Williams 
@_subject: Photo-ID: questions 
Hash: SHA1
I didn't get a photo UID in the key used to sign your message (and I use a keyserver that supports photos and subkeys) - is this a different key you are using for photos?
If you want to use an image it should at least be recognisable, so larger is better than pixelated.
I don't see that a photo UID aids key validation at all - key validation is all about exchanging key fingerprints face-to-face and verifying email addresses/UID's by correspondence and passports etc. A photo UID is just another UID to verify on the key - it's the key that is the most important verification step. Having the photo on the key doesn't help much - (excluding any previous knowledge/contact) I'd still need some 'official' photo ID from a trustworthy / government third party source before I could verify that you are who you say you are. Without that first step, I'd never sign your key.
Photos are a nice feature - with the expected drawback of an increase in the size of the public key - but personally I don't see how they increase Odd. Aren't you concerned that this will be used against you? If someone gets hold of your home postal address (perhaps from a WHOIS query on a personal domain), this could be a step in identity theft? OK, identities are stolen without handwriting signatures but that usually involves using a separate account/setup - if they had a real signature that they could spend loads of time perfecting their hand-written copy, identity theft could progress to real theft from your real accounts? I'd agree there are probably easier ways but, personally, I am surprised that you've done this.
It doesn't have to be trusted - if it's on your public key, anyone gets a picture of your handwritten signature. Whether they trust your key doesn't affect the ability to copy the handwriting.
That depends how many signed paper documents you leave lying around. Your public key is very public and worldwide accessible - it's not as if someone has to have access to some paper documents in one specific geographic Plus it adds to the feeling that people will end up signing your key after merely verifying the photo and the signature image. My key has already been signed by people I've never met or even had any correspondence - complete strangers don't bother to verify me and still sign my key at sig3. I've even emailed a one or two but I never get a response. If anyone thinks they will get their key signed by signing mine without verification, they will be disappointed. I don't see what people gain by this but there's probably a misunderstanding of the web of trust at the core of it. I dare say Werner and others get a lot more of these signatures. Once on a keyserver, there's little point in pursuing the matter.

@_date: 2004-02-21 14:43:04
@_author: Neil Williams 
@_subject: Photo-ID: questions 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
I tried keyserver.kjsl.com yesterday and again just now. I also tried subkeys.pgp.net and both returned an unchanged key:
pub  1024D/C2303358 2002-07-03 Ruediger Kupper (Dipl. Phys.) uid                            Ruediger Kupper uid                            Ruediger Kupper (Honda Research Institute) sub  2048g/24DD6D20 2002-07-03
gpg: Signature made Thu Feb 19 13:18:03 2004 GMT using DSA key ID C2303358
gpg: Good signature from "Ruediger Kupper (Dipl. Phys.) gpg:                 aka "Ruediger Kupper "
gpg:                 aka "Ruediger Kupper (Honda Research Institute) It was only sks.dnsalias.net that added a new UID and the signatures.
I thought keyserver.kjsl.com and subkeys.pgp.net synchronised with SKS

@_date: 2004-02-22 20:13:39
@_author: Neil Williams 
@_subject: Question about fingerprints and keys uploaded to keyservers 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
It's also quite an intuitive domain name - keyserver.com
(an alias for keyserver.net). So stick keyserver in the address bar of IE and keyserver.net appears.
If the browser doesn't add the .com, keyserver.org is for distributed computing DNS keyservers (not sure why they call them keyservers though), keyserver.net is the next in line in most people's 'blind' domain searching.

@_date: 2004-02-25 08:28:02
@_author: Neil Williams 
@_subject: =?iso-8859-1?q?can=B4t_encrypt_and?= sign 
Hash: SHA1
You need to set the key as trusted in GnuPG - edit the key --edit-key , and set the trust to ultimate if it is your key.
If it isn't your own key, you need to verify and sign the key with your trusted key.
As the error says, the key is untrusted. It would be a disaster for GnuPG to encrypt to a key that you haven't declared as trustworthy!
Also, if you ever expect to receive an encrypted file or message, you'll need to publicise your keyid, not hide it behind XXXX. So before you send any signed emails, please send your key to a keyserver:
gpg --keyserver sks.dnsalias.net --send-key yourkeyid

@_date: 2004-02-25 09:06:13
@_author: Neil Williams 
@_subject: gnupg-agent problem 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
You need to put the eval "$(gpg-agent --daemon)" command into one of the scripts that is run automatically, each time you login. The Aegypten site describes using .xsession or you might need to insert the command into startkde - don't just tack it onto the end of startkde.
My primary reason for interest in Aegypten is to be able to sign and verify PGP/MIME messages - where the signature is a valid MIME component instead of in the text of the message - the inline method. KMail will already do inline signing and encryption, you don't need to export to and from KGpg. There is the advantage that the inline method won't 'wrap' around any attachments - these need to be encrypted or signed separately - whereas a MIME signature can (optionally) include or exclude individual attachments.
Once the agent is working, KMail and KGpg will both use the agent for passphrase entry. KGpg doesn't always use the passphrase cache though, it'll sometimes ask you for the passphrase twice, sometimes just once. This may have been fixed since I last used it on Mandrake 9.1
I'm now waiting for gpg-agent functionality to be included within KDE (either via the new PIM or KMail) as I can't get Aegypten project code to compile on Debian. (So I send inline when composing the message is easier in KMail and I use PGP/MIME when I don't need/have a GUI by using Mutt - e.g. copying and pasting from two or three other messages into an existing reply isn't easy without a GUI, especially if I only want two lines out of a 5Kb message). I could use Mutt for all messages but I have a lot of mail filters to re-implement from KMail.

@_date: 2004-02-26 22:39:16
@_author: Neil Williams 
@_subject: gnupg-agent problem 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
The backend - Aegypten won't compile. I think I got as far as ksba before the compile went into a tail-spin.
Aha, interesting. Did you build the complete tree from source, or did you use a Debian package for cryptplug, gpgme and libgpgerror0?
Debian kernel:		2.4.23-1-686
Debian dist:		testing
libgpg-error0 		0.6-0.1
libgpg-error-dev 	0.6-0.1
cryptplug			0.3.16-1
cryptplug-dev 		0.3.16-1
libgpgme6		0.3.15-1
libqt3-mt-dev 		3:3.2.3-2
qt3-dev-tools		3:3.2.3-2
glib2.0			2.2.3-1	(libglib2.0-0)
libglib2.0-dev		2.2.3-1
It halts at newpg.
When I last tried to get it to work, the code appeared OK but the packages
don't provide the error code definitions - ksba just redefines the errors as
gnupg macros which in turn are not defined by the Debian packages.
I'm afraid I'm swamped with other work at the moment and I am not likely to have time to do a build from source for a few weeks.
However, here's the output that causes the halt:
newpg-0.9.4 $ make
maperror.c: In function `map_ksba_err':
maperror.c:46: error: `KSBA_Out_Of_Core' undeclared (first use in this maperror.c:46: error: (Each undeclared identifier is reported only once
maperror.c:46: error: for each function it appears in.)
maperror.c:47: error: `KSBA_Invalid_Value' undeclared (first use in this maperror.c:48: error: `KSBA_Not_Implemented' undeclared (first use in this maperror.c:49: error: `KSBA_Conflict' undeclared (first use in this function)
maperror.c:50: error: `KSBA_Read_Error' undeclared (first use in this maperror.c:51: error: `KSBA_Write_Error' undeclared (first use in this maperror.c:52: error: `KSBA_No_Data' undeclared (first use in this function)
maperror.c:53: error: `KSBA_Bug' undeclared (first use in this function)
maperror.c:54: error: `KSBA_Unsupported_Algorithm' undeclared (first use in this function)
maperror.c:55: error: `KSBA_Invalid_Index' undeclared (first use in this maperror.c:56: error: `KSBA_Invalid_Sexp' undeclared (first use in this maperror.c:57: error: `KSBA_Unknown_Sexp' undeclared (first use in this If there's an obvious problem, I'll pursue it - just not right now.
I've got pinentry compiled and installed - in case I get gpg-agent running.
./configure --enable-pinentry-qt --with-qt-dir=/usr/share/qt3

@_date: 2004-02-26 22:51:08
@_author: Neil Williams 
@_subject: gnupg-agent problem 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Those three are fine, already installed (libgpgme6).
That server appeared unresponsive when I tried.
I'll need the package names / descriptions.

@_date: 2004-02-28 15:29:08
@_author: Neil Williams 
@_subject: GPG encrypting and decrypting files 
Hash: SHA1
Linux / windows machines?
What kind of file and how are you transferring it - ASCII or Binary FTP?
You are encrypting to a binary format (by not using -a ASCII armour) so transferring the file by ASCII FTP could be the source of the problem. If it's a text based file, try encrypting using:
$ gpg -ar [recipient] -e [unencryptedfile]
Then send by ASCII FTP. (type A).
To make sure it has transferred correctly, use a detached signature ( -b ) and send that by FTP. Verify the signature on the other machine before attempting to decrypt. The detached signature can also be in ASCII by adding -a.
I don't usually specify an output file, gnupg will use the same filename without the .gpg or .asc.
Which filename is being refused - the encrypted file or the specified output (Assuming you've checked the permissions.)

@_date: 2004-02-28 15:34:13
@_author: Neil Williams 
@_subject: [Announce] GnuPG 1.3.5 released (development) 
Hash: SHA1
0x49E1CBC9 is a subkey of 0x99242560 - you are using a keyserver that cannot locate the key from the subkey. Use a better keyserver!

@_date: 2004-02-28 19:44:19
@_author: Neil Williams 
@_subject: Werner's key expired? Re: [Announce] GnuPG 1.3.5 released 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
It hasn't actually, it's your keyserver that is at fault.
Yes and it's on the working keyservers. You're using an old keyserver that doesn't handle changes in expiry dates on keys so it ignores Werner's new expiry and tells you fibs.
Use a better keyserver.

@_date: 2004-03-03 16:54:03
@_author: Neil Williams 
@_subject: backup startegy for keyrings 
============================== START ==============================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
That's left to you. Your public keys don't really need to be backed up - all you need is the list of keyID's and a keyserver. Maybe stick them in a database or just a simple text file. You should, obviously, have a secure backup of your secret key AND a secure revocation certificate. Beyond that, it's nice to have a backup of your trustdb and gpg.conf to save time.
To get a list of all keyids in your local public keyring:
$ gpg --list-keys | grep "^pub" | cut -d"/" -f2 | cut -d" " -f1 > keylist.txt
One per line.
If you cannot recover using gpg commands, delete the keyring and reimport the In one way, your local public keyring is just there to save going to the keyserver all the time - your keys can do with being refreshed regularly, otherwise you can miss out on a local key being revoked - potentially catastrophic if you've sent an encrypted message between revocation and refreshing. GnuPG cannot warn you about a revoked key if the local copy has not been refreshed.
I use a cron script to purge untrusted keys and refresh all other keys. The purge section was created from contributions on this list.

@_date: 2004-01-02 17:08:27
@_author: Neil Williams 
@_subject: problem decrypting 
Make sure he is encrypting to your key, not his own. You can decrypt anything sent to you using your own key (because you can decrypt encrypted emails sent between your email accounts). You don't need his key to decrypt a message TO you, you only need it to send an encrypted message to HIM or to verify his signatures. He needs your key to encrypt to you and verify your signatures. Him -> You = your key
You -> Him = his key
Can he decrypt an encrypted email from you? That will be encrypted to his public key and as he has his own secret key, he should be able to decrypt it.
He then needs to make sure he is encrypting to your public key before sending the encrypted message to you.

@_date: 2004-01-02 18:11:21
@_author: Neil Williams 
@_subject: problem decrypting 
Looking at your key, if you are expecting to encrypt messages to your friend, it would be best for you both to sign each other's keys. GnuPG will complain if you ask it to encrypt to an untrusted key and you can't build that trust until you get your key signed with his and his with yours. This keysigning is different to signing email or encrypting messages - there's plenty of documentation on keysigning at  and Try using 'gpg --list-sigs' on some of the keys already in your keyring - including those imported to verify signed emails on this list - to see how these key signatures show up. Make sure you read about keysigning before jumping in - e.g. please don't sign any key without personally verifying it. You should be able to verify your friend's key by contacting him by phone/post to verify the fingerprint of his key. 'gpg --fingerprint'. Other keys can be verified at Linux User Group meetings, OpenPGP meetings, exhibitions or other events.

@_date: 2004-01-08 20:24:06
@_author: Neil Williams 
@_subject: Fwd: GPG 
man gpg lists -t as a kludge to get around problems with PGP but doesn't make it clear what --textmode means when not used for signing or armouring - if it does anything in those modes.
Would someone mind giving a fuller explanation?
Anyone know why Mutt recommends it?
He apparently has problems getting the subscription to work, so he's CC:
on this message.
----------  Forwarded Message  ----------
I saw your name on the GPG mailing list and was wondering if I could
humbly ask you a question about it.  (I'd subscribe except I've tried
twice and the mailing list doesn't seem to be working for me.)
What does --textmode do??? The gpg man page says this
is for the "canonical text mode".  It does not explain what this means.
Could you please describe what GPG's "canonical text mode" is?
P.S. I'm using GPG to sign emails in my MUA which is mutt on Linux.
Mutt recommended --textmode.  I don't know why.
Christian Seberino, Ph.D.
SPAWAR Systems Center San Diego
San Diego, CA 92152-5385

@_date: 2004-01-08 21:42:37
@_author: Neil Williams 
@_subject: Fwd: GPG 
man gpg lists -t as a kludge to get around problems with PGP but doesn't make it clear what --textmode means when not used for signing or armouring - if it does anything in those modes.
Would someone mind giving a fuller explanation?
Anyone know why Mutt recommends it?
He apparently has problems getting the subscription to work, so he's CC:
on this message.
----------  Forwarded Message  ----------
I saw your name on the GPG mailing list and was wondering if I could
humbly ask you a question about it.  (I'd subscribe except I've tried
twice and the mailing list doesn't seem to be working for me.)
What does --textmode do??? The gpg man page says this
is for the "canonical text mode".  It does not explain what this means.
Could you please describe what GPG's "canonical text mode" is?
P.S. I'm using GPG to sign emails in my MUA which is mutt on Linux.
Mutt recommended --textmode.  I don't know why.
Christian Seberino, Ph.D.
SPAWAR Systems Center San Diego
San Diego, CA 92152-5385

@_date: 2004-01-09 19:50:06
@_author: Neil Williams 
@_subject: Can you help me??...I need it! 
WinPT Key Caching
Caching keyrings, please wait . . . Key Cache Error ec=10361968
(.jpg would be a better choice than .pcx - it's a compressed format. Better still, quote the text in the email as above, instead of sending images.)
You'll probably only solve this by using GnuPG at the command line. Can you list your own keys. Try gpg --update-trustdb Have you generated a key of your own? --gen-key
Who says it's you at fault? - Windows isn't exactly innocent in installation errors. I suspect your Registry keys for the install may have been corrupted. Try uninstalling and reinstalling - always worth doing on a Windows system.

@_date: 2004-01-09 20:06:14
@_author: Neil Williams 
@_subject: ultimate trust 
I thought your own keys had to be ultimate trust? If you can't make your own keys ultimately trusted, what is the point of setting 'u' for any other key? Equally, if the secret key is not available, what's the benefit of ultimate trust - wouldn't it be a case of using --always-trust on the command line or as a config option?
Perhaps ultimate trust should be only available if the secret key is also

@_date: 2004-01-09 21:18:33
@_author: Neil Williams 
@_subject: I can't trust my own key? 
You didn't retain the trustdb when you upgraded. gpg shows you the level of trust in your key in the --edit-key screen as -/- untrusted.
Setting your key to ultimate trust will establish the starting point from which GnuPG can calculate how to trust other keys.
Command> trust
enter 5
prompt: are you sure? y

@_date: 2004-01-11 01:20:10
@_author: Neil Williams 
@_subject: Removing signature from signed file 
I've just tried this out on a copy of a tar.gz file - using -s or --sign you'll find that the original file is left intact and unaffected.
$ ls
$ gpg --sign test.tar.gz
$ ls
test.tar.gz If you've deleted that file, I don't see why GnuPG would be expected to replace it. It's done what it can to preserve the signed data even after being given a sub-optimal command.
It's times like these when you start to wonder about an undo command for the command line - not just the bash history but a complete undo recovery. Was there a real situation behind the assumption in the question?
Is there real data that needs to be recovered?
How much time and effort is that data really worth? You can recover most file deletions or corruptions if you throw lots and lots of time and resources into the mix.

@_date: 2004-01-11 01:27:31
@_author: Neil Williams 
@_subject: Removing signature from signed file 
Oops. Sorry to reply in haste - I didn't think to verify it when I did that quick test. Ignore the other reply - it must be time to go to bed.

@_date: 2004-01-11 16:15:00
@_author: Neil Williams 
@_subject: certified with a trusted signature 
BTW: Your key 0xD5EF252D appears to be an ordinary DSA/Elgamal 1024 key with three UID's and unlimited expiry - is there are reason you've put the location of the key in the comment field of your email but not put the key onto keyservers? It means that to verify your signature, I cannot use auto-retrieve as you can to verify my signature. Some people justifiably don't use keyservers when they use signing subkeys and other features that older keyservers tend to not understand, but keyservers are useful things and it will increase the availability of your key. Keyservers are there to make it easier to manage key signatures that will prevent this message:
But none of those people have also signed your key. Key 0xD5EF252D has only been signed by you. Nobody else can therefore trust your key - we'll all get the same message on your key as you do on everyone else's key.
See some of these sites on keysigning:
Because you have signed your own key. Until you also sign someone else's key and someone else signs yours, you won't see any changes. You will always get some keys that are not certified by a trusted signature but the more signatures you make and the more signatures you receive, the more trusted your key becomes.

@_date: 2004-01-11 16:31:14
@_author: Neil Williams 
@_subject: header modification from this list list manager software 
Yes. The signed part is still there but the complete email has to be declared as mixed because there is some text added to the email after the signed part:
Gnupg-users mailing list
This adds another section to the email - one that is not signed.
KMail shows it as:
multipart/mixed containing:
When it leaves your machine, it just has the middle three.
The mailing list manager also adds helpful headers like, what this list is, how to unsubscribe, how to identify the list in filters, where the archives are, etc.
Others are using mutt without apparent problems, perhaps there's a configuration you've changed / omitted?
I'm only just getting used to mutt and haven't used it for mailing lists yet, others on the list should be able to clarify what's happening in your case.

@_date: 2004-01-11 16:37:04
@_author: Neil Williams 
@_subject: header modification from this list list manager software 
If you choose 'e' in mutt to view the entire text of the email, as you received it, you'll find that it is still defined as multipart/signed:
From your post to the list, as I received it:
protocol="application/pgp-signature"; boundary="xxxxx"
Content-Disposition: inline
Is that because the public key could not be retrieved?
Do you get the same with my messages sent via the list?

@_date: 2004-01-13 18:03:32
@_author: Neil Williams 
@_subject: Keyservers not working properly with GnuPG 
Which keyserver did you use?
http_proxy setting required in .gnupg/options perhaps?
either honor_http_proxy or broken_http_proxy as keyserver options.
keyserver-options broken-http-proxy

@_date: 2004-01-27 17:00:26
@_author: Neil Williams 
@_subject: struggling with potential keyid conflicts 
Only if you use the shorthand methods.
Use a longer ID string - e.g. when I sign emails using the OpenPGP plugin, my key is shown in the KMail headers using the longer ID: 0x8801094A28BCB3E3 which represents the last 16 characters of the key fingerprint instead of just the last 8 for the shorter ID of 0x28BCB3E3. It might be easier to remember but it is not unique.
If that conflicts, you could use the entire fingerprint.
In your documentation, if you cover deleting multiple keys from a local keyring you'll find that GnuPG asks you to be clear which ones to delete and recommends the fingerprint in full.
--delete-key name
                 Remove key from the public keyring.   In  batch  mode  either
                 --yes  is  required  or  the key must be specified by finger-
                 print.  This is a safeguard against  accidental  deletion  of
                 multiple keys.
The fingerprint (IIRC) is absolutely unique.

@_date: 2004-01-29 14:49:50
@_author: Neil Williams 
@_subject: Automated importing of keys 
There is a Perl module that can interface directly with GnuPG. It can retrieve public keys from the keyserver specified in the .gnupg/gpg.conf or .gnupg/options file with or without the auto-key-retrieve option. Just install GnuPG::Interface from CPAN, set the correct  in the $homedir variable and populate the  array.
 -w
use IO::Handle;
use GnuPG::Interface;
use strict;
my $homedir = "/home//.gnupg";
my $gnupg;
my $input   = IO::Handle->new();
my $error   = IO::Handle->new();
my $output  = IO::Handle->new();
my $encrypthandles = GnuPG::Handles->new( stdin  => $input,
my $pid;
my my $idlist;
my $gnupg = GnuPG::Interface->new();
$gnupg->options->hash_init( armor => 1, homedir => $homedir );
$gnupg->options->meta_interactive( 0 );
# ===============================================
# Update the keys in the  array in the local keyring
foreach $idlist ( {
$pid = $gnupg->recv_keys( handles => $encrypthandles,
 = <$error>;
close $output;
close $error;
waitpid $pid, 0;
That's a snippet from a working script - it should work unless I've inadvertently omitted a line in the (more complex) original script.
Rather than running this manually, if you use apache or some other process that already runs as the specified user, Perl will behave in the same environment. e.g. you could run it as a .pl file in a cgi-bin or as a cron task or directly from the application (or one of it's supporting scripts). The public key ID strings (in my case) are held in MySQL which makes it simplicity itself to update the list. The script/application/cron can take care of the rest. MySQL can cope easily with only allowing access to the relevant table to certain users.
Ain't open source great!

@_date: 2004-01-31 00:40:09
@_author: Neil Williams 
@_subject: local-key and key on keyserver seems to differ 
There's no comment, no fullname, just your login/username/nicname. Perhaps it'd be good to add a second UID that contains your full name? It's not a big thing but it would help.
Alternatively, put your full details on a website like biglumber so that people can identify you as well as your key.

@_date: 2004-07-14 18:14:24
@_author: Neil Williams 
@_subject: What does `sig!3' mean in the output of `gpg --check-sigs'? 
The exclamation mark is only produced on --check-sigs, it's absent on --list-sigs so it's an indication that the signature is good. All signatures with --check-sigs should have the ! because signatures made by keys not in your key ring are excluded.
The digit is the indication of how much verification took place before signing - when you sign a key, GnuPG asks you how carefully you verified the key, 3 is the highest level - very careful checking. As the man page describes, this is a personal thing and one person's definition of 'very careful' might not match yours. Personally, I mean: I checked the fingerprint against a printed copy given to me face-to-face by the keyholder who proved his/her identity using recognised photo ID (passport, driving licence etc.) and the email address was verified by correspondence.
0 means you make no particular claim as to how carefully you verified the key.
                 1 means you believe the key is owned by the person who claims to own it but you could not, or did  not verify  the  key  at  all.   This  is useful for a "persona" verification, where you sign the key of a pseudonymous user.
                 2 means you did casual verification of the key.  For example, this could mean that you  verified  that the key fingerprint and checked the user ID on the key against a photo ID.
                 3 means you did extensive verification of the key.  For example, this could mean that you verified the key fingerprint with the owner of the key in person, and that you checked, by means of a hard to forge document  with  a photo ID (such as a passport) that the name of the key owner matches the name in the user ID on the key, and finally that you verified (by exchange of email) that the email address on the key belongs to the key owner.
                 Note  that  the examples given above for levels 2 and 3 are just that: examples.  In the end, it is up to you to decide just what "casual" and "extensive" mean to you.
From this section of the manpage:
      --default-cert-check-level n

@_date: 2004-07-20 11:09:44
@_author: Neil Williams 
@_subject: Revocation Certificate 
To revoke a specific key - it is generated in advance so that if you later forget the passphrase you can still revoke the key. (Although you can't do anything else with the key). It is an external file, usually, a simple text file that gpg can import. It is created using the secret key, so you must have the passphrase when you create it, hence why you create it in advance.
Revoke the key that generated the certificate. Nothing else.
Because it does not require the passphrase to import the file and revoke the key - you must take great care about how you store the certificate. Anyone who gets hold of your revocation certificate can revoke your key and there would be nothing you could do to stop it.
Also because without a certificate, if you forget the passphrase to your key it will languish on the keyservers forever as a seemingly active key. No key can be revoked without either the passphrase (and secret key) or the revocation certificate (no secret key needed).
If you still know your passphrase and your key is compromised, it still needs to be revoked and a certificate will still need to be created, imported and the updated key sent to keyservers. A stored certificate is just there in case you forget the passphrase or lose the secret key in some hard disc drama. (You must have a backup secret key if you want to continue using the Revocation is about helping others - when you know the key is unusable/compromised, revocation lets everyone else know too.

@_date: 2004-07-21 19:45:48
@_author: Neil Williams 
@_subject: Problems with keys 
Is this a binary file or an ASCII file?
How was it transferred between platforms / machines? Sometimes these things can go wrong when you transfer it as ASCII when it's binary.
If you have the list of key ID's the best way is to now get updated versions from the keyservers - outdated keys from an old file are not much use to Use gpg --keyserver subkeys.pgp.net --recv-keys keyID

@_date: 2004-08-02 16:17:31
@_author: Neil Williams 
@_subject: Can't locate public key or pubring.gpg - followup 
Then you need an email client that is security-aware - specifically PGP / GnuPG aware. On Linux, that's KMail, Mutt, Mozilla Thunderbird, Mozilla Mail and others. On Windows you want Eudora or Mozilla Thunderbird / Mozilla Mail. Mozilla on either platform needs the Enigmail plugin - don't know much about enigmail on Windows except that it works.
Mozilla Thunderbird/Mail with enigmail also works on MacOSX.
Yes. You need access to the keys as an ordinary user so if you copy the files, make sure you use chown to set it to the username instead of root. If the username is servie, you'd need:
# chown -R servie.servie .gnupg/
(Some Linux distros may require servie.staff or servie.users)
Then logout of root (never a good idea to be in root) and copy the files. To prevent warnings from GnuPG, check the permissions on each file before and after the copy, use chmod to change.
No point, you've got perfectly usable keys, just not the permission to access them as a user.
Yes, IF you change the ownership of the files once they are in /home/servie as root - you can't use files that are still owned by root when logged in as a user. Use ls -l to show the ownership and chown to change.
Once the files are readable by servie, yes.
1. Sort out your GNU/Linux internet connection and send from GNU/Linux.
2. Sort out your Windows installation and sign within Windows.
Only because you are using the wrong email client.
A competent email client is the first requirement.
Now, see, that's where it goes pear-shaped. Using yahoo or any webmail service with signed emails is a PITA. Get a decent email client and sign automatically - it's just a case of entering the passphrase once in a while. The client does the rest.
I'd say one or t'other. Sending a file encrypted with GnuPG over an SSH connection is overkill. If SSH isn't good enough, just use GnuPG. If GnuPG isn't good enough, don't use the internet to send it!
P.S. PLEASE strip unnecessary lines from your replies. Poor quoting will put people off helping you.

@_date: 2004-06-15 19:54:27
@_author: Neil Williams 
@_subject: Expired signature 
I hope that this isn't covering old ground, I've been away and haven't been able to contribute for a few weeks.
Which version of GnuPG are you using? I thought this was fixed in v1.2.4 so that expired signatures can be re-done - it's not exactly a refresh because the expired one is still shown on keyservers etc., but a new signature is made so that the key can be included back into the web of trust. I made a signature on a friend's key before he changed his key expiry date. When the main key expired, so did my old signature.  He changed the expiry and I used GnuPG 1.2.4 to re-sign the key. Take a peek at 0x8F455606 to see the result.
pub  1024D/8F455606 2002-11-01
sub  2048g/AB55D8A0 2002-11-01 [expires: 2003-11-01]
sub  2048g/51A28915 2003-11-01 [expires: 2004-10-31]
The old subkey is expired, the new one is usable. (This has implications for the keyservers that you use too, old keyservers don't like keys like this In the snipped signature list, note the expired sigs (X) and the new ones.
pub  1024D/8F455606 2002-11-01
sig 3       8F455606 2003-11-01 sig 3       8F455606 2002-11-01 sig 3       28BCB3E3 2003-12-22   Neil Williams (CodeHelp) sig 3       A897FD02 2003-12-22   Neil Williams (laptop) sig 3     X 28BCB3E3 2003-02-03   Neil Williams (CodeHelp) sig 3     X A897FD02 2003-02-03   Neil Williams (laptop) sub  2048g/AB55D8A0 2002-11-01 [expires: 2003-11-01]
sig         8F455606 2002-11-01  sub  2048g/51A28915 2003-11-01 [expires: 2004-10-31]
sig         8F455606 2003-11-01

@_date: 2004-06-16 10:08:45
@_author: Neil Williams 
@_subject: RSA keys for encryption and in general DSA/RSA/ElGamal-keypairs 
You answered this question yourself in the quote from the The GNU Privacy Others here can explain why DSA has a maximum size, but the handbook is clear - no matter what you ask gpg to do for the Elgamal key, no DSA key will be created larger than 1024 bits (or smaller than 512). Different algorithms have different strengths, different potential weaknesses and limitations.
GnuPG defaults to the strongest and most suitable algorithm for each use of the most commonly generated keys. When signing this message, I don't really want a signature MIME part that is larger than the message, as some large bit length keys may produce. When encrypting a message, final size is less important than the strength of the algorithm/encryption. Using the same algorithm for both signing and encrypting requires an algorithm that is good at both - sometimes this is too much of a compromise and the best option is to use different algorithms for each purpose within the key.
So DSA is good for signatures but the limitation on key size (and probably other features that I don't get into) make it unsuitable for encryption. Conversely, Elgamal is good for encryption but there was an issue with Elgamal when used for signatures, so Elgamal is no longer recommended for Nothing. If you ask gpg for the fingerprint of the subkey, the same fingerprint is produced:
neil gpg --fingerprint 0xA897FD02
pub  1024D/A897FD02 2002-01-27 Neil Williams (laptop)      Key fingerprint = 744C 978D 7AB8 F27B 3BA6  C101 93B0 D5AF A897 FD02
sub  1024g/4D6D2952 2002-01-27
neil gpg --fingerprint 0x4D6D2952
pub  1024D/A897FD02 2002-01-27 Neil Williams (laptop)
     Key fingerprint = 744C 978D 7AB8 F27B 3BA6  C101 93B0 D5AF A897 FD02
sub  1024g/4D6D2952 2002-01-27
gpg takes care of that on your behalf.
Why? If it was possible to obtain the two figures directly, instead of having to compute them, cracking gpg encryption becomes simple. I don't expect that this is what you intend!
What does --list-key show? Is there an encryption subkey?
It's best to quote the KEYID when comparing a working key with a non-working key - it allows others to compare the keys directly, instead of constantly asking you to run certain options and re-post the output. If your test key isn't for 'real' use, put the keyblock in the message (just the once) rather than using keyservers.

@_date: 2004-06-16 10:21:11
@_author: Neil Williams 
@_subject: how to transfer a secret key to another comp? 
You are asking gpg to sign the file without specifying a key to use to create the signature, either as a default key (~/.gnupg/gpg.conf) or on the command from man gpg:
      -u, --local-user name
                 Use  name  as the user ID to sign with.  This option is silently ignored for the list commands, so that
                 it can be used in an options file.
laptop:~/$ gpg -u KEYID --sign testfile
or in ~/.gnupg/gpg.conf :
default-key  KEYID
You can always override the default if you have a second secret key to hand:
neil gpg -u a897fd02 --sign dead.letter
You need a passphrase to unlock the secret key for
user: "Neil Williams (laptop) "
1024-bit DSA key, ID A897FD02, created 2002-01-27
neil gpg --verify dead.letter.gpg
gpg: Signature made Wed Jun 16 09:23:13 2004 BST using DSA key ID A897FD02
gpg: Good signature from "Neil Williams (laptop) "

@_date: 2004-06-16 10:40:25
@_author: Neil Williams 
@_subject: gpg problem while decrypting 
So whose key contains ID 3E07473B? User-A or User-BCD?
But who is it encrypted TO, that's crucial. What recipient did you specify?
But each have their own keyrings in their own ~ space. Each should only have their own secret key. It gets confusing when you use hidden or generic names for users and then don't specify the keyid's for both. It makes it easier to help if you specify the exact command line (remove the email address if you like, but the keyid's are best left in).
A full example:
Garfield has the secret key for 0x28BCB3E3 and the public key for 0xA897FD02.
neil gpg -a -r 0xA897FD02 -e dead.letter
neil scp dead.letter.gpg laptop:
'laptop' has the secret key for 0xA897FD02 and the public key for 0x28BCB3E3.
neil gpg --decrypt dead.letter.gpg > dead.letter2
neil gpg -a -r 0x28BCB3E3 -e dead.letter2
neil scp dead.letter2.gpg garfield:
neil gpg --decrypt dead.letter2.gpg
If you don't specify a recipient and gpg still encrypts, you've got a default encrypt setting in ~/.gnupg/gpg.conf which is 'hiding' the error. The encrypted file will then be encrypted using the default key as no recipient was given. In my example, this would cause dead.letter.gpg to be encrypted to 0x28BCB3E3 (garfield's key) - laptop (in my example) would not be able to decrypt it.
Similarly, with 0xA897FD02 as default encrypt key on the laptop, dead.letter2.gpg would be encrypted to 0xA897FD02 (the laptop key) not the intended garfield key 0x28BCB3E3. Garfield would not be able to decrypt.

@_date: 2004-06-16 10:52:45
@_author: Neil Williams 
@_subject: Duplicated User IDs arisen 
Looks like that keyserver is broken. Use a up to date keyserver:
Or use subkeys.pgp.net
neil gpg --recv-key 0x2A623F72
gpg: key 2A623F72: public key "Christoph Probst " imported
gpg: Total number processed: 1
gpg:               imported: 1
neil gpg --list-key 0x2A623F72
pub  1024D/2A623F72 2003-11-17 Christoph Probst
uid                            Christoph Probst uid                            Christoph Probst sub  2048g/7F5A2741 2003-11-17 [expires: 2008-11-15]
Only two UID's imported.
Repeat that using a working keyserver.
I'd say this is all the keyserver's doing.
The doubles only exist on the broken keyserver - repeat the process of deleting and receiving using a working keyserver and all should work. There's nothing you can do about the bad keyserver except to ignore it.
Tell everyone you know not to use old keyservers and why.
It probably has but I'd never notice and if anyone complains, it's simple to point them towards a better keyserver.

@_date: 2004-06-17 10:12:25
@_author: Neil Williams 
@_subject: how to transfer a secret key to another comp? 
Which machine was this on?
gpg --delete-secret-key 0xE0807C30
Make sure it's gone by listing the secret keys:
gpg --list-secret-keys
Umm, did you actually delete the secret key from the laptop or from the other machine? It's the laptop keyring that needs the secret key removal.
If you've done what I think you've done, you need to re-import gpg.sec on the other machine. Use --list-secret-keys on both machines and find out where you

@_date: 2004-06-19 15:09:49
@_author: Neil Williams 
@_subject: Deleting uids from a public key 
Deletion only works for local keys, keys that are already on keyservers should have old UID's revoked instead.
Keyservers only ever add details, never subtract. Once a key is on a keyserver, it remains available for as long as keyservers continue to synchronise.  This is why anything on your key that is out-of-date should be I can delete a UID from your key with no need for secret keys or passphrases - it'll just re-appear as soon as the key is refreshed. Subkeys are different, but UID's can be deleted by anyone, anytime. There's little point in doing so if the key came from a keyserver in the first place.
Keyservers don't remove, they merge the incoming data with any existing data. The only things that can change your key once on a keyserver are new signatures, new UID's, revoked UID's, revoked sigs and revocation certificates for the key itself.

@_date: 2004-06-21 22:01:24
@_author: Neil Williams 
@_subject: Strange behaviour on MacOSX 
I just emailed atom about this but although I know atom likes tinkering with his keys, it might not be the key that is wrong. I think there's something strange going on with GnuPG 1.2.4 on MacOSX. When I verify this email on my iBook I get:
fergus:~ neil$ gpg --verify Documents/atom.eml
gpg: Signature made Mon Jun 21 19:48:26 2004 BST using DSA key ID 3D7D41E3
gpg: Good signature from "Atom Smasher "
gpg:                 aka "Atom Smasher "
gpg: WARNING: This key has been revoked by its owner!
gpg:          This could mean that the signature is forgery.
gpg: reason for revocation: Key is superseded
gpg: revocation comment: This key has been superseded by:
gpg: revocation comment: 4096R 0x762A3B98A3C396C9C6B7582AB88D52E4D9F57808
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the Primary key fingerprint: 3EBE 2810 30AE 601D 54B2  4A90 9C28 0BBF 3D7D 41E3
When I verify the same email on my PC (running the same version of GnuPG on Debian unstable) I get:
neil gpg --verify atom.eml
gpg: Signature made Mon Jun 21 19:48:26 2004 BST using DSA key ID 3D7D41E3
gpg: Good signature from "Atom Smasher "
gpg:                 aka "Atom Smasher "
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the Primary key fingerprint: 762A 3B98 A3C3 96C9 C6B7  582A B88D 52E4 D9F5 7808
      Subkey fingerprint: 3EBE 2810 30AE 601D 54B2  4A90 9C28 0BBF 3D7D 41E3
I can scp the email back and forth, delete the original key (that came from keyserver.kjsl.com) and use the key from a file from atom's own website and no difference.
What might be going on?
Here's --check-sigs from the MacOSX box:
fergus:~ neil$ gpg --check-sigs d9f57808
pub  4096R/D9F57808 2004-05-11 Atom Smasher sig!3   P   D9F57808 2004-05-12   Atom Smasher uid                            Atom Smasher sig!3   P   D9F57808 2004-05-12   Atom Smasher sub  1024D/3D7D41E3 2003-10-04 [expires: 2006-01-25]
sig!        D9F57808 2004-05-12   Atom Smasher sub  2048g/1E88BF71 2003-10-04 [expires: 2006-01-25]
sig!        D9F57808 2004-05-12   Atom Smasher and again from the PC:
neil gpg --check-sigs d9f57808
pub  4096R/D9F57808 2004-05-11 Atom Smasher sig!3   P   D9F57808 2004-05-12   Atom Smasher uid                            Atom Smasher sig!3   P   D9F57808 2004-05-12   Atom Smasher sub  1024D/3D7D41E3 2003-10-04 [expires: 2006-01-25]
sig!        D9F57808 2004-05-12   Atom Smasher sub  2048g/1E88BF71 2003-10-04 [expires: 2006-01-25]
sig!        D9F57808 2004-05-12   Atom Smasher I can't see any difference in the key.
BTW. What does the P mean?

@_date: 2004-06-22 01:34:19
@_author: Neil Williams 
@_subject: Strange behaviour 
Excellent, thanks. The other box had deleted both the old keys when they showed up as revoked on the last refresh. It's sorted on the other box now - nice to know it was something simple.

@_date: 2004-06-22 15:07:52
@_author: Neil Williams 
@_subject: Truncated file in GPG? 
You might find better results if you can use Debian testing or unstable - I've been using unstable for months now without problems. GnuPG in unstable is v It might not even be Linux specific, see later.
Where is this command being executed? There have been problems encrypting large files on Windows and this might be down to Windows memory management (which wouldn't affect you) or Windows filesystem management (which could). Do an md5sum of the original file, copy it to a genuine Linux filesystem, md5sum it and compare. Then try the encryption.
But probably only contains 60Mb of mail. (Been there, done that.) It would be easy if you could export mail messages as files in a batch operation.
?? Last time I used it, it was a completely bloated format!
One option: use a utility to farm these messages out into a directory as discrete files - far easier to view and read later. I had horrendous trouble getting archived mailboxes back into MS clients before I adopted KMail. I now use MHonArc (a perl script) to archive the mail into HTML. It's far easier and it's how most mail archives operate across the web. Easy to read, well indexed, easy to search. Example:
Eudora can be very useful in converting different mailbox formats and it writes into a true Unix/Linux format.
Anything that converts into a open standard is going to make it easy to archive, encrypt and process.

@_date: 2004-06-28 00:55:42
@_author: Neil Williams 
@_subject: missing subkey 
This hasn't appeared after 24hrs, re-posting.
Was anyone else able to verify Stoyan's message on the list (Re: Detection of sign-only vs. sign-and-encrypt keys) Yesterday 1:12:04 and again today?
I use Debian unstable, GnuPG 1.2.4 and --auto-key-retrieve and --include-subkeys with keyserver.kjsl.com but the subkey is not found, even though the main key is imported seemingly successfully. The subkey shows up on the search results page using a www interface, but it is not imported.
Here's my output:
 gives the main key as 0xB8D71FB6 - which I already have in the keyring:
gpg: Signature made Sat Jun 26 07:59:42 2004 BST using DSA key ID 1E3D95C3
gpg: key B8D71FB6: "Stoyan Dimitrov " not changed
gpg: Total number processed: 1
gpg:              unchanged: 1
gpg: Can't check signature: public key not found
Your key only shows up with one subkey, 5831A000
neil gpg --delete-key B8D71FB6
gpg (GnuPG) 1.2.4; Copyright (C) 2003 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.
pub  1024D/B8D71FB6 2004-06-15   Stoyan Dimitrov
Delete this key from the keyring? yes
neil gpg --import
(pasted the key block as on this page:)
gpg: key B8D71FB6: public key "Stoyan Dimitrov " imported
gpg: Total number processed: 1
gpg:               imported: 1
neil gpg --list-key  B8D71FB6
pub  1024D/B8D71FB6 2004-06-15 Stoyan Dimitrov
uid                            Stoyan Dimitrov
uid                            Stoyan Dimitrov (stoyanski) sub  2048g/5831A000 2004-06-15
No second subkey, despite it being shown on the search page.
I also tried my preferred keyserver and had the same result. The subkey shows in the results but is not imported.
I've sent this to the list as well because I can't see what has happened to the key and how the second subkey can be imported.

@_date: 2004-06-28 02:12:23
@_author: Neil Williams 
@_subject: missing subkey 
Sorry, I don't understand what you've done with uuencode there, I can't get the second subkey, even though it's listed in the web interface and biglumber.com doesn't have any matches:
Search results for "1D0E12EDBE255476430CDB418C12BBBAB8D71FB6"
Sorry, no matches were found.
No change at this end.

@_date: 2004-06-29 20:08:03
@_author: Neil Williams 
@_subject: missing subkey 
Was anyone else able to verify Stoyan's message on the list (Re: Detection of sign-only vs. sign-and-encrypt keys) Yesterday 1:12:04 and again today?
I use Debian unstable, GnuPG 1.2.4 and --auto-key-retrieve and --include-subkeys with keyserver.kjsl.com but the subkey is not found, even though the main key is imported seemingly successfully. The subkey shows up on the search results page using a www interface, but it is not imported.
Here's my output:
 gives the main key as 0xB8D71FB6 - which I already have in the keyring:
gpg: Signature made Sat Jun 26 07:59:42 2004 BST using DSA key ID 1E3D95C3
gpg: key B8D71FB6: "Stoyan Dimitrov " not changed
gpg: Total number processed: 1
gpg:              unchanged: 1
gpg: Can't check signature: public key not found
Your key only shows up with one subkey, 5831A000
neil gpg --delete-key B8D71FB6
gpg (GnuPG) 1.2.4; Copyright (C) 2003 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.
pub  1024D/B8D71FB6 2004-06-15   Stoyan Dimitrov
Delete this key from the keyring? yes
neil gpg --import
(pasted the key block as on this page:)
gpg: key B8D71FB6: public key "Stoyan Dimitrov " imported
gpg: Total number processed: 1
gpg:               imported: 1
neil gpg --list-key  B8D71FB6
pub  1024D/B8D71FB6 2004-06-15 Stoyan Dimitrov
uid                            Stoyan Dimitrov
uid                            Stoyan Dimitrov (stoyanski) sub  2048g/5831A000 2004-06-15
No second subkey, despite it being shown on the search page.
I also tried my preferred keyserver and had the same result. The subkey shows in the results but is not imported.
I've sent this to the list as well because I can't see what has happened to the key and how the second subkey can be imported.

@_date: 2004-07-06 16:42:43
@_author: Neil Williams 
@_subject: Duplicated User IDs arisen 
So those changes will be insulated from the effects of synchronising with other keyservers? (You are going to synchronise?!)
Why do it this way when you could just accept keys as they are - let the owners edit the key on their own systems - the keyserver would simply accept the key AS-IS and not do any merge operations. In effect, overwrite the current key with the new.
Logically, you would then change synchronising so that it works this way:
1. If I don't have the key, take a copy
2. If I do have the key, accept revocations only.
(Presumably you are not going to allow anyone to un-revoke a key).
(If the user has deleted the entire key, what then? You can't simply ignore all new keys when synchronising, you'd have to keep a log of the fingerprint and reject keys you know to have been deleted. Seems odd.)
Users would need some sort of login and then be able to upload a changed key that would overwrite any existing copies.
Is it worth the bother?

@_date: 2004-07-06 16:42:48
@_author: Neil Williams 
@_subject: Gpg 1.2.4 with The Bat 2.11 error 
Please send your key to a keyserver - there's no point signing emails if the reader cannot verify the signature by downloading your public key.
gpg --keyserver subkeys.pgp.net --send-key 0x29D7378D
So you have this as the default key, that's OK.
It just means that you don't need to specify -r 29D7378D when you encrypt to anyone else.
You haven't signed this key with 0x29D7378D so gpg can't verify that this is the key that you say it is. (I can tell that because D6506963 is on the IF you have verified the fingerprint with the user of D6506963, and checked the email address and photo ID, then sign the key and you'll be able to encrypt. Read about keysigning before making a public declaration that you have personally verified D6506963 by signing it.
Because only your own key is trusted so far.
Lack of trust in the other key.

@_date: 2004-03-06 14:26:16
@_author: Neil Williams 
@_subject: gpg --list-sigs (root for other users) 
Hash: SHA1
Why would you want to?
GnuPG will justifiably warn you about permissions on the user's folder.
However, you can just user --homedir
# gnupg --homedir /home/someuser/.gnupg --list-keys
A worthy reminder that no-one should keep a secret key on ANY box where the owner of that secret key does not have root permissions on the box.

@_date: 2004-03-09 09:14:33
@_author: Neil Williams 
@_subject: gpg --list-sigs (root for other users) 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
?? If they don't care about security, why are they using a security product ??
Anyone using a secret key in this environment deserves never to have their key trusted! Looks like I need to add another question to my keysigning protocol. "Have you ever stored your secret key on any installation or media to which you did not (at all times) have sole access as root?"
I'd never sign a key where the owner is so casual about security. How can I trust the signature - it could be you or it could be the user. How can I encrypt to the key if the secret key is accessible to you and the owner?
There are ways, yes. Keep the secring.gpg on a USB stick etc. and when the user wants to sign something, use --homedir to access the secret keyring on the removable media. If you don't keep the public keyring there, you can make the media read-only for better security.  If it is read-write, a simple bash script can update the public keyring on the workstation with keyids from the removable media. This one-liner produces a list of keyids in one public keyring:
gpg --list-keys --with-colons | grep "pub:-:" | cut -d: -f5
Then pass the output to gpg --recv-keys on the other machine to create a sync.
I just needed to do this once, so I used a Perl script to parse the content one-line at a time and give the gpg --recv-keys command. I'm sure someone here can come up with a more efficient method. (Perhaps replace \n with a space and tack the whole construct onto one gpg --recv-keys command?)
This way, you can still sign in a public environment without compromising your secret key but ONLY because your secret key never gets stored on the public The security of the removable media then becomes imperative. (i.e. do NOT keep the revocation certificate on the same removable media!!)
IMHO, any secret keys that are accessible to more than the sole verifiable owner of the key MUST be revoked as hopelessly compromised. Anyone not willing to keep their secret key SECRET (i.e. only available to the sole verifiable owner) should never have their key signed and must be strongly advised to change their ways or risk having their key revoked by force. (With the secring.gpg file in your hands, a simple dictionary attack could undo many passphrases on the assumption that those who care this little for secret key security aren't going to have chosen a decent passphrase either.)

@_date: 2004-03-09 20:21:31
@_author: Neil Williams 
@_subject: gpg --list-sigs (root for other users) 
A targeted attack is always more of a problem. If someone really is out
to get you, there will be a way to compromise the key.
No. :-))
I never would, it was just a possible solution for someone else's
problem. I agree it isn't a whole lot better but it was the best I could
come up with at the time. As the manual says, it depends on your level of paranoia.
Agreed. Thankfully, I'd never take such a risk with my secret key.

@_date: 2004-03-09 20:28:12
@_author: Neil Williams 
@_subject: extensions of files when decrypting 
That's the problem - why can't it be file.zip.pgp or file.zip.gpg?
If you reverse the process, Linux will convert a file.tar.gz into a
It doesn't make any odds, Linux doesn't rely on the extension anyway. If
it's a zip file, it can be unzipped - no matter what the filename or
Use mv if you really want to have the extension:
mv file file.zip
The idea that files only have one . and the extension being the sole
determinant of the content is a DOS artefact. There is no reason to
continue with such convensions.

@_date: 2004-05-02 09:14:33
@_author: Neil Williams 
@_subject: OT: Revoking Old Keys... my problem 
Yes, edit the key and set a new expiry. This will cause problems for some (broken/old) keyservers so make sure that you upload the key to a capable keyserver: subkeys.pgp.net or keyserver.kjsl.com are my two favourites.
from man gpg:
    --edit-key name
                 Present a menu which enables you to do all key related tasks:
When you upload it, the new self-signature will be added to the keyserver copy of the key which will allow gpg to show the new expiry.

@_date: 2004-05-02 09:33:34
@_author: Neil Williams 
@_subject: OT: Revoking Old Keys... my problem 
There is. Advocate GNU/Linux for your workplace every 10 seconds until you're either fired or pacified.
Get a Tux tie, use pro-Linux banners on your internal email sigs, use Linux post-it notes, Linux mugs, Linux baseball cap/T-shirt if allowed, become a complete pain-in-the-**** until someone asks why.
If your workplace doesn't have the kind of clout required to implement any IT change, join a forum or workplace committee that does. Read up on Linux, use Linux exclusively and prove to everyone that it works.
You're the one person best suited to changing opinions in your workplace.
There must be a better mailing list for this discussion! Try joining a local LUG and getting help from that section of the community. For the UK, start at  - or for international LUG's start here:

@_date: 2004-05-05 17:43:49
@_author: Neil Williams 
@_subject: How do I choose different private keys to sign different 
use the -u option to specify which keyid to 'use'
It's in the man page. I'd use:
gpg -u 0xA897FD02 -as somefile
to sign a file with my secondary key
The same applies when editing/signing keys.
gpg -u 0xA897FD02 --edit-key somekey
gpg -u 0xA897FD02 --sign-key keyid

@_date: 2004-05-05 19:43:35
@_author: Neil Williams 
@_subject: gpg utils W9x vs. Linux 
That doesn't leave you a lot of room - that's less than 3Gb each with swap?
Time for a second hard drive?
Mozilla and OpenOffice.org are fairly unique in running on multiple platforms, most other programs don't. Doesn't look like gpgshell does either.
So that's a GUI shell on top of GnuPG for Linux. That's OK, almost exactly the same functionality as gpgshell comes as standard in KDE 3.2 using KGpg. You need a fairly recent KDE though. KGpg is KDE only. KDE does not run on Windows 95/98/NT or OS/2 (yet). To run KDE, you need to have a UNIX system. There are other GUI frontends for Linux, see the gnupg documentation:
Linux will normally mount the windows partition for you and Mozilla will import it's own settings from the windows files. Make a note of where these are stored on your windows system before you boot Linux.
The keys can be imported by GnuPG, using the appropriate --import and --import-ownertrust commands. Make sure you use --export-secret-keys when exporting or you'll lose the ability to sign, edit or decrypt. Then use --export-ownertrust and redirect it to a file.
gpg --export-ownertrust > trustfile.gpg
Make sure you then test your gpg installation, make sure you can encrypt and decrypt as well as sign and verify files, then delete the exported files - you don't want your exported secret key file hanging around!

@_date: 2004-05-05 21:35:18
@_author: Neil Williams 
@_subject: OT: Revoking Old Keys... my problem 
GnuPG documentation advice is that this comes first, immediately after generating the key. It isn't affected by anything you do to the public key after generation.
Not mandatory or AFAIK default. Your key is already self-signed in the normal way - it was done during generation. It will also be self-signed again each time you make changes to the key such as new UID's etc.
IMO, non-revocable signatures are probably reserved for special uses of GnuPG/PGP where secondary security or precautions are used/required.
Only by adding another UID - your comment is part of your user identity and cannot be changed - same as your email address. You can only add, not modify.
Already done by default. Generate the revocation cert. NOW.
Only by editing the key and adding a second UID.
The documentation order is revocation cert first, everything else as and when you feel like it.
The bigger the keysize the bigger the signature on emails etc. It's a personal Most keys out there are 1024.

@_date: 2004-05-10 12:42:06
@_author: Neil Williams 
@_subject: [OT?]: Keyserver / Subkeys / replicating selfsigs 
Use a keyserver that supports subkeys like subkeys.pgp.net
Wrong keyserver.
Some keyservers are OK.
The long list of self-sigs is clearly visible but, personally, I've no idea why there are so many.

@_date: 2004-05-15 14:38:50
@_author: Neil Williams 
@_subject: key-signing for pseudonyms 
If you don't correspond with that person in an environment where that alias or nickname is regularly used, don't sign that UID. There is no other reliable method of verification. When you verify the key face-to-face, you can always ask about the nickname, where it's used and verify it later before actually signing the key.
No, IIRC, we've had this discussion about photo ID's before - IMHO, photo UID's are of use when you are hoping to meet someone for the first time because they help you find each other at the pub/event. However, the photo ID would need to be verified face-to-face when most people would want to see separate photo ID like a passport anyway. It would be helpful to sign the photo UID when you have verified a passport face-to-face, I suppose (for others to know that it has been checked), but I can't see much more use than that. I certainly don't think that a photo UID has any effect on the credibility of the rest of the key simply as a photo.

@_date: 2004-11-15 20:26:39
@_author: Neil Williams 
@_subject: using gpg remotely over ssh? 
The more important question is: Do you have the root password for this remote machine? Does anyone else? Is that what you mean by trust?
It's your decision, but I wouldn't put my secret key on any remote machine. If it's hosted on someone else's system your secret key could be available to a third party. With the secret key in their possession, only an attack on your passphrase protects your secret key from being compromised.
Isn't there another way of doing this? Why not decrypt and sign locally? SSH has a complimentary SCP that can copy the required files over ssh.
Just have any necessary public keys on the remote machine, encrypt and verify signatures if you want to, then copy the files to your local machine for decryption and back again if you are sending up signed files.

@_date: 2004-11-17 10:09:21
@_author: Neil Williams 
@_subject: Of Public Key Servers, Revocation and Key ID's 
Yes. Keep it safe, don't keep it on your filesystem and don't keep it anywhere that someone will be able to find it or where you might enter it accidentally. Many people print them out, it's only a few lines of text.
Import the revocation certificate into your local keyring and then send the revoked key to the keyserver. Anyone can do this, once they have access to the revocation certificate they don't need access to the secret key, so be careful where you store it!
$ gpg --import revcert.asc
$ gpg --keyserver subkeys.pgp.net --send-key 0xKeyID
Most keyservers have a web interface that will show you the status of the key.
1. Export your public key to a file.
2. Delete your own public key from your local keyring.
3. Import your public key from the keyserver.
4. Verify it has been revoked.
We have to meet in person, exchange key fingerprints and verify photo ID. Then we sign each other's keys. The signed keys are uploaded to keyservers. People who trust me to properly verify keys will usually accept yours as verified.
Potentially yes, it makes things awkward but not difficult. You should always revoke a key that is:
1. compromised or
2. the only UID is invalid (e.g. the specified email account no longer operates) or
3. the key itself is no longer in use or
4. if you've forgotten the passphrase for your secret key.
Revoking a key prevents anyone using it to encrypt to you. It should be used when either the encrypted message could be read by someone else or when you no longer have the ability to receive and/or decrypt the message using that Please read the FAQ's before posting.

@_date: 2004-11-17 12:08:38
@_author: Neil Williams 
@_subject: Newbee question 
To do this, the server needs the secret key of the client. This may be insecure. Can't the server have it's own key? Does the server need a key at all - if you just want to encrypt something during transport, use SSH and it's partner scp which use the same security as https://
You haven't exported the secret key yet - it's a separate option because it has security implications and shouldn't be used without thinking through the problems. Once you export a secret key and copy it to another machine, the chances of the key being compromised increase. If this is to be your personal key, it would be better to use a key for you and a separate key for the server. Better still, find a way for the server to not do the decryption itself if you cannot solve the security problems. gpg -a --export-secret-key gpg > mysecretkey.txt
And mysecretkey.txt
gpg --import mysecretkey.txt
gpg is right, the secret key needed to decrypt the message (the client secret key) isn't available.

@_date: 2004-11-17 17:53:39
@_author: Neil Williams 
@_subject: Compiling gnupg for mipsel 
You've used strip?
man strip
strip - Discard symbols from object files.
Packaging schemes will strip the debugging symbols but when compiling from source, it's usually left to you because if you are developing code, you need debugging symbols to work with gdb etc.
Stripping one of my own library files compiled from a tarball makes it go from 53Kb to 9.3kb - a 6 fold decrease that should bring your 3.6Mb closer to Sometimes, strip can be put into the make options or it can be done in preparing the package.

@_date: 2004-11-17 18:02:38
@_author: Neil Williams 
@_subject: (foulty) revoking key 
(Blame your OS - there's no reason for a revocation certificate to have an automatic action, it should be described as text/plain and load in a text editor, NOT gpg.)
Good - if you'd done the next bit properly. As it turns out, sending to the keyserver was a bad thing.
BAD!!! There was no need to delete the secret key (or the revocation Panic is NOT a good tutor.
You can't. You need one of two things:
1. the secret key AND passphrase (neither is adequate on their own) OR
2. the revocation certificate.
There's nothing you can do, your original key now joins the army of redundant keys on keyservers that can never be used or revoked.
Next time, PRINT the revocation certificate, DELETE the revocation certificate FILE and keep the print out very safe.
THINK before you go for the shredder.

@_date: 2004-11-20 19:36:26
@_author: Neil Williams 
@_subject: Two different problems 
A revocation certificate is bound to a certain key - if you imported the revocation certificate for 0x42020537, it would be revoked on your local system. The certificate for 0x42020537 cannot revoke any other key.
Check your key listings and send the key to keyservers to revoke it. Neither key is currently showing as revoked.
Receiving a key from a keyserver merges the keyserver copy with the local copy - if the keyserver copy is not revoked, the --recv-key operation will have no effect. To undo a local error on your key, you must first delete the local copy of your public key and then receive the keyserver version.
Use a different keyserver, it was found perfectly on subkeys.pgp.net and keyserver.kjsl.com - other keyservers are usually not worth using.

@_date: 2004-11-23 18:11:05
@_author: Neil Williams 
@_subject: PGP encrypt/GnuPG decrypt problem 
WOAH! Why on earth are you running this as ROOT!!?? A: No good reason. Do not login as root, don't run userland programs as root, don't spend any longer than you absolutely must in a root environment.
1. Check you can encrypt and decrypt on the one box first. Encrypt a file using GnuPG and decrypt it using GnuPG without transferring it.
2. You presumably have a key in PGP that has a secret key, try the reverse - encrypt in GnuPG to PGP.
That's normally the subkey used to encrypt the message. e.g. with my key:
gpg: encrypted with 1024-bit ELG-E key, ID AD3CB326, created 2002-01-27
The public key is:
pub  1024D/28BCB3E3 2002-01-27 Neil Williams (CodeHelp) uid                            N Williams (CodeHelp) uid                            Neil Williams (general) uid                            Neil Williams (Linux User Group) uid                            Neil Williams (Devon and Cornwall LUG) sub  1024g/AD3CB326 2002-01-27
Check for that subkey in your PGP keyring.

@_date: 2004-10-15 13:19:00
@_author: Neil Williams 
@_subject: Can a new version use old keys? 
More information needed, but generally the keys will continue to work. There are some keys that 1.2.1 can use that 1.0.6 cannot so it's best to upgrade So what (exactly) is the error message?
What kind of keys are you using (gpg --list-key keyid)
What are you using to decrypt on Windows? WinPT or PGP?
Can you decrypt the files on GNU/Linux?
(i.e. before you send them)
Can you decrypt files sent from the Windows box on the GNU/Linux box?
How are you transferring the files?
Are you using ASCII armour for the encrypted files? (Make sure if you are then using FTP to use ASCII transfer, not binary).

@_date: 2004-10-23 20:25:31
@_author: Neil Williams 
@_subject: Reload keys 
PGP might be skipping the trust database check. You can do the same but GnuPG will prompt you to run --check-trustdb from time to time (like when new keys are imported or existing ones refreshed) so that might be something to do via cron or Task Scheduler (if that still exists on Windows).
I use no-auto-check-trustdb in gpg.conf and gpg --check-trustdb in cron, at least once a week, plus manual --update-trustdb to catch up with new keys with no user trust level (which check- won't do).

@_date: 2004-10-31 09:08:54
@_author: Neil Williams 
@_subject: iconv.dll redux 
.dll files are only for Windows. You don't need iconv.dll for GNU/Linux.
No, not needed.
What error in the ./configure make make install caused you to think that this file was needed?
$ ./configure
(the dot and slash are required)
$ make
$ su
# make install
Binary files from one operating system are not compatible with binaries from If this is Knoppix, why not use apt?
As root, # apt-get install gnupg gpa mozilla-thunderbird mozilla-thunderbird-enigmail
There's no need to compile any of these unless you want the absolute latest versions. If you learn a bit more about Knoppix and Debian, you can switch to the testing version of Debian and get the current releases. Default 'stable' might be a little old.

@_date: 2004-09-03 21:10:47
@_author: Neil Williams 
@_subject: Q: Local keyring security, attacks and lsign 
As you noted, you got a VALID signature, not a trusted signature. IMHO, a valid signature on the GnuPG code isn't good enough, for exactly the reasons you describe later.
Your best solution is your personal trust level, not lsign. Later . . For your peace of mind, my Web of Trust allows me to fully trust Werner's key and I get the same fingerprint.
Your key is already in the strong set, courtesy of the signature of Chris Howells. You have a short distance to Werner's key, via Chris:
Only Marc Mutz and/or Ingo Klocker need to be trusted to verify keys correctly when signing for Werner's key to be trusted. Setting the trust value is a personal thing, but sometimes I do bump a key up to marginal or full trust even when I haven't signed it myself. If you can personally trust Ingo and/or Marc to properly validate keys when signing them, you should find Werner becomes trusted too.
The quickest way of finding close keys that are trustworthy is to import all the missing signatures on keys that YOU have already signed. Then view each key in something like KGpg or on a keyserver and see if there are enough other signatures on the key that could merit you trusting the keyholder to validate keys properly when they are signing other keys. One or two judicious tweaks can make a lot of difference - just take care and be realistic about whether you can trust the person behind the unsigned key to really validate keys properly.
These trust values are personal and local and no lsign or sign is involved. This, to me, would appear to be your best option. If for any reason you change your mind, edit the trust level of the link key and GnuPG will sort out the rest.
With what? You are verifying an untrusted key against a copy of the same untrusted key. You have a slight protection in that Werner (or someone else) would probably spot a very similar key on the keyservers trying to pretend to be Werner - it's hardly worth considering.
You still have to be sure that the key really belongs to the physical person reliably identifiable as Werner Koch who has sole access to the private key. lsign isn't a cop-out for bad security, it's there for those who don't want a valid signature to show up on keyservers, perhaps because their own key isn't on keyservers.
As far as GnuPG is concerned, a lsign is as valid as a sign and it will calculate your web of trust on that basis. You could set the trust value of the lsign'ed key as don't trust (so that none of the keys signed by Werner are affected by your lsign) but it's already getting messy.
?? Why does lsign appear to be less trustworthy than sign ??

@_date: 2004-09-06 17:50:58
@_author: Neil Williams 
@_subject: Q: Local keyring security, attacks and lsign 
otherwise the key would have to have been compromised, yes.
True. The GnuPG / PGP signing process tells you that much. However, it doesn't help you trust either key. You can trust that the signatures made from one key to another are valid signatures and you can check for either key being revoked, but without a web of trust, that's all you can do.
messages cannot be verified without publishing the public key. You could make the public key anonymous - you would then have to go by the fingerprint.
Protect? You protect the secret key, public keys need no protection.
If a key is untrusted, it easily cannot be protected from 'man-in-the-middle' attacks - that's why the web of trust is so important - you'd have to verify the fingerprint.
Alternative protocols can be envisaged. Presumably, there is some method of delivery of other goods and services. Some form of secure communication should be available or could be arranged using physical media conveyed over routine delivery channels. This would be sufficient for the exchange of certain data:
1. Photo ID, as per any keysigning protocol. In this case, verified using external records, maybe from the professional body who sent her out. The veracity of the ID attested by being securely sent alongside the key details.
2. The key fingerprint, ditto
3. some random text token that cannot be guessed or intercepted (random text and digits etc.) ENCRYPTED to the recipient key on read-only media.
4. A return of the same items PLUS a SIGNED (and possibly encrypted) copy of the identical text token on read-only media.
As long as she chooses to whom she will send the parcel, using details from the key, she can validate that the person she chose really does have the appropriate secret key.
If she has her own key by this time, the token sent in 3. should be signed by her key and the token in the reply should be encrypted to her key. That should allow both keys to be signed.
The recipient must have the correct secret key to decrypt the text for the reply, similarly, a signed reply shows that it was not a coincidental discovery of the text token.

@_date: 2004-09-22 20:42:27
@_author: Neil Williams 
@_subject: having trouble with encrypted mail - thunderbird, enigmail, 
You need the secret key on the same machine - not just the public key.
Both computers (in your case) need at least one secret key and BOTH public gpg --export-secret-keys gpg --export only exports the public key, therefore there's only the public key to import.
Did you generate both keys on the same computer?
Reading signed email only needs the public key.
Decryption always requires the secret key.
Probably because it's on the other machine.
Run this on both machines:
gpg --list-secret-keys
It's there, you just didn't realise it.
Also, make sure you really are encrypting to the correct key - try it on the command line by specifying the other key using -r
'man gpg' should sort out the rest of your queries.

@_date: 2004-09-25 00:20:15
@_author: Neil Williams 
@_subject: Question about FAQ section 7.1 
(Which kind of legislates against large key sizes!!)
I keep print outs of revocation certificates because they are truly short - 3 or 4 lines. My secret key is more like 50 lines. I would have to be truly desperate to type, check and re-check all those characters. I'm generally a good typist, but I wouldn't like to try that little exercise! I think I'd find it easier to recreate the more important signatures on a new key.

@_date: 2005-04-07 11:22:29
@_author: Neil Williams 
@_subject: Question regarding GpgMe 
You can set your own key as default recipient in .gnupg/gpg.conf. That will take care of your own key.
You could also assume that the sender would want the reply encrypted using that key, you may be able to retrieve that from elsewhere in the application. After all, you are reencrypting the file to someone and your application needs to know who is the recipient - or are you trying to obtain *that* information from gpgme as well?
More information needed really.
Is the file being encrypted to more than 2 keys? You and the sender?
What are you using to write your application? Could you use gpg directly instead of via gpgme and use the full gpg command line / API? It sounds like some form of scripted application - is it Perl, PHP, bash or what?
I'm not sure gpgme can do that for you, but gpg certainly can. If you are in a bash environment, you could use pattern matching etc. to detect the other keys. It all depends on what and how you are doing with the application.

@_date: 2005-08-03 23:13:53
@_author: Neil Williams 
@_subject: Encrypting an e-mail to a Hushmail user 
1. Please send your key (with photo) to subkeys.pgp.net so that people on the list can verify your signatures.
2. The exact error message is essential.
3. Check that your own key is set to ultimate trust. (gpg --edit-key  and set trust/)
4. Run gpg --update-trustdb
Unlikely. Usually the error is that no trusted key can be found and this error is due to you not setting your own key as trusted.

@_date: 2005-08-08 21:04:31
@_author: Neil Williams 
@_subject: Extra information in public key 
Be careful about such information - remember that it is not just sent in your emails but stored on keyservers.
Identities can be stolen and you are giving away a lot of the information that could be used to "identify" you in a new bank or loan application.
Do you really want such information to be publicly viewable?
Even if you include such info in a text signature block like mine below, remember that this too will be publicly archived by many mailing list archivers. Google and other engines visit such regularly updated sites very Some information just needs to remain private.

@_date: 2005-08-08 22:00:52
@_author: Neil Williams 
@_subject: Extra information in public key 
Please send replies to the list:
Only in small chunks.
I still don't see the point, but you could put a website URL in a comment.
A better idea would be to simply put all the details you want on Biglumber where people using keys would *expect* to find details about you:
Some keyservers then offer a link to lookup the key on biglumber and locate all the information anyone could ever want.
Try searching for my key here:
and with the fingerprint displayed, a link to biglumber appears.
Biglumber makes it easy to not only publicise your city but to locate others within your city and your local region and for others to find you.

@_date: 2005-08-16 10:15:12
@_author: Neil Williams 
@_subject: signing only one particular uid on a key? 
Then you missed it.
$ man gpg
uid n     Toggle selection of user id with index n.  Use 0 to deselect all.
$ gpg --edit-key command> uid 1
That selects the first uid on a toggle basis - uid 1 unselects it, uid 2 selects the second uid and leaves other selections unchanged.
Subsequent commands operate on the selected UID's.

@_date: 2005-08-16 15:25:51
@_author: Neil Williams 
@_subject: Help revoking signatures on a key 
Use a better keyserver: subkeys.pgp.net
No, the keyserver probably doesn't understand what you've done. Use a better

@_date: 2005-02-04 00:36:46
@_author: Neil Williams 
@_subject: Any LiveCD with GnuPG 1.4? 
USB - possible, better to probably roll your own if you've got one of those 1Gb USB sticks - probably more work than it is worth to re-hash an iso to 512Mb. Why not try to create your own? It's how all projects start . .  .
Google is your friend - don't rely on others.

@_date: 2005-02-11 01:25:02
@_author: Neil Williams 
@_subject: GPG corruption 
Why as root???? If you use -z, you will get a compressed archive - it could be confusing to give this the name .tar which usually refers to an uncompressed archive:
.tar.gz for -z
Now you've stopped using -z - what's going on?
Make absolutely sure what you are doing and use names that help others see what you are doing, also avoid using root whenever possible.

@_date: 2005-02-15 20:56:14
@_author: Neil Williams 
@_subject: Changing passphrase 
Provided you remember which passphrase is which, yes. Either key can be used to decrypt messages sent to the public key or to make signatures with the one But, why not just have two keys?
Having two passphrases is no more secure because you can do everything with either passphrase, all you need is the right passphrase - so no change there.

@_date: 2005-02-15 22:06:28
@_author: Neil Williams 
@_subject: Changing passphrase 
There is actually no need to synchronise secret keys, once exported, the copy remains valid and doesn't ever need to know about the 'original'.

@_date: 2005-02-17 18:03:12
@_author: Neil Williams 
@_subject: Multiple signing 
$ gpg -u other_key
Not multiple sign, you simply change the user to the other key one at a time - after all, different keys, different passphrases. Naturally, you need the secret key for the other_key.

@_date: 2005-02-25 19:13:02
@_author: Neil Williams 
@_subject: Checking signature on thebat email client 
Put this in your .gnupg/gpg.conf
keyserver  hkp://subkeys.pgp.net
keyserver-options auto-key-retrieve
You meant keyservers.
You also need to send your public key to a keyserver:
$ gpg --keyserver subkeys.pgp.net --send-key 0xC566534E

@_date: 2005-02-28 18:13:05
@_author: Neil Williams 
@_subject: useless test keys and keyservers 
Sorry, I didn't check the reply address - this was meant for the list.
But then many, many keys would be unavailable at any one time. With only 365 days a year and so many tens of thousands of keys, that's a lot of keys every single day.
The point with a keyserver is that the key is always available and always up to date. It's especially important that revoked and expired keys are continuously available - when someone queries for a key that has been revoked, it is imperative that the keyserver always gives a definitive answer. "Sorry, I'm waiting for that one to be sent back but last time I saw it, it was revoked" is not good enough.
An attacker would know the anniversary date and could put up an attacked key in it's place - in the lagtime before the real owner connects to the internet, the wrong key is in use. After all, the attacker has the key before it is revoked and is unlikely to knowingly refresh the key to import the revocation certificate so his copy will be unrevoked - he can just as easily put that onto the keyserver as the real owner.
Your purge could result in many attacked (and currently revoked) keys suddenly becoming usable again - the real owner may not keep a copy of their revoked key if they don't have much data that was encrypted to that key before the attack. The attacker certainly does have an unrevoked copy, public and Then you've got the whole keyserver synchronisation to consider - by your reasoning, the key would disappear completely from every keyserver at the same time! If you change the date of removal so that each keyserver purges at a different time, the key will be refreshed from another keyserver at next sync, rather than from the user so you lose the entire point of your But many keys don't change year to year - there's nothing wrong with that. Just because a key doesn't change, there's no reason to think it's out of No, it would be a very BAD thing - it's part of the controversy over PGP GD.
If you want to use a keyserver that implements that kind of policy, fine, just be very careful to use a full-size keyserver to refresh your keys in case someone revoked their key coincidentally just before the arbitrary creation anniversary date.

@_date: 2005-02-28 18:26:50
@_author: Neil Williams 
@_subject: useless test keys and keyservers 
Which? Who decides? But signatures made by those keys will still be around in 5 years time and people will want to know who the signatory was.
All keys need to be kept - you can't tell if a key is out of use simply by waiting for the owner to respond. If the key owner has lost the passphrase or simply moved email account, the key is orphaned but there is no easy way of detecting these.
As I said, if you do this, the expiring keyserver is prevented from every synchronising with the non-expiring and that means everyone using the expiring keyserver has to check the non-expiring one anyway.
No, because if the key is never deleted from the keyserver, uploading an unrevoked version doesn't UNDO the revocation. A revoked key stays revoked.
And how are they meant to do that if the keyserver deletes it?
That requires massive logs of which keys have been searched and then you include all those that search for "Joe Bloggs" or "0xDEADBEEF" - they get lots of hits, but do all of those count?
I don't want any keyserver to delete anything - even if the owner doesn't want it around there are others who might, particularly if the key has made any kind of public signature.
Useless test keys are a problem, agreed, but creating an automated filter that can tell the difference is v.hard.
If keys start disappearing from keyservers when they are still in use, we'll all end up having to use keys on personal websites and the whole thing becomes even more burdensome.
?? What is the point of that?? People sign my key without any prompting and without any verification already. (Note to anyone reading this: Please do NOT sign my key until we meet face to face.)

@_date: 2005-02-28 19:45:39
@_author: Neil Williams 
@_subject: useless test keys and keyservers 
Melissa, could you put your key on a keyserver somewhere? I don't like that option - I can't see any benefit to the ordinary user who simply wants to check the signatures on my key. Plus the GD puts masses of useless signatures on your key too - my key is one of those that will never go on GD. It's fortunate that GD have implemented the non-owner-refuse-submission as this is the only way of protecting your keys from their signature attacks.
IMHO, anyone who signs emails to a public mailing list should make their public key available with the minimum of fuss. This, to me, means putting it on one of the recommended keyservers, e.g. subkeys.pgp.net
All keyservers support the option to not upload your key - it's just that once a key is public, there's no real way of stopping it being submitted by someone else. Thereagain, if the key IS public, it should be on a public keyserver - that's my case.

@_date: 2005-01-01 14:27:57
@_author: Neil Williams 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
But you cannot do that, you cannot prove to me that it is that key. There is no way that I can verify the key because I cannot verify the UID. As David said, it is trivial to create yet another PGP Global Directory Verification Key - how can you prove which one is 'real'? As it would be my own key, created under false pretences, I could introduce it to PGP GD and sign whatever I wanted with it. Without verifying the UID you cannot verify the key.
Without verifying the key, you cannot prove that the key is genuine.
Without proof that the key is genuine, you must NOT sign the key!!!
Exactly, so the key is impossible for those outside PGP to verify. Unless you have inside knowledge of who really created that key and who has access to the secret key, you CANNOT verify that key.
Rubbish - it's not verifying the key at all, it's merely recognising what it purports to be. No verification has been achieved, no proof has been shown because none exists. You must have inside knowledge before you can sign this key - the UID alone is insufficient and cannot be positively identified.
True, but that also means that this key CANNOT be verified.
I despair at those who are willing to sign unverifiable keys, I will NOT sign any key that cannot be properly verified to me. I can prove that every signature I have made was verified - positively identified as that physical person, that precise key, that email address.
I fail to see that anyone can ever deem it reasonable to sign keys when verification hasn't even taken place.
A signature is NOT for your benefit - it is a testament to others that YOU have positively identified that person, that key and that UID and that you can PROVE your verification.
People need to be able to use signatures, signing a key that is not identifiable to a physical person is pointless. Only a fool signs without verifying the physical person. If no physical person can be identified, it should never be signed! Simple!
Don't sign it unless you can prove it!

@_date: 2005-01-01 14:39:18
@_author: Neil Williams 
@_subject: RFE: Unsignable keys 
Request for Enhancement / Comments: GnuPG.
Would it be possible to create an --expert option to generate a key that CANNOT be signed (under any circumstances) unless BOTH secret keys are available? (signer has to have secret key anyway, these special keys would also need the signee secret key in the same keyring).
$ gpg --expert-unsignable --gen-key $ gpg --expert-verification --gen-key
This could be useful for corporate and verification keys that would then be used to sign other keys but could only be signed by keys owned by the original key owner. These signatures could be used to bring the key into the WoT without allowing any of the noise that pollutes current robot / impersonal keys.
If the PGP Global Directory Verification Key was unsignable, only those with access to the secret key within PGP GD would be able to sign it.
Anyone else would get a telling off from GnuPG:
"This is a verification key - it cannot be verified or signed without access
to it's secret key. Your request to sign this key has been ignored."
(I haven't looked at the OpenPGP spec, it probably breaks it but as an --expert option, GnuPG already supports other options that allow operation outside the strict spec.)

@_date: 2005-01-01 17:45:45
@_author: Neil Williams 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
That's true, but there's no harm in putting up reasons for users to *think* about the trust model.
IMHO, you'd be better off with an x.509 Thawte key - their trust model is closer to yours.
You are willing to trust a key only on the say so of a corporate entity - that's a Thawte and x.509 model, not GnuPG.
GnuPG doesn't use the x.509 model - that's the entire point. The two models cannot be reconciled, the fundamentals are different and comparisons are void. This is the flaw in the PGP GD - they are trying to square a circle.
Completely the opposite concept of trusting keys. x.509 you/I trust Thawte etc. to verify the person. GnuPG I do that myself. The two have different models, different uses.
Nothing wrong with either, it just pays to understand which model you will Why not? It's a simple matter of programming. (bash/cron in this case) and a decent connection. There'd be no need to set a passphrase on the false key so my system could sign maybe 1,000 a minute? i.e. I'd be creating a second robot - a false one. Just as capable as the one on the site already.
Any software method of signing can be copied and reimplemented elsewhere.
No need - with all keys signed twice, who can tell which is genuine? You're now reduced to checking only a fingerprint - the keyid can easily be duplicated. Just run a script on --gen-key until /dev/random provides the right input to output the required 8 characters. Duplicate keyid's already exist - 0xDEADBEEF is almost common.
If I had time, I probably would. So you are trusting your entire verification to whether someone can hack an email account or forge the From: address????
I can send from any address I like, it's only a case of changing the email client config!
Hacking an email account is not exactly hard - depending on the user. A dictionary attack will deal with most ordinary users. How many people use 'password' for their email?
How many people are actually going to wait for email verification of the PGP GD key before signing it anyway? The documentation makes no mention of it and encourages users to sign without it.
Only if your trust model is x.509.
Wrong model. A signature verifies a PERSON. Before I sign a key, I establish the correctness of the identification of that person by examining photo ID, verification of the email address (using CA bot) and verify the fingerprint using a print out handed to me by that person face-to-face at the time of photo ID verification.
If any stage fails, I don't sign.
For the last time, I'm verifying a PERSON, not just the key.
x.509 requires you only to verify the key as issued by Thawte etc.
OpenPGP requires you to verify the UID - the PERSON.
Still the same model as x.509. Please get your head around the OpenPGP trust model - it's not about corporate bodies or material objects, it's about one individual trusting another individual.
Doesn't mean I can't help inform those people of an alternative viewpoint.
You should consider using x.509 for those situations - GnuPG is built on a PERSONAL WoT.
No, unless you can prove it 'beyond a reasonable doubt'.
Again, people want to be able to RELY on your signatures. This is why GnuPG has a trust level that the user has to set themselves - when I meet someone for a keysigning, I make an assessment of how well they verify my key, how they take care of their own key and set my trust accordingly.
Yes, passports can be forged - there are limits.
As long as you don't make pointless signatures that dilute the trust.
Your signatures can affect my trust model - that is why I'm taking time out to reply to the thread.
I really think you should look at Thawte - you've entirely missed the personal aspect of the GnuPG trust model.
It's about Bob trusting Neil who trusts Anne. It's about Bob assessing how carefully Neil verifies keys so that he can decide whether he should set Neil's key to fully trusted and therefore trust Anne's key.
(I am not a number)

@_date: 2005-01-01 18:18:57
@_author: Neil Williams 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
1. You are still trusting an unknown person you've never met to give you the right information, just on the basis of their employer.
2. How many people will even do that? (And can you imagine the response from reception if we all did?)
It's still about trusting an individual - if you don't meet, you will never know if it's actually the right person.
David's explained why he'd sign a robot key if he was in a privileged position with the owner of the key - so would I in the same situation because there would be >=1 person who I could verify as individual(s).
Like David, I'd never sign a non-individual key otherwise.
That's my main point - I only sign if I can honestly and publicly declare that I KNOW and have proven that it is the correct key for the UID.
That is what I believe a signature to be.
I would hope that everyone would be willing to trust my key and keys that I have signed on this basis: Verify me and have confidence that the keys that I have signed are known to have been good at the time of signing.
Until you've verified my key and me (or someone who has signed my key) as an individual, you cannot hope to prove that this signature is made by the person claimed in the key UIDs.
You could ring me on the 'phone and ask, but you still haven't verified me - just my phone number. It could be anyone at the end of the phone, there's not even much certainty that you'd get the right number without knowing me.

@_date: 2005-01-01 21:30:23
@_author: Neil Williams 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
That's the problem, right there. A signature is not for YOUR benefit! You need to take on board how signatures are used by others. To others, the key and the role, the key and the person, are completely separate.
There's a massive difference between trusting someone individually and declaring to the world that you have proof of that trust.
Besides, it's not just your neighbour, it's me.
You've lost the plot again!! :-)
A signature is not for your benefit - it's done for the benefit of others so you have to disregard any notion of how YOU expect the signature to be used!
The capacity is NOT in the system to say that your signatures should always be untrusted - basically because the system is of the opinion that untrustworthy signatures shouldn't be made in the first place!
?? OK, if you haven't verified photo ID and their fingerprint, I think I understand that, and agree.
Leave x.509 out of this - it doesn't apply to the issues.
The confusion is about keysigning of individual keys that are used by machines. Never sign them!
??? I hope you are not saying you'd make an exportable signature on their key on just that basis???
If you have to trust that key and REALLY feel you *can*, make a LOCAL signature and it won't be exported.
Local signatures can be for your benefit. Normal (exportable) signatures are for the benefit of the rest of us.
Fine - that's how we all deal with it. I trust only those I've signed and some of the ones that those people have signed, depending on an assessment of how careful the person is at verifying keys and people.
Absolutely correct.
I trust Philip Hands because I've met him, verified his photo ID and his email and his fingerprint. He's done the same with me and my keys. Philip has signed other people (lots and lots) but a lot of those I never need to contact. If I do, then Philip's signature on their key does mean that I can trust their key for email encryption. (I don't send really sensitive stuff).
I would never trust someone else who was signed by someone signed by Philip. i.e. this is a one-level thing: I trust Philip, I trust those he's signed but I can't trust *those* people to verify keys when they sign.
The WoT is not about trusting the entire strong set. Out of 24,000 keys in the strong set, I trust maybe <100. I've met 22.
I only have keys at full trust if I've met them and signed their key, plus one or two who have been signed by those that I already trust. All the keys from this list that get pulled in on --auto-retrieve get cleared out each month with a nice little cron task.
Hmm, that's not my take on it, but hey, those are local signatures so I really don't care what you do with those.
Fine - so why are we discussing this at all??
You use local signatures for times when you want to trust someone that gpg cannot trust directly, you only trust other keys when you know the person, where is the problem?
Just keep to local signatures and don't send unverified signatures to Ah, now that's where we differ. Please, consider only using a local signature if you really must sign any robot key or the PGP GD key.
You cannot prove to me that you verified the PGP GD key so your signature on that key would automatically be untrustworthy.
Only those who work with the people who have access to the secret key for that key should sign it. Anyone else is free to sign it locally. That's my view.
I hope you'd do the full keysigning protocol of verifying the identity of the person too! If it's someone you don't already know, you really need to see photo ID, get a printed copy of their fingerprint face to face and verify their email address.
Your paranoia is unlikely to be darker than mine.
The WoT is not a take-it-or-leave-it all or nothing construct. You retrieve those keys that you know belong to people you already trust. You set your personal trust level to tell GnuPG how much you trust that person to verify someone else's key and ALL other keys, if you don't know the person, tell GnuPG "don't know". There's an option in the trust that explicitly uses "don't know". It's not a cop-out, it is a vitally important setting.

@_date: 2005-01-01 21:37:15
@_author: Neil Williams 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
What, at PGP? I'd never sign their key anyway.
I have to meet someone face to face, verify their photo ID, receive a printed copy of their key fingerprint and then verify their email address (using CA bot unless I already have email correspondence) and then I'll sign a key.
Seriously, I would never sign any key that cannot be verified as above. I have not and will not sign any automated or corporate keys that cannot be tied to one specific individual who can be independently verified.
I cannot prove the verification of any such keys so I will not put myself in a position where someone might be excused for using such a proof.
It doesn't stop me using encryption to those people that I need to use encryption, it doesn't stop others trusting my key on my software. I continue to seek out keysignings to increase the number of people who can trust my key and I jealously guard both the key and the system that allows people to trust my key.
No, you simply don't, ever, sign their key.
If you must, use a local.

@_date: 2005-01-02 14:38:38
@_author: Neil Williams 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
I've got Enigmail working with Mozilla and Thunderbird. Check that out, it should work and it can work.
This list is using the usual behaviour of GNU/Linux mailing lists, it's not unusual at all. The other lists you describe are probably hacking their config to satisfy requests like that - the discussion is as old as the list and I don't see either position changing.
Mozilla doesn't handle it as well as some others, KMail handles it perfectly.
Reply on this list, and KMail replies to the list because the folder is configured that way.
Try reply all.
Tough! I sign everything - especially on lists where it annoys OE users. I use it to make a point.
Use a different email address for lists with lots of OE users and then you can configure that account to either not sign or to sign in the deprecated inline format that will break occasionally.
I have linux@ for GNU/Linux lists that have a propensity for GNU/Linux email clients, I have a different account at the same domain for lists with a propensity of broken MS email clients.
?? I've had your key in the past, yes, we haven't exchanged keys in the sense of fingerprints for a keysigning.
Sign inline. How often do you send attachments anyway?

@_date: 2005-01-06 20:00:27
@_author: Neil Williams 
@_subject: Subkey - second email address 
Usuallly, you'd just add a UID.
If you want a second subkey so that people encrypting to your work email address would use a different key to those encrypting to your home email address, that's probably a job for a second key. It means always having both secret keys available as well.
adduid from the --edit-key menu.
--addkey adds a subkey that can be used if you have a short expiry on your encryption key compared to the main key, or to use different algorithm Only adduid or a second key will list both work and home email addresses.

@_date: 2005-01-14 18:07:08
@_author: Neil Williams 
@_subject: signing and encrypting newbie question 
You can use one operation, just add -s :
gpg -asr 8F455606 -e qof-test.c
(I usually use -a as well - I encrypt mostly text files.)
When decrypted, this will print the validity of the signature at the end of the output. You can separate the two when decrypting:
gpg --decrypt qof-test.c.asc > qof-test.c
The file will be created and the signature validity displayed.
More commonly, use two operations. Encrypt the file, then sign the encrypted file using
gpg -ab
-a outputs the signature in ASCII text
-b creates a detached signature.
You'll then have two files to send up.
$ gpg -r 8F455606 -e qof-test.c
$ gpg -ab qof-test.c.gpg
$ ls -l qof*
-rw-r--r--  1 neil neil 2699 2005-01-14 16:01 qof-test.c
-rw-r--r--  1 neil neil 1743 2005-01-14 16:02 qof-test.c.gpg
-rw-r--r--  1 neil neil  189 2005-01-14 16:02 qof-test.c.gpg.asc
The .asc file is the signature, typically it's 189 bytes.
You don't need to sign keys to verify the signature. Just download both files into the same directory and use:
$ gpg --verify qof-test.c.gpg.asc
gpg: Signature made Fri 14 Jan 2005 16:02:57 GMT using DSA key ID 28BCB3E3
gpg: Good signature from "Neil Williams (CodeHelp) "
GnuPG will assume that qof-test.c.gpg is the file that has been signed.
Once the signature is verified, the file can be decrypted:
$ gpg --decrypt qof-test.c.gpg

@_date: 2005-01-14 23:44:16
@_author: Neil Williams 
@_subject: Signing files 
Don't forget, when you create a key you create a secret key too - that's what signs the file and you never need to send that to anyone. The public key is sufficient to verify the signature without being able to create it.
Home machine: has your keypair, public and secret and the public key for the customer. Sign and encrypt the files here.
FTP host: No need to install GnuPG, just copy the signed and encrypted files to that machine.
Customer: Downloads the files using FTP to his local machine. His copy of your PUBLIC key verifies the signature, his SECRET key decrypts the contents.
If I signed and encrypted an email to you, I'd sign and encrypt it here where both my public and secret keys exist. None of the servers in between need know anything about GnuPG to handle the email, it just gets copied around (intact) from one to another until it arrives in your inbox. You then verify the signature on the email using a copy of my public key and you decrypt the contents using your secret key. That's all there is to it.
You sign it on your local machine and send it to the FTP site already signed. The FTP server does NOT need to do anything to the file(s) except make it ? So? That doesn't stop you signing the files on your local machine (whichever that is) and sending the files signed! Signed files only need GnuPG when they need to be verified - i.e. by the recipient. The server knows nothing about GnuPG and that's the way it should No need. The files are already signed and encrypted, the machines in between don't need to know anything about the contents of the file or the encryption.
The customer already has your public key, that's all that is required.
Keep your secret key where it is and sign the files on that machine. Sign the files ON Machine A! There is no reason to sign anywhere else. Sign where the secret key was created, don't copy the secret key to any remote machines and copy the files to the FTP server, already signed.

@_date: 2005-01-15 00:26:20
@_author: Neil Williams 
@_subject: Encrypt & Sign 
That's disingenious Atom - the premise of the article is a rogue program. Isn't that why we use free software? That's why we verify GnuPG carefully before installing, why we have the source code to inspect to allay precisely these fears.
Despite what the article says, it is NOT possible for someone else to sign this email with this key. Anyone who has had their key signed by my key(s) will be able to determine that I consented to the signature made on this email and it's content.
The whole point of the WoT is to tie the person to the key. Tying the person to the key ties the person to the computer used to access the key and hence the circle is complete.
I would challenge anyone to prove that I did not sign and consent to the precise and complete content of the signed component of this message.
Just because someone else can create a *similar* key with no passphrase that can be used to sign anything, doesn't mean that MY signature is any less valid. It relies on my key being trusted. A false key can never duplicate the trust - that is why there was so much discussion about the GD keyserver, anything that affects key signatures is of concern. The WoT is fundamental to how GnuPG and PGP work. If the GD had threatened to weaken the WoT, the fuss was fully justified. As it happens, the discussion has still raised important Not true. It requires trust in the key and the person identified in the key. It also requires that you update that key to check for revocation.
I can sign my email from any computer to which I copy my secret key. Part of trusting a key is trusting that the key holder won't do something stupid like copy their secret key to a public location. That's why face-to-face verification is so useful, it allows time to discuss issues and make that All that is needed to be trusted is the key holder - that s/he can be trusted to manage their key properly and carefully and to take reasonable precautions against leaving their secret key somewhere that anyone else has access.
That step is covered by revocation. The computer does not need to be trusted, it's the keyholder and his/her behaviour that is trusted by those who have signed the key. Both parties can trust the code because the code can be inspected.
Access to the secret key doesn't equate to compromise of the key - there's still the passphrase. Or is he asserting that a keyboard sniffer is also required now?
How's that different to someone copying a written signature and taking measures, in advance, to get a usable copy?
All he's saying, in a lengthy and confused fashion, is that you can't trust a signature made by an untrusted key. Wow, big news.
The key isn't trusted, so why should you trust the signatures???? You can't!
All these emails that show up in yellow in KMail (signature mathematically valid but key untrusted) - the signatures are nice but cannot be trusted as the key is untrusted.
I sign emails because there are people out there who HAVE signed my key and had their key signed with mine. They are the only ones who can truly say that my signatures are genuine and reliable. They know me, they have all met me (those who are cross-signed) and all talked about how keys are handled and used. Others on this list will be able to trust my key because of people they have met. For everyone else (including you, Atom), my signatures are useful but cannot be used to prove that I sent it - only that the signature is valid but you cannot trust the key.
It isn't enough that I can encrypt to those people, they need to know that it is ME sending the information, not just that someone has got their public key and chosen to encrypt the content with it. That's why I sign and encrypt to those people - I know only they can read it, they know only I could have sent None of that is possible without keysignings and the WoT.
It IS better than a physical signature - he makes the point himself that a written signature still has to be verified by an external authority - be it the person under oath or a handwriting expert - to prove that it is a genuine signature. Handwritten signatures are easily copied. Digital signatures cannot be copied.
Having a perfect digital reproduction of my written signature could get you into all kinds of situations in my place. Having a perfect digital reproduction of my digital signature gets you nowhere.
(Some people put images of their written signature in their keys - seemed crazy to me, as if trying to certify the key with a weaker form of If you've been signed by my key, my digital signature is better than any written signature. No-one can hide the content of this email from me before signing (as you can with paper), no-one can tamper with this email and change the content without the signature being broken (as you can with paper). You have to know me pretty well to recognise my written signature - I sign so many things it often changes (as my bank can testify)! Nothing is completely secure, but the combination of the WoT and digital signatures CAN be used to prove that a document was knowingly signed by an identifiable, physical person who has been independently verified by multiple other people and who is named in the key that made the signature.
What paper signature can do the same?
Of course this is a signature, it is a verifiable and tamper-proof seal created uniquely by me and which can be uniquely tied to me as a physical person - no matter what computers were used in the generation process.
The fact that you are not currently one of those people who CAN trust my key is not for want of trying, you don't seem to have many signatures on your key. I'm doing my bit, are you?

@_date: 2005-01-15 19:14:38
@_author: Neil Williams 
@_subject: 2 ways of signing files 
Yes, the key, not the file.
There is no command there to sign the file, it'll just be encrypted.
You need to specify the -s or -b options etc.
'gpg -s --recipient "blake --output
$rootpath\\$filepgp --encrypt
You've specified --sign so it will be signed.
No. Signing a key is nothing to do with signing a file. Before you sign a key you should verify the key under keysigning protocols.
If you just want to sign it to encrypt to it (despite not being able to trust it), you can use a local signature. (non-exportable).

@_date: 2005-01-16 11:57:02
@_author: Neil Williams 
@_subject: auto sign files 
Signing is a personal act, that's why it requires a passphrase. If you want to sign automatically, use a non-personal key that doesn't have ANY passphrase set. You cannot trust any machine to sign FOR you, recording the passphrase in any form of script is simply insecure. There is no difference between using a passphrase in clear text in the script and using no passphrase at all! You wouldn't consider a key without a passphrase as secure - why do you think storing the passphrase in clear text is going to be OK?
(Or do you keep your current passphrase on a post-it note on your monitor for everyone to read?)
You said nothing all through this about automating this process - you've talked only of signing files manually. It's a completely different issue.
1. You cannot sign a personal signature automatically (because you have to be 2. Any machine operated signature isn't worth verifying because the script will sign anything it's told to sign.
A signature made by a script doesn't verify anything - it just means that the script is functioning. Anyone with authorised or unauthorised access to the machine can sign the files - no matter what they contain.
You're not even doing this on a secure system, it's Windows! You have no idea if that box is already compromised. There could be someone with a trojan already available who could put their own files on that box and the script would sign the files!!! You'd be sending your customer a signed and encrypted TROJAN! Best of all, the attacker would have absolute anonymity because he'd be putting files on YOUR machine and using YOUR key!
Explain to your 'customer' - the choices are:
1. Files are only encrypted, not signed at all.
2. Files are signed with a machine-only worthless signature.
3. Files are only released when you are awake.
Any other option is untenable and explain why. Don't accept a customer who would be happy with the attack described above - s/he will quickly blame you if it happens and their machines get attacked via your poor signature process. If there's money involved, it's imperative that you do not open yourself to this risk - by not signing any files automatically - or s/he will have every reason to sue you for negligence. Do you have that kind of money?
A signature made by a machine cannot be trusted because the key cannot be trusted - the machine will sign everything that is thrown at it.
We've had this discussion before about the GD - people's trust models vary but that's mine.
If you can't sign the file personally, don't sign the file at all.
How often are these files changing? What on earth are you actually doing?
Why not make it easier for an attacker to find the passphrase by putting the passphrase and the secret key on your home page? This is NOT a secure way of using a key!
Then change the schedule. I do this every day - I let the script do everything up to the point where a signature is required for the final file. Then it waits and only proceeds if the signature file can be found and verified.
Verifying a signature doesn't require the passphrase, just the public key.
You can be notified or reminded by email, even SMS if you configure it (and pay for it IIRC).
Not securely.
Only for those who don't have a clear understanding of security and the reasons for signing files.
Decide clearly whether you want to sign these files :
1. as a person - in which case YOU need to be there. OR
2. as a script - in which case use a separate key and advise your customer that the signature is worse than useless should your machine be compromised. Naturally, you would assure your customer you would make every effort to prevent such an attack but that you cannot guarantee that the machine has NOT been attacked when the automated signature is made (because you won't be logged in at the time to check).
The customer MUST be clear that this would be a MACHINE signature and it has NO correlation with you as an individual - or any other individual. You cannot be held personally responsible for the content of the signed files. (So what's the point?)
If they are willing to accept that, they have only themselves to blame. To me, such signatures are worse than useless.

@_date: 2005-01-16 21:02:28
@_author: Neil Williams 
@_subject: auto sign files 
auto-signing keys is always a bad idea - how can you automate the keysigning verification? Only the PGP GD and robot keys have done that and the results are not always welcomed.
By all means use automation to assist in keysigning protocols, I use the scripts from Peter Palfrader (cabot on Debian), but automation IMHO, should never replace personal verification and involvement. I've got various GnuPG automated environment scripts and processes - NONE have access to any secret keys. I can't think of a single situation where a secret key is actually necessary in an automated environment. There is always a better, more secure, Convenience is the nemesis of security.
"You should use the option --batch and don't use passphrases as there is usually no way to store it more securely than on the secret keyring itself. "
This is the use of keys without passphrases to which I referred. The FAQ clearly takes you through how to remove the passphrase.
The consequences are as I mentioned - the signature in this case is merely asserting that the script is functioning. Anyone can create another key with the same details and sign their files - so it comes down to checking the fingerprint of the signing key.
As you have no way of verifying the key against a person, if the website is hacked and the displayed fingerprint altered, users would have no way to The FAQ is clear on the risks:
" It's also a good idea to install an intrusion detection system so that you hopefully get a notice of an successful intrusion, so that you in turn can revoke all the subkeys installed on that machine and install new subkeys. "
i.e. automated environments require additional security layers, increased vigilance and egg-on-face apologies when they go wrong.
Personally, I just don't think it's ever worth the risk - far better to copy the files to your machine, sign the files personally, then copy them to the public machine. Secret keys and public servers just don't mix.

@_date: 2005-01-18 13:14:21
@_author: Neil Williams 
@_subject: Gnupg with php 
Please at least Google for the answer before posting:
There are lots of other articles too:

@_date: 2005-01-18 13:29:20
@_author: Neil Williams 
@_subject: auto sign files 
Wrong - it falls into the security trap of being LESS secure than current.
No, it's to send signed files that are copied in to place from a private Keep private keys on private machines.
No, because to use automated signing, the passphrase must be kept somewhere on the automated (public) system in a clear-text form or the key set to not ask for a passphrase at all. Just reading the script will be enough to identify the passphrase. Therefore automated signatures give a FALSE sense of security. As soon as the machine is compromised, the script is readable, the key identifiable, the passphrase known. oops.
Automated signing removes any protection from the secret key itself. It's worse than non-signing because any compromise of the box is automatically a compromise of the key. Once an attacker can read the script, the passphrase (if any) becomes obvious, the secret key is easily located (because the script has to be able to find it) and the attacker can use the key as his/her own. Worse, the script would continue operating and issuing signatures AFTER the attack - no-one would have to know - including on files that are put onto the now compromised machine and dutifully SIGNED with YOUR key by your script! The extra layer of security doesn't exist because if the script knows the passphrase, anyone who can break into the machine and read the script ALSO has the passphrase. What you've introduced is a single point of failure for key AND machine.
Signing only provides an extra layer of security to the files IF the secret key is NOT on that machine. (Having a secret key with a passphrase that the script does not know is pointless.)
Automated signing INCREASES the security burden of the machine, it requires all sorts of extra precautions and intrusion detection systems to protect the (now) vulnerable key.

@_date: 2005-01-18 14:51:48
@_author: Neil Williams 
@_subject: Using GnuPG to sign web pages. 
Section about checksums: Why not use a valid attribute like title or id instead of inventing chksum? Title will show up in a tool-tip, id can be used as a link.
Now what we need is a method for displaying the validity of the signature within the main browser application window.
Maybe a little script to sit in the Konqueror Tools menu? It already supports HTML validation with W3C and lots of other tools, this could be added.

@_date: 2005-01-18 23:44:18
@_author: Neil Williams 
@_subject: auto sign files 
Because security is more than just that one machine - from the perspective of the recipient, 'security' encompasses the whole transaction - from creating the file to installing the decrypted contents. If the file is changed before encryption (or used to replace a genuine encrypted file) and signed using an automated process, security has been breached. Yet the customer will receive no indication of the breach, therefore, from his/her perspective, the transaction using the automated process was insecure. S/He will rightly claim that you should have anticipated that such a breach would not be evident to them and should have taken steps to avoid such a situation. Therefore, the automated process has required the installation and monitoring of yet another layer of security to monitor intrusions - something that would not be a problem (even thought it would be wise to install) if the files could not be signed automatically.
The original case was a file on a remote machine. This machine could be attacked. An attacker could easily replace the file, the details of the checksum that would be listed on the webpage of the site and, if the files are signed automatically, could also sign his own files to replace the originals, using the script. S/He wouldn't need to decrypt the original files, just overwrite them with his/her own and use the script to identify the key to be used for encryption of his own content. Encryption is no protection in this scenario.
Encryption is a red herring - if the source of an encrypted transmission is not secure, the encryption is pointless - this is all about the signatures. The only reason to encrypt these files is to determine who can decrypt the downloaded files - it does not protect the files on the server itself once an attacker has root/admin privileges.
Exactly. The recipient cannot tell if the machine has been compromised (the signature on an attacker's file would validate as well as an original file because the attacker can use the script).
Therefore, as the recipient, the fact that the signature verifies is NO indication that the contents are as expected. The signature then provides a false sense of security - waiting to catch out the unwary who take the signature to mean that the file is safe to use.
It would be more secure (overall) to be open and leave it unsigned - then the recipient is under no doubts that the content should be checked. From the perspective of the recipient (the customer in the original case), a signature made after an attack on the server should NOT verify. The fact that it DOES, means that the signature is entirely worthless. Acknowledging the risk leads to better overall security than trying to wish it away or obscure it under meaningless wrappers like automated signatures.
The recipient would not know - the checksum would be OK, the signature would be valid, the file would be encrypted to his/her public key - everything would check out until it was decrypted. Oops.
Far better to only have the secret key on a private machine. Copy the original files to that machine. Sign them there. Copy the files to the public host. Encrypt them anywhere along that line, by preference. Now the public host cannot be used to authenticate files created by the attacker - the recipient is alerted by the use of the wrong keyid or a bad signature, BEFORE decryption. Security, from the perspective of the recipient, is much Change the perspective a little - this has all centred on the remote machine. Think about this from the perspective of the recipient. In the original situation, the recipient (customer) was requiring encryption and signatures specifically in order to have some assurance about the security of the contents. If you automate the signing, the recipient can no longer be sure that the file contains what it is meant to contain, despite both the signature (using the script on the compromised machine) and the encryption (using the same script). No decryption is necessary, replacement files containing trojans or backdoors will look the same if padded to the same archive size as the expected file. That isn't hard - stick some (abusive) text at the end until you get the right file size. It'll look the same, the filename is easy, the same encryption key can be used, the signature will verify but the contents are not what is expected. Isn't that the definitive Trojan Horse?
This can only happen because the admin of the remote machine chose an insecure method to sign the files. Keep the secret key off the remote machine and even if the server is attacked, the attacker cannot move the attack onto the customer's machines.
Think about it - attack one server, replace the files with your own that create backdoors from every customer machine back to the attacked server - or another one somewhere else. Put some useful content in there as filler/spoiler, maybe output some complicated error message about a bad copy operation or whatever. This is a real threat - it's the idea behind all the internet worms that were used for DoS attacks and/or now used for sending spam. If the customer machines cannot be compromised (because the attacker can't sign the files with the right key), the attack stops at the server. Excellent news for you. Your customers are safe, the original encrypted files can easily be identified and are easily verified to detect any tampering. A few careful deletions, restoring a few files from elswhere, you're back up and running before some of your customers even notice.
All this comes undone if the attacker can create identical files with his/her own content to replace the genuine files. Now, even when you do discover the attack, you have to consider the key and all files on that server as compromised. There is no way to protect the key or older files that may contain genuine content, you'd have to decrypt them individually to verify them. All the signatures are valid because they are all generated using the same script. Your downtime goes through the roof as you try to replace maybe tens of thousands of customer files - many of which may be perfectly usable.
NOT GOOD!
Precisely. Automation and convenience usually result in lower security. It's a Important distinction here. If the key is only ever kept on a private machine, an attack on the public machine hosting the files does NOT compromise the key. Two machines - the private machine with the secret key and the public machine that hosts the final files. Plus the bonus of not having any automated signatures on the public machine - improves security and helps you out after any attack.
Equally don't hide the implications of getting the assessment wrong. We cannot presume to know what is good enough for the original enquirer - let them hear the opinion of those with different security needs and make their own decisions. As long as the decision is made in full knowledge of the possible problems, the group has served the enquirer well. If we hide the more complex problems from everyone, or fudge the issues or palm people off with soft security, how does that serve to further the use of GnuPG?
Never the intention, but those who ask about using a security program should be able to get a response from those who have higher security needs. It doesn't hurt to make the dangers known.

@_date: 2005-01-20 20:01:36
@_author: Neil Williams 
@_subject: Web of trust in Southwest Ohio, USA 
1. Advertise that you use GnuPG by signing emails, putting your key in ASCII armour on your webpage, linking to that page in your email sig, . . .
2. Get yourself onto biglumber (ref in my sig) to help people in your area to find you.
3. Join local user groups, especially (GNU/)Linux User Groups (GLUG or LUG).
4. Start with your own friends and contacts.
The practical reason for that is that multi-month searches require lots of server time and unless you've got the power of Google, the scripts time out.
Google will search particular sites - check the advanced search options.
It's a checksum of the content of the email. It is calculated from your key and the email text and each signature is unique. Your email client will do the calculations for you. Your standard email sig (the plain text bit) should just mention your keyid or a webpage that holds a copy of your key plus sundry other contact details. You don't write a digital / GnuPG signature You're using Thunderbird so you'll need the Enigmail plugin to sign using GnuPG. It's very simple to configure.
It will allow you to sign all outgoing messages or just the ones you select.
Atom has also written a GnuPG encryption routine for PHP:

@_date: 2005-01-25 17:53:35
@_author: Neil Williams 
@_subject: Pb with my passphrase 
Did you create a revocation certificate - as you were advised?
If not, you can only delete the key - providing you haven't already sent it to a keyserver. If it's already on a keyserver, it is now orphaned and joins many similar keys - there is nothing you can do about that.
Nobody can revoke that key as the passphrase is required, along with the secret key itself. If you haven't sent it to a keyserver, revocation isn't an issue anyway - just delete it from your keyring. If you create a new key:
1. Create a revocation certificate immediately.
2. You won't get the same keyid or fingerprint but you can use the same UID: name, comment and email.

@_date: 2005-01-26 12:22:54
@_author: Neil Williams 
@_subject: Are all the UIDs on a key supposed to be equal? 
gpg --edit-key
Command> uid 3
Command> primary
primary is only available when the secret key is also available.
GnuPG assumes the most recent on (IIRC) unless primary is used.

@_date: 2005-07-10 17:44:53
@_author: Neil Williams 
@_subject: Revoking Keys 
That's all you need. Import the public keys from keyservers into your local keyring. Import the revocation certificate into the local keyring. Send the now revoked key to the keyservers.
The point of a revocation certificate is that you don't need the secret key to revoke the key - that's why the certificate must be kept SAFE!

@_date: 2005-07-20 14:27:31
@_author: Neil Williams 
@_subject: receiving key to file and more 
--keyring  --no-default-keyring
from man gpg:
--keyring file
        Add file to the current list of keyrings.  If file begins with a tilde         by the $HOME directory. If the filename does not contain a slash, it         directory ("~/.gnupg" if --homedir or $GNUPGHOME is not used).
        Note that this adds a keyring to the current list.  If the intent  is          alone, use --keyring along with --no-default-keyring.
--search-keys displays a list of possible matches and allows you to select which one (if any) to import. Use to search parts of a name or domain. Used when you don't know the specific keyid, just the name or email.
--recv-keys imports the specified key without further prompts. Easiest when used with a specific keyID.

@_date: 2005-07-25 12:28:30
@_author: Neil Williams 
@_subject: Getting Started... 
Assumption is the mother of all $^?&*^ ups.
Presumably users are aware that this would render their own keys insecure so you're using "group" or "corporate" keys via your key generation/storage? Why then check the *user's* keyrings? Shouldn't that be the central keyring of generated keys (presumably with no passphrase).
Users should not be given the impression that these keys are secure for use with personal email, keysigning etc.
For absolutely anyone to read - you're merely using encryption for the external part of the mail chain? You assume that your internal security is sufficient to prevent unauthorised users within the company reading the Well I wouldn't use it! :-)
If I encrypt to someone, I expect that person to be the only person to be able to decrypt the message. I do not expect some automated script to be able to decrypt it in passing - I wouldn't sign any such key so exactly who or what is encrypting to this script?
Have you looked at x.509 certificates that have a different trust model, perhaps more suited to a "group" or "corporate" model rather than the individual trust inherent in GnuPG/PGP?
Automated encryption is fine - if you've got sufficient keys - but automated decryption always weakens the security and can make encryption itself worthless. How secure is the server that runs the script? How secure do you actually need the communication? Wouldn't using standard protocols via SSH accomplish the same end via much simpler (and standardised) methods?
I use a script to automatically encrypt messages from the server to those members who have suitable keys, but I'd never trust any server open to the internet sufficiently to decrypt messages automatically.

@_date: 2005-06-21 12:03:42
@_author: Neil Williams 
@_subject: Corrupt keys 
as does subkeys.pgp.net - it was retrieved automatically and without spurious signatures or errors.
gpg --list-sigs 0xF874C613
pub   1024D/F874C613 2005-04-28
uid                  Alphax sig          97394664 2005-05-23  [User ID not found]
sig 3        F874C613 2005-04-29  Alphax sig 1   P    C521097E 2005-05-05  [User ID not found]
sig 1   P    9C851DF1 2005-05-05  [User ID not found]
uid                  Andrew Cranwell (Alphax) sig          97394664 2005-05-23  [User ID not found]
sig 3        F874C613 2005-04-28  Alphax sig 1   P    C521097E 2005-05-05  [User ID not found]
uid                  Andrew Cranwell sig          97394664 2005-05-23  [User ID not found]
sig 3        F874C613 2005-04-29  Alphax sig 1   P    C521097E 2005-05-05  [User ID not found]
sub   2048g/51E09049 2005-04-28
sig          F874C613 2005-04-28  Alphax Delete the key from your keyring, retrieve it from subkeys.pgp.net and change your keyserver preference.
Because it's sensible and uses decent headers like List-Id.

@_date: 2005-06-21 21:17:21
@_author: Neil Williams 
@_subject: Corrupt keys 
It wasn't a keyserver issue, I was under the impression the problem was the key being used to sign the messages: 0xF874C613 whereas you are looking at

@_date: 2005-03-04 22:44:14
@_author: Neil Williams 
@_subject: PHP Script to Send Key to Keyserver 
Hopelessly broken and contains many damaged keys. Don't use it.
Use a functional keyserver and preferably one that handles subkeys properly:
like subkeys.pgp.net

@_date: 2005-03-10 20:53:49
@_author: Neil Williams 
@_subject: Encrypt - but no such user-id 
No, now you are trying to encrypt a file. To sign a file, use
gpg -b
gpg -s
I generally use -a as well to make it a text signature that can be easier to inspect and as I'm usually signing files for distribution, I use a detached signature that doesn't alter the file itself.
gpg -ab
Who are you encrypting TO? gpg could use any key in the keyring to encrypt the content, you need to tell gpg who is the intended recipient?
Who should be able to read this message? gpg cannot assume it was the most recently imported key, you need to tell gpg that you want the message encrypted TO a particular person.
gpg -r myfriend -e test
gpg -r 0x28bcb3e3 -e test
You have not given a User ID, use the option -r. gpg is telling you what you need to do. Tell gpg who is meant to read this encrypted text.
Provide a User ID of someone who should be able to decrypt the item. If that is only you, then you can use the default-recipient option in gpg.conf.
default-recipient name
                 Use  name  as default recipient if option --recipient is not used and don't ask if this is a valid one.
Because you haven't said who should be allowed to decrypt it.

@_date: 2005-03-21 09:17:50
@_author: Neil Williams 
@_subject: new (2005-03-20) keyanalyze results (+sigcheck) 
Jason, I've been meaning to ask you this for ages. In the analysis report, at the very tail, I get:
13 hops:     2
Farthest keys (13 hops):
  576E20E9 9A0BF27D
  01000000 2A000000
That   01000000 2A000000 line - what's that all about? It looks like debugging output to me, the 2 farthest keys are the line above.

@_date: 2005-03-22 11:18:18
@_author: Neil Williams 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
To find out what caused that fault, use the bt command: backtrace.
It happened in strdup() so that's usually because the string you are trying to copy (or copy to) is not accessible - maybe not properly initialised. The fault is not necessarily in the file identified above, it just showed up there. Use up and down commands after getting the backtrace to inspect the calls that lead to the segmentation fault.
You can't usually continue after a segmentation fault - or if you try you won't get predictable behaviour.

@_date: 2005-05-03 09:55:49
@_author: Neil Williams 
@_subject: 2 noob problems 
What command are you using? Search by keyid where possible or at least by something that's likely to be uncommon, like the email address. Don't underestimate how many keys are out there. Can you connect to the keyserver at all? This could be a network problem or a firewall problem.
Try --recv-key with your keyid.
Keyservers don't delete signatures so every time you self-sign, it remains on the keyserver. Deleting the signature once a key has been sent to a keyserver is pointless because refreshing the key will always import all the old Don't send test keys to keyservers!
Revoke this key and start again with a new one. If you want to do more local testing, use a second key that you never send to a keyserver.
Keyservers exist for the benefit of others, not for your test purposes. The keys are there to help other people verify and sign your key.

@_date: 2005-05-20 11:11:34
@_author: Neil Williams 
@_subject: Keyservers and the future 
Is that a completely different key to another domain used by the same owner?
I've got many domains but I only want one main key.
If someone trusts codehelp.co.uk does that mean they also trust dcglug.org.uk just because I've got both in the UID's of my key?
There are lots of keys with multiple UID's across disparate domains - like Are you proposing a completely new key per domain that is "less secure" than the personal key because it's per domain and not per user? Who controls such domain keys? Is this just another "corporate" key?
What about domains that have millions of users (like aol.com)?
I may trust one or two individuals with AOL accounts, there is NO way I'm going to trust everything from AOL!
You're just verifying that the signature is good, not that the key is trusted? That's reasonable.
How do you guarantee that From: cannot be spoofed - it sounds like you are delegating that to the individual ISP / domain holder. I'm concerned that the domain is too blunt as an instrument against spam and that it will remain easy to send spam from: aol.com and hotmail.com. Even if someone does compromise the AOL terms and conditions, users cannot ignore all email from that domain - it's simply too large - so I could not set the aol.com key to be untrusted or unwanted.
This could prejudice small domains, userspace domains, unfairly. The big domains would trivialise the signature because you could not discriminate between your AOL friends and the AOL spammers. If a particular domain holder with lots of accounts is tardy or just inefficient in booting off people who abuse their terms, the user is left with a useless "validation" because the user cannot distinguish between users at the domain.
Where does the secret key reside?
Who controls the signing?
What happens with the existing signature?
Are you using MIME to achieve this - what are you going to do about broken email clients like OE that hide the message when receiving PGP/MIME - the message body is displayed as an attachment.
What about other clients (like some webmail) that cannot yet cope with

@_date: 2005-05-20 23:26:17
@_author: Neil Williams 
@_subject: 2 noob problems 
As far as self-signatures go, these are an important part of key maintenance and key integrity. If a key has changed, there needs to be a verification that the change is tied to the secret key. If you add a UID or change the key behaviour in other ways, the key should be verified and the different components of the key "tied" together with a new self-signature. It's just like the tie on a bag - if you add another bag, you need another tie. If you use just the latest tie to secure everything in one go, you lose the ability to trace the management of the key.
If you're thinking of the other signatures, consider that people spend a lot of time and travel large distances to gain signatures on their keys - why should that be wiped out arbitrarily?
Even if the key that made the signature is out of use, the signature itself is still valid - it testifies that the owner of the key was verified on the date shown by the person named in the signing key.
Why is a new signature (of either type) more important than an old one?

@_date: 2005-05-21 21:28:32
@_author: Neil Williams 
@_subject: 2 noob problems 
If the signature expired, the new signature is needed. However, the *expired* signature is still useful too as it tells others that the key was also valid at the earlier date. Often, an expired signature only exists because the key originally had an expiry date.
Self-signatures are the only ones that are repeated on a key without an That leaves the new UID dangling - it's not "tied" into the rest of the key in the same way as all the other UID's.
I don't see how you would get two signatures from someone else on any one key, except because of an expiry. If I try to sign any key that I've already signed, I get an error.
No, but signing it one year and then signing it the next year does indicate that the contract runs over both years. It's a bad analogy because a key signature is a single point in time, a contract is generally intended to run over a period of time.
It's not meaningless - it still means that the key in question was verified by the signer on that date. The expiry of that signature is separate. It is a snapshot - a single point in time.
Simple answer there is that the GD is a bad design and nobody is forced to use it. That argument was played out on this list when GD was launched. Then don't allow your keys onto the GD. Simple.
It also means that the GD will ultimately fail to be global - it's subkeys.pgp.net that is most likely to be termed a global keyserver as it handles all keys without breaking them, like the older ones, and without allowing / encouraging other keys *not* to use it, like the GD.
Of course, I'm well used to writing and rationalising API's / ABI's.
I don't see that this is actually much of a problem. So it adds a few bytes to a public key - is that REALLY such a problem?

@_date: 2005-11-01 12:33:38
@_author: Neil Williams 
@_subject: Feature request: expand 'clean' to 'clean total' 
I think you've missed the distinction between this happening on a local keyring and the effect on a keyserver. If keyserver behaviour remains as now, changes like this to your local keyring will have no effect on the signatures that other people see in their keyrings.
Each user would be free to prune their local keyring - subject to having to re-run `clean` if they use gpg --refresh-keys.
Nothing - the keyserver simply adds your signature to all the others. The clean effect is local to your keyring. When you remove signatures from the copy of the public key in your local keyring, it has no effect on the copy of the same key in other, remote, keyrings like the keyserver or my local Probably not all - there are always a few people who sign keys without verifying them, there are few on my key.

@_date: 2005-11-21 13:43:21
@_author: Neil Williams 
@_subject: GPG on windows mobile 5 
Why not replace Windows with GNU/Linux by installing Familiar onto your iPAQ?
I'm running Familiar with GPE on a iPAQ HP3900. GnuPG is available as a package - pre-compiled and configured for Familiar.
GnuPG doesn't do the mail component, plus you have the usual problems with keeping a secret key protected whilst on a small, portable, device.
At least with a genuine GNU system on the device you can use sensible security mechanisms and have a truly security-aware kernel.
Don't confuse "for free" with "free software". The benefits of gnupg do NOT arise from the lack of a price tag but from the freedom to modify, copy and distribute the source code and compiled binaries.
Don't forget the role of the OS. It's hard enough protecting the device, let alone the holes in windows mobile security.
I couldn't even logout on my iPAQ using WinCE and anyone with SynCE installed on their GNU/Linux box could read and write all my Windows data without ANY security intervention whatsoever. That would INCLUDE a gnupg secret key. I could copy / move it off the device or replace it with a different one - you wouldn't know. I'd only need 2 minutes alone with your Windows iPAQ.
At least with Familiar, you have an ordinary user with a login password, a root user with a root password and a login manager. SSH connectivity is supported (and can be secured further) and it has a genuine 2.6 Linux kernel with iptables support for a genuine firewall too. It's up to you how secure you make your Bluetooth support but it's only enabled after you login.

@_date: 2005-10-13 19:36:12
@_author: Neil Williams 
@_subject: Recommended keyserver 
Yes, it does not cope well with photo UID's, subkeys that have an expiry date changed and other features.
pgp.mit.edu isn't as broken as some others, but it's not as good as the best.
Use subkeys.pgp.net
It's a DNS round-robin of 3 servers that support the widest range of gnupg keys and features.

@_date: 2005-10-13 22:11:10
@_author: Neil Williams 
@_subject: Bogus Key on Keyservers 
You can't. You need to rely on the fingerprint - that is the only unique identifier for any key.
It's quite unlikely that they would generate a key with the same userid and the same short key ID (8 characters) and most email clients now will display the 16 character ID which makes it even less likely. There are duplicates out there of the last 8 characters (0xDEADBEEF is the most common) but not of the longer 16 character ID.
(short keyID is the last 8 characters of the fingerprint, longer the last 16 Any change you make to your key could be mirrored by whoever created the other key. Use the fingerprint, that's what it is for.

@_date: 2005-10-22 20:30:53
@_author: Neil Williams 
@_subject: Delete key from keyserver 
It is actually a component of one of the major strengths - the web of trust.
1. It is made perfectly clear that you are the sole protector of your private key and if you still had your private key you could revoke the unused keys.
2. Revoked keys are valuable and should not be deleted from keyservers - the fact that a key has been revoked can be critically important.
3. Having lots of keys for (apparently) the same person is a GOOD thing as it explains, reinforces and encourages usage of the web of trust. It makes it less likely that anyone will be dumb enough to trust a key simply on the UID 4. It is up to the user to decide when it is appropriate to send their key to a keyserver. If anything needs to change it is that the documentation should more strongly encourage users to test locally and only upload keys that they are proposing to use regularly - not test keys.
One thing I have considered is that if a keyserver receives a new key (rather than an updated one) it might be possible for a protocol change to ask the user if this key really should be uploaded. The keyserver might use such a change in the protocol to pass an error/result code to the gnupg program submitting the key, raising the warning and asking for confirmation. No idea how workable this might be.
5. These unused keys typically don't clutter up the web of trust either - again because they usually only have self-signatures so they can be excluded at the first step of the calculations. Only signatures made by someone else on your key are counted to the web of trust.
It is the fault of the users that there are so many unused keys on keyservers. However, this is NOT a critical area. The capacity of keyservers is not a problem - critical or otherwise. These unused keys are v.small because they rarely have more than a self-signature and one UID.
No, it is more like not being reminded to not send junk to your website. It's not about "losing" anything, it is about the point at which your local data (the key) becomes public. You have simply copied a file to a remote location - you lose nothing by doing so.
That is exactly my point, NOBODY should rely on ANY of that information to identify a key. The only identifier for a key is the fingerprint. You MUST verify the fingerprint with the person and only then can you be sure that the key is for that person.
The web of trust enables such verification - if you can't meet me in person, you can verify my key by having your key signed by someone who has met me (there are lots).
Until that happens, you have no way of trusting that this key belongs to the named person. None. The signature simply means that the message has not been tampered since being signed.
You've got the wrong end of the problem. This is about enhancing security by preventing people making wrong assumptions about key ownership simply from the public data on the key that can be so easily duplicated. You can only trust the fingerprint - which cannot be duplicated.
It must be impossible for anyone but the key owner (or their appointed representative) to revoke a key. Any user can, however, mark a key in their keyring as disabled - it has no effect whatsoever on the keyserver copy, neither do you need the private key of that key to disable it locally.
It isn't. I could generate a key under your name at any time. The only way anyone can identify YOUR key is by getting the fingerprint identification from you.
Do NOT trust the UID until you can trust the fingerprint. If you don't have verification of the fingerprint, you cannot trust the key - at all. Zip. Yes, the web of trust and the benefits of keysigning.

@_date: 2005-10-22 23:13:51
@_author: Neil Williams 
@_subject: Delete key from keyserver 
Objections don't change the reality. No-one but you can trust your key.
As I said, you can verify my key via someone else. Once your key is in the "strong set" this becomes a lot easier. I regularly come across keys used on this list that are instantly verified by the web of trust.
The web of trust is scalable - you just need the opportunity to get signatures. This is an area where we largely make our own opportunities.
I have not met everyone I can trust via the web of trust. From David's stats, I have 20 or so signatures that link within the main set and I can trust some 1400 keys that way.
In certain areas, maybe. The only solution to that is to get more keysigning ? That key has NO signatures other than yourself! There's no way anyone can trust it. There are NO paths.
Instead, try looking for a path from Werner to me, or Jason Harris or some of the Debian developer keys.
See also these images of my keyrings:
Sorry to hear that but how hard have you tried? Have you travelled to somewhere that other key users might be expected to gather, like exhibitions or Linux meetings? Do you have a LUG in your area and have you joined? You aren't listed on biglumber so that's one avenue you haven't tried.
"Sorry, no matches were found.
That key has not been added to biglumber yet. Below is a list of user IDs from their key: you may wish to contact them and ask that they add themselves. Zeljko Vrba (UNIST-OSS) "
The way the web of trust works is that small, local, groups (like a LUG) sign each other's keys. At some point, one LUG member travels outside the local area and meets other key users at an exhibition etc. That keysigning links the small, isolated, ring into the main keyring. As this repeats, more and more strands are added to link the local group more and more tightly to the main "strong set". The strong set represents the keys that are closest to each other across the entire keyring and is populated by lots of package maintainers for the various distributions like Debian (because we use keys to authenticate uploads) and leading lights in the GnuPG/PGP and GNU world - like Werner, Peter Palfrader, Martin Michlmayr and Richard Stallman
For keysigning, that is:
1. Verify the physical person by a method of photographic ID that is widely accepted, e.g. passport.
2. Verify the fingerprint of the key using a print out given to you by that person face to face.
3. Verify the email address (possibly using tools like cabot).
No. It's just an email address - there could be any number of people with access to that email inbox.
What you need to verify is the person with access to the private key.
Same here, it hasn't stopped me getting lots of signatures.
That's not hard, I have a second key with similar signatures.
See 0xA897FD02.
You cannot. You need to verify the person behind the key, either directly or via someone who HAS signed your key.
The point is that verification is important for encryption and verification of package uploads. Email signatures are often just tamper-evidence.
Keysigning is testifying to the world that you have verified the person, the fingerprint and the email.
That is all you can judge with your key as is.
If you want a formalised external method of identity verification, consider using x.509 and people like Thawte will provide an alternative to GnuPG's personal (face-to-face) methods.

@_date: 2005-10-22 23:41:18
@_author: Neil Williams 
@_subject: Delete key from keyserver 
Sorry, that should be Jason's stats, not David's. Look for this message from Jason Harris for more info:
new (2005-10-16) keyanalyze results (+sigcheck)
16/10/2005 11:54 pm

@_date: 2005-10-23 12:05:18
@_author: Neil Williams 
@_subject: Delete key from keyserver 
That path is circular - it leads to your "master" key, to one signature and then back to you. It doesn't lead to any keys in the strong set.
There is still no way the web of trust can help your key become trusted without a signature that links you into the main key sets - preferably the strong set.
Compare with some of the paths from my key (including the path (v.short path) from me to Bob Henson who also replied to your query). (Hi Bob!).
You have enough for your key to be in the strong set:
The most useful thing to do for anyone seeking signatures is to join biglumber.com - it's linked into the keyserver at kjsl.com ( which makes it very useful for following paths and working out who could be available for keysigning if you are With a biglumber listing, Bob wouldn't have had to ask on the list, he could have simply looked up the details from the keyserver output.

@_date: 2005-10-23 18:03:04
@_author: Neil Williams 
@_subject: Delete key from keyserver 
I've got a v.v.brief one:
It's just why I use gnupg rather than a treatise on why someone else should use it. It is GFDL.
There's also general stuff here:
Elements of each could be combined - the FAQ isn't expressly GFDL but if it's used for GFDL material I would have no objection.
If that work is sent back to me, I would also be v.happy to publish it as part of the first site, under the GFDL.
Don't worry about the HTML, a plain text version crafted from these and other sources would be fine - as long as it can go under the GFDL.
No, you just have to be interested in GNU type stuff - and in most LUG's GnuPG qualifies as relevant.
Bad choice of email client!
There are plenty of email clients that integrate gpg/pgp very easily. The resistance is not against gnupg itself but against the change of email client / problems with the existing client.

@_date: 2005-10-26 21:00:06
@_author: Neil Williams 
@_subject: Delete key from keyserver 
No, because you've separated the two - there has to be a reason to do this and therefore you are implying that there is a difference between the two UID's.
I wouldn't sign the email only one because an email address can be accessible to more than one person. If I'm encrypting to this key, I want to know to WHOM I am writing.
I wouldn't sign the name-only one either - I cannot contact the person with that name because I have no idea if the email address is solely for the person named in the other UID.
A UID should reflect how I know a person. I've got several UID's and if you know me as webmaster, you sign that one, if you know me from the LUG you sign that one, if you know me professionally, you sign that one.
Without an email address and a name, a UID is rather useless.
But when signing a key, I'm signing a specific UID. It is bad practice to sign all UID's belonging to any one key. "Sign only the ones you can verify"  is my advice at keysigning events. If there's no email I cannot verify that UID. If there's no name, I cannot verify that UID.
IMHO, they should not sign at all.
A signature is a *public* testimony that you have verified this person.
You do not sign for your own benefit but to assist others. It is other people's perceptions of the act of signing that are important.
Sign locally - you get the benefits and the rest of us do not get more untrustworthy signatures on otherwise trusted keys.
The challenge token is sufficient because it is used to show that the person you met and verified personally also has access to the private key at the address indicated.
One form of challenge is explained here:
A verification challenge would use a modified procedure that nevertheless ensures that the person I met is the person with access to both the email account and the private key.
The real name always matters. email-only verification is pointless - it doesn't strengthen the web of trust.
So sign it locally. By signing it with an exportable signature, you are trying to indicate to ME that you have verified the identity of that person, not just the email account.
Not true. By all means sign that locally, but do not lead others to believe you have verified more than you have.
You don't if you sign locally.
You do if other people are going to be using that signature in their web of You should advertise this policy and then people like me could set your trust level to "Do NOT trust" so that none of your signatures ever count towards my trust calculations.
I cannot trust your signatures if you refuse to verify the *person*.
That's what it comes down to - your exportable signatures impact on MY web of trust and if you are not going to complete the full verification, others cannot trust your signatures.
I would recommend you only sign keys locally until you are willing to accept how other people would be affected by your incomplete verification policy.
BTW. Knowing this in advance, I would not sign your key even if I could verify your physical identity, fingerprint and email address. It would send the wrong signal to those who already know me.

@_date: 2005-09-04 10:02:28
@_author: Neil Williams 
@_subject: Transparent keyboards 
What makes you think a keylogger goes 'inside' a keyboard? The cable connection is just as easy and an internal unit (on the inside of the socket on the box) even better.
If someone has physical access to your machine whilst you are away, all manner of things can be done to compromise the system - a keylogger would be the least of your worries.

@_date: 2005-09-04 23:57:31
@_author: Neil Williams 
@_subject: Expired Keys 
Message was signed on 01/01/1970 12:59 am with unknown key 0x68312280.
The validity of the signature cannot be verified.
gpgkeys: key 8892825868312280 not found on keyserver
If you are going to sign emails, PLEASE make sure your key is on From previous discussions here:
gpg --batch --yes --delete-key `gpg --list-keys --fixed-list-mode \
--with-colons | grep "^pub" | grep -v "^pub:[u|f]:" | cut -f5 -d":"`
That deletes anything that is NOT u (ultimate trust) of f (full trust). Adapt the regexp ^pub:[u|f] to suit.
If, like me, you run this regularly as a cron job to filter out the useless keys that clutter up many keyrings, use:
gpg --check-trustdb
gpg --batch --yes --delete-key `gpg --list-keys --fixed-list-mode \
--with-colons | grep "^pub" | grep -v "^pub:[u|f]:" | cut -f5 -d":"`
gpg --import /home/neil/documents/gpg/people/*.asc
gpg --refresh-keys
gpg --check-trustdb
The import line brings back keys that I want but which I have not yet had a chance to sign.
The refresh-keys command updates every key still in the keyring - you could run that FIRST but it takes longer. It depends how likely it is that some of the "junk" keys will turn out to be trusted once refreshed.
Of course, one man's junk is another man's gold. YMMV.

@_date: 2005-09-05 01:40:34
@_author: Neil Williams 
@_subject: Expired Keys 
But then keyservers don't delete keys - expired or not.
Think about it, when I use a keyserver, I still want to be able to retrieve an expired key - so that I can KNOW it's expired!
It's even more important with revoked - simply saying the key isn't listed does NOT protect me from an attacker using a compromised (and revoked) key!
There are established protocols and packages for running keyservers - expired and revoked keys should be retained.
If you really just mean, as I've done, that you want a PHP/Perl web interface to a small group of users' keys then use gnupg and don't set any keys to ultimate trust - then there is never any trust to check. Put some other authentication in the web site and you could consider using a trust always model that allows you to encrypt to any key in the local keyring. Use gnupg on the box and something like GnuPG::Interface in Perl to handle the key selection and updates and take your updates from *public* keyservers that can be relied upon to give you complete and up to date information.

@_date: 2005-09-05 14:34:39
@_author: Neil Williams 
@_subject: Key signing policy 
I don't think there is one policy to fit all needs. There are FAQ's and HOWTO's on keysigning events/parties and lots of groups have their own policies for their own needs. There are also tools like CA Bot (by Peter Palfrader) and others that help in keysigning - particularly when keys and identities are verified at distant events and the participants won't necessarily meet again for a considerable time.
There's a very simple HOWTO for those who don't know the details of *how* to sign a key:
A more general FAQ based on the GNU Privacy Handbook:
and containing it's own keysigning guide:
And the general keysigning HOWTO:
All are written from a standpoint of a loose association of GnuPG users who correspond regularly by email and meet occasionally or just once. Each document tends to consider participants as individuals with their own individual key(s) and with no "group key" or "group hierarchy".
i.e. they are policies for friends/contacts, not necessarily policies for These may need to be adapted for your purposes. The main DCGLUG guide at is licenced under the GNU Free Documentation Licence.

@_date: 2005-09-28 19:21:45
@_author: Neil Williams 
@_subject: Newbie Help 
Did you generate your own key?
(with revocation certificate kept safe!)
Oops. Whatever you intended to do there didn't work.

@_date: 2006-02-07 22:45:14
@_author: Neil Williams 
@_subject: how can i sign a complete keyring 
There are keysigning tools that can do this - in association with something like gpg-agent that caches your passphrase for a few seconds.
If you're using Debian, there are tools you can use:
caff -- CA - fire and forget
 caff is a script that helps you in keysigning. It takes a list of keyids on the command line, fetches them from a keyserver and calls GnuPG so that you can sign it. It then mails each key to all its email addresses - only including the one UID that we send to in each mail.
(Note, it's better to retrieve the keys from a keyserver immediately prior to signing rather than to use a local (stale) keyring - just in case someone has revoked their key between the event and the signing.)

@_date: 2006-02-12 19:49:06
@_author: Neil Williams 
@_subject: Migrate from gnupg/Linux to gnupg/win32 
That's all that really matters.
If you've still got a working GNU/Linux system, you can retrieve the list of keys, if not just get them from a keyserver. All your signatures should be on the keyserver. (Unless you're using lots of local signatures).
The important point is the ownertrust which is not stored within the public keyring - so once the keys are imported from a keyserver, you may still have a usable ownertrust database.
Get the keys themselves from keyservers. (Always better than stale keys from a keyring file).
Copy the ownertrust or just re-run gpg --update-trustdb. It doesn't take too long for gpg to calculate who you can trust from your signatures and show you which keys you need to update.

@_date: 2006-01-23 14:18:16
@_author: Neil Williams 
@_subject: GPGOL breaks Enigmail 
Check that your own keys are still set to ultimate trust, then run $ gpg --update-trustdb
(It should find and re-import the old trust settings once your own key(s) is/are ultimately trusted again).
I had this problem once or twice with Kgpg - the key management GUI front-end for KDE - when I upgraded to KDE 3.5. It shouldn't happen but ....

@_date: 2006-03-13 11:11:57
@_author: Neil Williams 
@_subject: Problem removing a public key whose private key is gone 
Same as the public key ID for that secret key. It's only the ID, not the key, that is needed.
But seeing as you were too idle to create a revocation certificate before you thrust this useless key onto the keyservers, that's a moot point.
Why not? You are advised to create a revocation certificate when you create the key! If you couldn't be bothered to even do that, you are beyond help.
Nothing can be done to remove / revoke a key that has been sent to a keyserver unless you have EITHER the secret key OR the revocation certificate.
Sunk. Lost. Beaten. Hopeless situation. Impossible to resolve. Doh!
Take your pick.
There's no point in deleting a public key from your keyring if it's on a keyserver. You've just given the word another unusable key. Thanks.
ALWAYS create a revocation certificate BEFORE you send your key to a keyserver!!!! No excuses.
Just a test key? Keep it to yourself. Don't send to keyservers - ever.
Usable key? Create a revocation certificate BEFORE you send to a keyserver.
Keyservers are for the rest of us. If we don't need to know about your key, don't put it on a keyserver. It does not benefit you to send a key to a keyserver, it is for the benefit of others.
Werner et al. :
Maybe it's time that --send-key checks if the key to be sent has a secret key in the secret keyring and if it does, prompts the user about a revocation certificate BEFORE allowing the key to be sent? Even a simple prompt, default NO, would prevent the majority of these useless keys on keyservers. It's not that much hassle for those who have their certificate, depending on how often they add subkeys etc.

@_date: 2006-03-13 11:18:10
@_author: Neil Williams 
@_subject: Problem removing a public key whose private key is gone 
Sadly, that doesn't help the rest of us as the key is already on keyservers.
