
@_date: 2013-08-02 07:17:58
@_author: Philip =?ISO-8859-1?Q?J=E4genstedt?= 
@_subject: Is it possible to sign a key again after revoking a signature? 
Hi all,
I'm new to GnuPG and have probably been a little too ambitious for my
own good. I originally signed key AB4DFBA4 at level 3 after a meetup,
but was later paranoid that I was too lax and wanted to resign it at
level 2, but did the resigning (by deleting the first signature locally)
and revoking in the wrong order, and left my signature simply revoked.
After some tinkering I arrived at
 and now want to sign the
key again at level 3, but want to make sure I don't make a mess of it
again. The problem:
When I try to sign the key using gpg --edit-key, I'm told that (twice)
that the key "was already signed by key 9DC6C210" and that there's
"Nothing to sign with key 9DC6C210."
The first time I bypassed this didn't turn out great, so can someone
confirm to me that my (3) existing signatures locally, signing again and
then syncing with the keyserver will leave this is in a state where my
signature will be considered valid, in spite of an earlier revoke on the
same key?
As a side note, the interaction with revsig at the point where I had
made two signatures tricked me into thinking that it was possible to
revoke only one of them, since it asked for both of them separately.
Should I file a bug for this, or is it intentional? Also, since gpg
apparently doesn't really want one to make multiple signatures on the
same key, maybe it should warn when trying to upload a signature when
there's already one on the keyserver, but not locally?

@_date: 2013-09-11 23:42:30
@_author: Philip =?ISO-8859-1?Q?J=E4genstedt?= 
@_subject: Is it possible to remove capabilities from an existing key? 
My public key has the default capabilities sign and certify. I've seen
that some people have only the certify capability in order to be able to
keep the main key offline most of the time.
Is it technically possible to change the capabilities of an existing
key, even if there's no way to do it via --edit-key?
If it's not possible, what would be the consequence of adding a subkey
with the sign capability, which key would be used when both are

@_date: 2013-09-12 14:53:29
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: Is it possible to remove capabilities from an existing key? 
Certainly, I can't take the master key offline and then pretend it has
never seen a computer with a network connection. I could have used
other terminology, what I'm actually considering is how to remove the
private master key from my laptop, so that if it's lost/stolen I only
need to revoke the subkeys.
On Thu, Sep 12, 2013 at 12:07 AM, Daniel Kahn Gillmor
You're both right, I've tested simply adding a subkey with the sign
capability, and that's the one that gpg used, even with the master key
available. In other words, it's perfectly possible to do what I wanted
without modifying the existing keys.

@_date: 2013-09-15 11:33:06
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
Hi all,
Let's assume that I have signed enough keys and assigned enough
ownertrust so that if I had all the world's keys locally and did `gpg
--list-key --list-options show-uid-validity` I would see a bunch of
keys as valid via the web of trust.
Is there a way to determine if a given key would be valid in this case
without actually importing all the world's keys? It seems like the
keyserver ought to be able to find trust paths and that the keys could
then be downloaded and verified locally, but I've not found anything
to do this.
The practical problem I'm trying to solve is how to determine if a
signed git tag is in fact from a key I can trust without a lot of
manual work.

@_date: 2013-09-15 21:11:04
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
Right, I used the wrong terminology in my question. What I'm looking
for is an automatic way to find a (valid) signature path from me to
another key.
In very concrete terms, how can I determine which keys I need to
import so that the GnuPG dist sig (4F25E3B6) has full validity? Right
now I'm pretty sure that it won't matter which keys I import because
it's too many steps away, but that won't be the case for every key. My
current best approach is to use  in order to find
the shortest paths and then manually import the keys to verify that it
is in fact true...

@_date: 2013-09-16 17:45:27
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
That would nice, yeah.
Right, I want to use the calculated validity, possibly with my own
values for --completes-needed, --marginals-needed and
--max-cert-depth. talks about this.
I've tried (in a testing keyring) to sign and trust marginally 3 keys
that have signed the GnuPG dist sig key, and it indeed results in full
validity for that sig. However, it's not possible to proceed deeper
than 1 step without assigning at least marginal trust in people I
haven't met. Since --update-trustdb *does* ask me for ownertrust of
the dist sig key in this scenario, I'm guessing that at least some
people are willing to do that, and I can certainly see myself
assigning marginal trust to some of these keys.
What could certainly be automated is to find out if there are any
signature paths, but since no one has stepped up yet I'm guessing key
servers simply can't be queried for this information.
 can help for keys in the strong set, but requires
a lot of manual work.
If there are no good tools, what have others done to verify that they
have a path to 4F25E3B6?

@_date: 2013-09-16 22:37:52
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
Too bad. I guess one could do it by starting at the destination and
following signatures back using a shortest path algorithm and a lot of
requests to the keyserver, though.
How would an attacker create n independent paths without deceiving n people?
 says:
"At one extreme you may insist on multiple, short paths from your key
to another key K in order to trust it. On the other hand, you may be
satisfied with longer paths and perhaps as little as one path from
your key to the other key K. Requiring multiple, short paths is a
strong guarantee that K belongs to whom your think it does. The price,
of course, is that it is more difficult to validate keys since you
must personally sign more keys than if you accepted fewer and longer
Having multiple, short paths to a key would increase my confidence,
even if it's not as good as face-to-face verification. When I'm about
to compile some software and install it on a public server, that's
useful to me. Am I doing it wrong?

@_date: 2013-09-17 15:56:32
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
Going with the GnuPG built-on model, it seems like I can get the "n
people would need to be deceived" effect by (in a temporary keyring)
assigning marginal trust to all keys in the world and
--marginals-needed n, without requiring the paths to be independent.
Does that sound right?

@_date: 2013-09-17 22:01:00
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
That's a good point. So, if you have a tool to find signature paths,
it could also show a sorted list of the keys which you are trusting to
some non-zero degree. If similar/identical names show up, you
That's fine, I'm just trying to figure out what others do to convince
themselves that (e.g.) the GnuPG dist sig key is trustworthy-ish and
if there are any tools to help with the boring bits.

@_date: 2013-09-18 22:14:40
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
Yeah, that sounds like a useful approach. If I assume that the Wayback
Machine isn't part of a conspiracy against me, then I could use it to
check what signing keys were listed on gnupg.org in the past:

@_date: 2013-09-18 22:58:04
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
Yes, of course I would need to check it from multiple networks, but
even that is no guarantee, since the MITM could just be very close to

@_date: 2013-09-18 23:37:01
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
It's one more server which would have to be under the attacker's
control, in addition to gnupg.org, Google cache, mailing list mirrors
and whatever else one might find.
When checking the GnuPG dist sig key, the risk is some third party
modifying the source, i.e. that the code I'm getting is not from the
same origin as all the gpg binaries everyone else is using and
trusting with their secrets.
I wanted to try 2.1.0beta3 which isn't in Debian testing, but using
the package manager (which I trust) as yet another cross-check sounds
reasonable, if some package happened to include the dist sig key, but
I haven't found it.
While imperfect, checks like these might have to suffice until I can
use the web of trust to establish key validity instead.

@_date: 2013-09-19 09:26:20
@_author: =?ISO-8859-1?Q?Philip_J=E4genstedt?= 
@_subject: How to find and verify a trust path? 
I did mention it once:
Since the signature paths it finds can be verified separately, I don't
think it matters that it's not served over HTTPS.
Right, so I was looking for an approach that requires little work for
me, while requiring a lot of work for someone else to subvert. (Of
course I've already spent a lot more time discussing the approach than
I would investigating any single key, because the topic in itself is
fun and interesting.)
I get the feeling that if I say that I don't want a third party to
insert backdoors into gnupg, git, nginx, node, or whatever other
packages I might be compiling from source, you'll tell me that the
maintainer can do that as well and I should audit the code.
At the end of the day I'm assuming that Debian, GnuPG, Git and a lot
of other packages that I and people I know have used for years have
maintainers who care about their reputation, and that the reason these
packages are popular is because they've done a good job historically.
I've certainly trusted them with my secrets, so if the trust is
misplaced I've already lost. When compiling from source, it would be
nice to verify that what I'm getting is from these same maintainers. I
realize that there's no guarantee that the maintainers of the packages
I've been trusting using are the same people I'll find when following
(multiple, independent) signature paths, but it looks much better than
no check at all, and my servers and secrets just aren't important
enough to warrant going much further.
