
@_date: 2008-08-01 12:50:34
@_author: bezna 
@_subject: Keyblock packet tree structure? 
Hi Werner,
Thanks for the info. I'm looking now for some more detailed information,
maybe something like this:
PGP keypair Is that the gist of it or is there anything else that I'm missing or
glaringly wrong? What's the "root" packet where the tree starts, the one
that links the public key and secret key packets, if they are even linked?

@_date: 2008-07-28 08:34:05
@_author: bezna 
@_subject: Keyblock packet tree structure? 
I was wondering if someone in the know could fill me in on what, in general
terms, the structure of a keyblock in GPG looks like. I know it's a tree of
packets that diverges into one for the secret key and one for the public key
component, but what's at the root? Just what the arrangement of packets in
the keyblock is, maybe as a diagram (even an ASCII one in the email body),
is all I'd like to know.
Thank you,

@_date: 2008-06-06 13:26:19
@_author: bezna 
@_subject: max-cert-depth and "chains of trust" in GPG 
I'm a bit confused as to how trust is handled in GPG, or maybe PGP in
general. It seems to me that it is impossible to establish long chains of
trust in GPG, because trust databases are kept hidden from other users and
ownertrust values have to be set by the user himself; as a result of this
the maximum depth of a "chain of trust" seems to be 2: the owner (depth 0),
his trusted introducer (depth 1) and the person whose certificate is
validated by the trusted introducer (depth 1). When I got into GPG I was
under the impression that you could rely on long "chains of trust" or chains
of trusted introducers in order to validate a certificate at the end of the
chain. However, as Abdul-Rahman points out
( this
does not seem to be the case. Let me illustrate with an example. Say Alice signs Bob's key, and Bob signs
Charlie's key. Now say Alice fully trusts Bob. Suppose also that Bob fully
trusts Charlie. Because of her trust in Bob, Charlie's certificate appears
valid to Alice. The chain might look something like this (note that the
arrow represents both a valid signature and full trust given by the person
from whom the arrow originates to the person tip of the arrow).
          A --> B --> C
Depth: 0       1       2
Valid:   y       y       y Recall that Bob fully trusts Charlie. Now suppose Charlie had signed Dale's
certificate. In theory, this could lead to the establishment of a "chain of
trust" where Dale's certificate appears valid to Alice, who trusts Bob's
competence in assessing the authenticity of a certificate, who in turn
trusts Charlie, who vetted and signed Dale's certificate. How trustworthyess
should be computed as we progress down such a chain is another issue.
          A--> B--> C--> D
Depth: 0      1     2      3
Valid:  y       y     y      y
However, this does not happen in GPG. Because Alice does not have access to
Bob's trust database (unless he exports it and gives it to her), she has no
way of knowing who Bob trusts and to what extent. Thus, she can only rely on
the signatures made by Bob himself to determine if a certificate is valid,
but not Bob's trusted introducers because she has no idea who they are.           A--> B--> C--> D
Depth: 0      1     2      3
Valid:   y      y     y      ?
A workaround to this problem is for Alice to fully trust Charlie (who
appears valid to her because of Bob's signature) as an introducer, thereby
validating Dale's certificate through him. Note that Alice doesn't need to
sign Dale's certificate herself to do this. The next illustration shows the
situation from Alice's perspective only (IE she has no access to who the
other players trust). --> arrows represent both a signature and full trust,
while ==> arrows represent only signatures.
          A-->  B
           \      ||
     v
            ---> C==> D
Bob's certificate appears valid to Alice because she signed it. Charlie's
certificate is validated because she trusts Bob and Bob signed Charlie's
key. Dale's certificate is validated because she trusts Charlie and Charlie
has signed Dale's key.
Note that the graph tracing the signatures the players have made is
different from the above graph of Alice's trust database, keeping in mind
that Alice signed Bob, Bob signed Charlie and Charlie signed Dale:
          A==> B==> C==> D
Depth: 0      1       2       3
So for Alice to be able to validate a certificate through someone else's
signature, she has to personally trust that someone else; the trust can't
transfer through an intermediate. Ok, now, after all this, which I hope you understood, come the questions. Am
I understanding this correctly? Can "chains of trust" have only a depth of
one (Alice and the person she trusts) or is there something more? What does the max-cert-depth parameter refer to? Is that the depth of the
"chain of signatures"? And lastly, how do all these sites and applications that trace a path
between your certificate and another person's certificate work? Based on
tracing signatures alone? Is it possible to export your trust database to
these servers so they will aggregate it into one and take trust as well as
signatures into account in determining validity down a chain?
Is there anything out there that incorporates real chains of trust of some
substantial length?
Thanks for your assistance and for taking the time to read this.

@_date: 2008-06-09 11:30:59
@_author: bezna 
@_subject: max-cert-depth and "chains of trust" in GPG 
Dear David and GPG users,
Thank you for your clarification and prompt reply. I still have some further
questions. 1) On the output of the --check-trustdb command, there is a line for each
level of depth in the path of signatures similar to this:
gpg: depth: 3  valid:   1  signed:   0  trust: 1-, 0q, 0n, 0m, 0f, 0u
What does the "trust: 1-" entry stand for? I noticed that this "-1" entry
usually accompanies the last hop in the chain of signatures that has made a
signature to validate another key. Similarly, I've noticed that sometimes
"trust: 0-" appears. What does this mean?
2) I'm a bit confused about the tsign command. I tried setting up some test
cases in which there is a chain of tsigns of the form A-->B--C-->D-->E etc.,
each tsign having been answered with "full trust" and "level 10" at their
respective queries during the signing protocol. I was puzzled to find that
the same occurred as with "regular" signatures; only those certificates
which were signed by someone the owner placed trust in directly were
validated, but they were given no trust values (IE their trust was
"unknown"). The extra trust information encoded in the trust signature
seemed to be lost to GPG, with one exception: the certificates tsigned by
the owner himself. I noticed that as soon as those keys who the owner had
tsigned were imported, their trust was automatically set to the value given
in the tsign, rather than defaulting to "unknown" as with regular
signatures. This was not the case for tsigns made further down the line from
those who the owner had tsigned. Am I then to understand that trust in GPG
is not transferrable, and that assigning trust can only be done directly by
the owner and not delegated to others, even through tsigns? That is to say,
there's no way to place confidence in the trust calls made the users whom
your own trusted introducers trust, and thus have a propagation of trust
down a chain? I was under the impression that the tsign was useful in a
system which uses Certificate Authorities (CAs), but the mechanism behind
its use is unclear to me. Could you please provide some additional
clarification on how tsign is supposed to work in the grand scheme of
things?  And just how can another user "make a signature on your behalf"? 3) Also on the topic of tsigns, I was wondering what the trust signature
levels represented, how they are useful and whether any value greater than
10 (enough to qualify for a 'T') is treated the same.
Many thanks,

@_date: 2008-06-11 16:10:28
@_author: bezna 
@_subject: Questions about trust signatures 
Dear GnuPG users,
I have some questions regarding use of the tsign command; please don't feel
you have to answer all of them at once, just one will do, although I'd like
to point out that the one most important to me is  I?ve been doing some
reading and experimentation with tsign and I think I have a handle on how
the mechanics of it work. A brief aside: David Shaw posted a message
( )
providing a link to an article which apparently explained trust signature
concepts well (
). However, the link appears to be down and searches for the article have
turned up nothing. Does anyone (perhaps David himself) have a copy of it, or
know where I can obtain it? Thanks in advance; now, my questions:
1) My first question revolves around its application in a real-life
scenario. Suppose we have a strictly hierarchical environment, where the
validation of certificates depends solely on CAs. In such a scenario, would
the users perform trust signatures of a certain level on the CAs, who would
then perform trust signatures on CAs lower in the hierarchy (and thus lower
in power, since with each link in the trust signature chain the ?trust
power? represented by the depth allotted to the tsig diminishes until it
reaches 1, the terminal value, beyond which the trust chain cannot be
extended through empowering other users with tsigs). Consider the following
User 1 ? tsig of depth 2 -->  Root CA ? tsig of depth 1 --> Subordinate CA ?
regular signature --> User 2
Thus, through this chain of trust, User 2?s certificate appears valid to
User 1. A similar chain could be traced from User 2 to User 1, or between
any other two users in the organization, using the Root CA as a hub for
trust signatures; alternatively, only the subordinate CA could be the
trusted entity by the users, in the case where that CA is responsible for a
department and users don?t care about the validity of all the certificates
of users outside their own branch in the organization.
So my first question is,  have I understood the use of this command in a
real-world environment correctly?  Are there other ways in which it could be
applied? Can it be applied in a non-hierarchical context? What I mean by
this is, is there some way to get rid of this ?depth? functionality and to
be able to propagate trust continuously and indefinitely down a chain of
users, without having it diminish until it reaches an endpoint? For example
( --> denotes a signature, ==> denotes trust) :
A ==> B ==> C ==> D --> E
Through this chain of trust, Eve?s certificate appears valid to Alice. The
implementation of this example using GPG trust signatures would involve
using descending orders (the ?depth? parameter) of trust signatures with
each hop:  A =3=> B =2=> C =1=> D --> E
Obviously this ?depth? parameter is better suited to the CA example outlined
earlier; it might not be possible for Alice (or any  other user in the
chain) to know how many hops away Eve is, and what depth to tsign Bob with
so that she will validate Eve?s certificate. Furthermore, if Bob tsigned
Carmen with a depth of 4 (for his own purposes), the chain of trust linking
Eve to Alice would be broken since GPG computes certificate validity (and
trust in the case of tsigns) only down paths where each next node in the
path was tsigned with a lower ?depth? than the ?depth? of the tsign on the
node before it. Is there some way to circumvent this in GPG, short of writing your own code?
Does the PGP Corporation?s program offer any alternatives?
That was the main question I wanted to address. Now, here are some other
issues I have with tsign:
2) I noticed that when two disjoint, continuous (not broken by a tsign
assigning only ?marginal? trust somewhere) paths of tsigns of the same
length lead to the same certificate at the end of the path, the signature
which was last made is taken into computing that terminal certificate?s
trust rating, rather than some other criteria. This is hard to explain
without an example, so here it is:
  Root CA 1 --> CA 1  /                  \
A                    B --> C
 \                  /
  Root CA 2 --> CA 2 Bob's certificate has been validated in two companies he works for. Alice
wishes to find the validity of Charlotte's certificate, who was signed by
Bob. She has tsigned the Root CAs of both companies (with a depth of 3 for
the sake of the example). Now, the subaltern CA (tsigned with a depth of 2)
of Company 1 has tsigned Bob (with a depth of 1) and specified that he was
fully trustworthy when it came to validating certificates. The subaltern CA
of Company 2 though, had also tsigned Bob but according to him Bob is only
marginally trustworthy. According to the current GPG implementation, CA2's signature which is the
most recent would be used in determining Bob's ownertrust in Alice's trust
database! Consequently Charlotte's certificate would appear marginally
valid. This to me seems flawed. If CA1's signature was made before CA2's
(assume CA1 is a procrastinator), then Bob would appear as fully trustworthy
to Alice and Charlotte would be validated. The fact that Bob's
trustworthyness to Alice hinges on which CA got his signature in last seems
like a bad approach to me.
3) What's the point of masking any depth of a tsign greater than 9 with a T?
signature and so on. Signatures beyond the threshold of 9 aren't discretized
into the same class.
4) What do the "12x" and "13x" mean in the following --with-colones
--list-sigs output? sig:::17:2E62D2D5026D69FA:2008-06-11::6 120::David:13x:
sig:::17:1816F82A9DE5372F:2008-06-11::1 60::Larry:12x:
5) As in question 2, I noticed that if there are two disjoint paths of
tsigns that lead to the same certificate and one path is shorter (suppose
Root CA 2 signed Bob's certificate directly), the shorter path is preferred
over the longer one. Are there any other rules for determining which path of
tsigns is used, using criteria such as the level of certitude in the
signature (3 for "checked very carefully", 2 for "checked casually", or 1
[or 0]), the depth of the signature, and so on? The only other "rule" I
seemed to find was the one mentioned in question 2, with the newest trust
signature winning over the older ones.  That's all for now. Thanks for reading. Please note that Question 1 is my
priority, so please don't feel you have to answer all the questions or all
of them at once.
Thank you,

@_date: 2008-06-13 08:07:12
@_author: bezna 
@_subject: Signatures stored as information inside a "public key"/certificate? 
I'm having a disagreement with someone over this. From what I've read,
signatures on a "public key" or rather, a certificate, including the
self-signature, are stored as a packet on that key. The important point:
This data (IE all the signatures made on your certificate) is encoded on the
certificate within that block of ASCII armoured text/binary data when it is
exported for someone else to import in their keyring. Now I'm being told that signatures are not part of the certificate itself,
but rather as data on the keyring, and that the "export" command in fact
exports this additional data from your keyring and somehow attaches it to
the public key to produce the ASCII armoured output or whatever. Similarily,
I'm being told that when you upload your keys to a keyserver, what is in
fact uploaded is your "keyring" and that this is where the signature data
comes from.
To me the latter view is false. I see the list of signatures as being a
component of the certificates stored within the certificate, not somewhere
else. When keys are uploaded to a server, you can filter out which keys you
want uploaded; the notion of a "public keyring" to me is simply a set of
public keys (certificates), with no extra data attached, or at least not the
signatures. While it is possible to export multiple certificates at once in
one block of text, this text contains just those certificates, not some
"keyring" or meta-entity; the certificates then contain their respective
signature data.
Which is correct? Are signatures an inherent part of the key or are they
stored extrinsically?

@_date: 2008-06-13 11:35:08
@_author: bezna 
@_subject: PGP doesn't import trust signatures w/ depth > 8 on keys exported 
I'm using PGP Desktop 9.8 and I noticed when I export a public key from GPG
and import it in PGP, any trust signatures made on it with GPG and given a
depth greater than 8 are lost. Presumably this is because of constraints
within PGP, IE the maximum trust depth that can be set in PGP for a
signature is 8.
I was wondering if anyone can provide a rationalization for why this is?
Ostensibly even a trust signature of depth 2 carries enormous power with it,
but there is no such cap on GPG. Furthermore, why are signatures in GPG with
a trust depth greater than 9 marked as a 'T' on listings, even though the
depth of the signature still matters (e.g. a trust signature with a depth of
14 is still more powerful than one of depth 12, even though they're both
labelled 'T'). Many thanks,
P.S. Sorry about the flurry of questions recently. I'm new to GPG and PGP,
have searched the list archives but I'd like to have greater in-depth
knowledge on some issues.

@_date: 2008-06-16 13:14:52
@_author: bezna 
@_subject: Questions about trust signatures 
Dear David,
First, thank you for your reply and for the working link to the white paper.
You have my enormous gratitude for taking the time to share your knowledge
with me. I believe you might be mistaken on this point. I ran some trials and it
seems that if the next trust signature in the chain has a higher depth than
the one preceding it, it is treated just as a regular signature (depth 0) and the trust data contained in the signature is discarded, effectively
breaking the chain. The next hop in the chain will have an appropriate trust
value of "undefined", and the one following it will simply be "unknown". See
for yourself:
A nice "continuous" chain of tsigs of descending order:
pub   1024D/B2D7B73D 2008-06-10
uid       [ultimate] Alice
sig 3        B2D7B73D 2008-06-10  Alice
sub   2048g/D4380BAE 2008-06-10
sig          B2D7B73D 2008-06-10  Alice
pub   1024D/87E9321A 2008-06-10
uid       [  full  ] Bobby
sig 3        87E9321A 2008-06-10  Bobby
sig 3      3 B2D7B73D 2008-06-16  Alice
sub   2048g/E88071D6 2008-06-10
sig          87E9321A 2008-06-10  Bobby
pub   1024D/0C73E6E9 2008-06-10
uid       [  full  ] Carlos
sig 3        0C73E6E9 2008-06-10  Carlos
sig 3      4 87E9321A 2008-06-16  Bobby
sub   2048g/4EE6F059 2008-06-10
sig          0C73E6E9 2008-06-10  Carlos
pub   1024D/026D69FA 2008-06-10
uid       [  undef ] David
sig 3        026D69FA 2008-06-10  David
sig 3      1 0C73E6E9 2008-06-16  Carlos
sub   2048g/D9A7D20C 2008-06-10
sig          026D69FA 2008-06-10  David
pub   1024D/1D764C2F 2008-06-10
uid       [ unknown] Elena
sig 3        1D764C2F 2008-06-10  Elena
sig 3        026D69FA 2008-06-16  David
sub   2048g/8829A23F 2008-06-10
sig          1D764C2F 2008-06-10  Elena
Curious stuff. What do you think?

@_date: 2008-06-17 14:09:06
@_author: bezna 
@_subject: Questions about trust signatures 
I think I made a small error in my last post, and I want to alleviate any
confusion. I made the following statment:
"The next hop in the chain will have an appropriate trust value of
"undefined", and the one following it will simply be "unknown"."
This is somewhat incorrect. In the case where Bob issues a tsign with a
depth greater than the one issued to him by Alice, the next link in the
chain (Charlie) will appear as valid to Alice but his trust will be
"undefined". David, who was tsigned by Charlie, will then appear to Alice
with a validity of "undefined" and a trust of "undefined". Finally, Elena,
who was signed normally (tsign of 0) by Charlie, will have a validity of
"unknown" and a trust of "unknown". This all makes sense to me semantically
but I just wanted to clarify so people don't get confused by my last post.
