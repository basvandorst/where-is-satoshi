
@_date: 2001-08-01 02:19:01
@_author: David Shaw 
@_subject: Photo ID patch, version 2. 
With some judicious changes, sure.  I doubt it will work as it stands
now - win32 doesn't do fork().
It should more or less just plain work on OS X.  I'd love to hear from
anyone who can try it and let me know how it works for them.

@_date: 2001-08-01 13:24:01
@_author: David Shaw 
@_subject: Photo ID patch, version 2. 
I posted it to gnupg-devel, but this thread seems to have migrated.
You can get it from
Strictly speaking it doesn't require X - it just runs an external
program to display the photo.  If you have a program that will work
without X, then it should work fine.  You can also save the photo to a
regular JPG file for future use, and that doesn't require any graphics
display at all.
V3 of the patch coming soon.  I have some good stuff to add :)

@_date: 2001-08-15 05:50:04
@_author: David Shaw 
@_subject: How to encrypt streaming data realtime? 
GnuPG isn't really the right tool for this job, though you might look
at the code in the /cipher/ subdirectory for the various symmetric
ciphers which should be able to handle that sort of thing.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2001-08-18 03:18:01
@_author: David Shaw 
@_subject: PGP: Invalid key ? 
In this case "invalid" means "not connected to you via the web of
trust".  Did you export both the secret and public keys?  (Having the
secret key there makes the public key ultimately trusted)
If not, then signing the key with an ultimately trusted key (even
signing it non-exportably) will make the key valid in PGP's eyes.

@_date: 2001-08-18 03:18:04
@_author: David Shaw 
@_subject: Same private key on multiple sites 
Also look at --export-secret-subkeys, which does almost the same
thing, but blanks out the secret part of the primary signing key.
This is really useful as it lets you keep the important primary key
(the one that collects signatures, and thus ties you to the web of
trust) offline altogether, and just use subkeys which are easily
creatable and revocable to do your work.  I'm a big fan of this
feature, as I also need to have keys in multiple places.
Hmm.  Should --export-secret-subkeys do an automatic --no-comment?  At
least for DH keys, GnuPG generates comment packets with the key
factors.  Is there a security implication with this?

@_date: 2001-08-21 00:53:02
@_author: David Shaw 
@_subject: Password reset 
In short, no.
That is a feature.  Remember: if you can reset your password and
regain access to a key, so could the Bad Guys.

@_date: 2001-08-21 14:41:02
@_author: David Shaw 
@_subject: Password reset 
Revocation and expiration are a very good and useful feature - but
they don't (and shouldn't) prevent people from using the revoked or
expired key.
OpenPGP puts the onus of deciding whether to use or trust a key on the
local user's side.  This is good, as it puts the control where it
belongs, but it also means that revocations and expirations are really
just advisory (i.e. "please don't use this key anymore", and "please
don't use this key after such-and-such date.").

@_date: 2001-08-21 16:29:01
@_author: David Shaw 
@_subject: Password reset 
Oh, yes, the implementation may make decisions, but the local user
always has control.
A revocation certificate is really just a signature.  If I remove it
(gpg --edit-key can do this easily), then my local copy of the key is
not revoked any longer.
An expiration date is just a time_t.  If I set my clock back to before
that time, the key isn't expired any longer.
The user always has control.  There is a convention between
implementations that they won't use a key that has a "revoked"
certificate attached, but what I was saying was that there is nothing
in the cryptography that prevents this.

@_date: 2001-08-21 18:11:01
@_author: David Shaw 
@_subject: Password reset 
Sure, but just because some implementations may not allow the user to
modify keys and dates and such, that implementation cannot usually
assume that that all implementations do the same.  If this locked-down
implementation will accept key data from the outside world (say, a
keyserver), then someone can still modify the key.
What RFC 2440 says or doesn't say is interesting, but not to my point.
My point is that there is nothing in the cryptography that prevents
this sort of thing from happening.  The cryptography *prevents*
someone from reading an encrypted document without a key.  The
cryptography *prevents* a signed document from being modified without
also invalidating the signature.
RFC 2440 is a social convention between human beings that says "if I'm
going to speak OpenPGP, I'm going to speak it this way".  Human
conventions can be trivially broken (e.g. set your clock back, or
remove the revocation).
It could be argued that this is a good or a bad thing, but it is
nevertheless the case that expiration dates and revocations are human
conventions in OpenPGP, and are not backed up by the mathematics.
Could there be a controlled OpenPGP installation that only
communicates among controlled nodes and never exchanges OpenPGP
messages or keys with anyone not under this control?  Sure.  In such a
case, one could expect expirations and revocations to be something
more than advisory - but they still wouldn't be backed up by the math.

@_date: 2001-08-29 18:33:01
@_author: David Shaw 
@_subject: No valid OpenPGP data found. 
Don't you think this could be an example of "be conservative in what
you generate, and liberal in what you accept"?  Generate perfect
RFC-compliant messages, sure, but maybe GnuPG should accept messages
that are somewhat broken (especially in this case, which is a
difference of whitespace only).
Maybe we need a --strict and --nostrict :)

@_date: 2001-08-29 19:07:02
@_author: David Shaw 
@_subject: No valid OpenPGP data found. 
It also says "a warning message or even a message rejection might be
appropriate under some circumstances."
So they may be legal, but GnuPG is still completely allowed to reject
the message :)
p.s. Though I think it should accept it.

@_date: 2001-08-30 03:09:01
@_author: David Shaw 
@_subject: Slightly off topic ... 
When you make an alias like that, you are prepending a string to your
input.  So, with the first alias, if you enter "clearsign foobar" you
are executing:
   mount /mnt/floppy && gpg --clearsign foobar
With the second alias, you are executing:
   mount /mnt/floppy && gpg --clearsign && umount /mnt/floppy foobar
The second line is clearly nonsensical.  You could pretty easily make
a shell script to do this instead:
    mount /mnt/floppy
  gpg --clearsign $*
  umount /mnt/floppy

@_date: 2001-07-09 13:25:01
@_author: David Shaw 
@_subject: Curiosity with RSA sign/encrypt keys 
I was doing some experimenting with the "new" (v4) RSA key format
(which cannot be generated by gnupg, but if you generate them via pgp,
gnupg will use them), and I ran into an interesting situation:
When looking at the actual packets in the key, the main public key is
algorithm 1 (i.e. "RSA Encrypt or Sign" as per RFC 2440).  The subkey
is also algorithm 1.  However, if I sign with this key, gnupg will
only use the main key, and if I encrypt with this key, gnupg will only
use the subkey.  The "!" syntax still does not allow me to encrypt to
the main key.  I tried removing the subkey altogether, leaving only
the main key and gnupg still would not allow it to be used for
encryption ("unusuable public key").
There are other algorithms (2 for RSA encrypt-only, and 3 for RSA
sign-only) that would make sense with this restriction, but algorithm
1 is specifically specified as an encryption and signing key.
I know that in real world use, there are a zillion reasons to use
primary and subkeys to divide signing and encryption and not use the
same key for both.  I'm just trying to understand gnupg's behavior
Any ideas what is happening here?

@_date: 2001-07-09 23:03:01
@_author: David Shaw 
@_subject: Curiosity with RSA sign/encrypt keys 
Aha, interesting.  Now it makes sense (I missed the keyflags packet).
I wonder why PGP generates v4 RSA keys this way.  I know there are
many procedural reasons why it is not a good idea to use a single key
for both signing and encryption, but is there a cryptographic reason
why using a single RSA key for both signing and encryption is a poor
idea, or was it just done to maintain the DSS/ELG key/subkey
sign/encrypt way of doing things that people were familiar with?
I'm looking forward to v4 RSA support in gnupg.  It neatly addresses a
common complaint about keeping a very large sign-only key that never
expires to collect signatures, and using the subkeys on that key for
actual work.  Gnupg's --export-secret-subkeys feature, plus v4 RSA
pretty much nails the problem for me.

@_date: 2001-07-10 23:20:01
@_author: David Shaw 
@_subject: (cosmetic?) bug in 1.0.6 
I just stumbled on a bug in 1.0.6.  If you have two keys with similar
uids, and you gpg --edit one of them and do something that needs the
passphrase, gpg may prompt you for the passphrase for another key.
For example, say I had two keypairs - "dshaw key1", and "dshaw key2",
and I wanted to add a subkey to "dshaw key1".  I do "gpg --edit
dshaw", and "addkey".  I am then prompted to type the passphrase for
"dshaw key2", which is wrong.
Note that even though the prompt is for a different key, gnupg still
requires you to type the passphrase for the key you are actually
working with.
The obvious workaround is to specify the key with the hex keyid.

@_date: 2001-07-12 20:01:02
@_author: David Shaw 
@_subject: GPG in a chroot env 
Since /dev/random is a device, can't you just mknod another one within
the chroot jail?

@_date: 2001-07-17 15:11:01
@_author: David Shaw 
@_subject: Semi-off-topic - Netiquette ? 
The guidelines are different for different uses of email.  For
person-to-person email, it's just fine to send encrypted email.  If
the person has a public key posted somewhere (web page or keyserver),
they can be presumed to accept encrypted email.  The worst thing that
can happen is you'd get back a note asking you to re-send in the
For mailing list or other public forum (like Usenet), encrypted
messages are frowned on.  Not really because of rudeness or etiquette,
but because it is mostly pointless - the message is going to "the
world", so you'd have to encrypt it to everyone on the list, which
mostly defeats the point of encryption.  You would also need a key for
everyone on the list/newsgroup which is unlikely to happen except on
certain specific lists - it's likely that everyone on this list has a
key, as this list is about GPG.  It's very unlikely to be the case on
a list with a different topic.
It is frowned upon to post your public key in each message.  There are
better ways to distribute keys (keyservers, web pages, etc) than to
keep sending it out in every mail.  It is, however, just fine to
include your key ID and fingerprint in each mail - it's a heck of a
lot shorter than the whole key.  Note that including your key
fingerprint isn't like signing the message - all it does is provide a
way for someone reading the message to get your key.  For very
prolific posters, it also provides a certain amount of weak evidence
the key is yours.  If someone wanted to spoof your key, it would be
very difficult to get around the many messages you had sent in the
past with your true fingerprint.  I say "weak" evidence, since
obviously key signatures and the web of trust is a much stronger
solution for this.
Clear signatures are generally accepted in any messages, public or
Finally, remember that these are just guidelines, and a particular
mailing list may have other guidelines and rules.  Still, most lists
that I've seen follow the guidelines above.

@_date: 2001-07-17 16:47:01
@_author: David Shaw 
@_subject: Semi-off-topic - Netiquette ? 
In theory, it shouldn't matter.  Since the key will (hopefully) be
validated via signatures in the web of trust, or at least via a
fingerprint checking phone call, there is no particular security
advantage to one over the other.  It isn't really an netiquette issue.
Stick them on one, the other, or both.  I recommend both - maximizing
your chances that someone will get the key in the first place.
That said, there are some handy advantages to keyservers - gpg can
fetch keys automatically and it's the also first place people look for
new keys.  If it wasn't for the problem that some older keyservers
have with certain of the newer v4 keys, it would be perfect.

@_date: 2001-07-18 14:09:01
@_author: David Shaw 
@_subject: "no subkey for key signature packet" 
I know there are two or three new keyservers being worked on that
presumably handle this correctly, and I know the PGP LDAPish keyserver
handles this correctly, but isn't anyone interested in pksd anymore?

@_date: 2001-07-19 21:33:02
@_author: David Shaw 
@_subject: programming languages & GNU PG 
I've seen the occasional Java crypto, but like most other things, it's
a C world.  The Java crypto usually is for a specific niche, like the
Hushmail code or the SSH implementation intended for use within a
It is pretty common for crypto software to contain heavily optimized
assembly code on top of the regular C.  Modern crypto is very math
intensive, and the assembly code can be massaged into giving much
better performance than C.

@_date: 2001-07-22 02:45:01
@_author: David Shaw 
@_subject: Steganography (`stealth') with GnuPG 
Stealth only works with old-style pgp messages (pgp 2.6.x and
friends).  It won't work with pgp 5 and up or openpgp (and hence gpg).
It worked by stripping and juggling headers so that all that was left
was raw encrypted bits which ideally would appear to be random.
You can probably use it with gpg if you generate pgp 2.6.x compatible
messages (gpg --rfc1991 --cipher-algo idea --no-literal) using an old
style v3 RSA key.
You might want to also look into gpg --throw-keyid.  While that does
not result in a message that resembles random noise (it's still
clearly a openpgp message), it does remove the ID of the user the
message was encrypted to which provides some level of security for a
message intended for steganographic hiding.

@_date: 2001-07-22 02:47:01
@_author: David Shaw 
@_subject: Steganography (`stealth') with GnuPG 
Er, make that "gpg --rfc1991 --cipher-algo idea --compress-algo 1".
Wrong cut-n-paste :)

@_date: 2001-07-22 22:17:01
@_author: David Shaw 
@_subject: Steganography (`stealth') with GnuPG 
Oh, it's certainly possible.  You might even be able to adapt the
existing stealth code for openpgp messages.  The hard bit is that
openpgp allows for different symmetric and asymmetric ciphers among
other things - part of what made stealth as simple as it is was the
guarantee that every message would be RSA/IDEA.

@_date: 2001-07-24 19:03:02
@_author: David Shaw 
@_subject: Selecting signing key 
Try gpg -u 8A1D9A1F!
Note the exclamation point at the end (which you might have to quote
so your shell doesn't get to it).

@_date: 2001-07-25 15:55:02
@_author: David Shaw 
@_subject: Setting default UID 
That's not completely true.  There actually is a "primary user ID"
packet defined for OpenPGP.  The catch is that while I believe gnupg
will do the right thing if it sees such a packet, it doesn't yet
provide a way to generate such a packet.

@_date: 2001-07-25 19:29:02
@_author: David Shaw 
@_subject: Win32 passphrase proposal 
More than just automation.  Any program that calls gpg to do something
for it may use --passphrase-fd.  For example, the mutt mail user agent
has very nice gpg/pgp integration and hands the passphrase the user
types over to gpg using --passphrase-fd.

@_date: 2001-07-26 04:02:02
@_author: David Shaw 
@_subject: Question about images 
GnuPG doesn't support images (that is, it doesn't blow up if it sees
one, but doesn't display it either).
The "[revoked]" thing, I don't quite understand.  Is the uid actually
revoked?  I just tested a key with a non-revoked photo ID
(prz and gpg (1.0.6) claims the photo id is revoked as well.

@_date: 2001-05-28 20:28:01
@_author: David Shaw 
@_subject: gpg key server 
Speaking of keyservers, GPG's keyserver support is for the HTTP-ish
PKS server, while PGP now uses a LDAP-ish server.  Are there any plans
to support the LDAP type keyservers in GPG?

@_date: 2001-10-16 06:14:01
@_author: David Shaw 
@_subject: Sig classification, version 2 
I try and send this sort of thing to gnupg-devel where it belongs, but
half the people who mailed me about the patch are only on this list.
Anyway, here's version 2 of the sig classification patch I sent in
yesterday (thanks for the comments, everyone).
It contains everything that was in version 1, with some better help
text, and it also shows a few other pieces of information about the
  1-3 == amount of verification in the signature (just like before)
  L   == local signature (e.g. made by "--lsign-key").
  R   == signature is non-revocable.
  P   == a policy URL is attached to this signature.
  N   == a notation is attached to this signature.
You can use the --show-policy-url and --show-notation options to
display the policy or notation (in a --list-sigs or --edit/check).
There is also a --no-show-policy-url and --no-show-notation for the
folks who like to override their config file on occasion.
--fast-list-mode disables everything except the 1-3 levels of
verification (which don't cost anything to retrieve).
 Comments welcome.

@_date: 2001-09-05 14:31:01
@_author: David Shaw 
@_subject: Extending the key expiration date 
I wouldn't call it a flaw.  I'd call that a feature :) Having to
revoke the self-signature and put a new one in place will lead to huge
trails of self-signatures followed by certificate revocations followed
by more self-signatures every time the user changed their preferences.
2440 says that implementations should rewrite (i.e. replace) the
self-signature when the key expiration date changes.  Both PGP and
GnuPG do that.  The problem is when you then send that key to someone
else (or a keyserver) who had the key already with the old
self-signature, and you suddenly find you have two self-signatures.
In any event, the standard allows for multiple self-signatures.  It
doesn't give too much help in how to work out conflicts though...

@_date: 2001-09-05 20:30:01
@_author: David Shaw 
@_subject: Extending the key expiration date 
Sure, but you can revoke the key, which trumps the attacker :)

@_date: 2001-09-05 20:34:02
@_author: David Shaw 
@_subject: Extending the key expiration date 
I was referring to self-signature replacement in-place (rather than
revoking the old self-sig and adding a new one).  Is that not what you
were referring to?

@_date: 2001-09-05 20:51:02
@_author: David Shaw 
@_subject: Extending the key expiration date 
Ah, I just twigged to the confusion.  I was discussing self-signatures
because the key expiration time is contained in the self-signature.
Changing the expiration time of the key involves changing the
My point was that it is a Good Thing that OpenPGP allows
self-signature replacement in-place, rather than forcing a revocation
and new signature.  Otherwise, every time you change the key
expiration time (or any key preferences, actually), the key will gain
a revocation and signature.  After a while, that makes for a really
huge key.

@_date: 2001-09-05 21:20:01
@_author: David Shaw 
@_subject: Extending the key expiration date 
It's the eternal conflict between ease-of-use and security.  It's a
handy feature to be able to extend the expiration date, but it is not
as secure as an unchangeable expiration date set at key generation
It would be nice if there was a way to support both and let the key
owner decide.
The spec does allow for nonrevocable signatures..  I wonder if a
nonrevocable self-signature would be useful here to signal the
implementation that it mustn't be changed.  It isn't as secure as
having the date in the key packet, but it would at least force the
attacker to modify the key (replacing the original self-signature),
and as you point out, that's not easy in a deep network.

@_date: 2001-09-20 04:15:02
@_author: David Shaw 
@_subject: Replacement subkeys 
Content-Disposition: inline
Content-Disposition: inline

@_date: 2002-04-01 20:52:01
@_author: David Shaw 
@_subject: RSA 
Yes.  You will need the IDEA plugin to read the message.
Please read  first, but if this
does not apply to you, you can get the plugin at
ftp://ftp.gnupg.dk/pub/contrib-dk/idea.c (and idea.c.sig)

@_date: 2002-04-03 19:33:02
@_author: David Shaw 
@_subject: Key Type & Size / Multiple Email Accounts / Key Server Questions 
You actually have another possibility which is an RSA key.
As to which to pick, it depends on the use.  ElGamal signatures are
somewhat controversial (they're hard to get right), and so may not be
widely supported in the future.  RSA signatures are physically large,
which may be a disadvantage if you're signing emails most of the time.
This document, while slightly out of date, is fantastic on the subject:
In general, if you are signing emails, then I'd pick DSA for your
signing key.
Well, DSA is limited to 1024, and that what to use (there is no point
in going smaller).  The size of the encryption key can be larger.  You
can pretty easily test how fast you can go with various key sizes.  In
general, the speed doesn't matter terribly much in practical terms
unless you're processing thousands of items an hour.
Yes, pretty much.

@_date: 2002-04-03 21:15:02
@_author: David Shaw 
@_subject: my signatures 
What sort of trouble?  Signatures that won't verify, or people
disliking PGP/MIME?
(I don't want to get into a PGP/MIME battle, but suffice to say that
some people like PGP/MIME and some people don't.)
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-04-03 23:11:01
@_author: David Shaw 
@_subject: searchable archive 
Oops.  I didn't mean to give the impression that it was a very
contentious issue.  Just very mildly contentious. :)
There are archives for this list (and others) on lists.gnupg.org, but
they are not searchable.  You can use Google to search them by
searching for "(whatever you want to search for) site:lists.gnupg.org".
In other words, just tack on "site:lists.gnupg.org" to the end of your

@_date: 2002-04-04 05:39:02
@_author: David Shaw 
@_subject: Key Type & Size / Multiple Email Accounts / Key Server Questions 
If you use one of the 1.0.7 development versions (or generate the key
in PGP), then RSA is an option.  Once the key is generated, you can
use it in your current version of GnuPG.
Only for signing.  Encrypting with ElGamal is just fine.
For what it's worth, I decided to start the transition to using an
OpenPGP key a few months ago.  I settled on an 4096 bit RSA master
key, with an ElGamal encryption subkey, and a DSA signing subkey.
Best of all worlds :)

@_date: 2002-04-17 19:05:05
@_author: David Shaw 
@_subject: Error 
The problem is you do not have the IDEA cipher installed.  Read:

@_date: 2002-04-17 19:21:01
@_author: David Shaw 
@_subject: verifying rsa signatures 
PEM and PGP are not the same thing.  While both use the RSA algorithm,
nearly everything else is different.  PEM keys and signatures are not
directly usable by an OpenPGP program (and vice versa).

@_date: 2002-04-17 19:24:01
@_author: David Shaw 
@_subject: How do I achieve full compatibility 
If you try to use IDEA in 1.0.7 and the plugin is not installed, GnuPG
gpg: the IDEA cipher plugin is not present
gpg: please see  for more information
 has reasons not to use IDEA,
and instructions on how to get it if the reasons don't apply to you.

@_date: 2002-04-18 19:12:01
@_author: David Shaw 
@_subject: Lost Cipher and Hash preferences 
Hmm.  This shouldn't make any difference - a key without preferences
defaults to the safe values of 3DES & SHA1.  What version of PGP is
your client using?

@_date: 2002-04-20 15:55:02
@_author: David Shaw 
@_subject: Automatic resyncing of keys? 
This is a feature in GnuPG 1.0.7.  Use "gpg --refresh-keys".
GnuPG 1.0.7 will be released soon.

@_date: 2002-04-21 19:19:01
@_author: David Shaw 
@_subject: Lost Cipher and Hash preferences 
Hmm.  I tried encrypting to your key here with 7.0.3 and all was well.
I don't know what was exactly was changed between 7.0.1 and 7.0.3 (or
if what was changed is relevant to this problem).  That said, here are
two things to try:
1) Add preferences to your key and give it to the customer to try
   again.  You can add preferences by going to the --edit menu, using
   "delsig" to delete your self-signature, then using "sign" to
   re-sign it with itself.  (gpg -u 1B32D54B --edit 1B32D54B)
   Make a backup first to be safe. :)
2) Ask your customer to upgrade (hard, I know).

@_date: 2002-04-22 23:05:02
@_author: David Shaw 
@_subject: Automatic resyncing of keys? 
Are you using 1.0.6e?  Can you show me an example?
I don't doubt you, but it's hard to imagine how this could be since
the keyservers work on numerical key ids, and GnuPG naturally couldn't
know the keyid of a key that wasn't already in its keyring.  Is it
possible what you saw what a new user ID showing up on an existing

@_date: 2002-04-23 05:02:02
@_author: David Shaw 
@_subject: Lost Cipher and Hash preferences 
Oops - sorry, I was thinking 1.0.7 in my head :(
To get back to your original problem, what version of PGP are they
using on their Unix box?

@_date: 2002-04-23 22:42:02
@_author: David Shaw 
@_subject: Revocation problem with keyserver 
This looks like a classic example of the "keyserver ate my key" bug.
Most keyservers on the net today cannot deal with multiple subkeys and
will respond by corrupting the key instead.
Hopefully the new generation of keyservers will come along soon and
solve this problem.  In the meantime, don't use the keyserver network
to distribute your key.

@_date: 2002-04-24 00:17:01
@_author: David Shaw 
@_subject: Revocation problem with keyserver 
I'm not saying don't distribute your key - I'm saying to provide it in
a non-keyserver place.
The problem with the two or three good keyservers out there are that
they synchronize with the bad ones.  If a key is sent to a bad one
first, then it is likely that the good ones will get a corrupted copy
of the corrupted copy of the key via synchronization.

@_date: 2002-04-24 15:07:01
@_author: David Shaw 
@_subject: Encrypting to different UIDs ? Use of subkeys ? 
Believe it or not, it can make a difference although it usually does
not.  Each different UID can have a different set of preferences
attached, which influence how the data is encrypted to you.
For example, say you use the same key for home and work.  At home you
like AES, BLOWFISH, and 3DES.  Your work requires TWOFISH, CAST5, and
3DES.  If you set the preferences properly, someone encrypting to your
home address would then use a different cipher than someone encrypting
to your work address.
All that said, people usually have the same preferences for all user
IDs and so in that case it does not matter.
Preferences do not attach to subkeys, but multiple subkeys in general
would of course mean a different key to encrypt to.

@_date: 2002-04-28 04:27:02
@_author: David Shaw 
@_subject: keyserver problems with my key - "Key block corrupt: more than one signature on subkey" 
Your guess is right.  Your key was unusable because the subkey had expired.
The HKP keyservers, including the pgp.mit.edu keyserver, cannot handle
an expiration time update on a subkey and will refuse to accept it.
There is not much you can do, unfortunately, unless you want to
contact each keyserver operator and get them to replace your key
individually.  This gets complex quickly with the keyservers
synchronizing with each other.
Try one of the CKS keyservers.  They do not have this problem.
One warning - do not try and make a new subkey with no expiration
date.  The HKP keyservers will mangle keys with multiple subkeys and
render all of the subkeys unusable.

@_date: 2002-04-30 22:44:01
@_author: David Shaw 
@_subject: Makefile errors? 
The tar you sent clears it up:
(a few dozen more ldap.h errors follow).
What version of OpenLDAP are you using?  You need OpenLDAP to compile
the LDAP keyserver code, but if you don't want to update your OpenLDAP
installation, you can configure GnuPG with the '--disable-ldap' flag.

@_date: 2002-04-30 22:59:02
@_author: David Shaw 
@_subject: MakeFile on SuSE 7.2 -- OK 
============================== START ==============================
SuSE 7.2 probably has a newer OpenLDAP than RH 6.2EE does.

@_date: 2002-08-03 16:02:02
@_author: David Shaw 
@_subject: Removing a bad signature in a key 
Your mystery signature is a "direct key signature".  It's a special
sort of self-signature that applies to the key data, rather than the
usual key signature that applies to the key data plus the user ID
being signed.
Direct key signatures have a few possible uses, but most commonly are
used to set a designated revoker.  A designated revoker is someone who
you appoint to (among other things) revoke your key if you are unable
to do so yourself.  In the example key you gave (Philip Zimmermann's
key 0xB2D7795E), he has a designated revoker set.
GnuPG 1.0.6 does not support designated revokers.  You'll need to
upgrade to 1.0.7 to see what's inside those 1F signatures.  To answer
your other question, no, there is no way to delete them within GnuPG
(you really don't want to - key owners set designated revokers for a

@_date: 2002-08-03 17:16:02
@_author: David Shaw 
@_subject: Installing GNUPG 1.0.7 to windows 
It is, but you can also use the regular MingW32 setup (mingw32+msys)
from  to compile it on a regular windows box.  It doesn't
compile cleanly out of the box though.  1.1.91 from CVS does.

@_date: 2002-08-03 17:16:07
@_author: David Shaw 
@_subject: My key expired, do I need to revoke 
The OpenPGP standard allows you to extend the expiration date of your
key.  If you like, you could just change the expiration date.
If you want to generate a new keypair anyway, then it is not strictly
necessary in this case, but good practice to revoke the old one as it
makes it significantly harder for an attacker to get ahold of your old
secret key and extend the expiration date against your will.

@_date: 2002-08-05 13:34:58
@_author: David Shaw 
@_subject: My key expired, do I need to revoke 
Fair enough, but at least the "big two" of implementations, PGP and
GnuPG, both permit it.  Offhand, I don't know of an implementation
that doesn't allow it.
The expiration situation is somewhat unfortunate in OpenPGP, as a hard
expiration limit (as in v3 keys) can be very useful.  Perhaps someday
there will be "v5" keys that can support both hard (like v3) and soft
(like v4) limits in one.  Incidentally, this is how GnuPG handles v3
keys with v4 self-sigs - the v3 limit is the hard limit, and the key
cannot be used beyond that no matter what.  The v4 limit in the
self-sig can be used to lower, but not raise this limit.  There is of
course no guarantee how other implementations will handle this case.

@_date: 2002-08-07 14:16:02
@_author: David Shaw 
@_subject: musings... 
No major reason, but a few minor ones.  It makes more sense if you
know that the key is incomplete - there is another subkey attached (a
DSA signing key).  I use the Elgamal key for encryption, the DSA
signing key in some places for signing, and the big RSA key is only
used to sign subkeys and is stored offline.

@_date: 2002-08-07 16:47:02
@_author: David Shaw 
@_subject: Message was not integrity protected 
Sure, get people to send you integrity protected messages ;)
That warning is to inform you that the message that was sent has no
MDC.  If it's a file that you encrypted yourself, you might want to
re-encrypt it with a MDC.

@_date: 2002-08-07 20:00:02
@_author: David Shaw 
@_subject: Incompatibility with CryptoEx OpenPGP CryptoEngine Version 2.1 ? 
I've seen a few problems with CryptoEx.  What happens when you try to
use the keys?
Could you send me some of the keys that cannot be used?  I'll check it

@_date: 2002-08-07 21:26:01
@_author: David Shaw 
@_subject: Groups of Keys? 
Yes.  In version 1.1.90 and later, GnuPG has a "group" command, to be
used like this:
group groupname 0x99242560 0x33ED72C6 0x13300731
Then you can encrypt to "groupname" and GnuPG will expand that to the
listed keys.  Note that the 1.1.x series are development only versions
of GnuPG that will eventually become version 1.2.

@_date: 2002-08-08 16:54:02
@_author: David Shaw 
@_subject: Algorithm support - patch for Elliptic Curve available ? 
I still have a copy.  If anyone wants it, let me know.  (I'd send it
to the list, but it's 60k).

@_date: 2002-08-09 00:08:01
@_author: David Shaw 
@_subject: Keyservers (was: Re: Dumb Question) 
Keep in mind that wwwkeys.pgp.net is actually several different
keyservers around the world.  Read  for the
whole list.

@_date: 2002-08-13 23:11:02
@_author: David Shaw 
@_subject: build of 1.0.7 fails on redhat 6.x 
Yes.  Redhat 6.2 comes with a very old OpenLDAP.  You need to either
upgrade to a newer OpenLDAP, or build GnuPG with
  ./configure --disable-ldap

@_date: 2002-08-14 13:42:02
@_author: David Shaw 
@_subject: Query keyserver with email address [was: invalid armor header] 
It is available in 1.0.7.
  gpg --keyserver (whatever) --search-keys email
It works for the LDAP keyserver as well as most of the HKP and
HKP-alike servers.

@_date: 2002-08-14 23:10:01
@_author: David Shaw 
@_subject: Detached signature on multiple files? 
GnuPG can do multiple detached signatures without any shell magic.
  gpg -b *.doc
I don't have a windows box in front of me, but it should work the same
way there.  I believe the problem you were having was using "-sb" to
sign, and not just plain "-b".

@_date: 2002-08-14 23:24:01
@_author: David Shaw 
@_subject: checking signatures in shell scripts 
GOODSIG gives you the full 64-bit keyid.  --list-keys gives you only
the lower 32 bits.  Notice that the the last 8 letters in the GOODSIG
id match the keyid in the --list-keys listing.
Still, fingerprint is the most accurate match.

@_date: 2002-08-15 02:45:01
@_author: David Shaw 
@_subject: Secondary Keys 
Specify the key by keyid when you determine who to encrypt to, and add
an exclamation point.
  gpg -r (subkeyid)! --encrypt foo.bar

@_date: 2002-08-15 03:05:02
@_author: David Shaw 
@_subject: Detached signature on multiple files? 
I'm sorry - I misremembered what multiple files for -b does.  Now that
I look at it again, this will not work.  When you specify -b with
multiple files, you are actually signing all the files together
(i.e. "gpg -b a b c" signs a concatenated with b concatenated with c).

@_date: 2002-08-15 04:36:02
@_author: David Shaw 
@_subject: keyserver.kjsl.com + photo IDs (Re: GnuPG 1.1.91 released) 
Rather than discarding them, why not just keep the attribute packets?
You can safely treat them as user IDs with opaque contents.  Just
invent a fake "user ID" string like GnuPG does ("[jpeg image of size
That would be nice.  Many people have lost keys to this bug, and HKP
keyservers are mostly worthless for serious use because of it.  Even
just a patch to discard any subkeys after the first would be fine, and
a proper fix can come later.

@_date: 2002-08-15 13:39:01
@_author: David Shaw 
@_subject: Using "ultimate" Owner Trust 
Think of it as one more tool in the key management toolbox.  There are
often multiple ways of doing something, and different people like
different methods.  For example, imagine a company where the CEO signs
everyone's key.  Without this signature, the key is not a "real"
company key.  Rather than having everyone sign (locally or otherwise)
the CEO's key, you can accomplish this by giving the CEO's key
ultimate trust.
Incidentally, the old --trusted-key option is identical to setting a
key to ultimate trust.  It's also one more tool - it may be easier for
this hypothetical company to give everyone a consistent config file
than it is to instruct employees on how to edit trust.

@_date: 2002-08-16 16:23:01
@_author: David Shaw 
@_subject: Can a private key be copied to another machine? 
Machine A>   gpg --export-secret-key (mykeyid) > mykey.gpg
Machine B>   gpg --import mykey.gpg

@_date: 2002-08-16 16:37:01
@_author: David Shaw 
@_subject: most convenient key type? 
The most interoperable key type is the PGP 2.x style v3 RSA keys.
This does not make it the best choice however.  v3 RSA keys can't have
subkeys, so you lose that benefit.  You also lose most of the new
OpenPGP features, and RSA signatures grow in size as the key size
grows, so if your RSA key is big, your sigs are too.
The best 'all round' key is a DSA signing key with an Elgamal
encryption subkey.  This is the default key in PGP and GnuPG and is
nearly as widely supported as PGP 2.x keys.
If you want to avoid the DSA 1024 bit limit, then you are back in the
"large sigs" problem with RSA (I don't recommend Elgamal signatures at
One possible solution is to do what I did: a RSA primary key, with an
Elgamal encryption subkey and a DSA signing subkey.  The RSA primary
can be whatever size you like and is used for signing the subkeys
(note that using a big primary key generally makes the hash the weak
point).  This works well with the GnuPG feature to use a secret key
without a primary.  I keep my large primary offline, and use the two
subkeys for actual work.
One disadvantage with this is the common keyserver bug that mangles
keys with more than one subkey.  Until that bug is fixed, you can't
really distribute the key with all the subkeys attached.  The other
disadvantage is that all versions of PGP have a bug in that it cannot
verify signatures made by a signing subkey.  GnuPG and Imad's PGP-ckt
Because it's not the most convenient or interoperable key type ;)
Elgamal sign+encrypt is still there, if you add an --expert to your
command line.  You can also make RSA sign+encrypt that way.

@_date: 2002-08-16 16:46:02
@_author: David Shaw 
@_subject: Can a private key be copied to another machine? 
Yes, that works as well, but it copies everything and replaces your
existing keyrings on that machine.  If you have don't have any keys
you want to keep on the target machine, then this is fine.

@_date: 2002-08-16 21:46:01
@_author: David Shaw 
@_subject: most convenient key type? 
This is true, but then you give up some of that interoperability,
since PGP 2.x versions (except modified ones) won't handle the v4
signature on the v3 key.  You need a program that handles v4
signatures so you might as well use a v4 key.  It's a good trick to
"upgrade" old v3 keys though.
It's an interesting problem with DSA - supposedly the 1024 bit limit
balances fairly well in terms of strength with the 160-bit hash you
use with it.  Even if you made a 2048 bit DSA key, the weak point
would be the 160-bit hash.  Of course, it can be argued that a large
key is more important than a large hash.  Still, a "better DSA" should
really raise both the key size and the hash size.
It actually used to be available, but was removed.  The main reason is
that the web of trust is currently built via signatures from and on
primary keys only.  Subkeys making key signatures would split the web
of trust into the PGP half (primary keys only) and the GnuPG half
(primary + subkeys).

@_date: 2002-08-17 16:32:02
@_author: David Shaw 
@_subject: most convenient key type? 
Sounds about right to me.  This is pretty much the same thought
process I followed when I decided on a big (4096) RSA primary, a DSA
signing subkey, and an Elgamal encrypting subkey.  Remember that
you'll have a few signatures made with the weaker hash floating around
until the better hash arrives.
There are still the two catches I mentioned before - most keyservers
don't like this key and until the keyserver bugs are fixed, I can't
upload the whole key (I have to leave off one of the subkeys to avoid
the key corruption bug), and that PGP won't verify a signature made by
the signing subkey.  GnuPG and PGP-ckt will.

@_date: 2002-08-17 16:33:02
@_author: David Shaw 
@_subject: most convenient key type? 
Right.  This is what I do.  It's true that this does not violate the
RFC (intentionally, the RFC says almost exactly nothing about trust
models), but I'm not too sure of the benefit here since you can use
the primary key on your desktop to sign other people's keys, just like
you (must) use it to sign subkeys.

@_date: 2002-08-18 15:29:01
@_author: David Shaw 
@_subject: Ldap Support 
If OpenLDAP is installed when you build GnuPG, it should notice this
fact and build the LDAP keyserver code automatically.  If you install
OpenLDAP after GnuPG is already built, you must rebuild GnuPG.
Once you have done that, you may specify a LDAP keyserver as
"keyserver ldap://whatever.com"

@_date: 2002-08-20 17:33:01
@_author: David Shaw 
@_subject: using various subkeys 
You are trying to make a key with two signing keys (primary and
subkey) and no encryption subkey?  If so, you can generate that
directly.  Just generate a "DSA sign only" key, then add a DSA subkey
to it.
Well, it's not clear actually.  The HKP bug eats keys with more than
one subkey, and you will only have one.  There may be another bug
lurking in there, but it may also be fine.  You could test it :)
8.0.  In other words, no current version.  Imad's PGP 6.5.8ckt can do
it, however.
Not sure.  Certainly 1.0.4 and later can do it, and I suspect much
earlier as well.
Well, theoretically yes, but no OpenPGP program accepts key signatures
from subkeys.  The attacker could do some magic to change the subkey
into a primary key, but then it would not be trusted any longer.
No.  It will use the signing subkey by default unless you are making a
key signature.  You will need to use the keyid! syntax if you want to
use the primary signing key to make a signature.

@_date: 2002-08-21 22:19:08
@_author: David Shaw 
@_subject: subkeys 
This is possible, but not within GnuPG.  It's a non-trivial
combination of gpgsplit, cat, and running gpg under a debugger to
persuade it to sign the subkey with your primary key.
Going the other way (making a subkey into a primary key) is much
easier.  Just gpgsplit the key, and edit the first byte of the file
that contains the subkey to transform it into a primary key.  Then cat
that file together with a user ID packet (from another run of
gpgsplit), and --import it.  You should sign it as well, but the
regular --edit/sign will do that properly.

@_date: 2002-08-22 00:49:02
@_author: David Shaw 
@_subject: most convenient key type? 
Legal if you do it right.  Notations are for future expansion of
signatures.  Currently, the only officially defined notation names are
the "user defined" ones.  Basically, you can use any name you like so
long as there is a " sign in it.  The idea here is that you create a
name like "my_notation_type and you can put whatever you
like in the value.  There are a few (officially undefined, and
therefore not "legal") other tags in use at the moment, most notably
However, if the intent here is to show users where to get your key,
there is a better way in the "preferred key server" subpacket.  This
is a URL (so it can be a file) of where to get your key, and it can be
in any signature.  GnuPG does not currently support this, but it's
pretty easy to add (just reuse all of the existing policy URL code).
One somewhat roundabout way to do it is to use a signature policy URL.
For example, take a look at Douglas Calvert's key 0x13300731.  When I
signed it, I included a policy URL that directs people to
  I could pretty easily add a link to that page saying something like
"...and to download my key, click here".
The preferred key server subpacket is probably the best way to go.

@_date: 2002-08-22 19:35:01
@_author: David Shaw 
@_subject: LDAP keyserver 
gpg --keyserver ldap://pgp.surfnet.nl:11370 --recv-keys 0xBBD3B003
You can put the "keyserver" line in your options file as usual if you

@_date: 2002-08-23 23:31:02
@_author: David Shaw 
@_subject: revoking a key using 'addrevoker' 
Yes, this is like the photo ID problem with the pksd keyservers.  Only
the LDAP keyservers can handle designated revokers.
I know Jason Harris was fixing lots of pksd problems, perhaps you can
persuade him to fix this as well :)

@_date: 2002-12-02 19:13:02
@_author: David Shaw 
@_subject: Encrypting a file for anyone to read if having my public key. 
I'm not quite sure what you're trying to do here, or why.  If you want
a message decryptable by your public key (which is presumably public,
then why bother to encrypt it at all?

@_date: 2002-12-02 21:12:01
@_author: David Shaw 
@_subject: Encrypting a file for anyone to read if having my public key. 
It works mathematically (an OpenPGP signature is partially done by
encrypting with your secret key), but the actual programs do draw a
distinction between the public and secret keys.
This works for me.  Of course, I use 'cat' instead of 'type'.

@_date: 2002-12-03 04:10:01
@_author: David Shaw 
@_subject: PGP and signing subkeys 
I wouldn't call that a particularly great feature...  If a user sets
an expiration date, and that date has passed, the UI should note that
fact.  That signature is not "good" any longer.
GnuPG sets the critical bit for its expiring signatures, which causes
them to be invalid in PGP 8 anyway, so this isn't an issue with GnuPG.
That's a feature ;)
The PGP 8 behavior is legal according to the spec, but it is
unfortunate.  I'd rather see the UI report "expired signature" or some

@_date: 2002-12-03 04:44:02
@_author: David Shaw 
@_subject: PGP and signing subkeys 
Sure, but that seems to be an actual bug, rather than an "I wish".
The behavior is legal according to the spec, so I agree it's difficult
to argue adding a feature.  Especially difficult since PGP 8 does
correctly reject an unhandled critical signature subpacket, so there
is no real-world issue here.
If someone really cares about their expiration dates, they should mark
them as critical.  If they're not critical, then an implementation
should be free to ignore them (heck, GnuPG <= 1.0.6 did just that).

@_date: 2002-12-03 13:51:02
@_author: David Shaw 
@_subject: Ohhhh jeeee: mpi crosses packet border 
This is a known bug with the pksd keyserver.  It occasionally mixes
garbage in with larger keys.  They keyserver operators need to upgrade
to pksd 0.9.5.

@_date: 2002-12-03 16:43:01
@_author: David Shaw 
@_subject: PGP and signing subkeys 
Wow.  I just checked the final 8.0 release and it seems to ignore all
expiration dates on data sigs, whether critical or not.  That
seems... suboptimal.  Hope they fix that in 8.1.

@_date: 2002-12-04 23:43:02
@_author: David Shaw 
@_subject: GPG 1.3.1: Can't import key 
None of the above.  That key is an Elgamal signing key.  They're slow,
and I mean *really* slow.

@_date: 2002-12-05 01:00:01
@_author: David Shaw 
@_subject: GPG 1.3.1: Can't import key 
Your keyring has your self-sigs cached.  Someone importing the key via
--import or a keyserver doesn't.  When using your key, they have to
verify your signature 10 times (once for the self-sig on each user ID,
plus three more times for the three revoked user IDs).  It adds up
fast.  Try using your key with --no-sig-cache set and you'll see what
I mean.
When Michael deleted some of your user IDs, he caused his sig cache to
be updated, which makes things seem faster since GnuPG doesn't have to
verify each signature every time the key is used.
You can do the same thing for a whole keyring at once with
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-12-05 03:20:02
@_author: David Shaw 
@_subject: GPG 1.3.1: Can't import key 
Yes, they have DSA keys.
Not corrupted.  David's key has several user ID revocations on it.
Elgamal is a very slow signing algorithm, and validating those
revocation self-signatures takes time.
When you deleted one of them, you caused the signature cache to be
updated, so the sigs didn't need to be checked again.  You could have
deleted anything from that key or run --rebuild-keydb-caches and
gotten the same result.
When GnuPG imports a new key, it automatically caches signatures, but
does not cache user ID revocations.

@_date: 2002-12-05 14:43:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
I think this is not terribly safe - as "postmaster" for a few sites, I
know that I get a lot of bounces that would surprise the users the
mail was intended for.  An unscruplous postmaster could also get the
signed keys from the mail spool and abuse them.  The only way to be
totally safe is to never generate a signature unless you intend it to
be used.
I actually started setting up a similar robot at but I've almost persuaded myself (after arguing the other side for a
while) that there is no point in such a service.  You can get a
reasonable binding between key and email address, but how useful is
that in the real world?  Remember that the usual real-world binding is
between key and *person* (hence checking fingerprints in person, etc).
It comes down to this: I am a person who wants to encrypt a message to
Alice.  I get her key from the keyserver.  Assume for the sake of
argument that I don't have a strong key<->person trust path to her, so
this weaker key<->email path is a possibility.
Two possibilities then:
1) Alice's key does have such a signature, so I go ahead and send my
   encrypted mail to her.
2) Alice's key doesn't have such a signature, so I don't know if the
   email address has been verified... but I don't care; If the person
   behind the email address does not have access to the key, they
   won't be able to read the encrypted message I just sent them
   anyway.
Where's the benefit?  If it was guaranteed that ALL keys would have
such a signature then there is the traffic analysis benefit of never
sending a message like in the second example.  However, in the real
world there is no such guarantee.
I'm not dismissing the idea (it's interesting engineering one of these
things, and I've done it myself as well), but I'm having problems
seeing how it's useful in the real world.

@_date: 2002-12-05 17:09:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Encrypting the response isn't always possible.  Remember that OpenPGP
supports sign-only keys.  Even so, it's just safer design - if the
signature never existed in the first place, then there is no way it
can fall into the wrong hands.
How?  I understand the arguments you are making, but they are really a
"here's how it works" rather than a "here's the benefits it brings".
The only reason I have come across thus far to do this at all is to
combat this one particular denial of service attack:
Mind you, I'm not saying that this isn't a good enough reason to do
it.  I just don't want the impression going around that email
verification is somehow "secure", and the best way to do that is to
lay out in clear terms exactly what this is good for.
You're not saying this is secure, and in fact saying the opposite,
which is admirable.  Many people won't understand that, unfortunately.

@_date: 2002-12-05 17:13:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Better to expire the signatures themselves.  If you expire your
signing key, then everyone will have to get their key re-signed.
Yes, but it doesn't have to be encrypted.  Signatures are made on the
primary key, which is (99.9% of the time) a key that can sign.  You
can do the same thing by sending a challenge and asking for it to be
signed.  This is what I did with keysigners.org.
Note also that OpenPGP defines multiple signature verification
levels.  I've argued in the past, and continue to argue now that any
automated signer should use 0x11 "persona" signatures as a hint that
this is an unusual signature.

@_date: 2002-12-05 20:45:02
@_author: David Shaw 
@_subject: 2 FAQs 
"sig", followed by:
1. ! for good sig, - for bad sig, % for error, and blank for no public
   key available to verify sig.
2. 1-3, giving the verification level of the key.  This is just
   cosmetic (a note from the signer to you) and has no bearing on
   whether the key is trusted or not.
3. L for a local signature, blank if not local.
4. R for a nonrevocable signature, blank if revocable.
5. P if a policy URL exists on this signature, blank if not.
6. N if a notation exists on this signature, blank if not.
7. X if the signature is expired, blank if not.
8. 1-9 if this is a trust signature, or "T" if the trust signature
   depth is greater than 9.  Blank if not a trust signature.  (GnuPG
   1.3.x only).
Make a signature, and when it asks you for the level, enter a '?'.

@_date: 2002-12-05 21:08:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
You know, now that I think about this some more, whether the key or
the sigs expire, people are going to have to get re-signed
periodically.  (Let's say 1 year for the sake of argument).  Given
that, it's not clear which is better:
1) Expire the robot's key every year.
2) Expire each signature the robot makes every year.
3) Both (if you're planning on doing  there is no harm expiring the
   sigs at the same time).  No real benefit either though.
 helps with the problem that the robot's key lives on a box
publically available on the net.  If that box gets cracked, then the
robot's key can be abused.  This helps put a limit on the amount of
abuse possible (though you should still keep a revocation certificate
and revoke the key if necessary).  The drawback is that everyone using
the system would need to get the new robot key each year.
 is good since it simplifies what the end user needs to do -
specifically, they don't need to fetch a new key each key to verify
these signatures.
Given that there must be a way to revoke and re-issue a robot's key
(for example, you've already had to do this once), I'm leaning towards
 or  now.  Of course, I pulled the "1 year" time period out of
thin air.
Incidentally, the option you are looking for to make expiring
signatures is --ask-cert-expire.

@_date: 2002-12-05 21:37:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Yes, but *how*?  The goals are laudatory, but what exactly does this
give us in concrete engineering terms?  What makes this better then
Granny just going ahead and using an untrusted key?
We've discussed one reason thus far: it makes it a lot harder for
Mallory to perform a DoS attack against by publishing a bogus "Alice"
key.  Still, remember that Granny's software can defeat the same
attack by just encrypting to all "Alices".
What else is there?

@_date: 2002-12-05 22:25:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
That's an excellent idea.  If (for example) the 2002 key expired in
2004, and the 2003 key expired in 2005, then you can spread out the
load for user recertification.  It does mean that users will need more
than one robot key at a given time in their keyring though.  No real
harm, since this can eventually be handled automatically.

@_date: 2002-12-05 22:28:02
@_author: David Shaw 
@_subject: 2 FAQs 
No.  However, all designated revoker signatures are also nonrevocable,
so that's why it may look that way.

@_date: 2002-12-05 23:03:03
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Agreed, BUT: in the real world, there is no way to guarantee that
every key holder will get this email checking signature.  Therefore,
there will be some keys with, and some keys without.  Therefore we
must handle both cases.  My thinking is that since we have to handle
both cases, there is no benefit derived here.
If Granny gets Alice's key, and it doesn't have the signature, her
only proper course of action is to use the key untrusted since she
doesn't know if Alice has had her key validated or not.
I think that an email checking robot could be very useful in closed
communities - say, the Debian folks, a university, or even a
particular ISP or email provider (the "hotmail.com" robot?).  In a
closed community, Granny CAN say "if the key isn't signed, I won't use
it".  This is why some companies have a "official key signer" key, and
the Debian folks have their own authentication scheme.
Doing this for all email across communities has no benefit that can't
also be gotten via smart code on Granny's computer, and since we need
that smart code anyway for those keys that aren't email-validated, why
do the work twice?
If Alice doesn't have a key at all, then all schemes fail.  Let's
presume at least that Granny can get some of Alice's keys.
If Alice has multiple keys, and one is validated, then Granny
encrypted to the validated one.
If Alice has multiple keys, none validated, Granny encrypts to all
Granny can get.
Now, since Granny has no way to know if Alice has gotten her key
validated, Granny can't tell the difference from the first case and
the second case where she was unable to get the validated key.  This
is the case for all non-closed communities.
(Yes, I know Alice could tell Granny to look for the email validation
signature, but if Alice can communicate securely with Granny, then
Alice could just read her a key fingerprint as well).

@_date: 2002-12-05 23:12:02
@_author: David Shaw 
@_subject: 2 FAQs 
Correct.  --list-sigs doesn't actually validate the signature.
You can reissue the signature.  Revoke the first via "revsig", and
then issue a new one.
See key 7D53BA6C on the keyserver for an example.
No, this is a standard part of OpenPGP.  It's been around for a while,
but GnuPG 1.3.x is the first time GnuPG supported it.
Not from the perspective of the trust system within GnuPG.  They are
only cosmetic, and used to tell you what the signer was thinking.  For
the trust system, they are all equal.  There is a possibility of doing
more than this in the future (it's a common request), but that hasn't
happened yet.
No.  You'd need to reissue the signature.
Same thing.  You need to reissue.  That's a feature, by the way.  Even
if you could update a signature in-place, there is no way to guarantee
that other people (and especially keyservers) would do the same
in-place update.  You'd end up with two signatures anyway.

@_date: 2002-12-05 23:27:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
This still doesn't stop the doppelganger.  The postmaster attack lets
someone get a signed key in addition to the user's signed key.  Then
there would be two seemingly identical "Alices" on the keyserver.  If
people do notice, how do they pick from between the two?  ("I'm
Spartacus!  No, I'm Spartacus!").
The thing is, I'm not sure this is actually better than nothing.  Like
I said in another email, it is certainly better than nothing if you
can guarantee that everyone in the community uses it (closed
community), but what change does it actually make in the use of
encryption outside of a closed community?  What benefits does it give?
At worst, I can accept that it is harmless (except for that false
sense of security), but if something is harmless and without a real
benefit, why do it at all?

@_date: 2002-12-06 13:53:02
@_author: David Shaw 
@_subject: Policy URLs 
All good advice, but note that:
--cert-policy-url sets a policy URL for key signatures (i.e. certifications)
--sig-policy-url sets a policy URL for data signatures
--set-policy-url sets both.
--cert-notation sets a notation for key signatures
--sig-notation sets a notation for data signatures
--notation-data sets both.

@_date: 2002-12-06 14:00:02
@_author: David Shaw 
@_subject: Policy URLs 
Note that the OpenPGP standard doesn't like people to use any tag name
they like ("info" in the above example).  The standard asks that
people who want to make up their own tags use a tag name like
"info  You can use your email address for example,
but the only important thing is that it has a ' in there somewhere.
1.2.2 enforces this, by the way.

@_date: 2002-12-06 14:19:02
@_author: David Shaw 
@_subject: 2 FAQs 
Well, it's not clear.  Like you say, you end up with two sigs.  If you
later revoke one (or one expires), what should the reading program do?
Does revoking the later effectively revoke the earlier?  Does the
later one expiring effectively expire the earlier?
In GnuPG, the answer is yes in both cases.  However, the OpenPGP
standard is silent on trust issues (it's really a file format
specification).  There may be other implementations with other
choices, so the only way to *guarantee* that you get what you want is
to revoke the old signature before making the new one.

@_date: 2002-12-06 14:28:02
@_author: David Shaw 
@_subject: Policy URLs 
No official tag, so you could make up your own.
"eleuteri+policy perhaps.
However, if you're just making a policy, then use a policy URL.
That's what they are for.
Not yet. ;)
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-12-06 18:35:01
@_author: David Shaw 
@_subject: Policy URLs and Notations on a per-signature basis 
Hi folks,
I got some personal mail asking me how I make the policy URLs that are
different for each key I've signed (see Douglas Calvert's key C9541FB2
for example).
Perhaps the answer is more widely usable, so here's how it works.  If
you mix certain codes into your policy URL string, those codes will be
expanded into useful items:
%k = keyid of the key you are signing
%K = long keyid of the key you are signing
%f = fingerprint of the key you are signing
%s = keyid of the key you are signing with
%S = long keyid of the key you are signing with
These are usable in policy URLs or notations.  Obviously, not all are
usable at all times - %k is only meaningful when making a signature on
a key, etc.
This isn't currently in the manual (sorry, my fault), but will be in
for 1.2.2.

@_date: 2002-12-06 18:52:02
@_author: David Shaw 
@_subject: Policy URLs 
No, they were added in 1.0.7... the manual was out of date. :(

@_date: 2002-12-06 18:57:02
@_author: David Shaw 
@_subject: Policy URLs 
Yes, it was.. at the same time I added --cert-policy-url and
--sig-policy-url. ;)

@_date: 2002-12-07 00:12:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Absolutely, but this applies to the postmaster attack as well.
Remember that it is trivial for her postmaster to get a signed "Alice"
key without Alice's participation or knowledge.  Still, I agree that
this is a genuine example of "better than what we have now".
See "Notation Data" in RFC 2440.  Alice can add a notation to her own
self-signature that indicates whatever she likes.  This is
particularly elegant for people who have more than one user ID on
their key, as they can indicate different preferences for each ID.
If end users aren't meant to think about the question, why make it an
option? ;)  Seriously though, I can see a MUA would be useful with
Granny Mode as well as Expert Mode.

@_date: 2002-12-07 00:18:04
@_author: David Shaw 
@_subject: Policy URLs 
The idea is to prevent collisions in the limited namespace (if I make
a notation name "foo", and so does 10 other people, what happens if my
"foo" doesn't mean the same thing?).  The answer is to write
foo which if I am the owner of example.com, means that
it's MY "foo" and not anybody elses.  The note about email address is
just a side benefit - since the tag name is "foo it
becomes an email address and that address could be pointed towards
someone who can be consulted about the use of the tag.
I'd use a modified email address.  For user I'd do
something like "user+tagname  That guarantees that it's
a unique tag name and also lets the user have more than one.
Still, if a tag is useful enough, I'd submit it to the IETF for
standardization so everyone can benefit.

@_date: 2002-12-07 01:05:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
That's cheating a little bit - you're promoting this to make crypto
simpler for Granny.  Granny won't know what on earth it means to have
multiple signed keys.  Plus, it's going to be a VERY common case to
have multiple signed keys by the robot.  It happens every day that
someone makes a key, sends it to the keyserver, and then forgets the
passphrase so they have to make a new one.  Some people have 4-5 dead
keys on the keyservers that they can't get rid of.
One answer to that is for the robot to track email addresses and only
sign a new key for an old email address after it first revokes the sig
on the old key, or even for Granny to use the most recently signed
key... but both of those open things up to a postmaster attack again.
It's easy to just declare that any key that isn't email validated is
outside of the community, but so long as this is a
community-within-a-community, you do have to deal with the case of
someone inside the community trying to encrypt to someone outside of
the community.
This means problems at the boundaries:
Granny wants to encrypt to Alice.  Granny's MUA fetches all "Alice"
keys from the keyserver.
1) If Granny has a strong trust path to an Alice key, use that key. I
   think everyone can agree on that.
2) If Alice has an email validation, use the key.  Remember that there
   may be more than one validated key - what to do?  Send to all?
   Send unencrypted?
3) If Alice has nothing, what to do?  By definition, we can't prompt
   Granny for help.  Send unencrypted as if Alice had no key?
No, not exactly.  I'm just thinking along the same lines as you to
make use of crypto simpler, and encrypt-to-all-keys is something that
could be easily implemented in a MUA.  What I do personally is harder
to automate in code:
1) If there is a strong trust path, use the key.  This is fairly easy
   for me since my key (99242560) is very well connected.  It is very
   unusual to find a key with more than a couple of signatures that
   I'm not connected to via some path (strong set).
2) If that fails, check the key - is it the key that the person has
   been signing with for months?  Is it in their headers for the same
   period of time?  If so, use it.  Not proof against a MITM attack,
   but they've added evidence that the entity that I have been
   communicating with uses that key.  There is a nice tool called
   "keystory" ( that simplifies this.
3) If that fails, and there is only one key available, use it.
4) If that fails, and there are multiple keys available, use either
   all or the most recent.  If more than one key is used, include a
   note in the message saying something along the lines of "Hey, I
   sent this to multiple keys..."
Given the people I communicate with, I rarely have to go past step 2
in practice.
I do see your point that a new user has to start at step 2 or more
often 3.

@_date: 2002-12-07 14:10:02
@_author: David Shaw 
@_subject: Initial Installation Problem 
Interesting.  All three machines are identical HP-UX OS 11.11 boxes?
Same compiler, etc?  What happens if you copy the 'gpg' binary from
the good machine to the problem machines?

@_date: 2002-12-07 14:19:02
@_author: David Shaw 
@_subject: newbie problems 
PGP always encrypts without MDC, though it can understand
MDC-protected messages generated elsewhere.

@_date: 2002-12-07 20:52:02
@_author: David Shaw 
@_subject: AW: Robot CA at toehold.com 
My experience is different here - I was thinking a 1-year expiration
was reasonable.  Seems to me that nearly everyone I know I always
mailing me with "I got a new email address".
There is also a simpler reason - anyone who runs any sort of Internet
service (mailing lists, etc.)  knows the problem of people who manage
to get themselves signed up for things without the faintest clue about
how to get un-signed up.  Expiring sooner rather than later lets
people get out of the system painlessly.

@_date: 2002-12-08 06:44:02
@_author: David Shaw 
@_subject: newbie problems 
Well.. no, not really.  The chosen ciphertext attack that MDC foils is
a really difficult attack to implement, and it involves the
(presumably unwitting) assistance of the message recipient (i.e. you).
In general, signing the message gives you similar protection.
MDCs as used in OpenPGP have some controversy around them.  Some
people are calling for their removal from the standard, and
replacement with a different design.

@_date: 2002-12-08 06:56:01
@_author: David Shaw 
@_subject: setting owner trust 
Yep.  Do this: "gpg --edit-key 0xXXXXXXXX trust quit" Then enter the
trust you want, and you're done (two steps).

@_date: 2002-12-08 13:03:02
@_author: David Shaw 
@_subject: AW: Robot CA at toehold.com 
Well, it almost doesn't matter.  This detail isn't really so much a
matter of security as a matter of sanity.  Remember that every time
you sign a key, you add a new signature packet - and the old one stays
around as well.  If you are signing (and then re-signing) a key every
3 months, pretty soon the key will be huge and covered in your
The numbers you were looking for, by the way, are 31% of all email
addresses get changed every year:
I suspect you will find that your "repeat business" drops off
dramatically unless a mail client is going to automate this
every-3-months stuff.

@_date: 2002-12-08 13:22:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
It's worse actually, since multiple signed keys isn't even really an
exception.  I can point to dozens of people who have multiple keys
with the same email address for "non-error" reasons:
1) People who have a "main key" (presumably offline) and a "laptop
   key"
2) People who keep around a PGP 2.6.x key as well as an OpenPGP key.
It is interesting to me that this design discourages encrypted
communication between Granny and OpenPGP-savvy users (who are far more
likely to have multiple keys than the average population).
Which raises an interesting question.  Should people (real people, not
other robots) sign the robot's key.  I strongly feel the best answer
here is "no".  There is no need to - the robot is a CA and has that
authority with or without such signatures.  Signing a robot key also
encourages people who don't need to use this system to use it anyway
because it hooks them into the web of trust via a weakly-checked back
If a robot CA must be done, and I do see some limited benefits to it,
it must not become a free pass into the web of trust strong set.  That
hurts all of the users of OpenPGP.

@_date: 2002-12-08 19:28:13
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
By signing the CA key, you are asserting that you believe for whatever
reason that the key in question really belongs to the CA.  Trust is a
different issue.  It is possible to trust a CA without making the
public assertion about the CA key identity.
How do you assert the identity of something (nearly) unverifiable?  In
the Robot CA case, Kyle can, certainly, but how does someone else?
It's an interesting case of the "nonhuman key" problem.  For example,
the key that signs many software distributions is created just for the
purpose of signing software.  This case is even more interesting since
the CA may sign other keys and influence the web of trust.

@_date: 2002-12-08 19:33:02
@_author: David Shaw 
@_subject: DBG messages in release and some bugs(?) 
This is not possible with the current pksd keyserver.  It does not
return error messages in a machine-usable way.
Yes, 1.3.x does this.
Openkeyserver is broken and won't work reliably with GnuPG.  I once
spent a while trying to work around their bugs by adding special code
to GnuPG, but finally realized that this was the wrong direction to go
in.  I've reported the bug to them a few times.  I'm not even sure
that Openkeyserver is still maintained since I heard nothing back.

@_date: 2002-12-08 20:41:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Content-Description: signed data
They don't exist.  You are also correct that there is no way to
prevent this from happening.  The best we can hope for is for people
to not sign such keys, or perhaps for the documentation for a robot to
indicate the problem and ask people not to sign the key.
If someone was against such signatures enough, they could even use
this as a test to see if they trust people to make good signatures.
Someone's signature on a robot key would be a hint they don't check
well.  This isn't completely fair, of course, since someone could make
a persona signature which is supposed to be for this sort of
situation.  Unfortunately, no implementation yet allows people to
ignore persona signatures.  It's unlikely that PGP will ever add such
a feature, so we can easily end up with two different views of the web
of trust.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-12-08 20:44:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Well, what is a CA?  A CA is (supposedly) an Authority.  It does not
need mere users to sign it to give it more authority as it is absolute
by design.  If someone wants to use the CA top-down trust model, they
can directly do so.  Having a CA be a part of the web of trust is sort
of blending two different trust models.  It's not necessarily bad or
good, but I suppose everyone needs to decide for themselves where the
line is drawn.

@_date: 2002-12-08 21:32:02
@_author: David Shaw 
@_subject: AW: Robot CA at toehold.com 
We're worried about everything. ;)  A good number of possible attacks
and operational issues simply disappear if the policy is to retain all

@_date: 2002-12-08 21:35:02
@_author: David Shaw 
@_subject: DBG messages in release and some bugs(?) 
Yes and no.  --search-keys returns to the user whatever the keyserver
provides.  No current keyserver provides fingerprints, though the LDAP
servers at least provide long keyids.

@_date: 2002-12-08 23:21:02
@_author: David Shaw 
@_subject: DBG messages in release and some bugs(?) 
Yes, but it's not part of the new machine-readable indexing feature in
the latest pksd.  I'm extremely reluctant to do even more fragile
parsing of HTML in GnuPG.  It's prone to failure enough already.

@_date: 2002-12-08 23:32:03
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
You see, here I disagree with you.  The system you are trying to put
into place does not in any way depend on other people signing the
robot's key.
Any person who wants to use the robot's signatures must download the
robot's key and assign it (local) trust.  Signatures on the robot's
key are meaningless in this configuration.
However, having random people sign the robot's key - which allows
people to gain trust *through* the robot does nothing but harm the web
of trust for no real benefit.  Since the robot works perfectly well
without collecting signatures on its own key, those signatures should
be discouraged.
It is not an issue of trusting certain types of signatures.  If
someone wants to trust the robot and use its signatures, they can.
Signing the robot's key gives it more power than intended, and does
impact the web of trust exactly as if someone just signed every key
that came along.  Why harm the web of trust, especially since your
plan works equally well without harming it?

@_date: 2002-12-08 23:45:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Keep in mind that no OpenPGP programs except very recent version of
GnuPG can even express weak signatures - and even GnuPG treats them as
cosmetic and does not interpret them differently.  Think about that
for a second: no PGP user can even see what you are doing.
No.  Getting more people in it in a strong manner makes it more
valuable.  Adding weak signatures to it hurts it for everyone.  You
don't need to add weak signatures to the web of trust for your robot
to work.
Your robot should not be part of the web of trust at all.  It is a
(weak) CA.  A CA is a different trust model than the web of trust.  By
mixing the two, you hurt the web of trust without helping the CA model
at all.
"a little chaos in the meantime?"  Wow, that's just what's needed to
get more people to adopt crypto.  You know, for something that is
intended to make things simpler for Granny, we're now redesigning
trust models, modifying the keyanalyze reports, toying with massive
new infrastructure... maybe I missed it - when did things get simpler?
The goals and requirements for this thing should be just a little more
understood before we start redesigning a system that has worked quite
well for over 10 years and millions of messages.

@_date: 2002-12-08 23:50:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Keep in mind that despite you tagging the signature as persona, no
OpenPGP programs treats it any differently.  You're making a strong
binding there, and calling it weak doesn't make it weak.  People
depend on you as a member of the web of trust to not do this.

@_date: 2002-12-09 01:01:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Don't forget PGP.  You're making signatures that act incorrectly for
exactly 100% of the user base of OpenPGP.  Are you sure you want to do
Even if we could wave a magic wand and suddenly upgrade every other
piece of software, PGP doesn't handle multiple signature levels and
most likely will never handle them.
Anyway, you know all this.  It is one of the nice things about OpenPGP
that everyone gets to decide for themselves what they trust.  In my
opinion, a key that issues weak signatures is a key that doesn't get
trust.  Of course, that's just me.

@_date: 2002-12-09 03:10:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Quite right, but only on paper.  Unfortunately, people treat the web
of trust as gospel.  Many Alices would treat David's key as trusted
because there is A path, rather than because there is a GOOD path.
This is nonsense of course, but pervasive nonsense.  I don't believe
in catering to nonsense in general, but I do keep it in mind.
Let me turn the question around and ask "what benefit is derived by
someone other than the robot operator signing the robot key?"
The problem here is not the lack of fine control over trust in GnuPG.
The problem is the lack of fine control in *all* OpenPGP clients.
Even if/when I add the code to do this in GnuPG, it doesn't address
PGP... if you follow the logic available to a PGP user who can't
discriminate between signature types, discarding that weak 0x11
signature also means that he can't trust Jason's key at all.  That's
unfortunate, so I pointed it out.  If Jason wants to do it anyway,
hey, it's his key and his reputation.  OpenPGP puts all trust control
in the hands of the end user, so it's certainly not up to me whether
his key should be trusted or not by anyone other than myself.
I was the person who added signature types to GnuPG back in 1.0.7.  My
intent at the time was to do a few releases with them as they stand
now to get more typed signatures out in the wild, and then add the
sort of functionality that you describe.  Since then, I've had more
than a few moments wondering whether this is a bad idea.  The factors
are, as always, usability and PGP.  The usability factor says don't
make using GnuPG more complex which will chase people away.  The PGP
factor realizes that PGP is never, ever, going to support this (I'd be
thrilled to be shown wrong, but I'm not holding my breath).  Combine
the two and it comes up as a cool feature that will alienate and harm
more than it benefits.  So a few people get to do a neat trust trick
that they couldn't do before... at the cost of how many people who
don't start using GnuPG at all because there is yet one more
comphrehension barrier to adopting it.  The web of trust is difficult
enough for the beginner to understand already.
All that said, I still plan on doing this some time in 1.3.x, but
it'll be something only the "power user" will ever see.  I'm halfway
regretting having non-power users see the signature levels at all, but
that's done with already.
Actually, neither do I.  While I think that people should show some
restraint in issuing persona signatures, I think that once they are
issued they should certainly show up in the keyanalyze reports.
They're a genuine part of the web of trust even if I personally don't
like it, so why hide them?
Keyanalyze gets it output from GnuPG, if I recall.  GnuPG shows
invalid signatures - does keyanalyze ignore this information?
In any event, I don't really follow your logic here - because the
system is already vulnerable to subversion we don't have to care about
putting poor data in?  Surely not.
There are in fact several places where GnuPG design is influenced to
be compatible with PGP, and places where the PGP design is influenced
to be compatible with GnuPG (this wasn't always true, but the new PGP
company has been quite good at fixing interoperability problems
reported to them) This is true even in places where the OpenPGP
standard doesn't dictate behavior either way.  We all have to work
together, or what is the point of standards in the first place?

@_date: 2002-12-10 03:36:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Using the web of trust is actually a pretty ineffective way to verify
the robot key.  Remember that (by default) the web of trust is 4
levels deep.  That means they'd have to trust you, trust someone who
trusts you, or trust someone who trusts that person.  Anything further
than this and the robot key is useless.
Having people trust the robot key explicitly means a:
 trusted-key (robot key)
in their config file.  Very explicit, very much opt-in, and no
question about accidentally trusting something that was not intended.
Since this system was promoted as part of a special setup for Granny,
that special setup can trivially include this configuration.  It
doesn't help Granny to involve the web of trust at all.
Believe it or not, I agree with this.  You are running the robot, if
there is anyone out there who knows the robot key, it's you.  This is
just another example of the general non-human-key problem like company
key signers, software signing keys, etc.
But it does mean that people who are driving along with them should be
careful ;)

@_date: 2002-12-10 03:43:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
"poor data" being the weak signatures in the first place, not the
source of the signatures.  I understand (and mostly agree) with the
statement that there is a need for weak signatures, and GnuPG should
provide some mechanism for dealing with that.  If/when that feature is
added, then there will be a way to specify such relationships.
But - we live in a wider world, and GnuPG is only one of several
OpenPGP implementations.  People who use this feature will have to
understand that the signature will more often than not, NOT mean what
they think it means.  PGP will treat this signature as strong, as will
all earlier versions of GnuPG, as will any of the other OpenPGP
implementations out there.
A "power user" feature, sure, but I wish I had a way to wave bright
red flags in someone's face before they do this to make sure they
understand that it almost certainly isn't going to do what they think
it will.

@_date: 2002-12-10 03:45:01
@_author: David Shaw 
@_subject: setting owner trust 
gpg --export-ownertrust
The first field is the fingerprint of the key.  The second field is
the trust value, where 2 is undefined, 3 is never, 4 is marginal, 5 is
full, and 6 is ultimate.

@_date: 2002-12-10 03:49:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
I agree with this.
But not this.  Just because the web of trust isn't perfect, it does
not follow that adding weak data to it is okay.  Why not add more
strong data and make it better?

@_date: 2002-12-10 03:52:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Yes, this would be nice.  Unfortunately, the GnuPG trustdb isn't
really calculated in a way to make this type of output possible.  It's
not impossible, but it would be a fairly large change (and the trustdb
would have to become much larger than it is now).
Maybe something optional.  It's on my "think about ways to do this"
list, anyway.

@_date: 2002-12-10 03:53:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Ah, I misremembered.  pgpring does not check signatures.  I imagine
it's a lot faster than GnuPG for that reason.

@_date: 2002-12-10 04:00:01
@_author: David Shaw 
@_subject: trust calculations (was Re: Robot CA at toehold.com) 
This sounds neat in theory, but that would mean a massively
complicated trust system.  How many people would seriously use it
(actually enter in stuff like "for user X, if they make a 0x11 that
means this, and a 0x12 means that, but a 0x12 on a photo ID means this
other thing... except for that one signature on key Y, which
It's just not possible in a sane system to give a different arbitrary
trust level to arbitrary signatures.
However, if you seriously want to do this, GnuPG 1.3.x will have
(soon) a "direct" trust model where you can set the validity of any
key directly and GnuPG will use it.  With that trust model you can
write any program or script to spit out a complete trustdb that makes
you happy and GnuPG will follow it.

@_date: 2002-12-10 04:08:02
@_author: David Shaw 
@_subject: trust 
No harm, but no benefit either.  The trust value will be ignored on an
invalid key.
ly. I
 at
I think what you are looking for is a local signature ("lsign" in the
--edit-key menu, or --lsign-key on the command line).  This is a
signature just like any other signature except that it is local to
your keyring only.  Use lsign instead of sign and you solve the exact
problem you describe.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-12-10 05:25:02
@_author: David Shaw 
@_subject: warning msg - what does it mean 
Well, no.  "Securely" in this case means that the user that owns the
keyring is the only one that can write to it.  If you want to have a
keyring that multiple users can write to, then it isn't secure by that
If you put the keyring in any directory other than the home directory,
GnuPG won't do the permissions check.  You can also disable the
permissions check with --no-permission-warning.

@_date: 2002-12-10 14:32:02
@_author: David Shaw 
@_subject: Despite "no-include-revoked" revoked still included 
no-include-revoked and no-include-disabled only apply to
--search-keys.  This is for various security reasons, most notably if
you are doing automated key fetches (say, to verify the validity of a
possibly revoked key), you want the key even if it is disabled or

@_date: 2002-12-10 15:18:02
@_author: David Shaw 
@_subject: trust 
This is all true, but there is an easier way to handle it.  Just use
"gpg --update-trustdb".  GnuPG will build all possible trust paths,
and prompt you for any key that needs to have ownertrust set.  In the
example above, as soon as you signed Josh Huber's key,
--update-trustdb would see that and ask you to assign ownertrust to
Werner's key.

@_date: 2002-12-10 16:02:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
I would hope that Alice the Programmer would take a lot more care than
a link in the web of trust before installing the robot key as a CA in
Granny's software.  The web of trust is good, but it's not nearly
(IMO) good enough to justify installing a new axiomatically trusted CA
on countless copies of a new email client!
The web of trust is a pretty good "just in time" calculation, but for
something like a CA, I'd hope that Alice would contact you directly,
and work out something more airtight.

@_date: 2002-12-10 16:03:03
@_author: David Shaw 
@_subject: Third party information (was: Semi-automated trust, policy) 
For what it's worth, the same exact thing happened to me, and I also
declined to sign the key in question.

@_date: 2002-12-10 17:51:02
@_author: David Shaw 
@_subject: warning msg - what does it mean 
Sure, but you want to make sure that the public key it reads is not
one what some other process just slipped in there.  That is what the
homedir permission check helps ensure.

@_date: 2002-12-10 18:13:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
This is not necessarily true - I wrote a robot which has the same
general concept as the other robots, but does no signing online.  I
wasn't satisfied with including a key on a internet-connected machine,
so the robot code just handles the grunt work and then passes me a
list of keys to sign offline.  That robot, incidentally, is not
I totally agree about storing the key online though.  It would be a
real mess if a CA secret key was stolen.
I think we want the same thing, but are going about it differently.  I
want robots and scripts kept out of the web of trust... but if they do
leak in there, I don't want them excluded from the various web mapping
programs.  By that point, the damage is done and they are for better
or for worse part of the web.  Of course, it could be argued that this
would encourage people to sign robot keys, so perhaps it is indeed
better to leave them out.  I don't like that as the mappers will then
show a different web of trust than the real world will.

@_date: 2002-12-10 18:52:02
@_author: David Shaw 
@_subject: Despite "no-include-revoked" revoked still included 
Yes, you are right - that is confusing.  I'll fix the manual.
This involves keeping the actual data around and just hiding it from
the user which GnuPG already does (in some places anyway).  That's why
a revoked user ID doesn't show up in --list-keys.  The same idea could
be used to hide revoked subkeys, etc.

@_date: 2002-12-10 18:55:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Not a valid attack, because it's not an automated process.  I am
personally the part of the process that signs the keys and I double
check. ;)
Incidentally, what do you plan to do if/when your robot key gets
compromised?  There are a lot of "Granny"s that will need their
configurations updated.

@_date: 2002-12-10 18:59:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Yes, this would be nice for this purpose, but as you say, it would
break compatibility with other OpenPGP applications.  Nothing in the
standard says you can't have a key signing subkey, but at the same
time nothing in the standard says you have to.  In practice, no
program does.
You can implement almost the same thing by having the robot operator
make a master robot key, which is kept secure, and then signing the
robot key with the master robot key.

@_date: 2002-12-10 20:33:01
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
The part about robots being inherently insecure because they keep
their keys online.  The robot I wrote didn't do so, and used a human
being to do the actual signing.  I guess you could argue that
something that involves a human isn't really a robot.
I sort of agree with you, but those signatures are, like it or not,
part of the web of trust at that point.  They may be weak and
unfortunate additions, but there are present.  More practically, who
makes the decision what gets included or not?  One person's exclusion
list is bound to be different than another.  This loops back to the
discussion about having GnuPG print out a user-customized web of trust
that takes into account local signatures and trust values.  With a
publically available web of trust appilication (pathfinder, etc.) the
link is there, so I think it should be shown.  Of course, that's me.
If there was a computationally feasable way to exclude certain keys on
a dynamic basis, then I have no objections to that of course.  I
suspect that it would be possible or even easy for pathfinders to do
this dynamically, but very difficult for things like the keyanalyze
report to do this dynamically.

@_date: 2002-12-10 21:17:02
@_author: David Shaw 
@_subject: Despite "no-include-revoked" revoked still included 
I see what you mean, but there are some odd corner cases there - for
example, lets say that a user had a signing subkey, used it for a year
and then revoked it and made another.  Should this subkey be deleted?
If it is you can't verify any of the signatures issued during that
What I was suggesting (and perhaps did not explain well) is a feature
for GnuPG where it simply never shows you revoked subkeys, revoked
user IDs, etc. during a --list-keys.  They may be there, but you won't
see them so the effective result is the same as if they were deleted.
GnuPG already does this for user IDs.  It would just mean extending
the same idea for other objects.

@_date: 2002-12-11 03:24:01
@_author: David Shaw 
@_subject: GPG support in Mahogany 
Content-Description: signed data
Oh no, don't do that.  Even if PGP/MIME is better in every single
detail than plain inline messages, there is one crucial factor: plain
inline messages are supported in every mail client back to (and
including) /bin/mail.  Even this many years after its creation,
PGP/MIME is still only supported in a very few clients.
Inline can be trivially scripted ("gpg --clearsign ... | mail"), and
PGP/MIME can't.  Inline doesn't blow up when run through an archiver,
and PGP/MIME usually does.  Even mutt, which for years was PGP/MIME
only finally got inline support as well.  I don't see that as a step
Perhaps the whole world will be PGP/MIME someday, and I'm sure that
will be wonderful as PGP/MIME handles many important things that
inline can't (like non US-ASCII character sets), but it's not time to
stop supporting inline yet.
Some discussion on this topic:
     David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-12-11 04:10:07
@_author: David Shaw 
@_subject: Despite "no-include-revoked" revoked still included 
Ah, I see.  This is one of those things where it's actually not all
that hard to do... but really hard to make interactive in a sane and
usable way.  I'll put it on my "think about this some more" list.

@_date: 2002-12-11 13:54:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Not negative, just zero.  It can't be negative, or signatures by this
key will cause otherwise trusted keys (from good paths) to be
untrusted.  Better to make the untrusted key have no effect at all.
"Don't know", "Don't trust", and unset are all treated as zero trust.

@_date: 2002-12-11 14:07:02
@_author: David Shaw 
@_subject: A bug in version 1.2.1? 
It is okay so long as the user signs the key locally ("lsign").  This
is one of the things lsign is for.  It does not affect any other user
since the signature is local.
This is much better of course.

@_date: 2002-12-11 15:56:01
@_author: David Shaw 
@_subject: A bug in version 1.2.1? 
I'm afraid that users will do 'sign' instead of 'lsign' by
accident. :)

@_date: 2002-12-11 15:59:01
@_author: David Shaw 
@_subject: signing emails 
They are both correct.  RFC-1991 and 2440 define the inline format.
RFC-3156 defines the PGP/MIME format.
There is some substantial disagreement on which is the right one to
use in various cases.  In general, PGP/MIME handles many things that
inline does not, but inline is much easier to support and has less
interoperability problems.

@_date: 2002-12-11 18:13:02
@_author: David Shaw 
@_subject: A bug in version 1.2.1? 
That's fine so long as it doesn't make users sign keys willy-nilly to
"make them work".  That's what lsign is for, but I have little hope
that many users even know what lsign is.

@_date: 2002-12-11 18:42:02
@_author: David Shaw 
@_subject: recipient preferences 
AES256 == S9
AES192 == S8
AES    == S7
You'll have no preferences, which means the cipher 3DES, the hash
SHA1, and the compressions ZIP or uncompressed.

@_date: 2002-12-11 20:17:02
@_author: David Shaw 
@_subject: recipient preferences 
Leave off the [mdc].  It's always on unless you specifically turn it
off with no-mdc.

@_date: 2002-12-11 21:54:01
@_author: David Shaw 
@_subject: signing emails 
PGP/MIME is *an* official standard (well, standards track anyway).
Inline messages are also standards track.  Neither one is any more
official than the other.

@_date: 2002-12-12 03:41:02
@_author: David Shaw 
@_subject: GPG support in Mahogany 
Content-Description: signed data
Agreed, but pushing PGP/MIME should not mean dropping support for
Agreed, but this has not happened yet.  It's not PGP/MIME's fault, but
it's an example of something that PGP/MIME makes worse.
Hmm.  I thought I had heard there was a problem with clearsigning... I
don't have much experience with this problem since I pretty much use
US-ASCII all the time.
I agree with all of this (I use a PGP/MIME capable client myself, and
would probably use something else if mutt wasn't PGP/MIME capable),
but I don't think that the world is ready to switch over to
exclusively PGP/MIME any time soon.  In the interim - and that interim
may be long - mail clients really need to support both PGP/MIME and
I'm sure it would hasten PGP/MIME adoption if all inline would
disappear tomorrow, but what is good for adoption of PGP/MIME may be
very bad for adoption of encryption in general.  "The perfect is the
enemy of the good".
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-12-12 13:37:01
@_author: David Shaw 
@_subject: --check-sigs 
The ones that show up as 'sig-' instead of 'sig!' in the listing.

@_date: 2002-12-13 21:19:02
@_author: David Shaw 
@_subject: bad signature on clear signing 
You should be able to mangle whitespace at the end of lines in clear
signatures.  Part of the spec specifically requires that end of line
white space is ignored when making the signature hash (for the exact
reason you mention, if I recall correctly).

@_date: 2002-12-14 17:10:02
@_author: David Shaw 
@_subject: Robot CA at toehold.com 
Even then, zero is better than negative.  Otherwise there is an attack
where Mallory makes a key, and starts making bad signatures on bogus
IDs.  Once everyone marks the key with negative trust, Mallory signs
some genuine keys with this "poisoned" key.

@_date: 2002-12-15 00:19:02
@_author: David Shaw 
@_subject: Comment option questions 
Such as?
No.  Each comment must be on a single line, but there is nothing in
the standard that says how long a "line" is.  There is also nothing in
the standard that says you can't have multiple Comment headers.  Note
that doesn't mean that any given implementation will allow it - just
that the standard is silent on the subject.
RFC-2440.

@_date: 2002-12-18 15:46:01
@_author: David Shaw 
@_subject: Most appropriate / usefuls / synchronizing keyservers ? 
As things stand now, this is really the only keyserver I recommend
anyone using unless there is a specific reason to use another (photo
IDs).  Jason Harris has most of the pksd bugs fixed, including the v4
RSA keyid bug and the serious subkey corruption bug.  This server also
synchronizes well with the other servers.

@_date: 2002-12-19 05:07:02
@_author: David Shaw 
@_subject: disabled keys: bug or misunderstanding (GPG 1.2.1) 
Yes, this is a problem.  It will be fixed in GnuPG 1.2.2.

@_date: 2002-12-19 05:07:10
@_author: David Shaw 
@_subject: simultaneous symmetric and public key encryption ? 
The spec supports this in theory, but GnuPG (or PGP, for that matter)
does not yet.
The encryption is just as secure as it always is, but there is still a
security implication of doing this as it is easier to attack the
message because all you need to do is guess passphrases.  Attacking
the message with public key cryptography requires that the attacker
somehow steal your secret key *and* guess the passphrase.

@_date: 2002-12-19 16:11:01
@_author: David Shaw 
@_subject: Automatic check of key revocation 
Use 'gpg --refresh '.  If the key is revoked on the server, the
key will then be revoked on your local keyring.

@_date: 2002-12-19 18:44:02
@_author: David Shaw 
@_subject: simultaneous symmetric and public key encryption ? 
Not really.  Modern ciphers are pretty resistant to chosen plaintext
b and especially c, do not follow a.

@_date: 2002-12-19 19:04:02
@_author: David Shaw 
@_subject: signing emails 
RFC-1991, and updated in RFC-2440.
Remember that application/pgp does not mean inline, and inline does
not mean application/pgp.  application/pgp isn't a standard.

@_date: 2002-12-19 19:04:18
@_author: David Shaw 
@_subject: Automatic check of key revocation 
Automatic as in "check for a revocation every time a key is used"?
GnuPG can't currently do this, but it's a reasonable wishlist item.
It'll only be really usable for cases like yours where you have your
own keyserver.  It'll be brutally slow otherwise.

@_date: 2002-12-19 19:04:32
@_author: David Shaw 
@_subject: Automatic check of key revocation 
You can also do 'gpg --refresh-keys localdomain' to refresh only keys
that match localdomain.

@_date: 2002-12-19 19:04:47
@_author: David Shaw 
@_subject: simultaneous symmetric and public key encryption ? 
It doesn't work that way when mixing symmetric and public-key
encryption.  The passphrase+s2k+hash is used to decrypt the existing
session key, and is not the session key itself.
In general, this comes down to the "how secure is your passphrase"
question.  Alice has the same ability as any random person in deriving
Bob's passphrase.

@_date: 2002-12-27 18:09:02
@_author: David Shaw 
@_subject: --check-sigs option 
This is a known side-effect of the signature caching that GnuPG uses
to speed up some operations.  In the example above, you imported key
2C6D110A before importing key 09AC0A6A, then deleted key 2C6D110A.
Basically, it's harmless.  If it really bothers you, you can make it
go away with (this will take a while to run):
 gpg --no-sig-cache --rebuild-keydb-caches

@_date: 2002-12-27 23:17:02
@_author: David Shaw 
@_subject: rpm upgrade 
In short, yes.  There are a number of bug fixes and enhancements
between 1.0.6 and 1.2.1.  You will also have problems upgrading to a
newer GPA without upgrading your GnuPG as well.
1.0.3 should not be used at all: look up the release of 1.0.4 in

@_date: 2002-02-07 18:47:02
@_author: David Shaw 
@_subject: Check a file? 
You can get the signatures with "gpg -v the_key_file".
Getting the trust levels is more difficult as they need to be
calculated over your public keyring.  You need to import the key to do

@_date: 2002-02-07 19:12:01
@_author: David Shaw 
@_subject: File Size 
You got it.  GnuPG compresses the input before encrypting it, so even
though the processing adds some data, the resulting file is usually a
bit smaller than the original.
You can tweak the compression details with the --compress-algo and -z

@_date: 2002-02-07 20:19:02
@_author: David Shaw 
@_subject: update info 
I'm afraid you're out of luck.  The keyservers cannot delete UIDs -
they can only add.  What you can do is issue a revocation for the UID,
which marks it as unusable.  You can do this in the --edit menu by
using "revsig" to revoke your own signature on the UID.
This should really be in the FAQ.  It gets asked all the time.

@_date: 2002-02-12 07:20:02
@_author: David Shaw 
@_subject: GnuPG has trouble decrypting multi-key messages? 
It is not true that a message encrypted with an ELG-E key
automatically won't need IDEA.  In fact, the symmetric cipher for a
given message is mostly unrelated to the algorithms for the public
keys used to encrypt.
When a message is encrypted, it is encrypted using some symmetric
cipher (of which IDEA is one of several possibilities) using a
randomly generated session key.  Then, the session key is encrypted
using the various public keys of the receipients of the message.
If the message you received used IDEA as the symmetric cipher, then
you will need the IDEA plugin regardless of what algorithm the public
keys it is encrypted to uses.

@_date: 2002-02-13 21:48:02
@_author: David Shaw 
@_subject: HOWTO Revoke a key without having any backup of the key pair ???? 
Yes indeed.
There is a feature in the OpenPGP spec for this called a revocation
key (PGP calls it "designated revoker").  It works by having the key
owner designate a key that is permitted to issue revocations for the
key owner's key.
It presumes you *really* trust that person :)
I actually started implementing this for GnuPG, but work intervened.
It's about halfway done (it can accept and handle revocations, but it
can't yet add a designated revoker to a key, or issue revocations).
If there is interest, I'll see if I can find some time to finish it

@_date: 2002-02-18 18:18:02
@_author: David Shaw 
@_subject: AW: gpg certificate authorities 
Yes, but at the same time, this is also one of the main advantages to
OpenPGP - that it does not require the user to trust a CA to function
properly ;)

@_date: 2002-02-20 17:25:02
@_author: David Shaw 
@_subject: Getting a key from a keyserver.. 
You can in the upcoming gpg 1.0.7 with gpg --search-keys.  You can
search for a name, email address, or any text in the user ID.
Of course, that only gives you a key with that text on it.  You still
need to confirm it is the right key via the usual methods (signatures,
checking fingerprint, etc.).
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-02-21 18:06:01
@_author: David Shaw 
@_subject: trust values and trusted keys 
gpg --with-colons --list-keys
The second field and the ninth field are the ones you want.  The
second field contains the validity, and the ninth field contains the
trust setting.  See doc/DETAILS from the GnuPG distribution for all
the possible values there.
gpg --update-trustdb
Note this is a new 1.0.7 feature (not released yet), and is not
available in 1.0.6.

@_date: 2002-02-21 20:19:02
@_author: David Shaw 
@_subject: trust values and trusted keys 
Yes.  A --show-trust or something like that would be nice.  You can
always see the trust in the --edit  menu, but that's a
one-key-at-a-time thing.
In 1.0.6, it just forces an update of the trust DB.  In 1.0.7 it
updates the trust DB and also prompts you for any key that is
valid/trusted, but does not yet have owner trust set.

@_date: 2002-02-22 16:16:01
@_author: David Shaw 
@_subject: GnuPG with virtual servers 
Clearly there is no danger to you - after all, it's your *public* key.
No harm there.
Offhand, it sounds like the administrator is worried that someone may
abuse the trusted status of your key - say, if they can inject a key
signed by yours into the keyring, then the injected key could gain
trust.  This is true, but it is also true that anybody who manages to
get access to the machine to add a key to it could do pretty much
anything they wanted to do anyway.
Could you post exactly what you were asking the administrator to do?
I don't see any real risks here, but perhaps I do not fully understand
his concerns.

@_date: 2002-02-22 21:43:02
@_author: David Shaw 
@_subject: reasons for needing --allow-secret-key-import? 
In GnuPG 1.0.6, you can set the trust of a public key to whatever you
like, but if you have the secret key as well, that trust jumps to
"ultimate".  (The assumption is that if you own the secret key, the
key is you.)  Thus the need for the --allow-secret-key-import option
to prevent the bad guys from sending you a secret key which can alter
trust on your keyring.  There is no problem because you cannot import
a secret key without setting the option first.
In 1.0.7, secret keys do not confer any automatic trust, so the
--allow-secret-key-import option is obsolete.

@_date: 2002-02-23 03:29:01
@_author: David Shaw 
@_subject: Serpent Support 
To do this, Serpent must first be added to the OpenPGP spec.  It does
little good to add it to GnuPG if other OpenPGP compatible programs
can't use it as well.
Hmm.  Try adding the "--openpgp" option as well.  I suspect MDC
See section 3.7 of RFC2440:
   String-to-key (S2K) specifiers are used to convert passphrase
   strings into symmetric-key encryption/decryption keys.
It gives lots of detail exactly how this works.

@_date: 2002-02-26 01:27:01
@_author: David Shaw 
@_subject: How to keep signature on received messages after decrypting them 
Sorry, GPG doesn't currently have this feature.  There is nothing
preventing it, but it hasn't been written.

@_date: 2002-02-27 00:03:01
@_author: David Shaw 
@_subject: subkeys 
[ ... ]
Use "gpg --edit ", select the subkey ("key X"), and use the
"revkey" command.

@_date: 2002-02-27 14:59:01
@_author: David Shaw 
@_subject: gpg bug or keyserver bug 
Keyserver bug.  The HKP keyservers do not understand multiple subkeys
(the NAI and CKS ones do).  Basically, the keyserver does not
understand multiple subkeys so it sort of mangles them.
There isn't much you can do, I'm afraid.  Hopefully the new keyserver
software coming out in a few months (which does not have this bug)
will make the situation better.

@_date: 2002-02-27 17:45:01
@_author: David Shaw 
@_subject: implications of subkeys? 
The minimal OpenPGP "key" is made up of one key, called the "master"
or "primary", plus a user ID.  You can add more user IDs, if you like,
and many people do.  The user IDs "belong" to your key, and are bound
there by a self-signature from the primary key.
Now, just take that same idea and replace "user IDs" with "keys" and
you've got subkeys.  You can add any number of keys to the pile, and
to prove that they belong there, they are bound in place by a
self-signature from the primary key.
The only difference between the two concepts is that other people can
add their signatures to your user IDs if they want to, but they cannot
add their signatures to your subkeys.
* To make all these signatures work, there is a rule that a primary
  key must be able to sign.  If it can encrypt as well, that's fine
  too, but it must at least be able to make a signature.
* When you "sign someone's key", you are actually signing their
  primary key, plus the specific user ID you chose to sign.
* Even though a signing subkey CAN sign another person's key, by
  convention, when you sign another person's user ID, you do it with
  your primary key.
So, to answer your questions:
The master private key is *a* signing key.  If you have a subkey that
can sign, then you have more than one signing key.
Yes.  Private subkeys are signed with the master private key.
They're just like the master key, except that you usually don't sign
other people's keys with them.  They're used for signing data.
PGP does not currently support signing subkeys.  Current versions will
give weird error messages if you feed them a message signed with a
signing subkey.  I mailed a nice guy at NAI who hangs out on the
pgp-users list and he added support for verifying such messages for
the next version of PGP.

@_date: 2002-02-28 15:15:02
@_author: David Shaw 
@_subject: Signatures. 
I'm not sure exactly what you are asking, but yes, if you use
--encrypt and --sign together, you end up with a document that is
signed and then encrypted.

@_date: 2002-01-05 23:08:01
@_author: David Shaw 
@_subject: list of keyservers? 
Only one of the seven pgp.net nameservers have disabled zone
transfers.  You may have just gotten unlucky :)
Try "host -l pgp.net ns0.pipex.net".  You can get the list of possible
nameservers to try with "host -t ns pgp.net".  "nac.no" is the
one that disabled zone transfers.

@_date: 2002-01-07 20:02:01
@_author: David Shaw 
@_subject: removing the secmem warning 
One of the points of warnings is to warn someone about a situation
they did not know about.  In this case, the user would have to be
already aware of the issue to know they needed to enable the warning.
That defeats the purpose of a warning.
I think something like this would be better:
gpg: Warning: using insecure memory!
gpg: Please read There is already a similar refer-to-this-web-page in the 1.0.7 test
version for users missing the IDEA plugin.

@_date: 2002-01-08 15:12:01
@_author: David Shaw 
@_subject: Automating Encrypting Message to Users with no trust level 
I belive the flag you are looking for is "--always-trust".  Try
something like:
gpg --yes --batch --always-trust -r the_key --encrypt the_file

@_date: 2002-01-09 15:31:01
@_author: David Shaw 
@_subject: v4 Signature Clarification Needed 
It sounds like you do understand. :)
If you sign ("certify") someone's key, PGP (any version after 5) can
handle a v3 or v4 signature.
If you sign a file, PGP 5.x and 6.x can only handle a v3 signature.

@_date: 2002-01-11 17:40:02
@_author: David Shaw 
@_subject: removing the secmem warning 
I believe you are right.  If the algorithm wasn't patented (or was
patented but with a GPL-compatible licence grant), there wouldn't be
an issue.
The error message is:
gpg: the IDEA cipher plugin is not present
gpg: please see  for more information
The web page doesn't point to where the plugin code can be downloaded
though - it's just an explanation of the patent problem.

@_date: 2002-01-16 02:43:02
@_author: David Shaw 
@_subject: Revocation questions 
All of these are valid options.   or  may not be the best thing to
do if you have lots of signatures on your key which you would then
have to replace.
With many signatures,  is a good way to go, and yes, the new userid
will be the primary one (the current gpg uses the most recent userid
as the primary one - the new gpg currently in test lets you pick any
userid you like as primary).  You may also want to revoke the old user
ID with the invalid email address.

@_date: 2002-01-16 15:05:02
@_author: David Shaw 
@_subject: Changing/deleting comment. 
Add this to your command line:
  --comment "This is my new comment"
  --comment ""
You can put those in your options file as well, if you take off the
"--" at the beginning of each line.

@_date: 2002-01-16 16:33:01
@_author: David Shaw 
@_subject: Changing/deleting comment. 
It will change the comment for that one invocation of gpg.  If you put
it in your options file, it will change the comment permanently.

@_date: 2002-01-17 05:58:02
@_author: David Shaw 
@_subject: How should a front-end handle a stored passphrase 
The first thing to do is think about your threat model: what are you
protecting against?  This ranges from protecting the user against root
on the same box (pretty much impossible) to protecting the user
against someone on a different box altogether (not nearly as hard).
Think about all the steps that touch on that passphrase.  Can the
keyboard be tapped via X11 or a hardware device a la Scarfo?  Can the
passphrase be read out of /dev/mem?  Is the box physically secure?
Consider each spot and decide what - if anything - you want to do
about it.  It is reasonable to conclude there are certain attacks you
won't address - for example, if an attacker has root on the box you
are running your application on, there is really very little you can
This is not to say that even if there is nothing you can do, you
should actually do nothing.  Doing something even if there are some
attacks you are still vulnerable to raises the bar against attackers
in general, and as such is a good thing.
All that said, to answer your question - while this doesn't protect
you from root, you can take a few precations with the memory the
passphrase is stored in by:
* ensuring that the chunk of memory holding the passphrase doesn't get
  swapped out to disk.  Various Unix-like systems have various
  different ways to lock a chunk in memory.  You might take a look at
  the code in gpg for this - see the file util/secmem.c.
* Disable core dumps, just in case the attacker can make you crash
  with the passphrase in memory.
* When you are done with the passphrase, you can "burn" that block of
  memory, but read Peter Gutmann's comments on this at

@_date: 2002-01-17 15:23:01
@_author: David Shaw 
@_subject: Unable to Import Public Key 
There is the right way and the less good way :)
The right way is to get the owner of BAADBBCD to sign their own key.
The less good way is to do:
   gpg --allow-non-selfsigned-uid --import e:\test2.txt

@_date: 2002-01-23 19:18:01
@_author: David Shaw 
@_subject: Several questions as feedback on gnupg 
There are two different trust values.  The one you are talking about
here is the "owner trust".  It tells GnuPG how well you trust the
owner of that key to sign other keys.  Nobody can change their own
owner trust without walking up to your computer and doing it - it is
not part of the key.

@_date: 2002-01-24 20:38:01
@_author: David Shaw 
@_subject: signed messages & mutt 
Normal.  Some of the messages you received are PGP/MIME and some are
not.  Mutt can automatically detect a PGP/MIME message, but does not
detect the other sort.
If you are using a fairly recent version of mutt, you can use esc-P to
ask it to check the signature of the other sort of message.  With
older versions of mutt, you can just pipe the message to gpg to check
the signature (i.e. type "|gpg").

@_date: 2002-01-24 20:42:02
@_author: David Shaw 
@_subject: email on keyservers 
When you send a key to a keyserver it, along with any email addresses
on it, become public.
That said, as far as I know no spammer has yet tried to harvest the
keyserver database for addresses, probably because harvesting Usenet
and the web is a lot easier.  The keyservers really don't make it
particularly easy to get addresses in bulk.

@_date: 2002-01-25 20:05:01
@_author: David Shaw 
@_subject: multiple user ID 
There is another interesting benefit, which is each user ID has its
own set of preferences.  For example, let's say you have a home and
work address on the key.  The home user ID can have a different
preferred symmetric cipher or hash than the work user - which can be
useful if you are using IDEA.  Since IDEA is free for personal but not
work use, your home user ID can accept IDEA-encrypted messages but
your work one does not have to.
(Or you could just avoid the whole issue and leave IDEA out.  I
couldn't think of a better example offhand :) )

@_date: 2002-01-29 23:49:01
@_author: David Shaw 
@_subject: Import/Export key pair 
gpg --export my_key -o my_public_key.gpg
  gpg --export-secret-key my_key -o my_secret_key.gpg
Copy my_public_key.gpg and my_secret_key.gpg over, and --import them.
If you are using the current version of GnuPG (1.0.6) or earlier, you
need to set --allow-secret-key-import as well:
  gpg --import my_public_key.gpg
  gpg --allow-secret-key-import --import my_secret_key.gpg
Theoretically you could copy the files from the .gnupg directory, but
this is not a good idea for various reasons (it may not work in the
future being high on the list).  --export and --import is the proper
way to do this.

@_date: 2002-07-01 15:37:02
@_author: David Shaw 
@_subject: adjusting the key verification level after signing it 
No, there isn't.  The class (aka "verification level") of a signature
is part of the signature itself, and changing it would invalidate the
What you can do is either delete or revoke the old signature and then
re-sign the key with whatever class you like.

@_date: 2002-07-02 18:15:02
@_author: David Shaw 
@_subject: wiping files 
It doesn't.  GnuPG runs on many platforms, and a wiper is very
There are a number of free-space wipers out there, but you need to say
what platform you are on.

@_date: 2002-07-02 18:17:01
@_author: David Shaw 
@_subject: feature request: --show-photos additions 
This is in 1.2 (soon), or the 1.1.90 devel snapshot.
Hmm.  I'm not sure I understand what you mean here.  Do you mean show
the photo when a signature from that key is checked?

@_date: 2002-07-02 22:59:03
@_author: David Shaw 
@_subject: feature request: --show-photos additions 
The first example should work, but you need to put options before
commands in GnuPG:
$ gpg -photo-viewer 'cat >foo' --show-photos --list-keys B565716F
If you want to do it completely programmatically, use gpg
--attribute-fd and pass a fd.  GnuPG will write the raw attribute
packet to that fd.  Note that the attribute packet is not the photo -
it follows the RFC format, so you need to remove the photo header
before using the data as a jpeg.  --attribute-fd is only available in
1.1.90 and later.
This sounds reasonable, but I need to think about it some more. :)

@_date: 2002-07-02 23:02:02
@_author: David Shaw 
@_subject: feature request: --show-photos additions 
I understand what Simon was suggesting now.  This would not impact
trust - it's saying "this is who the key claims to be owned by", just
like printing the username when a sig is checked.
Yes.  The photo ID code in 1.0.7 was never really intended to work on
Windows.  You can sort of manipulate it into working with careful
choice of photo-viewers, which is nice.  1.2 (or the 1.1.90 devel
snapshot) has complete Win32 support for photo IDs.

@_date: 2002-07-07 18:16:02
@_author: David Shaw 
@_subject: unsign key...? 
Yes.  Use gpg --edit to edit the key, and then use "revsig" to revoke
the signature.

@_date: 2002-07-08 23:24:02
@_author: David Shaw 
@_subject: gnupg-1.0.7: keyserver subdir? 
Exactly that.  The keyserver subdirectory in 1.0.7 contains
gpgkeys_ldap for communicating with the NAI LDAP keyserver, and
gpgkeys_mailto for communicting with the keys-by-mail keyserver.
gpgkeys_ldap is built if you have OpenLDAP installed and
gpgkeys_mailto is built if you have sendmail installed.  They are
automatically installed when you install GnuPG.  GnuPG will call them
when needed.

@_date: 2002-07-09 00:02:02
@_author: David Shaw 
@_subject: gnupg-1.0.7: keyserver subdir? 
Yes.  I keep meaning to document the keyserver API so people can write
their own plugins...

@_date: 2002-07-09 15:50:01
@_author: David Shaw 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
Hey, this is quite nice!
I have a few minor comments/concerns (maybe we should drag this over
to gnupg-devel?):
1) You shouldn't send the PROGRAM ("PROGRAM 1.1.91\n") line back to
   GnuPG unless you require a particular version of GnuPG.  This will
   cause a warning if someone uses your plugin with anything other
   than 1.1.91.  It's really intended for those gpgkeys_x programs
   that ship with GnuPG itself.
2) Why "jkp"?  Why not use dns: as per
    ?
   After reading your draft, I think I should modify the keyserver URI
   parser in GnuPG to be able to accept a raw URI scheme like "dns",
   which works well with the syntax in your draft to indicate a DNS
   retrieval without specifying a particular server to get it from.
   This way both "dns" and "dns://keyserver.com/" could be used.
3) I see that you didn't follow the CERT RFC recommendation on naming
   the CERT RRs.  Frankly, I think your method is better since it is
   common to know the keyid of a key without knowing the userid (say,
   for verifying signatures).  However, why not take it a step further
   and use the fingerprint (or at least the 64-bit keyid) as the RR
   name?  Searching by fingerprint is the most accurate way to
   retrieve a key as it is too easy to invent a collision with plain
   keyids.
   What do you think of structuring the records like this:
   ; The full CERT, named by fingerprint
   0x7D92..(full fpr)... CERT 3 0 0 (blah blah blah)
   ; The short keyid CNAMEd to the fingerprint
   0x99242560 CNAME 0x7D92...
   ; The long keyid CNAMEd to the fingerprint
   0xDB698D7199242560 CNAME 0x7D92...
   ; The user id in DNS form CNAMEd to the fingerprint
   dshaw.jabberwocky.com CNAME 0x7D92....
   This scheme also lets you index by multiple user ids - just add a
   CNAME for each.

@_date: 2002-07-10 00:39:01
@_author: David Shaw 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
[ using CERTs for key distribution ]
Signed answers can be useful for some things, but unfortunately there
is no ready way to translate the zone trust (company signed zone
containing a CERT) to the GnuPG web of trust (signature on the key
that was retrieved).  To properly place the key in the web of trust,
the company would have had to sign the key itself, and once they do
that it doesn't matter if the zone is signed or not.
Yes.  One of the nice things about CERT is that it allows any OpenPGP
certificate - this can be a revocation certificate or the whole key.
(Perhaps a detached signature?)
The performance issue I'm actually concerned about is that the current
keyserver code in GnuPG does a fork/exec for each retrieval.  That is
pretty heavyweight compared to the UDP DNS protocol.  If we are to use
this for a lightweight key revocation check, I will revise the
keyserver code to keep the pipe to the subprocess open for multiple

@_date: 2002-07-10 13:26:02
@_author: David Shaw 
@_subject: GNU PGP 
Use '--textmode'.  Note that canonical text is really an issue of line
endings though, and not general text formatting.

@_date: 2002-07-10 16:48:02
@_author: David Shaw 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
That's an interesting idea.  The current behavior takes one (the last
specified) keyserver and uses it.  If that keyserver is wedged, GnuPG
will block until it times out.
Are you suggesting querying multiple keyservers at once and taking the
first answer, or suggesting having a list of keyservers and quering
them in order until one answers.  I rather like the second idea, but
not the first for load reasons.
Another way to implement the second idea would be to treat keyservers
with multiple IP addresses as multiple keyservers
(i.e. wwwkeys.pgp.net, which is made up of several different

@_date: 2002-07-10 19:41:02
@_author: David Shaw 
@_subject: wipe issues 
There are two big reasons:
1) GnuPG is portable code that can run on many different platforms.
Wipe programs, by necessity, are generally very unportable.  This
would mean writing and maintaining a different wiper for each
platform.  Since there are already wipers for pretty much all
platforms, why implement the same thing again?
2) GnuPG follows the "do one task, and do that one task well" design
(sometimes called the "Unix ideal").  Time spent working on wipers is
time spent not working on the main task.
This should really be in the FAQ.  It gets asked a lot.

@_date: 2002-07-10 21:07:02
@_author: David Shaw 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
Perhaps.  Despite the variable and function names I used in the code,
it's arguable whether the item specified in a 'keyserver' command is
really a URI or not.  In any event, GnuPG 1.2 accepts either HKP or

@_date: 2002-07-10 21:21:01
@_author: David Shaw 
@_subject: DNS keyserver (was Re: gnupg-1.0.7: keyserver subdir?) 
Err, make that "...SHOULD BE really a URI or not.".

@_date: 2002-07-10 22:38:02
@_author: David Shaw 
@_subject: kjsl.com stats/Re: DNS keyserver 
Not really.  The copy of 0xC7A966DD on keyserver.kjsl.com (probably
the other pksd servers as well) is doubled - the uid and most
signatures appear twice.

@_date: 2002-07-11 16:45:01
@_author: David Shaw 
@_subject: v3/v4 keys - v3/v4 signatures 
When signing a key, v3 keys make v3 certs and v4 keys make v4 certs,
except when force-v4-certs is set or you are signing a v4 key with a
v3 key in which case make a v4 cert always.
When signing data, v3 keys make v3 sigs, and v4 keys make v4 sigs,
except when force-v3-sigs is set in which case make a v3 sig always.
If you are seeing behavior other than that, I'd be interested in the
details.  Are you sure your v4 key has a v3 selfsig?  I fetched it
from the keyserver and checked - the copy there has v4
Is it possible you are looking at the number after the "sig" in a key
sig 3       515E30C7 2002-02-11   Ivo Alxneit.....
That "3" doesn't mean v3.  It means "very carefully checked".  All
selfsigs in GnuPG are level 3, as you can usually trust that you are
yourself when signing your own key ;)

@_date: 2002-07-11 17:30:02
@_author: David Shaw 
@_subject: v3/v4 keys - v3/v4 signatures 
Good point.  Still, he could have generated the key with 1.0.6 and
then moved to 1.0.7.  1.0.6 was out for a long time - why only have a
problem now?

@_date: 2002-07-15 15:51:01
@_author: David Shaw 
@_subject: simple-sk-checksum in linux gpg-1.0.7 to  windows gpg-1.0.6 compatibility 
Here's how to transfer a 1.0.7-generated key to 1.0.6.
1) gpg --simple-sk-checksum --edit (mykeyid)
2) "passwd".  Change the password.  You can change it back to what it
   was originally if you like.
3) "save".
Now you can do the usual --export-secret-key and --export to export
the keys in a format that 1.0.6 can import.

@_date: 2002-07-15 15:51:06
@_author: David Shaw 
@_subject: --override-session-key $PASS simple brute force attack vulnerability? 
No, that SHA1 is required by the OpenPGP protocol.  You can put other
hashes in front of it if you prefer, but you can't get rid of it.  The
same thing applies to the 3DES cipher, and the "Uncompressed"
compression type.

@_date: 2002-07-15 23:55:01
@_author: David Shaw 
@_subject: Non-cipher preferences (Was: Re: --override-session-key $PASS simple brute force attack vulnerability?) 
That's interesting.  To me, 12.2 means the opposite of your
interpretation - they also have the implied addition of the MUST
Look at it in terms of functionality.  Let's say I'm encrypting a
message to you, and the question arises whether to compress it, and
what algorithm to use.  I consult your compression preferences and see
that you allow ZLIB only.  My implementation can only do ZIP.  Now we
cannot communicate.  The answer is, of course, to not to compress -
which would violate your interpretation of the RFC.  Again: if I do
not use the implied "uncompressed" setting at the end of your list,
then we cannot communicate at all.

@_date: 2002-07-16 01:06:02
@_author: David Shaw 
@_subject: can't handle public key algorithm 100 
Yes, 100-110 are reserved for private and experimental use.  GnuPG
doesn't support them since there is no way to know what algorithm is
"100" as 100 may mean something different for every OpenPGP
I suspect that signature is a X.509 signature, which was a private NAI
extension to PGP.  If you send me the key, I can take a look at it.

@_date: 2002-07-16 05:44:02
@_author: David Shaw 
@_subject: Non-cipher preferences (Was: Re: --override-session-key $PASS simple brute force attack vulnerability?) 
Indeed, this is my point, and this is exactly what GnuPG does.  If
there is no "uncompressed" anywhere in the list, it is added to the
I see where you are going with this, but I disagree: SHA1 is not
"widely known to be implemented".  Rather, it MUST be implemented in
every OpenPGP implementation (section 9.4).  The problem in your above
statement is the phrase "mutually agreeable".  There are common cases
where there are no mutually agreeable hashes.  So given that SHA1 is
required, here's the same example as before with SHA1 substituted for
"uncompressed": I want to encrypt & sign a message to you.  I
therefore would like to know what hashes you understand.  Your
preference list says "RIPEMD160 and TIGER192".  I, however, am using
an implementation that cannot use either of these algorithms.  I have
a choice of either not communicating, or using SHA1 which I know (due
to it being a MUST) you can handle.
What the OpenPGP spec is doing with the 3DES/Uncompressed/SHA1
MUST-implement algorithms is handling the case where there is no way
to reach agreement on algorithm choice.

@_date: 2002-07-16 05:48:01
@_author: David Shaw 
@_subject: key-keyserver problem? 
Do you have a v4 RSA key (that is a RSA key generated with GnuPG, or a
fairly recent version of PGP?)  The LDAP keyserver on pgp.surfnet.nl
handles these properly, but the HKP keyservers (including the HKP
keyserver pn pgp.surfnet.nl) do not.

@_date: 2002-07-16 13:50:01
@_author: David Shaw 
@_subject: GnuPG 1.0.7 & AIX 4.3.3 
Content-Disposition: inline
This is a known bug in 1.0.7.  It's fixed in 1.2, but in the meantime,
apply this patch.

@_date: 2002-07-16 15:38:01
@_author: David Shaw 
@_subject: UI non-obviousness 
Try adding a "-v" to your command line.  Then GnuPG will report:
  gpg: assuming signed data in `.....'
You do raise a good point though.  Perhaps this line should not
require -v.

@_date: 2002-07-16 16:08:02
@_author: David Shaw 
@_subject: key-keyserver problem? 
Yes, that is what happens with signing subkeys.
So it's a v4 RSA key and you have multiple subkeys.  The HKP
keyservers are going to mangle the key, and then just to add insult to
injury, report it under the wrong keyid (look under 4E553FDF). :(

@_date: 2002-07-16 19:12:02
@_author: David Shaw 
@_subject: Unable to send key containing photogrtaphic ID 
This is a general problem with HKP keyservers.  At this time, only the
LDAP keyservers understand photo IDs.  Try ldap://pgp.surfnet.nl:11370
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-07-16 21:04:02
@_author: David Shaw 
@_subject: key-keyserver problem? 
Honestly, I'm not really closely following what you are doing with
keyserver.kjsl.com.  After you pretty much didn't care that your HTML
changes were breaking programs that search the keyservers (like "gpg
--search-keys"), I figured you had decided to do what you wanted to do
and to hell with interoperability, so it wasn't worth my getting
stressed about it.
If your server doesn't have the indexing bug, then great:
all-hkp-keyservers-except-one.  It doesn't matter in any event, since
every HKP keyserver, including yours, will mangle any key with
multiple subkeys.
It's great that you are doing work on HKP to help it along, but no HKP
server is safely usable so long as they continue to corrupt keys.

@_date: 2002-07-16 22:25:02
@_author: David Shaw 
@_subject: corrupted secret keyring 
It's not terribly elegant, but you can use gpgsplit (comes with 1.0.7
and later) to break your secret keyring into its component packets,
delete the evil key, and then reassemble.
1) cd ~/.gnupg ; mkdir temp; cd temp
2) gpgsplit ../secring.gpg
3) Find which of the "secret_key" packets is the bad one (run gpg on
   it to print out the key id) and delete it and the other packets
   that go along with it (i.e. delete everything until the next
   "secret_key").
4) cat * > newsecring.gpg
Then backup your current secring, and give newsecring.gpg a try.

@_date: 2002-07-16 23:02:02
@_author: David Shaw 
@_subject: key-keyserver problem? 
This is not completely correct - the LDAP keyservers can searched by
(long) subkey IDs.
gpg --keyserver ldap://pgp.surfnet.nl:11370 --recv AA26722D2D455703
See that GnuPG fetches key 4B764FE1D4F1DD5E.
If you have "keyserver-options auto-key-retrieve" enabled, then GnuPG
does this automatically.
Alas, a LDAP keyserver bug prevents subkey searching from working with
v4 RSA keys, and it seems NAI isn't going to be fixing minor bugs. :(

@_date: 2002-07-17 00:56:02
@_author: David Shaw 
@_subject: Non-cipher preferences (Was: Re: --override-session-key $PASS simple brute force attack vulnerability?) 
If the user selects "showpref", GnuPG shows what the preferences are
*in effect*.  That is, including 3DES/SHA1/Uncompressed if they are
not already present.  This is because GnuPG is going to act on those
pseudo-preferences whether or not they are physically present.
If the user selects "pref", GnuPG shows what the preferences are *on
the key*.  If the key owner hates SHA1, then they can leave it out and
it won't sully their display.  Either way, it doesn't change that
GnuPG is going to use the implied preferences if all else fails.
Preference is perhaps the wrong word here.  The implied "preference"
for SHA1 does not imply that SHA1 is favored or even a good choice.
All it means is that **if all else fails**, we still have a hash
What exactly are we arguing about here?  That I'm calling it a
"preference", that the user can see it, or that it is used as the
last-ditch hash choice?
Anyway, we're going in circles now, so let me summarize with the
example again:
1) All OpenPGP programs have SHA1.
2) Your implementation has RIPEMD160, TIGER192, and SHA1.
3) Your preferences are RIPEMD160 and TIGER192.
4) My implementation has only SHA1.
Now, I want to encrypt and sign a message to you. What does my
implementation do:
a) fail     (unacceptable)
b) use SHA1 (remember - I know you have it because ALL OpenPGP
c) other    (??)
I won't do a), and you seem to fear b).  I'm all ears if you have a
good c).  Bear in mind that in OpenPGP, the SENDER controls what hash
algorithms are used.  NOT THE RECEIVER.  The most the receiver can do
is say (via the preference list): "please use one of these
algorithms".  You don't get to tell other users they can't use SHA1.
That's their choice.

@_date: 2002-07-17 01:01:02
@_author: David Shaw 
@_subject: key-keyserver problem? 
Yes.  Since it only works with long keyids, GnuPG will do a regular
key fetch with a short keyid, and a key+subkey fetch with long keyids
or fingerprints.  You can turn this behavior off with the
keyserver-option "no-include-subkeys" (a new feature in 1.2).
It seems there is a whole group of minor bugs in different programs
surrounding v4 RSA.  Virtually nobody got it right on the first try :(

@_date: 2002-07-17 01:02:01
@_author: David Shaw 
@_subject: can't handle public key algorithm 100 
Yes, this is a X.509 sort of key.  PGP (the company, not the program)
has a way of converting these to PGP keys, but this is not part of the
standard, and isn't in GnuPG.
X.509 is a standard, just like OpenPGP is.  They're just not the same
standard :)

@_date: 2002-07-17 05:07:01
@_author: David Shaw 
@_subject: key-keyserver problem? 
Alas there is but one available to the public:
     ldap://pgp.surfnet.nl:11370

@_date: 2002-07-17 05:12:02
@_author: David Shaw 
@_subject: Non-cipher preferences (Was: Re: --override-session-key $PASS simple brute force attack vulnerability?) 
Hey, give me a chance.  1.2 isn't even released yet.  You're using the
development version ;)
I'm all for placing additional smarts before we must resort to using
the last-ditch hash algorithm (see below for discussion), but the
last, last, last-ditch algorithm must always be SHA1 as it is the only
algorithm that is guaranteed to be present in all OpenPGP
implementations.  Since no other algorithm has that crucial feature,
none of them can be used as a the last-ditch choice.  Or to put it
differently, why use a last-ditch choice that may or may not work,
when we can use a last-ditch choice that will *always* work?
That's not exactly how it works.  There is a warning on the recipient
side if the cipher used in a message is not one of those ciphers in
the recipient's preferences, but since 3DES is always in those
preferences (whether we call this a "real" preference or not) a
warning is never printed for a message encrypted in 3DES.  This is as
per section 12.1 of 2440bis-05.  Translating this idea over to hashes
may have merit, but it also means that there would be no warning for
SHA1 in particular.
c) is not a viable solution.  We already know that there is no
compatible algorithm to have gotten that far, so choosing anything on
the sender's list other than SHA1 is likely to result in an unusable
message.  I'm all for letting people shoot themselves in the foot if
they really want to, as I'm sure you remember with the
cert-digest-algo discussions, but foot shooting must not be the
default behavior. :) There is always --digest-algo if someone wants to
override the default.
I'm sure you'll be pleased to know that d) is in fact the default
behavior in GnuPG for a non-null intersection.  A null intersection,
of course, is SHA1.
It's starting to sound like what you want is a
--personal-digest-preferences that acts more like --digest-algo: if it
can negotiate gracefully, fine, but if it can't then act like
--digest-algo and force the issue.

@_date: 2002-07-17 18:09:01
@_author: David Shaw 
@_subject: Non-cipher preferences (Was: Re: --override-session-key $PASS simple brute force attack vulnerability?) 
You could write that bit for the documentation too you know... :)
I don't quite agree: all negotiations, whether cipher, hash, or
compression, happen on the sender's side, and are ultimately the
sender's choice.  The sender is king.  The RFC bans any sender for
using a cipher that the recipient cannot use (and the sender would be
foolish at best to do so), but the sender can still do it.  That's
just wordplay though.  We're basically talking about the same thing
In any event, the version of GnuPG you are using has a warning for
this already: "forcing digest algorithm "foo" violates recipient
preferences".  Note that this does not apply to a sender using SHA1 -
the warning is to warn about a violation of the preferences, and using
SHA1 does not violate preferences (implied preferences, if you wish).
Note also that this warning only appears if the user forces a
non-listed algorithm with --digest-algo.  Unless the sender takes
intentional action to override the default behavior, GnuPG will never
violate the preference list.
You couldn't tell that was the behavior?  That feature is in the
version of GnuPG you are using.  Documented, too ;)
It will be e) in 1.2 (and is already e) in 1.1.x), but as I noted
earlier, that does not apply to SHA1.
Even if the other reasons I gave above did not apply, there is a less
theoretical problem: keys generated with PGP do not provide a hash
algorithm list at all.  This is perfectly legal (it is interpreted as
a list containing only the implied SHA1), but if there was a warning
when SHA1 was used when it was not physically in the list, barring
some special hack to avoid it, this would cause a warning every single
time someone encrypted&signed to a PGP user, which is unacceptable.
Yes.  You can only really use it with other GnuPG users (which is not
a big problem since no other implementation has it anyway...)

@_date: 2002-07-17 23:52:02
@_author: David Shaw 
@_subject: There is no indication that this key really belongs to the owner 
When in batch mode, you have no way to approve the use of a untrusted
key.  You can either sign or lsign the key to make it trusted, or add
an '--always-trust' to your command line.

@_date: 2002-07-18 21:09:02
@_author: David Shaw 
@_subject: LDAP support in gpg-1.0.7? 
Look a few lines down for the line reading:
checking for ldap_init in -lldap...
If this isn't "yes", then the configure wanted LDAP support, but you
didn't have the LDAP libraries installed so it didn't built the LDAP
Yes, the 1.2 configure messages are a little more clear: "checking
whether LDAP via "(path)" is present and sane" :)
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-07-18 23:21:01
@_author: David Shaw 
@_subject: Subpackets 
I imagine it is because there is no real benefit to protecting it (no
harm either, of course).
The end result of an attacker changing the keyid in the unhashed area
and the end result of an attacker changing the keyid in the hashed
area is the same.

@_date: 2002-07-19 00:17:02
@_author: David Shaw 
@_subject: Subpackets 
Either way it is detected if it is changed.  Since the OpenPGP program
needs the keyid to find the key to check the signature, changing the
keyid (hashed or not) either results in an unverifiable signature (if
the keyid does not exist) or an invalid signature (if it does exist).
It's rather like a chicken-or-the-egg problem.  Its certainly true
that changing a hashed keyid renders the signature invalid - but who
can say if it is invalid because we're now using the wrong keyid to
verify it, or because we changed the hash?  Or both :)
Basically, you can only detect the modification if you can use the key
to verify the signature... and if you could use the key to verify the
signature, it wouldn't have been changed in the first place.
Using a hashed issuer subpacket could be useful when using multiple
issuers for a given signature, but GnuPG does not support that.
Look at build_sig_subpkt() in build-packet.c.  In short, all
subpackets are protected except issuer subpackets.

@_date: 2002-07-19 15:30:02
@_author: David Shaw 
@_subject: Exporting non-exportable signatures 
Well, it's hard to export nonexportable signatures since that defeats
the purpose :)
Here is one way.  First make a backup of your keyrings, just to be
safe, then:
1) Delete all keys on your old keyring except the ones you want to
   keep.
2) cat oldkeyring.gpg newkeyring.gpg > ultimatekeyring.gpg
3) Install 'ultimatekeyring.gpg' as your pubring.gpg.
4) gpg --update-trust

@_date: 2002-07-19 15:31:02
@_author: David Shaw 
@_subject: Secure Viewer Option.... 
The secure viewer option (aka "for your eyes only") is off by default.
Do you have it turned on somewhere in your options file?
If you have it set in your options file and only want to disable it
for certain messages, try --no-for-your-eyes-only

@_date: 2002-07-22 16:26:01
@_author: David Shaw 
@_subject: Creation Date GnuPG 1.1.90 on secret key? 
Interesting.  I was not able to find your public key on a keyserver.
Can you tell me where I can get a copy to examine it?  You can send it
to me off list if you like.

@_date: 2002-07-22 19:12:01
@_author: David Shaw 
@_subject: Creation Date GnuPG 1.1.90 on secret key? 
Well, I took a look at the key and it's fine.  Amusing, perhaps, but
fine.  In GMT time, you created the primary key 7/21 23:43 and the
subkey around 37 minutes later on 7/22 0:20 - after midnight, so it's
the next day.

@_date: 2002-07-22 19:32:02
@_author: David Shaw 
@_subject: secure viewer 
In PGPfreeware there is an option called something like "always use
secure viewer".  Make sure that option is turned off.

@_date: 2002-07-22 21:52:01
@_author: David Shaw 
@_subject: default cipher question 
It is.  The above note refers to the s2k cipher and conventional
(i.e. --symmetric) encryption.  The default for public key encryption
is 3DES.
Cool.  I'm looking forward to more OpenPGP implementations.  There is
also an OpenSSL-based one under development.
Yes.  The smallest possible legal OpenPGP implementation would support
3DES and SHA1 only.  In practice, you pretty much need ZIP as well to
read incoming messages since PGP does not follow the compression
settings and always generates ZIP.  It is also good for security to
compress if you can when generating messages.

@_date: 2002-07-23 18:35:02
@_author: David Shaw 
@_subject: How secure is GnuPG 
PGP 2 used only IDEA as a symmetric cipher.  More recent OpenPGP
implementations, which includes GnuPG and PGP 6 and 7 from the PGP
folks, may use several different symmetric ciphers, one of which is
GnuPG does not come with IDEA for patent reasons (see
 but it can use it if the
patent restrictions do not apply to you.  You can download it from
that web page.
As to the security issue, IDEA is not generally felt to be
particularly more or less secure than the other comparable ciphers.
Read  for more in-depth
Some folks disagree.  Even Bernstein himself points out that his
proposed method may not be usable in practice.
In any event, it is perfectly reasonable to make 2048 bit (or larger)
RSA keys if you prefer.
It means you need to upgrade :)  GnuPG 1.0.7 includes RSA key generation.
Depends who your attacker is.  Unless you're concerned about a large
government, then probably it is.

@_date: 2002-07-23 22:38:01
@_author: David Shaw 
@_subject: How secure is GnuPG 
Many people made their keys before it was so easy to make large keys.
RSA signatures get larger in proportion to the size of the key.  If
you are going to sign emails and such, be warned that a really big
signing key is going to mean one huge signature at the bottom.  DSA
signatures are very small.
Performance-wise, RSA encrypting is much faster than ElGamal, and
ElGamal is a little bit faster than RSA for decrypting.  RSA signing
is much slower than DSA, and RSA sig verification is much, much
faster.  Frankly, unless you are using a palm pilot or similar, the
speed issues don't really make that much of a difference on modern
computers.  Remember that the bulk of the encryption work is done with
the symmetric cipher (3DES, AES, IDEA, etc) and only the session key
is encrypted with RSA or ElGamal.
One of the very nice things about the OpenPGP standard is that it
allows you to use different subkeys for different actions, and they
are all neatly bound together into your one "key".
But seriously - forget all that.  The real question to ask yourself is
*what do you want to do?*  The overwhelming majority of the time,
people end up with a DSA signing key (1024, the maximum) and an
ElGamal encryption key (2048-4096).  That is a good all-round safe
choice for many uses (email being the most common example).
It is very easy to upgrade, and all your keyrings will still work.
There is no such thing as translation to RSA.  GnuPG 1.0.6 can use RSA
as well - what was added was the ability to generate new RSA keys.  If
you have an existing key it should work fine.
Downgrading from 1.0.7 to 1.0.6 can be a little sticky, so if you want
to go back and forth, make a backup of your keyrings.
Do you mean ElGamal or RSA here?  Either way, it's hard to say what is
"beyond our technology".  Certainly, given today's technology, it is
computationally infeasible to brute force a 2048-bit RSA or ElGamal
key in any realistic time frame.
Yes, but it's not really realistic.  Your passphrase would be over 100
characters of gibberish, and nearly impossible to remember.  Instead,
take a look at  for a much easier to remember
scheme that gives you between 60-90 (approximately) bits.
While it is generally true that the passphrase is usually the weakest
part in PGP, remember that the passphrase is just to protect the
secret key.  To start brute forcing your passphrase, an attacker has
to have already stolen your secret key.

@_date: 2002-07-24 02:34:01
@_author: David Shaw 
@_subject: How secure is GnuPG 
No.  GnuPG can use RSA for either signing or encrypting.
No plans, because it's already in there. :)

@_date: 2002-07-24 03:07:01
@_author: David Shaw 
@_subject: How secure is GnuPG 
DSA and ElGamal are based on the same underlying hard problem, so
1024-bit DSA and 1024-bit ElGamal are very similar security-wise.
Note that DSA doesn't encrypt and ElGamal doesn't (usually) sign.
They work well as a pair of keys.
DSA is asymmetric.
That's the spec.  I believe it was chosen to be somewhat in balance
(with regards to strength) with the 160-bit hash that DSA also uses.

@_date: 2002-07-24 04:33:02
@_author: David Shaw 
@_subject: How secure is GnuPG 
Appropriately, it's not an RSA key... :)
DSS does not define DSA.  DSS is built on top of DSA.  Specifically,
DSA is the algorithm, which is specified to use a 160-bit hash and up
to 1024-bit keys.  DSS is a US government specification that uses DSA.
It requires SHA-1 as the hash and 1024 bit keys (it used to allow
768-1024, but they revised it).  If your DSA key is 1024 bits long,
and you use SHA-1, then you are compliant with DSS, but this is not a
OpenPGP requirement.

@_date: 2002-07-25 00:12:05
@_author: David Shaw 
@_subject: 1.0.7 ldap problems 
You need to upgrade your OpenLDAP to a more recent version.  GnuPG 1.2
(when it is released) is able to deal with very old OpenLDAP installs,
but 1.0.7 needs a modern version.
If you don't want to upgrade your OpenLDAP, then build with
./configure --disable-ldap

@_date: 2002-07-25 01:23:01
@_author: David Shaw 
@_subject: How secure is GnuPG 
Sure, but it's a matter of layers of protection.  Each additional
layer makes it that much difficult to mount a successful attack.
First layer is that the attacker doesn't have the secret key.  If they
get the secret key, the second layer is that they don't have the
passphrase.  If we use the passphrase tool in Tinfoil Hat, we've just
made it that much harder (but not impossible, of course) to get the
passphrase.  As each layer is added, you eliminate another group of
potential attackers.  After enough layers, the remaining set of
potential attackers is pretty small.
Of course, if someone had root-level access on a box they could go
around the passphrase problem and just intercept the plantext before
it was encrypted, too :)

@_date: 2002-07-26 19:43:01
@_author: David Shaw 
@_subject: Win32 Binaries 
It is also worth pointing out that 1.1.90 is a development release and
is really intended for testing.
It prints out:
  gpg: NOTE: THIS IS A DEVELOPMENT VERSION!
  gpg: It is only intended for test purposes and should NOT be
  gpg: used in a production environment or with production keys!
on startup, but that can be missed if you are using a frontend of some

@_date: 2002-07-26 23:19:01
@_author: David Shaw 
@_subject: Encrypt and Sign - strange problem to open on Windows 
I only see one '-r' for recipient there.  Which one are you encrypting
to (i.e. what's under the "xxxxxxxxxxxxxxx"?)

@_date: 2002-07-29 05:16:01
@_author: David Shaw 
@_subject: Exact timestamps may be bad 
A forger cannot alter the timestamp, as it is (nearly) always part of
the hashed data.  By altering the timestamp, the forger would
invalidate the signature.
One way of handling the problem is simply to not include the timestamp
at all.  In OpenPGP signature packets, the timestamp is a distinct
subpacket and can be removed trivially when the signature is
generated.  It is somewhat unclear whether this violates the OpenPGP
RFC or not, as I can point to sections in the RFC that seem to say
this is not allowed, and some other sections that seem to say this is
allowed.  The point may be moot since you can't use OpenPGP data
signatures with most versions of PGP, and I imagine you want to be as
widely compatible as possible.
Another way is simply to always use the same timestamp, which is
doable with either OpenPGP or the older style signatures.  I think
this may be better than adding some skew to the timestamp since (as
you mention in one of the bits I've snipped) if Alice sends many
messages with the same skew, Eve may be able to get some clues about
the window size.  If zero is used for the timestamp (i.e. 1/1/1970),
then there is no way to even get a guess about the real setting of the
GnuPG will refuse to validate such a signature ("public key is
1027635505 seconds newer than the signature"), unless the
--ignore-time-conflict option is used to override this check.  PGP
seems to not mind either way, and will dutifully report that the
signature was "made" on 1/1/1970.
Yes, there can be two timestamps in signed OpenPGP messages.  The
first is in the signature, of course, but there is one other one in
the "literal data packet" that contains the material that is signed.
No big deal, but if you are removing one, you need to remember to
remove the other.  This second timestamp is in encrypted messages as
well, but since they're encrypted, they are not visible to anyone but
the recipient.
Clearsigned messages, which are used far more frequently, only contain
the one timestamp in the signature.

@_date: 2002-07-29 17:47:01
@_author: David Shaw 
@_subject: Exact timestamps may be bad 
I tend to have an allergy to trusting anyone but the sender for this
sort of thing.  What if Alice were to increment her timestamps as she
goes - that is, first message use 1, second message use 2, etc.  That
should defeat replay, and also hide the real clock value.  The
timestamp field is 32 bits, so she can send quite a few messages
before it rolls over.
It's somewhat of an abuse of the timestamp field, but who's to say
that Alice doesn't really think it's some time in 1970? ;)

@_date: 2002-07-29 21:47:01
@_author: David Shaw 
@_subject: automatic getting keys from server 
Put in your options file:
  keyserver-options auto-key-retrieve

@_date: 2002-07-30 04:23:01
@_author: David Shaw 
@_subject: Signing Keys w/ Multiple User IDs 
The classic PGP trust model gives trust through user IDs, so when you
"sign a key" you are really signing a user ID on that key.  For
example, if you want to send email to joe and you have a
valid trust path to Joe, you're all set.  If you want to send mail to
patti you might be out of luck, even though Joe and Patti
are two different user IDs on the same key.  In this case, you trust
that Joe is a valid name on the key, and therefore you trust the key,
but Patti is not a valid name, so you don't trust the key.
This is not exactly a common situation, of course. :)
It depends.  Signing more than one user ID means that you vouch for
all of those user IDs.  Do you?
For example, if I was signing a key, and one user ID says "Charles
Dodgson" and the other says "Alice Liddell", I'd probably be
suspicious.  Personally, I email all of the user IDs before signing
them to confirm the mail goes to someone who has access to the secret
key half.
If you vouch for all of the user IDs (names and email addresses), then
by all means sign all of the user IDs.  Not too long ago I signed a
key whose owner had just changed his name.  He showed me evidence of
the name change, so I signed his key.  No big deal.
In the specific case you mention (a key used to verify a software
package), it does not matter.  This is because in this case, the key
is located by its key ID and not a particular user ID.  Signing one or
all of the user IDs will have the same function of trusting the key.

@_date: 2002-07-30 15:07:01
@_author: David Shaw 
@_subject: Signing Keys w/ Multiple User IDs 
Correct.  There is actually a way in the OpenPGP spec of indicating
which user ID within a key did the signing, but this is generally not
A user ID is just a blob of bytes that indicates something about the
owner of the key.  This blob can be a text string, a photo, or
whatever you like.  A signature on a user ID means, in effect, "I
believe this user ID matches a human being that controls this key".
I'm not sure if this is what Werner was referring to in the TODO list,
but there is also the notion of a "trust signature", which is somewhat
different from the above trust model, and is based on "Modelling a
Public-Key Infrastructure" by Ueli Maurer
(ftp://ftp.inf.ethz.ch/pub/crypto/publications/Maurer96b.pdf).  I
actually have a GnuPG implementation of this working, but it is too
experimental for the 1.2 release.  Trust signatures are interesting as
they let you make statements like "I trust Alice completely, but only
when she is signing keys in the example.com domain".  This sort of
thing is useful in the corporate world, where the Big Boss can
delegate key signing responsiblity to others with this method.

@_date: 2002-07-31 19:42:02
@_author: David Shaw 
@_subject: BAD Signature 
It means the signature is bad, but the signature packet itself is not
corrupted to the point of not being able to read the issuer out of it.
It's not perfect - if the signature is BAD, the keyid of the issuer is
certainly suspect.

@_date: 2002-07-31 20:18:02
@_author: David Shaw 
@_subject: Signature verification problem 
CryptoEx is not generating proper messages.  Specifically, it is
missing the "Hash:" header to indicate the hash used in the document.
RFC-2440 says "If the "Hash" armor header is given, the specified
message digest algorithm is used for the signature. If there are no
such headers, MD5 is used, an implementation MAY omit them for V2.x
This message uses SHA1 as the hash, but by omitting the "Hash: SHA1"
header, it is claiming to use the MD5 hash.
Note that if you change your message to stick in the missing header,
it verifies correctly:
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
This is a signature test.
I imagine it works on PGP because of "be conservative in what you
generate and liberal in what you accept" and so PGP double-checks the
claimed hash against the actual signature data in some manner.
It could be (and should be) argued that GnuPG should do the same here,
but nevertheless this is a bug in CryptoEx.

@_date: 2002-07-31 20:57:02
@_author: David Shaw 
@_subject: pgp.mit.edu is unhappy (was Re: wierd error message) 
pgp.mit.edu seems to be having problems at the moment.  Try requesting
that key
(i.e. and you get a bunch of stuff (HTTP headers, etc) mixed in with the key
data.  Try using another keyserver.

@_date: 2002-07-31 21:35:02
@_author: David Shaw 
@_subject: Signing Keys w/ Multiple User IDs 
Yes.  When a key is selected by key ID, the exact details of user ID
pretty much don't matter.  As long as one of the user IDs is fully
trusted, then the key is fully trusted.

@_date: 2002-07-31 22:10:02
@_author: David Shaw 
@_subject: Signature verification problem 
Perhaps it's worth an error message if the hash specified in the armor
header does not match the hash specified in the signature.  The same
thing could happen with the onepass signatures as well.

@_date: 2002-06-01 16:31:01
@_author: David Shaw 
@_subject: Can't transfer old secret subkey to 1.0.7 secring 
Merging two different secret keys is not currently supported.  There
is a workaroung using "gpgsplit" (comes with GnuPG).
1) Export both secret keys into files
   gpg --export-secret-keys 86ECAC0B > first.gpg
   gpg --export-secret-keys --secret-keyring secold.gpg 490CC343 > second.gpg
2) Run gpgsplit on the second file.
   gpgsplit second.gpg
3) Delete the parts you don't want.  You only want the subkeys, so
   delete everything until the first secret subkey packet (i.e. if the
   first secret subkey is 000004, then delete 000001, 000002, and
   000003).
4) Merge the keys:
   cat first.gpg 00000* > newkey.gpg
5) Delete the current secret key
   gpg --delete-secret-key 86ECAC0B
6) Bring in the merged key:
   gpg --import newkey.gpg
Obviously, make a backup first!

@_date: 2002-06-02 05:14:02
@_author: David Shaw 
@_subject: Key preferences =?iso-8859-1?Q?=28Davi?= 
MingW32 is not cross compiled.  You don't need a Linux box to do
anything here - download 1.0.7, download MingW32, compile away.
Building your own binary is complex and fussy, and I don't recommend
it unless you know what you are doing, but you certainly don't need
anything but a regular Windows box to do it.

@_date: 2002-06-03 17:03:01
@_author: David Shaw 
@_subject: 1.07 RSA support questions 
Yes, there are.  If "pgp2" is set in the options file, GnuPG disables
certain options that you might want to use (like sign&encrypt in one
Yes.  This isn't really a RSA thing so much as an OpenPGP thing.
OpenPGP keys are generally made up of a signing-only master key, with
multiple subkeys to do various other tasks (usually encryption).
The next GnuPG will let you generate a RSA sign+encrypt key, but this
is not recommended.

@_date: 2002-06-03 19:14:01
@_author: David Shaw 
@_subject: 1.07 RSA support questions 
Not a bug or change in behavior.  1.0.6 did RSA/3DES also.
The reason that GnuPG does not use IDEA for legacy keys by default is
that it has no way to know the capabilities of the OpenPGP program on
the other side.  IDEA is not required by OpenPGP, so without a
preference list to tell GnuPG that IDEA is a possibility, it can't
safely use it.  Preference lists generally don't exist on legacy keys,
though if one is present, GnuPG will use it.  The current development
GnuPG allows you to add a preference list to a legacy key.
When you use --pgp2 you are telling GnuPG that you *know* the program
on the other side can handle IDEA, so it uses it.

@_date: 2002-06-04 00:57:01
@_author: David Shaw 
@_subject: Downgrade problem. 
You are correct.  1.0.7 has a slightly different keyring format
(actually a problem in 1.0.6).

@_date: 2002-06-04 01:48:01
@_author: David Shaw 
@_subject: 1.07 RSA support questions 
This right here is one of the great things about OpenPGP: cipher
choices are handled for you automatically.  Each user specifies what
ciphers they can handle in whatever order they like (like AES?  List
it first!) and the program figures out the best choice give the
You can add cipher preferences to an PGP2-style key, but PGP2 can't
handle it.  You can only use a key with preferences in more recent

@_date: 2002-06-04 04:17:02
@_author: David Shaw 
@_subject: Downgrade problem. (Jean-David Beyer) 
This is not correct.  There is no need to go through the trouble (and
danger) of making a special copy of the key with no passphrase,
disconnecting from the network, etc.
Just do this:
0) Make a backup of your keyrings.
1) On the 1.0.7 box:
   gpg --simple-sk-checksum --edit (keyid)
   Enter "passwd", and change your password to anything.  It does not
   have to be blank, and you can in fact "set" it to what it currently
   is.
2) On the 1.0.7 box:
   gpg --export-secret-key (keyid) > mykey.gpg
   gpg --export-key (keyid) >> mykey.gpg
  (copy mykey.gpg to the new box)
3) On the 1.0.6 box:
   gpg --allow-secret-key-import --import mykey.gpg
However, I wouldn't do it - rebuild 1.0.7, and use that.

@_date: 2002-06-04 04:42:01
@_author: David Shaw 
@_subject: To upgrade or not? 
This sounds like the Klima/Rosa attack, but there is some
misunderstanding here.  GnuPG is already protected against this attack
(and has been for a long time - 1.0.5, I think).  The new
SHA1-protected secret keys are more to protect a key in transit, and
for implementations that do not have built-in Klima/Rosa protection.
This is not what the Klima/Rosa attack does.  Adding an additional
decryption key sounds like the old PGP ADK bug, but GnuPG never had
that problem, as it does not use ADKs at all.

@_date: 2002-06-04 04:46:02
@_author: David Shaw 
@_subject: Question on IDEA 
David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-06-05 04:56:01
@_author: David Shaw 
@_subject: Cannot encrypt/decrypt zip-Files correctly (Andreas) 
If you encrypt a compressed file, GnuPG (1.0.7) will try to
automatically disable compression so as not to compress twice.  By
default, if you encrypt a uncompressed file, GnuPG will automatically
compress it while encrypting.  You are pretty safe going either way
with the compression :)

@_date: 2002-06-06 20:29:01
@_author: David Shaw 
@_subject: Key certification quality 
of a
a 2
At some point in the future this may be possible.  Currently, the
number is just there for human use.
When I wrote that feature, I figured that it would take a while before
enough people used it on enough keys to make it worthwhile to talk
about going further.
Possibly it would work something like "I only accept level 2 and above
key certifications from user X, but from user Y, I accept only level
3s".  OpenPGP already has a notion of a "trust signature" which is
more along the lines of what you are saying with more or less
'powerful' signatures.  This would be something much simpler.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-06-06 21:44:02
@_author: David Shaw 
@_subject: gpg --encode / gpg --decode round-trip breaks my files 
Check if you have "textmode" set in your options file.  That would
cause the exact problem you are seeing.

@_date: 2002-06-07 17:35:01
@_author: David Shaw 
@_subject: Two Signing keys in one key 
Yes, completely legal.  Many people use the same sort of key.
Alas, no.  Most keyservers have a bug that will corrupt a key with
more than one subkey.
This will eventually work via the keyservers, once the new generation
of keyservers are up and running.  In the meantime, certain keyservers
do work with this sort of key - try ldap://pgp.surfnet.nl:11370
There is one catch to this sort of key that you didn't mention - no
version of PGP understands signatures made from a signing subkey.  It
was supposed to be added, but unfortunately NAI cancelled PGP before
that version was released.

@_date: 2002-06-07 22:44:02
@_author: David Shaw 
@_subject: Using ELG sign and encrypt key 
that gave
ption is
This last reason, for me, is particularly important.  Aside from the
Big Bad Government reason, there are several advantages from a key
management perspective to use a seperate signing key.  I keep my
encryption subkey on my laptop and leave the signing key offline.  If
my laptop gets stolen, I don't lose my whole key.
If you want a 4096-bit key that can sign, why not use a 4096-bit RSA
key?  It's certainly more widely supported (including PGP support)
than ElGamal signing keys.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-06-11 15:42:02
@_author: David Shaw 
@_subject: listing --lsign keys 
In 1.0.7, regular --list-keys shows this:
sig 2 L     3CB3B415 2002-06-11   David M. Shaw       ^
 This 'L' means "local".
In using --with-colons, the third letter in the 11th field will be 'x'
for a regular signature, and 'l' for a local signature.

@_date: 2002-06-11 15:58:01
@_author: David Shaw 
@_subject: "invalid subkey binding" 
This is an example of the keyserver corrupting keys with multiple
subkeys.  GnuPG is unhappy with the key because it is missing one of
its two subkey binding signatures, and the other binding signature is
moved to the wrong subkey.

@_date: 2002-06-11 16:32:01
@_author: David Shaw 
@_subject: "invalid subkey binding" 
As far as I know, the only remaining public LDAP keyserver is
ldap://pgp.surfnet.nl:11370.  The pgp.com folks ran one for a while,
but it is now down.
There are also a few HKP (HTTP) based servers coming on the horizon
that don't have the bug.
Unfortunately, you can't guarantee that using a LDAP keyserver will
give you uncorrupted keys.  Since all the keyservers eventually sync
to each other, if the key was originally uploaded to a keyserver with
the bug, then every other server (including the LDAP ones) will learn
the corrupted copy since that it what the buggy keyserver sends out.
If the key was originally uploaded to the LDAP keyserver, then you
stand a better chance.

@_date: 2002-06-11 16:58:02
@_author: David Shaw 
@_subject: (?) Problems building and running gpg on Tru64 v5.1 
This is a known bug.  See
 for
a patch.  It is fixed in the next version.

@_date: 2002-06-11 19:22:01
@_author: David Shaw 
@_subject: PGP-GPG Compatibility 
This is not unusual.  Remember that the key preferences and expiration
date are contained in the self-signature.  If the key owner changes
their prefs or expiration date then a new self-signature will be
This error message is due to the X.509-ish signature on the key.  This
is not part of OpenPGP, and is discarded by GnuPG.  The error can be
safely ignored.

@_date: 2002-06-12 17:13:02
@_author: David Shaw 
@_subject: weird WARNING messages with 1.0.7 
For when the problem is in the options file, I think I'll change this
to be something like:
gpg: /path/to/option/file:lineno: deprecated option "honor-http-proxy"
gpg: please use "keyserver-options honor-http-proxy" instead
With the line number given, it should be clearer where the problem is.
If the option comes from the command line, then it will be the current

@_date: 2002-06-13 15:57:01
@_author: David Shaw 
@_subject: automatically downloading public keys no longer works. 
Sure they are.  If you have OpenLDAP installed, GnuPG 1.0.7 will pick
it up and include LDAP support.
Note, however, that the keyserver line given above is incorrect.  This
keyserver is LDAP, but they run it on a different port than the LDAP
standard.  Try this:
   keyserver ldap://pgp.surfnet.nl:11370

@_date: 2002-06-14 14:42:02
@_author: David Shaw 
@_subject: checking up on one's public key 
It's not unheard of, but not exactly common either.  It could be an
error with someone picking your key to test on and accidentally
uploading it to the server afterwards.  Famous people tend to get it
more: Phil Zimmermann has signatures from 'president
and 'vice-president ;)
OpenPGP actually has a flag to say essentially "don't accept updates
to my key on the keyserver unless they come from ME".  GnuPG does set
this flag, but none of the current HKP keyservers uses it.  I'm not
sure if the LDAP keyserver does - does anyone know for sure?  It's a
hard feature to support since it means you need some sort of
authentication between the user and the keyserver which complicates
things quite a bit.  The LDAP keyserver already has this
authentication, of course.

@_date: 2002-06-17 14:20:07
@_author: David Shaw 
@_subject: How to select a specific subkey for signing? 
Yes.  Stick a "!" after the keyid you specify and GnuPG will use it
  gpg -u 0xDF2D08D3! --sign .....

@_date: 2002-06-17 18:10:01
@_author: David Shaw 
@_subject: How to select a specific subkey for signing? 
It is.
       Note that you can append an exclamation mark to key IDs or
       fingerprints.   This flag which tells GnuPG to use exactly
       that primary or secondary key and don't try to figure  out
       which secondary or primary key to use.

@_date: 2002-06-17 22:39:02
@_author: David Shaw 
@_subject: PhotoID viewing on Win32 
Hi folks,
One of the changes in the next release of GnuPG is much better support
for photo IDs on Windows platforms.
You can of course set the viewer to whatever you like, but as the code
sits now, the default viewer uses "start" to read the registry and use
the default jpeg viewer.
This default needs to be slightly different on 95/98/ME and NT/2k/XP,
and I'd like to make the default most useful for the most people.  Can
the Windows users give me an idea which Windows platform you are
using?  (You can reply to me directly rather then load the list down
with this).

@_date: 2002-06-18 15:36:06
@_author: David Shaw 
@_subject: keyservers 
I agree.  We're already seeing questions come in now ("why can't I
send my key with a photo to the keyservers?").  What particularly
worries me is that while the photoid support is a harmless bug (it
just doesn't work, and causes no other harm), the multiple subkey bug
is very harmful (it just doesn't work, and breaks your key in the
I'm actually hoping that the more visible problem of photoid support
drives a fix for both.

@_date: 2002-06-18 16:52:01
@_author: David Shaw 
@_subject: Preferences 
The 3DES cipher (like the hash SHA-1) is always available in OpenPGP.
If you don't explicitly include it in your preference list, it is
assumed to be at the end of the list.
[mdc] is not really a preference.  It means that you can handle
messages that include a MDC (modification detection code) to prevent
modification of encrypted messages.

@_date: 2002-06-19 14:23:01
@_author: David Shaw 
@_subject: cipher prefs and cipher-algo settings 
Yes.  This is a very bad way to do things as it overrides what the
public key owner asked you to use.  He may not even HAVE that
algorithm, and will not be able to decrypt the message at all.
"cipher-algo" (as well as "digest-algo" and "compress-algo") should
almost never be needed in regular usage.  Let the GnuPG program figure
out which algorithms to use - if you are using OpenPGP keys (GnuPG,
any PGP after v5) it will always pick algorithms that the public key
owner can handle.

@_date: 2002-06-19 14:31:01
@_author: David Shaw 
@_subject: keyservers 
That's a very good question.  The answer is... nobody knows exactly.
The nature of the keyserver net is that anyone who wants to run one
can, and there is no central authority to dictate policy.  That's a
good thing, but it makes this sort of program more complicated.
The keyserver operators are usually reasonable people, who are usually
aware of the problem.  I sent out some code that can detect and repair
the mangled keys so I expect that the new keyservers will do something
similar and repair keys as they arrive.

@_date: 2002-06-24 00:18:01
@_author: David Shaw 
@_subject: different fingeprint and uid after upload to keyserver 
Yes.  This is a bug in the keyserver.  There is nothing wrong with
your key.

@_date: 2002-06-24 00:19:01
@_author: David Shaw 
@_subject: different fingeprint and uid after upload to keyserver 
It is good that there is a fix for the keyid bug, but note that this
keyserver is not compatible with the --search-keys feature in GnuPG.

@_date: 2002-06-24 19:02:02
@_author: David Shaw 
@_subject: different fingeprint and uid after upload to keyserver 
No, the RFC is correct here.  When calculating fingerprints, the
public key is canonicalized so that all programs calculate
fingerprints in the same way.  Specifically, the CTB byte is always
0x99 so that no matter how the key is rewritten it is still treated
the same.  It has nothing to do with what the first byte is in the key
For example, I could write the same key with a new-style CTB and
four-byte lengths just as well as with an old-style CTB and 2-byte
lengths.  It's the same key, but unless you canonicalize the key
before creating the fingerprint, you'll end up with the wrong
Note that calculating the key hash for signatures does the same thing,
for the same reason.

@_date: 2002-06-26 14:19:01
@_author: David Shaw 
@_subject: GPG 1.0.7 Official Win32 Build (?) 
So you keep saying.  Care to post anything more illuminating than
"doesn't compile"?
I'll be happy to help and fix the problem, but I need just a little
more information here.

@_date: 2002-06-27 20:43:01
@_author: David Shaw 
@_subject: encrypting using a PGP 7.0 pubkey does not work 
Judging by the key creation date, it's from an earlier PGP than 7.0 :)
Is there some way you can post the key information without xxxxx-ing
it out?  There is almost no way to help you without being able to see
the key.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-06-27 23:02:02
@_author: David Shaw 
@_subject: GPG 1.0.7 Official Win32 Build (?) 
Hmm.  There was a change between 1.0.6 and 1.0.7 to improve the
assembler code on Solaris (if I recall) that seems to be what is
causing this.
1.0.6 worked for you, right?

@_date: 2002-06-28 14:26:02
@_author: David Shaw 
@_subject: GPG 1.0.7 Official Win32 Build (?) 
I think it's the standard assembler for OpenBSD.  The OpenBSD 3.0 box
I have access to here also uses 1.92.3.

@_date: 2002-06-30 17:51:02
@_author: David Shaw 
@_subject: Windows CE version 
============================== START ==============================
The only thing I know of is "PGP Wireless", which was a NAI product.
Unfortunately, NAI discontinued PGP, so you can't buy it any longer.
I don't know of any free (speech or cost) products to do it, though it
is theoretically possible for someone to port GnuPG to the iPAQ.

@_date: 2002-03-01 00:59:01
@_author: David Shaw 
@_subject: implications of subkeys? 
Yes, but then you would have had two "keys" in the keyservers and on
people's keyrings.
Correct.  If they do not specify a particular key to encrypt to, GnuPG
will make a reasonable guess for which subkey to use (it uses the one
with the most recent signature, which generally means the most
recently created key).
Generally this is not an issue since people usually don't have very
many active encrypting subkeys at the same time.  Usually there is
only one, and a new one is added some time before the first expires.
Once the new one is widely distributed the old one is revoked or
allowed to expire.
If you are intend to use different keys for home and work, that
particular case sounds like it would be more convenient to use two
different full keys.
Mostly correct.  GnuPG is biased internally towards subkeys.  If you
don't specify otherwise, it will use a subkey over the master key if
possible.  To specify a particular key, you can use --local-user and
append an exclamation mark to the key id.  This means "Don't try and
figure out which subkey to use.  Give me this exact key id."
All correct.  It would be sort of interesting to be able to have
different passphrases for different subkeys, and there is nothing in
the standard that prevents it, but GnuPG doesn't do it now.

@_date: 2002-03-01 01:05:02
@_author: David Shaw 
@_subject: Multiple subkey warning 
Hi folks,
What with all the discussions of multiple subkeys, I wanted to add a
** Most of the current keyservers in use on the net today do not
handle multiple subkeys properly.  The subkeys get mangled together
and corrupted. **
Worse, most of the keyservers synchronize with other keyservers, so
even if you send your key to one of the good ones, it can end up on
the bad ones as well and get corrupted.
Obviously this doesn't affect your local copy or anyone you send your
key to directly, but anyone who gets it off one of the bad keyservers
will get a corrupted key.

@_date: 2002-03-01 17:04:02
@_author: David Shaw 
@_subject: implications of subkeys? 
In this particular case, it means "Don't use these." :) ElGamal
signatures are somewhat controversial.
Yes.  That's a good thing, as the DSA primary (plus your user ID) is
what ties you into the web of trust.  You'd want that key to stay
around for a long time, if not forever.
You can do it with "gpg --export-secret-subkeys".
However, that allows the authorities to decrypt everything sent to
that key (which is a reason right there to change your encryption key
every now and then).  You can reveal the session key for a single
message with --show-session-key.
Seriously, though - if that happens, call a lawyer before you do
anything, and then call the EFF.

@_date: 2002-03-01 20:38:02
@_author: David Shaw 
@_subject: implications of subkeys? 
Hmm.  Personal preference, I think.
For me, I always felt it was better to seperate my work life from my
personal life - that means two email addresses, two different keys,
etc.  There is inevitable overlap, of course, but it works well for me
that way.  It also works better if the company requires things like a
company revocation key, or worse, a company ADK.  I wouldn't want that
on my personal key.
In the USA, at least, I have read about possible legal issues with
regards to the boundaries between private and company communications.
If I send a private email from a company email address, the company
can under some circumstances ask for a copy of it.  (I am not a
lawyer, laws are different everywhere, etc.)

@_date: 2002-03-01 20:43:02
@_author: David Shaw 
@_subject: implications of subkeys? 
Yes.  The algorithm is up to you and what you trust more.  GnuPG 1.0.7
gives you the choice between DSA and RSA.  They each have advantages
and disadvantages.
Problem here.  If your key is already on the bad keyservers, adding a
new subkey will trigger the bug.  Even if you remove the old subkey
first, it doesn't leave the keyservers.

@_date: 2002-03-01 20:48:01
@_author: David Shaw 
@_subject: implications of subkeys? 
I heard about this a few months ago (I think you were the one who told
me, actually), but I don't really see a large benefit here.  All it
means is that your new key is one certification depth "hop" closer
than it would be otherwise.  Is that really such a big benefit?
GnuPG does not do this, incidentally.

@_date: 2002-03-02 15:24:01
@_author: David Shaw 
@_subject: advantages/disadvantages of DSA/RSA keys (was: Re: implications of subkeys?) 
This is pretty good:
        David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-03-04 05:12:01
@_author: David Shaw 
@_subject: duplicate keyid survey results 
I strongly agree with Len on this.  Since the user's program must
validate the keys via signatures anyway, a keyserver does not need to,
and should not try to work out valid or invalid keys.
A quick look at the list of duplicate key ids seems to show that they
are all old-style v3 RSA keys which are known to have a problem with
having easy to create arbitrary 32 *or* 64-bit key ids.  Did I miss
any v4 keys on the list?
Creating a matching key id with the newer v4 key format requires
either brute force creating keys until the key id matches, or breaking
SHA-1, a problem that may not be impossible someday, but is difficult
to the point of effectively impossible today.
All that said, the 64-bit OpenPGP keyid space is very large but not
infinite.  There are going to be naturally occuring collisions
eventually (plus, one can certainly generate a v3 RSA key with the
same key id (but not fingerprint) as a v4 key).  This should be
harmless since the keys are validated based on the signatures and not
on anything the keyserver does or does not do.
If a duplicated keyid is requested from the current HKP and NAI LDAP
keyservers, *all* matching keys are returned.  This is the correct
behavior, as it lets the receiving program and the user decide which
(if any) of the returned keys is the right one.

@_date: 2002-03-04 14:43:01
@_author: David Shaw 
@_subject: advantages/disadvantages of DSA/RSA keys (was: Re: implications of subkeys?) 
This is true, and important - v4 RSA keys do not have most of the
disadvantages of v3 RSA keys.  Specifically in section 8.1, statements
    (mostly), and  do not apply to v4 RSA keys.
Also, v4 RSA is not directly backwards compatible with v3 RSA without
doing significant packet munging magic.
RSA signing keys, that is.
For me, the worst thing about RSA signing keys is that they make much
larger signatures than a DSA key.  All in all, that's not such a big
problem these days. :)
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-03-04 19:12:02
@_author: David Shaw 
@_subject: 106d (was: Re: timestamp (0x40) signatures?) 
That's interesting.  The gpg.info file is actually missing
double-dashes in quite a few places.
The master gpg.sgml has it right, and the gpg.1 man page file
(generated from gpg.sgml) also has it right.  The gpg.info file is
generated from gpg.texi which is generated from gpg.sgml, but it has
it wrong.  Maybe something in the docbook-to-texinfo stuff?

@_date: 2002-03-04 19:24:01
@_author: David Shaw 
@_subject: short question 
"man page" refers to a page in the online Unix manual.  For example,
"man gpg" gives you the manual for gpg.
As for 'foo':     David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-03-06 16:08:01
@_author: David Shaw 
@_subject: Order of namestrings changed when importing keys 
Yes.  GnuPG makes the (reasonable) assumption that the most recently
added (actually the most recently self-signed, but that usually means
most recently added) user ID is the primary one.
Yes.  In a few weeks, GnuPG 1.0.7 will come out with a command
("primary") to mark whichever user ID you like as primary.
A few months ago, I posted a different way to do the same thing.  You
can read that here:

@_date: 2002-03-09 04:24:01
@_author: David Shaw 
@_subject: duplicate keyid survey results 
GPG uses 64-bit keyids internally, so even though most people don't
know their own 64-bit keyid, when someone does a --refresh-keys
command or a key is retrieved automatically because of the
--auto-key-retrieve option the 64-bit keyid can be used.
Even so, the user can see their 64-bit keyid by adding the
"--with-colons" option to the usual --list-keys or --list-sigs
I'd even like to be able to search by fingerprint.  The way I see it,
since the 32-bit keyid is just the lowest 32 bits of the fingerprint,
and the 64-bit keyid is just the lowest 64 bits of the fingerprint,
the keyserver must calculate the fingerprint no matter what.  Since
it's already calculated, it would be nice to use it.
If you don't think this is the right way to go, what do you suggest as
an alternative?  I think a warning is fine, but not returning one of
the keys leaves the keyserver open for a denial of service attack.

@_date: 2002-03-09 05:19:02
@_author: David Shaw 
@_subject: duplicate keyid survey results 
The user does not know if any key from a keyserver is valid or not.
Even if an attacker creates hundreds of duplicate keys, it does not
matter since the signatures are what is used to check if the key is
It is easy to make even a duplicate 64-bit keyid.  If the keyserver
makes the user go through many extra steps to get a key if there is a
duplicate keyid, then that is a (mild) denial of service as well.

@_date: 2002-03-09 14:46:01
@_author: David Shaw 
@_subject: duplicate keyid survey results 
This is an algorithm that a human being can follow.  What is a program
supposed to do?  Most people do not use a web interface to get their
keys - they use the keyserver interface in their application, which
can only say "give me 0xXXXXXXXX".  It should not have to parse and
understand lots of HTML to try and resolve conflicts.  Also, PGP is
not being updated anymore.  Even if code is added to GnuPG to talk to
your keyserver, PGP will not be able to.
Let me try and approach this from another direction: do you see any
security problem with returning more than one key with the same keyid?
If yes, can you tell me why?
Remember that the keyserver does nothing to validate the keys - that
is the job of the signatures on the key.  The decision on whether to
use a particular key belongs to the *user* who verifies the signatures
and decides where this key fits into the web of trust.  One of the
main reasons for key signatures in the first place is to deal with
this exact problem.  There can never be a denial of service by
generating a fake key with the same keyid because of the signatures.

@_date: 2002-03-09 15:01:01
@_author: David Shaw 
@_subject: duplicate keyid survey results 
Only if the keyserver can only handle 32-bit keyids.  If GPG is
talking to a server that can handle more (like the LDAP server), it
will use the full 64-bits.  (Werner, this is one of the things I added
in the generic keyserver code :) )

@_date: 2002-03-10 16:45:02
@_author: David Shaw 
@_subject: duplicate keyid survey results 
Sorry - spam blocking system on your netblock.  Your addresses are
right in the middle of a pile of open relays in Korea.
I've overridden the blacklist for your servers.

@_date: 2002-03-10 20:30:02
@_author: David Shaw 
@_subject: duplicate keyid survey results 
I think this is a good thing except for one problem.  From the
perspective of a program that is making a call to a keyserver via HKP,
it has no way to know if the keyserver is pksd, CKS, or something
else.  Since only CKS supports this syntax, there is a problem.  I
guess it could try twice and fall back to the 32 bit key id if the
keyserver returns an error with a fingerprint lookup.
Something to be discussed in the RFC, I think. :)

@_date: 2002-03-10 23:37:02
@_author: David Shaw 
@_subject: lookups by fingerprint and long keyid (was Re: duplicate keyid survey results) 
For browser-based lookups by human beings, fine.
For any program-driven interface, it must be discussed first.
Creating a feature that breaks compatibility with an existing server
base needs at least a minute or two of thought before doing it.

@_date: 2002-03-13 16:43:02
@_author: David Shaw 
@_subject: Compatibility problem ?? 
Yes.  PGP does not support signing subkeys.
There is a practical use - many people like to set expiration dates on
their subkeys and/or rotate them every now and then.  Using a signing
subkey this way means you don't have to generate a new key and get it
signed each time.
Using a signing subkey also means you can keep your primary key
offline and just use the subkeys for signing and encryption.

@_date: 2002-03-15 17:59:02
@_author: David Shaw 
@_subject: Local signatures v. exportable signatures 
GnuPG 1.0.7 shows a "L" between the "sig" and the keyid for local
signatures.  I don't know about GPGShell.
GnuPG 1.0.7 is getting closer to release.

@_date: 2002-03-15 18:00:01
@_author: David Shaw 
@_subject: Problem generating RSA keys 
GnuPG 1.0.6 cannot generate RSA keys.  That is a new feature in 1.0.7.

@_date: 2002-03-16 02:01:02
@_author: David Shaw 
@_subject: Question about mangling of passphrases 
What happens is there are multiple hashes done so there will always be
enough bits of hash to fill in the key bits.  Each additional hash
beyond the first is preloaded with an increasing number of zeroes to
force the resulting hash to be different.
This is documented in RFC-2440, if you want to read more about it.
Look for the "String-to-key (S2K) specifiers" section.

@_date: 2002-03-17 23:57:01
@_author: David Shaw 
@_subject: Problem with --not-dash-escaped 
Can you post a short sample signature that did not work?  Also, sort
of key are you signing with?

@_date: 2002-03-19 22:42:03
@_author: David Shaw 
@_subject: gpg subkeys, revisited 
GnuPG does not currently allow importing secret subkeys.  In your
particular example where you have two different copies of the secret
key, each with a different subkey, you are going to have a
difficulties.  It's not exactly a common problem. :)
The solution is to generate one key from your two, and import that.
To do this, you need the "gpgsplit" tool, which is part of GnuPG 1.0.7
(grab the test version from
ftp://ftp.gnupg.org/gcrypt/devel/gnupg-1.0.6d.tar.gz if you need it).
Run one of the keys through gpgsplit and delete all the files that
come before the first "XXXXXXX-007.secret_subkey" file.
Then cat the key you didn't split along with the files that are left
after you deleted everything before the secret subkey.
For example:
$ gpgsplit mykey2
$ rm 000001-005.secret_key 000002-013.user_id 000003-002.sig
$ cat mykey1 000004-007.secret_subkey 000005-002.sig > mywholekey
$ gpg --allow-secret-key-import --import mywholekey

@_date: 2002-03-20 00:14:01
@_author: David Shaw 
@_subject: 1.0.6d, 1.1.x and big keyrings 
GnuPG 1.0.6d is (or rather, will be) 1.0.7, it just needs some more
work and testing.
Several people (including me) are running 1.0.6d quite happily.
Still, it is a development version.  There is a reason it prints a
warning on startup: "NOTE: THIS IS A DEVELOPMENT VERSION!  It is only
intended for test purposes and should NOT be used in a production
environment or with production keys!"
If you do choose to give 1.0.6d a try, be sure to report any problems
back to gnupg-devel so they can be fixed.
The 1.1.x versions in the devel directory are actually older in terms
of code than 1.0.7. :)

@_date: 2002-03-20 18:48:01
@_author: David Shaw 
@_subject: Which keyring for Public Keys ? 
Both :)
The private keyring stores private keys (presumably your own).  The
public keyring stores your own and other peoples' public keys.
However - each private key also contains a copy of its corresponding
public key.  If you ever lose all copies of your public key
(unlikely), you could regenerate it (minus signatures from other
people) from the private key.

@_date: 2002-03-23 01:23:01
@_author: David Shaw 
@_subject: gpg New Bee 
There is no command line option to handle this case, as generally
people don't encrypt to themselves multiple times.
That said, you can still do it - just hit "enter" three times when
prompted for the passphrase for the key you don't want to use.  This
will make GnuPG roll over and try the next available key.
Good job on "Rhapsody in Blue", by the way ;)

@_date: 2002-03-25 20:16:02
@_author: David Shaw 
@_subject: Key IDS 
What shell are you using?  That's a SH-ish shell line, but the error
message is from csh or a near relative.
Try the command using sh or bash.  If you must do it with csh, try
gpg --batch --decrypt --list-only --status-fd 1 | awk '/^\[GNUPG:\] ENC_TO / { print $3 }'

@_date: 2002-03-25 20:25:08
@_author: David Shaw 
@_subject: cannot receive certain keys 
Generally, "no valid OpenPGP data found" means just that - the key is
not found on the server.
However, the certserver.pgp.com keyserver is having problems right
now, so you shouldn't take that error message too seriously.  Try
another keyserver.
It's unclear what, if anything, will happen with the
certserver.pgp.com keyserver with the recent changes at pgp.com.
People have been asking on the keyserver operators list, but no
answers yet.

@_date: 2002-03-26 00:55:02
@_author: David Shaw 
@_subject: Changing from long UID to UID 
I assume you mean key ID?  The regular or short key ID is just the
lower half of the long key ID.
For example:
Long keyID:  DB698D7199242560
Short keyID:         99242560
Incidentally, for OpenPGP keys (DH/DSS or v4 RSA) you can do the same
trick with "how do I get a key id from a fingerprint".
Fingerprint: 7D92FD313AB6F3734CC59CA1DB698D7199242560
Long keyID:                          DB698D7199242560
Short keyID:                                 99242560

@_date: 2002-03-26 19:28:02
@_author: David Shaw 
@_subject: FAQ item?: Using GnuPG in a business 
With the recent changes at NAI/pgp.com, there has been a definite
upswing with the "can I legally use GnuPG in my business?" questions.
While the GPL discussions are interesting, I suspect that the majority
of the people asking this question are companies that just want to use
GnuPG now that they can't use PGP.  Most questions of code
modification or distribution don't apply to them - they just want a
PGP-alike to use.  Naturally, the GPL lets them do this.
Could someone write this up and stick it on a web page somewhere?  If
nobody jumps at it, perhaps I'll have a crack at it in a couple of
days.  The idea here is to make it very clear that if they're just
talking about using it (rather than making their own version and
distributing the changes, or whatever else), then they don't need to
bother to read beyond the first paragraph.
Maybe this should be a FAQ - I saw Douglas Calvert volunteered to be
the new FAQ maintainer.

@_date: 2002-03-26 22:40:01
@_author: David Shaw 
@_subject: FAQ item?: Using GnuPG in a business 
Yes, that's exactly what worries me about the current documentation
and web pages.  The fact that it took you that long to be sure the GPL
allowed you to use GnuPG freely means that it just isn't clear enough.
The GPL gives users many wonderful things, but a good-sized piece of
the "target market" for GnuPG simply don't care about modifying the
code or redistributing it.  What is needed for those people or
businesses is a simple statement that says "Yes, it's free.  No, there
are no licencing fees.  No, there are no patent issues.  Take it and
enjoy using it.  If you want more help than is available for free on
the Internet, then these three companies will even sell you support
for it."

@_date: 2002-03-26 23:14:02
@_author: David Shaw 
@_subject: Announcing a tool to restore original filename automatically 
I'm not sure I fully understand this.  Why not just use the
--use-embedded-filename flag?

@_date: 2002-03-27 06:39:02
@_author: David Shaw 
@_subject: Announcing a tool to restore original filename automatically 
Hey, no worries.  It's a pretty big manual - easy to miss stuff in

@_date: 2002-03-30 17:32:01
@_author: David Shaw 
@_subject: Problem importing a secret key 
This is not correct - the secret key should contain everything in the
public key except for key signatures (other than the self-signature).
It's possible you don't have a user ID packet in your secret key for
some reason.  Can you tell me what GnuPG displays when you add
--verbose to your command line?

@_date: 2002-03-30 17:32:06
@_author: David Shaw 
@_subject: FAQ item?: Using GnuPG in a business 
There are several pieces of information that need to be mentioned in
the answer for this question.  The thing that I think is most
important, though, is that it is very clear very early in the answer
that it is just fine to use it in a business and there are no licence
fees or contracts to be signed.  A lot of the free software documents
on the net are very good and very complete but don't really get to the
heart of the question for a business that just wants to use it (as
opposed to distribute, modify, and so on).
Many business folks don't really understand free software, and we
should make their first experience with it be as painless and happy as
possible :)

@_date: 2002-03-31 03:05:01
@_author: David Shaw 
@_subject: --compress-algo 
The default for --export is already uncompressed.  If you want to
compress keys, use --compress-keys along with the usual
Note that GnuPG can import compressed keys just fine, but if you
compress outside of GnuPG (with gzip or bzip2 or whatever), then
you'll need to uncompress it yourself before --importing it back into

@_date: 2002-03-31 22:25:01
@_author: David Shaw 
@_subject: Restrictions / Commercial Use? 
This is correct.  Use it commercially, use it non-commercially, use it
for whatever you like.  Have fun.
However, if you want to use the IDEA cipher then the situation changes
a little.  The IDEA cipher is patented by a Swiss company called Ascom
Systec Ltd.  They require a licence for commercial use.
GnuPG does not come with IDEA, despite what people may have added to
their own copies of the distribution.  You don't even need IDEA unless
you are trying to communicate with a user who uses certain versions of
PGP 2.  Since the current version of PGP is 7, it's been a few years
since PGP 2...

@_date: 2002-05-01 04:23:01
@_author: David Shaw 
@_subject: Makefile errors? 
Yes.  The problem is a very old install of OpenLDAP on the RedHat box.
I've fixed the GnuPG autoconf (it'll be in 1.0.8) to work properly in
that case.
In the meantime, you can successfully build on the RedHat box if you
run configure as "./configure --disable-ldap"

@_date: 2002-05-01 17:38:01
@_author: David Shaw 
@_subject: gpg 1.07  updating trust  ?quicker way 
gpg --update-trustdb
rebuild-keydb-caches is used for other things.

@_date: 2002-05-02 00:43:02
@_author: David Shaw 
@_subject: 1.07 and v3 rsa signatures 
The bug in 1.0.6 was if a message was signed with a v3 key, then PGP
couldn't verify the signature (GnuPG could, of course).  1.0.7 fixes
that bug, and now anyone can verify a signature from a v3 key.
Works for me (and the others who tried and posted).  Try saving it to
a file and not going via the clipboard and WinPT.

@_date: 2002-05-02 14:27:02
@_author: David Shaw 
@_subject: Keyserver question - key id 
This is a bug in the pks keyserver software that runs on pgp.net.
Basically, it assumes if your key is RSA (as your second key is) then
it must be a v3 key.  Key IDs are calculated differently for v3 (PGP
2-ish) and v4 (OpenPGP) keys.  The bug is that the server is
calculating key IDs for v4 RSA as if they were v3 RSA, causing the
weird key ID change that you saw.
Luckily, this does not harm the key in any way.  The key is stored
properly on the keyserver and is not damaged, but you just can't find
it using the keyID.
There is a workaround in GnuPG for this problem, but since GnuPG needs
to already have the key to calculate what the bogus key ID is, it only
works when doing a --refresh-keys.  To enable the workaround, add
"refresh-add-fake-v3-keyids" to your keyserver-options in your options
file.  Hopefully that option can go away at some point.
If you use one of the other keyserver types (try
gnv.us.ks.cryptnet.net), you should not have this problem.
Unfortunately, --search-keys does not work yet on the cryptnet.net

@_date: 2002-05-02 22:23:01
@_author: David Shaw 
@_subject: gpg --pgp2 and sign+encrypt 
No.  The main difference is that GnuPG will now error if you try to do
it with --pgp2 set, rather than generate a message that PGP 2.x won't

@_date: 2002-05-02 22:59:01
@_author: David Shaw 
@_subject: gpg --pgp2 and sign+encrypt 
I should expand on this a bit.
1.0.6 behavior:
    sign+encrypt with a v3 key: signature that only GnuPG can use
    sign+encrypt with a v4 key: signature that all versions of GnuPG
    and PGP except PGP 2.x can use
1.0.7 behavior:
    sign+encrypt with a v3 or v4 key: signature that all versions of
    GnuPG and PGP except PGP 2.x can use
GnuPG can make clear signatures and detached signatures for PGP 2.x.
The only thing that it does not do is encrypt+sign for PGP 2.x.

@_date: 2002-05-03 18:28:01
@_author: David Shaw 
@_subject: Problems understanding IDEA problem :-) 
Well, there is certainly a problem.  If CryptoEx follows the OpenPGP
spec, What I suspect happened is this:
The John Doe key looks like an PGP 2 style (v3) RSA key, which
generally means "IDEA only".  Since CryptoEx needs a cipher algorithm
that both you and John Doe can handle, it joins John Doe's cipher
prefs (IDEA) with yours (AES, CAST5, 3DES), comes up with no match,
and picks IDEA.
This is legal, but not recommended, according to OpenPGP ("... an
implementation MAY, but SHOULD NOT use IDEA in an algorithm conflict
with a V3 key.").
All in all, yet another reason not to use v3 keys. :(

@_date: 2002-05-04 22:56:01
@_author: David Shaw 
@_subject: Automatic resyncing of keys? 
That's not a bug.  That's inherent in the design of the keyservers.
If a program asks for "X" and two keys have key ID "X", then you get
them both.  Nothing can be done about that.  Of course, you won't have
any trust in the other key.
GnuPG will use the maximum key ID size it can.  If you are using
--refresh with a LDAP keyserver, it uses the 64-bit key ID which makes
this sort of thing much less likely.  Of course, there is only one
LDAP keyserver left for public use.

@_date: 2002-05-05 03:25:02
@_author: David Shaw 
@_subject: GPG private key still does not work with PGP 
GnuPG uses a different (more secure) method to store the secret key
data.  If you want to use it in PGP, you must do these two steps:
Change the key to the older, less secure format:
  gpg --simple-sk-checksum --edit (yourkeyid)
  Use "passwd" to change the password.  You can change it to anything,
  even right back to the current password if you like.
Export the secret key:
  gpg --no-comment --export-secret-keys -a -o sec.asc

@_date: 2002-05-05 03:59:02
@_author: David Shaw 
@_subject: Automatic resyncing of keys? 
"... for public use."
I'm sure there are dozens that aren't available for public use.

@_date: 2002-05-05 14:48:01
@_author: David Shaw 
@_subject: Automatic resyncing of keys? 
I agree.  --refresh-keys will now discard new keys.

@_date: 2002-05-06 22:53:01
@_author: David Shaw 
@_subject: Nullify's GnuPG 1.0.7 Release 2 
Reasonably easy, but the end result would be a v4 key with a different
keyid and fingerprint, so there is little point: it couldn't be used
(without some code munging to get the ids right) to decrypt things
that were encrypted by it's v3 cousin.  You'd also lose any signatures
on that key.
However, v3 RSA keys can be made into subkeys on a v4 key very easily
and they still work just fine.  GnuPG and PGP both support this, but I
wouldn't expect all OpenPGP implementations to permit it.  You still
lose the signatures though.

@_date: 2002-05-06 23:12:02
@_author: David Shaw 
@_subject: Assigning Primary User ID? 
It is a Good Thing.  The only major drawback is that it makes PGP 2.x
reject your key.  You can keep a copy of the key pre-change for the
PGP 2.x users of course.

@_date: 2002-05-07 16:59:02
@_author: David Shaw 
@_subject: Compile gnupg-1.0.7 on Compaq Tru64 
Content-Disposition: inline
This is fixed in 1.0.8.  In the meantime, you can apply the attached
patch to util/memory.c.

@_date: 2002-05-08 14:28:02
@_author: David Shaw 
@_subject: Making it simple 
This is one of the things I fixed with the improved PGP compatibility
in 1.0.7.  The problem is that PGP keys don't give any preferences for
compression algorithms, so GnuPG would default to 2.

@_date: 2002-05-08 15:53:02
@_author: David Shaw 
@_subject: Install problem 
Yes.  The OpenLDAP that comes with RH 6.2 is pretty old.  If you don't
need LDAP keyserver upport, you can also skip it by specifying
--disable-ldap when you run ./configure.

@_date: 2002-05-08 17:04:02
@_author: David Shaw 
@_subject: Install problem 
That will work as well (GnuPG 1.0.8 has something similar), but I do
not want to make autoconf checks for lber.h as there are other ldap
libraries that could be used here, and I also did not want to
encourage people to use the old OpenLDAP.  If this becomes a problem
(it seems to be getting there), then I could reconsider.

@_date: 2002-05-09 16:31:02
@_author: David Shaw 
@_subject: MAX_RESOURCES under 1.0.7 
I believe (though have not tested) what you are looking for is
MAX_KEYDB_RESOURCES, set in keydb.c.

@_date: 2002-05-11 00:07:01
@_author: David Shaw 
@_subject: Making it simple 
No preference for hash means "SHA1".  No preference for compress means
"ZIP, Uncompressed".
Hash doesn't matter much, since nobody uses the hash preference yet.
It depends if they have v3 (PGP2-style) or v4 self-sigs.  If the
self-sig is v4, they have the same default preferences as any v4 key:
3DES for cipher, SHA1 for hash, and ZIP+Uncompressed for compression.
If they have a v3 self-sig, they have no preferences at all, but
generally this is interpreted as IDEA for cipher, MD5 for hash and ZIP
for compression.
At least this is GnuPG's behavior.  PGP seems to ignore the compress
preference completely and uses ZIP for everything.
This client is violating the standard.  Ah well.  It doesn't actually
hurt you since you can decrypt AES (though GnuPG will warn you that
someone is using a cipher that isn't in your preferences).
You might be able to script something with gpg --list-packets, but the
problem is that the data you need is usually inside the encrypted
block.  You have to decrypt the message to see them.

@_date: 2002-05-13 01:11:01
@_author: David Shaw 
@_subject: Making it simple 
If it's a v3 sig, by definition there are no preferences. ;)
Not ok - PGP uses ZIP even if the preference is Uncompressed.

@_date: 2002-05-13 02:30:02
@_author: David Shaw 
@_subject: Adding photos 
All photos on keys are JPEG, as the standard requires that.  What PGP
does when you paste a photo into the little box is do a quick
conversion from whatever you pasted into a JPEG :)
The difference is that GnuPG wants a JPEG from the start.  You might
try dialing up the compression level a bit higher to see if you can
get the image smaller.  There are a number of tools out there (usually
intended for web use) that are excellent at taking an image and
spitting out a very optimized JPEG.

@_date: 2002-05-13 15:58:01
@_author: David Shaw 
@_subject: /dev/null ownership and moving keys 
The permissions warning on /dev/null is a bug.  You can safely ignore

@_date: 2002-05-13 18:12:01
@_author: David Shaw 
@_subject: configure produces zero length Makefile 
This was fixed.  It now checks $PATH, /usr/sbin, /usr/libexec, and

@_date: 2002-05-14 01:16:01
@_author: David Shaw 
@_subject: protection algorithm 254 is not supported 
* Secret keys are now stored and exported in a new format which
      uses SHA-1 for integrity checks.  This format renders the
      Rosa/Klima attack useless.  Other OpenPGP implementations might
      not yet support this, so the option --simple-sk-checksum creates
      the old vulnerable format.
Basically, you need to --edit your key on 1.0.7 with
--simple-sk-checksum set.  Change the passphrase (you can even change
it back to itself if you like).  Then export.

@_date: 2002-05-15 00:37:02
@_author: David Shaw 
@_subject: User ID length requirement 
It is not part of the spec.  You can turn off the check and put
whatever you want in the user ID with the '--allow-freeform-uid' flag

@_date: 2002-05-16 00:15:01
@_author: David Shaw 
@_subject: using a key without self-signature 
No.  If it doesn't have a self-sig, and you don't want to use the
--allow-non-selfsigned-uid option, then there is nothing you can do,
aside from asking the key owner to sign it.
Why don't you want to use allow-non-selfsigned-uid ?

@_date: 2002-05-16 14:23:02
@_author: David Shaw 
@_subject: using a key without self-signature 
This is one of those things that I agree we should support, but also
try and get people not to use.  It has the valid purpose of putting
the user in control of what keys are considered valid.  Unfortunately,
I suspect that it'll be used as a finer-grained allow-non-selfsigned,
which is not necessarily the right (most secure) thing to do.
In virtually all cases, the owner of the non selfsigned key has the
ability to selfsign it.  We should enourage people to get the key
signed by the owner, and use this only as a last resort.

@_date: 2002-05-16 14:37:01
@_author: David Shaw 
@_subject: signing & encrypting 
Maybe not in one or two sentences ;)
In an encrypted, but not signed message, it is theoretically possible
to modify the message by inserting more encrypted bytes into the
middle.  Sort of like transforming "Hi Fred, I hope you are well" into
"Hi Fred, you rotten bastard, I hope you are doing badly and soon fall
down a well".
Signing prevents this problem, as the signature would not be valid on
a modified message.  However, GnuPG also supports the MDC
(modification detection code) feature of OpenPGP which includes a
mini-signature inside the encrypted data which can also prevent this
without signing.
Other way around - when you encrypt and sign, you are doing

@_date: 2002-05-17 19:54:01
@_author: David Shaw 
@_subject: Symmetric cipher selection order, RSA keys 
(Sorry - missed this message when it was first posted)
Anyway, GnuPG will pick either AES or CAST5 in this case, depending on
the order in which the keys are given during encryption.  You can
influence these choices with --cipher-algo (which forces a given
algorithm, disregarding the preferences), and --disable-cipher-algo
which removes a given algorithm from the available list.

@_date: 2002-05-20 14:31:01
@_author: David Shaw 
@_subject: MDC & Symmetric 
Yes.  Since unlike PK encryption, there is no way to tell if the
recepient can handle it, it is off by default.  You usually need to
turn it on via --force-mdc.  It is on by default on all of the >128bit

@_date: 2002-05-20 14:33:01
@_author: David Shaw 
@_subject: Internal File Structure 
You can get some information, but a encrypted document looks the same
as an encrypted and signed document - all you can see is the encrypted
blob and the session keys.  You can't tell what's inside to tell if it
is signed or not without decrypting the blob.

@_date: 2002-05-21 13:56:01
@_author: David Shaw 
@_subject: MDC & Symmetric 
Sorry - I did indeed mean block size, and not key size.  However, what
you say above is not correct: it's block size > 128.  AES128 is not
included here.

@_date: 2002-05-22 16:18:01
@_author: David Shaw 
@_subject: Symmetric cipher selection order, RSA keys 
After thinking about this some more, I think that a list of algorithms
that the user favors is a good idea.  I've added
"--personal-preference-list" to the CVS.  GnuPG will take this list
into account when picking algorithms.
You can't use it to violate the RFC by forcing an algorithm that the
recepients do not have - it only applies to cases where there are
common algorithms among all recepients and in the personal preference

@_date: 2002-05-27 02:09:01
@_author: David Shaw 
@_subject: photo in gpg key 
On some platforms (including all Windows platforms), you need to use
temp files while displaying photos.  The default photo viewer is
correct for Unix platforms, but not Windows so you need to set a
viewer in your options file like "photo-viewer myviewer.exe %I".
Some photo viewers don't work properly on Win32 without a patch to the
code, but give it a try.  1.0.8 (or whatever the next version is) or
the CVS version have better Win32 support for photos.

@_date: 2002-05-28 00:51:04
@_author: David Shaw 
@_subject: "--honor-http-proxie error" 
You can ignore this error if you like (it's just a warning).  The
problem is that your config file has the line:
  honor-http-proxy
and as of GnuPG 1.0.7, the option to do that is
  keyserver-options honor-http-proxy
If you stick a "keyserver-options" in front of the "honor-http-proxy"
the warning will go away.
I'd need to see what you have on line 123 :)

@_date: 2002-05-29 01:49:02
@_author: David Shaw 
@_subject: gpg keyservers allowing photos in key-id's 
Unfortunately, the majority of keyservers do not allow photos.
Luckily, unlike the multiple-subkeys-ate-my-key bug, it doesn't cause
any harm.  Instead, it will just not accept the photo part of the key.
All pks keyservers (a la "wwwkeys.pgp.net", "pgp.mit.edu", etc.) do
not accept photo IDs.
All LDAP keyservers (ldap://pgp.surfnet.nl:11370) do allow them.
I don't know offhand about the Cryptnet and Openkeyserver servers.

@_date: 2002-05-29 02:34:02
@_author: David Shaw 
@_subject: gpg keyservers allowing photos in key-id's 
It does not work this way in the case of photo IDs.  If keyserver A
and B synchronize, and A accepts photo IDs and B does not, then if you
send your key to B, it will remove the photo ID before sending it to
In practical terms, this means that if you want your photo ID to be on
a keyserver, you must send it to a keyserver that supports photo IDs
and let the other keyservers learn it from there.
Note that ldap://pgp.surfnet.nl:11370 does support photo IDs, but your
key does not have a photo ID on that server.

@_date: 2002-05-30 13:53:02
@_author: David Shaw 
@_subject: Q about (self-) signatures 
Not currently, no.
30 is "features" - various flags to show what your OpenPGP
implementation knows how to handle.  The feature that corresponds to
bit 1 (actually the only feature defined thus far) is MDC.
It's specified in 2440bis, the draft to replace 2440.

@_date: 2002-11-02 16:20:01
@_author: David Shaw 
@_subject: cypher algorithm - which one? 
It's a difficult question, because it's sort of an apples-and-oranges
comparison.  It really depends on what you are using the key for.  a
1024bit DSA signing key is generally felt to be more or less as secure
as the 160-bit hash that it uses.  If you make a bigger DSA (and this
is technically possible, though GnuPG and PGP follow the spec and stop
after 1024), you still have that 160-bit hash as your weak point.

@_date: 2002-11-02 16:22:02
@_author: David Shaw 
@_subject: Key with no signing possibilities 
Most OpenPGP "keys" are actually two different keys stuck together -
one signing key, and one encryption key.  It is technically possible
to make an encrypt-only key (which would be a single key), but this is
unusual enough that it may not be widely supported.

@_date: 2002-11-03 05:24:02
@_author: David Shaw 
@_subject: unable to encrypt to one specific user 
This key is probably not self-signed.  Try retrieving the key from a
keyserver and you'll get the missing bit.

@_date: 2002-11-03 23:36:01
@_author: David Shaw 
@_subject: Problem with keyservers 
a
You have the ability to create whatever key type you like... and the
keyservers have the ability to accept whatever key types they like ;)
The LDAP keyservers do not accept ElGamal sign+encrypt keys.  Not
surprising, really, since the LDAP keyserver was written by NAI and
NAI's PGP didn't support that sort of key.  (Neither does PGP's PGP
8).  I'm afraid your only answer is in fact to change your key type or
only use the HKP keyservers.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-11-04 00:39:02
@_author: David Shaw 
@_subject: Problem with keyservers 
Of course.  1.2.1 comes with support for HKP, LDAP, and email
keyservers (and DNS keyservers via Simon Josefsson's plugin).
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-11-05 19:54:02
@_author: David Shaw 
@_subject: Possible Feature Request (was Re: Security Concerns) 
Not really.  The keyid in a signature packet is really just there for
the convenience of the receiving program.  Since the public key can
effectively point to the key owner, and (by definition) the public key
is public, you don't gain anything by hiding the keyid.
The only true way to avoid announcing that you've signed something is
to keep your public key private (or as private as possible).

@_date: 2002-11-05 20:52:01
@_author: David Shaw 
@_subject: Feature request 
s. It
They're not :)
Where?  If the key is revoked and you (for example) verify a signature
from it, it has a very loud message..
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-11-05 23:48:02
@_author: David Shaw 
@_subject: Feature request 
--edit-key does show revoked user IDs, but it says "[revoked]" next to
them.  --list-keys does not show revoked user IDs unless you use -v,
and it says "[revoked]" then as well.
Incidentally, the same thing happens (with "[expired]") for expired
user IDs.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-11-06 00:51:01
@_author: David Shaw 
@_subject: another little thing 
st it
I guess I can see the idea of a "send" command, though it would really
need to be a "save-and-send" command (just like "save" is really
"save-and-quit") for sanity's sake.  I don't see the benefit of
"refresh" though.  What would be the point there?
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-11-06 23:03:02
@_author: David Shaw 
@_subject: [Announce]GPGRemail v0.1 initial announcement 
Content-Description: signed data
There is also the possibility of using --throw-keyid to anonymize the
recipients.  Then you can do the latter, which allows you to benefit
from SMTP optimizations (sending mail to multiple users in given
domain but only transmitting it once, etc.)
The development GnuPG has much finer control over anonymous recipients
than 1.2.1.  You can turn the hiding on and off on a per-recipient

@_date: 2002-11-06 23:34:01
@_author: David Shaw 
@_subject: ^M characters are embedded at the end of every record. 
The problem is the different line endings on the Windows and Unix
platforms.  The solution is, when encrypting, make sure you tell your
encryption program that the file is text.  If you have GnuPG on the
Windows side, use the --textmode option.  If you have PGP, there is a
checkbox for "input file is text".
Then, when the file is decrypted on the Unix side, the receiving
program knows what to do about the line endings.

@_date: 2002-11-06 23:45:01
@_author: David Shaw 
@_subject: ^M characters are embedded at the end of every record. 
--armor is --armor (or --armour ;) )
--text is --textmode

@_date: 2002-11-07 06:26:02
@_author: David Shaw 
@_subject: Key ID - different? 
There is a short version because that's what everybody got used to
with PGP 2.x.  The long version has always been used internally since
the short version has a much larger chance of "accidentally"
duplicating someone elses keyid.
Jason Harris has a nice list up that shows dozens of duplicated keyids
at

@_date: 2002-11-08 04:35:01
@_author: David Shaw 
@_subject: Multiple keyring support 
I just committed a feature to do this on the development version of
GnuPG if anyone is interested in playing with it.  Use
"default-keyring" to denote the keyring that you want imports to go to
by default.  You may change it on the command line as well.  If you
don't specify a default-keyring, then the behavior is unchanged -
imports will go to the first writable keyring.

@_date: 2002-11-10 00:19:01
@_author: David Shaw 
@_subject: Icq 
Note that the "gabber" Jabber client uses GnuPG for encryption.  I
don't use it myself, but I have heard it is quite nice.  I believe the
gabber folks plan to remove GnuPG support and replace it with
something Jabber-specific.

@_date: 2002-11-10 20:56:01
@_author: David Shaw 
@_subject: Key servers 
dk.pgp.net is down for a few weeks while they rebuild a dead server.
Right at the moment, the only keyservers I can really recommend are:
  hkp://keyserver.kjsl.com
  ldap://pgp.surfnet.nl:11370
  ldap://keyserver.pgp.com
Pretty much all of the others suffer from the multiple-subkey
corruption bug or are still non-production test servers.  If your key
only has one subkey, then any of the pgp.net servers will work.

@_date: 2002-11-10 20:57:02
@_author: David Shaw 
@_subject: Icq 
This was a bug in 1.0.7.  It was fixed in 1.2.0, so it should work in
any version after that.

@_date: 2002-11-11 00:33:01
@_author: David Shaw 
@_subject: Compiling 1.2.1 on BSDI 4.1 and 4.3 and I get the same failures on gmake test 
Can you send me your mds.test.log and sigs.test.log files?  They will
be in your checks/ directory.

@_date: 2002-11-11 05:11:02
@_author: David Shaw 
@_subject: Key servers 
Like I said, if your key only has one subkey, you can use any server
you like.

@_date: 2002-11-11 18:56:01
@_author: David Shaw 
@_subject: conventional encryption with passphrase remaining blank? 
Why encrypt at all?  "gpg --sign file" outputs the original file and a
signature together in one file.

@_date: 2002-11-13 12:03:02
@_author: David Shaw 
@_subject: [Announce]GnuPG 1.3.1 released (development) 
The latest release from the development branch of GnuPG is ready for
public consumption.  This is a branch to create what will be GnuPG 1.4
someday.  It will change much more frequently than the 1.2.x "stable"
branch, which will mainly be updated for bug fix reasons.
The more GnuPG-familiar user is encouraged try this release (and the
ones that will follow in the 1.3.x branch), and report back any
problems to gnupg-devel  In return, you get the latest code
with the latest features.  However, it is always important to keep in
mind that this is still development code - please do not use it on
anything mission-critical.  Critical applications should always use
the 1.2.x stable branch.
You may notice the smaller tarball size for these development
releases.  This is due to the translations other than de being
removed.  You may also notice the smaller size of the compiled gpg
binary, and that is due to some of the keyserver modifications.  See
the list below for more changes.
The files are available From: ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.1.tar.gz (1506k)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.1.tar.gz.sig
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.0-1.3.1.diff.gz (167k)
MD5 checksums for the files are:
  bbfd0613a3309e10b2d8b9d7d08bbe8a  gnupg-1.3.1.tar.gz.sig
  eaf6fd07ca5088c3f1589c20718b81d7  gnupg-1.3.1.tar.gz
  55ef3ce7ae7532e5f377ea963b33d20e  gnupg-1.3.0-1.3.1.diff.gz
Noteworthy changes in version 1.3.1 (2002-11-12)

@_date: 2002-11-14 21:40:05
@_author: David Shaw 
@_subject: Automatically Signing Keys? 
Try this:
printf "%s" "password" | gpg -u [CA-KeyID] --status-fd 1 --passphrase-fd 0 --batch --yes --edit [KeyID-to-be-signed] sign save

@_date: 2002-11-14 23:09:02
@_author: David Shaw 
@_subject: Is ZIP compress-algo 1 or 2 ? 
The --version output is correct.  I'll fix the manual.  ZIP is
algorithm 1 and ZLIB is 2.
However, you shouldn't need to put compress-algo in your options file.
The default is correct and will automatically do the right thing for
PGP users (uses ZIP) and GnuPG users (uses ZLIB).  There are a few
extreme cases where you must use compress-algo, but it should not be a
common thing.
This wasn't always true, which is why you often see the advice to use
compress-algo, but it hasn't been true since GnuPG 1.0.7.

@_date: 2002-11-15 05:56:02
@_author: David Shaw 
@_subject: Multiple keyring support: GPGV 
It could be used for that, but the easiest way to add new keys to
trustedkeys.gpg is:
gpg --export (key_to_add) >> ~/.gnupg/trustedkeys.gpg
Incidentally (I mentioned this on gnupg-devel as well), the name
'default-keyring' stinks a bit as there is already a concept of a
default keyring, and it has nothing to do with this.  Any suggestions
for something better? --writable-keyring? --use-keyring? --import-keyring?

@_date: 2002-11-17 22:06:02
@_author: David Shaw 
@_subject: a version of GnuPG for SUN Solaris 
There are many reasons, security and otherwise, not to use GnuPG
1.0.0.  What is wrong with using 1.2.1?

@_date: 2002-11-17 22:09:02
@_author: David Shaw 
@_subject: User ID 
There should not be any, but there are issues with going back and
forth between 1.0.6 and 1.2.x.
You will need to do three things after upgrading:
1) gpg --rebuild-keydb-caches
2) Run "gpg --edit" on each of your own keys, and make them ultimately
   trusted (i.e. "trust", "5").
3) gpg --check-trustdb

@_date: 2002-11-17 22:19:02
@_author: David Shaw 
@_subject: Multiple keyring support: GPGV 
I agree with you, but agree enough that I have similar problems with
--use-keyring and --active-keyring.  ;) "use" and "active" implies
that the other keyrings aren't being used or active, which isn't
really true.  I guess use-keyring is closest, but it is not very clear
what it means from the option name - someone would have to go and read
the manual to know what it means.

@_date: 2002-11-17 23:03:01
@_author: David Shaw 
@_subject: User ID 
--edit-key is the real command name.  --edit will work as it is a
nonambiguous shortening of the name.  Any of the GnuPG commands and
options can be shortened that way.  Even "ed" works to mean "edit".

@_date: 2002-11-17 23:52:01
@_author: David Shaw 
@_subject: Compiling and using v1.2.1 on Solaris. 
The FAQ item refers to keyrings from 1.0.7 used on 1.0.6.  Your
problem seems to be something else.  "packet too short" generally
means the original encrypted file was truncated or otherwise

@_date: 2002-11-18 20:39:01
@_author: David Shaw 
@_subject: Can signing subkeys certify keys? 
The OpenPGP standard does not specify a trust model, so you can
theoretically use a signing subkey for anything you like.  However, as
a practical matter it is not a good idea.  The web of trust is built
by signatures from primaries on primaries, so a subkey signature would
not be usable as part of the web of trust.  Because of this, signing
subkeys are only permitted to sign data and not other keys.
The --with-colons listing is incorrect here, and has been fixed for
the next release of GnuPG.

@_date: 2002-11-18 21:01:01
@_author: David Shaw 
@_subject: Stop me from beating myself. 
Which PGP 8 beta are you using?  The early betas had some problems in
this regard.  You can find the PGP build number in the "About PGP..."
(Let's move this to gnupg-users or pgp-users - it's not really
relevant to the keyserver operators list).

@_date: 2002-11-18 22:22:02
@_author: David Shaw 
@_subject: Can signing subkeys certify keys? 
Since you are only concerned about local signatures, one thing you
could do is just make yourself a key that you don't use except to sign
keys locally.  Just don't send this local-only key to a keyserver ;)

@_date: 2002-11-19 02:06:01
@_author: David Shaw 
@_subject: Will GPG use Dual Processors under Windows ? 
It does not.  There are some things you might try to speed up the
process, though.  First of all, if you turn off compression, you save
some CPU time, though at the cost of a larger file size.  Secondly,
choose your ciphers with care.  Don't use 3DES if you can possibly
avoid it.  While it is the most highly thought of in terms of
security, it is also the slowest cipher by far.
Note that you can take advantage of multiple CPUs if you split up the
work intelligently - for example, say you want to encrypt and
compress.  If you have GnuPG encrypt, and a different program compress
then you can keep both CPUs busy.  Also, if you break your 10 gig file
into 2 5 gig files, then you can run two instances of GnuPG at once.

@_date: 2002-11-19 22:22:01
@_author: David Shaw 
@_subject: --group questions 
gpg --group testgroup="0xkeyidtest1 0xkeyidtest2"
There are no --list-xxx commands since the group command is not
persistent unless you put it in your gpg.conf file... and in that
case, you don't need a --list-xxx command ;)

@_date: 2002-11-20 00:14:02
@_author: David Shaw 
@_subject: Personal prefs (was Re: --group questions) 
Not combined, since that could violate the standard by forcing the use
of an algorithm that the recipient is unable to use.  Instead, the
personal lists are used to limit what the keyholder may request.  In
the example you give, the result will be the empty set since there are
no common algorithms chosen.  This will result in
An easy way to think about the personal prefs is as an additional
recipient that doesn't actually get the message, but does have
preferences that must be taken into account.

@_date: 2002-11-20 14:26:02
@_author: David Shaw 
@_subject: Personal prefs 
Pretty much.  Each recipient has a list of algorithms on their key,
you have a list of algorithms in your config file.  GnuPG takes the
intersection of all of these lists and uses it to pick the algorithms
for that message.  If the cipher intersection is empty (i.e. if you
allow only CAST5 and AES, and your recipient allows only TWOFISH and
BLOWFISH), then 3DES is used.  If the hash intersection is empty, SHA1
is used.  If the compression intersection is empty, the message is not

@_date: 2002-11-20 14:29:01
@_author: David Shaw 
@_subject: Personal prefs (was Re: --group questions) 
Yes.  Putting cipher-algo or digest-algo in gpg.conf should really
only be used in very special circumstances.  The prefs functions let
you do the same thing, but in a safe manner that won't generate
messages that violate the recipients preferences.

@_date: 2002-11-20 18:18:01
@_author: David Shaw 
@_subject: Personal prefs (was Re: --group questions) 
This is correct.  Preferences are only consulted when encrypting or
encrypt+signing.  When you are only signing, there is no "recipient"
to consult the preferences for, so none of the preference calculations
are invoked and the hash used is whatever --digest-algo is set to.
I see the problem though.  Perhaps it would be good to have
--digest-algo default to the most highly ranked
--personal-digest-preferences value instead of SHA1.  Then it would be
possible to put it into the gpg.conf file without running the risk of
using a hash that the recipient coult not use.

@_date: 2002-11-21 14:10:02
@_author: David Shaw 
@_subject: Personal prefs 
Of course.  This would not change that.  The issue is that currently
personal-digest-preferences works only if there is a recipient
(i.e. encrypt+sign).  The user must use digest-algo to set the digest
for sign-only and sign+symencrypt.  This is not desirable since
digest-algo overrides ALL digests and therefore cannot be used in the
config file due to possibility of forcing a digest the recipient can't
handle.  There is no way to safely just set the desired value, so
users must remember to change the digest value each time they sign.
With this change, if the user hadn't set digest-algo, but had set
personal-digest-preferences, the digest-algo for sign-only and
sign+symencrypt would be taken from personal-digest-preferences.
sign+encrypt is unchanged.  The user can then set their preferred hash
in one place and GnuPG will use it when it can (sign-only,
sign+symencrypt), and won't when it would violate the spec
(sign+encrypt if the recipient can't handle it).

@_date: 2002-11-21 15:32:02
@_author: David Shaw 
@_subject: Moving subkeys around 
This is technically possible, but you would have to do it by hand.
GnuPG comes with "gpgsplit", a program that can handle the packet
disassembly for you, but you will still need to get a valid
self-signature on the moved subkey.
I've done it by running the gpg binary under gdb and tricking it into
signing what I wanted ;)

@_date: 2002-11-21 22:24:02
@_author: David Shaw 
@_subject: Personal prefs 
Neither.  Since symmetric encryption does not use a public (or secret)
key, there are no key-based preferences involved.  The only
preferences that are a factor in that case are the personal

@_date: 2002-11-21 23:00:01
@_author: David Shaw 
@_subject: Personal prefs 
Yes.  I'm not too worried about this particular feature as it doesn't
give a user the abilility to do anything they couldn't do already
(after all, they could just set --digest-algo), but it does make it
easier to do this.  I thought about suggesting an option to set a hash
algorithm for just sign-only and sign+symencrypt (so it would not
override the hash chosen for sign+encrypt), but I wonder if that would
be more confusing than helpful.
Maybe it would be worthwhile to add a note to the manual about
algorithm choices and the need to be compatible with the rest of the
world.  Something like:
  ALGORITHM CHOICES AND INTEROPERABILITY
  GnuPG tries to be a flexible implementation of the OpenPGP
  standard.  In particular, GnuPG implements many of the "optional"
  parts of the standard, such as the RIPEMD/160 hash, and the ZLIB
  compression algorithms.  By default, GnuPG will not create a message
  that a recipient cannot handle, but it is important to be aware that
  not all OpenPGP programs implement these optional algorithms and
  that by forcing their use via the --cipher-algo, --digest-algo, or
  --compress-algo features in GnuPG, it is possible to create a
  perfectly valid OpenPGP message, but one that cannot be read by the
  recipient.

@_date: 2002-11-22 15:06:02
@_author: David Shaw 
@_subject: keyserver URIs 
Ah.  There is a standard form for LDAP URLs (rfc2255), but given the
way the LDAP keyserver is designed it may be hard to construct a URL
for it.  The LDAP keyserver always needs two queries per key - first,
to ask the server what the dn is, and then again to get the key.
The dn is always "OU=ACTIVE,O=PGP KEYSPACE,C=US", but might not be in
the future.
For the HKP keyservers, there is no standard URL format (since there
is no standard "hkp" URI scheme).  You could always write it as a HTTP
url though:

@_date: 2002-11-26 06:35:01
@_author: David Shaw 
@_subject: PGP and signing subkeys 
Hi folks,
Some good news on the signing subkeys front - after the disappointment
of the first beta, I wrote a note to the PGP folks giving the various
rationales of signing subkeys and the new PGP 8 beta now supports
signing subkeys.  I tested it, and it works fine with both DSA and RSA
signing subkeys.
Note that this doesn't mean PGP 8 can make signatures with a subkey,
but it at least doesn't barf when it verifies a message signed with a
signing subkey from GnuPG.
Another nice thing that showed up in the latest beta is the ability to
understand SHA-1 protected secret keys.  This means PGP 8 can handle
keys generated with GnuPG 1.0.7 and later without any of the
"--simple-sk-checksum & change your passphrase" stuff.
Let's just hope that these features stay in for the final release. :)

@_date: 2002-11-27 22:18:02
@_author: David Shaw 
@_subject: with-colons listing, issue with distinguishing between encrypting and signing keys. 
This is correct behavior.  If you have multiple subkeys capable of
doing the requested action, GnuPG will pick the most recent capable
subkey.  You can override this choice by specifying the subkey with an
exclamation point (!) after the keyid.  This makes GnuPG use that
specified subkey and not try any others.

@_date: 2002-11-28 03:36:01
@_author: David Shaw 
@_subject: with-colons listing, issue with distinguishing between encrypting and signing keys. 
What are the subkey types (RSA, Elgamal, ?)  Also, can you post the
output of:
  gpg --export (yourkey) | gpg --list-packets

@_date: 2002-11-28 04:49:02
@_author: David Shaw 
@_subject: with-colons listing, issue with distinguishing between encrypting and signing keys. 
Aha, I found it.  This is a bug.  When you change the expiration date,
the key flags are lost which makes a sign-only or encrypt-only RSA key
into a sign+encrypt.  This will be fixed for the next version of

@_date: 2002-11-28 17:11:01
@_author: David Shaw 
@_subject: erf, forgot to change the mailto in the reply.. 
It's repairable, but you'd need to make a temporary patch to your
GnuPG, do the repair, and then go back to your old GnuPG.  If you
aren't compiling your own GnuPG, you can just revoke that subkey (you
don't need to revoke the whole key) and make a new one.

@_date: 2002-11-28 17:57:02
@_author: David Shaw 
@_subject: PGP and signing subkeys 
Hmm.  Build 349 is the one that seems to have fixed it.  I have 349
and your subkey-signed document at
 verifies just fine.

@_date: 2002-10-01 20:16:01
@_author: David Shaw 
@_subject: GnuPG 1.2.0 binary for Windows NT 
Even better - there will be a 1.2.1 fairly soon that contains fixes
for the problems that have popped up after the 1.2.0 release.

@_date: 2002-10-01 21:28:02
@_author: David Shaw 
@_subject: encrypt multiple files into one singlefile and then decrypt back the original multipe files 
Not by itself.  The OpenPGP format requires only one "file" inside an
encrypted message.  You can zip or tar the files together and then
encrypt that though.

@_date: 2002-10-01 22:38:01
@_author: David Shaw 
@_subject: gpg: protection algorithm 254 is not supported 
You can ignore the IDEA message.  As for the 254 problem, can you do:
gpg --export-secret-key 403fb2a7 | gpg --list-packets
After the line that begins "skey[3]: ..." there is a line that says
something like "iter+salt S2K, algo: 1...".  Can you tell me what the
line reads?  You can snip off the "salt" if you prefer.
Also, what version of GnuPG did you generate the key with?

@_date: 2002-10-02 02:13:02
@_author: David Shaw 
@_subject: Cannot revoke signature 
Content-Disposition: inline
Nothing.  This is a bug in 1.2.0.  There will be a proper fix soon,
but in the meantime you can apply this patch.

@_date: 2002-10-02 02:14:02
@_author: David Shaw 
@_subject: encrypt multiple files into one singlefile and then decrypt	back the original multipe files 
The 't' in your gpg command line means "textmode".  A tarball isn't
text, so remove the 't'.

@_date: 2002-10-02 04:08:01
@_author: David Shaw 
@_subject: Cannot revoke signature 
There will be a 1.2.1 release for both Windows and Unix fairly soon
that contains the fix.  In the meantime, if you have a copy of an
older GnuPG still around, you can use that to import the revocation
certificate (or send it to a friend with the fix and have them send
you back the revoked key if that is possible).

@_date: 2002-10-02 15:12:02
@_author: David Shaw 
@_subject: gpg: protection algorithm 254 is not supported 
Hmm.  What version of gpg were you running for the above message?  Are
you sure it is not 1.0.6 ?

@_date: 2002-10-02 17:55:01
@_author: David Shaw 
@_subject: gpg: protection algorithm 254 is not supported 
I believe you just discovered a bug in 1.0.6.  As best as I can tell,
you generated the key with 1.0.7 or 1.2.0, used it in 1.0.6, and then
used it in 1.0.7 or 1.2.0.  There is a bug in 1.0.6 that damaged the
key.  Unfortunately, I'm afraid the key is now corrupted and is not
recoverable.  Do you have a backup?  If so, import it into 1.0.7 or
1.2.0 and you should be okay.

@_date: 2002-10-02 23:22:05
@_author: David Shaw 
@_subject: Confused about sub-keys. 
It's in 1.2.1:
sec# 4096R/99242560 2002-01-28 David M. Shaw ssb  2048g/1643B926 2002-01-28
Look for the '

@_date: 2002-10-03 01:17:13
@_author: David Shaw 
@_subject: gnupg on FlashDisk with autofs (o.t.?) 
There is a solution.  The problem is in locking, so if you use
--lock-never then GnuPG will not try and lock the keyrings.  However,
you will need to make very sure you never run two copies of GnuPG at
the same time :)
One good way to do it is to keep the pubring online as it is the one
people generally need to write to when importing new keys, and only
keeping the secring on the flash disk.  No locking issues in that
system unless you want to add a new secret key.

@_date: 2002-10-03 14:50:02
@_author: David Shaw 
@_subject: existing keys as subkey 
That would be a lot of messages, and you lose the nice mailing list
ability to send in bulk (i.e. you have more than one subscriber at a
given domain, so you send one copy to that domain and let their mail
system deliver it multiple times).
You can use --throw-keyid to remove the key IDs of the subscribers, so
the only thing that an attacker would know about the subscribers is
how many of them there are.  You can throw some extra fake
"subscribers" into the mix as well to throw off the count as well ;)
The only catch is that PGP does not implement speculative keyids, so
all of the subscribers must be using GnuPG.  Or you could only use
--throw-keyid on the GnuPG users.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-10-03 14:55:03
@_author: David Shaw 
@_subject: Can't install 1.2 over 1.06 (prob a Make question) 
It sounds like your original gpg installation was in /usr.  The source
distribution installs in /usr/local by default.  Which sort of system
is it - if it is something with some notion of package management
(Redhat, Debian, etc.) you can probably just delete the old 1.0.6
package and have it all go away at once.  That will leave you with
only the 1.2.0 install.

@_date: 2002-10-03 16:31:01
@_author: David Shaw 
@_subject: existing keys as subkey 
Good idea.  I don't think anybody has ever really implemented
something like this.  It would be interesting to see how encryption
interacts with the usual mailing list stuff like VERP (where you must
send a single copy per user).  What does the usual "many bounce
messages =3D=3D removed from list" rule mean when a remailer is used?
Will the messages be flagged as viruses (unreadable binary gibberish)?
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-10-03 23:51:01
@_author: David Shaw 
@_subject: MUAs supporting GnuPG FAQ update 
Adrian is right - this should be changed.  OpenPGP does not mean

@_date: 2002-10-05 03:27:02
@_author: David Shaw 
@_subject: how to delete a signature? 
The user id in your case is "Peter Jay Salzman ".  Since
you only have one, enter "1" before using the "delsig" command.  Delsig
will prompt you for which signature you want to delete.
However, note that this signature will come back if you ever refresh
your key from a keyserver or another user.  Why bother to delete it?
It doesn't have any effect since the key that made it is expired.

@_date: 2002-10-05 16:56:12
@_author: David Shaw 
@_subject: Recent problem 
"secret key parts are not available" is the error that is returned
when a user tries to make a signature with a key that was created via
--export-secret-subkeys.  These keys have all their subkeys, but no
primary key, which is generally the key used for signing.  Did you use

@_date: 2002-10-07 12:37:02
@_author: David Shaw 
@_subject: RSA sign and encrypt 
These are v4 RSA keys.  They do not have the problems that v3 keys
have.  The regular "RSA" that you see without --expert is v4 as well.
The key you saw under --expert is a RSA sign+encrypt key (i.e. do both
with one key).
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-10-11 02:55:02
@_author: David Shaw 
@_subject: gpg run from .procmailrc can't find secret keyring 
Could you possibly have more than one copy of gpg installed?  What
happens if you do gpg --version in your procmail script?

@_date: 2002-10-11 14:14:01
@_author: David Shaw 
@_subject: Hash selection defaults 
The sender is non-conformant.  RFC2440 dictates that the Hash header
is present, and if it is not then MD5 is the hash.
I added this warning message for this exact case.  Perhaps it should
be something stronger than a "WARNING" :)

@_date: 2002-10-11 19:04:02
@_author: David Shaw 
@_subject: Why subkeys? 
While it is possible, it's not a very safe thing to do if the original
primary key that you want to make into a subkey has been distributed
at all.  There can be odd problems with PGP if a primary key and
subkey on the same keyring have the same keyid.  There really isn't
much of an advantage - aside from convenience - in doing this anyway -
you don't get to keep any signatures made on the old key.
You can upload the key to one of the good keyservers:
  hkp://keyserver.kjsl.com
  ldap://keys.pgp.com
  ldap://pgp.surfnet.nl:11370
If you upload to those three first, then they will get the good copy
of the key.  They do all synchronize with the others (though
keys.pgp.com seems to be behind), so when the other keyservers learn
the key it will be corrupted on those servers, but not the good three.
Personally, I'd just not upload the key to the servers yet (which is
exactly what I did do - I have a signing subkey that isn't used yet)

@_date: 2002-10-12 02:01:02
@_author: David Shaw 
@_subject: Rsa or Rsa Legacy with PGP 7.0 
It supports both.  However, regular RSA (not "legacy") is a better key
type to use unless you must be compatible with very old PGP programs.

@_date: 2002-10-12 02:01:09
@_author: David Shaw 
@_subject: Weird error after moving .gnupg to new machine 
It means the new machine is running an older version of GnuPG than the
old machine.  You need to run at least 1.0.7 on the new machine.

@_date: 2002-10-12 21:24:02
@_author: David Shaw 
@_subject: How to export gpg keys to use in PGP 8.0 beta 
PGP uses whatever the config option "Preferred Algorithm" is set to to
protect secret keys.  It defaults to AES256.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-10-12 21:33:02
@_author: David Shaw 
@_subject: How to export gpg keys to use in PGP 8.0 beta 
This has come up fairly often, so here's the HOWTO:
PGP can (for most key types) use secret keys generated by GnuPG.  The
problems that come up occasionally are generally because GnuPG
supports a few more features from the OpenPGP standard than PGP does.
If your secret key has any of those features in use, then PGP will
reject the key or you will have problems communicating later.  Note
that PGP doesn't do Elgamal signing keys at all, so they are not
usable with any version.
These instructions should work for GnuPG 1.0.7 and later, and PGP
7.0.3 and later.
Start by editing the key.  Most of this line is not really necessary
as the default values are correct, but it does not hurt to repeat the
values, as this will override them in case you have something else set
in your options file.
->> gpg --s2k-cipher-algo cast5 --s2k-digest-algo sha1 --s2k-mode 3 --simple-sk-checksum --edit THEKEYID
Turn off some features.  Set the list of preferred ciphers, hashes,
and compression algorithms to things that PGP can handle.  (Yes, I
know this is an odd list of ciphers, but this is what PGP itself uses,
minus IDEA).
->> setpref S9 S8 S7 S3 S2 S10 H2 H3 Z1 Z0
Now put the list of preferences onto the key.
->> updpref
Finally we must decrypt and re-encrypt the key, making sure that we
encrypt with a cipher that PGP likes.  We set this up in the --edit
line above, so now we just need to change the passphrase to make it
take effect.  You can use the same passphrase if you like, or take
this opportunity to actually change it.
->> passwd
Save our work.
->> save
Now we can do the usual export:
->> gpg --export THEKEYID > mypublickey.pgp
->> gpg --export-secret-key THEKEYID > mysecretkey.pgp
Sometimes I wonder if a --convert-to-pgp command for GnuPG to automate
all of that would be useful.

@_date: 2002-10-14 14:55:03
@_author: David Shaw 
@_subject: bug 
That is a known bug - it is fixed in 1.2.1.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-10-14 15:23:03
@_author: David Shaw 
@_subject: Rsa or Rsa Legacy with PGP 7.0 
No, 6.5.8 works with v4 RSA keys.  It won't generate them, of course,
but it can encrypt to them and verify sigs from them if they are not
too large (4096 doesn't work, 2048 seems to).

@_date: 2002-10-14 16:02:02
@_author: David Shaw 
@_subject: message was not integrity protected 
GnuPG supports integrity protected messages which adds a hash (sort of
a mini-signature) inside the encrypted message to alert the user if
the message was tampered with.
That warning message means that the message you received did not have
integrity protection enabled.  PGP 7 does not generate messages with
integrity protection, though it does understand them when a GnuPG user
sends messages to a PGP 7 user.
This feature is to help combat message modification attacks such as
the one given in You can make the warning go away with --no-mdc-warning.

@_date: 2002-10-14 21:28:02
@_author: David Shaw 
@_subject: deletion of a photo-id 
Yes.  There is also a delphoto command that does the same thing.

@_date: 2002-10-15 17:49:02
@_author: David Shaw 
@_subject: deletion of photo id 
delphoto is exactly like deluid.  You must select the user ID you want
to delete.  In this case, enter "2", then "deluid" or "delphoto".

@_date: 2002-10-16 03:29:02
@_author: David Shaw 
@_subject: personal-<foo>-preferences? 
Use the same letter codes that "setpref" uses.  You can list the
available codes with "gpg -v --version".
For example. a preference list giving AES, CAST5, and BLOWFISH in that
order would be "S7 S3 S4".

@_date: 2002-10-16 03:31:03
@_author: David Shaw 
@_subject: compilation error on Intel Solaris 8 
See The CVS tag to use is STABLE-BRANCH-1-2
However, note that a 1.2.1 release candidate should be released very

@_date: 2002-10-16 03:32:02
@_author: David Shaw 
@_subject: 1.2.1 
It is not released yet, though a test version to make sure that all
the build problems were fixed should be released soon, and if all goes
well the real 1.2.1 release should come soon after that.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-10-16 14:43:02
@_author: David Shaw 
@_subject: Decrypting/Verifying 
In an automated environment, the best thing to do is use the
--status-fd feature and look at the data sent to that fd.  For
gpg --status-fd 1 --output (whatever) --decrypt (whatever)
On FD 1, you will get status messages giving the exact results from
that encrypted message, including "GOODSIG".  See the doc/DETAILS file
for more info.  There are ways to specify pretty much every signature
case, from no signature at all, to an expired signature, to an
signature made by an expired key, etc.

@_date: 2002-10-16 15:51:02
@_author: David Shaw 
@_subject: Decrypting/Verifying 
Very safe assumption.  To have a GOOD sig, there has to be a sig in
the first place ;)
I think for automated use when you want that kind of information,
there is no reason not to use it for all operations.  It doesn't
significantly impact performance.

@_date: 2002-10-17 13:44:03
@_author: David Shaw 
@_subject: personal-<foo>-preferences? 
This is one of the things I have on my list for the devel version.
You should be able to use the S-codes as well as the full cipher names

@_date: 2002-10-17 13:51:03
@_author: David Shaw 
@_subject: multiple keys in one .asc - like debian guys 
gpg --armor --export key1 key2 key3 key4 > keysonethroughfour.txt

@_date: 2002-10-18 18:55:02
@_author: David Shaw 
@_subject: [Announce]GnuPG 1.3.0 released (development) 
The first release from the new development branch of GnuPG is ready
for public consumption.  This is a branch to create what will be GnuPG
1.4 someday.  It will change much more frequently than the 1.2.x
"stable" branch, which will mainly be updated for bug fix reasons.
I encourage the more GnuPG-familiar user to try this release (and the
ones that will follow in the 1.3.x branch), and report back any
problems to gnupg-devel  In return, you get the latest code
with the latest features.  However, it is always important to keep in
mind that this is still development code - please do not use it on
anything mission-critical.  Critical applications should always use
the 1.2.x stable branch.
You may notice the smaller tarball size for this release - that is due
to the translations other than de being removed.  You may also notice
the smaller size of the gpg binary, and that is due to some of the
keyserver modifications.  See the list below for more on these
The files are available From: ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.0.tar.gz (1432k)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.0.tar.gz.sig
MD5 checksums for the files are:
  2dcd23aae21e1ff08ffc258d6f075d64  gnupg-1.3.0.tar.gz
  006384951e566ffa4581251b538af154  gnupg-1.3.0.tar.gz.sig
Noteworthy changes in version 1.3.0 (2002-10-18)

@_date: 2002-10-19 14:47:03
@_author: David Shaw 
@_subject: Understanding MDC (Modification Detection Code) 
That is correct.  As you saw, MDC is unrelated from any particular
cipher choice.  However, given the general evolution of OpenPGP, it is
possible to infer from the presence of Twofish and AES that MDC
exists.  Ideally, of course, the key would have an explicit MDC flag,
but PGP does not do this.
Among other things, read 6.5.8 != 6.5.1i.  Two different programs.

@_date: 2002-10-23 05:33:02
@_author: David Shaw 
@_subject: I lost my public key! :( 
Unlike many "lost key" situations, you're not completely out of luck.
All OpenPGP secret keys have a copy of the public key inside them, and
in a worst-case scenario, you can create yourself a new public key
using the secret key.  Some versions of PGP, in fact, do this
automatically when you import a secret key.
Did you (or someone else) send your public key to a keyserver?  If so,
you can probably retrieve a copy from there.

@_date: 2002-10-23 16:52:01
@_author: David Shaw 
@_subject: Verifying a signature 
The most secure way to do this is to look for GOODSIG *and* VALIDSIG.
The first argument to VALIDSIG is the fingerprint of the key that made
the signature.  You can do this with just GOODSIG, but since GOODSIG
has only the keyid and not a full fingerprint, it is spoofable.

@_date: 2002-10-23 18:07:02
@_author: David Shaw 
@_subject: I lost my public key! :) 
I have added a similar feature to the development GnuPG.  When you
import a secret key, the embedded public key is imported as well.  You
can disable this behavior with "--import-option no-convert-sk-to-pk".

@_date: 2002-10-23 18:32:01
@_author: David Shaw 
@_subject: gpg: Oops; key lost! 
Looks like you have public keys in your secret keyring.

@_date: 2002-10-24 03:50:01
@_author: David Shaw 
@_subject: I lost my public key! :) 
It isn't required - the problem you had earlier was a bug.  It's been
fixed now as part of 1.2.1.
In 1.2.1 you do need to use --try-all-secrets to decrypt though, for
various reasons having to do with how GnuPG looks up keys internally.
This is handled in the latest devel version (1.3.1) which creates a
public key automatically from the secret key.

@_date: 2002-10-24 17:38:02
@_author: David Shaw 
@_subject: PGP 7.1.1 reports "bad signature" on messages from GnuPG ? 
I believe 7.1.1 handles it correctly, but try it and see ;)
No problems.  All the --pgp7 switch does is to use a subset of GnuPG

@_date: 2002-10-24 17:42:02
@_author: David Shaw 
@_subject: Expiring Keys 
There is some confusion with expiring keys, since the meaning of
expiration changed a few years ago.  In the old v3 keys (PGP 2.x),
expiration meant "this key only lasts this long, period."  Once the
key expired, the key was dead.  In the new v4 keys (PGP 5+, GnuPG),
expiration means "I plan on using the key this long, but I may change
my mind" - the expiration date can be changed by the key owner, even
after the key has "expired".
Anyway, expiration is a tool that you can use to handle certain
problems like the loss of a secret key.  After the key expires, nobody
will use it.  It does not protect you against a stolen secret key
since the attacker could just extend or remove the expiration date

@_date: 2002-10-25 04:57:01
@_author: David Shaw 
@_subject: PGP 7.1.1 reports "bad signature" on messages from GnuPG ? 
It could be.  Try using --pgp7 or --force-v3-sigs and see if it makes
a difference.  --pgp7 includes --force-v3-sigs so you don't need to
set them both (no harm if you do though).

@_date: 2002-10-25 14:47:01
@_author: David Shaw 
@_subject: Have key ID, but can't decrypt. 
Another way to do this is the --throw-keyid option, which keeps using
your own key for encryption, but removes the keyid so it can't be
traced.  Unfortunately, --throw-keyid acts on *all* keys used, and not
specific ones so it would remove the keyid of the recipient as well.
I should look at that.

@_date: 2002-10-25 18:46:01
@_author: David Shaw 
@_subject: E-Mail Encryption: Why Isn't Everyone Doing It? 
Well, my key comes with GnuPG... if anyone finds themselves near
Cambridge, Massachusetts in the US, I'd be glad to sign their key.
There was talk about a email based robot CA a few months ago.  It
would check only the email address (by sending a challenge).  An
interesting idea, if done right.

@_date: 2002-10-25 19:32:02
@_author: David Shaw 
@_subject: E-Mail Encryption: Why Isn't Everyone Doing It? 
It was on the cryptography list, I believe, and a few other places
The basic idea was a web form where a user could paste their key or an
email address to send it the key to.  The program would then email a
challenge string to each email address on the key.  If the challenge
came back signed by the user's key, then the program would sign that
user ID with its own key.
One gotcha we can avoid, if there are multiple levels of certification
in the future, is to use a different signing key for each.  That way
users can trust the signing key for the exact service they want.  I
understand Thawte got this detail wrong when they set up their PGP
signing service.
Anyway, the basic idea is pretty clear, but the details are not.  One
signing key?  Multiple signing keys?  What if a signing key gets
compromised?  And so on... ;)
I actually registered keysigners.org for the project back when it
first came up.  I happen to have a bit more free time nowadays (I'm
also adding trust signatures to GnuPG), so perhaps I'll ressurect the

@_date: 2002-10-25 23:53:01
@_author: David Shaw 
@_subject: E-Mail Encryption: Why Isn't Everyone Doing It? 
That's another possibility, but I'd want things to work well with PGP
as well, and PGP doesn't do signature levels.

@_date: 2002-10-26 01:22:01
@_author: David Shaw 
@_subject: automated userid certifications (was Re: E-Mail Encryption: Why Isn't Everyone Doing It?) 
I'd rather use 0x11, as a new signature class would have a serious
backwards compatibility problem.  0x11 is pretty good for this

@_date: 2002-10-26 14:07:01
@_author: David Shaw 
@_subject: automated userid certifications 
I thought about this, but again it's a PGP problem because PGP ignores
policy URLs :(
I'm currently thinking about doing 0x11, a policy URL, and a policy
URL in the (parentheses) as part of the user ID.  Cover all bases..

@_date: 2002-10-26 18:47:01
@_author: David Shaw 
@_subject: Build error on gpg 1.3.0 
Edit keyserver/Makefile.am and change the gpgkeys_hkp_LDADD line to
gpgkeys_hkp_LDADD = ../util/libutil.a  Then re-run ./configure

@_date: 2002-10-27 03:57:01
@_author: David Shaw 
@_subject: automated userid certifications (was Re: E-Mail Encryption: Why Isn't Everyone Doing It?) 
It means only what it says.  It's a semantic difference, not a
functional difference.  The user ID is being certified, because there
is a signature being made at all, but the semantic meaning of that
certification is "I'm making this signature, but I didn't check what
I'm certifying".  RFC-1991 defines it as "This key was created by
someone who has told me that he is this user" which is perhaps a
better way to look at it.
Yes.  However I think the 0x11 "I haven't checked", is closer to the
right value than the 0x12 "I casually checked".  It's all a matter of
the opinion of the *signer*, so it would be equally appropriate for it
to be a 0x13 - if the email checking robot considered checking email
"very careful" ;)

@_date: 2002-10-29 13:19:01
@_author: David Shaw 
@_subject: E-Mail Encryption: Why Isn't Everyone Doing It? 
The comment I was referring to would be on the CA-bot key itself to
help make the purpose of the key clear.  The comment is not on the key
that is being signed.  The Thawte system added user IDs to the signed
key which I always thought was really ugly.
I'm planning (if I do this) on using them all together (0x11, policy
URL, a comment on the signing key, and a different key for each sort
of certification).  It's the only way to really work well across
multiple OpenPGP implementations.

@_date: 2002-10-29 16:03:02
@_author: David Shaw 
@_subject: Multiple keyring support 
Try this: in your gpg.conf file, specify the additional keyring only:
  keyring catch-all.gpg
Make your current keyring readonly:
  chmod a-w pubring.gpg
Now you still have the current pubring listed first in key listings,
but new keys go to the catch-all ring.  To override, restore
writability to pubring.gpg.
(I'm not saying this is necessarily optimal, but it does give you what
you want).

@_date: 2002-10-30 15:22:01
@_author: David Shaw 
@_subject: Multiple keyring support 
I'm not sure why it changed.  Werner would have to say.
I am interested in the problem though.  It seems to me that the 1.0.6
behavior is just as "bad" as the 1.0.7 - it's just different and
easier to work around to get what you want.  In 1.0.6, a user is
forced to put the catchall keyring last.  What if the user wants it
somewhere else?
What if there was a way to flag a particular keyring (from either
gpg.conf or the command line) as the default one, and that keyring
became the one that new keys were imported into?  Would that solve
everyone's problem?

@_date: 2002-10-30 18:33:02
@_author: David Shaw 
@_subject: gpg: protection algorithm 254 is not supported 
This is a problem if you have a key generated with 1.0.7 or later,
import it to 1.0.6 and then import it back into 1.0.7 or later.  1.0.6
corrupts the key.

@_date: 2002-10-30 23:01:01
@_author: David Shaw 
@_subject: cypher algorithm - which one? 
If speed doesn't matter, and you want the safest choice, then that's
3DES.  It's been around the longest, and it's withstood more
challenges than any other cipher.
See  for more.

@_date: 2002-09-03 00:52:02
@_author: David Shaw 
@_subject: correction, Re: HushMail interoperability 
References: <000f01c2522f$20524bc0$4b914c51 <20020902044151.GC985 <20020902044327.GD985 <3D730A46.2070107 <00f401c2524e$cc5a6c80$f48a4c51
 to
Have you read  ?
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-09-03 00:53:02
@_author: David Shaw 
@_subject: two questions 
References: <20020902032304.A16455
Unless the user overrides it for whatever reason, the default is

@_date: 2002-09-03 18:08:06
@_author: David Shaw 
@_subject: correction, Re: HushMail interoperability 
References: <015501c25310$5b87be00$4f72893e It is.  However, it is important to only use --disable-mdc for
Hushmail users and not disable it for everyone.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-09-04 13:30:02
@_author: David Shaw 
@_subject: problem with --groups 
References: <20020904101032.25727.qmail
gpg --group "hello 0x382c2523 0x8692324 0x48125CF2"

@_date: 2002-09-06 08:47:02
@_author: David Shaw 
@_subject: correction, Re: HushMail interoperability 
References: <015501c25310$5b87be00$4f72893e  <20020903160912.GA1033 <004601c253e7$83fc5c60$72854c51
ed my
The MDC is essentially a hash of the document, encrypted along with
the document.  Think of it as a mini-signature to verify that the
document was not tampered with in transit.
It prevents some attacks against a message that involve such
tampering.  Admittedly, those attacks are extremely difficult to pull
off.  You can read  for all
the details.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-09-06 21:43:02
@_author: David Shaw 
@_subject: correction, Re: HushMail interoperability 
References: <015501c25310$5b87be00$4f72893e  <20020903160912.GA1033 <004601c253e7$83fc5c60$72854c51 <20020904172437.GB668 <002e01c2558f$ad6a3be0$f4994c51
You can get almost as good protection by always making sure that the
messages you send are compressed.  GnuPG does this by default unless
the file is already compressed.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2002-09-09 05:10:02
@_author: David Shaw 
@_subject: problem with --groups (Thanks) 
References: <20020904113009.GA2725 <20020907054421.93456.qmail
You are using a *development* version of GnuPG.  Every time you run
it, it starts up with:
gpg: NOTE: THIS IS A DEVELOPMENT VERSION!
gpg: It is only intended for test purposes and should NOT be
gpg: used in a production environment or with production keys
Development versions exist so people can play with them and find
problems.  They are not production releases.  If you find a bug, even
in the documentation, you could contribute a fix rather than scolding
people about it...

@_date: 2002-09-09 05:12:01
@_author: David Shaw 
@_subject: importing secring.skr 
References: <20020908134854.7596.qmail
It depends on which version of GnuPG you have (run 'gpg --version' to
check).  I'm assuming you are running 1.0.7 here.
Anyway, to import your secring.pgp:
  gpg --import secring.pgp
However, you'll likely need your pubring.pgp as well:
  gpg --import pubring.pgp
1.0.6 is similar, except you need to add a '--allow-secret-key-import'
to the first import line.

@_date: 2002-09-10 15:33:02
@_author: David Shaw 
@_subject: importing secring.skr 
References: <20020909031235.GB675 <20020910130852.28977.qmail
What does GnuPG respond with when you do
  gpg --allow-secret-key-import --import secring.skr

@_date: 2002-09-12 15:24:01
@_author: David Shaw 
@_subject: When will the new GPG version 1.0.7 be released for Windows? EOM 
It will not be.  However, version 1.2 (with many Windows improvements)
will be released for Windows soon.  The (hopefully last) development
snapshot for 1.2 was released last night.

@_date: 2002-09-12 15:32:01
@_author: David Shaw 
@_subject: GnuPG 1.1.92 released 
Development release.  We're now following the common even-odd model,
so if the minor release number is odd, it's a development release
(e.g. 1.1 == development.  1.2 == stable).
That said, 1.1.92 is intended to become 1.2 soon.

@_date: 2002-09-13 18:10:02
@_author: David Shaw 
@_subject: Bug? lsign first, then sign 
This was changed in 1.0.7.  GnuPG now prompts the user to see if they
want to "promote" the local signature to a full exportable signature.

@_date: 2002-09-13 18:11:02
@_author: David Shaw 
@_subject: Changing "main" user ID 
In GnuPG 1.0.7 there is a "primary" command in the --edit menu.  Just
select the user ID that you want to be primary.

@_date: 2002-09-13 19:55:01
@_author: David Shaw 
@_subject: Changing "main" user ID 
It is just a cosmetic change, but you are not permitted to make the
change for keys you do not own.  Only the key owner can decide how
their key is displayed.

@_date: 2002-09-13 20:59:01
@_author: David Shaw 
@_subject: Changing "main" user ID 
Actually, it isn't in there.  The standard is really mostly a
'on-the-wire' spec.  It often says little or nothing about
interpretation.  There is nothing in the spec to prevent such a thing.
An easy way to do it would be to add the primary uid indicator to the
unhashed area of the self-signature.  Of course, if you are doing
something local then you can do whatever you want.
That's the problem here... what happens after you export the key to
give to a friend?  Should GnuPG strip the primary uid subpacket that
you added?  How does it know that it was one that you added and not
someone else?  Should it strip unhashed primary uid subpackets when
importing keys?  Why or why not?
There are sometimes very good reasons for adding unhashed data to
self-signatures on keys you don't own (to add a MDC flag for example).
In this case, it opens up a whole lot of potentially dangerous
questions for something that is, after all, cosmetic.

@_date: 2002-09-16 19:59:02
@_author: David Shaw 
@_subject: gpg 1.0.7 and 1.0.6 on redhat 7.3 
Note that RedHat has a RPM for 1.0.7.  If you install it, it will
simply replace the older 1.0.6 RPM.
The new RPM requires OpenLDAP.

@_date: 2002-09-23 17:16:02
@_author: David Shaw 
@_subject: ARRRGHHH Had GPG working, now it doesnt. 
Put this in your options file:
 keyserver-options auto-key-retrieve

@_date: 2002-09-23 21:18:02
@_author: David Shaw 
@_subject: Tiger and SHA2 in gpg 1.2.0 
SHA2 is not part of the official GnuPG.
Note there are many good reasons not to use TIGER.  If those reasons
do not apply to you, you can enable TIGER at build time with
./configure --enable-tiger

@_date: 2002-09-23 21:57:01
@_author: David Shaw 
@_subject: --pgp2 option asumes CAST5 by default? 
Hmm.  Do you have a "cipher-algo cast5" in your config file anywhere?

@_date: 2002-09-24 15:17:01
@_author: David Shaw 
@_subject: web of trust vs subkeys use cases 
I think that each person using a different subkey can quickly become
very difficult to manage.  I recommend using the web of trust.  Create
a "keymaster" key, which can then sign all of the individual keys in
use.  For good measure, make this keymaster key the designated revoker
for the individual keys.  When someone leaves the organization, revoke
their key.

@_date: 2002-09-24 21:25:02
@_author: David Shaw 
@_subject: Tiger and SHA2 in gpg 1.2.0 
You would need to use a patched version.  I think you can get the
patch at My concern is with interoperability.  TIGER isn't fully specified in
OpenPGP, as it does not have an OID number.  The OID used in GnuPG is
a dummy placeholder.  This means that once the real OID is assigned,
it will not be compatible with TIGER signatures made with the dummy.
Also, GnuPG is the only implementation that has TIGER support at all -
if you use it, only other GnuPG users will be able to verify your
signatures.  Finally, as you say, at 192 bits it can only be used with
RSA signatures.

@_date: 2002-09-25 13:44:02
@_author: David Shaw 
@_subject: gpg 1.2.0. and Solaris compilation 
This is interesting - it only happens when the EGD entropy daemon
driver is used (as it uses sockets).
Fixed.  Thanks for the report.

@_date: 2002-09-25 17:49:01
@_author: David Shaw 
@_subject: compiling gpg 1.2.0 on HP-UX 
Which lines is this in longlong.h?  Is it 318 and 365-380 ?
This doesn't make total sense.  The autoconf check should have
detected that.  Did you end up with a gpgkeys_ldap that didn't resolve
host names, or did it not compile at all?
It's required for any scheme that is host-based (RFC 2396).  For the
schemes that ship with GnuPG, that means both hkp and ldap, but not

@_date: 2002-09-25 19:47:02
@_author: David Shaw 
@_subject: compiling gpg 1.2.0 on HP-UX 
That makes little sense - if there were unresolved symbols, the
compile should have failed, and if there were no unresolved symbols,
then there should be nothing needed from liblber or libresolv.  Is
there something unusual about your installation?  SOCKS maybe?
Also, you said you saw the same thing on a Linux box.  Were the
symptoms (compiled ok, but no DNS) the same?

@_date: 2002-09-27 06:15:02
@_author: David Shaw 
@_subject: gpg 1.2.0. and Solaris compilation 
It is fixed in the CVS (though I would appreciate someone testing it -
I don't have access to a Solaris box at the moment).  It will be in
the next release.

@_date: 2002-09-27 20:58:01
@_author: David Shaw 
@_subject: compiling gpg 1.2.0 on HP-UX 
Curiouser and curioser.  I tried it on a 7.2 RH box and it works for
me.  Tell me - which LDAP keyserver did you use to test with?  Was it
ldap://keys.pgp.com or ldap://pgp.surfnet.nl:11370 ?
If you don't recall, can you try it with both?  I have a theory what
is going wrong here.

@_date: 2002-09-29 19:51:02
@_author: David Shaw 
@_subject: Import of revocation certificate fails 
Content-Disposition: inline
This is a bug in 1.2.0, unfortunately.  I have attached a patch.

@_date: 2003-04-03 00:15:01
@_author: David Shaw 
@_subject: default algorithms in gpg 1.0.6 
Hash: SHA1
It's a difficult question since the cipher can change depending on the
recipient.  For example, if the recipient requests CAST5, it'll be
CAST5.  If there is a conflict between recipients, it'll be resolved
as best as possible.  If the conflict cannot be resolved, it'll be
The hash is a little easier: in 1.0.6, it's SHA-1 unless the signing
key is a PGP 2.x key.

@_date: 2003-04-03 02:27:11
@_author: David Shaw 
@_subject: adduid questions 
Hash: SHA1
If I understand your email properly, you have a single key with two
email addresses (work and home).  In this case, it doesn't matter
which email address you use - they'll end up pointing to the same key.
If you have two actual different keys, then you can select which key
to use with the -u command line option.

@_date: 2003-04-03 02:31:02
@_author: David Shaw 
@_subject: simplifying the use of --throw-keyid option 
Hash: SHA1
All keys are tried until one successfully decrypts the message.  In
the example you give, even though an earlier secret key has the same
passphrase, GnuPG will continue processing until it hits the right

@_date: 2003-04-03 07:14:01
@_author: David Shaw 
@_subject: simplifying the use of --throw-keyid option 
Hash: SHA1
That is what GnuPG currently does.  The problem with this method is
that when decrypting a message with a thrown (hidden) keyid, the user
must type the passphrase for every single key.  For users with more
then one secret key, this is annoying.  The new system asks for a
passphrase once, and then tries each secret key with that passphrase.

@_date: 2003-04-03 07:22:02
@_author: David Shaw 
@_subject: simplifying the use of --throw-keyid option 
Hash: SHA1
Part of the point of thrown keyids is that the local user can't know
which secret key to decrypt with.  They'd have to try every key
manually, which defeats the point of using -u for a speed improvement.
Even assuming the local user happens to know via whatever means which
secret key to use, unless the user has a massive number of secret keys
to try, there is no real advantage to this.

@_date: 2003-04-03 16:42:03
@_author: David Shaw 
@_subject: simplifying the use of --throw-keyid option 
Hash: SHA1
I have 63 secret keys on my current keyring, and that's the ring I
used to test the feature ;)   The check to see whether a given key is
the right one is actually extremely quick.
I'm not completely against the idea, but I am reluctant to add extra
complexity for something this obscure.  Nobody is saying "add this,
because I'm having a problem without it".  If it came to pass that
this was an actual problem for people someday, it would be a different
I'm also not sure that -u would be the appropriate option here, since
- -u is designed and documented to work in an options file, which would
make thrown keyid messages more or less unusable in those cases unless
the -u value happened to match the key in use.

@_date: 2003-04-03 18:11:03
@_author: David Shaw 
@_subject: HKP and firewalls 
Hash: SHA1
I'm not familiar with that particular router, but I can give you some
general information that will hopefully help you.
HKP is HTTP underneath it all.  The only thing unusual about it is
that it runs on port 11371.  If there is a general "HTTP"
configuration for your firewall, try that, and allow it on port 11371.
If that isn't possible for whatever reason, you might look around for
a HKP keyserver that runs on port 80 (for this exact reason -
firewalls).  Ask on the pgp-keyserver-folk @ flame.org list, and I'm
sure someone there can suggest a server to use.

@_date: 2003-04-04 17:53:01
@_author: David Shaw 
@_subject: "key expired" from PGP 6 
Hash: SHA1
Without seeing the key in question, I can't be completely sure but I
suspect you have two expiration dates set.  This is normal, and GnuPG
is picking the one that was set most recently.  It seems PGP is
picking the other one....  What happens when you try the key in a more
recent version of PGP?

@_date: 2003-04-04 19:51:02
@_author: David Shaw 
@_subject: False insecure memory warnings... 
Content-Disposition: inline
[ that is not the problem ]
Very interesting.  There are a few other reasons that GnuPG might be
unable to get secure memory.  Being not setuid root (on those
platforms that need it) is only the most common.
Let's dig a bit more.  What happens if you run this program out of
cron in the same way (zsh -c 'time testprog').  Make testprog setuid
   int main(int argc,char *argv[])
  printf("UID: %d\n",(int)getuid());
  printf("EUID: %d\n",(int)geteuid());
  return 0;
The other obvious thing to try is to rebuild GnuPG to see if something
changed in the underlying libraries when you upgraded NetBSD (you may
have done this already).
Content-Disposition: inline

@_date: 2003-04-05 03:10:01
@_author: David Shaw 
@_subject: simplifying the use of --throw-keyid option 
Hash: SHA1
It's a pretty neat system - there are short checksums that are used to
throw out clearly wrong decryptions so GnuPG doesn't need to continue.
It also doesn't proceed to decrypt the message if the secret key can't
be decrypted.
Hmm.  I don't know what the original intent was with that help text.
I can't think of any place where -u can actually be used to specify a
decryption key.  Maybe something in an earlier version that was
It is unfortunately difficult to change the help text in 1.2.2 as
it'll break all of the translations. :(

@_date: 2003-04-07 16:11:02
@_author: David Shaw 
@_subject: message was not integrity protected 
Hash: SHA1
If the key does not have the MDC flag set, then MDC will not be used.
GnuPG sets this flag, but PGP does not.  Were the keys generated with
There are also various options that disable MDC, either directly or as
a side effect.  Do you have any of these in your gpg.conf file?
  disable-mdc
  pgp2
  pgp6

@_date: 2003-04-07 16:15:01
@_author: David Shaw 
@_subject: simplifying the use of --throw-keyid option 
Hash: SHA1
GnuPG can handle it.  No version of official PGP can handle it, but
Disastry's hacked 2.6.3 can.

@_date: 2003-04-07 16:16:02
@_author: David Shaw 
@_subject: simplifying the use of --throw-keyid option 
Hash: SHA1
Yes, this is raised to 32k in 1.2.2.
I don't understand this.  GnuPG already reports that a passphrase is
This is in 1.3.x.  See the --hidden-recipient option.

@_date: 2003-04-07 20:50:01
@_author: David Shaw 
@_subject: simplifying the use of --throw-keyid option 
Hash: SHA1
This was also addressed in 1.3.x, as there is only one passphrase
prompted for.

@_date: 2003-04-08 17:10:02
@_author: David Shaw 
@_subject: Understanding MDC (Modification Detection Code) 
Hash: SHA1
Incorrect.  The MDC stops this vulnerability.
Note that the chosen ciphertext attack mentioned requires a lot more
than an uncompressed file to succeed: the victim needs to cooperate
(even unknowingly) and send back decrypted text.
No problem, so long as your recipient can handle MDCs.  That means PGP
7 or later, or GnuPG.

@_date: 2003-04-08 17:12:02
@_author: David Shaw 
@_subject: How to remove passphrase? 
Hash: SHA1
When GnuPG prompts for the new passphrase, just hit enter.

@_date: 2003-04-08 17:13:02
@_author: David Shaw 
@_subject: invalid trustdb error 
Hash: SHA1
Delete both, and GnuPG will create a new, good, trustdb the next time
it runs.  A zero-length trustdb has no data in it you can save anyway.

@_date: 2003-04-08 18:33:02
@_author: David Shaw 
@_subject: A GnuPG oddity (decompression) 
Hash: SHA1
I believe this is has to do with a similar problem seen with CryptoEx
compresssed messages.  It is fixed in 1.2.2.

@_date: 2003-04-08 20:45:02
@_author: David Shaw 
@_subject: export single UID of a key 
Hash: SHA1
Note that this doesn't really give you what you want in all cases.
OpenPGP keys are usually made up of a primary signing key and a number
of secondary encryption keys.  There are other combinations, but that
is by far the most common.
Anyway, when you sign a key, you are actually signing the primary key
plus the user ID.  If you follow  above, you are actually sending
the signed key to an entity that may or may not control the signing
key - in effect, signing something without strong proof that the
recipient actually "owns" that key.
There are cases where this isn't a problem (a PGP 2.x key, or a
sign+encrypt primary key), but the common case is a problem.

@_date: 2003-04-08 23:15:01
@_author: David Shaw 
@_subject: export single UID of a key 
Hash: SHA1
No, the binding signature is useless here.  Think about it: would you
sign my key based on the fact that I signed some random piece of data
at some point in the past?  Surely not, but that is what this system
It is certainly true that in the huge majority of cases, the entity
that controls the decryption key is the same one that controls the
signing key.  However, OpenPGP does not in any way require this.  When
you make a signature you are making it over {primarykey,uid}.  The
decryption key is of only incidental importance here.
For example: let's say someone can read my mail, and manages to steal
my key and passphrase.  Big deal - they still didn't get my primary
key, which is stored offline.  I can just revoke the subkeys, and make
some new ones.  Until I realize what happened, the attacker has a
pretty strong incentive to get more signatures on my key.  If people
sign using the suggested method above, then the attacker gets lots of
signatures and doesn't "own" the key.
If people require a signed challenge, the attacker is foiled.  He
cannot fulfil the challenge.
Another place where the suggested system breaks down is in split key
setups where there is one OpenPGP "key" broken into different subkeys
for different employees with the employer controlling the primary.
Finally, what happens with a sign-only key in this system?  Who do you
encrypt the message to?

@_date: 2003-04-09 00:00:01
@_author: David Shaw 
@_subject: export single UID of a key 
Hash: SHA1
So don't encrypt the challenge.  Encrypting the challenge doesn't buy
you any additional security.  You don't need confidentiality here -
you need identity confirmation.
Nevertheless, you are signing the primary key plus the user ID.  It
doesn't matter how programs display it for human consumption.
Yes.  That is why the method being discussed does not work in all
You are signing the primary key... but giving someone with access to
only the decryption key the ability to use your signature.  Signing A,
but giving B access to it.  A and B are not necessarily the same
By using a challenge, you are signing A, and requiring proof that the
entity controls A.

@_date: 2003-04-09 05:43:01
@_author: David Shaw 
@_subject: export single UID of a key 
Hash: SHA1
This is actually a good thing.  Since you are signing {primary,uid},
if the uid is no longer usable then your signature should certainly no
longer be used.  The uid being revoked breaks a part of the "contract"
you have with the key owner.
Well, yes, and no.  OpenPGP defines a "direct key signature", which is
a signature on the primary key only.  However, GnuPG doesn't accept it
as part of the web of trust.  I'm actually not sure if PGP does,
either.  Both programs use it for special key features (like
designated revokers).  Neither program allows users to make direct key
signatures on other people's keys.
Using a direct key signature is a bit like giving unconditional trust
("I can't confirm who this person is, but I trust the key belongs to
them anyway").  I think it could be useful in special cases where
those somewhat weird semantics don't matter, but it just isn't that
useful the rest of the time.
Exactly :)  The stronger everyone is in making their own signatures,
the better the web of trust is overall.  People who only need weak
checks can still use the strong links, but people who need strong
links can't use weak checks.

@_date: 2003-04-10 22:35:02
@_author: David Shaw 
@_subject: Import a pubkey sans self-sig? 
Hash: SHA1
It's historical.  Early versions of PGP (2.x) did not automatically
self-sign user IDs.  RFC-2440 maintains that in not requiring a
Note that GnuPG will import and export non-self-signed user IDs, but
will never actually use a key with no self-signed user IDs unless:
1) If --allow-non-selfsigned-uid is set.
2) If a user ID is signed (or lsigned) by an ultimately trusted key.

@_date: 2003-04-12 00:07:24
@_author: David Shaw 
@_subject: delete ID 
Hash: SHA1
The new draft OpenPGP RFC does define this meaning (as well as the
notion of an expiring user ID, done via an expiring selfsig).
1.2.2 has a new "revuid" command to do this easily so there is no need
to manually revoke the selfsig.

@_date: 2003-04-14 00:49:02
@_author: David Shaw 
@_subject: Charset of gpg --with-colon 
Hash: SHA1
The name field of --with-colons is the raw UTF-8 value of the user ID
field, with some values \-escaped.
So, to extract the user name you need to take the value from the field
and replace every occurance of '\xQQ' with the byte QQ.  This results
in the UTF-8 name field.

@_date: 2003-04-15 17:27:03
@_author: David Shaw 
@_subject: Cannot sign key with expired signature 
Hash: SHA1
No, this is a real problem.  GnuPG should allow you to re-sign a uid
when the new signature has a different expiration date than the
original.  I'll fix that.
In the meantime, a workaround is to use "delsig" in the --edit-key
menu to remove the old signature before re-signing.

@_date: 2003-04-15 17:29:23
@_author: David Shaw 
@_subject: adduid questions 
Hash: SHA1
Each has its own, but it is common in cases like this to sign each key
with the other to join the webs.

@_date: 2003-04-16 17:45:02
@_author: David Shaw 
@_subject: exporting private key created with GPG to PGP 
Hash: SHA1
This is a FAQ.  See  for step-by-step
instructions on how to do this.  The issue is that PGP (particularly a
version as old as 6) does not implement the newer OpenPGP features.
GnuPG also implements more of the optional ciphers than PGP 6 does.
The FAQ has instructions to alter the feature and cipher list to match
what PGP 6 can handle.

@_date: 2003-04-18 08:26:02
@_author: David Shaw 
@_subject: decipher secret keyring 
Hash: SHA1
Probably the best thing for you to read is RFC-2440.  In particular,
see the section for "Secret Key Encryption", as well as "Secret Key

@_date: 2003-04-18 08:26:34
@_author: David Shaw 
@_subject: 3DES key generation 
Hash: SHA1
GnuPG uses 3DES for session keys, so you do not need to generate
them.  They are generated automatically as needed.

@_date: 2003-04-20 16:07:02
@_author: David Shaw 
@_subject: --verify --always-trust --with-fingerprint broken? 
Hash: SHA1
That is the fingerprint of a null key (i.e. all zeroes).

@_date: 2003-04-22 06:53:02
@_author: David Shaw 
@_subject: [Announce] 1.2.2 release candidate 2 
Hash: SHA1
That seems to be just an error in the rc2 tarball.  Don't worry, the
man page will be back for the real 1.2.2 release.
By the way, you say you built it on MacOS 10.2.5.  Did you use any
options in ./configure, or did you build it straight?

@_date: 2003-04-23 21:06:01
@_author: David Shaw 
@_subject: querying multiple keyservers 
Hash: SHA1
This is on the "to do" list, but is not currently an available

@_date: 2003-04-23 23:07:02
@_author: David Shaw 
@_subject: querying multiple keyservers 
Hash: SHA1
See for the spec that GnuPG follows when making keyserver requests.  It is
fairly easy to implement in a similar manner to the script you have

@_date: 2003-04-24 22:19:02
@_author: David Shaw 
@_subject: Adding Footer on MTA, where MUA using GPG 
Content-Disposition: inline
Mailman 2.1 keeps the original multipart/signed message and adds a
text/plain footer.  I can't speak for all MUAs, but mutt handles it
Content-Disposition: inline

@_date: 2003-04-25 00:25:02
@_author: David Shaw 
@_subject: Messed up my GnuPG settings....help needed. 
Hash: SHA1
Alas, no.  The passphrase is just used to encrypt a random key.  You
can't recreate a key by using the same passphrase.
If you generated a revocation for your previous key, then that's
great.  Just do "gpg --import the_revocation" and the key will be
If you have your old key on a keyserver, then you might want to also
do "gpg --send-key (thekeyid)" to propagate the revocation to the

@_date: 2003-04-29 15:59:02
@_author: David Shaw 
@_subject: Adding Footer on MTA, where MUA using GPG 
Content-Disposition: inline
I'll try attaching it here as a rfc822 item, and I'll send it to you
directly as well.
Content-Disposition: inline
Return-Path: X-PGP-Key: 99242560 / 7D92 FD31 3AB6 F373 4CC5 9CA1 DB69 8D71 9924 2560
X-Request-PGP: X-Phase-Of-Moon: The Moon is Waning Crescent (5% of Full)
User-Agent: Mutt/1.5.4i
X-Mailman-Version: 2.1.1
Precedence: list
Sender: mailman-bounces
Content-Disposition: inline
Content-Disposition: inline
Hi there.  This part of the message is signed.  Notice that Mailman
attaches a footer in such a way that doesn't mangle the signature, and
doesn't become invisible.
Content-Disposition: inline

@_date: 2003-04-30 00:43:01
@_author: David Shaw 
@_subject: missing self-signature ? 
Hash: SHA1
3614 seconds is a bit over an hour.  The user visible "date" may be
the same, but the internal date stamp used by GnuPG has a higher
Check your clock.  If you are sure it is correct, you can wait an hour
or so, or use the --ignore-time-conflict option.

@_date: 2003-08-01 16:01:01
@_author: David Shaw 
@_subject: key question: GNUGP -> PGP -> GNUPG 
Hash: SHA1
No problem, just change the password again but do it without the

@_date: 2003-08-01 16:58:03
@_author: David Shaw 
@_subject: key expiration 
Hash: SHA1
Send me a copy of this shortened key exported from PGP.  I want to
make sure that what I am seeing is exactly what you have, so I cannot
get it from the keyserver.

@_date: 2003-08-01 17:53:02
@_author: David Shaw 
@_subject: key expiration 
Hash: SHA1
Okay, I looked at it, and your problem seems to be a 1-year key
expiration date set on the photo ID.
That said, I don't know why PGP is using that particular expiration
date since there are later self-sigs that give a 10-year expiration
date.  My copy of PGP (8.02) shows it correctly as 10 years.

@_date: 2003-08-01 19:39:02
@_author: David Shaw 
@_subject: key expiration 
Hash: SHA1
It's a keyserver issue, but not for the reason you think.  Most
keyservers reject photo IDs.  The problem 1-year expiration time was
on the photo ID... so it never made it onto a keyserver.

@_date: 2003-08-01 22:48:02
@_author: David Shaw 
@_subject: key expiry (was: Re: PGP8) 
Hash: SHA1
An expired sig doesn't mean an expired key.  The problem you are
having is due to two user IDs that still have a 5-year key expiration
date set on them.
  Todd

@_date: 2003-08-03 03:28:02
@_author: David Shaw 
@_subject: PGP8 
Hash: SHA1
I should say, though, that the PGP folks that I've dealt with have
been extraordinarily nice about GnuPG issues.  I don't know about the
marketing or legal or whatever issues, but the technical people have
been very willing to make PGP<->GnuPG work better.

@_date: 2003-08-05 02:14:02
@_author: David Shaw 
@_subject: digest-algo problem with 1.2.3rc2 
Hash: SHA1
I'm not sure if I understand the problem you are having.  The fact
that you could change the passphrases means that you could already
access your keys...

@_date: 2003-08-05 13:28:01
@_author: David Shaw 
@_subject: digest-algo problem with 1.2.3rc2 
Hash: SHA1
Can you try to duplicate the problem and post the steps you followed?
GnuPG works fine with a s2k digest of sha256.  The error message you
got also doesn't follow from the scenario you describe - if a s2k
digest was used that GnuPG can't handle, the error message is
"md_enable: algorithm %d not available".
I'm wondering if you didn't really comment out the s2k-digest-algo
line, which would give you the exact problem you described.

@_date: 2003-08-08 20:25:31
@_author: David Shaw 
@_subject: extracting a public key from the secret key 
Yes.  All OpenPGP secret keys contain an internal copy of the public
key.  Do this:
gpg --export-secret-key thekey > sec.gpg
gpgsplit --no-split --secret-to-public sec.gpg > pub.gpg
gpg --import pub.gpg
In 1.3.x, you can do:
gpg --import-options convert-sk-to-pk --import secret-key.gpg

@_date: 2003-08-08 21:05:02
@_author: David Shaw 
@_subject: Signing headers (was Re: Evolution signatures) 
PGP/MIME can handle this using a message/rfc822 content-type.
Essentially, it puts the entire message, headers and all, inside the
encrypted or signed portion of the mail.

@_date: 2003-08-10 01:21:02
@_author: David Shaw 
@_subject: Signing headers (was Re: Evolution signatures) 
Content-Disposition: inline
Content-Disposition: inline
X-PGP-Key: 99242560 / 7D92 FD31 3AB6 F373 4CC5 9CA1 DB69 8D71 9924 2560
X-Request-PGP: X-Phase-Of-Moon: The Moon is Waxing Gibbous (92% of Full)
For what it's worth, this is what a signed message/rfc822 message
looks like.  I made it manually with mutt by writing the message out,
then creating a new message and attaching this response to it.
Content-Disposition: inline

@_date: 2003-08-14 21:13:02
@_author: David Shaw 
@_subject: Deleting signatures question. 
You would need to "drive" GnuPG via the --command-fd and --status-fd
The ability to do what you describe has been requested occasionally
(along with the similar "delete all sigs that aren't self-sigs").  It
is on my list of things to look at.  It won't be in 1.2.3 though -
we're too close to release on that to start adding features like this.
Ideally, I'd like to handle it a way to avoid the problem with the
sigs coming back after a refresh.  I'm thinking of import options
"self-sigs-only" (don't import anything that isn't a self-sig, or a
designated revocation), and "known-sigs-only" (don't import a sig from
a key that isn't present on the local keyring).

@_date: 2003-08-14 21:24:01
@_author: David Shaw 
@_subject: make check problem 
It is indeed a shell syntax error.  It is (will be) fixed in the
upcoming version 1.2.3 (soon).

@_date: 2003-08-20 14:06:02
@_author: David Shaw 
@_subject: file decryption executes, but produces no output file 
Hash: SHA1
It is not clear what your problem is, but the very first thing I'd try
is to upgrade your copy of GnuPG:
This version is extremely old.

@_date: 2003-08-20 22:16:02
@_author: David Shaw 
@_subject: compete switch reference for gpg 
If there is a switch that is not in the GnuPG man page, then that is
likely an oversight.  Which switches are missing?

@_date: 2003-08-20 23:57:01
@_author: David Shaw 
@_subject: compete switch reference for gpg 
Hash: SHA1
True.  There are some deprecated options that are not in the manual
any longer.

@_date: 2003-08-20 23:58:01
@_author: David Shaw 
@_subject: compete switch reference for gpg 
Hash: SHA1
Yes.  Most options are not in --help... there are just too many
options and --help should be the most commonly used options.
Keyservers change fairly often, so that is difficult.  The default
gpg.conf file contains a few though.

@_date: 2003-08-21 14:22:02
@_author: David Shaw 
@_subject: compete switch reference for gpg 
Hash: SHA1
gpg --help is a just short reference for common commands.  Not all of
the options are documented there (a good thing, since otherwise the

@_date: 2003-08-22 16:41:02
@_author: David Shaw 
@_subject: Problem with key showing up as expired... 
I'm not sure that anything is wrong here.  The key is, in fact,
expired.  It expired 2003-08-08.  Is this not what you were expecting?

@_date: 2003-08-22 16:51:01
@_author: David Shaw 
@_subject: Expire-date of subkey problem 
You need to specify the subkey if you want to change the subkey
gpg --edit key 1

@_date: 2003-08-24 00:50:01
@_author: David Shaw 
@_subject: FWD: [OCLUG] GNU ftp servers compromised! 
Hash: SHA1
It means nothing in regards to GnuPG.  GnuPG is not hosted on
ftp.gnu.org, and even if it was, each and every GnuPG release is
digitally signed by Werner.  It is not possible to trojan a release
without invalidating the signature.
(Someone will shortly respond to this mail to ask "How do I know it's
really Werner's key.  I have no trust path to him."  The answer is
even if you don't have a trust path to that key, it would be
extraordinarily difficult to replace the dozens of copies of that key
in various places around the net.  Each keyserver has it, many
previous releases of GnuPG have it, etc.)

@_date: 2003-08-24 00:52:01
@_author: David Shaw 
@_subject: Problem with key showing up as expired... 
Hash: SHA1
It depends on how the key was set up by the key owner.  It's certainly
not unusual.

@_date: 2003-08-24 02:33:02
@_author: David Shaw 
@_subject: Problem with key showing up as expired... 
Hash: SHA1
It is expired.  Sort of.  You can't have an unexpired subkey with an
expired primary key.  The primary key always takes precedence and
forces the subkey to be expired.
If the signer is still using this key regularly, it is possible that
he at some point extended the expiration date of his primary key, and
you didn't get a copy of that extension.  I suggest asking the key
owner for a copy of his key.

@_date: 2003-08-26 03:22:01
@_author: David Shaw 
@_subject: Keyring Storage 
Hash: SHA1
The secret keys are stored encrypted on the keyring.  The passphrase
is used to decrypt them just before use.
It is possible to have no passphrase, and thus no encryption, but this
isn't recommended for obvious reasons.

@_date: 2003-08-26 23:34:02
@_author: David Shaw 
@_subject: Wipe function? 
There are no plans.  Wipe functionality, as you point out, is a very
different problem on different platforms and different filesystems.
You need something written for your platform and filesystem.

@_date: 2003-08-27 00:04:02
@_author: David Shaw 
@_subject: Wipe function? 
Peter Gutmann wrote a fascinating paper on this subject.  It turns out
that zeroes aren't enough.

@_date: 2003-08-27 15:58:01
@_author: David Shaw 
@_subject: NAI PGP Keyserver with OpenLDAP 
Can you give me an example of what you mean?  How did you put the keys
into the LDAP server in the first place?

@_date: 2003-08-29 14:01:02
@_author: David Shaw 
@_subject: NAI PGP Keyserver with OpenLDAP 
Hash: SHA1
Interesting.  The code path that LDAP imports follow is actually the
same path that file imports follow.  Can you try creating a
CRLF-delimited key file and importing it via --import on the Win32

@_date: 2003-08-29 14:06:04
@_author: David Shaw 
@_subject: How to add my own algorithm to gnupg? 
Hash: SHA1
The first way.  The extension module feature was removed from GnuPG
for several reasons (portability, code simplicity, lack of use).  To
add a new algorithm, you need to:
a) Write the code for your new algorithm.  See the files in cipher/
   for examples on the GnuPG interface for hashes (see sha1.c), public
   key algorithms (see rsa.c), and symmetric algorithms (see dsa.c).
b) When you need an algorithm number, use something in the 100-110
   range.  These numbers are reserved for this sort of use.
c) Add your algorithm to the necessary table in GnuPG (cipher/md.c for
   hashes, cipher/pubkey.c for public key, and cipher/cipher.c for
   symmetric).

@_date: 2003-08-29 16:06:01
@_author: David Shaw 
@_subject: Infere key frm plaintext and exncrypted version? 
No.  This is a "known plaintext attack", and all of the algorithms
used in GnuPG are resistant to such attack.

@_date: 2003-08-29 16:43:02
@_author: David Shaw 
@_subject: NAI PGP Keyserver with OpenLDAP 
It looks like a LDAP library problem.  Let's test for that.  Try
adding a "keyserver-options keep-temp-files" to your gpg.conf file.
Try and retrieve a CRLF-delimited key from your LDAP server and look
at the temp file.
The temp file will be in a directory named gpg-XXXXXX where the XXXXXX
is random text, and that directory will be in your temp folder
(c:\windows\temp I believe).

@_date: 2003-12-01 16:07:05
@_author: David Shaw 
@_subject: new (2003-11-30) keyanalyze results 
Content-Description: signed data
Heh.  I was waiting for someone to suggest this.  I'm a little
surprised it took this long. ;)
Using a compromised key to revoke a key out from under someone else
raises some interesting ethical questions.  It's similar (though not
quite as problematic) to the use of a virus to patch people's
computers without their knowledge.  I don't plan on doing this, but
it's an interesting question nonetheless.
It's only *possible* where it is the primary.  Subkeys are revoked by
the primary key, so if the primary isn't Elgamal sign+encrypt, then
there is no way to get the revocation signature issued.

@_date: 2003-12-01 18:45:07
@_author: David Shaw 
@_subject: new (2003-11-30) keyanalyze results 
Yep.  Which is why notifications happened, rather than forced
revocations.  This does mean there will be some keys that never get
revoked, but that is being handled on the GnuPG side by refusing to
use them.  Users are free to not upgrade, but eventually there will be
nobody to talk to.

@_date: 2003-12-02 17:04:56
@_author: David Shaw 
@_subject: gpg vs gpgv default keyring directory... 
$ apropos gpgv
 gpgv                 (1)  - signature verification tool
Don't give it encrypted files. ;)

@_date: 2003-12-02 18:12:19
@_author: David Shaw 
@_subject: Invalid Packet (ctb=3b) 
It's possible.  The file does look corrupt.
I sometimes recommend that people generate files in ASCII armor, so
whether they use ascii or binary ftp, the file is not harmed.

@_date: 2003-12-02 19:16:56
@_author: David Shaw 
@_subject: Corrupted Files -- Need Help 
Interesting.  Those files were generated with PGP (you can tell from
the ":marker packet: 50 47 50").  How were they transferred to you?
If it was FTP, can you ensure that it wasn't ASCII mode?
Try having the user send you an ASCII armored file.  Also try having
the user zip the file before sending it, which can help establish
where the corruption is happening.
Out of curiosity, try decrypting each with the --show-session-key
flag.  Don't post the output - just tell me if the key is the same for
all three.

@_date: 2003-12-03 23:34:20
@_author: David Shaw 
@_subject: Remove Address From Key? 
You can revoke the old address.
$ gpg --edit-key 9ABF6F14
Enter the number of the user ID that you want to revoke, then
"revuid".  Follow the prompts.

@_date: 2003-12-04 00:55:16
@_author: David Shaw 
@_subject: public keyring management practices (was: Re: GPG Recipients 
I've occasionally toyed with making an option to automatically do a
refresh before encrypting, and a different option to automatically do
a refresh when verifying.  I haven't done it because the load on the
keyservers would be brutal.  I'd be curious if someone has a different
take on that, or how they would want such a feature to work.
For me, I'd only really care to know if the key was revoked.  New sigs
are useful, but that's not something I generally need to know right
before I encrypt something.  Simon Josefsson's work with storing keys
in DNS might be useful here for really lightweight revocation checks.
Revocation certs are pretty small (~75 bytes for DSA), and can
generally be sent in one DNS packet.
If/when people start using the "preferred keyserver" packets on their
keys (partially implemented in 1.3.x now), it's possible to fetch the
revocation from there (which could be, for example, a file on their
web page).

@_date: 2003-12-04 02:12:57
@_author: David Shaw 
@_subject: GPG Recipients List 
Probably, but I think what really happened was that you got two
different servers in the subkeys.pgp.net rotation.  16DE8D28 is a
subkey, so one server allowed searches by subkey, and one didn't.

@_date: 2003-12-05 01:28:54
@_author: David Shaw 
@_subject: port 80 keyserver access (was Re: GPG Recipients List) 
It won't.  There are an infinite number of ways that different scripts
can be used to relay keyserver commands.  We can't support every
single one.
That is the proper solution if you want a keyserver that runs on port
80: actually run a keyserver on port 80, port forward, or run a proxy
that forwards.  None of those solutions require a custom keyserver

@_date: 2003-12-05 01:37:20
@_author: David Shaw 
@_subject: public keyring management practices (was: Re: GPG Recipients 
I don't know.  Jason, do you have any ideas?
I like the idea of a revocation server, but there is a danger of using
an existing keyserver protocol in that a user could point their
revocation-keyserver to the same place as their regular
keyserver.  Since the protocols would be the same, the regular
keyserver would get hammered.
To be sure, there is only so much that can be done to protect users
from doing stupid things, but in this case, it's really more
protecting the keyserver operators from users doing stupid things :)

@_date: 2003-12-05 06:25:08
@_author: David Shaw 
@_subject: GPG Recipients List 
Content-Description: signed data
There is always the keys-by-mail service.  Email generally makes it
through firewalls.
gpg --keyserver mailto:pgp-public-keys --send-key KEYID

@_date: 2003-12-05 20:56:57
@_author: David Shaw 
@_subject: port 80 keyserver access (was Re: GPG Recipients List) 
Hmm.  I get the same, but I can retrieve the key by telnetting to port
80.  I suspect the problem is that GnuPG's HTTP handler does not
provide the "Host:" header and keys.se.linux.org is a virtual host.

@_date: 2003-12-06 02:14:38
@_author: David Shaw 
@_subject: port 80 keyserver access (was Re: GPG Recipients List) 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
That's about it.  You don't want to change the HTTP version to 1.1
though.  This isn't true 1.1, but rather 1.0 with a Host: header.
There is no host header used to the http_proxy case since the proxy
itself gets to send the host header.  You also need to make "request"
a little bigger just in case.
Index: http.c
RCS file: /cvs/gnupg/gnupg/util/http.c,v
retrieving revision 1.12.2.2
retrieving revision 1.12.2.3
diff -u -r1.12.2.2 -r1.12.2.3

@_date: 2003-12-06 18:33:45
@_author: David Shaw 
@_subject: Non-revokable signing of keys? 
Revocable means that you can go back later and revoke your signature
if you choose to.  Nonrevocable means you can't.  Nonrevocable isn't
that useful in the real world since people want the ability to revoke
their own signatures.

@_date: 2003-12-09 18:30:35
@_author: David Shaw 
@_subject: RSA key size restriction? 
Note that the limit is for generation of these keys.  If you generate
a larger key somewhere, GnuPG is able to work with it.

@_date: 2003-12-10 23:53:51
@_author: David Shaw 
@_subject: RSA key size restriction? 
Remember that hiding it behind --expert (and a "Don't do this!"
message) still didn't stop people from generating Elgamal sign+encrypt
keys.  If the key sizes are available under --expert, then people will
inevitably generate them, thinking "bigger must be better".  However,
bigger isn't always better: very large keys are slower, problematic
for signatures (a 16k RSA clear signature is 45 lines long!), and
terrible for compatibility with anything other than GnuPG or hacked
versions of PGP.
Again, if someone generates such a key, GnuPG will work with it.  I
still don't see the need to make it easy to generate them though,
especially given that if someone wanted it badly enough, they can
remove the line of code that prevents it themselves.

@_date: 2003-12-11 01:32:05
@_author: David Shaw 
@_subject: feature request: allowing display of session key used for 
In 1.3.x you can do -r for regular recipients,, and -R for hidden
recipients, and mix them however you please.

@_date: 2003-12-11 21:12:47
@_author: David Shaw 
@_subject: RSA key size restriction? 
Yes, but before the key was generated, they had to agree to:
  The use of this algorithm is only supported by GnuPG.  You will not
  be able to use this key to communicate with PGP users.  This
  algorithm is also very slow, and may not be as secure as the other
  choices.  Create anyway?
The README reflected the belief that the implementation was secure.
The warning reflected the belief that despite being believed secure,
it was not a good idea. ;)
Search for "keysize too large" in g10/keygen.c

@_date: 2003-12-12 20:10:28
@_author: David Shaw 
@_subject: gpg-agent question 
I was half kidding in my response.  GnuPG can handle this, but not
because of something special in GnuPG.  Having different passphrases
on different subkeys is a requirement of the OpenPGP format - each key
is encrypted by itself.  If the user happens to use a different
passphrase on each, then the end result is a different passphrase on
The user interface in GnuPG doesn't allow you to make such a key, but
if you can do it elsewhere, GnuPG will properly handle the key.
The only way to do it right now is to manually build the key using
gpgsplit.  Export the secret key and gpgsplit it.  Then, change the
passphrase, re-exprt, and re-gpgsplit.  Now copy the subkey with the
new passphrase over the subkey with the old passphrase, leaving the
other packets intact.  Reassemble, and re-import the key.  It's a

@_date: 2003-12-12 20:27:06
@_author: David Shaw 
@_subject: RSA key size restriction? 
V3 subkey signatures are legal, but certainly a bit odd.
Out of curiosity, do you know how or why your correspondent came up
with 7680 bits in particular?

@_date: 2003-12-13 15:34:43
@_author: David Shaw 
@_subject: feature request: allowing display of session key used for 
This is correct.  The size and the asymmetric algorithm number is
visible.  There are also a lot of hints in a message as to what
version of PGP or GnuPG generated it.
What --throw-keyid does is make the job harder.  There are a whole lot
of "2048-bit RSA keys" out there.  Removing the keyid helps the key
owner to hide in the crowd.
If you use an uncommon key size or key algorithm, the crowd you can
hide in is smaller: there aren't many "3232-bit Elgamal sign+encrypt
keys" out there.
Not by itself, no.  Hidden recipients are intended to make
identification harder, not impossible.

@_date: 2003-12-15 00:59:54
@_author: David Shaw 
@_subject: RSA key size restriction? 
Hash: SHA1
If I recall, there was a version of PGP that did allow using Elgamal
keys for signatures, but it used the Elgamal encrypt-only keytype to
do it.  There was some uncertainty back then - PGP 5.0 came out nearly
a year before RFC-2440.

@_date: 2003-12-15 15:39:56
@_author: David Shaw 
@_subject: Change comments? 
Hash: SHA1
The comments are part of the user ID string, and are not changeable.
You need to create a new user ID with the comments you want, then
delete or revoke the old user ID.

@_date: 2003-12-17 23:56:11
@_author: David Shaw 
@_subject: Can --textmode break things ? 
If you can guarantee that you will never send anything that isn't
text, you can safely stick --textmode in your options file.

@_date: 2003-12-18 19:54:14
@_author: David Shaw 
@_subject: Handling of different key types with GnuPG 
I don't understand why you should have such problems.  --pgp2 is
needed for PGP 2.x compliance.  However, all other --pgpX options are
not generally useful and exist only for the case where a key has bad
preferences.  For example, if you generate a key in GnuPG and put in a
AES preference, and try to use that key in PGP 6, you won't be able to
decrypt because people will follow your preference and use AES.  What
--pgp6 does is pretend that the preferences on the key are "cast5 3des
If you are communicating with a PGP 2.x user, you usually need --pgp2.
The overwhelming majority of the other times, the right thing to do is
to use NO --pgpX option at all.  --pgpX is really only there to work
around the fact that PGP doesn't have any way to update preferences on
imported keys.

@_date: 2003-12-19 16:41:23
@_author: David Shaw 
@_subject: Symmetric Encryption Requirement 
You can get the key with --show-session-key and write it to a file
however you like, but it is unlikely you will be able to decrypt the
data without doing some work, as OpenPGP programs use a special
"OpenPGP cipher feedback mode" which may not be supported by your
generic 3DES implementation.
Why not just run GnuPG on the mainframe?

@_date: 2003-12-19 17:01:00
@_author: David Shaw 
@_subject: Symmetric Encryption Requirement 
Content-Description: signed data
RFC-2440: You can modify the GnuPG code.  See cipher/cipher.c and cipher/des.c.
The code is capable of doing regular CFB, but obviously that piece of
the code doesn't get used too often since it isn't used in PGP.
GnuPG can decrypt in batch processes - it can take the passphrase via
stdin and never prompt the user.
The major difficulty in porting GnuPG to odd platforms is the need for
a random number source.  Since you are only decrypting on the
mainframe, no true randomness is needed for that.  This should make
porting substantially easier.  What happens when you do ./configure on
GnuPG on the mainframe?

@_date: 2003-12-19 18:11:16
@_author: David Shaw 
@_subject: Symmetric Encryption Requirement 
Oops - my mistake.  Using --show-session-key with symmetric messages
is a fairly new feature that was added in version 1.3.4.  That's the
development version, so you probably aren't using it.
For symmetric files, the most common way to make the session key is to
take the passphrase and repeatedly hash it (usually using SHA1) along
with some random salt.  The method is given in RFC-2440 as "iterated &
hashed S2K".  For public key encrypted files, the session key is
It is stored in the encrypted file.  If you run gpgsplit (comes with
GnuPG) on a symmetric file, you'll end up with two files:
"000001-003.sym_enc" and "000002-009.encrypted".  The first is the
session key (see RFC-2440 for the format of packet   The second is
the encrypted data (see RFC-2440 again, for packet I'd seriously try and build GnuPG on the mainframe.  Given that you
don't need a random number source, it should be fairly simple to come
up with the right set of configure options to build the thing.

@_date: 2003-12-19 20:29:16
@_author: David Shaw 
@_subject: Symmetric Encryption Requirement 
What linker do you have?  If it isn't in your PATH, then you need to
specify it manually with somthing like:
Also see the config.log file.  Whenever configure fails, the last
entry in config.log is more information about the item that caused the

@_date: 2003-12-20 05:50:11
@_author: David Shaw 
@_subject: RSA compatibility 
Hash: SHA1
Define "reasonably current".  It it means "any PGP after 7, and any
GnuPG after 1.0.6" then yes, it's compatible.  You could probably go
back even further, but those are both quite old now and known to work.

@_date: 2003-12-20 15:27:43
@_author: David Shaw 
@_subject: RSA keys (1.2.3) 
Hash: SHA1
No.  RFC-2440:
    There are algorithm types for RSA-signature-only, and
    RSA-encrypt-only keys. These types are deprecated. The "key flags"
    subpacket in a signature is a much better way to express the same
    idea, and generalizes it to all algorithms. An implementation
    SHOULD NOT create such a key, but MAY interpret it
RSA sign-only and encrypt-only is a RSA sign+encrypt key with key
flags set.

@_date: 2003-12-23 04:28:07
@_author: David Shaw 
@_subject: encrytp to specific key 
It is certainly documented.  In the man page, under "HOW TO SPECIFY A
USER ID":
       Note that you can append an exclamation mark to key
       IDs or fingerprints.  This flag tells GnuPG to  use
       exactly  the given primary or secondary key and not
       to try to figure out which secondary or primary key
       to use.

@_date: 2003-12-23 15:17:39
@_author: David Shaw 
@_subject: encrytp to specific key 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
No.  Senders are free to pick whatever subkey they like.

@_date: 2003-12-23 18:09:16
@_author: David Shaw 
@_subject: encrytp to specific key 
Whatever the sender's program decides to use.  GnuPG uses the most
recent key that is not expired, not revoked, and of an appropriate
type (i.e. it won't try and encrypt to a sign-only key).

@_date: 2003-12-24 18:50:38
@_author: David Shaw 
@_subject: Symmetric Encryption Requirement 
I've occasionally thought about writing a very simple program that can
handle OpenPGP symmetric encrypted files (i.e. gpg --symmetric).  I
expect it wouldn't be that difficult to do, especially since the
crypto stuff can be trivially pulled in from gcrypt or openssl, or use
the crypto hardware on some platforms like yours.

@_date: 2003-12-29 17:36:11
@_author: David Shaw 
@_subject: "unusable public key" on encryption 
It's probably a sign-only key.  Do this:
 gpg --export 3006DF31 | gpg --list-packets | grep flags

@_date: 2003-12-29 21:41:01
@_author: David Shaw 
@_subject: Errors compiling 1.2.4 on OpenBSD 3.4 
OpenBSD used to have a different/unusual assembler than the other
BSDs, so there is special code to handle that.  If OpenBSD 3.4 changes
this, then there could be a problem.
What happens if you apply the attached patch to mpi/config.links ?

@_date: 2003-12-29 22:09:28
@_author: David Shaw 
@_subject: Errors compiling 1.2.4 on OpenBSD 3.4 
cd gnupg-1.2.4/mpi
patch < /the/path/to/the/saved/patch/file/I/sent/you
cd ..

@_date: 2003-12-29 22:35:18
@_author: David Shaw 
@_subject: Errors compiling 1.2.4 on OpenBSD 3.4 
I disabled the special OpenBSD assembler handling.  It looks like
OpenBSD doesn't need it any more.
I'd appreciate it if anyone with an OpenBSD 3.3, 3.2, 3.1, or 3.0 box
could try the same patch and see what happens.  I'm not sure when
OpenBSD changed things, so it's difficult to write a proper fix for
the next version of GnuPG.

@_date: 2003-12-29 22:51:26
@_author: David Shaw 
@_subject: trust problem 
It's not better if people already have problems understanding the
"dumbed-down" model.  As it happens, GnuPG 1.3 supports the Maurer
trust model (a simplified version with no cycles).  However, this
model isn't that useful given the common uses of PGP and GnuPG.  PGP
has supported the Maurer trust model for years, and I think I've seen
it used all of once.
"well thought out" and "dumbed-down" are the wrong words to use to
describe the trust models available.  The right words are "does it
allow me to express what I want to express?"  The classic PGP trust
model is very well suited for what it is used for - no CA, iffy
connectivity, and everyone deciding for themselves who or what they
will trust to what degree.

@_date: 2003-12-29 23:36:19
@_author: David Shaw 
@_subject: Errors compiling 1.2.4 on OpenBSD 3.4 
Okay, try this new patch.   Remember to re-"./configure", and "make
clean" after patching.  Ideally, it should work properly on both 3.3
and 3.4 (and previous versions as well).
Any OpenBSD users who can try this on different versions of OpenBSD
would be much appreciated.

@_date: 2003-12-30 01:10:49
@_author: David Shaw 
@_subject: Errors compiling 1.2.4 on OpenBSD 3.4 
Freshly unzipped.  If you could do it on both your 3.3 and 3.4 boxes,
that would be ideal.

@_date: 2003-12-30 02:30:01
@_author: David Shaw 
@_subject: Errors compiling 1.2.4 on OpenBSD 3.4 
You could send me your mpi/asm-syntax.h file, and I'll take a look.
I don't have an OpenBSD box here though, and this sort of problem is
nearly impossible to track down without one.

@_date: 2003-12-30 02:39:28
@_author: David Shaw 
@_subject: "unusable public key" on encryption 
Hash: SHA1
It means it is an sign-only key.  GnuPG won't encrypt to it because
the key is only for signing.  The key owner needs to add an encryption
subkey before you can encrypt to that key.

@_date: 2003-12-30 14:53:14
@_author: David Shaw 
@_subject: show photo Not working in GnuPG 1.2.4 on WinXP Pro? 
Hash: SHA1
The photo code hasn't changed between 1.2.3 and 1.2.4, so I'm not sure
what problem you could be having.  Did 1.2.3 work for you on XP Pro?
Try adding "--debug 1024" to your GnuPG command line.  That will print
out everything it is doing with regard to photo IDs.

@_date: 2003-12-31 01:38:52
@_author: David Shaw 
@_subject: trust problem 
If I recall, the Modeling a Public Key Infrastructure paper is from
the PGP 2.x era.  When PGP 5 was being developed, the paper was used
to make a new trust model.
There are two main trust models in GnuPG.  First, the "classic", has
user IDs being the item being signed.  A key signs a user ID, thus
expressing the key owner's belief that the user ID is valid.  The user
ID belongs to a key of its own, of course, and that key becomes the
beneficiary of this validity.
The "PGP" model is the one based on Maurer.  The idea is that each
signature has a numeric value embedded in it, and validity is a
function of that value.  So if A signs a user ID on B with 100 points,
and A is fully valid, then B has 100 points.  B can then sign a user
ID on C, but can only use 100 points to do it (if B signs with 200
points, C only gets 100 of them).  By convention, 60 points is
equivalent to the classic trust model's "partial trust", and 120
points is equivalent to "full trust".  The signature can also have the
number of levels the points may travel, and a regular expression to
match user IDs on which the points may travel.  Thus you can make
signatures that say such things as "I sign B's user ID, but I only
trust B enough to make people partially trusted and only for people at
aol.com.  All trust must stop after 2 hops.".  A given key may only be
a member of one chain at a given time.  By convention, the most recent
chain is chosen.
It's sort of loosely based on Maurer's paper, with the changes you see
to accomodate using it alongside the classic trust model.

@_date: 2003-12-31 17:55:40
@_author: David Shaw 
@_subject: show photo Not working in GnuPG 1.2.4 on WinXP Pro? 
No, use --debug 1024 on the gpg command line:
  gpg --debug 1024 --edit-key (whatever)
  showphoto

@_date: 2003-12-31 19:29:18
@_author: David Shaw 
@_subject: show photo Not working in GnuPG 1.2.4 on WinXP Pro? 
Probably.  You can see the command line the GnuPG is executing.  If
you can't run that command line yourself, then you know where the
problem is.

@_date: 2003-02-01 08:02:39
@_author: David Shaw 
@_subject: Getting rid of old uids from my key... 
What you need to do is revoke the extra user IDs.  You can do this
from the --edit-key menu.  Select the user ID you want to revoke, and
enter "revsig".  Revoke the self-signature on that user ID, and the ID
itself will become revoked.
In the development version 1.3.x, you can use "revuid" directly.

@_date: 2003-02-02 15:13:02
@_author: David Shaw 
@_subject: Remailers 
Start here:    David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2003-02-02 19:39:01
@_author: David Shaw 
@_subject: Remailers 
what
Last I looked, it was v3 RSA only.  If you use --pgp2, GnuPG shouldn't
have any problems talking to the remailers.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2003-02-05 14:49:02
@_author: David Shaw 
@_subject: What is 'gpg: Warning: unsafe permissions on directory ' 
It means that the directory referenced was either:
1) Not owned by you
2) Gives read or write permission to someone other than you.
In certain cases, like CGIs or other unattended installs, the warnings
are not useful for one reason or another.  In these cases, you can use
the "no-permission-warning" option.

@_date: 2003-02-05 17:39:02
@_author: David Shaw 
@_subject: mutt question 
Mutt is generating PGP/MIME messages.  That's a good thing if it is
supported by your recipient, and a frustrating thing if it isn't.
Mutt comes with a document PGP-Notes.txt, and one of the questions in
there is "I don't like that PGP/MIME stuff, but want to use the old
way of PGP-signing my mails.  Can't you include that with mutt?".
A complete explanation is in there.

@_date: 2003-02-06 05:46:01
@_author: David Shaw 
@_subject: gpg: no handler for keyserver scheme "ldap" 
This is a flaw in the RPM spec file.  The --libexecdir is specified to
be just the root libexec directory, and not a program-specific
Yes.  None of the makefiles install anything into the libexec
directory, so there is no need to set a different $libexecdir there.
The keyserver makefile does install things into $libexecdir, so it
needed to be set.  Basically, the keyserver $libexecdir is correct.
All the others are wrong.

@_date: 2003-02-06 05:56:01
@_author: David Shaw 
@_subject: gpg: no handler for keyserver scheme "ldap" 
What happens when you run it by hand (i.e. "/usr/lib/gnupg/gpgkeys_ldap -V")
What is your exec-path?  What happens if you set it to
"/usr/lib/gnupg" ?

@_date: 2003-02-06 21:29:01
@_author: David Shaw 
@_subject: gpg: no handler for keyserver scheme "ldap" 
Ah, that explains what happened.  makeinstall is overriding the
libexecdir setting, which causes gpgkeys_ldap to go into the
overridden libexecdir.  However, the main gpg binary isn't overridden,
so it contains the hardcoded path.
I think I can fix this without too much fuss for the next release.

@_date: 2003-02-06 23:35:02
@_author: David Shaw 
@_subject: how can i remove gnupg 
Go into the gnupg build directory and do "make uninstall".

@_date: 2003-02-09 04:52:02
@_author: David Shaw 
@_subject: encryption to multiple recipients 
Yes, this is a typo (it is fixed for 1.2.2). The man page has the
right syntax.

@_date: 2003-02-09 04:52:24
@_author: David Shaw 
@_subject: building GPG 1.2.1 on HP/UX 11.11 
There is a an autoconf check for inline.  It is strange you had a
problem with a P.h file - is this a clean source tree or did you build
GnuPG on a different machine first and copy the files over to build it

@_date: 2003-02-09 04:52:46
@_author: David Shaw 
@_subject: Lost key -- retrieval possible? 
That is indeed weird.  That means you have something other than a
secret key mixed in with your secret key data.  It does look like
The first thing to try is to export and re-import the key - with a bit
of luck, the important parts of the key won't be corrupt.
  cp ~/.gnupg/secring.gpg ~/.gnupg/secring.backup
  gpg --export-secret-key nori > nori.gpg
  gpg --delete-secret-key nori
  gpg --import nori.gpg
If that does not help, then I need some more information.  What
happens when you do:
  gpg --no-comment --export-secret-key nori | gpg --list-packets
That will display the structure of your secret key.

@_date: 2003-02-10 03:07:03
@_author: David Shaw 
@_subject: why must gnupg user-id "real names" be at least 5 characters long? 
Use --allow-freeform-uid to remove any restrictions on the user ID.
It is used to identify the owner of the key.  When someone signs your
key, they are actually signing the user ID plus the key data.

@_date: 2003-02-10 03:08:02
@_author: David Shaw 
@_subject: sending a public key to a keyserver 
It sounds like the keyserver already has a copy of your key.  In
general, I would not use keyserver.net.  It has many bugs that make it
a poor choice for key storage.

@_date: 2003-02-10 03:16:02
@_author: David Shaw 
@_subject: inline problem 
autoconf defines inline in config.h, and all of the intl/ files seem
to include that before including gettextP.h.  Can you tell me which .c
file is breaking?  Also, what does config.h show for "inline"?

@_date: 2003-02-11 01:41:02
@_author: David Shaw 
@_subject: why must gnupg user-id "real names" be at least 5 characters long? 
Neither do I.  There are many difficulties with userids like that, not
the least of which is "So, show me a photo ID that says you are Bart

@_date: 2003-02-11 01:41:24
@_author: David Shaw 
@_subject: inline problem 
Good catch there.  I think it would be good to report this to the
autoconf people (cc'd).  They can then improve the "inline" testing
code to catch this case, and all autoconfed software can benefit.
For the autoconf folks: GnuPG uses autoconf 2.54.

@_date: 2003-02-11 01:42:01
@_author: David Shaw 
@_subject: FAQ addition 
Another solution for the same problem is in GnuPG 1.2.2.  1.2.2 comes
with a script "convert-from-106".  If you run it, it automatically
tags all of your secret keys as ultimately trusted.
(As the name suggests, the script is intended for people upgrading
from 1.0.6 or earlier, but it works for this as well).

@_date: 2003-02-11 01:43:01
@_author: David Shaw 
@_subject: Lost key -- retrieval possible? 
That's a public key.  Are you sure you got that from your secret
keyring?  If so, I think when you were copying data around, you might
have copied your public key on top of your secret key.  That is
consistent with the other errors you reported as well.
Do you have any backups?  Or perhaps when you were copying files
around you copied the secret keyring into a different file?

@_date: 2003-02-11 14:51:02
@_author: David Shaw 
@_subject: Lost key -- retrieval possible? 
That's very strange.  If you just copied the .gnupg directory whole,
this should not be possible.  Perhaps as the disk was failing one file
became munged into another?
You don't need to do all the renaming: just run "gpg --list-packets"
on each file in question.  Grep for "secret".

@_date: 2003-02-12 19:53:02
@_author: David Shaw 
@_subject: gnupg and subkeys 
I've added this to the devel branch.  If you specify "primary_keyid!"
you get the primary key only.  If you specify "subkey_keyid!" you get
the primary plus that subkey.  If there is no exclamation point, you
get the whole key as before.
Note that this syntax works for --export and --export-secret-keys as
well as --export-secret-subkeys.

@_date: 2003-02-12 22:51:02
@_author: David Shaw 
@_subject: gnupg and subkeys 
Well this feature is in the development version (1.3.2).  It won't be
in the next stable release (1.2.2).

@_date: 2003-02-13 21:41:02
@_author: David Shaw 
@_subject: gnupg 1.2.1 IDEA support 
Try and force that.  Edit the idea.c file and remove all the for endianness and replace them with
   BIG_ENDIAN_HOST 1

@_date: 2003-02-14 14:57:01
@_author: David Shaw 
@_subject: gnupg 1.2.1 IDEA support 
Ok, I need you to do me (and all future AIX/powerpc users ;) a favor.
Send me the output of "gcc -E -dM - < /dev/null", and I'll fix idea.c
to work without hackery.

@_date: 2003-02-14 18:43:02
@_author: David Shaw 
@_subject: gnupg 1.2.1 IDEA support 
Ok.  What does "gcc -E -dM - < /dev/null" output on your machine?

@_date: 2003-02-15 14:40:02
@_author: David Shaw 
@_subject: Ohhhhh jeeeee bug persists! 
You were having problems because of a public key in your secret
keyring.  When you generated your new key, did you keep your old
public key in the secret keyring?  GnuPG is having problems getting
past it.
If that is the case, it's fixable.  To confirm that is the case, what
happens when you do --list-secret-keyring ?

@_date: 2003-02-15 15:03:01
@_author: David Shaw 
@_subject: gnupg 1.2.1 IDEA support 
Aha, that's the one.  I'll put it in.  This is almost as fun as the
guess-the-dependency game ;)
I think I will change the idea.c file so it gets endianness from
GnuPG at least when it is being built in directly.  That should
simplify things.

@_date: 2003-02-17 13:48:01
@_author: David Shaw 
@_subject: gpg barfing on system on which i don't use it 
Your public keyring is not in public keyring form.  Corrupt, perhaps.

@_date: 2003-02-18 18:12:01
@_author: David Shaw 
@_subject: gpg -c option 
CAST5 unless you change it.
Use the --cipher-algo option.
Yes, you can.  There is a several byte header on the data.  You can of
course remove the header if you choose, but GnuPG does not do that

@_date: 2003-02-19 18:09:01
@_author: David Shaw 
@_subject: Problem with GnuPG 1.2.1 generated Key (Broken Key or Keyserver Problem) 
The key is fine.  The pksd keyserver on pgp.mit.edu has a known bug
that causes the keyid to appear incorrectly.  This is only cosmetic,
but it is annoying.  I submitted a fix for this bug in the latest
version of pksd (0.9.6), and I'm sure that the operators of pksd
keyservers will be upgrading at some point.

@_date: 2003-02-21 13:21:02
@_author: David Shaw 
@_subject: Certs by a revoked key 
No, because unless you are talking about a very special use where the
sender and receiver have rigidly controlled clocks and nobody else can
participate, there is no way to tell whether the "old signatures"
predate the revocation or not.

@_date: 2003-02-21 13:56:02
@_author: David Shaw 
@_subject: Elgamal signatures (was Re: splitting keys) 
I guess it depends on why you are signing.  If the intent is to get
other people to check the signatures on your messages to verify they
did indeed come from you, then it does sort of defeat the purpose of
signing if checking the signature is so unpleasant that nobody does
There are many reasons not to use Elgamal signatures.  Only GnuPG
supports them, so you can't communicate with any other OpenPGP
program.  They are also incredibly slow, which means people have to
sit for 10-20 seconds every time they need to check one of your
messages.  If they have their mail reader configured to automatically
verify signatures, then they can be reading happily along, hit one of
your messages, and they're locked up for a while.
Seriously, if you don't like the 1024-bit DSA limit, use RSA.

@_date: 2003-02-23 15:02:01
@_author: David Shaw 
@_subject: Certs by a revoked key 
I'm sorry - perhaps I misunderstood your point.  GnuPG doesn't use
signatures from revoked keys in trust calculations.

@_date: 2003-02-23 15:03:01
@_author: David Shaw 
@_subject: Certs by a revoked key 
No, they are the same.  PGP signatures contain a signed signing time
as well.  In both cases, the signing time is only as reliable as the
signer's clock.

@_date: 2003-02-23 21:12:01
@_author: David Shaw 
@_subject: Certs by a revoked key 
A signature timestamp can be compared - in theory - with the timestamp
of a revocation signature for reasons 0x01 and 0x03 to tell whether
the signature should be accepted or not.
I say "in theory" because while the RFC says this, the clocks used in
general-purpose OpenPGP programs like PGP and GnuPG are not even
vaguely reliable enough.  For certain embedded uses that do not
communicate with the outside world of bogus clocks, this feature might
be usable.
There is when there is no reliable way to tell the difference between
"retired" and "compromised", or more specifically "compromised after

@_date: 2003-02-24 21:23:01
@_author: David Shaw 
@_subject: Certs by a revoked key 
No, multiple revocation certs are supported (section 10.1 of the spec:
"Zero or more revocation signatures").  While it is true that a
retired key could be compromised, that's not really my point either.
Let's make sure we're talking about the same thing.  What exactly are
you suggesting here?  It sounds like you are saying that the 0x01 and
0x03 revocation reasons are a "revocation lite" that means "don't use
this key anymore, but don't really fully revoke it in terms of the web
of trust either".

@_date: 2003-02-24 22:11:01
@_author: David Shaw 
@_subject: Certs by a revoked key 
How would you handle this scenario: Alice signs Baker's key at
timestamp 1, and Charlie's key at timestamp 3.  Now, we get a 0x01 or
0x03 revocation for Alice's key with timestamp 2.
What does this mean to Alice's signature on Charlie's key?  On top of
that we've already established that we can't trust any timestamps, so
what does it mean to Alice's signature on Baker's key?

@_date: 2003-02-25 01:05:02
@_author: David Shaw 
@_subject: Certs by a revoked key 
Not completely true - the 0x01/0x03 revocation means "don't use this
key except for trust calculations".  The key still wouldn't be used
(for encryption), so the revocation is not useless.
I agree.
Werner and I had a mail conversation about this a few months ago that
you and I have more or less reconstructed at this point ;) (I was
arguing for the same thing you are arguing for).
Forgetting the RFC for a moment, note that if this was implemented,
GnuPG would be the only program that handles "soft revoked" keys
properly.  There is a huge software base (including PGP) that treats
them as hard revoked.  This is not a reason not to do it, of course,
or we'd never progress, but it does mean that even if it is
implemented, it won't be globally useful for a long time until more
programs support it.  Similarly, the keyservers don't handle this, so
soft revoked keys appear hard revoked.
To clarify: I'm more concerned about a malicious user setting their
clock incorrectly on purpose, rather than clocks being untrustworthy
in general.  A malicious user - or even Alice - can continue to issue
signatures from a soft revoked key by manipulating the timestamps.  It
could be argued that this isn't a problem.  If someone other than
Alice has the secret key, then the key should be hard revoked, and if
Alice is the one doing it, well, it's Alice's key anyway.  Using that
logic, it could even be argued (though I disagree and I believe you do
too) that the signature on Charlie's key from the example should be

@_date: 2003-02-25 01:37:02
@_author: David Shaw 
@_subject: Certs by a revoked key 
The RFC (2440) doesn't say this.  2440bis does (or it seems to), but
2440bis hasn't been finalized into an RFC yet and so everything in it
that isn't also in 2440 is subject to change (of course, some of the
2440bis stuff has been trickling into implementations for a while,
official standard or no).  It would be interesting to track down the
person who championed that particular language change and see exactly
what their intent was.
Globally useful meaning if I make this statement ("I don't use this
key anymore, but it isn't compromised, so keep the trust"), it will be
more widely understood than in GnuPG alone.  A use on your own keyring
is only locally useful ;)
For example, it took a long time to get support for signing subkeys
into PGP.  Until that happened, signing subkeys were not globally
You wouldn't really lose it - if and when programs started handling
soft revocations like you hope, the trust in that key will
automatically return.
I agree about the keyserver brokenness, but it isn't really a seperate
issue.  GnuPG has to play in a larger playing field than GnuPG - if a
change like this is to be made, it has to be made with some thought as
to what this will do to other implementations and common uses.  Since
the other implementations treat soft revocations as hard revocations,
that's "failing safe", so I don't see a problem.  Perhaps someone else
Perhaps Werner would comment.

@_date: 2003-02-25 01:52:24
@_author: David Shaw 
@_subject: can't change the primary uid on a RSA key 
Hash: SHA1
Note the error message you received.  User IDs with v3 self-signatures
(generally old PGP 2.x keys) cannot receive the primary uid flag.
That is a v4 feature and requires more modern keys.
You can promote your old key to one with v4 self-signatures, but then
the key cannot be used in PGP 2.x any longer.

@_date: 2003-02-25 18:21:01
@_author: David Shaw 
@_subject: Certs by a revoked key 
Content-Disposition: inline
Ah, I understand now.  Yes, this is true, but is it different from the
current problem where an attacker can prevent the victim from getting
at any revocation?  That is, use the same example as you gave, but
just remove the soft revocation from the equation.
Indeed.  For me, discussions are half the fun in working on GnuPG.
The fact that Richard and I mostly agree doesn't hurt either..
Content-Disposition: inline

@_date: 2003-01-02 15:25:02
@_author: David Shaw 
@_subject: key signing 
If you type a question mark (?) when GnuPG asks this question, you
will get a long explanation.  That text is:

@_date: 2003-01-02 15:42:02
@_author: David Shaw 
@_subject: GnuPG footprint questions 
The easiest thing to do is to build it with:
./configure --disable-exec --disable-nls --disable-dynload
It's not difficult to go even smaller by stripping out various ciphers
or the help text strings, but there is currently no way to do that
with a simple ./configure option.  You'd have to edit the source.
As for removing the encrypt functionality, that's an edit-the-source
as well.  I wonder how much space you'd save doing that, since the
encrypt and decrypt functions share a lot of the same underlying code.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2003-01-03 01:54:02
@_author: David Shaw 
@_subject: Receiving a key on standard output 
The only difficulty with this is that versions of GnuPG less than 1.3
don't have a gpgkeys_hkp - only gpgkeys_ldap and gpgkeys_mailto.
Without gpgkeys_hkp, I think the easiest way to fetch a key from a
keyserver into a file is with wget or similar programs:
 wget -O thefile.asc '
'thefile.asc' now has the key.

@_date: 2003-01-03 08:25:02
@_author: David Shaw 
@_subject: Listing the signatures of a certain UserID 
I guess I'm not exactly sure what you need this information for - if
the keys that are needed to check those signatures are not present,
then the signatures are potentially (very) misleading - i.e. they can
be forged, invalid, etc, and you'd never know.

@_date: 2003-01-03 15:27:02
@_author: David Shaw 
@_subject: lc2 
The LANCrypto version is a patch that adds a few algorithms - a public
key signing algorithm (LANS), a hash (GAS48), and ciphers WICKER,
NUSH128, NUSH192, and NUSH256.  OpenPGP in general supports this sort
of thing by defining a range of algorithm numbers that are reserved
for experimental use like this, and LANCrypto quite properly put their
new algorithms in the experimental range.
However, the bottom line is that are LANCrypto algorithms, and are not
part of the OpenPGP standard so they will not be usable in PGP or
(regular) GnuPG.  PGP and GnuPG are doing the correct thing by
refusing to import LANS keys.

@_date: 2003-01-03 16:23:02
@_author: David Shaw 
@_subject: key signing 
In general, you should never (publically) sign keys you have no idea
about.  This is what local signatures are for.
The theory is that they can then not trust that signature if they
don't approve of this type of signature.  However, both GnuPG and PGP
treat all signatures (including these persona signatures) alike, so
persona signatures are not that useful right now except in special

@_date: 2003-01-03 20:46:04
@_author: David Shaw 
@_subject: Receiving a key on standard output 
Why bother with that?  Just do 'gpg --recv-keys 99242560'
The reason to retrieve it to a file first was so that the original
poster could then examime the file before importing the key.

@_date: 2003-01-05 06:58:01
@_author: David Shaw 
@_subject: Must I Retrieve? 
No.  You can delete the key when you are done, but you must have the
key to verify a signature.

@_date: 2003-01-06 14:49:01
@_author: David Shaw 
@_subject: lc2 
Well, yes and no.  The LanCrypto ciphers and hashes, yes.  The
LanCrypto public key algorithm, no.  Preferences do not cover pk
In any event, the LanCrypto algorithms have experimental algorithm
numbers.  It's not exactly clear what the right thing to do in
preferences for experimental algorithms since it's easy to have two
completely different "algorithm 100"s.

@_date: 2003-01-06 21:30:03
@_author: David Shaw 
@_subject: lc2 
Exactly.  If an implementation gets a "cipher 100" preference, it has
no way to know what the cipher really is.

@_date: 2003-01-08 00:37:02
@_author: David Shaw 
@_subject: Instant messaging client with GnuPG support ? 
Jabber does (did?) have OpenPGP support in the protocol.  The only
client I know of offhand that implemented it is Gabber, which doesn't
run on Windows.
I heard a story that Jabber was dropping OpenPGP support and using
something they came up with internally instead - I don't know more
than that (and it may not even be true).

@_date: 2003-01-08 00:58:02
@_author: David Shaw 
@_subject: Instant messaging client with GnuPG support ? 
This was a bug in GnuPG.  It only applies to 1.0.7.  1.2.0 and later
should work properly with Gabber.

@_date: 2003-01-08 03:55:01
@_author: David Shaw 
@_subject: armoring without encrypting or signing? 
Good point.  Using gpg --armor --store also works more smoothly with

@_date: 2003-01-08 18:13:02
@_author: David Shaw 
@_subject: armoring without encrypting or signing? 
All recent versions.. I don't know when the feature was added.
It's not.  This is a GnuPG-specific feature.  As it happens, PGP can
usually handle it, but that is not guaranteed of course.
You're better off using Brian Minton's suggestion of "--armor
--store".  That will work with PGP.
The filename problem you are having can be fixed if you are using
GnuPG 1.2.2.  Use --no-mangle-dos-filenames.

@_date: 2003-01-08 20:24:02
@_author: David Shaw 
@_subject: gnupg and subkeys 
I think what he means is:
Given secret key A, with subkeys A1 and A2, if you import "A+A1", you
can not then import "A+A2" to create "A+A1+A2".  You can only do that
with public keys.  For secret keys, you need to use gpgsplit and
manually assemble "A+A1+A2" for import.

@_date: 2003-01-09 16:03:03
@_author: David Shaw 
@_subject: How to do.......... 
If you are running 1.3, you can also use the --primary-keyring option.
This lets you specify which keyring gets new keys during an import.

@_date: 2003-01-09 16:15:03
@_author: David Shaw 
@_subject: Deploying GnuPG into University Administration 
A keyserver can definitely handle this.  There are a handful of
different keyservers available, each with advantages and
disadvantages.  The two main ones are:
 is the "classic" keyserver that
runs wwwkeys.pgp.net.  It has some bugs, but basically works for
common key types.... and totally mangles some other types.
PGP, Inc. has a LDAP-based keyserver that has some features that makes
your particular use easier (users submit their keys, the keyserver
detects that they are not signed and automatically puts them on hold
so they can be signed).  This keyserver is not free (money) or free
Ask around on the keyserver operators mailing list
(pgp-keyserver-folk and you'll hear about some other
keyservers you can use.

@_date: 2003-01-09 17:14:02
@_author: David Shaw 
@_subject: Deploying GnuPG into University Administration 
.. or, since you control the gpg.conf files as each new user gets set
up, stick a "trusted-key xxxxxx" in there.  Simpler, and works even if
the user manages to mangle their trustdb.
Users who forgot their password can have their key revoked by the CA
if you are using revocation keys.
I do. ;)  I designed a system for a company here.  It was vaguely
similar to what you mention above, except it had to provide for data
recovery and had to work with PGP on Windows as well.

@_date: 2003-01-09 22:55:02
@_author: David Shaw 
@_subject: TAB at EOL (GPG and PGP interoperability) 
This is a bug in PGP.  The OpenPGP standard dictates that "...any
trailing whitespace (spaces, and tabs, 0x09) at the end of any line is
ignored when the cleartext signature is calculated."  PGP only ignores
spaces and includes tabs.
GnuPG can automatically detect and fix this problem in PGP 2 messages,
but there is no way to tell with PGP 5.x and later.

@_date: 2003-01-09 23:23:01
@_author: David Shaw 
@_subject: Article on PGP uses Gnupg :) 
This is sort of funny.
Popular Mechanics recently ran an article about email encryption and
PGP.  It's a decent introduction for newcomers to encryption.
However, even though they are talking about PGP, the screen shots
within the article are showing GnuPG messages...
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2003-01-10 00:44:02
@_author: David Shaw 
@_subject: TAB at EOL (GPG and PGP interoperability) 
This is not what happened.  If you modify GnuPG to have the same bug,
the file verifies properly.
In any event, it doesn't matter how it got that way.  If the line ends
on a tab, the tab must be ignored.  Period.  It's not realistic for
the receiving program to try an unmangle a signed file by guessing the
countless different ways the sender could have broken it.  The fix is
for the sender to do it right in the first place.  That's why we have
standards.  Even so, GnuPG looks for and can detect this bug in some
cases, but not in this particular case.

@_date: 2003-01-10 00:46:02
@_author: David Shaw 
@_subject: Article on PGP uses Gnupg :) 
Yes, that's where I saw it.
I wonder what the message is...
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2003-01-13 18:51:01
@_author: David Shaw 
@_subject: Certificate Question 
Signatures contain the keyid of the signer inside them.  If you run
gpg on the file, you will see a line that reads something like:
gpg: Signature made Mon 13 Jan 2003 12:51:07 PM EST using RSA key ID xxxxxxxx
The 'xxxxxxxx' is the keyid of the signer.  You can then find that
keyid on any keyserver you like to give you a name.  If you use
'keyserver-options auto-key-retrieve' in your gpg.conf file, gpg will
do this automatically for you.

@_date: 2003-01-13 23:07:02
@_author: David Shaw 
@_subject: GnuPG main site down 
GnuPG is still very actively supported.  The web site seems to have
had a failure of some sort.  Don't worry, I'm sure it'll be back up

@_date: 2003-01-14 00:54:03
@_author: David Shaw 
@_subject: Automatic Signing via Script 
In general, it is not a good idea to drive gpg via the "human being"
interface.  There may be changes in the interface that break your
Rather, you should use the --status-fd and --command-fd messages,
which are designed for this sort of use.

@_date: 2003-01-14 01:04:02
@_author: David Shaw 
@_subject: elGamal Keys to Sign+Encrypt 
Well, that's a pretty big argument against ElGamal ;)  It's also
incredibly slow, makes big signatures, and requires special care when
generating the key or signatures from the key can be forged.
However, that said, why should a CA care?  I wouldn't make the CA
signing key an Elgamal signing key, but it shouldn't matter if you
certify an ElGamal key.

@_date: 2003-01-14 03:26:02
@_author: David Shaw 
@_subject: elGamal Keys to Sign+Encrypt 
Well, I agree that it comes down to policy.  My point was that there
is no technical issue with making such a signature.
However, it is an interesting question what the appropriate policy is.
Traditional OpenPGP certification signatures do not attempt to say
more than some variation on "I certify that such-and-such entity (or
role) matches such-and-such key".  I'm not talking about trust
signatures here, of course, which are a different beast.  It raises
some interesting issues whether the signer should take into account
something other than key ownership when making a certification.  There
are of course exceptions to this, and a signer is free to do whatever
the heck they like anyway.
How different is the example above with signing the key of someone who
is known to make willy-nilly bad signatures?  Your certification is
still strong, despite the poor certification policy that the keyholder
has.  On the other side of this is the fact that nobody likes to be
the one to "enable" a weak link in the web of trust.
No one answer here, I'm afraid.

@_date: 2003-01-14 17:55:02
@_author: David Shaw 
@_subject: What kind of key do I have? 
Some keys don't map particularly well to the "RSA" vs "DSS/DH"
question.  My key (99242560) is a "RSA/DH".  Adrian, what would your
key be - a DSS/DH/DSS/DSS? ;)
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2003-01-14 20:49:02
@_author: David Shaw 
@_subject: TAB at EOL (GPG and PGP interoperability) 
Content-Description: signed data
PGP does have a word wrap function.  Since some mailers do their
wrapping after PGP has been run on the mail, that would break the
signature.  To help avoid this, PGP can wrap as part of the signing
function.  The idea is you make PGP wrap at a lower value than your
mail client, so the mail client never has anything to do.
GnuPG never wraps.  Mailers in the *nix world tend to handle filtering
properly so it is not necessary.  I'm not sure if WinPT wraps or not.
   David Shaw  |  dshaw  |  WWW    "There are two major products that come out of Berkeley: LSD and UNIX.
      We don't believe this to be a coincidence." - Jeremy S. Anderson

@_date: 2003-01-14 22:47:02
@_author: David Shaw 
@_subject: What kind of key do I have? 
True.  In fact, some programmers have made the same mistake and used
"is it an RSA key" when they should have asked "is it a v3 key".
That's why v4 RSA keys have mangled keyids on the pksd keyserver, and
why you can't search for v4 RSA keys by subkey ID on the LDAP

@_date: 2003-01-15 14:51:02
@_author: David Shaw 
@_subject: How to use a keyserver 
--keyserver hkp://keyserver.kjsl.com
HKP keyservers are not HTTP, though they do share some similarities.

@_date: 2003-01-15 14:53:01
@_author: David Shaw 
@_subject: Error during make - i386ld fatal:Symbol referencing error 
Looks like you're missing a library.  What happens if you manually add
-lnsl to your link line?
cc -g -o bftest bftest.o ../cipher/libcipher.a ../mpi/libmpi.a ../util/libutil.a -lsocket -lnsl ../intl/libintl.a

@_date: 2003-01-15 15:02:02
@_author: David Shaw 
@_subject: Decoded message was: Re: Article on PGP uses Gnupg :) 
That is known as a known-plaintext attack.  All algorithms used in
OpenPGP are resistant to such attacks.

@_date: 2003-01-15 15:04:01
@_author: David Shaw 
@_subject: TAB at EOL (GPG and PGP interoperability) 
Good.  Seems to me that's the right place for wrapping.

@_date: 2003-01-15 17:11:02
@_author: David Shaw 
@_subject: Error during make - i386ld fatal:Symbol referencing error 
Ah, I love the game of "guess the dependency"!
Can you take a look in your /usr/lib directory and see which library
defines the missing symbols?
You might also try -lresolv (which in turn may require -lnsl - try

@_date: 2003-01-15 17:32:02
@_author: David Shaw 
@_subject: TAB at EOL (GPG and PGP interoperability) 
It doesn't.  If you delete the tab at the end of the line, the
signature should still validate correctly.  However: if you are using
a v3 RSA key, GnuPG guesses you want to be compatible with PGP 2.x, so
it includes the tab.  Using the --openpgp flag makes this strictly
RFC-2440, so it will not include the tab.
They should both calculate it the same way.  The standard says that
the way GnuPG does it is right, which makes what PGP is doing wrong.
I have a good bit of sympathy for the PGP developers here.  This is a
problem they've had for a long time, and it's very difficult to fix
without breaking backwards compatibility.

@_date: 2003-01-15 19:44:02
@_author: David Shaw 
@_subject: TAB at EOL (GPG and PGP interoperability) 
Yes, that is what I am saying.  The tab is not included in the hash so
it doesn't matter if you delete it or not, or even add 30 more tabs
If you use a hash other than MD5, then GnuPG won't detect the message
as PGP 2.x compatible so will not turn on the tab detector.

@_date: 2003-01-15 21:08:03
@_author: David Shaw 
@_subject: Error during make - i386ld fatal:Symbol referencing error 
Use the program "nm" on the .a files.  You are looking for the name of
the missing symbols plus a capital letter "T".  If you see that, then
the symbols are defined in that .a file.  I'm assuming your nm is like
mine here.  I'm not familiar with the SCO nm.
Anyone out there with a SCO box have any other ideas?

@_date: 2003-01-15 21:21:02
@_author: David Shaw 
@_subject: Please Help - Compilation Failed on Solaris 8 
This is a known problem with Solaris (search for the error message
with google and you'll see it happens with many different programs).
Is _LARGEFILE_SOURCE defined in your config.h file ?

@_date: 2003-01-15 21:31:03
@_author: David Shaw 
@_subject: TAB at EOL (GPG and PGP interoperability) 
No, that will work (and in fact there is a place within GnuPG where we
do something similar), but it incurs a cost since we must in effect
process every clearsigned file twice.  Given how often this is a
problem (this is the first time I've seen this problem come up in over
a year), the cost would outweigh the benefit of the fix.

@_date: 2003-01-16 14:16:02
@_author: David Shaw 
@_subject: comment, propagation, and key servers 
Plus: the server has a bug that makes it not work properly with GnuPG
on all platforms....

@_date: 2003-01-16 17:28:01
@_author: David Shaw 
@_subject: options -> gpg.conf 
Remove the first three lines.
The options.skel file has some documentation.  There is also more
complete documentation on the man page.
cd .gnupg
mv options gpg.conf

@_date: 2003-01-16 18:45:02
@_author: David Shaw 
@_subject: Grouping Keys 
You defined a group, but didn't use it.  Defining groups (while it
does work), is not that useful on the command line.
Try putting the group line in your gpg.conf file, and then encrypting
to the groupname just like you'd encrypt to any name. (-r groupname).

@_date: 2003-01-16 20:24:02
@_author: David Shaw 
@_subject: Keysigning a "corporate" key - how ? 
This is a difficult question since signing such a key doesn't really
fit into the traditional "identify a person, match that person to a
key, sign the key" model.
Some people will sign such a key, and some people will not.  In a way,
it is similar to the question of whether someone other than a robot CA
operator should sign the robot CA key.
I would recommend that people sign your personal key (as they can
verify who you are, etc), and then you sign the corporate key (since
you can verify it is correct).

@_date: 2003-01-23 20:54:02
@_author: David Shaw 
@_subject: question about zip 
If the underlying OS supports large files (e.g. LARGEFILE), GnuPG will
take advantage of it.

@_date: 2003-01-24 15:40:02
@_author: David Shaw 
@_subject: Create Subkey Binding 
) I have a DSS/DH key pair that I'm trying to use with GPG. It refuses
Let me make sure I understand what you are trying to do - you have a
secret/public keypair that has no subkey binding, so you want to add a
binding to the subkey so you can use it.  There is no easy way to do
this, as GnuPG obviously wants to reject an invalid/corrupt subkey.
You'd have to patch the code to override the checks and force GnuPG to
put a binding signature in place.
I took a look at s-mail.com, and it looks rather similar to hushmail.
Was the key generated by s-mail.com and exported to you?  Subkeys
without bindings are not at all secure since any random person can
insert one and become a man in the middle.

@_date: 2003-01-24 17:27:17
@_author: David Shaw 
@_subject: Create Subkey Binding 
Not a MITM with you receiving the secret key - a MITM between the rest
of the world and you during use of the public key.  If your key has no
subkey binding, then anyone in the world can (for example) upload a
new subkey to a keyserver.
In any event, both GnuPG and PGP will properly refuse to use the
corrupted key.  I think you need to get the s-mail people to fix the

@_date: 2003-01-24 18:47:02
@_author: David Shaw 
@_subject: Create Subkey Binding 
Indeed.  You might tell the S-Mail people that such keys also violate

@_date: 2003-01-29 01:38:03
@_author: David Shaw 
@_subject: different keys for different machine? 
I have a fix in that prevents pksd from mangling multiple subkey keys.
It should be a part of the next pksd release.  Note this doesn't mean
that pksd will actually store the multiple subkeys, but it does mean
that it won't mangle the key if you try.

@_date: 2003-07-02 15:22:04
@_author: David Shaw 
@_subject: Expiration Confusion 
Hash: SHA1
You can select the subkey via the "key" command.  So:
gpg --edit-key (thekey)
key 1  <-- selects the subkey.  If you have more than one, use 2, 3, 4, etc.
GnuPG does all the self-signature work underneath the hood.

@_date: 2003-07-02 15:23:03
@_author: David Shaw 
@_subject: Expiration Confusion 
Hash: SHA1
This is not correct.  The old self-signature is indeed deleted.  You
are probably thinking of keyservers, which keep the old self-sigs

@_date: 2003-07-02 15:34:02
@_author: David Shaw 
@_subject: Differing File Sizes & GPG Symmetric Decryption Failure After ~4G 
Hash: SHA1
Under the hood.  It's an encoding method used when the size of the
file is not known (usually because the file came in via a pipe).  It
also is needed to handle >4G files.
Your current file is going to be unusable.  If the file contents were
critical, you *might* be able to hack a copy of GnuPG to handle it,
but if you say it is not a big deal, then it's probably not worth the

@_date: 2003-07-02 15:36:03
@_author: David Shaw 
@_subject: gpg without commands 
Hash: SHA1
Running just "gpg" is the same as running "gpg filename.gpg".  Without
the filename, it just waits for you to paste filename.gpg into its
window :)

@_date: 2003-07-02 15:48:02
@_author: David Shaw 
@_subject: Curious about public keys and keyservers. 
Hash: SHA1
Are you sure they are the same all the way through?  It's easy to miss
a few digit differences in the middle of a long armor block.

@_date: 2003-07-02 16:01:04
@_author: David Shaw 
@_subject: Differing File Sizes & GPG Symmetric Decryption Failure After ~4G 
Hash: SHA1
No.  The problem you saw was fixed in 1.2.2.  Upgrade to GnuPG 1.2.2
and (if your OS has large file support) you don't have to worry about
any of the file size issues anymore.

@_date: 2003-07-02 16:17:02
@_author: David Shaw 
@_subject: 1.2.3rc1 fails to build on SunOS 4.1.4 
Hash: SHA1
  ./configure ac_cv_sys_symbol_underscore=yes
This is bug on bugs.gnupg.org.

@_date: 2003-07-02 18:00:02
@_author: David Shaw 
@_subject: Curious about public keys and keyservers. 
Hash: SHA1
No.  There are many ways to represent OpenPGP keys.  They are
functionally identical, but differ in the actual bytes on disk.  It
doesn't matter.

@_date: 2003-07-07 22:22:02
@_author: David Shaw 
@_subject: IDEA algorithm 
Hash: SHA1
See However, please don't do it unless you must. IDEA is only really
needed for PGP 2.x compatibility.

@_date: 2003-07-07 22:49:01
@_author: David Shaw 
@_subject: hash algorithm 
Hash: SHA1
The hash algorithm is used in several places, but generally the use
that matters most to people is when making a signature.  The data
being signed is hashed, and the resultant hash is what is signed.
What is the "best" algorithm is a matter of slight controversy.
GnuPG supports MD5, SHA-1, RIPEMD/160, TIGER192, SHA256, SHA384, and
SHA512.  However there are reasons to use or not use certain
MD5 is needed to make PGP 2.x compatible signatures.  Aside from that,
don't use it.  It's not broken, but is starting to show some weakness.
SHA-1 has the nice advantage that it is guaranteed to be available in
all OpenPGP applications.
Don't use TIGER/192.  It is not going to be part of the next OpenPGP
revision, and using it now will just make that transition harder.
This is only available if you enable it at build time.
SHA256/SHA384/SHA512: These are the "wide SHAs".  They are read-only
in the current version of GnuPG (that is, you can read a message from
someone else using these hashes, but cannot generate such a message
yourself).  384 and 512 are only available if you enabled them at
build time.
DSA keys can only sign using SHA-1 or RIPEMD/160.  RSA keys can use
any algorithm.
The short answer is, unless you have a good reason and know what you
are doing, use the default which is SHA-1.

@_date: 2003-07-08 14:22:02
@_author: David Shaw 
@_subject: IDEA algorithm 
Hash: SHA1
Well, sure... if you set IDEA as your first preference, it'll
certainly be used.

@_date: 2003-07-08 18:11:02
@_author: David Shaw 
@_subject: IDEA algorithm 
Hash: SHA1
Yes.  The preference algorithm works like this:
1) Make a list of all preference items that exist for all recipients.
   In your case above that means (these are not in any particular order):
      Cipher: IDEA, 3DES, CAST5
      Digest: SHA1
      Compression: Uncompressed, ZIP
      Features: (none)
2) Pick an item in the intersection (if any), by using one of the
   recipients as the tie breaker.  If the tie breaker was your key,
   then you'd pick IDEA (since it is your first choice).  If your tie
   breaker was the other key, you'd pick CAST5 (since it is their
   first choice).
   The tie breaker is currently the first key encrypted to, which any
   --encrypt-to keys are.  If the first key encrypted to doesn't have
   any prefs, the lowest algorithm number is used (in the case above,
   that would be IDEA/SHA1/Uncompressed).

@_date: 2003-07-08 22:04:10
@_author: David Shaw 
@_subject: GnuPG Keys 
Hash: SHA1
That is not necessarily true.  This question has come up before about
the GPL and libraries.
Without getting into legalities (plus, I'm not a lawyer), read:

@_date: 2003-07-08 23:10:03
@_author: David Shaw 
@_subject: gpg as unix login (was: Corporate public key?) 
Hash: SHA1
I think he is referring to The commercial ssh also has a way to use OpenPGP keys.  I don't know
if the two implementations are interoperable (I would hope they are).

@_date: 2003-07-09 04:41:06
@_author: David Shaw 
@_subject: IDEA algorithm 
Hash: SHA1
My error, that would be "IDEA/SHA1/ZIP", as there is a special rule in
the code to use ZIP over Uncompressed in the no-prefs case if every
key can handle it.

@_date: 2003-07-10 18:21:03
@_author: David Shaw 
@_subject: Build-Reports 1.2.3rc1 
Hash: SHA1
This is unlikely to be fixed.  TIGER192 is strongly deprecated as it
does not appear in the upcoming revision to the OpenPGP standard.
GnuPG still has it, but it is disabled by default.  The real answer to
this problem is to not use --enable-tiger.  At some point, TIGER192
will be dropped altogether.

@_date: 2003-07-10 19:41:07
@_author: David Shaw 
@_subject: Twofish, Blowfish no recommended cipher anymore ?! 
Hash: SHA1
PGP only supports Twofish, not Blowfish.
Those two ciphers are not in the default preferences for compatibility
and conservatism reasons.  If you want to use Twofish and/or Blowfish,
you can certainly update your preferences to include them.

@_date: 2003-07-11 16:19:02
@_author: David Shaw 
@_subject: Twofish, Blowfish no recommended cipher anymore ?! 
Hash: SHA1
I can't imagine a reason to drop them, unless they are broken at some
time in the future.  The important thing is that all of those
algorithms are defined in OpenPGP so you get to pick which you want.
If a particular algorithm isn't available in a particular
implementation, you can always change implementations or add that
algorithm to your chosen implementation.

@_date: 2003-07-13 16:19:02
@_author: David Shaw 
@_subject: Auto Key Refresh 
Hash: SHA1
Note that the "list of best places to refresh" already exists in
5.2.3.18. Preferred key server
   (String)
   This is a URL of a key server that the key holder prefers be used
   for updates. Note that keys with multiple User IDs can have a
   preferred key server for each User ID. Note also that since this is
   a URL, the key server can actually be a copy of the key retrieved
   by ftp, http, finger, etc.

@_date: 2003-07-13 16:19:11
@_author: David Shaw 
@_subject: Twofish, Blowfish no recommended cipher anymore ?! 
Hash: SHA1
The plugin system didn't make it easy to add new algorithms to GnuPG
(it's free software - you could always add new algorithms).  The
plugin system just made it easy to distribute the plugins separately
from GnuPG.
Also, keep in mind that OpenPGP never really supported Tiger.  There
was no OID specified, and so it was supported in GnuPG with a
nonstandard OID.  This means that no other OpenPGP program (unless
they used the same nonstandard implementation) would be able to verify
Tiger signatures from GnuPG.
Back then, Tiger was the largest hash in GnuPG.  That is no longer
true.  Tiger is a 192-bit hash.  Today, GnuPG supports SHA-256,
SHA-384, and SHA-512 - a good bit longer than Tiger.

@_date: 2003-07-14 08:14:05
@_author: David Shaw 
@_subject: Twofish, Blowfish no recommended cipher anymore ?! 
Hash: SHA1
Right, but that's still mostly a distribution thing (you need to get
the users of your new algorithm to patch their GnuPG source, and
rebuild).  For the developer, you certainly aren't rebuilding the
entire tree each time you make a change.  Or if you are, you need a
better implementation of 'make' ;)
Internally, the support is complete.  The restriction is that the user
cannot specify the new SHAs via --digest-algo.  If a key has a digest
preference for one of the new SHAs, then GnuPG will follow it.  The
reason for this is so that we can get a code base that understands the
new hashes out there before people start generating them.  We're
trying to avoid compatibility problems.  Incidentally, PGP 8 supports
SHA256 (but not 384 or 512) read-only as well.
I'm actually a little surprised (though pleased) at how few people
immediately removed the read-only restriction as soon as they
downloaded GnuPG.  The code is trivial to enable, though it is right
below a comment from me asking the user not to enable it :)

@_date: 2003-07-14 16:54:02
@_author: David Shaw 
@_subject: Twofish, Blowfish no recommended cipher anymore ?! 
Hash: SHA1
Well, if they did, they haven't widely used the new hash in public.
Do a few web searches for "Hash: SHA256".  There aren't any in the
various mailing list archives.  There is only one guy I can see using
it on Usenet.

@_date: 2003-07-15 15:47:03
@_author: David Shaw 
@_subject: error in GNUPG.org pubkey? 
Hash: SHA1
"Be liberal in what you accept, conservative in what you generate."

@_date: 2003-07-15 18:03:01
@_author: David Shaw 
@_subject: Keyservers and subkeys 
Content-Disposition: inline
This is a known bug in the LDAP keyserver.  If the primary key is RSA,
it doesn't bother to index the subkeys.  I've reported the bug to the
PGP.com people, so hopefully it'll get fixed at some point.
Content-Disposition: inline

@_date: 2003-07-17 14:07:02
@_author: David Shaw 
@_subject: keys and many OS and backuping keys! 
Hash: SHA1
Sure, try it.  Also --enarmour, --dearmour, --no-armour, etc.

@_date: 2003-07-17 16:52:02
@_author: David Shaw 
@_subject: Can you unlock sent messages ?? Somehow ?? 
Hash: SHA1
No.  There is nowhere you can send a file to have it decrypted for you
since that would defeat the point.  GnuPG wouldn't be a good
encryption program if there was a way for someone else to decrypt a
In short, without the key, you can't decrypt.
What are you trying to do here?  If the concern is that you want to
use encryption, but you want the company to be able to decrypt as
well, there are solutions for that.  See "encrypt-to" in the manual.

@_date: 2003-07-18 14:28:02
@_author: David Shaw 
@_subject: Can you unlock sent messages ?? Somehow ?? 
Hash: SHA1
Not without also modifying the program that processes the message,
which would defeat the purpose.

@_date: 2003-07-21 19:03:03
@_author: David Shaw 
@_subject: ELG-E key requires IDEA cipher? 
Hash: SHA1
This is correct.  I guess PGP 5 used IDEA for the internal
Exactly, yes.

@_date: 2003-07-21 23:35:03
@_author: David Shaw 
@_subject: Deliberate false signatures in spam? 
Hash: SHA1
Yes, this was a pretty lame quasi "signature".  No CRC, no proper
ending to the armor, etc.  Of course you are right - if spamassassin
started checking for properly formatted signatures then spammers would
start providing them.  The only way to be sure is to verify the
signature and that is expensive.

@_date: 2003-07-22 03:47:01
@_author: David Shaw 
@_subject: Which keyserver should I use? 
Content-Disposition: inline
At the moment, the only keyserver I can honestly recommend is
sks.dnsalias.net.  It works with subkeys, works with photo IDs, and
will soon have the ability to do subkey searches.
Content-Disposition: inline

@_date: 2003-07-22 13:55:02
@_author: David Shaw 
@_subject: gpgkeys_ldap doesn't get compiled 
Hash: SHA1
Those two configure lines essentially mean "I request LDAP support".
That doesn't mean that your system is capable of delivering on that
request.  Look for:
 checking whether LDAP via "-lldap" is present and sane... yes
or something similar (as configure checks for several different LDAP
libraries before giving up).
If the answer to those questions is "no", you need an LDAP library on
your system for gpgkeys_ldap to be built.

@_date: 2003-07-22 15:25:01
@_author: David Shaw 
@_subject: gpgkeys_ldap doesn't get compiled 
Hash: SHA1
The most commonly used LDAP library is OpenLDAP
( though the GnuPG code should work with any
library that uses the same API.

@_date: 2003-07-24 23:17:02
@_author: David Shaw 
@_subject: Disabling paging/swapping without being root? 
Hash: SHA1
GnuPG does not disable paging in general, but rather locks a
particular chunk of memory and uses that chunk for any data that
should not end up in swap (secret keys, session keys, etc).  It's
kindler on the rest of the system than disabling all paging.
Generally, GnuPG need to be setuid root to do this, but it can also
use POSIX capabilities on those platforms that support it to do the
same thing without being root.

@_date: 2003-07-25 00:43:02
@_author: David Shaw 
@_subject: key expiration 
Hash: SHA1
What happens if you try it with PGP 7 or 8?

@_date: 2003-07-25 05:21:01
@_author: David Shaw 
@_subject: key expiration 
Hash: SHA1
No, both PGP 7 and 8 have free versions.  (Free as in cost, not free
as in freedom).

@_date: 2003-07-25 13:37:01
@_author: David Shaw 
@_subject: can`t verify signature 
Hash: SHA1
Probably multiple user IDs on a single key.  I looked on the keyserver
to confirm this, but I only saw three "John Aldrich"es.

@_date: 2003-07-25 17:02:02
@_author: David Shaw 
@_subject: Decrypt an encrypted mail with detached signature?!? 
Hash: SHA1
Two questions:
1) What version of GnuPG are you using?
2) Can you arrange to send me (key 99242560) such a message?
Try adding --list-packets to your GnuPG command line when you try to

@_date: 2003-07-26 21:27:12
@_author: David Shaw 
@_subject: How to submit the primary uid to keyserver? 
Hash: SHA1
There are a few games you can play with rearranging packets, but in
general, there is always going to be one keyserver that doesn't do
what you want.  I wouldn't worry too much about it - on a keyserver,
it's a cosmetic issue.
The keyservers could certainly look for the primary flag (even without
cryptographic support), but it's not something that anyone has written
code for.

@_date: 2003-07-26 21:27:27
@_author: David Shaw 
@_subject: Key Expiration, need verification please 
Hash: SHA1
The "pub" and "sub" lines refer to two different keys.  If you change
the expiration date of one, it only changes that key.  If you want to
change both, you need to change both.

@_date: 2003-07-26 21:27:35
@_author: David Shaw 
@_subject: Revoke a public key w/o the secret key? 
Hash: SHA1
This is a frequently given piece of advice, but is actually not the
best thing to do.  There are older versions of PGP that don't
understand revoked signatures and will treat that signature as valid -
thus certifying the old, unusable key with the current key.
The person who suggested asking all the people who signed the key to
revoke their signatures had a better idea.  While this still doesn't
mean anything in old PGPs, it at least does not give a key more
validity than it had earlier.
Of course, the best thing to do is generate a revocation certificate
when you generate the key... or at least, appoint a trustworthy friend
as designated revoker.

@_date: 2003-07-26 21:31:02
@_author: David Shaw 
@_subject: key expiration 
Hash: SHA1
I just looked at your key.  Based on what the actual key says, GnuPG
is displaying it correctly.  I'm not sure why PGP is showing a subkey
expiration date for the whole key, but it could be a bug in PGP, or
perhaps the expiration date field in the PGP GUI is intended to be the
soonest expiration date of the key set.

@_date: 2003-07-29 02:33:03
@_author: David Shaw 
@_subject: Key Expiration, need verification please 
Hash: SHA1
Modern OpenPGP keys have a primary, plus zero or more subkeys.  It is
possible for an OpenPGP key to have no subkeys if it is a sign+encrypt
key, but they're not that common.  More likely, the keys you saw were
PGP 2.x-style keys, which are all sign+encrypt.

@_date: 2003-07-29 06:04:01
@_author: David Shaw 
@_subject: Why expire? 
Hash: SHA1
Expiration in OpenPGP keys is unfortunately not able to handle that
case.  The expiration date on a compromised key can be changed by the
attacker, thus "unexpiring" it.  This is an intentional feature, but
the benefit of being able to extend expiration dates comes with the
disadvantage of an attacker being able to do the same thing.
A good reason to put an expiration date on a key is that people
sometimes forget their passphrase or lose the secret key.  With an
expiration date, there is a drop-dead date after which the key is not
going to be used.

@_date: 2003-07-30 00:06:02
@_author: David Shaw 
@_subject: Why expire? 
Hash: SHA1
I think that's a good description.  There have been suggestions on
changing the expiration system to an optional "hard" (non-changeable)
expiration, as the old PGP 2.x keys had, but this looks like it won't
be happening soon for a few technical reasons.

@_date: 2003-07-30 16:41:04
@_author: David Shaw 
@_subject: encryption problems 
Hash: SHA1
There is no trust path connecting things.  GnuPG is looking for a
chain of signatures between you and the key.

@_date: 2003-07-30 23:25:02
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.2.3 second release candidate 
Hash: SHA1
We are pleased to announce the availability of the second release
candidate for GnuPG 1.2.3:
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.2.3rc2.tar.gz (3218k)
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.2.3rc2.tar.gz.sig
or as a patch against 1.2.3rc1:
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.2.3rc1-1.2.3rc2.diff.gz (588k)
Win32 binaries are also available:
 ftp://ftp.gnupg.org/gcrypt/alpha/binary/gnupg-w32cli-1.2.3rc2.zip (1304k)
 ftp://ftp.gnupg.org/gcrypt/alpha/binary/gnupg-w32cli-1.2.3rc2.zip.sig
Mirrors are listed at  and most of them
should be in sync by tomorrow (Thursday).
MD5 sums are:
898e19cf998105a5cf7ec017d4d9d78b  gnupg-1.2.3rc2.tar.gz
5f16053c4e1ce2d2a428797efde9fb6f  gnupg-1.2.3rc1-1.2.3rc2.diff.gz
b444fb6079a57dd68d3f5780d8dbfce0  gnupg-w32cli-1.2.3rc2.zip
This release contains a number of bug fixes (including a fix for the
slow key listings in 1.2.2), as well as a large number of portability
fixes.  If you had problems building 1.2.2 or earlier versions, we
would appreciate it if you would check this release candidate for any
build problems on your platform.
If there are no problems with this candidate, we expect the official
1.2.3 release to follow shortly, so please test soon.
Other changes since 1.2.2:
    * New "--gnupg" option (set by default) that disables --openpgp,
      and the various --pgpX emulation options.  This replaces
      --no-openpgp, and --no-pgpX, and also means that GnuPG has
      finally grown a --gnupg option to make GnuPG act like GnuPG.
    * A number of portability changes to make building GnuPG on
      less-common platforms easier.
    * Romanian translation.
    * Two new %-expandos for use in notation and policy URLs.  "%g"
      expands to the fingerprint of the key making the signature
      (which might be a subkey), and "%p" expands to the fingerprint
      of the primary key that owns the key making the signature.
    * New "tru" record in --with-colons --list-keys listings.  It
      shows the status of the trust database that was used to
      calculate the key validity in the listings.  See doc/DETAILS for
      the specifics of this.
    * New REVKEYSIG status tag for --status-fd.  It indicates a valid
      signature that was issued by a revoked key.  See doc/DETAILS for
      the specifics of this.
Happy hacking,
   The GnuPG Team (David, Stefan, Timo, Werner)
Gnupg-announce mailing list

@_date: 2003-06-03 17:22:02
@_author: David Shaw 
@_subject: Is there a protocol definition for fetching keys from key servers? 
Hash: SHA1
This is not correct.  A HKP request does end with \r\n\r\n.  The GnuPG
code sends the second \r\n in a different spot, so if you were
grepping for \r\n\r\n you wouldn't find it. ;)
The protocol is currently being documented in an informational RFC.
The draft is:

@_date: 2003-06-03 18:30:07
@_author: David Shaw 
@_subject: Adding new UID problems. 
Hash: SHA1
I did add some code to the PKS tree to at least avoid the worst
problems (it will reject additional subkeys rather than corrupting
them), but this is a far cry from full subkey support.
My current recommendation is to use the SKS keyservers.
  hkp://keyserver.bu.edu
  hkp://sks.keyserver.penguin.de
  hkp://sks.dnsalias.net
  hkp://ensemble02.cs.cornell.edu
Any of those, or hkp://keyserver.kjsl.com will work correctly with
multiple subkeys.
It is unfortunate that the usual recommendation of "use
wwwkeys.pgp.net" is no longer the right answer as some of the servers
in the wwwkeys rotation have subkey bugs.

@_date: 2003-06-04 20:04:02
@_author: David Shaw 
@_subject: Adding new UID problems. 
Hash: SHA1
No.  Your key was slightly mangled by one of the keyservers.  I've
seen keyserver.kjsl.com do that in the past, but it is not clear if it
is a problem in keyserver.kjsl.com itself or in interaction with a
different server.  Once any server does it, though, all servers learn
it via sync.
The good thing is you can ignore it.  It's a harmless warning.
The keyserver situation in the OpenPGP world is tragically, comically
bad.  GnuPG does the right thing.  PGP does the right thing.  Fewer
than 1 in 5 keyservers do the right thing, and unfortunately, the good
servers sync with the broken ones so the damage is spread far and wide
when a bad server causes a problem.  Thankfully most damage, like your
example, is just an annoyance.
I would be thrilled if one keyserver operator chose to run a working
keyserver, and refused to sync with anyone who was running a broken
one.  I'd use that "mini network" in a heartbeat.  In the meantime,
I've given up and just started giving people a URL to a copy of my key
on my web page.  There is an OpenPGP feature that allows a user to
embed the URL to a key inside signatures.  I plan to add support for
that in GnuPG as well.

@_date: 2003-06-04 20:31:02
@_author: David Shaw 
@_subject: Help Compiling GnuPG 
Hash: SHA1
This is a known problem on HP-UX.  It is fixed in 1.2.3, but in the
meantime, edit your config.h file and set:
 HAVE_GETTIMEOFDAY 1

@_date: 2003-06-05 06:49:02
@_author: David Shaw 
@_subject: [Q] "sign" vs "sign-locally" 
Hash: SHA1
A nonrevocable signature is different than a nonrevocable key.
OpenPGP doesn't have the notion of a nonrevocable key.
A nonrevocable signature (via "nrsign") is generally only useful in
special cases.  It's not something most people need.

@_date: 2003-06-06 15:27:02
@_author: David Shaw 
@_subject: Virtual Keysignings 
Hash: SHA1
Be careful.  Someone was unable to encrypt a message to me using PGP 8
and it turned out there is a bug.  A key with a signing subkey that is
newer than the encryption subkey cannot be used for encryption in PGP
8 (or 8.0.2).  A key where the encryption subkey is newer than the
signing subkey can be used for encryption.
This doesn't mean you can't have a signing subkey, but it does mean
the most recent valid subkey must be an encryption subkey, or else you
can't encrypt to the key in PGP 8.

@_date: 2003-06-18 17:03:02
@_author: David Shaw 
@_subject: default secret key for decryption 
Hash: SHA1
If you do not respond to the first two prompts, GnuPG will use the
third key to decrypt.  Just enter a blank passphrase.

@_date: 2003-06-18 18:36:02
@_author: David Shaw 
@_subject: Downloading public keys with GnuPG 
Hash: SHA1
Don't use " for HKP keyservers.  Use "hkp://foo".
The Surfnet LDAP keyserver runs on a different port:
  ldap://pgp.surfnet.nl:11370

@_date: 2003-06-19 14:55:02
@_author: David Shaw 
@_subject: Question about UIDs and valid email addresses 
Hash: SHA1
This is resolved in the new GnuPG 1.2.3 release candidate.

@_date: 2003-06-19 14:56:02
@_author: David Shaw 
@_subject: Downloading public keys with GnuPG 
Hash: SHA1
Most keyservers do not yet support searching by subkey ID.  The only
ones that currently do support this are the LDAP keyservers, and even
then, you must use the long keyid (e.g. 0xDB698D7199242560 instead of

@_date: 2003-06-19 14:59:01
@_author: David Shaw 
@_subject: default secret key for decryption 
Hash: SHA1
No particular reason I can think of.  It's never come up before.

@_date: 2003-06-19 19:05:02
@_author: David Shaw 
@_subject: Self Decrypting Archives 
Hash: SHA1
GnuPG does not support this, and likely will never support this.  SDAs
are wildly, tragically, insecure.  Think about it: someone is sending
you a *program* and saying "please run this for me!"

@_date: 2003-06-19 20:55:02
@_author: David Shaw 
@_subject: Self Decrypting Archives 
Hash: SHA1
I'm curious why installing GnuPG isn't a viable option.  (I assume
this is a Windows platform).  I certainly understand the resistance to
install a new program under Windows, but given the use you are talking
about (regular symmetric encryption of a file) GnuPG doesn't need to
be "installed" to be used.  Just unzip the archive and you can run the
'gpg' program.  No installation necessary, and to "uninstall" just
throw the program in the trash.
If you really wanted to, you could even send your receiver a zip file
containing the "gpg" binary, plus the encrypted file, and a batch file
that contained something like "gpg theencryptedfile.gpg".  Poof:
instant SDA.  Of course, it's still insecure ;)

@_date: 2003-06-19 21:09:02
@_author: David Shaw 
@_subject: Removing extranious subkey signings 
Hash: SHA1
No.  The keyservers are add-only for various reasons.  You can't
remove a signature from them.  However, as you noted, GnuPG can and
does remove the invalid signatures when you import the key.

@_date: 2003-06-19 21:29:02
@_author: David Shaw 
@_subject: GnuPG on an AS400 
Hash: SHA1
Need just a little more info here :)
OS/400?  Linux?
I'm not sure how POSIX the OS/400 build environment is, but failing
that, you could look at something like

@_date: 2003-06-19 22:54:02
@_author: David Shaw 
@_subject: Self Decrypting Archives 
Hash: SHA1
This doesn't make complete sense.  If the person you are communicating
with has PGP and uses it to send you a SDA, why would you want to send
a SDA back?  Your partner has PGP.. just send them a regular old
OpenPGP message.
In any event, GnuPG can be used to make SDAs.  Just make a zip file
that contains the encrypted file and the gpg binary itself.

@_date: 2003-06-19 22:57:02
@_author: David Shaw 
@_subject: Self Decrypting Archives 
Hash: SHA1
But a SDA *is* "installing" something.  What do they think happens
when they click on it?
Try this:
It works, and the end result is a SDA.

@_date: 2003-06-19 23:19:01
@_author: David Shaw 
@_subject: Self Decrypting Archives 
Hash: SHA1
So, what is an SDA?  An SDA is a program, that when executed, decrypts
an internal payload and deposits said payload in an unencrypted
How is what I said different than this definition of a SDA?  If you
are looking for a a "SDA created by the PGP program", then obviously
GnuPG can't help you.

@_date: 2003-06-20 00:47:02
@_author: David Shaw 
@_subject: Self Decrypting Archives 
Hash: SHA1
That's why I'm confused that what PGP creates is an "SDA", and a
self-extracting zip file containing gpg, an encrypted file, and an
autorun command to decrypt the file somehow isn't an "SDA".  All "SDA"
is is a "(S)elf (D)ecrypting (A)rchive".  There is no magic there.
The problem is that there is no way to do it in a portable manner.
Linux executables won't run on Windows, Windows executables won't run
on FreeBSD, etc, etc.  It would be very easy for someone to make their
own SDAs by self-extracting-zipping together the encrypted file, and
the decryption engine, but that's not really the point of GnuPG.

@_date: 2003-06-20 00:52:02
@_author: David Shaw 
@_subject: Self Decrypting Archives 
Hash: SHA1
Then it sounds like you're all set.  Make a self-exctracting zip file
that contains the encrypted data and the decryption engine and send it

@_date: 2003-06-20 01:29:01
@_author: David Shaw 
@_subject: [Announce] gnupg 1.2.3 release candidate 
Content-Disposition: inline
Specifically, if any of the folks with HP/UX problems with
gettimeofday(), or Solaris problems with "undefined reference to
`bind_textdomain_codeset'", or IRIX and "l10nflist.c" could check
this...  You know who you are :)
Content-Disposition: inline

@_date: 2003-06-20 05:37:02
@_author: David Shaw 
@_subject: [Announce] gnupg 1.2.3 release candidate 
Hash: SHA1
keyserver.bu.edu is part of subkeys.pgp.net
Fixed.  Thanks!

@_date: 2003-06-20 18:23:02
@_author: David Shaw 
@_subject: SIG level (was: Why CAs or public keysigning?) 
Hash: SHA1
This is a misunderstanding of signature levels.  The whole point of
them is that they are completely and utterly subjective.  By design,
they cannot be anything but subjective.  Similarly, their value lies
in them being subjective, as if they were not, they could be fairly
easily abused.

@_date: 2003-06-20 18:28:02
@_author: David Shaw 
@_subject: Why CAs or public keysigning? 
Hash: SHA1
That is, of course, your choice.  The idea of sig levels is to allow a
signer to express the difference between (for example), checking a
passport, and checking a passport plus verifying the email address.
They are both "checking", but one is certainly more casual than the
If you always check in the same single way, and will not sign unless
that exact requirement is met, then signature levels don't help you
When I sign, for example, I check a photo ID and send an email address
challenge.  If that is met, I give a level 2.  If I know the person
personally, I'll give a level 3.  It's completely subjective, and my
level 2 is likely to be different than someone elses level 2.

@_date: 2003-06-20 18:35:02
@_author: David Shaw 
@_subject: How to read list-packets 
Hash: SHA1
That's not the size of the RSA key.  That's the size of the session
The compression algorithm.  1==ZIP.
The documentation for --list-packets is RFC-2440 ;)  Just look up each
packet type and you'll see the different arguments.

@_date: 2003-06-20 21:00:02
@_author: David Shaw 
@_subject: Why CAs or public keysigning? 
Hash: SHA1
As I said, then, in your case signature levels don't help you much.
Not at all true.

@_date: 2003-06-21 15:33:02
@_author: David Shaw 
@_subject: HP/UX 11.11 
Hash: SHA1
Note that rather than patching config.h, you should be able to do this
when configuring:
  ./configure ac_cv_func_gettimeofday=yes
and autoconf will do the right thing.
(I don't have a HP box to confirm this, but it should work).

@_date: 2003-06-21 16:02:02
@_author: David Shaw 
@_subject: key server security 
Hash: SHA1
You could try an overload.  One of the interesting things about DSA
signatures is that they are more expensive to verify than to generate.
You could flood a keyserver with a ton of data that costs it more to
verify than it costs you to generate.  (In reality, this probably
doesn't matter much - you could flood with anything, but DSA makes it
a bit worse).
Still, the real question here is what do you mean by "lacking" ?
No good reason.  Most keyservers do.
Possible DoS, but no real impact as to the security of a given key
since PGP or GnuPG is going to recheck the key when importing it
anyway.  That is, if you can get a key from a owned server, it may be
corrupt, it may have important bits removed (say, if an attacker
didn't want you using certain subkeys), but what you do get that
passes the local check is going to be valid (if not usable).

@_date: 2003-06-23 01:55:10
@_author: David Shaw 
@_subject: Upgrade from 1.0.7-6 to 1.2.2 in RedHat 8.0 
Hash: SHA1
You don't need to do this.  GnuPG does not install any libraries.

@_date: 2003-06-23 01:55:27
@_author: David Shaw 
@_subject: Hash preferences (was: test) 
Hash: SHA1
For various reasons, GnuPG by default has a personal-digest-preference
of SHA1 set, and that is overriding your key preferences.  If you want
the key preferences to be followed, you need to put:
  personal-digest-preferences ""
in your gpg.conf file.
Note that when encrypting and signing to multiple keys, the digest
algorithm chosen needs to be agreed on by all keys, and since (by
definition) the only digest algorithm that all keys can agree on is
SHA1, it may be being chosen for that reason.
Note also that the digest preferences in the key won't be followed if
they don't make sense.  DSA requires a 160-bit hash, and so if the key
digest preference requests something else, GnuPG naturally won't
(can't) follow that.

@_date: 2003-06-24 16:09:08
@_author: David Shaw 
@_subject: Hash preferences (was: test) 
Hash: SHA1
Well, I'm sure that any contributions you make to the documentation
would be gratefully acknowledged. ;)

@_date: 2003-06-24 22:50:02
@_author: David Shaw 
@_subject: Documentation blues 
Hash: SHA1
What is "order of need"?  My order of need is bound to be different
than someone elses.  Anyway, see the README file that comes with GnuPG
and/or   That seems to be what
you are looking for.  They don't get into the more esoteric commands
I don't agree with this way of thinking.  If you know enough to ask a
question, I think you are extremely close to understanding the answer.
The person who truly doesn't understand often doesn't even understand
how to ask the question.
If you ask a question, and get an answer that you understand, why not
write a paragraph on that specific detail for the manual?  If you had
to ask the question in the first place, clearly the manual didn't give
you the answer.  Once the question is answered, though, you know the
answer and could write a few lines on the subject for the next person.
I'm usually happy to answer questions, but utterly delighted to answer
them when the answer is going to be put into the documentation.  Good
documentation helps everyone.

@_date: 2003-06-25 02:16:03
@_author: David Shaw 
@_subject: Documentation blues 
Hash: SHA1
cipher-algo, digest-algo, and especially cert-digest-algo fall into
the "esoteric" command category.  They are not something that should
be used except in very special circumstances, and those circumstances
are usually rare.
There is no global gpg.conf.  You can build custom preferences
directly into the binary if you really want to, but this is
discouraged.  A global gpg.conf can be dangerous - it means that
someone else could change your encryption details out from under you,
and thus cause something unexpected or unwanted to happen.
I'm not necessarily talking about a malicious attack (someone who
could change /etc/gpg.conf could probably change your gpg.conf file
anyway), but an change that is reasonable in a global gpg.conf may not
be reasonable in your local gpg.conf and cause a problem.
I think the OSX frontend does write gpg.conf (of course, you'd need to
be running OSX).  I wonder if someone wants to make a GnuPG module for
the dotfile generator (
That said, the standard works-for-almost-anyone configuration is a
*blank* gpg.conf.  The default options built into the program are
carefully chosen to be the right values for the majority of uses.  A
significant number of problems (both in use of GnuPG and in
interoperability with other users) come when people change these safe
GnuPG gives the user a significant amount of configurability.  That's
a good thing usually, but the other side of this is that GnuPG also
gives the user a significant ability to shoot themselves in the foot.

@_date: 2003-06-25 03:56:02
@_author: David Shaw 
@_subject: Documentation blues 
Hash: SHA1
Pretty esoteric :)
The danger in forcing an algorithm is that you don't know if the
recipient can handle it.  GnuPG does quite a bit of work to ensure
that it never picks an algorithm that the recipient can't handle, and
will warn you if you force the use of an algorithm the recipient can't
handle.  Of course, if you are only communicating within your company
then I guess you do know that the recipient can handle it.  Outside of
your company that isn't necessarily true since the only guaranteed
available algorithms in OpenPGP are the 3DES cipher and the SHA1
A safer way to ecourage the use of an algorithm is to set:
  personal-cipher-preferences s10
That means "use TWOFISH if at all possible, and 3DES if not".  It
doesn't guarantee that you use TWOFISH at all times, but it does
guarantee that you'll never encode a message in a way that a recipient
can't handle.
The same thing can be done for digests:
  personal-digest-preferences h3
Meaning: "use RIPEMD/160 if possible, and SHA1 if not".
Yes, the syntax of "s10" or "h3" is not exactly intuitive.  In 1.4
(and in 1.3.x now), you can use the strings "twofish" or "ripemd160".
Frankly, the personal-xxx-preferences options are esoteric as well
since by default GnuPG always picks an algorithm that is usable by all

@_date: 2003-06-30 03:49:37
@_author: David Shaw 
@_subject: cannot export key 
Hash: SHA1
search.keyserver.net is hopelessly broken.  Don't use it.  The only
keyservers that work with photo IDs are:
   hkp://sks.dnsalias.net
   hkp://keyserver.bu.edu
   hkp://sks.keyserver.penguin.de
   ldap://keyserver.pgp.com

@_date: 2003-06-30 03:49:56
@_author: David Shaw 
@_subject: Newbie w/ strange error msg 
Hash: SHA1
It means you have two config files.  GnuPG is warning you that it is
ignoring the old one (named "options").  It is unrelated to your
friend using PGP 8.

@_date: 2003-06-30 03:50:16
@_author: David Shaw 
@_subject: encryption 
Hash: SHA1
It is fairly common for people to encrypt messages to the recipient,
and also to themselves just so they can still read their own
messages.  You probably have such a configuration in your mail reader.

@_date: 2003-06-30 05:42:41
@_author: David Shaw 
@_subject: Robots in the WoT (clean version) 
Hash: SHA1
This is pretty much a FAQ nowadays.  The answer is yes, but it doesn't
make a difference.
Yes, it is possible to hit a keyserver over and over to get addresses
from it.  No, it doesn't really make a difference for a few reasons:
1) It's hard to do, as keyservers only give a few hundred responses at
   a time.  This means the spammer has to do "aaaaaa" "aaaaab"
   "aaaaac" etc, searches and that takes forever.  Remember that if it
   is hard to do, the spammer is going to go where it is easier to
   reduce costs.
2) There are MUCH richer sources of addresses out there.  A spammer
   can pull a never-ending stream of addresses from the web and/or
   usenet.  Comparatively, the keyservers are worthless.
3) Just because an address is on a keyserver, it doesn't make it
   valid.  There are a lot of old dead addresses in there.

@_date: 2003-06-30 05:43:01
@_author: David Shaw 
@_subject: Import of trustpaths 
Hash: SHA1
Did you run 'gpg --update-trustdb' after you signed the RootCA key?
GnuPG does this automatically by default, but some people have the
automatic update turned off.

@_date: 2003-06-30 15:04:02
@_author: David Shaw 
@_subject: Import of trustpaths 
Hash: SHA1
You can't do that.  It's just not how the web of trust works.
Once you sign the Root CA key, the Root CA key becomes valid.
However, it doesn't make any difference to any key underneath the Root
CA because you must set ownertrust on the Root CA key so that the
validity of the signed key can be calculated.
This applies to GnuPG, PGP, and anything else.

@_date: 2003-06-30 16:33:03
@_author: David Shaw 
@_subject: Import of trustpaths 
Hash: SHA1
Whoops - my apologies.  I just took a second look at the sample keys
you provided.  I didn't realize you were using trust signatures
Anyway, the proper answer to your question is that the current stable
GnuPG 1.2.x doesn't support that type of signature (it treats it as a
regular non-trust signature).  GnuPG 1.4 will support this fully when
it is released, and the development 1.3.x supports it now.
In the meantime, you can approximate the trust signature results by
manually setting trust at each hop.  "gpg --update-trustdb" will
prompt you for the needed values.  You only have to do this once: once
set, you don't need to set them again.

@_date: 2003-03-03 20:28:02
@_author: David Shaw 
@_subject: Stripped down (minimalistic) gpg? 
Hash: SHA1
When you build GnuPG, use ./configure --disable-exec --disable-dynload
That will leave out some extra stuff you don't need like the keyserver
support, photo ID support, and the ability to dynamically load the
IDEA cipher.
The development GnuPG allows you to also use --disable-xxxxx to leave
out individual algorithms, and --enable-minimal to make the smallest
gpg possible.  The minimal GnuPG has only DSA, Elgamal, RSA, MD5,
3DES, SHA-1, RMD160, ZIP and ZLIB.

@_date: 2003-03-04 15:39:01
@_author: David Shaw 
@_subject: Size of encrypted files 
Hash: SHA1
By default, it is mangled as specified in RFC-2440, section 3.6.
Basically, it is salted and then hashed multiple times.
As the key directly.

@_date: 2003-03-10 17:53:01
@_author: David Shaw 
@_subject: Batch (non-interactive) key signing 
Hash: SHA1
Use a capital Y here.  It's case-sensitive.

@_date: 2003-03-11 15:21:02
@_author: David Shaw 
@_subject: RSA sign key id being modified on MIT PGP keyserver 
Hash: SHA1
It was released a few weeks ago as part of pks 0.9.6.
Automatically corrected.
You'll have to ask the pgp.mit.edu administrator.  I do know they were
testing the new keyserver version, but I don't know what their plans
are.  The pks software is changing fast, so they may be waiting for
the next release.
There are a few keyservers that have upgraded, or who don't run pks so
the bug never applied to them.  Try:
   keyserver.bu.edu
   blackhole.pca.dfn.de
   pgp.cns.ualberta.ca
   keyserver.stinkfoot.org
   keyserver.kjsl.com
You can also use the PGP.com LDAP server: ldap://keys.pgp.com

@_date: 2003-03-12 15:19:01
@_author: David Shaw 
@_subject: a big and a small key 
Hash: SHA1
Adrian von Bidder has a nice HOWTO for this at

@_date: 2003-03-13 03:31:01
@_author: David Shaw 
@_subject: New crypto idea implemented in gpg 
Hash: SHA1
One of the things that harms OpenPGP compatibility of this is the lack
of a self-signature on the user ID.  There is no particular problem
with the user ID being fake, but the lack of a self-sig hurts (in
practice, even though the OpenPGP spec allows it).
Is there any problem with signing the user ID?  I imagine that the
keyid field of the signature can be set to the same as the
incomparable public key.  Each incomparable public key should be able
to verify signatures made by the single secret key, correct?

@_date: 2003-03-14 15:36:02
@_author: David Shaw 
@_subject: --edit-key / list 
Hash: SHA1
That's the primary user ID.  It is the one that is considered your
"main" user ID for most purposes.  You can change it with the
"primary" command.

@_date: 2003-03-14 15:38:01
@_author: David Shaw 
@_subject: fetchin public keys automatically 
Hash: SHA1
Do you have a keyserver set in your gpg.conf file?

@_date: 2003-03-14 17:23:01
@_author: David Shaw 
@_subject: problems with changing trust 
Hash: SHA1
=9Ee spr=C3=A1vne(
m cestovn=C3=ADch pasu*,
That looks like a bug in the polish translation.  Try the same thing
in english, and see if it also happens there.

@_date: 2003-03-21 23:12:02
@_author: David Shaw 
@_subject: Segfault when using symmetric encryption and gpg-agent 
Hash: SHA1
This is a known bug with using the agent with symmetric encryption,
and it will be fixed in 1.2.2.

@_date: 2003-03-21 23:19:01
@_author: David Shaw 
@_subject: I have no idea about "IDEA." 
Hash: SHA1
You can't easily upgrade a PGP 2.x key into a modern key, but if you
upgrade the self-signature on the key, you can gain some of the new
features like preferences.  If you have preferences you can dictate
which ciphers you accept, and remove IDEA if you choose.
To do this, run "gpg --expert --edit ", "sign", and follow
the prompts.

@_date: 2003-03-21 23:24:02
@_author: David Shaw 
@_subject: Ohhhh jeeee: no decrypt() for 17 
Hash: SHA1
The file was generated by an OpenPGP program with a bug.  Algorithm 17
is DSA, and you can't decrypt a DSA message, as it is a sign-only
algorithm.  There isn't much you can do except try and track down
which program encrypted it.  With luck, that program could decrypt it.

@_date: 2003-03-21 23:49:02
@_author: David Shaw 
@_subject: Revocation of a user id? 
Content-Disposition: inline
Yes, exactly.  In 1.2.2 you will be able to use "revuid" to do the
same thing with a bit less prompting.
Trust is chained via user IDs, so if you have multiple user IDs, and a
person signed them all, if you revoke one it does not matter from the
perspective of that person.  If the person only signed one user ID,
and you revoke that one, then the chain stops that that point.
Content-Disposition: inline

@_date: 2003-03-22 00:47:02
@_author: David Shaw 
@_subject: Revocation of a user id? 
Hash: SHA1
That is correct, with the caveat that not all OpenPGP programs will
necessarily do the same thing here.  I seem to recall that PGP doesn't
understand revoked user IDs and so will continue to propagate trust.
I haven't tested this under PGP 8 however, so it may have changed.

@_date: 2003-03-22 16:20:02
@_author: David Shaw 
@_subject: GnuPG --gen-key batch process? 
Hash: SHA1
Given the speed of your machine, it is likely that what is slowing you
down is the depletion of your entropy pool.  If you keep the machine
busier (type on it, run the disks, etc), you could probably go faster.

@_date: 2003-03-25 18:28:02
@_author: David Shaw 
@_subject: Signing a specific UID identified by an e-mail-address 
Hash: SHA1
Try using the test release of GnuPG 1.2.2 for your signing.  In that
version, "uid 1" always selects the primary.

@_date: 2003-03-27 00:14:01
@_author: David Shaw 
@_subject: private key protect cipher 
Hash: SHA1
It depends on which version of GnuPG you are using.  For quite a while
now (since 1.0.4 at least?) it is CAST5.

@_date: 2003-03-27 20:18:02
@_author: David Shaw 
@_subject: private key protect cipher 
Hash: SHA1
Not exactly.  The session key is (assuming you have a decent random
number generator) full strength for whatever cipher you are using, so
if you are using TWOFISH or AES256 then you do get the whole 256 bits.
That session key is encrypted with the public key of your recipient.
Your recipient decrypts their private key, and uses it to decrypt the
session key, and uses that to decrypt the message.
If you look at this end to end, then the weakest spot is still the
passphrase, but unless the attacker can get to your local system and
steal your private key, there is no way take advantage of this.
Without getting ahold of the private key, the weak point is either the
public key encryption or the (256-bit) symmetric encryption.

@_date: 2003-03-28 05:49:02
@_author: David Shaw 
@_subject: private key protect cipher 
Hash: SHA1
If your secret key is encrypted with a cipher that can use more than
128 bits, yes.  Note that you would also want to use a hash algorithm
that can generate enough bits here as well.  The default (SHA1)
generates 160 bits.
Before you try and memorize a 256-bit passphrase, though, keep in mind
just how realistic this attack is - and that someone who can access
your computer to lift the encrypted secret key might be able to try
and install a key logger...
GnuPG will use whatever the imported key uses.  However, if you change
the passphrase, GnuPG will re-encrypt using CAST5.  You can change the
cipher GnuPG uses for secret keys with --s2k-cipher-algo.
Note that GnuPG also adds a SHA1 secret key checksum when
re-encrypting an imported secret key.  This protects against some key
modification attacks.

@_date: 2003-03-28 15:35:01
@_author: David Shaw 
@_subject: Securing Secret Keys 
Hash: SHA1
It depends on your paranoia level.  In decreasing order of
paranoia-level, some solutions are:
* Revoke the key.
* Buy your company another hard drive, and take this one with you.
* Wipe the hard drive (not really that effective with modern
  hardware).
Something to look into in the future is to use subkeys and keep your
primary secret key offline.  Then, the worst that can happen is you
will generate some new subkeys and you get to keep your existing

@_date: 2003-05-03 03:46:02
@_author: David Shaw 
@_subject: Feature request 
Hash: SHA1
I'm afraid I don't follow this.  Can you give an example?

@_date: 2003-05-03 17:10:02
@_author: David Shaw 
@_subject: GPG ON UNIX 11 
Hash: SHA1
Note that GnuPG 1.2.2 has a built in workaround for the broken inline
keyword with the HP ANSI C compiler.  The problem should be
automatically detected and resolved.

@_date: 2003-05-03 17:11:02
@_author: David Shaw 
@_subject: Why Twofish implementation only with 256 bit ? 
Hash: SHA1
The reason is the OpenPGP standard.  "Twofish", in RFC-2440, is
specified as 256-bit.

@_date: 2003-05-03 17:18:03
@_author: David Shaw 
@_subject: [Announce] 1.2.2 release candidate 2 
Hash: SHA1
Ah, heh.  powerpc64 is a stub directory, with no code in it.  Using
that is the same as disabling assembler.

@_date: 2003-05-03 17:30:09
@_author: David Shaw 
@_subject: Feature request 
Hash: SHA1
Ah, I understand now.  That's a good point.  It is currently difficult
to tell which key you are signing with if you have more than one key
with the same user ID string.

@_date: 2003-05-04 02:47:02
@_author: David Shaw 
@_subject: gnupg-1.2.1: public key not found 
Hash: SHA1
'gpg' and 'gpgv' use two different keyrings.  Importing a key into the
gpg keyring does not import it into the gpgv keyring.  See the gpgv
man page for the details.
rpm uses its own keyring as well.  Try "rpm --import".

@_date: 2003-05-04 04:44:12
@_author: David Shaw 
@_subject: [Announce] Key validity bug in GnuPG 1.2.1 and earlier 
Content-Disposition: inline
Content-Disposition: inline
As part of the development of GnuPG 1.2.2, a bug was discovered in the
key validation code.  This bug causes keys with more than one user ID
to give all user IDs on the key the amount of validity given to the
most-valid key.
This bug does not impact any key with only one user ID.  Photo IDs
("user attribute IDs") do not count as an additional user ID for the
purposes of this bug.
For example, given a key with two user IDs:
   Alice    Alice's other address If the encrypting user has a trust path to to the ID
alice then this ID is fully valid, and there is no
warning message when encrypting to alice
If the encrypting user has either an insufficient or no trust path to
the ID "alice then that ID is either not fully
valid, or not valid at all respectively.  There should be a warning
message given when encrypting to this other user ID ("it is not
certain this key belongs to the user named in the user ID / do you
want to encrypt to it anyway?"), but due to the bug, the invalid user
ID is accepted as valid and no warning message is given.
This bug has been fixed in the newly released GnuPG 1.2.2, and
upgrading is the recommended fix for this problem.  For those who
cannot upgrade for whatever reason, the attached patch fixes the
problem as well.  The patch should apply (perhaps with some offsets)
to GnuPG 1.2,1, 1.2.0, or 1.0.7.  Note that GnuPG 1.0.6 (and possibly
earlier) versions have the same problem, but these versions are too
old to successfully apply the patch.  If you are using GnuPG 1.0.6 or
earlier versions, please upgrade.
The GnuPG Team (David, Stefan, Timo and Werner)
Content-Disposition: attachment; filename="patch-gnupg-1.2.1-trustfix.txt"

@_date: 2003-05-04 06:57:02
@_author: David Shaw 
@_subject: feature request 
Hash: SHA1
There is currently no way to do this via autoconf, but you can do it
manually if you like.  Use ./configure as normal, then edit the file
"g10defs.h", and put whatever value you like in for GNUPG_HOMEDIR.
Then "make" as usual.

@_date: 2003-05-04 18:44:01
@_author: David Shaw 
@_subject: Warnings from make check in 1.2.2 
Hash: SHA1
This is a typo in the 1.2.2 release.  It can be safely ignored.  What
matters is if the tests report PASS or FAIL.

@_date: 2003-05-05 15:47:03
@_author: David Shaw 
@_subject: Problem with Import of ultimate trusted key 
Hash: SHA1
Yes.  This is intentional since GnuPG sees you importing a key that
doesn't currently exist... but at the same time sees that key has
ultimate trust in the trustdb.  Since GnuPG normally deletes trust
when a key is deleted, this means there is a mismatch between the
trustdb and the keyring(s).
gpg --trustdb-name ./temp.trustdb .......
rm ./temp.trustdb

@_date: 2003-05-05 19:42:01
@_author: David Shaw 
@_subject: Building 1.2.2 on HP/UX 11.11 
Hash: SHA1
Strange.  That sounds like something in autoconf.  What does your
config.log show for the gettimeofday check?
Is the old inline problem at least working all right?

@_date: 2003-05-05 19:49:12
@_author: David Shaw 
@_subject: Building 1.2.2 on HP/UX 11.11 
Hash: SHA1
Actually, I have a related question - what error did you get when
gettimeofday did not exist?  Theoretically, GnuPG should be able to
build without it.

@_date: 2003-05-05 21:24:02
@_author: David Shaw 
@_subject: GPG 1.2.2 on Tru64 4.0F 
Hash: SHA1
That's very odd.  What happens if you change the empty definition of
EXTERN_UNLESS_MAIN_MODULE in include/iobuf.h to:
    EXTERN_UNLESS_MAIN_MODULE " "

@_date: 2003-05-05 22:51:02
@_author: David Shaw 
@_subject: Building 1.2.2 on HP/UX 11.11 
Hash: SHA1
Sorry - I wasn't clear.  I meant to ask what error you got when
building GnuPG when gettimeofday wasn't available.  Not the configure
error.  It was probably something in cipher/

@_date: 2003-05-06 02:31:01
@_author: David Shaw 
@_subject: Building 1.2.2 on HP/UX 11.11 
Hash: SHA1
Got it.  It'll be fixed in 1.2.3, though if autoconf had a problem
finding gettimeofday(), I'm not sure if it would fine times()

@_date: 2003-05-10 00:19:02
@_author: David Shaw 
@_subject: keyservers 
Hash: SHA1
If you want to build a keyserver, I'd subscribe to the
pgp-keyserver-folk mailing list and discuss your plans there.  See
 to start.
Also, if you want GnuPG to be able to use your keyserver without
writing a special plugin, you need to read this:

@_date: 2003-05-10 00:31:01
@_author: David Shaw 
@_subject: Keysigning 
Hash: SHA1
How about just adding two extra fields: "Nearest big city" and
"Distance to nearest big city" ?

@_date: 2003-05-10 04:58:02
@_author: David Shaw 
@_subject: keyservers 
Hash: SHA1
The size of an RSA signature is proportional to the size of the key.
He has a large RSA key.
 is more or less accurate on
the subject.

@_date: 2003-05-10 05:22:01
@_author: David Shaw 
@_subject: mobile GPG installation 
Content-Disposition: inline
It's pretty easy to do this.  Just copy the 'gpg' binary plus the
.gnupg directory onto the removable storage.  When you want to use it,
insert the storage, and then you can run gpg directly from the
removable storage as:
   gpg --homedir (path_to_the_.gnupg_directory)
On Unix you can set the GNUPGHOME environment variable instead of
using --homedir, but that does not work on Windows.
Note that this isn't terribly secure - an untrusted computer can
easily have a program on it to snatch your keys.
Content-Disposition: inline

@_date: 2003-05-10 05:26:02
@_author: David Shaw 
@_subject: [Q] Comparison of Encryption Algorithms 
Hash: SHA1
It's not an easy question to answer, because it's a hard question to
ask right ;)
Probably the best resource to look at is the book Applied
Cryptography.  Also read  for
some OpenPGP-specific discussion.

@_date: 2003-05-10 06:41:02
@_author: David Shaw 
@_subject: Building 1.2.2 on SunOS 4 
Hash: SHA1
Hmm.  In the main gnupg build directory, what does
  "grep underscore config.log" return?

@_date: 2003-05-10 22:41:03
@_author: David Shaw 
@_subject: Building 1.2.2 on SunOS 4 
Hash: SHA1
What happens if you do "./configure ac_cv_sys_symbol_underscore=yes" ?

@_date: 2003-05-11 04:50:02
@_author: David Shaw 
@_subject: [Q] Generating a key pair. 
Hash: SHA1
grep ac_cv_have_dev_random config.log
You shouldn't need to.  If you have a /dev/random device, configure
should automaticaly do the right thing.  (And if it doesn't, then it
should be fixed).

@_date: 2003-05-11 04:59:03
@_author: David Shaw 
@_subject: [Q] Generating a key pair. 
Hash: SHA1
"Best" is subjective.  You need to weigh speed (the bigger the key,
the slower the encryption), type of key (primary keys should be larger
in some key use schemes), the algorithm (RSA signing keys make large
signatures, and they get larger with the key size, DSA signing keys
are capped at 1024), and intended use.
This sounds far more complicated than it is, and lot of these factors
are of the "killing a fly with a sledgehammer" sort.  The question
becomes just how flat do you want to make the fly, because it's dead
either way.

@_date: 2003-05-11 05:02:01
@_author: David Shaw 
@_subject: [Q] Uploading my public key to a key server. 
Hash: SHA1
It advertises the keyid of your signing key, which someone could then
use to retrieve the key from a keyserver.  Of course, it has to get to
the keyserver first.
Use "gpg --keyserver wwwkeys.pgp.net --send-key (thekeyid)"
HOWEVER: DON'T DO THIS UNTIL YOU HAVE MADE A BACKUP AND A REVOCATION
The keyservers are filled with keys that are "lost" in one way or
another - keys that cannot be deleted, and cannot be revoked because
the key owner lost the secret key for whatever reason.

@_date: 2003-05-11 05:03:02
@_author: David Shaw 
@_subject: [Q] Comparison of Encryption Algorithms 
Hash: SHA1
Yes it does.  Generally speaking, anything you see on the net about
PGP applies to GnuPG as well.  There are exceptions, of course, but
Sam Simpson's FAQ is about both.

@_date: 2003-05-11 19:14:03
@_author: David Shaw 
@_subject: Photo ID Display Behavior 
Hash: SHA1
Yes, this is intended behavior.  The reason is that the --edit-key
menu is to see and manipulate what is really on the key.  A
revoked/expired photo ID shows up with a "[revoked]" or "[expired]"
just like a textual user ID would.
PGP 6 doesn't have any notion of a revoked user ID.  It treats revoked
user IDs as unrevoked.
This is in fact how the --list-keys photo code works now, and if you
do "--show-photos --list-keys", you get the semantics you want.

@_date: 2003-05-11 21:19:02
@_author: David Shaw 
@_subject: mobile GPG installation 
Hash: SHA1
gpg --homedir d:\whatever\you\like.
No registry.

@_date: 2003-05-12 02:39:03
@_author: David Shaw 
@_subject: multiple keyservers 
Content-Disposition: inline
It is possible that a future version of GnuPG will use multiple
keyservers at once, but for now, the last specified keyserver is the
only one that is used.  All others are ignored.
Content-Disposition: inline

@_date: 2003-05-12 03:42:02
@_author: David Shaw 
@_subject: Building 1.2.2 on SunOS 4 
Hash: SHA1
Good.  Now we just have to figure out why the autoconf test didn't
detect that properly... :/

@_date: 2003-05-13 05:48:02
@_author: David Shaw 
@_subject: [Q] DSA 1024-bit limit. 
Hash: SHA1
The DSA 1024-bit limit is not really a problem in practice.  DSA is
also limited to a 160-bit hash which is (some arm waving here) around
as "strong" as the 1024-bit key.  If you made a larger DSA key, then
the hash would become the weak point, and you didn't really gain
If you don't want to be limited to a 1024-bit signing key, don't use
DSA.  You can make an RSA signing key up to 4096 bits without any
special hackery.  There are drawbacks to this (such as a truly massive
signature size), but it's a good way to get a larger key size.
Some people (like me), have a 4096-bit RSA signing key, but use a
1024-bit DSA subkey for day to day use.
The problem with not caring about the standard is you can issue
massive signatures with a large DSA key.... but who is going to be
able to verify them?

@_date: 2003-05-15 03:28:03
@_author: David Shaw 
@_subject: [Q] DSA 1024-bit limit. 
Hash: SHA1
Note that GnuPG can use those monster keys.  The restriction is only
on generating them (for the sake of sanity and interoperability).

@_date: 2003-05-15 04:15:01
@_author: David Shaw 
@_subject: Using GnuPG on Windows/Linux 
Hash: SHA1
It's not impossible technically, but the locking scheme GnuPG uses at
the moment isn't compatible with a FAT filesystem.  It uses link().

@_date: 2003-05-16 03:55:13
@_author: David Shaw 
@_subject: SDA (was: mobile GPG installation) 
Hash: SHA1
Yes.  I once toyed with the idea of making a small decrypt-only
OpenPGP program for this sort of thing.  The idea was to be something
like gpgv - no trustdb, no key management, just decrypt symmetrically
encrypted messages.  I didn't do it because the regular 'gpg' binary
is already pretty lightweight, and doesn't need a complex installation
to run anyway.

@_date: 2003-05-16 03:55:48
@_author: David Shaw 
@_subject: Cracking AES 
Hash: SHA1
I'm curious why you're having a problem with '&'.  The only character
that should be a unusable via passphrase-fd is a newline.
The source code for all versions of GnuPG is available at
ftp://ftp.gnupg.org.  The Windows code is the same as the Unix code
(more or less).  Read the code in g10/seckey-cert.c and
g10/passphrase.c, in particular, for the code that handles secret key
decryption.  You should be able to hotwire it to do what you want.

@_date: 2003-05-16 15:20:02
@_author: David Shaw 
@_subject: Trouble signing (was: Trouble exporting keys) 
Hash: SHA1
I'm not quite sure what you mean here.  That user attribute contains
an image, so it says so.  Do you mean a name in addition to the image,
rather like the HTML "alt" tag, so nongraphical displays can still
give a text line?

@_date: 2003-05-16 20:27:03
@_author: David Shaw 
@_subject: User attributes and audio IDs (was: Trouble signing) 
Hash: SHA1
Ah.  There are a few ways to do this, but probably the best way
doesn't exist in the standard yet. ;)
The "user attribute" sort of ID can actually contain more than just
photos as it is a general storage medium for any sort of data.  There
is no reason why it cannot also store a "text" attribute.  The catch,
of course, is there is no text attribute defined in the standard yet.
I've been making a list of potentially useful attributes (images other
than JPEG, audio clips ("Hello! My name is XXXX and my fingerprint is
XXXXXXXX"), and the like.  Perhaps it would be reasonable to add a
text attribute to that as well for use when the other attributes were
not usable (i.e. non-graphical display, no sound card, etc.)
I'd be interested to hear comments about whether people would make
good use of something like an audio ID or not.  It certainly has the
potential to make keys very very large, though perhaps that is the
problem and choice of the key holder.

@_date: 2003-05-17 01:17:02
@_author: David Shaw 
@_subject: User attributes and audio IDs (was: Trouble signing) 
Hash: SHA1
Yes.  It doesn't lower security (it's just a different sort of ID),
but I can't think of any really good uses for it except the coolness
factor.  Then again, it could be argued that photo ID is just a cool
trick also.  Since you can't actually select a key via a photo ID, it
isn't really a good user ID.

@_date: 2003-05-17 06:09:02
@_author: David Shaw 
@_subject: User attributes and audio IDs (was: Trouble signing) 
Hash: SHA1
True, but no software exists (whether GnuPG or PGP) to do this today.
In both cases you need to select the key in question, and then view
the photo.  It's sort of a backwards way to select a key as normally
the user ID is used to get to the key.  I can see photos being used
more as a "select a key, then look at the photo to confirm it's the
right one" rather than a "encrypt to that photo".
It would be interesting to see a GUI that did what you suggest.  It
could be very helpful to people who were not particularly
I quite agree.  I think that would be a wonderful keyserver
enhancement.  Since the photo is actually a straight JPEG with some
OpenPGP header bytes that can be ignored, it should be fairly
straightforward for a keyserver to feed the JPEG data back to the
I responded a few days ago.  Didn't you see it?

@_date: 2003-05-17 14:16:02
@_author: David Shaw 
@_subject: Duplicated self-signatures on keyservers 
Hash: SHA1
Yes, that is what happens now.  GnuPG automatically strips an older
self signature if a newer valid self signature is already available.
On the other hand, a newer self signature is accepted for import, but
the old one is not deleted.  This is occasionally reported as a bug.
It isn't a bug, but it can be confusing.
It is a very good thing that the keyservers do not do this since they
do not have cryptographic support to know whether the "new" signature
is valid (or indeed, whether it is really new or not).

@_date: 2003-05-17 16:35:02
@_author: David Shaw 
@_subject: Duplicated self-signatures on keyservers 
Hash: SHA1
Yes, that is correct.  The signature check only happens when an
existing signature (and hence an existing key) is already in your

@_date: 2003-05-17 16:37:02
@_author: David Shaw 
@_subject: User attributes and audio IDs (was: Trouble signing) 
Hash: SHA1
If the standard got a "text" attribute tag, then this would be no
problem.  It's essentially the same thing we were discussing before.
Even if the standard didn't have a text attribute tag, it is possible
to use one of the experimental tags for this purpose, but of course
then only GnuPG would be able to use such user attribute IDs.

@_date: 2003-05-21 14:11:41
@_author: David Shaw 
@_subject: Encouraging email security. 
Hash: SHA1
Many of the keyservers have an email keyserver component.  GnuPG can
use them:
   gpg --keyserver mailto:pgp-public-keys --send-key (thekey)

@_date: 2003-05-21 14:13:43
@_author: David Shaw 
@_subject: Encouraging email security. 
Hash: SHA1
This is a fairly frequent request, but the functionality you desire is
built into every copy of GnuPG.  GnuPG is extremely configurable.
For example, to completely disable the web of trust, put:
  always-trust
in your gpg.conf file.  That makes all keys fully valid and ignores
all signatures on them.  A slightly less drastic way to disable the
web of trust is:
  max-cert-depth 1
That makes GnuPG trust any key you have signed yourself, but no
If you want certain ciphers to be used, try:
  default-preference-list ""
That makes the key use only 3DES, SHA1, and ZIP (or none) compression.

@_date: 2003-05-22 14:36:02
@_author: David Shaw 
@_subject: Consider a feature request? 
Hash: SHA1
Put in your config file:
    group cousins = 0xABCDABCD 0x12345678 0xDEADBEEF
Then encrypting to "cousins" encrypts to the specified keyids.  It
doesn't work for --list-keys: only --recipient (-r).

@_date: 2003-05-23 02:23:02
@_author: David Shaw 
@_subject: storing keyrings into SQL database? 
Hash: SHA1
Instead of storing each key with a random temporary filename, use a
filename derived from the fingerprint of the key.  It's deterministic,
plus if two keys have the same fingerprint, they are treated as the
same key for many purposes anyway.

@_date: 2003-05-23 05:56:03
@_author: David Shaw 
@_subject: Fingerprint security (was Re: storing keyrings into SQL database?) 
Hash: SHA1
A natural collision? Very, very unlikely.  V4 keys use SHA1 to
fingerprint, and the effective size of that hash due to the birthday
paradox is 80 bits.
V3/PGP 2.x keys are a different story altogether.  There is a weakness
in the key format that means you can play fingerprint games with
fairly little effort.  You can fake a keyid easily as well, but V3
fingerprints are not secure either.  This isn't a MD5 hash issue
(though MD5 has issues): it is a flaw in the fingerprinting

@_date: 2003-05-23 22:01:02
@_author: David Shaw 
@_subject: storing keyrings into SQL database? 
Hash: SHA1
This is not correct.  PGP uses all 160 bits of the SHA1 fingerprint,
giving 80 bits of collision resistance.

@_date: 2003-05-24 03:37:02
@_author: David Shaw 
@_subject: GNUPG FOR WINDOWS WITH GUI 
Hash: SHA1
Check out Windows Privacy Tray.  It is a graphical interface to GnuPG.

@_date: 2003-05-26 14:59:02
@_author: David Shaw 
@_subject: no-permission-warning in options file 
Hash: SHA1
GnuPG checks for permissions in three places: the --homedir, the
gpg.conf file, and any extensions (i.e. the IDEA module).
The check for the homedir happens *before* reading the gpg.conf file
so that anything in the gpg.conf file cannot disable it.  This is
because an unsafe (and possibly hacked) gpg.conf file might contain a
"no-permission-warning" flag specifically to turn off the warnings so
you don't know it was hacked.
This isn't clear in the documentation.  I'll fix that.

@_date: 2003-05-27 19:49:02
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.2 released (development) 
Hash: SHA1
The latest release from the development branch of GnuPG is ready for
public consumption.  This is a branch to create what will be GnuPG 1.4
someday.  It will change much more frequently than the 1.2.x "stable"
branch, which will mainly be updated for bug fix reasons.
The more GnuPG-familiar user is encouraged try this release (and the
ones that will follow in the 1.3.x branch), and report back any
problems to gnupg-devel  In return, you get the latest code
with the latest features.
Note that while this code is stable enough for many uses, it is still
the development branch.  Mission-critical applications should always
use the 1.2.x stable branch.
The files are available From: ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.2.tar.gz (1617k)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.2.tar.gz.sig
MD5 checksums for the files are:
  c984bfeb35fbc7bdc591bffb0d690d22  gnupg-1.3.2.tar.gz
  8d6c476a9d972ee7c3436d5ba2029130  gnupg-1.3.2.tar.gz.sig
Noteworthy changes in version 1.3.2 (2003-05-27)

@_date: 2003-05-30 05:34:03
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.2 released (development) 
Hash: SHA1
9 out of the 22 NEWS entries are new for 1.3.2.  There are a few more
changes that were not in the NEWS file, but these were not very
user-visible changes.  The diff between 1.2.1 and 1.2.2 was big enough
(and had to be applied to 1.3.1 as well) that I wanted to get 1.3.2
out to get a nice clean working surface again.
The changes that are in 1.3.2 and not in 1.2.2 are:
    * Multiple trust models are now supported via the --trust-model
      option.  The options are "pgp" (web-of-trust plus trust
      signatures), "classic" (web-of-trust only), and "always"
      (identical to the --always-trust option).
    * The --personal-{cipher|digest|compression}-preferences are now
      consulted to get default algorithms before resorting to the
      last-ditch defaults of --s2k-cipher-algo, SHA1, and ZIP
      respectively.  This allows a user to set algorithms to use in a
      safe manner so they are used when legal to do so, without
      forcing them on for all messages.
    * New --primary-keyring option to designate the keyring that the
      user wants new keys imported into.
    * --s2k-digest-algo is now used for all password mangling.
      Earlier versions used both --s2k-digest-algo and --digest-algo
      for passphrase mangling.
    * Handling of --hidden-recipient or --throw-keyid messages is now
      easier - the user only needs to give their passphrase once, and
      GnuPG will try it against all of the available secret keys.
    * DNS SRV records are used in HKP keyserver lookups to allow
      administrators to load balance and select keyserver port
      automatically.  This is as specified in
      draft-shaw-openpgp-hkp-00.txt.
    * When using the "keyid!" syntax during a key export, only that
      specified key is exported.  If the key in question is a subkey,
      the primary key plus only that subkey is exported.
    * configure --disable-xxx options to disable individual algorithms
      at build time.  This can be used to build a smaller gpg binary
      for embedded uses where space is tight.  See the README file for
      the algorithms that can be used with this option, or use
      --enable-minimal to build the smallest gpg possible (disables
      all optional algorithms, disables keyserver access, and disables
      photo IDs).
    * The keyserver no-modify flag on a key can now be displayed and
      modified.

@_date: 2003-11-12 04:58:29
@_author: David Shaw 
@_subject: Expired keys 
Content-Description: signed data
While the key may still be valid, the expired signature is not the
reason.  An expired signature is not counted in the web of trust.
Check if there is another signature on the key in question that is
giving it some validity.  Check also if your trustdb is out of date.
GnuPG tries to rebuild the trustdb as needed, but if you have
no-auto-check-trustdb set, then it cannot do so.
Sure, just try and sign it again.  You should get a:
  Your current signature on "(whoever)" has expired.
  Do you want to issue a new signature to replace the expired one? (y/N)

@_date: 2003-11-13 16:17:50
@_author: David Shaw 
@_subject: RSA v4 keys 
I cannot duplicate this problem here, so I need some more
information.  What does:
  gpg --export (yourkeyid) | gpg --list-packets

@_date: 2003-11-13 22:26:45
@_author: David Shaw 
@_subject: Expired keys 
No.  Expiry is unrelated to the trust indication.
Upgrade ;)  That feature was added in 1.2.2.
It should take it.  You'll probably end up with both signatures being
You'll probably end up with both signatures being present.  Of course,
only the unexpired one will count.

@_date: 2003-11-14 13:52:00
@_author: David Shaw 
@_subject: RSA v4 keys 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Nothing is broken here.  You have a v3 signature on your subkey, which
implicitly makes it a sign+encrypt subkey.  When GnuPG sees a usable
subkey, it uses it instead of the primary.  PGP can't make signatures
with subkeys, so it uses the primary.  Everything is working as it
That said, while the key is valid, the makeup of the key
is... eccentric.  You have a self-signature with class 10, which GnuPG
doesn't generate.  PGP does generate it, but it wouldn't have put
Blowfish in the preferences.  Then you have a v3 subkey binding
signature which neither GnuPG or PGP generates.  The key flags are
missing completely, making your primary key into a "sign+encrypt" key.
What did you use to make this key?

@_date: 2003-11-17 20:13:20
@_author: David Shaw 
@_subject: Matching a key with other emails 
Put in gpg.conf:
  group name = name
That works for regular GnuPG.  I don't know if it works inside

@_date: 2003-11-17 20:14:52
@_author: David Shaw 
@_subject: Matching a key with other emails 
Not completely true.  It's up to the key owner - OR the local user
(i.e. yourself) to amend the key.  You can trust the key owner, and
you (presumably) can trust yourself.

@_date: 2003-11-19 17:46:00
@_author: David Shaw 
@_subject: --compress ; not working in config file 
FYI: Werner and I discussed this and "--compress-level" will be in
GnuPG 1.2.4.

@_date: 2003-11-19 23:53:42
@_author: David Shaw 
@_subject: Strength of passphrase encryption 
By default, GnuPG uses CAST5 to encrypt the private keyfile on disk.
The encryption key is derived from the passphrase ("string-to-key")
via SHA1 and some salt, and that combination is hashed repeatedly.
This helps foil dictionary attacks.  A SHA1 checksum is used to detect
any modification of the key on disk.
Both CAST5 and SHA1 are considered strong at this time.
Of course, these are the defaults.  The user is free to use any
symmetric cipher, hash, or string-to-key scheme they like, or even
store their secret keys unencrypted, but the defaults are just fine
for most people.  The protections in place are vastly stronger than
the average passphrase, making the passphrase the weak point.

@_date: 2003-11-20 23:14:13
@_author: David Shaw 
@_subject: invalid armor header and PGP 8 
This is a corrupt file.  PGP generates all that on one line.  It looks
like something tried to word-wrap it...

@_date: 2003-11-20 23:47:40
@_author: David Shaw 
@_subject: Partial length headers 
Normally GnuPG chooses partial or not depending on the requirements of
the data (very large files must be partial, other files can be partial
or not).  You can force it to always be partial by giving it the data
via stdin.  That is, instead of doing:

@_date: 2003-11-24 19:27:15
@_author: David Shaw 
@_subject: Partial length headers 
The MDC packet is defined in 2440bis - the draft that will eventually
replace RFC-2440.  You can get the latest draft at

@_date: 2003-11-24 23:54:03
@_author: David Shaw 
@_subject: Partial length headers 
See util/iobuf.c, and search for the word "partial".

@_date: 2003-11-25 00:07:19
@_author: David Shaw 
@_subject: Migrating keys 
The problem with this is that lacking some additional information,
your old signers do not know if you are you, or if you are someone
else who has stolen your old key.

@_date: 2003-11-25 01:57:16
@_author: David Shaw 
@_subject: Migrating keys 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
These are two different problems.  In the case of someone presenting
me with a signed document, I may accept it or not depending whatever
criteria I want to use (how much validity I give the signing key,
mostly).  In the case of signing a key, I am making a public assertion
of verification, which is a substantially more rigorous check.

@_date: 2003-11-25 20:01:15
@_author: David Shaw 
@_subject: uninstall previous version 
It depends on how you have it installed.  If the previous version was
installed via an RPM or the like, you should uninstall it the same
way.  If you installed it there manually, you can do "make uninstall"
from the gpg build directory.

@_date: 2003-11-27 14:07:16
@_author: David Shaw 
@_subject: About ElGamal keys 
Hash: SHA1
That's odd.  Mail was sent to each of the type 20 key owners listed on
the keyservers.  I do see your name on the list, but I'm not sure why
you didn't receive it.

@_date: 2003-11-27 18:27:27
@_author: David Shaw 
@_subject: How can one tell what kind of a key one has set up? 
gpg --list-keys (yourkey)
Here's my key.
pub  4096R/99242560 2002-01-28 David M. Shaw sub  2048g/1643B926 2002-01-28 [expires: 2012-01-26]
sub  1024D/49E1CBC9 2002-01-28 [expires: 2012-01-26]
Look here.
If there is a capital "G" after the key size, that's an Elgamal
sign+encrypt key.  Anything else is safe.  It must be a capital "G"; a
lowercase "g" is also safe.

@_date: 2003-11-27 21:33:37
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.4 released (development) 
Hash: SHA1
The latest release from the development branch of GnuPG is ready for
public consumption.  This is a branch to create what will eventually
become GnuPG 1.4.  It will change with greater frequency than the
1.2.x "stable" branch, which will mainly be updated for bug fix
The more GnuPG-familiar user is encouraged try this release (and the
ones that will follow in the 1.3.x branch), and report back any
problems to gnupg-devel  In return, you get the latest code
with the latest features.
This release contains code to address the recently discovered Elgamal
sign+encrypt problem discussed in:
Note that this change prevents generating any new Elgamal sign+encrypt
keys, and prevents generating any new Elgamal signatures or encrypting
to Elgamal sign+encrypt keys.  This also means that this version of
GnuPG cannot be used to revoke an existing Elgamal sign+encrypt
primary key (as the revocation involves issuing a signature).  It can
still be used to revoke an Elgamal sign+encrypt subkey with a
non-Elgamal primary key.  If you still have a primary Elgamal key you
want to revoke, you will need to do it with an earlier version of
As always, note that while this code is stable enough for many uses,
it is still the development branch.  Mission-critical applications
should always use the 1.2.x stable branch.
The files are available From: ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.4.tar.gz (1861k)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.4.tar.gz.sig
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.3-1.3.4.diff.gz (242k)
MD5 checksums for the files are:
  3e2722be17f9ff3979c95b5fb1371818  gnupg-1.3.4.tar.gz
  907cd4bbaf03d6713e697310613612e9  gnupg-1.3.3-1.3.4.diff.gz
Noteworthy changes in version 1.3.4 (2003-11-27)

@_date: 2003-11-27 21:54:15
@_author: David Shaw 
@_subject: Migrating keys (fwd) 
Hash: SHA1
No.  If you sign my key, you sign my primary key plus a user ID.
**I** sign my subkeys.  You do not sign them.

@_date: 2003-11-28 01:11:19
@_author: David Shaw 
@_subject: Migrating keys (fwd) 
Hash: SHA1
No.  When you sign a key, you sign the primary, and you sign a user
ID.  You do not sign a subkey, and thus you are not making a statement
in any way, shape, or form about the number, quality, or otherwise of
the subkeys.  Don't read too much into what a key signature means.
Key signatures have exactly nothing to do with subkeys.

@_date: 2003-11-28 16:40:10
@_author: David Shaw 
@_subject: Migrating keys (fwd) 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
I've never met anyone who believed this, but rather than spending a
lot of time and effort to try and change the standard to remove
something that is a significant *feature* of the standard.... why not
just accept how things actually work?

@_date: 2003-11-28 16:55:57
@_author: David Shaw 
@_subject: How can one tell what kind of a key one has set up? 
Yep, that's an Elgamal sign+encrypt key.  Still, at least you can just
revoke the subkey.  You don't have to revoke your entire key.

@_date: 2003-11-28 19:04:06
@_author: David Shaw 
@_subject: How can one tell what kind of a key one has set up? 
The attack allows for a signature issued by an Elgamal sign+encrypt
key to be used to reveal the secret key.  For an Elgamal sign+encrypt
primary key, this pretty much means the whole key is compromised from
the start since the self-signatures on that key are of course issued
by itself.  For an Elgamal sign+encrypt subkey, while you still should
revoke it, you at least don't have to revoke the entire key.  Revoking
the subkey is sufficient.

@_date: 2003-11-29 01:23:17
@_author: David Shaw 
@_subject: Problem with Open BSD build 
Hash: SHA1
Try building with "./configure ac_cv_sys_symbol_underscore=yes".  This
problem pops up every now and then, and I haven't had the time to
really dig into it (I don't have an OpenBSD box here).  It's odd
because based on reports from other OpenBSD folks, it doesn't happen
in all cases.

@_date: 2003-11-29 04:17:17
@_author: David Shaw 
@_subject: Problem with Open BSD build 
Hash: SHA1
They both will work.  Solution  should run faster since it uses
assembly implementations for some of the big number math.  Solution only uses C.
There is an OpenBSD port of GnuPG 1.2.3.  I'd recommend running that

@_date: 2003-11-30 14:43:06
@_author: David Shaw 
@_subject: gpg 1.3.4 doesn't warn that it is an experimental version 
Hash: SHA1
The experimental version warning shows up when you actually perform an
action with gpg.  There was never an experimental version warning in
the --version output.  Perhaps there should be.  It would be an
obvious place for it.

@_date: 2003-11-30 22:08:59
@_author: David Shaw 
@_subject: subkeys and key flags 
Yes and no.  There is nothing banning subkeys certifying other keys in
2440, but at the same time, this is not a meaningful statement of
validity in the commonly used trust models.  GnuPG did do it
accidentally in the past for a release or two.  It hasn't done this in
a long time.
A lack of key flags means that the key may be used for whatever the
algorithm can support.  So, for example, an RSA type 1 key without key
flags is effectively a sign+encrypt key.
A signing subkey has the appropriate key flags set for signing data
and communications at generation time.  The certification flag is not
In theory it's doable, but GnuPG does not provide a means to do it.
You'd have to hack the source.

@_date: 2003-11-30 23:53:24
@_author: David Shaw 
@_subject: gpg 1.3.4 doesn't warn that it is an experimental version 
Hash: SHA1
We expect a 1.2.4 release candidate fairly soon.  It has some minor
bug and build fixes, as well as:
    * Support for Elgamal sign+encrypt keys has been removed.  Old
      signatures may still be verified, and existing encrypted
      messages may still be decrypted, but no new signatures may be
      issued by, and no new messages will be encrypted to, these keys.
      The only new message that can be generated by an Elgamal
      sign+encrypt key is a key revocation.
The current plan is for GnuPG 1.4 to have no Elgamal sign+encrypt
support at all.

@_date: 2003-12-01 00:06:31
@_author: David Shaw 
@_subject: new (2003-11-30) keyanalyze results 
According to the stats you sent earlier, only around 11% of Elgamal
sign+encrypt keys have been revoked.  21% are expired.  69% are still
usable.  (The numbers don't add up to 100 since some keys are both
revoked and expired, plus I'm rounding).
I hope that when 1.2.4 comes out there will be some more revocations
since there is nothing else that can be done with a type 20 key in
1.2.4.  Still, it is more likely that some of these are forgotten

@_date: 2003-12-01 05:55:34
@_author: David Shaw 
@_subject: subkeys and key flags 
It depends on the subkey type.  For types that depend on flags
(i.e. RSA), the flags were put in for a long time (1.0.6?).  For
Elgamal encrypt-only and DSA there was no point in flags, but for
neatness, flags were added anyway starting in 1.2.3.
GnuPG will.  I'm honestly not sure about the others.  It's also worth
verifying that all keyservers will store the second signature.  I'm
pretty sure that most won't.

@_date: 2003-10-01 00:42:01
@_author: David Shaw 
@_subject: Help adding the idea extension... 
Hash: SHA1
We need to see something a little more informative than "problem
getting the idea extension to work" ;)
What happens when you do "gpg --load-extension /path/to/idea -v --version" ?
I don't know if SCO has some problems with dynamically loaded code.
If it does, then --load-extension won't work.  You could take the
idea.c file and drop it into the GnuPG source cipher/ directory.
Re-run ./configure, rebuild GnuPG, and you'll have IDEA built-in.

@_date: 2003-10-01 20:51:02
@_author: David Shaw 
@_subject: Help adding the idea extension... 
Hash: SHA1
Interesting that there isn't even an error message here.  What does:
 grep USE_DYNAMIC_LINKING config.h
in the GnuPG build directory give?

@_date: 2003-10-04 18:19:01
@_author: David Shaw 
@_subject: newbie question about identities 
Hash: SHA1
Just a note - you use GnuPG without the WOT if you put:
  trust-model always
in your gpg.conf file.
This disables all trust calculations, and treats all keys (signed or
not) equally.

@_date: 2003-10-04 22:40:01
@_author: David Shaw 
@_subject: 1.3.3 binary //  for windows ? 
Hash: SHA1
1.3.3 hasn't been released yet.  It's only available from CVS, so
you'd need to build it yourself with MingW32 or Cygwin.

@_date: 2003-10-07 13:38:01
@_author: David Shaw 
@_subject: opie or s/key with gpg? 
Hash: SHA1
It is theoretically possible (I've thought about it for certain uses),
but it does not do what one might think it does.  One-time passwords
pretty much require that the item being protected be under the control
of the machine that runs the OTP system.  The process that
authenticates the OTP can then grant access to the protected item, in
this case the secret key.  It comes down to the OTP process either
needs access to the unprotected key or the passphrase.
This isn't a fatal flaw (after all, the gpg agent holds the same
information in memory), but it does change the circumstances where
such a setup would be useful.  Since most people want such a thing for
accessing their keys remotely, the requirement that their remote
machine must remain completely secure usually makes them reconsider.

@_date: 2003-10-08 20:09:03
@_author: David Shaw 
@_subject: opie or s/key with gpg? (fwd) 
To steal a a secret key, the attacker needs both the encrypted key
file, and the passphrase.  Using OTP doesn't make it any harder or
easier for the attacker to get the encrypted key file, so let's look
at the passphrase:
It's a given that "regular" GnuPG passphrases can be sniffed off of
the wire (or via a keyboard bug, or countless other variations), and
so can a one-time passphrase.  The point of one-time passphrases is
that they are only able to be used once and cannot be re-used a second
time.  There is no point in sniffing such a one-time passphrase, since
it won't be usable later.
However, in the system you suggest above, a OTP *can* be re-used.  The
problem here is the downwards count.  Any OTP x is capable of being
transformed into any OTP x+n.  A stolen encrypted key file encrypted
with OTP x can be decrypted by any OTP n where n < x by hashing the
OTP x-n times.
The only case where the proposed system is more secure than the
current system is if the attacker sniffs a passprase, and then later
goes back for the encrypted key file.  If the attacker steals the
encrypted key file at the same time he sniffs the passphrase, or
steals the encrypted key file before sniffing the passphrase then the
proposed system is effectively the same as the current design.
You seem to have realized this as well:
Not pointless.  It's possible to construct examples where OTP could be
useful (say, a signing service or decryption server that does not give
general access to the encrypted secret keyring), but it is not
generally useful as a passphrase-protection mechanism.

@_date: 2003-10-09 02:11:03
@_author: David Shaw 
@_subject: opie or s/key with gpg? (fwd) 
Hash: SHA1
If you come up with a scheme that prevents an attacker from deriving
OTP x+n from OTP x using the hash-x-times methodology in OPIE, I, and
doubtless many others across the Internet, would be quite interested
to see how.

@_date: 2003-10-09 17:33:44
@_author: David Shaw 
@_subject: win32 random source 
The win32 code uses a random gatherer based on Peter Gutmann's
Cryptlib.  The source for it is in cipher/rndw32.c in the GnuPG
The specific items used to stir into the random pool are things like
the disk I/O metrics, network statistics, some system performance
metrics, process statistics, etc.
GnuPG has a notion of entropy quality, and it ranks the entropy
sources accordingly.

@_date: 2003-10-11 01:27:21
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.3 released (development) 
Hash: SHA1
The latest release from the development branch of GnuPG is ready for
public consumption.  This is a branch to create what will eventually
become GnuPG 1.4.  It will change with greater frequency than the
1.2.x "stable" branch, which will mainly be updated for bug fix
The more GnuPG-familiar user is encouraged try this release (and the
ones that will follow in the 1.3.x branch), and report back any
problems to gnupg-devel  In return, you get the latest code
with the latest features.
Feedback on the "show-validity" display changes is particularly
appreciated.  Is this additional information (seen in --list-keys or

@_date: 2003-10-11 18:26:13
@_author: David Shaw 
@_subject: --gnupg option 
Hash: SHA1
The most significant differences are:
* Some win32 mail programs add whitespace to armor in odd places,
  --gnupg works around this.
* --openpgp has no MDC packets.  --gnupg does.
* --openpgp has no photo IDs.  --gnupg does.
* --openpgp has no TIGER/192 hash.  --gnupg might (if it is compiled
  in).
* All versions of PGP have differences in how they hash text data for
  signatures.  --gnupg has workarounds.
Minor differences -

@_date: 2003-10-12 00:06:41
@_author: David Shaw 
@_subject: --gnupg option 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
All versions before 7 cannot handle v4 data signatures.  Some versions
of 7 can handle them, and some can't.  8 can handle them.  I should
update the manual about that.
Correct.  You can do "--gnupg --no-force-v3-sigs" though.
In GnuPG 1.2.3, --openpgp wins.  There would be no MDC.
See above :)
Remember that --gnupg is the default.  You get --gnupg if you don't
explicitly set --openpgp, --rfc2440, --rfc1991, --pgp2, --pgp6,

@_date: 2003-10-12 14:40:16
@_author: David Shaw 
@_subject: --gnupg option 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
That's a different problem in PGP 8.  It can't always verify
signatures made by a subkey.
The only way to get PGP 8 to verify subkey signatures is to use the
"pgpmail" interface: save the mail to a file and run it through.
Using the "current window" trick or plugins won't work.

@_date: 2003-10-13 23:14:59
@_author: David Shaw 
@_subject: Can anyone tell me why it is happening (fwd) 
Another possibility is that the vendor was only encrypting (and not
signing) the files earlier.  Now that the vendor is signing, you'd
naturally get the "can't check signature" message.

@_date: 2003-10-15 13:43:58
@_author: David Shaw 
@_subject: BUG in gpg 1.2.3 (Re: Problem with multiple encryption subkeys) 
Content-Description: signed data
Hard for me to say something intelligent here without seeing the
The same thing works just fine for me.

@_date: 2003-10-15 13:49:57
@_author: David Shaw 
@_subject: question on multiple public keys 
Hash: SHA1
Yes, this is possible.  In each user's gpg.conf file, add a line
  keyring /path/to/the/shared/keyring.gpg
Note that when importing a key, each user will import to their own
local keyring unless they specifically state they want to import to
the shared keyring.  Likely you don't want the shared keyring to be
imported to by random users, so making it read-only is appropriate.

@_date: 2003-10-17 01:17:43
@_author: David Shaw 
@_subject: secret keys and public keys 
Hash: SHA1
You have to write your own, though 'gpgsplit' is helpful in getting
the packets together.  You can of course modify the GnuPG code to help
you do this - see in particular sign.c and keygen.c.
Some of the information about a keypair is stored in the public key.
It is not strictly necessary (all secret keys contain the correponding
public key anyway), but given the design of GnuPG it works out that
way.  Future versions of GnuPG may not require this.
You can create a public key from a secret key if you like.  GnuPG
1.3.1 and later do this automatically when you import a secret key.

@_date: 2003-10-17 16:02:45
@_author: David Shaw 
@_subject: 1.2.3 and 1.2.1 compatibility 
It is possible.  To really help though, I'd need more than "it doesn't
work".  Can you tell me what error message, if any, you saw?  Can you
encrypt a message to me with 1.2.3 and I'll try decrypting it in

@_date: 2003-10-20 13:49:38
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.3 released (development) 
Hash: SHA1
You're right, but note that the amount of change in a given 1.3.x
release is generally significantly higher than in the 1.2.x releases.

@_date: 2003-10-31 20:29:59
@_author: David Shaw 
@_subject: help needed desperately: gpg --decrypt hanging 
First things first.  If you put the data in a file, and run:
  gpg thefile.gpg
Does it work properly?

@_date: 2003-09-02 14:38:01
@_author: David Shaw 
@_subject: Key import - time warp or clock problem 
Hash: SHA1
Two problems:
1) His clock is a little over an hour fast... or your clock is a
   little over an hour slow.  It's not much of a problem
   since the warning message should go away after an hour when the
   clocks catch up with each other, but he (or you) should fix the
   clocks anyway.
2) He needs an encryption subkey, so he needs to do:
   gpg --edit mrname
   addkey
   (type passphrase)
   3
   (pick a size.  The default is reasonable).
   (pick an expiration date.  The default is reasonable).
   y
   y
   quit
   y

@_date: 2003-09-03 15:17:02
@_author: David Shaw 
@_subject: Changing the Hash algo in gpg1.2.3 
Hash: SHA1
It's the other way around.  MD5 isn't broken, but there have been some
weaknesses found in it.  It's still vastly stronger than most people
need, but people are tending to use SHA1 anyway.

@_date: 2003-09-03 20:16:02
@_author: David Shaw 
@_subject: desig-revoke 
Yes.  That is one of the intended uses of designated revocations.
They must authorize it ahead of time - essentially this is a special
signature added by the keyholder which authorizes a particular key to
issue revocations.  Note that the keyholder needs their secret key to
issue the authorization, so designated revocation doesn't magically
fix the problem of a lost secret key.
This lets someone revoke someone elses key, in effect (though with the
permission of the keyholder).  This is useful for companies with many
employee keys - rather than escrowing a revocation certificate for
thousands of employees, they can just be a designated revoker for
those keys.  Another example would be to appoint a trusted friend as
your designated revoker.  If something happens to you, they can then
revoke your key (which, presumably, you would be in no shape to do).

@_date: 2003-09-03 20:59:02
@_author: David Shaw 
@_subject: desig-revoke 
Content-Description: signed data
I'm not sure what you mean here.  Can you give me an example?

@_date: 2003-09-10 16:16:01
@_author: David Shaw 
@_subject: computing detached signature for a batch of files 
You assume correctly.  It is the concatenation of both files.
There is no way to do what you want inside of GnuPG itself (though as
it happens, it's on my list of stuff to add at some point).  You could
write a script to do it, but of course the script would have to know
the passphrase... and will thus be in insecure memory.  Only you can
decide whether this is a problem or not.
Another solution is to use the gpg-agent.  This caches your passphrase
in a secure manner.

@_date: 2003-09-11 13:59:01
@_author: David Shaw 
@_subject: question regarding relative security of md5 vs sha1 
Hash: SHA1
It's not an easy question - susceptible to attacks by *whom*?  Attacks
become feasible for different groups at different times (people who
have lots of fast computers and/or lots of money to spend on fast
computers are going to be able to attack sooner).  Also the difficulty
of different attacks varies widely (a birthday attack is massively
Because of this, and other reasons, the years you'll hear from
different people are likely to vary.
For what it's worth, the year I've seen cited for the ability to do a
birthday attack against MD5 is 1992 (yes, it passed already), and 2013
for SHA1.[1] It shouldn't be inferred that SHA1 suddenly becomes
broken in 2013 - just that somewhat around that time, the difficulty
of the attack goes from "practically impossible" to merely "absurdly
difficult" (think distributed.net).  Or someone could break it
tomorrow with a brand new attack that doesn't involve brute forcing.
Not everyone agrees with those dates, of course, but in any event MD5
has also had some successful analysis attacks against it.[2] It was
never "broken", but regardless of whether the hash is short enough to
be birthday attacked, it still would not be prudent to use it.
[1] [2]

@_date: 2003-09-11 19:14:02
@_author: David Shaw 
@_subject: Different uids with different trusts? 
It shouldn't be trusted.  B signed foo not bar  They're not the
same, even though they may reside on the same key.  This prevents
(among other things) this attack:
1) Trent creates a key, and gets it signed by Charlie.
2) Baker trusts Charlie, so therefore believes that Trent's key is
   valid.
3) Trent then adds a new user ID "Alice".
4) Baker wants to encrypt to "Alice", but which key to use?  They both
   appear valid.
The right thing to happen is for the real Alice to be valid, but
Trent's fake Alice to be invalid.

@_date: 2003-09-11 20:58:04
@_author: David Shaw 
@_subject: Different uids with different trusts? 
It doesn't work that way.  Self-signatures do not count in the web of
Neither does PGP, because that just not how the web of trust works.
If it worked the way you describe, then it would be open to trivial
spoofing attacks.

@_date: 2003-09-13 14:40:01
@_author: David Shaw 
@_subject: Can't decrypt PGP 8 msg 
Hash: SHA1
CryptoEx, historically, has not followed the OpenPGP spec particularly
well.  I wonder if they've fixed that yet.
No matter what hash algorithm was really used in clearsigning,
CryptoEx labels it as "MD5" which breaks verification.  It also
encrypts to sign-only keys...

@_date: 2003-09-15 15:39:02
@_author: David Shaw 
@_subject: Can't decrypt PGP 8 msg 
That is excellent news, and I am truly glad to hear it.  Is there a
demo version I could download and check out?  I'd be happy to do a
quick "smoke test" of CryptoEx <==> GnuPG compatibility.

@_date: 2003-09-15 20:43:02
@_author: David Shaw 
@_subject: Older self signature not stripped 
GnuPG never actually stripped older self-signatures.  What it did do
was disard any about-to-be-imported self-signature that was older than
an existing self-signature.  It did not go back and remove the older
one when importing a newer one.
As of v1.2.3, GnuPG does not even do this any more.  Enough people
complained.. ;)

@_date: 2003-09-22 22:54:05
@_author: David Shaw 
@_subject: primary? 
FWIW, the picture size warning comes up if the picture is over 6KB.
There is nothing magical about that number - when I wrote the code, I
looked at a good number of jpegs from PGP keys, noticed the same thing
that Mads Laursen noticed, and just bumped it up to 6KB to be safe.

@_date: 2003-09-28 15:42:02
@_author: David Shaw 
@_subject: questions 
Hash: SHA1
 when=20
e made Sun Sep=20
That's not an error.  That is a warning that the message does not have
internal integrity protection.  Integrity protection was not added to
the OpenPGP standard until fairly recently, so GnuPG is just warning
you that this message does not have it.  It does not mean that the
message was not decrypted successfully.

@_date: 2004-04-02 16:26:21
@_author: David Shaw 
@_subject: GPG - Invalid packet 
Could you run 'gpg --list-packets' on those files?  It might shed some
How large are the files (both input, and expected output sizes) ?
Are the input files ASCII armor ("---BEGIN PGP MESSAGE---", etc) or

@_date: 2004-04-02 17:20:59
@_author: David Shaw 
@_subject: GPG - Invalid packet 
Is it a binary or ASCII armor file?  That is, if you read the
encrypted file, does it begin with "----BEGIN PGP MESSAGE----" or is
it binary gibberish?

@_date: 2004-04-02 17:24:13
@_author: David Shaw 
@_subject: GPG - Invalid packet 
How was the file transferred to you?  It it was FTP, make sure you
didn't transfer it in text mode.  That'll mangle the file in a way
similar to what you posted.

@_date: 2004-04-02 18:45:12
@_author: David Shaw 
@_subject: GPG - Invalid packet 
That's normal for a binary message.
So, it could be binary being treated as text somewhere.  This is a
really common problem.  An easy check is to send the file you received
back to the sender.  If it doesn't match, then it got mangled by the
Another thing to try is to get the sender to turn on ASCII armor.  If
your transfer program wants text, give it text :)

@_date: 2004-04-09 04:55:17
@_author: David Shaw 
@_subject: Use of public key servers 
All true.  However, note the existence of phone books and directory
assistance.  It is convenient to be able to look people up in one
place, rather than asking everyone for their key individually.
Hasn't happened yet.  Isn't likely to happen for various technical
reasons, the simplest being that for a spammer, scraping addresses off
of the web or usenet is so trivial, why bother with something

@_date: 2004-04-09 04:56:20
@_author: David Shaw 
@_subject: --refresh-keys stops working while processing 
Hash: SHA1
Do you have any Elgamal signing keys in your keyring?  Refreshing one
of those can take a very long time.

@_date: 2004-04-09 14:07:01
@_author: David Shaw 
@_subject: gpg: can't put a policy URL into v3 (PGP 2.x style) signature 
Hash: SHA1
It's not a question of prohibition.  It's a question of
impossibility.  V3 signatures have no subpackets - there is no place
to put the policy URL.

@_date: 2004-04-09 14:09:54
@_author: David Shaw 
@_subject: notation data & policy URL 
Hash: SHA1
Yes.  Policy URLs are URLs.
Still, if you include all that information in the signature, you're
making the signature larger.  A policy URL at least is small.

@_date: 2004-04-09 21:39:25
@_author: David Shaw 
@_subject: gpg: can't put a policy URL into v3 (PGP 2.x style) signature 
You probably have --force-v3-sigs or one of the --pgpX options set.

@_date: 2004-04-09 21:48:24
@_author: David Shaw 
@_subject: notation data & policy URL 
Because the standard says so :)
Sure, why not?  Self-signatures are signatures too.

@_date: 2004-04-10 01:27:53
@_author: David Shaw 
@_subject: gpg: can't put a policy URL into v3 (PGP 2.x style) signature 
PGP compatibility.  No version of PGP before 8 can reliably handle v4

@_date: 2004-04-10 01:45:45
@_author: David Shaw 
@_subject: notation data & policy URL 
Because you want to say "this is how I verified the key".  Someone
else wants to say "this key belongs to me".  Someone else wants to
embed unprintable binary data.  Someone else wants to give his phone
Thus, a key=value pair.  Notations are a general purpose extension
mechanism.  They are not a policy URL alternative.
Same way one would do it for a non self-signature.  cert-policy-url or

@_date: 2004-04-10 12:57:33
@_author: David Shaw 
@_subject: gpg: can't put a policy URL into v3 (PGP 2.x style) signature 
Where is the typo?
The default is just the one that is most appropriate.  There is no
standard behavior to have the "no" value be the default.  Note
"--escape-from", "--mangle-dos-filenames", and "--ask-cert-level" are
also default-to-yes.

@_date: 2004-04-10 13:06:36
@_author: David Shaw 
@_subject: notation data & policy URL 
Nope.  It's dangerous for a program to try and be "smart" and guess
what you really mean.  You asked for a notation in both certs, so you
got it.
Notations are a general-purpose extension mechanism.  To do this, they
need to be usable anywhere a signature is generated.

@_date: 2004-04-10 13:10:21
@_author: David Shaw 
@_subject: notation data & policy URL 
The draft defines it thus:
    Notation names are arbitrary strings encoded in UTF-8. They reside
    two name spaces: The IETF name space and the user name space.
    The IETF name space is registered with IANA. These names MUST NOT
    contain the " character (0x40) is this is a tag for the user
    name space.
    Names in the user name space consist of a UTF-8 string tag
    followed by " followed by a DNS domain name. Note that the tag
    MUST NOT contain an " character. For example, the "sample" tag
    used by Example Corporation could be "sample
    Names in a user space are owned and controlled by the owners of
    that domain. Obviously, it's of bad form to create a new name in a
    DNS space that you don't own.
    Since the user name space is in the form of an email address,
    implementers MAY wish to arrange for that address to reach a
    person who can be consulted about the use of the named tag.  Note
    that due to UTF-8 encoding, not all valid user space name tags are
    valid email addresses.
Once you have a @ character in the key, you are explicitly saying that
the format of the value is defined by you.  You can thus put anything
you like in there.  Since the IETF has not defined any "official"
keys, GnuPG requires you to have that @ character.

@_date: 2004-04-13 01:57:26
@_author: David Shaw 
@_subject: notation data & policy URL 
There have been occasional suggestions, but none have been adopted.
It does serve as a handy response to some of the more eccentric
suggestions when people want to change OpenPGP in various ways: just
use a notation.

@_date: 2004-04-13 13:37:44
@_author: David Shaw 
@_subject: pgp/mime vs in-line pgp 
Hash: SHA1
Inline PGP is absolutely an official standard.  See RFC-2440.  It's
just a different official standard than PGP/MIME (RFC-3156).
Inline PGP can't handle all the situations that PGP/MIME does, and
it's not nearly as transparent as PGP/MIME, but it is a genuine
official standard.

@_date: 2004-04-13 23:21:41
@_author: David Shaw 
@_subject: pgp/mime vs in-line pgp 
What is a standard?  A standard is a bunch of people agreeing to do a
particular task in a particular way.  RFC-2440 makes inline OpenPGP
standards track.  If you choose to use it for email, that's great, but
the standard says nothing one way or the other.  OpenPGP is not an
email standard any more than TCP is an email standard, even though it
is commonly used in/for email.
If mutt supports it (it does), that's great, but it has nothing to do
with whether it is "official" or a "standard".

@_date: 2004-04-13 23:32:48
@_author: David Shaw 
@_subject: pgp/mime vs in-line pgp 
For every one problem that it would solve, it would create at least
one hundred more.  The answer to mail problems is to fix mail

@_date: 2004-04-14 22:58:30
@_author: David Shaw 
@_subject: Most commonly used OpenPGP symmetric ciphers 
Most commonly used is a hard question.  Most commonly used for *what*?
Historically, banking systems used 3DES (common for financial stuff).
PGP users used IDEA (because that is all that PGP 2 had), etc.

@_date: 2004-04-16 20:16:54
@_author: David Shaw 
@_subject: twofish keysize 
You cannot without modifying the code.  While the actual code can
handle 128 bit keys, that is not a valid key size in OpenPGP and is
not used.

@_date: 2004-04-17 04:16:44
@_author: David Shaw 
@_subject: twofish keysize 
There isn't one available that I know of.  Why do you want to use 128
bit keys?  The default is the larger 256 bits.

@_date: 2004-04-26 17:38:05
@_author: David Shaw 
@_subject: AES cipher support 1.0.6 and 1.0.7 
No.  It's due to the new secret key format in 1.0.7 and later.

@_date: 2004-04-26 17:39:04
@_author: David Shaw 
@_subject: verifying signature after decryption 
There is nothing in the OpenPGP protocol that prevents this.  In fact,
it's quite easy to do.  However, the code in GnuPG doesn't currently
allow it (it's not a generally useful feature).

@_date: 2004-04-26 17:40:02
@_author: David Shaw 
@_subject: MUA option "encrypt to self" weakness in certain situations? 
It's sort of correct, but not really a problem in the real world.  It
is true that the message is only as "safe" as the smallest key it is
encrypted to, but even the smaller key in your example is vastly
stronger than most attackers.
To put it another way, if your attacker can't climb more than 1000
feet, adding alligators and a moat to your 1001 foot wall doesn't
matter much.
It all depends on the attacker.

@_date: 2004-04-27 01:54:44
@_author: David Shaw 
@_subject: RSA Encryption / exchange with PGP 
Hash: SHA1
Unfortunately, PGP 6 does not follow the PGP specification very
closely.  GnuPG has code to work around this.  Try setting the
"--pgp6" option:
  gpg -r THEM -r US --pgp6 --output readme.gpg -es readme.txt
How did you get the encrypted file (install.log.pgp)?  More than
anything else this looks like the encrypted file was transferred to
you via text mode instead of binary FTP and so the file was corrupted
before you got it.

@_date: 2004-08-02 19:54:22
@_author: David Shaw 
@_subject: 1.2.5 windows binary  //  throw-keyid option 
Sorry about that.  It's a bug, and is fixed for 1.2.6.  In the
meantime, use "throw-keyids".

@_date: 2004-08-04 21:13:55
@_author: David Shaw 
@_subject: GPG equivalent of PGP's --group option? 
Yes, there is a --group command.  Stick in your gpg.conf file:
group name_you_want_to_use = keyid1 keyid2 keyid3 keyid4

@_date: 2004-08-04 21:16:05
@_author: David Shaw 
@_subject: gpg: malformed CRC 
Can you post a short sample message that works with PGP but not GnuPG?
Also, what happens if you use the --ignore-crc-error option to gpg?

@_date: 2004-08-05 17:44:55
@_author: David Shaw 
@_subject: gpg: malformed CRC 
I think PGP is correct here.  The spec says the checksum is a MAY, so
it should be legal to have an armored message with no checksum at all.
I keep meaning to change that in 1.3.x.
Though, of course, just because the checksum is optional doesn't make
it smart to leave it out.  There won't be any option to not generate a
checksum, but if you chop it off, I think GnuPG should accept the

@_date: 2004-08-05 21:39:31
@_author: David Shaw 
@_subject: gpg: malformed CRC 
Neither the CRC or MDC protects against packet addition as you
describe.  The CRC is not secure at all (nor is it intended to be),
and an attacker can just make a new CRC after modifying the message.
The MDC cannot be trivially replaced, but it protects just payload
data, and not the entire OpenPGP collection of packets.
The CRC is really just a quick way to see if an armored message got
mangled in email or Usenet.
It is very easy to create a message that looks like it should be
decryptable by three people, but only one of them can really decrypt
it.  Similar games are possible, like a message that looks like it was
encrypted to Alice, but it's actually secretly encrypted to Baker.

@_date: 2004-08-09 13:21:26
@_author: David Shaw 
@_subject: gpg: malformed CRC  //  feature request 
I think this sort of thing is safely beyond what GnuPG should do
itself.  Manipulating user-supplied input is a dangerous road to go
down.  Nothing stops a user from doing this via a front-end or script
if they desire, of course.

@_date: 2004-08-10 02:22:26
@_author: David Shaw 
@_subject: Partial body length encoding for Compressed packets 
For PGP 2 compatibility reasons, GnuPG uses indeterminate lengths for
compressed packets.  There is no way to change this, but if you are
willing to compile a special GnuPG to test with, you can do something
like setting "new_ctb" to 1 in build_packet() when generating a
compressed data packet.

@_date: 2004-08-12 17:20:35
@_author: David Shaw 
@_subject: GPG equivalent of PGP's --group option? 
There is no set limit, but you may eventually run out of space on the
command line.

@_date: 2004-08-17 21:23:00
@_author: David Shaw 
@_subject: Unrevoke revoked uid 
It depends.  If you sent the key with the revoked UID to people or
keyservers, then it is harder - you need to re-sign the user ID.
If you never sent the key with the revoked UID to anyone, just use
delsig to delete the revocation and you're done.

@_date: 2004-08-22 00:54:44
@_author: David Shaw 
@_subject: exec-path question 
The 1.3.x branch does not have HKP support compiled into the main gpg
binary.  All keyserver access is done externally.  1.2.5 cannot use
the 1.3.x keyserver programs since the protocol has changed.

@_date: 2004-08-27 01:04:01
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.2.6 released 
What processor do you have?  Offhand, I don't see any changes in the
MPI code that would do this.  There were barely any changes at all in
the MPI code between 1.2.4 and 1.2.6, and the few were for OpenBSD and
What does 'head -2 mpi/asm-syntax.h' return?

@_date: 2004-08-27 02:11:49
@_author: David Shaw 
@_subject: Solaris 2.9 and 1.2.6 (was Re: GnuPG 1.2.6 released) 
Hmm.  Does 1.2.4 build cleanly on that box after the upgrade?

@_date: 2004-08-31 01:59:46
@_author: David Shaw 
@_subject: How to generate old-style signatures? 
You can't.  GnuPG will understand old-style signatures but will not
generate them.
If you really must generate old signatures, there is a trick using
detached signatures and gpgsplit to assemble such a message by hand at
  See "Signing and encrypting a
document for a PGP 2.x user".

@_date: 2004-08-31 23:24:51
@_author: David Shaw 
@_subject: How to generate old-style signatures? 
Neither is exactly right.  I think that document was written quite a
while ago - back then, GnuPG did not have RSA at all.  Even today,
it's not a v3 or RSA thing, but an RFC-1991 (PGP 2.x) thing.  The line
should read something like "GnuPG does not have native support for
both signing and encrypting a document in such a way that it can be
read by a PGP 2.x user".

@_date: 2004-12-02 00:54:52
@_author: David Shaw 
@_subject: Clarification on how revokation works 
Yes.  The secret key at that point is only useful for decrypting
things that were encrypted before the key was revoked.
Yes.  And note that it's possible (though very difficult in practice)
to unrevoke a key by removing that statement.
I assume you are speaking about revoking a whole key here.  It is also
possible to revoke a subkey and a user ID.

@_date: 2004-12-13 16:36:53
@_author: David Shaw 
@_subject: PGP Global Directory 
Hi Folks,
I figured I'd forestall the obvious question about the new keyserver
that the PGP company announced this morning:
Yes, it works great with GnuPG.... but you need GnuPG 1.3.90 or
later.  Just set your keyserver to "ldap://keyserver-beta.pgp.com".
If you aren't using that version, you can use the new keyserver
through its web interface.

@_date: 2004-12-13 16:37:34
@_author: David Shaw 
@_subject: Decryption failed error 
What happens when you say 'gpg --list-keys 6A4285DA' ?  If nothing,
then it does seem like your customer encrypted to the wrong key.

@_date: 2004-12-13 16:38:34
@_author: David Shaw 
@_subject: PGP Global Directory 
Close.  It results in an email to every email address on the key, but
the rest is basically correct.
Weeding out dead keys is really, really useful.  I often have to guess
from 2-3 keys on the keyservers which is the right one to send to for
a given email address (I usually just pick the most recent, but there
is no guarantee that is right).  With the GD, you know the key is the
right one (for some reasonable value of "know").  It isn't perfect,
but it's better than the current system.
Could be.  You have 2 weeks to answer the mail probe.  If you don't,
your key is purged.  Big deal - just send it in again.  Submitting a
key fresh, and reconfirming a key really amount to the same thing.
The GD is supposed to be a list of active keys.  If a key ages off,
well, it wasn't really that active ;)
Yes, as many as you like.
Yes.  I haven't tried it with multiple photos, but I expect it works.
It certainly works with single photos.
This is a very good point, and I don't think the PGP folks have made
this nearly clear enough in their documentation.
The fact is, the GD is serving two functions: one, a keyserver that
weeds out bad email addresses, and two, a (weak) CA, based on the same
idea.  These two functions are related, but not identical.
If you want to use it purely as a keyserver, you can do that - just
treat it like any other keyserver.  You will continue to use the web
of trust to validate keys, and nothing has really changed for you
except that it's a little easier to get keys.
If you want to go further, you can get and locally sign the GD key and
give it as much trust as you care to.  This lets you automatically
trust any key that comes from the GD.  For some people, the GD
mailback verification is sufficient (set trust to "full").  For some
people it is a hint, but not complete (set trust to "moderate").  For
some people it is completely useless (don't set any trust at all).
It's important to note that this part of the system is strictly
opt-in.  If you do nothing, nothing happens.

@_date: 2004-12-14 22:09:29
@_author: David Shaw 
@_subject: Key strangeness 
Hashing a canonicalized pubkey packet is perfectly RFC compliant, and
in some cases is required.  You must never hash the original pubkey
packet with header, or you get problems, for example from a public key
with a 1-octet length encoding versus a 2-octet length encoding.  In
fact, there was an old PKS bug from exactly that problem.
This problem is a little different in that it is the MPI that causes
the problem, which is inside the pubkey packet itself and not a
header.  This is not a RFC compliance issue because the RFC forbids
leading zeroes in an MPI, period.  Since this key has leading zeroes,
it is a broken, non-RFC compliant key.  Any behavior is legal,
RFC-wise at this point, including discarding the bad key completely.
That said, since it seems GnuPG, PGP, (and PKS?) all resolve the issue
one way (canonicalize the MPI) and SKS does it the other way, it might
be nice to get SKS to canonicalize.  But this is not an RFC
requirement.  The SKS behavior is not incorrect here.
Of course, you're responding to a post from over 10 months ago.  This
may well have been resolved since then.

@_date: 2004-12-14 22:54:44
@_author: David Shaw 
@_subject: PGP Global Directory 
It should "just plain work" since, as you say, the GD isn't encrypting
the mails.
I think the target audience for the GD is rather different than many
of the people who hang out on this list.  The target audience needs a
way to get keys, with as little pain as possible, and with some amount
of assurance that the key is the right one.
Their definition of "some amount of assurance" and yours or mine is
going to be fairly different, to say the least.  The thing that
pleases me about the GD is that the design can be used by the beginner
or the advanced user.  The beginner can trust the GD key.  The
advanced user does not have to, and still gets the benefits of the

@_date: 2004-12-14 23:17:02
@_author: David Shaw 
@_subject: PGP Global Directory 
I think this is a known bug.  You might tell the PGP folks about it,
in case it is not known.

@_date: 2004-12-15 02:01:44
@_author: David Shaw 
@_subject: Key strangeness 
At this point I think you're just trolling so I'm going to stop
replying.  Needless to say, you've misunderstood what the RFC
requires, and what noncompliant actually means in this case.
Clearly the authors of the various versions of PGP and GnuPG got this
wrong.  I suggest you contact them posthaste and point out their

@_date: 2004-12-15 04:49:23
@_author: David Shaw 
@_subject: [Sks-devel] Re: Key strangeness 
The RFC does say that, but it is not the whole story.  It also says:
  The length field of an MPI describes the length starting from its
  most significant non-zero bit. Thus, the MPI [00 02 01] is not
  formed correctly. It should be [00 01 01].
MPIs with leading zeros are not RFC compliant.
Which is exactly my point.  The keys are made up of noncompliant MPIs.
The keys are thus corrupt/broken/not RFC compliant.  Whatever we call
it, the keys are outside the purview of the RFC.  There is no language
in the RFC that dictates how a program should handle a noncompliant
key.  This is a good thing, since questions like this can rapidly
spiral out of control - how much corruption is too much?
So given that noncompliant keys are outside the purview of the RFC, it
is correct to canonicalize the MPIs in an effort to "rescue" the key.
It is also correct to do nothing.  It is also correct to reject the
key altogether.
While I think it would be nice if SKS canonicalized as PGP and GnuPG
does, I would also be happy if it just rejected corrupt keys.  I do
think it would be a kindness to the community if SKS did not store
keys under the "wrong" key ID (and I use "wrong" carefully here since
it is not clear what is "right").
But this is just me expressing a preference.  The RFC does not mandate
any particular outcome here.

@_date: 2004-12-15 04:49:40
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.93 released 
It's been a long time since I looked at this, but I seem to recall the
reason is that we use indeterminate length encoding for compressed
packets (we pretty much have to since you can't tell how big something
will be after compression without using temp files).  Since we're
pushing something of indeterminate size into an encrypted data packet,
the encrypted data packet length is necessarily indeterminate as well,
and that chokes PGP 2.x.
The thing is, this isn't something new for 1.4.  Like I said, it's
been a good while since I looked at this, but I think it's been this
way since at least the 1.0.6 days.  Are you sure that you got
compression with --pgp2 before?
Definitely not!  Here's a fix:
Index: g10.c
RCS file: /cvs/gnupg/gnupg/g10/g10.c,v
retrieving revision 1.292
diff -u -r1.292 g10.c
--- g10.c	11 Dec 2004 04:47:33 -0000	1.292
+++ g10.c	15 Dec 2004 01:20:53 -0000
 -542,7 +542,7    /* hidden options */
     { aListOwnerTrust, "list-ownertrust", 256, " /* deprecated */
-    { oCompressAlgo, "compression-algo", 1, " /* alias */
+    { oCompressAlgo, "compression-algo", 2, " /* alias */
     { aPrintMDs, "print-mds" , 256, " /* old */
     { aListTrustDB, "list-trustdb",0 , "
     /* Not yet used */
Yes, but use at your own risk. ;)  They are not widely supported
outside of GnuPG.
It's a bit of backwards compatibility.  1.2.x used the Hx format in
"setpref" to set key preferences.  To be compatible with that, 1.4
still allows them.
The latest 2440bis draft (bis-12) deprecates it.
Thanks for the report!

@_date: 2004-12-16 23:23:29
@_author: David Shaw 
@_subject: Windows Binary 1.4.0 vs 1.4.0a  which to use? 
1.4.0a.  A bug was discovered too late to make it into 1.4.0, so a
1.4.0a was quickly released.

@_date: 2004-12-17 01:55:29
@_author: David Shaw 
@_subject: Broken signatures with Thunderbird/Enigmail since 1.4.0? 
Can you post the gpg command line that Enigmail uses to process a
signed message?

@_date: 2004-12-17 03:18:47
@_author: David Shaw 
@_subject: Broken signatures with Thunderbird/Enigmail since 1.4.0? 
Okay, I bet I know what the problem is.  I need to talk to some of the
Enigmail folks.  I think they may have a PGP/MIME text
canonicalization bug that one of the changes in 1.4 is aggravating.
In the meantime, you can work around the problem with the attached
patch to GnuPG.  This isn't a real fix for the problem, but should get
you going with 1.4 again until the real fix is ready.

@_date: 2004-12-17 15:20:56
@_author: David Shaw 
@_subject: [Announce] GnuPG stable 1.4 released 
Where do the keyserver helpers end up with an RPM build?  If they
aren't in your $PATH, then you do need exec-path.

@_date: 2004-12-17 15:32:17
@_author: David Shaw 
@_subject: [Announce] GnuPG stable 1.4 released 
Oops - meant to say "If they aren't in your libexecdir", which is

@_date: 2004-12-18 07:33:42
@_author: David Shaw 
@_subject: [Announce] GnuPG stable 1.4 released 
If you use configure --prefix=/usr then the libexecdir will end up
being /usr/libexec/gnupg.

@_date: 2004-12-20 14:56:32
@_author: David Shaw 
@_subject: Use of PGP to sign distributed files 
And if the public key isn't available, you can have GnuPG go and fetch
it for you automatically from a keyserver.  In fact, in 1.4, you can
tell GnuPG where to get a key without even having it on a keyserver.

@_date: 2004-12-20 15:10:31
@_author: David Shaw 
@_subject: expire function 
The main problem is one of convenience.  If you have gathered a number
of signatures on your key, you have to get them over again with a new
key.  Since you say you are using it mainly for private communication,
perhaps this reason does not apply to you.
Note that signing the new key with the old one doesn't do anything in
the web of trust: expired keys are not counted.
A reasonable solution for the desire to have expiring keys, plus the
desire to have one well-known key to sign is to use subkeys and have
the subkeys expire.  That is what I do.

@_date: 2004-12-20 17:36:23
@_author: David Shaw 
@_subject: expire function 
Ah, what a perfect opening to talk about the new 1.4 features to help
with the keyserver problem!
1.4 has the ability to embed a URL in a key or signature to tell
people which keyserver the key owner prefers to keep his key on.  The
URL can even be a web page or finger file so people don't even have to
use keyservers at all.
I'll send a longer writeup to this list.

@_date: 2004-12-20 17:36:59
@_author: David Shaw 
@_subject: Using the "preferred keyserver URL" in GnuPG 1.4 
GnuPG has long had a feature where a missing key would be fetched from
the keyserver upon signature verification (turn this feature on with
the keyserver option "auto-key-retrieve").  However, this did not
handle the case where the key owner preferred one particular keyserver
(say, one that wasn't broken or one that supports subkeys and photo
GnuPG 1.4 adds a new "preferred keyserver" feature, that lets you
include a URL with your key and/or with signatures you issue to help
the recipient know where and how to get your key.
To add a URL to your key, follow these steps:
1) gpg --edit-key (yourkey)
2) keyserver (yoururl)
3) save
The preferred keyserver URL lives on the user ID self-signature (along
with the other preferences), so if you want to get fancy, you can even
have a different preferred keyserver URL on each user ID.  Just select
the user ID you want the preferred keyserver URL on before entering
Once you have done this on your key, any user who uses
"--refresh-keys" on your key will automatically get your key from the
URL you have chosen.  The keyserver option "honor-keyserver-url" turns
this features on, and "no-honor-keyserver-url" turns it off.  It is on
by default.
To add a URL to your signatures, just stick this in your gpg.conf:
  sig-keyserver-url (yoururl)
Once you have done this, any user who verifies your signature but does
not have your key can automatically fetch it if they have the both the
keyserver options "honor-keyserver-url" and "auto-key-retrieve" set.
Note that honor-keyserver-url is on by default, but auto-key-retrieve
is not.
The URLs can be:
  hkp for HKP servers
      for example: hkp://subkeys.pgp.net
  ldap for LDAP servers
      for example: ldap://keyserver.pgp.com
  http for a file on the web
      for example:   finger for a finger plan:
      for example: finger:wk

@_date: 2004-12-20 19:41:27
@_author: David Shaw 
@_subject: Broken signatures with Thunderbird/Enigmail since 1.4.0? 
1.4.0 is not the problem here.  The problem is that the signer has
made a --textmode signature over a binary object (a gz file).  This
won't work reliably because gpg will try and change the line endings
and there aren't real line endings inside a binary blob.
This signature won't work with PGP either for the same reason.  The
fact that it works with gpg 1.2.6 is mostly luck.

@_date: 2004-12-20 23:05:12
@_author: David Shaw 
@_subject: Using the "preferred keyserver URL" in GnuPG 1.4 
Quite right.  I had forgotten about that since I have it in my
Someday no-force-v3-sigs will be the default.
Yes.  This shows what the keyserver URL is for the interested.  Note
that if you don't have the key when verifying a signature and there is
a keyserver URL present, the URL is *always* shown to you.  This
option only controls whether the URL is shown when verifying sigs from
keys you already have.

@_date: 2004-12-21 14:58:22
@_author: David Shaw 
@_subject: Using the "preferred keyserver URL" in GnuPG 1.4 
Different result, but underneath it's the same bug that Simon
Josefsson saw.  Try the patch I just sent to the list.
Good guess - it is indeed that the http code does not follow
redirects.  I have to think about how best to handle this.

@_date: 2004-12-21 17:02:30
@_author: David Shaw 
@_subject: Using the "preferred keyserver URL" in GnuPG 1.4 
Excellent.  The fix will be in 1.4.1.
Neat.  Where can I download gpgkeys_dns? ;)

@_date: 2004-12-21 18:26:42
@_author: David Shaw 
@_subject: Readline support in 1.4 
There was a little problem with the autoconf check for readline in
1.4.0.  It's already been fixed for 1.4.1, but the fix is too large
for me to just send to you as a patch.
The problem is that on some platforms, readline needs other libraries
as a sub-dependency (usually termcap or curses).  It seems that FC2 is
one of those platforms.
You might try doing:
  LIBS="-ltermcap" ./configure

@_date: 2004-12-21 20:18:02
@_author: David Shaw 
@_subject: Using the "preferred keyserver URL" in GnuPG 1.4 
If it is okay with Werner, it is ok with me.  The only thing is that
we need a copyright assignment to the FSF.  Keep in mind that you're
committing yourself to maintain it on different platforms :) :)
Not currently.  Somewhere on the todo list is a change to allow that.
It is difficult since there is no way to say "give me this update only
if it is revoked" in many keyserver protocols.  It is possible in
LDAP, and with CERT of course.

@_date: 2004-12-21 21:15:53
@_author: David Shaw 
@_subject: Readline support in 1.4 
Tab-completion is a whole different problem.  Does the up-arrow
history stuff work properly for you when building with -ltermcap?

@_date: 2004-12-21 22:28:47
@_author: David Shaw 
@_subject: Readline support in 1.4 
Do you think you could try the CVS version and let me know if things
work properly for you on FC3?

@_date: 2004-12-21 22:34:15
@_author: David Shaw 
@_subject: Readline support in 1.4 
It's not a bad idea to tab-complete the commands.  If nothing else, we
should turn off the tab-completion of filenames in the keyedit menu
since it doesn't actually take filenames..

@_date: 2004-12-21 23:14:02
@_author: David Shaw 
@_subject: Using the "preferred keyserver URL" in GnuPG 1.4 
Yes, the SRV code uses res_query.  If you use HAVE_DNS_SRV to detect
whether res_query is available and link with  then you can
safely use res_query anywhere.  If HAVE_DNS_SRV is set, you can rely
on res_query(), dn_expand(), and dn_skipname().
I'll make you a deal - if you write the DNS handler to properly handle
a flag passed from gpg to do a revocation-only search, I'll write the
code in gpg to pass that flag when appropriate.  Since a
revocation-only check can also be fulfilled (though slower) by a
regular check, this would be nicely backwards compatible.

@_date: 2004-12-22 06:39:06
@_author: David Shaw 
@_subject: Using the "preferred keyserver URL" in GnuPG 1.4 
I think Perl is probably fine (after all the "mailto" handler is
Perl).  The only thing is that we must make sure that all of the Perl
module dependencies are there before using it.  We can do that in
jkp is not the same as the proposed dns:// url.  Any reason not to use
'dns'?  I know the RFC hasn't been published yet, but perhaps this can
give you a chance to try the naming scheme out.
I'm not sure, exactly.  I hadn't really thought about having a
different server for revocations.  Is it sufficient to have a
revocation context flag passed to the gpgkeys_foo program?  For
example, in LDAP, the query string which is usually something like
'(pgpcertid=DB698D7199242560)' could be changed to
I worry about this sort of thing.  It can lead to serious user
confusion since gpg (or more likely gpgkeys) needs to track when the
key was last retrieved, and some users use different servers at
different times so it would have to be stored per-server and then the
user wonders why their key didn't update because it was within the
lockout period, etc, etc...

@_date: 2004-12-22 15:38:09
@_author: David Shaw 
@_subject: host not found: ec=11001 
Authenticated proxy support was just added in 1.4.0.  It will not work
in 1.2.5.
(and yes, I see the amusement of needing to upgrade to get the key to
verify the upgrade with... you'll have to get the key another way for
this one!)

@_date: 2004-12-22 15:46:20
@_author: David Shaw 
@_subject: t-sign 
When I wrote it, I did a lot of black-box testing against PGP 8 (I
must have made hundreds of test signatures).  So long as you use the
"PGP" trust model (remember that if you upgraded to 1.4.0 from 1.2.x,
you may still have the "classic" trust model), both programs should
behave the same way.
To see what trust model your trustdb is using, use:
  gpg --check-trustdb
To update an old trustdb to the PGP trust model, use:
  gpg --trust-model pgp --check-trustdb
After that, gpg will always use the PGP model until you change it

@_date: 2004-12-22 22:15:19
@_author: David Shaw 
@_subject: Install 
Can you post a few more lines before "Error 1"?  You snipped out what
the actual problem was :)

@_date: 2004-12-22 22:40:56
@_author: David Shaw 
@_subject: Install (updated) 
I believe this is the same problem several people have had with
What happens if you build with:
  LIBS="-ltermcap" ./configure

@_date: 2004-12-23 14:32:01
@_author: David Shaw 
@_subject: Install (updated) 
Very interesting.  Hmm.  Can you tell me what version of readline you
have installed?
Cobalt RaQ4 uses RPMs if I recall, so do "rpm -qa | grep readline"

@_date: 2004-12-23 14:48:32
@_author: David Shaw 
@_subject: Install (updated) 
Wow.  No wonder it isn't building.  Okay, you can build GnuPG like
  ./configure --without-readline

@_date: 2004-12-23 15:08:07
@_author: David Shaw 
@_subject: Install (updated) 
That readline dates from around 1998.  No big deal, but I need to
update the readline test for 1.4.1 to automatically detect the problem
you saw and leave readline support out.  You don't actually need
readline to build GnuPG - it's just a convenience.

@_date: 2004-12-23 15:52:10
@_author: David Shaw 
@_subject: host not found: ec=11001 
What happens if you stick in your gpg.conf file:
  keyserver-options http-proxy

@_date: 2004-12-23 17:00:30
@_author: David Shaw 
@_subject: host not found: ec=11001 
Oops - this is a bug.  It should be lowercase.  I will fix it for the
next release.
Note, by the way, that you can do:
  keyserver-options http-proxy="
and avoid the whole environment variable thing if you want.

@_date: 2004-12-23 17:03:22
@_author: David Shaw 
@_subject: host not found: ec=11001 
Wait a moment.  I thought there was a bug, but the code looks correct.
Did it work for you with "HTTP_PROXY" or "http_proxy" ?
"http_proxy" (lowercase) is the correct one.

@_date: 2004-12-23 18:05:22
@_author: David Shaw 
@_subject: KSP question: merge signatures? 
Automatically merges.  Just import both keys and you're all set.

@_date: 2004-12-24 22:00:31
@_author: David Shaw 
@_subject: [IPC Error Console] What's that ? 
GnuPG has no windows, so it's being generated from Enigmail or
Thunderbird.  I'd ask the Enigmail folks.

@_date: 2004-12-25 21:30:42
@_author: David Shaw 
@_subject: The disadvantages of online KSP 
Signing someone's key is you making a statement that you have checked
that the key belongs to the person named in the user ID.  You really
can't do that in a strong way without meeting physically.
I would not sign someone's key under such circumstances.

@_date: 2004-12-26 14:08:57
@_author: David Shaw 
@_subject: The disadvantages of online KSP 
Be very careful with the signature levels.  They're not as meaningful
as many people think.  First of all, they are really only for human
eyes - the web of trust does not give more trust with a level 3 than
with a level 2.  PGP and (until recently) GnuPG treats all signatures,
whether 0, 1, 2, or 3 alike.  These days, to help deal with a large
number of pointless and completely unchecked signatures, GnuPG
actually discards any level 1 signatures it sees.  Finally, note that
0 is not lower than 1.  0 is "I do not participate in this signature
scheme so I will not answer".  1 is the lowest.
The bottom line is that signature levels are vaguely useful as an
indication from one human being to another, but for the sake of the
web of trust, don't think that a lousy signature can be made less bad
by making it level 1.  A lousy signature is a lousy signature.

@_date: 2004-12-28 04:31:58
@_author: David Shaw 
@_subject: Compile GnuPG 1.4 under cygwin? 
Not a stupid question at all.  The problem you are having is a known
bug in 1.4.0, and I believe it is fixed for the upcoming 1.4.1.
However, this bit:
troubles me a little.  Can you check if there is a resolv.h in your
cygwin install?  I was under the impression (possibly incorrect) that
resolv.h existed.

@_date: 2004-12-28 04:42:09
@_author: David Shaw 
@_subject: GPG wants to check trustdb every day 
The date is set to the nearest expiration (key or signature) that
affects the calculated trust (i.e. a key or signature that actually
got used in your web of trust).  So the check is not really once a
month or so, it's when needed.  If you have no expiring keys or
signatures, GnuPG will never recheck.
Note that many actions (including importing keys, deleting keys,
revoking keys, revoking user IDs, etc) all force a recheck of the
trustdb since these actions may invalidate the existing web of trust.
If you're next trustdb check is scheduled for December 30th, then you
probably have a key or signature that expires then.
Note that if you're using PGP's global directory service, you will
always have a signature that expires soon since the GD issues 14 day

@_date: 2004-12-28 05:15:15
@_author: David Shaw 
@_subject: Compile GnuPG 1.4 under cygwin? 
Hmm.  Are you able to build 1.4.0 with it?  How new is your Cygwin

@_date: 2004-12-28 16:41:43
@_author: David Shaw 
@_subject: Compile GnuPG 1.4 under cygwin? 
No, it's okay to not have it.  It is for an optional feature of the
HTTP handler (SRV support), and things work fine without it.
Try the attached patch.

@_date: 2004-12-29 04:59:39
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
No real preference.  All?  The GD sigs aren't really relevant outside
of the GD system.
I strongly disagree.  The GD is just a key signer.  The GD does not
send its signatures to keyservers.  The GD doesn't even issue the
signature until someone asks it to.
If what the GD does could have an actual impact on the keyservers and
web of trust, then the keyservers and web of trust were already
hopelessly broken.  They weren't broken before, and the GD doesn't
break them any more than any prolific signer would (that is, not at
all).  There is only one thing that the GD actually breaks, and that's
the various "what's the path from key XXXXX to key YYYYY" servers like
wotsap.  Those servers will eventually need to leave the GD key out to
avoid the short circuit that the GD signature provides.
My concern is mainly about the aesthetics here.  It's unattractive
(and over time large) to have that many expired sigs on your key.
This is essentially the same as not exporting expired sigs to
keyservers.  It doesn't work well for the reasons I mentioned in the
last email, though it might work well enough to slow the problem down.

@_date: 2004-12-29 05:11:48
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
This is intentional.  Unlike the unix-ish system(), win32 system()
returns immediately to the calling process and does not wait for the
spawned process to exit.  This does not work for GnuPG since we need
to know when the child process exited and what its return code was.
Hence the CreateProcess call.
I'm not against it, but not that interested in writing it myself ;)
The mailto keyserver helper has always been a bit of a lower
priority.  I was surprised to see your mail, actually.  I didn't think
anyone was using it.
Anyone have any ideas on this one?  Is there some win32 shell magic
that can be used to associate gpgkeys_mailto with a perl interpreter?
I'd like more information about this.  Can you give me a pointer?

@_date: 2004-12-29 05:41:35
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
I certainly won't argue that many aspects of the keyserver design are
broken.  The problem is, some of the brokenness is also a design
requirement for some people.  "Broken" is really a question of "broken
for whom" ;)
Someone told me once that the old NAI "LDAP keyserver" supported
no-modify, but even if it is supported, neither of the two servers
running this software has it turned on.
The GD doesn't support no-modify either.
True.  However if the concern is strictly the UI then a "don't show
unusable sigs" flag would handle that.  There is already a "don't show
unusable user IDs" and "don't show unusable subkeys", so adding one
for sigs is no big deal.

@_date: 2004-12-29 06:12:04
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
We don't actually need perl or sendmail - just the ability to send
mail somehow.  I did it with perl and sendmail on unix because it was
easy, not because it was portable :)
I wonder if it would solve all the problems to provide an actual
gpgkeys_mailto.exe on win32 that used ShellExecute() to "open" a
mailto: URL.  The user would get a pre-filled in mail window from
whatever program they use for email, and just have to hit send.

@_date: 2004-12-29 06:25:14
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
When I was writing the original keyserver exec code, back in the 1.0.7
timeframe, system() was certainly returning immediately.  It could
very well have been command or cmd.exe returning immediately after
launching the command line, but either way, the practical result was
that system() returned control to gpg before the child process ended.

@_date: 2004-12-29 14:20:12
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
Yes.  As I understand it, the GD has a weak form of no-modify since it
does not allow new user IDs or subkeys without approval, but does
allow new signatures without approval.  The new signatures must come
from a key that is already on the GD.
It's not a bad way to go, considering the GD is aimed at "regular
people" rather than crypto enthusiasts.  One less special key option
for people to understand.  I'd prefer no-modify, but I'm not the
target audience.
Security-wise, it's safe.  One of my concerns when I first heard about
the GD was that the approval process would allow a key owner to
prevent a signature revocation or designated key revocation from a
third party from reaching his key.  Since third party signatures are
allowed in without key owner approval, this cannot happen.
Yes, I mentioned this in my first mail.  There seems to be an overlap
between the old and new signatures.  The signature lasts for 14 days,
but the new signature is issued sooner.  I've seen overlaps as short
as 8 days.

@_date: 2004-12-29 14:29:58
@_author: David Shaw 
@_subject: ElGamal sub key expired 
In the --edit-key menu, type "key n" where n is the subkey number.  An
asterisk will appear next to the subkey to show you which key you
chose.  Then enter "expire".

@_date: 2004-12-29 19:15:59
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
It lowers the rate of growth (and thus the keyserver load) since gpg
would not send out expired sigs to keyservers.  The GD itself doesn't
export keys, so if we can prevent users from doing it accidentally,
then the useless sigs never get onto the keyserver net.
That's up to the keyserver authors.  I'm not against it, but they
might be as it involves special-casing certain keys.
I'm still holding out hope that the current 14 day expiry is because
the keyserver is still in beta.  The GD is supposed to revalidate keys
every 6 months, so a 6 month expiry seems obvious to me.
I wonder if it is better to "clean" the keyring by simply not showing
or preventing the import of sigs that are not useful rather than by
deleting them after they are already imported.  Flags for "don't
show/expire/import expired sigs" you can set once in gpg.conf and
you're done.  Deleting expired sigs you have to do every single time
you do a --refresh-keys.

@_date: 2004-12-29 20:14:37
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
Do you happen to know if using ShellExecute() to open a mailto: URL is
widely supported?
Writing a new gpgkeys_mailto seems like a pain, but it would allow me
to cross a different item off my todo list: removing the various perl
dependencies which makes packaging GnuPG difficult.

@_date: 2004-12-30 00:33:09
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
Yes, it seems that the GD key itself is not changing.  Since the GD
has a LDAP backend, this wouldn't be hard to do.
No idea.  This is all black box conjecture.

@_date: 2004-12-30 03:57:26
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
Generating bogus keys and using them to sign real keys is noise in the
web of trust.  The GD is actual useful signatures, though not useful
to all people.  Neither has any meaningful impact on the web of trust.
The web is just not designed that way.  If you don't give trust to a
bogus key that someone generated to be "funny", signatures from that
key are invisible to you.  Similarly, if you don't give trust to the
GD key, the GD signatures are invisible to you.  The web of trust is a
perfect example of a strict "opt in" system.
The worst thing that unusable signatures can do is to make keys larger
and make UI displays unattractive.  This isn't impacting the web of

@_date: 2004-12-30 04:34:45
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
Yes, this is true.  Ok, how about going back to the idea of import and
export options to not import or export expired sigs.  It's not
perfect, due to the time overlap between expired and reissued GD
signatures, but it's a reasonably good solution.
I rather like the notion of GPG keeping GPG clean, the keyservers
keeping the keyservers clean, and so on.  So long as people aren't
actively bridging keys between the GD and the keyserver net (which
seems to be happening in my case, though I have no idea why someone
would bother), this should be okay.

@_date: 2004-12-30 05:09:11
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
Looks like using mailto: is a non-starter whether from ShellExecute()
or WSH.  The limit is 2k, and even smaller on some older versions of
win32.  2k isn't enough to do much more than submit the very smallest
of keys.

@_date: 2004-12-30 05:21:06
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
Try this patch to 1.4.  It adds an export-option
"export-unusable-sigs" and an import-option "import-unusable-sigs".
Both are off by default.
Comments welcome.

@_date: 2004-12-30 15:04:39
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
I'm not sure what connection this comment has with the discussion.
You're talking about people signing a key and uploading their
signatures (however foolish this might be in the case of the GD key).
I'm talking about someone downloading keys from the GD and then
pushing them onto the keyserver net.
As I said, unless someone is bridging keys intentionally, then the
GnuPG filter should handle it reasonably well.  (Only "reasonably"
well because of the overlap in signature dates).
I think the people who the GD was designed for pretty much don't care
about signatures from keys not registered with it.  That's the whole
Understand that being "unsynchronized" is a major *feature* of the GD.
A goal of the GD is to keep all of the old crap from the keyserver net
off.  I know you like synchronization, but you are not the target
audience for the GD.  Neither am I.  I use it because it provides some
level of useful functionality even to people who aren't the target

@_date: 2004-12-30 21:22:03
@_author: David Shaw 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
Oh, I can believe that.  It's the "I need to sign this to make things
work" thing.  Do beginners necessarily understand what signing
entails?  No.  Do they necessarily understand what the web of trust
even is?  No.  All they know is that the instructions say to sign the
key, so they sign the key.

@_date: 2004-12-30 21:38:11
@_author: David Shaw 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
[people signing the GD key]
I'd estimate that around 5 of those signatures are genuine and the
majority of the rest are either completely or partially accidental.
Some people probably meant to locally sign, and some people just
didn't have any idea what they were doing.  I'm sure some people did
it intentionally with full understanding of what they were doing, but
I suspect they are in the minority.
It's a amusing example of how well people verify keys before the sign
them.  I have a (much fewer) number of similar unchecked signatures on
my own key.  My key comes with the GnuPG distribution, so I think
people use it for testing sometimes.
Unless you are or know the robot's keeper.
It's an interesting keysigning question, actually.  Not just for
robots, but for any key that doesn't directly correspond to a single
human being (robots, nym keys, role accounts, etc).

@_date: 2004-12-30 21:54:38
@_author: David Shaw 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
Both GnuPG and PGP do more or less the same thing here.  You can
import keys freely, but such keys will remain invalid until there is a
valid trust path to the key.  Invalid keys are usable, but you get
some variation of the "are you sure?" message before you can use the
If there is no valid trust path to the key, and you want to make it
valid (say, if you want to trust signatures issued by it, as in the
case of the GD key), then you need to sign or locally sign the key
yourself.  PGP's "Sign" command actually defaults to local signing.
You need to make an explicit action (check a check box) to make it a
regular exportable signature.  Note that I'm speaking about PGP 8
here, though I seem to recall that PGP 7 was the same.

@_date: 2004-12-30 21:57:32
@_author: David Shaw 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
Ideally, signing a key should never be affected by a key signing
policy, though since this is the real world, it certainly is a factor.
Still, how would you go about checking the identity of a key that
identifies itself only as "PGP Global Directory Verification Key" ?  I
can certainly understand that you signed the Robot CA key, but signing
the GD key seems to be a leap of faith rather than actual hard

@_date: 2004-12-30 22:24:51
@_author: David Shaw 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
It depends how you are using PGP, I guess.  I imagine some plugins may
restrict more, but the regular "PGPmail" application lets you encrypt
to any key you like.  It just grays out invalid keys, but they are
still usable.
Yes.  PGP differs on this point - you can only make a key ultimately
trusted if you have both the public and secret parts.  GnuPG lets you
make any key ultimately trusted.  I like the GnuPG method better since
some people keep their secret keys offline.

@_date: 2004-12-31 01:56:29
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
Hmm, so it's worth a try.  Adding a key via a mailto URL could be
interesting, though.  I wonder how the various mailto handlers would
deal with an URL that is over 32k long!

@_date: 2004-12-31 03:53:32
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
This is not an example of bridging keys.  The GD key (CA57AD7C) is
stored on the GD, but isn't itself certified by the GD (except for the
obvious selfsig) and isn't part of the GD verification system.
An example of bridging keys is (for example), my key 99242560.
Someone took the trouble of downloading it from the GD, and then
uploading it (gee thanks) to the keyserver net.  They didn't add any
signatures, they didn't add anything at all - just copied it over.  It
could have been accidental or it could have been intentional, and it's
probably happened to at least a few keys besides mine.  I don't think
this sort of thing is common, or there would be a huge number of
signatures from the GD key on the keyserver net, and there aren't.
Since this isn't common, then a GnuPG feature to disregard expired
sigs should work reasonably well, as I've said.
Which shows that people aren't actively bridging keys, or you'd have
vastly more than 120 signatures issused by the GD key on the keyserver
net.  Far more than 120 people use the GD.

@_date: 2004-12-31 04:14:10
@_author: David Shaw 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
There is a difference between believing something personally, and
making a public statement about that same something.  The first is
opinion.  The second needs proof.
Key 57548DCD is the key that signs new GnuPG releases.  I believe that
this key belongs to Werner.  It would be absurdly difficult for it to
be some imposter since there have been however many GnuPG releases
over the past few years, all signed by this key.  Realistically, it is
utterly obvious that Werner is the key owner.  Would I sign this key
without meeting Werner?  No.
Perhaps a better example would be Jason Harris' key D39DA0E3.  I never
met Jason, but his key is fully valid to me because I met another
fellow and signed his key, and he in turn met Jason and signed his
key.  Am I confident that Jason's key is really D39DA0E3?  Absolutely.
Not only do I trust Douglas' signature, but Jason also signs his
email, so I see a ton of signatures coming from Jason all from key
D39DA0E3.  Still wouldn't sign it without meeting Jason in person.
Crazy, no doubt!
Indeed.  With trust issues it is very easy to paranoid oneself into
immobility.  The idea behind the GD is that some people are willing to
trade a (hopefully small) amount of security for a (hopefully large)
amount of usability.  The neat bit of design the PGP folks did in the
GD is that you can choose to get some of the usability features
without trading anything in security.  They left it up to the user
what tradeoff to make.

@_date: 2004-12-31 16:41:28
@_author: David Shaw 
@_subject: Global Directory signatures 
Very neat!
I'm curious about the details.  What keyserver protocol are you
planning to use to communicate with the outside world?  (http like the
current biglumber? hkp? ldap?)
You may well have addressed this already, but there are a couple of
hidden gotchas in a design that only allows the key owner to prevent
third-party updates.  Consider the case where Alice signs Baker's key,
and Baker stores this signed key in biglumber.  If Alice then revokes
that signature, Baker may well choose to keep the signature but
discard the revocation.  This makes a false link, and is an attack
against Alice and anyone who trusts Alice's signatures.
There are similar problems with designated revocations.  Baker has his
key stored in biglumber but it is compromised.  Alice is Baker's
designated revoker, and generates a revocation certificate for Baker
but cannot upload it because the false "Baker" won't allow her to.
A simple solution to all of this is to allow some modifications to
take place on keys without key owner approval: signature revocations
(only if the original signature exists on the key), key revocations
(anytime), and designated revocations (only from a designated
revoker).  Note that 'sensitive' designated revocations come with
their own designated revoker status.
Incidentally, I believe the GD handles these issues correctly, though
I'm not sure about designated revocations.  I know I discussed them
with the PGP folks when they were designing the GD.

@_date: 2004-02-04 00:08:43
@_author: David Shaw 
@_subject: --comment // multi-line? 
No, it violates the OpenPGP spec to have a comment that spans multiple
You can have more than one "comment" though.  In the 1.3.x GnuPG, you
can do:
  gpg --comment foo --comment bar --comment baz  etc.

@_date: 2004-02-04 00:24:14
@_author: David Shaw 
@_subject: What is the "small security glitch" mentioned in the FAQ? 
The glitch was fixed in the standard a while ago, and both GnuPG and
PGP have the fix.  This is the MDC function which is intended to
prevent message manipulation.  If you've ever decrypted a message and
saw something like "WARNING: message was not integrity protected",
that's what it is talking about.

@_date: 2004-02-04 16:38:28
@_author: David Shaw 
@_subject: Bug: Unusable key 
The key may expire in 2012, but the subkey expired yesterday:
pub  1024D/AF351431  created: 2002-02-04 expires: 2012-02-04
sub  4096g/E3889A13  created: 2002-02-03 expires: 2004-02-03
                                                  ^^^^^^^^^^

@_date: 2004-02-04 18:54:47
@_author: David Shaw 
@_subject: Keyserver.net 
Don't use search.keyserver.net.  It doesn't work.  It never worked.
It hasn't shown any indication of working at some point in the future.

@_date: 2004-02-05 13:54:36
@_author: David Shaw 
@_subject: restoring ~/.gnupg folder 
gpg --export your_secret_key > /mnt/floppy/my_secret_key.gpg
chmod 700 ~/.gnupg
chmod 600 ~/.gnupg/*

@_date: 2004-02-05 16:36:09
@_author: David Shaw 
@_subject: Bug: Unusable key 
This is a little difficult since the reason is not always easy to say
in a simple error message.  For example, given a key with two subkeys,
one is expired, and one is revoked.  What should the error message

@_date: 2004-02-05 16:47:37
@_author: David Shaw 
@_subject: Keyserver.net 
Indeed.  subkeys.pgp.net does work, and is in fact the default
keyserver in new installations of GnuPG.

@_date: 2004-02-05 18:12:49
@_author: David Shaw 
@_subject: Bug: Unusable key 
Unless I misunderstand your suggestion, that would mean that in cases
where a user has a collection of old expired subkeys (and the one
current one), there will be a whole lot of output about "subkey xxxxx
expired" every time the key was used.  Messy.
Even if the error list was only printed if there were no usable
(sub)keys at all, over time the list would just get longer and longer.

@_date: 2004-02-05 22:14:02
@_author: David Shaw 
@_subject: Bug: Unusable key 
Which key was unusable?  In the example, there were two subkeys.

@_date: 2004-02-06 02:41:42
@_author: David Shaw 
@_subject: Bug: Unusable key 
Hash: SHA1
Yes.  One of the main advantages to subkeys is the ability to keep
making more of them without needing a whole new key (which then has to
be re-signed, etc).
The current error message is:
  gpg: username: skipped: unusable public key
I don't want it to appear that I'm rejecting any change here.  I'm
not.  It's just that there are so many different reasons a key can
become unusable (no encryption capability at all, revoked or expired
subkeys in various combinations, etc) that it is difficult to have an
error message here that is both truthful and concise.

@_date: 2004-02-06 05:11:10
@_author: David Shaw 
@_subject: copy GNUPG keys for user from one box to another 
Where did you read that?  --export doesn't do private keys at all.
That's what --export-secret-keys is for.

@_date: 2004-02-06 06:05:32
@_author: David Shaw 
@_subject: Bug: Unusable key 
Where does it end?
I think that's more confusing than helpful.  "such-and-such skipped:
the most recent subkey was revoked or expired".  If I saw an error
message like that I'd wonder why the other subkeys weren't usable.
Worse, I'd start to think that only the most recent subkey was
relevant, as stated by the error message, which isn't true.  Worse
again, there doesn't have to be SUBkeys involved in the first place.
V3 keys don't have them, and V4 keys can be sign+encrypt.
The current error message says, perhaps over-tersely, that the user
asked to encrypt to key such-and-such.  Key such-and-such (including
any and all subkeys) couldn't do it.  Thus, "unusable public key".
"key does not support encryption" - better, but not completely good
because clearly it did support encryption before the subkey expired.
"key does not currently support encryption" - sure, but why?  It did
support it yesterday.
"no currently valid encryption capability" ?
"no unexpired or unrevoked encryption capability" ?
"all encryption capability is missing, expired, or revoked" ?  Ugh.
"no usable encryption capability" ?
"not capable of encryption" ?
These are really just trading something terse and mostly unhelpful
(but true) for something else terse, mostly unhelpful, but true.
I'm not concerned about the successful case.  There is already a good
answer for that (say nothing).  I don't agree with the argument that
an error message doesn't matter because it isn't the common case.
Clearly, this one confuses people because this isn't the first time
it's come up on the list.  If it really didn't matter, then I may as
well leave it as "unusable public key".
If the user requested a particular subkey, I could show an error
saying "subkey XXXXXX: can't use it because it's not capable of
encryption" or "is expired", or "is revoked".  If the user asks to use
"the key" as a whole, then the unfortunate fact is that there are a
huge number of possible reasons why a given public key might be

@_date: 2004-02-06 14:50:47
@_author: David Shaw 
@_subject: Bug: Unusable key 
It's helpful, true, and less terse - it's also not the whole story.
True that the user can't use ... but our poor user also can't
use  (revoked a year ago)  (it expired a month
before ) and they don't understand WHY.  At the same time, by
not mentioning the other subkeys, the user wonders those other keyids
weren't mentioned.  Clearly they exist - he can use --list-keys and
see them!  What's going on here?
Sometimes giving more information leads to less clarity overall.
Not a huge number of subkeys - a huge number of reasons.  Take
Werner's key 621CC013 as a good example.  It has two expired subkeys,
one revoked subkey, and one good subkey.  Let's say that the good one
expired, so the reasons 621CC013 would become unusable for encryption
1) ADF6A6E1 is expired
2) B5A18FF4 is expired
3) B5A18FF4 is Elgamal type 20
4) B5A18FF4 is revoked
5) 23D2A63D is expired
6) 70E37CCD is expired
7) 621CC013 doesn't support encryption
 and  can be collapsed into one item since it was revoked before
it expired, so ditch   That leaves 5 reasons.
Date stamps are not really useful here since it's not a correctness
issue - it's a confused user issue.
No, you misunderstand my concern.  I have no problem at all in giving
a longer error message.  I don't believe that terse is good, nor do I
like the current error message (the fact that it comes up on this
mailing list every month is a pretty good indication that it's not
clear enough).  My concern is that a longer error message tell the
whole and complete story, which causes a counter-concern that the
message will be too large.
The problem here is that given the code in that particular area of
GnuPG, changing the error string is easy, but giving more information
is complex and touches a good number of other places in the code.
That is not something I want to do unless there is a really good
So - given that I want to have a better error message here, and given
that I have to dig into and make a number of changes in (for example)
the key retrieval functions to support giving a more informative error
messsage, I want the best possible bang for my buck.  I want the code
to be reusable, and I want a REALLY DARN GOOD error message ;)
The suggestion that I currently like the best, despite my concern
about what will happen as keys age and gain more subkeys, is to just
list each key and the reason why it wasn't accepted.  Using the
hypothetical expired key of Werner's:
gpg: unable to encrypt to subkey ADF6A6E1: expired 2002-11-01
gpg: unable to encrypt to subkey B5A18FF4: revoked 1999-11-12
gpg: unable to encrypt to subkey 23D2A63D: expired 2003-12-31
gpg: unable to encrypt to subkey 70E37CCD: expired 2004-02-06
That says everything, it's clear as a bell, and if that lists gets too
long over time... well, I'm willing to change things then to perhaps
list only the top 4.

@_date: 2004-02-06 16:30:40
@_author: David Shaw 
@_subject: MacOS X 10.3.2 (was Re: gnupg 1.2.4 compile error) 
10.3.2 is pretty new.  Has anyone else seen this problem?  It would be
a bug in gettext, rather than in GnuPG (not that that helps you in
getting GnuPG built).  For what it's worth, the gettext stub that
comes with GnuPG is version 0.12.1.
As a workaround, try building with "./configure --disable-nls". You
will lose the translations, however.

@_date: 2004-02-06 21:46:32
@_author: David Shaw 
@_subject: Bug: Unusable key 
I strongly disagree.  Human interface factors are pretty darn crucial
in general, and much more so for a security application.  GnuPG is not
supposed to be used solely by crypto fans.  Open source software has a
bad reputation for being written by geeks for geeks.  I believe in the
benefits of crypto, so that can't fly here.  I want as few barriers as
possible to people using it.
This is why GnuPG gives an error "encrypting a message in --pgp2 mode
requires the IDEA cipher" rather than "cipher 1 unavailable".
That's absurd.  There are certainly users who know how to type
--list-keys (which is the first example given in every single "how to
use GnuPG" document I've ever seen), but yet don't know that PART of a
key can expire without affecting the rest of the key.  How many people
on this list right now don't know that?
Pretty straightforward cost/benefit calculation.  The cost is
relatively high for this one given how the key selection code works.
If the benefit isn't, then it's not worth it.  Without that
calculation, then every feature that anyone wants, however ill
advised, goes into the code and the code becomes unreadable - and
unverifiable - spaghetti.  Spaghetti is not what you want to see in a
security application.
I ask a cost/benefit question of myself before making any change to
GnuPG.  To do otherwise would be irresponsible.  Generally, the
conversation is within my head and lasts a few minutes.
That doesn't mean that I'm willing to run the risk of stagnation
either.  There is a development branch of GnuPG (1.3.x) where the bar
for changes is set pretty darn low.  This will become GnuPG 1.4
Like I said before (and you snipped out), I think the benefit here
justifies the cost, but given the cost, I want a pretty darn good
benefit.  And if that means I need to think about 7 different ways to
do it, then I'm going to think about 7 different ways to do it before
picking the best one.  Usually that's a short process, when there are
no mailing lists involved.
Suggest an alternative, and say why it is better.  Format stuff can be
cheap to change, as I've already "invested" in the architecture to
allow users to customize formats to some degree.  Have you looked at
the format changes in 1.3.x?

@_date: 2004-02-06 22:05:22
@_author: David Shaw 
@_subject: Bug: Unusable key 
That does not cover all the cases.  Specifically, it doesn't cover the
case where there is no encryption key at all.
If we're talking about an error message change here, then it needs to
embody the concept "I did find the key, but the key isn't capable of
encryption - this might be because there is no encryption capability
in the first place, and it might be because there was encryption
capability in the past which is now revoked and/or expired."
The current message is "unusable public key".  Any other suggestions?

@_date: 2004-02-06 22:50:23
@_author: David Shaw 
@_subject: Bug: Unusable key 
Heh, I like that.  How about "unusable public key" ?  That pretty much
describes the problem ... ;)

@_date: 2004-02-06 23:37:09
@_author: David Shaw 
@_subject: Old format packet support 
The problem with the this encoding is that it is indeed indeterminate
length - there is no length encoded in the packet itself, so the
reader must infer from context (i.e. end of file, end of encapsulating
packet) what the end of the packet is.  2440 deprecates this format as
a SHOULD NOT.
GnuPG can understand this format, but in general does not generate it
except for compatibility reasons.  You can force it in some cases with
the --rfc1991 option, but not all packets make sense as indeterminate
What are you trying to do?

@_date: 2004-02-07 15:35:51
@_author: David Shaw 
@_subject: Old format packet support 
Hash: SHA1
Interesting project.  Take a look at the code in
compress.c:do_compressed() in GnuPG.  It's one of the places GnuPG
generates indeterminate packets.

@_date: 2004-02-08 02:37:23
@_author: David Shaw 
@_subject: Key strangeness 
Hash: SHA1
Something is fairly broken here, and I'm not quite sure what yet.  The
key is pretty certainly 7EDB7A47, but for some reason the keyserver
indexed it as 3A546EC2.  It seems possible, or even likely that the
keyid was 3A546EC2 at one point as the three self-sigs and the subkey
binding sig are from 3A546EC2.
All in all, I'm guessing corruption of the key, which can pretty
easily change the keyid to something else.  It could be a bug in
CryptoEx, but I'd think a bug that changes keyids would have been
noticed before now.  What does your correspondent say his keyid is?
None of this explains how the keyservers managed to index it correctly
as 3A546EC2, but serve up a key that hashes to 7EDB7A47.  I've cc'd
one of the keyserver development lists.  Yaron, any ideas?

@_date: 2004-02-08 15:58:42
@_author: David Shaw 
@_subject: [Sks-devel] Re: Key strangeness 
Last night, I requested key 0x3A546EC2 from sks.keyserver.penguin.de.
The armored key blob that the server sent turned out to be key
In short, if I request 0x7EDB7A47, I get 0x7EDB7A47.  If I request
0x3A546EC2, I still get 0x7EDB7A47.  The 0x7EDB7A47 I do get looks
like it has the self-sigs from 0x3A546EC2.
I just tried it again, with the same results from sks.dnsalias.net.
This is likely not a SKS-specific problem, as pgp.mit.edu (running
pksd) does the same thing.

@_date: 2004-02-08 16:12:47
@_author: David Shaw 
@_subject: [Sks-devel] Re: Key strangeness 
Recent update: some new valid self-sigs for and on 0x7EDB7A47 just
showed up on sks.dnsalias.net.  Requesting 0x3A546EC2 still brings up
0x7EDB7A47 though.

@_date: 2004-02-08 16:47:15
@_author: David Shaw 
@_subject: Key strangeness 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
A bug in his software (CryptoEx) would explain nearly everything
here.  Since CryptoEx naturally would be compatible with itself, it
would see the keyid as 3A546EC2.  It would fill in 3A546EC2 as the
issuer of signatures, and it would be able to verify its own
signatures so the key would be valid.
That theory doesn't explain why the keyservers indexed the key as
3A546EC2 though.  GnuPG, PGP 6 and 8, and my local copy of pksd all
agree the keyid is 7EDB7A47.

@_date: 2004-02-08 19:47:33
@_author: David Shaw 
@_subject: [Sks-devel] Re: Key strangeness 
vindex or index does not show the problem.  The actual keyblock
returned by SKS is the problem.  Try:
    Import that armored key into GnuPG or PGP, or even re-submit it to
SKS.  That key is 0x7EDB7A47.

@_date: 2004-02-08 21:00:43
@_author: David Shaw 
@_subject: [Sks-devel] Re: Key strangeness 
My guess is the same, but there are some other factors that are very
1) The problem is not SKS specific, and pgp.mit.edu (a pks
   installation) shows the same thing.
2) Downloading the "bad" key, and then re-submitting it to the
   keyserver results in the correct record - i.e. the keyserver is
   able to parse the key properly the second time around.
I'm vaguely wondering if the key was slightly corrupt - say, a badly
formatted MPI - and when the keyserver received it, it
re-canonicalized the MPI to make it correct, but still indexed it
under the bad key ID.  Could SKS do such a thing?

@_date: 2004-02-09 03:44:51
@_author: David Shaw 
@_subject: [Sks-devel] Re: Key strangeness 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Maybe.  It depends how the key is propagated.  Assuming my "normalized
key" theory is true (which has not been proven yet), then the question
becomes whether the key is propagated before or after the
normalization took place.  If before, then things make sense.  If
after, then my theory is likely shot, as a normalized key should have
appeared under the right keyid.
Unlikely.  The original key had self-sigs issued by the wrong keyid.
This strongly suggests a wrong - but internally consistent - program.

@_date: 2004-02-09 18:17:19
@_author: David Shaw 
@_subject: signing options 
-u or --local-user means: "use this key to sign with".
--default-key means: "use this key to sign with unless I'm using -u"
It means that you can do "-u foo --list-keys" without any harm.

@_date: 2004-02-09 18:21:20
@_author: David Shaw 
@_subject: trailing whitespace 
GnuPG does not behave differently on FreeBSD or Linux.  On all
platforms, there are no blank lines added or removed at the end of the
original text file when signing.  If you are using GnuPG via a mail
program, perhaps the mail program is doing some manipulation before
the text is passed to GnuPG to be signed.

@_date: 2004-02-09 19:44:20
@_author: David Shaw 
@_subject: Question about backdoors 
I assume you are referring to the "Additional Decryption Key".  GnuPG
does not have such a thing.
Usually "backdoor" refers to something hidden inserted into the code.
ADKs are not hidden, but are an advertised - and certainly
controversial - feature of PGP.

@_date: 2004-02-10 04:28:04
@_author: David Shaw 
@_subject: 10x compression factor 
Hash: SHA1
If they are compressing before they PGP, then they could be using
anything.  It's not really a PGP or GnuPG question.  There are many
different compression programs out there, using different algorithms,
and a 10x compression is not unheard of.
If they are compressing within PGP, then it's ZIP compression, as
that's the only compression algorithm that PGP supports.  GnuPG
supports it as well, so anything your client could do in PGP, you
could do in GnuPG.

@_date: 2004-02-10 14:32:27
@_author: David Shaw 
@_subject: Compression compatability [was Re: 10x compression factor] 
Hash: SHA1
This isn't what happens.  GnuPG treats having no compression
preferences as a preference for ZIP.  This is part of the OpenPGP
standard.  Thus, it will always use ZIP when encrypting to a PGP key,
and PGP has ZIP, of course.
There are occasional problems when someone generates a key in GnuPG
(thus having a "ZLIB ZIP" preference), then moves that key over to PGP
for use without updating their preferences.  Programs encrypting to
that key see the ZLIB preference and use it.
The problem here is actually in PGP, which should warn the user when
they import the key that they are advertising preferences that cannot
be honored.  The new OpenPGP draft standard recommends this.
Nevertheless, since PGP does not currently have the ability to rewrite
preferences, this has to be done on the GnuPG side.  It's a FAQ, in

@_date: 2004-02-10 17:18:31
@_author: David Shaw 
@_subject: Removing AES 
This is a "how do I use this blowtorch to turn this screw" sort of
question.  The underlying assumption is incorrect, so the request
(removing AES) won't solve the problem.
If you can post some details about what isn't working, and what
happens when you try, then we can likely help you.  Hundreds, if not
thousands, of people use GnuPG along with PGP 7 and 8 every day.
Be specific about what you did, and what you saw.

@_date: 2004-02-10 17:46:38
@_author: David Shaw 
@_subject: GPG Linux to GPG on XP 
I wonder if you are corrupting the file in transfer.  How are you
sending the file over from the Linux system to the XP box?  If it is
FTP, are you sure you are doing it in binary mode?

@_date: 2004-02-10 18:09:05
@_author: David Shaw 
@_subject: gnupg make fails on hpux 11.11 
This is a fairly common HPUX problem when there is a mismatch between
gcc's headers and the system headers.  It causes build problems with
anything using sockets.
See

@_date: 2004-02-10 18:29:14
@_author: David Shaw 
@_subject: Removing AES 
Interesting.  I've heard what I thought was every possible variation
on the "this product won't handle files from that product because of
suchandsuch preference" problem, and it's always turned out to be a
misunderstanding of the problem.  This might just be the first time
it's real.
That they cannot use GnuPG *or* PGP 8 generated keys is interesting.
PGP 7.0.1 does support AES (it was the first version to do so).  I
wonder if there is something else going on (are they using PGP 7.0.1
straight or via the SDK, etc).
Please do.  I'd be very interested to see what happens.

@_date: 2004-02-10 19:29:59
@_author: David Shaw 
@_subject: 10x compression factor 
If you want to talk about good compression ratios, remember that GnuPG
1.3 supports bzip2 compression.  A one gig file of spaces, just like
yours, using the highest compression level in GnuPG:
  ZIP:   1,043,671 (1028:1)
  ZLIB:  1,043,677 (1028:1)
  BZIP2: 833       (1289005:1)
So, bzip2 compresses 1 gigabyte to less than 1 kilobyte. :) Of course,
this is an really artificial situation (all spaces) that plays
directly into a major strength of bzip2, but it's amusing nonetheless.
Note that ZLIB actually does marginally worse in this situation than
ZIP, when under more common circumstances, it would do a good bit
Compression ratios like this make for decompression bombs...

@_date: 2004-02-10 19:39:37
@_author: David Shaw 
@_subject: Compression compatability [was Re: 10x compression factor] 
There are unfortunately many ways people can shoot themselves in the
foot with algorithm choices.  For example, the --compress-algo option
overrides the preferences and allows you do make a message that cannot
be understood by the recipient.
If GnuPG ever creates a ZLIB message when sending to a ZIP-only key,
that would be a bug.  I'd love to see a message like that, and what
settings were used to create it.

@_date: 2004-02-11 04:01:50
@_author: David Shaw 
@_subject: 10x compression factor 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
No, it's fine, and you can use it.  It's mostly included in 1.2.x to
smooth the way for 1.4 though, so it doesn't let you do things like
"--compress-algo bzip2".
The trick to add a "Z3" pref into your key is allowed as it is safe.
Using the preferences system, GnuPG won't use bzip2 unless all of the
recipients can handle it.

@_date: 2004-02-11 17:14:05
@_author: David Shaw 
@_subject: v4 rsa subkey peculiarity 
You said it yourself.  You have an encrypt and sign primary, and an
encrypt and sign subkey.  GnuPG will always try and use a subkey
rather than the primary, so since there is a subkey that can sign,
it's using it.
If you don't want this to happen, put a ! after the keyid.  You can
put this in the gpg.conf file if you like:
  default-key xxxxx!
  local-user xxxxx!

@_date: 2004-02-11 23:00:28
@_author: David Shaw 
@_subject: Storing keys under a different user... 
On Windows, yes.
  However, note that a stolen private key doesn't really help the
attacker.  The private keys are stored encrypted, using the same
ciphers that GnuPG or PGP uses to protect messages.
If your passphrase is good, the attacker can't get to the actual
secret key data even if he manages to steal the secret key file on
Even so, your basic suggestion of storing keyrings in a non-stealable
way is not a bad one (extra protection doesn't hurt here), but there
are stronger ways to accomplish the goal.  The SELinux people have the
notion of a file that cannot be read except by certain processes.  In
this case, it doesn't matter if the attacker can become root - they
still can't read the file.
No harm being in the US (I am).  You just have to jump through the
appropriate hoops.

@_date: 2004-02-12 00:30:36
@_author: David Shaw 
@_subject: v4 rsa subkey peculiarity 
Subkeys aren't intended primarily for encryption.  Subkeys are
intended (in GnuPG) primarily for everything.  GnuPG will always try
to use a subkey over the primary key, unless there isn't a subkey that
is usable, or the user requests something specific.

@_date: 2004-02-14 02:44:15
@_author: David Shaw 
@_subject: Standards? 
Hash: SHA1
Exactly.  One way of looking at OpenPGP is as a collection of
standards.  It uses (for example), PKCS, SHA1, RSA, DSA, etc. to make
X.509 can also be considered a collection of standards, but put
together in a different way than OpenPGP.

@_date: 2004-02-18 22:57:35
@_author: David Shaw 
@_subject: STDOUT & STDERR 
We should probably look at it for 1.4 though.  Atom, can you give an

@_date: 2004-02-21 20:53:43
@_author: David Shaw 
@_subject: Question about fingerprints and keys uploaded to keyservers 
We did.  keyserver.net is, in fact, horribly broken in many ways (this
particular problem is just the tip of the iceberg).  It's never worked
properly.  I mailed them about fixing it a few years ago, but all the
mail disappeared into a black hole, so I gave up.
What happens here, if you're curious, is that the broken software on
keyserver.net sees "V4 RSA" and calculates the fingerprint for "V3
RSA".  That's why it's 32 bits short (and wrong).
As always, the answer is subkeys.pgp.net.  It Just Works(tm).

@_date: 2004-02-21 23:26:27
@_author: David Shaw 
@_subject: Question about fingerprints and keys uploaded to keyservers 
Might be.  It happens every now and then that one server doesn't sync
for a bit.
Close enough.  I'd change the slogan to "It Just Works More Often Than
The Other Solutions", but it doesn't read quite as well. ;)
Maybe the synchronization was slow for a bit.  The SKS servers have
their own sync algorithm, and the PKS servers use email to sync.  (SKS
uses email to sync with PKS).  Either way, network connectivity is
needed (though the server must have had some connectivity to be able
to accept the key submission in the first place).
subkeys.pgp.net is made up of three machines in round robin rotation
(Jason's fixed PKS, and two SKS, if I recall).  Who knows which one
the original key submissionw as sent to and which one you hit when you
tried.  I keep meaning to show the IP address (under some high
verbosity level) that is used when making keyserver calls.

@_date: 2004-02-22 05:51:17
@_author: David Shaw 
@_subject: Question about fingerprints and keys uploaded to keyservers 
Yes.  Back in the day when nearly all keyservers had this bug, I
actually added a little feature to GnuPG to help deal with it.  The
code is still in there, so if you want, add
   keyserver-options refresh-add-fake-v3-keyids
to your gpg.conf file.
Then, when you do a --refresh-keys, it tries both the real and bogus
I wonder if the fact that PKS and the keyserver.net server have
several identical bugs says something about the genealogy of
keyserver.net.  PKS has been somewhat fixed at this point, but
keyserver.net hasn't.  I think(?) the PKS licence allows for this, but
it's interesting anyway.

@_date: 2004-02-22 19:29:41
@_author: David Shaw 
@_subject: Question about fingerprints and keys uploaded to keyservers 
No, I didn't try that hard.  I mailed them about the bug (and giving
them the fix) a few times back in 2002, but that's about it.  No
responses, so I just didn't bother to pursue it.  There is only one
Veridis keyserver out there, and if it's broken - well, eventually,
market forces are darwinian.  It's a shame they are running a broken
server on the good keyserver.net domain name, though.
I'm not too worried about security implications of a broken keyserver.
It's annoying, to be sure, but it's really a denial of service attack
rather than any exploitation of OpenPGP itself.
Frankly, I don't know how new users of OpenPGP discover keyserver.net
in the first place.  Google?  Some HOWTO document that mentions it?

@_date: 2004-02-23 20:36:31
@_author: David Shaw 
@_subject: What is the default symmetric cipher? 
You didn't say what version of GnuPG you were using, but unless you
have it set in your gpg.conf file to something else, it's probably
You can tell what cipher was used by decrypting the file with the -v
(for verbose) flag set.

@_date: 2004-02-23 21:08:25
@_author: David Shaw 
@_subject: current RFC 
The new RFC hasn't been published yet.  The latest draft is:

@_date: 2004-02-24 06:18:29
@_author: David Shaw 
@_subject: Bus error on Solaris 9 
I need some information.
1) What are the first two lines of your mpi/asm-syntax.h file?
2) Go into the g10 directory and run:
   gdb gpg
   Then enter (all one line):
   run --homedir checks --quiet --yes --no-permission-warning --import checks/pubdemo.asc
   You should get a bus error again.  When you do, enter "bt full" and
   send that information as well.

@_date: 2004-02-24 19:18:42
@_author: David Shaw 
@_subject: Bus error on Solaris 9 
Hmm.  Try this patch.  If the patch doesn't work, does building with
the --disable-asm configure option work?

@_date: 2004-02-24 22:23:04
@_author: David Shaw 
@_subject: SKS servers with e-mail 
I think Jason's server does.  It doesn't understand photo IDs though.
Sure, just do a HTTP GET and mail the results back.
Just replace the 0x99242560 with the keyid you want.

@_date: 2004-02-27 02:27:13
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.5 released (development) 
Hash: SHA1
The latest release from the development branch of GnuPG is ready for
public consumption.  This is a branch to create what will eventually
become GnuPG 1.4.  It will change with greater frequency than the
1.2.x "stable" branch, which will mainly be updated for bug fix
The more GnuPG-familiar user is encouraged try this release (and the
ones that will follow in the 1.3.x branch), and report back any
problems to gnupg-devel  In return, you get the latest code
with the latest features.
This release brings development fairly close to a good point for 1.4.
If there is something that you do not like here, be it a missing
feature, a UI choice, or, well, anything, now is the time to speak up.
Once 1.3.x becomes the new stable, large changes will be unlikely.
While we obviously cannot guarantee that every suggestion will be
included, they will all be looked at.
As always, note that while this code is stable enough for many uses,
it is still the development branch.  Mission-critical applications
should always use the 1.2.x stable branch.
The files are available From: ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.5.tar.gz (1.9M)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.5.tar.gz.sig
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.5.tar.bz2       (1.5M)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.5.tar.bz2.sig
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.4-1.3.5.diff.gz (323k)
MD5 checksums for the files are:
  e6b35d22f529ad8a625e46cdf224f1b0  gnupg-1.3.5.tar.gz
  c4b00adc6886cb2756124b3c46f3f677  gnupg-1.3.5.tar.bz2
  3074a3f469e22ad9d836a8fd909f1d8a  gnupg-1.3.4-1.3.5.diff.gz
Noteworthy changes in version 1.3.5 (2004-02-26)

@_date: 2004-02-27 16:53:27
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.5 released (development) 
Just in case it was lost in the standard release notice boilerplate:
Look at things.  Poke at things.  At the very least - especially if
you aren't running some flavor of Linux - build it on your platform
just to see if the self-tests work by doing a make check.
I'm currently leaning towards the idea that the show-long-keyids
option (really two different options, one for --list-keys, and one for
sig verification) feature is too complex and not complete to boot.
Tell me I'm right.  Tell me I'm wrong.  Most importantly, tell me
Incidentally, if anyone is in an environment that is using the "PGP
Universal" system, the new LDAP support should be able to interoperate
with its keyserver.  It works for me.  I'd love to hear from anyone
else who tries it.
Send comments to the list, though, and not directly to me.  Someone
may have a comment about your comment, and we'll all benefit.

@_date: 2004-02-28 19:33:27
@_author: David Shaw 
@_subject: Werner's key expired? Re: [Announce] GnuPG 1.3.5 released 
gpg --keyserver subkeys.pgp.net --refresh-keys 57548DCD

@_date: 2004-02-28 22:22:17
@_author: David Shaw 
@_subject: multiple self signatures 
Exactly again.
Exactly a third time, but note that if you ever refresh your key from
the keyserver, the extra sigs will come back.
Oops.  It'll be in 1.2.5.

@_date: 2004-02-28 22:26:52
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.5 released (development) 
Yes.  subkeys.pgp.net is three machines.  Two allow searching for
subkeys, and one doesn't.  This is a problem since subkeys.pgp.net is
supposed to be the one name that Just Works without needing pages of
documentation explaining which keyserver to use for what sort of key,
the program you're using, the phase of the moon, etc.

@_date: 2004-03-03 16:36:52
@_author: David Shaw 
@_subject: backup startegy for keyrings 
The pubring is backed up automatically.  Look in your ~/.gnupg
directory for "pubring.gpg~", which is the backup for "pubring.gpg".

@_date: 2004-01-01 18:12:32
@_author: David Shaw 
@_subject: trust problem 
No, this is one of the crucial details of trust signatures.  ALL of
the information is incorporated into the signature.  This is both good
and bad - it's nice that the signer can require the recipient to
interpret the information the way the signer wants.  It's perhaps less
than nice to say publically how much you trust people to sign keys
You do all of it in one step with "tsign".  tsign prompts you for all
the other information, including trust level, maxiumum number of hops,
and domain for the regexp.  tsign is only available in the 1.3.x

@_date: 2004-01-08 20:24:16
@_author: David Shaw 
@_subject: Need some help on OpenBSD 
We've had some build problems on x86 OpenBSD for a little while, and
I'd like to nail them down before the next release.  I'd appreciate it
if anyone with an x86 OpenBSD box who wants to help test would try
1) Download GnuPG 1.2.4 from 2) Replace the file config.links (in the mpi directory) with the new
   one attached to this mail.
3) Build normally with "./configure" and then "make check".
Does it work?  If so, great.  Mail me and tell me what version of
OpenBSD you built it with and which processor you have.  If it doesn't
work, mail me the same information and add what happened when the
build failed.
I believe this config.links should work correctly on all versions,
including the new OpenBSD 3.4 (much thanks to Richard Cattien for
testing thus far), but I want some more data points before I commit
this, so even if you have 3.3 or 3.4, feel free to re-test.

@_date: 2004-01-08 23:01:49
@_author: David Shaw 
@_subject: Fwd: GPG 
As it happens, I recently updated the documentation about this:
    Treat input files as text and store them in the OpenPGP canonical
    text form with standard "CRLF" line endings.  This also sets the
    necessary flags to inform the recipient that the encrypted or
    signed data is text and may need its line endings converted back
    to whatever the local system uses.  This option is useful when
    communicating between two platforms that have different line
    ending conventions (UNIX-like to Mac, Mac to Windows, etc).
    --no-textmode disables this option, and is the default.
Does that make it clearer?

@_date: 2004-01-09 17:11:06
@_author: David Shaw 
@_subject: gnupg API access 
Content-Description: signed data
Note that this interface is the same one that Enigmail and GPGME
uses.  It is a good general way to call GnuPG from another program.

@_date: 2004-01-09 22:35:38
@_author: David Shaw 
@_subject: I can't trust my own key? 
You have two choices:
1) gpg --edit-key cfcea5d0
  > trust
  > 5  ("Do you really want to do this?")
  > yes
  > quit
  This sets your key to ultimate trust, which basically means that it
  is your key (presumably you ultimately trust yourself!)
2) In the tools/ directory of GnuPG, there is a "convert-from-106"
   script.  Run it.  It does the same thing as  for all keys that
   are yours.

@_date: 2004-01-11 00:25:48
@_author: David Shaw 
@_subject: Removing signature from signed file 
Hash: SHA1
Just verify the signature.  (gpg file.tar.bz2.gpg).  That will give
you back the original file.tar.bz2 file.

@_date: 2004-01-14 00:42:55
@_author: David Shaw 
@_subject: Exporting key with photo ID 
pgp.mit.edu does not work with Photo IDs.  There is nothing you can
do except use a different keyserver.
This is something odd happening on the surfnet keyserver.  The server
is reporting that the key already exists, but isn't giving it to you
in the search.

@_date: 2004-01-14 15:37:49
@_author: David Shaw 
@_subject: Key appearing twice in keyring and upload to keyserver problem 
Hash: SHA1
No, if you have a keyring with a duplicate key, the merge happens on
import.  Since the keys are already there, the way to fix it is:
* export both keys to a file
* delete the keys on the keyring.
* import the keys again.  They will be merged.
Make a backup first, just in case.
You have more than one subkey.  Many keyservers do not accept keys
with multiple subkeys.  Try using hkp://subkeys.pgp.net as your

@_date: 2004-01-15 19:28:59
@_author: David Shaw 
@_subject: Which Key server? 
Yes, it's been thought about, and it's on the wishlist.  It's not
terribly high on the wishlist though ;)

@_date: 2004-01-27 16:21:38
@_author: David Shaw 
@_subject: struggling with potential keyid conflicts 
The part you are missing is that key IDs are not 32 bits long - they
are 64 bits long.  GnuPG displays only the 8 character (32 bit) key ID
for convenience, but internally it uses all 64 bits.  If you happen to
have a 32 bit collision, use the full 64 bits.
$ gpg --list-keys 0xdeadbeef
pub   1024D/DEADBEEF 2001-01-21 Preston Wilson uid                             Imad R. Faiad
sub   2048g/27D72110 2001-06-24
pub   2048R/DEADBEEF 1999-08-03 Imad R. Faiad
pub   1024R/DEADBEEF 1995-09-28 Prime Rib Lovers
Three keys with the same keyids?  Nope:
$ gpg --list-keys 0xF87A2B53DEADBEEF
pub   1024D/F87A2B53DEADBEEF 2001-01-21
uid                          Preston Wilson uid                          Imad R. Faiad
sub   2048g/A9452D5227D72110 2001-06-24
$ gpg --list-keys 0xA2061199DEADBEEF
pub   2048R/A2061199DEADBEEF 1999-08-03
uid                          Imad R. Faiad
$ gpg --list-keys 0xA69AB99CDEADBEEF pub   1024R/A69AB99CDEADBEEF 1995-09-28
uid                          Prime Rib Lovers
It is "difficult" (i.e. nearly impossible) to create a 64-bit keyid
collision with OpenPGP keys.  If the impossible happens, and there is
a 64-bit keyid collision, use the whole fingerprint:
gpg --list-keys 0x5BD18B6A42B9247EF79214B7F87A2B53DEADBEEF
Note that all this applies to OpenPGP (v4) keys.  The old PGP 2.x (v3)
keys have trivially forgeable keyids and fingerprints.  There is no
way to really secure against that, as it is inherent in the key
format.  Don't use them.

@_date: 2004-01-27 19:13:30
@_author: David Shaw 
@_subject: struggling with potential keyid conflicts 
It's the keyserver.  GnuPG gives the whole fingerprint to the
keyserver, and the keyserver handles it as it sees fit (which
generally means to truncate it to the lowest 32 bits).

@_date: 2004-01-27 23:10:07
@_author: David Shaw 
@_subject: struggling with potential keyid conflicts 
$ gpg --version
gpg (GnuPG) 1.3.5-cvs
There have been dozens of improvements between 1.2 and 1.3.  I forget
which version I'm running sometimes.
So, upgrade for that feature. ;)

@_date: 2004-01-28 00:41:55
@_author: David Shaw 
@_subject: Importance of time in pgp algorithms 
It depends.  How much skew are we talking about here?  If you skew
enough that the clock reads a time before your key was created or
something dramatic like that, you could get some errors.  See the
--ignore-time-conflict option if your clock is that bad.
It is secure.  As to whether you do it, it's your choice.  Some people
like two different keys in that situation.  Some people use the same

@_date: 2004-01-28 04:05:15
@_author: David Shaw 
@_subject: struggling with potential keyid conflicts 
Hash: SHA1
Yes.  The v3 fingerprint algorithm is flawed, and allows someone to
trivially duplicate someone elses fingerprint.  The giveaway is that
the forged key cannot have the same size as the real key.
This problem doesn't exist in v4 OpenPGP keys.

@_date: 2004-01-28 16:59:33
@_author: David Shaw 
@_subject: struggling with potential keyid conflicts 
Well, they don't really fit all implementations.  There are a whole
collection of little fussy details with v3 keys that cause large
interoperability problems.  It would be a kindness to all other users
of PGP and GnuPG if v3 key users would migrate to v4 keys.

@_date: 2004-01-28 20:20:36
@_author: David Shaw 
@_subject: How to change gnupg quotation behaviour? 
This is an Enigmail question.  GnuPG doesn't modify the message at

@_date: 2004-01-28 20:32:41
@_author: David Shaw 
@_subject: gpg.conf and groups 
You can't right now.  You must use one very long line.
When GnuPG 1.2.5 is released, you will be able to split across
multiple lines as:
group mygroup = foo bar baz
group mygroup = join these with the previous three

@_date: 2004-01-29 15:13:06
@_author: David Shaw 
@_subject: Cannot decrypt with PGP 7.0.3 using PnuPG private key. 
It isn't the algorithm.  PGP 7 uses a older method to protect the
secret key.  Do this:
 gpg --simple-sk-checksum --edit-key (yourkey)
 passwd (change the password - you can change it back to the same
 save
Now export the secret key again and import it into PGP.

@_date: 2004-01-30 23:50:46
@_author: David Shaw 
@_subject: local-key and key on keyserver seems to differ 
Yes.  The same key may often appear differently on different
keyservers.  It's harmless.

@_date: 2004-01-31 00:19:36
@_author: David Shaw 
@_subject: Signing a will with GnuPG 
Indeed.  Wills were explicitly left out of the "E-Sign" law passed
here a few years ago.

@_date: 2004-01-31 01:00:50
@_author: David Shaw 
@_subject: update between pgp.mit.edu and keyserver.net 
There are other reasons not to use keyserver.net.  It doesn't work
properly for many key types, and has a bug that prevents it from
working reliably for any key on Linux.  Just don't bother.

@_date: 2004-02-01 02:37:35
@_author: David Shaw 
@_subject: GPG Key Photo Removal 
Hash: SHA1
The problem is that older keyservers don't like photo IDs.  You have
a few possibilities as to how to proceed:
1) Use a better keyserver.  subkeys.pgp.net is a good choice.  Also
   try sks.dnsalias.net.
2) Send your key to the bad keyserver like this:
   gpg --keyserver-options no-include-attributes --send-key xxxxxxx
3) Delete the photo before sending the key to the bad keyserver.
   gpg --edit-key xxxxxx
   (select the number next to the photo ID)
   deluid
   save

@_date: 2004-02-01 02:40:03
@_author: David Shaw 
@_subject: GPG Key Photo Removal 
This is not true.  The mild error reports are due to a different sort
of keyserver corruption (subkeys).  There aren't many keyserver issues
with photo IDs - basically, it either works correctly, or it rejects
the key completely.  No gray area like subkeys.
That is out of date.  The updated specification supports user ID
revocation.  In GnuPG, use --edit-key and then "revuid" (the old
method of revoking the self-sig works as well).

@_date: 2004-02-01 02:48:33
@_author: David Shaw 
@_subject: Newbie: Choosing a user ID questions 
Hash: SHA1
Some people may refuse to sign it if the email address is invalid.
The main reason not to do it is that it will break many mail programs
that use the mail address to find a key.
There haven't been any cases of spam harvesters hitting keyservers,
probably because keyservers are not particularly interesting for a
spammer.  They have to do a lot of work to get addresses since the
keyservers don't let people download names in bulk, plus there very
few addresses there compared to what a spammer could find on the web.
It's just not worth it, when for the same effort a spammer could get
significantly more addresses by scraping the web.
Because it's not human readable.  It's machine readable ;)
The easiest way to see what keys are in an armored file is to simply
   gpg the_file
This will print out a human readable list of keys.

@_date: 2004-07-06 16:43:31
@_author: David Shaw 
@_subject: Duplicated User IDs arisen 
How is this different than just using a web server with keys on it?

@_date: 2004-07-06 16:44:43
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.6 released (development) 
I don't think so.  The quasi-1991 encoding was a leftover from the
GnuPG 0.x days.  It was nonstandard.
If you are unable to handle 2.6.3 messages, that may be a bug.  I'll
try and duplicate your problem here.
One more code path.  It was no longer needed since no program has
generated this type of file for years.

@_date: 2004-07-14 18:14:11
@_author: David Shaw 
@_subject: subkey types and preferences... 
For signing, DSA signs faster and RSA verifies a signature a lot
faster.  This is likely to be a non-issue in the real world.
If you like big keys, you'll probably prefer RSA which can have keys
larger than the DSA 1024-bit limit.  RSA can also use hashes of any
size, while DSA is limited to 160 bits.
DSA makes signatures that are small and non-annoying when attached to
a email message.  Big RSA keys make big, potentially annoying
signatures.  For me, that's a pretty good reason to use DSA if the
intent is to sign email.
For encryption, RSA is a lot faster to encrypt, but a little slower to
decrypt.  Again, this is a non-issue in the real world.
It's important to understand that while there are a collection of
minor points that make people like one pk algorithm over the other, in
the real world, it doesn't really matter that much.  Both algorithms
are vastly stronger than most people need.  Consider your attacker: if
your adversary can only climb 10 feet, having a 10,000 foot wall
around your house is just as good as a 10,005 foot wall.
Strictly if you want to.  Since there is no current way to encrypt to
a photo (that is, you can't say "gpg -r  --encrypt"),
preferences on a photo are currently a no-op.
Not exactly.  1.2.x and 1.3.x both set keyserver no-modify.  1.3.x
just shows you that it was set.
Generally speaking, the default set given via 'updpref' is the best
one for reasons of strength and compatibility.  People frequently
argue whether (for example) Twofish (256) is stronger than AES (256).
This is akin to the 10-foot wall example earlier.
If you want to advertise the ability to handle any cipher algorithm,
then it's fine to edit the list to put in whatever you like.
Hash algorithm preferences work the same way: if you want to encourage
people to use a particular hash when signing and encrypting to you,
then feel free to override the default (SHA-1).
Compression algorithms are purely your preference.

@_date: 2004-07-16 11:09:01
@_author: David Shaw 
@_subject: Fwd: using gnupg with a secure ldap (ldaps) keyserver 
GnuPG 1.3.6 (or the CVS version) can do ldaps, but it requires that
you have OpenLDAP set up to do ldaps.  OpenLDAP only does ldaps if you
have OpenSSL installed.

@_date: 2004-07-16 16:33:54
@_author: David Shaw 
@_subject: subkey types and preferences... 
no-ks-modify is a flag that asks keyservers to not accept changes to
your key (i.e. new signatures) unless they came from you.  No public
keyserver actually honors this flag, but it's part of the OpenPGP
standard so we allow setting it.
MDC is a modification detection code.  It protects messages against
certain modification attacks.

@_date: 2004-07-16 20:45:07
@_author: David Shaw 
@_subject: Fwd: using gnupg with a secure ldap (ldaps) keyserver 
It's not that GnuPG doesn't support it.  The keyserver itself doesn't
support ldaps.  GnuPG supports both ldaps and ldap using TLS.  The old
NAI keyserver supports neither.  If you want to communicate with the
NAI keyserver, you have to turn off ldaps or TLS.
I think there is some confusion here.  What exactly are you doing?
That is, where did you get this server?  What software is it running?
What do you get if you run:
  ldapsearch -h ldap.company.com -P2 -x -b "cn=pgpServerInfo" -s base cn=pgpServerInfo

@_date: 2004-07-16 21:42:03
@_author: David Shaw 
@_subject: Calculated trust and ownertrust of signatures 
I'm not quite sure I understand what you are trying to do.  There is
no ownertrust on signatures.

@_date: 2004-07-17 16:31:17
@_author: David Shaw 
@_subject: subkey types and preferences... 
Not specified.  The actual language in the standard says:
   the key holder requests that this key only be modified or
   updated by the key holder or an administrator of the key server.

@_date: 2004-07-20 23:42:03
@_author: David Shaw 
@_subject: gpg --edit-key when the key has many signatures 
How long is "quite a while"?
How many is a "number of signatures"?

@_date: 2004-07-21 13:32:02
@_author: David Shaw 
@_subject: gpg --edit-key when the key has many signatures 
Check something for me - you say there are 16 uids.  Do an --edit-key
on this key and count them.  Then do a --list-keys on this key and
again count the uids.  Do all the numbers match?
Also, is --list-keys really slow like --edit-key or is it fast?  If
--list-keys is fast, then check if --check-sigs on this key is slow.
There are two good possible reasons why this key is slow for you, and
I'm trying to nail down which one.

@_date: 2004-07-21 21:42:49
@_author: David Shaw 
@_subject: gpg --edit-key when the key has many signatures 
Yep.  You've been caught by a keyserver bug.  Sometimes keyservers
duplicate user IDs, signatures and all.  GnuPG knows about this bug,
so when you use --edit-key, it checks for duplicate user IDs and
collapses them into one.  This takes some time when there are a lot of
The answer is to --edit-key the key, wait until you get a prompt, and
then just enter "save".  This saves the key in the fixed state and now
--edit-key should be fast again.
However, note that the keyserver may well give you duplicate user IDs
again the next time you refresh the key...
Which keyserver do you use?

@_date: 2004-07-22 14:49:05
@_author: David Shaw 
@_subject: gpg --edit-key when the key has many signatures 
It might not be pgp.earth.li that did it - since keyservers sync with
each other, any brokenness often replicates quickly to other servers.
I'm not sure which particular keyserver software had (or has) this
The upcoming GnuPG 1.2.5 repairs keys automatically on import so you
don't need to do it when the key is edited.

@_date: 2004-07-23 19:03:59
@_author: David Shaw 
@_subject: Signatur type 0x30, Certification revocation signatures 
Yes.  Revoking a self-signature effectively revokes that user ID.
"revuid" and "revsig" on a self-signature are identical.

@_date: 2004-07-27 20:41:38
@_author: David Shaw 
@_subject: Fwd: using gnupg with a secure ldap (ldaps) keyserver 
I don't know.  I'm still trying to understand what you set up, and
using what LDAP schema from where.  Is this the PGP schema?  If so, it
should work with GnuPG as well.  If it isn't the PGP schema, then it
won't work no matter what you try.

@_date: 2004-07-27 23:40:35
@_author: David Shaw 
@_subject: Fwd: using gnupg with a secure ldap (ldaps) keyserver 
Interesting.  What happens if you do:
ldapsearch -h ldap.company.com -x -P3 -s base -b "" '(objectClass=*)' namingcontexts
Now that you made the certificate change on the server, did you try
using GnuPG again?
  gpg --keyserver ldap://ldap.company.com --search-keys whatever

@_date: 2004-07-28 00:42:55
@_author: David Shaw 
@_subject: Fwd: using gnupg with a secure ldap (ldaps) keyserver 
Yes, ignore that for now.  It's not the main problem.
No, it should be something like "o=PGP Keys", or at least including
the "PGP Keys" as part of the string.  It's pretty clear what is going
wrong, but it is not clear whether this is a problem with your LDAP
server setup or in gpgkeys_ldap.
I think you said this was set up by your IT dept for PGP users as
well.  Does it work with PGP?

@_date: 2004-07-28 01:46:23
@_author: David Shaw 
@_subject: Fwd: using gnupg with a secure ldap (ldaps) keyserver 
Check your slapd.conf file.  In the section for the pgp keys, there
should be a line that looks something like:
 suffix "ou=PGP Keys,dc=DOMAIN,dc=COM"
Does that exist?
Also, since it works from PGP on windows, can you check something: in
the PGP options dialog, click on the "servers" tab.  Double click on
the entry for your keyserver.  Is there anything in the "Base DN"

@_date: 2004-07-28 17:30:37
@_author: David Shaw 
@_subject: Fwd: using gnupg with a secure ldap (ldaps) keyserver 
Okay, this explains what is going on.  Both GnuPG and PGP use a LDAP
feature to autodetect where the keys are stored in a given server.
PGP has the ability to override the autodetection and force a
particular base DN to search in.  GnuPG only works with the
autodetected value.
I think the ability to override the base DN is useful, so I'll add
that to the next GnuPG release.
In the meantime, you can either arrange for the autodetection to work
properly (with 'suffix "ou=pgp keys,dc=company,dc=com"' in your
slapd.conf file), which would work for both PGP and GnuPG, or just
hardcode that as your base DN in gpgkeys_ldap.c until the next

@_date: 2004-06-08 13:47:11
@_author: David Shaw 
@_subject: Expired signature 
Delete the old signature before you try to sign the key again.

@_date: 2004-06-08 17:23:10
@_author: David Shaw 
@_subject: Expired signature 
Why is it safe to assume that?
Some people look at a key expiration date as a statement by you:
"After xxxx date, I do not vouch for my own key".  Given that, why on
earth should someone else vouch for it longer than you do?
This is an unresolvable debate since neither side is entirely wrong
and neither side is entirely right.  The current behavior in GnuPG is
the more conservative of the two choices, as is proper for a default.

@_date: 2004-06-09 21:13:51
@_author: David Shaw 
@_subject: PGP TO GPG key import problems 
Do "gpg --s2k-cipher-algo cast5 --edit-key xxxxxxx" and then "passwd"
to change the passphrase.  It doesn't matter what you change it to,
and can even change it to the same passphrase it has now.  This
reencrypts the key using CAST5 so you won't need IDEA any longer.
Yes.  The cipher you are having a problem with is the cipher that
encrypts your own secret key (to protect it in case it is stolen).
This has no connection with the ciphers that may be used to encrypt a

@_date: 2004-06-15 17:36:34
@_author: David Shaw 
@_subject: Secure deletion of files in a directory 
GnuPG does not have a file shredder.  It is not possible to write such
a thing to be portable to as many platforms at GnuPG runs on.
I'd look at "shred", but keep in mind the caveats the author gives in
the man page.

@_date: 2004-06-15 17:49:46
@_author: David Shaw 
@_subject: GNUPG and cryptoex 
Generally, GnuPG and cryptoex work together just fine.  Unfortunately,
you haven't given any details whatsoever as to what isn't working, so
it's impossible to help you.

@_date: 2004-06-15 20:01:08
@_author: David Shaw 
@_subject: Secure deletion of files in a directory 
SuSE is Linux.  GnuPG runs on Linux, various BSDs, Windows, RISCOS,
VMS, etc.  A shredder that works on one is likely to not work on
As I said, keep in mind the caveats the author gives.  He says that it
doesn't work with journaling filesystems.
You must decide your paranoia level.  If it is high enough, you
*don't* return hard drives once they have data on them.  Most people
are content with overwriting the data a few times.  Let's put the
problem into perspective : not many people are concerned with very
well funded adversaries using magnetic force microscopy.

@_date: 2004-06-15 23:54:24
@_author: David Shaw 
@_subject: Checksum in Secret Key Packet 
No, they're the same.  You might have turned the checksum off when you
generated the 1.2.4 key, but that's something you did, not a change in

@_date: 2004-06-15 23:55:41
@_author: David Shaw 
@_subject: Expired signature 
"gpg --edit-key (thekey)"
Enter the number corresponding to the user ID you want to delete the
signature from.
Say yes or no as desired.

@_date: 2004-06-16 02:01:47
@_author: David Shaw 
@_subject: Checksum in Secret Key Packet 
Yes, and starting with 1.0.7, GnuPG does not use it any longer.
However, if you specifically ask for it (via --simple-sk-checksum),
then you will get the old checksum.
If the example key you give was generated with GnuPG 1.0.7, then it
was due to --simple-sk-checksum.

@_date: 2004-06-17 05:01:07
@_author: David Shaw 
@_subject: Duplicated User IDs arisen 
I strongly disagree with this logic.  It's somewhat silly, as one of
the main points of public key cryptography is that the key
distribution channel does not have to be secure.  Who cares if a
keyserver is hacked up one side and down the other?  Unless it is
hacked to the point of not being able to give out a key, this does not
affect the security of OpenPGP.
Ask jharris.  He refuses to release the patches.  Not that it matters
terribly much - PKS is dead, victim of a changing world.

@_date: 2004-06-17 05:07:16
@_author: David Shaw 
@_subject: Duplicated User IDs arisen 
The only recommended server to use is subkeys.pgp.net.  Everything
else is guaranteed to cause problems in one way or another.  If not
today, then eventually.
Note that subkeys.pgp.net is the only HKP server given in the sample
gpg.conf that comes in the distribution.
Keyservers are a problem.  GnuPG 1.3.x has a number of different ways
to store keys for those who want to avoid the keyserver net.

@_date: 2004-06-17 05:22:05
@_author: David Shaw 
@_subject: how to transfer a secret key to another comp? 
Don't use --export-secret-subkey.  It has nothing to do with what you
are trying to do, and is the cause of the "secret key parts are not
available" error.
Delete the secret key on your laptop and re-import the gpg.sec file.
NOT the gpg.sub file, which will in no way work.

@_date: 2004-06-17 06:08:24
@_author: David Shaw 
@_subject: Duplicated User IDs arisen 
What do you plan on doing that SKS isn't already doing?  SKS fixed all
of the PKS bugs and corruptions, but given the parameters and
limitations of a public keyserver network, it seems that many of the
remaining problems are inherent in the architecture.

@_date: 2004-06-18 18:31:21
@_author: David Shaw 
@_subject: RSA keys for encryption and in general DSA/RSA/ElGamal-keypairs 
"gpg --edit-key (thekey)"
"key (n)" where n is the subkey you want to replace
"revkey" (follow the prompts, enter your passphrase, etc)
"addkey" (follow the prompts, select a new key type, enter your passphrase, etc)

@_date: 2004-06-18 20:45:28
@_author: David Shaw 
@_subject: Diffie Hellman V. ElGamal 
DH/DSS (PGP) == DSA and Elgamal (GnuPG).
For historical reasons, PGP calls Elgamal Diffie-Hellman, or DH.
Basically, when PGP 5 was being written, the patent holder on Diffie
Hellman told the company that if they called it DH instead of Elgamal,
they'd give them a free patent licence (there were still a few months
left in the patent).  Anyway, the patent has long since expired, but
the name stuck.

@_date: 2004-06-19 04:27:52
@_author: David Shaw 
@_subject: Deleting uids from a public key 
Keyservers are add-only.  Once a key is on the keyservers, you can't
delete a user ID.
What you can do is revoke (rather than delete) the user ID.  This
marks the user ID as unusable, and it will be ignored (but still
present) from then on out.  Just use "revuid" instead of "deluid".

@_date: 2004-06-21 20:03:00
@_author: David Shaw 
@_subject: Duplicated User IDs arisen 
But there is a crucial difference between a secure distribution
channel and a reliable distribution channel.  An attacker cannot
falsely revoke a key - the best he can do is try to prevent a
revocation from being distributed.
This is similar to a denial of service where the attacker tries to
prevent a user from getting a key in the first place, in hopes they
will send a message unencrypted.

@_date: 2004-06-22 20:47:48
@_author: David Shaw 
@_subject: Detection of sign-only vs. sign-and-encrypt keys 
gpg --with-colons --list-keys (thekey)
Look in the 11th field.  Capital S means the key can sign.  Capital E
means the key can encrypt.  Capital C means the key can certify
(i.e. sign other keys).

@_date: 2004-06-24 22:30:58
@_author: David Shaw 
@_subject: Detection of sign-only vs. sign-and-encrypt keys 
RSA encrypting keys are not deprecated.  GnuPG supports both RSA
signing and RSA encryption.  Try adding a new subkey onto a key.  Note
that RSA encryption is one of the options.

@_date: 2004-06-24 23:08:56
@_author: David Shaw 
@_subject: ###adding compression algorythm 
GnuPG 1.2.4 supports BZip2.  Most likely the GnuPG binary he is using
was not linked with the BZip2 DLL.  I know there is one out there, but
I have no idea how common it is.

@_date: 2004-03-06 19:28:16
@_author: David Shaw 
@_subject: The keyserver follies 
No, the fixed PKS one works for subkeys.  The problem was one of the
other ones, and it has been fixed now.
Still, the situation is not ideal.  Not all of the servers in
subkeys.pgp.net work with photo IDs... the quest for one keyserver
that JUST PLAIN WORKS without fussing over photo IDs and special
tricks for v3 RSA and hacks for subkeys seems never to end.
Maybe it's time for a "it-just-plain-works-damnit.pgp.net".

@_date: 2004-03-06 20:15:31
@_author: David Shaw 
@_subject: Removing AES 
I'm afraid I can't help then.  What this person you are working with
is claiming would be a pretty substantial breakdown of the OpenPGP
protocol or a bug in any of several different products.  Without any
evidence or supporting information whatsoever, there is nothing I can
Extraordinary claims require extraordinary evidence.

@_date: 2004-03-06 23:54:39
@_author: David Shaw 
@_subject: upgrade / install help 
Your version of the bzip2 libraries is old.  You can either upgrade
the bzip2 library, or build GnuPG with ./configure --without-bzip2

@_date: 2004-03-09 15:38:58
@_author: David Shaw 
@_subject: Different fingerprints on different servers - general problem? 
keyserver.net is broken in this and many other details.  Don't use it.

@_date: 2004-03-09 20:54:45
@_author: David Shaw 
@_subject: backup startegy for keyrings 
This is not true.  It should be generated before an import starts.
Thus, after the import completes, the pubring.gpg~ file is your
pubring from before the import.

@_date: 2004-03-09 22:09:48
@_author: David Shaw 
@_subject: Error Messages when decrypting a PGP encrypted document 
1.0.4 is over three years old.  The first thing to try is to upgrade
GnuPG to 1.2.4 and try reading your file again.

@_date: 2004-05-01 19:18:47
@_author: David Shaw 
@_subject: Is a .gnupg directory /w write access mandatory? 
It is documented.  The problem is that GnuPG is trying to save the
random number seed file.  If you don't want this to happen, use

@_date: 2004-05-02 02:55:22
@_author: David Shaw 
@_subject: Is a .gnupg directory /w write access mandatory? 
Oops.  You'll need both --no-random-seed-file and --lock-never in this

@_date: 2004-05-10 16:50:08
@_author: David Shaw 
@_subject: [OT?]: Keyserver / Subkeys / replicating selfsigs 
The keyserver is broken.  Most of them are.  Very few are fixed.
(snip a long list of replicated selfsigs)
Same reason as above.  The keyserver is broken.
You can't win.  Give up.
I don't mean this sarcastically, and I say this as someone who has
spent quite literally years fighting the keyserver battles.  You can't
win, and it's not worth trying any longer.  Too many servers are
broken in all sorts of ways, and the precious few servers that aren't
hopelessly broken still exchange data with the broken ones - thus
faithfully replicating the corrupted data even to non-broken servers.
As things stand today, this is one of the few workable solutions.
Without a massive re-thinking of how keyservers are operated, the game
is long since lost.
GnuPG 1.4 will have a way to tag keys with your favorite web server,
and --refresh-keys will fetch it from there.

@_date: 2004-05-10 20:57:54
@_author: David Shaw 
@_subject: [OT?]: Keyserver / Subkeys / replicating selfsigs 
The SKS servers are the few that I referred to that are fixed.  They
work properly, don't mangle keys, etc.
The problem with the SKS servers are not the SKS software itself, but
that operationally they are tied into the same keyserver network as
the broken servers.  Corruption spreads, even though it's likely not
from the SKS servers.
One current limitation of all keyservers (SKS included) is that they
do not have cryptographic support.  It's possible to forge a
revocation and send it to a keyserver and the keyserver will show the
key or subkey as revoked.  The key isn't really revoked, of course,
and importing it into GnuPG or PGP will show that.
You can use gpg --edit-key and the "delsig" command to remove any
signature you don't want.  However, if you refresh the key from the
server, the signatures will come back.

@_date: 2004-05-11 22:26:22
@_author: David Shaw 
@_subject: port 80 keyserver access, 
Or just
  iobuf_writestr(hd.fp_write,
                "Content-Type: application/x-www-form-urlencoded\r\n");
Note that GnuPG 1.2.5 (to be released soon) does this automatically.
Can we find a few more lists to cc this to?  Seriously, the people who
just got cc'd have no idea what we're talking about.

@_date: 2004-05-13 13:46:20
@_author: David Shaw 
@_subject: RSA and GPG 
This is an old PGP key that still protected using IDEA.  GnuPG doesn't
have IDEA for patent reasons, but there is an easy fix: change the
passphrase in PGP to nothing (that is, just hit enter when asked for
the new passphrase), then import the key to GnuPG.  Finally, set the
passphrase back to something you like within GnuPG.
Alternately, you can download the IDEA plugin for GnuPG, but please
first see:

@_date: 2004-05-13 13:48:46
@_author: David Shaw 
@_subject: key revocation 
Most keyservers do the same.  Of course, this is a metadata/display
issue only, and an illegal revocation won't be acted upon by GnuPG.

@_date: 2004-05-13 13:50:19
@_author: David Shaw 
@_subject: key revocation 
Both PGP and GnuPG allow designating a subkey as a revocation key.  In
such a case, a subkey can issue a revocation.

@_date: 2004-05-13 13:53:52
@_author: David Shaw 
@_subject: retrieving keys over a proxy 
The username/password syntax for proxies is not currently supported.
It's somewhere on the wish list, though.

@_date: 2004-05-13 19:30:58
@_author: David Shaw 
@_subject: Revocation of key with only secret portion 
You can generate a public key from your private key.  How did you
attempt it?
Try this:
  gpg --export-secret-key yourkey > secretkey.gpg
  gpgsplit --no-split --secret-to-public secretkey.gpg > publickey.gpg
  gpg --import publickey.gpg

@_date: 2004-05-14 14:41:31
@_author: David Shaw 
@_subject: trusting secret keys 
Hash: SHA1
Yes.  Since people can send secret keys around just as easily as they
send public keys, there is an attack that involves sending a secret
and public key together (which would then be ultimately trusted).
That allows someone to falsely influence your web of trust.
By not automatically giving ultimate trust to public keys when the
secret key is present, this attack is stopped.

@_date: 2004-05-15 01:24:15
@_author: David Shaw 
@_subject: ZIP decompression problem 
Please do a gpg --list-packets (yourfile) and tell us the results.

@_date: 2004-05-15 01:59:18
@_author: David Shaw 
@_subject: ZIP decompression problem 
Ok, there is your answer ;)
I don't recall this one, but it seems to have been resolved.

@_date: 2004-05-18 17:18:28
@_author: David Shaw 
@_subject: GnuPG 1.2.4 fetches revoked key 
There is no problem here.  By manipulating a primary key into a
subkey, you create two keys with the same keyid.  SKS is doing the
right thing in giving you both since it has no way to tell which one
you really want (in any event, the key material is identical).
On the GnuPG side, "include-revoked" and "include-disabled" only apply
to --search-keys.  When you use --recv-keys, any key that matches the
specified keyid is retrieved.

@_date: 2004-05-19 00:25:44
@_author: David Shaw 
@_subject: Signature Types 
That sentence is just to inform you that while 0x10, 0x11, 0x12, and
0x13 are all valid, the PGP program only generates 0x10 (though it
will accept any).

@_date: 2004-05-19 00:35:44
@_author: David Shaw 
@_subject: script failure & random seed file 
It looks like you are using the program prngd to generate randomness,
but prngd isn't running.  GnuPG needs a source of entropy, whether it
is native to the OS, prngd, egd, or otherwise.  It won't run with no
entropy source at all.

@_date: 2004-05-19 02:19:47
@_author: David Shaw 
@_subject: Signature Types 
Yes.  It even says so: "PGP program".  In general, 2440 says "OpenPGP"
when it means the protocol, and "PGP" when it means PGP the

@_date: 2004-05-19 16:58:15
@_author: David Shaw 
@_subject: how to transfer a secret key to another comp? 
You used --export-secret-subkey when exporting your secret key.  You
should have used --export-secret-key

@_date: 2004-05-20 00:13:12
@_author: David Shaw 
@_subject: script failure & random seed file 
It depends on how GnuPG was built.  It's possible to build a gpg
binary that has support for all random gatherers, but there is no way
for me to tell how your gpg binary was built.
No.  The random_seed file is generated at run time, and contains a
seed to initialize the random pool for the next run.

@_date: 2004-05-22 02:20:21
@_author: David Shaw 
@_subject: wiping files 
No.  This is not possible to do portably, and GnuPG needs to run on
dozens of platforms.
That said, see:
      It's not nearly as easy it might seem to wipe a file.

@_date: 2004-05-22 02:30:27
@_author: David Shaw 
@_subject: revoked key - was: Re: key-signing for pseudonyms 
There is an interesting attack against signing subkeys where the
attacker adopts a signing subkey from someone elses key.  As you say,
they cannot issue signatures from this subkey, but the neat bit is
that they can believably claim that documents that you have signed
were in fact signed by them.  Lacking out of band means of
verification, there is no way for a user verifying the signature to
know who really made the signature.
This is fixed in the updated OpenPGP draft, and GnuPG will have the
fix as soon as it is standardized.  (Actually, it already has the fix,
but it's disabled).

@_date: 2004-05-22 05:25:56
@_author: David Shaw 
@_subject: revoked key - was: Re: key-signing for pseudonyms 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Exactly, yes.
Currently, the main key signs all subkeys.  The fix is that signing
subkeys sign the main key as well.  Since an attacker who "steals" the
subkey cannot issue this back-signature, it is very obvious that the
attacker key is fraudulent.

@_date: 2004-05-22 16:20:12
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.6 released (development) 
Hash: SHA1
The latest release from the development branch of GnuPG is ready for
public consumption.  This is a branch to create what will eventually
become GnuPG 1.4.  It will change with greater frequency than the
1.2.x "stable" branch, which will mainly be updated for bug fix
The more GnuPG-familiar user is encouraged try this release (and the
ones that will follow in the 1.3.x branch), and report back any
problems to gnupg-devel  In return, you get the latest code
with the latest features.
This release brings development even closer to a good point for 1.4.
If there is something that you do not like here, be it a missing
feature, a UI choice, or, well, anything, now is the time to speak up.
Once 1.3.x becomes the new stable, large changes will be unlikely.
While we obviously cannot guarantee that every suggestion will be
included, they will all be looked at.
As always, note that while this code is stable enough for many uses,
it is still the development branch.  Mission-critical applications
should use the 1.2.x stable branch.
The files are available from:
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.6.tar.gz        (1.9M)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.6.tar.gz.sig
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.6.tar.bz2       (1.5M)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.6.tar.bz2.sig
or as a patch against the 1.3.5 source:
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.5-1.3.6.diff.gz (193k)
MD5 checksums for the files are:
  931f67b4c261349f613c531c00e8f068  gnupg-1.3.6.tar.gz
  886764469a51845cb84cece3e8a6ccf1  gnupg-1.3.6.tar.gz.sig
  36d1291322a277ec391fdc0950a56bb9  gnupg-1.3.6.tar.bz2
  aa009ee54efec31ba1f4d304de3b3f06  gnupg-1.3.6.tar.bz2.sig
  a1fc4269789909ea17f2d6965ea7b4dd  gnupg-1.3.5-1.3.6.diff.gz
Noteworthy changes in version 1.3.6 (2004-05-22)

@_date: 2004-05-22 22:57:09
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.6 released (development) 
Hash: SHA1
Yes.  The preferred keyserver is set on the self-signature (like the
other preferences) and so needs the secret key.  You don't want any
random person to be able to set your preferred keyserver.

@_date: 2004-05-22 22:59:17
@_author: David Shaw 
@_subject: revoked key - was: Re: key-signing for pseudonyms 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
There is little point in doing it with encryption-only subkeys since a
stolen encryption subkey does not allow the attacker any benefit.  If
someone encrypts a message to the stolen key, the attacker can't read

@_date: 2004-05-23 06:26:21
@_author: David Shaw 
@_subject: revoked key - was: Re: key-signing for pseudonyms 
These are two different attacks.  The subkey attack allows Mallet to
verify Alice's signatures in such a way that there is no way to tell
if Mallet or Alice made the signature.  This is a technical flaw in
the protocol.
What you are talking about is an identity problem.  The fact that
Mallet could get signatures on Alice's key is a social problem.
People who sign keys without checking what they sign are not very
responsible signers.  The web of trust - in theory - deals with these
people by gradually removing their trust.
That method is very close to being correct, but not completely correct
for OpenPGP keys (it's fine for PGP 2.x keys).  For OpenPGP keys, it
is slightly better to issue a random challenge and have the key owner
prove their ownership of the key by signing your challenge.
Remember that in OpenPGP, when you "sign a key" you are really signing
the primary key (i.e. the signing key) plus the user ID.  There is no
guarantee that a user either has a encryption subkey or has the
capability to use an existing encryption subkey.  Best to prove the
item that you are actually signing.
The fix is fairly simple conceptually.  Just have the signing subkey
issue a signature on the primary key.  Mallet could not issue such a
signature.  It does not address the attack you mention.  That attack
is a social problem, and is thus resistant to technical solution.

@_date: 2004-05-23 16:19:30
@_author: David Shaw 
@_subject: key-signing and stolen subkeys 
Hash: SHA1
Not if the person is issuing the challenge properly.  Challenges must
be random.  When someone challenges Mallory to prove he can issue
signatures from Alices key, the challenge string will not match the
challenge that Alice signed.

@_date: 2004-05-23 17:51:19
@_author: David Shaw 
@_subject: key-signing and stolen subkeys 
Mallory doesn't issue the challenge.  The person who Mallory wants to
sign his or Alice's key issues the challenge.
A challenge is of no use to someone else since Mallory doesn't get to
issue it in the first place.

@_date: 2004-05-23 17:55:28
@_author: David Shaw 
@_subject: revoked key - was: Re: key-signing for pseudonyms 
A person signing a key (certifying it) is saying, in effect, "I vouch
that this public key and this user ID are bound together."  That is,
that the entity described in the user ID is the owner (for some value
of "own") of the public key in question.
The social problem is that many people don't bother to actually read
what the user ID says before making this statement.  If I am going to
vouch for a binding, I'm going to make reasonably sure that the name
in the user ID is actually the name of the person, and I'm going to
make reasonably sure that the email address in the user ID actually
reaches the person.

@_date: 2004-05-24 00:09:38
@_author: David Shaw 
@_subject: key-signing and stolen subkeys 
Work a signing scenario through and you will see your mistake.  He
can't prove anything because ** he does not issue the challenge **.
Let me restate your argument:
   Alice, Mallory, and Baker attend a key signing party.
   Mallory sends a challenge to Alice and Baker.  Because he's trying
   to do something sneaky, he uses the same challenge for both.
   Alice signs Mallory's challenge.
   Baker signs Mallory's challenge.
Now Mallory has the same challenge signed by both Alice and Baker.  So
what?  He can't give it to Baker to persuade Baker to sign anything
since BAKER issues challenges for BAKER.  He can't give it to Alice to
persuade Alice to sign anything since ALICE issues challenges for
ALICE.  The person requesting proof always issues the challenge, or
there is no point in challenging.
If I was going to sign your key, I would issue YOU a challenge.  Not
vice versa, since there is no point in you issuing a challenge to me.
I don't need to prove key ownership, but you do.

@_date: 2004-05-24 16:26:01
@_author: David Shaw 
@_subject: proving subkey ownership - was: Re: key-signing and stolen 
The primary key.  When you make a key signature, you sign the primary
key and the user ID.  Thus, that's the key that needs to be proved to
There is no point in challenging signing subkeys.

@_date: 2004-05-24 16:51:03
@_author: David Shaw 
@_subject: Newbie needs help: any *detailed* documentation on gpg syntax? 
There is not much to say.  When making a notation or a policy URL you
can use several %-escapes in the string.  The %-escapes are expanded
when the string is used:
%k   the keyid of the key you are signing
%K   the long keyid of the key you are signing
%f   the fingerprint of the key you are signing
%s   the keyid of the key making the signature
%S   the long keyid of the key making the signature
%g   the fingerprint of the key making the signature
%p   the primary key fingerprint of the key making the signature
%%   is "%".
For example, if you had a cert-policy-url of:
    And signed key 99242560 with key 12345678, the policy URL would be:

@_date: 2004-05-24 22:53:43
@_author: David Shaw 
@_subject: Failed to build gnupg-1.2.4 on Windows with Cygwin and gcc 3.3.1 
Good point.  Does this patch (to "configure") work as well?
--- configure~	Mon May 24 16:50:58 2004
+++ configure	Mon May 24 16:52:05 2004
 -4391,6 +4391,7          have_dosish_system=yes
         try_gettext="no"
+        LDAPLIBS="-lwldap32"
         ;;
     i?86-emx-os2 | i?86-*-os2*emx )
         # OS/2 with the EMX environment

@_date: 2004-05-25 02:11:15
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.6 released (development) 
Seems to be a bug.  What happens if you add "--s2k-digest-algo md5" to
the command line when decryption a 2.6.3ia convential file?

@_date: 2004-05-28 10:02:26
@_author: David Shaw 
@_subject: Quasi-1991 encoding 
It's related, but not the same thing.  Indeterminate length encoding
means "I don't know how long it is".  Partial length encoding means "I
know how long the next little bit is, repeat.".

@_date: 2004-05-28 10:02:29
@_author: David Shaw 
@_subject: key-signing and stolen subkeys 
Exactly.  There is no need to hypothesize complicated ways for Alice
to make a mistake.  If we're starting with the assumption that she
doesn't know what she is doing, just hypothesize that Mallory asks
Alice for her passphrase and key and Alice complies.  Done. :)

@_date: 2004-06-05 11:13:45
@_author: David Shaw 
@_subject: Charset conversion during encryption 
Also true.  UTF-8 test in OpenPGP is historically a little weird.  No
program did it, and then the standard came along and required it.  So
everyone basically ignored the standard on that point.  The upcoming
revision to the standard has a fix for this.
Yep.  GnuPG is adding a  to each of those es for --textmode.
Note that when you decrypt the message, it changes the  into
whatever is correct for the local platform.  On Unix that means back
to .  On Win32, it leaves it as .

@_date: 2004-06-05 11:14:17
@_author: David Shaw 
@_subject: Self-sigs with trusted key 
That's now how trust works.  You can't sign your own key to make it
valid.  Neither can Werner ;)
If you think about it, this makes sense.  If this wasn't true, then
there would be no point in having different validity levels on
different user IDs since all user IDs would become as trusted as the
key as a whole.

@_date: 2004-06-05 11:14:40
@_author: David Shaw 
@_subject: Self-sigs with trusted key 
No, this is not correct.  Only user IDs that you have a signature path
to are valid.  It is not true to say that if the key as a whole is
valid that the user IDs are valid as well.  Trust does not 'flow' in
that direction.
This is a mistake in the man page.  I'll fix it.  In 1.3.x, the
default value is 2.

@_date: 2004-11-09 23:11:55
@_author: David Shaw 
@_subject: Question - after decryption, carriage-control oddness? 
The messages are being sent as binary, not as text, so there is no way
for the recipient to canonicalize line endings (LF->CR->CRLF->etc).
You need "--textmode" in your GnuPG command line.

@_date: 2004-11-16 04:32:29
@_author: David Shaw 
@_subject: detecting armor or text 
This is not a meaningful question.  A message can be text or binary,
and armored or not.  Or any combination.  There aren't three
possibilities, there are four:
Armored text
Armored binary
Unarmored text
Unarmored binary
To tell an armored message from an unarmored one, just look at the
first byte.  If it has the high bit (0x80) set, it is not armored.
To tell a binary message from a text one, there is a PLAINTEXT status
tag in 1.3.x.  The first argument will be 62 for binary, 74 for text,
and 75 for UTF-8 text.

@_date: 2004-11-16 04:36:18
@_author: David Shaw 
@_subject: w32 installation paths 
I wonder why.  The 1.3.x binary actually has less code than the 1.2.x
one since there is no keyserver stuff and the Elgamal signing code was
Perhaps the bzip2 library?

@_date: 2004-11-19 14:01:42
@_author: David Shaw 
@_subject: Determining algorithm to be used? 
Not necesssarily.  The algorithm picker works like this:
1) Take the union of all preferences from all recipient keys.  This
   rules out any algorithm that isn't supported by all recipients.
   Note that all recipients understand 3DES, regardless of what the
   preferences say.
2) The personal-cipher-preferences list gets to be the "tie breaker".
   Whatever this lists first is the algorithm that is used, so long as
   it is still in the union (i.e. that all the keys support it).  If
   there are no personal-cipher-preferences set, then the last key is
   used as the tie breaker.
You never want to use --cipher-algo with public key encryption.  It's
only safe to use with --symmetric.  The reason why is simple: the
above system to choose algorithms to use is safe - it will never pick
an algorithm that will result in an unusable message by one of the
recipients.  If you use --cipher-algo you override this safety net and
force the use of an algorithm that not all of your recipients can
The bottom line, if you want to use AES256, is to put this:
  personal-cipher-preferences aes256
in your gpg.conf file.  That will use AES256 whenever possible, but
will never use it if a recipient cannot handle it.
Note that personal-cipher-preferences is a GnuPG 1.4 feature.

@_date: 2004-11-19 17:13:28
@_author: David Shaw 
@_subject: GnuPG and Proxy 
It depends on what you mean by "full proxy support" and "didn't work".

@_date: 2004-11-22 04:23:38
@_author: David Shaw 
@_subject: Determining algorithm to be used? 
Yes, this is a problem.  Your friend just needs to do "gpg --edit-key
xxxx updpref", and the preferences will be updated properly for his
new environment.  Without that, he's advertising the wrong preferences
and will have all sorts of problems.  GnuPG 1.4 actually does this on
key import automatically, so hopefully this will become less of a
problem in the future.

@_date: 2004-11-25 01:13:23
@_author: David Shaw 
@_subject: Export the smallest possible version of a public key 
Restoring a public key from a private key has nothing to do with what
you are asking.  It's not that it is more complicated or more
simple... it's just unrelated to the problem.
There is no feature in GnuPG that does what you want.  It's asked for
often enough that if I have a few minutes this weekend, I'll probably
do it for 1.4.  It's very simple.
In the meantime, the method you are using is fine.

@_date: 2004-11-25 19:33:01
@_author: David Shaw 
@_subject: Access to key servers through athenticating proxy server 
The upcoming GnuPG 1.4 supports username/password authentication for
proxies.  You might download the latest 1.3.x release and give it a

@_date: 2004-11-26 20:23:05
@_author: David Shaw 
@_subject: Resetting expiration of subkey 
You have to specify the key you want to remove the expiration date
from.  If you don't specify, you are removing the expiration from the
key as a whole.  Use "key 1" (or "key 2", etc) in the --edit-key menu
before using "expire".

@_date: 2004-11-27 22:40:56
@_author: David Shaw 
@_subject: RfC 2440 Signature Types and Web Of Trust 
That's all true.  Remember that the OpenPGP is (mostly) a message
format, and as such does not define the trust model to use.  The
classic PGP web of trust is actually not specfied in any standard
For historical reasons, the web of trust never used the 0x11-0x13
signature types (except to treat them as identical to 0x10).
Yes.  You can use the --min-cert-level option which allows you to
ignore certain signature types.  For example, a --min-cert-level
option of 2 means that 0x11 signatures are ignored.  GnuPG 1.4
actually defaults to this.

@_date: 2004-11-28 02:16:34
@_author: David Shaw 
@_subject: GnuPG versions... 
GnuPG 1.3.x are the development releases building up to GnuPG 1.4.
They are available from:
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg

@_date: 2004-11-30 21:47:27
@_author: David Shaw 
@_subject: Public key server doesn't accept photos. 
Use "--keyserver-options no-include-attributes" for this.
--export-options only applies to exporting to a file, not sending to a

@_date: 2004-10-02 16:04:48
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.90 released (development) 
The latest release from the development branch of GnuPG is ready for
public consumption.  This is a branch to create what will very soon
become GnuPG 1.4.  As the version jump from 1.3.6 to 1.3.90 indicates,
the 1.4 release is expected soon.  We encourage people to try this
development release and report any feedback or problems to
As always, note that while this code is stable enough for many uses,
it is still the development branch.  Mission-critical applications
should use the 1.2.x stable branch.
The files are available from:
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.90.tar.gz       (3.6M)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.90.tar.gz.sig
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.90.tar.bz2      (2.5M)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.90.tar.bz2.sig
MD5 checksums for the files are:
  c3f1a4b5134ad15aae5f93897c8294fa  gnupg-1.3.90.tar.bz2
  767cf77145ea4ce0df3b2ca6e86ce0a9  gnupg-1.3.90.tar.bz2.sig
  e3f8d36309bd63f05bae3b7371bcb994  gnupg-1.3.90.tar.gz
  32a4376ae5a7a5b548bacd4d3a14816a  gnupg-1.3.90.tar.gz.sig
Noteworthy changes in version 1.3.90 (2004-10-01)
    * Readline support at all prompts is now available if the systems
      provides a readline library.  The build time option
      --without-readline may be used to disable this feature.
    * Support for the OpenPGP smartcard is now enabled by default.
      Use the option --disable-card-support to build without support
      for smartcards.
    * New command "addcardkey" in the key edit menu to add subkeys to
      a smartcard. New command "keytocard" to transfer a key to a
      smartcard.
      The serial number of the card is show in secret key listings.
    * -K may now be used as an alias for --list-secret-keys.
    * HTTP Basic authentication is now supported for all HKP and HTTP
      keyserver functions, either through a proxy or via direct
      access.
 The GnuPG team (David, Stefan, Timo and Werner)
Gnupg-announce mailing list

@_date: 2004-10-03 01:45:38
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.90 released (development) 
This is an autoconf thing, not a GnuPG thing.  Configure scripts allow
any options, legal or not.

@_date: 2004-10-04 03:15:34
@_author: David Shaw 
@_subject: updpref problem 
Skipped content of type multipart/mixed-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 251 bytes
Desc: not available
Url : /pipermail/attachments/20041003/5cc9a065/attachment-0001.bin

@_date: 2004-10-05 22:05:18
@_author: David Shaw 
@_subject: Encrypting / decrypting without importing keys? 
If you want to specify which keyring to import to in a multi-keyring
setup, specify the special one with "--primary-keyring".

@_date: 2004-10-05 22:25:16
@_author: David Shaw 
@_subject: Implications of using insecure memory 
Exactly.  This is a very important point, but frequently lost in the
discussion about secure memory in general, and Windows in particular.
Sure, secure memory/running on a secure OS/inside a Faraday
cage/disconnected from the network/etc is potentially safer, but it
would be foolish to let the lack of these things stop you from using
encryption at all.  Just understand the limitations of what you are
doing.  There is a lot of benefit that can be derived from encryption,
even if you are doing it on Windows.

@_date: 2004-10-06 20:14:14
@_author: David Shaw 
@_subject: Encrypting / decrypting without importing keys? 
It's a CRC24, and you can tell it is there because it's always the
last line, and it begins with an '=' sign.  However, the CRC24
checksum is optional according to the standard (though both GnuPG and
PGP always include it).
RFC-2440 defines the format for OpenPGP, including the various details
of armoring (which as you noticed is essentially base64).

@_date: 2004-10-07 04:43:51
@_author: David Shaw 
@_subject: GPG compatibility to PGP 6.0 or above 
No, you are in luck.  Generally, PGP 6 does not require IDEA.  In
fact, if you just generate a key with GnuPG, you should be able to
give that key to your vendor and it will "just plain work".
However, note the word "generally" in the above paragraph.  PGP 6 does
not follow the OpenPGP specification very closely, and so there is
sometimes strange non-standard behavior.
GnuPG can work with IDEA, though it does not ship with IDEA included
for the obvious reasons.  Before going down the
get-the-code-and-buy-a-licence route, try just generating a regular
key.  Chances are it will work just fine without IDEA.

@_date: 2004-10-09 00:08:17
@_author: David Shaw 
@_subject: decryption failed: weak key 
1.4 will give a warning, but allow you to decrypt even with a weak
key.  As you say, there is no risk in decryption.

@_date: 2004-10-09 15:05:32
@_author: David Shaw 
@_subject: Who can explain RSA key types for me? 
Certification  == signing someone's key
Signing        == signing some data (e.g. a file)
Encryption     == encrypting some data
Authentication == signing a challenge to indicate you are who you say
Authentication is the new one.  It was only recently added to the
OpenPGP standard.  It could be used, for example, if you wanted to use
your OpenPGP key for a SSH login.
The flags can be set on any key, with some restrictions - Elgamal is
an encrypt-only algorithm and cannot be C, S, or A.  DSA is a
sign-only algorithm and cannot be E.  RSA can be anything.  None of
this is a special property of the key - it's just a flag given as a
hint as to what purpose you intend to use the key for.
I should note that this applies to the upcoming GnuPG 1.4.  The
current version does not have all of these options.

@_date: 2004-10-11 22:15:03
@_author: David Shaw 
@_subject: Who can explain RSA key types for me? 
So far as I know, bis-10 is current.  It seems to have expired from
the IETF site.

@_date: 2004-10-12 22:06:46
@_author: David Shaw 
@_subject: symmetric encryption to multiple recipients // multiple 
GnuPG (1.4) can read such a message, but will not generate it.

@_date: 2004-10-12 22:23:33
@_author: David Shaw 
@_subject: symmetric encryption to multiple recipients // multiplepted 
I'd have to dig into the changelogs to refresh my memory, but I
believe you're right.

@_date: 2004-10-12 22:44:22
@_author: David Shaw 
@_subject: symmetric encryption to multiple recipients // multiplepted 
None that I know of.
Not currently planned for 1.4.  There are UI issues involved, since it
involves prompting for multiple passphrases, and the --passphrase-fd
method can only handle a single passphrase.

@_date: 2004-10-12 23:02:12
@_author: David Shaw 
@_subject: invalid packet (ctb=2d) 
Very often, this error:
means that the file is corrupt.  A common way of corrupting files is
to FTP them in ASCII mode instead of BINARY.  How are your files being
moved around?
I understand that you successfully read this file with PGP, but which
copy did you test with?  The same one on the same box as GnuPG?

@_date: 2004-10-13 14:47:10
@_author: David Shaw 
@_subject: What's "memory guard"? 
Leave it off, unless you are developing code.  It's a memory bounds
checker.  It's not very sophisticated (valgrind is better), but does
serve to knock out some common cases.  It also doesn't work on all

@_date: 2004-10-15 14:10:45
@_author: David Shaw 
@_subject: Error Message 
It means "corrupted message".  Seven times out of ten, it means
someone transferred the file via ASCII ftp instead of BINARY ftp and
so got flipped bits.

@_date: 2004-10-16 15:02:11
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.3.91 released (development) 
Hash: SHA1
The latest release from the development branch of GnuPG is ready for
public consumption.  This is a branch to create what will extremely
soon become the new stable release of GnuPG 1.4.
We strongly encourage people to try this development release and
report any feedback or problems to gnupg-devel  If you have
been waiting until the 1.4 release is imminent before trying the code,
that time is now.
The files are available from:
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.91.tar.gz          (3.7M)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.91.tar.gz.sig
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.91.tar.bz2         (2.5M)
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.91.tar.bz2.sig
or as a patch against the 1.3.90 source:
  ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.3.90-1.3.91.diff.gz  (1.9M)
MD5 checksums for the files are:
  839e1404fa7b59fb815f44527da2b821  gnupg-1.3.90-1.3.91.diff.gz
  bc03e5651387e996f122ecfdb970211b  gnupg-1.3.91.tar.gz
  fb0f58ff5392c6c20759cd9de190c659  gnupg-1.3.91.tar.bz2
SHA1 checksums for the files are:
  eabf07abc4ca2deddfc917d55f340440331e2a0d  gnupg-1.3.90-1.3.91.diff.gz
  d67a2d0fd640b1d38e3e34efa9430698c54e7a55  gnupg-1.3.91.tar.gz
  f1e9a9c00bd48165f7da0824504f2ee4551a5bf0  gnupg-1.3.91.tar.bz2
Noteworthy changes in version 1.3.91 (2004-10-15)

@_date: 2004-10-16 15:19:21
@_author: David Shaw 
@_subject: Decryption of truncated data? 
Unfortunately, if you lost 43 bytes into a message, you lost part of
the session key.  You won't be able to decrypt without the session
However, are we talking about ASCII armored messages (i.e. "BEGIN PGP
MESSAGE", etc) ?  If so, then 43 bytes in may not even have touched
the actual message data.  It depends on how big the headers are.  The
default GnuPG headers are longer than 43 bytes.

@_date: 2004-10-20 16:37:33
@_author: David Shaw 
@_subject: generating a v4 rsa sign and encrypt keypair // no subkey 
There is no particular intent behind sign+encrypt keys.  The standard
allows for them (but does not recommend them), and so GnuPG allows
them as well (and just as much does not recommend them - note that
they are hidden behind --expert).

@_date: 2004-10-21 18:34:53
@_author: David Shaw 
@_subject: CRC error supressed...still getting unspecific read error 
This isn't surprising.  The CRC error means that file is corrupt.
Supressing the CRC error just tells GnuPG to pretend that the file
isn't corrupt... but since it IS corrupt, it bombs out somewhere else.

@_date: 2004-10-27 14:12:19
@_author: David Shaw 
@_subject: setpref syntax 
gpg -v --version
But note that in 1.4, you don't need to use "S1 S2 Z3" any longer
since it understands "IDEA, 3DES, BZIP2".

@_date: 2004-10-28 00:31:12
@_author: David Shaw 
@_subject: PGP5 and v4 GPG keys 
PGP 5 predates OpenPGP, and as such is not OpenPGP compatible.  GnuPG
is OpenPGP.  It's a miracle they communicate at all.

@_date: 2004-10-28 04:29:11
@_author: David Shaw 
@_subject: PGP5 and v4 GPG keys 
That key is broken.  As a guess, it seems that the private half is not
really the private half for the public key.  Corrupt, perhaps.

@_date: 2004-09-06 01:07:41
@_author: David Shaw 
@_subject: How to encrypt symmetric to many passphrases? 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
This only works with GnuPG 1.3.x.

@_date: 2004-09-13 18:36:15
@_author: David Shaw 
@_subject: Share group aliases between GnuPG and PGP? 
Yes and no.  If you have a command line version of pgp, you can grep
the group lines out of gpg.conf and do some magic to convert them to
pgp -ga commands.  If you don't have a command line version that
supports groups (note that the new PGP 8 command line doesn't) then
there isn't any really good way to do it.  The PGP "PGPgroup.pgr"
files have a private format, and while I suppose they could be reverse
engineered, there hasn't been much need for interchangeable group
files yet.

@_date: 2004-09-16 17:47:24
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
There is no way to see the version of a key directly.  You can infer
some information by noting that the V3 keys are sign+encrypt RSA,
which is uncommon in the V4 world, but that doesn't guarantee a V3
Even so, this is a can of worms: there are V3 keys with V4 signatures,
or V4 self-signatures.  Those are likely being used on a modern
OpenPGP application, so beware using PGP 2.x parameters which might
make the message not readable.
"--pgp2" is hardly a mile long.
Perfect backwards compatibility is not possible since a PGP 2.x key
doesn't mean that the user is using PGP 2.x.  It just means they
generated their keys a long time ago.  Forcing PGP 2.x options for a
mix of keys (old & new) can cause the owner of new key to not be able
to decrypt the message.  GnuPG tries to be compatible with the old PGP
2.x stuff, but never at the cost of hurting compatibiltity with the
current stuff.
Right about now is usually when I get a lot of email complaining about
this comment, and how PGP 2 is the only good version, etc, etc, etc.
People seem to get *really* angry on this topic.
At the risk of enflaming passions, note that OpenPGP is hardly "new"
any longer.  V4 keys date from 1997, and are over 90% of the keys on
the keyservers.  If you take into account keys that are actually used,
as opposed to old forgotten keys, then I suspect the percentage of
OpenPGP keys would be even higher.

@_date: 2004-09-16 17:54:56
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
Although, I should add that if you really want to see a key version,
you can do 'gpg --export key | gpg --list-packets' and pipe that
through something to parse out the key version.  That's not a
supported interface though, and may change in the future.

@_date: 2004-09-16 21:27:47
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
It's not just that the person with the PGP 2.x key must have IDEA -
it's that people with OpenPGP might not.  Take this case: User A has a
PGP 2.x key.  User B has an OpenPGP key.  In an effort to accomodate
user A, you encrypt using IDEA.  However, user B does not have IDEA.
By trying to be backwards compatible with user A, you accomplish
locking out the modern user B.  The only really safe way to handle PGP
2.x users is to encrypt twice - once for the PGP 2.x people, and once
for everyone else.
Yes and no.  Yes, you can convert a V3 key to a V4 one, and such a key
would be mathematically able to decrypt the messages sent to, and
verify sigs from, the old V3 key.  However, the key ID of the new key
would be different, which makes this somewhat pointless since in
practical terms, the encryption program would not know to use the new
key.  Plus, signatures on the old V3 key would not transfer to the new
V4 key.  There is really no benefit in converting a key this way.
It is also possible to convert an old V3 key into a subkey on a V4
key.  This is somewhat less pointless, but still not that useful in

@_date: 2004-09-17 00:08:03
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
It is always possible to add yet another feature to try and work
around the fundamental incompatibilities between PGP 2 and OpenPGP.
The problem with this is where does it stop, and how many people does
this benefit?  Given that the overwhelming majority of people don't
use PGP 2, this is a simple calculation.  Better to spend that
valuable development time on something that is usable by more people.

@_date: 2004-09-17 02:31:58
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
Why should he?  In most of the world he can't even use IDEA legally
without a licence.  This isn't his problem (over 90% of the userbase).
This is user A's problem (less than 10% of the userbase).
In any event, this is not a useful suggestion.  When working on GnuPG,
I have to follow the OpenPGP standard.  There is absolutely no
requirement in OpenPGP that a client supports IDEA, and therefore I
cannot assume that a client supports it either.

@_date: 2004-09-17 14:21:40
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
Using something legally and using it hoping (or even expecting) not to
be sued are not the same thing. ;)
I would expect that the use of pgp 2.x would be less among those
knowledgeable about encryption, given the list of problems (using MD5,
small key sizes, fingerprint forgery, keyid forgery, etc), plus that
it doesn't interoperate well with the rest of the world (encryption is
great, but not if you can't actually use it to communicate) There are
certainly a number of 2.x die-hards who simply will never change over,
and that's fine for them, but that should not stop progress for
everyone else.
In any event, let's play with the numbers a bit.  I misremembered the
statistics when I wrote that email.  It's actually *worse* for V3
keys: slightly over 95% for V4 keys and slightly under 5% for V3.
Stats as of May 2002 (as per
         V2 keys 18159
      V3 keys 143068
      V4 keys 3055126
These are stats from 2002, but I'd be pretty shocked to see that V3
keys grew at a faster rate than V4 between then and now.
For the sake of argument, let's pretend the V2 keys are V3 keys.  What
percentage of the V3 keys do you think are still in use and not
abandoned?  What percentage of the V4 keys?  It would have to be a
pretty large percentage of V3 and a pretty small percentage of V4 to
justify making rather significant changes to GnuPG.
IDEA often prevents decrypting a PGP 2.x message, but in any event, my
comment was in regards to generating a message to more than one user.
Decryption is not usually a problem (either it works or it doesn't -
it does not harm other users in the process).
My comment was that given a case of user A with PGP 2.x, and user B
with anything else, there is effectively no way to encrypt that will
definitely work for them both.
The problem is this: PGP 2.x breaks on anything it doesn't understand.
This includes an encrypted session key.  Thus, given the case if user
A has PGP 2.x and user B has anything else, if user B has an RSA
encryption key, AND it is less than 2048 bits long, AND they have
IDEA, then it is possible to encrypt to both.  Anything else will
break PGP 2.x.
If all the OpenPGP users would agree to using <=2048 bit RSA keys and
either buy IDEA, use it non-commercially, or use it illegally, then
we'd be set. ;)
Since there is (effectively) no way to generate a message that is
usable for both users, this pretty much demands using two different
messages, and encrypting twice, once for each user, and that is
something that really belongs outside of GnuPG.
There are certainly other ciphers there, but OpenPGP has a preferences
system to give guidance as to what ciphers are usable for a given key.
This prevents one user from encrypting something in a way that the
recipient cannot handle.  Using a cipher (IDEA or otherwise) in
violation of the preferences violates OpenPGP ("An implementation MUST
NOT use a symmetric algorithm that is not in the recipient's
preference list").
In any event, like I said, it's not just IDEA.  It's RSA, it's key
size, etc.

@_date: 2004-09-17 20:08:52
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
Actually, no.
IDEA is patented in Austria, France, Germany, Italy, the Netherlands,
Spain, Sweden, Switzerland, United Kingdom, Japan, and the USA.

@_date: 2004-09-17 21:10:21
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
Thanks Jason.  This brings up a very good point.  To be a completely
fair comparison, we should compare V3 keys against V4 pubkeys (and not
subkeys).  Since V4 keys are usually 2 or more V4 keys together, this
unfairly elevates the number of V4 keys.
So, using Jason's numbers for 2004-07-06, 9% of the keys are v2/v3 and
91% of the keys are v4.

@_date: 2004-09-20 03:49:02
@_author: David Shaw 
@_subject: Detecting PGP 2.6.x keys 
I don't know.  I got the patent list from
I assume they are claiming something that is true, but I'm certainly
not a patent lawyer.  The FAQ on that site is interesting though.
It's a little misleading with regards to GnuPG.

@_date: 2004-09-21 23:55:16
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
gpg --version
In 1.2.x, GnuPG supports MD5, SHA1, and RIPEMD160.  It also supports
SHA256 read-only (you can verify existing signatures made with SHA256,
but not make new ones).  If you compile it with the right options, you
can get SHA384 and SHA512 read-only.  TIGER192 is allowed, but
In 1.4, GnuPG will suppports MD5, SHA1, RIPEMD160, and SHA256.  It
will support SHA384 and SHA512 read-only.  TIGER192 is removed.

@_date: 2004-09-22 04:11:44
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Keep in mind that the argument against SHA256 that it hasn't been
analyzed as much as SHA-1 also applies to RIPEMD-160 (though to less
of a degree than SHA256).
I recommend against this.  SHA-1 is not, repeat, not broken.  We
should not run around switching hashes willy-nilly because of a rumor.
If someone manages to make actual progress against SHA-1, it'll be
major news.
Avoiding the use of SHA-1 in OpenPGP is somewhat silly since many
major parts of the standard (like fingerprints) use SHA-1 only.

@_date: 2004-09-22 21:27:46
@_author: David Shaw 
@_subject: Ignore use of "--keyring" in options-file 
A possibly silly question - if you don't want all those keyrings
defined, why add them in the first place?

@_date: 2004-09-24 17:51:04
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
While this isn't a practical break of MD5, it is still prudent to stop
using it.  In the context of OpenPGP, stopping using MD5 means
stopping using v3 keys.  If we stop using MD5 today, we can gracefully
migrate to something better.  If we wait until there IS a practical
break, then we are forced into a frantic repair mode that can cause
other harm.
The very next paragraph in Bruce Schneier's essay is:
  But there's an old saying inside the NSA: "Attacks always get
  better; they never get worse." These techniques will continue to
  improve, and probably someday there will be practical attacks based
  on these techniques.
He's arguing to start the slow transition away from SHA-1.  If there
is a rational argument for starting a transition away from SHA-1, then
we sure as heck should have been off MD5 for a long time now.

@_date: 2004-09-24 21:53:16
@_author: David Shaw 
@_subject: Question about FAQ section 7.1 
This isn't true any longer.  OpenPGP now has the MDC protection.  Both
GnuPG and PGP support it.  MDC can be turned off manually, or if you
encrypt to a key that doesn't support it, it is switched off
automatically, but in general it is on.  GnuPG tries pretty hard to
use MDC whenever possible.  MDC works for conventional encryption
No basic problem.  Some people like to use --symmetric when encrypting
to themselves, and some people like to use their public key.  It's
really a matter of taste.  I prefer to use my public key so I don't
have one more passphrase to remember ;)

@_date: 2004-09-24 23:38:20
@_author: David Shaw 
@_subject: Question about FAQ section 7.1 
I have backups of my secret key off of my HD, burned onto a CD and
stored in a secure place.  Don't forget one of the best backup
methods: export the secret key packet with ASCII armor and print it
out.  Paper generally is the safest thing out there in terms of media
decay.  If all else fails, I can re-type the thing in.

@_date: 2004-09-25 00:59:46
@_author: David Shaw 
@_subject: Question about FAQ section 7.1 
Not the whole secret key.  Just the secret key packet itself.
The logic is that I don't need to do anything special to back up my
public key and signatures since if all else fails I can just get it
from any of a number of keyservers.  The self-sigs are on the public
key as well.
My secret key is backed up in the usual way (CD-R).  The paper copy is
a "if all else fails" backup, and it's not large at all: The only
truly secret part of the secret key is the key data itself, and the
common 1024-bit DSA key is only 11 lines long.  I'd rather type in 11
lines than make a new key.  It's not something I want to do regularly,
but if my CD-R backups fail for whatever reason, I can spend 30
minutes typing it back in again, and not lose access to my encrypted
People often see CD-Rs fail after 3-4 years... paper will last longer
than I will.

@_date: 2004-09-25 16:22:08
@_author: David Shaw 
@_subject: Decrypting without designing? 
Check the manual for the --status-fd option and read the file DETAILS
(in the doc/ directory).  This shows how you can get the information
you want.  Looking at the exit code is not enough.

@_date: 2004-09-26 14:37:20
@_author: David Shaw 
@_subject: Weakness in SHA-1 
... but it is required for calculating v3 fingerprints.
I'm so tired of this endless argument.  People, just let v3 go
already.  It was time for it to go years ago.  Now it's just silly.

@_date: 2004-09-27 16:44:17
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
It's a good question.  Basically, nobody (PGP or GnuPG) officially
supports 384/512 yet.  It is prudent to get a code base out that
understands a new feature before a code base is released that actually
enables a new feature.  Since 1.2.x does not support 384/512 at all
unless it is specifically compiled in by the user (which the majority
do not), the first release of GnuPG that can (almost always)
understand 384/512 is going to be 1.4.  Once 1.4 has been out for a
while, 384/512 can be enabled for read/write.
OpenPGP has a sometimes justified reputation as being difficult to get
different versions to interoperate.  Just look at the many web sites
with huge compatibility charts.  This is not good for anyone, and
holding back on a new feature until it can be used safely is an
attempt to dispel this reputation.
Incidentally, 384 is sort of pointless for OpenPGP.  It's mostly the
same algorithm as 512 truncated to 384 bytes.  Unless you need to save
16 bytes, there is little benefit.

@_date: 2004-09-27 16:46:10
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
Why would you use Tiger192 when SHA256 is available?  I imagine SHA256
is getting a lot more attention by people trying to break it than
Tiger192 is.
In any event, Tiger192 was removed from the OpenPGP standard (not
because it was thought weak, but because nobody really used it and
there were longer hashes available).

@_date: 2004-09-27 22:03:56
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
I think history shows that any uncommon algorithm is going to be used
simply because it's there...

@_date: 2004-09-27 22:58:02
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
Tiger does not have a 160 bit variant.  You can truncate the 192 bits
to 160, but it's the same algorithm (somewhat similar to SHA256 and
This does not follow.  Just because someone includes an algorithm in
the OpenPGP specification does not in any way mean that algorithm can
be considered secure.  All it means is that enough people wanted to
use the algorithm so it was assigned an algorithm number.

@_date: 2004-09-28 06:25:15
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
Probably a direct function of it not being used anywhere.  If you were
a cryptographer wanting to publish a paper, would you spend time
attacking SHA-x and get famous, or Tiger192 and get a big shrug from
the media?
By the way, I don't have anything against the algorithm or design of
Tiger192.  My reasons to argue against it is more logistics - it
hasn't had much use in the field, and it's not part of OpenPGP any
longer.  Since GnuPG is an OpenPGP client, using Tiger would be
nonstandard, and nonstandard is exactly what you don't want when it
comes time to interoperate with the rest of the world.

@_date: 2004-09-28 06:27:12
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
Absolutely.  Breaking a widely used algorithm gets you interviewed.
Breaking an algorithm that barely anyone uses get you nothing.
Thus, we can guarantee that Tiger is never cracked by not using it. ;)

@_date: 2004-09-28 06:30:55
@_author: David Shaw 
@_subject: Weaknesses in SHA-1 
That's effectively what SHA512 is now.  It's read-only unless you
modify the code.
Exactly.  GnuPG already supports MD5, SHA1, RIPEMD160, SHA256, SHA384,
and SHA512.  If all of them are broken at the same time, I'll eat my
hat.  To say nothing of the fact that if SHA1 is broken, OpenPGP as a
whole needs to be revised.

@_date: 2005-04-01 18:57:16
@_author: David Shaw 
@_subject: key capabilities usage meanings 
Probably they were generated with two different versions of GnuPG.
The "A" authentication type is fairly recentl.
Signing is signing data (i.e. gpg --sign the_file)
Certification is signing a key (i.e. gpg --sign-key the_key)
Authentication is signing a challenge (like ssh does).  The
Authentication stuff can be used to log in to a machine using your GPG key.
The signature math is the same however you do it.  The key usage flags
are just to classify things.
Not with CAST5.  CAST5 has a blocksize of 64 bits.

@_date: 2005-04-13 17:04:46
@_author: David Shaw 
@_subject: Encrypt with public key from stdin/file possible? 
You can't do it without importing the key, but you can sort of fake
what you want.  Do something like:
  gpg --no-default-keyring --keyring ./tempkeyring.gpg --import  (thekey)
  gpg --no-default-keyring --keyring ./tempkeyring.gpg --encrypt  ......
  rm tempkeyring.gpg

@_date: 2005-04-15 19:03:31
@_author: David Shaw 
@_subject: After installing the new release. 
No, you can keep using your current key.  No problem.

@_date: 2005-04-18 18:15:16
@_author: David Shaw 
@_subject: Revocation certificate still valid after changing subkeys? 
It applies to the master key only.  You do not need to generate a new
revocation certificate.  Revoking the master key takes out all UIDs
and subkeys in one step.

@_date: 2005-04-21 14:54:34
@_author: David Shaw 
@_subject: 1.4.1 won't retrieve key from keyserver? 
Yes, this was fixed the day I responded to your original mail.
However, I don't currently have a good way to test on windows, so if
you could test when the 1.4.2 release candidate comes out, that would
be great.

@_date: 2005-04-22 00:12:50
@_author: David Shaw 
@_subject: importing large keyring 
No, not really (at least if you see them on a keyserver like in the
example).  The copy of the key on the keyserver is corrupt.  GnuPG
will do a reasonable amount of repair as it imports, and generally
ends up with a usable key.

@_date: 2005-04-23 15:00:47
@_author: David Shaw 
@_subject: [PATCH] gnupg.spec [WAS: unable to execute program 
Okay, this is done and will be in 1.4.2.  If anyone tracking CVS wants
to give this a whirl before then, do let me know how it works out.

@_date: 2005-04-25 16:20:05
@_author: David Shaw 
@_subject: Sign more than one uid 
Sure, just select all the user IDs you want to sign, then "sign".
It's the same as signing one user ID, except there are more than one.

@_date: 2005-04-28 20:06:33
@_author: David Shaw 
@_subject: gpg dependency issues (krb5 & klogd) 
This is a SuSE specific issue.  GnuPG does not require Kerberos or the
kernel logger daemon (which is a Linux specific thing anyway).  I
don't know why they have those marked as requirements in the RPM.

@_date: 2005-08-03 20:49:41
@_author: David Shaw 
@_subject: IPv6 failover? 
The complaint is that keyserver.linux.it has both IPv4 and IPv6
addresses, but you can't reach it via IPv6, so you want gpgkeys to
fail over to its IPv4 address?

@_date: 2005-08-03 22:52:26
@_author: David Shaw 
@_subject: Encrypting an e-mail to a Hushmail user 
I'm afraid that nobody will be able to help you unless you post
something more useful than "I get an 'error'"

@_date: 2005-08-03 23:57:09
@_author: David Shaw 
@_subject: Leave clearsigned content encoding alone, how? 
I believe you are having a problem somewhere, but GPG does not do any
character set conversions whatsoever, in clear signing, or any
If something is converting, you need to check your MUA or other
programs that you are using around GPG.

@_date: 2005-08-04 01:21:36
@_author: David Shaw 
@_subject: IPv6 failover? 
The thing is, if you have a --with-libcurl build, this failover would
need to happen within curl itself.  What happens if you do:
  curl on the command line.  Obviously it won't do anything keyserver-wise,
but does it manage to connect?

@_date: 2005-08-04 02:40:14
@_author: David Shaw 
@_subject: IPv6 failover? 
I'm not sure.  CURL_IPRESOLVE_V4 is documented to force the connection
to IPv4.  That is, it'll ignore IPv6 addresses altogether, rather than
try to connect and then fail over within curl.  What happens if you
add a "-4" to the command line above?  That sets CURL_IPRESOLVE_V4.
Also, going back to the original problem, can you send me the output
when you try fetching a key with "--keyserver-options debug" set?

@_date: 2005-08-04 14:01:19
@_author: David Shaw 
@_subject: SKS v. unknown HTTP headers (was:  Re: IPv6 failover?) 
Hmm.  No really good way to fix that in GPG or curl since they can't
detect that a server is 1.0 without doing a GET first.  Curl, if I
recall, can correctly handle the case when the Continue header is not
supplied (it gives up after a while).
The problem here seems to need a SKS fix.  SKS needs to ignore HTTP
headers that it doesn't understand.  That's HTTP, anyway.
Terribly misleading error message from curl there.

@_date: 2005-08-05 14:13:38
@_author: David Shaw 
@_subject: SKS v. unknown HTTP headers (was:  Re: IPv6 failover?) 
Excellent.  Thanks, Jason.  I'm glad these little details are getting
fixed before the next GnuPG which uses curl by default.

@_date: 2005-08-09 15:22:32
@_author: David Shaw 
@_subject: Multiple self signatures 
You can't, really.  Every time you change the expiration date of your
key, or change your preferences you issue a new self-signature.  The
keyservers don't delete old ones (they can't), so self sigs pile up
after a while.  They are harmless.
If it bothers you, do --edit-key and use the "clean" command.

@_date: 2005-08-09 19:14:58
@_author: David Shaw 
@_subject: removing revoked or expired signatures 
This is required for security.  The last signature revocation is
always kept (earlier ones are removed).

@_date: 2005-08-18 05:52:30
@_author: David Shaw 
@_subject: Signature verification fails with GPG 1.4.0 
Yes, that is what is wrong.  There is a very long explanation about
text canonicalization which explains why it works in 1.4.2 but not in
1.4.0, but the bottom line is that if the file is binary, it needs a
binary sig or it just won't work reliably.  (I've been trying to
persuade the spamassassin release people of this for a while now).
I can guarantee it will break between different versions of GnuPG, and
I can guarantee it will break between different versions of GnuPG and

@_date: 2005-08-21 04:32:25
@_author: David Shaw 
@_subject: GPG 1.4.2 errors 
No, it's not a bug.  You didn't set the right option.  If you want to
clean keys on --import you set --import-options.  If you want to clean
keys on keyserver recv, you set --keyserver-options.

@_date: 2005-08-23 05:31:19
@_author: David Shaw 
@_subject: gnupg 1.4.2 import time errors 
gpg --edit pmehta
  setpref
  save
Then send the key to the keyservers again.
However, it is interesting to note that your key is slightly corrupt
(there is no cipher algorithm 0, though your key has it set as a
preference).  Did you edit your preferences at one point?  And if so,
what program did you use?

@_date: 2005-08-26 17:59:44
@_author: David Shaw 
@_subject: Version 1.4.1 generate keys that don't import in 1.2.6 
You don't give any actual information about the key, so it's not
possible to help you.  I suspect, given the versions of GnuPG, that
you generated a Elgamal sign+encrypt key.  This key type was dropped
from the OpenPGP standard, so newer programs will not support it.
What does 'gpg --list-keys 7CC30F25' return?

@_date: 2005-12-07 05:22:16
@_author: David Shaw 
@_subject: disjunct paths 
Yes, exactly.  1 hop away is easy, but as you get further and further
away, you just don't know the people any longer.
The same way it calculates for one hop: fully valid keys with full
trust can make other keys fully valid.  It doesn't matter if they are
one hop or 15 hops away, so long as the hop count is less than

@_date: 2005-12-07 15:07:16
@_author: David Shaw 
@_subject: disjunct paths 
I leave it at the default unless I'm testing something (so it is 5).
I agree it is the same issue as above, yes.  5 seems like a more or
less sane default - big enough to be useful, small enough to not be
(too) dangerous.  Different people have a different comfort level, of
course, which is why the value is changeable.  In any event, the cert
depth doesn't really change the actual calculations in most cases -
most people don't have chains of people they know that are that long.

@_date: 2005-12-14 16:00:22
@_author: David Shaw 
@_subject: Encrypting a file in a non -interactive mode 
Sure, just do something like this:
 gpg --batch -r (recipient) --output (name-for-encrypted-file) --encrypt (file-to-encrypt)
However, this assumes that the recipient is trusted by you.  If not,
then you also need to add "--trust-model always" to override that.
This also assumes that name-for-encrypted-file doesn't exist.  GPG
won't overwrite it if it exists.  To force GPG to overwrite the
existing file, add "--yes".

@_date: 2005-12-14 17:51:59
@_author: David Shaw 
@_subject: Signature has algorithms 
The procedure you give above will put new self signatures on the key.
You can't recreate old ones, but you can delete them.  Note that if
you have your key on a keyserver, the old self-sigs will come back
since the keyserver (or really anyone else who has a copy of your
current key) doesn't delete the old self-sigs.

@_date: 2005-12-16 05:11:55
@_author: David Shaw 
@_subject: Automation advice wanted 
This is a reasonable thing to do.
This can be reasonable in some circumstances, but also can be risky -
it's hard to hide a passphrase in a script that way.  Also, how do you
plan to prevent people just copying the script, key, passphrase, and
It's hard to suggest an alternative without knowing more about what
you're trying to do.  Is there actually a need for encryption once the
data in question is on-site, or is it just a transit issue?  Would it
be acceptable for one person to own the master key and decrypt and
then re-encrypt to a list of individual keys for your internal users?

@_date: 2005-12-16 14:32:10
@_author: David Shaw 
@_subject: mpi too large 
Probably unrelated.  The "signature not checked" is not an error, but
normal operation: the key you imported has a signature from a key you
don't have.  It's just a note so you can go out and get this other key
if you care.
The "mpi too large" is a problem, but likely on the sender side.  Do
you know what program they are using to encrypt?

@_date: 2005-12-19 20:34:45
@_author: David Shaw 
@_subject: Signature has algorithms 
You can't, without hacking GPG to do it.  It's easier to just make a
new subkey.
No.  Backsigs are not really meaningful for encryption keys.  Backsigs
protect against a particular attack (someone claiming your signing is
theirs) that isn't relevant to encryption keys - if someone stole an
encryption key, they might try and claim they owned it, but that
doesn't mean much as they couldn't read anything encrypted to it.
I'm vaguely toying with the idea of including backsigs for encryption
keys with an algorithm that can at least issue signatures (i.e. RSA),
since it doesn't hurt and might be marginally useful, but this
couldn't be a general thing since not all encryption algorithms can
sig (i.e. Elgamal).

@_date: 2005-12-20 17:59:17
@_author: David Shaw 
@_subject: Moving the GPG keys from 1 machine to another 
No, you don't.
On old box:
  gpg --export-key (thekey) > mykeyfile.gpg
  gpg --export-secret-key (thekey) >> mykeyfile.gpg
(now copy mykeyfile.gpg from old machine to new)
On new box:
  gpg --import mykeyfile.gpg

@_date: 2005-12-27 17:07:47
@_author: David Shaw 
@_subject: Issue in decrypting file 
This isn't an error.  It just means that the person who sent the file
signed it and GPG is warning you that you don't have that person's key
so you can verify the signature.  GPG will decrypt the file anyway,
but you might want to get a copy of the vendor's key so you can verify
the signature.

@_date: 2005-02-02 16:37:33
@_author: David Shaw 
@_subject: --list-sigs, --check-sigs and --list-keys 
--list-sigs shows the sigs.  --check-sigs goes one step further and
checks the sigs for validity.
In general --check-sigs is going to be slower as there is more work to
do.  Whether it is significant or not depends on a number of factors.
In most cases with 1.4.0, it's not even noticable.  In some cases
(with Elgamal signatures and older GnuPG), it's 20-30 minutes slower.

@_date: 2005-02-02 16:51:53
@_author: David Shaw 
@_subject: difference between undef and unknown 
Unknown means completely unknown.  The trust calculations have not yet
reached that key, the user ID is not signed by any key you have, etc.
Undefined means not enough information.  For example, if you have
marginals-needed set to 3 and only have 2 marginal signatures.
In practice, they are the same.  Either way, the user ID isn't valid
to encrypt to without a warning.

@_date: 2005-02-02 22:52:30
@_author: David Shaw 
@_subject: --list-sigs, --check-sigs and --list-keys 
That's why in most cases with 1.4.0 it's not even noticable.  Every
time you check your trustdb, uncached signatures are cached.

@_date: 2005-02-03 22:35:01
@_author: David Shaw 
@_subject: [Announce] release candidate for 1.4.1 available 
I'm not sure what didn't work here.  What did you verify with PGP 8.1?
This was a typo.  The options are *off* by default.

@_date: 2005-02-04 17:12:53
@_author: David Shaw 
@_subject: GPG question 
GnuPG automatically includes the original filename inside the
encrypted file.  Include the --use-embedded-filename option when
decrypting to use this name when decrypting.

@_date: 2005-02-04 19:35:57
@_author: David Shaw 
@_subject: Signing a Key 
Some people decided that since a level 1 "I didn't check at all"
signature type was available, that it was a Real Good Idea to sign
every single key they saw.
Also, it's one more thing to have to explain to newbies.  If they
don't see the question, they don't have to ask.

@_date: 2005-02-04 21:45:19
@_author: David Shaw 
@_subject: Signing a Key 
I'm afraid I don't see the point you're trying to make.

@_date: 2005-02-05 02:43:08
@_author: David Shaw 
@_subject: Signing a Key 
[ snip RFC quoting ]
[ snip more RFC quoting ]
Facts are interesting things.  The RFC doesn't specify a trust model
anywhere.  Thus, all programs accept a 0x11 (or 0x10, 0x12 or 0x13)
signature... but treat them all the same.  Perfectly compliant to the
0x11 signatures are also interesting things.  When made by people (as
opposed to robots) they are in effect someone making a public
statement to say "Hey, look, I made a lousy signature".  I can't
imagine why someone would choose to advertise far and wide how
terrible their signing policy is, but GnuPG allows people to do stupid
things if they really want to.
GnuPG will quite happily make 0x11 signatures.  It just doesn't do so
by default.  Those people who want to make typed signatures can set
--ask-cert-level and then everyone is happy.
Similarly, by default GnuPG ignores 0x11 signatures.  Like issuing
them, this doesn't stop anyone from accepting 0x11 signatures.  Any
user who cares to can opt-in via "--min-cert-level 1" and accept any
signatures they like.  Given that the whole point of an 0x11 signature
is to say "I didn't check AT ALL", ignoring them by default is safer
than accepting them.
To put this another way, the RFC allows a sender to send foolish
things.  It does not require the recipient to accept them.
Your own statistics argue against this.  589 people in the entire
OpenPGP world actually issued 0x11 signatures.  Just 293 people issued
more than one.  Given the number of people using OpenPGP, 293 people
is a rounding error.  That's not worth having a whole new trust model
for, especially given the serious security ramifications of 0x11
signatures, be vastly more confusing to new users, and be incompatible
with PGP to boot.

@_date: 2005-02-05 20:20:48
@_author: David Shaw 
@_subject: Signing a Key 
As I keep saying: if you want to issue 0x11 signatures, go ahead.
Nobody is stopping you.  If you want to accept 0x11 signatures, go
ahead.  Nobody is stopping you.
Where's the problem?  You don't like the defaults?  Change them.
If a user only wants to accept 0x13 signatures, that is their decision
to make, via --min-cert-level 3.  The default behavior in GnuPG is to
accept both 0x12 and 0x13 (and 0x10, of course).

@_date: 2005-02-05 20:35:01
@_author: David Shaw 
@_subject: Signing a Key 
You're right.  The manual is misleading on this point.  I'll fix it.

@_date: 2005-02-07 14:16:14
@_author: David Shaw 
@_subject: "http" & "finger" keyserver schemes 
http and finger schemes are most useful for putting in preferred
keyserver URLs so the key can be automatically refreshed.  They're not
really intended for use on the command line, but it's possible to fool
the system into working on the command line by doing something like:
  gpg --keyserver finger:the_finger --recv-keys 99999999
i.e. "receive key 99999999 from finger:the_finger  The
key that arrives probably won't be 99999999, but it'll arrive anyway.

@_date: 2005-02-08 15:07:58
@_author: David Shaw 
@_subject: 1.4.0: Howto verify a signed file quickly - without any 
It sounds like you are looking for gpgv, which comes with GnuPG.  It
does just what you want - verifies files and nothing else.

@_date: 2005-02-08 17:32:29
@_author: David Shaw 
@_subject: Partial body length encoding for Compressed packets 
PGP 2 isn't RFC-2440 compliant.  PGP 2 dates from quite a few years
before 2440 was even written.
It won't work ;)
Sane PGP interoperability requires knowing when to give up.  For
example, there are details between PGP 5 and 7 where you can support
one or the other, but not both.
To a certain extent, supporting bugs from old versions that have been
replaced many times over is actually harmful.  I know that some users
have settled on one version of PGP and will continue to use that
version until the sun goes nova, but given the choice between
supporting that tiny minority of people, and the huge majority of
people who are using something actually RFC compliant, I know where
I'm going to spend my energy.

@_date: 2005-02-08 19:56:37
@_author: David Shaw 
@_subject: Partial body length encoding for Compressed packets 
It's historical.  PGP 2.x came before the partial body length encoding
existed, so that's why it doesn't support it at all.

@_date: 2005-02-08 20:09:41
@_author: David Shaw 
@_subject: Partial body length encoding for Compressed packets 
PGP2 does not support partial body length packets.  GnuPG is forced to
use PBL encoding if it does not know the length of a message (say, if
you're encrypting stdin or something with no clear size).  In that
case, regardless of the --pgp2 flag, PGP2 will not be able to decrypt

@_date: 2005-02-09 20:50:51
@_author: David Shaw 
@_subject: GD doesn't always accept revocations 
:
  Can I post a revoked key to the PGP Global Directory?
  No. The PGP Global Directory includes many features to prevent it
  from being filled with unusable keys. One of these features is that
  the directory does not support revoked keys. Instead of revoking
  your key, simply remove it from the directory.
In short, it's a feature.  I'm not sure I completely like that
feature, but nevertheless, the GD is operating as intended.

@_date: 2005-02-09 21:04:49
@_author: David Shaw 
@_subject: GD doesn't always accept revocations 
Supposed to by whose say-so?  Period or what?  I'll repeat the quote
from the GD:
   Can I post a revoked key to the PGP Global Directory?
   No. The PGP Global Directory includes many features to prevent it
   from being filled with unusable keys. One of these features is that
   the directory does not support revoked keys. Instead of revoking
   your key, simply remove it from the directory.
They don't do it.  They even document their not doing it.  You might
suggest it to them as a feature, but they don't do it now.
I'm not saying I think this is optimal behavior, but the documentation
is pretty clear on this point.

@_date: 2005-02-09 21:29:35
@_author: David Shaw 
@_subject: GD doesn't always accept revocations 
Yes.  I don't think this is the best design.  I understand the desire
to keep revoked keys off of the GD, but it's not clear what to do in
this case (an unrevoked key on the GD is suddenly revoked).
Drop the key immediately?  Accept the revocation and then drop the key
after some time has gone by?  I rather like the idea of accepting the
revocation, and then immediately causing the key to need to be
reverified by the user (as if their 6 month time on the GD was up).
This way the user knows what happened, and doing nothing causes the
key to fall out of the GD.

@_date: 2005-02-09 22:15:14
@_author: David Shaw 
@_subject: unable to execute program `gpgkeys_hkp': Permission denied 
If you don't mention bugs, they can never be fixed.
What configure command line did you use originally?  Did you use
--prefix or something similar?

@_date: 2005-02-09 22:22:30
@_author: David Shaw 
@_subject: GD doesn't always accept revocations 
Well, that's one possible answer.  Why don't you suggest it to the GD
Why go through a lot of bother to find an expired or revoked key which
you then manipulate into being acceptable?  Just make a brand new key
with your victim's email address and submit that.  It's the same

@_date: 2005-02-09 22:39:38
@_author: David Shaw 
@_subject: Are all the UIDs on a key supposed to be equal? 
I don't think the MIT keyserver shows revoked UIDs as being revoked.

@_date: 2005-02-09 23:50:30
@_author: David Shaw 
@_subject: revoking a UID 
None, since it doesn't happen ;)
What people generally call "signing a key" is really "signing a
key+uid".  If you revoke a uid, then those signatures are no longer

@_date: 2005-02-10 00:26:19
@_author: David Shaw 
@_subject: GD doesn't always accept revocations 
Maybe it is, and maybe it isn't.  If you just want to complain, then I
guess you're all set.  If you want something actually fixed you should
tell them.
That sounds like a lot of 'ifs' to me.  Sure, if you can dupe them
into doing something stupid, and if that key had been revoked before,
and if they then removed it from the GD, and if they had forgotten
they had done so, then maybe you have an attack?
It's always possible to come up with an attack if you get to use
enough 'ifs'.

@_date: 2005-02-10 04:32:56
@_author: David Shaw 
@_subject: unable to execute program `gpgkeys_hkp': Permission denied 
Try this spec file.  If it works for you, I'll put it in 1.4.1.  It
works ok on a FC3 box here.

@_date: 2005-02-10 21:15:32
@_author: David Shaw 
@_subject: unable to execute program `gpgkeys_hkp': Permission denied 
GnuPG doesn't actually do the install.  Rather, automake does.  It
seems to take your umask into account when doing it through.  What is
your umask?

@_date: 2005-02-11 01:16:50
@_author: David Shaw 
@_subject: GPG corruption 
Judging by the file size, I think you've been bitten by a 2gig file
size limit.
GnuPG 1.2.1 is very old.  You should upgrade, as that limit was
removed (ironically, only 4 days after 1.2.1 was released).

@_date: 2005-02-11 02:24:59
@_author: David Shaw 
@_subject: GPG corruption 
It wouldn't be.  It's an encoding bug that was fixed in 1.2.2.  The
data is there, it's just not encoded properly so GnuPG won't read it.

@_date: 2005-02-11 04:46:45
@_author: David Shaw 
@_subject: [Announce] Attack against OpenPGP encryption 
Skipped content of type multipart/signed-------------- next part --------------
Gnupg-announce mailing list

@_date: 2005-02-11 04:48:51
@_author: David Shaw 
@_subject: [Announce] Attack against OpenPGP encryption 
Skipped content of type multipart/signed-------------- next part --------------
Gnupg-announce mailing list

@_date: 2005-02-11 17:01:00
@_author: David Shaw 
@_subject: GnuPG 1.2 encryption key selection with authentication keys 
Unfortunately, manipulating the binding signature by itself won't
work.  You'd have to manipulate the date field in the key itself,
since that is what is used to determine which subkey to use.  It's
probably easier to revoke that subkey and make a new one which will
also make the encryption key the most recent.
You could also revoke the authentication subkey, but then you couldn't
use it, of course.
Note that PGP (even the latest 8.1) has the same bug.  The PGP folks
have been informed and are working on it.

@_date: 2005-02-12 02:14:56
@_author: David Shaw 
@_subject: [Announce] Attack against OpenPGP encryption 
Even in those cases, the same methodology applies.  If the candidate
session key came from an assymmetric decryption, then the check is not
done.  If the candidate came from a passphrase mangling or
passphrase-encrypted session key, then the check is done.
Probably not, but once weakness is visible, it's generally good
practice to start moving to something better.  Look at MD5 - the first
weakness was shown in 1996, if I recall.  It took 8 years to get to
the serious break in 2004, but OpenPGP started migrating away from it
back in 1996, so the break wasn't as big a deal.
It wouldn't help or hurt the symmetric encryption.  It would just help
in being a quick check.

@_date: 2005-02-12 02:15:39
@_author: David Shaw 
@_subject: set-filename / use-embedded-filename 
I assume you are talking about --clearsign here.  --sign does include
the embedded file name.  --clearsign has no filename, so that field is

@_date: 2005-02-12 05:33:43
@_author: David Shaw 
@_subject: set-filename / use-embedded-filename 
It's not meaningful to have a file name there.  The idea behind
keeping the original filename around is so you can reconstruct the
original file to its pre-encryption state.  In the case of
clearsigning, the clearsigned document *is* the document, so there is
nothing to reconstruct.

@_date: 2005-02-12 05:49:25
@_author: David Shaw 
@_subject: "http" & "finger" keyserver schemes 
There is no feature to include a keyserver URL inside a key signature.
It's not an impossible thing to do, but there is no support for it

@_date: 2005-02-12 06:01:50
@_author: David Shaw 
@_subject: [PATCH] gnupg.spec [WAS: unable to execute program 
It looks like it's needed for the make because the RPM macro for
%makeinstall is Being Helpful and overriding the libexecdir variable
back to what it was before we overrode it in the first place.
I don't think this is correct.  Removing that line causes the rpmbuild
to fail on my system.  Do you have the info package installed?  That
may be the difference between your box and mine.
Try the attached spec.  I think it should work now.

@_date: 2005-02-12 06:04:39
@_author: David Shaw 
@_subject: unable to execute program `gpgkeys_hkp': Permission denied 
That looks sane to me.  I don't know.  I've never seen this particular
problem before.  If you do the install over again, does the same thing

@_date: 2005-02-16 15:40:59
@_author: David Shaw 
@_subject: SHA1 broken? 
The paper has not been published yet, but the information released
thus far indicates the team was able to find a collision in SHA-1 in
2^69 operations.  Since SHA-1 should have been resistant to collision
to 2^80 operations, this is a very impressive attack.  Incidentally,
this is same team that was behind the successful attack on MD5.
However, in the real world this doesn't seem like a very useful
attack.  It's rather like someone pointing out that the 100 foot high
wall around your house is only 50 feet high.  True, the wall is not as
tell as claimed, but it's still probably taller than it needs to be.
To put this in perspective, the "broken" SHA-1 is stronger than MD5
was thought to be before the MD5 breaks were discovered (MD5 was
Still, I'm speculating based on the little information that has been
released.  Nobody really knows all the details yet since the paper
hasn't been published.  It is not yet known if the attack can be
extended to the SHA-2 hashes (SHA-256, SHA-384, and SHA-512).  Even if
it can be extended, the sheer length of the SHA-2 hashes may render
the attack moot in practical terms... or it might not.  We just don't
know yet.
In terms of GnuPG: it's up to you whether you want to switch hashes or
not.  GnuPG supports all of the SHA-2 hashes, so they are at least
available.  Be careful you don't run up against compatibility
problems: PGP doesn't support 384 or 512, and only recently started
supporting 256.  GnuPG before 1.2.2 (2003-05-01), doesn't have any of
the new hashes.  Finally, if you have a DSA signing key (most people
do) you are required to use either SHA-1 or RIPEMD/160.  RSA signing
keys can use any hash.

@_date: 2005-02-16 15:42:24
@_author: David Shaw 
@_subject: How to display fingerprint for secret key 
gpg --keyid-format long --list-secret-keys
gpg --fingerprint --list-secret-keys

@_date: 2005-02-16 16:30:11
@_author: David Shaw 
@_subject: sha-1 
For user IDs, that's easy and you can do that now.  Just delete your
self-sig and re-sign the UID.  For subkey self-signatures, you can
theoretically do it, but it's probably not worth it.  Just revoke the
old subkey and make a new one with whatever hash algorithm you like.
Be careful though - remember that not all OpenPGP implementations
support all hashes.  You can easily make your key unusable by some
people.  The nice thing about SHA-1 is that it is required by the
protocol so it always works.

@_date: 2005-02-16 17:19:51
@_author: David Shaw 
@_subject: SHA1 broken? 
Sure, assuming the SHA-1 "wall" was only 100 meters high in the first

@_date: 2005-02-16 17:52:56
@_author: David Shaw 
@_subject: SHA1 broken? 
If you presuppose a workable attack you can conjecture any result you
like.  Let's not go off the deep end here.
Skipping completely over the point that the paper has not been
published yet so it can be checked over by the cryptographic
community, let's assume that they have indeed done what they claim to
have done: demonstrated they can find a collision in 2^69 instead of
2^80 operations.  A collision attack.  Not a preimage attack.  And
it's not workable in practice.  How many entities have the ability to
do 2^69 operations in a sane amount of time?
Without more information, it looks to me like we are now in the
position we were in with MD5 several years ago.  It's not broken in
practical terms yet.  Attacks don't get worse over time, of course, so
we need to start moving to something better.  SHA-1 was already being
phased out:
To be sure, this is bad, but the sky isn't falling yet.

@_date: 2005-02-16 17:54:21
@_author: David Shaw 
@_subject: SHA1 broken? 
Yes it is.  Assuming this is true, we must start migrating away from
SHA-1.  Actually, we should start this anyway - even the NIST
recommends moving away from SHA-1 for long-term security.

@_date: 2005-02-16 20:05:03
@_author: David Shaw 
@_subject: SHA1 broken? 
Yes.  The update cannot happen overnight.  I see this like MD5 a few
years back.  It is time to start the migration now because it will
certainly take several years to complete.
As you point out, the first step in the migration is knowing what to
migrate to, and that is not at all clear yet.  Until we know what
we're doing, I think we can do more harm by running around crazy and
changing things without careful study.

@_date: 2005-02-17 00:35:45
@_author: David Shaw 
@_subject: subkeys problem 
I'd need to get a better error report than "subkey errors" to help
you, I'm afraid.
For what it's worth, I pulled your key from all of the servers that
make up subkeys.pgp.net and it was fine on each of them.

@_date: 2005-02-17 02:00:02
@_author: David Shaw 
@_subject: subkeys problem 
Sure, it works fine.
To be sure, they key that is stored on the keyserver is full of all
sorts of bad data (data in the wrong place, etc), but GnuPG doesn't
really care about that, as it skips the bad stuff.  The keyserver
operators may care to figure out how your key was so mangled, but
regular users should just see a good key for you.  GnuPG doesn't even
print out the warnings about skipping bad data unless you ask for it.

@_date: 2005-02-17 04:15:06
@_author: David Shaw 
@_subject: [Announce] Second release candidate for 1.4.1 available 
We are pleased to announce the availability of a the second release
candidate for the forthcoming 1.4.1 version of GnuPG:
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.1rc2.tar.bz2      (2.7M)
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.1rc2.tar.bz2.sig
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.1rc1-1.4.1rc2.diff.bz2 (338K)
An installer for Windows is also available:
 ftp://ftp.gnupg.org/gcrypt/alpha/binary/gnupg-w32cli-1.4.1rc2.exe (1.4M)
 ftp://ftp.gnupg.org/gcrypt/alpha/binary/gnupg-w32cli-1.4.1rc2.exe.sig
SHA-1 checksums for the above files are:
 cfa9d6f4c7a0aa5b58df75e3b5480a8ccf223dea  gnupg-1.4.1rc2.tar.bz2
 21d4c2ef378e89b87123dc97c90989e8f1e09783  gnupg-1.4.1rc1-1.4.1rc2.diff.bz2
 99f3bd0165cbfcbc2b562b42a3e0be64cec09b85  gnupg-w32cli-1.4.1rc2.exe
Please try these versions out and report any problems.
Noteworthy changes since 1.4.0:
    * New --rfc2440-text option which controls how text is handled in
      signatures.  This is in response to some problems seen with
      certain PGP/MIME mail clients and GnuPG version 1.4.0.  More
      details about this are available at
      .
    * New "import-unusable-sigs" and "export-unusable-sigs" tags for
      --import-options and --export-options.  These are off by default,
      which causes GnuPG to not import or export key signatures that
      are not usable (e.g. expired signatures).
    * New experimental HTTP, HTTPS, FTP, and FTPS keyserver helper
      that uses the cURL library  to retrieve
      keys.  This is disabled by default, but may be enabled with the
      configure option --with-libcurl.  Without this option, the
      existing HTTP code is used for HTTP, and HTTPS, FTP, and FTPS
      are not supported.
    * When running a --card-status or --card-edit and a public key is
      available, missing secret key stubs will be created on the fly.
      Details of the key are listed too.
    * The implicit packet dumping in double verbose mode is now sent
      to stderr and not to stdout.
    * Added countermeasures against the Mister/Zuccherato CFB attack
      .
    * [W32] The algorithm for the default home directory changed:
      First we look at the environment variable GNUPGHOME, if this one
      is not set, we check whether the registry entry
      {HKCU,HKLM}\Software\GNU\GnuPG:HomeDir has been set. If this
      fails we use a GnuPG directory below the standard application
      data directory (APPDATA) of the current user. Only in the case
      that this directory cannot be determined, the old default of
      c:\gnupg will be used.  The option --homedir still overrides all
      of them.
    * [W32] The locale selection under Windows changed. You need to
      enter the locale in the registry at HKCU\Software\GNU\GnuPG:Lang.       For German you would use "de".  If it is not set, GnuPG falls
      back to HKLM.  The languages files "*.mo" are expected in a
      directory named "gnupg.nls" below the installation directory;
      that directory must be stored in the registry at the same key as
      above with the name "Install Directory".
    * Add new --edit-key command "bkuptocard" to allow restoring a
      card key from a backup.
    * The "fetch" command of --card-edit now retrieves the key using
      the default keyserver if no URL has been stored on the card.
Happy Hacking,
  David, Timo, Werner

@_date: 2005-02-17 04:40:54
@_author: David Shaw 
@_subject: [PATCH] gnupg.spec [WAS: unable to execute program 
I think this is a good idea.  I don't want to mess about with the
build this close to the 1.4.1 release, but I will revisit this for

@_date: 2005-02-17 16:53:24
@_author: David Shaw 
@_subject: Extracting UserAttribute (photo) 
Try something like
gpg.exe --photo-viewer "C:\Path\Of\Viewer\viewer.exe %i" --edit mustermann The %-escapes are:
 %i is expanded to a temporary file that contains the photo.
 %I is the same as %i, but the file isn't deleted afterwards by GnuPG.
 %k is expanded to the key ID of the key.
 %K is expanded to the long OpenPGP key ID of the key.
 %t is expanded to the extension of the image (e.g. "jpg").
 %T is expanded to the MIME type of the image (e.g. "image/jpeg").
 %f is expanded to the fingerprint of the key.
 %% is %, of course.

@_date: 2005-02-17 17:50:51
@_author: David Shaw 
@_subject: [Announce] Second release candidate for 1.4.1 available 
No, the new spec is in CVS, but I checked it in just after Werner
built 1.4.1rc2.  No worries, it will be in 1.4.1.

@_date: 2005-02-22 14:43:41
@_author: David Shaw 
@_subject: gpg: Oops; keylost! 
Can you send what GnuPG prints after that error?  It indicates what
In general, though, your pubring.gpg is probably corrupt.

@_date: 2005-02-24 23:12:21
@_author: David Shaw 
@_subject: gpg.conf 
The man page gives all the options, but if someone is looking for a
nice project to do, a web page with each option and commentary would
be a great thing to point people to when they have questions.

@_date: 2005-02-24 23:13:31
@_author: David Shaw 
@_subject: Unable to Sign RPM Packages 
Do things work properly without rpm calling gpg for you?  That is, can
you sign any old file 'gpg --sign foo' ?
If so, then you need to ask the rpm folks for help, since gpg is
working properly.

@_date: 2005-02-25 14:45:34
@_author: David Shaw 
@_subject: WARNING: key <KEYID> contains preferences for unavailable 
That warning message means pretty much what it says.  PGP creates keys
with preferences that advertise the use of algorithms that GnuPG
doesn't support.  GnuPG is warning you that if you use that public key
without fixing the preferences, someone may try and follow those
incorrect preferences and send you something you can't decrypt.
Since you mention PGP, it's probably a case of missing IDEA.
Note this only happens when importing a secret key along with a public
key (or importing a secret key for which you already have a public key
or vice versa).
You should answer 'yes' to the question and allow GnuPG to fix your

@_date: 2005-02-25 15:07:48
@_author: David Shaw 
@_subject: WARNING: key <KEYID> contains preferences for unavailable 
To a keyserver or to who you are communicating with?  Yes.  The point
is that your correspondent will use those preferences to decide what
algorithms to use when communicating with you.  He or she needs this
updated key to get the correct algorithm list.

@_date: 2005-02-28 21:27:16
@_author: David Shaw 
@_subject: building gnupg 1.4.0 
It's part of readline.  This is fixed in 1.4.1, but in the meantime,
try building with ./configure --without-readline

@_date: 2005-01-01 15:10:49
@_author: David Shaw 
@_subject: gpg and the new PGP keyserver 
PGP used to have two LDAP keyserver.  The old one at
ldap://keyserver.pgp.com was compatible with any version of GnuPG.
The new one ldap://keyserver-beta.pgp.com is only compatible with 1.4
or later.
Recently, the keyserver.pgp.com hardware melted down, so they pointed
the keyserver.pgp.com name at the keyserver-beta.pgp.com server.  This
breaks things for GnuPG users unless they are using 1.4.

@_date: 2005-01-01 15:48:55
@_author: David Shaw 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
This is a general problem with signing any key that does not have a
direct mapping to a human being.  I did not give a good example of the
problem by citing keys that do have direct mappings to human beings.
So let me use your example of the GD key:
For me, refusing to believe it is the "real" GD key is fairly silly,
of course, not least because its action is very obvious.  We can all
see the signatures it issues.  It's available on a few web sites.
Heck, it even *comes with GnuPG* as one of the sample keys.
However, personally believing this key is the right one, and being
willing to testify to others that this key is the right one is not the
same thing.  It's a fine point.  I do not wish to give the impression
that I am right and others wrong in drawing this point here.  The
existence of the "ownertrust" concept in the web of trust speaks to
the varying opinions about when to sign.
For me, signing the GD key without some higher level of proof (and it
is not clear what that could be for a key that does not identify a
human being), would be akin to signing a key because someone else I
knew signed it.

@_date: 2005-01-01 17:21:01
@_author: David Shaw 
@_subject: signing a robot's key - was: Re: Global Directory signatures 
I think that's a bit of a straw man there.  Nobody that I see in this
discussion is plugging their ears and chanting "la la la la la" about
the concept of role or robot keys.  Keys clearly exist for roles and
robots, and they are clearly widely used.
The original question I asked was not "how can you ever trust a role
key?", but "how can you sign a role key?"  There is a difference
between trusting and using a role or robot key for oneself, and
publicly standing up and asserting that belief for the world.
Please understand: I'm not criticizing your stance here, and I don't
particularly care if I persuade you or anybody to my way of thinking.
I'm genuinely interested in the opinions and rationales of people who
have given this problem thought and then arrived at a different
conclusion than I did.
That conclusion, if anyone cares, is that I will happily sign a role
or robot key if I have actual proof (rather than just firm belief)
that the role or robot key is the right one.  I would, and have,
signed a no-human-name hostmaster or postmaster key if I worked at the
company they were for.  In that case, I was in a position to say
publicly that I knew the key was correct.
I won't sign the GD key without being in that position, though I quite
happily use and believe the GD key is the right one.  Let me ask you
this: did you sign the GD key?  If not, why not?  Clearly you believe,
as I do, that it is the right key.

@_date: 2005-01-01 18:55:42
@_author: David Shaw 
@_subject: RFE: Unsignable keys 
What you suggest is not impossible, but has a number of caveats when
done as part of OpenPGP.  The signature math of OpenPGP does not cover
this sort of case, so such a flag would need to be somewhat advisory.
This isn't to say that advisory flags are useless: most things like
this in OpenPGP are advisory, and they work fairly well.
There are quite a few ways to do this, each with their plusses and
minuses, but it comes down to the interoperability question.  It would
have to be part of OpenPGP (and not GnuPG-specific) if it was to
really work, and some consideration would have to be given to what the
semantics were when an old implementation ignored the flag and signed

@_date: 2005-01-03 00:41:57
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
I'm fairly sure you understand the difference between "active" and
"passive", and if not, it should be quite clear from the context.  I'm
not going to explain it again.
I'm happy to continue having this discussion, but if you would rather
play "neener neener neener" games, I'd just as soon pass.  I'd rather
do something productive.
I'm not as sure as you that the 14 day expiration is intended to be
permanent.  It may be, as it does very well serve to cap the time
after a key has been retrieved from the server but before the client
must go back for a refresh.  The GD works on 6 month increments, so a
6 month signature would seem to be the obvious duration to use, but
that of course does not handle as well the case where the key is
removed from the GD (or replaced within the GD) before 6 months is up.
The user would be forced back to the GD for a new 14-day signature at
which point they would discover that the key is missing so no new
signature would be available.  This makes the key invalid in their
trust calculations.
I don't think that is the intent of the GD.  Rather, the idea is that
if you find a key on the GD, it is a usable key.  Period.  If a key
isn't usable (revoked, expired, etc), it should not be on the GD at
all.  A compromised key would presumably be removed from the GD by the
owner so it could not be served at all.
As before, if the key itself no longer exists on the GD, you will not
get another 14-day signature, and the key will become invalid to you.
Sure, you could dream up a scenario where a key was revoked and then
removed from the GD so the actual revocation was only posted to the
keyserver net, but note that the GD did the right thing for its design
here - it stopped serving the revoked key.  It is not responsible for
serving the revocation, since it only serves keys that are usable.
Shortly after all this happens, the 14-day signature expires and the
GD is completely uninvolved.
Remember that the GD is intended to be the "keyserver of last resort"
for new users.  If it isn't on the GD (or the 3-4 places PGP looks
before it falls over to the GD), the key doesn't exist.

@_date: 2005-01-03 00:47:58
@_author: David Shaw 
@_subject: RFE: Unsignable keys 
No, the flags are protected by a signature.  Think of something like
the "designated revoker" data.  It is part of a self-signature on the
key itself.  It is advisory in the sense that no part of the math
requires an implementation to honor it.  Honoring it is part of the
protocol instead.
Maybe.  The new RFC is very unlikely to specify different signature
math, but who knows what the future will bring?

@_date: 2005-01-03 16:02:26
@_author: David Shaw 
@_subject: problem using keys created with 1.2.1 with 1.0.6 
The OpenPGP protection algorithm for secret keys changed after the
1.0.6 release.  To import a later key into 1.0.6, edit the later key
using the later gpg via 'gpg --simple-sk-checksum --edit (thekey)',
change the passphrase via 'passwd' (you may even use the same
passphrase if you like), then 'save'.
The password change is simply to cause gpg to decrypt and reencrypt
the key.  The --simple-sk-checksum tells it to use the old format when
it reencrypts.
Now export the key and you can import it into 1.0.6.

@_date: 2005-01-03 16:24:52
@_author: David Shaw 
@_subject: Encrypting a file to multiple recipients 
You need to put a '-r' before every recipient.  However, if you
frequently use the same list of recipients, you can stick something
like this into your gpg.conf file:
  group my_list_of_people = recipient_01 recipient_02
Then you can use '-r my_list_of_people' and get both recipients in one

@_date: 2005-01-03 16:39:14
@_author: David Shaw 
@_subject: Global Directory signatures (was Re: GPG wants to check trustdb 
Lovely.  Moving on then, do you see this as something you can resolve
in your keyserver?  I've made the change in GnuPG to not import or
export expired signatures by default.  This is a limited fix, of
course, due to the overlap between an old GD sig expiring and a new GD
sig being issued.  It strikes me that if the goal is to keep the
keyservers clean, then the keyservers need to take action.  There is
only so much that clients can do here.
Incidentally, my concern is slightly larger than what you state above.
It is interesting to me *who* copies keys, but also to *what extent*
the keys are copied.  If the key owner copied the key, we can perhaps
assume they meant to do it; it's their key.  If a key recipient did
it, we cannot make this assumption.  Given current keyservers, we
can't tell the difference so the point is academic, but no matter who
does the copying, a few signatures aren't going to wreak havoc (you
mentioned you had seen extra signatures showing up on only 120 keys
thus far), but a large number of copied keys start looking messy.

@_date: 2005-01-03 19:13:41
@_author: David Shaw 
@_subject: signing a robot's key 
A key that does not have a direct mapping to a human being could be
something like 'postmaster'.  There are humans somewhere there, just
not a direct mapping to one of them.
Even so, there are non-humans in the WoT right now, and have been for
quite a while.  Even back as far as 1994, there was the SLED signing

@_date: 2005-01-04 04:33:34
@_author: David Shaw 
@_subject: Issues with adding UID's 
This is intentional.  If no UID is explicitly set as primary, then
GnuPG uses the most recent UID as the primary.  The reason is that if
someone (for example) gets a new email address, the new UID *should*
be the primary one.
It's certainly possible to come up with an argument why the old UID
should be primary, just as there is an argument why the new UID should
be primary.  The solution is to remove the ambiguity, and set the
primary UID flag when you want a particular UID to be primary.
Just the secret key.  GnuPG doesn't do merging of secret keys, so you
can't export it one place and merge it into another without deleting
the target first.

@_date: 2005-01-04 17:02:46
@_author: David Shaw 
@_subject: GnuPG and LDAP keyserver 
This is a strange response.  Can you add:
  --debug 1024 --keyserver-options keep-temp-files
to your command line and then send me the "tempin.txt" and
"tempout.txt" files?  They will end up in wherever your temp directory
is.  Look for the log line beginning "args expanded to" for the whole

@_date: 2005-01-04 17:37:28
@_author: David Shaw 
@_subject: Problems attemoting to use GPG with a USB watch 
I don't think this will work without further effort (or at least, I'd
be rather surprised if it did).  Perhaps Adam's secring.gpg is
The reason why the locking didn't work is that your watch is formatted
as a VFAT filesystem, as David Champion guessed.  GnuPG uses link() as
part of its file locking scheme, and VFAT doesn't support links.
You have a number of options, one is to use --lock-never as David
Champion suggested; you will of course have to take care not to run
two instances of gpg at the same time.  The other option is to make
the secret keyring read-only.  Read-only files have no need for locks,
and thus are ignored by the locking code.  Of course, read-only files
are read-only, so that may not be useful to you if you want to
actually manipulate your keyring on the watch frequently.  Or you
could reformat your watch as ext2 or 3 (or really, anything that
supports hard links).

@_date: 2005-01-05 23:00:44
@_author: David Shaw 
@_subject: GnuPG and LDAP keyserver 
Looks like two problems here.  First, the LDAP handler is manipulating
line endings.  Second, GPG itself isn't relaxed enough to accept the
key anyway.
Did you compile your own GPG?  If I send you a patch, can you compile
and test it?

@_date: 2005-01-07 04:19:07
@_author: David Shaw 
@_subject: Weakness in the keyserver network (Was Re: Global Directory 
The whole meaning of non-exportable is that the signatures are, well,
non-exportable.  Having the GD issue non-exportable signatures rather
defeats the point of the thing.  Forgetting for a minute the protocol
issues with this, a simple practical reason why this won't work is
that GnuPG won't import a non-exportable signature without modifying
the config, and PGP won't do it at all.  Mandating code changes in the
clients isn't going to happen since it would require all GD users to
upgrade, which is unrealistic.
You call the GD a "nuisance".  I don't agree.  We can have that
discussion if you like, but perhaps more interesting is that the GD,
nuisance or not, is illuminating weaknesses in the keyserver network.
The keyserver network is dependent on clients being well-behaved.
That's a recipe for abuse if I ever saw one.
To make an extreme example, say there was a rogue signer, pumping out
thousands of signatures a day onto the keyserver network, all set to
expire in a week.  Due to the design of the web of trust, there is no
real impact on it.  However, there is an ugliness to all those
signatures.  UI displays (e.g. vindex) are rendered almost useless.
Over time, this approaches a denial of service when the signed keys
get so big they can't easily be downloaded.  The keyserver database
gets huge.  Lots of bandwidth is used to sync all of those signatures
between the various nodes in the keyserver net.  It gets messy fast.
Now, to be sure, this isn't a brand new keyserver attack that nobody
ever thought of, plus the GD is nowhere near as bad as my example
above.  The GD behavior (being a very prolific signer, with no
particular effort taken to prevent signatures leaking from the GD onto
the keyserver net) is just a reminder that the keyserver net is
vulnerable to this sort of flooding.
If you need a reason other than someone just being mean, spammers
could fairly easily get keyservers to display their ads with this sort
of flooding.  There's incentive right there.  You'll forgive me for
not going into excessive detail how exactly to do it, I hope :)

@_date: 2005-01-07 05:58:29
@_author: David Shaw 
@_subject: Weakness in the keyserver network (Was Re: Global Directory 
No, you can use any version of GPG through the web interface.  The new
LDAP stuff in 1.4 just lets you search the keyserver directly.
Incidentally, the new LDAP code wasn't added to talk to the GD.  It
was added to allow users to store their keys in their own LDAP
servers.  Corporate environments are big on this.  It just so happens
that the GD uses the same LDAP schema, so it all worked painlessly.
Lightly consulted.  I suggested some ways to handle signature and
designated revocations.  No idea if they were already doing it in a
safe way, but we discussed it.
It's not.  Nor is that the point.  The point is that the keyserver net
was vulnerable, but nobody really cared.  Now there is something that
will eventually cause a problem due to this vulnerability.  Plus, the
comparison is apples and oranges.  Hammering a web server with
requests versus uploading terabytes of garbage data that will be
replicated faithfully among many servers.  Pretty nice amplification
there for an attack.
Quite so, but this is a massively more difficult attack against the GD
than it is against the keyserver net.  The GD requires mailback
authentication, so the pace of adding keys cannot be nearly what it is
on the keyserver net where you can just add keys directly 24/7.
Plus, remember that unlike the keyserver net, the GD is under the
control of a single entity.  Abuse it too much, and they can simply
lock you out and refuse to accept more keys and/or key approval web
hits from your IPs.  That simple response doesn't work on the
keyserver net, where you'd need to get all operators to agree to block
an abuser, plus the abuser can resort to other means of getting the
keys in (email would be a good way in).  It's not impossible to block
an attacker from sending to the keyserver net, but it is certainly
vastly more difficult.
*You* have decided that the GD output is garbage.  Many other people
clearly don't think so.  Can we please get past the "it's bad" "no, it
isn't" ?  I'm not going to convince you, and you're not going to
convince me, so why bother?  We both agree that there is an
unfortunate impact on the keyserver net, so let's at least try and
accomplish something useful here.
Who said anything about cryptographic checks?  That's just one way to
handle the problem, and it opens you up to a DoS like you say.  Why
not start with something like not accepting or sending out expired
sigs?  Periodically, vacuum expired sigs from the database.  You don't
need crypto for that.
There is lots more that can be done, including just ditching any GD
signatures before they even get to the database.  That doesn't require
crypto either.
Doing sig trickery like this will help with the GD problem, but it's
not much of a defense against a general flooding attack,
Which is why it's not a good idea for keyservers to display photo IDs
from unauthenticated keys in searches.  The biglumber keyserver does
this right.

@_date: 2005-01-07 05:59:51
@_author: David Shaw 
@_subject: GPG <> PGP6 subkey selection 
Unless told otherwise, GnuPG will use the most recent subkeys, so if I
understand what you are asking, you don't need to do anything for
GnuPG to use the new subkeys.

@_date: 2005-01-07 14:48:08
@_author: David Shaw 
@_subject: Weakness in the keyserver network (Was Re: Global Directory 
Indeed.  Honestly, I'm not sure of what the answer is here, or even if
there is one without a redesign of the keyserver net.  A CA that leaks
onto the keyserver net can be handled fine by a "no sigs from key
xxxxx" rule, but an attacker would use using different keys to make
the sigs to get around the rule (or just upload different keys

@_date: 2005-01-07 23:38:22
@_author: David Shaw 
@_subject: Weakness in the keyserver network (Was Re: Global Directory 
I give up.  When you actually want to discuss possible solutions for
the problem at hand, let me know.  I'm not all that interested in the
"The GD is eeeeeevil, and if it just disappeared the world would be
the Way I Want It To Be" stuff.
Fact: The GD exists.
Fact: It makes signatures.
Fact: They leak.
Now, you can deal with the facts, or you can complain.  Thus far, all
I'm seeing is complaining, and that bores me, so... bye.

@_date: 2005-01-09 03:27:40
@_author: David Shaw 
@_subject: Gpg error 
Hard to say, but as a guess you have your public and secret keyrings
switched, or somehow ended up with a secret key in your public
keyring.  Do other things work properly?

@_date: 2005-01-11 04:11:26
@_author: David Shaw 
@_subject: 1.4.0a won't retrieve key from keyserver? 
Yes.  The keyserver stuff is pretty significantly different, but many
people are using 1.4.0a on win32 without a problem.
Can you re-run the keyserver that failed command with
'--keyserver-options keep-temp-files' set?  Reply with the tempin.txt
and tempout.txt files.  The tempin.txt and tempout.txt files will end
up in a directory named gpg-XXXXXX under your temp dir (usually

@_date: 2005-01-11 17:09:34
@_author: David Shaw 
@_subject: 1.4.0a won't retrieve key from keyserver? 
Ah, this is a win32-specific bug that was fixed already.  The fix will
be part of 1.4.1.

@_date: 2005-01-12 09:43:19
@_author: David Shaw 
@_subject: gpg process 
Yes, gpg needs to be able to read the file to encrypt it.  It opens
the file, filters it through the ciphers, and writes a new (now,
encrypted) copy out.

@_date: 2005-01-12 23:33:45
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
Hmm.  What win32 platforms have MAPISendMail() present?

@_date: 2005-01-13 16:43:58
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
That's a good point.  I'll take a look at moving gpgkeys_mailto to C,
but I'll need a few volunteers to help test the win32 part.  I don't
have easy access to a win32 box any longer.

@_date: 2005-01-14 17:56:58
@_author: David Shaw 
@_subject: Encrypt & Sign 
The reason is that by doing sign & encrypt (that is, sign a document
and then encrypt the signed document) you protect the identity of the
signer.  There is no particular reason why one is better than the
other, but generally people like the identity protection aspect of

@_date: 2005-01-14 20:06:49
@_author: David Shaw 
@_subject: Encrypt & Sign 
Maybe, maybe not.  It depends on what you can persuade the legal
system where it happened what the significance of it should be ;)

@_date: 2005-01-15 19:03:24
@_author: David Shaw 
@_subject: 2 ways of signing files 
No.  They are completely different and unrelated.  Scenario 1 is you
signing Blake's key.  Scenario 2 is you signing a document.  The first
is you making a statement about Blake's key.  The second is you making
a statement about the document you are encrypting.

@_date: 2005-01-16 22:08:52
@_author: David Shaw 
@_subject: auto sign files 
Hold on here... this is getting a little hysterical.
There is nothing at all wrong with signing from a script, automated
signing, or any variation thereof.  Just like any signing, the crucial
bit is to understand what you are doing, and why, and what the risks
are.  Once you have that understanding, determine if the risks are
acceptable to you or not.  Just as it is a mistake to relax your guard
too much, it is also a mistake to be so secure that you can't actually
get your work done.
The risks of automated signing are mainly that someone may break into
your machine and steal your key.  They can then use this signature in
various ways to impersonate the script that is making the signatures.
Take a moment to think about why you want the setup you describe, and
what would happen if the key was stolen.  Remember that once the
message leaves your unattended signing machine it is identical to the
message that would leave the machine if you had 50 armed police
officers guarding you as you typed in your 4-paragraph passphrase.

@_date: 2005-01-18 20:57:04
@_author: David Shaw 
@_subject: auto sign files 
Pretty much.  It depends on the overall system in which the signature
is being used.  There aren't any hard and fast rules, except that you
must look at the whole system and not just a part.  For example, in
the automated signing example, the recipient is part of the system,
and therefore needs to know that the signatures are being issued by a
machine.  The recipient can then decide what necessary countermeasures
(if any) are warranted against the chance of a compromised key.

@_date: 2005-01-18 21:21:53
@_author: David Shaw 
@_subject: GnuPG 1.4.0 and PGP/MIME signatures 
Shortly after the release of GnuPG 1.4.0, an unexpected problem was
reported while using it with mail programs that support PGP/MIME.
After some research, it turned out that some mail programs did not
perfectly follow the PGP/MIME specification, RFC-3156.  The end result
was that PGP/MIME signatures made with one of these programs and GnuPG
1.4.0 were not always verifiable on other mail programs that did fully
follow the specification.
The PGP/MIME specification requires that end-of-line whitespace
(generally spaces) be protected against removal by the signing
program.  It turns out that several programs were using GnuPG to
remove the end-of-line whitespace rather than protecting it
Most of these mail programs were fixed shortly after the 1.4.0
release.  Nevertheless, to give some time to the mail program
developers who have not yet implemented a fix, GnuPG 1.4.1 will
contain a new option: --rfc2440-text.  This option, which is on by
default, causes GnuPG to use the old text encoding that was used in
the 1.2.x and 1.3.x releases of GnuPG.  At some point in the future,
after there has been sufficient time for the various mail programs to
fix the problem and release an update, this option will be switched
In the meantime, once 1.4.1 is out, an easy way to tell if your
particular mail program correctly implements PGP/MIME signing is to
set --no-rfc2440-text, and send yourself a signed message that has a
number of blank spaces at the end of a line.  Then, set --rfc2440-text
and attempt to verify the signature.  If the signature does not verify
correctly, you may wish to contact the developer of your mail program
for an update.

@_date: 2005-01-18 21:29:57
@_author: David Shaw 
@_subject: Is there a gpgkeys_mailto for Win32? 
I have a general question with all these discussions of
gpgkeys_mailto.  What is the interest here?  Are people actually
*using* the email keyserver helper from GPG, or is this just a desire
to improve Win32 support in general?
It seems to me that the email keyserver helper is a pretty lousy way
to get keys from GPG.  All GPG does for you is send an email with a
particular subject line.  It doesn't even import the key when it
eventually arrives.

@_date: 2005-01-19 00:29:24
@_author: David Shaw 
@_subject: any data file 
The parameter you are looking for is --textmode.  That option tells
GnuPG to use canonical text format to send, and tells PGP 8 to
un-canonicalize on the receiving side.

@_date: 2005-01-19 15:33:01
@_author: David Shaw 
@_subject: [Fwd: OpenPGP javacard implementation] 
That's pretty cool.  The Java Ring is really a Java card underneath,
so you could carry the applet around on your finger.

@_date: 2005-01-20 15:01:03
@_author: David Shaw 
@_subject: [Fwd: OpenPGP javacard implementation] 
They're serial devices underneath it all.  There are drivers for
various platforms, including *nix, here:

@_date: 2005-01-20 19:09:22
@_author: David Shaw 
@_subject: Encryption algos 
The algorithm list is defined by OpenPGP.  If the OpenPGP standard
gets more algorithms, we'll likely support them.  I don't think it it
likely to happen (I'd argue against it) but you can make a proposal to
the OpenPGP working group if you like:

@_date: 2005-01-26 01:32:00
@_author: David Shaw 
@_subject: Are all the UIDs on a key supposed to be equal? 
No, you generally designate the UID you want to be primary by using
the --edit-key command "primary".  If you don't pick one, then the
primary is assumed to be the most recently added UID.

@_date: 2005-01-26 22:59:08
@_author: David Shaw 
@_subject: Extracting UserAttribute (photo) 
photo-viewer "cat > ~/photoid-for-key-%k.%t"
Then view the photo.

@_date: 2005-01-29 14:56:45
@_author: David Shaw 
@_subject: tempout.txt 
This is a general thing for everyone: If you're going to post things
to get help, please don't "sanitize" them for "security" to the point
where they are useless as diagnostic tools.  You've removed at least
4-5 lines from that.

@_date: 2005-01-29 16:22:09
@_author: David Shaw 
@_subject: tempout.txt 
There is a whole other file that will have lines like "COMMAND",
"HOST" and the like.

@_date: 2005-07-03 22:59:00
@_author: David Shaw 
@_subject: your mail 
Feature.  Those dashes are part of the protocol, and are necessary to
protect your text from the clearsigning armor header lines.  Note that
when you verify the signature, the extra dashes are removed.

@_date: 2005-07-06 16:17:30
@_author: David Shaw 
@_subject: pgp and gpg 
No, they are different.  In the first case, the signature did not
verify.  In the second case, it did.  I'd need a lot more information
(if possible, a copy of the message) to say why.

@_date: 2005-07-07 23:31:16
@_author: David Shaw 
@_subject: Security problem with zlib 
Yes and no.
If you compile GnuPG on a system that has no zlib (or build with
--with-included-zlib), the zlib that is included with the GnuPG
distribution is used.  This zlib is NOT vulnerable to the recent
If you compile GnuPG on a system that has a zlib, the system zlib is
used.  Your system zlib may or may not be vulnerable to the recent
problem.  If your system zlib is vulnerable, then I strongly recommend
that you upgrade :)

@_date: 2005-07-08 05:29:04
@_author: David Shaw 
@_subject: set-policy-url 
No.  They both mean the same thing.  The only difference is that
--sig-policy-url is used when signing a file (i.e. --sign), and
--cert-policy-url is used when signing a key (i.e. --sign-key).

@_date: 2005-07-09 04:20:08
@_author: David Shaw 
@_subject: Security problem with zlib 
Basically, yes.  It's unclear if the bug is exploitable beyond
crashing the process that is using zlib, but the crash is certainly
Oddly, I haven't seen any mention of this on the zlib main web site -
just on bugtraq and the CVE site.

@_date: 2005-07-10 15:50:21
@_author: David Shaw 
@_subject: Revoking Keys 
I'm afraid I don't understand exactly what you do and don't have left
from your crash.  Do you have the secret keys for the keys you want to
revoke or not?

@_date: 2005-07-10 20:53:34
@_author: David Shaw 
@_subject: revokation thing 
gpg --gen-revoke (thekey)
This outputs the revocation certificate.  Save it somewhere, and
you're done.

@_date: 2005-07-11 04:07:53
@_author: David Shaw 
@_subject: how do I excrypt a file so that it can be opened with CA PGP 
There are many different versions of PGP.  What you are doing will
work with some, but not others.
In general, if the version of PGP you are using is even vaguely
recent, you don't need any options at all.

@_date: 2005-07-13 00:19:41
@_author: David Shaw 
@_subject: Direct LDAP access 
A very easy way to do this is to write your code to "import" the key
from the LDAP server into a brand new empty keyring, and then delete
it afterwards.
The current LDAP code can specify the base.  Use something like
  keyserver-options basedn=whatever-you-like

@_date: 2005-07-20 16:13:24
@_author: David Shaw 
@_subject: catching output from gpg --verify 
The problem here is not really that you can't capture the output, but
that you shouldn't capture the output.  The output of GPG is very
subject to change, and every time we change GPG, we'll break your
There are two good ways to do this safely:
1) Use something like:
   gpg --status-fd 1 --verify kernel_name_sig kernel_name 2>/dev/null
That will cause a machine readable series of messages to appear on
stdout.  If you see a VALIDSIG tag, you know the signature is good.
2) Use gpgv, which is just a signature verification tool and exits 0
   if the signature is good, and non-0 otherwise.

@_date: 2005-07-21 16:42:34
@_author: David Shaw 
@_subject: same key: pgp 2.6 version and gpg version: keyserver 
There is only one version of the key whether it is in PGP or GPG.  Go
ahead and submit it to any keyserver you like.

@_date: 2005-07-21 19:57:10
@_author: David Shaw 
@_subject: same key: pgp 2.6 version and gpg version: keyserver 
You changed the secret key.  The public key is the one that goes on
the keyserver and is exactly the same between PGP and GPG.

@_date: 2005-07-22 18:28:18
@_author: David Shaw 
@_subject: Filename for digests 
Red Hat and others use a filename of "MD5SUM", which is a clearsigned
file containing the human readable MD5 hashes.  I like your CHECKSUMS
idea better since MD5 isn't the way to go any longer.

@_date: 2005-07-23 01:29:53
@_author: David Shaw 
@_subject: Filename for digests 
Sure they are.  Or rather, a hash makes a very effective checksum, and
that's how we're talking about using them, as a redundancy check.
Where do you think the "sum" from md5sum/sha1sum/etc comes from?

@_date: 2005-07-23 04:22:25
@_author: David Shaw 
@_subject: Changing the email address on an existing key...how? Should I? 
There isn't a way to edit an email address on a key.  That is a
feature, for various reasons.  What you need to do is generate a new
address on that key, and then revoke the old address.  Some people
have many old addresses (revoked) on their keys.  Some people just
make a whole new key.  It's really a question of how easy it is in
your environment to make a new key, and whether you have signatures
(on the non-revoked user IDs) that you want to keep, etc.

@_date: 2005-07-25 02:56:10
@_author: David Shaw 
@_subject: gpg doesn't know 
Corrupted message.  In this particular case, corrupted ascii armor.

@_date: 2005-07-28 19:58:59
@_author: David Shaw 
@_subject: Best/correct way to back up keys and configuration? 
One advantage to using --export-secret-keys and --armor is that you
can print the secret key out and in a worst-case scenario, type it
back in again.
Not a replacement for regular backups of course, but unlike CDR and
floppies, ink on paper in the dark can last longer than you and I

@_date: 2005-07-30 02:52:58
@_author: David Shaw 
@_subject: Entropy in ascii-armored output? 
ASCII armor is just a base64 transformation of some data, so if the
original data was random, then the armor is as well.  If you do:
 cat /good/random/source | gpg --enarmor
you'll get armored random data.
However, it takes more armor to get to the same amount of random data,
due to the expansion that base64 does.  For example, 128 digits of
random data takes 171 armored digits (I'm not counting padding and
checksum for now).  This means that if you take 10 digits of armor,
you're not getting 10 digits of randomness.  Combine that with the
knowledge of the valid armor characters (a-z, A-Z, +, and /), and you
can set yourself up with a passphrase that is weaker than you think it
All that said, the bottom line is that if the source is random, the
armor is too.

@_date: 2005-07-31 03:24:39
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.4.2 released 
Thought you'd get a kick out of that...
Note that in the next release of GnuPG, --with-libcurl will be the
default.  (So the more people who try it now, and report back any
problems, the better).

@_date: 2005-06-01 01:45:32
@_author: David Shaw 
@_subject: Pref 
No difference.
Yes, Z is compression (think "Zip").
Do "gpg.exe -v --version" to see the algorithm numbers.
I'm not sure what you're asking here.

@_date: 2005-06-01 21:42:02
@_author: David Shaw 
@_subject: Pref 
Yes, you will.
However, why are you doing this?  GnuPG automatically does this for

@_date: 2005-06-01 22:08:40
@_author: David Shaw 
@_subject: Pref 
Yes, but this is a bad mistake to make.  If an algorithm does not
appear in someones preferences, then it shouldn't be used.  For
example, IDEA is an optional algorithm in OpenPGP.  If your
administrator decides that everyone should use IDEA, that will mean
that some users will not be able to read the message.
The whole point of preferences is for the users to tell you what
algorithms they can handle.  Overriding this means that the users are
getting something they can't handle.
The only safe way to do this is to either do nothing and let the
automatic algorithm selection system do its job, or use
--personal-xxx-preferences which works within the preference system to
pick an algorithm (and won't pick it if it means violating the

@_date: 2005-06-02 22:19:52
@_author: David Shaw 
@_subject: compress-algo vs (cipher-algo and digest-algo) 
You can use names in all of them.  Early versions required numbers in

@_date: 2005-06-04 04:32:35
@_author: David Shaw 
@_subject: Set date for signature to expire 
Set ask-cert-expire in yout gpg.conf or on the command line and you'll
be asked when the key signature should expire.

@_date: 2005-06-04 15:41:01
@_author: David Shaw 
@_subject: How to delete superceded self signatures? 
Funny you should mention that....  Install the 1.4.2 release
candidate, do --edit-key and then "clean sigs".  This is a new feature
in 1.4.2, and I'm still playing around with ways to tie it into export
and import (optionally).
Anyway, if you do "clean sigs", it'll strip any superceded sigs.

@_date: 2005-06-04 16:44:14
@_author: David Shaw 
@_subject: How to delete superceded self signatures? 
Keyservers do not have the ability to verify signatures (no crypto at
all, in fact), and thus cannot do anything other than store all
packets.  This is why they never go away on keyservers.

@_date: 2005-06-05 00:54:05
@_author: David Shaw 
@_subject: subpacket of type 20 has critical bit set 
Subpacket 20 is a signature notation.  What that error means is that
someone put in a signature notation that GnuPG doesn't understand (it
only understands one notation - the PGP/MIME vs partitioned one that
the pgp.com folks use).  Since the notation was marked as critical,
this means that GnuPG will reject the signature.

@_date: 2005-06-05 00:56:21
@_author: David Shaw 
@_subject: GnuPG Clearsign vs. PGP/MIME Signing 
When at all possible, use PGP/MIME.  It's automatically handles all of
the little fussy things that cause signatures to become invalid after
being mailed.  Plus, it handles attachments.  Plus, it handles
character sets that aren't US-ASCII.  Plus, plus, plus.

@_date: 2005-06-05 00:57:37
@_author: David Shaw 
@_subject: GnuPG Clearsign vs. PGP/MIME Signing 
Possibly the confusion is that RFC-2015 was updated by RFC-3156.  You
should do things the 3156 way.

@_date: 2005-06-05 04:09:22
@_author: David Shaw 
@_subject: GnuPG Clearsign vs. PGP/MIME Signing 
One or two, yes.  Mainly that there are programs out there that - even
this many years later - don't understand it.  Outlook is the chief
culprit here.

@_date: 2005-06-06 17:02:35
@_author: David Shaw 
@_subject: Additional self-signature 
Yes.  This will happen with any version.  It depends on what version
of GnuPG generated your key, and not on what version you are importing
This will be an option in 1.4.2, but we're still deciding what the
user interface should be.
For now, you can do --edit-key and then "clean sigs" to remove this
(and other non-useful) signatures.

@_date: 2005-06-08 05:07:50
@_author: David Shaw 
@_subject: How to use a revokation key 
Are you asking how to add a designated revoker to a key or are you the
designated revoker and you want to issue a revocation for a key?
For 1, do --edit-key thekey then "addrevoker".
For 2, do --desig-revoke thekey

@_date: 2005-06-14 14:19:10
@_author: David Shaw 
@_subject: import pgp public key in gnupg 
Judging byt eh "algorithm 100", I suspect that key is one of PGP's
X.509 hybrids.  GnuPG does not support that.

@_date: 2005-06-14 15:10:25
@_author: David Shaw 
@_subject: Set date for signature to expire 
In general I agree.  There is one spot in GnuPG where the behavior is
slightly different than this - if you sign a key that has an
expiration date (key expiration), then by default the expiration date
of your signature will be that date.  This was added because in v4
OpenPGP keys, there is no notion of a "hard" expiration date.  We
currently only have a "soft" expiration date that can be extended.
It's one of those little fiddly details that come up now and then.
They're also useful for a CA or a CA-like entity, who want to verify
for a artifically short period of time.  For example, something like
keyserver.pgp.com, which verifies only for 2 weeks to force users of
your key to refresh frequently.  Or take a CA that sells
certifications - they want you to buy another signature after a year

@_date: 2005-06-21 15:08:03
@_author: David Shaw 
@_subject: How to import a secret subkey? 
You can't.  GnuPG does not currently support merging secret subkeys.
To do it, you need to delete the secret key on the second machine and
re-import the whole key.

@_date: 2005-06-22 20:21:11
@_author: David Shaw 
@_subject: Message Digest 
GnuPG supports all of the SHA-2 hashes (256, 384, 512).

@_date: 2005-06-23 14:30:15
@_author: David Shaw 
@_subject: is gnupg can retrieve only ascii keys from http? 
That's correct.  At some point, I may change this, but it is not
currently a feature.

@_date: 2005-06-27 02:03:13
@_author: David Shaw 
@_subject: UTF-8 support 
It's already in the latest release candidate for 1.4.2.

@_date: 2005-06-27 06:28:48
@_author: David Shaw 
@_subject: "--for-your-eyes-only" 
I'm afraid I don't know what this means.  GnuPG has no such 'long
headers', so I assume you're calling it from some front end.
In that case GnuPG discards the text and does not save or display it.

@_date: 2005-06-28 05:14:45
@_author: David Shaw 
@_subject: "--for-your-eyes-only" 
If I understand your question, no, there is no secure viewer built
into GnuPG.  There are many reasons, but two good ones are that GnuPG
is a command line application, and you can't really make a secure
viewer on the command line, and by its nature a secure viewer would
not be nearly portable enough.
However, GnuPG can call other programs to do other tasks (keyserver
access programs, JPEG viewers for photo IDs), so it's not impossible
that GnuPG could call an external secure viewer program.  I don't know
of one offhand though.

@_date: 2005-03-01 18:43:51
@_author: David Shaw 
@_subject: key edit question // adding a comment 
The comment is part of the user ID.  If you want a new comment, you
need to make a new user ID.

@_date: 2005-03-01 19:06:18
@_author: David Shaw 
@_subject: key edit question // adding a comment 
Pretty much.  Right now, comments are part of the user ID.  You can
use notations or the like to add other text to a key if you like, but
the comment field that is part of the user ID is, well, part of the
user ID.

@_date: 2005-03-01 19:44:12
@_author: David Shaw 
@_subject: [OT] Re: useless test keys and keyservers 
This reminds me of something that happened back in the PGP 2 days.
The web of trust was a lot smaller than it is today, and someone took
it upon themselves to duplicate it by making all the keys themselves,
and recreating the various inter-key links to match the real web.

@_date: 2005-03-01 20:52:42
@_author: David Shaw 
@_subject: Create a Key using a script? 
Read the "Unattended key generation" section of the doc/DETAILS file.

@_date: 2005-03-01 20:54:25
@_author: David Shaw 
@_subject: correspondence between pref notications and algo's 
RFC-2440.  You can also get a listing with 'gpg -v --version'
"pref" isn't that useful any longer now that 1.4 is out.  "showpref"
is the way to go since it actually gives the algorithms by name.

@_date: 2005-03-01 21:15:21
@_author: David Shaw 
@_subject: Create a Key using a script? 
It is part of the distribution.  If you can't find it in the materials
you have, just download the latest release.  It's in the doc/

@_date: 2005-03-03 13:59:18
@_author: David Shaw 
@_subject: gpg: Oops; keylost! 
Yep.  You have a secret key in your public keyring.  Note the first
line after the "key lost" message.

@_date: 2005-03-03 15:08:09
@_author: David Shaw 
@_subject: gpg: Oops; keylost! 
There are a number of ways to fix it, but before we try those, can you
try this:
gpg --no-default-keyring --keyring ./fixed-pubring.gpg --secret-keyring ./fixed-secring.gpg --import /path/to/your/broken/pubring.gpg
If that works, you should end up with two new files:
fixed-pubring.gpg contains the public keys, and fixed-secring.gpg
contains the secret keys.
Then you can --import the fixed-secring.gpg file to put the secret key
where it belongs, and replace your pubring.gpg with fixed-pubring.gpg
to put the public keys where they belong.

@_date: 2005-03-03 21:08:04
@_author: David Shaw 
@_subject: group options 
I tried this using your conf file with both 1.4.0, and 1.2.8.  It
works fine for me.

@_date: 2005-03-03 21:26:07
@_author: David Shaw 
@_subject: group options 
The latest for AIX should be the same as the latest for any Unix-ish
machine: 1.2.7 or 1.4.0.  You should be able to drop in the binary
without affecting anything.

@_date: 2005-03-03 21:40:23
@_author: David Shaw 
@_subject: group options 
Yes.  That command doesn't mean anything.  The options mean, in order,
encrypt, textmode, ascii armor, decrypt.  You have to pick either
encrypt or decrypt as doing both would result in nothing happening.
Also, --group doesn't go on the command line.  You use the group name
as a recipient (-r HlthStream).

@_date: 2005-03-10 03:01:20
@_author: David Shaw 
@_subject: Preventing temporary files? 
That's a lock file.  It is needed to prevent more than one instance of
GnuPG from modifying keyrings (which would naturally corrupt them).
If you can guarantee this exclusion outside of GnuPG, then see the
--lock-never option in the manual.

@_date: 2005-03-10 03:03:51
@_author: David Shaw 
@_subject: keyserver 
It depends on what kind of keyserver you have set up.  If it's the
OpenLDAP sort, then they don't sync with other servers (except in the
LDAP sense of sync - and there aren't any public servers that sync
that way).  If it's SKS or PKS, then you can sync via email.
Your best bet is to subscribe to the pgp-keyserver-folk list at:
   Nearly every operator of a public keyserver is a member, and you can
get all the information you need there.

@_date: 2005-03-10 14:14:37
@_author: David Shaw 
@_subject: keyserver 
horowitz.surfnet.nl is not the "OpenLDAP sort" of keyserver.  It's one
of the old NAI keyservers.  They're sort of LDAP on the front end, but
not really.  I'm not even sure this is still sold as a product,
actually.  pgp.com runs two keyservers: one NAI and one OpenLDAP.
Bottom line is, they're not the same thing.
This is silly.  If the lists.alt.org version of the list is broken, is
there a reason why not to fix it?  And if it isn't going to be fixed,
why not just make a new list (or promote the backup) and be done with
it rather than have two lists, neither being the One True List?

@_date: 2005-03-10 14:20:40
@_author: David Shaw 
@_subject: Trust model: classic or pgp? 
That is the difference.  The "pgp" trust model is identical to
"classic" except that "pgp" supports trust signatures, and "classic"
doesn't (it treats them the same as any other signature).
I'm not quite sure what you're asking.
You probably were using GnuPG 1.2.x or earlier before you upgraded to
1.4.  In this case, your trustdb was created as "classic", and so
GnuPG 1.4 is just respecting that.  If you want to force an upgrade to
"pgp", do
     gpg --trust-model pgp --check-trustdb
After that, you can just do --check-trustdb as before, but it'll use
the "pgp" trust model calculations.
Incidentally, you can similarly switch from "pgp" to "classic" by
     gpg --trust-model classic --check-trustdb
As to whether you want to do this or not, it's up to you.  If you
don't use trust signatures, then there is no benefit to using the
"pgp" model.  No real harm either, though.

@_date: 2005-03-10 15:20:36
@_author: David Shaw 
@_subject: Proxy still not work 
There have been a few reports of proxy problems in 1.4.0.  Can you try
something for me?  Instead of using:
   keyserver-options honor-http-proxy
try this:
   keyserver-options http-proxy
Let me know if that helps.

@_date: 2005-03-10 15:48:50
@_author: David Shaw 
@_subject: Encrypt - but no such user-id 
Can you switch your language to English and repost the messages you
got?  I can probably help, but unfortunately I can't read what you

@_date: 2005-03-10 19:51:16
@_author: David Shaw 
@_subject: How to extend subkey's expiry date? 
It somewhat a matter of personal taste, but in general, it's a good
idea.  The ability to replace subkeys periodically is one of the
reasons for subkeys.

@_date: 2005-03-15 16:14:50
@_author: David Shaw 
@_subject: disgest-algo question 
Your signature says you are using GnuPG 1.2.5.  If you want to use
SHA256, upgrade to 1.4.0 or later and put:
in your gpg.conf file.

@_date: 2005-03-16 02:02:09
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.4.1 released 
While I'm all in favor of people using (and testing) the cURL support,
please do remember it's still experimental.

@_date: 2005-03-17 05:45:51
@_author: David Shaw 
@_subject: gpg: WARNING: Using untrusted key! 
It means that you have "--trust-model always" set.  GnuPG is warning
you that it isn't checking trust.

@_date: 2005-03-17 14:22:12
@_author: David Shaw 
@_subject: gpg: WARNING: Using untrusted key! 
No, as you discovered, you can still encrypt to any key you like
(though GnuPG may ask "are you sure").  --trust-model always is really
a special case for use in special situations (scripts or situations
where the trust is checked outside of GnuPG).  It completely bypasses
all trust and signature checking and assumes all keys are fully

@_date: 2005-03-17 22:12:04
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.4.1 News 
Huh?  Your own experiment shows they are off by default:
They can be turned ON if you want.  Like all --import-options and
--export-options, they apply to --import and --export only.  If you
want them to apply to keyserver operations, list them in
--keyserver-options.  See the manual.

@_date: 2005-03-17 22:15:12
@_author: David Shaw 
@_subject: How to create self-decrypting executable? 
GnuPG is portable to many different operating systems, and so does not
have a SDA feature since it would involve making an executable for
every supported platform.
You can more or less do this yourself by writing a script if you like.
SDAs aren't all that secure either.

@_date: 2005-03-17 23:28:23
@_author: David Shaw 
@_subject: Retaining expired sigs 
I don't agree.  An expired signature is not relevant - it is just
meaningless bytes at this point.  Note also that expired user IDs and
subkeys are, in fact, removed.  That's not new behavior, by the way:
it has been this way for as long as I can remember.
I mean the instructions to put the --import-options and
--export-options in --keyserver-options if you want them to apply to
keyserver operations.  The command line you gave as an example was
incorrect in that you specified --import-options but were doing a
keyserver operation.

@_date: 2005-03-18 05:31:58
@_author: David Shaw 
@_subject: Retaining expired sigs 
To be honest, I don't think I can possibly express just how much I
don't care that "0xB56165AA was signed by 0xCA57AD7C starting on
2004-12-29 while 0x99242560 was signed by it starting 2004-12-08".
All I care is that both signatures have since expired, and are
therefore irrelevant to me.  To say nothing of the fact that anyone
who thinks that OpenPGP has strong date semantics - and bases their
behavior on that - is fooling themselves in a wonderfully large way.
It is not good design to hamper the majority of users to please the
minority of users who like to calculate key signing statistics.  In
any event, I still fail to see a problem here.  Anyone who wants to
import and export expired signatures is free to do so.
Even though the GD prompted this change, this isn't a GD-specific
issue.  Over time, keys build up cruft - expired user IDs, expired
subkeys, and expired sigs.  These items serve no useful purpose for
the vast majority of users.  If someone insists that they are useful
and wants to include them, well, go right ahead.  Just don't bother
the rest of us with it.

@_date: 2005-03-18 16:45:41
@_author: David Shaw 
@_subject: [Announce] GnuPG 1.4.1 released 
With libcurl as well?  Excellent.  There were some problems building
that on MinGW in the release candidate and I'm glad to see the fix

@_date: 2005-03-18 18:19:43
@_author: David Shaw 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
Understood.  I'm just pleased that it builds on MinGW at all.  Build
stuff can be very painful on different platforms.  Now that it builds,
everything else after that is "just a bug" ;)
That would be great, thanks.

@_date: 2005-03-18 19:20:17
@_author: David Shaw 
@_subject: Retaining expired sigs 
That's somewhat impractical.  Should we ban expiring signatures?  You
seem to have a problem with the GD because it issues fast-expiring
signatures, but many people use expiring signatures.  Even if people
issued 1-year signatures, there would be a problem eventually.
In the real world, we cannot control what other people generate.  The
best we can do is "be liberal in what we accept, and conservative in
what we generate".
There is a significant difference.  An expired signature is *expired*.
It's dead as Marley.  A superceded signature is very much alive, and
is used *unless something better is present*.
In GPG, an expiring (but not yet expired) signature will supercede an
earlier signature from the same signer.  Once this signature expires,
it still supercedes the earlier signature (thus effectively disabling
the original signature).  Thus you have a perfectly valid signature
that is disabled by an expired signature.  This is one of those
interesting areas of the trust model where things get fuzzy: it's not
clear what the semantics should be here, since it requires GPG to
guess what the signer "really meant" to say, and worse, guess this
without all the data at hand.
It gets messy very fast: if I sign a key with no expiration, then sign
it again with an expiration, then the second signature expires - is my
original signature still valid?  Maybe I actually revoked the first
signature, but the revocation packet isn't present right now, or was
stripped out by the key owner.  Maybe the second signature was a short
term signature because the original signature wasn't present at that
time.  Add to that the problems of packets being missing and bad
clocks, and it's a very fuzzy question indeed.
I recommend that if people want to replace an earlier signature with a
new, expiring, signature, they first revoke the earlier signature, and
only then issue the new expiring signature.  This way there are much
fewer questions as to the intent of the signer, and many fewer
opportunities for the trust code to guess wrong.

@_date: 2005-03-18 20:34:27
@_author: David Shaw 
@_subject: Retaining expired sigs 
No.  I modified GPG to help remove *expired signatures*.  This has
nothing to do with the GD specifically.  I did, incidentally, consider
a "don't export expired GD keys" flag, but that is not what the
feature is.
I don't disagree with this.  It's not unreasonable to remove them, but
it doesn't happen that way today.  The problem at hand was expired
sigs, so that is what I addressed.
Removing superceded signatures, however, re-raises the semantic
questions I asked in my last mail.  What algorithm runs first: the
"remove superceded" or "remove expired"?  Depending on which runs
first, you can get a different result.
But should it be?  My point is not to say that such-and-such is the
answer.  My point is to say that it is not at all clear what the
answer should be.  I may take some time this weekend and run a few
test cases against other OpenPGP implementations to see what they do.
Only if the right behavior is that expired signatures *should*
supercede earlier, unexpired signatures.
If the answer is that expired signatures should supercede, then the
current implementation of the expired sigs filter is insufficient - it
needs to remove the earlier sigs as well to avoid re-awakening an old
signature.  If the answer is that expired signatures should not
supercede, then the current implementation is correct.
Which do you favor (and why)?  Does every sig stand alone, or can sigs
only be interpreted in terms of a series?
I vaguely lean towards the idea that expired signatures should not
supercede earlier unexpired signatures (the "sigs stand alone"
answer), but only vaguely.  I find the simplicity of it attractive.
Interpreting sigs in a series raises a number of dangerous problems,
like what happens when a sig is "unrevoked" by an attacker by removing
packets from the key.

@_date: 2005-03-18 22:31:55
@_author: David Shaw 
@_subject: Searching Mail Archives 
One good way to search is via google.  Just add "site:lists.gnupg.org"
to whatever you are searching for, and google will restrict matches to
these mailing lists.

@_date: 2005-03-19 07:20:49
@_author: David Shaw 
@_subject: Retaining expired sigs 
Why keep around the last expired signature and remove all others?  I
    d) When stripping a signature, strip all earlier signatures from
       that particular issuer.
Remember that the original thing that spawned this thread was the
desire to keep expired signatures from clogging keys.  In the case
where the latest signature is expired, you don't need to keep *any*
signatures.  Using your desired semantics (superceding), the most
recent sig invalidates all earlier ones.  That leaves you with a
single expired sig, which can be removed since there is no longer an
earlier sig to supercede.
I don't think it's viable to argue the "what if a signature comes
back" game, since if you are presupposing packet manipulation, then
most of the discussion we are having here is moot anyway.
Keep reading to the end of 5.2.3.3.  The draft, in fact, intentionally
does not answer the question of multiple self-sigs.  There is some
advice about interpreting selfsigs as narrowly as possible, and
biasing towards more recent, but "An implementation that encounters
multiple self-signatures on the same object may resolve the ambiguity
in any way it sees fit" means pretty much what it says.
I'm not adverse to changing the code to implement superceding, but I
don't think you can (or really need to) rationalize it from 2440bis.
Remember that OpenPGP does not really specify validity semantics.
Unfortunately (or fortunately depending on how you look at it), some
semantics have crept into what is supposedly just a message format
document.  In fact, this is another grey area: subkeys can
theoretically be unrevoked by issuing a new binding signature, just
like user IDs can.  GnuPG doesn't do this for simplicity, but that's
an implementation choice, and not specified (either way) in the
Grey area again.  I happen to agree with part of what you say
(non-revocable sigs can be superceded), but this is not specified in
the standard anywhere.
Dragging the conversation out of the standard and into implementation
details for a moment, I'm rather inclined to change the expired-sigs
trimming code to implement the change (d) from above.  It's consistent
and safe from signature resurrection problems.

@_date: 2005-03-19 20:22:49
@_author: David Shaw 
@_subject: Retaining expired sigs 
This troubles me a bit, as it is getting into packet manipulation
games.  It's hard to say which packets an unsynchronized keyserver (or
worse, an attacker) will suddenly resurrect.  However, I do agree it
does no harm to do this, and might help in some cases.  Ok.
I agree.  It's not just expired and superceded signatures.  There are
a good number of other semantic questions that are not covered in 2440
or 2440bis.  For example, the so-called "PGP trust model" is not
covered anywhere.  This is historical: the original plan for the IETF
group was that there would be multiple specifications (a message
format document, a trust model document, etc).  Unfortunately, only
the message format document was written, and it became 2440.
I'm not sure I agree with this.  I was under the impression you were
arguing for something else, so let me make sure we're both talking
about the same thing.  Given this case:
One way of looking at this is the end result is nothing.  That is, the
revocable sig of 2-Jan-2000 has superceded the non-revocable sig of
1-Jan-2000, and then the revocation has revoked the sig of 2-Jan-2000.
There are no valid sigs left, and all three can be disregarded.
Another way of looking at this is that the revocable sig of 2-Jan-2000
has not superceded the non-revocable sig of 1-Jan-2000.  The
revocation of 3-Jan-2000 has revoked the sig of 2-Jan-2000, which
leaves the non-revocable sig of 1-Jan-2000 as valid and usable.
Now try this case:
One answer here is that the expired sig of 2-Jan-2000 has superceded
the nonrevocable sig of 1-Jan-2000.  The end result is nothing and
both sigs can be discarded.
Another answer is that 2-Jan-2000 has expired, which leaves the sig of
1-Jan-2000 as valid and usable.
What are you arguing for?

@_date: 2005-03-20 05:26:17
@_author: David Shaw 
@_subject: Retaining expired sigs 
Good.  Then we agree.  What's more, there is nothing to change.  GnuPG
already effectively works this way (see below).
I agree with your general idea here, but not the details, exactly.
What GnuPG does in this case is to take the 1-Jan-2000 signature and
ignore any that follow.
I don't like the idea of a signature that is temporarily superceded.
Either it is superceded (and can be removed) or it is not.  It's a bit
of a distinction without a difference, really.  The end result is
basically the same, but the rationale is different.
Ok, I buy this.  I'll change the unusable sig filter to remove earlier
sigs in a series when filtering.  It's a little different than the
current implementation since this would allow a newly imported
signature to cause older signatures already on the keyring to
disappear (say, if an expired signature was imported that dated after
all the signatures that were already present).

@_date: 2005-03-20 19:33:49
@_author: David Shaw 
@_subject: Retaining expired sigs 
I think we're not communicating again.  There is no visible difference
between these two things.  What's to have a problem with?
Seriously, think about it:
Now, say it's January 3rd.  According to what you want, the signature
that gets used is the 2-Jan-2000.  Then, suddenly, on 10-Jan-2000,
when that signature expires, the 1-Jan-2000 signature is used.
  End result: there is always a signature.
According to what actually happens, the signature that is used is
  End result: there is always a signature.
I suggest that if it bothers you all that much, you pretend that it's
doing what you want.  It's not like there is a way to tell the
Haven't checked yet.  I don't know that it'll be terribly illuminating
on the subject of non-revocable sigs since so far as I know, GnuPG is
the only one that implements them (except for the usual use in
designated revokers).  It might reveal something interesting about
expiring sigs though.

@_date: 2005-03-21 02:30:19
@_author: David Shaw 
@_subject: Retaining expired sigs 
Ok, I see where you're coming from.  You are correct: I do feel that a
non-revocable signature must be a non-revocable + non-supercedable
I feel it really needs to be this way to fulfil the spirit as well as
the letter of the standard.  There is little point to a non-revocable
signature (described as "They represent a commitment by the signer
that he cannot revoke his signature for the life of his key." in the
spec) if that signature can be effectively revoked by superceding it
with an unusable signature (say, one with an unusable hash algorithm).
The nice thing (in terms of the 0x12/0x13 question) is that it doesn't
matter: GPG doesn't interpret 0x12 any differently than 0x13.  Thus
(from the earlier example), it genuinely makes no difference if the
1-Jan-2000 signature is 0x12 and the 2-Jan-2000 signature is 0x13.  So
long as GPG interprets either of those as a signature with no
qualifications, then there is no advantage or disadvantage to either
signature being used.  Either one is just "signature".
I'm aware that you want GPG to interpret 0x12 and 0x13 (and 0x11)
differently, but that's already been discussed a number of times and
will no doubt be discussed again.  GPG doesn't do it today.
I just checked PGP 8.1 and the results were interesting.
When importing a sig+expired sig set, PGP does what we ended up with:
it strips the sig and leaves the expired sig.
When importing a non-revoke-sig + revoked sig set, PGP doesn't strip
anything, but does ignore the non-revokable sig (it isn't even visible
in the GUI).

@_date: 2005-03-21 02:32:47
@_author: David Shaw 
@_subject: Retaining expired sigs 
Yes, this is exactly why I don't want to do what Jason suggested.
That would imply allowing a sig1 (which is ignored) to override a
non-revocable signature, implicitly "revoking" it.

@_date: 2005-03-21 05:33:19
@_author: David Shaw 
@_subject: Retaining expired sigs 
As soon as you posit a user who is going to edit their local keyring,
there is nothing to discuss.  Editing the keyring violates the trust
I don't think there is anything left to discuss.  We've about reached
the stage where I'm saying "10+2!" and you're saying, "Bad example!
It's 6+6!"
No.  So far as I can tell in a not particularly rigorous 5-minute
test, it ignores the non-revocable sig completely.  It's as if the uid
is unsigned.  This is a safe way to ignore such a signature.  No idea
what PGP 9 does.  I haven't played with it yet.
PGP 7, incidentally, did allow non-revocable sigs to be revoked.  Nice
to see that was fixed.

@_date: 2005-03-21 17:34:25
@_author: David Shaw 
@_subject: Question about ultimate trust 
Not necessarily.  You can set ultimate trust to any key you want to
allow to make trust decisions for you - for example, if you work at a
company with a corporate signing key.
They're similar, but ultimate trust has more power.  Think of ultimate
trust as combining complete trust, plus automatically making the key
fully valid, plus bypassing any restrictions on how many completely
trusted sigs make a key valid - any key signed by an ultimately
trusted key is always valid.

@_date: 2005-03-21 19:59:43
@_author: David Shaw 
@_subject: Retaining expired sigs 
I can only conclude that we are talking completely past one another.
You do seem to be very upset about all this, but I'm not detecting any
more signal amidst the noise.  I'm afraid I need to drop out of this
thread as I'm not really sure what you are advocating, or why, or if
you're just arguing to argue.  I'm genuinely sorry you don't seem to
be parsing what I'm saying, but there is nowhere else to go at this
If you have an actual change suggestion, I'd love to hear it.  But I
really do need:
1) What you think the current behavior is
2) What you want it to be
3) Why you feel this is better

@_date: 2005-03-21 20:08:36
@_author: David Shaw 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
That's odd.  The only thing that jumps to mind is are you building
with the configure option "--disable-keyserver-path" or using the
GPG option "exec-path" ?
Can you try running gpgkeys_curl.exe under gdb?  Just run it with the
temporary file you already got as the only command line argument.  It
would be very useful to see where it is failing.
I've gotten a number of successful reports of gpgkeys_curl on Unix-ish
machine, but has anyone had success with MinGW?

@_date: 2005-03-21 20:37:05
@_author: David Shaw 
@_subject: Multiple Subkeys/UIDs 
There seem to be a few ways to accomplish what you want to do here.
Can I get a little more information before I comment?  You mention
that all data enters the central location encrypted, but is then
decrypted ("for processing") and then re-encrypted.  Do I understand
that correctly?
Also: once a file is archived, is it still writable?  That is, is it
permissible to go back and edit this file to remove a particular key
from it?

@_date: 2005-03-21 20:48:27
@_author: David Shaw 
@_subject: 1.4.0a won't retrieve key from keyserver? 
I'm not sure if it ever made it into the bug tracker.  The issue, if I
recall correctly, was a line ending problem.  Unix-ish machines use \n
(LF) at the end of a line, W32 uses \r\n (CRLF).  The W32 libraries,
unless told otherwise, automatically transform LF into CRLF on the way
We were ending up in some cases with data coming in from a keyserver
that was already CRLF, and W32 was happily transforming that to
CRCRLF, which GPG didn't handle.
Can someone else on W32 confirm if this works for them?  Possibly the
problem is something else this time.  Hmm - do you have --openpgp set
in your gpg.conf file?

@_date: 2005-03-21 23:32:15
@_author: David Shaw 
@_subject: Multiple Subkeys/UIDs 
That makes things very difficult, unfortunately.  Given those
restrictions, I think your best bet is to have some sort of "check
out" process when someone needs to read a file.  At that point, the
file is decrypted by the master key and then re-encrypted to that
persons key.  Your local policy and setup will need to be written in
such a way that this person cannot make their own copy of the file
while reading it.
However, given that restriction (that the user has no way to make
their own copy), I wonder what the point is in re-encrypting.  Why not
decrypt as part of the check-out and give it to them in the clear?

@_date: 2005-03-21 23:48:02
@_author: David Shaw 
@_subject: signature level 
By default, GnuPG does not prompt you for a signature level.  If you
want to be prompted, use '--ask-cert-level'.
If you want to specify, but not be prompted each time, use
'--default-cert-level n' where n is 0, 1, 2 or 3.  The default is 0.
GnuPG can be configured to ignore certain signature levels.  Use
'--min-cert-level' to set the minimum level you want to accept.  The
default is 2.

@_date: 2005-03-22 00:39:45
@_author: David Shaw 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
Interesting.  Some difference between POSIX style $PATH and W32 style
%PATH% maybe?  Now that I think about it, GPG on MinGW is going to end
up appending ':c:\\programmi\gnupg" to your PATH.  That may well
result in a problem since W32 wants ';c:\\programmi\gnupg' (with a
leading semicolon).
The odd thing is the code has been this way for years (literally since
2002!) and I don't recall this exact problem popping up before.  Also,
there are other current MinGW builds that do work properly, so I
suspect there is still something not understood here.
Still, for curiosity's sake, try this patch to g10/exec.c:
Index: exec.c
RCS file: /cvs/gnupg/gnupg/g10/exec.c,v
retrieving revision 1.18
diff -u -r1.18 exec.c
--- exec.c      28 Oct 2004 02:14:06 -0000      1.18
+++ exec.c      21 Mar 2005 23:36:13 -0000
 -107,7 +107,7    if(curpath)
     {
       strcat(p,curpath);
-      strcat(p,":");
+      strcat(p,";");
     }
   strcat(p,path);
Yes, with -g and no -O.  Thanks!

@_date: 2005-03-22 14:52:11
@_author: David Shaw 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
The strdup segfault is happening due to a call from inside libcurl
itself.  That doesn't necessarily mean a bug in curl, though.  What
version of curl are you using here?
Also, can you try and rebuild libcurl with -g and no optimization?
Maybe we can get a better stacktrace.

@_date: 2005-03-22 14:52:53
@_author: David Shaw 
@_subject: signature level 
No.  0x10 sigs are always accepted regardless of the --min-cert-level.

@_date: 2005-03-22 15:05:28
@_author: David Shaw 
@_subject: 1.4.0a won't retrieve key from keyserver? 
Thanks.  I'll take a look.  However, I asked about --openpgp because
in some cases, that *causes* this problem, not fixes it.  Can you try
again without --openpgp set?

@_date: 2005-03-22 15:45:26
@_author: David Shaw 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
Yes.  If there is a path to add, it's always appended.  However, try
setting your --exec-path directly to the path you want.  That replaces
the current path completely.  So:
  exec-path c:\\whatever;c:\\programmi\gnupg

@_date: 2005-03-22 19:55:40
@_author: David Shaw 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
I don't know.  This isn't a GnuPG issue, but a libcurl one.  You might
ask the curl folks, as they are naturally much more familiar with
libcurl than I am.
I'm very pleased it is working for you!

@_date: 2005-03-22 22:08:48
@_author: David Shaw 
@_subject: 1.4.0a won't retrieve key from keyserver? 
Despite the name, you usually don't want to run with --openpgp set.
--openpgp uses a fairly strict interpretation of RFC-2440, the OpenPGP
standard, and the real world is a little more loose than that.
The default setting is --gnupg, and that is the recommended way to
That said, keyserver imports on W32 should work with --openpgp set as
well.  I will fix that.

@_date: 2005-03-22 23:53:36
@_author: David Shaw 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
Yes, that makes sense as it is the shell that expands %PATH% for you,
so it would only work on the command line.
Can you try running with '--debug 1024' ?  Do two runs, one with, and
one without --exec-path (on the command line).

@_date: 2005-03-23 00:17:45
@_author: David Shaw 
@_subject: signature level 
Stick 'ask-cert-level' in your gpg.conf file, and it will be your
default again.

@_date: 2005-03-23 15:07:55
@_author: David Shaw 
@_subject: Libcurl (was Re: [Announce] GnuPG 1.4.1 released) 
Thanks for running that test.  I can see what happened now.  It's
amusing that this comes up so many years later, and it seems nobody
When starting a keyserver subprocess, GPG sets the path to where the
subprocess binary exists (in your case c:\programmi\gnupg).  In doing
so, it removes the earlier %PATH%.  This is intentional, as I did not
want to search the whole PATH for a program named 'gpgkeys_xxx', and
run the risk of running the wrong one.  However, removing the whole
PATH removes your DLL directory as well.  I did not account for
someone putting the DLLs in a special directory, separate from the
system and the programs.
This is easy to fix, but I need to think for a moment on which fix is
best and keeps the current semantics of exec-path.

@_date: 2005-03-23 20:48:31
@_author: David Shaw 
@_subject: could not check signature 
What, exactly, do you mean by this?  What exact change did you make?
Can you send me an example of such a message?

@_date: 2005-03-23 21:04:54
@_author: David Shaw 
@_subject: could not check signature 
This does not tell me anything useful.  I don't know what mailer you
are using, and I don't know how you are calling GnuPG.  Specifically,
and *exactly*, what did you change.  Did you stick "digest-algo
ripemd160" in your gpg.conf?  Did you do something in a mailer config
file?  Did you change something on the command line?  Did you do
something else?

@_date: 2005-03-24 03:30:08
@_author: David Shaw 
@_subject: could not check signature 
You get the error when you *send* a message, or when you *verify* a
What happens if you remove the 'digest-algo RIPEMD160' line from
I see also that you are using The Bat! v3.0.9.9.  That version is a
pre-beta that came out yesterday.  You're not the first person who is
reporting this error with The Bat! so I'm wondering if the Bat folks
changed something internally.

@_date: 2005-03-24 05:09:17
@_author: David Shaw 
@_subject: could not check signature 
But does the message verify correctly if you remove the 'digest-algo
RIPEMD160' ?
Yes, PGP and GnuPG have a difference in their sig verification
routines.  GnuPG is more strict to the standard.  PGP actually allows
you to (for example) present a message that claims to be SHA1 but is
really RIPEMD160 and will successfully verify it.
I'm curious how The Bat! verifies PGP/MIME signed messages.  That
particular error sort of implies that they are constructing a brand
new OpenPGP message out of the various MIME parts and passing it to

@_date: 2005-03-24 22:16:45
@_author: David Shaw 
@_subject: Shouldn't keyservers store and provide subkeys? 
I'm all for it.  It would be nice to point people to a keyserver set
that works properly with everything: multiple subkeys, photo IDs, and
MR output.  At the moment, this is just SKS servers.

@_date: 2005-03-24 22:46:39
@_author: David Shaw 
@_subject: Shouldn't keyservers store and provide subkeys? 
I'm curious why it is better to run our own, when (with permission)
there are many well run SKS servers out there we can point to.

@_date: 2005-03-24 22:53:00
@_author: David Shaw 
@_subject: gpg: WARNING: unsafe ownership on configuration file 
It means that the user you are running GPG as was not the owner of the
gpg.conf file.  That can be a security problem (as someone other than
you can manipulate it), so GPG is warning you about it.
Since you're running as root on purpose, it's presumably not a
security problem, but GPG doesn't know that.

@_date: 2005-03-25 00:04:51
@_author: David Shaw 
@_subject: Shouldn't keyservers store and provide subkeys? 
That's great news.  I didn't realize that onak was actively running
I'll check it out.

@_date: 2005-03-25 05:46:48
@_author: David Shaw 
@_subject: The PATH problem (was Re: Libcurl) 
That is basically the plan.  The only (not very) complex thing is that
it needs to take into account --exec-path as well as the configure
option --disable-keyserver-path, and the various combinations of those
options or lack thereof.
Can you try this patch?

@_date: 2005-03-31 18:45:52
@_author: David Shaw 
@_subject: The PATH problem (was Re: Libcurl) 
Excellent.  Thanks for testing.  I've put the fix in for 1.4.2.

@_date: 2005-05-05 14:15:47
@_author: David Shaw 
@_subject: can not ? receive key : connection timeout 
If you need to use a proxy, then add:
  keyserver-options http-proxy="
to your gpg.conf

@_date: 2005-05-10 21:48:03
@_author: David Shaw 
@_subject: How to change trust model 
You can switch trust models by doing:
  gpg --trust-model xxxxxx --check-trustdb
You can switch at any time and as often as you like.

@_date: 2005-05-10 23:54:28
@_author: David Shaw 
@_subject: How to change trust model 
This is the "new" PGP trust model from PGP 5 and later.
This is the standard old trust model from PGP 2.x and GnuPG 1.2.x.
For most people, they will not see a difference between these two.
Only if you are issuing trust signatures (tsign) will a difference
show up.
This is a no-trust model, where you set each key trust individually,
and there are no calulations necessary.
I can't answer that question in those terms.  I don't know what you
want to do, who the CA is, how the CA signs...

@_date: 2005-05-11 00:04:54
@_author: David Shaw 
@_subject: Wherre to place keys under Linux 
You can share keyrings if you specify the shared keyring via "keyring"
and "secret-keyring" in both of your gpg.conf files.

@_date: 2005-05-11 00:18:09
@_author: David Shaw 
@_subject: How to change trust model 
You don't need trust signatures or any special trust models for this.
If you trust the CA, sign the CA key.  If the CA has signed your
contacts, then you're done.  The contact keys are now valid.

@_date: 2005-05-11 02:56:39
@_author: David Shaw 
@_subject: How to change trust model 
First, read this:
It's a very good explanation of trust signature concepts.
How they are used specifically in GnuPG is via the 'tsign' command.
tsign is just like sign (or lsign) except that you are asked a few
more questions by GnuPG.  Think of tsign as a combination of a regular
signature plus the ownertrust.  This combines two different things
from the classic trust model into one signature.
First you are asked:
   Please decide how far you trust this user to correctly verify other
   users' keys (by looking at passports, checking fingerprints from
   different sources, etc.)
     1 = I trust marginally
     2 = I trust fully
This is similar to the question you get asked when setting ownertrust.
What GnuPG is asking is not how much you trust the user, but how much
you trust the user to make good signatures.
The next question is:
   Please enter the depth of this trust signature.
   A depth greater than 1 allows the key you are signing to make
   trust signatures on your behalf.
The signature depth is how many levels "deep" can the power granted by
this signature travel.  For example, a level of 1 means that the key
you sign is valid for you (just like a regular signature), but also
that the ownertrust for this key is automatically set to MARGINAL or
FULL (depending on how you answered the first question).  A level of 2
means that the key you sign is valid for you, and the ownertrust is
automatically set, AND (assuming the trust made it to FULL) that this
key can issue signatures up to level 1 on your behalf.  A level of 3
means all that, plus the key can issue signatures up to level 2, etc.
You can think of a regular signature as a trust signature with a depth
of 0.
The next question:
   Please enter a domain to restrict this signature, or enter for none.
This allows you to restrict (by domain name) the power of the
signature.  For example, let's say that you wanted to make a level 2
signature on a CA key for a particular company.  You should be careful
with making any level above 1, so you want to restrict this to that
company.  By giving a restriction of companyname.com here, only
signatures issued by the CA key on keys in companyname.com will take
That's pretty much it.  If you think about it, tsign is not generally
useful outside of hierarchial environments with CAs.  Some people are
in hierarchial environments though, and this lets them interoperate.
Incidentally, you can combine tsign with any of the other signing
types (lsign, nrsign) in any combination you like: ltsign is a local
trust signature, nrltsign is a nonrevocable local trust signature,

@_date: 2005-05-12 14:25:27
@_author: David Shaw 
@_subject: How to change trust model 
Yes.  You only have one link betweeen you and the user: you -> CA -> user
Using a depth of 2 here will work, of course, but is overkill.
The usual thing happens, because that signature isn't part of the
trust signature chain.  We've already established that the key signed
by the CA is valid, so if you have sufficient ownertrust set, then
this other key would be valid as well.
You -> Big CA -> Little CA -> User
Useful in a company with many subdivisions.  You just sign the master
CA with a depth of 2, the master CA signs the various subdivision keys
with a level of 1, and the subdivision keys sign all the users in
their subdivision.
End result is that all users become valid to you.
Signing someone with a level of 2 or greater gives them *a lot* of
power.  It basically means that not only are they trusted introducers
for you, but they can grant the ability to be trusted introducers for
you to someone else.

@_date: 2005-05-15 22:40:47
@_author: David Shaw 
@_subject: Difference "gpg --armor --store" Vs. "gpg --enarmor" 
--armor --store creates an armored OpenPGP message: a "literal
message", which is unencrypted and unsigned.
--enarmor armors whatever you feed it.  The result is not an OpenPGP

@_date: 2005-05-16 15:16:47
@_author: David Shaw 
@_subject: importing private keys 
Short answer: yes.
Just export the private key from 8.1, and import it to GnuPG just like
you'd export/import a public key.

@_date: 2005-05-21 02:23:19
@_author: David Shaw 
@_subject: problem with key import 
This is a known problem with CryptoEx.  I believe they've fixed it
already.  Basically, CryptoEx didn't always calculate the key ID
properly, so self-signatures didn't verify.  PGP will import a key
with a bad self-signature, so it works in PGP.  GnuPG won't import
such a key, but you can override this with --allow-non-selfsigned-uid
Better to get an updated CryptoEx though.

@_date: 2005-05-22 00:11:34
@_author: David Shaw 
@_subject: 2 noob problems 
How useful is that, really?  Seriously - an expired signature may be
interesting to someone who can infer from it that a key was valid
earlier, but that doesn't really have any connection to the important
question of is the key valid *now*.
I'd be quite content if useless signatures were stripped from my key.

@_date: 2005-05-22 00:21:40
@_author: David Shaw 
@_subject: 2 noob problems 
Yes.  This is something I've been playing around with for the next
version.  I'm not completely decided on how to implement the UI for
it.  It'll be optional, of course, but the general idea is that people
can choose to remove "useless" signatures from their keyring
automatically at import or export time, or any time via --edit-key.
"useless" in this case means (almost) any signature that is not
actually used by GnuPG for the trust calculations.  The code in fact
is the same as the trust code.  So for example, an expired signature
would be deleted, along with any signatures that the expired signature
superceded.  A revoked signature similarly is deleted, and takes out
the superceded signatures with it.
There are several reasons why it is a good idea for keyservers to
store multiple signatures, but the main one is that they do not
currently have any crypto code to actually verify the signatures.
Without the ability to know if a given signature is good or bad, the
keyservers cannot make any decisions as to what signatures to keep or
GnuPG can verify signatures, of course, and so can safely prune them.
Incidentally, PGP prunes as well.  It's the only way to keep keys to a
rational size over a long period of time.

@_date: 2005-05-26 04:22:11
@_author: David Shaw 
@_subject: Unicode support 
GPG doesn't really care very much about the format of the data you
give it to sign.  If you put in UTF-8, you'll get a signature over
UTF-8.  If you put in something else, you'll get a signature over
something else.

@_date: 2005-05-27 01:58:00
@_author: David Shaw 
@_subject: Additional self-signature 
No, it's the other way around.  The public key can be created from the
secret key.  What you are seeing with the second self-signature is a
historical oddity.  In the past, keys were generated with two
different self-signatures - one on the secret key and one on the
public key.  You are just seeing them both.  Newer keys are generated
with a single self signature so you only see one.
It's recreated empty as a placeholder.

@_date: 2005-05-27 14:42:13
@_author: David Shaw 
@_subject: Additional self-signature 
"Newer keys" is 1.4.2 and later.  I'm sorry I didn't make that clear.
There is no need to.  The extra signature is harmless (it's a
signature issued by you, on your own key after all).  If it really
bothers you, you can use --edit-key and 'delsig' to delete one of them
(it doesn't matter which one).
I'm working on a general solution for extra signatures and what to do
with them, but it's important to note that this is mainly an aesthetic
problem.  The key will work just fine, and there is no weakness in
having extra signatures.  Some people just don't like extra
signatures, and when you get into things like the Global Directory,
you can have a LOT of extra signatures.

@_date: 2005-11-01 16:53:28
@_author: David Shaw 
@_subject: the best signature type someone can give me 
Exactly.  You've got it.
It means the same thing as it does with regular sign.  You need 1 full
paths or 3 marginal paths (by default) to make a UID valid.  If you
use MARGINAL with tsign, then it just means you need two other paths
before the UID becomes valid.  You can set the parameters you want to
use with "completes-needed" and "marginals-needed" in gpg.conf.

@_date: 2005-11-01 17:07:12
@_author: David Shaw 
@_subject: the best signature type someone can give me 
The question is based on a misunderstanding.  The hash size and key
size are not a 1:1 relation.

@_date: 2005-11-02 06:12:27
@_author: David Shaw 
@_subject: Character set and File exists 
Change your locale from "C" to "C.utf8".
Add the --yes option to the command line.

@_date: 2005-11-02 22:33:14
@_author: David Shaw 
@_subject: Strange entries in keyserver-listings 
Welcome to the occasionally painful world of keyservers.  Briefly,
some of them mangle keys in various ways.  GnuPG knows about the
doubled user ID and will automatically repair it when you actually
retrieve the key.

@_date: 2005-11-04 02:40:13
@_author: David Shaw 
@_subject: - -textmode??? 
Use --textmode if INFILE is text.  Don't use it otherwise.  It causes
text canonicalization so that text remains text across different
platforms.  For example, Unix machines end text lines with LF.  DOS
machines end text lines with CRLF.  Use --textmode and the file is
automatically converted.

@_date: 2005-11-04 20:24:32
@_author: David Shaw 
@_subject: back signatures 
It's a countermeasure against an attack against signing subkeys.
Basically, the primary key signs all subkeys.  With backsigs, the
signing subkey also signs the primary key.
Without this, an attacker can "steal" a signing subkey from someone
else and try and pretend that a signature came from his own key.  It's
not a particularly good attack: the attacker can't issue signatures to
prove his ownership.

@_date: 2005-11-04 20:29:37
@_author: David Shaw 
@_subject: back signatures 
I should add that this is a new feature for 1.4.3.

@_date: 2005-11-04 22:21:20
@_author: David Shaw 
@_subject: Expiring UID 
Honestly, no good reason.  There are a few iffy reasons in nobody ever
asked for this feature before, and that it would be of doubtful
compatibility outside of GnuPG.

@_date: 2005-11-05 14:30:31
@_author: David Shaw 
@_subject: back signatures 
It's as official as any release that hasn't happened yet: that is to
say, we're happy and thrilled if you test it out and report bugs (to
gnupg-devel), but you'll have to compile it from the SVN repository,
and it's not considered stable code.

@_date: 2005-11-05 14:31:05
@_author: David Shaw 
@_subject: back signatures 
No, it's unrelated to that.  It's a countermeasure against a (somewhat
weak) attack.  It has nothing to do with various bit twiddling you can
do to your own key.

@_date: 2005-11-05 14:44:59
@_author: David Shaw 
@_subject: back signatures 
So... report the bug?  We're not terribly good mind readers here.

@_date: 2005-11-05 15:33:30
@_author: David Shaw 
@_subject: how to handle "bad" signers? 
I'm sure it's 4, especially in the case when the person in question
never attended the party.  Some people just sign all the keys and call
it a day.
That is correct.  It really has to be this way, for good and for bad.
Trust is inherently subjective - even the 1-2-3 trust levels are just
guidelines and there is no way to enforce them beyond asking people
nicely not to abuse the system.
Of course, it would be possible to propose a different trust model
that takes into account such things (a reputation system), but that
would be a reasonably different beast than the current system.  Not
impossible, but it would take some working out of details.  OpenPGP
currently has no way to make a "negative" signature.

@_date: 2005-11-05 19:43:40
@_author: David Shaw 
@_subject: how to handle "bad" signers? 
Yes, more or less.  You could allow people who you trust to lower the
validity of other user IDs.

@_date: 2005-11-07 14:42:16
@_author: David Shaw 
@_subject: back signatures 
I'm afraid I don't understand what you're asking here.  How backsigs

@_date: 2005-11-07 16:24:43
@_author: David Shaw 
@_subject: back signatures 
Backsigs are part of a signing subkey.  You don't generally need to
issue them, since they are generated automatically when you make a
signing subkey.  If you have an older key with one or more signing
subkeys and want to add backsigs to it, do 'gpg --edit-key (thekey)'
and use the 'backsign' command.
Moving subkeys around is not supported in GnuPG.  You can follow the
steps in  if you want to do
it manually.
There are generally few reasons to move subkeys from one key to
another.  Usually a better answer is to just make another one -
subkeys are cheap.

@_date: 2005-11-07 16:37:03
@_author: David Shaw 
@_subject: back signatures 
Current signing subkeys have a weakness in that they can be moved from
one key to another without the key owner's approval.
This means that if I sign a message with a signing subkey, someone
else can lift the (public) signing subkey off of my key, attach it to
theirs, and issue a new binding signature for it.  This person can
then claim to be the person who signed the message.
Note that this person doesn't have the secret key or the passphrase -
they can't issue NEW signatures.  They can only claim to be the signer
for existing signatures.  They also can't stop the original signer
from claiming ownership.  If it comes down to two people, both
claiming they issued a particular signature, just ask them both to
sign a challenge (a different challenge for each).  The impostor won't
be able to.
Anyway, back signatures avoid all that by adding a signature from the
signing subkey on the primary key.  This proves that the owner of the
signing subkey is not an impostor, since the impostor could not issue
such a signature.

@_date: 2005-11-07 22:24:28
@_author: David Shaw 
@_subject: Prefered algorithms priority 
Correct, it's left to right.  The algorithm works by eliminating any
algorithm that isn't usable by all recipients (remember that by
definition 3DES is usable by all recipients, so it will be used if all
else fails).  Once the list has been reduced to what everyone can
handle, the final selection is made by either --personal-xxxx-prefs
(if you are using it) or by the first -r recipient.

@_date: 2005-11-08 14:44:12
@_author: David Shaw 
@_subject: Keytypes and changing them 
Yes.  Many people do it this way, including myself.  It's not actually
an RSA-S key (that's deprecated), but a regular RSA key with the S
flag set.  However, you don't actually want to change the primary from
CS to C.
You can add a signing subkey any time you like.  This doesn't flip
your primary CS key into a C only key, but that doesn't matter much.
If GnuPG sees you have a signing subkey, it will always choose it in
favor of the primary key when making a signature.
You don't want a C only primary key because if you go to a key signing
party, you may be asked to sign a challenge to prove you own your key.
This challenge must be signed with the primary key to be valid.
No.  This does not affect third-party signatures.

@_date: 2005-11-08 15:42:29
@_author: David Shaw 
@_subject: Keytypes and changing them 
Well, sure, given a particular effect you want to achieve, you can
always come up with a hideously complicated way to do it involving
multiple copies of the key and extra work.  Most people like to do it
the easy way.
If such a feature existed in GnuPG, yes.

@_date: 2005-11-08 15:56:59
@_author: David Shaw 
@_subject: Prefered algorithms priority 
It indicates to other users that you don't WANT to accept MD5 hashed
signatures.  It doesn't mean you won't get one.

@_date: 2005-11-08 18:27:55
@_author: David Shaw 
@_subject: Keytypes and changing them 
One possible (and current) use is to use an OpenPGP key for ssh

@_date: 2005-11-09 02:30:15
@_author: David Shaw 
@_subject: Keytypes and changing them 
It has absolutely no impact on security, either for or against.  It is
a 90% meaningless flag, and is in fact happily ignored in virtually
all OpenPGP applications.  If you insist on making such a key, the
only impact that you'll notice is that you won't be able to answer
email challenges using GnuPG.
You sound like you really, really, want to do this.  I'm telling you
it's a bad idea, but it's your key.  You have to be happy with it.

@_date: 2005-11-09 02:42:33
@_author: David Shaw 
@_subject: Keytypes and changing them 
That is not how email challenges work.  If someone loses their email
address, the signature is effectively invalid.  That's a feature, not
a flaw.  When you sign an email address, you are certifying that it is
valid at that point.  Obviously you can't certify it as valid forever.
Isn't this really saying you want to use a C-only key because it is
possible to use it?  I don't see you presenting a reason to use them
aside from "the standard has them, and since they exist in the
standard, clearly they're supposed to be used".  Lots of things are
possible, but not necessarily useful.  C-only keys are possible, but
not viable in the real world.
Note that it's also possible to make a CS Elgamal-E key.  It's utterly
meaningless, but physically possible to create.  Not every bit pattern
is useful.
It doesn't say this.  You could make a CS key, sign some data, then
flip it to a C-only key.  The other user can infer exactly nothing
about the past usage of a CS key compared to a C key.

@_date: 2005-11-10 21:24:59
@_author: David Shaw 
@_subject: back signatures 
Not exactly.  The problem is limited to signing subkeys because
identity is attached to the primary key.  When you make a signature
with your primary key, you're saying "key XXXX made this signature,
and key XXXX is owned by Joe Smith".  When you make a signature with a
signing subkey, you're saying "key XXXX made this signature, and key
XXXX is owned by key YYYY and key YYYY is owned by Joe Smith".
The problem is that only key YYYY (the primary) asserts ownership of
key XXXX (the signing subkey), which means that ZZZZ (someone elses
primary) can come along and also assert ownership of XXXX.  The fix
("back signatures") is to have XXXX assert posession by YYYY.  This
foils ZZZZ since she cannot issue a signature from XXXX.
No, 0x13 (or 0x10, 0x11, 0x12) are used to sign a user ID and primary
key together.  Historically, people call this "signing a key", but
it's really signing a user ID + key.
0x1F signatures are truly signing a key alone.
Yes, indeed.
GnuPG does, as of 1.4.3.  I expect other clients will do as well.

@_date: 2005-11-11 15:05:40
@_author: David Shaw 
@_subject: How to execute gpgkeys_ldap, gpgkeys_curl, gpgkeys_finger, 
You don't execute them.  GPG executes them as needed.  For example, if
you are using a HKP keyserver like subkeys.pgp.net, then GPG will
execute gpgkeys_hkp for you.

@_date: 2005-11-17 15:46:03
@_author: David Shaw 
@_subject: Key Capabilities 
Certification is just the ability to sign other keys.  All primary
keys, by definition, are able to certify, so the flag is not very
meaningful there.  In GPG 1.4.2 the key generation menu doesn't show
you certification as an option, but it does automatically set the flag
behind the scenes.
1.4.3 is a little different.  To make things clearer, 1.4.3 does show
certification in the list of flags, but you can't turn it off (as this
would violate OpenPGP).

@_date: 2005-11-26 16:30:42
@_author: David Shaw 
@_subject: Zero width no-break space (U+FEFF) in clearsigned output message 
U+FEFF is the BOM character.  It was in the original document, so it's
in the signed document as well.

@_date: 2005-11-26 23:06:07
@_author: David Shaw 
@_subject: Zero width no-break space (U+FEFF) in clearsigned output message 
I'm not sure what question you're asking here.  The BOM character is
in your original document.  GnuPG doesn't modify input text, so
therefore the BOM character is in the output text as well.  If you use
--textmode, GnuPG canonicalizes line endings to CRLF, but again does
not change actual text, including the BOM.
If you don't want a BOM character in your output, don't put a BOM
character in your input.
I have yet to receive a readable copy of a mail with that problem.
Note that forwarding me the message will not tell me what I need to
know since a forwarded mail will rearrange and break the signature.  I
need the actual mail file.

@_date: 2005-11-27 01:43:13
@_author: David Shaw 
@_subject: Zero width no-break space (U+FEFF) in clearsigned output message 
For clearsigned files, effectively --textmode is always set.

@_date: 2005-11-28 05:03:32
@_author: David Shaw 
@_subject: no-ask-cert-level, default-cert-level, and keysigning 
You pretty much summarized it.  --ask-cert-level turns on the
question.  If you don't have the question turned on, GPG will use the
value from --default-cert-level, which defaults to 0.
That is the only way to do it.  The cert level is part of the
signature, and thus changing it requires issuing a new signature.
It's a matter of personal taste, really.  Some people like it, and
some don't.  It doesn't make much difference in practice since (unless
you're issuing level 1 sigatures, which are ignored by default), all
signature levels (or 0) are treated the same.

@_date: 2005-11-29 05:25:03
@_author: David Shaw 
@_subject: Forging fingerprints/KeyID? 
It was true, but not true any longer.  Back in the PGP 2.x days, it
was possible to create a key with (almost) any key ID you liked.  See
the various "DEADBEEF" keys on the keyservers for example.  Similarly,
it was possible to create a key that had the same fingerprint as a
(also PGP 2.x) victim/target key.
If you have a OpenPGP (v4) key, such as created by GnuPG, then this
basically doesn't apply to you.

@_date: 2005-11-29 05:43:53
@_author: David Shaw 
@_subject: trust path lookup on server 
Yes, it is.  There are a few servers that do more or less what you
describe (for example   It's
useful to see the various paths, but unless you trust each step in the
chain, it doesn't really help you get trust in the end point.

@_date: 2005-11-29 05:57:39
@_author: David Shaw 
@_subject: Forging fingerprints/KeyID? 
It was true, but not true any longer.  Back in the PGP 2.x days, it
was possible to create a key with (almost) any key ID you liked.  See
the various "DEADBEEF" keys on the keyservers for example.  Similarly,
it was possible to create a key that had the same fingerprint as a
(also PGP 2.x) victim/target key.
If you have a OpenPGP (v4) key, such as created by GnuPG, then this
basically doesn't apply to you.

@_date: 2005-11-29 05:57:51
@_author: David Shaw 
@_subject: Keytypes and changing them 
This is not a cryptographic question.  The key is same either way.
This is just a flag that says "I intend this key to be used for
And - this is the important bit - the user can *reissue the flags as
desired*.  I can make my key claim to be anything I like, and then
change it 5 seconds later.  Anyone who bases any decisions on what
flags the key has is fooling themselves.
No.  A certification signature is made over the primary key and the
user ID.  A signing subkey is not involved in this, and is thus not
really able to answer the challenge.

@_date: 2005-11-29 16:01:50
@_author: David Shaw 
@_subject: Forging fingerprints/KeyID? 
It's pretty easy to create a short (eg, 99242560) key ID collision -
just generate keys over and over on a resonably fast desktop machine
until you collide.  It's not yet realistic to create a long key ID
collision (eg, DB698D7199242560) intentionally, though it does happen
every now and then by accident.  It's currently completely out of the
question to intentionally create a colliding v4 fingerprint.  To do so
would imply a total break of SHA-1, in which case we have other
problems.  Note that even MD5 isn't broken to that extent.
It doesn't hurt, but it doesn't help either.  Actually, it's not true
that it doesn hurt - it does hurt a little if people start to believe
that this actually protects them in a meaningful way.  It's important
to be honest with yourself.

@_date: 2005-11-30 19:42:05
@_author: David Shaw 
@_subject: disjunct paths (was: Re: trust path lookup on server) 
Yes, if you trust those disjunct paths :) A hundred disjunct paths
that you don't trust don't help much.
There is a notion of partial trust, where if you gather enough
partially trusted signatures then it equals full trust.  You can tune
the trust calculations with the --marginals-needed and
--completes-needed options.  By default, you need 3 marginally trusted
signatures or 1 completely trusted signature.

@_date: 2005-11-30 21:16:52
@_author: David Shaw 
@_subject: disjunct paths 
Unless you're talking about paths with only one hop, it doesn't work.
The paths *start* with keys signed by you.  After that, you have no
Given these paths:
Gregor  ->  Alice  ->  Baker  ->  Charlie  ->  David
Gregor  ->  Lorina ->  Mark   ->  Nate     ->  David
Gregor  ->  Edith  ->  Frank  ->  George   ->  David
You know (because you signed them), that Alice, Lorina, and Edith are
valid.  Lets say that you also fully trust them to make good
signatures, so that makes Baker, Mark, and Frank fully valid as well.
However, not knowing how well Baker, Mark, or Frank issue signatures
stops you from making Charlie, Nate or George valid, which stops you
in turn from making my key valid.
GPG will calculate trust for 5 hops along the path, by default.  You
can tune this with --max-cert-depth.

@_date: 2005-10-03 00:08:56
@_author: David Shaw 
@_subject: Can't check message signature 
It means, if you are willing to, to please send me a copy of the
message, with the signature intact, so I can examine it.

@_date: 2005-10-13 23:14:29
@_author: David Shaw 
@_subject: Bogus Key on Keyservers 
If you use the PGP global directory (ldap://keyserver.pgp.com) as your
keyserver, you can, since it checks the email address by sending mail
to it.
On other keyservers, you can't do this.  This is what the web of trust
is for; your real key would have signatures proving that it is yours.

@_date: 2005-10-14 00:14:33
@_author: David Shaw 
@_subject: Lack of backwards compatability? 
TIGER192 is not part of OpenPGP.  Sometimes it's less painful to rip
the bandage off all at once than it is to pull.  it.  off.  really.
really.  slowly.
GnuPG dropped TIGER192 in 2003.  Re-adding it now would be a step
backwards in pulling that bandage off.

@_date: 2005-10-14 17:02:59
@_author: David Shaw 
@_subject: Bogus Key on Keyservers 
Use ldap://keyserver.pgp.com.  It does email verification.  However,
it does not (for obvious reasons) sync with the other keyservers.

@_date: 2005-10-18 17:19:15
@_author: David Shaw 
@_subject: PGP Zip with a single file? 
I'm having an awful problem understanding exactly what the problem is
here.  When you make a PGP Zip archive with one file in it it is not
tarred up?  If so, then it's just the file itself, no?

@_date: 2005-10-18 17:43:25
@_author: David Shaw 
@_subject: Subkey revocation means losing signatures? 
Revoking a subkey loses nothing (except the subkey).  Revoking a user
ID loses any signatures on that user ID - after all, those people
signed that user ID, and by revoking it you say that you, the owner,
does not treat the user ID as valid any longer.  If you don't treat it
as valid, why should anyone else?

@_date: 2005-10-18 20:30:33
@_author: David Shaw 
@_subject: Subkey revocation means losing signatures? 
You're talking about adding a new user ID.  The original question was
regarding revoking an existing user ID.

@_date: 2005-10-19 14:40:42
@_author: David Shaw 
@_subject: Subkey revocation means losing signatures? 
No.  Deleting a UID results in loss of signatures on that UID
(deleting a UID actually removes the signatures completely so they're
really lost).  Revoking a UID also results in loss of signatures on
that UID.  They're not deleted, but they are ignored from then on.
Signing a UID with another UID is not a meaningful statement.  UIDs
don't sign.
Some people do this, and it can be useful in certain places (signing
keys), but it does not resolve the "this key is untrusted - use it
anyway?" question unless people select the key using the empty UID.

@_date: 2005-10-20 21:39:50
@_author: David Shaw 
@_subject: Subkey revocation means losing signatures? 
Sort of.  The problem is that there is not really such a thing as
trust to a key: it's trust to a user ID.  So people actually get
different trust values for each different user ID on their key.  A
free-form user ID can certainly be signed, and certainly carries
trust, but is not generally used by programs (which like email
addresses), so it doesn't really help you.

@_date: 2005-10-22 04:35:45
@_author: David Shaw 
@_subject: Delete key from keyserver 
If you don't have the private key, then yes, right.  There is nothing
you can do about it.
You really can't.  Even if one operator did remove the key, keyservers
synchronize with each other, so the others could just put it back
later.  You'd have to remove it from all keyservers... and even then
if someone accidentally resubmitted it, you'd have to go through this
Nope.  It's an inherent scaling problem of the keyserver net.  I've
seen estimates that the majority of the keys on the keyserver net are
not used for one reason or another, but can't be deleted.  Even with
the garbage keys, the keyserver database isn't too large to be served
The PGP company is running a different sort of keyserver at
  This type of keyserver allows you to remove
keys if you can prove (by answering an email challenge) that you have
access to the email address on the key.  This keyserver obviously does
not synchronize with the others, however.

@_date: 2005-10-23 16:12:59
@_author: David Shaw 
@_subject: Delete key from keyserver 
GPG can use this keyserver.  Just set:
  keyserver ldap://keyserver.pgp.com
in your gpg.conf file (or whatever GUI you happen to be using).
This is a harder question.  I would unhesitatingly recommend it for
beginning users.  It's also useful for any level user who wants to
simplify the whole key selection process - it guarantees there is only
one key per email address.  If you want to mail to a particular
address, there is no question which is the "right" key, as there is
only the one key there.
I believe it is also the default keyserver for PGP users.
Some people do not like this server as it does email address
verification (via sending a mail to the email address on the key, if
any), and then signs the key.  These signatures are reissued every 2
weeks or so if people keep requesting the key.  The list of signatures
can get long.  Both PGP and GPG have features to delete the expired

@_date: 2005-10-23 19:27:29
@_author: David Shaw 
@_subject: The never-ending GD discussion, 
This is a misunderstanding about the Global Directory.  It does not,
is not designed to, and should not give more than one key for a given
email address.  The GD says "This is the key.  Period.  There is no
other key.  Take this key and use it.  Have A Nice Day.".  The goal of
the GD is specifically NOT to say, "This is the key.  Here are a few
more keys.  Well, here's another one that the person may or may not
have lost the passphrase for.  Oops, found another one.  And this one
too.  Now figure out which one, if any, you should use!"
It always amuses me that people complain bitterly about the GD storing
one key per email address, but don't complain, for example, about
people putting their key up on a web page.  After all, they may
contain only one key, and might cause people to miss a revoked key. ;)
Completely untrue.  For the huge majority of users, email verification
is sufficient.  The GD is one-stop shopping for them: they get a
single key that points to an email address that has been checked.
Sure beats 3-4 keys on the keyserver and having to parse out the web
of trust to see which one to use... only to find that more than one
was in the web of trust, pick one anyway, and then hope the key owner
didn't lose the passphrase or just stopped using encryption.
Remember that the people who subscribe to this mailing list and have
any knowledge of the web of trust are not in any way the huge majority
of users.  We're a miniscule blip on top of a near nothingness.
You assert that e-mail verification alone is of little value.  I
disagree.  I challenge you to make a key with my email address and get
the GD to accept it.  Let me know when you succeed.

@_date: 2005-10-23 22:30:22
@_author: David Shaw 
@_subject: The never-ending GD discussion, 
You always need to search the GD by email address.  Name searches
don't make sense there, as the GD only verifies the email address.
The name on the key is essentially a comment, with no more meaning
than any other comment.  It's a consequence of the design to handle
automated encryption - in that case, an email address may be all you
have to work with.
In any event, name or email address, the concern with missing a
revoked key is sort of a non sequitur as the GD doesn't store revoked
keys in the first place.
Not necessarily.  If another Doug Barton comes along, he could just as
easily bump you out.

@_date: 2005-10-25 00:06:49
@_author: David Shaw 
@_subject: Delete key from keyserver 
I don't agree with this.  The user ID system in all OpenPGP products
gives a regular UTF-8 string.  Signatures simply bind that string to
the primary key.  The system says exactly "Alex Mauer belongs with key
0x51192ff2" and "hawke belongs with key 0x51192ff2".
You cannot sign a user ID without binding it to a key.

@_date: 2005-10-25 16:36:16
@_author: David Shaw 
@_subject: Signature packets without (whatever) 
Given that one of the errors is a signature packet without a
keyid... it's hard to locate the signature :)
You could do trickery with gpgsplit and such, but I'd wait until 1.4.3
is out.  It doesn't error on such signatures any longer.

@_date: 2005-10-25 16:51:35
@_author: David Shaw 
@_subject: Signature packets without (whatever) 
I doubt this is involved in any trustdb problems.  All versions of GPG
ignore such signatures.  1.4.3 just ignores them quietly.

@_date: 2005-10-25 23:56:31
@_author: David Shaw 
@_subject: Signature packets without (whatever) 
Yes.  The PGP GD key that's on the HKP network is riddled with
garbage.  Getting it from ldap://keyserver.pgp.com (or manually via
HTTP as you did) is the right thing to do.
It actually revealing interesting key use data: the copy on
keyserver.pgp.com is the "real" copy, with only the signatures that
the PGP company put there.  The copy on the HKP net has a few hundred
other signatures... some, no doubt, in error.  You could probably
regard most of the difference between the two sets as people who
didn't use local signatures, but should have.  Judging by the number
of signature revocations attached to that key, some people did realize
their error, but too late.

@_date: 2005-10-26 01:41:01
@_author: David Shaw 
@_subject: Delete key from keyserver 
Some people (myself included) check both before signing.  The name via
some sort of formal ID, and the email via a mail challenge.
Still, if you don't want to bind both tokens together, just create an
user ID of  without the name attached or a user
ID of "Alex Maurer" without the email address attached.  Some people
will not sign such a user ID though, and at least the name-only one is
of questionable usefulness in practice.

@_date: 2005-10-26 05:39:21
@_author: David Shaw 
@_subject: Delete key from keyserver 
It's not an issue of improving the trust, it's an issue of
disambiguation.  In my case, there are many different David Shaws out
there, including a furniture designer in New Zealand, a Pulitzer prize
winning journalist in the US, and a former MP for Dover in the UK.
I'm none of these.  There are at least 19 David Shaws on the keyserver
net as well, not including me.  My email address globally indicates
which David Shaw I am.
Questionable usefulness *in practice*, I said.  In practice, one of
the major uses for GPG is email, and mail clients tend to look for
keys by email address.  It's a email client design issue, not a
cryptographic issue.
Because the keyholder elected to put them together.  OpenPGP puts the
keyholder in charge of what is signable.  If the keyholder wants to be
able to have an email-only or name-only user ID, that's up to them.
The signer can't override what the keyholder decides (which makes
sense, as it's the keyholder's key).  My key has both my name and
email address, and I don't want people signing just one.
Give a challenge cookie to the person when you meet them, and ask them
for it in the email challenge.  It proves that the person who is
responding to your mail is either the physical person you met, or is
at least in communication with them.

@_date: 2005-10-27 14:11:42
@_author: David Shaw 
@_subject: ECC 
There is an experimental patch at
However, there will not be official support in GnuPG until the OpenPGP
standard gets ECC support.  There are no particular plans to do that
at this time.

@_date: 2005-10-27 18:00:42
@_author: David Shaw 
@_subject: Delete key from keyserver 
Because they're not joined together it is not a real disambiguation.
With two UIDs, it is possible for someone to remove one without
affecting the other.  We've established that people are sometimes
unwilling to sign "David Shaw" (with no email).  Having two UIDs, each
requiring their own signature, is much the same case since the email
address UID can be removed.
You don't.  But it's not up to you as the signer - it's up to the key
holder to say how he wants to be known.

@_date: 2005-10-27 18:09:40
@_author: David Shaw 
@_subject: allowed commands on keys that keyservers handle correctly 
Note that the ability to replace an old key with an updated one and
not syncing with other public servers go together.  You can't have key
replacement if you sync, since the old key can come back from a server
that hasn't done the replacement.
Biglumber is not really a keyserver.  Well, it's a keyserver in the
sense that it is a server, and it stores keys that people can retrieve
from it.  It's not a keyserver in the sense that it has no automated
interface that can be used via something like:
   gpg --keyserver biglumber.com --search-keys xxxx
Biglumber is more of a "find people to sign keys" service, though some
people do use it as a sort-of keyserver.

@_date: 2005-10-27 19:02:13
@_author: David Shaw 
@_subject: Delete key from keyserver 
You always have the option to not sign, of course.  But you don't get
to tell the keyholder what information he puts in his user ID string.
You don't create that, and it must be signed completely or not signed
at all.

@_date: 2005-10-28 14:49:48
@_author: David Shaw 
@_subject: The never-ending GD discussion,part 74 
No, free-form UIDs are the same as any other UID in the web of trust.

@_date: 2005-10-30 15:59:32
@_author: David Shaw 
@_subject: ECC 
That would work if GnuPG stood alone, but it doesn't.  New algorithms
or message constructions need to be discussed and worked out as part
of a standard so that all programs can interoperate.
This isn't to say that nobody can add new algorithms: see
 for one.  It does
mean that without standardization, only their experimental modified
GnuPG can read these messages.

@_date: 2005-10-31 01:35:09
@_author: David Shaw 
@_subject: the best signature type someone can give me 
It is not suggested.  NR signatures are useful in very specific
circumstances, and regular people signing other people's keys are not
one of those circumstances.  It's not necessarily a benefit to you
that someone can't revoke a signature - if you lose your key and can't
revoke it, you'd want your signers to revoke their signatures.
Remember that the numbers don't actually mean anything - a "2" for one
person may be the same as a "3" for someone else.  The web of trust
does not look at these numbers at all, except that signature level 1
is ignored by default.  You don't get any more validity from a 3 than
you get from a 2 or a 0.
Trust signatures are not generally useful outside of hierarchal
company-type environments.

@_date: 2005-10-31 19:45:35
@_author: David Shaw 
@_subject: the best signature type someone can give me 
Well, aside from this one:
It also doesn't take into account the very human possibility of
mistake.  If you sign by accident, you really don't want it to be a NR
First, read this:
Then, read this:

@_date: 2005-10-31 19:55:54
@_author: David Shaw 
@_subject: the best signature type someone can give me 
This is up to you, but note that most OpenPGP programs don't support
SHA512 yet.  Also note that most people have a DSA primary key and
thus can't use any hash larger than 160 bits.

@_date: 2005-09-01 05:06:12
@_author: David Shaw 
@_subject: [Sks-devel] Re: zero-length MPIs (was: Re: mpi error with 
I think this is very close, but not perfect.  You must also protect
against accidentally reading too many bytes, as then you can't parse
the rest of the stream.
Try this patch.

@_date: 2005-09-05 19:53:08
@_author: David Shaw 
@_subject: Certification-only key 
It would be 0x01.  0x00 is not meaningful in PGP since that would mean
"key with no capabilities".  The standard requires that all primary
keys must be able to certify.  Even if the 0x01 bit is not set by the
user, primary keys can certify.
It's not impossible - 1.4.3 (not released yet) supports certify-only
keys like you want.  It's not necessarily a good idea though: some
people before agreeing to sign a key will ask for a signed message to
prove that you "own" the secret portion of the key they are about to
sign.  Without the ability to sign, such a signature is hard to
Why do you want such a key?

@_date: 2005-09-05 22:47:28
@_author: David Shaw 
@_subject: Certification-only key 
They might, but really shouldn't (I wouldn't).  When you make a
certification signature on someone elses key, you're signing the
primary key plus the user ID in question.  There is no benefit in
receiving a signed challenge from any key other than the primary.
For the same reason, encryption challenges ("can you decrypt this?")
aren't usually meaningful in OpenPGP (PGP 5+, GnuPG).  Since the
object being signed is the primary key, that's the key you want to
establish ownership of.  The huge majority of primary keys in the
world today don't or can't encrypt.
GnuPG actually makes it hard for you to screw up here.  If there is a
subkey that can sign, GnuPG will use it rather than the primary.  The
only way to get a signature (as opposed to a key certification) from
the primary is to specify its key ID explicitly with an exclamation
Some people keep their primary key offline and do their regular day to
day signing and encryption with subkeys.  In that case, it's not
possible to screw up: even if you override the default by specifying
the key ID and an exclamation point, the actual key isn't there to
Yes.  Obviously you can't do things like turn a DSA key into an
encryption key, but you can certainly twiddle an RSA key into whatever
you like.

@_date: 2005-09-06 17:07:01
@_author: David Shaw 
@_subject: Certification-only key 
The flaw is that  is not necessarily a stupid thing to do.  There
are useful things that can be done by having two different keys that
happen to share subkeys.  It's not illegal in OpenPGP to do so.  In
addition, given the current design of signing subkeys, it's possible
to steal a subkey from someone elses key and pretend that their
signature is from you.  (GnuPG has a fix for this from a recent
OpenPGP draft, but I'm waiting for PGP to implement it before I turn
it on).
The real flaw here is accepting a signature from something other than
the object you are signing.  That's one step removed, and therefore

@_date: 2005-09-07 00:15:08
@_author: David Shaw 
@_subject: PGP global directory cruft in keyservers 
To my knowledge, the PGP GD doesn't sync with anyone.  It would be
interesting to know how/where these signatures are leaking into the
keyserver net.
Do you think this is that useful?  I had expected people to treat
clean-* as a "set it and forget it" feature and let GnuPG handle the
keyring.  Note that if clean-* is set, doing a --refresh-keys, as many
people do every now and then, effectively runs clean on each key.
Would be difficult to do in SKS.  You need to be able to verify
signatures (so cleaning doesn't remove the wrong signature), and right
now SKS doesn't verify signatures.

@_date: 2005-09-07 18:22:41
@_author: David Shaw 
@_subject: PGP global directory cruft in keyservers 
I'm not terribly familiar with the PGP 9 product, but does it even
have a feature to do this?  I seem to recall some notion of uploading
changes to your own key, or changes to keys that you have signed, but
not a way to upload changes to a whole keyring.
It seems like an odd feature for a program to have.

@_date: 2005-09-07 19:23:43
@_author: David Shaw 
@_subject: clean sigs 
I can't seem to duplicate your problem here.  Are you sure you saved
the result when you exited from --edit-key?

@_date: 2005-09-08 00:06:52
@_author: David Shaw 
@_subject: How to run a key server 
There are three good ways to do this:
First is SKS  While SKS is most commonly
used for public keyservers, there is no reason why you can't run it
without synchronizing with other servers.
The second is regular old LDAP.  GnuPG can use keys stored on a LDAP
server.  This is often a good choice for internal infrastructure as
many companies already have a LDAP server in use.
The third is regular old HTTP.  GnuPG can also fetch keys from a web
server.  This is not as easy as the other two options as you can't say
"find me the key with email address abcd or the like, but
for some usages this ability is not necessary.

@_date: 2005-09-08 05:01:04
@_author: David Shaw 
@_subject: PGP global directory cruft in keyservers 
Dropping all signatures that match a particular key ID would indeed
resolve a significant piece of the problem (and you don't need crypto
support in the keyservers for that), but I don't agree that this is
the fault of PGP.  PGP isn't sending these signatures out.  PGP
doesn't sync with anyone, in or out.  The question to ask is not how
to make PGP stop, but how are the signatures leaking from their
isolated island server?
I've gotten a number of private emails today from PGP 9 users who
indicate that PGP 9 has *no* functionality to bridge a key and say it
must be done manually.
Any keyserver operators care to trace down where the signatures are
being injected from?

@_date: 2005-09-08 22:00:51
@_author: David Shaw 
@_subject: clean sigs 
I'm trying, but I still can't duplicate the problem.  Can you put
together a simple keyring and simple gpg.conf file that still shows
the problem?

@_date: 2005-09-09 02:01:08
@_author: David Shaw 
@_subject: clean sigs 
No, they're not.  The only requirement is that the signatures remain
after the appropriate user ID.  Within each user ID block, though, you
can rearrange signatures without affecting anything so most programs
don't give any particular effort to keeping them in order.
GnuPG will look for your own key.  Did you generate a key with that
key ID?
Looks like they're not all that well synchronized :)
Yes, I see what happened now.  It's just a misunderstanding.  "clean"
can't work unless you have the key that issued the signature that you
want cleaned (so it can know which signatures to remove).  In your
case, you need to fetch key CA57AD7C (the PGP GD key).  Once you have
that key, GnuPG can remove signatures that it has issued.

@_date: 2005-09-09 04:29:09
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
It's your keyserver, and you of course make the choices for what it
carries, but for the record, I think this is a bad idea.  Skipping the
usual discussion about the GD (I don't think anyone will convince
anyone else at this point), you do realize that this means you are
making a decision to edit the web of trust for others based on your
own personal criteria.
I'd be all in favor of an option where users could elect to filter out
keys: that would put the user in control.  Forcing your decision on
others by stripping signatures is a very disturbing step.

@_date: 2005-09-09 05:29:54
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
You're not dropping expired signatures.  You're dropping all
signatures from a particular key - expired or not.  Those signatures
are part of the web of trust.  The web of trust now has a different
view from your keyserver than from the rest of the world.
If I ran a keyserver, would it be appropriate for me to drop all
signatures from your key D39DA0E3 simply because they're available
somewhere else?
Personal opinions as to the usefulness of signatures should not be a
factor in what a keyserver stores.  It's a very dangerous path to go
down: do you also strip signatures from someone "known" to be a bad
signer?  What's the criteria for inclusion in your keyserver?  Is it
stated somewhere so users can read it?

@_date: 2005-09-09 14:32:20
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
Obviously not.  The GD is an island that synchronizes with nobody.
The whole design of it is radically different than the other
keyservers out there in that it is not designed to store all keys.  It
is designed to store one key per active user, and that is enforced.
Synchronizing would destroy that design goal.  Not synchronizing is
also the only way they can avoid certain semantic problems with robot
Still, Jason, you can't have it both ways: you complain that the GD
won't sync, and you complain that the GD signatures leak out.  Which
do you want to fix?
Known by *you*.  I rather think the GD is a good signer, for what it
is.  I know a whole lot of other people who think the GD is a good
signer, just as I know a whole lot of people who think the GD is a bad
signer.  Is your keyserver for you personally or for the public?
Do understand, this isn't about the GD specifically: it's about a
keyserver operator who is editing their database to present a
different trust view than is really there.  When do your personal
preferences start impacting a public service?  If a user fetches a key
from sks.dnsalias.net they see one view of the world.  If they fetch
the same key from your keyserver, they see your private view of the
Or to put it another way: I know dozens of bad signers (I could tell
some horror stories here).  Should you drop their signatures too?
With regards to the GD problem, specifically: Jason, I've seen you do
amazing things with debugging the keyserver net, and point to exactly
where particular signatures entered the net.  Why don't you just see
where the signatures are leaking in from before you redefine what a
keyserver stores to suit yourself?  They're not coming from the GD,
and PGP and GnuPG have no way to bridge them automatically.  Therefore
someone is doing it manually, and on a regular basis.
If you insist on presenting a different view to users than the entire
rest of the keyserver net, without any way to turn such a "feature"
off, then I suggest that keyserver.kjsl.com be removed from the
subkeys.pgp.net rotation.  It will cause more confusion than benefit.

@_date: 2005-09-09 14:51:26
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
I have sympathy for that argument, so wouldn't it be good to trace
down where the sigs are entering the keyserver net, and ask whoever is
doing it to stop?  It seems like the obvious first step.

@_date: 2005-09-09 14:56:39
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
If the keyservers had crypto support, you could do the equivalent of
GnuPG "clean" on each key.  Without crypto support, though, you could
remove a good signature and keep a bad one.
I suspect it would be cheaper to store the extra packets than it would
be to do all the signature math for every key....

@_date: 2005-09-09 14:58:07
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
Then it needs to be done across the board after discussion by the
keyserver operators, not by a single operator acting alone.

@_date: 2005-09-09 15:42:58
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
You seem to continue to ignore my point, probably because it's easier
for you to argue this as a GD issue.  Let me try again:
1) This isn't about the GD.
2) Nope, not about the GD.
3) Still, not about the GD.
4) It's about one lone keyserver operator, without any discussion with
   other operators, editing his own keyserver to remove material he
   doesn't like.
5) Did I mention it wasn't about the GD?
Jason, what would you do if one particular keyserver in
subkeys.pgp.net refused to sync with the others, so it presented a
different view?  What would you do if one particular keyserver decided
to drop all signatures from you because they don't think you're a good
signer (0x11 signatures - argh).  Should they be dropped from
subkeys.pgp.net?  Are they breaching their responsibility to the rest
of the keyserver net?  Remember: not a GD issue.  You're editing your
keyserver based on *your* personal preferences.  Again, by the way,
not a GD issue.
You do realize, I hope, that the very email that started this thread
was from someone confused about why the keyservers weren't giving back
the same material...

@_date: 2005-09-09 16:29:48
@_author: David Shaw 
@_subject: gpg looking for strange additional key upon import (was Re: 
That looks disturbingly like uninitialized data, but I'm not able to
duplicate it here.
Here is what I'm doing:
$ rm ~/.gnupg/trustdb.gpg
$ gpg --import koch.asc
gpg: /home/dshaw/.gnupg/trustdb.gpg: trustdb created
gpg: key 57548DCD: public key "Werner Koch (gnupg sig) " imported
gpg: Total number processed: 1
gpg:               imported: 1
Can you give exact steps to follow?

@_date: 2005-09-09 16:47:03
@_author: David Shaw 
@_subject: clean sigs 
Unfortunately not, because without the signing key, gpg can't tell if
a signature is valid or not.  If there is no way to tell if a
signature is valid then the wrong thing might happen in cleaning.
Here's an example:
signature 1 from key 12345678 is dated January 1, 2000.
signature 2 from key 12345678 is dated January 1, 2001.
It would seem obvious that signature 1 should be removed... but in
fact, signature 1 is valid, and signature 2 is a forgery.  If gpg
removes signature 1, then the forger who created signature 2
effectively "revoked" signature 1.  Only if the signing key 12345678
is present can gpg tell which is the real signature.
There is perhaps an argument to be made for a "super clean" that does
clean and also removes any signature where the signing key is not
present (in fact, an early version of clean did that), but that's a
different thing than clean.

@_date: 2005-09-09 23:28:11
@_author: David Shaw 
@_subject: This IS about GD - a proposal on dealing with the problem 
So if I take material from  and distribute it around the
net, it's CNN's fault for not protecting their data better?
It might be useful to tone down the rage here.  PGP isn't producing
toxic waste.  They're producing small packets of binary data.  Nobody
is actually being poisoned and dying here.  Extra signatures on keys
do not actually harm anyone, despite all the hysterics that they seem
to cause.  At best, this is an aesthetic problem.
Also, these are not "junk" signatures.  They have semantic meaning,
and are used by many people.  Please clarify what makes a signature a
"junk" signature.  I'd like to understand why you classify them that
Where is the time (aside from the time we keep spending talking about
it)?  Where is the aggravation?
Costs?  Picking a random GD signature off my key, it is 293 bytes
long.  Let's guess that there are around 10,000 keys that exist both
on the SKS net and the GD.  Let's also say that there is a malicious
person out there who is bridging *every one* of those 10,000 keys.  I
doubt this is happening, but again, let's go with it.  Given all those
weighted-to-be-awful numbers, what does that come to?  2.8 megabytes.
The GD reissues signatures on demand, more or less every 2 weeks.  52
weeks in a year, so the GD will add 72.7 megabytes a YEAR to the SKS
server net.  72.7 megabytes a year.  In 8 years, we'll have enough to
fill a CD-ROM.
Allow me to opine that if we're hurting from 72.7 megabytes a year,
than the keyserver net has other problems than the GD.
Why the outrage?  I really don't understand why people are so hopping
mad about this.  Turn on "import-clean" in your gpg.conf and you'll
never see more than one GD signature at a time.
It's fairly obvious at this point that someone is bridging the GD to
the keyserver net.  PGP (the company) isn't doing it, and PGP (the
product) and GnuPG have no way to do it automatically.  Again, may I
suggest that before we implement changes in keyservers or send
threatening letters to the PGP company or even just continue to vent,
we simply track down who is doing it and ask them nicely to stop?
I've seen Jason pull off miracles at tracking down the origin of bad
packets on the keyserver net.  That would actually accomplish
something, rather than getting all angry and scolding PGP (which might
make people feel better, but likely won't change any part of the GD).

@_date: 2005-09-09 23:29:12
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
Yep.  Oddly enough, people seem to blame the GD and PGP company rather
than blaming the actual litterer.

@_date: 2005-09-10 15:35:02
@_author: David Shaw 
@_subject: gpg looking for strange additional key upon import (was 
Aha!  I found the problem.  It's actually a bug in the German
translation.  I was testing in English, so never saw it.  I'll file a
bug for that.  Thanks for your help running this one down.

@_date: 2005-09-10 18:46:35
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was: Re: clean sigs) / Feature 
There is such a flag, and GnuPG even sets it by default (type
"showpref" in the --edit-key menu and you'll see "keyserver
Unfortunately, the keyservers don't honor the flag...

@_date: 2005-09-12 04:29:42
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
It wasn't an idle suggestion.  You can assume that I do, in fact, know
that this is possible, or I wouldn't have suggested it.  Why on earth
an email address is relevant here I have no idea.  You don't need
anything more than the IP address.
I made the suggestion as a challenge.  The trace is not actually going
to happen, as it is far, far more entertaining to complain and moan
about the GD than it would be to see who is bridging the signatures.

@_date: 2005-09-12 04:31:59
@_author: David Shaw 
@_subject: [Sks-devel] stripping GD sigs (was:  Re: clean sigs) 
No, actually it doesn't.  The GD doesn't distribute signatures in
bulk.  In fact, you have to fetch each new signature manually.

@_date: 2005-09-12 04:42:40
@_author: David Shaw 
@_subject: This IS about GD - a proposal on dealing with the problem 
There are so many levels of wrong here that I am actually struck
utterly silent.  Congratulations.  I'm leaving the thread.  I cannot
answer without somehow falsely implying that there is any signal in
the noise.

@_date: 2005-09-12 05:01:59
@_author: David Shaw 
@_subject: clean sigs 
I rather like "minimize", but this isn't really a minimal key (as it
has signatures other than selfsigs).

@_date: 2005-09-12 20:30:43
@_author: David Shaw 
@_subject: gpg: invalid armor header 
That comment was correct.  What happens is a message that has a
version line that is very long.  Something like:
Version: PGP 8.0.2 - not licensed for commercial use: The line is long enough that the " on the end linewraps
around when the message is pasted into some mail clients.  The
 on its own line breaks the message.

@_date: 2005-09-14 13:45:49
@_author: David Shaw 
@_subject: Importing keys 
Keyrings must be binary format.
Incidentally, keyring format isn't defined by the RFC - just the
import/export transport format.  Historically, though, most programs
use the binary format.  It isn't guaranteed to stay this way forever,
and this is why there is the frequent advice to not rely on the fact
that a keyring is just a block of binary keys glued together.

@_date: 2005-09-14 17:06:45
@_author: David Shaw 
@_subject: Two questions 
gpg --edit-key (thekey)
I'm not quite sure what you mean here.  Thawte certs are X.509 - it's
a different creature than OpenPGP.

@_date: 2005-09-15 03:01:08
@_author: David Shaw 
@_subject: How to delete a secret key in batch mode? 
1CBB4C01 is not a fingerprint.  Do this:
  gpg --fingerprint 1CBB4C01
The resulting value is a fingerprint.

@_date: 2005-09-16 11:17:20
@_author: David Shaw 
@_subject: Bug? 
Is it a bug?  Yes and no.  Those messages in 1.4.1 indicate an actual
problem with a key (corruption or other oddness).  However, keys in
the wild on keyservers are mangled often enough that GnuPG has been
modified to accept them anyway.
This modification is partly done in 1.4.2 (the current version), and
will be complete in 1.4.3 (the next version).

@_date: 2005-09-19 23:54:56
@_author: David Shaw 
@_subject: Windows Corp Implementations 
Not at all: LDAP makes an excellent keyserver protocol.  GnuPG can
already use an AD box as a keyserver (or OpenLDAP, iPlanet, etc).  The
schema is the same one that PGP uses for its LDAP keyserver support.

@_date: 2005-09-21 20:11:49
@_author: David Shaw 
@_subject: Extracting a single signature from a file containing multiple 
Yes, and yes.
To separate signatures, use 'gpgsplit', which comes with gpg.  You'll
end up with each signature in its own file.
The documentation of the signature file format is in RFC-2440:

@_date: 2005-09-24 18:43:16
@_author: David Shaw 
@_subject: --throw-keyid and -R options 
Since you are using -R (which does a per-recipient --throw-keyid) for
both recipients, there is no difference between the two commands.
There is: there are both options --throw-keyid and --throw-keyids
(they do the same thing).  Come to think though, --throw-keyid could
be removed since is effectively an abbreviation of --throw-keyids.

@_date: 2005-09-28 04:36:18
@_author: David Shaw 
@_subject: Any way to get smaller key sizes? 
Yes, but it's almost impossible to answer this because it's not clear
what you're doing.  Are you storing the keys or the results?  1024 bit
keys with what algorithm?  The only key type that is locked to 1024
bits is DSA and that's a signing algorithm, so encryption never comes
into the equation.
Say what you're doing, and we can help a lot.

@_date: 2005-09-28 18:54:48
@_author: David Shaw 
@_subject: Any way to get smaller key sizes? 
Well, it's a tiny difference in practice, but you can generate small
Elgamal keys by using the --expert flag along with --gen-key.

@_date: 2005-09-30 15:46:44
@_author: David Shaw 
@_subject: Can't check message signature 
Interesting.  This means that the signature is malformed in a
particular way.  If there is nothing private in it, could you send me
the message off-list?

@_date: 2006-04-02 00:52:33
@_author: David Shaw 
@_subject: ElGamal: key length vs performance 
Not significantly.  GnuPG uses Elgamal to encrypt a session key, which
is only around 16-32 bytes long.  That's not going to change much
regardless of the key length.  If you were encrypting many files over
and over again, perhaps, but most people never notice it in practice.
The performance between different ciphers (3DES, AES, CAST5, etc) is
where you might see something, and it will vary over different sized
files to encrypt.

@_date: 2006-04-03 20:53:33
@_author: David Shaw 
@_subject: GnuPG 1.4.3 failed to compile 
Looks like you're building with --enable-m-guard.  Try turning it off.

@_date: 2006-04-04 00:15:45
@_author: David Shaw 
@_subject: gnupg 1.4.3 build fails @ 'make' on OSX 10.4.5, 
This one doesn't seem related to GnuPG: you installed a a new gettext
and it's conflicting with the Apple-shipped iconv.
What happens if you build with --with-included-gettext ?

@_date: 2006-04-04 03:02:40
@_author: David Shaw 
@_subject: gnupg 1.4.3 build fails @ 'make' on OSX 10.4.5, 
It was just luck that 1.4.3 triggers the failure and 1.4.2 doesn't.
The code in 1.4.3 is legal.  Your library setup seems not to be.
I have a Tiger box and 1.4.3 builds fine.  Even if I add readline, it
still builds fine.  Maybe go to the Apple site and download the latest
build environment?  Aside from that, I'm not sure what to suggest to
you aside from building without your added readline or with
--disable-nls, or maybe with --disable-gnupg-iconv

@_date: 2006-04-04 05:14:04
@_author: David Shaw 
@_subject: renewing of expired signatures 
It depends on what version of GnuPG you are talking about.  For over
two years now, (since version 1.3.3 in October 2003), GnuPG will
prompt you with:
  Your current signature on "(whatever)"
  has expired.
  Do you want to issue a new signature to replace the expired one? (y/N)

@_date: 2006-04-04 23:56:31
@_author: David Shaw 
@_subject: dns cert support (was: GnuPG 1.4.3 released) 
While you could try and do some magic with piping the output of dig
into a script, at the moment, simulating an encryption is the only
easy way to do it directly from GnuPG.  I do plan to have a
--locate-keys command to do this in the next version; I just didn't
want to delay the 1.4.3 release any further.
Good idea.  I just checked one in to the GnuPG SVN.

@_date: 2006-04-05 14:41:42
@_author: David Shaw 
@_subject: dns cert support 
At the moment, GnuPG will take whichever it sees first (the PGP or the
IPGP, but not both).  So given round robining, if you have both, it
will seem to flip back and forth between the two.  I'm thinking about
having GPG favor one or the other in these cases (probably PGP since
if it has already fetched the whole key, it may as well import it
rather than go to a web page or keyserver somewhere).
The reason it is not fetching from the IPGP record you have there is
there is only a fingerprint, and you must have a --keyserver defined
for it to fetch the fingerprint from in that case.  Do you have a
--keyserver defined?

@_date: 2006-04-05 16:51:54
@_author: David Shaw 
@_subject: dns cert support 
Certainly the CERT PGP type has size restrictions, but I think that's
fine: I don't really see the CERT PGP type as a repository for whole
keys with dozens of signatures like on a keyserver.  Rather, it's a
place to store minimal (via export-minimal) keys.  Once this "seed"
key is gotten via CERT PGP, it can be fleshed out via a keyserver or
preferred keyserver subpacket on the key itself.
The GnuPG 16k max-cert-size is changeable, by the way:
  --keyserver-options max-cert-size=65536
16k was a bit of a guess as to a good value since CERT is so new.
Whether to favor CERT PGP or CERT IPGP is one of those things where a
reasonable case can be made for either path.  It depends on what
you're using CERT for: if you were using CERT in a PKA-like scheme,
you'd want CERT PGP to get the answer as fast as possible, while if
you were using CERT as a automatic key locater you'd probably want
CERT IPGP to get all the signatures.
Yes, I think it should.  Note that you could make your IPGP contain
both a fingerprint and a URL - that way you get to specify where the
user will fetch your key from (it may not exist in the manner you
desire on their particular keyserver).

@_date: 2006-04-06 03:44:34
@_author: David Shaw 
@_subject: pka-lookups 
It depends on the feature.  Certainly require-cross-certification will
not be turned on by default in 1.4.4.  Too soon.
It's there.  It says:
    When  verifying  a signature made from a subkey, ensure that the
    cross certification "back signature" on the subkey is present and
    valid.  This protects against a subtle attack against subkeys that
    can sign.  Currently defaults to --no-require-cross-certification,
    but will be changed to --require-cross-certification in the
    future.

@_date: 2006-04-06 04:01:27
@_author: David Shaw 
@_subject: 1.4.3 // proper syntax for --edit-key cross-certify ? 
PGP does not generate signing subkeys.  You generated a RSA encryption
key that happened to be without key flags (I guess that version of PGP
didn't use them yet), and so it appears as a RSA sign+encrypt key in
Bottom line is, this does not work on PGP generated keys.

@_date: 2006-04-06 17:02:57
@_author: David Shaw 
@_subject: 1.4.3 // proper syntax for --edit-key cross-certify ? 
PGP generated keys are not any different than GPG generated keys in
this regard.  Go ahead and use a ! if you like.

@_date: 2006-04-06 23:42:25
@_author: David Shaw 
@_subject: Date and time format 
GPG uses whatever the OS specifies as the date format.  It is not
something that is changeable by GPG - you need to set the date format
in your OS.

@_date: 2006-04-07 00:23:04
@_author: David Shaw 
@_subject: Date and time format 
OS setting via LC_TIME, according to Microsoft, though I have no idea
how to set it on win32.

@_date: 2006-04-07 17:30:14
@_author: David Shaw 
@_subject: fetching DE415B0E from sks ([don't know]: invalid packet 
This is a feature, believe it or not.  During an import (and a
keyserver --recv-keys or --refresh-keys is really just an import), GPG
reads packets off the input stream.  Once any of those packets prove
invalid (a packet starting with 2D is invalid), there is no way to
know where it is in the stream - how many bytes should it jump ahead
to get back on the track.

@_date: 2006-04-08 02:21:23
@_author: David Shaw 
@_subject: fetching DE415B0E from sks ([don't know]: invalid packet 
--import (and therefore --refresh) does try to handle all keys in the
stream.  It just can't continue once there is a stream error as there
is no way to reestablish its place in the stream.  The stream coding
more or less says stuff like "here's a signature and it's 40 bytes
long (40 bytes here)".  GPG reads that and keeps going.  If GPG sees
"here's garbage and it's garbage bytes long", it can't read it because
it's garbage, and it can't skip it because it doesn't know how many
(garbage) bytes to skip over.  The only thing it can do at that point
is stop.
Keyserver operations result in multiple streams (one per key).  If one
errors out, it might be possible to jump to the next BEGIN header, but
that would be a pretty nontrivial undertaking given how the code
currently works.
All that said, though, I'm not convinced that the armored stream you
got from the keyserver is invalid.  I think there may be a problem in
GPG's armor parser (hard to imagine after this many years, but..)  It
seems that the bad key is the right length (exactly 8192 bytes) to
trigger a problem.
That's easy.  I'll do that.

@_date: 2006-04-09 02:10:59
@_author: David Shaw 
@_subject: auto-key-locate pka (gpg version 1.4.3) 
This means that the build of GnuPG you has no DNS support (pka and
cert require DNS support, and ldap and keyserver don't).

@_date: 2006-04-09 15:27:21
@_author: David Shaw 
@_subject: fetching DE415B0E from sks ([don't know]: invalid packet 
This was indeed a bug.  I've attached the fix.  With this patch in
place, you should be able to import DE415B0E without error.

@_date: 2006-04-09 16:38:27
@_author: David Shaw 
@_subject: auto-key-locate pka (gpg version 1.4.3) 
Cross-certification and PKA/CERT are unrelated to each other.  What
(public) key were you trying to cross-certify?

@_date: 2006-04-09 18:21:42
@_author: David Shaw 
@_subject: auto-key-locate pka (gpg version 1.4.3) 
I think there is a misunderstanding.  None of those keys have signing
subkeys.  Cross-certification is meaningless without a signing subkey.

@_date: 2006-04-09 21:40:33
@_author: David Shaw 
@_subject: Error: MPI larger than indicated length 
I don't think anyone here can help you without knowing what version of
GnuPG you're talking about.

@_date: 2006-04-10 00:27:44
@_author: David Shaw 
@_subject: More questions about: "gpg: WARNING: message was not integrity 
MDC can be forced on via --force-mdc.  As Werner said, the preference
system will automatically handle this for public key encryption.  For
symmetric encryption (which has no preference system), you can use
--force-mdc if you want a MDC.
In an effort to increase the use of MDC, it was noted that all
implementations that could handle AES could also handle MDC.  Thus,
using any AES (or TWOFISH) turns the MDC flag on for you.
It is, but this is not a complete answer.  Neither of you should have
a cipher-algo set in your gpg.conf file.  If you do, you're fighting
against all the automatic parts of the system.  Let GPG do what it is
supposed to do and you'll be better off.
That's sort of an apples and oranges question.  CAST5 is a 128-bit
cipher.  AES256 is a 256-bit cipher.  Is CAST5 weaker than AES256?
Yes, but that's that not to say that CAST5 is broken somehow: AES256
is just twice as large.

@_date: 2006-04-10 02:10:15
@_author: David Shaw 
@_subject: More questions about: "gpg: WARNING: message was not integrity 
Exactly.  Which is a great example why people should not set
particular ciphers, and just let the automatic system do its job.  The
main point of the automatic system is to prevent mismatches like this.

@_date: 2006-04-10 02:11:43
@_author: David Shaw 
@_subject: More questions about: "gpg: WARNING: message was not integrity 
Indeed.  However, again, that doesn't mean CAST5 is broken.  Just
smaller than AES256.
AES256 is vastly stronger than most people need in practice.  Heck,
CAST5 is vastly stronger than most people need in practice.  Even so,
AES256 is more or less the default for new keys in both PGP and

@_date: 2006-04-10 14:10:44
@_author: David Shaw 
@_subject: auto-key-locate pka (gpg version 1.4.3) 
No.  There is no compile-time question whether enarmor exists or not.
It just exists.  If you want a list of all keywords that GnuPG
understands, use "gpg --dump-options".

@_date: 2006-04-10 14:52:03
@_author: David Shaw 
@_subject: More questions about: "gpg: WARNING: message was not integrity 
You should really use MDC whenever you can.  The only time you should
not use it is when communicating with someone who can't read it.  If
you are encrypting to yourself, you can assume you can read it, of
Basically, yes.
Every key has a number of preferences on it (they live on the
self-signature).  The union of these lists are taken together which
results in a list of ciphers that everyone can handle.  That is, it
doesn't matter in terms of interoperability which cipher is chosen
from this list.  To make sure that there is always a choice even if
the union is empty, in this case 3DES is used.  Finally, your
personal-cipher-preferences are consulted to pick the one from this
list that you personally like best.  MDC works similarly: each key is
consulted to see if it can handle MDC.  If all can, then MDC is used.
If AES or TWOFISH happens to be in the preferences, then it is assumed
that MDC exists even if the MDC-is-usable flag isn't set.
Have you ever bought a pizza with a number of people?  The preference
system is a bit like that.  Everyone seems to like a different topping
on the pizza but can more or less agree on something.  (Though you
can't get half one thing and half another with crypto!)
Three.  I had forgotten for a moment the larger blocksize of AES256, as
Werner pointed out.
You could turn the MDC flag on for CAST5 for yourself, of course, but
that still leaves the larger keyspace and larger blocksize that AES256
Backwards compatibility.  CAST5 has been around it seems forever.
AES256 hasn't.
It's fine to use AES256, just don't do it with "cipher-algo AES256".
Use "personal-cipher-prefs" instead, and list the ciphers you prefer
in the order you prefer them.  Then AES256 will be used whenever it is
possible to use it (including --symmetric encryption), rather than
forcing AES256 even when the recipient won't be able to read it.
Incidentally, AES256 is really, really strong.  How strong is your
public key?  In most cases, the public key is not as strong as AES256,
so an attacker may choose to go up against the weaker public key
encryption and not attack AES256 at all.  The NIST people estimate
that you'd need a 15360-bit DSA or RSA key to match the strength of
Nothing wrong with using AES256 anyway, of course, so long as your
public key is strong enough for your purposes.

@_date: 2006-04-10 18:13:31
@_author: David Shaw 
@_subject: More questions about: "gpg: WARNING: message was not integrity 
Try "personal-cipher-preferences".  Maybe vim only highlights the
longer form of the name.

@_date: 2006-04-22 15:41:20
@_author: David Shaw 
@_subject: Non-ascii embedded filename 
Indeed.  This is fixed for 1.4.4.  Embedded filenames are now UTF-8
encoded on the way in, and UTF-8 decoded on the way out.

@_date: 2006-08-01 04:35:46
@_author: David Shaw 
@_subject: [Fwd: perl EUID change causing failure] 
This is not a bug, and it certainly isn't new behavior.  GnuPG will
not run if the euid does not match the uid.  On a number of platforms,
GnuPG is installed setuid root so it can grab locked/unswappable
memory.  Once it has allocated a block of memory, it drops root privs.
To prevent any chance of an attacker fooling the system into letting
it keep root privs, it will halt if euid!=uid.

@_date: 2006-08-02 02:21:18
@_author: David Shaw 
@_subject: solaris certification 
It's hard to fully answer this question.  What does "certifying" mean
to you?  Yes, I am one of the GPG developers, and yes, I say that GPG
functions correctly on Solaris.  However, why should you trust me? ;)
GPG is supported via the community.  If you need a higher level of
support (i.e. an email address or a phone number you can use and get
an guaranteed answer), you might want to take a look at
 where you can contact companies who
offer service contracts.

@_date: 2006-08-02 04:57:53
@_author: David Shaw 
@_subject: solaris certification 
No reason from the GPG perspective: meaning that GPG should
automatically detect that /dev/[u]random exists at ./configure time
and build in the necessary code to talk to it, but also meaning that
you need to decide whether SUNrand is something you want to use.
I don't mean this to imply that SUNrand is bad or weak or anything
like that, just that nobody can make this decision for you.
You might want to play around with

@_date: 2006-08-02 18:08:52
@_author: David Shaw 
@_subject: [Fwd: perl EUID change causing failure] 
It is, yes.
That's exactly the reason.  That assertion was put in to prevent a
possible root privilege elevation if someone managed to trick the
memory locking code.
You're the first person that I recall hitting that assertion under
normal operation.

@_date: 2006-08-02 18:13:06
@_author: David Shaw 
@_subject: Security of truncated hash functions 
Note, though, that NIST explicitly allows (i.e. requires) hash
truncation in the new DSA spec.  At least in the context of DSA, the
official answer is that either a full SHA1 or a truncated SHA256 is
roughly of the same safety.

@_date: 2006-08-02 18:23:59
@_author: David Shaw 
@_subject: Security of truncated hash functions 
Er, sorry.  That should be "either a truncated SHA256 or a truncated
SHA512 is roughly of the same safety".

@_date: 2006-08-10 19:48:13
@_author: David Shaw 
@_subject: Export-Classification 
Yes, it does.  All of those parts (all of GnuPG, actually) fall under
the TSU exception, which more or less exempts open source crypto from
This is a simplification, of course.  Export classification is a
vastly more complex topic than can be covered in an email.

@_date: 2006-08-11 19:17:43
@_author: David Shaw 
@_subject: GPG question 
cat thefile.gpg | gpg | gpg -r recipient_1 -r recipient_2 -r recipient_3 --encrypt > output.gpg
The catch is that the first gpg instance is doing to need to prompt
you for a passphrase, and the second gpg instance may need to prompt
you whether the recipients are trusted (if you don't have a trust path
to them).  An easy way to fix this, is to add a "--trust-model always"
to the second instance (assuming you really do trust those recipient

@_date: 2006-08-12 21:18:16
@_author: David Shaw 
@_subject: Keyserver Software Recommendations 
In short, yes.  Given your requirements, SKS is the best (and really
only) choice.  Make the effort, and if you have problems, ask on the
SKS mailing list:

@_date: 2006-08-14 16:38:17
@_author: David Shaw 
@_subject: GPG question 
GPG can do it, of course, but automating passphrases is something that
needs some thought before you go ahead.  There are three ways to pass
a passphrase to GPG: via a file, via a file descriptor, or just on the
command line.  Any of these will work, but you need to ask yourself
whether this is a risk in your environment.  For example, if you pass
the passphrase on the command line, anyone who can log into the box
can see the passphrase via 'ps'.  If you pass the passphrase via a
file, anyone who can read that file can see the passphrase.  These
details are also different on Unix-like systems or Win32 (not sure
which you are using).
You also need to ask yourself: if you're just going to hardcode a
passphrase anyway, would it be better to simply use a key with no
passphrase at all?
On the command line:
  gpg --passphrase (the-passphrase)
Via a file:
  gpg --passphrase-file (the-filename)
Via a file descriptor
  gpg --passphrase-fd (the-fd)

@_date: 2006-08-15 19:09:14
@_author: David Shaw 
@_subject: GPG and 1024-bit (or multiple) subkeys 
In short, no.  Your customer is confused.  GPG does not require any
particular key size.  By default, it will generate 2048-bit keys, but
it will work quite happily with 1024-bit, 4096-bit, or whatever you
feel like using.
Yes, it does, but given that the premise behind the customer's
question is wrong, this may not be the answer:
    Note that you can append an exclamation mark (!) to key IDs or
    fingerprints.  This flag tells GnuPG to use the specified
    primary or secondary key and not to try and calculate which primary
    or secondary key to use.

@_date: 2006-08-18 21:23:54
@_author: David Shaw 
@_subject: Multiple recipients 
No.  OpenPGP doesn't work that way.
For convenience, you can put stuff in the gpg.conf file like this:
  group merged_named = user1 user2 user3
and then encrypt to "merged_names", but that's still encrypting to all
three separately.

@_date: 2006-08-18 21:54:53
@_author: David Shaw 
@_subject: Multiple recipients 
OpenPGP doesn't work that way.  You can either give the single key to
each user, or have one "special" user decrypt the message and
then re-encrypt it to multiple users.

@_date: 2006-08-18 23:16:26
@_author: David Shaw 
@_subject: Multiple recipients 
Doesn't this violate the "have their own key for security and auditing
purposes" requirement?

@_date: 2006-08-20 03:16:40
@_author: David Shaw 
@_subject: Don't store your key on a flash drive! [was Re: GnuPG (GPG) 
This is quite correct and frequently misunderstood.  After all, the
secret key encryption is essentially the same symmetric encryption
that is used to encrypt messages.  If you're trusting it to protect
your messages, you probably should trust it to protect your key as
The big difference, as I see it, between a smartcard and a flash key,
is not so much in how it protects the key "at rest" (i.e. a stolen
smartcard or flash key), but how it protects the key when in use.
A flash key has a mountable filesystem with actual files on it.  A
compromised host machine could copy the secret key file, while
simultaneously keylogging the passphrase for it.
A smartcard cannot give up the secret key in normal use - there is
simply no interface to do that.  (I'm not counting electron
microscopes and the like as "normal use" here.  Normal use is sticking
the card into a reader.)  A compromised host machine could keylog the
passphrase, but can't get the key.
In either case, a compromised host can *use* the key, say to decrypt
something, or make a signature.
Yes.  Smartcards really lag behind what general purpose machines can
generate.  1024 is fairly rare these days, and even 4096 is becoming
more common.

@_date: 2006-08-28 14:57:57
@_author: David Shaw 
@_subject: I don't get it - utf8 on Mac 
It's not your fault.  There is an old bug in the Mac libraries such
that it reports everything as US-ASCII.  Stick "display-charset utf-8"
in your gpg.conf file and that will override the libraries.

@_date: 2006-08-29 18:07:59
@_author: David Shaw 
@_subject: Using subkeys to renew an expiring key 
It's not clear what you mean by "set our key to expire every year".
Are you expiring your whole key, or just the additional subkey?
Your choice.  You can extend the expiration of your subkey if you
like.  If the reason you used a 1-year expiration was to limit the use
of the key, then sure, make a new subkey.
There is a flaw in this question.  Why are you revoking a subkey that
will expire?  After September, 2006, the older subkey won't work.

@_date: 2006-08-31 17:27:21
@_author: David Shaw 
@_subject: importing preference changes 
Any time you import a key, GnuPG will check to see if the key is
advertising preferences that GnuPG can't fulfil.  If you don't update
the preferences to match reality, you can receive messages that you
won't be able to decrypt.
This does not parse.  Do you have some reason to believe the
preference system is insecure?  If so, please state it directly.
It does.  Are you piping the GPG output somewhere and missing it?
The full message printed would be something like:
gpg: WARNING: key XXXXXXXX contains preferences for unavailable
gpg:          algorithms on these user IDs:
gpg:          "whatever": preference for cipher algorithm AES
gpg: it is strongly suggested that you update your preferences and
gpg: re-distribute this key to avoid potential algorithm mismatch problems

@_date: 2006-12-03 06:23:53
@_author: David Shaw 
@_subject: gpg strips '0x' on key searches... 
It's in GPG.  You're quite right, and this is fixed for the next

@_date: 2006-12-05 21:44:32
@_author: David Shaw 
@_subject: encrypt the sent folder 
I must disagree with this.  OpenPGP is not solely a wire protocol.
There are even parts of the specification that were added mainly for
the benefit of mass storage.  It's being used in storage in a number
of places today.
The nice thing about using OpenPGP as an archival primitive is that
each encrypted file is its own file and decrypting one does not impact
any others.  This works well in the context of email, where each mail
is its own object.

@_date: 2006-12-05 22:14:03
@_author: David Shaw 
@_subject: encrypt the sent folder 
Absolutely.  It all depends on what the goal is.  Given a compromise,
many distinct files can limit the damage done to a subset (or one) of
the encrypted files.  A compromise of an encrypted filesystem
generally compromises the whole filesystem containing all the files.
On the other side, as you say, an encrypted filesystem will probably
outperform multiple encrypted files.  Given the original request (to
store encrypted mails on a remote IMAP server), OpenPGP seems like an
obvious answer as it works even when the remote IMAP server isn't
under the control of the user (which is often the case).
OpenPGP (and encrypted filesystems) are two good solutions to two
slightly different and overlapping problems.

@_date: 2006-12-07 17:48:13
@_author: David Shaw 
@_subject: Problem building 2.0.1 
OSX has iconv already.  I see a problem in the Makefiles that we're
not linking to it though.  I've fixed this in svn, and 2.0 now builds
more or less (still some doc/ issues) on my OSX box.
Here's a patch for the various people who have had a problem.

@_date: 2006-12-07 17:57:25
@_author: David Shaw 
@_subject: GnuPG 2.0.1 compile error 
We need at least a tiny bit of information to try and help you.  Let's
start with what kind of computer you have and what OS is running on
it?  Then look in config.log and see what it says about zlib.h (stuff
like "checking for zlib.h usability" and "checking for zlib.h").

@_date: 2006-12-07 18:04:24
@_author: David Shaw 
@_subject: Problem building 2.0.1 
That's not correct.  10.3 has iconv.  10.2 doesn't, but, well, 10.2 is
also from 2002.  Get modern, people, or compile iconv yourself ;)

@_date: 2006-12-07 22:59:24
@_author: David Shaw 
@_subject: Fwd: GnuPG 2.0.1 compile error 
Ok.  The problem is simple: you don't have zlib installed, or at least
don't have the zlib development package installed.  I'm not sure what
it's called on Ubuntu, but there is probably some variation of "zlib"
and some variation on "zlib-devel".  You need zlib-devel.
GnuPG 1.4.x comes with a built-in zlib just in case the build platform
doesn't have one.  GnuPG 2.0.x doesn't have a built-in one, so you
must provide it yourself.

@_date: 2006-12-08 08:53:02
@_author: David Shaw 
@_subject: Problem building 2.0.1 
That is correct.  Charly, you have to run automake before the patch is
useful to you.

@_date: 2006-12-11 15:16:50
@_author: David Shaw 
@_subject: Upgrade from 1.2.1 to 1.4.6 
While there are many reasons to upgrade to 1.4.x, note that there was
a 1.2.x version released with a fix for last week's vulnerability.
 ftp://ftp.gnupg.org/gcrypt/gnupg/gnupg-1.2.8.tar.bz2
 ftp://ftp.gnupg.org/gcrypt/gnupg/gnupg-1.2.8.tar.bz2.sig
 ftp://ftp.gnupg.org/gcrypt/gnupg/gnupg-1.2.8.tar.gz
 ftp://ftp.gnupg.org/gcrypt/gnupg/gnupg-1.2.8.tar.gz.sig
I'd still upgrade to 1.4.6, but this might allow you to do it in a
more relaxed manner.

@_date: 2006-12-11 23:07:48
@_author: David Shaw 
@_subject: GPG question 
It's hard to answer your question, since there are multiple different
things in GPG that could fit the description of "selecting the
symmetric cryptographic algorithm".  Please explain further what you
are trying to do.  Are you trying to set the preferences on your key
so other people will send you messages encrypted with a particular
cipher?  Are you trying to set the outgoing cipher to something?

@_date: 2006-12-11 23:08:43
@_author: David Shaw 
@_subject: Problem building 2.0.1 (on Mac OS X 10.4.8) 
I think the best bet here would be to wait for the next 2.x rc
release.  There have been a number of changes.

@_date: 2006-12-21 16:17:57
@_author: David Shaw 
@_subject: Importing a key that has been revoked by a designated revoker 
This is neither a bug or a feature, but a natural result in how
designated revokers work.  Designated revokers do their job by issuing
a signature onto the key they want to revoke.  Naturally, if the
designated revoker's key isn't on the keyring, we have no way to
verify the signature.  If we can't verify the signature, we can't know
if it's real or a forgery.
Keys in this state are treated specially: neither revoked or not
revoked, but with a question attached.  If you verify a signature from
such a key, you'll see:
  gpg: WARNING: this key might be revoked (revocation key not present)
It might be a good idea to display a similar warning on encryption to
such a key, but we don't do that right now.

@_date: 2006-12-27 15:42:08
@_author: David Shaw 
@_subject: Issues w/Daylight Savings Time in 2007 ? 
GPG (like all OpenPGP programs) uses the common "seconds since
1/1/1970 UTC" method of storing time where daylight savings time or
other conversions are irrelevant.
Of course, people use GPG within an operating system which may or may
not give GPG the right time.  So, the best answer I can give is that
if your OS is correct, GPG will be too.

@_date: 2006-12-28 00:30:43
@_author: David Shaw 
@_subject: gnupg clearsigning question 
DSA signatures contain random data, so even if you hacked around the
timestamp problem, the signature would not match.  RSA signatures do
not contain random data.
However, even if you managed to do this with an RSA key, why on earth
would you want to construct such a massively convoluted way, involving
hacking around the clock on your computer, just to generate a key that
would be not good as a simple file with random numbers in it would be?
Why create complications when the simple answer is both easier and
more secure?

@_date: 2006-12-28 01:10:24
@_author: David Shaw 
@_subject: Issues w/Daylight Savings Time in 2007 ? 
Werner would have to say the reason, but I want to note that this is
only an output/display change.  Internally, GPG will always use
seconds since epoch for OpenPGP as this is part of the OpenPGP

@_date: 2006-12-28 09:27:32
@_author: David Shaw 
@_subject: gnupg clearsigning question 
No, the random data is part of DSA.  The reason that RSA is large and
DSA is small is unrelated to the use of random data.

@_date: 2006-12-28 20:28:14
@_author: David Shaw 
@_subject: Signature notations? 
They're not notations, so the various methods of showing notations
won't help you.  The revocation reason is stored within the revocation
signature, and is shown when a signature made by the revoked key or
subkey is verified, or when decrypting a message encrypted to the
revoked key or subkey.

@_date: 2006-02-17 04:43:46
@_author: David Shaw 
@_subject: [Announce] First release candidate for 1.4.3 available 
We are pleased to announce the availability of the first release
candidate for the forthcoming 1.4.3 version of GnuPG:
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.3rc1.tar.bz2 (2.9M)
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.3rc1.tar.bz2.sig
SHA-1 checksums for the above files are:
 6c2d5f65c2acde6eaeb1ae3a4bc9ae971f942126  gnupg-1.4.3rc1.tar.bz2
 62f13c67d5a32bb9747db0da667e420e5391f1e7  gnupg-1.4.3rc1.tar.bz2.sig
Note that this is only a release candidate, and as such is not
intended for use on production systems.  If you are inclined to help
test, however, we would appreciate you trying this new version and
reporting any problems.
Noteworthy changes since 1.4.2:
    * If available, cURL-based keyserver helpers are built that can
      retrieve keys using HKP or any protocol that cURL supports
      (HTTP, HTTPS, FTP, FTPS, etc).  If cURL is not available, HKP
      and HTTP are still supported using a built-in cURL emulator.  To
      force building the old pre-cURL keyserver helpers, use the
      configure option --enable-old-keyserver-helpers.  Note that none
      of this affects finger or LDAP support, which are unchanged.
      Note also that a future version of GnuPG will remove the old
      keyserver helpers altogether.
    * Implemented Public Key Association (PKA) trust sub model.  This
      is an optional trust model on top of the standard ones.  It make
      use of special DNS records and notation data to associate a mail
      address with an OpenPGP key. It is by default not used.  To use
      it you need to set the new option --allow-pka-lookup and an
      appropriate trust-model.  Also added new keyserver option
      auto-pka-retrieve which is enabled by default but only working
      if --allow-pka-lookup is also used.
    * When exporting subkeys, those specified with a key ID or
      fingerpint and the '!' suffix are now merged into one keyblock.
    * Added "gpg-zip", a program to create encrypted archives that can
      interoperate with PGP Zip.
    * Added support for signing subkey "back signatures".  Requiring
      back signatures to be present is currently off by default, but
      will be changed to on by default in the future, once more keys
      contain the back signature.  A new "backsign" command in the
      --edit-key menu can be used to update signing subkeys with back
      signatures.
    * The key cleaning options for --import-options and
      --export-options have been further polished.  "import-clean" and
      "export-clean" replace the older
      import-clean-sigs/import-clean-uids and
      export-clean-sigs/export-clean-uids option pairs.
    * New "minimize" command in the --edit-key menu removes everything
      that can be removed from a key, rendering it as small as
      possible.  There are corresponding "export-minimal" and
      "import-minimal" commands for --export-options and
      --import-options.
    * New --fetch-keys command to retrieve keys by specifying a URI.
      This allows direct key retrieval from a web page or other
      location that can be specified in a URI.  Available protocols
      are HTTP and finger, plus anything that cURL supplies, if built
      with cURL support.
Happy Hacking,
  David, Timo, Werner

@_date: 2006-02-17 15:07:20
@_author: David Shaw 
@_subject: sporatic decryption issue 
The first thing to do is establish whether this is an encryption
problem or transport problem.  You say you encrypt the files, and
transfer them to a FTPS server, where the client fetches them via
FTPS.  Space allowing, try keeping the originals on the encrypt box
for a while.  If and when the client has a problem with a file,
compare a hash of the local copy with the one the client has.  That
is, both you and the client run "gpg --print-md sha1 (thefile)" and
verify it matches.
If it doesn't match, you have a transport problem.  If it does match,
you may have an encryption software problem.  This can chop the
possible problem space way down.  Right now, there are too many

@_date: 2006-02-17 18:25:43
@_author: David Shaw 
@_subject: Back signatures (was Re: [Announce] First release candidate for 
I don't know of one.  Any PGP program that doesn't ignore unknown
noncritical signature subpackets would be pretty broken.

@_date: 2006-02-19 06:52:18
@_author: David Shaw 
@_subject: cURL keyserver handlers broken 
Keep in mind 1.4.3rc1 is a development version and hasn't been
released yet.  gnupg-devel would be a more appropriate place.
That said, please run with:
  --debug 1024 --keyserver-options keep-temp-files
added to your command line, and post the results as well as the
contents of your tempin.txt file (the location of the tempin.txt file
may vary on different systems, but will be shown in the debug
output).  It looks like you're not talking to sks.keyserver.penguin.de
at all.

@_date: 2006-02-19 07:26:04
@_author: David Shaw 
@_subject: cURL keyserver handlers broken 
No question that it exists.  Just that gpgkeys wasn't talking to it...
The output you sent is helpful.  Can you do another run, but add:
  --keyserver-options verbose verbose verbose
(that's 3x verbose)

@_date: 2006-02-19 16:18:41
@_author: David Shaw 
@_subject: cURL keyserver handlers broken 
That looks correct so far.  I don't suppose you have an environment
variable http_proxy set?

@_date: 2006-02-19 17:24:05
@_author: David Shaw 
@_subject: cURL keyserver handlers broken 
If you set "keyserver-option no-http-proxy", the proxy will be
disabled, even if you have the environment variable set.

@_date: 2006-02-19 21:19:00
@_author: David Shaw 
@_subject: Remote signing? 
You have two good options.  Which is the best option depends on your
exact circumstances.
The first option is to hash the files remotely, with something like:
  gpg --print-md sha256 (thefile)
and then make a text file of hashes on your local laptop and sign that
text file.  This option presumes that the link between the remote
machine and your local machine is secure so that someone replacing the
hash between the remote and local machine is not a risk.
The other option is to make a new key (or new subkey) that can live on
the remote machine.  This key would be signed with your main key so
there is a chain of trust.  The disadvantage here is that if the
remote machine (and thus the key living there) is compromised, the
attacker may issue signatures using that key.  You can revoke the key,
of course, but this assumes that the recipients can get the

@_date: 2006-02-20 17:01:05
@_author: David Shaw 
@_subject: [Announce] First release candidate for 1.4.3 available 
There is not currently a 1.4.3rc1 for Windows, I'm afraid you'd have
to build it yourself.  Several people have done so, judging by the
test mails I've gotten in the past few days.  Also remember this:

@_date: 2006-02-20 21:36:47
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
Here's a rough guide for OpenLDAP:
0) Have a working OpenLDAP server running already.
1) Copy pgp-keyserver.schema wherever your schemas go.
2) Add an include line in /etc/openldap/slapd.conf for it:
 include         /etc/openldap/schema/pgp-keyserver.schema
3) Add a place to store the keys to /etc/openldap/slapd.conf:
 database    bdb
 suffix      "ou=PGP Keys,dc=DOMAIN,dc=COM"
 index       objectClass eq
 index       pgpCertID,pgpKeyID,pgpKeyType,pgpUserID,pgpKeyCreateTime sub,eq
 index       pgpSignerID,pgpSubKeyID,pgpKeySize,pgpKeyExpireTime sub,eq
 index       pgpDisabled,pgpRevoked eq
 directory   /var/lib/ldap
 access to dn="ou=PGP Keys,dc=DOMAIN,dc=COM" by * write
 rootdn          "cn=Manager,dc=DOMAIN,dc=COM"
4) Restart slapd
5) Make this file:
cat > pgp.ldif
dn: ou=PGP Keys,dc=DOMAIN,dc=COM
objectclass: organizationalUnit
ou: PGP Keys
dn: cn=PGPServerInfo,ou=PGP Keys,dc=DOMAIN,dc=COM
cn: PGPServerInfo
objectclass: pgpserverinfo
pgpSoftware: OpenLDAP
pgpVersion: 2.2.29
pgpBaseKeyspaceDN: ou=PGP Keys,dc=DOMAIN,dc=COM
6) ldapadd -x -D "cn=Manager,dc=DOMAIN,dc=COM" -W -f pgp.ldif
The configuration above obviously allows anyone to write/delete keys.
That may or may not be what you want.  Note that GPG will use TLS or
LDAPS just fine if you want to use that.

@_date: 2006-02-20 21:40:26
@_author: David Shaw 
@_subject: file encryption and integrity check 
You want passphrase encryption (not public key) and integrity
  gpg --force-mdc --symmetric (thefile)

@_date: 2006-02-20 23:59:55
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
Try for TLS, and do nothing if TLS can't start:
  keyserver-options tls=try
Try for TLS, and print a warning if TLS can't start:
  keyserver-options tls=warn
Try for TLS, and fail if TLS can't start:
  keyserver-options tls=require
If you want to use a particular certificate file:
  keyserver-options ca-cert-file=/path/to/the/file
If you don't want to check the certificate chain (default is to check
  keyserver-options no-check-cert
(Incidentally, the new keyserver handlers in 1.4.3 can do SSL and TLS
for HTTP and FTP as well).
You could probably use a "allow update_anon" in slapd.conf.
No.  There isn't really a strong notion of authentication for
keyservers beyond IP restriction in the server at the moment.  In
fact, the current LDAP code doesn't explicitly bind at all.  The
assumption is that any server we're likely to run into is V3 (or that
odd NAI semi-LDAP keyserver that's not really used any longer), and
doesn't need a bind.
I'm not against adding authentication, but I'd want to know more about
what you're doing.  There are not too many people running their own
LDAP servers with OpenPGP keys on them.  I'd love to hear how it goes.

@_date: 2006-02-21 00:52:02
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
LDAP had TLS support back in 1.3.5.  HTTP and FTP just got TLS support
in 1.4.3.  At one point, I started documenting the new options and
stopped because the man page would be enormous.  At some point, I'll
probably make a "gpgkeys" man page so as to not grow the main "gpg"
page too much.
I don't know that LDAP is a good *public* keyserver as things stand.
By its nature, even if some sort of authentication was added, the
server would only carry keys that were explicitly submitted to it.
Most other keyservers synchronize with their peers automatically to
carry a global keyring.
A LDAP keyserver would be useful as a company keyserver where people
inside the company IP range or an administrator can add keys, and the
rest of the world can just read.  The PGP Universal product
automatically looks for keys to encrypt to at
ldap://keys.thedomain.com, so that fits nicely with this method.
Somewhere on my todo list is to do something similar to tie in with
the automatic key fetch features coming in 1.4.3.
Anyway, that is (more or less) how I was expecting LDAP to be used.  I
never added LDAP auth because I wasn't sure exactly what was needed,
and didn't want to implement it without some clear use case.
What is it that you're trying to set up?

@_date: 2006-02-21 18:45:51
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
Not exactly.  It looks for PGPServerInfo under each DN returned from
namingContexts in order.  It may well check for
"cn=PGPServerInfo,dc=DOMAIN,dc=COM" first, but once that fails, it'll
get to "cn=PGPServerInfo,ou=PGP Keys,dc=DOMAIN,dc=COM" next.
Very interesting.  What version of OpenLDAP are you using?  I
developed this against a 2.0.x version, and it looks like something
has changed.  In gpgkeys_ldap.c, try adding:
  unique=1;
At the top of make_one_attr().

@_date: 2006-02-21 19:07:48
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
It's in the NEWS file for 2004-02-26, but it's true there wasn't any
way to know how to turn it on without reading the source...
Yes.  Something like peername.ip=192.168.1.0%255.255.255.0 to specify
the "inside the company" range for those who can write.
The problem here is remote authentication.  Each user would need some
way to authenticate to the LDAP server to give them the delete
ability.  LDAP can do this, of course, and GPG doesn't care one way or
the other, but how would you handle password distribution for each

@_date: 2006-02-21 19:10:26
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
It's possible to do this, of course, but remember that GPG currently
does not have password functionality for keyservers, and so this
implies a cleartext password for the keyserver stored somewhere in a
config file.
To be sure, pam_ldap stores a cleartext password in a config file as

@_date: 2006-02-21 22:31:35
@_author: David Shaw 
@_subject: GnuPG for PalmOS 5 
Not in the near future, no.  There are vague possibilities if and when
the new Palm OS (aka "Linux on a Palm") comes out, but that's pretty
far in the future.
The PGP company made a version of PGP for the Palm.  I vaguely recall
it had problems on OS 5, and was only officially supported on OS 4,
but you'd have to check with them to be sure.

@_date: 2006-02-21 23:20:20
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
What does:
 ldapsearch -h your-ldap-server -x -b "" -s base namingcontexts

@_date: 2006-02-21 23:51:10
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
gpgkeys_ldap will only check DNs given in namingContexts.  That's part
of the LDAP design that the PGP folks did, to allow programs to
automatically locate the key store.
If you need to override the autodetection, do something like:
  keyserver-options basedn="ou=PGP Keys,dc=DOMAIN,dc=COM"

@_date: 2006-02-21 23:58:35
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
It's certainly finer-grained.  With authentication, you can restrict
each user to their own key.  However, then you give yourself a
password management headache :)
That sounds like it would work fine.  Most of the work is on the LDAP
configuration side, but it would be easy enough to add binddn and
bindpw to gpgkeys_ldap for the GPG piece.  However, the problem is how
to handle the password on the GPG side.  Prompt the user each time he
uses the keyserver?  Inconvenient, plus GPG has no code for this
today.  Stick it in a config file?  Potentially dangerous.  How
sensitive is this password?  Is a mode 600 file secure for your usage?

@_date: 2006-02-22 04:26:13
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
It's theoretically possible, but no keyserver works that way.
Okay, I buy this.  I'll add binddn and bindpw to gpgkeys_ldap for
the next release.

@_date: 2006-02-22 14:28:00
@_author: David Shaw 
@_subject: file encryption and integrity check 
This is correct.  Of course, it's possible that GnuPG doesn't
recognize a particular kind of compression.  If I recall, it looks for
bzip, gzip, and zip.

@_date: 2006-02-23 00:28:21
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
It's a bit more complex than that - what LDAP (and any keyserver) does
is provide the key itself.  That key is then imported and lives
locally from then on until it is deleted.  There would need to be
cleanup after use or keys would be left behind.  Are you looking for a
remote keyring?  That's slightly different than a keyserver, or at
least the thing that GnuPG calls a keyserver.
1.4.3.  I've added the new feature, so you could probably grab the
gpgkeys_ldap.c from svn and use it in your 1.4.2 if you like.  There
aren't significant changes to the keyserver protocol between the two.
Just replace the existing gpgkeys_ldap.c with the new one and
This is just for testing though - the actual feature needs a little
more work before 1.4.3 release - the binddn and bindpw is global for
all keyservers, so if someone selects a different ldap keyserver
without removing the binddn and bindpw, they likely will be refused
(bad password).  This can happen automatically with keyserver URLs.
What is really needed is a .netrc-style "ldap-password" file that
contains binddn and bindpw for different machines.

@_date: 2006-02-23 04:24:02
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
No, unless it's via a remote filesystem (NFS, SMB, some magic with
fuse, etc).
I'm not sure I agree with this.  GnuPG does support multiple
keyservers in the sense that it handles preferred keyserver records on
keys, as well as the new auto-key-locate feature.  All of these have
the same set of options, as keyserver options are not per-keyserver.
They're not "options for keyserver x" - they are "options that pertain
to keyservers".  For example, "auto-key-retrieve" is not meaningful
except in the general sense.
Until yesterday, in fact, when I added binddn and bindpw, all the
options were not meaningful except in the general sense.  I think the
right place for the solution is in gpgkeys_ldap itself.  Certainly,
HTTP, FTP, and HKP have no notion of a DN to bind to.

@_date: 2006-02-23 14:03:13
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
I did.
Not a bug - you're quoting it wrong in the shell.  It takes a lot to
make the shell not eat stuff sometimes:
 --keyserver-option "binddn=\"uid=user1,ou=PGP Users,dc=EXAMPLE,dc=COM\""
That is, quote the value, not the name=value.  The parser in GPG
understands quotes.

@_date: 2006-02-23 16:21:49
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
keyserver-options.  Not keyserver-option.  The 's' is part of the
option name.  It works on the command line for convenience, but the
config file must be strict.

@_date: 2006-02-23 17:44:34
@_author: David Shaw 
@_subject: OpenLDAP schema to store OpenPGP keys? 
No.  Preferred keyservers are a different sort of thing.  Look at it
this way: you have one list of options, with which you can use any
keyserver.  Preferred keyservers are the OpenPGP way for the keyholder
to say "I like this keyserver - when using my key, please use this
keyserver".  It's like an automated way of changing --keyserver on a
per-user ID basis.
That's true.  Here's what I did - keyserver-options must be global,
but I added the ability to have per-keyserver options as well:
Global options:
  keyserver-options option1 option2 Options tied to ldap://my.ldap.server:
  keyserver ldap://my.ldap.server option1 option2 option3
In your case you could do something like:
  keyserver ldap://server binddn="ou=pgp keys, etc..." bindpw=secret

@_date: 2006-02-23 17:55:19
@_author: David Shaw 
@_subject: Howto setup an OpenLDAP PGP keyserver 
Thanks for writing this up!  I will certainly be pointing people to
this when they ask inthe future.
One comment:
This isn't quite correct.  GnuPG looks for PGPServerInfo under each
namingContext in order until it finds one.  It is perfectly fine not
to have PGPServerInfo under the base DN.  PGP as well as PGP Universal
does this the same way.

@_date: 2006-02-23 19:21:20
@_author: David Shaw 
@_subject: Howto setup an OpenLDAP PGP keyserver 
Another thing worth adding to your HOWTO is that if the LDAP server is
going to be publically available, a good name to use is
"keys.(yourdomain)".  The reason for this is that both PGP and GnuPG
(as of 1.4.3) can automatically locate keys using that name.  For
example, let's say I want to encrypt a message to joe but
I have no joe key.  GnuPG can automatically ask
ldap://keys.example.com for joe and import it.

@_date: 2006-02-28 05:39:01
@_author: David Shaw 
@_subject: Ohhhh jeeee: ... this is a bug (getkey.c:2079:merge_selfsigs) 
This is a heavily patched GnuPG release.  Did you try this on the
official version?

@_date: 2006-02-28 20:21:03
@_author: David Shaw 
@_subject: Using GnuPG subkeys at two insecure locations 
Unless it's really old PGP (say, PGP 5.0 era) it'll work fine.
All this is somewhat moot, as you cannot make key signatures with a
You can't.  The concept of trust is a whole-key concept.

@_date: 2006-01-01 18:26:52
@_author: David Shaw 
@_subject: Smart card signing failure 
A little of both.  GPG should give a better error message if you try
to sign with a hash the card does not support, but
personal-digest-preferences should not have selected a hash that the
card doesn't support in the first place.
Fixed for 1.4.3, thanks!

@_date: 2006-01-04 01:42:43
@_author: David Shaw 
@_subject: updating a key's self-signature 
Yes, but note that it's still possible for someone to get the old
self-sig from a keyserver.
Anyway, do this:
gpg --expert --cert-digest-algo (thehash) -u (thekeyid) --sign-key (thekeyid)
GPG will warn you that the key is already signed, but give you the
option to sign anyway.  Remember that if you pick a hash algorithm
that your correspondents don't have, the key will become unusable to
them.  Despite the recent attacks, I'd use SHA-1.
Why did you self-sign a v4 RSA key with MD5 anyway?

@_date: 2006-01-04 18:35:30
@_author: David Shaw 
@_subject: updating a key's self-signature 
Remember than keys are merged on the keyservers, so you'll end up with
both self-sigs present.  To be sure, GPG will use the more recent,
stronger, self-sig, but the old one is still there.
If an attacker compromises the keyserver or in any way distributes
your key himself, he can remove the new self-sig, leaving the old one
It's not much of an attack.  I wouldn't lose sleep over it.
This is fine, but note that the key may not work in older versions of
PGP and GPG.

@_date: 2006-01-05 14:11:47
@_author: David Shaw 
@_subject: updating a key's self-signature 
Sure, but you have exactly the same problem as before: an attacker can
simply unrevoke it by removing the revocation packet.
Revoking the whole key is not the same as revoking all selfsigs.  One
revokes the key.  The other makes the key completely untrusted and
untrustable.  They're not at all the same.

@_date: 2006-01-07 20:17:20
@_author: David Shaw 
@_subject: Preferred keyserver 
Bug.  I've fixed it for 1.4.3.  Thanks for the report!
Index: keyserver.c
--- keyserver.c	(revision 3984)
+++ keyserver.c	(working copy)
 -1794,7 +1794,7        int i;
       /* Try to handle preferred keyserver keys first */
-      for(i=0;i<count;i++)
+      for(i=0;i<numdesc;i++)
 	{
 	  if(desc[i].skipfncvalue)
 	    {

@_date: 2006-01-10 04:51:49
@_author: David Shaw 
@_subject: updating a key's self-signature 
Yes.  Signing a document and signing a key are not the same thing, and
must not be artificially glued together just because they are both
gpg --export (thekey) | gpg --list-packets

@_date: 2006-01-16 14:58:07
@_author: David Shaw 
@_subject: Providing shell-completions for gpg, minor scripting issues 
gpg --with-colons --list-config
Note the "pubkey", "cipher", "digest", and "compress" fields.

@_date: 2006-01-17 17:14:27
@_author: David Shaw 
@_subject: Does a secret key need to be signed? 
No, a secret key does not need to be selfsigned.  The self-signatures
from the public key are the ones that matter.  When self-signing,
GnuPG does put the selfsigs on both the secret and public key as a
convenience: when importing a secret key, GPG can then create a public
key from the secret key automatically.

@_date: 2006-01-20 19:55:49
@_author: David Shaw 
@_subject: Using other compression algos with GnuPG 
No.  GPG supports all of the compression algorithms that are defined
by the OpenPGP standard.  RAR isn't one of them.
It's always possible for someone to add a nonstandard algorithm, but
if you really want a particular algorithm, it's healthier to get the
OpenPGP working group to add it officially.

@_date: 2006-01-21 14:53:27
@_author: David Shaw 
@_subject: Using other compression algos with GnuPG 
In fact, BZIP2 was added pretty much for archival purposes:
I wouldn't be against LZMA if it was significantly better than BZIP2.

@_date: 2006-01-21 15:19:05
@_author: David Shaw 
@_subject: Using other compression algos with GnuPG 
I don't recall that LZMA was considered.  BZIP2 was added pretty much
for the reason you'd expect: better compression.  It does not preclude
LZMA.  It doesn't preclude any new compression algorithm.
Compression algorithms are different than ciphers and hashes, where it
is prudent to carefully scrutinize each new algorithm.  Compression
algorithms don't really impact security, so the barrier for inclusion
is significantly lower than for ciphers and hashes.

@_date: 2006-01-21 17:34:22
@_author: David Shaw 
@_subject: Using other compression algos with GnuPG 
No.  The removing obvious redundancy is a nice side benefit, but
compression is not intended to be secure in any way.  If the cipher
isn't enough to make you safe without compression, you're not going to
be really safe no matter what you do with compression.
No.  But similarly, it is not really cryptographically useful to have
bzip2 over zlib.  Or zlib over zip.
GnuPG in fact does this.

@_date: 2006-01-27 01:44:05
@_author: David Shaw 
@_subject: Problem with revoking my old key 
Do this:
  gpg --import revoke_old_key.asc
So the key on your keyring is revoked.
Now upload the key to the keyserver:
  gpg --keyserver wwwkeys.pgp.net --send-key daniel

@_date: 2006-01-28 05:10:45
@_author: David Shaw 
@_subject: mpi larger than indicated length 
As you noted, this is unlikely to be related to pks.  It looks like
some interaction between GnuPG and PsypherOPS.
The message was encrypted to two keys, 9E1BA0486180F04C (you) and
D2DDC51A2F833978 (someone else).  The encrypted session key for the
second key (the one who isn't you) appears malformed.  Specifically,
the error says that the pubkey enc packet contained two MPIs, the
first of which seems to be 1024 bits (too small), and the second of
which is missing altogether.  Anyway, that's breaking the decryption.

@_date: 2006-01-30 16:50:03
@_author: David Shaw 
@_subject: uncleanable expired sig 
Yes.  That's the last signature you have from the GD.  The older ones
don't carry a meaning (the were replaced by the newer ones), but this
last one must stay as it does carry meaning - that as of 2005-09-04,
the GD had expired a signature for you.

@_date: 2006-07-07 23:09:55
@_author: David Shaw 
@_subject: Keysigning challenge policies/procedures 
I've been away on vacation and only picked up this thread now.  This
statement is not correct.  Back in the PGP 2.x days, this might have
been true, but with OpenPGP, there is no particular requirement that
the ability to sign and the ability to decrypt are connected.  You can
have a shared key with separate capabilities.
Sending an signed key via encrypted mail does not ensure anything
about the key owner.

@_date: 2006-07-07 23:17:59
@_author: David Shaw 
@_subject: Keysigning challenge policies/procedures 
Sure you can: just send the random string to the email address.  If
the person can return the string back to you, signed, then you know
that there is access to both the signing key and the email address.

@_date: 2006-07-07 23:20:24
@_author: David Shaw 
@_subject: Keysigning challenge policies/procedures 
There is no harm (and no real benefit either) in sending the challenge
NOT in the clear.  Either way, you're proving the same thing: whether
the email address goes anywhere and whether someone who has access to
the email also has access to the key.

@_date: 2006-07-07 23:22:18
@_author: David Shaw 
@_subject: Keysigning challenge policies/procedures 
This is exactly correct.  The "identity" (for lack of a better word)
is the primary+UID.  Since that is what you are signing when you sign
someone's key, that is what you should be verifying before you make
the signature.

@_date: 2006-07-12 20:05:22
@_author: David Shaw 
@_subject: How to verify the file was successfully encrypted... 
There is no way to design such a self-check.  This isn't a lack in
GnuPG, but a design impossibility for any program.  Think about it: a
"check mode" would try and account for a bug in GnuPG and warn you
that the file was not encrypted properly.  However, if you're
presuming a bug, then who says you should trust the check mode?
If GnuPG completes successfully, that means it succeeded.  If you want
more assurance than that, the only way to do it is to decrypt the file
and compare.

@_date: 2006-07-14 00:43:49
@_author: David Shaw 
@_subject: [Sks-devel] key too large? 
Version?  At least for the recent code, It's very hard to see how you
got that error.  The code just doesn't flow that way.

@_date: 2006-07-14 02:07:28
@_author: David Shaw 
@_subject: [Sks-devel] key too large? 
There are no meaningful changes in gpgkeys_hkp between those two
revisions.  Can you reproduce this with --keyserver-options
"use-temp-files keep-temp-files" and send me the temp file?

@_date: 2006-07-14 14:39:19
@_author: David Shaw 
@_subject: Calculating Buffer Size 
Yes, but not if compression is turned on (as it is by default).
Factors are key size, key algorithm, and number of recipients to the

@_date: 2006-07-14 17:29:35
@_author: David Shaw 
@_subject: [Sks-devel] key too large? 
Aha, fixed, thanks.
Your armored key just happened to have text in it that looked like the
"KEY xxxx"... delimiter.

@_date: 2006-07-21 16:29:17
@_author: David Shaw 
@_subject: Version of signatures 
Yes, it depends on the key and a number of other details (is it a data
signature or a signature on a key?  Does the signature expire?  Does
the signature have a notation on it? etc, etc.)

@_date: 2006-07-21 23:53:33
@_author: David Shaw 
@_subject: bad signature on encrypted and signed block? 
No, it is definitely possible.  The CRC is not nearly as strong as the
signature for validation.

@_date: 2006-07-22 15:00:22
@_author: David Shaw 
@_subject: Fetching keys via http/https? 
Some keyservers operate on port 80 as well as the usual 11371.  Try

@_date: 2006-07-24 23:22:04
@_author: David Shaw 
@_subject: Driving licence as identification and accepting signed keys 
It depends on what *you* think.  Some people do accept driver licences
as adequate identification.  Some don't.  I do, for what it's worth.
No, it's not.  Some people do it, though.
Note that there is a difference between what page at
 says
and what you say above.  The page (correctly) notes that all that is
necessary is that the person *sign* the challenge before sending it
back to you.  The page makes clear ("encrypted, if you like") that
encryption is optional here, and adds little to what you are trying to
prove.  It doesn't matter if other people can read the signed
challenge or not.  Of course, it doesn't hurt to encrypt, so long as
it is understood that it doesn't really help either.
Take a look at the thread starting at
It has a pretty good discussions of various issues around keysigning.

@_date: 2006-07-24 23:49:12
@_author: David Shaw 
@_subject: Driving licence as identification and accepting signed 
It comes down to whether you believe it is hard or easy to get a false
drivers license.  That is something that is going to be very different
in different places.  You also need to factor in whether you'd
recognize a fake drivers license anyway (I'm not sure I would - here
in the US there are over 50 types of drivers licenses)..
The error here was made by the signer.  As you are the signee,
presumably you have good assurance that you are who you say you are.
I'd go ahead and upload the keys :)

@_date: 2006-07-26 22:33:47
@_author: David Shaw 
@_subject: GnuPG 1.4.4 does not compile on NetBSD is curl library is 
Should be fixed now, thanks.
Index: Makefile.am
--- Makefile.am (revision 4198)
+++ Makefile.am (working copy)
 -50,4 +50,5  gpgkeys_curl_LDADD =   gpgkeys_hkp_CPPFLAGS =  gpgkeys_hkp_LDADD =  +gpgkeys_finger_CPPFLAGS =  endif

@_date: 2006-06-04 01:00:44
@_author: David Shaw 
@_subject: Info on sub keys? 
B would mangle it and send the mangled version to C.  Offhand, I don't
recall any pre 0.9.6 PKS installations left though.
It's not a general convention.  PGP said things like that because when
you made a RSA primary key, it would (by default) also make a RSA
subkey.  Once you start mixing algorithms (RSA primary, Elgamal
subkey, etc), the convention breaks down.

@_date: 2006-06-05 23:56:07
@_author: David Shaw 
@_subject: sign and encrypt 
This isn't a rfc3156 (PGP/MIME) or GPG issue.  The recipient can
forward anything he likes and there is no way to prevent him.
If you want to make it not useful for him to forward, stick something
like "I sent this to so-and-so" in the signed message.

@_date: 2006-06-07 18:58:45
@_author: David Shaw 
@_subject: how to authenticate an ldaps keyserver lookup 
First make sure you're using the latest version (1.4.3), then you can
  keyserver ldaps://somehost binddn=xxxx bindpw=xxxx
binddn is the LDAP DN to bind to, and bindpw is the password to use.
Try adding "keyserver-options debug=1" and running it again to get
some idea what GPG is seeing.

@_date: 2006-06-07 19:06:54
@_author: David Shaw 
@_subject: sign and encrypt 
Note that eyes only does not prevent forwarding.  It is an advisory
flag only (i.e. "please don't forward this").

@_date: 2006-06-09 14:03:40
@_author: David Shaw 
@_subject: sha2 utilities: Print or check SHA-2 digests 
I'm not sure if I fully understand your question (coreutils has
nothing to do with GnuPG), but GnuPG does have the SHA2 hashes:
gpg --print-md sha256 (thefile)
gpg --print-md sha384 (thefile)
gpg --print-md sha512 (thefile)
The next version of GPG will add:
gpg --print-md sha224 (thefile)

@_date: 2006-06-09 21:06:54
@_author: David Shaw 
@_subject: PGP zip 
It only exists in GnuPG for Unix-like systems (it's a shell script
that calls GPG).

@_date: 2006-06-10 00:07:27
@_author: David Shaw 
@_subject: sha2 utilities: Print or check SHA-2 digests 
Man page:
       --print-md algo [files]
       --print-mds [files]
              Print message digest of algorithm ALGO for all  given files  or
              stdin.   With  the  second  form  (or  a deprecated "*" as algo)
              digests for all available algorithms are printed.

@_date: 2006-06-10 14:15:00
@_author: David Shaw 
@_subject: sha2 utilities: Print or check SHA-2 digests 
"--print-md * file" is deprecated in favor of "--print-mds".  The
functionality is still there.  Just the name is different.

@_date: 2006-06-12 02:35:44
@_author: David Shaw 
@_subject: gnupg 1.4.3 uses SHA1 when preferred Digest is SHA2 
The misunderstanding here is that "showpref" sets preferred algorithms
for outgoing messages.  It doesn't.  The preferences on the key are
used on messages being sent *to* your key.  If you want to set
preferences for outgoing messages, stick something like:
  personal-digest-preferences sha256 sha384 sha512
in your gpg.conf.

@_date: 2006-06-13 19:51:04
@_author: David Shaw 
@_subject: False Decrypt Error... 
You've got a bunch of warnings here.  Let's take them one at a time:
Just what it says: the directory /opt/fxnet/gpg is writable by someone
other than you.  It's a good idea for you to fix it, but it isn't the
cause of your problem.
GPG tries to lock a small amount of memory so you can't accidentally
swap a passphrase out to disk.  Depending on how you are using GPG,
this may not be significant to you.  Either way, it's not the cause of
your problem.
This means that there is no integrity protection packet on the
message.  There is a very difficult attack against the old PGP message
format that the integrity protected format combats.  This isn't the
cause of your problem either.
THIS is your problem.  GPG found garbage in the message that could not
be parsed.  Since you say the message was decrypted correctly before
the garbage was found, it's likely the garbage is at the end.
Is this an armored (i.e. "--- BEGIN PGP MESSAGE ---") message or
binary (not printable ASCII)?

@_date: 2006-06-13 20:46:18
@_author: David Shaw 
@_subject: False Decrypt Error... 
Take a look at how you're transferring the files around.  It's a very
common problem where people use FTP in ascii mode to copy the files
around and end up with them mangled.

@_date: 2006-06-13 21:17:38
@_author: David Shaw 
@_subject: OpenPGP smartcard restore 
There is a little misunderstanding here.  When you generate a card key
with off-card backup, the key is not generated via the on-card method.
The key is generated like any other key, and then uploaded to the
card (and saved to the backup file).
The card does not allow reading a secret key off the card, so if you
really generated it on-card, there would be no way of making the
backup file.

@_date: 2006-06-13 21:36:29
@_author: David Shaw 
@_subject: OpenPGP smartcard restore 
Try this: do everything you did above, but at the end, delete the
secret key stub:
  gpg --delete-secret-keys KEYID
(or gpg --edit-key, toggle, and delkey if you're doing just a subkey).
And now recreate the stub:
  gpg --card-edit
I don't have my card with me so I can't test this, but it should do
what you want.

@_date: 2006-06-13 22:48:48
@_author: David Shaw 
@_subject: OpenPGP smartcard restore 
It is a standalone importable secret key, just as you thought.

@_date: 2006-06-15 14:02:22
@_author: 'David Shaw' 
@_subject: how to authenticate an ldaps keyserver lookup 
keyserver-options ca-cert-file=/path/to/cacert.pem
   keyserver-options no-check-cert
Again, though, these are 1.4.3 features.  They won't work on your

@_date: 2006-06-15 14:11:49
@_author: 'David Shaw' 
@_subject: searching for a key with gpg ldap 
This is a misunderstanding of what the logs are saying.  The LDAP
library is doing a logical AND between (pgpuserid=*Test*) and
(pgpdisabled=0).  You just don't have any records that have
pgpDisabled being equal to 0.
The pgpDisabled field is part of the PGP LDAP schema.  Are you using
this schema?  If not, you're likely to hit many other compatibility
problems like this.
Yes.  That's exactly what it means.  If you want to include all (even
disabled) keys, then use:
  keyserver-options include-disabled

@_date: 2006-06-17 18:07:56
@_author: David Shaw 
@_subject: personal-cipher/digest-preferences 
Not exactly.  It even takes effect when you're encrypting to one
recipient.  Let's say that recipient asked for CAST5 and you don't
have CAST5 in your personal-cipher-preferences.  In that case, GPG
will keep looking for a better match.
Same as above.

@_date: 2006-06-22 21:01:06
@_author: David Shaw 
@_subject: Interesting error message on import 
It means that the signature has a subpacket on it that GPG doesn't
know about, but yet it is also tagged as critical.  In that case, GPG
can't really "understand" the signature (as it doesn't know what the
subpacket means).

@_date: 2006-06-23 02:17:23
@_author: David Shaw 
@_subject: Quick --sign question 
Right.  You do '--sign --encrypt' to sign and encrypt.
It depends on your configuration, but by default it's the ZIP

@_date: 2006-06-23 22:53:10
@_author: David Shaw 
@_subject: personal-cipher/digest-preferences 
You can do this outside of GPG if you like, but within GPG, no.
Why?  You are the person making the signature here.  It's your choice
what algorithm to use.  The recipient only gets to say "these are the
algorithms I will accept".  Not "this is the algorithm I want you to
use".  Outside of DSA2, GPG will always select an algorithm that is
usable by everyone.  If all else fails, it's going to be SHA-1.

@_date: 2006-06-25 18:22:50
@_author: David Shaw 
@_subject: Reminder about GPG 1.4.4 and the new DSA 
Hi folks,
GnuPG 1.4.4 was released today, and it contains a new feature
(--enable-dsa2) that needs a bit of explanation.  For many years, the
DSA signing algorithm has been limited in two ways: first, you could
not create a key larger than 1024 bits, and second, the key could only
use a 160-bit hash, which in practice meant either SHA-1 or
Recently, the long awaited update to DSA was released by NIST.  Most
people have been calling it DSA2, though the official name has not
changed.  DSA2 allows for much larger keys and can work with almost
any hash.
The last release of GnuPG (1.4.3) contained limited support for DSA2
so it could at least verify (most) DSA2 signatures.  Today's release
of GnuPG (1.4.4) contains full support for DSA2.  You can now generate
DSA2 keys and you can issue DSA2 signatures.  However, (and here's the
problem): no other OpenPGP programs can currently use (all of) DSA2.
No doubt that over the coming months and years, other OpenPGP programs
will add support for DSA2, but this does not exist today.
If you want to experiment with DSA2, that's fine, but fair warning:
until other OpenPGP programs add DSA2 support, using DSA2 means
isolating yourself to a GPG 1.4.3 or 1.4.4 world.

@_date: 2006-06-26 23:25:51
@_author: David Shaw 
@_subject: Trust Issue 
Most likely, a signature somewhere in the trust chain expired.
Expired signatures do not carry trust.

@_date: 2006-06-27 20:07:00
@_author: David Shaw 
@_subject: Corrupt file issue? 
You're sending the file by ascii FTP.  That will corrupt binary data.
You need to transfer with binary FTP.  There are far too many FTP
clients out there for me to tell you how to set your particular client
to binary, but check the manual.

@_date: 2006-03-03 16:22:48
@_author: David Shaw 
@_subject: gnupg, news and Signature Verify 
The file is mangled.  Possibly it wasn't generated by GnuPG 1.4.1 as
the Version header seems to indicate as GnuPG doesn't generate this
The real problem is that it is missing the "Hash" header, which should
be the second line in the file, right after the BEGIN PGP SIGNED
MESSAGE line.

@_date: 2006-03-03 16:50:32
@_author: David Shaw 
@_subject: Which Digest Algorithm to use? 
There is a misunderstanding here.  PGP 2 keys don't use MD5 as a
default hash algorithm.  They act just like any other key - they use
the prefs on the *recipient* keys, filtered through
personal-digest-prefs, and if all else fails, use SHA-1.
There are "first indications" of weaknesses in all algorithms.  If I
recall, SHA-1 even with all attacks against it, is still stronger than
MD5 was even before all the attacks against it.
Yes, but then you can't use the key in PGP 2 any longer.
I'd just make a v4 key and move on.

@_date: 2006-03-03 19:35:07
@_author: David Shaw 
@_subject: Which Digest Algorithm to use? 
He can if he wants to.  It doesn't actually make a difference either
way since the new signature overrides the older one.

@_date: 2006-03-04 17:35:53
@_author: David Shaw 
@_subject: Which Digest Algorithm to use? 
An implementation that encounters multiple self-signatures on the
    same object may resolve the ambiguity in any way it sees fit, but
    it is RECOMMENDED that priority be given to the most recent
    self-signature.
There is no implementation that behaves otherwise.

@_date: 2006-03-07 00:54:22
@_author: David Shaw 
@_subject: Which Digest Algorithm to use? 
I was talking about signing data, and you were talking about signing
keys.  Your understanding is correct.  Unless some option is used to
change things, the default behavior is to use SHA-1 except in the one
specific case of signing a PGP 2.x key with another PGP 2.x key.  This
case uses MD5.
This is done to avoid breaking the PGP 2.x key, as modern signatures
will render it unusable in PGP 2.x.

@_date: 2006-03-08 19:46:21
@_author: David Shaw 
@_subject: add notation to self sig 
--edit-key the key, delsig the current selfsig, and "sign".  Sign will
do the right thing.
That's pretty icky, though.  I'll see if I can add a "notation"
--edit-key command for 1.4.3.

@_date: 2006-03-09 04:26:37
@_author: David Shaw 
@_subject: add notation to self sig 
If you're tracking SVN, try the latest.  I've added a notation command
under --edit-key.
Yes, but only if you ask for it specifically.  Try adding
"show-sig-subpackets=20" to your --list-options.

@_date: 2006-03-09 20:22:17
@_author: David Shaw 
@_subject: add notation to self sig 
That's actually a feature.  I didn't explain it too well in the
manual.  Basically the problem is that zero-length notations are legal
in OpenPGP.  So if there was a foo notation on the sig
already, then foo would remove it.  If there was no
foo notation on the sig already, then foo
would be added as a zero-length notation.
Let's make it simpler: I just added the ability to delete notations
directly by using a minus sign prefix like "-foo
Given these notations:
  foo
  foo
  foo
if you use "-foo you'll delete that specific
notation.  If you use "-foo you'll delete all three.
I went back and forth on this a few times, as I can see a good
argument for either replacement or adding a second notation, but
finally went with the current behavior as more flexible.  It's easy
enough to change if it doesn't work out well in the field.  Note that
this only applies to key matches.  Adding a completely matching
notation (both key and value) is skipped.

@_date: 2006-03-09 23:35:00
@_author: David Shaw 
@_subject: add notation to self sig 
Yes.  I figured that since nobody has complained yet about not being
able to start a non-critical notation with a !, then - was safe. :)

@_date: 2006-03-10 00:19:42
@_author: David Shaw 
@_subject: [Announce] GnuPG does not detect injection of unsigned data 
That is legal.  Using the same notation as before, that is:
 O + O + D + S + S

@_date: 2006-03-10 01:35:41
@_author: David Shaw 
@_subject: [Announce] Second release candidate for 1.4.3 available 
We are pleased to announce the availability of the second release
candidate for the forthcoming 1.4.3 version of GnuPG:
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.3rc2.tar.bz2 (3.0M)
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.3rc2.tar.bz2.sig
SHA-1 checksums for the above files are:
 eb5b839555ff1957b5956aaf4c96505223a2f9d0  gnupg-1.4.3rc2.tar.bz2
 2168b475f49100f5c41fa3830d90eb6d863220e7  gnupg-1.4.3rc2.tar.bz2.sig
Note that this is only a release candidate, and as such is not
intended for use on production systems.  If you are inclined to help
test, however, we would appreciate you trying this new version and
reporting any problems.
Note that this release candidate contains fixes for both the "False
positive signature verification in GnuPG" and "GnuPG does not detect
injection of unsigned data" problems reported against 1.4.2.
Noteworthy changes since 1.4.2:
    * If available, cURL-based keyserver helpers are built that can
      retrieve keys using HKP or any protocol that cURL supports
      (HTTP, HTTPS, FTP, FTPS, etc).  If cURL is not available, HKP
      and HTTP are still supported using a built-in cURL emulator.  To
      force building the old pre-cURL keyserver helpers, use the
      configure option --enable-old-keyserver-helpers.  Note that none
      of this affects finger or LDAP support, which are unchanged.
      Note also that a future version of GnuPG will remove the old
      keyserver helpers altogether.
    * Implemented Public Key Association (PKA) signature verification.
      This uses special DNS records and notation data to associate a
      mail address with an OpenPGP key to prove that mail coming from
      that address is legitimate without the need for a full trust
      path to the signing key.
    * When exporting subkeys, those specified with a key ID or
      fingerpint and the '!' suffix are now merged into one keyblock.
    * Added "gpg-zip", a program to create encrypted archives that can
      interoperate with PGP Zip.
    * Added support for signing subkey cross-certification "back
      signatures".  Requiring cross-certification to be present is
      currently off by default, but will be changed to on by default
      in the future, once more keys use it.  A new "cross-certify"
      command in the --edit-key menu can be used to update signing
      subkeys to have cross-certification.
    * The key cleaning options for --import-options and
      --export-options have been further polished.  "import-clean" and
      "export-clean" replace the older
      import-clean-sigs/import-clean-uids and
      export-clean-sigs/export-clean-uids option pairs.
    * New "minimize" command in the --edit-key menu removes everything
      that can be removed from a key, rendering it as small as
      possible.  There are corresponding "export-minimal" and
      "import-minimal" commands for --export-options and
      --import-options.
    * New --fetch-keys command to retrieve keys by specifying a URI.
      This allows direct key retrieval from a web page or other
      location that can be specified in a URI.  Available protocols
      are HTTP and finger, plus anything that cURL supplies, if built
      with cURL support.
    * Files containing several signed messages are not allowed any
      longer as there is no clean way to report the status of such
      files back to the caller.  To partly revert to the old behaviour
      the new option --allow-multisig-verification may be used.
    * The keyserver helpers can now handle keys in either ASCII armor
      or binary format.
    * New auto-key-locate option that takes an ordered list of methods
      to locate a key if it is not available at encryption time (-r or
      --recipient).  Possible methods include "cert" (use DNS CERT as
      per RFC2538bis, "pka" (use DNS PKA), "ldap" (consult the LDAP
      server for the domain in question), "keyserver" (use the
      currently defined keyserver), as well as arbitrary keyserver
      URIs that will be contacted for the key.
    * Able to retrieve keys using DNS CERT records as per RFC-2538bis
      (currently in draft): Happy Hacking,
  David, Timo, Werner

@_date: 2006-03-13 14:51:42
@_author: David Shaw 
@_subject: Problem removing a public key whose private key is gone 
Cough, cough.  ldap://keyserver.pgp.com
It purges keys that aren't confirmed via email and doesn't sync with
any other keyserver.
Still, even with a keyserver that doesn't sync, that doesn't stop
other people from (accidentally or otherwise) downloading a key from
ldap://keyserver.pgp.com and distributing it via other means.

@_date: 2006-03-17 22:17:54
@_author: David Shaw 
@_subject: How to receive keys from a keyserver when you don't have a key 
Upgrade to 1.4.3 when it comes out (or use the 1.4.3rc2, the latest
release candidate).  This version has a feature called
auto-key-locate.  Put:
  auto-key-locate hkp://your.keyserver
in your gpg.conf.  Then, when encrypting, if $RECIPIENTID is in the
form of an email address (in your example it is), and that key is not
on the local keyring, GPG will automatically fetch it from the

@_date: 2006-03-21 17:33:25
@_author: David Shaw 
@_subject: How to sign with non-subkey? 
Put a ! after the key ID to tell GPG that you want that exact key.

@_date: 2006-03-28 23:45:33
@_author: David Shaw 
@_subject: Key updating and preferred keyservers 
gpg --keyserver-options no-honor-keyserver-url --refresh-keys
Of course, the owners of those keys did presumably set a preferred
keyserver URL because they wanted you getting their keys from the
preferred keyserver...

@_date: 2006-03-30 00:07:36
@_author: David Shaw 
@_subject: is clearsigned text also vulnerable to recent injection of 
It doesn't.  Here's the story:
* It doesn't apply to signed software tarballs (detached signatures)
* It doesn't apply to PGP/MIME signed email messages (which are
  detached signatures under the hood)
* It doesn't apply to clearsigned messages
* It might apply to sign+encrypted PGP/MIME messages and
  sign+encrypted messages in general (though note your attacker in
  this case may be the person who encrypted the message...)
* It might apply to unencrypted-but-binary-signed messages
  (essentially signed+encrypted without the encryption - generally not
  used much).

@_date: 2006-05-02 18:49:29
@_author: David Shaw 
@_subject: Retrieving keys via v3 fingerprint 
You can't.  It would require the keyserver to be able to retrieve by
v3 fingerprint and none can.

@_date: 2006-05-02 20:09:45
@_author: David Shaw 
@_subject: Export Private Key 
gpg --export-secret-key (the key) > thefile.sec
(copy the file over)
gpg --import thefile.sec

@_date: 2006-05-03 14:32:41
@_author: David Shaw 
@_subject: Retrieving keys via v3 fingerprint 
How GPG stores internal trust data and what keyservers support have
nothing to do with each other.
Work on the keyring with --list-packets?  It depends what you mean by

@_date: 2006-05-04 17:09:50
@_author: David Shaw 
@_subject: Can I see the checksum when I sign/verify a file? 
There isn't.  Note that the hash that is used when making a signature
is not the same one that you'd get when using something like
--print-md anyway.  There are timestamps, subpackets, etc, in the hash
used in the signature.  --print-md is a raw hash of just the file.
--personal-digest-prefs takes a list of hash algorithms.  It will pick
the first one that is usable for your signature type.
Don't use md5.

@_date: 2006-05-04 19:06:06
@_author: David Shaw 
@_subject: Can I see the checksum when I sign/verify a file? 
MD5 is deprecated in OpenPGP.  The current OpenPGP draft says:
      * The MD5 hash algorithm has been found to have weaknesses, with
        collisions found in a number of cases. MD5 is deprecated for
        using MD5 as a hash function. They MAY continue to consider

@_date: 2006-05-05 19:06:14
@_author: David Shaw 
@_subject: simultaneous encryption to public key, 
No.  It's the same session key throughout.  Having multiple session
keys would effectively equal sending the entire message multiple
times, once for each session key.

@_date: 2006-05-08 23:51:18
@_author: David Shaw 
@_subject: more than one keyserver 
Then you're fine.  The auto-key-locate and import-clean are not needed
for that purpose, but won't hurt you.

@_date: 2006-05-09 06:26:49
@_author: David Shaw 
@_subject: more than one keyserver 
Yes.  It is unrelated to fetching a key when receiving a signed

@_date: 2006-05-09 23:14:47
@_author: David Shaw 
@_subject: Rijndael usage 
You can't use GPG or PGP to decrypt this.  It looks like they're
encrypting using raw Rijndael.

@_date: 2006-05-09 23:15:38
@_author: David Shaw 
@_subject: List embedded filename 
Why do you need to list embedded filenames?  What is the purpose of
the extraction of this data?

@_date: 2006-05-10 20:18:11
@_author: David Shaw 
@_subject: Upgrading from 1.2.1 to 1.4.4 
There should be no special steps to take.  Aside from the obvious
steps of making a backup and testing that your environment still does
what you want it to do, you can just install 1.4.3 on top of 1.2.1.

@_date: 2006-05-17 16:45:43
@_author: David Shaw 
@_subject: Problems decrypting a mail with my openpgp card 
You basically can't, unless you have a copy of your authentication key
outside of the smartcard in which case you can modify it into an
encryption key and decrypt.
This is a bug in PGP, where it will encrypt to keys that are not
marked for encryption.  It was fixed recently (in 8.something, if I
recall), but as you have seen, there are many old copies of PGP out

@_date: 2006-05-22 18:20:14
@_author: David Shaw 
@_subject: auto-key-locate 
It's not HKP keyservers, exactly.  It's any keyserver that returns
more than one key, when the last key that is returned is not valid.
Here's a patch.

@_date: 2006-05-24 14:00:21
@_author: David Shaw 
@_subject: preferred compression types with multiple recipients 
Not switch from zlib, necessarily, but at least advertise they have
the ability to handle bzip2 also.
That is correct.  Conflicting compression algorithms are handled the
same way conflicting cipher algorithms are:
 1) Make a list of all compression algorithms supported by all
    recipients.
 2) Add "uncompressed" to the list even if nobody requested it (by
    definition, all OpenPGP implementations can handle uncompressed
    data).
 3) We now have a list of algorithms, any of which are usable
    (i.e. compatible with everyone).  If
    --personal-compress-preferences is set, try those algorithms in
    order.  If it isn't set, walk the list supplied by the last user.
 4) If we still don't have an algorithm, use "uncompressed".
The cipher selection algorithm is essentially the same if you
substitute "3DES" for "uncompressed".

@_date: 2006-05-26 18:31:08
@_author: David Shaw 
@_subject: Cipher v public key. 
Yes, this can handle AES256.  It's listed, so it can be handled.
You're using both an asymmetric key (RSA, DSA, ELG-E), and symmetric
key (AES, CAST5, TWOFISH, etc) when you encrypt.
It's possible you're already using AES256.  Add a "-v" to your gpg
command line when you encrypt to see which cipher it is using.

@_date: 2006-05-26 18:48:44
@_author: David Shaw 
@_subject: Issue in Importing a PGP signature key 
"no valid OpenPGP data found" means pretty much what it says: GPG
looked for a key in the file and didn't find one.  If it does not
reveal something that shouldn't be revealed, post here or send me the
HTST126A.pass.asc file and I'll take a look at it.

@_date: 2006-05-28 00:02:28
@_author: David Shaw 
@_subject: SHA2 compatibility 
This is a true statement, but not relevant to your question.  I was
discussing DSA keys, and you're asking about RSA.  You can use any
hash with RSA that you like.  There are no restrictions in size or
otherwise.  The only thing you have to worry about is whether your
recipient can handle that hash or not.
Exactly what --pgp8 allows.  SHA256 alone.

@_date: 2006-05-28 22:29:55
@_author: David Shaw 
@_subject: GnuPG Smartcard and Authentication Key 
This is unfortunately turning into a FAQ.  Basically, you've run into
an old PGP bug.  It was recently fixed (I don't recall exactly in what
version), but there are countless installations of PGP that predate
the fix.
OpenPGP keys have "key flags" that indicate what a key is to be used
for (encryption, signing, or authentication).  GnuPG honors these
flags and will not encrypt to any key that isn't marked for
encryption.  The bug is that PGP is not properly looking at the key
and will happily encrypt to a signing or authentication key.
As to what you can do about it, your best bet is to contact the sender
and ask for a retransmission encrypted to the proper key.  It might be
possible to write a program that can essentially trick the smartcard
into decrypting the message by pretending it is a signature that needs
to be verified but it depends on how exactly the card handles
signatures.  In any event, no such program exists today.

@_date: 2006-11-06 03:50:49
@_author: David Shaw 
@_subject: How to enable a block cipher or hash algorithm for a keypair? 
Note, though, that neither of these will take effect unless the other
keys participating in the encryption agree.  You can only use an
algorithm that is present in the preferences of all keys you are
encrypting to.

@_date: 2006-11-06 05:43:40
@_author: David Shaw 
@_subject: gpg error messag 
The program that generated this message has a problem.  First it
announces that the signature hash is going to be SHA1:
Then it provides the signature:
Digest algo 8 is SHA256, not SHA1.
You might be able to manipulate things into verifying the signature by
editing the file to change the SHA1 string to SHA256, but the real
problem is probably in whatever program generated the message.

@_date: 2006-11-06 06:19:02
@_author: David Shaw 
@_subject: deleting signatures from uids 
No.  GnuPG has the ability to verify signatures, and so can correctly
do this.  It's not as simple as just dropping all expired signatures.
You must distribute some signatures, even though they aren't usable
(for example, the last in a series of expired signatures).
Keyservers don't have any crypto support, so can't verify signatures,
and so can't do any sort of signature cleaning safely.

@_date: 2006-11-06 14:15:56
@_author: David Shaw 
@_subject: gpg error messag 
Ah, I recall this problem.  I reported it to the PGP GD people quite a
while ago, and I thought it had been fixed.  The GD was generating a
PGP/MIME micalg setting of pgp-sha1, but the actual signature was
being made with SHA256.

@_date: 2006-11-06 20:00:24
@_author: David Shaw 
@_subject: Question abut use of --cipher-algo AES & --openpgp 
This method for identifying ciphers is not reliable.  There are many
ways for a file to be packed, and this method will do the wrong thing
for all but one of the ways.

@_date: 2006-11-06 21:13:01
@_author: David Shaw 
@_subject: keyserver 
There are two good ways to run a keyserver.  If you are planning on
syncing your internal keyserver with the outside world, then SKS is
for you.  If you are having problems building it, ask on the SKS
mailing list at If you are not planning to sync with the outside world, then may I
suggest using LDAP?  Many sites already have a LDAP server, and GnuPG
will quite happily use it as a keyserver.  The LDAP schema for OpenPGP
keys is at

@_date: 2006-11-07 15:00:34
@_author: David Shaw 
@_subject: keyserver 
LDAP overwrites.  SKS or PKS merges.  It's an interesting question
which behavior is better, but (as in many things) the answer comes
down to the behavior that is "better" is the one that you like
more. :)
Personally, I think that LDAP is better for key populations that have
a distinct boundary: a company, for example.  In a company, key
merging isn't really that useful or desirable, as generally there
isn't much back-and-forth key signing.  Rather, the company signs each
key with the authoritative company key.
Since you already have a running LDAP setup, it seems like an obvious
solution to use it rather than have to maintain a whole second server
(with backups, etc).
LDAP has another side benefit if you choose to make it visible outside
the company: people who use PGP will automatically find keys for your
employees and encrypt their mail.  When encrypting to
user PGP universal looks for ldap://keys.example.com and
asks it for the user key.  Put "auto-key-locate ldap" in
your gpg.conf, and GnuPG will do the same.
I wouldn't use PKS at this point.  It is unmaintained code, and has
many known bugs.  It is simply not an option any longer.
SKS has a good user population on their list.  They can very likely
help you.
My involvement with PKS was really that of desperation.  PKS was the
main and only keyserver software for years, and worked great.  As
OpenPGP grew, though, the keyserver wasn't really grown to match, and
so had serious key-mangling problems with the the more modern OpenPGP
features.  I couldn't persuade many people to stop running it and move
to SKS, so I got involved long enough to fix the worst of the bugs.
The current state of PKS is that it still doesn't work with modern
keys, but at least it doesn't destroy them any longer.
The SKS developer (Yaron Minsky) has done an excellent job with SKS,
and virtually all the public keyservers run SKS these days.

@_date: 2006-11-07 17:42:56
@_author: David Shaw 
@_subject: Question abut use of --cipher-algo AES & --openpgp 
I've attached two files that will both give you the wrong answer using
the "first six bytes" methodology.

@_date: 2006-11-14 14:17:31
@_author: David Shaw 
@_subject: --edit-key command 
gpg --edit-key (yourkey)
If you have never distributed your key, you can use adduid to add a
new user ID, and then deluid to remove the old one.  However, if you
have distributed your key, you can't really change names any longer.
The best you can do is use adduid to add a new user ID, and revuid to
revoke the old one.  This doesn't actually remove the old one, but
does mark it as not to be used.

@_date: 2006-11-14 14:18:49
@_author: David Shaw 
@_subject: Get signatures from a keyring file 
You want to export *just* the signatures?  There is no way to to that.
Key ignatures are attached to a key and are generally not meaningful
outside of that context.  You can export keys if you like.

@_date: 2006-11-14 22:38:02
@_author: David Shaw 
@_subject: how to create a symmetric cipher 
I'm a bit confused as to what you are asking, but if the question is
"how do I encrypt data using a symmetric cipher?", then the answer is
"gpg --symmetric (thefile)"

@_date: 2006-11-14 23:15:52
@_author: David Shaw 
@_subject: how to create a symmetric cipher 
I'd like to help you, but I can't parse the question.  GPG uses both
passphrase and non-passphrase encryption in different circumstances.
I suggest you read the section on "Hybrid ciphers" in the manual
( and hopefully that will
help clear up the confusion.

@_date: 2006-11-16 17:18:19
@_author: David Shaw 
@_subject: GnuPG 2.0 
Here is your clear commitment to the future of 1.4.x.  The numbering
between 1.4 and 2.0 is perhaps unfortunate in that it implies that 2.0
replaces 1.4.  It doesn't.  They are two different programs that serve
different purposes.  There is certainly overlap (they both do
OpenPGP), but 1.4.x is not going anywhere and new OpenPGP development
will be done on both.

@_date: 2006-11-17 06:04:43
@_author: David Shaw 
@_subject: Problem compiling libgpg-error-1.4 with Mac OS X 
I did some digging on this, and it seems the problem is that configure
(specifically, the tests in gettext.m4) looks for libintl.h to
determine if libintl exists.  On OS X, it doesn't find libintl.h (so
it builds the included copy) but in fact libintl does exist on OS X.
The end result is that it tries to link libintl in twice and fails
because the doubled symbols.
This is not a GPG specific problem, and I wonder if a more up to date
version of the gettext code would resolve this.

@_date: 2006-11-17 06:06:24
@_author: David Shaw 
@_subject: Problem compiling libgpg-error-1.4 with Mac OS X 
I should add also that a temporary workaround if you don't need the
translations is to build with --disable-nls.

@_date: 2006-11-21 01:09:46
@_author: David Shaw 
@_subject: Problem compiling libgpg-error-1.4 with Mac OS X 
That's generally true for most programs, but crypto programs in
particular tend to be different.  Crypto very often contains
endian-specific code for performance reasons, and thus someone
building a fat binary needs to take care they don't end up with big
endian code on an Intel Mac, or little endian code on a PPC Mac.
GnuPG (at least 1.4.x) can be built "fat", and there are special
options in configure to handle the endianness issue (see the README
Still, the original problem reported with libgpg-error-1.4 is not
related to building fat or not.  The package doesn't yet compile at

@_date: 2006-11-27 18:13:50
@_author: David Shaw 
@_subject: Encrypt + Sign format? 
It is encrypted also.  OpenPGP encrypted and signed messages are:
  Encrypt ( Sign ( Message) )

@_date: 2006-11-30 04:20:11
@_author: David Shaw 
@_subject: [Announce] First release candidate for 1.4.6 available 
We are pleased to announce the availability of the first release
candidate for the forthcoming 1.4.6 version of GnuPG:
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.6rc1.tar.bz2 (3.0M)
 ftp://ftp.gnupg.org/gcrypt/alpha/gnupg/gnupg-1.4.6rc1.tar.bz2.sig
SHA-1 checksums for the above files are:
 c7fe6551350866af8509c3ba0666d1e69a1668cd  gnupg-1.4.6rc1.tar.bz2
 9a35c9b9a9544dd0b5afd91c6595655dca2c0b9c  gnupg-1.4.6rc1.tar.bz2.sig
Note that this is only a release candidate, and as such is not
intended for use on production systems.  If you are inclined to help
test, however, we would appreciate you trying this new version and
reporting any problems.
Noteworthy changes since 1.4.5:
    * Fixed a bug while decrypting certain compressed and encrypted
      messages. [bug
    * Fixed a buffer overflow in gpg. [bug
    * Added --s2k-count to set the number of times passphrase mangling
      is repeated.  The default is 65536 times.
    * Added a GPL license exception to the keyserver helper programs
      gpgkeys_ldap, gpgkeys_curl, and gpgkeys_hkp, to clarify any
      potential questions about the ability to distribute binaries
      that link to the OpenSSL library.  GnuPG does not link directly
      to OpenSSL, but libcurl (used for HKP, HTTP, and FTP) and
      OpenLDAP (used for LDAP) may.  Note that this license exception
      is considered a bug fix and is intended to forgive any
      violations pertaining to this issue, including those that may
      have occurred in the past.
Happy Hacking,
  David, Timo, Werner

@_date: 2006-10-02 02:34:09
@_author: David Shaw 
@_subject: Create a key without subkey? 
This is a problem in PGP 5.  PGP 5 is extremely old and does not work
well at this point.  If you are being forced to use PGP 5 by a
financial company, this does not say good things about the company.

@_date: 2006-10-06 04:45:37
@_author: David Shaw 
@_subject: Expiry Date of Key used for signatures? 
It's up to the person who gives you the signature.
This is the default behavior, but you can have your signature expire
at a different time if you choose to.

@_date: 2006-10-09 14:51:25
@_author: David Shaw 
@_subject: Cannot refresh my own key 
You have a mistaken assumption.  The fingerprint is not relevant here.
It looks like you have a preferred keyserver set pointing to the wrong
place.  Add "--keyserver-options verbose verbose verbose" to your
command and see where you're actually looking.

@_date: 2006-10-27 15:10:53
@_author: David Shaw 
@_subject: Another passphrase related question... 
GPG only has a limited amount of secure (i.e. unswappable) memory, and
that's where passphrases and keys are handled.  The effective limit
for a passphrase is a few thousand characters.
If you can type it, GPG will use it.  The only two characters that
aren't usable are null and \n.  Be careful, though.  It's really easy
to get into a situation where you can type something on one
machine/keyboard/os combo that you can't type on another.  If you
ever need to replace a machine, you could lock yourself out.

@_date: 2006-10-29 23:14:33
@_author: David Shaw 
@_subject: FAQ 6.10: "If I submit a key to a keyserver, 
You are confused.  That FAQ item refers to a version of GnuPG that
hasn't been current in 6 years.  You might be having a problem, but it
seems to work just fine for everyone else and has been working for
many years.
Please give enough information that we might be able to help you.
Simply saying "keyserver uploads weren't working" gives us no way to
even guess.

@_date: 2006-10-30 01:36:03
@_author: David Shaw 
@_subject: gpgkeys_hkp: error while loading shared libraries: libcurl.so.3: 
Your configure statement pretty much broke autoconf's heart.  Try a
simple "./configure --prefix=/where/you/can/write/to" and leave it at
that.  Let autoconf work for you.

@_date: 2006-10-30 15:48:59
@_author: David Shaw 
@_subject: gpgkeys_hkp: error while loading shared libraries: libcurl.so.3: 
Ok, good.  Can you send me the config.log file that autoconf generated
for this run?

@_date: 2006-09-12 21:03:41
@_author: David Shaw 
@_subject: Need non-writable --homedir 
It is harmless to use --no-random-seed-file.  If you use it, GnuPG
will just get randomness from whatever your random source is.  The
only difference is that it won't have a seed to start from, so it will
run a little slower.
Encryption shouldn't block.  Key generation might (key generation
tries to use higher quality randomness).  The random data used with
--no-random-seed-file is just as good as the random data otherwise: it
just takes longer to get to it.

@_date: 2006-09-18 05:37:45
@_author: David Shaw 
@_subject: Option file setting for cipher and hash not global? 
I think you're asking for this:
  default-preference-list TWOFISH RIPEMD160
However, note that this controls what other people use when encrypting
to you, and not what ciphers you use when encrypting to them.
Also note that if you only accept TWOFISH and RIPEMD160, you're going
to get a lot (perhaps even most) of your encrypted messages actually
encrypted with 3DES.  TWOFISH is not as common as other ciphers (like
AES), and a sender without TWOFISH will fail over to 3DES.

@_date: 2006-09-27 02:24:33
@_author: David Shaw 
@_subject: DSA2 
No, the licenses are not compatible.  We had quite a problem (and are
still fixing the fallout) with even a small license exception to allow
linking the LDAP and CURL keyserver helpers to OpenSSL for ldaps and
Plus there are the patent issues, which raise a very large headache
for Free software in general.
In any event, it doesn't matter even if the licenses were compatible:
OpenPGP does not have ECC in it.  GnuPG won't support ECC until the
OpenPGP standard specifies it.  I don't see that happening any time
soon, especially given the patent issues.

@_date: 2006-09-28 05:04:09
@_author: David Shaw 
@_subject: DSA2 
It's okay.  We changed the license terms for the keyserver helpers so
they can legally link to OpenSSL.

@_date: 2007-04-03 19:55:43
@_author: David Shaw 
@_subject: comment and version fields. 
The premise of the argument is false.  You didn't alter his
clearsigned post.

@_date: 2007-04-03 20:11:11
@_author: David Shaw 
@_subject: comment and version fields. [Long] 
This is silly.  Observe:
Step 1:
  echo "This is my signed message" | gpg --clearsign > my-signed-message.gpg
Step 2:
  cat my-signed-message.gpg | gpg > output
Step 3:
  cat output
  This is my signed message
Look: no comments or anything like that.  You cannot infer any meaning
from a signed message before you verify it, and notice that when you
verify it, you get exactly what you'd expect.  You're basically
reading the message "source code" before it has been verified.
Complaining about the Comment field is rather like complaining about
OpenPGP packet headers.  I could hide all sorts of super-sekrit
messages in packet headers or in unhashed signature subpackets.  It
doesn't matter a whit.  They're not part of the signed message.
The OpenPGP documentation does not really need a note to say that "you
need to actually verify a signature before you decide that it is

@_date: 2007-04-03 20:58:32
@_author: David Shaw 
@_subject: no, it's not an email client problem, it's what I said at the 
Hash: RIPEMD160
No, it is not.  The RFC doesn't allow it.  GnuPG doesn't allow it.
Nobody allows it.
I am clearsigning this message.  I challenge you to modify it.  I will
donate $1,000 US to any charity you like if you succeed.  The
definition of success is that:
a) The signature must still verify correctly
b) The output of the signature verification in step 'a' still contains
your modification.
Go for it.
I think it's that the mistake you're making has been explained over
and over and you're still repeating it.

@_date: 2007-04-04 01:12:20
@_author: David Shaw 
@_subject: up a creek 
You have quite a few questions here.  I'll answer them as they come up
Yes, this is a feature.  You can also use the key fingerprint here if
you like.
No, this worked correctly.  An OpenPGP "key" is actually multiple keys
glued together.  Each of these keys has their own independent
expiration date, so if you want to change an expiration, you need to
specify which key (primary or subkey) you are changing the expiration
of.  In your case above, if you wanted to change the expiration of the
subkey, you'd type "key 1" before "expire".
The man page says:
   expire   Change the key expiration time. If a subkey is selected,
            no selection, the key expiration of the primary key is
            changed.
Incidentally, since the "identity" of a key is tied to the primary
key, it is a fairly common situation to have a primary key that does
not expire, but a subkey that does.  Then you can keep making subkeys,
and letting them expire over time without having to tinker with the
primary key.  A nice side effect from doing things this way is that
the primary key can even be kept offline altogether.
That's the precompiled binary downloads distributed by the MacGPG
project.  If you're building it yourself, you can do it on whatever
OSX you have.  I personally test new releases on 10.3 and 10.4 (both
PPC and Intel).
Don't use '-i'.  I'm not sure where that idea got started, but it's
just not correct.  -i tells make to keep going after a failure, and
that's not something you want to do: if there is a failure, best to
just stop.  (This is just a side comment - I doubt it has anything to
do with the problems you had later).
I see what happened, but I don't think installing the new GPG did this
to you.  You had a symlink to a directory, and something removed every
file in that directory, and then the directory itself, before GPG ran
as above.  Aside from calling keyservers, which creates and deletes
randomly named temporary directories like "/tmp/gpg-2iSFzk", GPG
simply doesn't have any code in it to delete directories:
$ find . -name '*.c' | xargs grep rmdir
./g10/exec.c:      if(rmdir(info->tempdir)==-1)
Are you using some front-end or installer that might have done this?
Did you delete your GnuPG 1.4.1 installation before adding the new

@_date: 2007-04-04 07:42:56
@_author: David Shaw 
@_subject: your mail 
I can't speak for the binary releases from macgpg.sourceforge.net, but
if you are building from the regular source code release, gpg ends up
in /usr/local/bin, and the keyserver helpers end up in

@_date: 2007-04-04 07:43:37
@_author: David Shaw 
@_subject: unknown_subject 
No, that's where it stores keyrings.  The executable is the 'gpg'
program itself.

@_date: 2007-04-04 08:38:38
@_author: David Shaw 
@_subject: no, it's not an email client problem, ... 
I almost hate to drag reality into this discussion, but the man page
does say exactly that:
   --comment string
   --no-comments
       Use string as a comment string in clear text signatures and
       ASCII armored messages or keys (see --armor).  The default
       behavior is not to use a comment string.  --comment may be
       repeated multiple times to get multiple comment strings.
       --no-comments removes all comments.  It is a good idea to keep
       the length of a single comment below 60 characters to avoid
       problems with mail programs wrapping such lines.  Note that
       comment lines, like all other header lines, are not protected
       by the signature.
And while we're at it, the RFC says it too:
   The Armor Headers are pairs of strings that can give the user or
   the receiving OpenPGP implementation some information about how to
   decode or use the message.  The Armor Headers are a part of the
   armor, not a part of the message, and hence are not protected by
   any signatures applied to the message.

@_date: 2007-04-04 08:40:24
@_author: David Shaw 
@_subject: gpg executable path 
Right.  Those aren't executables.  An executable is the file that you,
well, execute: the 'gpg' binary itself.  Each user gets their own
personal .gnupg directory, but (generally speaking) all users share a
single 'gpg' binary.

@_date: 2007-04-04 12:51:48
@_author: David Shaw 
@_subject: signature digest conflict in message 
This is a known bug with the PGP Global Directory.  Essentially, it
sends out PGP/MIME messages that say "Here comes some data that I
signed with SHA-1", and then says "And here's the signature using
SHA-256".  SHA-1 != SHA-256, so it doesn't work.
I reported the bug a while back.  Presumably it'll be fixed at some

@_date: 2007-04-06 10:48:17
@_author: David Shaw 
@_subject: Un-revoking a key pair 
Yes it is possible.  The first thing is that you must not distribute
the keys while they are in this revoked state: do not send them to
anyone, and absolutely do not send them to a keyserver.
Here's how to unrevoke.  It's a very manual process.  Be safe: make a
backup before you do stuff like this.
  1) Export the public key into a file.
     gpg --export (thekey) > mykey.gpg
  2) Split it into parts:
     gpgsplit mykey.gpg
     This breaks the key into multiple files with names like
     "000001-006.public_key".
  3) Figure out which packet is the revocation.  It's likely to be
     "000002-002.sig", but make sure with:
     gpg --list-packets 000002-002.sig
     That will show information about the packet.  If the sigclass is
     set to 0x20, that's the revocation.  Delete that file.
  4) Put the key back together again:
     cat 0000* > myfixedkey.gpg
  5) Remove the old key:
     gpg --expert --delete-key (thekey)
     You need --expert here so GPG will let you delete the public key
     when a private key is still around.
  6) Import the new key:
     gpg --import myfixedkey.gpg

@_date: 2007-04-13 19:57:19
@_author: David Shaw 
@_subject: Gnupg cannot handle extremely large keys on 32 bit Linux 
I cannot confirm this.  I tested GPG 1.4.7 on OSX 10.4.9 running on
both PPC and Intel.  The 16k key works correctly on both.  Can you
double check your report?

@_date: 2007-04-13 21:45:23
@_author: David Shaw 
@_subject: Key Revocation 
This is one of those things that can be done in multiple different
ways - all of which are "right".
If you can get mail today at the Embarq address, even though the
Earthlink address still works, there is no harm in making an Embarq
key now.  You can revoke the Earthlink key whenever you'd like -
personally, I'd do it when the Earthlink address stops forwarding.
There is one other way to do this that you might want to consider.
Instead of making a new key, just add a new user ID to your existing
key.  The end result is a key with two addresses on it.  Once the
Earthlink forwarding stops, revoke just the Earthlink user ID on the
key (not the whole key).

@_date: 2007-04-14 08:37:49
@_author: David Shaw 
@_subject: Gnupg cannot handle extremely large keys on 32 bit Linux 
Indeed, and this is very strange.  Can you tell me if you compiled
1.4.7 yourself or downloaded it pre-built from somewhere?

@_date: 2007-04-14 08:35:05
@_author: David Shaw 
@_subject: Gnupg cannot handle extremely large keys on 32 bit Linux 
Just to be clear, it does not work for you on either PPC or Intel?  In
both cases you get the incorrect key ID?  (Is it 17CACAE3 both times?)

@_date: 2007-04-14 10:31:12
@_author: David Shaw 
@_subject: Gnupg cannot handle extremely large keys on 32 bit Linux 
And this is a regular 1.4.7, no patches or anything done beyond
download, ./configure, and make ?  And you tested it with the exact
key from the original email at
 ?
I'm not sure where to go with this from here.  Clearly you and I are
doing something different.  I just downloaded a brand new copy of the
1.4.7 tarball from ftp.gnupg.org, and built it again on three
platforms and tested against the key from the original email.  It
still works.
Can someone else with a Mac try importing that key?

@_date: 2007-04-14 15:10:39
@_author: David Shaw 
@_subject: personal-digest-preferences 
It's historical.  Older versions of GPG generated keys with a standard
hash preference of RIPEMD/160 before SHA-1.  When GPG later started
using that hash preference to decide which hash to pick, this resulted
in people who were expecting SHA-1 to suddenly get RIPEMD/160.  To
restore the old behavior, we stuck a SHA-1 preference in

@_date: 2007-04-14 17:07:48
@_author: David Shaw 
@_subject: personal-digest-preferences 
Sure.  Just set the preferences to whatever you actually prefer.  If
you want no preferences at all, do
  personal-digest-preferences none

@_date: 2007-04-14 20:33:38
@_author: David Shaw 
@_subject: personal-digest-preferences 
Note that you don't have to use stuff like "H3 H2 H1" anymore.  As of
version 1.4.0, you can use "RIPEMD160 SHA1 MD5".

@_date: 2007-04-14 23:58:37
@_author: David Shaw 
@_subject: personal-digest-preferences 
No.  You can put any hash in the list you like.  If that hash is not
appropriate for a given context (say, SHA256 with a DSA key), then it
is skipped.
The intent behind the personal-xxxxx-preferences is they are a "safe"
way to specify algorithms.  Unlike forcing an algorithm with something
like --digest-algo, personal-digest-preferences will never cause the
use of an algorithm that violates the protocol.

@_date: 2007-04-15 00:19:08
@_author: David Shaw 
@_subject: Batch Mode and decrypt 
Look at the --passphrase-fd, --passphrase-file, or --passphrase
options.  They are all in the manual, and can be used to provide a
passphrase during batch operation.
However, if you are including the passphrase in a script, it is worth
asking yourself if there is any security benefit in having a
passphrase-protected key at all.  After all, an attacker who gets
access to the script needs merely to read it to know the passphrase.

@_date: 2007-04-15 10:28:17
@_author: David Shaw 
@_subject: Gnupg cannot handle extremely large keys on 32 bit Linux 
A bug.  No big deal, bugs get fixed.
Thanks for helping work this out.  It does indeed seem to be a GPG 2.x
bug that does not happen in the GPG 1.4.x code.  That simplifies where
things need to be searched for.

@_date: 2007-04-16 23:19:42
@_author: David Shaw 
@_subject: Problem when decrypting multiple files 
This is fixed for 1.4.8.  I've attached a patch for now.

@_date: 2007-04-17 12:09:34
@_author: David Shaw 
@_subject: Batch Mode and decrypt 
--passphrase-fd 0 means "give me the passphrase on fd 0 (i.e. stdin)".
This is for people who have this sort of thing in their script:
 program_that_prints_the_passphrase | gpg --passphrase-fd 0
If you don't have that sort of structure, --passphrase-fd isn't useful
to you.
You sound that you want --passphrase-file or just --passphrase.
Again, though, if you're going to actually code the passphrase into
the script itself, why have a passphrase at all?

@_date: 2007-04-18 10:24:01
@_author: David Shaw 
@_subject: Quantum computing 
Robert was commenting on a symmetric cipher (like AES), not asymmetric
(like RSA).  Factoring a 256-bit RSA key is trivial and can be done on
regular home PCs in fairly short order.  However, factoring is not an
attack against symmetric ciphers.
My favorite comment (from Jon Callas at PGP, Inc) about brute forcing
keys is one I think I've posted here before, but still:
  Modern cryptographic systems are essentially unbreakable, particularly
  if an adversary is restricted to intercepts. We have argued for,
  designed, and built systems with 128 bits of security precisely
  because they are essentially unbreakable. It is very easy to
  underestimate the power of exponentials. 2^128 is a very big
  number. Burt Kaliski first came up with this characterization, and
  if he had a nickel for every time I tell it, he could buy a latte or
  three.
  Imagine a computer that is the size of a grain of sand that can test
  keys against some encrypted data. Also imagine that it can test a
  key in the amount of time it takes light to cross it. Then consider
  a cluster of these computers, so many that if you covered the earth
  with them, they would cover the whole planet to the height of 1
  meter. The cluster of computers would crack a 128-bit key on average
  in 1,000 years.
  If you want to brute-force a key, it literally takes a planet-ful of
  computers. And of course, there are always 256-bit keys, if you
  worry about the possibility that government has a spare planet that
  they want to devote to key-cracking.
Note that he's talking about brute-forcing keys here.  If someone
finds a weakness in AES (or whatever), then this math may change
radically.  Pure brute-forcing without such a weakness is just not

@_date: 2007-04-20 09:42:20
@_author: David Shaw 
@_subject: Key signing parties 
Go to It's the perfect site for setting up and finding key signing
gatherings as well as individual signature exchanges.

@_date: 2007-04-21 00:39:16
@_author: David Shaw 
@_subject: Key Revocation 
This will work, but you don't actually have to do it.  The most
recently added user ID is automatically treated as the primary if
there is no primary set.  If you want to set it anyway, just select
the new uid ("uid 1") and enter "primary".
You select the user id with "uid x" where x is the number of the user
ID.  Then "revuid".

@_date: 2007-04-23 13:24:42
@_author: David Shaw 
@_subject: Key signing parties 
Their key exchange service is a tool, and like most tools it can be
used properly or improperly.  You must use the tool in a way that
meets the requirements of both yourself and the person you are
exchanging signatures with.
One thing that their service does nicely is help prevent the case
where A signs B's key, and B promises to but doesn't sign A's key.  It
won't release the keys until everyone does what they promised to do.

@_date: 2007-04-23 13:46:22
@_author: David Shaw 
@_subject: Generating and storeing keys on usb pen 
There is an incorrect assumption underneath this question.  GPG keys
are stored on a usb drive in exactly the same format they are stored
on a laptop: encrypted.  (Well, encrypted by default - if you didn't
explicitly remove the passphrase, they're encrypted).
My point is that storing the keys on a usb drive doesn't change
anything if the keys are lost.  If someone steals your laptop, they
have the encrypted keys.  If they steal your usb drive, they have the
encrypted keys.  There is no difference.  Either way you cut it, the
thief has an encrypted copy of your key.  Unless the thief can figure
out your passphrase, the key is useless to him.
It's quite a bit easier to lose a usb drive than it is to lose a

@_date: 2007-04-25 11:56:09
@_author: David Shaw 
@_subject: Generating and storeing keys on usb pen 
This is mixing the threat to a laptop with the threat to a USB drive.
The main threat to a laptop in this view is being stolen.  The main
threat to a USB drive is being lost or forgotten, not stolen.  Given
that a 1GB USB drive goes for around $10 US around here, I'd be fairly
surprised to see someone bothering to steal a USB drive.  The risk is
higher than the reward unless they're really stealing the data on the
drive which could be worth more than $10 US.
I'd wager for every stolen laptop there are tens of USB drives left
behind.  I base this on the startling number of USB drives attached to
keychains that I see left behind in stores and restaurants.
This is a commonly cited reason for storing keys on a USB drive.  Some
people even keep a GPG binary on the USB drive along with their keys
so they can use GPG in Internet cafes and the like.  This is a very
foolish thing to do.  A USB drive is not a smartcard.  Using your key
from a USB drive on a machine not under your control means the person
who does control that machine can make a copy of your key and
passphrase.  After all, from the perspective of the computer, there is
nothing magic about a USB drive: it's just a disk that fits in a

@_date: 2007-04-27 11:33:15
@_author: David Shaw 
@_subject: Algorithm 11 not available 
The issue here is not that GPG2 doesn't currently have SHA224 and GPG1
does.  There are always going to be algorithm differences between
versions.  The issue here is that the program blew up rather than
failing gracefully when it was unable to use the missing hash.

@_date: 2007-04-27 12:17:48
@_author: David Shaw 
@_subject: Algorithm 11 not available 
Everyone take a breath.  There is nothing wrong, and nobody has
decided to not support SHA224.  The GPG 2 svn already has SHA224
support, and GPG 2.0.4, when it is released, will have SHA224.
Remember that GPG2 uses libgcrypt for it's crypto, so you'll also need
to use a libgcrypt that has SHA224.
That said, however, SHA224 in OpenPGP is a strange thing and is mainly
there for completeness.  It is essentially SHA256 with 32 bits lopped
off, so it costs the same as 256, but only gets the value of 224.

@_date: 2007-08-09 16:52:56
@_author: David Shaw 
@_subject: Partial file download issue - GPG 
The file is corrupt, so cannot be processed.  How was the file
created?  Try comparing the original to what the customer has.

@_date: 2007-08-10 13:08:28
@_author: David Shaw 
@_subject: CoreLabs Detects Flaw In GnuPG - any comments ? 
Basically, upgrade to 1.4.7, which was released on March 5th.

@_date: 2007-08-21 09:56:18
@_author: David Shaw 
@_subject: Compression routines - please include 7-Zip 
Now that 2440bis has been submitted to the IETF, the best way to get a
new algorithm in to OpenPGP is to submit a simple draft that just adds
that algorithm.  It's essentially 3 pages of boilerplate, and a
paragraph or twho saying "add algorithm XXXX".  For example, here's
the draft I put together to add the Camellia cipher:
Of course, the WG has to approve it, and for procedural reasons I
doubt it would be considered until 2440bis is published (it's hard to
publish a document extending X until X is published).  Still, 2440bis
is already in the RFC editor queue, so it's coming.

@_date: 2007-08-22 12:37:52
@_author: David Shaw 
@_subject: Questions about generating keys 
Yes.  Mail programs tend to fetch keys by email address (out of
necessity - that's usually all they know about the person being
No real reason, except it would make the list of key types very long
if every possible combination was listed (RSA primary/Elgamal subkey,
DSA primary/RSA subkey, RSA primary/RSA subkey, DSA primary/Elgamal
It's not common, and keeping a 5 character name helps prevent errors
(mistyping).  If you really have a name that short, you can use the
--allow-freeform-uid to override the test.
As it happens, this will probably be possible in an upcoming version,
but for other reasons.  That said: I wouldn't bother - it changes
nothing about the key and is completely cosmetic.

@_date: 2007-08-22 12:46:47
@_author: David Shaw 
@_subject: subpacket of type 20 has critical bit set 
It means that the person who made that signature set a notation on it,
and marked that notation as "critical".  That means, essentially, "if
you don't understand this notation, you cannot understand this
signature".  Thus, that signature is not usable.
The only notations that GPG understands, and thus allows to be
critical without invalidating the signature are:
  preferred-email-encoding at pgp.com
  pka-address at gnupg.org
Note that the critical notation might be set on a key or data
signature.  That message can be from either.

@_date: 2007-08-22 20:22:07
@_author: David Shaw 
@_subject: Questions about generating keys 
I'm not sure if that is still true or not, but either way, if PGP
doesn't use them now, it will soon.  The new OpenPGP spec supports
large DSA (so-called "DSA2") keys.
Same here.  DSA2 supports larger hashes.
This is actually not completely true.  DSA makes signatures faster
than RSA.  RSA verifies signatures faster than DSA.  Since most
signatures are verified more often than they are generated, this is
generally stated as RSA being faster, but in OpenPGP usage, this is
almost always irrelevant.  Unless you're issuing thousands of
signatures a second, the time needed to read the files, and do the
hashing is far more significant.
Now that DSA2 is here, there aren't really that many benefits to RSA
(and I say this as someone with an RSA key).  In theory, DSA is better
because it is required by OpenPGP: you won't be able to find any
OpenPGP implementation that doesn't handle it.  This is not true of
RSA (it's legal for a program to reject it just because it is RSA).
In practice, that doesn't happen much because the "big two", PGP and
GPG, both handle RSA.
So DSA is the default because the OpenPGP standard requires it to be
present, and does not require the same of RSA.  The reasons behind
this were mainly legal stuff and not relevant any longer.
The feature wasn't removed.  Option 7 took its place.  RSA (sign and
encrypt) is the same thing as RSA (set your own capabilities) - just
turn on the sign and encrypt flags.
No performance difference.  There is a minor security difference
between one and two keys in that if your key is compromised, with one
key you've compromised both your signing and encrypting capabilitles.
With two keys, you've only compromised the one.
The usual example of this is the police demanding an encryption key
from you (which they can do in many places around the world).  If you
have a subkey for encryption, you could turn over that subkey without
affecting your primary key (and thus all the signatures you've
gathered and issued).  If you don't have a subkey for encryption, you
can be forced into turning over the one key, which compromises your
signing "key" as well.
Mainly the use of GPG inside anonymous remailers and similar proxies.
In cases like that you may want to randomize or force the internal
timestamps to hide the original values.
There is a whole lot of code in the world that really really expects
an email address in there.  You're free to do what you want, but don't
be surprised when something breaks.

@_date: 2007-08-22 23:35:55
@_author: David Shaw 
@_subject: Questions about generating keys 
Make sure you're comparing apples to apples here.  If you're comparing
RSA to DSA, you need to measure signature speed.  If you want to
compare RSA encryption speed, you need to compare it against an
encryption algorithm like Elgamal.  DSA doesn't encrypt.
There is a substantial difference, but no real difference in practice
for most uses of OpenPGP.  (I could make up a case where it might make
a difference, but it would be an odd, clearly invented, case).
Yes.  DSA signatures are relative to the size of the hash used.  RSA
signatures are relative to the size of the key.
Not exactly equal, but roughly equal.  The largest DSA2 key that GPG
will generate is a 3072 bit key that uses a 256-bit hash.  The largest
RSA key that GPG will generate is 4092 bits long.  3072/256 is roughly
balanced in strength (that is, the key and the hash are about the same
strength).  4096, the RSA limit, isn't felt to be significantly
stronger than 3072 (the next step after 3072 is actually 7680 in the
NIST key management publication 800-57).
It's important to note that we're talking about tiny fiddling details
here.  Either path is so vastly stronger than is usually needed that
this is rather like discussing whether a 1001-foot fence is better
than a 1000-foot fence: sure, 1001 sounds better, but if you have an
attacker that could get over a 1000 foot fence, it's safe to assume
they can make a pretty good crack at the remaining foot.
If you're really worried about people with older software not being
able to use your key, that's a strong reason to not choose DSA2.  In
that case, I'd make a RSA primary key, an encryption subkey of
whatever algorithm you like, and then a DSA subkey that you actually
use to sign with.  Do avoid signing documents with a big RSA key.
It's really annoying to the recipient.
It's way more complex than that (both for OpenPGP and other IETF
specs).  Check out the significant number of patent-related documents
on the IETF website.  There are (at least) two full RFCs on this topic
Remember also that before OpenPGP was OpenPGP, it was just PGP: a good
bit of the OpenPGP standard was "standardized" before the IETF was
brought in.  Again, historical and occasional legal issues that aren't
really relevant any longer.

@_date: 2007-08-23 09:57:49
@_author: David Shaw 
@_subject: Using an old .gnupg directory 
You shouldn't have to do anything else.  Once you have a .gnupg
directory in your home directory, GPG will find it and use it.

@_date: 2007-08-24 08:58:29
@_author: David Shaw 
@_subject: Questions about generating keys 
Thanks for checking this.  Can you tell me what happens if you import
a (GPG created) DSA2 key into PGP?  Is PGP then able to verify a DSA2
signature created with GPG?
It's reasonably common with this sort of thing to enable reading a new
feature before enabling writing it.  It's the whole
be-liberal-in-what-you-accept thing.

@_date: 2007-08-24 15:52:40
@_author: David Shaw 
@_subject: Questions about generating keys (hash firewalls) 
I suspect a major reason is the main use of DSA is really DSS - and
DSS was never intended to be used with any hash other than SHA-1.
It gets a little stickier with DSA2/DSS2 where there are several
possible hashes.  For example, a 1024/160 DSA key can use SHA1, but
also SHA224, SHA256, SHA384, or SHA512, by truncating them to 160

@_date: 2007-08-31 07:55:32
@_author: David Shaw 
@_subject: How to use GnuPG to generate sha512sum hash? 
You are making a mistake with "echo".  By default, echo adds a newline
at the end of what it prints.  You are hashing "AAA" on the website,
and "AAA\n" with GPG, so naturally they don't match.
Add the "-n" flag to echo to tell it to not add a newline, and you
will see the results match:
  echo -n AAA | gpg --print-md sha512

@_date: 2007-12-13 09:17:06
@_author: David Shaw 
@_subject: Are there new Builds for OS/X ? 
Yes, you are current.  Version 1.4.8 will be coming out soon.

@_date: 2007-12-13 12:46:27
@_author: David Shaw 
@_subject: How to trust a key only for users in one domain 
Use "gpg --edit-key (thekey)" and then "tsign".  You will be asked the
usual signature questions, and also the trust level (RFC-4880 section
5.2.3.13) and then the domain.

@_date: 2007-12-20 10:49:53
@_author: David Shaw 
@_subject: Help! I can't revoke my public Key! 
Do this:
  gpg --import (the revocation file)
  gpg --keyserver pgp.mit.edu --send-key (the key id)

@_date: 2007-02-01 15:04:27
@_author: David Shaw 
@_subject: 'sensitive' designated revoker -- are the keyservers still aware? 
Not exactly.  When exporting a key that has a sensitive designated
revoker set, the key is exported, but the designated revoker
information is not included.  Anyone looking at the key from the
outside cannot tell the difference between this state, and no
designated revoker set at all.  However, if the designated revoker has
in fact revoked the key, then the designated revoker information IS
included, along with the revocation.
The idea behind this is that the relationship between the designated
revoker and the key owner is sensitive, and so we must not reveal the
identity designated revoker until we absolutely must (i.e. when they
actually revoke the key).
Note that there is an option "export-sensitive-revkeys" which tells
GPG to export the designated revoker information even if the key isn't
revoked.  This essentially pretends that the "sensitive" flag is not
set.  Under normal circumstances, you don't want to do this.

@_date: 2007-02-01 15:37:25
@_author: David Shaw 
@_subject: 'sensitive' designated revoker -- are the keyservers still aware? 
Any anonymous revoker could not do their job as we wouldn't know
whether to ignore the revocation or not.  For example, say you
designated me as your revoker.  If my identity is kept secret, even
after I issued a revocation, how could someone coming across that
revocation know that they should accept it?

@_date: 2007-02-01 16:39:34
@_author: David Shaw 
@_subject: explain nrsign & lsign? 
Good point.  I like the service that biglumber provides for
keysignings.  It nicely automates a lot of the bookkeeping, tracks the
participant list, etc.  It also makes the information spam-unfriendly.

@_date: 2007-02-05 00:12:26
@_author: David Shaw 
@_subject: GPG fails to verify clamav 
Download the key 985A444B:
  gpg --keyserver random.sks.keyserver.penguin.de --recv-keys 985A444B
Then do the verify.

@_date: 2007-02-08 11:08:36
@_author: David Shaw 
@_subject: gen-key non-interactively 
Make a file that looks like this:
     %echo Generating a standard key
     Key-Type: DSA
     Key-Length: 1024
     Subkey-Type: ELG-E
     Subkey-Length: 1024
     Name-Real: Joe Tester
     Name-Email: joe at foo.bar
     Passphrase: abc
     %pubring foo.pub
     %secring foo.sec
     # Do a commit here, so that we can later print "done" :-)
     %commit
     %echo done
Then do:
    gpg --batch --gen-key /path/to/the/file/above
End result will be a public key in foo.pub and secret key in foo.sec.
See the DETAILS file (in the doc directory) for the various things you
can do.

@_date: 2007-02-08 11:10:02
@_author: David Shaw 
@_subject: gen-key non-interactively 
I strongly advise against using expect to generate keys.  Your expect
script will break when we change the text that GPG displays.  If you
want to generate keys unattended, then use the --batch --gen-key

@_date: 2007-02-08 15:45:32
@_author: David Shaw 
@_subject: GnuPG on MS Vista 
Can you do the request, but add
  --debug 1024 --keyserver-options "use-temp-files keep-temp-files"
There will be a line that says something like "DBG: Using temp file
such-and-such".  Send me the tempin.txt and tempout.txt file.

@_date: 2007-02-09 22:12:45
@_author: David Shaw 
@_subject: sig-keyserver-url 
I think there is some confusion here.  sig-keyserver-url applies to
signatures.  That is, signatures on data (--sign-file or the other
signature making commands).  It has no effect on signing keys
What are you trying to accomplish?

@_date: 2007-02-12 00:56:42
@_author: David Shaw 
@_subject: sig-keyserver-url 
Given the current GPG, you can't.  There is no ability to do that.
You can only put a preferred keyserver URL on your own key (in a
self-signature), or in a data signature.

@_date: 2007-02-13 11:43:11
@_author: David Shaw 
@_subject: Sending Public Key 
It sounds like straight OpenPGP will do the job for you.  It is a
well-understood and widely supported protocol for public key
encryption.  GnuPG can do what you need right out of the box, and can
handle both email and postal easily.

@_date: 2007-02-13 13:45:55
@_author: David Shaw 
@_subject: storing password lists in mails to myself on IMAP? 
Yes.  If the data is securely encrypted, mail is just as good as any
other over-the-network method for moving the file from machine to

@_date: 2007-02-16 17:51:52
@_author: David Shaw 
@_subject: GnuPG, Thunderbird, and Armor Headers From PGP 9.5 
This is a problem that pops up now and then.  PGP Desktop isn't adding
a second line (the " Rather, it is adding one big
Version line, and then something in the mail chain (generally it's
their mail program) is "helping" by word wrapping the mail.  Since
that Version line is really long, the  bit ends up on a new
You might want to ask the folks mailing you to check their word
wrapping settings.

@_date: 2007-02-18 23:31:55
@_author: David Shaw 
@_subject: Keyserver refresh period after gpg --send-keys 
There is not an easy answer to that question.  subkeys.pgp.net is not
actually a keyserver, but rather a collection of (at the moment) 5
different keyservers.  When you use it, you get one server from the
pool in a round-robin fashion.  Generally speaking, any given
keyserver in the pool that you update reflects the update immediately,
but frequently people update one keyserver in the pool, but then check
for the update from another server in the pool which hasn't gotten it
That said, if you don't see an update by tomorrow, I'd send it again.

@_date: 2007-02-19 12:19:32
@_author: David Shaw 
@_subject: Keyserver refresh period after gpg --send-keys 
I think you're right (to print as a "verbose" thing for those who care
to know or to help with debugging), but unfortunately there is not an
easy way to get the IP address when using libcurl.  I'm not
particularly eager to start playing socket games with
CURLINFO_LASTSOCKET just to get a string to print.

@_date: 2007-02-23 08:09:20
@_author: David Shaw 
@_subject: Attribute 'comment' 
If you're referring to the "Comment: xxxxxx" string that appears in
the header of armored messages, then yes.  Just use "--comment xxxxx"

@_date: 2007-02-26 15:52:31
@_author: David Shaw 
@_subject: Available and default options 
This is an example of "be liberal in what you accept, conservative in
what you generate".  In theory, it shouldn't matter what algorithms
were listed in the preference list as the OpenPGP protocol would never
allow using an algorithm that couldn't be handled by all users.
In practice, however, it turned out that not all programs properly
handled preferences, and there were issues with people generating a
key with one program and using it on another without resetting the
preferences to what the new program could handle, and things like
Even though most of the old systems are no longer used, the end result
is the preference list as you see it now, and there is high confidence
that it will interoperate with anything.  Nothing stops you from
putting whatever algorithm you want in there, of course.

@_date: 2007-01-02 08:55:46
@_author: David Shaw 
@_subject: Import PGP Secret Keys 
It is difficult to answer this, because this is an "impossible"
occurance.  Public and private keys are not the same, and a private
key somehow ending up in the public keyring in GPG would cause it to
panic and terminate the process.  There are many places where this
assertion is enforced.  Please check that what you think is happening
is really happening.  Is the file you are importing really a private
key?  (gpg --list-packets on the file can help answer this question).
Also, note that if you import a secret key (in either PGP or GPG)
without the corresponding public key, the program will create a public
key from the information in the secret key as a secret key alone is
not useful.  The end result is both a secret and a public key are

@_date: 2007-01-02 22:52:58
@_author: David Shaw 
@_subject: Connecticut DSS Requirements for Electronic Signatures 
I'll preface this by noting that while I have done work similar to
this in "fitting" GPG to set regulations, and could reasonably be
called an authority on OpenPGP/GPG, obviously I'm not an authority
from the Connecticut DSS, or even the Massachusetts one.
The "unique code" is the user's private key, plus the passphrase.
Not exactly true, but true enough.  The exact details depend on which
signing algorithm you're using.
The name and email address are just stored along with it.  They are
treated as part of the key for convenience, but are not a factor in
the actual crypto math.
I'd say the "unique code" includes the passphrase.  It would be hard
to argue otherwise as even the example given in the document shows the
passphrase being included (requirement 1).  That said, I don't see 7b
as requiring you to issue each user a new passphrase every 60 days.
It is sufficient for you to "ensure passphrases are revised
periodically", which would allow for users to change them.
The catch here is that there is no facility in OpenPGP for forcing a
periodic passphrase change.  Since it can't be forced, you may have to
trust your users to do this properly.

@_date: 2007-01-18 13:01:42
@_author: David Shaw 
@_subject: Upgrade from 1.0.4 to 1.4.6 
GPG needs you to tell it which keys are ultimately trusted (i.e. your
own keys).  Do "gpg --edit (thekey)" enter "trust", and set the trust
to "ultimate".  Repeat for each of your keys.
There is a script ("convert-from-106") that comes in the tools
directory of the GPG distribution that automates all this.  Just run
that and it will do all the work for you.

@_date: 2007-01-20 11:03:22
@_author: David Shaw 
@_subject: sig-keyserver-url 
This will work fine, as will "hkp://minsky.surfnet.nl".
This will work fine as well.
This one wouldn't.  0x%S isn't a key ID, but if you put a key ID
there, it'll work fine too.
Basically it works this way when you have automatic key retrieval
turned on: if the sig-keyserver-url is a keyserver (i.e. not a full
HTTP path), then GPG will do the right thing and try and fetch the key
in question (i.e. the one that issued the signature).  If it's a full
HTTP path, GPG will retrieve it directly.

@_date: 2007-01-22 07:50:16
@_author: David Shaw 
@_subject: Symmetric encypher with private key decypher 
Given the above syntax, how would you decrypt?  That is, how are you
saving a local copy of the key for later?
It'll stop after \n.  You can pipe your random key through something
that will escape the \n character if you like.

@_date: 2007-01-24 12:07:54
@_author: David Shaw 
@_subject: working with bare gpg - how to close the text-block 
To go further and accomplish what goal?  What are you trying to do?

@_date: 2007-01-25 11:49:37
@_author: David Shaw 
@_subject: trust owner => trust his key? 
Owner trust doesn't mean "I trust this person" or "I trust that this
key belongs to the person it seems to".  It actually means "I trust
this key to sign other keys".  If you want to make a key valid, you
need to either sign it yourself (you can use 'lsign' if you want to
make a local signature that is for your own use, or 'sign' if you want
to make the signature publically for anyone to use).  Once a key is
valid, then its owner trust is taken into account with making keys
that it signed also valid.
You were on the right track before.  Just instead of giving full owner
trust to some of the developers, lsign their keys also.

@_date: 2007-01-28 12:19:22
@_author: David Shaw 
@_subject: explain nrsign & lsign? 
Neither key is made non-exportable.  A local signature just means the
*signature* is local.  So if you lsigned B with A, then exported B (or
sent it to a keyserver), the local signature from A would not go along
with it.  GPG automatically strips off any local signatures on the way
nrsign, for a non-revocable signature, means pretty much what it
seems: a signature that cannot be later revoked.  If A nrsigns B, then
A can't change his mind later and issue a revocation.

@_date: 2007-01-28 15:00:08
@_author: David Shaw 
@_subject: explain nrsign & lsign? 
No, there is no point in doing this as the main point of signing a key
is so that GnuPG (or PGP) can use the signature in its trust
calculations to decide if a given key is valid or not.  If you post
your signature values on a web page somewhere (presumably in a human
language), GnuPG can't read it and understand it, and so that
information is not usable.

@_date: 2007-01-28 15:33:50
@_author: David Shaw 
@_subject: [HELP NEEDED] GnuPG-1.4 IDEA migration to GnuPG-2.0 
It's not true that IDEA isn't OpenPGP compatible.  IDEA is cipher in OpenPGP, and the new RFC does not change that.  It is absolutely
part of (though an optional part of) OpenPGP.
The problem with IDEA is that it is patented, and will be patented for
at least 3 more years (the exact end date depends on which country
you're in).  Without going into endless detail, patented algorithms
and the GPL license are not really compatible with each other.
Even so, ask if you really need IDEA or not.  Unless you have a
serious need for PGP 2.x compatibility, IDEA doesn't buy you much.

@_date: 2007-01-28 15:37:36
@_author: David Shaw 
@_subject: explain nrsign & lsign? 
GPG doesn't care what the email address is.  Most keyservers don't
care either (with the notable exception of ldap://keyserver.pgp.com
which sends a confirmation mail to the address on the key).
Signatures made by such a key live on other keys, so if those other
keys are retrivable, then the signatures come with.
Can you explain what you're trying to do?  In general, there are good
reasons for email addresses being real email addresses, and keys being
real keys, and so on.  There is a good amount of software here that is
designed to help you.  If you insist on throwing nails in the gears,
the software can't do its job.

@_date: 2007-01-28 18:06:29
@_author: David Shaw 
@_subject: explain nrsign & lsign? 
Pick any that GnuPG supports.  They're all strong.
You limit the distribution of the secret key.  You distribute the
public key widely as that is what allows trust to be followed.  There
is no harm in distributing the public key, and no benefit in
restricting it.
Why not a real address?  What benefit does that give you?
Why two different encrypt-only keys?

@_date: 2007-01-29 10:22:18
@_author: David Shaw 
@_subject: explain nrsign & lsign? 
This is very true.  The economics of spam have changed radically over
the past few years.
At one point, the keyservers could be considered "uninteresting" to
the average spammer: lots of invalid addresses mixed in with the good
addresses, the annoyance factor of pulling addresses from a keyserver
that only returns a small fraction of the entire keyring per search,
etc.  Nowadays, many spammers aren't using their own bandwidth or CPU.
So why *not* hit the keyservers?  It costs them essentially nothing.
This was my conclusion as well.

@_date: 2007-01-31 16:19:33
@_author: David Shaw 
@_subject: explain nrsign & lsign? 
============================== START ==============================
Indeed.  It is also possible that the keyservers aren't being targeted
specifically as keyservers, but rather that people have links to
keyserver searches out there, and the spammers are just using a
crawler that happens to follow that link.  Some keyservers don't
obfuscate their search results.

@_date: 2007-07-03 12:18:36
@_author: David Shaw 
@_subject: algortihm 11 
Yes.  A key likely used SHA224 for a subkey certification or a
"backsig" certification.  When GPG2 tried to verify that subkey, it
needed SHA224, didn't find it, and failed.

@_date: 2007-07-03 13:03:02
@_author: David Shaw 
@_subject: algortihm 11 
I should add, though, that this bug is fixed and will be in the next
gpg2 release.

@_date: 2007-07-06 19:37:56
@_author: David Shaw 
@_subject: Cross Compile gnupg 1.4.7 on a Mac PPC for Mac Intel? 
It's in the README:
    Building Universal Binaries on Apple OS X
    -----------------------------------------
    You can build a universal ("fat") binary that will work on both
    PPC and Intel Macs with something like:
    ./configure CFLAGS="-arch ppc -arch i386" --disable-endian-check \
    If you are doing the build on a OS X 10.4 (Tiger) PPC machine you
    may need to add "-isysroot /Developer/SDKs/MacOSX10.4u.sdk" to
    those CFLAGS.  Note that any third-party libraries you may link
    with need to be universal as well.  All Apple-supplied libraries
    (even libraries not originally written by Apple like curl, zip,
    and BZ2) are universal.

@_date: 2007-07-11 11:30:11
@_author: David Shaw 
@_subject: Strange experience with diskperf 
Consider it brought to their attention.
What you are seeing is probably related to the fact that GnuPG can use
diskperf as one of its random number sources.
Can you give more information - specifically what version of GnuPG?
Also, on your system without diskperf, do you get a message like
"NOTE: you should run 'diskperf -y' to enable the disk statistics" ?

@_date: 2007-07-17 12:13:13
@_author: David Shaw 
@_subject: GnuPG and PGP 5.0 compatibility problem 
We'd have to track down what the problem was first.  Understand that
PGP 5.0 predates the OpenPGP standard that modern PGP and GnuPG use by
quite a while.  It's not massively insecure (though there were some
bugs reported), but it just doesn't follow the same "rule book" as
everyone else.
The usual PGP 5 behavior when it doesn't understand something is to
ignore it, as you saw.

@_date: 2007-06-01 14:31:26
@_author: David Shaw 
@_subject: setting expiration dates 
Yes, it is possible.  At the prompt, enter the date in YYYY-MM-DD

@_date: 2007-06-01 22:20:04
@_author: David Shaw 
@_subject: setting expiration dates 
The expiration does not apply to someone who has the key without the
expiration.  It's not really a question of mandatory or discretionary,
but just an out-of-date key.  If and when they update their copy of
your key, they will get the expiration.

@_date: 2007-06-06 22:20:39
@_author: David Shaw 
@_subject: setting expiration dates 
Your key looks fine to me.  Possibly the GD was complaining that you
have two expired subkeys, though this should not matter as you also
have an unexpired one.
Perhaps try deleting the expired subkeys before submitting the key to
the GD.  If that works, you might submit a bug report on the GD, since
an expired subkey should not prevent uploading the whole key.

@_date: 2007-06-11 13:26:16
@_author: David Shaw 
@_subject: Revoke and expire 
They're similar, but different.  A key that has reached its expiration
date is not usable, but a new expiration date can be put on it that
makes the key usable again.  A key that has been revoked cannot be
easily un-revoked.
Note that I'm talking about whole keys here.  It is possible to
un-revoke a revoked user ID on a key.

@_date: 2007-06-11 13:39:59
@_author: David Shaw 
@_subject: PGP software pirated 
I suspect what you got was either someone elses license file, or
possibly something that patches the PGP code itself to bypass the need
for licensing.
Even if the PGP license key was somehow compromised (which I highly
doubt), it does not follow that "probably our keys can also be

@_date: 2007-06-13 12:04:08
@_author: David Shaw 
@_subject: decrypt : primary key or subkey ? 
No. --export-secret exports the whole secret key, including subkeys.
--export-secret-subkeys exports ONLY the subkeys, and is likely not
what you want.

@_date: 2007-06-13 16:38:25
@_author: David Shaw 
@_subject: Revoke and expire 
Essentially, yes, though there are simpler ways to do it.  Save a
revoked key to a file and run 'gpgsplit' on it.  Delete the revocation
packet.  Join the parts back together again, and poof: you have a
unrevoked key.
The catch, of course, is that the key on the keyservers is still
revoked.  You can send out this "non-revoked" key, but as soon as
someone refreshes from a keyserver, it'll become revoked again.
There are a few interesting attacks around this sort of packet
tampering.  Say that Alice got a copy of Bob's private key and his
passphrase.  Bob finds this out, and immediately revokes his key and
sends the revocation to a keyserver.  Later, Charlie wants to
communicate with Bob, and Alice "helpfully" gives him a copy of Bob's
un-revoked public key, knowing that she can read anything encrypted to
it.  This doesn't work in practice, as Bob will presumably notice that
Charlie is using a revoked key.  (GPG will actually warn Bob when
decrypting Charlie's message) Still, Alice could get one message that
I have a different opinion for full keys (for which I mildly favor
revocation because it's an explicit step that means "this key is dead,
full stop") and subkeys, which I'd just let expire.
It's not really a big deal though - either way, the key and/or subkey
isn't usable.

@_date: 2007-06-17 12:58:35
@_author: David Shaw 
@_subject: RSA 1024 ridiculous 
GnuPG supports RSA keys much larger than 4096 bits.   It does not,
however, currently allow generation of such keys, so the keys must
come from elsewhere.
For many cases, yes.  However, ECC is not yet defined for OpenPGP.
Until that happens, there won't be official support for it in GnuPG.
Note, though, there is a ECC version of GnuPG out there if you want to
try it.

@_date: 2007-06-17 14:48:03
@_author: David Shaw 
@_subject: RSA 1024 ridiculous 
Not exactly.  There are two main costs when signing a file: the cost
to hash the file, which is dependent on the size of the file and the
chosen hash algorithm.  The other cost is the signing algorithm.
Since the data signed in a signature is the hash output, and since
hashes are generally tiny relative to the size of the file, this is
really the cost of the signing algorithm itself (the biggest hash
algorithm supported by GnuPG is SHA-512, and that's only 64 bytes

@_date: 2007-06-17 17:18:39
@_author: David Shaw 
@_subject: RSA 1024 ridiculous /8192 is sublime 
It's in keygen.c:ask_keysize.  It's trivial to change, but be aware
that we've set it to 4096 for a reason (several reasons).  Of course,
I firmly believe in the right of everyone to shoot themselves in the
foot if they insist on it.

@_date: 2007-06-17 17:20:32
@_author: David Shaw 
@_subject: Which key is used when more than one are valid? 
GnuPG picks the subkey for you unless explicitly told which one to
use.  In the above case, it would pick the second key, as it is more

@_date: 2007-06-17 17:38:49
@_author: David Shaw 
@_subject: RSA 1024 ridiculous / RSA 8192 sublime, and, possible with gnupg. 
There is no magic "stop working if the key is > 4096 bits" in the RSA
code.  The math doesn't work that way, anyway.  The limit in GnuPG is
artificial, but carefully considered to balance multiple factors like
performance, and perhaps most crucially, interoperability with other
OpenPGP implementations.
Every year someone (re)patches GnuPG to raise the key size limit for
RSA.  This is followed by a flurry of messages until people see just
how inconvenient a giant RSA signature is and then move on.
This year is slightly different in that I'm waiting for someone to
discover they can also raise the key size limit for DSA.  That, at
least, is marginally less strange as I put in code to make the hash
size automatically rise as the key size rises.  Using SHA-1 with a
8192-bit RSA key is... odd.

@_date: 2007-06-17 22:27:37
@_author: David Shaw 
@_subject: RSA 1024 ridiculous / RSA 8192 sublime, and, possible with gnupg. 
I have no idea what this means... which makes it an excellent analogy
for the key size question.  It takes some understanding of the issues
to know why a particular key size matches up with a particular hash
size, is used with particular software, for particular usage, etc.  I
don't understand the issues in your example (beyond saying "they're
two different bullets"), so if I needed to choose between them, I'd
have to do some learning first to even understand the question, much
less reach the right answer for me.
The defaults in GnuPG are chosen to be basically sane for the
overwhelming majority of users.  People who are recompiling GnuPG need
to understand the implications of the change they are making and be
aware they're throwing away that safety net.

@_date: 2007-06-20 14:39:02
@_author: David Shaw 
@_subject: If the message is encrypted symmetrically... 
No.  The symmetric key is not generated by the public key.  As Joseph
said, the symmetric key is random.
The symmetric key is used to encrypt the data, and then the public key
is used to encrypt the symmetric key.

@_date: 2007-06-22 08:54:51
@_author: David Shaw 
@_subject: RSA 4096 ridiculous? (was RSA 1024 ridiculous) 
If you want bzip2, use can use bzip2 directly from within GnuPG:
  --compress-algo bzip2
For some inputs (like text), bzip2 does some impressive things.

@_date: 2007-06-22 15:20:21
@_author: David Shaw 
@_subject: Two questions 
The preference on the key is unrelated to what you will use when
signing with that key (though given how often this comes up, I'm
tempted to change it).
Pick the hashes you like, and put a line in your config file listing
those hashes:
  personal-digest-prefs SHA256 RIPEMD160
This will use SHA256 when possible (i.e. when signing with a RSA or
DSA2 key), and RIPEMD160 otherwise.
In your config file:
  default-key (your-keyid-here)

@_date: 2007-06-22 15:33:09
@_author: David Shaw 
@_subject: Two questions 
See the warnings on "digest-algo" in the manual.  In short, don't use

@_date: 2007-06-26 21:13:18
@_author: David Shaw 
@_subject: Converting ascii armored signature to cleartext 
Interestingly enough, while you can't always go from a signed file to
a clearsigned file, you can safely do the opposite of what the
original poster asked: converting from cleartext to a signed file
(armored or not) is possible.
(I'm not sure when someone would want to do this, but...)

@_date: 2007-06-30 07:28:58
@_author: David Shaw 
@_subject: Converting ascii armored signature to cleartext 
You grab the signature from the clearsigned file, convert it to binary
form, grab the text from the clearsigned file, package it inside a
plaintext packet, and then just glue the two together.  Something like
1. gpg --output text_part clearsigned_file
2. gpg --output sig_part.gpg --dearmor
   (now paste in the signature from the clearsigned file)
   ^D
3. Edit text_part and remove any whitespace at the end of each line,
   then remove the LAST (and only the last) message separator (CR, LF,
   etc).
4. gpg -z0 --textmode --store text_part
5. cat sig_part.gpg text_part.gpg > my_new_file.gpg
Step 3 is the tricky bit, of course.  Using a unix-ish system as an
example, if the text file ends with "\n\n", you still only remove the
last "\n".  Step 5 makes a old-style signed file (you could make a
new-style onepass signed file, but you'd need to create the onepass
It's an interesting side-effect of how the text canonicalization is
done.  The clearsigning rules are more strict than the regular
signature rules, so it's possible to switch the packaging like this.

@_date: 2007-03-02 07:58:08
@_author: David Shaw 
@_subject: Error with encrypting: unusable public key 
It's okay - this is the new sort (i.e. OpenPGP or V4) of RSA key.  You
can add subkeys and do anything you'd do with any other OpenPGP key.
Only the old PGP 2.x (V3) RSA keys cannot carry subkeys.

@_date: 2007-03-07 13:08:52
@_author: David Shaw 
@_subject: [Macgpg-users] 1.4.7 packages for OS X 
Do you mean binary releases from somewhere or building your own?  If
you're building your own, this is not the case, or at least, should
not be the case.  If compiling 1.4.7 on Panther doesn't work, report
it as a bug.  I will fix it.

@_date: 2007-03-07 18:21:47
@_author: David Shaw 
@_subject: [Macgpg-users] 1.4.7 packages for OS X 
Yes indeed.
Let me reiterate: as far as I'm concerned, if the current GPG doesn't
build on a particular version of OSX, that's a bug.  And I'll do my
best to fix GPG so it does build.

@_date: 2007-03-08 13:17:24
@_author: David Shaw 
@_subject: [Macgpg-users] 1.4.7 packages for OS X 
gcc 4.0.1 is not needed to build GnuPG.  You should be able to build
it with whatever version is on your Panther box.
If it doesn't work, tell me, and I'll make it work.

@_date: 2007-03-09 20:10:30
@_author: David Shaw 
@_subject: no-force-v3-sigs 
It is not the default.  It should be made the default eventually, but
it's not yet.

@_date: 2007-03-10 00:00:45
@_author: David Shaw 
@_subject: no-force-v3-sigs 
Subkeys get certs, not sigs.  force-v3-sigs only applies to data
signatures, and never to keys or subkeys.

@_date: 2007-03-10 00:02:11
@_author: David Shaw 
@_subject: Armor bis... 
Please do not send messages like this.  Among the various problems it
causes, it renders the list archive on the web useless, and that list
archive is important for people to find information.  This is what
this looks like on the web:

@_date: 2007-03-13 00:13:36
@_author: David Shaw 
@_subject: GnuPG incompatible with windows-vista ? 
You are either missing gpgkeys_hkp.exe or GPG can't find it (not in
your path).

@_date: 2007-03-13 09:29:35
@_author: David Shaw 
@_subject: GnuPG incompatible with windows-vista ? 
Interesting that GPG was able to find gpgkeys_curl.exe but not
gpgkeys_hkp.exe.  Hmm.  What version of GPG is this?
Can you send the output of your keyserver request with "--debug 1024"

@_date: 2007-03-13 14:35:04
@_author: David Shaw 
@_subject: GnuPG incompatible with windows-vista ? 
Interesting.  Can you tell me the settings of these values in config.h
when you compiled:
  HAVE_DRIVE_LETTERS
  DISABLE_KEYSERVER_PATH
  HAVE_W32_SYSTEM
Also, do note that I don't think anyone has done a strong check of the
random number code on Vista yet, so be warned about that.  I'm just
debugging the keyserver access stuff here.

@_date: 2007-03-13 14:59:31
@_author: David Shaw 
@_subject: GnuPG incompatible with windows-vista ? 
This will fix HKP, but remove the ability to use HTTP.  Better to fix
the bug here.

@_date: 2007-03-13 16:12:56
@_author: David Shaw 
@_subject: GnuPG incompatible with windows-vista ? 
I don't disagree, but we're going to have to get this working on Vista
eventually.  The only way it's going to get supported and usable is to
fix the problems.

@_date: 2007-03-13 22:41:29
@_author: David Shaw 
@_subject: GnuPG incompatible with windows-vista ? 
If anyone is building on Vista (or building elsewhere but using it on
Vista), try this patch.

@_date: 2007-03-13 21:52:11
@_author: David Shaw 
@_subject: GnuPG incompatible with windows-vista ? 
I doubt this is a path problem.  gpgkeys_hkp.exe and gpgkeys_curl.exe
are in the same directory.  If it was a path problem, both wouldn't
It's an access() problem.  I'm not sure exactly what I want to do
about it though.

@_date: 2007-03-14 08:40:34
@_author: David Shaw 
@_subject: GnuPG incompatible with windows-vista ? 
Thanks for building this.  It looks good, so I'll commit the patch for
the next releases.

@_date: 2007-03-14 21:00:40
@_author: David Shaw 
@_subject: PGP Desktop and GPG 
The short answer is yes, any key you generate with a roughly recent
PGP Desktop can be used with GnuPG, and vice versa.  Just export it
from one (remember to export the secret key too) and import it into
the other.

@_date: 2007-03-14 22:04:19
@_author: David Shaw 
@_subject: PGP Desktop and GPG 
That's correct.  Most people do need to decrypt stuff sent to them,
and so they'd need a private key.  If you are strictly encrypting to
others, then all you need is their public key.

@_date: 2007-03-16 10:13:08
@_author: David Shaw 
@_subject: Deleting a designated revoker 
This is not exactly true.  You can certainly delete the packet that
says "this key has a designated revoker", but note that there is no
way to undo the designation if the key has been distributed.  It's
like a signature from a key you don't own: you could delete the
signature packet, but you can't revoke it.  Designated revoker
signatures are irrevocable as part of the OpenPGP protocol, even
though they are issued from your own key.
What PGP is doing is just deleting the packet.  If you sync with a
keyserver that has your key, the packet will just come back.
All that said, yes, GPG has no way to delete designated revoker
packets.  The only way to do it is export your public key and run
'gpgsplit' on it.  Then delete the packet you want to get rid of and
'cat' the packets back together.

@_date: 2007-03-22 18:54:53
@_author: David Shaw 
@_subject: why gpg use SHA1 instead of pref??? 
The MDC is always SHA-1.  It is fixed as part of the protocol.
The type of public-key encryption is defined by what type of key you
are encrypting to.  An RSA key means RSA encryption.  The symmetric
ciphers are not relevant to this question.

@_date: 2007-03-27 23:25:58
@_author: David Shaw 
@_subject: Signature version line not protected against alteration 
The "comment" and "version" armor fields are both essentially
comments, and are ignored by the OpenPGP protocol.  You can change
either of them to whatever you like.

@_date: 2007-03-31 17:51:47
@_author: David Shaw 
@_subject: Problem interoperating with PGP Univeral? 
That's just a regular signature.  How does Enigmail call GPG to do the

@_date: 2007-05-07 09:11:06
@_author: David Shaw 
@_subject: Extra key best solution for very insecure locations? 
This is certainly possible.  The catch is that I suspect you'll find
that people don't know how or aren't able to encrypt to a particular
subkey some of the time, and a different subkey the rest of the time.
GnuPG does, but not all OpenPGP programs have the ability to pick
which subkey to encrypt to.

@_date: 2007-05-16 15:28:24
@_author: David Shaw 
@_subject: Printing Keys and using OCR. 
I've actually done quite a bit of work on "paper escrow" systems like
this.  It tends to raise a few eyebrows, but in reality paper and ink
in a dark place has wonderful archival characteristics - better than
the usual CD-R, memory stick or (luckily not much used anymore)
One trick that can be done when paper escrowing OpenPGP keys is to
only print the part you care about.  OpenPGP secret keys are heavily
padded with non-secret data.  In fact, the secret key contains a
complete copy of the public key.  Since the public key generally
doesn't need to be escrowed (most people have many copies of it on
various keyservers, web pages, etc, etc), it would not be hard to
write a program that extracts just the secret bytes and prints that.
To reconstruct, you'd re-enter those bytes (whether by hand or via
OCR) and use them to transform your public key into a secret key.
For example, the regular DSA+Elgamal secret key I just tested comes
out to 1281 bytes.  The secret parts of that (plus some minor packet
structure) come to only 149 bytes.  It's a lot easier to enter 149
bytes correctly.

@_date: 2007-05-16 23:31:58
@_author: David Shaw 
@_subject: Printing Keys and using OCR. 
The goal with paper is not secure storage.  There are countless ways
to store something securely (not least of which makes use of GnuPG
itself).  The goal is rather a "backup of last resort".  Most of the
storage media in use today do not have particularly good long-term
(measured in years to decades) retention of data.  If and when the
CD-R and/or tape cassette and/or hard drive the secret key is stored
on becomes unusable, the paper copy can be used to restore the secret
Superencrypting the secret key and storing the passphrase doesn't
solve that problem.  If you have the passphrase but the secret key
that it encrypted was on that bad CD-R, you have nothing.

@_date: 2007-05-17 11:24:40
@_author: David Shaw 
@_subject: Printing Keys and using OCR. 
They're certainly advertised to (I've seen some pretty incredible
claims of 100 years or more), but in practice it doesn't really work
out that way.  The manufacturing of the media, the burn quality, the
burner quality, the storage, etc, all have an impact on how long an
optical disc will last.  Some tests show that you're lucky to get 10
For paper to last 100 years is not even vaguely impressive.  Paper
regularly lasts many hundreds of years even under less than optimal
Another bonus with paper is that ink on paper is readable by humans.
Not all backup methods will be readable 50 years later, even if you
have the backup, you can't easily buy a drive to read it.  I doubt
this will happen anytime soon with CD-R as there are just so many of
them out there, but the storage industry is littered with old now-dead
ways of storing data.
I doubt I'll still be alive in 100 years - my key storage requirements
fall somewhere in between optical disc longevity and paper longevity.
I use paper because knowing that the paper will outlive me, I don't
have to worry about reburning a disc every few years.

@_date: 2007-05-18 15:14:06
@_author: David Shaw 
@_subject: Printing Keys and using OCR. 
Your point does not follow.  There are many "useless" algorithms that
are still vastly stronger than the attack that most people can bring
to bear.  Let's say that I printed a DES (1970s era single DES) key on
paper.  DES is "useless" today, but unless I wanted to invest
significant money and time in key cracking (even though it would
eventually succeed), I should really keep that paper around and not
rely on DES being useless.
Even so, you snipped part of my comment in your reply.  The point is
not only that paper lasts effectively "forever", but also that optical
disc doesn't last long enough.  For many key-on-paper uses, it doesn't
matter much if paper lasts 100 years or 1000 years.  It only matters
that it lasts longer than I need it to last (e.g. will it last longer
than I will).  Optical disc doesn't last that long.

@_date: 2007-05-20 21:47:09
@_author: David Shaw 
@_subject: Printing Keys and using OCR. 
It doesn't currently exist, but I'll see what I can put together.
Something that prints out the necessary bytes with a checksum would be
useful to have.

@_date: 2007-05-31 15:09:53
@_author: David Shaw 
@_subject: Re-establish keys 
Without the secret key, you cannot decrypt.  If you no longer have it,
you're stuck.

@_date: 2007-11-01 22:11:18
@_author: David Shaw 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
I've actually been rather surprised with the number of downloads of
paperkey.  I expected it to be in the tens, but there have been
several hundred downloads.
Is secret sharing a feature that people would want in paperkey?  You'd
be able to print out a number of pages, and pick some threshold number
of pages that would be needed to reconstruct the key.
I consider paperkey as the "backup of last resort", and it occurs to
me that the ability to stash different printed backups in multiple
places is useful, in case there is fading/damage to a printout as
happened to the poor fellow who started this thread.  That said, I am
not completely convinced that it is better to use multiple
secret-shared printouts rather than just multiple copies of the same
printout.  Does anyone see a good use case (aside from the cool-trick
factor) to using secret sharing in paperkey?

@_date: 2007-11-01 23:14:09
@_author: David Shaw 
@_subject: Key safety vs Backup : History of a bad day (key-restoration 
Makes sense, especially if you are printing out the secret key with no
passphrase (as if there was a passphrase, then even multiple lost
copies shouldn't matter).  Given the "backup of last resort"
mentality, I think that printing the secret key without a passphrase
can be a real benefit, and secret sharing can make that a bit more

@_date: 2007-11-02 11:52:22
@_author: David Shaw 
@_subject: New OpenPGP standard published 
The new OpenPGP standard has been published.  It was assigned RFC
number 4880 (someone at the IETF has a sense of humor):
  In terms of GnuPG, we're almost completely compliant to it already as
GnuPG was updated as the various drafts of the standard were
discussed.  Upcoming versions of GPG will change the "--openpgp" flag
to mean the new RFC-4880.  The old behavior will be available as
"--rfc2440" (which already exists).

@_date: 2007-11-04 10:05:47
@_author: David Shaw 
@_subject: Meaning  of "sig!   N" self-signature 
There is a notation on the signature.  A notation allows the issuer of
the signature to add special instructions or general information to be
seen by whoever verifies the signature.
gpg --cert-notation "foo=bar"
This sets a notation named "foo" that contains the contents "bar".

@_date: 2007-11-04 11:53:33
@_author: David Shaw 
@_subject: Meaning  of "sig!   N" self-signature 
The rule, according to RFC-4880 is that the notation name is in the
form of an email address: your-notation-name at your-domain.example.com
or the like.  This prevents collisions among different people (since
their domain is in the notation name).
There is a process in which a given notation can be made an internet
standard, and thus not need the ' sign, but there are no such
standard notations yet.

@_date: 2007-11-05 23:27:36
@_author: David Shaw 
@_subject: UID management 
The ordering does not matter.  GPG supports selecting a user ID by hash:
gpg --with-colons --list-keys (whatever)
uid:-::::2006-08-02::A8DCEA454269C4701E724839B04AEDD404BC21EB::Foo Bar :
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
                      this is the hash value
gpg --edit-key (whatever)
uid A8DCEA454269C4701E724839B04AEDD404BC21EB

@_date: 2007-11-06 00:29:54
@_author: David Shaw 
@_subject: converting between detached undetached signatures? 
gpg -z0 --store the-original-file
cat the-detached-sig.sig the-original-file.gpg > my-new-joined-file.gpg
Note that if the signature is a text-mode signature, you need to add
--textmode to the --store command.
Use gpgsplit to break the file up into packets.  Note that you might
need to use 'gpgsplit --uncompress' if the original file was
compressed, and then run gpgsplit again on the uncompressed file.
Find the file that ends in ".sig".  That's the detached signature.
There are a few very obscure cases where you can't do these two
tricks.  If you have a textmode signature, and the original document
has whitespace at the end of the line, and your other user is using
PGP (not GPG) then you might have a problem.  Incidentally, this is
one of the things that RFC-4880 resolved.

@_date: 2007-11-06 16:23:50
@_author: David Shaw 
@_subject: New OpenPGP standard published 
Drat.  I did submit this, but it seems to have been accidentally left
out when the document was published.
I'll file it as an errata.  Sorry about all that.

@_date: 2007-11-06 17:43:11
@_author: David Shaw 
@_subject: PGP encryption: block or stream cipher? 
Short answer, it's historical.  There has just never been a strong
reason to change it.

@_date: 2007-11-06 22:23:40
@_author: David Shaw 
@_subject: removing a misplaced comment in UID 
Now that the key has been sent to the servers, no, you can't remove
it.  What you can do is revoke that user ID and make a new one that
looks the way you want.  This doesn't remove the old user ID, but does
hide it so it is not seen in most cases.

@_date: 2007-11-07 11:27:13
@_author: David Shaw 
@_subject: Image viewer in gpg.conf 
photo-viewer "xloadimage %i"
If I recall, xloadimage can't take data via stdin.

@_date: 2007-11-09 16:22:00
@_author: David Shaw 
@_subject: Keyserver name command 
gpg --edit-key (the-key)
keyserver hkp://minsky.surfnet.nl
(type your passphrase)
gpg --edit-key (the-key)
keyserver none
(type your passphrase)

@_date: 2007-11-11 19:30:24
@_author: David Shaw 
@_subject: UID management 
That's not a uid hash.  That's your key id (look at the last 8
characters).  When you list keys, always use --fixed-list-mode.

@_date: 2007-11-16 16:38:18
@_author: David Shaw 
@_subject: [Announce] GnuPG release candidate 1.4.8 
If you are referring to the keyserver problems under Vista, then yes.

@_date: 2007-11-19 22:38:14
@_author: David Shaw 
@_subject: Enigmail.js errors seen on Console log 
That's not completely true.  The first part is true: the error is from
a message that claims to use one hash, but actually uses a different
one.  The error does not mean that the wrong algorithm was used for
DSA2 in GPG doesn't work that way.  --enable-dsa2 only controls
whether you are able to issue a DSA2 signature.  It does not have any
impact on whether you are able to verify someone elses DSA2 signature.
I've seen this error before - the cause back then was a PGP/MIME
signed message where the micalg field in the email header was set to
one hash, and the actual signed data was different.

@_date: 2007-11-23 10:47:13
@_author: David Shaw 
@_subject: Revoke a key - What is with the decrypted messages? 
Excellent. :)
No problem.  You can always decrypt old messages (and verify old
signatures) even if the key has been revoked.  Revoking the key only
stops new use of the key - old messages are still okay.

@_date: 2007-11-23 16:09:02
@_author: David Shaw 
@_subject: Revoke a key - What is with the decrypted messages? 
Both, really.  It's a social process in that a revocation just adds a
note to a key that says "don't use this".  It's mechanical in the
sense that all OpenPGP software respects this flag, so the user
doesn't get consulted about it.

@_date: 2007-11-29 09:50:19
@_author: David Shaw 
@_subject: Error: this may be caused by a missing self-signature 
Your key is probably missing a self-signature.
This has nothing to do with the operating system they are running.
The error is on your side, not theirs.
What OpenPGP programs are you using currently, and what program did
you use to generate your key?

@_date: 2007-11-29 11:12:32
@_author: David Shaw 
@_subject: 2 keys with same passwords and email on keyserver(but only 1 
There isn't enough information here to give a solid answer, but I
suspect that since both keys have the same user ID string, you are
encrypting to the new key, and only think you are encrypting to the
old one.  Or possibly you didn't really delete the old key.

@_date: 2007-11-29 20:05:15
@_author: David Shaw 
@_subject: SHA-224 problem 
A typo was recently discovered in the new OpenPGP RFC.  While an
errata document will be issued to take care of the RFC, there is some
impact to GPG as well.  The typo was in the encoded ASN.1 OID for
SHA-224: a number that forms part of the signature when the hash is
used with an RSA key.
I've committed a fix for this for 1.4.8, so that new RSA + SHA-224
signatures use the right constants.  I've also added some
bug-compatibility code so that 1.4.8 (and later) will be able to
verify the old, incorrect signatures.
What this means:
* If you make a RSA + SHA-224 signature with 1.4.8 or later, earlier
  versions will not be able to verify it.
* Existing RSA + SHA-224 signatures that were made with 1.4.7 or
  earlier will still be verifiable with 1.4.8 or later.
Remember that this only applies to an RSA signature made with the
SHA-224 hash.  There is no problem with any DSA signatures (whether
they use SHA-224 or not), or RSA signatures with any other hash.
Also note that this does not make the signature insecure or unsafe in
any way.  This is strictly a compatibility issue.

@_date: 2007-11-29 23:07:17
@_author: David Shaw 
@_subject: SHA-224 problem 
I should also add that GPG2 does not have this problem as it uses
libgcrypt for its crypto, and libgcrypt does not currently support
SHA-224.  The version of libgcrypt currently in development does have
this problem, but it will be fixed before it is released.

@_date: 2007-10-04 08:36:28
@_author: David Shaw 
@_subject: LDAP PGP Keyserver 
Ah, this is a problem.  What you are seeing when you request a LDAP
access is a message from the "generic" keyserver handler (using curl).
Are you built with LDAP support?  Recompile GPG with LDAP support, and
you should be in better shape.  You can tell if you have LDAP support
if there is a "gpgkeys_ldap" program.
Note, though, that if PGP can't send keys to the keyserver without
authentication, that GPG probably won't be able to either - they use
essentially the same LDAP calls.  One problem at a time, however.
Let's get you talking LDAP at all before we debug the other problem.

@_date: 2007-10-04 09:22:19
@_author: David Shaw 
@_subject: LDAP PGP Keyserver 
When you run ./configure to build GPG, what does it say about LDAP?
It would be something like this:
 checking whether LDAP via "-lldap" is present and sane... yes
If it doesn't say 'yes', then you're not building with LDAP support.
Depending on your OS, you often need to install a "devel" package for
this (so, openldap-devel or similar).

@_date: 2007-10-04 18:02:06
@_author: David Shaw 
@_subject: LDAP PGP Keyserver 
I don't know how to answer that.  It seems not to be the case.

@_date: 2007-10-07 11:15:17
@_author: David Shaw 
@_subject: which revoke? 
Just run 'gpg revoke.txt'.  It will print out what key the revoker is
for.  It doesn't actually revoke the key until you do 'gpg --import

@_date: 2007-10-21 14:30:38
@_author: David Shaw 
@_subject: Trouble with keyservers 
The problem with your key on the keyserver is that you have a primary
key that is tagged for Signing (signing data) and Certification
(signing keys), and a subkey tagged for Authentication (proving you
are you).  You don't have any key or subkey for encryption.
Or to be more accurate, you DO have a key for encryption, but the
keyserver isn't storing it.  This is a well-known keyserver bug with
the pksd keyserver software, but many sites refuse to stop running it,
despite this and other bugs.  If you use a keyerver running sks
software, you'll be fine.  I believe that pool.sks-keyservers.net has
only sks servers in its mix.

@_date: 2007-10-22 07:53:00
@_author: David Shaw 
@_subject: Trouble with keyservers 
subkeys.pgp.net is running a mix of sks and pksd.  The history of pgp
keyservers is a little messy, but essentially subkeys.pgp.net means
"won't destroy your key with multiple subkeys" and not "stores the
complete key and all subkeys".  The distinction is crucial. ;)
I suspect the reason this hasn't been a bigger problem is that most
people have only one subkey, so they never see this.
One way is to add "--keyserver-options debug" to your command when you
hit a keyserver.  GPG will print out some information, including a
line like:
  Server: sks_www/1.0.10
  Server: pks_www/0.9.6
sks is sks, and pks is pksd.

@_date: 2007-10-22 08:03:02
@_author: David Shaw 
@_subject: Separate Fingerprint for elGamal-Subkey? 
To list both primary and subkey fingerprints, just list --fingerprint
  gpg --fingerprint --fingerprint
However, you are correct that (outside of some special circumstances)
the primary key fingerprint is sufficient.  When you identify an
OpenPGP key, you are really identifying the primary key.  The user IDs
are attached to the primary.  When you sign a key for someone, you are
signing the primary and user ID.  Subkeys get their 'trust' via a
signature from the primary key, not directly.

@_date: 2007-09-01 09:16:30
@_author: David Shaw 
@_subject: Key Signing, Subkeys 
Most people poll for updates occasionally (e.g. "gpg --refresh").
There is no notification method.
Not necessarily true.  You can use a subkey for signing if you like.
In this usage, the master key is only used for signing other keys
(whether your own subkeys or other peoples keys).
No.  The trust calculations are between master keys and user IDs
(people don't sign a master key - they sign a master key and user ID).
Subkeys just go along for the ride.

@_date: 2007-09-06 10:51:00
@_author: David Shaw 
@_subject: losing meaningful whitespaces in an encrypted file 
Are you sure about that?  There is no '-f' option in GPG.
This is a mini-bug sort of thing, based on historical practice in the
OpenPGP community and two different versions of the OpenPGP.
Basically, OpenPGP specifies both binary and text transports.  Binary
is just that - a binary image of the file, with no changes.  Text is
canonical text, and there are rules for the canonicalization (change
line endings to CRLF, etc).
When the OpenPGP spec was written, a piece of 'incorrect' language
crept in: that whitespace at the end of a line would not be included
in canonical text.  PGP already worked fine and never changed their
code to match the language in the spec.  GPG came along later and
followed the spec exactly.  For various reasons, this mismatch in
canonicalization wasn't really a problem in practice, but
nevertheless, in the process of writing the updated OpenPGP spec
(which is with the RFC editor now, so it'll be out soon), this was
resolved.  The new canonicalization rule is the historical one: change
line endings, and do nothing to trailing whitespace.
It is hard for me to give you exact advice on what to do from here
without a few piece of information:
1) What version of GPG are you using?  (gpg --version)
2) The command line you are using (I'm fairly sure the one above is
   not correct, as GPG has no '-f' option).

@_date: 2007-09-10 20:55:12
@_author: David Shaw 
@_subject: losing meaningful whitespaces in an encrypted file 
Again, this is not a bug, but a documented part of the protocol.
There are ways around it, and the details on this will be changing in
the future, but at least for today, if you send files as text, you
will lose end-of-line whitespace.

@_date: 2007-09-21 22:36:50
@_author: David Shaw 
@_subject: Printing Keys and using OCR (was: Proofreadable base64) 
Indeed.  I'm very glad the thread woke up again, though, as it
reminded me that I had written some code for this back in May, but
unfortunately let it get buried under other work.  I've tidied things
a bit and packaged it at It implements a secrets-only backup via paper (or bar code, or
whatever you like), and then allows you to rebuild the original secret
key when you like.
README file is attached.

@_date: 2007-09-28 17:12:23
@_author: David Shaw 
@_subject: feature request 
============================== START ==============================
This is a bad, or at least unnecessary feature.  If GPG is strong,
there is no benefit in playing games with the file format to make it
look like something else.  If GPG is not strong, you shouldn't be
using it in the first place.

@_date: 2008-04-01 13:12:23
@_author: David Shaw 
@_subject: Whirlpool Hash 
Not that I know of.  Note that Whirlpool is not specified for OpenPGP,
so that is a major barrier.
There is a project to add Whirlpool to OpenPGP going on at the moment
(also the Camellia cipher, by the way).  When that happens, Whirlpool
makes more sense than it does now.

@_date: 2008-04-02 10:24:43
@_author: David Shaw 
@_subject: 1.4.7 <-> 1.4.8 compatibility 
No problems that have been reported.  Note that we're up to version  1.4.9 now though.

@_date: 2008-04-04 09:03:16
@_author: David Shaw 
@_subject: re GPG 2.0 
Yes.  The flaw is not trivially exploitable, but there is always a  Very usable.  GPG follows the OpenPGP standard, so any version of GPG  should be able to handle any OpenPGP key.

@_date: 2008-04-04 11:45:03
@_author: David Shaw 
@_subject: sign a public key ? 
You have several options here.
If you know that the key is valid (say, if you met Stefan), then you
can sign the key which tells the system that you know it is the right
key.  This will prevent GPG from asking you about it.
  gpg --sign-key Stefan     (sign publically - signature can be
      		 	     exported for others to use)
  gpg --lsign-key Stefan    (sign locally - signature is local to you)
Alternately, you can tell GPG to not ask the question at all.  This is
less good, but is still appropriate for certain uses where you know
the key is the right one.
  gpg --trust-model always

@_date: 2008-04-07 09:28:30
@_author: David Shaw 
@_subject: Encrypt files using my secret key 
Not exactly.  What you are looking for is a "signature".  Signatures  are made using your secret key, and can be verified by your public  key, and it does show that it came from you (or at least, that it came  from your key).
However, signatures do not encrypt the data, so you get authenticity,  but not confidentiality.  If you want to encrypt also, you must  encrypt on top of the signature.  GPG can do this with "--sign --

@_date: 2008-04-08 13:22:12
@_author: David Shaw 
@_subject: Invalid cross certification? 
This should work.  I believe the code is identical around backsigs.
It seems that there is a valid 0x19 signature already, as 1.4.9 does
not give you a warning.  Still, if you do --edit-key and then
"cross-certify", you can add a backsig to any key you like.
Looking at your signing subkey 8D02BBB3, I do see a valid backsig on
Ah, I suspect this is the reason:
        subpkt 32 len 86 (signature: v4, class 0x19, algo 17, digest
Digest algo 11 is SHA-224, which is fairly recent.  I believe it was
added to libgcrypt somewhere in the 1.3.x development.  Does your
libgcrypt have it?

@_date: 2008-04-09 08:53:43
@_author: David Shaw 
@_subject: Invalid cross certification? 
I'm trying to persuade myself that doing nothing is the right answer :)
I rather like the FAQ idea, so we could print the notice on any failed  SHA-224 verification?  We might want to do that in 1.4.x as well,  actually (with a reminder that we won't be fixing the signatures in  the background forever).  That way we could encourage people to fix  the signatures as soon as possible.
I need to check the backsig issuing code in keyedit.c to see how users  can reissue backsigs.  It shouldn't be too bad: backsigs live on the  unhashed part of the signature.  Maybe --expert could allow the  backsig to be reissued.

@_date: 2008-04-11 16:17:27
@_author: David Shaw 
@_subject: Need Help 
The recent bug only applies to 1.4.8 and 2.0.8.  It does not apply to
1.4.7 or any earlier version.  There is no need to backport any

@_date: 2008-04-11 16:32:50
@_author: David Shaw 
@_subject: Re-attaching a signature 
The OpenPGP protocol allows for this, but there are no tools that can
currently do it.  What you need is a change in GPG to unwrap only one
layer of a layered object.  Signed and encrypted data is layered with
the data on the inside, then the signature around that, then the
encryption around that.
It's actually on my list of interesting things to do someday, but
doesn't exist today.

@_date: 2008-04-14 13:41:30
@_author: David Shaw 
@_subject: Miscellaneous questions 
Not a bug.  It's there to protect people from making poor UIDs.  you
can turn off the check with --allow-freeform-uid.
GPG allows this.  Add "--expert" to your command line when you want to
re-sign the UID, and GPG will allow you to do what you want.
Mind you, while GPG can do it, I don't think what you are doing is a
good idea: OpenPGP itself uses SHA1 in a number of places.  These are
not changeable, so even if you purge SHA1 from your key, note that
you're still using SHA1.  Also, SHA512 is not widely implemented yet.
You can very easily render your key not usable by a large percentage
of the population if you pick a hash they don't have.
Modify the source.
Modify the source.
You can do this with "setpref" but there is no point.  GPG is just a
computer program and doesn't care about making statements.  If you
take 3DES, SHA1 and Uncompressed out, any program that sees your key
will just internally put them back in again as required by 4880.

@_date: 2008-04-14 17:55:43
@_author: David Shaw 
@_subject: How trust works in gpg... 
Yes.  It's fairly common to say "I signed a key", but in reality,
you're signing a UID on a key.  Thus, the UID that you signed is
marked as valid, but the UID you didn't sign isn't.  If you want that
UID to be valid as well, you need to sign it too.

@_date: 2008-04-15 12:39:07
@_author: David Shaw 
@_subject: How trust works in gpg... 
You are correct.  You should not sign his key until you check his
identity.  Signing his key is making a statement that you confirm his
identity, and in the example above you cannot make such a statement.

@_date: 2008-04-15 13:32:17
@_author: David Shaw 
@_subject: How trust works in gpg... 
It does not.  When you sign a key, you make that key *valid*, which
just means "I believe this key does belong to the person it claims to
belong to".  When you set *trust* (aka "ownertrust") on that key, you
are saying "I believe the person who owns this key makes signatures
that I am willing to rely on".

@_date: 2008-04-15 13:37:52
@_author: David Shaw 
@_subject: How trust works in gpg... 
Because of the word "supposedly" in your question above :) You don't
really *know* that UID2 refers to the same real-world person as UID1
without checking.
Now, if UID1 is "David Shaw", and UID2 is "Dave Shaw" (and the email
address is the same for both), you can probably sign UID2 without too
much worry.  But if UID1 is "John Smith " and UID2
is "Bill Smith ", you need to ask some questions
before signing UID2.

@_date: 2008-04-15 13:45:33
@_author: David Shaw 
@_subject: How trust works in gpg... 
That's not how signing works.  You don't sign a UID with a UID.  You
sign a UID with a key.
KEY = The primary key.  It can issue signatures.
UID = A name
SIG = A signature that is made on the combination of KEY+UID.
SELFSIG = Same as SIG, bit issued yourself (i.e. by KEY).
When you make a key, you end up with (leaving out subkeys for now):
  KEY + UID + SELFSIG
If someone wants to sign your key, you then end up with:
  KEY + UID + SELFSIG + SIG
So SELFSIG is you saying "I bind this KEY and UID together", and SIG
is the other person saying "Me too".
If you add another UID at this point, you have:
  KEY + UID + SELFSIG + SIG + UID + SELFSIG
Now, note that the other person hasn't made any statement about
whether the second UID is valid.  YOU have, but then, it's your key:
you can make any statement you like.  It only becomes believable when
someone else adds their "me too".

@_date: 2008-04-15 14:04:26
@_author: David Shaw 
@_subject: How trust works in gpg... 
Not enough information above to say nonsense or not.  There are silly
ways to use challenges and non-silly ways.
The idea behind a challenge is to send something to the email address
in the UID and ask the recipient to sign it, and send it back.
Encryption is not involved here (you can encrypt it if you like, but
it doesn't make a difference either way).  You are verifying that the
email address on the key goes to some entity that has the ability to
actually use the key.

@_date: 2008-04-15 14:09:02
@_author: David Shaw 
@_subject: How trust works in gpg... 
Not at all (though it is true that the S in Harry Truman's name isn't
an abbreviation).
When you sign a UID, you're signing what is there, and not making any
statement beyond what is there.  You don't need to insist they spell
out all of their names.

@_date: 2008-04-15 16:41:21
@_author: David Shaw 
@_subject: How trust works in gpg... 
It is irrelevant to this.  There are a lot of "David Shaw"s in the
world, and it's pointless to try and prevent collisions in a set that
large.  The disambiguation in OpenPGP keys is really the email
address, not the name.

@_date: 2008-04-15 16:43:37
@_author: David Shaw 
@_subject: How trust works in gpg... 
Yes indeed.  OpenPGP even expects users to change their SELFSIGs
occasionally - the preferences and other UID-specific information is
stored there, so a change to preferences means a change in SELFSIG.

@_date: 2008-04-15 17:09:42
@_author: David Shaw 
@_subject: How trust works in gpg... 
Change your preferences and GPG will make a new selfsig for you.  No
source hacking needed.

@_date: 2008-04-15 17:54:15
@_author: David Shaw 
@_subject: Miscellaneous questions 
There are a lot of things that fall into the category of "legal by the
standard, but not good in the real world".  A zero-length UID is one
of them.  GPG handles this the way it handles most such things - it
will accept such a key from the outside world, but will not generate
it itself.
Not exactly.  It contains what the user prefers **among the algorithms
that his implementation supports**.  It's the intersection of the
algorithms the user prefers for one reason or another and the
algorithms that his implementation supports.
It will work.  It's foolish and you'll hurt yourself doing it, but it
will work.
This is another thing that GPG will accept from the outside, but not
generate itself.
Like Robert said, the RFC requires them to be either present, or if
they are not present, the implementation must act as if they were
Section 13.2:
   Since TripleDES is the MUST-implement algorithm, if it is not
   explicitly in the list, it is tacitly at the end.  However, it is
   good form to place it there explicitly.  Note also that if an
   implementation does not implement the preference, then it is
   implicitly a TripleDES-only implementation.
"...it is good form to place it there explicitly..."
Feel free to change your preferences to not have it there if it makes
you happier.  Any program that reads your key will act as if it was
there anyway.
No, you can't.  If you only include AES256, your preference list is
effectively "AES256, 3DES".  You can't get rid of the 3DES.
In the example above, you may end up with either 3DES or AES256.  The
spec requires that it is one of the two - it does not require a
particular one to be chosen.  That's why GPG has the
personal-cipher-preference option, where users can set what they like
in ranked order.  OpenPGP puts most of the power in the hands of the
sender, so the sender decides which algorithm to pick from the list.

@_date: 2008-04-15 18:04:15
@_author: David Shaw 
@_subject: Miscellaneous questions 
It will work with GPG.  I can't speak for other programs, but it's
legal by the spec, so it should work everywhere.
Mind you, you're going to hurt yourself, but it's legal by the spec.
No, if he wants to do a downgrade attack, he can just strip off your
revocation packet and the new selfsig packet and use the old selfsig.
Revoking it doesn't make it vanish.
Most likely not until we tackle V5 keys.  Current keys are V4.
I'm not insulted.  Being conservative with crypto is a compliment.
See sign.c:make_keysig_packet(), and the functions that it calls

@_date: 2008-04-15 18:29:44
@_author: David Shaw 
@_subject: Miscellaneous questions 
This is a very real issue.  The problem is that GPG tries to support a
very wide swath of users.  Some want lots of ciphers, some don't care.
Some want photo IDs, some don't care.  Different keyserver types,
different trust models, etc, etc.  Then there is the third group of
people, who not only don't want feature X, they don't even want it in
the binary.
We can't make all three groups happy with one program.  At best, we
can do the first two.
There is an - admittedly limited - attempt at making the third group
happy built in to the code, however.  If you build GPG from source,
you can tell autoconf to simply leave out chunks of code you don't
want.  For example, you can do "--disable-XXXXX" where XXXXX can be
things like "AES" or "RSA", or even things like keyservers.  Do a
"./configure --help" for the complete list.
See also "./configure --enable-minimal" which turns off (almost)
everything that isn't required for OpenPGP compliance.  The end result
is a GPG that understands only DSA, Elgamal, 3DES, MD5, SHA1,
RIPEMD160, ZIP and ZLIB.  No keyserver support and no photo ID

@_date: 2008-04-15 18:38:12
@_author: David Shaw 
@_subject: Miscellaneous questions 
It is frequently commented on, and not just in a tongue in cheek
manner, that it is a shame that the earlier versions of PGP weren't
broken.  If the old stuff had been broken, we would have no reason to
maintain compatibility with it.

@_date: 2008-04-16 08:41:15
@_author: David Shaw 
@_subject: Miscellaneous questions 
I was pretty much getting out of this thread as non-useful, but I have
to comment on this.  It's not true.  GPG does not export
non-exportable signatures.
You can choose to configure GPG to do so, but this is not default
behavior, and does not enable you to do anything you couldn't do by
just copying the keyring around.

@_date: 2008-04-16 09:29:34
@_author: David Shaw 
@_subject: Miscellaneous questions 
I think - and please understand I do not mean this as an attack on you  - that before someone proposes sweeping changes to an RFC, they must  really understand the history and reasoning behind the original  design.  Without that understanding, the proposed changes tend to  become "I don't like this - please change it", without actual  I contributed a lot of work to 4880, over the span of years.  I found  that the more I learned, the smaller the change I proposed was.
Skipping the actual security issue for a moment and just looking at  code realities, OpenPGP and its ancestors have been around for so  long, and there is such a huge base of installed code, that this is  pretty much the only way to work with it.  It's not a blank sheet of  paper where anything goes.  This is why V5 keys are so appealing -  it's not exactly a blank sheet of paper, but it's as close as we've  had for a very long time.
I don't want to discourage you from suggesting changes, but I do  advise that you really understand what you are suggesting.  For  example, the ideas around user IDs being required to be full names  show misunderstanding of the OpenPGP trust model.  The ideas around  different parts of the user ID living in different packets (attribute  packets vs user ID packets) would break a large percentage of existing  systems.  This is fine, of course, if that breakage is balanced out by  a corresponding gain in the rest of the system, but I don't see that  corresponding gain.  Work with a scalpel, not a cutlass.

@_date: 2008-04-17 12:13:30
@_author: David Shaw 
@_subject: editing User ID 
You can't really edit user information.  The reason is that the
information is "bound" to the key with a self-signature - editing the
user ID info would cause that signature to become invalid.  This is
for reasons of self integrity, as you wouldn't want an attacker to be
able to edit your user ID information.
The way to do what you want is to add a new user ID, with the correct
information (gpg --edit-key then "adduid"), then remove the old
incorrect UID.  There are two ways to remove that:
  gpg --edit-key then "deluid".
If you haven't sent the key to anyone, then this is safe.  It deletes
the bad user ID completely and that is that.
If you have sent the key to anyone (and that includes the keyserver),
the best you can do is revoke the user ID, which tags it with a flag
to indicate it should not be used:
  gpg --edit-key then "revuid".

@_date: 2008-04-19 20:37:48
@_author: David Shaw 
@_subject: Naming of GnuPG 
Not exactly evolving on its own.  1.4.x is not about to grow S/MIME  capabilities like 2.0.x, but some changes will certainly apply to both.
Do people find the 1.4.x / 2.0.x thing confusing?

@_date: 2008-04-24 12:16:44
@_author: David Shaw 
@_subject: How trust works in gpg... 
A signing subkey doesn't really work here though.  A given signing
subkey can be attached to any number of keys, and still issue
signatures.  When a make a certification, I am signing the primary key
and a UID.  Thus the things I need to "prove" are that primary key and
that UID.  A signing subkey (or encryption) aren't really involved in

@_date: 2008-04-24 13:21:08
@_author: David Shaw 
@_subject: How trust works in gpg... 
No.  Key flags do not pertain to UIDs or roles.  They pertain only to
What you sketch out above is legal by the spec.  No program that I
know of does it that way, but it's legal.
Again, legal, but nobody does it that way.
Sure.  Say I use the same key for home and work, so I have two UIDs on
the key.  Work has a keyserver, and home uses a public keyserver.
None that I know of.
It's not up to me to say whether it makes sense or not.  Policy URIs
are for specifying the policy under which a signature was issued.  If
you want to state the policy for your self sigs, this is how you do
it.  If you don't, don't.

@_date: 2008-04-24 15:12:06
@_author: David Shaw 
@_subject: How trust works in gpg... 
You are of course free to do so.  You are not free to mandate this for
others.  You can't stand behind people and insist they follow your
definition of a "whole name".  If nothing else, it's impractical.
I do see your point, but I think the problem with your idea is that is
not how the OpenPGP trust system works.  The person who gets to decide
if a key+uid should be signed is the person who makes the signature.
Nobody else gets a say.

@_date: 2008-04-24 19:22:53
@_author: David Shaw 
@_subject: Multiple Encrypted Files in one file. 
Sorry, no.  You must split the file before passing it to GPG.

@_date: 2008-04-25 09:11:55
@_author: David Shaw 
@_subject: How trust works in gpg... 
Absolutely.  At one point there was talk about putting together an RFC  for a defined OpenPGP trust system (essentially documenting what we  have now), but there didn't seem to be much interest in it.
A significant use of OpenPGP is without the WoT at all.

@_date: 2008-04-25 12:06:42
@_author: David Shaw 
@_subject: Vandalizing keyserver UID's 
The problem is that you aren't asking GPG to check that signature,
just dump the whole key.  Note what happens when you do '--check-sigs'
instead of '--list-sigs'.  GPG won't use that user ID for anything, as
it is not certified.  In fact, GPG won't even import the unsigned UID
unless you specifically tell it to.
Current keyservers don't have crypto at all (they're pure storage) so
they never check signatures.

@_date: 2008-04-26 23:08:34
@_author: David Shaw 
@_subject: Web of Trust 
I think there is some confusion between "validity" and "trust" in the  above, so it is very difficult to understand what you are asking here.
Basically, in the 4-key universe above, A is valid (you), B is valid  (you signed it), C is valid (B signed it, B is valid, and has full  ownertrust).  D is not valid because even though C signed it, C has no  I'm not sure what you are trying to get at with   It doesn't seem  to follow the problem statement of the 4-key universe.  If there are  other keys in play here with other signatures, then you need to state  them in the problem.

@_date: 2008-04-27 08:59:58
@_author: David Shaw 
@_subject: Web of Trust 
Yes.  That's how the "classic" trust model works.  The logic behind it  is that you must know if C is making *good* signatures and not just  signing anything that comes along without checking.  If you don't know  that, you can't really use C's signatures safely.
That is called a trust signature, and it's part of the "PGP" trust  model in GPG.  You can make them with "tsign" instead of "sign" in the  --edit-key menu.  They look like regular signatures except they have  the ownertrust level built-in to the signature along with some ways to  restrict the flows of that trust (hop counts and domain regular  expressions).  Trust signatures work more or less as you describe  above.  However, note that they are not really used very much outside  of corporate (very hierarchical) environments.  In the example above,  if B made a trust signature on C at the marginal level, you'd get what  you describe: A (you), B (valid + full trust), C (valid + marginal

@_date: 2008-04-28 14:21:39
@_author: David Shaw 
@_subject: dearmor in GPGME 
Also note that the CRC is optional in OpenPGP.  It's not even always

@_date: 2008-07-31 22:17:23
@_author: David Shaw 
@_subject: batch create DSA2 
Sort of.  There is no real distinction between DSA and DSA2.  There is  just DSA.  However, the hashes that you can use with the key are  dependent on the key length.  It breaks down like this:
length over 2048  ===  256 bit hash
length between 1025 and 2048 === 224 bit hash
length between 0 and 1024 === 160 bit hash
A 1024 bit DSA key can only use 160-bit hashes.  You can use whatever  hash you like (even the huge SHA512), but you're only going to get 160  bits worth of it.

@_date: 2008-08-05 08:37:03
@_author: David Shaw 
@_subject: good practices when using gpg --symmetric? 
No significant difference.  There is a minor difference in practice in  that multiple small files allow you to use a different passphrase on  each, but remembering 10,000 passphrases is non-trivial in itself.
Good crypto systems can give the attacker a known file format and are  still secure.
Not really, but I wonder why you're using --symmetric rather than the  regular public-key mode.  There is no significant difference in  security, but it might be more convenient for you if you have many

@_date: 2008-08-11 08:29:03
@_author: David Shaw 
@_subject: Remove a Key From a Key Server? by David Ross 
I'm afraid it doesn't.  There is no way to revoke any key where you  don't have the secret part (if you think about it, the ability to do  this would imply a break of OpenPGP signatures).
There used to be a popular trick where people would add extra user IDs  to a key.  Keyservers might show them, but, again, without the secret  part, those extra user IDs can't be signed and modern OpenPGP programs  will simply ignore them once the key is imported.
I'm afraid I can't see any way the method on that web page would  work.  In fact, it's worse than just doing nothing, as the end result  is a valid signature from the active key on the dead key.  I think the  intent is that you have a signature on the dead key that reads "Do not  use", but the steps given on that web page do not actually accomplish

@_date: 2008-08-12 10:18:41
@_author: David Shaw 
@_subject: transfer private key data between applications 
You could probably work through this and get it to work, but it's not  going to be easy.  For one, OpenPGP uses a somewhat strange cipher  mode (a variant on CFB).  You'd also have to deal with the OpenPGP  encoding on the packets.
Rather than do all that, take a look at    They have a Java library that can do OpenPGP directly.

@_date: 2008-08-16 08:24:45
@_author: David Shaw 
@_subject: revocation certificate command 
No problem.  So long as you have the secret key, you can generate a  revocation certificate whenever you like.  The common advice to  generate the revocation certificate right after you generate the key  is because people sometimes lose their secret key and are then unable  to revoke it.  If you generate the revocation certificate ahead of  time and store it somewhere safe, then you can always revoke the key  if you need to.
Anyway, the command syntax you're looking for is:
   gpg --gen-revoke (name)
Where (name) is a user ID on the key you are making a revocation  certificate for.  Once you do this, GPG will print out a certificate.   Save this somewhere safe, and you're all set.

@_date: 2008-08-18 19:11:06
@_author: David Shaw 
@_subject: SAS 70 Certification 
No.  SAS 70 is really more of an overall process audit statement.   GnuPG is a program that can fit into such a process, of course, but  it's not really a process itself.
(For the curious:

@_date: 2008-08-18 20:00:09
@_author: David Shaw 
@_subject: import and export with different gpg versions 
If I remember correctly, this error message is a bug that was fixed  sometime after 1.2.4.  The error message should be "no ultimately  trusted key found"  The particular key ID given is not correct.
The error just means that you don't have an ultimately trusted key,  and so cannot generate a trust database.  I expect the key you just  imported is the one you intend to use, so just make that your  ultimately trusted key.  On the 1.2.4 side:
  gpg --edit-key (your key id that you just imported)
  trust
   (set the key to "ultimate")
  save
Then you should be able to build your trust database.

@_date: 2008-08-19 20:32:08
@_author: David Shaw 
@_subject: Securely delete files... 
PGP has a secure delete feature, yes.
However, as you are asking this question of the GnuPG list, I suspect  you mean to ask about GnuPG.  GnuPG does not have a secure delete

@_date: 2008-08-20 09:58:02
@_author: David Shaw 
@_subject: Securely delete files... 
Note, though, the postscript that Gutmann added on to his paper in  later years:
The operative phrase here is "A good scrubbing with random data will  do about as well as can be expected".  The world of hard drives has  evolved since 1996, and unless you're pulling your hard drives from  10-15 year old machines, the only relevant parts of the 35-pass  Gutmann methodology are going to be the random ones.

@_date: 2008-08-20 09:59:05
@_author: David Shaw 
@_subject: Securely delete files... 
There is some debate on whether a well-funded adversary can recover a  useful amount of data (say enough to reconstruct a fragment of a file)  from a disk that has been overwritten multiple times.  It's an  interesting debate, but for many situations the question is somewhat  moot.  Hard drive prices are so low these days that if the drive  contains sensitive material that should not be exposed "no matter  what", just destroy the drive.  If you're designing a system that  requires that level of security, then the price of a new hard drive  now and then is included.
For what it's worth, the US government recently changed their  regulations on what qualifies for "clearing" (basically removal that  can foil an undelete function or games with 'dd' and 'grep') and  "sanitizing" (removal that can foil a laboratory).  The notable  difference is that in the new regulations, you cannot use any  overwrite method to sanitize a disk.  The only way to sanitize is to  degauss the drive or physically destroy the thing.

@_date: 2008-08-21 14:38:07
@_author: David Shaw 
@_subject: Securely delete files... 
I more or less agree with this, except I'd add the qualifier that it's  the only realistic way to completely scrub data with a perfect (or  close enough to perfect such that any difference is irrelevant)  guarantee of success.  Basically I'm adding a "perfect" and a  "guarantee".  There are other ways to scrub data, and whether they are  effective in practice depends on who the adversary is.   An adversary  who can merely download and run an undelete program is very different  from an adversary with an entire computer forensics laboratory (and  budget to match), and there are more people with undelete programs out  there then there are forensics labs.
I can't speak for the dozen or more shred programs that can be  downloaded from the net.  (I'm sure many of them are garbage - the  trick is knowing which ones).  For many adversaries, a good shred  program is effective.  Just because it isn't effective against all  adversaries, doesn't mean that it isn't effective against some.
All that said, I don't really use disk or file shredding software.   When I buy a drive, I use it until it dies and then I destroy it.   Disks are cheap and last for years.  Plus, shredding a multi-hundred- gigabyte disk can take days and hitting a drive with a hammer takes  minutes.  Plus again, given that I use the drive until it dies, it may  not even be possible to shred.

@_date: 2008-08-21 23:12:05
@_author: David Shaw 
@_subject: Securely delete files... 
That's exactly the problem - given modern disks, and modern  filesystems, there is not a perfect guarantee that you'll hit the same  disk blocks that the original file landed on.  The disk could  invisibly remap a block out from under you at any time (it does this  automatically when the disk firmware detects a bad block), the  filesystem could be doing journaling games, etc, etc.  A program  running on the computer the disk is attached to can't really do much  about disk block remapping since it doesn't see this.  It always asks  for (for example) block 100.  If the file was written when block 100  pointed to block 100, but by the time the overwrite happens, block 100  has become 12345, then the computer doesn't know it needs to overwrite  both 100 and 12345 to get all traces of the file.
Let's simplify things this way: you have regular people and forensics  lab people.  You have single file shredding, and whole-disk  shredding.  Regular people only have access to the disk that a  computer can have.  That is, they are reading the disk using the disk  interface.  Forensics labs can do things like remove the platters and  go for the electron microscopes.  Single file shredding is just that -  you pick a particular file on the disk and shred it.  Other files are  not affected.  Whole-disk shredding shreds the whole disk at a block  level, and the entire contents of the disk are lost.  The disk would  need a reformat / re-mkfs before using it again.  This is a  simplification, of course, but it's a reasonable one.
We've discussed forensics lab stuff elsewhere in this thread, so I'll  skip it here.  That leaves only two cases:
Regular people + single file shred: This may or may not be safe  depending on whether the filesystem you are using overwrites in place  or not.  Many modern filesystems (Reiser, XFS) do not necessarily  overwrite in place.  More primitive filesystems (like the FAT FS that  is used on many external disks) do overwrite in place.  Linux systems  most commonly use ext3, and that may or may not overwrite in place,  depending on how it is configured.  Then there is the fact that many  programs create temp files here and there which wouldn't get  shredded.  On top of that there is the fact that many programs save  files in ways that can defeat shredding.  Bottom line: it can be safe,  but you have to really know details of your OS and what programs  generate the files you want to shred.  In practice, it's a little iffy.
Regular people + whole disk: This is pretty safe.  The disk might be  doing magic underneath you, but given that the attacker is only able  to read the disk via the disk interface itself, the magic is not  visible (or rather, it is equally visible or invisible to both you and  your attacker).  Any temp files are blown away just like everything  else is.
Bottom line is, yes, you can protect yourself from your roommate with  shredding (assuming your roommate doesn't work for a computer  forensics lab).  Of course, you'd better make sure your shred program  is a good one.  I've seen some pretty silly bugs that make some of  them not actually protect you particularly well...

@_date: 2008-08-22 10:45:25
@_author: David Shaw 
@_subject: Securely delete files... 
Exactly right.  Shredding a whole disk is like using a hammer.   Shredding a single file involves a scalpel.  It's a lot harder - not  impossible, but harder - to use a scalpel.

@_date: 2008-08-22 17:29:40
@_author: David Shaw 
@_subject: Securely delete files... 
OS X is an interesting case.  The standard filesystem, as you note, is  HFS+ with journaling.  Usually this is a danger sign for shredding as  the shred process doesn't know all the information it needs to do a  proper shredding job.  However, Apple has shredding built-in to OSX,  and since both the shredder and the filesystem come from the same  people, it's at least possible that they did the necessary work to  have this shred properly (i.e. in a journal-sensitive way).  Did they  actually do this?  I have no idea, and would be curious to hear from  someone who does have a reference on this one way or the other.  Apple  tends to be fairly stingy about this level of detail.

@_date: 2008-08-28 12:44:46
@_author: David Shaw 
@_subject: Can I Encrypt Using an entire keyring instead of listing each key? 
No, you can't.  To include an entire keyring, you need to list each
key in that ring explicitly.

@_date: 2008-08-29 10:59:45
@_author: David Shaw 
@_subject: Installation gnupg on Windows 
This isn't quite right - I haven't been very involved in GPG 2- specific stuff (S/MIME, the assuan stuff, etc).  I've been very  involved in GPG in general, of course, but my work with OpenPGP tends  to apply to both 1 and 2.  GPG 1 scratches my particular itch, so I  usually run that rather than the larger GPG 2.

@_date: 2008-08-29 13:15:18
@_author: David Shaw 
@_subject: Automate decryption 
In general, yes, there are many ways to do it.   The details depend on  what the goal is.  Is this a server doing the work (i.e. no human  present), or do you just want to cache the passphrase so you don't  have to retype it frequently?  Or... ?
Also, to give you the best information, can you tell me if you are  using GnuPG 1.4 or GnuPG 2.0, as well as what platform (Linux, OSX,  Windows, etc) you are running on.

@_date: 2008-08-29 22:18:58
@_author: David Shaw 
@_subject: Automate decryption 
That makes things difficult.  You basically have two choices: One,  store your passphrase on disk (or just use no passphrase at all).   Two, have something that prompts for your passphrase at boot time and  caches it in memory for you (gpg-agent, or you can roll your own).   One has security problems if someone else can get access to the box,  Two has problems if someone can get access to the box, plus problems  if you have an unexpected reboot (power failure or crash) and a human  isn't around to type in the passphrase.
Many people solve this problem with method One, and then making sure  they lock the box down tightly.

@_date: 2008-11-30 21:04:20
@_author: David Shaw 
@_subject: Rare condition incompatibility of public key 
Incompatibility.  PGP 6.5.8 is too old for use in the modern age.   Yes, you can more or less make things work properly by persuading  everyone you communicate with to downgrade their clients, but even so  6.5.8 will occasionally pull the rug out from under you.  This is one  of those times.
No.  You need to tell your friend to upgrade.  6.5.8 predates OpenPGP,  and will thus have problems interoperating with most of the modern  clients (including PGP).

@_date: 2008-12-01 00:23:27
@_author: David Shaw 
@_subject: Rare condition incompatibility of public key 
I think that last question is irrelevant, as it follows from the  "doesn't trust versions that Phil hasn't worked on", which makes it  derived from a false premise.  It does not matter whether Phil has  worked on 7.0 and later, or indeed any version of PGP, because Phil  being involved does not ipso facto cause PGP to be good (for whatever  value of "good" you like).  If the equation is "Phil involved == good  PGP", and "Phil not involved == bad PGP" then the battle for making  intelligent decisions about PGP has been lost from the start.  Phil is  a good guy, and he did start something huge, but his involvement is  not magic pixie dust that causes crypto goodness to spring into being.
I think it does as well.  Once upon a time, I spent a lot of hours  coding various workarounds in GnuPG for old versions of PGP.  This is  where the --pgp2, --pgp6, --pgp7, etc, flags in GnuPG came from.  Now,  years later, I sometimes wonder if I made a mistake.  Perhaps it would  have been wiser to bite the bullet and let these things break.

@_date: 2008-12-01 01:23:11
@_author: David Shaw 
@_subject: Rare condition incompatibility of public key 
I strongly disagree.  Explaining to them that PRZ was present for  other versions of PGP feeds their "grossly misinformed" world view.   It's not a "small dose" of reality: it's an irrelevant (despite being  factual) statement that just corroborates their misunderstanding.   This leaves them with the belief that their understanding was correct  all along, and thus makes the situation worse.   How much harder is it  to bring reality to a situation once someone has "fed" the  I've had my share of conversations with the PGP True Believers over  the past 10 years.  After much painful experience, the method that has  always worked best for me is to state:
1) This is reality.  Full stop.
2) I will help you understand why this is true if you want me to (but  if you aren't interested, that's fine too).
3) If you keep doing what you're doing, you're going to break  something.   Usually this only hurts you, but sometimes you can hurt  people other than yourself.
4) Keep this up long enough, and you will isolate yourself.  Nobody  will be able to communicate with you reliably.  That tends to resolve  statement

@_date: 2008-12-01 10:25:36
@_author: David Shaw 
@_subject: Teaching crypto to newbies (was: incompat.) 
Did your teacher begin by saying "This is fact.  This is true."  Then  much later, "Actually... this wasn't true.  Please un-learn things  now."   Or did he say "This isn't actually fact, but it's a good  enough assumption for today.  You don't yet have enough knowledge to  really understand, but pretending this is true for now simplifies the  learning process.  Pretty soon you'll understand more, and you'll even  understand why the assumption we are making today is a useful one." ?
For me, it was the latter.  A teacher who lies, even with the best of  intention, loses his students.  The poor student never knows if he is  being told the truth or not.
Suits me.  The person who needs education regarding the (thankfully  dying out) belief that no version of PGP past (insert version here)  should be used isn't even on this list.
In an effort to drag this back to OpenPGP relevance, a sum-up for the  * No, it is not true that PGP 2.6 or 6.5.8 or some other version is  the "last good" version.
* Some variants of this belief involve Phil Zimmermann being present  for those versions but not others.  Mr. Zimmermann is a nice guy, and  very devoted to PGP, but his presence does not automatically mean the  version of PGP is secure, and similarly his absence does not  automatically mean the version of PGP is suspect.  Read his own words  on this belief: * You can, of course, keep using whatever version of PGP you like.   Nobody can force you to do anything.  However, understand that these  early versions predate the OpenPGP standard (first published in 1998,  and later updated in 2007).  Because of this, they generally don't  interoperate perfectly with true OpenPGP clients.  In other words, you  make it difficult for people to communicate with you securely.  Since  you're using PGP, we can assume that your intent was to communicate  securely, so making it harder to do so is, shall we say, less than  optimal.  This situation is getting steadily (though slowly) worse as  crypto technology evolves.
* There are many people on this list who would be happy to help you  understand any of these points.

@_date: 2008-12-01 17:01:47
@_author: David Shaw 
@_subject: Rare condition incompatibility of public key 
It is stored on the key (in one of the self-signatures of the key, to
be precise).  The problem is that pgp 6.5.8 doesn't handle expiration
properly, so it is not understanding that your key (having two
expiration dates, the original one and the new one) was un-expired.

@_date: 2008-12-02 13:32:31
@_author: David Shaw 
@_subject: Rare condition incompatibility of public key 
It probably would help, yes, since that removes the older selfsig that
contains the expiration.  It doesn't really solve the problem though -
as soon as the 6.5.8 person updates keys, the problem selfsig will
come back again.
They could keep a copy of GPG around to clean keys for 6.5.8, but then
it does raise the question why they don't just use the GPG that is
sitting there...
This is a perfect example of why 6.5.8 is bad: it more or less can be
made to work, but requires special steps to be taken which raises the
difficulty level of using PGP.  It removes the "it just works" and
replaces it with "it sort of works, but you have to ask lots of
questions on mailing lists and hit Google regularly".  That turns
people off from using PGP.
One of the great things that I think that the PGP company did in their
new system is spend a lot of effort to make it "just work".  I like
the idea behind GPGrelay (
for the same reason.  I don't use it - it's not targeted at me - but
the idea is a nice one.

@_date: 2008-12-02 16:28:54
@_author: David Shaw 
@_subject: Keyserver mangling (was: Rare condition incompatibility of public key) 
Yes, this is a headache in the common keyserver design.  It is just a
aesthetic problem, really, but when you have old code like 6.5.8 that
doesn't handle keys properly, then the aesthetic problem becomes an
operational problem.
The funny thing about the Global Directory is that it solves the
problem on the one hand (as it only puts into the keyserver what you
send it, and thus you can delete any old signatures you like), but
makes the problem worse on the other (as it adds its own signatures
A nice way to handle this is to use the "preferred keyserver"
functionality in GnuPG to tag your key with the place you like to
store it.  This doesn't deal with the initial problem of locating a
key, but once located, it will make sure that your key is refreshed
from a place that you choose.

@_date: 2008-12-03 00:10:20
@_author: David Shaw 
@_subject: Storing of PGP keys in OpenLDAP 
Unfortunately, it's not really possible.  The Distinguished Name needs  to be unique in LDAP, and a pgpUserID is not guaranteed to be unique  (say, a single person who happens to have two keys).  There can also  be a single key with multiple pgpUserIDs on it, so it is not clear  which user ID should be in the DN.
Currently, we use the pgpCertID (the 64-bit "long" key ID) to help  ensure that the Distinguished Name is unique.  You'll have a 64-bit  collision eventually if you keep trying, but this is at least as good  as OpenPGP itself (which also relies on the 64-bit key ID being very  close to unique).
Incidentally, for those people who store keys in LDAP servers - Jon  Callas told me recently that the Hushmail system now follows the "ldap://keys.example.com " method for finding keys via LDAP.  This means that if you make your  LDAP server visible to the net at large, PGP, GPG, and now Hushmail  can automatically find keys for people in your domain.  The feature is  on by default in PGP Universal and Hushmail.  For GPG, stick a "auto- key-locate ldap" in your gpg.conf to turn it on.  If you are  encrypting to (for example) person at example.com, and GPG does not have  a key for that user, it will try to retrieve it from ldap://keys.example.com

@_date: 2008-12-03 12:42:20
@_author: David Shaw 
@_subject: GnuPG 2.0,9 - Error when trying to compile in Linux. 
You're missing the development files for zlib.  Most distros break
libraries into two main pieces: the library itself, and the
information needed to compile programs using that library.  This lets
people who aren't compiling stuff not install the second package.
I don't know offhand what Ubuntu calls it, but look for a package
called something like "zlib-dev" or "zlib-devel".

@_date: 2008-12-05 16:38:13
@_author: David Shaw 
@_subject: gpg 1.4.9 (Unix) textmode file size limit 
--textmode turns on the RFC-4880 text processing which canonicalizes
line endings.  When it is enabled, all local line endings are
converted to CRLF pairs when encrypting, and similarly converted from
CRLF to local when decrypting.  Note that "local" is different
depending on what your local platform is.  Unix-ish machines tend to
use LF as their line ending.  Windows uses CRLF.  Other platforms may
use a bare CR, or a null or whatever they like.
So, let's say that you have a Unix-ish text file (so LF line endings).
You encrypt it using --textmode, so the encrypted file contains CRLF.
You then decrypt it using --textmode on a Unix box, so the line
endings are transformed back to LF.  If you had decrypted it on a
Windows box, the line endings would be CRLF.  An obvious side effect
of --textmode is that you may not get out exactly what the sender put
in (as the line endings may have been changed).
Aside from the 19995 characters per line limit, there aren't any other
limitations you need to know about.  In general, unless you're moving
text files, you don't need --textmode.

@_date: 2008-12-11 14:19:00
@_author: David Shaw 
@_subject: Description of why an UID is revoked 
A user ID (generally) has a self-signature that "binds" it to the key
and marks it as a real UID.  A UID revocation is just another self-sig
that tells anyone who cares that this user ID is no longer valid.  The
description line for why a UID was revoked is contained in this
revocation self-sig.
It is not usually visible - probably the easiest way to see it is via:
  gpg --export (thekey) | gpg --list-packets

@_date: 2008-12-18 10:52:44
@_author: David Shaw 
@_subject: How encrypt data/text stream instead of a file? 
GnuPG is designed to be able to accept a stream or a file.  To do a  stream instead of a file, just don't give a filename.  GnuPG will then  read data from standard input.
So, for example:
  my-pipeline-that-streams-data | gpg --encrypt | my-pipeline-that- You can freely mix streams and files as well:
  my-pipeline-that-streams-data | gpg -o output-file.gpg --encrypt
  gpg -o - --encrypt myfile | my-pipeline-that-accepts-encrypted-data
Anyway, that's how you do it on the command line.  If you want to do  it inside a program, it depends on what language you're using and how  that language deals with calling out to a command line.  In general,  though, you want to write data to the head of the GPG pipe, and read  data from the tail of the GPG pipe.  I do this frequently in C via the  usual pipe/fork/exec/dup2 method.

@_date: 2008-12-18 13:01:48
@_author: David Shaw 
@_subject: How encrypt data/text stream instead of a file? 
I don't want to do a full pipe/fork/exec/dup2 tutorial here (it's the
GnuPG list after all), but read this:
  Or try "popen" (and add some error checking):
  FILE *my_gpg_stream;
  my_gpg_stream=popen("gpg -o - -r whoever -e the-file-to-encrypt ..etc...","r");
 (now read from "my_gpg_stream" until you see EOF).
  pclose(my_gpg_stream);

@_date: 2008-12-21 16:49:19
@_author: David Shaw 
@_subject: Generating Keys by Existing 
I think what you're looking for is a "group".  When you use groups,  you define a particular name, and when you encrypt to this name, you  actually encrypt to everyone in the group.
 From the sample gpg.conf file:
# Group names may be defined like this:
#   group mynames = paige 0x12345678 joe patti
# Any time "mynames" is a recipient (-r or --recipient), it will be
# expanded to the names "paige", "joe", and "patti", and the key ID
# "0x12345678".  Note there is only one level of expansion - you
# cannot make an group that points to another group.  Note also that
# if there are spaces in the recipient name, this will appear as two
# recipients.  In these cases it is better to use the key ID.

@_date: 2008-01-31 19:20:17
@_author: David Shaw 
@_subject: more than one recipient 
Yes.  Most people encrypt to two (themselves and the intended
recipient) as a matter of course.  Just repeat -r for each one:
  gpg -r person-1 -r person-2 -r person-3 ...

@_date: 2008-02-04 09:36:00
@_author: David Shaw 
@_subject: Can you clarify when data compression is used? 
Prior.  Ciphertext doesn't compress particularly well.  Plus, there is
a minor (as in "don't rely on it, but it's nice to have") security
improvement in encrypting already-compressed data.
RFC-4880 documents this.

@_date: 2008-02-04 09:44:18
@_author: David Shaw 
@_subject: Can you clarify when data compression is used? 
It depends on what you are compressing.  BZip2 tends to do better than
zip against straight text, for example.
Current PGP handles BZip2, ZLIB, and Zip (and of course no
Even if you're communicating with a person whose program doesn't
support BZip2, it is safe to put BZip2 in your
personal-compress-preferences.  Those preferences are only used if all
parties agree, so you won't accidentally create an interoperability
problem.  This is true of all the personal-(whatever)-preferences

@_date: 2008-02-04 13:18:38
@_author: David Shaw 
@_subject: Can you clarify when data compression is used? 
DSA2 is not enabled by default.  It can be enabled with --openpgp or
--rfc4880 (or --enable-dsa2 of course).
There isn't a straightforward answer.  Basically, there is a list of
ciphers that is put in each key by default.  Currently that list is
AES256, AES192, AES, CAST5, and 3DES, but it can be changed at key
generation time (via the --default-preference-list option), or any
time afterwards (via the --edit-key command "setpref").
At encryption time, the list of possible ciphers is retrieved from
each recipient key, and a cipher is chosen that all recipients can
handle.  This guarantees that you never send a message that your
recipient won't be able to read.
It isn't always AES for you - it's just that for that particular
message, AES happened to work for all the recipients.

@_date: 2008-02-04 15:24:21
@_author: David Shaw 
@_subject: Can you clarify when data compression is used? 
The RFC doesn't specify default algorithms, aside from requiring 3DES
as the algorithm of last resort.  All decisions about algorithm
ranking are made by the implementations and indirectly, the user.
It's hard to list default algorithms in the man page mainly because
there isn't a single answer.  Different people will get a different
default algorithm depending on who they are sending a message to, and
possibly even by the order in which they specify the recipients on the
command line (see below).  All of this would need many paragraphs of
explanation, and that's not really appropriate for a man page.  I do
agree it would be good for it to be documented somewhere, though.
GPG doesn't use the Stable Marriage Problem when picking algorithms,
as this gives too much "power" to the recipients in choosing which
algorithm is used.  Rather, the intersection of preferences for all
recipients is generated, leaving an unordered list of algorithms that
are possible contenders for use.  At this point, note that it would be
possible to pick an algorithm from the list randomly, as there is no
algorithm on the list that isn't usable for all recipients.
GPG uses the personal-(whatever)-preferences as the final decider.  It
works its way down the personal preferences list in ranked order,
consulting the personal preferences against the generated intersection
list of recipient algorithms.  This gives the user the power to decide
what algorithms he or she generates, which is putting the power in the
right place.  If there are no personal-foo-preferences in use, then
GPG uses the first key specified as the decider.  This key is
frequently the user's key, so is a reasonable choice to pick the
favored algorithm.

@_date: 2008-02-04 22:52:22
@_author: David Shaw 
@_subject: Can you clarify when data compression is used? 
As I said earlier, DSA.  Trust me.  It's really DSA.
DSA doesn't have a particular hash (so it can't have SHA1 or anything
else as a hash).  It has a hash length.  Don't get hung up on the
DSA/DSA2 thing.  In actuality, there is no such algorithm as "DSA2".
Most people call DSA with a key larger than 1024 bits or a hash larger
than 160 bits "DSA2" for convenience.  All the --enable-dsa2 switch
does (and again, it's off by default in 1.4.8 and 2.0.8), is allow you
to generate a DSA key that is larger than 1024 bits or has a hash
larger than 160 bits.
No.  The first cipher is AES256.  AES and AES256 are not the same
cipher (AES in OpenPGP is AES128).
As of 1.4.8 and 2.0.8, and subject to change in future versions:
Cipher:      AES256, AES192, AES, CAST5, 3DES
Hash:	     SHA1, SHA256, RIPEMD160
Compression: ZLIB, BZIP2, ZIP, None
You could see this for yourself: generate a key, and run "showpref" on
it (which is in the manual, by the way).

@_date: 2008-02-05 09:42:16
@_author: David Shaw 
@_subject: Using notations on data signatures 
Yes, that is a reasonable use of a notation.  Notations (and
especially user notations) are basically the escape hatch in the
OpenPGP design: they're intended for adding stuff to signatures.  What
stuff if up to the adder.
See also --sig-policy-url for another, but more standard, way to add
information about a signature.

@_date: 2008-02-05 11:17:38
@_author: David Shaw 
@_subject: Can you clarify when data compression is used? 
That's basically the reason.  While GPG fully supports DSA2 signatures
today, there are a large installed base that cannot handle them.
Because of this, we decided to fully accept DSA2 keys and signatures
from elsewhere, but won't generate a new DSA2 key unless the user opts
in with --enable-dsa2.
The way is clear, and we'll get there eventually, but the installed
base is still pretty old.  Using --rfc4880 or --openpgp does enable
DSA2, but the default is still off.

@_date: 2008-02-05 13:00:54
@_author: David Shaw 
@_subject: can you see any problem with this? 
It's hard to really answer this as there isn't enough information to
say one way or another.
Speaking strictly to your question, and not the "is this wise"
question, if I understand it, you are proposing encrypting to a large
number of people, breaking the resultant encrypted message into many
PKESK packets (one per recipient) and one encrypted packet.  Then,
send each recipient their own PKESK plus the encrypted packet.
So, yes, that would work.  GPG even ships with the tools to make such
a message.  And it's safe to do so with the caveat that every user
will have the same encrypted message and be able to decrypt it.  On
the one hand, no big deal, becuase you sent everyone the same message,
so you clearly wanted them to have it.  On the other hand, it gives
Alice the ability to know that Baker got the same message that Alice
did.  Whether that is important or not depends on what you are doing.
Also, given that you are only sending each recipient their own PKESK,
why bother to use --throw-keyid ?  It might be easier to just encrypt
the whole message to each recipient individually rather than do all
the packet surgery.

@_date: 2008-02-05 13:50:56
@_author: David Shaw 
@_subject: can you see any problem with this? 
In that case, doing something like this may work for you:
gpg -o output.gpg -R recipient1 -R recipient2 -e thefile.txt
gpgsplit output.gpg
for i in *.pk_enc
  cat $i *.encrypted > `echo $i | sed -e 's/\-001\.pk_enc//'`
You'll end up with a directory full of files, one per recipient, and
each a valid OpenPGP message, but all of them protected via
throw-keyid.  I'll leave it as an exercise for the reader to determine
which file goes with which recipient ;)
  If Alice and Baker both get a message, and Alice knows which file
  Baker got, Alice can decrypt Baker's message using her own session
  key, thus revealing to Alice that Baker got the same message that
  Alice did.
  The "non-identifiable" feature with -R (aka throw-keyid) is only as
  good as throw-keyid is, which is pretty good but not perfect.
You may or may not care about these caveats.

@_date: 2008-02-05 14:00:34
@_author: David Shaw 
@_subject: Anti-Tempest Fonts, Where? 
No.  Or at least, not any longer.  There was a font package available
a few years ago that was an offshoot of some work done by Markus Kuhn
and Ross Anderson at the University of Cambridge.  More recently, they
improved the attack enough that the fonts were no longer effective.
  I'll update the manual so it does not reference the fonts any longer.

@_date: 2008-02-05 23:44:59
@_author: David Shaw 
@_subject: Any plans for GnuPG to implement decrypting to RAM? 
What does decrypt to swap mean?  For that matter, what does decrypt to
RAM mean?
  gpg -o /pick/your/own/destination -d file-to-decrypt.gpg
  gpg -d file-to-decrypt.gpg > redirect-to-a-file
  gpg -d file-to-decrypt.gpg | pipe-to-whatever-you-want
It's in the manual.

@_date: 2008-02-08 15:23:02
@_author: David Shaw 
@_subject: How know who is a file encrypted for ? 
Just run 'gpg' on the file, and don't give a passphrase.  It prints
all the possible recipients.

@_date: 2008-02-10 09:32:27
@_author: David Shaw 
@_subject: Can you clarify when data compression is used? 
It's basically true, at least in the context of OpenPGP.  Note that
the statement doesn't say that Twofish is insecure.  It's just that
when AES came along, it eclipsed many/most of the ciphers with similar
they'll attack AES because lots of people use it.  From the
perspective of the user of crypto, they'll use AES because of all the
research on it.  Repeat this cycle enough times, and you can see why
Twofish isn't used much.

@_date: 2008-02-10 14:57:26
@_author: David Shaw 
@_subject: Corporate use of gnupg 
This is essentially the rationale behind the "ADK" (additional
decryption key) feature of PGP.
It depends on how strong the term "force" is.  Even in PGP, the ADK
system can be circumvented if the person tries hard enough.
If you trust your employees to not hack you, then you can just stick a
"encrypt-to (the keyid)" in everyone's gpg.conf file and give everyone
a copy of the corporate public key.
Note that this isn't safe because of the crypto math.  It's "safe"
because you can fire people that don't do it ;)

@_date: 2008-02-10 20:15:49
@_author: David Shaw 
@_subject: Are DSA2 signing keys backwards compatible? 
Basically, no.  It's the main reason why --enable-dsa2 is off by

@_date: 2008-02-10 22:01:42
@_author: David Shaw 
@_subject: Are DSA2 signing keys backwards compatible? 
They were not introduced at the same time.  As you said in your
earlier mail, DSA2 was introduced in 1.4.8.  The new SHA hashes were
introduced in the 1.3.x development series.  All 1.4 and later GPGs
(including the 2.x series) have them.
It doesn't work that way.  SHA-1 doesn't even work with DSA2 keys.
DSA2 doesn't mean "a bigger DSA key".  It means "a bigger hash with a
bigger DSA key".  DSA2 allows for any hash size that is equal to or
greater than the hash size that was used when generating the key.
Thus, for example, it is legal (albeit silly) to use SHA-512 with a
old DSA key (which uses a 160-bit hash).  We just truncate to fit.
There is no special magic with the new hashes - once they exist, we'll
use them.
Have you tried using MD5 recently?
This is not how it works.  There is nothing becoming de-facto here.
Longer DSA keys are the de-jure standard today, and people are just
going to have to upgrade.

@_date: 2008-02-10 22:08:46
@_author: David Shaw 
@_subject: Authenticate capability of DSA or RSA signing keys 
The public/private question is not relevant here.
Sign = sign some data
Certify = sign a key
Authenticate = prove you are you
Authenticate is used for things like using an OpenPGP key for ssh.

@_date: 2008-02-10 22:10:59
@_author: David Shaw 
@_subject: Are DSA2 signing keys backwards compatible? 
I should clarify this.  DSA2 was enabled as part of standard OpenPGP
in 1.4.8.  We knew it was coming, though, so it exists as far back as
1.4.4 (June 2006).

@_date: 2008-02-10 23:33:59
@_author: David Shaw 
@_subject: Are DSA2 signing keys backwards compatible? 
No.  A 3096 bit DSA key that uses SHA-1 is possible and legal in
OpenPGP.  It is silly though, and GPG won't create it unless you
modify the code.  Outside of code modification, a 3096 bit key would
use a 256-bit hash (SHA-256, not SHA-512).  You could use SHA-512 with
it if you liked, but the hash would be truncated to 256 bits.
We follow the advice in FIPS 180-3:
      L = 1024, N = 160
      L = 2048, N = 224
      L = 3072, N = 256
So a 1024 bit key gets a 160 bit hash.  1025-2048 gets a 224 bit hash.
2049-3072 gets a 256 bit hash.  We don't generate keys less than 1024
bits or greater than 3072 bits.  Other programs may behave
differently, so GPG will naturally follow what the key encoding says
if it comes down to that.

@_date: 2008-02-10 23:46:47
@_author: David Shaw 
@_subject: Authenticate capability of DSA or RSA signing keys 
Math is math.  You could make an OpenSSH key into an OpenPGP key (or
vice versa) if you wanted.  It's just a file format change and some
related glue.  Doing this doesn't really give you anything useful
though.  The OpenPGP authentication key allows you to authenticate to
things like ssh - it doesn't make the key into an ssh key, just allows
it to act as if it was one.

@_date: 2008-02-10 23:58:57
@_author: David Shaw 
@_subject: Are DSA2 signing keys backwards compatible? 
I really did mean what I said.  De jure doesn't mean it exists on
paper and is not respected.  It just means it exists on paper, period.
As you say, "in law".  RFC-4880 is the published OpenPGP standard, and
it specifies DSA2.  Thus, de jure.
It will take some time for the "facts" to catch up with the "law"
here.  Hence the need for people to upgrade.

@_date: 2008-02-11 08:23:10
@_author: David Shaw 
@_subject: Are DSA2 signing keys backwards compatible? 
DSA signatures MUST use hashes that are equal in size to the number
 of bits of q, the group generated by the DSA key's generator value.
 If the output size of the chosen hash is larger than the number of
 bits of q, the hash result is truncated to fit by taking the number
 of leftmost bits equal to the number of bits of q.  This (possibly
 truncated) hash function result is treated as a number and used
 directly in the DSA signature algorithm.
No.  Preferences, including the digest preferences, are not relevant
here at all.  This is a signature *you* are making.  The digest
preferences are consulted when someone *else* is making a signature,
and wants to know if you can handle it.  It has nothing to do with
what your key needs because your key is not involved.

@_date: 2008-02-11 08:55:28
@_author: David Shaw 
@_subject: Are DSA2 signing keys backwards compatible? 
First of all, leave out 'showpref' from your documentation of this
question as it has nothing at all to do with hash choice when you make
a signature.  It's only relevant for other people making signatures
and sending them to you.
That leaves the question of which hashes are usable for a given DSA
key.  The answer is that all DSA keys contain a number called the 'q'
value.  That value specifies how large the hash must be when making
signatures with that key.  There are a few differences, but the main
difference between DSA1 and DSA2 is that DSA1 keys have q=160 and it
cannot change.  This is why DSA1 keys need SHA-1 or RIPEMD160 as their
hash: they are both 160-bit hashes, to match q=160.  DSA2 keys can
have different q values.
In DSA2, you can use whatever hash you like as long as it is equal to,
or greater than your q size.
Yes.  It's silly, as the hash is vastly stronger than the key, but
it's legal, and GPG can do it.
Robert is quite right about the defaults.  There are some very complex
issues here and GPG is a very configurable program.  It's excellent
that people spend the time to understand the issues, but I find that
most people who spend the time to learn the issues also use the
defaults :)

@_date: 2008-02-11 10:06:03
@_author: David Shaw 
@_subject: Are DSA2 signing keys backwards compatible? 
Exactly what you said - it only happens if he is encrypting to you at
the same time.
If there is a personal-hash-preference set, we use them.  For RSA,
that means to take the first one on the list, and if none are set, use
SHA-1.  For DSA, that means take the first one that is legal given the
signing key (i.e. large enough).  If there are no personal hash
preferences set, or none of the supplied preferences are legal, then
take the shortest SHA-x that matches the DSA2 key size.

@_date: 2008-02-14 13:07:05
@_author: David Shaw 
@_subject: Safe decryption with GnuPG? 
It is also important to test with different methods of disk
encryption.  On most systems there are a number of tunable parameters
that can significantly affect performance.  For example, AES is going
to be faster than 3DES.  Does the kernel do disk readahead?  If so,
how much?  Another question is how you're using it: a small file,
written once and read many times will be much faster on average than a
large file written once and read back once.  It's not as simple as
just saying "unnecessarily slow".
I worked on a disk encryption system a while back.  In design
discussions, we spent a lot of time discussing potential performance
issues and how that would affect the users of the system.  Finally, I
advised this:
1) Understand how you're going to use it.  What are you protecting
   against?  Given that encrypted disks are mounted and readable on a
   running system (effectively bypassing the encryption), often you're
   really just protecting against theft or a disk "sprouting legs" and
   going missing.
2) Tune the system for best performance for your particular usage.
3) Measure that performance.
4) Quantify in terms of money just how much the performance hit hurts
   you.  Call this "A".
5) Find out how much it would cost to hire someone big with a gun to
   stand in front of the server 24/7.  Call this "B".
6) Which is cheaper?
I've found that at the end of step 6, people tend to ask the smart
questions, and really start to understand step 1.

@_date: 2008-02-15 19:14:41
@_author: David Shaw 
@_subject: pgp servers hanging 
subkeys.pgp.net is a virtual keyserver.  The name actually points to
multiple different servers run by different people.
If any of these servers are down, keyserver requests can block for a
while until there is a timeout and GPG gives up.  You can change the
timeout value (it defaults to 2 minutes) with:
  keyserver-options timeout=xxxxx
Where xxxxx is the number of seconds to wait for the keyserver.

@_date: 2008-02-19 08:33:55
@_author: David Shaw 
@_subject: Corporate use of gnupg 
Yes.  Put "encrypt-to (the-adk-key)" in everyone's gpg.conf.
Of course, they could turn around and take it right out again.  Unless
you have pretty tight control over the environment, ADKs or
encrypt-tos are not foolproof (and that applies to both PGP and GPG).
As I said before, note that this isn't safe because of the crypto
math.  It's "safe" because you can fire people who don't do it.

@_date: 2008-02-19 11:06:28
@_author: David Shaw 
@_subject: Cannot Set the Expiration Date on Secure Subkeys 
Nope, you're quite right, and it's a bug.
It's a display bug, as the right data makes it into the key packet,
but --edit-key doesn't properly display it.  You can see this by doing
a --list-secret-keys on that particular key, and seeing the proper
expiration is set.

@_date: 2008-02-19 12:49:56
@_author: David Shaw 
@_subject: ADKs (was: Corporate use of gnupg) 
Let's define some terms, so we're all talking about the same thing in
the same way.
An ADK, for "Additional Decryption Key", sometimes called ARR for
"Additional Recipient Request", is a packet that is added to a key.
It is hashed into the key self-signature, so the key itself is needed
to add it.  This implies acceptance (or at least knowledge) of the
existence of the packet by the key owner, and if nothing else, they
can simply look at the key to see the ADK is there.  (There was a bug
a few years back where PGP accepted ADKs that weren't part of the
self-signature, but that has been fixed).
The main point of an ADK is to allow companies to get the benefit of
encryption, but help avoid the big risk of an employee encrypting
something in such a way that the company can't get it back.  The
employee could encrypt it and then quit (either maliciously or
coincidentally), or encrypt it and lose their key, and so on.  It's a
real risk.
The ADK contains two pieces of data: First, a key fingerprint.  This
is the key that the key owner is asking you to also encrypt to.
Secondly, there is a bunch of flags that tell you how strongly the key
owner feels about this.  The key owner can say either "Please also
encrypt to this key" or "You MUST also encrypt to this key".  In use,
an ADK is just another recipient.  It's more or less equivalent to
automatically adding a "-r the-adk-key" to a GPG command line.
Finally, note that the ADK is *not* part of OpenPGP.  It is a
proprietary extension of the PGP product.  It is also patented, which
prevents those other than PGP from implementing it.  (The PGP folks
are actually very reasonable about interoperability issues, but as far
as I know, nobody has asked about this.)
Now, in a closed environment (say, internal email) where everyone is
using PGP, it's great.  Every message is also encrypted to the ADK
key, and the company has assurance they won't lose any critical data.
In a mixed (PGP + GPG) but still closed environment, it's still pretty
good: those people using PGP will follow the ADK, and those people
using something else won't.  In the case of disaster, some data will
potentially not be recoverable.  This can be handled via the
"encrypt-to the-adk-key" in gpg.conf method.
To be sure, an employee in this closed environment could hack up
something that doesn't respect the ADK.  That's not a problem with the
software.  That's a problem with the employee.
The more difficult case is a completely open environment (say, email
for a company that also wants to encrypt their external email).  In
this case, those people using PGP will use the ADK, and others won't.
It's not possible to require every external person to do what you want
(they don't work for the company and have no reason to follow the
ADK).  In these cases, there isn't much that can be done aside from
key escrow, or running some sort of mail gateway system that can be
the keeper of the secret keys, or possibly even bounce messages back
that don't have an ADK (eg "You won't use the ADK, so I'm not talking
to you").
Even if the patent issue was resolved, it doesn't really solve much to
have GPG follow the ADK.  GPG is distributed as source - easy enough
for someone to simply comment out the ADK code if they didn't want it
to take effect.

@_date: 2008-02-27 13:23:34
@_author: David Shaw 
@_subject: How know who is a file encrypted for ? 
I'm serious - what is the use case here?  How often do people need to
list all recipients of a file?
By the way:
  gpg --no-default-keyring --secret-keyring /dev/null the-file.gpg

@_date: 2008-02-27 21:51:28
@_author: David Shaw 
@_subject: Signing people with only one form of ID? 
Perhaps more important than the number of IDs, is the quality of IDs.
A cheap generic photo ID from the local gym is practically worthless.
A passport or drivers license is usually good.
I wouldn't go crazy here: keep in mind that the web of trust is
designed for people who don't have the ability to prove that a
passport or license is real.  This is one of the reasons that more
than one signature is needed to make a key fully valid.  All that the
web of trust asks is that you do your best.

@_date: 2008-02-27 22:09:03
@_author: David Shaw 
@_subject: Signing people with only one form of ID? 
4 levels: 0-3, inclusive.  They are not binding (can't be, given the
design), but meaning is specified.  The meaning, however, is relative
to the signer.  That is, my  is not necessarily the same as someone
elses I know of no OpenPGP implementation that truly supports certification
level distinctions.  All of them, including GPG, treat a signature as
a signature, regardless of the level.  GPG does have a way to say
"don't accept anything less than level (X)" (which defaults to 2), but
once a signature has been accepted, it's the same as any other
The default is 0. 0 makes no claim at all, which is the safest
The levels (for general knowledge) are:
  0 = I'm not telling you    ("generic")
  1 = I didn't check at all  ("persona")
  2 = I checked a little bit ("casual")
  3 = I checked a lot        ("positive")
There is a lot more verbiage on the 4 types in RFC-4880, but it
basically boils down to what I said above.
Some people include a policy URL in the certification to tell a
recipient just what was done.  This has its own advantages and
disadvantages, but is really a comment as well, as no program parses
and acts on the information.
The bottom line is that you can sign with a signature level if you
like, but (barring persona signatures) it only makes a marginal
difference in practice.

@_date: 2008-01-04 21:14:08
@_author: David Shaw 
@_subject: pipes cgi and gnupg 
Not well.  The Linux key retention service (while very neat) doesn't  really solve the problem - GPG needs to be as platform-independent as  possible, which precludes solutions that are only available on Linux.

@_date: 2008-01-09 22:26:14
@_author: David Shaw 
@_subject: Decryption error 
This isn't an Amanda issue or a GPG issue.  Rather, it's a regular old
Unix-ish shared library issue.  The error means that the gpg binary
was compiled on a system that could find libgcc_s.so.1, but is now
being run on a system that cannot.
Does the libgcc_s.so.1 file exist at all on your machine?

@_date: 2008-01-09 22:38:18
@_author: David Shaw 
@_subject: Setting proxy through command-line parameters? 
I assume you mean the HTTP proxy for keyserver access?  If so, then
yes.  Add something like this to your command line:
   --keyserver-options "http-proxy=

@_date: 2008-01-12 09:53:11
@_author: David Shaw 
@_subject: Checking expiration date automatically 
See the file DETAILS in the doc/ directory.  Something like:
  gpg --with-colons --fixed-list-mode --list-keys test at date | cut -d: -f7
should do what you want.
The number is the expiration date (if any) expressed as the number of
seconds since 1/1/1970.

@_date: 2008-01-13 13:56:07
@_author: David Shaw 
@_subject: Backup my key (private/public) 
That is a fine way to back it up.  See also
 for another way to do
A public key can be automatically regenerated from your private key.

@_date: 2008-01-13 20:33:33
@_author: David Shaw 
@_subject: Question about history of hash and cipher collections 
I'm afraid the chart you made was somewhat eaten by word wrap, but it
seems basically sane.  Note that Camellia is not a standard algorithm,
and while it will probably be one eventually, it isn't today.
Yes.  "gpg -v --version" will give you the algorithm numbers along
with the algorithm names.  However, the algorithm numbers are not
really relevant to anything unless you're writing OpenPGP software.
For years now, all programs have referred to AES256 as "AES256" and
not "cipher 9".
S5 was SAFER-SK128 and S6 was reserved for DES/SK.  SAFER was dropped
and nobody ever implemented it.  DES/SK was never even allocated.
You can see the history between RFC-2440 and RFC-4880.  A good number
of algorithms were cleaned up between the two: if it wasn't actually
being used, it got dropped.

@_date: 2008-01-13 23:24:23
@_author: David Shaw 
@_subject: Question about history of hash and cipher collections 
Tiger was never really a part of OpenPGP.  RFC-2440 reserved an
algorithm ID number for it, but Tiger wasn't fully specified at the
time, so was not usable (the algorithm was specified, but an OID
number was never allocated).  It was dropped as part of RFC-4880 as it
was never widely implemented, and sort of missed its chance - it was
okay back when 2440 was published, but at only 192 bits, it's too
small for the modern 4880 era.
Serpent was never put in the OpenPGP standard, so GnuPG won't use it.
There isn't a really dramatic reason for it.  Adding algorithms to
OpenPGP involves a rough consensus among the OpenPGP working group.
With Serpent, that consensus never really happened.

@_date: 2008-01-14 12:24:39
@_author: David Shaw 
@_subject: Question about history of hash and cipher collections 
Version does report it that way.
$ gpg -v --version
gpg (GnuPG) 1.4.7
Copyright (C) 2006 Free Software Foundation, Inc.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions. See the file COPYING for details.
Home: ~/.gnupg
Supported algorithms:
Pubkey: RSA, RSA-E, RSA-S, ELG-E, DSA
Cipher: 3DES (S2), CAST5 (S3), BLOWFISH (S4), AES (S7), AES192 (S8),         AES256 (S9), TWOFISH (S10)
Hash: MD5 (H1), SHA1 (H2), RIPEMD160 (H3), SHA256 (H8), SHA384 (H9),       SHA512 (H10), SHA224 (H11)
Compression: Uncompressed (Z0), ZIP (Z1), ZLIB (Z2), BZIP2 (Z3)

@_date: 2008-01-14 17:56:35
@_author: David Shaw 
@_subject: Question about history of hash and cipher collections 
You could, but the end result would not interoperate with the rest of
the world.
For example, if you tried to send an encrypted message to someone who
hadn't hacked their GPG and had preferences of (for example) "TWOFISH,
CAST5, IDEA", your copy would pick AES256... and your message would
not be readable.
It doesn't matter all that much what the "cipher of last resort"
actually *is*, but it's absolutely vital that everyone has the *same*
one.  RFC-2440 and 4880 require 3DES for this reason.
Besides, 3DES has been around for longer than any other cipher in
OpenPGP, been studied and attacked far more, and still hasn't fallen.
The only thing wrong with it is that it's slow.  And I doubt you'd
notice the speed issue unless you're running on a very slow machine,
or sending very large messages.

@_date: 2008-01-15 11:52:04
@_author: David Shaw 
@_subject: Question about history of hash and cipher collections 
Choosing algorithms in OpenPGP is always a delicate balancing act
between technical issues, politics, and market forces.
Is the algorithm strong[1]?  Is the key length long enough?  Has it
been used in the past and a zillion keys have it in their preferences?
Will inclusion of the algorithm into OpenPGP allow use of OpenPGP in a
new industry (some industries in some countries have legally-mandated
algorithms), and so on.
CAST5 is a fine cipher and meets all the above criteria.  Don't assume
that just because it's older than AES, it's worth removing.  3DES is
the oldest cipher in OpenPGP (dating back to the 1970s) and it still
meets all the above criteria.  Arguably, it's better in some ways than
the newer ciphers as it's been actively studied and attacked since the
1970s and still hasn't fallen.
MD5 was effectively removed from OpenPGP.  RFC-4880 says:
  Implementations MUST NOT generate new signatures using MD5 as a hash
  function. They MAY continue to consider old signatures that used MD5
  as valid.
That's as close as removal as is realistic, given the huge number of
existing signatures using MD5 that are out there.
[1] I'm defining "strong" here in the loose sense of there are no
    workable attacks against it.  Remember that SHA-1 was broken, but
    it still in daily use as the break didn't reduce its strength
    enough for a workable attack.

@_date: 2008-01-15 12:09:49
@_author: David Shaw 
@_subject: Question about history of hash and cipher collections 
GPG does use 3DES as the default cipher for encryption.  That behavior
is required by OpenPGP.
There is no OpenPGP requirement for secret key protection (there are
few interoperability issues there), so CAST5 is as good as anything
else.  For what it's worth, if you set --openpgp mode, the secret key
protection cipher does switch to 3DES.

@_date: 2008-01-15 13:07:41
@_author: David Shaw 
@_subject: Question about history of hash and cipher collections 
It uses 3DES for symmetric encryption to a recipient as required.
Straight symmetric encryption you're allowed to use anything.

@_date: 2008-01-22 09:11:24
@_author: David Shaw 
@_subject: IDEA licensing issues 
Indeed.  Pretty much the only reason to use IDEA in the OpenPGP
context in this day and age is because you want some level of
compatibility with PGP 2.x or are similarly being forced into it for
other (non-crypto) reasons.  I try hard to stay out of the
newer=better discussions, but I believe it is safe to say that AES is
"better" than IDEA for pretty much any crypto criteria you'd normally
use, and most of the non-crypto criteria as well.  Plus, you don't
need a license for it.
It looks like the Mediacrypt people are having some problems.
 is down and idea ( mediacrypt.com bounces.

@_date: 2008-01-24 20:06:24
@_author: David Shaw 
@_subject: Problem with keys imported via DNS CERT 
I'm afraid you've redacted so much information (no real email address,
no real key ID) that it's not really possible to help you.

@_date: 2008-01-26 16:41:02
@_author: David Shaw 
@_subject: How true can this be? 
On the whole, the words of some random guy on some random web page
quoting some other random guy that he just happened to meet might not
be your best source of information.

@_date: 2008-01-29 18:11:54
@_author: David Shaw 
@_subject: adding a new email to a key 
You want to add a new UID, as that is what contains an email address.
A subkey is a different thing altogether.
The reason the new UID is listed first is that, by default, GPG treats
the most recent UID as the primary one.  This is because the more
recent email address generally is the more useful one.
That said, you can change it via the "primary" command in the "gpg
--edit-key" menu.  I don't know if kgpg makes this command available
via the GUI or not.
Note, though, that the notion of primary UID is almost completely
cosmetic.  It doesn't really matter much in practice UID is listed

@_date: 2008-01-30 08:43:56
@_author: David Shaw 
@_subject: UID order 
gpg --edit-key (the key id)
 uid X (where X is the uid number you want to be the first)
 primary
 save
Note that this is really a cosmetic thing, and has little impact aside
from that.

@_date: 2008-01-30 18:31:56
@_author: David Shaw 
@_subject: export/import additional user id 
Both addresses are still there.  It just doesn't show you both when
you import.

@_date: 2008-01-30 20:17:27
@_author: David Shaw 
@_subject: export/import additional user id 
Again, GPG supports any number of email addresses.  If some other
program that calls GPG chooses to ignore any after the first, there
isn't much that GPG can do about it.
Are you really sure that what is happening is what you think is
happening?  I'd be very surprised to hear that the Mail.app plugin
only supported the first address.

@_date: 2008-07-03 17:10:29
@_author: David Shaw 
@_subject: unable to use the public key 
There is confusion here.  Your key is a DSA primary.  You cannot
encrypt to it.  It's not a question of GPG disallowing it, it's a
question of the math simply not working that way.  DSA is not an
encryption algorithm.
Where is the origin of the belief that the vendor can only decrypt
from a primary key?  This is directly contrary to the behavior of all
known OpenPGP programs (GPG, PGP, etc).

@_date: 2008-07-09 22:11:28
@_author: David Shaw 
@_subject: key generation in a script or non interactive mode? 
Please read the section "Unattended key generation" in doc/DETAILS.

@_date: 2008-07-10 20:25:55
@_author: David Shaw 
@_subject: key generation in a script or non interactive mode? 
Your entropy source dried up.  Normally I'd suggest wiggling the mouse  or poking at the keyboard to make some more entropy, but if you're  running completely unattended that may be hard (you may not even have  a mouse on that box).
There is a good article on entropy gathering on Linux (I'm assuming  you are running Linux here) at

@_date: 2008-07-18 19:17:10
@_author: David Shaw 
@_subject: Encrypting external harddrive in windows vista with GnuPG 
Not with GnuPG.  That's not what GnuPG does.  There are, however, a  number of tools to encrypt hard drives.  I suggest you Google for  "full disk encryption windows vista" and see what comes up.

@_date: 2008-07-21 18:50:23
@_author: David Shaw 
@_subject: identical files -> non-identical encrypted files 
It's not salt - the session key is random.  If it wasn't, well,  decrypting would be pretty easy.

@_date: 2008-07-21 22:30:47
@_author: David Shaw 
@_subject: information in the public key block 
The key block is just a base64 transformation of the key.  The key  format is specified in RFC-4880, and yes, it includes email addresses,  the information necessary to calculate the key ID, and so on.

@_date: 2008-07-28 16:35:08
@_author: David Shaw 
@_subject: Key Flags 
Yes, though in practice, most primary keys have both.
Yes.  Note that since the web of trust is made up of primary key
signatures, this naturally follows from your first statement.

@_date: 2008-07-28 16:42:15
@_author: David Shaw 
@_subject: Key Flags Discontinuity 
Allowed, yes.  Actually done, no.  There is a good bit of historical
"this is the way we do it" in OpenPGP, and this is one of those
cases.  OpenPGP allows key flags to be in either a user ID signature
(0x10-0x13) or the direct key signature (0x1F).  In practice, everyone
puts them in the user ID signature.

@_date: 2008-07-31 09:56:19
@_author: David Shaw 
@_subject: compatible between GnuPG 1.4.7 and PGP 6.5.2 
In general, GPG will work with PGP 6.  However, you have not given  enough information for someone to help you.  We need more than "we got  problems" to give you an intelligent answer.  At the barest minimum,  what error message did you get when you tried to decrypt?

@_date: 2008-06-04 13:08:40
@_author: David Shaw 
@_subject: Wildcards in uids? 
Sorry, there is no way within GnuPG to do such a thing.  It's
frequently doable outside of GnuPG via your mail program, but you'd
have to consult the documentation for that program to learn how.

@_date: 2008-06-04 15:18:00
@_author: David Shaw 
@_subject: Wildcards in uids? 
I think I did understand the query.  You have email addresses like
"myaddress-foo at example.com", "myaddress-bar at example.com", and so on.
The question was is a "catch all suffixes" UID possible.  The answer
to that question is no.
That said, I'm not sure why you think this is a necessary thing to

@_date: 2008-06-06 17:45:26
@_author: David Shaw 
@_subject: max-cert-depth and "chains of trust" in GPG 
Correct.  This is because Alice does not necessarily agree with Bob.
The trust decisions are personal, and while Bob might feel that
Charlie is a good signer, Alice might not.
Yes.  The "classic" trust model requires personal trust.
Just signatures.
No.  As I noted above, the trust database is very dependent on the
owner - or put another way, why should you believe my trust database
is correct?
Yes, there is.  There is a different method of signing that does
basically what you are looking for here - try a "tsign" (for "trust
signature").  A trust signature does the same thing as a regular
signature, but also contains the trust information that would have
been put in the database.  Essentially, it allows you to issue a
signature that says "I verified the key belongs to her, and I also
trust her to make signatures on my behalf".
for some examples on how to use it.

@_date: 2008-06-10 23:24:15
@_author: David Shaw 
@_subject: known-plaintext attacks 
Cannot be answered in the context of this question.  It depends on the  cipher mode.

@_date: 2008-06-11 15:56:27
@_author: David Shaw 
@_subject: LD_PRELOAD attack 
I read the article.  For those who didn't see it, the basic summary is
that by using LD_PRELOAD to replace various functions (memcpy and
read) underneath a given execution of GPG, you can snoop on what is
going on.
I don't.  The idea of using LD_PRELOAD to play various security games
is not a new one.  It's fun to play around with and handy for
debugging, but it's not a useful attack in the real world.
If the attacker had access to your machine to implement the LD_PRELOAD
attack, there are literally dozens of ways they can similarly steal
whatever data they are trying to steal.  Why do a very complex attack
involving replacing libraries when they could just replace the GPG
binary itself?  Or add a shell script named 'gpg' and put it in your
search path ahead of the real gpg?  Or turn on typescript by default.
Or load a kernel module that changes the meaning of system calls.  Or
replace the rng with one that isn't random.  Or, or, or.
If you don't have control of your computer, you don't have control of
your computer full stop.  Having GPG do some extra checks doesn't
really help, because the attacker can simply arrange for these extra
checks to appear to succeed, or just replace GPG altogether so they
don't run.
If I may torture an analogy here, being worried about someone who has
access to your computer using LD_PRELOAD to attack you is like being
worried that a burglar has a key to your front door... but your front
door isn't locked anyway.

@_date: 2008-06-11 19:02:00
@_author: David Shaw 
@_subject: LD_PRELOAD attack 
Try it.  I don't have to replace it for everyone - just you, and if I
can write to your computer, I can make you run any binary I want.
Remember, you own your own shell .rc file.
Again, .bashrc.
Why would I care about getting your passphrase if I can get everything
you typed into the message before it was encrypted?
Still, just for laughs, here's a hack that will save everything typed
on a particular terminal, including passphrases (real error checking
and proper handling of sigchld left up to the reader):
       main(int argc,char *argv[])
  int master,slave,snoop;
  pid_t pid;
  char byte;
  snoop=open("/tmp/snoop",O_WRONLY|O_CREAT|O_TRUNC,0666);
  pid=fork();
  if(pid)
    {
      struct termios term;
      tcgetattr(0,&term);
      cfmakeraw(&term);
      term.c_lflag&=~ECHO;
      tcsetattr(0,TCSAFLUSH,&term);
      close(slave);
      for(;;)
    }
  else
    {
      pid=fork();
      if(pid)
      else
    }
  return 0;
Do you seriously think that someone who can write to your user-level
account can't get root pretty soon?  This can be as complex as reading
bugtraq for a while until a buffer overrun comes along, or as simple
as arranging for "su" to go somewhere else.
I do get it.  I'm not convinced that you do.
If an attacker has access to the user's account, it's game over.  At
that point, it's just a question which particular method the attacker
will choose to completely own you.

@_date: 2008-06-11 20:57:44
@_author: David Shaw 
@_subject: LD_PRELOAD attack 
Typescript is sort of an output keylogger.  It's mainly used to
produce a "script" of a session.  It's true that it doesn't record
passphrases, but you can write a program that does the same thing.
Note, I left out a line of code in the previous example if anyone
wants to try it:
  openpty(&master,&slave,NULL,NULL,NULL);
Defending against LD_PRELOAD doesn't actually make GPG safer overall.
It just makes it more complex.
Incidentally, there is a really easy way to "defend" against
LD_PRELOAD in GPG: just make it setuid root.  GPG is smart enough to
see it is setuid root and drop the root privs early, and most dynamic
linkers automatically disable LD_PRELOAD for setuid binaries.

@_date: 2008-06-11 21:06:54
@_author: David Shaw 
@_subject: public key different between keyserver and exported file 
Nothing to worry about.  OpenPGP packets can be written in multiple  different ways, even though they come out to the same thing in actual  usage.  You're just seeing a "re-formatting" of your key.

@_date: 2008-06-13 15:03:24
@_author: David Shaw 
@_subject: PGP doesn't import trust signatures w/ depth > 8 on keys 
I could make a guess (8 is a huge depth already and so they capped it
there to simplify things?), but it would really be just a guess.  I
suggest contacting the PGP folks and asking them.  They're a very
responsive company.  Let us know what you find out.
This one I can answer, as I wrote that part of the code.  The reason
that GPG marks signatures with a depth greater than 9 as 'T' in a
signature listing is simply because the signature listing is
formatted, and I only had room for a single digit without reformatting
the display.  Thus, 'T' in this case just means "more than 9".  Note
that this is strictly a display convention, and the internal trust
calculations use the real number of course.

@_date: 2008-06-13 15:12:20
@_author: David Shaw 
@_subject: Camellia 
Well, I do reserve the right to point and laugh if someone ignores the
warnings and ends up losing data (for cripes sake, GPG with Camellia
even prints out a warning every time you run it).
The Camellia draft has been submitted for sponsorship in the IETF (see
it at
Pretty soon there will be official Camellia support and the warnings
will go away.

@_date: 2008-06-13 15:39:20
@_author: David Shaw 
@_subject: passphrases: the police and subkeys scenario 
The signatures are actually on both the primary key and your user IDs,
but that's basically correct.
GPG (somewhat) supports different passphrases on subkeys and primary
keys.  The catch is that it does not generate such a key itself, so if
you want it, you have to generate it manually.
An easy way to handle the police scenario you give is to remove the
passphrase from your key, use --export-secret-subkeys to export just
the subkeys to a file, then put the passphrase back on your key.  Give
the police the subkey file, and you're done.  They then have the
ability to decrypt, but don't have your primary key.
That's just talking crypto, of course.  If it ever comes down to this
in the real world, I'd recommend talking to a good lawyer before you
do anything.

@_date: 2008-06-13 16:19:00
@_author: David Shaw 
@_subject: Remove public key from secret key 
No.  You can strip the public key data from the secret key, but then
the key is unusable (it's not a "OpenPGP key" any longer) until you
restore the public key data.

@_date: 2008-06-13 17:42:55
@_author: David Shaw 
@_subject: Questions about trust signatures 
Internet Archive has it:
You might also look around in the PGP.com white paper library for
similar information.  The PGP company bought the Cryptoex company a
while back, so PGP may have migrated some of the white papers over to
their own site.
Yes, you have.
No.  The problem here is the use of the word "indefinitely".  Without
the depth concept, anyone in the chain can make a signature beyond
their "signing privilege" (for lack of a better term).  For example,
using the chain above, let's say that Alice is the regular user, Baker
is the company-wide Root CA, Charlie is a VP, and Dorothy is a
Manager, who manages Eve.  Note now in the example you give above,
Dorothy cannot issue a trust signature to Eve - just a regular
signature.  If there was no depth limiting it, Dorothy could go rogue
and issue a trust signature to an attacker who could then issue more
trust signatures, etc.  The depth (along with the domain restriction)
prevents people from further down in the chain from doing things that
you, the head of the chain, (Alice in this example) don't want to
To be clear, note that nothing stops Dorothy from issuing such a
signature.  It's just that when resolving the chain **from the
perspective of Alice**, Dorothy's signatures are limited to a single
hop.  Even if she issues a signature with a depth of 99, when looked
at as part of the chain above, the depth will appear to be 1.  When
looked at from the perspective of someone else, the results may be
Another way for Alice to handle the problem is rather than signing it,
simply to mark the CA key as "ultimately trusted".  This avoids Alice
having to know the depth of the chain, as it will cause any signature
by the CA to be treated as if it was issued by Alice herself.  This
can be thought of as a infinite-depth trust signature if you like.
The chain isn't broken, the depth at each step is just lowered to
match the perspective of the head of the chain (Alice in this case).
If Bob tsigns Carmen, then from Bob's perspective, that chain in the
link had a depth of 4.  Similarly, if Roger signs Bob's key with a
depth of 5, then we have a new chain from Roger's perspective where
the Bob->Carmen link also has a depth of 4.  If Roger signed Bob's key
with a depth of 4, then the Bob->Carmen link has a depth of 3 (as it
is lowered to match the maximum depth granted by Roger).  If Roger
signed Bob's key with a depth of 50, then the Bob->Carmen link has a
depth of 4 (as it can't be larger than what Bob granted).
Both GPG and PGP handle this essentially the same way.  You can always
run with an external trust model by disabling trust in GPG, and doing
the work externally, but it won't be compatible with the rest of the
All approaches here are bad approaches, as one can always come up with
an example where the answer you want contradicts the answer you want
from another example.  Most recent is consistent and
It says how much the signer verified the key before signing it.  It is
really a cosmetic difference since GPG mainly ignores those numbers.
See "--default-cert-level" in the manual for more.
Shorter wins.  The reason for this is that a long chain is a fragile
chain: each additional link adds risk of someone doing something

@_date: 2008-06-16 17:02:12
@_author: David Shaw 
@_subject: Questions about trust signatures 
Interesting.  I'm going to have to go back to my notes from when I
wrote that code back in 2002, and see what I was shooting for.  My
memory is that I wanted the trust depth to automatically degrade as
the chain continued.  It's possible this is just a bug, or it is
possible I did it this way on purpose (PGP compatibility, maybe?)
I'll let you know what I find.

@_date: 2008-06-23 13:23:46
@_author: David Shaw 
@_subject: About my prefered settings... 
Put this in your gpg.conf:
 personal-cipher-preferences aes256
 personal-digest-preferences sha256
 personal-compress-preferences zip
GPG will then use those algorithms when possible, but will never use
them if it would make the recipient unable to decrypt.

@_date: 2008-06-23 14:37:21
@_author: David Shaw 
@_subject: TEXTMODE Option in Gpg4Win ? 
"TEXTMODE=ON" is an old PGP 2.x command.  It has nothing to do with
GPG.  Plus, it's actually the opposite of what you want.  In OpenPGP,
a text file is canonicalized into a standard format when encrypted,
and re-canonicalized to the platform local format when decrypted.
Both of these steps can change the CRLF line ending.
If you want to guarantee that there are no changes at all, and the
decrypted data is a byte for byte copy of the original, then turn off

@_date: 2008-06-23 14:58:46
@_author: David Shaw 
@_subject: What regenerates files in ~/.gnupg? 
If you run gpg, and those files don't exist, gpg will create them.  I
can't say what is running gpg so oten on your system, but something is
doing it - possibly evolution.

@_date: 2008-06-23 15:53:44
@_author: David Shaw 
@_subject: TEXTMODE Option in Gpg4Win ? 
Please do not top-post.
As I said, TEXTMODE=whatever is not a GPG command.  It has no
functionality in GPG whatsoever.
GPG defaults to textmode being disabled.  If you are not turning it
on, GPG doesn't turn it on for you.

@_date: 2008-06-23 16:23:53
@_author: David Shaw 
@_subject: Multiple uid's vs. multiple primary keys & "master signing keys" 
Not necessarily.  You are free to use 1 passphrase for all 3 keys if
you like.
Not weird.  Some people do it that way.  Some people find it
annoying.  It's really a matter of taste.
The latter.  They would just sign your master key, and you'd sign your
own "uid key" with your master.
Many do.  I personally do have a problem with it, as it makes it very
difficult to validate the key unless you know the person personally.
It's handy to make a distinction between your work and personal life,
and for many or even most people, their personal "identity" is a lot
longer lived than their work "identity".  People keep the same
personal address for years, but don't as often keep the same job (and
thus job address) for that long.
Personally, I do this with two keys.  One personal, and one work.  I
don't really get the work one signed, as people who want to reach me
generally do so in my personal context (I do FOSS work, but I do it
under my personal address as I've found that many people just send
mail to personal addresses even there is a special address for FOSS

@_date: 2008-06-24 08:56:53
@_author: David Shaw 
@_subject: About my prefered settings... 
S9 and AES256 are the same thing.  Use whichever you like.  I'd  recommend using the full name - the S9 thing is really just backwards  compatibility to an older version of GPG.
For personal-blahblah-preferences, list the ones you want to use when  you make messages.  If that list fails (because your recipients can't  all handle them), you'll end up with 3DES.  Similarly, when setting  preferences on your key, list the ones you want other people to use  when they make messages for you.  Again, if that list fails (because  the other recipients of the message can't all handle them), you'll end  up with 3DES.
gpg -v --version lists all the number codes, but again, use the names.

@_date: 2008-06-24 19:36:54
@_author: David Shaw 
@_subject: cipher ID's 
They could have been.  In the case of S5 and S6, they're marked as  reserved because they were actually allocated at one point for SAFER- SK128 (S5) and DES/SK (S6).  They're marked as reserved now to make  sure they're not used by anyone for anything.

@_date: 2008-06-26 14:54:14
@_author: David Shaw 
@_subject: Questions about trust signatures 
After some digging: GPG's trust signature implementation was based on,
and tested against PGP 7 (as a black box - we didn't see any of the
code).  My best guess is this is what PGP 7 did at the time?  I don't
really recall, and don't have a copy to test against any longer.
In any event, PGP 9 does lower the trust depth as the chain gets
longer, so I will update the calculations to match that.  Here is a
patch.  Can you give it a try and see if it works as expected for you?

@_date: 2008-03-03 19:47:01
@_author: David Shaw 
@_subject: Question on subkeys usage and OpenPGP card.  - warning, 
There are only minor security implications to this.  The main reason  why you use the primary key to sign keys (called "certification", by  the way) is semantic.  Identity in OpenPGP is a key plus a user ID.   That key, given the way keys are laid out, is the primary.  The  primary is what certifies (self signs) the user ID.
It is mathematically possible to certify a user ID with a subkey, but  semantically that subkey isn't part of your identity, so the  certification is not used.
No, you do not need to make a new key or do anything like that.  If  and when your key expires, you can simply extend the expiration date  as needed.  OpenPGP has "soft" key expiration that can be changed at  will by the keyholder.

@_date: 2008-03-04 11:41:23
@_author: David Shaw 
@_subject: gpg command 
You want the -o option, as in "gpg -o output-goes-here.gpg -e
Note that "-s" doesn't encrypt.  It signs.

@_date: 2008-03-04 11:54:42
@_author: David Shaw 
@_subject: Strength of ciphers in PGP? 
You're not likely to find a comparison between those three ciphers
except in the most light sense of the word.  Certainly not a "XXXX is
better than YYYY" type of thing.  The question is just more
complicated than that.
I'd read these to get the information you want:

@_date: 2008-03-04 11:59:48
@_author: David Shaw 
@_subject: IDEA? 
It's patented until 2010 (2011 in some places).
IDEA is effectively dead.  I don't mean that as a knock against IDEA -
it was a fine cipher for its time, but time has moved on.  The only
reason to use IDEA is if you want to be compatible with PGP 2

@_date: 2008-03-04 12:01:09
@_author: David Shaw 
@_subject: changing location of the home folder from ~/.gnupg to other 
gpg --homedir /path/to/the/folder
  export GNUPGHOME=/path/to/the/folder

@_date: 2008-03-06 12:01:57
@_author: David Shaw 
@_subject: When using svn version gnupg, why isnt svn version shown with 
It seems we forgot to reset the flag after the last release.  It's
fixed now:
 $ gpg --version
 gpg (GnuPG) 1.4.9rc1-svn4701

@_date: 2008-03-06 12:51:25
@_author: David Shaw 
@_subject: one more question: is there a way to use additional keyring 
Sure, just add "keyring the-other-keyring.gpg" to your gpg.conf file
or give --keyring on the command line.  By default, the keyring is
expected to be in your .gnupg directory.  If you want, you can give a
"/full/path/to/the/keyring.gpg" to the keyring command and then it
will look anywhere you like.

@_date: 2008-03-08 08:46:31
@_author: David Shaw 
@_subject: v1.4.8 --textmode incompatible with earlier versions 
This is not a bug.  There was a "buglet" in the original OpenPGP  specification around text canonicalization.  GnuPG follows the updated  spec (RFC-4880) now.  To revert to the older spec, use the "--rfc2440- text" for this specific issue, or "--rfc2440" for a full reversion.

@_date: 2008-03-17 13:22:09
@_author: David Shaw 
@_subject: How to establish a company web-of-trust 
Note that those methods are only useful so long as the communication
partner gets the key from your company (a web page, a company
keyserver, or the like), and not from a public keyserver or from the
employee.  The reason for this is that keys or signatures can be
'unrevoked' by a malicious 3rd party (who may or may not be the

@_date: 2008-03-17 17:06:17
@_author: David Shaw 
@_subject: How to establish a company web-of-trust 
The official public key *and* the employee key must be retrieved from
somewhere under your control.  You can get away with using public
keyservers for this, but it's not a guarantee.

@_date: 2008-03-18 12:57:59
@_author: David Shaw 
@_subject: Change limits on pubkey lengths? 
Camellia is not in RFC4880.  It is currently being discussed for its
own RFC, though.  The only 256-bit ciphers in 4880 are Twofish and
AES256, and the default for RSA is already 2048.  We'll accept up to
4096 (and of course accept virtually anything generated elsewhere),
but when you get much past that, things get problematic: RSA 16k is
unbelievably slow, and difficult to work with.  It's just too big.
A better answer is EC cryptography in OpenPGP, which gives you more
security for each bit of space.  As it happens, EC is also being
discussed for its own RFC at the moment.

@_date: 2008-05-01 13:22:27
@_author: David Shaw 
@_subject: Version 4 / Version 3 keys 
GPG only generates V4 keys.  V3 keys are supported, but only for  backwards compatibility.  It is very strongly recommended that you  don't go down the V3 route.  V3 is dead.  Let it stay dead.

@_date: 2008-05-01 13:47:32
@_author: David Shaw 
@_subject: GPG warning for integrity protection 
Basically, yes.
There is a flag on a key that tells GPG that is it safe to use the  MDC.  If that flag isn't there, GPG doesn't use MDC as it doesn't know  if the recipient can handle it.  (There are some exceptions to this  rule, but it is basically true).
To check if your key has the preference, run "gpg --edit-key  (yourkey)" and then "showpref".  MDC, if enabled, will be on the line  marked "Features".  To enable MDC on a key that doesn't have it, you  can use "setpref", which allows you to set all your preferences for  that key (cipher prefs, hash prefs, compression prefs, MDC, etc).

@_date: 2008-05-03 22:00:29
@_author: David Shaw 
@_subject: Question about GnuPG Smartcard 
The smartcard can store 3 1024-bit RSA keys.  It cannot store a 2048- bit key.

@_date: 2008-05-05 09:06:02
@_author: David Shaw 
@_subject: How trust works in gpg... 
Absolutely.  You signing a key means that you believe the key to  belong to who it claims to belong to.  You are certifying the mapping  between person (or auto-signing robot, or...) and the key.  Giving  trusted status to the key means that you trust that person/robot/etc  to sign other keys.
You signing a key makes that key "valid" in GPG.
You signing a key and assigning trust to it makes other keys *they*  sign (potentially) valid.

@_date: 2008-05-05 13:55:57
@_author: David Shaw 
@_subject: how long should a password be? 
That's a good article.  See this also: .  It gives a way of easily generating and (fairly) easily  remembering long passphrases.
This is very true and very important.  The passphrase is really the  protection of last resort, and only comes into play after the secret  key is already lost.  Simply locking your front door gives a layer of  protection here, and there are many other ways to prevent access to a  secret key so the passphrase never even gets tested.

@_date: 2008-05-06 14:47:45
@_author: David Shaw 
@_subject: Compile without libiconv or libintl on Solaris 
Can you post what happens when you try?  Where does it fail?

@_date: 2008-05-06 16:08:55
@_author: David Shaw 
@_subject: Compile without libiconv or libintl on Solaris 
Sun doesn't really approve of static linking on Solaris:
  That said, what happens if you do this:
  NETLIBS=-lnsl ./configure

@_date: 2008-05-07 12:26:06
@_author: David Shaw 
@_subject: Need recommendation on keyserver code 
Any of the above-mentioned keyservers should run just fine on Solaris,
including the LDAP one (which is really just configuration and a
schema file on top of a standard LDAP server).
This would be a good thing.  I'm sure such a package would be
The main questions you need to ask when setting up a keyserver are:
1) Are you going to be syncing with the public keyserver net?
2) Does your environment already have an LDAP infrastructure?
3) Are you using PGP Universal anywhere in your environment?
Unless syncing with the public keyserver net is vitally important to
you, I highly recommend the LDAP solution.  It works nicely with GPG,
and enables some extra automatic keyfinding magic in PGP Universal.
(GPG can do the keyfinding trick with any keyserver type, but I
believe PGP Universal only does it with LDAP).

@_date: 2008-05-15 12:22:07
@_author: David Shaw 
@_subject: Changing subkeys: what impact does it have? 
No.  If you delete the encryption subkey, then you will not be able to
decrypt.  The signing subkey is not involved in encryption, so you can
delete that one without affecting encrypted messages.
Aside from the obvious addition or removal of a subkey, no.

@_date: 2008-05-24 10:57:33
@_author: David Shaw 
@_subject: Disabling compression when encrypting 
Note that GPG also checks the input file to see if it is compressed.   If it sees a compressed input file, it automatically disables

@_date: 2008-05-24 21:22:30
@_author: David Shaw 
@_subject: Disabling compression when encrypting 
Known headers.  It's basically the same thing that file(1) does.   You're correct in that it only catches zip, gzip, and bz2.

@_date: 2008-11-01 09:17:44
@_author: David Shaw 
@_subject: receive my signed keys 
For most keyservers, there is no way to ask such a question (it  actually is possible in the LDAP keyserver, but the LDAP servers -  intentionally - aren't synchronized with the rest of the pool).
You can do it yourself though: go to Wotsap and search on your own key  in the "Key Statistics" section.  This will give you a list of all  keys signed by your key.  Then fetch those keys from any handy  This only works, of course, if the key that you signed is on the  keyservers in the first place.  If it isn't, then it won't appear in  the list and won't be fetchable from the keyservers anyway.

@_date: 2008-11-03 16:47:01
@_author: David Shaw 
@_subject: Signature semantics (was Re: Anyone know what became of the Gaim-E 
OpenPGP (properly) does not get very involved in the meaning of a
signature.  Regular signatures, in fact, are defined in RFC-4880 as
"This means the signer owns it, created it, or certifies that it has
not been modified." which is fairly wide open to whatever meaning
anyone wants to apply to it (that's a feature, not a bug).
The problem with a seal or a signature that it doesn't say anything
about the intended recipient of the message.  It's very easy for
someone to forward the message elsewhere as a man-in-the-middle.  An
example using OpenPGP in particular: Alice sends Baker the signed "I
love you" message.  Baker then forwards it to his rival Charlie.
Charlie sees a signed message from Alice, without any indication that
he is not the real recipient, and proceeds to make a fool of himself.
Encryption doesn't help this situation as (in most cryptosystems), the
encryption is a wrapper around the signature.  So Alice creates this:
  "I love you"
and signs it:
  Alice_sign( "I love you" )
now encrypts it to Baker:
  Encrypt_Baker( Alice_sign( "I love you" ) )
Baker gets it, and decrypts it:
  Alice_sign( "I love you" )
Then encrypts it again to Charlie:
  Encrypt_Charlie( Alice_sign( "I love you" ) )
One lesson that can be learned from this is that the signed portion of
a message should contain sufficient context so that the message cannot
be repurposed in this fashion.  Also, Alice should know better than to
trust Baker.  The cad.

@_date: 2008-11-03 17:04:56
@_author: David Shaw 
@_subject: Seals (was Re: Anyone know what became of the Gaim-E Project?) 
Rather offtopic, but I read an interesting paper on seals a while back
(I'm afraid I don't recall where offhand).  Seals never really assured
confidentiality.  A person who wanted to open a letter would just make
a mold of the seal, melt it free, read the letter and then re-make the
seal using the mold.
The countermeasure was to use multiple colors in the seal so that
melting it free would mix up the colors so the new seal wouldn't look
right.  The catch was that you'd have to send a drawing of how the
first seal looked using a different communications channel so the
recipient could compare...

@_date: 2008-11-04 00:32:19
@_author: David Shaw 
@_subject: Anyone know what became of the Gaim-E Project? 
Both PGP/MIME and S/MIME are built over MIME, and have the same  metadata protection.  Specifically, none of the mail headers are  included.  This is not a flaw - it's just not how MIME handles this  sort of thing (with some headers covered, and some not).  If you want  to protect an message, you protect the entire thing as a message/ rfc822 object which is completely covered.  Think of it as treating  the message you are protecting as an attachment to another message.

@_date: 2008-11-04 11:18:03
@_author: David Shaw 
@_subject: Seals 
Yep.  If you read about the history of crypto and message/information
security in general it's striking how things haven't really changed
all that much.  We do it faster/better/safer to be sure, but there are
a lot of fundamental concepts that have been around for hundreds or
even thousands of years.

@_date: 2008-11-04 11:58:49
@_author: David Shaw 
@_subject: Signature semantics 
It is not the place of GPG to modify the plaintext.  If it is needed,
that's the job of a mail program or other program that uses GPG.  GPG
should just provide necessary primitives to solve this, and it does:
  gpg --sig-notation "whatever at example.com=I encrypted this to Baker!" --sign --encrypt  blah.txt
The notation will be hashed into the signature and cannot be removed
without invalidating the signature.
All that said, doing this isn't a cure-all.  Alice (the signer here)
may not want her intended target to be public.

@_date: 2008-11-04 12:04:19
@_author: David Shaw 
@_subject: Signature semantics (was Re: Anyone know what became of the 
Indeed.  The alteration also may or may not be malicious.  The most
common alteration I've ever seen are mail programs that break the
signature via word-wrap or the like.  (Hence the frequent "Does my
signature verify now?" message chains on some crypto mailing lists).

@_date: 2008-11-04 14:42:56
@_author: David Shaw 
@_subject: Signature semantics 
Not really GPG's job.  Just like it isn't GPG's job to remind a user
to encrypt in the first place.  I'm all for making the tools that GPG
makes available more capable of handling this case, but an interactive
prompt isn't the way.
Also not really GPG's job, but it's not possible in any event.
OpenPGP does not timestamp encryptions.  There are only two timestamps
in an encrypted and signed message and they are the stamp of the
original file, and the stamp of the signature.  Decrypting and
re-encrypting doesn't change them.
Not at all.  The attacker controls his own clock, so it would just
look like a regular SMTP retransmit.  They happen hundreds of times a
day on any reasonably large mail server.

@_date: 2008-11-05 09:29:27
@_author: David Shaw 
@_subject: Signature semantics 
I'm always in favor of documentation.  I wouldn't restrict it to notes  about signatures though - a general quick start guide (there are  several out there that can be used or adapted) would be very handy to  ship in the installer.

@_date: 2008-11-09 10:30:16
@_author: David Shaw 
@_subject: Resign existing key with higher trust 
You have a few options here.  If you haven't sent the key to a  keyserver (i.e. nobody but you has the signature in question), then  just use "delsig" to delete the signature.  Then sign it again however  you like.
If you have already distributed the key with the signature in  question, the usual way to handle this is to revoke the old signature  (revsig) and then sign again.  I'm not sure why you object to that -  it gives you exactly what you want.
If you really want to sign it again without deleting or revoking the  original signature, then you can re-sign it by adding --expert to your  command line.  GPG will tell you you've already signed the user ID,  but then offer to sign it again anyway.  Note that the end result of  this would be two signatures from you on the particular user ID.

@_date: 2008-11-11 12:06:13
@_author: David Shaw 
@_subject: GnuPG and PGP Compatibility 
Go right ahead.  Both PGP and GnuPG follow the same OpenPGP standard.

@_date: 2008-11-16 21:29:59
@_author: David Shaw 
@_subject: Question regarding s2k algorithms 
Yes.  This is the same issue with picking a symmetric cipher that your  recipient doesn't have.  When you're encrypting using --symmetric it's  your responsibility to pick algorithms that your recipient can handle.
No.  "S2K" means "String to Key".  There is no string to key  conversion in the session key.  s2k-digest-algo only applies to your  local secret protection in this case, so there is no issue with  asymmetric encryption.
I can't quite parse a question here.  Use the cipher for what?   Symmetric?  Asymmetric?  You need to state what you're trying to do.   Be specific.
It tags the data as "for your eyes only", which can be interpreted in  different ways by different clients.  GnuPG in particular won't  display it to the screen, but will save it to a file.  Note that this  feature is more of a "please don't display this file", than a "this  cannot be displayed".  It's just a hint.

@_date: 2008-11-16 23:24:13
@_author: David Shaw 
@_subject: Question regarding s2k algorithms 
The RFC says nothing about it.  CAST5 was chosen to maximize  compatibility with older versions of PGP, but not be as slow as 3DES.   If you specify --openpgp, it becomes 3DES.
It is used whenever a key needs to encrypted/decrypted with a  passphrase.  The huge majority of the time that is protecting secret  keys.  The other spot where this is needed is a little obscure:  creating a message with both passphrase *and* public key encryption.   That is, some recipients use their secret keys to decrypt, and some  recipients use a passphrase.  In this case, the s2k-cipher-algo is  used to encrypt the session key to the passphrase recipients (and like  all symmetric encryption, it's up to you to make sure those recipients  can decrypt it).
Don't like SHA1?  That's fine, and we give you the ability to change  it to something else, but then you become responsible for not shooting  yourself in the foot. :)
Use the defaults.  Really.  If we felt that overall there was a better  algorithm to use than the current default, we'd make that algorithm  into the new default.

@_date: 2008-11-17 13:07:59
@_author: David Shaw 
@_subject: appending to gpg file? 
Not really.  You can do this as a running append (i.e. keep a file
descriptor open to your gpg process and keep pushing data at it),
which would create one large file.  You can't do it with '>>' as that
creates multiple OpenPGP messages in a single file, which is not
required to be supported by an OpenPGP client.

@_date: 2008-11-17 15:01:58
@_author: David Shaw 
@_subject: appending to gpg file? 
(please don't top-post)
Do this:
  echo "my log line" | gpg --armor >> my_log_file.txt
(Use whatever gpg options you like.  The important bit is that you
have --armor in there)
You will end up with a log file that looks like this:
  -----BEGIN PGP MESSAGE-----
  (Lots of base64 stuff)
  -----END PGP MESSAGE-----
  -----BEGIN PGP MESSAGE-----
  (Lots of base64 stuff)
  -----END PGP MESSAGE-----
  -----BEGIN PGP MESSAGE-----
  (Lots of base64 stuff)
  -----END PGP MESSAGE-----
and so on.  To decrypt, split up the file so that each BEGIN/END pair
is in its own file, and decrypt that.
Note this is a pretty space-inefficient way to store things, but it
does answer your question of how to do it.  There might be a better
way to solve the original problem, but I'm not sure what what is from
your email.

@_date: 2008-11-17 15:18:34
@_author: David Shaw 
@_subject: Trust Signatures 
You do understand correctly.  This is a known bug in GnuPG, and will
be fixed for the next version.  If you have the ability to, I'd love
if you would try the patch at:

@_date: 2008-11-18 09:01:24
@_author: David Shaw 
@_subject: Key Format For Exchange 
You do:
   gpg --export 7351884D > carlos-key.gpg
He does:
   gpg --import carlos-key.gpg

@_date: 2008-11-18 09:13:54
@_author: David Shaw 
@_subject: Fetch smartcard key from disk 
It depends on whether you have built your GnuPG with libcurl or not.   Libcurl is a URL-fetching library that GnuPG can use to, well, fetch  URLs.  If you are using libcurl then yes, you can use 'file' URLs.  If  your GnuPG was not built with libcurl, the you can only use the 'http'  The easiest way to tell if you have libcurl support is to try doing:
   gpg --fetch-keys file://C:\smartkey.asc
If it works, then you're all set.  If it doesn't work, then you might  try building your GnuPG with libcurl support.

@_date: 2008-11-18 10:55:09
@_author: David Shaw 
@_subject: keyformat 
gpg --fetch-keys finger:rfrancoise/key at db.debian.org

@_date: 2008-11-18 15:57:43
@_author: David Shaw 
@_subject: Key Format For Exchange 
For specific instructions and software to use GnuPG in Thunderbird,
please refer to the Enigmail folks:

@_date: 2008-11-19 07:48:24
@_author: David Shaw 
@_subject: Fetch smartcard key from disk 
This allows you to generalize.  The card can store a URL to the key,  whether it's HTTP or FILE, or what have you.  --import only works for  local files.  The card "fetch" command works for all ways to get a key.

@_date: 2008-11-20 11:16:31
@_author: David Shaw 
@_subject: Supported Formats 
You can't do this.
There are two popular ways to encrypt mail, one is S/MIME and the
other is OpenPGP.  Your GnuPG key is OpenPGP.  The Verisign certs are
S/MIME.  The two are not interchangeable without very special surgery.

@_date: 2008-11-21 11:43:00
@_author: David Shaw 
@_subject: Error when compiling gnupg-1.4.9 
What happens if you build with ./configure --disable-asm ?

@_date: 2008-11-21 17:11:21
@_author: David Shaw 
@_subject: gnupg compilation problems on Solaris 10 64 bit 
GnuPG has some assembler code for doing math on large numbers.  Every
now and then a new platform has trouble with it until we tweak things.
--disable-asm uses portable C code instead of the assembly.

@_date: 2008-11-21 19:56:45
@_author: David Shaw 
@_subject: gnupg compilation problems on Solaris 10 64 bit 
There is a nonzero benefit to the assembly code, but it is not large.
On the 3ghz 32-bit Linux box I'm currently sitting in front of, 100
encrypts of a 2-byte file to a 1024DSA/4096ElG key takes 11.3 seconds
on average for the assembly version, and 13.0 seconds on average for
the portable C version.
Unless you're going a lot of public key operations in a row, any
difference is going to be dwarfed by other factors.

@_date: 2008-10-03 15:24:41
@_author: David Shaw 
@_subject: Secret Key Not Available 
It's not a question of the passphrase; rather, the key isn't there.
If it works from the command line but not from the scheduled job, then
I'd check for differences in the environment.  Possibly you have two
different GPG home directories when run in your two different ways.
Check for different GNUPGHOME variables as well as different home
directories for your different run methods.

@_date: 2008-10-04 11:43:33
@_author: David Shaw 
@_subject: What happens to the original files after encryption? 
The original files are untouched, and you can do whatever you like  with them.

@_date: 2008-10-04 18:01:29
@_author: David Shaw 
@_subject: Adding a UserID to Your Key 
[personal email removed for obvious reasons]
Let me get this straight - you posted someone else's personal and  encrypted mail on a public mailing list?  To scold them for using  words that bothered you?  Seriously?
Also, no.  You don't get to pick what words people use in their  emails, encrypted or not.  If you don't like certain words used by  certain people, it is your right to not communicate with them.  It is  not your right to lower the general level of communication to a level  you approve of.

@_date: 2008-10-05 19:47:30
@_author: David Shaw 
@_subject: Paperkey (some questions about its usage) 
No charset problems.   Paperkey uses only straight 7-bit ASCII  everywhere, to eliminate charset problems in re-entering the key data.

@_date: 2008-10-05 19:49:32
@_author: David Shaw 
@_subject: Paperkey for Revocation Certificates? (Feature-Request :-) 
Paperkey does its trick by removing everything unnecessary from the  secret key, and printing that out in an easily retyped (or OCRed)  format.  This works well for secret keys, as the secret bits are only  around 10-15% of the size of the key (most secret keys can be  represented in as few as 170 bytes, which can be easily retyped in a  few minutes).  A revocation certificate, on the other hand, doesn't  have all that much that can be removed.  Luckily revocation  certificates are pretty short to begin with.  The only real advantage  that paperkey could bring to revocation certificates is the per-line  CRC, which makes retyping easier.
Noteworthy changes in version 0.8 (2008-02-01)
     * The file format is now included as part of the base16 output, as
       there is no guarantee that this program will be on-hand when a
       reconstruction is necessary.  The format can also be displayed
       via the --file-format command.  Suggested by Brendan Kidwell.
     * Some bug fixes (actually to gnulib, but relevant here as well)
       to the SHA-1 code on platforms that require aligned access.
       Thanks to Peter Palfrader.
     * New --comment option to add comments to the base16 output.
No major difference - just some convenience stuff and a bug fix that  probably doesn't apply to you (you'd know it if you were on one of the  platforms that had the gnulib bug because paperkey wouldn't run at all).

@_date: 2008-10-05 22:02:35
@_author: David Shaw 
@_subject: Paperkey for Revocation Certificates? (Feature-Request :-) 
You could theoretically reconstruct the key using any reasonable  editor that works on binary files.  Paperkey just does the work for  you.  Brendan pointed out, rather reasonably, that after a key is  archived on paper for a long time, there may not be a copy of paperkey  handy to restore it.  Thus, paperkey prints out the file format (as a  human-readable comment) before the actual secret key data.  It's just  there in case someone needs it someday.

@_date: 2008-10-05 23:05:23
@_author: David Shaw 
@_subject: Paperkey (some questions about its usage) 
I certainly have no objection.  Paperkey, like GnuPG, is under the GPL  license, so you can do anything you like (including distribute it)  that is supported by that license.

@_date: 2008-10-06 11:17:55
@_author: David Shaw 
@_subject: GPG --symmetric option and passphrases 
Yes.  Unless you change that safe default with --s2k-mode.
By default, it's 65536 iterations.  The hash algorithm is SHA-1,  unless you change it with --s2k-digest-algo.
--s2k-count is what you're looking for:
        --s2k-count n
               Specify how many times  the  passphrase  mangling  is                  This  value  may  range between 1024 and 65011712  inclusive, and
               the  default  is  65536.   Note  that  not  all   values  in  the
               1024-65011712  range  are  legal  and  if  an  illegal   value is
               selected, GnuPG will round up to the nearest legal  value.   This
               option is only meaningful if --s2k-mode is 3.
As always, the defaults here are safe.  Don't change them unless you  know what you're doing.

@_date: 2008-10-06 13:24:32
@_author: David Shaw 
@_subject: Maximum file size 
There are quite a few bits and details around this, but in general, it
is whatever the maximum file size your OS supports.
How big are the files you're talking about?

@_date: 2008-10-06 13:44:40
@_author: David Shaw 
@_subject: GPG --symmetric option and passphrases 
There is no limit in OpenPGP for a passphrase length, beyond that of
the inherent limit imposed by the hash used for string-to-key
conversion.  So, for SHA-1, the passphrase can be up to 2^64-1 bits,
or just under 2 exabytes.  In practice, however, that's an insane size
for a passphrase (around 457 million DVDs worth if my back of the
envelope scribble is right) and no OpenPGP implementation supports
anything near that.  GnuPG in particular will take whatever you give
it, but it must be able to fit in memory (and secure memory to boot,
on those platforms that support it).  You can probably get a few kb,
but not much more.
Obviously, your 128-digit hash (how are you getting 128 digits out of
Whirlpool anyway?  512 bits / 8 == 64 bytes) is well under the limit
and would work fine, but note that 128 digits is 1024 bits - well over
the largest key size of a symmetric cipher in GPG (256 bits).  You're
not really adding security at that point.  Even if you're using the
Whirlpool text output as the passphrase (which is the only way I can
see getting 128 digits out of Whirlpool), you are putting in 512 bits
of real input, which is still at least twice as large as the symmetric
Be careful you don't shoot yourself in the foot here.

@_date: 2008-10-06 13:56:36
@_author: David Shaw 
@_subject: Computational Efficiency of GnuPG ciphers and hashes 
AES is probably the fastest cipher in GPG, and MD5 is probably the
fastest hash (which doesn't make it good, just fast).
Measure it yourself.  Get some big file, and do this:
for i in 2 3 4 7 8 9 10; do echo "Trying cipher $i" && time gpg \
--cipher-algo S$i --yes --batch --passphrase test --symmetric ~/my-big-file \
&& echo && echo; done

@_date: 2008-10-06 14:03:05
@_author: David Shaw 
@_subject: Paperkey for Revocation Certificates? (Feature-Request :-) 
Good point.  I'll consider that, but in the meantime, note that you
can do something like this:
  gpg --gen-revoke (thekey) | gpg --dearmor | od -tx1

@_date: 2008-10-06 22:07:06
@_author: David Shaw 
@_subject: GPG --symmetric option and passphrases 
At least in the context of OpenPGP, I think you're confusing cipher  key size with hash size.  A hash is used to convert a passphrase to a  key that can be used in a cipher.  This is called a string to key or  S2K function.  The OpenPGP S2K function basically takes the  passphrase, adds salt, then hashes this blob over and over.  The  result is used as the key.  (I'm simplifiying - the exact details are  in RFC-4880).  In other words, the key is going to be 128 (or  whatever) bits no matter what you do.
No, it's "only" 2^128-1, but let's put this in perspective.  That  number is around 7 times larger than the number of atoms contained in  every human being on planet earth.

@_date: 2008-10-06 22:21:59
@_author: David Shaw 
@_subject: Paperkey for Revocation Certificates? (Feature-Request :-) 
Why would you use uuencode, when GPG actually has that built in?
   gpg --armor --export-secret-keys
But you seem to be missing the point.  Uuencode (or GPG armor) creates  lines that are very difficult to type in.  There are no spaces, and  the character set includes uppercase, lowercase, numbers, and  symbols.  There is no CRC to help you type it back in again, so if  there is an error, you must proofread the whole file.  Plus, as you  say, it's around 100 lines long.
The same key run through paperkey is only the letters A-F and numbers  0-9.  There are per-line CRCs so if there is a problem, you know which  line to examine.  And it's just 10 lines long.  A bit easier to  handle, no?

@_date: 2008-10-07 13:10:53
@_author: David Shaw 
@_subject: Attribute 'comment' 
It depends on what you mean by 'comment'.  If you mean the comment
that is part of your user ID, as in:
  My Name (my comment) Then no, you can't change it.  You can, however, make a brand new user
ID with a different comment (or no comment at all).  To do this, run
"gpg --edit-key (your key)" and then enter "adduid".

@_date: 2008-10-10 18:23:27
@_author: David Shaw 
@_subject: Difference in Public Key 
The different base64 packing is not relevant to the functioning of the
key.  Do you see a difference besides that?

@_date: 2008-10-13 15:47:53
@_author: David Shaw 
@_subject: Is there an easy way to know...? 
Sure, use Wotsap:
   Plug your keyid into the "Key statistics" section, and you'll get a
list of everyone who signed that key, and everyone who that key
Note that this only works if those keys (and sigs) were uploaded to
the keyserver net.

@_date: 2008-10-13 16:42:46
@_author: David Shaw 
@_subject: New subkey or edit expiration date? 
It's somewhat a matter of taste as there is no one right answer.
Either way, you need to redistribute your key (usually just reupload
to a keyserver).
I'd make the new subkeys, personally, but then I tend to like a longer
expiration time than 2 years.  If you make new keys every 2 years,
your key will eventually get pretty big.

@_date: 2008-10-13 16:50:10
@_author: David Shaw 
@_subject: Recovered files from Ext USB drive but in GPG format 
Are these really GPG files, or just files that happen to have a .gpg
filename extension?  Were you using GPG in the first place, or is this
some artifact of the file recovery process looking at files and
thinking they were GPG files?

@_date: 2008-10-13 17:56:44
@_author: David Shaw 
@_subject: Difference in Public Key 
If it is intermittent, then it is likely not your key.  If your key
was corrupt in some manner, it would fail reliably.

@_date: 2008-10-14 19:39:41
@_author: David Shaw 
@_subject: About UIDs 
Neither.  Signatures only contain the key ID of the key making the  signature.  When displaying signatures, GPG shows the primary UID of  that key at display time.  In other words, if you sign a key with one  primary UID, then make another UID primary, the display will change to  show the new primary.
There is, incidentally, a way of encoding which UID the signer "meant"  the signature to be from.  It's part of the OpenPGP standard, but no  software that I know of actually uses it.

@_date: 2008-10-15 20:36:36
@_author: David Shaw 
@_subject: Decrypting with private key and public key is missing 
There is a lot that doesn't follow here.  The --allow-secret-key- import command is a no-op in version 1.4.9, so if you had to use it to  import your key, then you're not using 1.4.9.
Also, if you were using 1.4.9, when you imported your secret key, it  would automatically create a public key for you.  This is built in,  and is on by default.
Finally, that error message means that your secret key was not, in  fact, imported.  It says nothing about your public key.
Given all of that, I suspect you didn't import your secret key after  To import a secret key, do:
    gpg --import (the secret key file)

@_date: 2008-10-16 23:48:05
@_author: David Shaw 
@_subject: add subkey vs generate new set? 
It depends on how many signatures you have.  If you have none, or just  a handful that could be easily gotten again, then it doesn't matter  much.  Otherwise, there is a real benefit to adding subkeys to your  existing key.
It is not true, though, that you need continually bigger keys to be  secure.  You just need (somewhat) bigger keys than the current best  attack to be secure.   The default size in GPG is 2048, which is  extremely safe.  When in doubt, use the default.

@_date: 2008-10-17 10:48:59
@_author: David Shaw 
@_subject: add subkey vs generate new set? 
4 years ago the default was different.  We keep the defaults at
reasonable settings as the world and GPG grows.

@_date: 2008-10-20 22:55:50
@_author: David Shaw 
@_subject: There is no limit on the length of a passphrase, 
There is no limit in OpenPGP for a passphrase length, beyond that of  the inherent limit imposed by the hash used for string-to-key  conversion.  So, for SHA-1, the passphrase can be up to 2^64-1 bits,  or just under 2 exabytes.  In practice, however, that's an insane size  for a passphrase (around 457 million DVDs worth if my back of the  envelope scribble is right) and no OpenPGP implementation supports  anything near that.  GnuPG in particular will take whatever you give  it, but it must be able to fit in memory (and secure memory to boot,  on those platforms that support it).  You can probably get a few kb,  but not much more.
Rethink what you're trying to do.

@_date: 2008-10-21 10:37:46
@_author: David Shaw 
@_subject: Session Key Questions 
It is the key size of your symmetric cipher.  So AES256 == 256 bits,  AES128 == 128 bits, etc.

@_date: 2008-10-21 11:49:02
@_author: David Shaw 
@_subject: Session Key Questions 
You're close.  It's the leftmost bits.
RFC-4880, section 3.7.1.1:
   If the hash size is greater than the session key size, the
   high-order (leftmost) octets of the hash are used as the key.
RFC-4880, section 3.7.1.1:
   If the hash size is less than the key size, multiple instances of
   the hash context are created -- enough to produce the required key
   data.  These instances are preloaded with 0, 1, 2, ... octets of
   zeros (that is to say, the first instance has no preloading, the
   second gets preloaded with 1 octet of zero, the third is preloaded
   with two octets of zeros, and so forth).
In other words, there are multiple hash contexts run, each responsible
for a different part of of the key (0-159 & 159-255 in your SHA1 and
AES256 example).
SHA1, and yes, it is the s2k-digest-algo.  S2K isn't only for key
protection.  It's for any time you need to convert a string to a key.

@_date: 2008-10-21 13:32:35
@_author: David Shaw 
@_subject: Session Key Questions 
No.  With SHA1 and AES256, you set up two SHA1 contexts.  The first
one (the one that will become 0-159) is left alone.  The second one
(the one that will become 160-255) gets a zero pushed in.  Now, take
the passphrase, add 8 bytes of random salt to the front of it.  Take
that blob and feed it to each hash context over and over until you
reach the defined byte count (65536 by default).
Section 3.7.1.3 of RFC-4880 gives the exact details.
No.  They're just random.  There is no point in salting and hashing
already-random data.  That is just for turning a passphrase into a
8 bytes, prepended.

@_date: 2008-10-21 14:59:18
@_author: David Shaw 
@_subject: Key ID format: short or long? 
Personally, I'd put the whole fingerprint on there (and in fact, that
it what I do).  It's not terribly long, and it is the most-specific
way to specify a particular key in OpenPGP.

@_date: 2008-10-21 16:00:43
@_author: David Shaw 
@_subject: Key ID format: short or long? 
That is the best of all worlds.  I have both on my business cards.

@_date: 2008-10-22 23:19:19
@_author: David Shaw 
@_subject: set type digest mode? 
personal-digest-preferences sha256 ripemd160 sha1 etc

@_date: 2008-10-22 23:55:13
@_author: David Shaw 
@_subject: set type digest mode? 
No.  Do this and you shoot yourself in the foot.  It violates the  OpenPGP protocol.

@_date: 2008-10-22 23:57:00
@_author: David Shaw 
@_subject: Key ID format: short or long? 
Or just search on the fingerprint directly:
   gpg --recv-keys 7D92FD313AB6F3734CC59CA1DB698D7199242560

@_date: 2008-10-23 00:00:43
@_author: David Shaw 
@_subject: Key ID format: short or long? 
I use both key ID and fingerprint even though the key ID is  redundant.  It lets me avoid explaining to people that the last 8  digits are the key ID.  As we've seen here, that's not widely  understood.  Plus, it may not be true forever.  One of the proposals  for future key formats has the key ID being the *first* 8 digits,  rather than the *last*.

@_date: 2008-10-23 14:40:14
@_author: David Shaw 
@_subject: DSA2 (was Re: set type digest mode? plus other query) 
That is the common setup.  I'd go with it unless there is an active
reason not to.
I'm not sure what your question is here.  If your key is 1024 bit DSA,
then you can only use a 160 bit hash with it, which means either SHA-1
or RIPEMD-160.  If your key is 1024 bit DSA and you have --enable-dsa2
set you can use any hash you like that is 160 bits or greater.  You
can never use MD5 with any DSA, as it is only 128 bits long.  Every
other hash in OpenPGP is 160 bits or greater.

@_date: 2008-10-24 20:42:14
@_author: David Shaw 
@_subject: PGP 6.5.8 ckt, 
gpg --edit-key (thekey)
Please don't anyone take that to mean that I think people should use  6.5.8ckt.  I really don't.

@_date: 2008-10-28 12:00:07
@_author: David Shaw 
@_subject: PGP 6.5.8 ckt,?just say no. 
Now that is an... interesting key.  It's a V4 (OpenPGP) key with V3
(PGP 2.x) binding signature).  GPG won't cross-certify such a key
because it is a one-way change.  Once cross-certified, the binding
signature will be V4 (OpenPGP).  Note that you can't change the
expiration date of the subkey on that key either (for the same

@_date: 2008-10-29 15:22:39
@_author: David Shaw 
@_subject: PGP 6.5.8 ckt,?just say no. 
Unfortunately not.  It's doable via various hackery by modifying the  GPG source, but there is no feature that will do that.

@_date: 2008-10-31 14:14:09
@_author: David Shaw 
@_subject: Use of gen-random 
============================== START ==============================
I think the confusion here is in the name "gen-random", which implies
it generates randomness out of nothing.  In fact, it generates
(pseudo) randomness from an entropy pool.  In the process, the
contents of the pool are used up and need to be replaced.
The details of that pool vary from platform to platform, and vary
fairly widely between Unixish and Windows systems.  Very basically,
the computer watches for the timings and details of certain events
(keyboard input, disk performance numbers, etc), and uses them as the
source of what goes in the pool.  When a random number is needed, data
from the (well-stirred) pool is used to help deliver it.
Thus, if you read random numbers, you are in fact tapping a limited,
but renewable, resource.  In practice, this isn't a particularly big
deal.  Keep using your computer, and the pool will refill itself.
It's only a problem if you consume randomness faster than it can be
An excellent source of information on random number generation:

@_date: 2008-09-01 10:24:44
@_author: David Shaw 
@_subject: CTB=55 cannot decrypt message from PGP 9 because of comment line 
This come up now and then.  The problem, as you noted, is the comment  line.  Basically, the PGP comment line is long enough that many  mailers word-wrap it.  Thus, the message that gets passed to GPG is  something like:
  -----BEGIN PGP MESSAGE-----
  Version: PGP 8.0.2 - not licensed for commercial use:
    qANQR1DBw04Dxrpn2akpjMkQD/457fxRygbnZG7jAssMb4JuMeXqZdXmMhcGetrm
  ...
  -----END PGP MESSAGE-----
Note the " wrapped to the next line.  There isn't much you  can do about it except check the various word-wrap settings involved.   Some mailers are 'helpful' and break the line in two.

@_date: 2008-09-02 14:12:11
@_author: David Shaw 
@_subject: Automate decryption 
Sure.  Storing the passphrase on disk just means that you stick it in
the script you use to call gpg, and give the passphrase right on the
command line:
  gpg --passphrase foobar --encrypt ... etc.
Or you can put it in a file and give gpg the filename:
  gpg --passphrase-file my-passphrase.txt --encrypt ... etc.
The danger here is that if someone can steal the script or the
passphrase file, then they have the passphrase for your key.  In most
cases, you can protect the passphrase file or script so that
unauthorized users cannot read them, even if they can log into the box
in question, but in practice, it is usually best to assume that anyone
who can log into a box can subvert this.  That doesn't mean there is
no point in protecting the file, of course, just that the file
protection should be regarded as something that will slow the attacker
down (perhaps a lot, depending on the abilities of the attacker), and
not something that will stop them cold.
Running without a passphrase just involves removing the passphrase
from the key altogether:
  gpg --edit-key (thekeyid)
  passwd
    (just hit enter for the new passphrase)
  save
In most uses, it's more or less as secure as storing a passphrase on
disk or in a script: just protect the secret key file (secring.gpg)
instead of protecting a passphrase file.  It's simpler than the above,
which is appealing as well.
This is such a common request, I wonder if we should be looking for
better solutions.  The big problem is that most of the obvious
solutions require a human being at some point to type a passphrase,
which is fine for desktop machines, but is a nonstarter for server
machines that need to be able to run in a lights-out environment
without a human being anywhere near them.  Without a change to the
fundamentals of the question, it's hard to see an alternative: the
server needs to boot without human assistance, therefore the key needs
to be accessible to the server.  If the key is accessible to the
server, it is accessible to someone who cracks the server...

@_date: 2008-09-03 17:24:06
@_author: David Shaw 
@_subject: CERT fails with LDAP URL 
I can't really help you without details, specifically the
"email at address" from above.  You can send that to me off-list if you

@_date: 2008-09-03 18:22:27
@_author: David Shaw 
@_subject: Controlling number of passphrase attempts 
Your best bet is to just return an empty string to the second and
third "GET_HIDDEN passphrase.enter" command prompt, if you don't want
to keep trying.

@_date: 2008-09-04 12:06:33
@_author: David Shaw 
@_subject: CERT fails with LDAP URL 
(Alex sent me the necessary information to diagnose this off-list)
This is actually working correctly.  CERT is not intended to pass a
keyserver address (like ldap://keyserver.pgp.com), but rather a
complete URL to the key (like That said, I don't see any harm in accepting a keyserver address in a
CERT in addition to full URLs.  I'll change the code to permit that in
the future.

@_date: 2008-09-05 13:32:58
@_author: David Shaw 
@_subject: Protect pubring.gpg and secring.gpg 
Which doesn't mean you should post your secring.gpg file on the web
somewhere.  That file, plus your passphrase, allows access to your
keys, so it's reasonable to take some care with it, but even if you
did post secring.gpg somewhere, a good passphrase would protect it.
pubring.gpg is supposed to be public.

@_date: 2008-09-05 17:00:22
@_author: David Shaw 
@_subject: Passphrase storage (was Re: Protect pubring.gpg and secring.gpg) 
Diceware does make an excellent passphrase, and I've found that people
can remember even the long ones... so long as there are only a few of
them to remember.  Past a certain point (and obviously that point
varies from person to person), you need some outside-of-your-brain way
to remember these things.
Out of curiousity, is anyone using one of the various passphrase
manager sort of programs?  Assuming they're implemented and used
correctly, they're not a bad solution for passphrase overload.

@_date: 2008-09-05 18:02:59
@_author: David Shaw 
@_subject: Protect pubring.gpg and secring.gpg 
No need.  The keys in secring.gpg are already encrypted.  That's why
you need a passphrase to use them :)

@_date: 2008-09-08 18:22:00
@_author: David Shaw 
@_subject: Someone has harvested my address 
There are (alas) many other ways for an address like that to leak.  If
anyone on the list has a compromised box, the malware often takes
copies of addresses from email on the box to send spam to.
My favorite example of this is a list I run for members of my family.
There are only 14 people on it, it's not archived anywhere, and the
list isn't even visible on the list server box.  A few months back, a
cousin got hit with some malware... and now the list gets dozens of
spams a day from around the world.

@_date: 2008-09-09 17:05:29
@_author: David Shaw 
@_subject: Someone has harvested my address 
You can't, of course, so it would be a short conversation :)
An owned PC is such a game over item (and such a general attack) that
it is usually ignored in the threat model.  If you think your PC is
not controlled by you, then you need to fall back on other methods of
communication until you can rectify that situation.

@_date: 2008-09-10 08:49:09
@_author: David Shaw 
@_subject: verifying of my own messages fails 
It is true that pgp.mit.edu is broken (in that it doesn't handle  subkeys correctly), but ldap://keyserver.pgp.com is not broken.  All  of the LDAP servers handle subkeys correctly.

@_date: 2008-09-11 17:50:58
@_author: David Shaw 
@_subject: Someone has harvested my address 
Teach good security hygiene.  Imparting knowledge is pretty much the
only thing you can do here.  People need to know why they should use
an OS that isn't a petri dish of infections, but that even discarding
Windows doesn't make you perfectly safe.
The quest for *perfect* safety is a doomed one from the start - you
can always come up with some reason (however impractical in the real
world) why it's not secure enough.  Past a certain point you have to
say you did the best you could, and move on.  That point, of course,
varies widely depending on whether you're emailing your friend about
going to the movies, or emailing your local revolutionary cabal about
taking over the country.
So, for a 1-sentence response, how about "Using GPG doesn't make you
perfectly secure: it just makes you a heck of a lot more secure than
you'd be without it."

@_date: 2008-09-11 17:55:25
@_author: David Shaw 
@_subject: Someone has harvested my address 
This question reminds me of the Alice and Bob dinner speech:
  Against all odds, over a noisy telephone line, tapped by the tax
  authorities and the secret police, Alice will happily attempt, with
  someone she doesn't trust, whom she cannot hear clearly, and who is
  probably someone else, to fiddle her tax returns and to organize a
  coup d'etat, while at the same time minimizing the cost of the phone
  call.
If you haven't read it, it's quite funny:

@_date: 2008-09-15 18:24:07
@_author: David Shaw 
@_subject: unix : gpg --import not importing the public keys 
Your version of GPG on Unix is old enough that it can't create a  public key from a secret key automatically.  Upgrade it.

@_date: 2008-09-15 18:26:09
@_author: David Shaw 
@_subject: Signature Question 
Not enough information to say.  Please show an example of an old  signature, and a new signature.  It has nothing to do with "DSA" or  "DSA/SHA".  That's just a human-readable message.  Unless you did  special configuration, all DSA signatures are DSA/SHA.

@_date: 2008-09-15 18:29:30
@_author: David Shaw 
@_subject: Signing Problem after Moving GPG and Keys 
Please clarify.  You state both that there is "no signature" and also  that the "signature doesn't pass".  Is there a signature on the file  or not?

@_date: 2008-09-16 10:28:19
@_author: David Shaw 
@_subject: Export secret key from WinXP (GnuPG) 1.4.7 to AIX PGP Version 
PGP 6 is really, really old.  It predates some of the OpenPGP  standard, so I suspect a passphrase encoding problem between the two  programs.  I suggest removing the passphrase completely (just hit  enter when asked for the new passprase), then copying the key over to  PGP, and changing the passphrase to what you want it to be.
That said, a signal 11 is a segfault.  If PGP is actually *crashing*,  there isn't much you can do.

@_date: 2008-09-16 13:26:21
@_author: David Shaw 
@_subject: Export secret key from WinXP (GnuPG) 1.4.7 to AIX PGP Version 
Mid-2000, I think.
No way to guess.  It's a segfault, so something is clearly very
broken.  A sane program would print an error instead of crashing.
Probably not, unless the person you are communicating with is using
PGP 2.x from the 1990s (don't laugh - some people still are).  Just
update your key like this:
 gpg --edit-key (thekey)
 setpref
 save
No.  IDEA is an optional part of PGP, and 3DES will be used instead.
Whether your recipient will be able to decrypt depends on whether
they're stuck with PGP 2.x.
Yes.  GPG, and every algorithm supplied with GPG is free for use in
any way you want to use it.
IDEA is a different beast.  It is not shipped as part of GPG, and
requires a license for commercial use.  You can add IDEA to GPG via a
plugin or special compilation, but don't.  Unless your situation is
extremely special, you don't need IDEA.  Just ignore it.
Bottom line: don't use PGP 6 (you can't use it for commercial use
without a license and I'm fairly sure there is nobody who will sell
you a PGP 6 license at this point anyway).  Use a recent GPG or a
recent PGP.  Don't even get involved with IDEA unless a specific
customer has a problem, and asking that customer to upgrade isn't an
option.  There is a lot of code in both GPG and PGP to make all these
cipher and version questions invisible to the outside world.  Let the
system do the work for you.

@_date: 2008-09-16 18:32:30
@_author: David Shaw 
@_subject: Export secret key from WinXP (GnuPG) 1.4.7 to AIX PGP Version 
Yes.  Even though the key specifies IDEA as a cipher, modern OpenPGP
systems (GPG or PGP) will both use 3DES as an alternative if they do
not have IDEA.
That's one way - even better would be to just send them a sample
encrypted message and verify they can decrypt the thing.  If it works,
it's proven.  If it doesn't work, you'll be in a good place to debug.
I think that information is a little out of date.  AIX since v5.2 has
had a /dev/random that is based on Yarrow.  Assuming that there isn't
some bug in their implementation (a point on which anyone's guess is
as good as mine), AIX should do just fine.
for a bit more info about the AIX random number generator.

@_date: 2008-09-17 00:15:21
@_author: David Shaw 
@_subject: GnuPG ElGamal Signing Key 
There was a bug in the Elgamal signing key code in GPG back then.   There is no longer a bug... and there is also no longer Elgamal  signing key code.  Elgamal signing keys were dropped from the OpenPGP  standard in RFC-4880, and so will not be supported in GPG.
Yes, but not in OpenPGP.

@_date: 2008-09-17 01:00:39
@_author: David Shaw 
@_subject: GnuPG Defaults 
There were many reasons behind it, but a significant one was that DSA  signing keys and Elgamal encryption keys were not patented.  It is  difficult to establish a new protocol if a major chunk of it is  patented.  SHA1 was the state of the art hash then, and an obvious  AES256 is not the default cipher.  3DES is.

@_date: 2008-09-17 01:07:04
@_author: David Shaw 
@_subject: GnuPG Defaults 
3DES is the default cipher for every and all OpenPGP compliant program.
I'm not sure what you mean by "session key cipher".  Elgamal, like  RSA, is a public key (aka "asymmetric") algorithm.  It was chosen  largely because it was patent-free, and at the time, RSA was most  certainly not.

@_date: 2008-09-17 11:51:28
@_author: David Shaw 
@_subject: Export secret key from WinXP (GnuPG) 1.4.7 to AIX PGP Version 
We're both right with regards to the facts of PGP 2.x.  With all due
respect to Robert, I'm right with regards to whether it'll work.
The situation, underneath it all is this: You have a modern OpenPGP
program.  Your correspondent has, or can be made to have, a modern
OpenPGP program.  Your correspondent's key is a V3 key (the so-called
"PGP 2.x" key).
OpenPGP does just fine with V3 keys.  The spec says:
   OpenPGP implementations MUST create keys with version 4 format.  V3
   keys are deprecated; an implementation MUST NOT generate a V3 key,
   but MAY accept it.
Both GPG and PGP follow that MAY, and happily accept V3 keys.  Since
you are the one doing the encrypting, and you are running GPG, and
your GPG does not have IDEA, you will encrypt using 3DES.  Your
correspondent, receiving this message will be able to decrypt it as
3DES is required by all OpenPGP programs.
As I said before, try it.

@_date: 2008-09-17 11:53:44
@_author: David Shaw 
@_subject: Export secret key from WinXP (GnuPG) 1.4.7 to AIX PGP Version 
I should add, though, that unless there is some reason why you need to
use that old V3 key, an arguably better solution would be to just ask
your correspondent to generate a new key...

@_date: 2008-09-17 12:15:09
@_author: David Shaw 
@_subject: GnuPG Defaults 
For several reasons, firstly, it's pure crypto conservatism.  Don't
use n+1 algorithms where n could work.  The other reason is more
practical - as can be seen by the never-ending discussion over IDEA,
and the "will version X work with version Y" questions, there is some
benefit to knowing that everyone can handle the same algorithms.  When
the decision was made to only include a subset of algorithms in the
default preference list, PGP didn't fully support preference lists,
and this spawned a whole array of "--pgp6", "--pgp7, "--pgp8" options
to tell GPG who was on the other side.
Nowadays, PGP fully supports preference lists, but we've stuck with
the shorter cipher list.  It's simpler, and simpler is usually better
in the crypto world.
No.  If you don't specify, GPG will take the union of every cipher
preference on every key you are encrypting to.  It will pick the
cipher from that list.  If that list is empty, it will pick 3DES.

@_date: 2008-09-17 12:16:40
@_author: David Shaw 
@_subject: GnuPG Defaults 
This is up to you.  You can list whatever algorithms you want to
accept on your key.  Your key, your rules.  Someone elses key, someone
elses rules.  OpenPGP will automatically pick an algorithm that is
acceptable to everyone.

@_date: 2008-09-17 12:21:42
@_author: David Shaw 
@_subject: Session Key Questions 
I think you're confusing the notion of the "default" algorithm with
the "preferred" algorithm.  The default algorithm in OpenPGP is 3DES.
It is the algorithm that is always available, and everyone must
accept.  There is a preference system within OpenPGP that allows
people to specify what they might like more than 3DES, and if it is
possible, OpenPGP will give people what they like.
When you generate a new key with GPG (and PGP too, for that matter), a
preference is set for AES256.  This means that AES256 will be chosen
in most cases.  3DES is still the default though.

@_date: 2008-09-17 14:01:46
@_author: David Shaw 
@_subject: Session Key Questions 
Symmetric encryption algorithm choices are not specified in RFC-4880.
Secret key protection algorithm choices are not specified in RFC-4880
If you drive a manual-shift car, you are responsible for shifting.
Why would you do something that is a) more complex, b) less secure,
and c) very prone to failure?  There are standard ways to do these
things.  Sure, you can force it to break if you try hard enough, but
why would you want to?
Secret key protection algorithm choices are not specified in RFC-4880.

@_date: 2008-09-17 16:31:49
@_author: David Shaw 
@_subject: Someone has harvested my address 
Yes.  This isn't new though - just updated for the modern era.  We
could rewrite that sentence many different ways, ranging from:
  "Whispering doesn't make your communications perfectly secure:
  however, it potentially makes your communications a heck of a lot
  more secure than you'd be without it."
  "Isolating yourself in a faraday cage on a deserted island doesn't
  make your communications perfectly secure: however, it potentially
  makes your communications a heck of a lot more secure than you'd be
  without it."
There is always some way to lose the benefits of whatever tool (GPG,
whispering, etc) you are using.

@_date: 2008-09-18 00:33:38
@_author: David Shaw 
@_subject: Changing preferences 
I disagree with this.  The preference system is for preferences, not  capabilities.  Most installations are capable of using many more  algorithms than are present in the preference list (GPG is capable of  using Blowfish and Twofish, but doesn't list them by default).  The  point of the list is to indicate the algorithm that the user prefers,  in the order that the user prefers.  There is an assumption that a  user won't prefer an algorithm that they are not capable of, but that  is reasonable: most users prefer to be able to read their incoming

@_date: 2008-09-18 00:43:21
@_author: David Shaw 
@_subject: Changing preferences 
You say you modified your preferences in gpg.conf - how?  There are a  few things regarding preferences in gpg.conf, but few of them impact  Showpref shows what the preferences are on the key itself.  These are  the preferences that other users who are encrypting to you will use  for you.  Obviously, your gpg.conf cannot be consulted by the other  users :)
If you want to alter the list of preferences on your key, do this:
  gpg --edit-key (thekey)
  setpref aes256 sha512 bzip2 blah blah blah
  save
Put the algorithms you like best first in the list, and you can freely  mix cipher, hash, and compression algorithms.  You can also use "mdc",  "no-mdc", "ks-modify", and "no-ks-modify" to enable and disable the  MDC and keyserver modify flags.  MDC defaults to on, ks-modify  defaults to off (i.e. don't allow modification).
Note that you can specify a different set of preferences for each user  ID.  This is a handy feature, as it lets you express things like "I  want to use AES256 for home stuff, but my work address requires 3DES  by policy".

@_date: 2008-09-18 13:07:39
@_author: David Shaw 
@_subject: Changing preferences 
This is not true.  GPG will never use a cipher that the recipient does
not prefer.  It may not use the recipient's  choice, but it will
always use something from the recipient's list.
It's not always simple to calculate what cipher should be used.  For
Alice:   AES256 TWOFISH
Baker:   TWOFISH AES256
Who wins?

@_date: 2008-09-18 15:03:49
@_author: David Shaw 
@_subject: Changing preferences 
No.  GPG finds the intersection of all of the recipient cipher lists,
and then picks one from that intersection.  That's it.  It may not be
clear because people keep thinking the sender is somehow involved in
I wasn't clear enough.  I was imagining the message was sent by
Charlie, and both Alice and Baker are only recipients.  There is
nothing to pick a "winner" here.
It was answered in 4880:
  When encrypting to more than one recipient, the implementation finds
  a suitable algorithm by taking the intersection of the preferences
  of the recipients.  Note that the MUST-implement algorithm,
  TripleDES, ensures that the intersection is not null.  The
  implementation may use any mechanism to pick an algorithm in the
  intersection.
Note what that says and what it doesn't say.  Firstly, it says nothing
about the sender.  That is appropriate, as the sender (unless they are
also a recipient) is not really relevant here.  Note also that the
"implementation may use any mechanism to pick an algorithm in the
intersection".  In other words, in the Alice/Baker example above,
AES256, TWOFISH, and 3DES are equally valid.
GPG, in an effort to give senders a bit more control, has the
personal-*-preferences lists.  This is legal because of the "any
mechanism" language above.  It basically lets the sender pick from
within the list that the recipients generate, and not incidentally
"ban" certain ciphers from use by not mentioning them.
I think it is.  The point is to communicate and agree on *any* common
cipher (even if it ends up being 3DES), and the preferences system
ensures that can happen.
For those people who really care that they only use certain ciphers,
that's what personal-*-preferences is for.
Sure, it would be possible to implement a weighting scheme so that in
cases like:
  Alice:   AES TWOFISH CAST5
  Baker:   TWOFISH AES CAST5
  Charlie: CAST5 AES TWOFISH
...we'd pick AES, because it was the most "popular" cipher.  Does this
really buy us very much?  By listing those three ciphers, Alice,
Baker, and Charlie have already indicated their willingness to receive
traffic encrypted by *any* of the three.  If they didn't want to get
traffic with (for example) TWOFISH, they shouldn't have listed it in
their preferences.
OpenPGP doesn't care either way.  The "any mechanism" wording ensures

@_date: 2008-09-18 15:42:09
@_author: David Shaw 
@_subject: Export secret key from WinXP (GnuPG) 1.4.7 to AIX PGP Version 
It's the correct question to ask.  They should be fine, but the best
way to know that for sure is to do exactly the test you propose.
It means "there is no MDC here".  An MDC is a Modification Detection
Code, which is one of the features of OpenPGP.  It protects against
certain forms of message tampering.  This key does not have the flag
that indicates MDC support, so GPG isn't turning the protection on.
The flag is part of OpenPGP, so that v3 key would naturally not have
"Legacy" is just a human term.  The question you have is whether it
can decrypt 3DES traffic.  Run the test you suggest above, and then
you'll know for sure.  I expect it will work.
Given what software they are using, and given the usual relucatance to
rip out a working system, I can understand why your customer would not
want to change keys, but note that there are a few not-small security
benefits in upgrading.  First step is to get things working, though.
After that there is time to worry about future work.

@_date: 2008-09-18 15:50:00
@_author: David Shaw 
@_subject: Doe MediaCrypt (IDEA) exist anymore? 
Good luck.  The mediacrypt web page has been offline for months.  I'd
suggest contacting MediaCrypt AG via the address given in their domain
registration.  See  You
also might try contacting someone at Ascom: I don't know your situation, of course, but I do know that in
virtually all cases, people don't actually need IDEA, and can do just
fine without it.

@_date: 2008-09-18 17:15:06
@_author: David Shaw 
@_subject: Changing preferences 
The preferences on the keys are used by people encrypting a message
*to* those keys.  It indicates that algorithms the keyholders prefer.
The personal-*-prefs are used by the sender.  It indicates which
algorithms within the above list the sender is willing to use.

@_date: 2008-09-18 20:00:13
@_author: David Shaw 
@_subject: Changing preferences 
Correct.  The sender is king here, and what the sender prefers is more  important than what the recipient prefers.  Note, though, that the  sender cannot prefer a cipher that a recipient does not prefer.  The  recipient must be at least willing to accept the cipher or the sender  cannot prefer it.
4880 says "The symmetric algorithm preference is an ordered list of  algorithms that the keyholder accepts." so the spec is an ordered  list.  The spec gives implementations a fair bit of leeway in  interpreting this ordered list, and so anything from scoring each  algorithm and choosing the one with the best score to arbitrarily  picking the 3rd item every time is valid, in terms of the standard.
GnuPG in particular works like this:
1) Take the intersection of all recipients preference lists.  This  rules out any algorithms that would be unusable by someone.
2) Elect a "decider".  The decider is the one person whose ordered  list we will honor the rankings for.  If the user has specified a  personal-*-prefs list, then the user is the decider.  If the user has  not specified a list, then the last recipient key is used.
3) Walk the decider preference list from highest ranked to lowest  ranked - as soon as we hit an algorithm that is part of the  intersection from step  stop.
For example:
  Alice has AES CAST5 TWOFISH
  Baker has CAST5 AES BLOWFISH
  Charlie has BLOWFISH AES CAST5
  Donald has CAMELLIA TWOFISH BLOWFISH
Assuming that there is no personal-*-prefs list set), here's how it  falls out:
   Alice Baker Charlie == AES
   Baker Alice Charlie == AES
   Charlie Alice Baker == CAST5
   Charlie Alice Baker Donald = 3DES

@_date: 2008-09-20 21:56:21
@_author: David Shaw 
@_subject: header field causing problem 
It looks like the message was slightly corrupt.  Specifically, there
is a blank line after the "Charset" header and before the "Version"
header.  That's an invalid file - there is supposed to be only one
blank line, and it comes right before the base64 data.
I'm not sure what generated that message.  I know it claims to be GPG
1.4.9, but GPG doesn't use the Charset header, so at least that line
must have come from elsewhere.

@_date: 2008-09-21 21:56:22
@_author: David Shaw 
@_subject: Changing preferences 
No.  Every preference list has 3DES in it.  If you don't include it  yourself, GPG adds it automatically to the end.
If you set your preferred algorithms to AES256 and AES128, you're  really setting it to AES256, AES128, and 3DES.
No, that is not the case.  The sender cannot use any algorithm that  you don't include in your preference list.  To do so would violate  OpenPGP, and cause major interoperability problems as the sender  doesn't know if you even have the algorithm in question.
The whole point of a preference list is that you list the algorithms  in the order in which you prefer them.  If you prefer some algorithms  more, put them earlier.  If you prefer some algorithms less, put them  later.   If you never want to see that algorithm used ever, leave it  off the list completely.

@_date: 2008-09-21 22:42:28
@_author: David Shaw 
@_subject: Changing preferences 
Oh, for crying out loud.  The sender can do whatever the sender  likes.  That's what is so nice about being the sender.  The sender can  send unencrypted, but we don't mention that option.  The sender could  also choose to encapsulate their message in a text-to-speech MP3, but  we don't mention that option either.  Heck, there could be some bug in  the sender's program that causes it to use the wrong algorithm, and  again we don't mention that.
I'm not going to prefix every single statement I make with an "Except  in the case where the sender is intentionally violating the spec and  is ignoring all the warning messages telling them to knock it  off...."  We need to have some baseline of communication here, and  avoid taking something that is really very simple and making it  tragically complex.

@_date: 2008-09-21 22:54:04
@_author: David Shaw 
@_subject: Changing preferences 
Partially.  You need to remember that the "sender" preferences are not  relevant here.  OpenPGP has no concept of a sender.  All it knows are  keys, and there is no particular requirement for a secret key to be  involved when sending a message.  For example, who is the sender here?
  gpg -r receiver1 -r receiver2 --encrypt my-file.txt
Using your nomenclature, here's the algorithm:
1) Take the intersection of the various PrXes.  This gives an  unordered set.
2) If there is a Pps, choose the highest ranked entry in Pps that also  exists in the intersection
3) If there is no Pps, choose the highest ranked entry in Pr1 that  also exists in the intersection
Note that Ps, and any PprXes are irrelevant and in fact are unknown or  unknowable at the time of encryption.

@_date: 2008-09-21 23:22:42
@_author: David Shaw 
@_subject: Changing preferences 
I know. I wrote the part of the documentation that told people not to  use them.
GPG is a very flexible program, and as such, it gives you tens of ways  to do things wrong.  All of these method are off by default, and  generally protected by strong warning messages that tell people when  they're shooting themselves in the foot.  People frequently write in  to this list needing help on some simple question.  My heart always  sinks when I see some of the responses that take a simple question,  and over-answer it in such a way as to guarantee that this poor person  is going to be utterly baffled as to what is going on.
If someone wants to know how to set their preference list, they're not  trying for new and fun ways to violate the spec.  Why even mention  that it is possible to violate the spec?  How does it help the  questioner to know that "if you use the flag that you're not supposed  to use, and ignore the warnings telling you to not use it... hey, you  can get GPG to do something illegal"?
To make this even more silly, you actually took the trouble to remove  the part of my quote where I said WHY it was a bad idea.

@_date: 2008-09-22 00:09:00
@_author: David Shaw 
@_subject: Changing preferences 
I'd welcome docs that make it clear, but I question how easily it  could be made "clear" in something pithy enough for a man page.  If  you make it simple enough to fit in the man page, you will get scolded  for not covering some obscure case with v2 keys or something.  If you  make it complete, it's too big for an already large man page.
I'd be content with something that says "List algorithms in the order  in which you'd like to see them used.  If you don't include 3DES, GPG  will add it automatically at the end.  Note that there are many  factors that go into choosing an algorithm, and so GPG may or may not  follow your chosen order for a given message.  However, it will only  ever choose an algorithm that is on the list of every recipient key.   See also the INTEROPERABILITY section."
If they are so horrible, suggest a different way to handle them.   Better to fix it in code rather than document something you feel is

@_date: 2008-09-22 09:37:22
@_author: David Shaw 
@_subject: Preferences... 
You don't need to say "Sxx Hxx Zxx" in preference lists.  You can give  the whole algorithm name if you like.  The Sxx Hxx Zxx form is just  for backwards compatibility with a much earlier version of GPG before  it understood the algorithm names.
Also note that Camellia is not yet part of OpenPGP.  GPG has some  support for testing as Camellia makes it through the RFC process, but  it is disabled by default.  If you enable it (and ignore the warning  message you will get every single time you run GPG), you could use  them... but there is no guarantee that those messages will be  decryptable, ever.  You've got a gun pointed at your foot.  Be careful  you don't pull the trigger.

@_date: 2008-09-22 09:46:48
@_author: David Shaw 
@_subject: Preferences... 
They are reserved for experimentation in GPG.  Don't use them.   They're for interoperability testing only.

@_date: 2008-09-22 11:28:09
@_author: David Shaw 
@_subject: Changing preferences 
Good analogy.  I usually explain it with pizza toppings ("I like
pepperoni or mushrooms, but hate anchovies").  3DES is then the plain
cheese pizza that everyone can settle on if they have to.

@_date: 2008-09-22 12:13:51
@_author: David Shaw 
@_subject: Changing preferences 
You should take this for granted, or you're going to be forced to
continually upgrade to get every possible algorithm whether you want
to or not.  IDEA today, Camellia tomorrow, Whirlpool eventually, etc.
OpenPGP guarantees that you will never be sent a message that violates
your preferences (effectively this means you will never be sent a
message that you can't decrypt due to some algorith mismatch).  Sure,
there could be a sender that is violating the spec, but do you really
want to configure yourself to do the right thing when communicating
with a partner who is broken?  They have many more ways of being
broken than you do of working around their brokenness.
I have never received a messsage that violates my preferences.  If I
did, and couldn't decrypt, I'd just send an encrypted message back
saying "I couldn't read this.  Knock it off with the algorithm games."

@_date: 2008-09-22 12:07:05
@_author: David Shaw 
@_subject: Changing preferences 
It an interesting thought, but I'm not sure this is a good analogy to
--cipher-algo and friends.  The danger with --cipher-algo is that you
can actually break communication: it's possible to make a message that
cannot be read by the recipient.  Preferences are vastly different, as
there is no way to break anything.  The absolute worst thing you can
do is make yourself confused as to which algorithm is being
chosen... and that was the state you were in before you messed with
the preferences in the first place.
This is an option where the right thing will happen if someone doesn't
touch it, and the right thing will happen if someone messes it up.  I
don't really understand the sudden need for repair here.

@_date: 2008-09-23 09:19:36
@_author: David Shaw 
@_subject: Preferences... 
It's even worse than that - the identifier for Camellia has changed  twice already, just during the process of debating the draft.  The  first draft had only Camellia256.  The second draft had Camellia192  and Camellia256.  Only now is there the full set of 128, 192, 256.   Any messages encrypted from either of those two earlier versions are  not decryptable now, and we haven't even left the draft stage yet.   Anyone using Camellia in OpenPGP at this stage is asking for it.
That's exactly it.  Camellia is a very popular algorithm in Japan.   Including it doesn't buy us much new from the cryptographic  perspective as we already have strong 128-bit ciphers in OpenPGP, but  it does buy us something from the usage perspective.  It is good for  the OpenPGP "ecosystem".
For those who are curious:

@_date: 2008-09-23 09:44:53
@_author: David Shaw 
@_subject: Changing preferences 
Good point.  How about:
List algorithms in the order in which you'd like to see them used by  someone else when encrypting a message to you.  If you don't include  3DES, GPG will add it automatically at the end.  Note that there are  many factors that go into choosing an algorithm (for example, you may  not be the only recipient), and so the remote OpenPGP application  being used to send to you may or may not follow your exact chosen  order for a given message.  However, it will only ever choose an  algorithm that is on the list of every recipient key.  See also the  INTEROPERABILITY section.

@_date: 2008-09-23 11:38:05
@_author: David Shaw 
@_subject: Suspect Signatures 
Alas, no.
There is a part of the OpenPGP spec, the keyserver no-modify flag,
that can be set to inform a keyserver that only the keyholder is
allowed to update the key on the keyserver.  GnuPG sets this flag by
default, but unfortunately no keyserver currently implements it, so
anyone can update a key on a keyserver if they like.  (The PGP
keyserver doesn't implement the flag, but it restricts updates to the
keyholder via other means).
That said, this is really an aesthetic problem, and not a trust
problem.  The web of trust ultimately takes care of bad signatures as
those people who issue them will eventually get marked as
untrustworthy.  I have a few mystery signatures on my key as well.  No
real harm - just ignore them.

@_date: 2008-09-23 12:13:46
@_author: David Shaw 
@_subject: Not able to decrypt gpg file 
It seems you managed to replace your gpg.conf config file with
something completely not a gpg.conf file.  Take a look at the file and
see what happened to it.  If need be, you can delete it and run with
the defaults, or try to find a backup copy of it.

@_date: 2008-09-23 14:27:17
@_author: David Shaw 
@_subject: gpg: fatal: can't create directory `~/.gnupg': A file or 
This sounds like a very confused setup on your AIX box.  Does the user
you are running GPG as have a home directory?

@_date: 2008-09-23 17:04:03
@_author: David Shaw 
@_subject: Changing preferences 
All set.  The next version of GPG will have the new text.
I've also taken Robert's point about confusion between OpenPGP
preferences as ranked lists vs capability sets, and changed the code
so that they are always ranked lists.  This means that GPG will now
allow the various recipient keys to "vote" on which algorithm is
chosen, and the most-preferred one will be chosen.  It doesn't really
change much that is visible in practice, but it does mean that if you
have a bunch of recipients that all list a particular algorithm
somewhere, and most of them have it as their first choice, you'll
probably end up using it.
Note that this doesn't change anything for those people using
personal-*-prefs.  If personal-*-prefs are set, GPG will continue to
pick algorithms based on them.

@_date: 2008-09-23 17:27:06
@_author: David Shaw 
@_subject: Changing preferences 
Huh?  You don't have preferences now, but will add some for this
feature?  Unless you generated your key with PGP 2.6 umpteen years
ago, you have preferences.
GPG can't magically infer what algorithms you want.  If it isn't on
the preference list, GPG won't use it.  All this new feature does is
try and be a bit more graceful with which algorithm it picks from the

@_date: 2008-09-23 18:22:04
@_author: David Shaw 
@_subject: Changing preferences 
Nope, you're right.  Your most preferred encryption algorithm is  AES256, followed, by AES192, etc.
As to what algorithm would be used when someone encrypts a message to  you depends on who else is a recipient.  Let's say the message was  encrypted to me (key 99242560) and you.  My preferences are (and I  really need to update these) AES, TWOFISH, CAST5, BLOWFISH, 3DES.  The  only algorithms that are even possible here (because we both have  them) are AES, CAST5, and 3DES.  AES is clearly the most popular of  these three, so AES will be chosen.  Between you and a different  person might give a different result.
Most keys generated with GnuPG in the past few years have the same  preferences as you (they're the defaults now).  For a message going to  those keys, AES256 will be chosen, as everyone favors it.

@_date: 2008-09-23 22:18:04
@_author: David Shaw 
@_subject: Changing preferences 
It's very simple and easy to explain now:
With personal-*-preferences, GPG works exactly as it does now.  That  is, whatever the personal-*-preferences say, goes, so long as they  don't violate any key preferences (i.e. we won't pick AES unless every  key can handle AES).
Without personal-*-preferences, GPG will pick the most popular  algorithm from the various recipient keys.  That's basically it.
For example:
Key A has: AES CAST5 3DES
Key B has: CAST5 3DES AES
Key C has: CAST5 AES 3DES
Then CAST5 will win.  It's the most popular.

@_date: 2008-09-23 22:19:47
@_author: David Shaw 
@_subject: Suspect Signatures 
Not exactly.  The WoT doesn't exactly figure out who is untrustworthy,  but rather who is trustworthy.  Anyone unknown is just ignored.  Thus,  a unknown signature on your key doesn't actually impact much unless it  is trusted by someone.

@_date: 2008-09-23 22:56:39
@_author: David Shaw 
@_subject: Changing preferences 
This is true (the algorithm I used to pick the algorithm is similar to  a Borda count), but note that you don't need to know that to use it.   Unless you're curious about the math behind the choice, it is equally  correct to say "it picks the most popular algorithm that all of the  recipients can support".

@_date: 2008-09-23 23:01:16
@_author: David Shaw 
@_subject: Changing preferences 
3DES is arguably the "best" (defined as "has been studied the most and  hasn't been broken") algorithm in OpenPGP.  3DES has been around since  1978 (far longer than anything else in OpenPGP) and been attacked  continually since then.  It hasn't fallen yet.  The main reason why  3DES isn't good is that it's dreadfully slow, not that it isn't a good

@_date: 2008-09-24 00:07:07
@_author: David Shaw 
@_subject: Changing preferences 
It doesn't matter whether PGP supports Blowfish or not (this actually  depends on the PGP version - there are varying levels of support).   What matters for preferences is what *you* like.  If you like  Blowfish, put it in there.  It doesn't matter if a million or zero  other programs support it.  Your preferences are purely what you like,  and whether anyone else supports it is irrelevant.  The protocol takes  care of not using any cipher that you won't be able to decrypt.
Twofish in OpenPGP is a 256-bit cipher.
SHA-384 is actually SHA-512 with 128 bits lopped off.  SHA-224 is  actually SHA-256 with 32 bits lopped off.  Same algorithms, slightly  different setup.
Use the names.  You're not wasting any space on the key, since the  names are always converted to a single byte each when written onto a  key.  Plus, the names are just easier.
Now to the big question: is there any reason to change the default  preferences at all?  No, not really.  The defaults were carefully  chosen to be good conservative algorithms.  Why change that?  For what  it's worth, I can say that unlike most poking about and changing  values in OpenPGP, you can't really hurt yourself changing the  preferences.  The very worst thing you can do to yourself is end up  using 3DES for your cipher, and that's just fine (some people even  select it on purpose).  3DES is very secure, but very slow.

@_date: 2008-09-24 00:21:39
@_author: David Shaw 
@_subject: Changing preferences 
In a perfect world, SHA512 truncated to 256 bits is exactly as strong  as SHA256.  We don't, of course, live in a perfect world.  However,  we're close enough in this case to treat the two as interchangeable in  a practical world.  This is what NIST did when specifying the new DSA  algorithm in FIPS-186-3.  They note that a 3072-bit DSA key needs a  256-bit hash, but that any hash larger than necessary can be truncated  to fit.  OpenPGP follows that spec, and so GPG will happily chop  SHA512 to fit.

@_date: 2008-09-24 10:31:58
@_author: David Shaw 
@_subject: Changing preferences 
CAST5 was invented in 1996.
The code that eventually evolved into the OpenPGP standard was started  in 1996.
Serpent was invented in 1998.
Serpent didn't exist when it might have been added.  When PGP 3 was  being developed, they used three ciphers: 3DES was the slow-and- conservative one, IDEA was the good-but-patented one, and CAST5 was  the good-and-free one.

@_date: 2008-09-24 10:41:44
@_author: David Shaw 
@_subject: Changing preferences 
If the goal was to keep the shelf attached to the wall, why would some  other solution be "better" ?   If there was something heavy on that  shelf, and I was standing under it, I'd probably be pretty satisfied  with 24 screws holding it up.

@_date: 2008-09-24 15:16:15
@_author: David Shaw 
@_subject: How can I choose a secret key for decryption? 
No.  GPG is just trying the secret keys in order.  If you want to
force KEY2 to be used for decryption and you are prompted for KEY1,
just hit enter for the passphrase until GPG gives up and prompts for

@_date: 2008-09-25 15:35:58
@_author: David Shaw 
@_subject: Malware targeting GnuPG/PGP Keyrings 
Neat.  It's not the first time PGP keyrings have been targeted by
malware, but it does seem like a more effective attack than this
attack back in 1999:
  Yep, a Word macro virus.
I wonder, though, how useful is this in practice?  I think encryption
is both useful and very important in society (which is why I work on
GnuPG), but even at my most hopeful, I know that the number of people
who actually use PGP/GPG style encryption are a fraction of a fraction
of a tiny sliver of the number of people who don't.  It seems odd for
a malware author to spend time going after such a small "target
market".  Going after company-wide installs, perhaps?

@_date: 2008-09-25 16:29:09
@_author: David Shaw 
@_subject: Malware targeting GnuPG/PGP Keyrings 
Sure, but the economics of it are interesting.  A tiny fraction of
users even have PGP.  Some fraction of those users use it for mail on
something approaching a regular basis, and some fraction of those
users are putting something that the malware author might care about
in a message.
It's not clear how big or small the fractions are, but the implication
is that the malware author must be very interested in a very few
messages... or the writing and distribution of this particular malware
was so easy that the small target space wasn't a worry... or some
graceful balance in between.

@_date: 2008-09-26 21:48:53
@_author: David Shaw 
@_subject: Malware targeting GnuPG/PGP Keyrings 
That's a good point.  At the moment, the majority of OpenPGP keys used  for signing software exists in the Unixish world, which as a class are  reasonably less vulnerable (for both engineering and user base  reasons) to this sort of malware.  Still, compromises do happen and  will inevitably happen more.  Just a few weeks ago, the Red Hat folks  had a breakin where the attacker managed to sign a few RPMs for their  Enterprise Linux distribution: .

@_date: 2008-09-29 11:32:53
@_author: David Shaw 
@_subject: .asc file problem 
The answer is different for different web servers, but basically you  need to tell the server that files ending in .asc are text files.  In  Apache, for example, you can do something like this in your server  config or .htaccess file:
AddType text/plain .asc
See your web server instructions.

@_date: 2009-04-01 08:49:54
@_author: David Shaw 
@_subject: default symmetric algorithm used for private key 
It's CAST5, unless:
a) You don't have CAST5 compiled in
b) You run with --rfc24480, --rfc4880 or --openpgp
In any of those cases, it's 3DES.
(Basically, unless you're doing something fairly unusual, it's CAST5)

@_date: 2009-04-06 19:14:05
@_author: David Shaw 
@_subject: .gnupg/gpg.conf permissions 
Why are you downloading keys as root (i.e. using sudo)?

@_date: 2009-04-07 23:02:31
@_author: David Shaw 
@_subject: Singing a key with a subkey 
Fundamental.  The OpenPGP web of trust is built from signatures from  primary keys.  Signing a key with a subkey (which can belong to more  than one primary) does not make sense in this context.

@_date: 2009-04-08 08:41:17
@_author: David Shaw 
@_subject: Help Solicited to implement a new pgp key server 
My advice is to not reinvent the wheel unless you need something  substantially different from the two standard keyservers on the net:
1) SKS: Main pro: Syncing with other keyservers
Main con: Client cannot manage keys beyond adding to them (i.e. no  deletes or replacements - you can only add new signatures/subkeys).
2) LDAP: (any LDAP server you have handy)
Main pro: Allows client to completely manage keys (i.e. deletes,  replacements work)
Main con: No syncing with other keyservers

@_date: 2009-04-14 23:03:31
@_author: David Shaw 
@_subject: Upgrade from GnuPG 1.4.5 to 1.4.9 breaks signature verification 
So, the decryption and verification works with GPG 1.4.9, but not with  a PGP 6.x.  It might be an algorithm conflict, or possibly a hashing  problem.  Can you tell me about what error is returned when PGP 6.x  tries to process the file?
Other questions:
-  are the files encrypted and signed in one piece, or are the  signatures detached signatures?
-  is this a DSA or RSA signature?  (when you did the test with 1.4.9,  it would say "using DSA key" or "using RSA key" when it verified).
-  Can you repeat the test decrypt/verify that you did with the  standalone 1.4.9, except add a "-v" to the command line.  This will  make GPG print out some extra information.  The pieces that are most  relevant to the problem are the lines that read "gpg: XXXXXX encrypted  data" and "gpg: YYYYYY signature, digest algorithm ZZZZZZ".   Can you  send me XXXXXX, YYYYYY, and ZZZZZZ?
You might try asking your client to add "--pgp6" to their GPG command  line.  PGP 6 is not really completely up to the modern PGP spec (it's  a good few years out of date), and --pgp6 tells GPG to try and be  compatible with the older version.

@_date: 2009-04-15 13:00:19
@_author: David Shaw 
@_subject: Keyserver doesn't honour removed signatures 
Yes, this has been pointed out in the past.  The attack that I came up  with was a bit different - use the keyserver net as your porn/warez/ kiddie porn/etc distribution point.  Just upload keys with whatever  you like embedded in them.  The keyserver net takes care of  distribution for you, and your "customers" can download your material  from whichever keyserver they like (or run their own keyserver and get  content synced to them on a regular basis).

@_date: 2009-04-15 13:47:40
@_author: David Shaw 
@_subject: Keyserver doesn't honour removed signatures 
The difference is that the keyserver network allows anyone to submit  data, and the keyserver net will then serve it on their behalf.  It's  like a publicly writable web site with multiple replicas and with no  ability to delete.  In the P2P case, only those people who choose to  participate in a given shared item are involved in the distribution of  that item (legal and illegal content can be processed at the same  time, and each participant gets to pick what they want to do).  The  keyserver net, as currently implemented, carries everything regardless  of the desires of the operator of the server.

@_date: 2009-04-16 09:13:35
@_author: David Shaw 
@_subject: Keyserver doesn't honour removed signatures 
Not exactly.  Usenet has delete :)
Even so, Usenet is a good example.  Note that even with delete, Usenet  is full of random junk dumped into it.  Publicly writable resources on  the net, be they Usenet, Wikipedia, blog comments, or some random ftp  server that isn't set up as a blind drop-box, tend to be written in  ways not necessarily desired by their operators.  All of these  resources have some means (of varying effectiveness, but they do at  least exist) to "clean up" the abuse (cmsg cancel, wiki editors,  kicking the admin who set the permissions that way), that the  keyserver net lacks.
Another way the current keyserver net differs from the earlier  examples is that many servers don't keep logs for very long (or at  all).  That's a good feature when we're talking about keys, but it's  also a good feature for someone who wants to throw some illegal  material on there for later download.  Of course, massive dumping of  junk into a keyserver would eventually be noticed, but a few items,  here and there, would easily fly below the radar.
I do like Usenet though.  I once thought (before Yaron Minsky came up  with the gossip protocol) that if we ever needed a good keyserver  protocol that could scale to massive sizes, that a slightly modified  NNTP would be ideal for it.  Use the key fingerprint as the NNTP  message-id field for IHAVE, and NNTP takes care of the distribution.   (You'd still need a keyserver front-end on top of the "article"  database, of course).  I think we're pretty far off from needing to  scale to that level, though.

@_date: 2009-04-20 21:26:19
@_author: David Shaw 
@_subject: OpenPGP digital signature query 
That's a pretty big step there.  Asking a user community of GnuPG a  question about OpenPGP is not reckless disregard.  What you do with  the *answer* might be reckless disregard, so John's advice to consult  an attorney familiar with the issue is wise.
Asking questions is good.  Doing the right thing with the answers is,  as always, the responsibility of the questioner.

@_date: 2009-04-20 21:43:06
@_author: David Shaw 
@_subject: Keyserver doesn't honour removed signatures 
I suspect that many keyservers are run at sites that are happy enough  to leave them running as long as they don't cause trouble of one sort  or another.  A concerted effort by someone to annoy and inconvenience  those sites (via uploading porn? via something else?) would rather  quickly reduce the number of keyservers.  Not to zero, but we could  lose a good number of them.

@_date: 2009-04-20 22:12:35
@_author: David Shaw 
@_subject: OpenPGP digital signature query 
"Sure.  They told me some stuff, and I treated it as anecdote until I  got confirmation from an attorney."
There is nothing wrong with asking questions.  It's what you do with  the answers that matters.

@_date: 2009-04-21 00:19:48
@_author: David Shaw 
@_subject: Keyserver doesn't honour signature removal 
You can.  Just list the Biglumber URL to your key as your preferred  keyserver (i.e. "

@_date: 2009-04-21 00:39:01
@_author: David Shaw 
@_subject: Keyserver doesn't honour signature removal 
That's not quite right.  PKA records in DNS can point to a keyserver,  but you still need the keyserver in the mix somewhere (though, like  the "preferred keyserver" feature, that "keyserver" might be a key  stored on a web server).
You might be thinking of CERT.  The CERT DNS record can store either a  URL like PKA does, or can store the whole key so you don't need a  keyserver.  Of course, that can make for a pretty big DNS record...
CERT is a standardized way (RFC-4398) to put OpenPGP keys in DNS.  PKA  is a different sort of thing - it's a pretty neat way to leverage the  ubiquity of DNS into a different trust model.  It just happens that  both CERT and PKA can do the "DNS lookup to find a key" trick.

@_date: 2009-04-21 08:24:39
@_author: David Shaw 
@_subject: OpenPGP digital signature query 
"Your Honor, I object.  Assuming facts almost comically not in  evidence."   The original poster says nothing about using this list as  a "first source of information" (your words), or even any words to  that effect.  In fact, allow me to repost the entire post:
 > Can OpenPGP digital signature be used to comply to FDA's 21 CFR  Part 11 , or does it mandatorily require X.509 or PKI based signatures
That's it.  One line.  You seem to be concluding from this that he has  somehow done something wrong by merely asking the question, but I see  no actual facts to base that on: merely a guess as to the situation  underlying the question, and then scolding the questioner based on  your guess.  Maybe it would be better let the questioner be  responsible for the questioner?
I'm happy to continue this discussion offline if you like, but as this  no longer has any bearing on GPG or OpenPGP, it seems inappropriate  for this list.

@_date: 2009-04-21 09:14:53
@_author: David Shaw 
@_subject: Keyserver doesn't honour signature removal 
Absolutely.  I do the same thing, just using CERT.  CERT has two  modes: "PGP" (where the whole key lives in DNS), and "IPGP" for  Indirect PGP, where you give a URL as in PKA.  IPGP and PKA are  basically the same thing from the find-a-key perspective.
It's sort of questionable how practical PGP mode is, with the whole  key stuffed in to DNS.  You'd get into DNS over TCP fairly quickly,  and then (poor) firewalls can start being cranky.  GnuPG does support  getting keys this way, and I suppose it could be useful with a  stripped down key (no 3rd party signatures, or even the output of  "minimize") and expect that people will eventually learn the rest of  the key info from a full keyserver.  I suspect the basic idea is more  useful for distributing other OpenPGP objects like revocations, as  they are quite small and the DNS check for a revocation is quite cheap.
IPGP, though, is very handy.
Ugh, that's a problem.  CERT has been supported since mid BIND 8 (and  arguably longer since you can do stuff like "TYPE37" and raw  encoding), but if your provider doesn't let you set arbitrary records,  then you're stuck.  I've seen providers that do DNS through a web GUI  with a drop-down menu that allows you to choose A, CNAME, or TXT.  I  suppose we should be grateful they at least allow TXT!

@_date: 2009-04-21 11:22:51
@_author: David Shaw 
@_subject: Keyserver doesn't honour signature removal 
If your preferred keyserver field points to the web server, that would  tend to (eventually) remove the normal keyserver from the equation.   That way, if they find your key via the keyserver, then they'll still  (assuming they haven't changed the default configuration) end up at  your web site at refresh time.
Personally, I don't worry too much about it.  Given the client-centric  design of OpenPGP, there will always be ways to get the key from the  wrong place.  When I update my key, I send it to the keyservers, and  stick it on my web site.  Whichever the person hits is fine with me  (or put another way, it's not as if I have a choice in the matter, so  I may as well be fine with it).
What does worry me about the keyserver situation is that it is  confusing for the newcomer to OpenPGP: there are several different  round-robin keyserver setups (with different semantics between them!),  there are some servers that still can't cope with subkeys, there is  confusion on whether a syncing server is necessary or not, etc.  This  is visible every time someone asks a keyserver question on this list:  each response gives a different recommended server.

@_date: 2009-04-23 18:27:02
@_author: David Shaw 
@_subject: Help with encrypting using my PGP Public key 
Recreated how?  Can you give exactly the steps you followed?  Even  better, can you generate a key using those steps and send it here so  we can examine it?
The error message that you got looks like it came from the PGP command  line product.  I actually have a copy of that here somewhere, and I'm  happy to check your GPG-generated key against it.

@_date: 2009-04-24 09:04:58
@_author: David Shaw 
@_subject: DH/DSS vs ElGame/DSS? 
It's historical.  Back in the late 1990s, the PGP developers were  offered a free patent license if they called it Diffie-Hellman.  Now  that the patent has expired, though, it's a little hard to change  their product without confusing a bunch of customers who would see  their "Diffie-Hellman" keys suddenly become "Elgamal" keys.

@_date: 2009-04-24 11:39:56
@_author: David Shaw 
@_subject: DH/DSS vs ElGame/DSS? 
Jon Callas, CTO of the PGP corporation.  I'm afraid I don't have a URL  to point you to.
Note that this wasn't skullduggery of some sort or another.  Whatever  the product calls it, it the same algorithm as specified in the  OpenPGP standard (that which we call a rose, by any other name would  smell as sweet).  The patent holders (Cylink) simply wanted to push  the name Diffie-Hellman for marketing reasons.  Back in the 1990s,  crypto was really hampered by patent problems, and I imagine a free  license would be a significant gift.

@_date: 2009-04-24 14:21:07
@_author: David Shaw 
@_subject: DH/DSS vs ElGame/DSS? 
Plus, both the GnuPG implementation and the PGP implementation are  available for review by anyone who wants to look at them.  (PGP isn't  open source of course, but you can still get the source for review).

@_date: 2009-04-24 15:07:51
@_author: David Shaw 
@_subject: Help with encrypting using my PGP Public key 
I examined this key and there is nothing particularly unusual about  it.   The only thing that jumps out (and this is a reach) is that the  Elgamal encryption subkey is rather small.  It's possible (though odd)  that the bank is configured to disallow keys of that size.  If it is  easy for you to try different keys with the bank, try making and  submiting one with a 2048 bit subkey (i.e. gpg --gen-key, select  option 1, then enter 2048).
I'll check it against the PGP command line product later (the virtual  machine it runs on is not powered on right now).

@_date: 2009-04-25 11:50:29
@_author: David Shaw 
@_subject: Help with encrypting using my PGP Public key 
I've checked it and it works just fine.  I'm able to encrypt to it  without any problems.
I'm afraid that doesn't leave you with a good answer, though.  I don't  think it will help, but it's worth trying making a larger key, as I  suggest above.  Aside from that, your bank or whoever you are  communicating with needs to give you some more information about why  this is failing.

@_date: 2009-04-25 19:10:24
@_author: David Shaw 
@_subject: certificate chain depth 
Almost.  The calculated trust actually refers to the validity of a  given user ID on a given key.  It is possible to have a key with  multiple user IDs, some of which are calculated to be valid, and some  of which are not.
Yes.  The terminology can get difficult if the term "trust" is used  for both.  Many people use the words "trust" (aka owner trust or  personal trust) and "validity" for these two concepts.

@_date: 2009-04-26 01:00:52
@_author: David Shaw 
@_subject: certificate chain depth (technical) 
The trustdb actually doesn't store per-user ID depth values.  Rather,  one of the many possible depths is stored for the key as a whole,  which is fine for our purposes, but may not give you what you want  here.  Take the case of A signs B(uid1), A signs C(uid1), and C signs  B(uid2).  B is thus fully valid as per B(uid1) being signed.  But  B(uid2) is also valid, and at one level of depth larger than B(uid1).   B as a whole thus lives at both depth 0 and depth 1.  We store this as  1, but I think you'd want it at 0.
You can see this in action, and perhaps give you the information you  want, by doing:
   gpg -v -v --check-trustdb.
You will see (along with some other debug info), a bunch of records  that look like this
0:1234567812345678:U:::f:::user at example.com:
0:1234567812345678:U:::m:::user at example.net:
The first field is the depth.   0 means "signed by an ultimately  trusted key", and 1 means one step beyond that, etc.
The second field is the key ID
The third field is K for keys and U for user IDs.  You're more  interested in user IDs here.
The 6th field is the validity:
   q == undefined validity
   f == fully valid
   m == marginally valid
The 9th field is a piece of the user ID string.
You can see some keys appear at multiple depths if a particular user  ID from that key becomes valid earlier than other user IDs on the key.

@_date: 2009-04-26 10:52:25
@_author: David Shaw 
@_subject: certificate chain depth (technical) 
Not exactly.  The level for a single-uid key is what you'd expect it  to be naturally.  The question arises when there are two or more uids  on a key, each becoming valid at a different level.  For a given key,  we store the highest level that covers all of the valid uids, or put  another way, the key has the level for the most-distant valid uid.  I  believe you are looking for the key to have the level of the least- distant valid uid.
It would be equally as correct as what we do now.  The algorithm  doesn't need those levels once the trustdb is built.

@_date: 2009-04-26 12:51:24
@_author: David Shaw 
@_subject: Just a thought 
I'm not sure if Enigmail has sufficient control here (due to the  Thunderbird restrictions), but if possible, it might be wise to handle  Bcc's recipients with --hidden-recipient instead of --recipient (i.e.  "-r").  That would better duplicate the standard expectations of a  user using Bcc: the regular recipients can all see who the recipients  are, but not the Bcc'd people.  As things stand now, any recipient can  see who was Bcc'd, which sort of removes the "B" from the Bcc.
--throw-keyids is a reasonable solution as well, but it's more of a  sledgehammer, rather than a scalpel.

@_date: 2009-04-27 10:23:03
@_author: David Shaw 
@_subject: Just a thought 
I don't think I was nearly clear enough.  My thought is that since the  current Bcc doesn't actually give you Bcc - it's essentially a Cc (non- blind), it might be better to --hidden-recipient those on the Bcc  line.  Completely true that it means that PGP users can't be the Bcc  people, but it is not at all true that it blocks all PGP users.  PGP  quite happily ignores hidden recipients, as per the RFC (it isn't  required to implement them, but it is required to not blow up when it  sees them).
Sure, PGP people don't benefit from the Bcc... but they don't benefit  now either.  At least this allows for someone to benefit, rather than  I don't think this really lets you get rid of the warning message from  Enigmail, though.  The user may not know if a given user is using PGP  or GPG, and needs to be warned that a PGP user on the Bcc line won't  be able to decrypt.

@_date: 2009-04-28 23:17:12
@_author: David Shaw 
@_subject: Subkeys... 
There are many answers to your question.  Basically, yes, you could,  but no, you almost certainly don't want to do it that way.  In  virtually all situations, the best way to handle this is to revoke the  subkey you no longer want and then make a new subkey with whatever  expiration date you desire.

@_date: 2009-04-29 12:26:28
@_author: David Shaw 
@_subject: Looking for a good port80 static-DNS keyserver 
Why not just throw the key onto a web server and point people at it  that way?  Part of the usefulness of a keyserver is to find keys that  you don't know how to get otherwise.  In your case, you are telling  people where to get it so that doesn't apply.

@_date: 2009-07-31 22:05:41
@_author: David Shaw 
@_subject: latest stable version of GnuPG that decrypts Adobe PDF files 
I'm going to guess that you are referring to the built-in PDF  encryption, and if so, the answer is no.  GnuPG cannot decrypt PDF  files unless they are encrypted with OpenPGP (PGP, GnuPG, etc).

@_date: 2009-08-07 23:45:07
@_author: David Shaw 
@_subject: Transferring GnuPG accounts 
To properly answer your question, you'd have to say what "does not do  digital signature as it did" means.
Does it not work at all?  Does it work, but in an unexpected way?   What does it do?  There just isn't any information to go on here.

@_date: 2009-08-11 13:31:38
@_author: David Shaw 
@_subject: Setting up SKS Keyserver 
is the place.
Yes.  Many folks on sks-devel are happy to sync with people.  Just ask.
The software posted there is the latest official release.  On sks- devel there are usually a handful of patches and bug fixes being  discussed before they are rolled into the official release.

@_date: 2009-08-11 13:48:27
@_author: David Shaw 
@_subject: Entropy-on-a-key 
This is cute:
(Reasonably on-topic as the device would work with GnuPG (at least on  Linux), as it seems to feed /dev/random)

@_date: 2009-08-11 19:45:42
@_author: David Shaw 
@_subject: GPG on iSeries (AS400) 
iSeries running what?  Linux?
If it's Linux, just compile it like you'd compile it anywhere else.   If it's OS/400, you might take a look at running it under PASE.

@_date: 2009-08-13 10:33:11
@_author: David Shaw 
@_subject: Two convicted in U.K. for refusal to decrypt data 
While I believe Perry Metzger was referring to the US courts, this  post is still well worth reading.  I doubt the situation is vastly  different outside of the US:   at metzdowd.com/msg10391.html

@_date: 2009-08-17 11:43:37
@_author: David Shaw 
@_subject: Changes in 1.4.10 
Yes.  I'll add a note to the NEWS file about it.
For the archive: the changes are that GPG now scores the preferred  algorithms, so (for example) if there are 3 recipients, and two of the  three vote for AES128 and one of the three votes for AES256, then the  algorithm chosen will be AES128.  However, despite the occasional  confusion on this point, keep in mind that this behavior is not  required by the standard, so don't expect everyone else to do what GPG  is doing here.  Not every OpenPGP implementation does ranking.  The  only requirement is that each implementation picks an algorithm that  is supported by all recipients, and beyond that, the implementation  can choose however it likes.  It is thus legal to just force every  message to use 3DES and never even look at the preferences.  So long  as all recipients support them, it is even legal, though perhaps  silly, to pick AES128 on Mondays, CAST5 on Tuesdays, but AES256 only  on alternate Thursdays in months with the letter "r" in them.
Also keep in mind that you, as the sender of the message, are king: if  you want algorithm X, and everyone can at least handle algorithm X,  then their votes for what they like best don't matter.  You're the  sender, and your wishes (via --personal-cipher-preferences and  friends) trump all.

@_date: 2009-08-17 18:35:53
@_author: David Shaw 
@_subject: Updating a signature 
It is not possible.  What you need to do is make a new signature with  the details you want (the policy URL, etc).  You can revoke the  earlier signature, but in practice it's usually simpler to just ignore  it since the new signature replaces the older one in trust calculations.

@_date: 2009-08-19 13:24:08
@_author: David Shaw 
@_subject: Practical Advice for those using AES256 cipher? 
The brief summary is don't worry too much about it.
The less brief summary is that given a particular relationship between  the (session) keys in use, and multiple copies of the same plaintext  encrypted with these particular keys, an attacker can attack a  simplified version of AES256 in less time than it would take to attack  it via brute force (and amusingly enough, in less time than it would  take to attack AES128).  The multiple catches here is that you usually  don't have special keys, you don't usually have multiple copies of the  same plaintext encrypted with the special keys, the amount of time it  would take to attack is still unfeasible, and GnuPG doesn't use a  simplified version of AES256 anyway (nobody does).
Is this bad for AES256?  Absolutely.  It's a crack in the armor.  But  is it a problem in OpenPGP today?  Not really, no.
So speaking about how it relates to GnuPG, I wouldn't bother to do  anything about it, personally, but if it worries you, you can easily  rank AES128 higher than AES256 in your preferences (or even remove  AES256 altogether if you like).  Either way you're probably fine.

@_date: 2009-08-26 09:41:38
@_author: David Shaw 
@_subject: Help with decrypting gpg file 
I'm not sure if that file is legal according to the OpenPGP spec.  It  depends on how it was packed together.  If you can encrypt a sample  file (using dummy data, but with the same number of text files) I  would be happy to take a look at it and see what is happening  internally to GPG.

@_date: 2009-08-27 10:48:04
@_author: David Shaw 
@_subject: Help with decrypting gpg file 
Try 'gpg --list-packets '.  What does that return?

@_date: 2009-08-27 21:49:22
@_author: David Shaw 
@_subject: rotating encryption sub keys 
It depends on what you're trying to do. :)
Not really, no.  I wouldn't rotate encryption keys for that reason,  but there are other reasons that might be more useful for you.  For  example, if, when you make a new subkey, you also destroy the old one,  you give yourself forward security.  All messages that were encrypted  to the earlier key cannot be decrypted by anyone (including you).  At  an extreme, you could use a new encryption subkey per-message  (something which the keyserver operators would no doubt be thrilled  about).  This is not generally useful, though, as most people do want  the ability to go back and review their old messages.
Incidentally, there have been proposals to add forward security  extensions to OpenPGP.  See

@_date: 2009-08-28 09:06:56
@_author: David Shaw 
@_subject: rotating encryption sub keys 
The idea of PFS is not one that works for all situations.  For those  that do want PFS semantics, the draft merely shows how to do it in the  context of OpenPGP.  Nobody is required to do this.  It's strictly opt- Not being able to decrypt an old message when using PFS is a feature,  not a bug.

@_date: 2009-08-31 11:34:40
@_author: David Shaw 
@_subject: LZMA Compression 
I've seen it mentioned once or twice, but not much more than that.   That said, adding algorithms to OpenPGP - especially compression  algorithms which have no security impact - is fairly easy to do.  I  suggest taking your suggestion to the ietf-openpgp mailing list.  The  folks there are very happy to discuss such things.

@_date: 2009-12-01 13:21:56
@_author: David Shaw 
@_subject: Equivalent segments between different Fedora & RPM Fusion ASCII 
It is normal.  Keys contain a certain amount of metadata and structure that is the same or similar for many keys.  When you convert keys to ASCII armored form, a few lines will thus naturally line up as the same.
It's an rpm timestamp.

@_date: 2009-02-01 21:43:37
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 1 
The packet header for any packet number less than 16 is utterly  irrelevant in every possible way.  GnuPG can change it to the new  format, the old format, or even mix the two in a pretty pattern.  And  without notifying the user.  Again, the packet header for any packet  number less than 16 is utterly irrelevant in every possible way
The packet header for any packet number less than 16 is utterly  irrelevant in every possible way.  Keyservers can change it to the new  format, the old format, or even mix the two in a pretty pattern.  And  without notifying the user.  Again, the packet header for any packet  number less than 16 is utterly irrelevant in every possible way

@_date: 2009-02-02 09:49:44
@_author: David Shaw 
@_subject: Notations / PKA 
Those are the only two real ones that I know of.  GPG interprets pka- address, of couse, but it merely "knows about" preferred-email-encoding at pgp.com   (i.e. GPG accepts it, but it is up to the MUA to act on it).
PKA information: preferred-email-encoding information: In the "non-real" category, I've seen "comment" used, but that is an  illegal notation name (it lacks the @ and domain, and is not  registered with the IETF).
That, I couldn't say.  It's been my experience that things involving  DNS and OpenPGP have not had particularly good adoption: not that many  people have access to their own DNS, and that acts as a barrier on top  of all the other usual OpenPGP barriers.

@_date: 2009-02-02 13:54:15
@_author: David Shaw 
@_subject: Detached Signature / Timestapm 
What do you mean by a detached cleartext signature?  A detached
signature that is ascii armored?  If so, then:
  --armor --detach-sign
1) It depends on what you plan on doing with the signatures.  If
you're just trying to show a timestamp for the document creation, then
yes, it's fine.
2) Again, assuming you're trying to show a timestamp, then no, it does
not matter.  The relevant timestamp is that imposed by the stamper
service, not the one imposed by your key.  Thus your key can be
compromised without affecting the timestamps.
Armored signatures are not any more stable than binary signatures.
The data is identical.  Only the file format is different.
If you're just doing timestamping, note that you can also just hash
the document and send that hash to the stamper service (i.e. your
personal signature doesn't add much to the equation):
  gpg --print-md sha256 (thedocument) | mail the-stamper-service

@_date: 2009-02-03 09:00:06
@_author: David Shaw 
@_subject: Keyserver question...again 
Don't use this one.  It unfortunately still runs pks, and does not  handle things like subkeys properly.
This server does not synchronize with the rest of the keyservers.   That's a feature, not a bug, as the intent of the server is to  validate your email address, as you noted, and it cannot do that if it  could learn keys from places other than the user.  It also signs your  key for you to show that the email address was checked (this can get a  little annoying as it re-signs the key now and then).   It's an  excellent server for particular uses.  Note in particular that it is  the default server in the commercial PGP product, so if you really  want your key to be found...

@_date: 2009-02-03 16:58:23
@_author: David Shaw 
@_subject: gpg: failed to create temporary file 
What is GNUPGHOME set to?  Is it fully qualified or is there a ~ in

@_date: 2009-02-04 16:35:11
@_author: David Shaw 
@_subject: Question about how to secure the signing key 
If the key was created with 1.4.9, the problem is already solved.  As
of 1.4.3 (2006-04-03), GPG supports the necessary cross-certification.
You'd know if you had the problem - every time you verify a signature
from an unfixed key, you'll get a warning about a missing

@_date: 2009-02-04 17:16:22
@_author: David Shaw 
@_subject: Question about how to secure the signing key 
Definitely.  Plus, now it is in the archives, so if someone was
wondering they'll see it.

@_date: 2009-02-08 10:25:54
@_author: David Shaw 
@_subject: Paperkey question 
Yes, you can.  That was one of the design goals in paperkey.  I wanted  to avoid the need for a program that may not be readily available when  you need it.  Paperkey automatically prints out instructions on how to  restore the key.  It's easier, of course, to use paperkey to do the  work, but in a pinch you can do it by hand.

@_date: 2009-02-08 11:55:38
@_author: David Shaw 
@_subject: Paperkey question 
Yes and no.  Someone could restore your private key in the sense that  they could recreate the same secret key file that you have.  However,  they could not use it as the paper key has the same passphrase as your  secret key.
You should protect the paper the same way you protect your electronic  secret key.

@_date: 2009-02-08 14:25:01
@_author: David Shaw 
@_subject: GPG - how to update keys to a new format? 
You can't convert a PGP 2.6 key.  GPG will happily use it (within some  limits, notably the IDEA cipher), but there is no way to convert it  into another sort of key.
I'd recommend revoking any key that was generated with PGP 5.0.  There  were problems with the random number generator in that version:

@_date: 2009-02-08 16:41:10
@_author: David Shaw 
@_subject: Paperkey question 
Yes, and yes.  In OpenPGP, a secret key is just a public key with some  extra stuff (the secret numbers) tacked on to the end.  That's how  paperkey makes the keys so small - it can safely leave off all the  public key information.

@_date: 2009-02-09 08:46:27
@_author: David Shaw 
@_subject: Paperkey question 
You can't take a public key and just attach the blob to the end.  A  secret key is made up of secret key packets.  You need to convert your  individual public key packets to secret key packets.  Split the public  key into packets, convert the individual packets, then reassemble the  Run "paperkey --file-format" and it will print out some pointers on  how to do this.

@_date: 2009-02-09 10:26:09
@_author: David Shaw 
@_subject: Paperkey question 
Please stop top-posting.
Next, you switch the type of each packet from public to secret (i.e.  change tag 6 to 5, or 14 to 7 for subkeys).  Then cat them all back  together again.

@_date: 2009-02-10 09:35:17
@_author: David Shaw 
@_subject: gnupg on celeron and atom cpus 
The PRNG is generally a function of the platform, not of the CPU.  If,  for example, you were running Linux on a Celeron or Atom, you'd have  the same PRNG as someone running Linux on any other CPU.
There is some fuzziness here - some CPUs may provide a PRNG, and there  are userspace entropy gathers like egd, but in general, use whatever  CPU you like.  GPG doesn't care.

@_date: 2009-02-10 11:30:07
@_author: David Shaw 
@_subject: paperkey  // ? feature request 
You don't need paperkey to do this.  Just use GPG.  If you import a  secret key and you don't have the matching public key, GPG will  automatically create a public key from the secret key.

@_date: 2009-02-10 12:57:07
@_author: David Shaw 
@_subject: paperkey  // ? feature request 
Then that's just storing a secret key.  Paperkey works by removing the
redundant part of a secret key (i.e. the embedded public key, the user
IDs, signatures, etc).  When you restore the secret key, you need to
provide a copy of the public key so that paperkey can restore the
secret key (putting back the redundant parts).
If you can't remove the redundant parts, then you're basically storing
a secret key, unchanged.

@_date: 2009-02-10 19:46:25
@_author: David Shaw 
@_subject: paperkey  // ? feature request 
This isn't completely true.  The USB protocol does have the concept of
a per-device serial number.  I don't know if I'd go so far as to call
it a GUID as it is only unique relative to the vendor and device type,
but in any event, it isn't always used by the manufacturer.  For
example, I have three USB drives on my desk at the moment.  One of
them has an actual (presumably unique) serial number, one has a serial
number of "FFFFFFFF", and the last has a serial number of "0".  There
is also no guarantee that the host computer will log the device serial
number (modern Linux does, but you're more likely to find some flavor
of Windows in an internet cafe).  There is also no guarantee that the
secret police will know what was run from the USB drive (the converse
is true as well, of course).
I can imagine the movie plot, though. :)
Do you have a cite on this recovery beyond that story?  I have not
heard of such a thing, and Google came up blank.  I wonder if your
sushi companion was pulling your leg.

@_date: 2009-02-10 19:58:41
@_author: David Shaw 
@_subject: paperkey  // ? feature request 
Not exactly: But still, I can imagine several ways USB drive can be traced - even  if it has a non-unique serial number and paid for with cash.  Most of  them sound somewhat silly outside of a movie (which doesn't make them  impossible - just amusing).

@_date: 2009-02-10 20:17:17
@_author: David Shaw 
@_subject: Hibernation and secret keys 
This is very true, and I wonder how many people carefully make sure
the GPG is using secure (unswappable) memory and then happily close
their laptop lids...
The GPG manual says this, but I don't expect many people read down
that far:
   Note also that some systems (especially laptops) have the ability to
   "suspend to disk" (also known as "safe sleep" or "hibernate"). This
   writes all memory to disk before going into a low power or even
   powered off mode. Unless measures are taken in the operating system
   to protect the saved memory, passphrases or other sensitive material
   may be recoverable from it later.
GPG does have some countermeasures against this sort of thing, but
given the nature of the problem, they are far from infallible.
These days, I pretty much assume that any storage device that I have
used has bits and pieces of sensitive stuff on it, and deal with that

@_date: 2009-02-10 22:58:37
@_author: David Shaw 
@_subject: paperkey  // ? feature request 
I suspect the better-quality or brand named ones are more likely to  have real serial numbers.  The ones that I have without serial numbers  are very much "no name brand".
Indeed.  Of course, even if the host does log the serial number, the  log is less useful if the serial number is "FFFFFF" or the like.  Not  that the lack of a serial number really changes the equation all that  much.  There are half a dozen or more ways for someone to be traced  through an internet cafe if the person doing the tracing is  sufficiently motivated and capable.  The Timothy McVeigh example from  earlier is particularly good here: the US government really, really  wanted to find him, and fast.  That is certainly "sufficiently  motivated and capable".

@_date: 2009-02-10 23:42:31
@_author: David Shaw 
@_subject: paperkey  // ? feature request 
Look for a program called "USB View".  I haven't used it myself, but  it is described as being able to print the entire USB tree.  Once  you're running look for the "iSerial" field.
Kingston DataTravelers do have serial numbers though.  I have one.

@_date: 2009-02-11 09:41:12
@_author: David Shaw 
@_subject: paperkey // ? feature request 
Even more amusing (and accurate) is the ALT text you can see when you  mouse over the picture.

@_date: 2009-02-11 10:36:15
@_author: David Shaw 
@_subject: Are GNUPG Keyservers ordinary LDAP Servers? 
Some of them are, yes.
Some of them are SKS: GPG speaks several keyserver protocols, including LDAP, HKP (what SKS  speaks), plain old HTTP, DNS CERT, etc.

@_date: 2009-02-11 15:52:00
@_author: David Shaw 
@_subject: Hibernation and secret keys 
Encrypted disks don't help without serious OS support around suspend.
Your machine suspends, and writes a snapshot of its memory to disk.
Sure, let's say it's even encrypted.  When you wake the machine, is
the encrypted disk still mounted?  If so, then why would I care if
it's encrypted or not?

@_date: 2009-02-11 17:00:46
@_author: David Shaw 
@_subject: Hibernation and secret keys 
Clearly you missed the point.  I've seen various cookbook sites on how
to do this, and some of them get it dramatically wrong.  Hence the
question: "When you wake the machine, is the encrypted disk still
If the answer is "Yes", then you're not protecting very much.  You did
not succeed in doing what you were trying to do.  If the answer is
"No", you at least avoided the usual pitfalls.

@_date: 2009-02-11 17:22:23
@_author: David Shaw 
@_subject: Howto import more than one key from a keyserver at a time 
Indeed, a whole lot of keys.  It might be more useful to pick a person
you are trying to make a connection to and just fetch the keys along
that path.  I've often thought that a clever keyserver could do that
(i.e. download the keys that form the shortest trust path between two
keys).  Wotsap and  are 80% of the way there

@_date: 2009-02-13 11:01:05
@_author: David Shaw 
@_subject: how to unrevoke a key 
Actually, keys can be unrevoked.  The catch is that you can't have
distributed the revocation for this to work.  Since you've sent it to
the keyserver, there isn't much you can do, sorry.

@_date: 2009-02-13 15:42:06
@_author: David Shaw 
@_subject: GMail PGP verification? 
Yes.  It's not clear exactly how they're going about this (and of
course, nobody has seen signing or encryption yet).  They could
possibly be heading towards a Hushmail type of system, where the key
activity can be done on your local system.
Even if they just do signing and sig verification, that would be a
huge boost in the number of signed messages out there on the net.  It
would certainly change the spoofed user equation, despite the various

@_date: 2009-02-13 16:05:43
@_author: David Shaw 
@_subject: GMail PGP verification? 
Yes, exactly.  This is more or less how Hushmail works, and we've seen
Hushmail give up cleartext under subpoena.  I'm not all that perturbed
by Hushmail's activity (which they were pretty clear about): it just
means that if your threat model includes such things as a legal order,
then you don't use the system.  I suspect the vast majority of people
wouldn't care very much if Google held keys for them - they're already
trusting in Google for many other things.

@_date: 2009-02-16 13:05:39
@_author: David Shaw 
@_subject: Transferring identity to a new public key 
Yes and no.  Such a message is okay so long as the person seeing it
treats it as a hint - that is, to go and fetch the new key, and then
build a brand new trust path to this new key.  As you note above, it
is pointless to assume the new key is good just because the old key
tells you.
They should ignore it (or more likely try and contact the keyholder
and figure out what is going on) if they cannot build a valid trust
path to the new key that does not go through the old key.
Yes.  It is bad practice to sign a key just because they signed a
previous key owned by the same person.  You should check each time.

@_date: 2009-02-16 13:16:36
@_author: David Shaw 
@_subject: FW from PGP-Basis: newbie question about bad keys 
"signatures not checked" means just what you guessed - the keys aren't
there, so GPG couldn't check them.
"bad signatures" means the signature was checked, but it turned out to
be invalid.
"not checked due to errors" is a grab bag for everything else.  A
common reason for something to show up in this group is a timestamp
conflict (for example, the signature is older than the key that issued
it).  When you do a --check-sig, some sigs are tagged with "sig%".
Look for those and you can usually read the reason for the error.

@_date: 2009-02-17 11:43:37
@_author: David Shaw 
@_subject: How secure asymmetric encryption to yourself? 
Let me make sure I understand the question - you are storing the  (encrypted) password file on the same drive as your public and secret  keys and you want to know if it makes a difference whether you you use  public key or symmetric encryption for encrypting that password file?
No, it doesn't matter either way.
If you use symmetric encryption, you are relying on a passphrase to  keep your encrypted password file safe.  If you use public key  (asymmetric) encryption, you are relying on your secret key to keep  your encrypted password file safe.... but you are relying on a  passphrase to keep your secret key safe.  Either way, you have a  passphrase to protect.

@_date: 2009-02-21 20:49:35
@_author: David Shaw 
@_subject: multiple e-mail addresses:  what are the solutions? 
On Feb 21, 2009, at 7:16 PM, gerry_lowry (alliston ontario canada)  That is one way to do it.  The other way is to have a single keypair  with multiple email addresses on it (using the --edit-key menu and  "adduid" you can add as many addresses are you like to a key).  And  then there is a blend of the two methods where you have more than one  keypair, each with some of the email addresses on it.
Which method you want to do with depends on what you're trying to  accomplish, and how you like to manage keys.  There is no one right  answer here - it's very much a matter of taste.
Personally, I like to use a different key for each overall purpose  (i.e. one key for $day_job, one key for personal and open-source  work), but again this is just what I like.

@_date: 2009-02-22 19:48:42
@_author: David Shaw 
@_subject: "Please select what kind of key you want" 
On Feb 22, 2009, at 6:54 PM, gerry_lowry (alliston ontario canada)  He recommends a RSA signing key and later adding a subkey for  encryption.  This is only a problem if someone does part 1 (the  signing key) of his recommendation and skips part 2 (the encryption  This is not correct.  A sign only key means sign only.  It has no  encryption capability.  That's why you need a subkey to handle the  (3) and (7) are special cases for advanced users.  They do not show up  in the menu unless the "--expert" flag is given.  They let you create  a key with any features that you want (for example, you could create a  RSA key that can sign and encrypt with a single key and not need  subkeys at all).  This is for advanced use only.
They are not meaningful there.  gen-key creates a primary key, and as  per the OpenPGP standard, a primary key must be able to issue  certification signatures.  An encrypt only key, by definition, cannot  issue signatures.
Again, not meaningful there.  addkey creates subkeys.  DSA+Elgamal is  not a subkey (it's a shortcut for specifying a DSA primary and an  Elgamal subkey).
No.  The numbers have changed in the past, and may well change in the  Not really.  It is true that the developer can choose to not allow  creating certain key types in their OpenPGP program.  It is also true,  though, that the developer can choose to not support an algorithm at  all.  The only algorithms that are required to be supported are DSA  for signing, Elgamal for encryption, 3DES as a symmetric cipher, and  SHA-1 as a hash.  Strictly speaking, everything else is optional.  Of  course, most programs support a good chunk of the optional algorithms.

@_date: 2009-02-23 16:19:53
@_author: David Shaw 
@_subject: "Please select what kind of key you want" ~~ suggestion to 
While I more or less agree with Robert, and would note that the GPG
built-in help is more intended as a reminder for those who already
have some understanding of the concepts (you're not going to learn to
code in C from the man pages), try typing a '?' here.

@_date: 2009-02-23 17:43:41
@_author: David Shaw 
@_subject: How secure asymmetric encryption to yourself? 
If you're already carrying around a PDA or smartphone, try:
(etc - there are at least half a dozen others depending on what PDA or
smartphone you have)
These are more usable as you always (as per the first statement) have
your PDA/smartphone with you, so you don't need access to any other
hardware or software to get your passwords.  They're searchable, and
can be backed up.
It's a reasonable question, of course, how secure these are.
Obviously their authors claim they are very secure.  Neither publish
source, but the 1Password people have a design document which
(assuming they followed it) shows them avoiding a lot of the common
mistakes people make when implementing this sort of thing (notably,
they were smart enough to not write their own crypto).
In practice, for me, it doesn't matter all that much.  Certainly they
are at least secure against casual snooping, which is all I need them

@_date: 2009-02-27 20:27:14
@_author: David Shaw 
@_subject: future proof file encryption 
Obviously, I'm a big fan of paper (exhibit A:    ), but the problem with prints is that you lose something when/if  you scan them back into the digital space.  It's a bit like a lossy  compression.  That said, I'd take a somewhat-degraded image over no  image at all.
It's not completely relevant to your example, but speaking of recovery  from paper: a lot of the early cinema was thought to be gone forever  because the negatives and all prints were lost or had decayed over the  years (early film was printed on a guncotton base - needless to say it  was highly flammable and degraded quickly).  It turns out that for  copyright reasons, some of the film companies had deposited paper  copies (essentially a photo print of each film frame) of the films  with the US Library of Congress.  The archivists re-photographed these  paper prints back onto film, and managed to reconstruct the original  movies.  See, for example,

@_date: 2009-02-28 01:40:29
@_author: David Shaw 
@_subject: future proof file encryption 
It's because black and white photographs and negatives contain actual  silver (another reason why old films are lost - they were melted down  for their silver content to make more film).  Color photographs and  negatives contain inks and dyes which can be very long lasting, but  still don't have the longevity and environmental resistance of the  silver.  For very long term storage, store it in the cold and in the  dark.  Don't display your only copy on the wall, or at least pay the  extra bit for UV blocking glass.  Really, though, if you have color  film you want to preserve "indefinitely", scan the negative to digital  and keep both the original negative in dark storage *and* the digital  copy (remastering it as needed).
If your color photos were shot on Kodachrome, incidentally, you're in  luck.  It has dark-storage capabilities that are vastly better than  any color negative film.
Drifting a bit from crypto here, I'm afraid.  We should wind this  subthread up.

@_date: 2009-01-01 20:23:58
@_author: David Shaw 
@_subject: how-to 1) remove a key, 2) avoid spam, 
Since it was never distributed, then you're in luck.  You can just  delete the key and be done with it.
   gpg --delete-secret-and-public-keys (yourkey)
This a matter of debate.  I don't think that spammers really care  about OpenPGP keys in particular.  In practice, the number of email  addresses on the keyservers aren't that great compared to other places  they pull addresses from.  The spammers might vacuum up some addresses  if someone links to the keyserver from a web page, but I doubt the  keyservers are being targeted specifically.  For most people, the  benefits of having an email address on your key outweigh the minor  risk of getting a few extra pieces of spam.
If there is only one UID, then it is the primary UID and you don't  need to do anything.  If there are multiple UIDs, then you can pick  one to tag as the primary via --edit-key.  That said, "primary"  doesn't really do very much - it's mainly a visual option so that the  chosen UID appears first in the list.

@_date: 2009-01-03 09:51:46
@_author: David Shaw 
@_subject: Which Key ID for Business Card? 
Neither.  You want the full fingerprint (9B9F 2D03 9996 AF83 9A4F CB26  20E8 0D0B F760 5786).  Some people, myself included, include both the  key ID (F7605786) as well as the full fingerprint.  Some people simply  boldface the last 8 digits of the fingerprint, as the key ID is the  same as the last 8 digits of the fingerprint.  However you choose to  do it graphically, the point is that you want the large fingerprint as  that is what (mostly) uniquely identifies your key.  The 8 digit key  ID is just a cut-down version of that which is easier to type in.
Your call on this one.  If your old key isn't widely signed by other  people, you have nothing to lose in revoking it and making a new one.

@_date: 2009-01-06 19:22:50
@_author: David Shaw 
@_subject: recover private key 
Do you have the file "secring.gpg"?  If so, you have your private  key.  If not, you don't.

@_date: 2009-01-06 19:25:37
@_author: David Shaw 
@_subject: Expire of elgamal sub 
You can have different expiration dates on an OpenPGP key.  The whole  key can expire, and individual subkeys can expire.  If the whole key  expires, it takes all subkeys with it (whether they are expired or  not).  If a subkey expires, only that subkey is expired.  In your  case, you have a (whole) key without an expiration date, and two  subkeys, one with an expiration date and one without.
That said, what are you trying to do?  What is the problem?

@_date: 2009-01-09 17:45:37
@_author: David Shaw 
@_subject: encryption bloats file 
Most OpenPGP programs compress files before they are encrypted.  Some
files (for example, already compressed files) are poison to
compression and actually get bigger.  Doubling in size, however, is
not likely.  In any event, you don't say that program generated this
file, but at least GPG detects common forms of already-compressed data
and will not attempt to compress it further.
If you can send me such an encrypted file (my key is 99242560) I will
look at it and see what is going on.

@_date: 2009-01-09 19:50:09
@_author: David Shaw 
@_subject: encryption bloats file 
Not double.  By definition ASCII armor is around 1/3 larger (actually  137%) than the original document (not counting headers and such, but  they only amount to a few hundred bytes, not megs).
Other way around - the original file was ~700MB.  The decrypted file  was ~350MB.
Incidentally, GPG has code to deal with the potential denial of  service from a "bzip bomb" like you mention.  See the --max-output  Scott, do you know what OpenPGP program created the file that was sent  to you?  Can you tell us what sort of data it it?  (text?  binary?   image file? (if so, jpeg?  mpeg? other?)   Also please try decrypting  the file again and add "-v -v" to the command line.  Please send us  anything you can that isn't sensitive (specifically the compressed  packet algo number, and the raw data size and mode from the literal  data packet).

@_date: 2009-01-09 20:15:29
@_author: David Shaw 
@_subject: Paperkey on windows 
It is absolutely ok and encouraged to send paperkey to whoever wants
it.  There are various ways to comply with the license (the GPL), but
one easy way is to do what you suggest and send a copy of the source
along with the binary.
In terms of trusting - well, that's up to you.  Windows users tend to
have to trust the people who compile things for them.
For what it's worth, I can probably release a Windows binary with the
next release of paperkey, which means it'll be signed by the same key
that signs the source tarball.  John, did you have to do anything
special to get it to build (is this mingw or something else?)

@_date: 2009-01-09 22:49:54
@_author: David Shaw 
@_subject: encryption bloats file 
That's helpful, as it indicates that the file was corrupt.  This could
explain why an encrypted file is so much larger than the decrypted
file - the decrypted file is truncated because the decryption failed
partway through.  Of course, that could just be this rejected file.
Can you check if your real file has some non-OpenPGP cruft glued to
the end of it?

@_date: 2009-01-10 09:54:34
@_author: David Shaw 
@_subject: Paperkey on windows 
A universal binary will run on both a PowerPC and Intel Mac.  Unless  you are using the same binary on both Macs (i.e. if you have multiple  Macs with different processors or are distributing binaries to people  who have PowerPC boxes), there is little point to doing this.  Just do  plain ./configure and let it figure out what options to use.
None.  ./configure does all the magic for you.
Same here.
As a general rule (for paperkey and really most programs), you just  build with ./configure and nothing else unless you are doing something  unusual or special.
It's probably in /usr/local/share/man/man1/paperkey.1, but that  doesn't matter unless you want to read the raw nroff manual file.   Just do "man paperkey" and let the machine do the work for you.

@_date: 2009-01-14 09:47:03
@_author: David Shaw 
@_subject: Paperkey on windows 
I'm gearing up for a new release of paperkey in the next several days.
No major change to the code - it's mainly a documentation update.  For
this release, I'm going to try and release a Win32 binary at the same
time.  This turned out to be much easier than I was expecting - plus
it's rather amusing to cross-compile a 32-bit Windows binary on a
64-bit Linux box, which is itself running within VMware on a Mac.
Anyway, if someone was willing to give the resultant Win32 binary a
quick test, please let me know (offlist).

@_date: 2009-01-14 11:53:36
@_author: David Shaw 
@_subject: Dan Brown - Digital Fortress book 
In Digital Fortress there are things called "computers" and things
called "human beings".  Quite near everything else - including what
these computers and human beings do - is fiction.
Well, maybe not that bad, but it certainly isn't good.

@_date: 2009-01-15 10:43:32
@_author: David Shaw 
@_subject: Dan Brown - Digital Fortress book 
Possibly Dan Brown used "freon" where he should have used "halon".  It
wouldn't be the first mistake in that book.  Not that halon doesn't
have its own dangers - the whole point of a gas fire supression system
is that it displaces or removes oxygen.  Which both humans and fires
are rather fond of...
I believe Halon is banned now (at least in the US) because of ozone
layer concerns, but there are some older systems that were
grandfathered in that are still in use.
Still, to give Dan Brown the benefit of the doubt, I've heard many
fire supression gases referred to as "Freon", whether they were or
not.  Freon is really a marketing catchall name for a lot of different
gases, some of which were actually used for fire supression before we
saw what they were doing to the ozone layer.

@_date: 2009-01-16 16:50:20
@_author: David Shaw 
@_subject: End of Line characters disappear after decryption 
This is almost a FAQ.  Most likely there is a textmode mismatch
between the encrypting side and decrypting side.
The issue is that different platforms handle text files in different
ways.  If you tell GPG to, it will resolve out these differences for
you, but some applications need their particular line endings
regardless of the platform.
Can you give us the details on how the file was encrypted?  Was it
encrypted with GPG or PGP?  The encrypting command line would be the
most useful thing here.  Also, please state the platforms (i.e. Unix,
Windows, etc) that you are encrypting and decrypting on.

@_date: 2009-01-19 10:39:24
@_author: David Shaw 
@_subject: storing gpg keys on a database 
Almost everything you need is done for you: set up a keyserver.
Given what you're describing, it sounds like a LDAP keyserver is the
way to go.  GPG talks to it natively, and you can do any sort of
queries you like.  For example, an email search can be as simple as:
(pgpUserID=*the-address at i.am.looking.for*)

@_date: 2009-01-20 08:54:55
@_author: David Shaw 
@_subject: storing gpg keys on a database 
You can think of an LDAP keyserver as a database.  It stores data, and
there is a query language to retrieve data in various ways.
You can do this in LDAP with something like
Hard to say - it's not clear what you're trying to do and why, so
we're all sort of feeling around in the dark.  Why don't you say what
you're trying to do, and we can help?

@_date: 2009-01-20 09:56:43
@_author: David Shaw 
@_subject: storing gpg keys on a database 
You can do this sort of thing with LDAP.
All keys signed by X:
Keys that have signed each other:
Did key "X" sign key "Y"?:
All keys not signed by X:
And so on.
To be sure, LDAP isn't SQL - you can't do all the complex joins and
relations you could do with a true database.  LDAP does have the big
advantage of being already written for you, though.
If you can express the questions you want to ask of your data in LDAP,
then I'd go the LDAP route.  If not, then a true database would
probably work better for you.

@_date: 2009-01-22 10:39:52
@_author: David Shaw 
@_subject: Paperkey 1.0 released 
Hash: SHA1
Given the recent paperkey discussion, I thought I'd mention that
paperkey 1.0 is now out.
  A reasonable way to achieve a long term backup of OpenPGP (PGP, GnuPG,
  etc) keys is to print them out on paper.  Paper and ink have
  amazingly long retention qualities - far longer than the magnetic or
  optical means that are generally used to back up computer data.  A
  paper backup isn't a replacement for the usual machine readable
  (tape, CD-R, DVD-R, etc) backups, but rather as an if-all-else-fails
  method of restoring a key.
  Unix (POSIX) source and Win32 binaries are downloadable at:

@_date: 2009-01-22 12:38:56
@_author: David Shaw 
@_subject: 1K file creation in PGP 
No, it will not.  GnuPG and PGP are two completely different code bases.

@_date: 2009-01-22 18:58:27
@_author: David Shaw 
@_subject: Paperkey 1.0 released 
Yes.  See RFC 4880, sections 5.5.3 and 11.2.  What makes paperkey
possible is that in OpenPGP, a secret key is actually the same thing
as a public key with a few extra fields tacked on (the ones specified
in 5.5.3).
Another nice side effect of this is that you can transform any secret
key into a public key.  In fact, GPG will do this for you - try
importing a secret key that you don't already have a public key for.
GPG will import the secret key, and then create a public key for it

@_date: 2009-01-23 15:39:52
@_author: David Shaw 
@_subject: A question about Camellia 
It's not enabled for anyone yet, whether in Japan or not, and really
can't be until Camellia is part of the OpenPGP standard.  There is a
draft RFC that adds Camellia (see
but until that draft is accepted as a new RFC, Camellia will not be
turned on.
It is true that the Camellia code already exists in GnuPG, but this is
there to help test the implementation.  It is not for general use, and
while we can't stop people from turning it on, they do so at their own

@_date: 2009-01-23 15:41:59
@_author: David Shaw 
@_subject: Silly question about secure deletion of files 
The two things have nothing to do with each other.  It's like asking
why human beings can't fly, but we still can eat lunch.

@_date: 2009-01-23 16:36:52
@_author: David Shaw 
@_subject: A question about Camellia 
While I understand, and even agree with many of their points, I tend
to disagree with the "strip it all out" folks.  OpenPGP is designed to
be flexible in dealing with multiple ciphers, and gives its users good
ways to pick a cipher that both the sender and recipient favor.  If
you only want to receive messages encrypted with 3DES, that's your
privilege, and when I send you encrypted mail I (or really, my copy of
GPG) will respect that and send you 3DES.  Similarly, when you send me
a message, it's my priviledge to give a list of ciphers, and it's your
privilege to pick from that list.  Send it in 3DES, and I will accept
Nobody but you and I have any input into the cipher choice when you
and I are communicating.  Which is as it should be.  The flip side of
that, of course, is that you do not have any input into the cipher
choice when I'm communicating with someone else.  Does that mean that
I feel a particular need to use Camellia/Blowfish/Cipher-X?  No, not
really.  But I do want the choice of what I use to be mine.
You have the ability to do pretty much that, but:
[ unknown] (1). Robert J. Hansen      Cipher: AES256, AES192, AES, CAST5, 3DES, IDEA
     Digest: SHA1, SHA256, RIPEMD160
     Compression: ZLIB, BZIP2, ZIP, Uncompressed
     Features: MDC, Keyserver no-modify

@_date: 2009-01-23 17:49:55
@_author: David Shaw 
@_subject: A question about Camellia 
This has nothing to do with your preference list.  GPG will happily
decrypt messages to any cipher, whether it is in your preference list
or not, as per the spec: "If an implementation can decrypt a message
that a keyholder doesn't have in their preferences, the implementation
SHOULD decrypt the message anyway, but MUST warn the keyholder that
the protocol has been violated."
You seem to be advocating that the community sweep away the ciphers
you don't favor so that nobody can use them.  I disagree, but can
understand the desire for simplicity.  At the same time, though, you
argue that using the part of the protocol that *as part of community
consensus* allows you to sweep away ciphers that you don't favor is
you imposing your prejudices on the community.  I'm not sure how to
reconcile those two statements.

@_date: 2009-01-23 17:52:48
@_author: David Shaw 
@_subject: Silly question about secure deletion of files 
This is incorrect.  Defragmentation does not need to land on a exact
place on the disk, and overwriting does.  Defragmentation ignores
remapped blocks, while overwriting cannot, etc.

@_date: 2009-01-23 23:57:25
@_author: David Shaw 
@_subject: A question about Camellia 
The spec is very clear on which preference must be used when it  matters to the protocol, and explicitly disclaims a choice when it  does not matter to the protocol.  This gives implementers the  flexibility to do useful things within the hard limits of the  protocol.  The semantics are extremely clear, including the places  where the spec dictates that the implementor can follow his desires.
If I allow (say) 3DES, AES, and Camellia, you can't send me anything  that isn't 3DES, AES, or Camellia.  If you really really really like  Camellia best, you can send that, even if I like 3DES better.  Why?   Because it's *your* message.  You're sending it.  It's your choice  within the boundaries of what I permit.
Standards are not written by the "Everything not forbidden is  compulsory" ants.  OpenPGP lays down the law where it matters, and  steps back when it makes no difference to the security of the protocol.
Why weird?  Every OpenPGP program supports 3DES (section 9.2).  3DES  is in every preference list (section 13.2).  You can pick from any  cipher in the preference list (also 13.2).  Thus, you can send 3DES to  everyone without reading the preferences, because you know from the  protocol that you are participating in that every preference list  always contains 3DES.  Just in case that wasn't clear, the spec even  mentions this exact case so there can't be any doubt: "Note also that  if an implementation does not implement the preference, then it is  implicitly a TripleDES-only implementation."
Computers, lucky us, are not people.  Still, if I told you ahead of  time that I would accept General Tso's chicken, a hamburger, or a  piece of pizza, and then asked you to choose, I should be quite  content with General Tso's chicken, even if I really wanted pizza.   Our "protocol" requires that.
I believe this is shortsighted.  Simple is good, but too simple is  inflexible.  "Make everything as simple as possible, but not  simpler."  When MD5 bit the dust, OpenPGP had several algorithms to  switch to (note that PGP 2.x did not).  When SHA1 was broken, OpenPGP  could almost shrug that off.  I say 'almost' because of the hard-coded  fingerprint issues - which also helps prove my point.  If fingerprints  were not hard-wired to SHA-1, the OpenPGP WG would not now be trying  to figure out a new fingerprint scheme.
OpenPGP benefits from the flexibility of being able to use multiple  algorithms.  Note that I'm also not saying which algorithms - like  you, I don't actually care all that much which are chosen, but I do  strongly care that the protocol as a whole can support different  algorithms safely and allow for changes without breaking things.  This  ability, to me, is necessary complexity.  Take the case of TLS 1.1: it  has MD5 and SHA-1 hard-wired throughout the design.  Now that it's  time to move away from those hashes, the TLS 1.2 designers had to do a  lot of painful hard work (causing much code complexity and  compatibility problems) to un-wire them.  It may be years before TLS  1.2 is really widely supported, and in the meantime TLS users are  going to use MD5 and SHA-1.  (There is interesting thread on this  right now on the cryptography mailing list, by the way).
I think this is actually a good example for my point as well (I love  an example which points out multiple things): Note when the Elgamal  signing key bug happened, it did not take down the rest of the  protocol.  People with RSA or DSA signing keys kept right on chugging.
Once you accept the idea that protocol algorithm flexibility is a good  thing (if you do), then you realize it doesn't really matter terribly  much which algorithms are in or out of the protocol, or even how many  there are.  If you like an algorithm, you use it.  If you don't, you  don't.  If you want smaller code or simplicity, you simply leave out  whatever you want to leave out.  4880 helpfully states what is  required (DSA, Elgamal, and 3DES, basically).  Everything else is  optional - the protocol does not require any of them.  The main thing  the protocol requires is that there is a concept of multiple  algorithms and the tools for dealing with that.
It does tend to argue against what you desire though: if you are  advocating that everyone in the community use a smaller algorithm  list, it does not really help your case when you don't use that  smaller list yourself, "proving" that it is workable in practice.
We had something close to what you describe though: RFC-1991, the old  PGP 2.x protocol.  It broke badly when MD5 broke badly (it was already  pretty broken).  It wasn't flexible enough to adapt.
Sure, just remove any algorithm you don't want.  The protocol in 4880  guarantees that you have the ability to do this:
  ./configure --disable-blowfish --disable-cast5 --disable-(etc)
I promise you that if you remove an algorithm, any bugs in those  algorithms, be they implementation problems or design flaws, will  never affect you. :)
Despite the joke, I'm really not kidding.  I added the --disable-xxx  flags because while I believe strongly that OpenPGP needs the  *ability* to handle multiple ciphers, I also believe just as strongly  that nobody should be forced into an algorithm they don't want used.   Set those flags, and you have a smaller codebase (the code is actually  left out of the build altogether) and smaller standard (you can ignore  any references to those ciphers in the standard).

@_date: 2009-01-23 23:59:29
@_author: David Shaw 
@_subject: compatibility of Gnupg-1.4.9 to Gnupg-1.0.6 
In the GPG tarball, in the "tools" directory, there is a script  "convert-from-106".  Run it, and you should be in better shape.

@_date: 2009-01-24 12:50:34
@_author: David Shaw 
@_subject: A question about Camellia 
But then, once we have algorithm agility, that means we must have a  means for dealing with that agility (preference lists being the  defined OpenPGP mechanism for that).  And then, having such means, why  do we care all that much whether an algorithm is present or not?
Camellia is a good example here.  It does not really bring something  new to OpenPGP in terms of security.  Sure, Camellia is believed to be  strong, and some studies have shown it to be strong.  But we don't  really *need* that - we have other ciphers that are (arm-wave here)  roughly as strong.  So why add it?  Because it brings something  helpful to the protocol as a whole - it means OpenPGP can be used in  certain environments in Japan that mandate Camellia.  More people  using OpenPGP is good.  That helps the community.
Do we want to add every cipher that comes down the pike?  Certainly  not.  Do we want to add well designed ciphers that have strong  evidence behind them?  Maybe, but still, why bother?   We have that  already.  Do we want to add well designed ciphers with strong evidence  behind them that people actually want to use (as opposed to the oft- heard "Yeah, it would be neat if OpenPGP had the new BLAH-256  cipher")?  Sure we do.  Or at least, I do.
So if I understand, the change you advocate is to move the optional  algorithms to an appendix?  They're already tagged as optional (they  can't, after all, be made *more* optional).   I think the 4880  language here is very clear:  you MUST support 3DES (the protocol  requires it), you SHOULD support AES and CAST5 (we recommend this, but  you're free to disagree, and the protocol will work just fine either  way), and you MAY support anything else you like (i.e. completely  optional, do what you like).
Remember that 4880 is not a guide to the coder, nor is it intended to  be used to favor or un-favor particular ciphers beyond what is  necessary for interoperability.  It is a mainly message format  document (note the title of 4880 is in fact "The OpenPGP Message  Format").  While there have been various suggestions for a "OpenPGP  Best Practices" sort of RFC, nobody has of yet stepped up to write  one.  I suspect this is due to the currently limited community of  people developing OpenPGP software, so it is not clear who the  audience of such an RFC would be.
In the meantime, though, we have a message format.  There is a section  for ciphers, and all the ciphers are in that section.  Having two  sections for ciphers would just makes people scroll around when  reading it.
My understanding is that you do not favor Camellia in OpenPGP (which  is what started this thread).  I don't quite see how to reconcile that  with your "algorithm appendix" comment.  After all, Camellia is in its  whole own draft.  You can't be more detached from the main RFC 4880  than that.
How?  You don't think they'd have just asked for all of the algorithms  in "Appendix A" rather than "Section 9.2" ?

@_date: 2009-01-24 12:50:49
@_author: David Shaw 
@_subject: compatibility of Gnupg-1.4.9 to Gnupg-1.0.6 
If "old" is 1.0.6 (circa 2001), and you haven't used any version of  GPG after 1.0.6 (i.e. you just upgraded from 1.0.6 to 1.4.9 like the  original poster) then you just need to run the convert-from-106  script.  There aren't any instructions beyond that.  The script takes  care of the various changes for you.
If you're not sure what to do, run it.  There is no harm in running it  when it is not needed.

@_date: 2009-01-24 15:07:21
@_author: David Shaw 
@_subject: expiring gpg keys 
That is not the case.  You won't be able to make new signatures or  encrypt new files with an expired key, but you can still verify old  signatures and decrypt old files after expiration.

@_date: 2009-01-24 15:14:51
@_author: David Shaw 
@_subject: A question about Camellia 
Why do Twofish, Blowfish, etc, need to be removed?  Mind you, I don't  care very much if they are, but we're drifting away from the "what to  do about new algorithms" question, to the "what do we do with old  algorithms once their useful life has passed" question.  Who do these  algorithms hurt?  Remember - they're all optional, all still  considered strong, and we have a robust system for choosing algorithms  so that nobody is ever forced to use them.
OpenPGP inherited some algorithms from PGP 5, before there was a  standard.  All of these algorithms were grandfathered in.  Some others  were added because people needed them.  If I recall, Twofish was added  to the spec before AES was finalized.  Twofish has a block size of 128  bits, which was needed, and at the time, no other ciphers in the  standard had that block size.
Adding new algorithms has nothing whatsoever to do with removing old  ones.  If Camellia is useful and needed, it is useful and needed  whether (say) Blowfish exists or not.  If someone wants to pursue  removing Blowfish, go right ahead, but they mustn't expect all forward  momentum to stop while the removal is discussed.  This is not an  algorithm swap.
Again, though: we have the means for people to remove the "cruft" on  their own.  I don't see people doing it.  One user's cruft is another  user's vital part of the system.
Who are the "others"?  Who is "people"?  Implementers aren't  confused.  We all know how to read a standards document.  The RFC  isn't meant for end users.  If the goal was a user manual, that's a  different document.
Management is not the target of a message format document, and we  cannot redefine how the thousands of RFCs are written just for them.   You can't make everyone happy with the same document, and trying is  frequently a fool's errand.

@_date: 2009-01-24 22:38:44
@_author: David Shaw 
@_subject: expiring gpg keys 
You don't have to do this if you don't want to.   If you set an  expiration date and the key expires, you can always change the  expiration date to a further date in the future (i.e. 'un-expiring'  your key).
This is what I do, FWIW.

@_date: 2009-01-26 09:52:19
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 1 
Look for the ietf-openpgp mailing list at Yes, see section 5.5.3 for the exact details, but in general 254  indicates that there is a SHA-1 hash of the secret data included.   This is to prevent a secret key tampering attack.
You could convert it, but there is little point.  The function of a  packet is the same no matter what.  It's purely a question of the  *contents* of the packet.  GPG uses the old format when possible for  backwards compatibility reasons.

@_date: 2009-01-26 09:54:49
@_author: David Shaw 
@_subject: Safety of the key and it's length 
It's difficult to say from the information here.   If you want to know  the size of your key, just do a --list-keys.  The size of the exported  key (especially when ASCII armored) does not really give you the  number you're looking for.  In the --list-keys output, the size of the  key is the number after the "pub" and before the "D" or "R" that  indicates key type.

@_date: 2009-01-26 11:31:16
@_author: David Shaw 
@_subject: Safety of the key and it's length 
It depends on who you need it to be secure against.  If we're talking
about protecting something from your roommate, then yes.  If we're
talking about protecting something from even a moderately funded
attacker, then no.
By way of example, a 512-bit number was factored way back in 1999.  It
took 5 months on around 300 machines running at 200-600 Mhz.  Today,
10 years later, I can buy multicore processors running at 3Ghz at the
office supply store down the street.  It would be interesting to see
how long such a job would take nowadays: even if we account for the
vast increase in computer performance, and the vast reduction in cost,
we also know more about how to attack the problem than we did 10 years

@_date: 2009-01-26 11:40:04
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 1 
Yes.  See  for the attack that
prompted this extra layer of protection.
The RFC says "If interoperability is not an issue, the new packet
format is RECOMMENDED."  Given that interoperability *is* an issue
(GPG works with PGP 2.x), we don't use the new packet format except
when necessary.
Really, though, it just doesn't matter.  It's the equivalent of
writing the number ten as "10" or "ten".  It contains the same value,
using different notation.
No, but you could patch it if you liked.  Take a look at the
write_header() and write_new_header() functions in build-packet.c

@_date: 2009-01-26 17:28:15
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 2 
It's a "token", that can be given from one person to another.  The
token contains only what is stated inside the signature itself.  Let's
say I put some useful information inside a notation packet, or perhaps
it contains identity inside a keyID packet, etc.  Think of it as a
physical token and some uses come to mind.
GPG doesn't support it.  Neither does any other OpenPGP program that I
know of.
It's used for designated revocation signatures.  There is no reason
why it *couldn't* be used for key expiration or key flags, but 0x13
works just as well for this.  OpenPGP supports both 0x1F and 0x13
(0x10, 0x11, 0x12), and historically people used 0x13, so there was
never a real reason to change.
It's a Notary signature.  For example: Alice writes a document.  She
later wants to be able to prove when it was written.  Obviously we
can't trust Alice's signature to prove that since she can set her
clock to whatever she likes.  We can, however, trust the notary (or
many notaries).  Alice signs the document, and then brings the
signature to the Notary.  The Notary verifies that the signature is
sane (i.e. the date is current) and then signs the signature (with an
0x50).  Alice gets her proof, and significantly does not have to show
the Notary her original document.
GPG doesn't support it.  Neither does any other OpenPGP program that I
know of.

@_date: 2009-01-26 17:31:39
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 1 
No, they don't have a concept of a packet type above 15.  There are
only 4 type bits in the old-style packet header. :)
Old programs will basically blow up if they see something they don't
understand.  There is a special packet, the Marker Packet (tag 10)
which basically exists to make PGP 2.x print out "You need a newer
version of PGP" before PGP 2.x would blow up.

@_date: 2009-01-26 22:57:37
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 1 
They should at least fail - a new style RFC-4880 (or 2440) packet (of  any type) is unreadable by an old RFC-1991 program.  It simply won't  be meaningful.  At to *how* it will fail, that depends on the program.
The point of the Marker Packet is to force a graceful failure early.
If there was such a situation, then forcing the use of a new packet  header would certainly break old programs, but this isn't sufficient:  most programs understand new packet headers, but they may not  understand your new packet type.  Or put another way - you can't solve  that problem with packet headers.

@_date: 2009-01-26 23:18:59
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 2 
Yes.  It's a valid key as per the spec, even though no program  actually generates such a key that I know of.  Note that I can't make  that same guarantee for other programs.  I suspect they'd work, but  you'd have to check to be sure.
They are similar, except that a timestamp signature is presumed to be  over actual data.  A notary signature is made over another signature.

@_date: 2009-01-27 10:48:09
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 3 
Pretty much, yes.  It's "the keyholder claims to be X and I believe  them, but didn't check."
In GPG, by default, it is simply ignored.  A 0x11 signature has no  value anywhere in a trust calculation.  You can change the default if  you like (or even make it more strict, by, say, ignoring 0x12  signatures as well) with the --min-cert-level option.
The RFC is really a file format document more so than a "how to use  trust" document.  Every now and then it is suggested that a trust  document or something like an OpenPGP best practices document should  be written, but nobody has taken up the suggestion yet.  So the RFC  that we have (4880) does not specify or deny this behavior: it simply  lists the signature types for reference.  So all that said, I don't  know if any other products ignore 0x11 signatures.  Keep in mind that  few products draw any distinction between 0x10, 0x11, 0x12, and 0x13  at all.  They treat all of the types identically and issue only 0x10  0x19 lives inside a signature subpacket on a signature that the 0x19  is making a statement about.  This makes it easy to find (it's always  on the subkey binding signature), and makes it naturally travel along  with the subkey that it is issued by (if you delete the subkey, the  0x19 vanishes along with it).  Semantically, it could be a top-level  The purpose of the back signature is to prevent "stealing" a signature  subkey.  For example, say Alice has a key with a signing subkey (but  no back signature).  She signs a document with her subkey and later  tries to prove that it is her work.  Baker, however, takes Alice's  subkey and attaches it to his key.  He can now try and prove that it  is his work.  To be sure, he doesn't have the passphrase for the key  and can't make more signatures, but he can verify signatures, and  verifying signatures would look like they were verified by  "his" (really Alice's) subkey.
One fix for this attack would be to ask both Alice and Baker to sign  something for you as only Alice could, but back signatures avoids the  whole shebang by having the subkey sign the primary key, making it  obvious which primary "owns" the subkey.
This attack isn't meaningful for encryption subkeys.  Baker can choose  to steal Alice's encryption subkey, but without the passphrase he  can't decrypt anything with it, and he can't claim anything in  particular after he has stolen it.  In any event, you couldn't make a  back signature with, say, an Elgamal encryption-only key.
There is no current means to do this in the standard.  There is no  reason for this beyond that nobody, as yet, has needed the ability.
The basic rule for this is put it in the hashed area unless there is a  reason not to.  The only subpackets that can safely live in the  unhashed area are those where, if they are modified, the security  semantics of the signature do not change, or the signature is broken.   Note that some programs put some things in one area that other  programs would put in the other.  All that said, GPG puts the Issuer  and Signature subpackets in the unhashed area.  These are the two  subpackets that are naturally tamper-proof.  Sure, an attacker can  tamper with them - but all they would accomplish is make the signature  not work (either because the signing key could not be found if they  mess with the Issuer, or invalidate the backsig for the Signature).
Yes and no.  Sure, if someone has the ability to modify the message  they can mangle the 16 bit "quick check" field.  But then, if they  have the ability to modify the message, they can mangle anything they  like.  Why restrain themselves to those particular 16 bits?  Mangling  - of any part of a signature - should cause the signature to be invalid.

@_date: 2009-01-27 11:21:40
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 2 
The magic of autoconf and careful programming.  When you run the  configure script when building GPG, it figures out what the sizes of  various items are in your system.  The code is written to do the right  thing and adapt to these sizes.
GPG doesn't run on a Windows 16-bit system, though.  That's ancient.

@_date: 2009-01-27 11:32:46
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 4 
I think at this point you should take the discussion to the ietf- openpgp list.  This is really the GnuPG users lists, and the questions  are in-depth design questions for the protocol itself.

@_date: 2009-01-28 09:15:36
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 1 
That is correct.  The packet header is not relevant to the contents.   You can change the packet header from old style to new style, or  change the length representation at will.

@_date: 2009-01-28 15:31:52
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 5 
On some platforms, a hardware RNG actually ends up feeding /dev/ random.  This is particularly nice as it means GPG (or any program  that uses /dev/random) benefits without code modification.

@_date: 2009-01-28 18:50:34
@_author: David Shaw 
@_subject: Selection of digest algorithm 
No.  OpenPGP/MIME can use any hash that OpenPGP can.  Possibly  Evolution is overriding the gpg.conf setting for your hashes?
Yes.  Or at least the current one is.  There is a new version of the  spec that allows for more hashes, but I don't believe there is a  physical card based on the updated spec that you can purchase yet.

@_date: 2009-01-29 09:07:41
@_author: David Shaw 
@_subject: gpg --list-keys  --with-colons 
Put the keyid at the end of the line:
gpg --with-fingerprint --with-colons --fixed-list-mode --list-keys

@_date: 2009-01-29 15:56:43
@_author: David Shaw 
@_subject: compatibility of Gnupg-1.4.9 to Gnupg-1.0.6 
That is correct.  The file conversion from 1.0.6 to 1.4.9 is one way.
If you want to go back to 1.0.6, you need to export your keyrings from
1.4.9 and then re-import them to 1.0.6.  You cannot simply use the
same files.

@_date: 2009-01-29 16:10:00
@_author: David Shaw 
@_subject: Series of minor questions about OpenPGP 5 
Use a Whirlygig device plus rng-tools to integrate the hardware device
randomness into the regular kernel /dev/random pool.

@_date: 2009-07-01 10:15:48
@_author: David Shaw 
@_subject: My public key block appears different on keyservers 
Not a bug or a problem.  OpenPGP keys can be represented in many  different, but functionally equivalent, ways.  Different keyservers  may choose different packet length types, etc.  In your particular  case, it looks like they just chose different places to place line  breaks in the ascii output.

@_date: 2009-07-02 08:48:00
@_author: David Shaw 
@_subject: My public key block appears different on keyservers 
No.  I'm saying that line breaks are one of many ways that they can  look different.  On casual glance, it looked like that was the only  As I said, OpenPGP keys can be represented in many different but  functionally equivalent, ways.  Different keyservers may choose  different packet length types, etc.
To torture an analogy, it's like the difference between "10" and  "ten".  They mean the same thing, but aren't literal matches for each  There is no particular requirement that same key exported from two  different servers match.  Forget keyservers in fact - there is no  particular requirement that the key file you import to GPG is the same  key file you get on export.  Like with the keyservers, it's the same  key. It's just been rewritten.  Don't worry about it.  It's not a bug,  and it's not a problem.

@_date: 2009-07-07 09:08:31
@_author: David Shaw 
@_subject: algorythm 11 mistake mac 
You need to contact the author of gpgmail.  Algorithm 11 (SHA-224) is  a later addition to the list of hashes in OpenPGP, but is perfectly  allowable in RFC-3156 (PGP/MIME) messages.

@_date: 2009-07-07 17:04:37
@_author: David Shaw 
@_subject: algorithm 11 mistake mac 
No, never use digest-algo.  It is almost always the wrong answer, and  causes a lot of pain and breakage in its wake.
He likely doesn't have any digest-algo set anyway - his key is a 2048- bit DSA key, which defaults to SHA-224 as its hash.  To override that,  use "personal-digest-preferences sha256" in the gpg.conf file, but  note that it may or may not work within gpgmail (it depends on how  gpgmail picks digests), and also note that it's chopping sha256 down  to 224 bits to fit.
However you cut it, the proper fix here needs to be in gpgmail.

@_date: 2009-07-07 18:02:42
@_author: David Shaw 
@_subject: algorithm 11 mistake mac 
Possibly.  It depends on what you believe it is irrelevant for.
A user using SHA-256 reasonably expects to get 256 bits worth of  hash.  It tends to be a surprise that GPG is silently lowering that to  224 bits behind the scenes (especially since the signature still  identifies as SHA-256).  It would be unfortunate, particularly on a  public mailing list, to give the impression that using SHA-256 instead  of SHA-224 with a DSA key built for 224 bits actually got you the  requested 256 bits of hash.  A more dramatic example would be someone  using SHA-512 with such a DSA key.  Despite the massive hash you are  working with, you still only get to use 224 bits of it.
It's an easy mistake to make, as this is not the case for RSA keys,  which use whatever hash you like without any truncations.
Or are you asking if there is there a significant difference between  SHA-256 truncated to 224 bits and straight SHA-224 in terms of hash  strength?  If so, no, there really isn't.  SHA-224 in fact *is* a  truncated SHA-256 with a different initialization.

@_date: 2009-07-07 18:23:17
@_author: David Shaw 
@_subject: algorithm 11 mistake mac 
You need to use what makes you happy, I guess.  GPG doesn't care one  way or the other, and this isn't one of those cases where doing the  "wrong" thing will hurt you in a significant way.

@_date: 2009-07-08 13:36:15
@_author: David Shaw 
@_subject: 8192bit RSA keys 
It depends on what you're protecting against.   For most common cases,  a 8192-bit RSA key is likely so vastly stronger than the rest of your  environment that a smart attacker wouldn't bother to attack it.   They'd just go after what they want via other attacks against you and/ or your environment.  Mind you, the same thing is true for a 2048-bit  RSA key as well.  (I'd wager that for many people, the same thing is  also true for a 512-bit RSA key).  If you can get the same end result  with a smaller key, you need to ask yourself what the big key actually  buys you.
If you're looking for a more immediate reason, though, note that if  you make a RSA key larger than 2048 bits you can't use it with the  spiffy new OpenPGP smartcard.

@_date: 2009-07-08 13:49:29
@_author: David Shaw 
@_subject: gnupg not building with gcc4 and --enable-minimal option 
Please don't top-post.
Try the most recent 1.4.9.  I believe this problem was fixed in 1.4.8.

@_date: 2009-07-08 15:16:11
@_author: David Shaw 
@_subject: Opinions on RIPEMD vs SHA? 
RIPEMD160 is nearly universally supported in popular PGP clients.   It's been around for a long time.
That said, you can't compare it to SHA-2.  I believe your academia/NSA  comparison is invalid (it's really just romanticism), but I'm not even  going to bother to restart the common algorithm/peer review/more  attacks/etc discussion that we've had a zillion times on this list,  and instead jump right to the easy reason:  RIPEMD160 is 160 bits  long.  SHA-2 is (at minimum) 224 bits long, and can go up to 512 bits  224 > 160.
512 is very > 160.
Unless you think SHA-2 is actually weaker than RIPEMD160 somehow, why  would you not use it?

@_date: 2009-07-26 23:09:18
@_author: David Shaw 
@_subject: Encryption keys in the OpenPGP spec 
Because it is difficult (or nearly impossible) to determine the  difference from the perspective of GnuPG.  That is, I as a person know  what I'm encrypting and what I plan on doing with it, but GnuPG just  sees bits.  As a general-purpose OpenPGP tool, GnuPG pretty much needs  to treat both communications and storage as the same thing.  Other  tools for more specific environments may "know" what their usage is  and can treat this differently.
This is expected behavior - the OpenPGP standard even mentions it:
    Note however, that it is a thorny issue to
    determine what is "communications" and what is "storage".  This
    decision is left wholly up to the implementation; the authors of      document do not claim any special wisdom on the issue and realize
    that accepted opinion may change.

@_date: 2009-07-27 10:33:23
@_author: David Shaw 
@_subject: IT Department having the secure key. 
If "locked" you mean "unavailable to anyone other than a keyholder"  then yes, they are effectively locked forever.
(Assuming you mean that the user actually encrypted the files - just  creating a key doesn't encrypt files, of course).
This will work (it's basically key escrow).  It's a risk (keep track  of your backups!), but everything carries some level of risk.  The  trick is to manage your level of risk to what you are comfortable with.
Note that schemes like this presume an honest user from the start.   They are not effective against a malicious employe who wants to cause  harm (which is not necessarily an issue, but worth mentioning).
It depends.  If only the passphrase is compromised (i.e. the attacker  didn't get the key file also) then changing the passphrase is  sufficient.  If the attacker got both the key and the passphrase, then  a new key must be generated.  The problem here (alas) is that it is  often difficult to tell whether an attacker got just the passphrase,  just the key file, or both.  It's often easier and more prudent to  assume that if the attacker got anything, they got both.

@_date: 2009-07-27 10:34:12
@_author: David Shaw 
@_subject: IT Department having the secure key. 
I'd use "encrypt-to" instead of "recipient", but basically, yes, that  will work.  It's a reasonably common solution for the problem.
This is similar in effect to PGP.com's additional decryption key (the  ADK has better granularity as it works on a per-key basis, but the  concept is the same).  However, note that this (and the ADK) both are  only really effective with an honest user.  If a user wants to  manipulate their key to remove the ADK (which is trivial) or edit  their gpg.conf to remove the extra encrypt-to line, then you'd need a  more central (and not under user control) way to guard against  trouble.  For example, if we're just talking about email, you could  tweak your mail server to check to see if the extra recipient was  present and if not, reject the message, etc.  I believe the PGP folks  have some variant of this ability, but you'd have to ask them for the

@_date: 2009-07-27 10:49:54
@_author: David Shaw 
@_subject: IT Department having the secure key. 
Somehow this thread mutated into being on both gnupg-devel and gnupg- users.  I'm only replying to gnupg-users.  Let's try to keep it on one  OpenPGP supports multiple recipients.  10 recipients do not require  10x the space of 1 recipient, instead, you end up with a single  encryption of the data, and then a small encrypted session key per  recipient.  So encrypting to 10 recipients is a bit larger than  encrypting to 1 recipient, but it is nowhere near as large as  encrypting to 10 recipients individually.  Any of the recipients can  decrypt the data.

@_date: 2009-07-27 11:35:38
@_author: David Shaw 
@_subject: Encryption keys in the OpenPGP spec 
As one of the authors of the document, I have already disclaimed any  special wisdom ;)
A contrived example: say you are in an environment where you do both  email (communications) and archiving data (storage).  You make a new  email (i.e. communications) subkey every year or so because you take  that key with you and want to make sure any exposure is limited.  You  only make a new archiving (i.e. storage) subkey every 10 years because  of the inconvenience.  Given those two use cases, you'd want the  ability to differentiate.
A better answer is that the ability is there in the standard as a tool  in the toolbox.  Whether the need to differentiate comes for legal  reasons (long-term storage needing a particular key type or size as  per regulation), or for convenience (as in my example), or for some  other reason altogether doesn't matter.  The ability is in the  standard in case someone wants to make use of it.

@_date: 2009-07-30 21:20:02
@_author: David Shaw 
@_subject: Changing GPG's default key type? 
There is theory and then there is practice.
In theory, there are some people who can't handle RSA as the standard  doesn't require it.  In practice (and especially given that the  original poster commented that 90% of the people he plans on  communicating with use GnuPG anyway), that number is vanishingly  small.  PGP in one form or another owns most of the OpenPGP market.   GnuPG owns most of the rest.  I wouldn't worry all that much.

@_date: 2009-07-30 21:20:13
@_author: David Shaw 
@_subject: Changing GPG's default key type? 
There is nothing particularly special about the change.  RSA keys are  part of the OpenPGP standard just as DSA is.  The difference is that  DSA is a required part of the standard, and RSA is optional.  The  reasons behind this are at least partly historical, and no longer  apply.  Nevertheless, RSA is still optional.
So yes, it is true that there could be an OpenPGP implementation out  there that does not support RSA.  In practice, however, I'd be very  surprised if you had any problems.  Even more so since you say that  over 90% of your correspondents use GnuPG.  Personally, I've used a  RSA key since 2002 and have never had even a single instance of  someone not being able to use my key because their OpenPGP program  didn't implement RSA.
In short, I wouldn't worry about it.  Use either DSA or RSA, and you  should be fine.

@_date: 2009-07-30 21:51:52
@_author: David Shaw 
@_subject: list of OpenPGP implementations [was: Re: Changing GPG's default 
Is that an example of a potential problem implementation?  Note that  the McAfee product does support RSA (not surprising, given its

@_date: 2009-07-31 00:22:52
@_author: David Shaw 
@_subject: list of OpenPGP implementations [was: Re: Changing GPG's default 
RSA was not added in RFC-4880.  It dates back to PGP 5 (1997-ish), and  was first formalized (in the RFC sense) in RFC-2440 in 1998.  It's  been in a RFC for 10+ years now.  Of course, it's been optional for  all that time as well.
Your comment is similar to the logic that we used when deciding about  making the RSA the new default key type: DSA-1024 wasn't cutting it  any longer for both length reasons and also the inability to use  larger hashes as it is locked to 160 bits (SHA-1 / RIPEMD160).  The  two best options we saw were either DSA2 by default (required by the  spec, but only added in RFC-4880 and so not as widely supported as  RSA), or RSA (not required by the spec, but very widely supported).  A  major reason we didn't choose DSA2 was because it wasn't widely  supported enough.  It turned out later that the PGP people made the  same decision for their product, and I actually found one product that  supports RSA but not DSA (yes, I know that makes them noncompliant,  but nevertheless they do exist).
Security (actually most things in engineering) is about balancing  various competing interests and issues.  Personally, I weigh the  ability to use a larger key with a larger hash more than I do the  knowledge that I might find some implementation that doesn't like my  key someday (I haven't actually found such an implementation yet, but  such an implementation could be written and be perfectly OpenPGP  compliant).  Others may not weigh things the same way, and GnuPG  serves them as well - they can create whatever key type works for  their particular balance.
Incidentally, a nice side benefit of RSA is the ability to store a key  on a smartcard.  I wasn't a major fan of the previous generation of  cards as you couldn't easily carry it with you unless you knew you had  a smartcard reader where you were going.  The new cards can be punched  for use in a SIM type reader, so the card plus the reader is the same  size as a USB "thumb drive" stick.  The smaller form factor makes a  dramatic improvement in the user experience for me.

@_date: 2009-06-02 13:06:05
@_author: David Shaw 
@_subject: Changing the expiration date after the key has expired 
Yes, you can.
This is fine.  Note that you can also change the expiration date of a  subkey by selecting it ("key X") and then doing the usual "expire".
This is a problem with the MIT keyserver.  It runs an older keyserver  software package, that is not fully compatible with standard keys (the  software was written before the standard was finalized).
Your best bet is simply to not use the MIT keyserver.  The other  keyservers (try "pool.sks-keyservers.net") should handle this case  without any problems.

@_date: 2009-06-05 10:45:40
@_author: David Shaw 
@_subject: backup all keys of DSA+ELG pair? 
It depends what you are trying to do.  If you want to export both the  secret and public keys, then do this:
Machine 1: gpg --export-secret-keys (thekey) > myfile.gpg
Machine 2: gpg --import myfile.gpg
If you want to export just the public key, then do this:
Machine 1: gpg --export (thekey) > myfile.gpg
Machine 2: gpg --import myfile.gpg

@_date: 2009-06-05 10:52:48
@_author: David Shaw 
@_subject: backup all keys of DSA+ELG pair? 
--allow-secret-key-import is a no-op.  It is no longer used for

@_date: 2009-06-05 11:03:20
@_author: David Shaw 
@_subject: backup all keys of DSA+ELG pair? 
Then something else must have been wrong.  That option does nothing.
          case oAllowSecretKeyImport: /* obsolete */ break;

@_date: 2009-06-05 13:07:14
@_author: David Shaw 
@_subject: backup all keys of DSA+ELG pair? 
Nothing is wrong.  When you export a key, all of the subkeys go along  with it.
Traditionally, the master key is used for signing and a subkey is used  for encryption.  In practice, you can actually have many subkeys, each  with whatever purpose you like.
No, the fingerprint does not change.  The key fingerprint is that of  the master key.
(Subkeys actually have fingerprints too, but you don't usually see  them since referring to the master key brings all of the subkeys along  Key revocation certificates are always generated for and by a master

@_date: 2009-06-05 14:46:56
@_author: David Shaw 
@_subject: Possible to recreate GPG using pen and paper? 
It is definitely possible.  It might take a while and use a good bit  of paper, but it's possible.  You would need to understand the public  key algorithm (RSA, for example) as well as the symmetric cipher  (3DES, AES, etc).  The actual bytes-in-a-row format is specified in  RFC-4880 (

@_date: 2009-06-06 09:30:08
@_author: David Shaw 
@_subject: the preference of signing keys question 
GPG will use the most recent valid subkey for a given purpose (i.e.  the most recent valid signing key, the most recent valid encryption  key).  If you want to force the use of a particular key, instead of  specifying your key as XXXXXXX (the key id), specify the exact key or  subkey you want as XXXXXXXX! (the key id plus an exclamation mark).

@_date: 2009-06-11 08:55:50
@_author: David Shaw 
@_subject: Primary uid not honored in 1.4.9 
I suspect that the primary UID is not actually being set somehow.  Can  you reply with "before" and "after" examples of a key (you can just  make a dummy key for this if you like) when you try and set the  primary UID?
   gpg --export (thekey) | gpg --list-packets
for both.  You're looking for a subpacket marked "Primary user ID".

@_date: 2009-06-11 09:32:12
@_author: David Shaw 
@_subject: Email signature 
I'm not sure it's exactly what you're looking for, but see: That is more of a way to signal a compliant mail reader that OpenPGP  is supported, and I think you're looking for a user-visible method.   Nevertheless, it's well worth a read.

@_date: 2009-06-17 09:20:02
@_author: David Shaw 
@_subject: Verify signature by specific key 
There is no way to do this directly, but a better answer than parsing  the stderr message would be:
gpg --status-fd 1 --verify (thefile)
Look for a line like:
[GNUPG:] VALIDSIG DDBA02CC9AE4EFC2A51F2DEA4B721440F246FA67 2009-06-17  1245244298 0 4 0 17 2 00 DDBA02CC9AE4EFC2A51F2DEA4B721440F246FA67
In order, the fields are:
  - the fingerprint of the key that made the signature (might be a    - the date of signing (according to the system that made the    - same as above in seconds-since-1970 form
  - the expiration time of the signature in seconds-since-1970 form,  or 0 if it never expires
  - signature version
  - reserved field (ignore it)
  - the algorithm used in making the signature (1==RSA, 17==DSA)
  - hash algorithm (2==SHA-1, etc).
  - signature class (00==binary signature, 01==text signature)
  - primary key fingerprint of the key that made the signature
Most of those fields are not relevant to your use.  Just compare the  last field (the primary key fingerprint) to the fingerprint of the key  that you want to confirm made the signature, and you should get what  you want.

@_date: 2009-06-23 00:34:38
@_author: David Shaw 
@_subject: cannot pass in input and passphrase at the same time in batch 
Assuming you're using bash as your shell, you want something like this  (but see below about --passphrase):
$echo abcd | gpg -u bob at xyz.com --output message.pgp -r alice at 123.com  --passphrase-fd 7 -se 7< I tried
Move --passphrase earlier in the command line (before the -se).
I thought you said you couldn't save the passphrase in a file, though  - isn't putting it on the command line effectively the same thing?

@_date: 2009-06-23 10:55:31
@_author: David Shaw 
@_subject: Hibernation and secret keys 
If possible, I'd also add a pause for running gpg processes to exit to  cover a small race condition.  Even if the passphrase cache is wiped,  if there is a running gpg process at suspend time, secret material  could still be caught in the hibernation data.  GPG does wipe its  memory for things like session keys (to the limit that such things can  be done in software), but the process has to complete for the wipe to

@_date: 2009-06-23 22:53:16
@_author: David Shaw 
@_subject: Key propagation 
Unfortunately, local signatures do not work that way.  Each  implementation strips local signatures both on export and on import  (just in case someone leaked one on export).  They just don't have  anything to do with exporting keys.

@_date: 2009-06-23 22:55:07
@_author: David Shaw 
@_subject: Key propagation 
You can ask those people, nicely, to not give your key out to anyone,  but that's about it.

@_date: 2009-06-23 23:01:06
@_author: David Shaw 
@_subject: corrupted file? 
ascii       Set the file transfer type to network ASCII.  This  is the default type.
Binary is not the default in the command line ftp program.

@_date: 2009-06-24 10:32:40
@_author: David Shaw 
@_subject: Key propagation 
A non-exportable self-sig would not be exported by the owner unless  the manually forced it to export.  Similarly, those self-sigs would  not be imported by anyone else unless they manually forced it to  import.  Similarly again, those self-sigs would not be re-exported  unless they were manually forced to export  And so on.
To say nothing of the fact that even if you did this, it just removes  the self-sigs, and a key is not required to have self-sigs to work!   The trust calculations will kick it out as invalid, but again, the  sender can ask for it to be used anyway.
It boils down to a very complicated way to say the same thing I said  before: "You can ask those people, nicely, to not give your key out to  anyone, but that's about it."

@_date: 2009-06-26 10:38:44
@_author: David Shaw 
@_subject: Question of a beginner: DSA/ElGamal or RSA/Elgamal with a higher 
There is no one "right" answer here, but there is general advice I can  Note that DSA is a signing algorithm (it does not do encryption), so  it would be more proper to say that DSA on signs with 1024 bits.
It is compatible with modern versions.  GnuPG has supported it since  That is not the case.
My advice would be to use a RSA signing key (the "primary" or "master"  key) and a RSA subkey for encryption.  The reason for using RSA for  signing is mainly because RSA lets you use larger hashes than DSA  does.  DSA2 also lets you use larger hashes, but RSA has been  supported for many years longer than DSA2 has.
As it happens, GnuPG will soon be switching its default key type to  RSA, for essentially this reason.

@_date: 2009-06-29 09:08:17
@_author: David Shaw 
@_subject: defining port number for keyserver searches 
If I understand your question, you're trying to set the *local* port  number that GPG uses when binding the socket to talk to a keyserver?   If so, no, GPG does not support that.  Why would you need such a  thing?  I suspect that there are other ways of accomplishing whatever  you're trying to do.

@_date: 2009-03-02 11:29:32
@_author: David Shaw 
@_subject: future proof file encryption 
I thought it was more or less dead, but then a new company popped up  to do silver YCM separations *generated from a digital scan*.   (Speaking about movies here - obviously anyone can generate  separations for stills with Photoshop or the like).  It's less crazy  that it seems on the face of it.  The separations have longer life  than a backup tape, and you don't need to remaster separations every  few years.  I still think I'd regard such a thing much as I regard the  paper key backups from paperkey: the backup of last resort.
Me too.  I think most people do, these days.  The only issue here is  that every few years, the scanning technology improves to the point  where re-scanning the original (chemical) image becomes worthwhile.   So you do need to keep the original around.
Indeed.  There is an interesting debate over whether digital photos  are too easy to erase.  Every now and then, the "unimportant" photo  turns out to be needed.  For example:

@_date: 2009-03-03 17:12:23
@_author: David Shaw 
@_subject: surrendering one's passphrase to authorities 
Well, maybe.  It's also possible that law enforcement does have the
ability to get into the encrypted data (by some means - I doubt brute
force), but does not want the knowledge of that ability to be made
(Note, incidentally, that this seems to be the "PGP Whole Disk"
product, rather than a PGP message, a la OpenPGP.)
It's an odd case.  Law enforcement *knows* what is on the laptop in
this case.  They saw it there before the computer was powered down
(thus locking the drive).  They are arguing over whether the
protection against self-incrimination (part of the US Bill of Rights,
for those who don't live here) even applies - after all, if law
enforcement already knows what is there, revealing the contents does
not incriminate.
Anyway, I, of course, am not a lawyer.  Instead, here is a discussion
of this case from someone who is:

@_date: 2009-03-03 17:18:33
@_author: David Shaw 
@_subject: Copy subkeys to primary key 
Is this combining two different secret keys (with different subkeys)
or combining two copies of the same secret key (with different
subkeys)?  If we're talking about the same secret key in both cases,
you can do it without any signature trickery.
1) Export both secret keys into files
   gpg --export-secret-keys 86ECAC0B > first.gpg
   gpg --export-secret-keys --secret-keyring secold.gpg 490CC343 > second.gpg
2) Run gpgsplit on the second file.
   gpgsplit second.gpg
3) Delete the parts you don't want.  You only want the subkeys, so
   delete everything until the first secret subkey packet (i.e. if the
   first secret subkey is 000004, then delete 000001, 000002, and
   000003).
4) Merge the keys:
   cat first.gpg 00000* > newkey.gpg
5) Delete the current secret key
   gpg --delete-secret-key 86ECAC0B
6) Bring in the merged key:
   gpg --import newkey.gpg
Obviously, make a backup first!

@_date: 2009-03-03 19:34:12
@_author: David Shaw 
@_subject: surrendering one's passphrase to authorities 
Good point.  I was thinking about the session key, which is basically  brute forcing proof.  The passphrase would indeed be an easier attack.
The lawyer discussion I posted ( ) suggests that law enforcement did try to "guess" (his word) the  passphrase.  Guessing could be anything from trying two or three  passphrases before giving up to running a list of common passphrases  against it.  For all we know, they're still running the passphrase  guesser right now.

@_date: 2009-03-03 19:58:31
@_author: David Shaw 
@_subject: surrendering one's passphrase to authorities 
This particular fellow was not necessarily the brightest bulb in the
bunch.  Remember that he also waived his Miranda rights (for the non
US readers: see Wikipedia for the details, but this is the "You have
the right to remain silent, etc" speech that you've probably seen on
US television and movies), and willingly showed the decrypted disk,
child porn and all to the border agents.
It was only after his arrest and the accidental re-encryption of the
disk did this passphrase issue arise.
There is, of course, a dramatic difference between how someone may act
when they're setting up their encryption at home and have time to
think things through, and how they may act when caught transporting
child porn over a border.
Even so, there are many things he could have done to try and hide his
illegal material *before* approaching the border.

@_date: 2009-03-03 23:58:50
@_author: David Shaw 
@_subject: auto key locate using keyid 
This is not currently possible.  It seems like it should be (the  principle of least surprise dictates that it should work with anything  that can be passed to '-r').
Let me think about this a bit.

@_date: 2009-03-04 13:43:30
@_author: David Shaw 
@_subject: auto key locate using keyid 
GPG does not strongly distinguish between these cases - either way,
the message is encrypted to the specified key, however that key is
located (by address or by keyid).
auto-key-locate grew out of the PKA and CERT feature.  When I
generalized it for PKA, CERT, and (automatic) LDAP, it grew the
ability to query any arbitrary keyserver.  To be sure, some of those
methods only could work with an email address.  PKA, CERT, and
automatic LDAP rely on an email address to find the key.  There is no
concept of a keyid there.  Keyservers, however, can accept either one.
(CERT actually allows for keyids in the protocol too, but GPG doesn't
implement that part).
So, assuming "auto-key-locate hkp://keys.gnupg.net" (or similar), the
surprise is that this works:
  gpg -r the-address at example.com -e the-file.txt
But this does not:
  gpg -r 0x12345678 -e the-file.txt
You can even extend the use case to stuff like:
 auto-key-locate ldap://my-company-keyserver hkp://keys.gnupg.net ldap://keyserver.pgp.com
And they will be tried in order until one of them succeeds.  While
most keyservers synch, a local company keyserver likely would not, and
things like PGP's global directory can't synch by their nature.

@_date: 2009-03-04 14:36:01
@_author: David Shaw 
@_subject: surrendering one's passphrase to authorities 
Why do you assume they wouldn't torture you anyway?  ("Reveal your
backups to us!"  "I didn't keep backups!"  "We don't believe you!")
After a news story like this, there is often a thread about technical
solutions to the problem (more encryption, better key management,
using hidden partitions that decrypt to pictures of puppies and
flowers instead of the illegal content when a different passphrase is
given, etc).
I suspect things would go rather like this:
 at metzdowd.com/msg10391.html

@_date: 2009-03-04 18:31:26
@_author: David Shaw 
@_subject: surrendering one's passphrase to authorities 
Indeed, and also (in the US at least), the attorneys for each side can
(to a limited degree that varies from situation to situation) remove
people from the "potential juror" list after interviewing them (a
"Voir Dire" challenge).  Frequently, one side or the other will remove
a juror with actual knowledge about the subject matter being covered
in court.  This makes sense from their perspective, as they would
rather the juror is a blank slate, only knowing what the lawyer says
on the subject, and not bring any of their own knowledge and opinions.
So if you're relying on a cryptography defense, your chance of finding
a juror who has any idea what you're talking about or has any means to
evaluate your statements is actually lower than it would be if you
picked random people off the street.

@_date: 2009-03-04 23:39:54
@_author: David Shaw 
@_subject: surrendering one's passphrase to authorities 
As I've said, I am not a lawyer, but the term "Voir dire challenge"  did, in fact, come from a real lawyer who I discussed my half-written  email with before sending it.  Simply Googling the term shows it in  rather common use.
It's not quite that simple.  My lawyer friend indicates that this can  cut both ways.  If one lawyer thought they had a very strong case,  they might actually want a smart or knowledgeable person on the jury,  going with the idea that this person would be able to explain the  complex issues to the rest of the jury.  Which of course may cause the  opposing attorney to challenge that person.  And so on, and around and  around.  This is why jury consultants make the big bucks.
We're now rather off-topic for GPG (and especially for a list that  serves more than the US).  Let's let this thread go, please.

@_date: 2009-03-05 00:02:21
@_author: David Shaw 
@_subject: Question about using additional keyrings 
Here's how it works: GPG allows for multiple public keyrings (via  "keyring") and multiple secret keyrings (via "secret-keyring").  The  default public keyring is $GNUPGHOME/pubring.gpg.  The default secret  keyring is $GNUPGHOME/secring.gpg.  Any keyrings, public or secret,  that you add are in addition to those defaults.  If you don't want the  defaults to be present at all, use --no-default-keyring.
Thus in your case, you have two secret keyrings, unless there is a -- no-default-keyring somewhere or $GNUPGHOME/secring.gpg does not exist.

@_date: 2009-03-05 00:50:09
@_author: David Shaw 
@_subject: Question about using additional keyrings 
The first one that is writable.  If you want to force it to be written  to a particular keyring, use the "primary-keyring" command instead of  just "keyring".

@_date: 2009-03-05 09:10:20
@_author: David Shaw 
@_subject: trying to understand UID and subkeys 
Neither.  It means you have 4 different ways other people can find  your key.  An OpenPGP key is made up of a pile of keys (a primary key  plus some number of subkeys) and a pile of user IDs.  Any of the user  IDs can be used to locate the key as a whole.  Sometimes people set  different preferences (essentially hints to the sender on how to  encrypt data) on different user IDs, but the key that they encrypt to,  and thus the key that you decrypt with, remains the same.
One reason is to have different keys for different purposes.  You can  have one subkey for encryption, one subkey for signing, and leave your  primary key for certification.  This lets you do tricks like keeping  your primary key offline.  This is useful as the primary key is the  most "valuable" key (since it can make more subkeys), so protecting it  is a good idea.
(S)ign: sign some data (like a file)
(C)ertify: sign a key (this is called certification)
(A)uthenticate: authenticate yourself to a computer (for example,  logging in)
(E)ncrypt: encrypt data

@_date: 2009-03-05 09:28:41
@_author: David Shaw 
@_subject: Import all keys from signatures 
Sure.  On the Ubuntu system, do this:
gpg --recv-keys `gpg --with-colons --list-sigs YOUR-KEY-ID-HERE |  egrep '^sig' | cut -d: -f5 | uniq`

@_date: 2009-03-05 12:23:05
@_author: David Shaw 
@_subject: trying to understand UID and subkeys 
No.  Primary secret key.  There is no risk in keeping a primary public
key online.  It's public already.
You cannot.  To make more subkeys you need both the passphrase and the
primary secret key.
Essentially, yes.  --gen-key always makes a primary key.  If you
accept the default, it also makes you a single subkey.  You can add
more subkeys to it later via --edit-key.
By offline I mean not even on your local hard disk.  Offline, say, on
a USB flash disk, or a CD-R.

@_date: 2009-03-07 08:25:34
@_author: David Shaw 
@_subject: gpg messages error after signing 
That is a normal part of OpenPGP called "dash escaping".  Basically,  since your signature itself starts with a dash (as part of "-----BEGIN  PGP SIGNED MESSAGE-----") any other dashes, such as those surrounding  your key that you're including in the signed message, need to be  escaped so the message parser does not get confused.  The way this is  done is to append a "- " (a dash and a space) to the beginning of each  Just verify the message to check the signature, and what comes out of  the verification step has all the escaping removed so you can use the  key you included.

@_date: 2009-03-12 12:55:13
@_author: David Shaw 
@_subject: trying to understand UID and subkeys 
"C" means this key permits the owner to certify keys (either your own
or someone elses).
"E" means the key can be used to encrypt, period.  It doesn't matter
if that is you or someone else.

@_date: 2009-03-17 09:04:47
@_author: David Shaw 
@_subject: Using GPG in embedded applications? 
In terms of legality - this is legal, but you must follow the  license.  GPG is licensed under the GPL.   See    for all the fine details (especially the FAQ there), but in general,  if you want to include bits and pieces of GPG in your application, you  must be prepared to release your application (both the PC side and  embedded side) under the same terms as GPG.
In terms of engineering - is this really what you want?  If your goal  is to encrypt over an insecure channel, see OpenSSL or GnuTLS.  If  your goal is to encrypt using a library of encryption code, see  libgcrypt or OpenSSL.  Libgcrypt, in particular, contains the same  crypto code as GPG (and more), packaged as a library, thus saving you  the bother of extracting it.  Note also that the licensing of these  packages are different than GPG, which may be of help as well.

@_date: 2009-03-24 12:06:13
@_author: David Shaw 
@_subject: TPK Archival 
Try something like this.
To encode:
  gpg --export-secret-key (thekey) | paperkey --output-type raw | dmtxwrite -e8 -f pdf > my_pdf_file.pdf
You can pass pdf, eps, svg, etc, to the -f option.  Use 'dmtxwrite -l'
to get a list of all supported image formats.
To decode:
  dmtxread -N1 my_pdf_file.pdf | paperkey --pubring ~/.gnupg/pubring.gpg > my_new_secret_key.gpg
dmtxread and dmtxwrite are part of the very clever libdmtx package at
I've actually been toying with building Data Matrix support directly
into paperkey (using libdmtx), but it's not clear what the point is
when dmtxread and dmtxwrite are so easy to use.

@_date: 2009-03-24 13:06:40
@_author: David Shaw 
@_subject: TPK Archival 
dmtxwrite uses ImageMagick for some image processing, so whatever file
formats ImageMagick can handle on your platform, dmtxwrite can handle
as well.
FWIW, I'm on Fedora 10 (ImageMagick 6.4.0.10) and I have PDF, SVG, and
PNG (and a few dozen others).

@_date: 2009-04-30 22:57:12
@_author: David Shaw 
@_subject: New results against SHA-1 
There is not much hard information yet, but the two big quotes are  "SHA-1 collisions now 2^52" and "Practical collisions are within  resources of a well funded organisation."

@_date: 2009-05-02 09:45:11
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
The short answer is that you can only use a 160-bit hash with your  default DSA key.  That means SHA-1 or RIPEMD/160.  There is a feature  you can enable (--enable-dsa2) that will allow you to use a bigger  hash -- but you can still only use 160 bits worth of it.  So if you  use SHA-256, you're actually only taking 160 bits worth of it and  discarding the rest.
To truly use all of a larger hash, you need to either use a RSA key or  a large (not default) DSA key (i.e. generated with --enable-dsa2  switched on, and a larger size than 1024 bits selected).

@_date: 2009-05-02 15:14:50
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
Yes.  (You can place it anywhere you like, depending on how highly you  rank it).

@_date: 2009-05-02 16:38:51
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
They're different algorithms that have the same hash size (160 bits).   The recent attacks against SHA-1 do not apply to RIPEMD/160, but note  that RIPEMD/160 is attacked far less than SHA-1 is.

@_date: 2009-05-03 22:56:24
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
It's always good advice to stick to the defaults, but it's possible in  this case that it's time to change the defaults.
In the meantime, while the defaults are being pondered, if your  current primary key is a 1024-bit DSA key (it'll say "pub 1024D" when  you do a key listing), then you should consider migrating to something  else.  That "something else" can either be a DSA key that is larger  than 1024 bits (often called "DSA2") or an RSA key that is larger than  1024 bits.   Different people have different opinions on which is a  better choice and there is no one right answer.  For what it's worth,  I personally favor RSA as RSA+SHA-256 has been around longer than  DSA2+SHA-256 and is therefore somewhat more widely supported over the  various OpenPGP clients out there, but DSA2 has some good things about  it, particularly that the signatures are physically smaller, and thus  aren't as intrusive over email.
It's important to remember that this isn't a completely SHA-1 free  key, as that is not currently possible in the OpenPGP protocol, but it  is possible to make a "use as little SHA-1 as possible key".
The way to make the new key is a little bit fussy, I'm afraid, as the  defaults in GPG are sort of built for SHA-1.
If you want a DSA2 key:
   gpg --enable-dsa2 --gen-key
Select option 1, and enter 3072 for the DSA key size.  Hit enter.   Then enter a key size for the encryption subkey.  The default (2048)  is fine.
If you want an RSA key:
  gpg --cert-digest-algo sha256 --gen-key
Select option 5.  Enter a RSA key size.  The default (2048) is fine.   Finish generating the key as usual, then type:
  gpg --cert-digest-algo sha256 --edit-key (yourkey)
  addkey
  6
Enter a keysize for the subkey.  Again, the default (2048) is fine.
For either case, finish up by sticking "personal-digest-preferences  sha256" in your gpg.conf file.
The end result will be a key that does not use SHA-1 either in its  internal construction or in signatures it makes elsewhere.  Keep in  mind that there are some clients out there that simply cannot cope  with this key and will reject it with one failure message or another.   The most recent versions of either PGP or GPG can handle it just fine.

@_date: 2009-05-04 08:51:56
@_author: David Shaw 
@_subject: New results against SHA-1 
In theory, OpenPGP implementations should cope just fine with multiple  keys having the same fingerprint.  What to do depends on the context,  but you could for example try all of the same-FP keys to verify a  signature, etc.
In practice, however, I suspect that most, if not all, OpenPGP  programs would exhibit strange behavior of one sort or another.  This  sort of thing is hard to test for since it essentially implies  creating a SHA-1 collision (which even with the recent discoveries is  not a trivial thing).  It's possible to fake a collision in the code,  but again, they're so absurdly rare there are other bugs that would  hit first.
In the computer urban legend department, I actually heard a story once  about someone who claimed to have (completely accidentally) generated  a key with a colliding fingerprint.  Unfortunately he deleted it  because he thought it was a bad key when his client didn't behave well  with it....  You may draw from that what you will!

@_date: 2009-05-04 22:44:12
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
Heh.  It's because of fussy internal parameter settings.  DSA2 keys  can use different hashes, and the hashes they use are tied to the key  size.  There is some looseness in the parameters, but in GPG it  basically it boils down to this:
If the key is over 2048 bits, use a 256-bit hash.
If the key is over 1024 bits, use a 224-bit hash.
Otherwise, use a 160-bit hash.
I couldn't specify the DSA key to be 2048 bits long to match the RSA  key because that would have given it a 224-bit hash instead of the  promised 256-bit hash.

@_date: 2009-05-04 23:46:33
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
I believe that's it.  Fingerprints, revocation signatures (which use  fingerprints internally), and the MDC.
While I would start (did start, actually, a few years ago) using  SHA-256 to certify other people's keys, I wouldn't bother re-issuing  older SHA-1 certifications.
Re-issuing your self-sigs is more or less harmless.  The keyservers  never delete anything, so they'll end up with both the old and new.   Assuming all works properly, the newer clients should end up using the  newer selfsig, and the older clients should keep using the old one (as  they won't be able to verify the new one).  If you're distributing  your key outside of the keyservers, then you can go further and strip  off the old SHA-1 selfsig.  If you do this, you can end up breaking  compatibility with some non-zero percentage of the community.  The  exact amount of breakage depends on your particular circle of  correspondents and how often they upgrade, etc.

@_date: 2009-05-05 22:16:17
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
It depends on the attack.  What is the attack you are concerned about?
They mustn't do this.  They can't, really.  It would enable a pretty  trivial DoS if I could make up a bogus self-sig with some hash number  that isn't even allocated yet, but a later date, and send it to a  keyserver to be attached to my victim key.  GPG must treat any  signature that does not verify as irrelevant.

@_date: 2009-05-07 20:09:31
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
It depends on what the attack is :)
One fear that I've seen talked about for SHA-1 is that an attacker can  create a duplicate document such that if you signed document or key A,  they could come up with a document or key B that your signature would  equally apply to.  That fear is more than a little overblown.  Even  MD5 hasn't been broken to that extent.
But for the sake of argument, let's say that this fear is realistic.   In that case, it doesn't make much of a difference whether you re-sign  or not.  If you do re-sign, the attacker can still get the earlier  signature from a keyserver.  Even if you revoke it, the old signature  is still there.
No, you are right.  When making an important statement about your key,  and you want to make it with an algorithm that doesn't have widespread  support yet, you do need to take into account that not everyone might  be able to understand your new statement.  To them, it would be as if  you had said nothing at all.
A key revocation is a perfect example of this.  You could end up with  part of the community thinking you revoked your key and part thinking  you did nothing.  Personally, if I was revoking a key, I'd use  whatever hash algorithm I used for my self-sigs (using the logic that  anyone who could use my key at all would see it was revoked, and that  I don't particularly care if people who can't use my key at all  (because they don't know that has) see if it is revoked or not).

@_date: 2009-05-08 08:53:02
@_author: David Shaw 
@_subject: Use other hash than SHA-1 
That's a different sort of attack.  In the rogue CA attack, the  attackers generated both A *and* B themselves.  They then arranged to  have A signed, and were then able to reveal B as if it had also been  signed (massive oversimplification, of course, as there was a huge  amount of work involved in even making that work, but the point here  is that the attackers generated both A and B themselves).  It's a  collision attack.  This attack (which again I must stress does not yet  exist for SHA-1) is one of the reasons why it's a good idea to switch  to SHA-256 for new signatures.  That's just prudent.
There is no current attack, however, against any hash algorithm in  OpenPGP, that would allow an attacker to pick some arbitrary signature  out there and generate a key or document that hashes to the same  value.  This is a preimage attack, either variant of which could be  used against OpenPGP, but neither of them currently exist - not in  MD5, and certainly not in SHA-1.  This (lack of) an attack is why I  don't think people need to worry all that much about their existing  signatures that are out there.

@_date: 2009-05-08 16:09:19
@_author: David Shaw 
@_subject: gpg: WARNING: standard input reopened 
It's a old bug in RPM, but it was fixed a long time ago.
The fix is to upgrade your version of RPM.  In the meantime, you can  ignore the error. It's harmless in the RPM case.

@_date: 2009-05-08 16:11:19
@_author: David Shaw 
@_subject: GPG Confirmation 
You need to tell GPG that your partner's key is valid.  To do this:
   gpg -u my-key --lsign-key my-partner-key
Then set 'my-key' to ultimate trust if you haven't done that already.

@_date: 2009-05-10 14:04:13
@_author: David Shaw 
@_subject: Problems changing hash algo for clearsign 
Please do not do this.  There is an entire section entitled  INTEROPERABILITY in the manual giving reasons why this will almost  certainly break things for you.

@_date: 2009-05-10 14:02:31
@_author: David Shaw 
@_subject: Problems changing hash algo for clearsign 
If the key you are trying to make a SHA256 signature with is the same  one that you signed this message with, then you can't.  It's a 1024- bit DSA key, and that key can only use a 160 bit hash.  (You can force  it to use SHA256, but you'll still end up using only 160 bits of the  256 bit hash).

@_date: 2009-05-12 09:38:20
@_author: David Shaw 
@_subject: Question regarding signature 
gpg -u (the-key-i-want-to-sign-with) --sign-key (the-key-i-want-to-sign)

@_date: 2009-05-12 10:20:05
@_author: David Shaw 
@_subject: Decryption streaming 
GPG (the program) can decrypt as a stream.  You can either write a  program that wraps around it, or use the GPGME library to do the work  for you.

@_date: 2009-05-14 23:25:31
@_author: David Shaw 
@_subject: Photo's in keys? 
The pic must be JPEG and the extension doesn't matter.  GPG doesn't  really care what the size is, but if it is over 6k, you'll get an "are  you sure?" message, as it is kindness to the rest of the world to keep  key sizes from getting out of control.  GPG does not manipulate/resize  the photo in any way.  The command is "addphoto", in the --edit-key

@_date: 2009-05-15 00:10:36
@_author: David Shaw 
@_subject: Photo's in keys? 
These days it's 120x144, but in the past it was double that (220x288).
Incidentally, GPG will allow you to have more than one photo ID, and  PGP only permits one.  PGP (9, anyway) will accept a key with multiple  photo IDs, but it will only show you one photo.  This is actually a  bit of a step backwards - in earlier versions it showed all photos,  even though it would only generate one itself.

@_date: 2009-05-16 19:34:09
@_author: David Shaw 
@_subject: There are actually two public keys? 
Exactly right.  In your example, both the primary key and the subkey  are public keys.
Basically, you can have multiple public/private key pairs.  When  people say "public key" in the OpenPGP world, they generally mean "My  public primary key, and any public subkey(s)".  Similarly, when people  say "secret key" or "private key" in the OpenPGP world, they generally  mean "My secret primary key, and any secret subkey(s)".
The common OpenPGP key of a primary key and one subkey is 2 key pairs:  the public primary, and its secret, and the public subkey, and its  secret.  Each additional subkey is a public/private key pair on its own.

@_date: 2009-05-16 23:40:10
@_author: David Shaw 
@_subject: There are actually two public keys? 
That's one of the reasons.  There were actually a good few reasons for  the switch at the time (the "PGP 3" timeframe, which became the PGP  5.0 product).  One reason was legal, and not technical.  RSA was still  patented at the time, so that couldn't as easily be used.  DSA was  chosen, but DSA can't encrypt, which pretty much required a multiple  key (primary key + subkeys) solution.  In addition, though, the  multiple key solution was chosen for its flexibility, as you noted.   It is handy to be able to make multiple subkeys and regenerate them as  One thing the multiple subkey design makes possible is to keep the  primary key offline altogether, and just use subkeys for all the day  to day encryption and signing needs.  In this way of working, the  primary key is only used for two purposes: to make new subkeys when  that becomes necessary, and to sign other people's keys.  When it is  not in use (i.e. most of the time), the primary key is stored on  separate media (say, a CD-ROM or USB stick).  See the --export-secret- subkeys description in the GPG manual for more on this.
Note, though, that if you want a single key for everything, you can  still do that.  Generate yourself an RSA key using the --expert flag,  and you can create a key that is capable of both encrypting and  signing in a single key.  It's unusual, and I don't recommend it, but  GPG will happily use it.

@_date: 2009-05-18 19:58:08
@_author: David Shaw 
@_subject: There are actually two public keys? 
Signing with a subkey has a slightly different meaning than signing  with a primary key.  When you sign a key, you're actually signing a  combination of the primary key and user ID that you chose to sign.  If  you signed with a subkey, you'd lose the nice symmetry of signing with  the thing that your friend is also signing on your key.  Rather, you'd  be signing with something one "hop" away from that primary key, as the  subkeys are signed by the primary.
Perhaps a more immediate answer is that nobody ever implemented it.   OpenPGP itself doesn't care (OpenPGP actually doesn't specify all that  much about trust models and the web of trust).  Historically, the web  of trust was built between signatures between primaries, and that's  what everyone implements today.  At one point there was talk of  publishing a standard for the web of trust, but there didn't seem to  be much interest in it.
To do this, you have to have the key in primary key form in the  (local) web of trust.  If you don't, then the signatures won't be used.

@_date: 2009-05-19 20:19:17
@_author: David Shaw 
@_subject: There are actually two public keys? 
I wouldn't think so.  The rest of the world will likely never even  notice that you're doing it, and the only person who you can really  hurt here is yourself.  At worst, you'd be denying other people the  use of some key signatures that you made.

@_date: 2009-05-21 12:00:40
@_author: David Shaw 
@_subject: GNUPG 1.2.1 problem 
Yes.  If you use the --skip-verify option to GPG, it will do the  decryption step, but not do the verification step.
Note, though, that may not be what you want if the signature over the  data is important to you.  In that case, you must either upgrade or  ask the person sending you the message to use a digest algorithm that  you can handle.  You can get a list of digests that you can handle by  typing "gpg --version".  The "Hash" list is what you can handle.
"Algorithm 8" is SHA-256.  Those folks who want a switchover to  SHA-256, pay attention :)

@_date: 2009-11-04 13:34:49
@_author: David Shaw 
@_subject: Interesting article on password guessing via cloud computing 
This is not, of course, an OpenPGP "crack", but rather high-speed  password guessing.  The nice thing about cloud password guessing is it  enables people to spin up massive cracking farms without actually  having to manage the racks and racks of running hardware.

@_date: 2009-11-04 20:03:36
@_author: David Shaw 
@_subject: Interesting article on password guessing via cloud computing 
Of course not.  Where did anyone say it was free?
I said "The nice thing about cloud password guessing is it enables  people to spin up massive cracking farms without actually having to  manage the racks and racks of running hardware."  Running hundreds of  machines is difficult and expensive in terms of the physical plant:  lots of racks, lots of cooling, lots of electricity, lots of  management.  Amazon does all that for you (and charges you for it, of  course).  Given Amazon's size, they can generally do the messy part of  managing hundreds of machines (especially since they are virtual  machines) cheaper than you can.

@_date: 2009-11-08 21:46:08
@_author: David Shaw 
@_subject: gpg rejects SHA224 with DSA-2048 
That's not quite how it works.  What matters here is how the key was  generated in the first place.
One of the numbers used to generate a DSA key is known as "q".  In  DSA, the size of q is what controls the size of the hash that will be  used with the key.  This value is set at key generation time, and  cannot be changed (it's part of the key).  It has no strong  relationship to the overall key size, so in theory, you could have a  2048-bit DSA key that uses a 8-bit hash.  Of course, that would make  for pretty poor signatures, so the DSA spec (and OpenPGP spec in turn)  give some guidelines as to what hashes should be used for a given key  size.  For a 2048-bit key, you can choose either a 224 or 256 bit q.
So, let's say you had a 2048-bit key, and the program you used to  generate it chose a 256-bit q size.  This key would allow a 256-bit  hash.  A 224-bit hash is impossible (too small).  If you had a 2048- bit key and the program you used to generate it chose a 224-bit q  size, this key would then allow a 224-bit hash.  A hash larger than  224 bits is allowable as well, but would be truncated down to 224 bits  to fit.
The problem you are having is that whatever program generated your key  chose a 256-bit q size.  That parameter, chosen at key generation  time, not GPG at signing time, is what is preventing you from using  So the real question here is why did your program generate a DSA key  with a 256-bit q, when a 224-bit q would have been equally acceptable  according to the spec?  As you say, they are both legal.  The answer  there is that while both are legal, a 256-bit q is slightly stronger  as it allows a larger hash to be used.  Both PGP and GPG use a 256-bit  q for a 2048-bit key.  However, if you managed to generate a 2048-bit  key with a 224-bit q (as earlier versions of GPG did), all versions of  GPG would (correctly) allow the use of SHA-224 with this key.

@_date: 2009-11-08 23:45:43
@_author: David Shaw 
@_subject: gpg rejects SHA224 with DSA-2048 
NIST, along with RFC-4880, says that you can use either 224-bit or 256- bit hashes with DSA-2048.

@_date: 2009-11-09 09:53:45
@_author: David Shaw 
@_subject: gpg rejects SHA224 with DSA-2048 
Very questionable, indeed.  There are a number of places where the  various standards that comprise OpenPGP, and the OpenPGP standard  itself, give the implementor leeway to pick path A or B.  Each  additional line of code to implement changes to accommodate stuff like  this adds testing time, adds potential for bugs, and takes away time  from more useful things.  IT department rules don't always make sense,  but you can't make a product like GPG in constant fear that some  hypothetical IT department will take offense at some particular  obscure detail in it (a detail, again, that is correct as per the DSS  and OpenPGP specs).  If that IT department became non-hypothetical, it  might be worth looking at.
In any event, that hypothetical IT department will find it rather hard  to use OpenPGP at all - offhand, I can't think of any current OpenPGP  product that supports DSA over 1024 bits that doesn't use a 256-bit q  for a 2048-bit key.

@_date: 2009-11-11 09:01:09
@_author: David Shaw 
@_subject: Is it safe to put an encrypted file on a public web server 
Yes, it is safe, but keep in mind that this rests the complete  protection of the data on the passphrase (i.e. it had better be a good  one, since an attacker can download your encrypted backup and spend  all the time they like trying to find the passphrase).  Generally,  people don't put their encrypted files in a public place.  This aids  in protecting the data since if the attacker can't get the file at  all, they can't even try to attack the passphrase.  It's a defense in  So basically safe, but perhaps inadvisable.
Personal taste, local business or other policy, legal requirements  (some industries in some countries have to use particular ciphers), etc.
Yes, some are stronger than others, but it's hard to say which is best  without knowing exactly what you want.  For example, 3DES is the  oldest (and by far the slowest) cipher in GPG's list, but if you want  the cipher that has withstood attack for the longest period of time,  that's your choice.  If you want the one that has had the most recent  study, that's probably AES.  If you want to be compatible with really  old versions of PGP (not GPG), you want IDEA (not in your list  above).  And so on.
AES256 is probably the best all-round choice in GPG if you want to  just say "strongest" and leave it at that (it is also the default  cipher for new keys), but note that unless your situation is unusual,  any of the ciphers in GPG is likely stronger than they need to be.

@_date: 2009-11-17 17:39:44
@_author: David Shaw 
@_subject: Is it possible to decide what is a gpg file? 
Please stop doing this.  Some people call it "GNU/Linux".  Some people  (the vast majority, at least in the US) call nearly any machine  running a Linux kernel "Linux".  Some people genuinely don't care.   The important thing here is that it's not particularly relevant to the  discussion of GnuPG.

@_date: 2009-11-17 17:49:41
@_author: David Shaw 
@_subject: Problem with the agent, gpg2 
1.4.4, to be precise.  That's mid-2006, so it's been supported for a  good long time.  DSA2 is not, incidentally, the default, which might  be the root of the confusion here.  You need to run with --enable-dsa2  to get longer DSA keys with larger hash support.

@_date: 2009-11-17 17:50:24
@_author: David Shaw 
@_subject: Is it possible to decide what is a gpg file? 
That is correct, GPG does not do that.  In theory, you could transform  GPG output in such a way to make it (plausibly) appear random.  The  difficulty in practice is that my plausible and someone else's  plausible may not match up - and you also would need a plausible  reason why you chose to hang on to a bunch of large "random" files on  your machine ;)
If you did some OpenPGP packet manipulation, you could probably do  fairly well here... but you'd have to do some work on the receiving  side to re-create a valid OpenPGP message so GPG could decrypt it.

@_date: 2009-11-17 22:21:57
@_author: David Shaw 
@_subject: digital signature primary key and encryption subkey 
Note that the default is "RSA and RSA" now, but "DSA and Elgamal" are  still available.
I'm afraid I don't really understand what you are asking.  Your  primary key (DSA) has a public and private part, and uses the DSA  algorithm.  Your subkey (Elgamal) has a public and private part, and  uses the Elgamal algorithm.  Your subkey is signed by your primary key  to indicate that they belong together.

@_date: 2009-11-18 09:38:24
@_author: David Shaw 
@_subject: digital signature primary key and encryption subkey 
Yes.  "Public key" is frequently shorthand for a number of public keys stuck together with some OpenPGP glue, and the same is true for private keys.

@_date: 2009-11-21 17:22:42
@_author: David Shaw 
@_subject: How to check the trust level 
It depends on what you mean by "trust level".  If you mean the  ownertrust, then you can't - that's personal to him and is not visible  outside of his machine.  If you mean the signature verification level,  then it is visible in the --list-sigs output - 3 for "positive"  verification, 2 for "casual" verification, and 1 for "persona" (aka  didn't check) verification.  If none of these numbers appear, it's a  "generic" verification.

@_date: 2009-11-21 21:07:59
@_author: David Shaw 
@_subject: How to check the trust level 
The spec disclaims any knowledge of the levels and leaves it up to the  individual person to decide within some (very rough) guidelines.  This  is both a good and bad thing :)
It's very possible that Alice's "casual" is stronger than Baker's   is very rare, since it essentially means that someone didn't check  at all.  GPG actually ignores level 1 signatures by default, so that  makes them even more rare - there is little point in making one since  GPG won't even see it.

@_date: 2009-11-28 10:47:20
@_author: David Shaw 
@_subject: GnuPG private key resilience against off-line brute-force attacks 
GnuPG (really OpenPGP) does iterated password hashing.  See section  3.7.13 "Iterated and Salted S2K" of RFC-4880 for the fine details, but  the gist is as you surmised - the passphrase is run through many hash  iterations.  This slows down passphrase guessers as they must also  repeat the hashing part the same number of times.  By default, GnuPG  uses 65536 iterations of the pasphrase hash, but can be configured via  the --s2k-count option to be as high as 65011712 iterations.
Be careful though - in some cases, a too-large value can hurt you  here.  If you create a passphrase-encrypted message on a fast machine,  and pick a huge s2k-count, and then try to decrypt on a slow machine  (say, a cell phone), the message may become effectively unusable since  the repeated hashes can take an unusable amount of time on the slow  I'd have to look up the details if anyone is interested, but there was  a case a few months back of a huge s2k-count actually causing an  embedded device to trigger its deadman timer - someone had generated  the message on a fast machine (so never noticed the large iteration  count), but sent it to the slow one which clobbered it.
Difficult question to answer, since everyone is going to wave around  their opinion. :)
I'd suggest starting with the various calculators on

@_date: 2009-11-28 16:25:40
@_author: David Shaw 
@_subject: GnuPG private key resilience against off-line brute-force attacks 
That's sort of the problem, though.  There are countless facts that  can be brought to bear on this question, and each one, by itself is  just an additional point which does not add very much to the perennial  question of key length.   The nice thing about the keylength.com site  is that they (or rather the several research papers and guides that  comprise the site) gather together hundreds or more of individual  facts and - carefully showing their methodology so that others can  learn - do derive recommendations.

@_date: 2009-11-28 16:28:34
@_author: David Shaw 
@_subject: GnuPG private key resilience against off-line brute-force attacks 
The s2k-count is only used when creating the passphrase for the first  time (and that applies to both creating a new secret key as well as  encrypting something with a passphrase via --symmetric).  If you want  to change the s2k-count of an existing secret key, you need to set the  new s2k-count and then change the passphrase.  You can "change" it to  the same passphrase if you like - it's the creation of a new  passphrase-to-key that picks up the new s2k-count.

@_date: 2009-11-28 17:08:38
@_author: David Shaw 
@_subject: GnuPG private key resilience against off-line brute-force attacks 
The "????" is CAST5, by default.  You can change it with --s2k-cipher- algo.  The usual s2k rules apply - if you change the s2k-cipher-algo,  it won't take effect until you change the passphrase.  Also, be  careful you don't shoot yourself in the foot with setting the  algorithm to something you can't handle.  This is less of a danger  than with most algorithm changing tweaks: you only have to guarantee  that *you* (and not all of your correspondents) have the ability to  handle the key.
So if you want your passphrase to be as strong as CAST5, you'd need a  really massive passphrase.  The passphrase is almost always the  weakest part of this sort of system, by far.
They're more likely to hit you with a wrench, a la  538/  :)

@_date: 2009-11-29 12:10:41
@_author: David Shaw 
@_subject: Some questions regarding libgcrypt-config 
Yes, the two algorithms go together.  SHA384 and SHA512 are  essentially the same algorithm.  SHA384 is really SHA512 with a  different initialization and 128 bits chopped off.

@_date: 2009-10-12 09:08:50
@_author: David Shaw 
@_subject: gpg-agent --daemon running in foreground 
I'm not sure exactly what you're trying to do, but you can run gpg- agent without it backgrounding by leaving off the "--daemon" option.

@_date: 2009-10-15 23:27:52
@_author: David Shaw 
@_subject: A lot of questions about CERT, PKA and make-dns-cert 
The whitespace issue was handled back in 2006 (one day after the  program was added to GnuPG, as it happens).  Possibly you saw an email  from someone who was tracking the code repository in between  releases.  There is no version of GnuPG that was ever released with  the bug.
Even if the documentation was better (and I agree, it is poorly  documented), I don't think CERT or PKA would be a very widely used  feature.  The reality is that the majority of users do not have the  kind of access to DNS that CERT requires.  PKA is a bit better in this  regard as it uses TXT records, which can at least be used by people  who have some web-based DNS configuration for their domain.  I don't  know of many of those configuration tools that do CERT at all (we're  talking text-files-and-bind usually for CERT).  Whether TXT or CERT,  though, it's a fairly high barrier for many users.
I do encourage you to document it better, and I'm willing to help  explain wherever necessary, or make code changes if there is something  that could be done better.
If you build GnuPG with curl (which is the default, assuming you have  curl), then you have HTTP 1.1 support.  That said, is there a  particular HTTP 1.1 feature that you need here?  After the PKA parsing  happens, GPG is just doing a regular HTTP GET.
It works fine for me.  What version of GPG are you using?
Incidentally, you have two different CERT records for gushi.gushi.org  at the same time.  You have both a fingerprint-style answer and a full- key answer.  This is not a major problem (GPG won't care - it'll just  take the first one that parses), but if your nameserver does some sort  of round-robining, it can be confusing as to which record is the one  that gets used.
When I wrote the code, precious few nameservers understood any of this  (and none understood IPGP at all - that patch only went into BIND a  few months ago).  That's why the record is TYPE37 and not CERT.  It's  ugly, but it was the least common denominator.  It has been a few  years since then.  Possibly it's time to upgrade.

@_date: 2009-10-21 00:17:06
@_author: David Shaw 
@_subject: A lot of questions about CERT, PKA and make-dns-cert 
You didn't give an actual version number (run gpg2 --version), so I  can only make an educated guess, but I do think I see your problem.   You don't have one key in your CERT - you have two (309C17C5 and  624BB249) combined into one DNS record.  That doesn't work - it's a  one-name-one-key mapping.  We should give a better error message in  this case.
Can you try again with a single key in your CERT?  Alternately, if you  want both of your keys, you could use 2 different CERT records for the  gushi.gushi.org. name, each with one of your keys (rather than 1 CERT  record with a payload containing two keys).  Note that this will  usually result in round-robining for those people who don't have your  key, which may or may not be what you want.
At least using gpg 2.0.13, and a single key in the CERT, this works  properly for me.  I can't speak for an earlier version.
All of that said, I think it's worth pointing out that IPGP (the  fingerprint+URL variation of CERT) is far more useful that PGP (the  full key).  Not all systems are going to be able to pass a 1718-byte  DNS message, as yours is.
Please do!  More testing is always welcome.

@_date: 2009-10-22 10:52:37
@_author: David Shaw 
@_subject: verification/installation 
GPG (any version) does not come with OSX.  If it is present there,  someone other than Apple installed it.
If you see results when you do a --search-keys, just enter the number  in parentheses, next to the key.  GPG will use the same keyserver to  retrieve and import the key.

@_date: 2009-10-25 11:31:18
@_author: David Shaw 
@_subject: A Couple of Questions... 
It depends.  In common use  is "yes", and  is "no".  However,  there are some setups where you would install it on the mail server so  the server can decrypt your mail / verify signatures and then provide  the mail, unencrypted, to you.  This is useful for dealing with mail  programs that can't or don't handle OpenPGP encrypted mail (for  example, most cell phones).  This does change the security situation  to some extent, of course, since your mail server will contain an  unencrypted copy of the mail.
A good way to look at this is the thing that does the decrypting/ verifying needs GPG.  If that thing is your local machinse, then your  local machines need GPG.  If that thing is the mail server, then your  mail server needs GPG.

@_date: 2009-10-30 10:42:22
@_author: David Shaw 
@_subject: No secret key under different account 
Most likely your keyring is stored under the Administrator account, so  when run as SQLService, you can't find the keys.
Look at the .gnupg directory in the Administrator account - it needs  to be available to the SQLService user.  See also the --homedir option  to GPG, which allows you to specify where the keyrings and config  files go.

@_date: 2009-09-02 11:11:03
@_author: David Shaw 
@_subject: 1.4.10rc1 vs. OS X 10.6 
10.6 ships with a newer version of the compiler toolchain that is  giving a few headaches here and there.  Until we work out the issue,  just compile with --disable-asm.

@_date: 2009-09-02 11:18:23
@_author: David Shaw 
@_subject: Secret Key replacement 
It depends.  Many uses of GPG in an automated mode use "--trust-model  always" or "--always-trust", since there is no need for a web of trust  in their setup.  If you are using one of those options, then there is  no need to sign anything.  If you are not using one of those options,  you probably need to make some signatures.
No mass sign ability, but you can do some shell magic like:
for i in (the keyids here)
   gpg -u XXXXXX --lsign $i
This assumes you don't have a passphrase on the key (otherwise you'd  have to type it multiple times as the shell loop ran), but no  passphrases is also a common setup for automated use.

@_date: 2009-09-04 13:12:07
@_author: David Shaw 
@_subject: what is the HEX signature off a normal *.gpg file . for 
This is unfortunately a difficult question.  GPG (really, OpenPGP)  supports multiple encodings and thus multiple signatures a file may  present to a mail scanner.
You may be able to match the most common signatures, but by no means  will that cover them all.
Having said that, some common signatures (in "file magic" format) are:
0       beshort         0x9900                  text/PGP key public ring
0       beshort         0x9501                  text/PGP key security  0       beshort         0x9500                  text/PGP key security  0       beshort         0xa600                  text/PGP encrypted data
0       string          -----BEGIN\040PGP       text/PGP armored data
 >15     string          PUBLIC\040KEY\040BLOCK- public key block
 >15     string          MESSAGE-                message
 >15     string          SIGNED\040MESSAGE-      signed message
 >15     string          PGP\040SIGNATURE-       signature
0       beshort         0x8501                  data

@_date: 2009-09-05 09:36:04
@_author: David Shaw 
@_subject: CAMELLIA 
Yes, and GnuPG 1.4.10 and 2.0.12 (if libgcrypt is recent enough)  supports it.

@_date: 2009-09-05 12:11:18
@_author: David Shaw 
@_subject: encrypting compression algorithms 
Unless you've disabled compression in your gpg.conf file, yes, it is  both encrypted and compressed.
Unless you've overridden the default, it is ZIP.
personal-compress-preferences (algo)
And (algo) can be "uncompressed", "zip", "zlib", or "bzip2".  Note  that bzip2 is only available if your GPG was built with the bzip2

@_date: 2009-09-05 23:10:29
@_author: David Shaw 
@_subject: encrypting compression algorithms 
Not really, but you could look at the debug output.  Try decrypting  the file with "-vv" added to the command line.  If it is compressed,  you'll see a line like ":compressed packet: algo=1".  Algo 1 is ZIP,  algo 2 is ZLIB, algo 3 is BZIP2.

@_date: 2009-09-06 18:45:12
@_author: David Shaw 
@_subject: Cant get Fellowship card to work 
Yes, it should.
Are you using pcsc or the built-in card driver?  What platform are you

@_date: 2009-09-08 19:32:19
@_author: David Shaw 
@_subject: RSA only enable to sign 
Just right.  As a general rule, people should never need --expert to  do regular OpenPGP-ish things (make keys, encrypt stuff, etc).

@_date: 2009-09-09 17:29:47
@_author: David Shaw 
@_subject: How do I use gpg to decrypt encrypted files???? 
Take away the "-d".  Just plain "gpg my-file-to-decrypt.asc" will do  what you want, and save the result in "my-file-to-decrypt" (it removes  the ".asc").  If you want to control the name that the file is saved  under, do:
   gpg -o file-to-save-the-decrypted-data-in my-file-to-decrypt.asc

@_date: 2009-09-09 19:53:10
@_author: David Shaw 
@_subject: How do I use gpg to decrypt encrypted files???? 
There are two versions of GPG.  One, the 1.4.x line is a self- contained GPG that builds on many platforms.  It only does OpenPGP.   The other, 2.x line, is a more modular version that builds on fewer  (but still all of the common) platforms.  It uses libraries for its  crypto and other things, and is somewhat harder to build.  It does  OpenPGP and x509 and has some other nice features that aren't in 1.4.x.
Of course, when you download a prebuilt binary, you don't need to  worry about building it.
I wonder if you are thinking of Windows Privacy Tray?  Or possibly GPGShell?

@_date: 2009-09-09 21:45:45
@_author: David Shaw 
@_subject: howto secure older keys after the recent attacks 
Yes, but it won't actually go away completely.  SHA1 is special in  OpenPGP.  Unlike the other hashes, SHA1 is required to be supported.   Removing SHA1 from an OpenPGP preference list doesn't actually remove  it, but instead effectively puts it at the end of the list (so it is  the lowest ranked choice).
Well, yes and no.  Old signatures are certainly available to both  friend and foe, but the real question is: use them for what?  What  attack are you concerned about here?
No need.  If you had a DSA key, I might suggest changing keys, but you  have an RSA key, and are thus free to use whatever hash you please.
To change the hash you sign with, stick this in your gpg.conf file:
personal-digest-preferences sha256
Feel free to list whatever hashes you like here.  GPG will rank them  in that order.
You pretty much can't.  The key ID itself is derived from SHA1.
There was a very long discussion of the SHA1 issue a few months back  on this list.  See, for example,    and In short, I wouldn't worry all that much about it.
With regards to AES256, I doubly wouldn't worry about it.  See This sort of question tends to cause long threads where everyone  throws in their own cipher preferences.  Instead of giving my  preferences, allow me to point at the wonderful defaults in GPG.   They're the default algorithms for a reason.

@_date: 2009-09-10 11:08:09
@_author: David Shaw 
@_subject: howto secure older keys after the recent attacks 
Not a new OpenPGP, exactly, but certainly a revised one.  New keys,  yes.  Of course, SHA1 is nowhere near being fully broken.  Heck, even  MD5 is nowhere near being "fully" broken (which doesn't mean I  recommend people use it, of course).
Yes.  To re-sign a key with a new hash, do this:
gpg --cert-digest-algo sha256 --expert --edit-key (thekey)
(pick the user IDs you want to sign)
The "cert-digest-algo" tells GPG which hash to make key signatures  with, and the "expert" tells GPG that it is okay to re-sign a user ID  that is already signed.
personal-digest-preferences sets the hash for signatures you make on  cert-digest-algo sets the hash for signatures ("certifications") you  make on keys.
No, just that we need to revise OpenPGP.  It's not a disaster - we've  done it in the past, and can do it again in the future.  It's just a  specification that describes a cryptographic system using the best  knowledge of the time.  If the knowledge changes, we change the  The real headache here is (as always) the practical - what to do with  existing keys and such.  I suspect that removing SHA1 would  effectively mean a new key type for OpenPGP (again, not a disaster -  we're on our 4th key type today).
There are occasional debates on who has the better PRNG.  The debates  usually end with no changes on either side :)
That isn't to say there aren't differences between systems - the  FreeBSD PRNG (which seems to have been inherited by OSX) is of a  fairly different construction than the Linux one, which has led to  some mild controversy in the past.  Notably, the Linux one blocks if  you run out of gathered entropy, and the FreeBSD one does not.   FreeBSD /dev/random is similar to Linux's /dev/urandom.
See also Given the same key length and same hash, they are (massive armwave!)  roughly equal for real-world use.  If you like, you can define  "roughly equal" as "usually so much stronger than the rest of the  system that fiddly differences are irrelevant". The actual difference  you find between the two is more in implementation and use issues,  like DSA signatures being physically smaller than RSA signatures (nice  for email), RSA being more widely supported in hardware doodads  (smartcards, crypto math chips, etc), and RSA allowing more hash  flexibility than DSA.
Read NIST SP 800-57 for lots of detail on strength, but they basically  conclude the same thing: roughly equal for real-world use.
I'm not exactly sure what you mean by "hash algorithm armor".  RSA in  OpenPGP does have a additional protection (usually called a "hash  firewall") that DSA lacks.  This gives some protection against hash  substitution attacks, but it's not a major deal either way.
It's true that NIST's guidelines say that to truly get the maximum  juice out of a 512-bit hash, you should use a 15360-bit key, but that  doesn't mean you must.  That overall strength of the system is the  weakest point, so as long as that weakest point is strong enough,  you're fine.
A 15360-bit key is wildly impractical.  I doubt we'll ever see keys of  that size in use.  When technology progresses to the point of that  being necessary (no time soon) we'll move on to other algorithms that  are stronger per-bit, like ECDSA.
Equally secure.  In fact, it's almost the same code.

@_date: 2009-09-10 11:27:04
@_author: David Shaw 
@_subject: howto secure older keys after the recent attacks 
Those are just implementations of methods to gather and manipulate  entropy.  If one method was better, the other would more likely re- implement the idea rather than lifting code wholesale.  This usually  works out that way in the open source world, and especially in the  open source crypto world.  Most likely, the people with the better  entropy gatherer would actively help the other people to improve their  This doesn't necessarily work out the same way in the non-open source  world, but even so, some companies are very good to deal with with  getting information and discussing common problems (the PGP company is  a good example of this).
Kong 1, Godzilla 0.  Not exactly an Oscar winner, but "King Kong vs.  Godzilla" does have its charms.
I'm not sure which is RSA or DSA in this example though, and then  there is Mechani-Kong, and Lady Kong, and... ;)

@_date: 2009-09-10 12:17:35
@_author: David Shaw 
@_subject: OpenPGP 2.0 and Hushmail keys 
It should work fine.  It sounds like a different sort of problem.
No, but there is a stub secret key that lives in the usual secret  keyring.  This isn't a true secret key (it does not contain the actual  key data), but is the OpenPGP information (user IDs and other things),  along with a pointer that says "the key is on smartcard XYZ".
So if they can get ahold of your computer, someone could steal this  stub, but there is nothing secret about it, and it won't do them any

@_date: 2009-09-10 22:23:43
@_author: David Shaw 
@_subject: howto secure older keys after the recent attacks 
Sure, but your computer vendor "could" have a relationship with the  NSA and put some special code in the BIOS to capture keyboard input  and periodically send it to a central server.  Your disk drive vendor  "could" keep a few extra sectors hidden from the reallocation pool,  and use them to store copies of things that match the byte signature  of a PGP key.  Your wifi AP vendor "could" have a hidden secret WPA  key that makes your home network available to a malicious individual  in control of the special secret.
"Could" is a very powerful word.  At some point, people have to buy  and run the closed-source hardware they need to run their open-source  software on :)

@_date: 2009-09-10 22:35:31
@_author: David Shaw 
@_subject: howto secure older keys after the recent attacks 
Yes.  It's not that gpg has a driver for it though.  The developers of  the entropy key were clever and instead of making programs write new  code to use the key, they made a program that reads the key and feeds  the Linux entropy pool.  Thus, anything that uses /dev/random (like  gpg) benefits without code changes.
Not completely useless given the Linux random design, but certainly an  evil source of entropy would be a serious problem.  Do you have any  reason to believe this device is evil?  There are many random number  generators on the market.  Knowing which ones are evil would be handy ;)
The kernel merges several sources of entropy into the /dev/random  pool.  The entropy key would just be another source (though a very  prolific source) of entropy.

@_date: 2009-09-10 22:46:34
@_author: David Shaw 
@_subject: howto secure older keys after the recent attacks 
No, at this point things are mainly being proposed as *additions* to  4880.  The first of these to reach completion is RFC-5581, which added  the Camellia cipher to OpenPGP (it's in 1.4.10, incidentally, but you  need to opt-in by adding it to your key prefs before it will be  used).  Another addition would be ECC support, or the SHA-1 free key  The place for all such suggestions is the IETF OpenPGP working group:

@_date: 2009-09-10 22:52:39
@_author: David Shaw 
@_subject: howto secure older keys after the recent attacks 
I suspect you are more in danger of being hit by meteors several times  in a row as you walk to your friend's house with the USB stick, than  you are in danger from SHA-1.

@_date: 2009-09-12 12:03:24
@_author: David Shaw 
@_subject: Does the SCM SCR3320 work with GnuPG? 
I can't speak to the MyKey device, but I have a SCR3320 and it works  just fine with GnuPG and the v2 card.
I like the smaller "USB stick" form factor a lot more than the larger  "credit card" sized cards.  They're much easier to deal with when you  don't have smartcard readers wherever you go.

@_date: 2009-09-12 18:02:50
@_author: David Shaw 
@_subject: Does the SCM SCR3320 work with GnuPG? 
I have [1] (the white plastic one with the black card carrier on the  side and black cap).  While it is possible, it isn't very convenient  to swap cards very often in this model.  The card carrier seems  somewhat fragile and not really up for frequent opening and closing.

@_date: 2009-09-13 22:54:13
@_author: David Shaw 
@_subject: One Private Key on Two or more OpenPGP 2.0 cards? 
The problem you are having is because the secret key still exists,  even after it is transferred to a card.  There are no secret bits any  longer, but the "stub" of the key is still there, and it contains the  serial number of the card (so GPG knows which card to look at for the  secret bits).  If you delete the secret key stub, you can re-import it  and transfer it to other smartcards.
Something like this:
1. Generate your key and save a copy of the secret part (gpg --export- secret-key ...)
2. Transfer the secret key to your production card
3. Delete the whole key from your keyring (gpg --delete-secret-and- public ...)
4. Import the secret key again (gpg --import ...)
5. Transfer the secret key to your backup card
6. Repeat 7. Repeat 8. Transfer the secret key to your offsite card.
9. Repeat 10. Import the public part of the key
11. Insert the card you want to use regularly, and do a "gpg --card- status" (this re-creates the stub for the card you use regularly)
If you ever want to use a different smartcard, you will need to delete  your secret key, insert the card, and do a "gpg --card-status" to  recreate the stub for that card.

@_date: 2009-09-15 13:12:23
@_author: David Shaw 
@_subject: Hash algo for signing - documentation 
Perhaps I wasn't clear in that message.  You definitely need to  specify --cert-digest-algo every time a key is signed (or put it in  your gpg.conf file).
For RSA, the rules are: if cert-digest-algo is set, use it.  If you  have a PGP 2.x key making a PGP 2.x signature, use MD5.  Otherwise,  use SHA-1.
No.  It does control what DSA keys use, but you must choose an  algorithm that makes sense for the particular DSA key (for example,  you can't use SHA-1 with a DSA 2048-bit key).

@_date: 2009-09-16 16:07:56
@_author: David Shaw 
@_subject: IDEA patent vs the recent USPTO memorandum 
Whether this means IDEA is okay or not patent-wise, I have a slightly  different take on this: who cares about IDEA at this point?  IDEA was  good back in the 90s and PGP 2.x.  It's 2009 now, and we have better  ciphers than IDEA, a massive installed software base that doesn't use  IDEA, and nobody is suffering for the lack of IDEA.  If IDEA was  suddenly not patented, none of this would change.

@_date: 2009-09-16 16:40:02
@_author: David Shaw 
@_subject: IDEA patent vs the recent USPTO memorandum 
If the "some people" still want this, I haven't seen it in a good long  while.  Possibly they gave up asking.  Still, it doesn't matter.   GnuPG is not a RFC-1991 tool, and a theoretical un-patenting of IDEA  doesn't change that either.  To say nothing of the fact that compliant  OpenPGP implementations are explicitly banned from generating RFC-1991  In effect, the request you're paraphrasing seems to be "Add support  for a dead, deprecated, and weaker format to GnuPG, and then deal with  a massive software distribution problem so everyone can have the new  version, all so a few remailers and tools don't have to upgrade to  OpenPGP".  That argument might have made more sense in 1999, to help  get people through the transition, but it's not 1999 any more.
I'll go out on a limb and suggest that upgrading the relatively few  remailers is an easier job...

@_date: 2009-09-18 07:41:49
@_author: David Shaw 
@_subject: I forgot about the meaning of some options... 
--default-preference-list                Set the list of default preferences to .  This                  list  is used for new keys and becomes the default for                 in the edit menu.
        --personal-cipher-preferences                Set  the list of personal cipher preferences to  .  Use gpg
               --version to get a list of available algorithms, and  use none to
               set  no  preference  at  all.  This allows the user to  factor in
               their own preferred algorithms when algorithms  are   chosen  via
               recipient  key  preferences.   The  most highly ranked  cipher in
               this list is also used for the --symmetric encryption

@_date: 2009-09-21 15:48:51
@_author: David Shaw 
@_subject: IDEA patent vs the recent USPTO memorandum 
There is IDEA support (as this is part of OpenPGP, albeit with patent  issues), but no V3 key generation support.
I recall it was not so much forced upgrading, as a general feeling of  "enough already".  If you take a look at the ietf-openpgp archives for  2003-2004, you'll see a few discussions around it.  Mind you, the  statistics we played with at the time (4-5 years ago) showed that over  90% of keys on the keyservers were V4.  I doubt that number has gone  anywhere but up since then.
Another way to look at it is that the new wording around V3 keys  (including the no-generate rule) enables someone to write an OpenPGP  implementation that has no V3 support whatsoever (something which  wasn't doable in RFC-2440).

@_date: 2009-09-22 00:05:29
@_author: David Shaw 
@_subject: IDEA patent vs the recent USPTO memorandum 
In my opinion, yes.  These days, you'd need a good reason to use IDEA  rather than AES, CAST5, or even 3DES.  When you add in the fact that  IDEA actually costs money (heresy!) and nearly every competitor is  free, it becomes a fairly easy calculation to make.
In the context of OpenPGP, the gradual abandonment has already  happened.  The usage today is non-zero, but negligible.  The only  reason the IDEA discussion comes up here (usually once or twice a  year) is that PGP 2.x used it back in the 1990s.

@_date: 2009-09-22 16:41:25
@_author: David Shaw 
@_subject: choosing an encryption target from a User ID 
The problem with this sort of thing is that for every possible  heuristic we can come up with, there is going to be someone who that  heuristic breaks.  GnuPG has done the "first matching key" since the  beginning, as did (old) PGP[1].  That behavior is baked deeply into  [1] PGP has a GUI nowadays, so this sort of thing doesn't apply in the  same way any longer.  I don't have my copy of PGP command line online  at the moment, so I can't check what it does, but I'd be surprised if  it didn't either take the first one or give an error message.

@_date: 2009-09-22 17:08:42
@_author: David Shaw 
@_subject: Two tidbits of potential interest 
First of all, someone has factored a 512-bit RSA key (the one used to  protect a TI programmable calculator, it seems).  It took 73 days on a  dual-core 1900Mhz Athlon64.  It took just under 5 gigs of storage and  around 2.5 gigs of RAM.  In other words: not much at all.  It's not  some big distributed project - rather it's a single guy who wanted to  factor it and just left it running in the background for 2 and a half  months.  (This is actually a month old - forgot to send it before now).
Also, here's the Stick Figure Guide to AES:

@_date: 2009-09-22 18:30:52
@_author: David Shaw 
@_subject: choosing an encryption target from a User ID 
I think the current behavior is the right one.  Otherwise we break  however many baked-in uses out there (scripts, etc), to say nothing of  having to explain to people why a particular key was chosen.  "We pick  the first valid key" cannot be misunderstood or confuse anyone.
Yes, it's wrong for some situations.  But every behavior is wrong for  some situations.  This particular "wrong" behavior has almost 20 years  of history behind it.

@_date: 2009-09-22 19:16:05
@_author: David Shaw 
@_subject: choosing an encryption target from a User ID 
It doesn't work that way.  The default is "the first valid key".  It's  been that way in the PGP world since before GPG as a product was  written.  If you want to propose a specific alternative, I'm ready to  listen, but I'm not going to defend the default behavior of 15+ years.
It's used everywhere user IDs are referenced in the product.  --list- keys.  --edit-key, --sign-key, etc, etc.

@_date: 2009-09-24 13:21:48
@_author: David Shaw 
@_subject: Two tidbits of potential interest 
Yes, that's exactly what happens.  If you factor the public key, you  can derive the private key.
In the case above, it seems TI was using that 512-bit key to ensure  that only TI could generate software images for their calculator.   With the key factored, anyone can sign a software image.

@_date: 2009-09-25 07:50:47
@_author: David Shaw 
@_subject: Two tidbits of potential interest 
Factoring is an attack against RSA.  It applies to wherever RSA keys  are used, whether OpenPGP, X.509, or whatever you like.
This idea is not specific to RSA though: there are other, similar (in  general concept, though not in the specific math of course) attacks  against other asymmetric systems.  The goal is to make it hard (for  whatever definition of "hard" works for your particular environment)  to derive anything non-public from the public key.
Keep in mind that nobody has used a 512-bit key in many years (they're  too small, as this result makes clear).  It seems TI's mistake here  was in choosing a 512-bit key in the (around) 1999-2001 time frame,  and not realizing that less than a decade later, that key length would  be small enough for someone to factor in their spare time.  It's a  little surprising, as it was well known around that time that 512 bits  were not sufficient.  I wonder if the memory size and CPU capability  of what is essentially a pocket calculator influenced that decision.

@_date: 2009-09-25 11:06:12
@_author: David Shaw 
@_subject: choosing an encryption target from a User ID 
What troubles me about this sort of behavior is that it is genuinely  good and helpful in some cases and baffling and off-putting in  others.  For example, someone has two different Alice keys in their  keyring.  Both keys have a single UID, which is signed by Baker.  One  of the Alices (call her Alice1) is also signed by Charlie.  The other  Alice (Alice2) is signed by Dan.  Alice2 is a newer key than Alice1.
At the moment, the keyring contains Alice1, Alice2, and Baker.  We  have full trust in Charlie and Dan, but they are not currently present  in the keyring.  We have a marginal trust in both Alices through  Baker, so following the suggested algorithm we pick Alice2 (as it is a  newer key).
Now, the user imports Charlie's key.  This completely changes the  calculation: we have full trust in Alice1 through Charlie, so Alice1  is now fully trusted.  We switch over to encrypting to Alice1 - it's  the older key, but it has full trust.
Then, the user imports Dan's key.  This completely changes the  calculation again: we now have full trust in both Alices, so we again  pick the more recent key, and pick Alice2.
Then there is the case where someone doesn't automatically rebuild  their trustdb - they can be in a position of having GPG pick one key,  then a rebuild is triggered, causing the other key to be picked.
I'm not against that behavior - it's reasonable and makes sense... to  someone who really understands the web of trust and OpenPGP.
My problem is that there is the potential for a lot of confusion  here.  Making the behavior optional doesn't really resolve that, as to  be useful, you want this sort of key-picking behavior to be the  default (I might even argue that if we do it, it shouldn't be  something that could be switched off, as at least there would be only  1 confusing behavior to document, rather than two).

@_date: 2009-09-25 19:42:22
@_author: David Shaw 
@_subject: Decryption Fails on UserName but not on EmailAddress ??? 
It sounds like you have two keys.  When you use "-r username" you're  matching one of them.  When you use "-r emailaddress at example.com"  you're matching the other one.
Check your keyring to be sure: do a "gpg --list-keys username" to see  all keys that match that name.

@_date: 2010-04-05 21:47:02
@_author: David Shaw 
@_subject: What to do when subkey expires? 
If they've expired, you don't need to do anything special: just make some new subkeys and upload to the servers.  Alternately, you can extend the expiration on your current keys and upload them to the servers.
Many people use key expiration as an opportunity to make new keys, but the choice is yours.

@_date: 2010-04-07 10:54:16
@_author: David Shaw 
@_subject: WikiLeaks Crackers 
Nobody who knows is talking, at least not yet.  This is early days for this particular story, so perhaps more will come out later.
Without any real information at this stage, it is hard to make useful statements on the subject.  For all we know, the original leaker who provided the data to WikiLeaks gave it to them in an encrypted zip file and the "break" was just running it through a password guesser for a few days or weeks.
I do not think that this is a break of any serious crypto, though.  If someone could arrange for AES or any other strong cipher to be broken simply by asking for it on a web site, this would be news.

@_date: 2010-04-07 15:26:21
@_author: David Shaw 
@_subject: Removing signatures from key 
When editing the key, you can use the "delsig" command to delete a particular signature (it will ask you for each signature if you want to delete it or not).  You may need to issue "uid (number)" to specify which UID you want to delete the signature from.
Note that if you have this key on a keyserver, deleting the signature won't change the copy on the server.  Once a signature is on a keyserver, it's pretty much there forever.
Alternately, if this is a signature that you issued (as opposed to getting from someone else), you could use "revsig" to issue a revocation for that signature.

@_date: 2010-04-08 08:30:25
@_author: David Shaw 
@_subject: secret keys are not imported 
This is normal behavior.  Only primary keys are counted when importing keys, even though there may be multiple subkeys attached.

@_date: 2010-04-12 15:58:39
@_author: David Shaw 
@_subject: DRM -- digital rights management 
No.  DRM is a collective term for the various means of controlling use of media in one way or another.  It's possible to use asymmetric crypto as part of a DRM scheme, but this is not a requirement, or inherent in the idea of DRM.

@_date: 2010-04-12 18:00:30
@_author: David Shaw 
@_subject: Invalid Marker Packet issue using PGP to encrypt using GnuPG 
The only valid marker packet contains exactly 3 bytes: P, G, and P.  Given that the following byte is C1, it looks like that's the beginning of the next packet, rather than part of the marker packet.  C1 would be the encrypted session key packet, which makes sense at that point in the document.
Can you tell me a few bytes from *before* the P, G, P?  Perhaps the length is wrong.

@_date: 2010-04-12 18:12:03
@_author: David Shaw 
@_subject: Invalid Marker Packet issue using PGP to encrypt using GnuPG 
A8 == Marker packet
03 == Length (3 bytes)
50 == 'P'
47 == 'G'
50 == 'P'
That looks fine.  It's possible there is corruption elsewhere in the file so that there is something that looks like a (mangled) marker packet, but this one is valid.
I'd check into how the client is sending you the files. If they're using FTP, make sure they are sending in binary or image mode and not ascii or text mode.

@_date: 2010-04-13 17:19:49
@_author: David Shaw 
@_subject: How to NOT Use IDEA? 
The --sign command belongs at the end of the line, next to --encrypt.  Also, what program did you use to create that new RSA/RSA 2048-bit key?

@_date: 2010-08-06 13:57:33
@_author: David Shaw 
@_subject: Message was not integrity protected. 
That's the command to disable the MDC on the sending side.  In this case, the sender is already not using a MDC.  If you want to disable the warning for a missing MDC on the recipient side, use --no-mdc-warning.
The Right Thing to do is to ask the sender to start using a MDC.  If that isn't possible, then --no-mdc-warning will make the warning on the recipient side go away.

@_date: 2010-08-11 10:11:24
@_author: David Shaw 
@_subject: no-ks-modify effect on signature uploads 
I actually considered this once, but in the end, it would be confusing to have a key be uploadable with PGP but not GPG.  Also, it could be defeated trivially by just exporting a key to a text file (always legal), and then uploading it to the keyservers using the web.  It would have been an illusion of actual functionality.

@_date: 2010-08-11 16:11:06
@_author: David Shaw 
@_subject: no-ks-modify effect on signature uploads 
99%+ of all keys created with GPG have the flag set (it's the default).  This would mean that virtually every time a key was exported with GPG, the exporter would get a warning along the lines of "hey, please don't upload this to a keyserver".
At that point, it's just noise.
I dislike illusion in security software.  Either a protection is strong or it is not, and we should not pretend otherwise.
The only way to properly implement the flag is on the server side.  I'd rather work towards that real answer than do something weak on the client side.

@_date: 2010-08-11 16:17:28
@_author: David Shaw 
@_subject: Build Gnupg2 to have bin name gpg 
If you're building this for a distribution, I strongly advise against this.  gpg and gpg2 are designed to be installable at the same time (they're not the same thing and gpg2 is not a strict replacement for gpg).  If you have gpg2 claim the gpg name, then gpg isn't installable any longer.  This is currently an issue that needs to be addressed in Fedora.
If you're just doing it for yourself, however, I still wouldn't change code.  Instead, just make a symlink from "gpg" to "gpg2".  Much simpler and you don't need to deal with renaming keyserver helpers, or re-patching the code every time a new release is made, etc.

@_date: 2010-08-12 22:06:20
@_author: David Shaw 
@_subject: policy url is not set on selfsigs 
This is intentional.  When you change the keyserver or prefs, you are *just* changing the keyserver or prefs.  It would not be appropriate to silently add a policy URL or notation as part of the process.  If you want to change a policy URL or notation after it has been issued, you can simply delete the old sig (even a self-sig can be deleted) and re-issue it.

@_date: 2010-08-16 23:18:21
@_author: David Shaw 
@_subject: Change encryption on the secret key 
Yes.  See also the --s2k-digest-algo option, but the default is what you want anyway.
Try gpg --list-packets, or decrypting with "-v" set.

@_date: 2010-08-16 23:22:36
@_author: David Shaw 
@_subject: Split Data Packet into Multiple Packets? 
Yes and no.  Yes, in that you can probably torture the GPG code into doing it.  No, in that OpenPGP does not permit multiple data packets in a single message.
Read RFC-4880.  Specifically, section 11.3, which gives the various legal packet combinations.

@_date: 2010-08-25 18:04:58
@_author: David Shaw 
@_subject: Strange behaviour of gpg when importing key from keyserver 
In English, it is "N" for "next".  If there are many results from the keyserver, N is used to go to the next page of responses.  The maximum number of results on a page varies depending on the window size, but it will never be smaller than 24.

@_date: 2010-12-07 10:24:22
@_author: David Shaw 
@_subject: Store revoke cert. in symmetric file? 
It's hard to answer as there are more factors in play here than what you give above.  Given the layers you describe (the GPG passphrase is stored in KeePass, and the GPG encrypted file is stored alongside the KeePass database) I'm not sure where the benefit is in the extra KeePass layer.  Why not just store the GPG encrypted file directly with the "strong passphrase that I know" ?

@_date: 2010-12-07 14:32:16
@_author: David Shaw 
@_subject: Store revoke cert. in symmetric file? 
It's not necessarily stupid, but it might not be ideal.  The idea behind generating a revoke certificate ahead of time is to protect you in case you lose access (forget the passphrase, delete the key, etc, etc) to your secret key.  Storing it in an encrypted bundle doesn't really help you if you forget the passphrase to the bundle.

@_date: 2010-12-08 09:32:55
@_author: David Shaw 
@_subject: Armor key - X.501 
RFC-4880 (  See section 6 in particular for how the armor is formed, and sections 4 and 11 for what goes into the armor.

@_date: 2010-12-08 17:12:54
@_author: David Shaw 
@_subject: Protecting IDs at a key signing party 
There isn't a simple answer here, since people who sign keys can each decide what they want before signing.  Personally, I'll sign with two government issued IDs, and wouldn't bother to bring more than that to a party.

@_date: 2010-12-09 19:16:03
@_author: David Shaw 
@_subject: multiple subkeys and key transition 
Yes, but at the risk of pedantry:
The attacks against SHA-1 haven't been extended to the SHA-2 family yet.  By truncating a SHA-2 to 160 bits, you're creating a non-broken (for now) 160-bit hash.  Think of it as a non-broken SHA-1: it's theoretically as strong as SHA-1 once was thought to be, but not stronger.
(i.e. it's a great SHA-1 alternative, but it's not as strong as a full-sized SHA-2).

@_date: 2010-12-09 22:33:05
@_author: David Shaw 
@_subject: multiple subkeys and key transition 
A good way to look at this is to pick what you want your primary key to be.  The subkeys don't really matter that much, as the primary is the one that gathers signatures, and the one that makes (i.e. signs) subkeys.  It's the key that establishes "identity" in the web of trust.  The subkeys matter a lot less as it's trivial to make new subkeys whenever you feel the need, using whatever algorithm and size is favored at that point.
One useful model is to make a large & non-expiring primary key, and use it only to make subkeys.  Use a subkey for signing data, and a (different) subkey for encryption.  This has a few advantages, such as that you can leave this primary key offline altogether (since you only actually need it to make more subkeys).  It's hard to compromise a key that isn't actually on your computer most of the time :)

@_date: 2010-12-10 08:49:16
@_author: David Shaw 
@_subject: multiple subkeys and key transition 
It's not likely to go anywhere useful until the NIST hash competition is finished (or at least is almost finished).  The competition came about at least partially because people realized we don't really know enough about hashing, so it's foolish to make hash-related decisions for OpenPGP before the competition completes.
I think that an update that truly removes SHA-1 is almost certainly going to not have a way to "upgrade" an existing key.  I ran through a bunch of cases when discussing this a while ago, and the various permutations where where Alice has a new key and Baker has an old implementation were rather unpleasant.  Why would you want to do it?  To avoid the hit to the web of trust? (i.e. getting all of your signatures again?)
This gets dramatically easier (and you can probably keep your existing keys) if you're willing to keep SHA-1 fingerprints, though not everyone is.
Yes.  This was an issue once.  I don't see it as an issue any longer.  Not just because many implementations support the whole set of ciphers and hashes, but because most implementations properly support the preference system, so even if they don't support a particular cipher or hash, the protocol can properly deal with it.

@_date: 2010-12-10 10:32:23
@_author: David Shaw 
@_subject: Speaking about SHA-3... 
With the various discussions about OpenPGP and hashes recently, I thought this would be of interest to the folks here: Incidentally, Skein is one of the finalists.  Here's some analysis of Skein:

@_date: 2010-12-11 14:07:52
@_author: David Shaw 
@_subject: multiple subkeys and key transition 
The flags you can turn on and off in expert mode are:
Sign: sign data (i.e. sign a file)
Encrypt: encrypt
Authenticate: prove your identity (for example, sign a challenge token presented by a server so it will let you in)
You can't actually turn on or off certify (which is to sign a key - either your own or someone elses).  In OpenPGP, the primary key can always certify (it may be able to encrypt/sign/authenticate as well, but the only strict requirement is that it must be able to certify).  Without the ability to certify, you could never make a subkey, since subkeys are signed by the primary key.
So given that all primary keys will certify, you just need to decide whether you want it to sign, encrypt, or both.  The default is to certify and sign, and that is what I recommend (no expert mode needed).
Once you make that primary key, you just add subkeys for whatever capabilities you desire.  Again, the defaults are recommended (they are correct for virtually everyone).  I'd add a sign-only subkey and an encrypt-only subkey.  GnuPG will automatically use the subkey for signing over the primary key for signing.

@_date: 2010-12-11 15:00:49
@_author: David Shaw 
@_subject: Add sign key only? 
Yes it is.  You can make signatures from either your primary or your subkey.  By default, GnuPG will pick the subkey.  You can override this choice using "-u BAD246F9!" Note the ! exclamation mark.
If you were forced to disclose your encryption key, you could give them just that particular subkey and not give them the signing subkey at all.  What some people (me, among others) do in addition to this, is to remove the primary key and store it offline.  That way even if it's an accidental leak of the key (rather than a compelled one), the primary key is safe.  Since the primary key can be used to revoke the old subkeys and make new ones, this is a very safe way to handle keys.

@_date: 2010-12-11 15:21:58
@_author: David Shaw 
@_subject: multiple subkeys and key transition 
Yes indeed.  See  for a project using the WoT for both SSH and HTTPS.
Right.  Since only the primary can certify, it will be automatically chosen whenever you try to sign another key.

@_date: 2010-12-11 15:57:00
@_author: David Shaw 
@_subject: Add sign key only? 
It depends on what they ask for.  Without getting into legal issues, it's foolish to hand over more than is requested (or demanded).  If they ask for the decryption key, I certainly wouldn't send them the signing key.  Why would I?  They didn't ask for it.  If they ask for everything, then it's a different story.
Plus, you can change the passphrase on the encryption key (or just remove the passphrase altogether) before you send it to them.  There is no need to give them your passphrase unless, again, they are demanding it.
Just send it to the keyserver, and you'll be fine.  The revoke certificate applies to the key as a whole, so it doesn't matter what you do with subkeys.  Whatever happens with subkeys, the revoke certificate will work.

@_date: 2010-12-11 16:03:22
@_author: David Shaw 
@_subject: Add sign key only? 
GPG has an option to create a special key like this.  Basically, after you make your backup copy, run:
  gpg --export-secret-subkeys (thekey) > my-subkeys-only.gpg
Then delete the real secret key (make sure you have a backup!):
  gpg --delete-secret-key (thekey)
And import the special no-primary-key version:
  gpg --import my-subkeys-only.gpg
The key will then work just like any other key, except that it can't sign other keys, and it can't make more subkeys (since you need the primary to do that).  The only visible difference is a " sign after the "sec" when you --list-secret-keys.
If your subkeys are compromised, or you need a new subkey, or want to sign someone elses key, you bring back your backed up copy of the full key, do what you need to do, and then go back to the no-primary-key version.

@_date: 2010-12-11 16:51:56
@_author: David Shaw 
@_subject: Add sign key only? 
No difference.  The public key is completely separate from the private key in this regard, so it makes no difference if the primary key is present or not.
They'd need the public half of the primary key, but that's part of your public key.  The --export-secret-subkeys trick doesn't touch the public key (no point - it's public), so anyone who wants to check a key signature can do that.

@_date: 2010-12-12 19:27:29
@_author: David Shaw 
@_subject: Best Practices 
Ah, I also wasn't sure what you were referring to.
The checksum in 5.5.3 is to foil the Klima-Rosa attack (see  for the whole paper).  Briefly, though, it means that if an attacker can get access to your secret key, they can modify it slightly and then wait for you to issue a signature.  Once they see a signature issued from the modified key, they can reconstruct the secret key.  The passphrase on your secret key does not protect against this.
It's a very interesting attack, though if someone had access to your computer where your secret key lived, there is a whole load of other stuff they could do besides tamper with your secret key and wait for you to issue a signature. :)
The fix in OpenPGP is to hash the contents of the secret key, so any tampering is evident.
I am also skeptical of this.  I strongly doubt that new fingerprints can be achieved without going to a V5 key format.  There are just too many interoperability gotchas with an upgraded V4.  We might be able to fight our way through them, but therein lies extra complexity and confusion for the implementer and user, which is not what is wanted for a secure system.
V5 has the advantage of cleanliness and simplicity: there is no interoperability.  Which doesn't mean that you couldn't have V4 alongside V5 for a period of time, just as we had V3 alongside V4 for at least a decade.  The WoT would survive this just as it survived the V3->V4 transition.  As V4 ramped up, V3 died out.

@_date: 2010-12-12 23:03:35
@_author: David Shaw 
@_subject: Best Practices 
Yes.  The other uses of SHA-1 are not nearly as significant as the fingerprint (and thus key ID).  For example, it's true that the MDC uses SHA-1, but no big deal - just make a new MDC that uses whatever you like, and repeat as needed.  Virtually all deployed code will handle this correctly (for example, a feature flag indicating the existence of the "mdc2" capability), and use it only when all participants can handle it.
The fingerprint issue is more than just making a new packet for a new MDC or revocation subpacket, though.  There is no concept in OpenPGP of a flag telling an implementation how to calculate the fingerprint - or rather there IS a flag: the version field, but its hardcoded :)

@_date: 2010-12-13 11:16:04
@_author: David Shaw 
@_subject: Best Practices 
It doesn't work that way.  If you want to make a proposal, I'm all ears, as are the folks on the IETF list, but it seems to me you are focusing on one specific part of the design (the secret key format), forcing it to remain unchanged, and (presumably) using changes elsewhere to accommodate this fixed point in the design (for example, doubled PKESK packets, one for each key ID).
As I see it, three major things need to happen to get OpenPGP using something other than SHA-1:
1) SHA-3 needs to exist: we will almost certainly use SHA-3, but even if we don't, we should wait until the SHA-3 reports are in.  SHA-3 is a major amount of effort focused on hashing.  It would be foolish to design something new involving hashing without using the latest research.
2) We need OpenPGP changes to incorporate the new hash in a way that works alongside the existing design.  It's not as easy as "s/SHA-1/SHA-3/", especially given the deployed base of OpenPGP programs.
3) We need to roll out those changes in a way that won't break things.  We're going to be running with SHA-1 and SHA-3 together for (at least) years.
Even if we assume that there will be no other unrelated changes at the same time (an assumption I'm not willing to make - everyone has the half-dozen fiddle things (like hard expiration dates) that they think could be better, but aren't really worth fixing unless there is a key version jump), I'm still not willing to go into the design process in step 2 with the assumption that changing the secret key format is somehow off-limits.  (And mind you, we haven't even reached step 1 yet!)

@_date: 2010-12-13 13:13:07
@_author: David Shaw 
@_subject: Best Practices 
Why is it that using the method you advocate, there is a graceful changeover between fingerprint formats, but a change in the certificate format requires a "hard cut-over" with "global interruption of existing networks..." ?  That's a straw man.  Who is advocating a hard cut over or any interruption whatsoever?  Personally, I suspect a changeover would take somewhere between 5 and 10 years, just as the v3->v4 changeover did.
It is premature to try and force a particular format into the design before we even have a SHA-3 to talk about.

@_date: 2010-12-14 13:23:43
@_author: David Shaw 
@_subject: best practices 
Not many.
Not that there is any *harm* in using a 256-bit symmetric cipher and a 2048-bit asymmetric key together.  It just means that, as with many things, including those in the physical world (think: heavy metal front door next to a glass window), your overall level of security is that of the weakest item.  There is no harm (aside from potential interoperability problems) as long as you aren't fooling yourself.
There is a weak safety factor argument, too.  If it turns out that (for example) AES-256 isn't as strong as expected, it may well be that AES-256 is actually a good match to RSA-2048, and you were wise to use it instead of AES-128 (which given the same imaginary attack would be weaker than RSA-2048).  You sort of need a crystal ball to make that argument though...

@_date: 2010-12-19 18:16:54
@_author: David Shaw 
@_subject: clearsign failed: Bad signature 
That is not a typo.  The v2 card works just fine with other algorithms.  If it isn't working for you, then there may be an issue, but it is not related to the fact that you are using a v2 card.

@_date: 2010-12-24 12:57:16
@_author: David Shaw 
@_subject: Block cipher mode? 
One of my vague desires for a "someday we'll do that" is to use a standard cipher mode in OpenPGP.  It's not a security issue (as you say, OpenPGP's CFB is strong), but it avoids the question, which has a benefit all its own.  Maybe in V5....

@_date: 2010-02-16 14:59:38
@_author: David Shaw 
@_subject: fetch public key from card? 
The data stored on the card is only the secret key - and even then, it's only the necessary pieces of the secret key (there is a lot of redundant data in the OpenPGP key format).  You cannot recreate a public key from a card, so you must store it elsewhere.

@_date: 2010-02-20 17:37:02
@_author: David Shaw 
@_subject: Questions about "--group" for group encryptions. 
No.  The group option creates a group of keys, not a key that covers a given group.  In other words, you can get your first requirement (encrypt to a group of people in one shot), but not your second (if more people are added to the group, they will not be able to access previously encrypted data).
An easy way would be to make a group key and give each person access to it.  The problem is that if you need to support people leaving the group, the old members can still decrypt...

@_date: 2010-02-24 13:25:17
@_author: David Shaw 
@_subject: SHA2 digest on gpg smartcard 
I'm looking at this, and it seems the code that selects a hash does not currently differentiate between the V1 card (where only 160-bit hashes were usable) and the V2 card (where other hashes are possible).

@_date: 2010-02-24 22:57:16
@_author: David Shaw 
@_subject: Migrating from PGP to GPG question 
They are not mutually exclusive.  If you want both batch operation, and to to answer 'yes' to questions, you should give both --batch and --yes.

@_date: 2010-02-25 17:46:05
@_author: David Shaw 
@_subject: Migrating from PGP to GPG question 
Yes, you can do a mass import of a keyring.  This is not always true, but is true for most keyrings, including those from PGP and PGPi (which you indicated you were using).

@_date: 2010-02-26 11:33:03
@_author: David Shaw 
@_subject: key question 
There is associated and then there is associated.  I suspect MFPA is using the term in the "met casually, perhaps at a keysigning event" sense, and not in the "friends with", or "partners in crime with" sense.
Both are associated.  The latter two are (forgive me) more associated.

@_date: 2010-02-26 15:08:15
@_author: David Shaw 
@_subject: key question 
An interesting tidbit here is that the OpenPGP spec actually handles this accidental submission case.  There is a keyserver no-modify flag that can be set on a key, which requests that the keyserver reject any key that isn't submitted by the key owner.  Alas, while GnuPG supports the flag, no keyserver does.  (And in fact, supporting it would require a pretty significant redesign of the keyserver network).

@_date: 2010-02-26 15:39:07
@_author: David Shaw 
@_subject: key question 
Support means it gives the user the ability to set and clear the bit (it is set by default).

@_date: 2010-02-26 15:42:11
@_author: David Shaw 
@_subject: key generation: email-address necessary? 
There is no problem with this from the crypto or GnuPG/OpenPGP or keyserver perspective.  They don't care what the user ID field is, and whether it contains a name, an email address, or both.
But: as you note, this can be a problem for some email clients, which tend to try and locate keys via an email address in the user ID field.  If you're willing to forego that piece of functionality, then it generally can be made to work via manual configuration for that key.

@_date: 2010-02-26 17:08:28
@_author: David Shaw 
@_subject: key question 
I don't think so.  At best it's a false sense of security to block or warn on "gpg --send-keys xxxx" but not on (for example) "gpg --export xxxx" (which is then followed by by sending the key via a web browser or email).  It also doesn't affect PGP.  I'd rather not give the user the impression that this is more than it is.
Plus (and I'll admit to a level of amusement in this situation), virtually all keys generated with GPG have the no-modify bit set, as it's the default.  It would thus block/warn on most every key.

@_date: 2010-02-26 17:12:29
@_author: David Shaw 
@_subject: key question 
The nefarious UID signature is not uncommon.  There are many "president at whitehouse.gov" keys (and other famous figures) that have signed well-known keys.  It's just easily-ignored noise, though, and has no impact on the web of trust.

@_date: 2010-02-26 21:51:26
@_author: David Shaw 
@_subject: key question 
There isn't much you can do about that, really.  Forget keyservers for a moment - some random person can post the same sort of fake "relationship" information on their blog, and it would show up with a Google search for your name.

@_date: 2010-02-27 09:58:53
@_author: David Shaw 
@_subject: key question 
Do you really mean to suggest that a US authority getting email headers - even without a warrant - is easier than typing a name into a search box on a keyserver?  No question that the authority *can* get such headers, but I question the "easier".  Have you read the various (leaked) guides the ISPs have for delivery of such materials?  They are fascinating, but in no way speedy.  I'd expect a truly competent law-enforcement agent would get both - order the requested material from the ISP, and while he's waiting for delivery, take the 20 seconds to search a keyserver.  (Of course, all this assumes that we're presuming guilt-by-encryption, or at least suspicion-by-encryption, which I don't really buy in any event).
In any event, Rob, could you do me a huge favor and clarify what statement you are trying to make here?  Jumping into a mail thread late is always fraught with misunderstanding, but, I've re-skimmed the thread, and I'm honestly still not sure what you're trying to say.
It seems (and I could be utterly wrong), that MFPA is saying "Not everyone wants their key on the keyservers, so please don't automatically send other people's keys there.  If the key owner wants the key on the keyservers, he'll send it himself."  You seem to be saying "This is not based on good logic as I see it, and therefore....  (something)."   What's the "(something)"?  That you reserve the right to send other people's keys to the keyserver?  That it's foolish to request that other people don't send them?  Something else?  Or perhaps I mischaracterize both your and MFPA's positions.
What am I missing here?

@_date: 2010-02-27 15:02:54
@_author: David Shaw 
@_subject: key question 
Much as the email headers do in your example.  If the mail is not encrypted, the headers just show that it might be.  In practice, headers won't show much as the majority of modern mail programs have the capability for encryption of one sort or another, even without add-ons.  It's rarely exercised, of course.
I agree that "generally speaking, it's a good idea to put keys on the keyservers".  I don't know if that makes it conventional wisdom, or who the arbiter of such wisdom might be, but clearly a very common use of OpenPGP is for encrypted mail.  If you want encrypted mail, putting your key on a keyserver is very helpful in reaching that goal. The word "generally" takes care of the exceptions (as there always exceptions for one reason or another).  So basically, yes, if you're using OpenPGP, keyservers are great.
With regards to the second statement, you give a great reason yourself a few paragraphs up: "If you live in Cuba and you're using GnuPG, then you should not have your key on the servers and you have a perfectly reasonable fear about people uploading your key there".  Is that not a good reason to request that a key stay off the keyservers?  I don't find the behavior *behind* this reason very good, as if someone lived in a place where encryption was banned, they'd be foolish and naive to think that their key would stay off the keyservers merely because they requested it - one accident, and it's published, and no way to withdraw it.  People who live in places where encryption is illegal need to do a lot more than simply not send their keys to a keyserver if they want to remain safe.
Personally, I don't find most don't-publish arguments (spam, traffic analysis, etc) compelling, and I correspondingly do send my key to the keyservers (in my case, it would be particularly silly not to).  However, I never send anything to the keyservers (or publish otherwise) if it isn't mine.  I don't know what their situation is, and it's not up to me to decide it for them.  Even if I did know their situation, as in the Cuba example above, and disagreed with them on how to handle their key, it still is not my key, and not my decision to make. I don't know if that makes it conventional wisdom, but I have acted that way since I became involved in the OpenPGP world many years ago.  Whether it's wise or not, I'd at least hope it's common politeness.
Keys ending up on keyservers contrary to the desires of the key owner has been a problem for a long time.  Note the addition of the no-modify flag when OpenPGP was first published as an RFC in 1998.  That was added after experience with PGP 2.  The whole point of that flag is to only allow the owner to publish their key.  Similarly, note that the PGP Global Directory only allows key uploads from the key owner, avoiding this problem.  The earlier PGP "certserver" had the capability, though I don't believe it was always turned on.  Clearly this is enough of a problem that work was done to avoid it.
So you are saying "I do not do this".  And MFPA is saying "I think nobody should do this" ?
Where's the problem?  From where I'm standing, that looks like something that passes for rough agreement, or - dare I say it - conventional wisdom. ;)

@_date: 2010-02-28 15:09:14
@_author: David Shaw 
@_subject: key question 
No, email addresses have been optional in GnuPG for as long back as I can recall.  It's certainly been true since version 1.0.6, back in 2001.
I don't recall the exact details for PGP on this point, but certainly the latest version allows you to skip the email address.  It'll ask you if you really want to make a key without an email address, but once you click "yes", you're free to do what you want.

@_date: 2010-02-28 15:29:32
@_author: David Shaw 
@_subject: key question 
No.  Many (most?) digital signatures are used to authenticate a system, rather than a real person.  For an OpenPGP-specific example, it is widely used to authenticate software packages, both when distributed as source, and also built-in to things like RPM for distributing binaries.  Outside of OpenPGP, there is SSL, etc.
It's not used in the same way, but it is far from meaningless.  You may not know who MFPA is, but if MFPA signs his messages (as he does), you can verify that the pseudonymous entity MFPA that you were speaking with yesterday is still the same pseudonymous entity MFPA you are speaking with today.
That isn't how the web of trust works.  Well, it *can* work that way for you, since you can choose who to trust and who not to, but that's not the information encoded in there.  I "know" dozens of people on the net.  I've exchanged encrypted mail with them, I've worked with them, in some case for years... and I've never met them in person.  For all I know, they're actually a group of people sharing the same email address and using a name that looks like a real one, and not obviously pseudonymous like MFPA.
Think about what it really means in the web of trust when you see a signature.  The signature only maps back to a real person indirectly.

@_date: 2010-01-02 19:45:15
@_author: David Shaw 
@_subject: Encrypting with an message expiration date 
No, there isn't.  The basic problem here is that you rely on someone  to honor your request to kill a message after the expiration date.   They can just ignore your request, and do what they like.  Even if  there was some means to do this, it's easy to foil - Alice sends a  self-destructing message to Baker, but before it expires, Baker reads  it and copies the contents into an unencrypted file.
Incidentally, the "For Your Eyes Only" option in OpenPGP is also not  particularly secure, for these same reasons.
It's possible to imagine a mail system that enforces this sort of  thing (not the crypto itself, but as part of the whole mail system of  which the crypto is only a part), but that's not a very strong  protection - and even then suffers from the copy-to-an-unencrypted- file problem.

@_date: 2010-01-02 23:54:20
@_author: David Shaw 
@_subject: Encrypting with an message expiration date 
But don't think it adds real security.  In OpenPGP, the FYEO option  just sets a flag in the message that means (in effect), "Pretty  please, with sugar on top, treat this as for your eyes only".  The  recipient is free to ignore the flag and do whatever they like.

@_date: 2010-01-03 00:12:00
@_author: David Shaw 
@_subject: Encrypting with an message expiration date 
It is more than analogous - it is that exact flag.  Even in old PGP,  the flag was really just advisory.

@_date: 2010-01-04 12:53:08
@_author: David Shaw 
@_subject: Encrypting with an message expiration date 
Did you read the Vanish paper?  That's not how it works - there isn't some piece of code that says "if (not_yet_expired) { show_data }".  Rolling the clock back has little effect.  In Vanish, the key is broken into multiple key shares (a la Shamir), and spread out over many machines in a large pool.  At expiration time (a regular occurrence on the node, and not specific to the message), the key share is simply dropped.  Eventually, enough shares are gone that the key cannot be recovered.  One could conjecture some master of the universe attack against all of the nodes, but it's a very different trick to subvert one machine than it is to subvert over a million of them (Vanish runs over Vuze).  Plus the attack would have to be mounted before the message expires.
Of course, see  ;)
To be sure, Vanish doesn't solve the problem we're talking about here, but I can't really hold that against it since that's not the problem it was designed to solve.

@_date: 2010-01-04 14:16:11
@_author: David Shaw 
@_subject: Compatibility version between version 1.2 and 1.4.10 
Impossible to say without knowing how you are using GPG.  I can say "almost certainly", though.
Impossible to say without knowing how you are using GPG.  I can say "probably", though.
Read the NEWS file that comes with every version of GPG.  The file is updated for every release.  In your case, you should read the sections between 1.4.10 and 1.2.

@_date: 2010-01-07 23:20:52
@_author: David Shaw 
@_subject: 768-bit RSA factored 
No terrible shock - we knew this was coming, but still, how  wonderfully neat, and a new factoring record, too.
Note that 1024-bit RSA has not yet been factored, but if you haven't  phased it out yet, it's really time to get started.  It's supposed to  be completely phased out by this year anyway, at least by those  following NIST and a few other guidelines.

@_date: 2010-01-10 22:52:07
@_author: David Shaw 
@_subject: Web of Trust itself is the problem 
While I do believe that there are a number of people in each of those  categories (or combinations thereof), I strongly suspect that the  largest category is:
d) those people who are completely unaware of crypo: unaware that they  might actually want it on occasion, and unaware that they don't have it.
It's not that they gave it a bit of thought and decided against it for  whatever reason - they never gave it even a moment of thought.  The  only crypto they use is the crypto that is invisible to them (usually  https, which is pretty invisible).

@_date: 2010-01-10 23:10:05
@_author: David Shaw 
@_subject: Web of Trust itself is the problem 
We can argue the definition of "invisible" vs "transparent" for days  and waste everyone's time.  I use the term to mean "They don't see  https.  They don't really care about it, as evidenced by most just  hitting the "continue" button when are told about a bad certificate,  and have only the vaguest notion (if even that) that they might want

@_date: 2010-01-19 17:18:55
@_author: David Shaw 
@_subject: weird behavior of symmetrically encrypted file 
Exactly.  The big speedup you get by using the quick check is that you don't discover that the key you have is wrong after you've gone and decrypted gigabytes of garbage.  It does not improve your s2k performance at all, since as you point out, that would render the s2k count sort of meaningless.
Incidentally, a few years ago there was an interesting attack against OpenPGP that used the quick check bytes as an oracle.  See  for the paper.  This is why the quick check isn't done for public key encryption (only conventional passphrase encryption).

@_date: 2010-01-22 08:48:56
@_author: David Shaw 
@_subject: Installation of gnupg on Sun Solaris 
It should "just work" with many compilers, but I'd recommend gcc if  you have it installed.

@_date: 2010-01-22 08:52:02
@_author: David Shaw 
@_subject: Storing password in keyring 
Not within GPG.  GPG stores keys within keyrings.  Passphrases are  stored outside the system (but see the gpg-agent for a local  passphrase cache).
Not using GPG, but there are several tools available for split keys on  the net.  For example: That is not GPG.  That is a completely different implementation of the  OpenPGP standard.  You should ask on the Bouncy Castle forums.

@_date: 2010-01-29 13:43:43
@_author: David Shaw 
@_subject: Problem encrypting to a hushmail gpg key 
Algorithm 3 is "RSA Sign-Only".
Algorithm 2 is "RSA Encrypt-Only".
Both of those algorithms are deprecated in the OpenPGP spec: "RSA Encrypt-Only (2) and RSA Sign-Only are deprecated and SHOULD NOT be generated, but may be interpreted."
The 1.4.x branch will interpret these deprecated keys (internally treating them as regular RSA with the appropriate encrypt or sign flags).  I don't think gpg2 does that.
Was this generated by Hushmail?  If so, they to stop generating keys that the spec says SHOULD NOT be generated :)

@_date: 2010-07-06 13:04:14
@_author: David Shaw 
@_subject: GPG clarification 
The encryption used for encrypting secret keys is the same symmetric encryption used for encrypting data.  By default this uses CAST5, but you can change it to whatever you like with --s2k-cipher-algo (and then changing your passphrase).

@_date: 2010-07-12 11:37:58
@_author: David Shaw 
@_subject: Decrypting file encrypted for multiple recipients using a given 
There isn't a direct way to do this.  GnuPG tries to decrypt the various encrypted session keys in order, so you'll get prompted for them in order.
If you want to always have B before A, try switching the "-r" arguments when you encrypt.  That will switch the order of the encrypted session keys.

@_date: 2010-07-20 16:56:09
@_author: David Shaw 
@_subject: verifying hashes with GnuPG 
No.  You can do this with sha1sum (sha256sum, etc), with the --check option.

@_date: 2010-07-21 10:33:16
@_author: David Shaw 
@_subject: GPG seems broken on FC13 after upgrade. 
Fedora 13 made a (in my opinion) bad change in how they handle GnuPG.  Previously, there were two packages: 'gnupg' and 'gnupg2'.  This makes sense since the two branches of GnuPG are intentionally non-conflicting, and while there is significant overlap, do serve somewhat different purposes.
Fedora 13 removed 'gnupg' (i.e. gnupg 1.4.x) and caused the 'gnupg2' (i.e. gnupg 2.x) package to replace it.  This breaks all sorts of scripts and things that were written to use 1.4.x.
A few people are trying to get this fixed in Fedora.

@_date: 2010-07-21 11:47:16
@_author: David Shaw 
@_subject: Keypair is expiring. 
Yes and no.  You can indeed change the expiration date of your key (use "gpg --edit-key THEKEY" and then "expire"), but you must give your public key to your encryption partners again so they get the new updated key.
That is another option.  Neither option is right or wrong.  If you have a bunch of signatures on your key that you want to keep, you'd probably do better with changing the expiration date.  If you want to take this opportunity to make a larger key, then you could re-issue.

@_date: 2010-07-22 17:17:40
@_author: David Shaw 
@_subject: plausibly deniable 
By that logic, no program can be said to provide plausible deniability ;)
(Not that I necessarily disagree - I tend to get stuck on the "plausible" part of the deniability.  If things reach the point where you're relying on plausible deniability to save you, you're already in deep trouble.)

@_date: 2010-07-23 13:34:55
@_author: David Shaw 
@_subject: User ID without email address 
It does make sense, and some people do it.  The problem is that it makes it difficult to use that key with some mail programs, which look for the proper key to use by email address.  You can also have problem with people finding your key on keyservers.
A better solution might be to just buy a domain (it's cheap these days) and then your email address will never change.
No.  When you make a signature, you are affirming that you believe that the user ID you are signing correctly represents the owner of the key.  If you don't check the email address, you can't really affirm that.
Not everyone checks.  I believe they should.

@_date: 2010-07-26 11:08:07
@_author: David Shaw 
@_subject: Can't open PGP file with Gnupg 
I'm happy to take a look at a file to see what exactly is wrong if you're willing/able to send me one.  I'd need the key to decrypt it, so either encrypt the test message to my key (99242560), or make a new key for the purpose.
Most likely the problem you are having is that PGP version 6.5 is beyond antique at this point.  You might try adding the "--pgp6" flag to your gpg invocation, which enables some workarounds for various PGP 6-isms, but basically the problem is that PGP 6.5 predates the standard that GnuPG follows.

@_date: 2010-06-03 11:02:39
@_author: David Shaw 
@_subject: Crypto Stick released! 
That is not correct.  Each individual key can be up to 3072 bytes.  The internal hardware can actually handle slightly more, but 3072 is the current limit.

@_date: 2010-06-07 11:23:07
@_author: David Shaw 
@_subject: Crypto domain auction ends tonight! 
Hi everyone,
The crypto domain auction has done better than I expected, and we've raised $185 for the FSF/FSFE.  At 8pm US/Eastern (midnight GMT) tonight, the auction will close and I will notify the winners shortly afterwards.
If anyone wants to grab a domain, now is your chance.  See

@_date: 2010-06-10 10:00:18
@_author: David Shaw 
@_subject: Keyserver spam example 
Hi everyone,
Periodically there is a discussion on this list about whether having your key on a keyserver will result in more spam.  My feeling on this is that you might get more spam, but it's a drop in the bucket compared to the usual onslaught that streams in daily.
That being said, I just got my first piece of spam that was definitely caused by presence on a keyserver:
Begin forwarded message:
(spam contents snipped - it goes on to offer to sell me LCD screens for my "retail store, shop, boutique or any public area")

@_date: 2010-06-10 10:56:28
@_author: David Shaw 
@_subject: Keyserver spam example 
Please read the spam I quoted above:  "We found your contact Email address from wwwkeys.ch.pgp.net:11371".
When the spammer takes the time to tell me he crawled my address from a keyserver, and is even kind enough to tell me which one, I'm inclined to believe him.

@_date: 2010-06-11 13:59:02
@_author: David Shaw 
@_subject: Importing private key from key server 
Sorry, no.  Keyservers only store public keys.  Even if you somehow managed to manipulate things to get that key onto your private keyring it would still be a public key and not contain the private data.

@_date: 2010-06-18 09:06:10
@_author: David Shaw 
@_subject: Multiple signatures 
gpg -u signer_1 -u signer_2 -u signer_3 --detach-sign file-to-sign
You'll end up with a file-to-sign.sig that contains all three signatures.  When you verify file-to-sign.sig, all three signatures will be checked.
Alternately, you can do the same "multiple signer" trick with regular --sign if you want the data and signatures to be put together into a single file.

@_date: 2010-06-18 09:25:44
@_author: David Shaw 
@_subject: Multiple signatures 
If you want a bunch of people all signing the same file, have each signer do this:
gpg -u signer-X -o signer-X-signature --detach-sign file-to-sign
Then have them all send you their "file-to-sign.sig" files.  You create a file containing all of them:
cat signer-1-signature signer-2-signature signer-3-signature > file-to-sign.sig
Then anyone can verify file-to-sign.sig against the original file-to-sign and see all the signatures verified.

@_date: 2010-06-18 15:42:31
@_author: David Shaw 
@_subject: auto refresh-keys 
When I wrote the new keyserver stuff, I thought about this sort of thing, but the lack of a good way to store metadata was a problem (the keybox fixes this), as well as the concern that keyservers are effective trackers of who is using what key.  For example, a keyserver operator could tell (based on how often which keys were refreshed), who your encrypted correspondents were, in rough frequency-of-communication order, to boot.
This doesn't necessarily make it a bad idea, of course - for some people, the benefits outweigh the disadvantages. It should be something users would have to elect to turn on, rather than having it turned on by default, though.
I'd want to hear from the keyserver community about this.  It's easy to talk about improving behavior, but they're running a free public service out of the kindness of their hearts.  This client-side change could mean a rather significant increase in the amount of bandwidth their free service consumes.  Some other useful client-side optimizations require the keyservers to actually do crypto (rather than be the easier packet stores), which requires a pretty dramatic change in the keyservers themselves.

@_date: 2010-06-18 15:42:39
@_author: David Shaw 
@_subject: auto refresh-keys 
The danger here is that it might take a long time (minutes+) to realize that the keyserver and/or network wasn't going to cooperate.  This could seriously slow down many GPG operations.

@_date: 2010-06-21 18:32:13
@_author: David Shaw 
@_subject: local signatures: should they be importable by default in some 
Not only is it reasonable, it is already the case :)

@_date: 2010-06-22 09:27:39
@_author: David Shaw 
@_subject: local signatures: should they be importable by default in some 
The definition of a local, or non-exportable, signature is one that is not intended (for whatever reason) to be used by someone other than the issuer.  Perhaps I should say the "original" definition, as with many other things, people can come up with creative uses for it that were not specifically discussed in the standard.
In any event, if a signature is not intended to be used by someone other than the issuer, then it is reasonable that the issuer (or in practice, someone who possesses the issuing secret key) should be able to import the signature without it being stripped off.  After all, it's a signature made by themselves for their own benefit.

@_date: 2010-06-22 09:27:46
@_author: David Shaw 
@_subject: local signatures: should they be importable by default in some 
I'm not sure this is good behavior for Alice.  If she is concerned about whether her linkage to Bob is publicly known, why would she risk that by giving Charlie a signature (local or otherwise)?  Now she has not only to worry about keeping her linkage secret herself, but she also has to worry about Charlie keeping her linkage secret.
In the above scenario, it seems more reasonable for Charlie to locally sign Bob's key himself on Alice's say-so.

@_date: 2010-06-22 13:29:32
@_author: David Shaw 
@_subject: local signatures: should they be importable by default in some 
The issue is not whether Charlie will maliciously expose Alice, but that information about Alice is under the control of someone other than Alice.  For example, say Charlie is hacked - the information given by Alice can be leaked without Charlie's consent.  Worse, since the information we're talking about here is in the form of a signature that could only have been issued by Alice (or at least someone with access to Alice's key), you get into non-repudiation issues.  Alice can deny a myspace page ("I have no idea what this guy Charlie is going on about - I've never met that Bob person").  Denying a signature is harder.
That's one of the main uses for local signatures - the "I believe this key is valid for me, but I'm not willing to say so in public for everyone" case.  That might be because of privacy, or it might be because Charlie is satisfied that the key is valid, but doesn't have enough proof to be willing to have other people rely on that.  This case is actually quite common.
For example - I've been working with Werner on GnuPG stuff for almost 10 years now.  I'm pretty sure his key is his by now ;)  Would I sign his key?  No, I wouldn't - because I can't perform the appropriate checks.  Would I sign it locally?  Sure.  Signing locally only makes a commitment to myself.  Everyone is free to make local signatures to whoever they like, on whatever criteria they like.  That's what's so wonderful about local signatures - they don't hurt anyone but the signer, so if you believe that the key is valid, lsign away.
In the case of Charlie using Alice's local signature, that's a strange use - a signature that was made with the express setting that it shouldn't be public, made into something public.  You can often stretch and bend a standard into doing these sorts of things, but it usually hurts.  Note, for example, that not all OpenPGP programs will even let you do this, so it immediately fails as soon as someone isn't using GnuPG.

@_date: 2010-06-22 22:39:57
@_author: David Shaw 
@_subject: IDEA Status? 
I'm not sure about the 2007 patent expiration - I recall it being right around now, actually (2010-2011).
In any event, it's mostly not supported.  IDEA in OpenPGP is a funny thing - it sort of missed its useful window because of the patent stuff.  PGP 2.x used it, but when things went to OpenPGP, 3DES was used instead, and IDEA was downgraded to a SHOULD implement in the first OpenPGP spec, and then downgraded further to a MAY implement in the revised spec.
Time moved on, and better ciphers became available, so these days even though the patent is expiring, there isn't really a use for IDEA outside of interoperating with users of PGP 2.x.  I'd be surprised to see much PGP 2.x usage these days.  OpenPGP even explicitly rejects making new PGP 2.x-style keys.

@_date: 2010-06-22 23:25:32
@_author: David Shaw 
@_subject: Using the "clean" function (and the "PGP Global Directory") 
Not exactly.  The GD speaks LDAP, so you can set your keyserver to ldap://keyserver.pgp.com and you can query and submit, etc.
The SKS servers (i.e. pretty much everything that isn't the GD) do support photo IDs, but they do not use the web interface to show you the photo.
Are you sure about that?  "clean" strips off useless signatures (useless being defined as an invalid signature, a superseded signature, a revoked signature, and a signature from a key that isn't present on the keyring).  Signatures from keys that are present, but have no trust value are not stripped off.
Hard to answer since you seem to be reporting behavior (signatures from keys that have no trust value being stripped off) that is not in accordance with what I'm seeing.  What version of GPG are you seeing it on?  Can you demonstrate the problem?
SKS servers will re-merge.  The GD won't re-merge, but will take the new key whole.

@_date: 2010-06-23 00:35:19
@_author: David Shaw 
@_subject: IDEA Status? 
So it's still patented, starting to show cracks, and only really used for compatibility with a very deprecated key type and codebase.
It's not even clear where you could get a license if you really had to use IDEA.  The mediacrypt.com site where you can get a license was offline for a long time.  It's back online now (and goes to the Nagra/Kudelski page, which may be amusing to those who used Nagra reel-to-reel tape recorders at one point - odd what companies expand into), but I still see nothing about IDEA licensing.

@_date: 2010-06-23 00:44:30
@_author: David Shaw 
@_subject: Using the "clean" function (and the "PGP Global Directory") 
Ah, good.  I'm glad.
Not directly, but you can do something like this:
   gpg --recv-keys `gpg --with-colons --fixed-list-mode --list-sigs $THE_KEY | egrep '^sig:' | cut -f5 -d: | sort -u`

@_date: 2010-06-27 16:11:27
@_author: David Shaw 
@_subject: "No-Keyserver" (and other) flags on keys 
Not only is it possible, it already exists.  GnuPG can even set it and unset it, as you like.
It's effectively a no-op though, as no server supports it.

@_date: 2010-06-27 19:34:51
@_author: David Shaw 
@_subject: "No-Keyserver" (and other) flags on keys 
It's a flag that can be set on a key user ID, similar to cipher or compression preferences.  Run "--edit-key" on a key, and enter "showpref" or "pref".  You will probably see a mention of "Keyserver no-modify" (or "no-ks-modify").  You can turn it on and off with setpref, like any other preference: "ks-modify" allows keyserver modifications, and "no-ks-modify" disallows them.
Note that the definition of no-modify is that only the keyholder (or the administrator of the keyserver) can override it.  So the flag only applies to other people - the keyholder can choose to upload his key if he so desires.
Sure enough, it's not in the man page.  I'll fix that.
Having keyservers support no-modify requires that they first support crypto at all.  That's a really big step.

@_date: 2010-06-27 20:44:09
@_author: David Shaw 
@_subject: "No-Keyserver" (and other) flags on keys 
Vastly more.  Keyservers are basically databases with a front-end that understands the OpenPGP key format.  They don't actually do any crypto math - just storing the key packets in the database and allowing people to search for them.
At the moment, it doesn't.  That would need to be addressed if you want keyservers to be able to reject a no-ks-modify key.  One way to do it is to only accept key updates that are signed by the key itself.  But, of course, to do that, the keyserver needs to be able to verify a signature...

@_date: 2010-06-27 22:29:35
@_author: David Shaw 
@_subject: "No-Keyserver" (and other) flags on keys 
Correct, but then, RFC-2440 or 4880 doesn't say much about keyservers at all.  It's mainly a message format document.  Semantics of keyservers are not specified beyond one or two minor things like the no-modify flag and the "preferred keyserver" field.
The difficulty with mailing the primary user ID a cookie is that it pretty much means your server can't synchronize with any other server.  Since your server would have an entrance restriction, and the other servers won't, that means that your server would have to either reject keys from other servers (i.e. not syncing) or apply the same restriction (email user IDs from keys that weren't uploaded directly to your server).  keyserver.pgp.com solves this by simply not syncing to anyone else.  That makes it a completely opt-in server.
There is crypto involved in showing that the flag is real - that the keyholder set the flag, and not someone just setting the flag for malicious reasons.
For example, take the case of a key with the no-modify flag set (i.e. the keyholder doesn't want the key on a keyserver).  The attacker takes this key, and removes the flag.  He then sends the key to a keyserver without crypto.  The keyserver sees the key has no flag, so accepts it.  This allows an attacker to violate the keyholder's requirements.  If the keyserver had crypto, it would know that the key had been tampered with and the flag removed.

@_date: 2010-06-28 11:41:16
@_author: David Shaw 
@_subject: "No-Keyserver" (and other) flags on keys 
The difficulty in transferring the owner's intent to update from server A to server B is one of the reasons why a server that does honor no-modify can't easily sync with other servers.  It's not impossible, but would require a whole new method of synchronization to accommodate the extra signatures involved.  Syncing from a server that honors no-modify to one that doesn't honor it is even worse.
It does.
  auto-key-locate  hkp://pgp.mit.edu  hkp://subkeys.pgp.net  hkp://some.other.server.etc  ldap://even.a.ldap.server.works
List as many as you like, they'll be tried in order.
No, it doesn't.  At the moment we have a set of servers that clearly and explicitly do not have support for this.  There is nothing to attack here - you can't fool a server into accepting something it shouldn't, when the server by design accepts everything.
If we had keyservers that didn't properly implement this new feature, then you have something to attack.  Users might believe that the feature actually works and act accordingly, only to find out that it doesn't actually work, and that it can be tricked into accepting keys it claims it won't.
I'm neither for it nor against it.  I'm for clearly specified and well designed features.  If one of those features requires crypto, then that's fine, and it becomes possible to weigh the pros and cons of adding crypto on the one side, and the benefit of the new feature on the other.
The cost of adding crypto is high.  The benefit of having the keyserver check self-sigs is minimal since the clients will have to do it all over again anyway.  I wouldn't do it just for that.  Once you've added crypto, though, a number of features that were previously impossible become possible (no-modify for one).

@_date: 2010-06-29 23:11:12
@_author: David Shaw 
@_subject: On the fly encryption of files possible? 
One piece that you're likely to find difficult in a fuse filesystem using GnuPG is that fuse is a more or less straight mapping between the kernel VFS and userspace. That means you need to handle seeking and other out of order reads. Since OpenPGP objects are CFB(ish), you can't seek within them. So on the one hand you have a filesystem interface that requires seeking. On the other hand, you have a storage primitive that cannot seek.
There are a few ways to handle it, but as with most things, the best answer depends on the fine details of your situation.

@_date: 2010-02-28 19:55:13
@_author: David Shaw 
@_subject: key question 
You can certainly tell a lot about someone by the signatures on their key.  Either directly from the signature or because those signatures point to other keys that have their own signatures, etc.  With your permission, may I see what I can find from the signatures on your key D6B98E10?  I will of course never post it here or anywhere without your permission.  I will send it only to you, off-list.  I'm not trying to be evil - just demonstrating that you can derive a lot from signatures on a key.  If you do not want me to look, I won't.

@_date: 2010-02-28 20:08:10
@_author: David Shaw 
@_subject: key question 
Voltaire.  "Le mieux est l'ennemi du bien".  Rob's translation is as good as any I've seen.

@_date: 2010-02-28 22:24:57
@_author: David Shaw 
@_subject: key question 
Understood, and I agree it makes no such statement.  However, it does make a reasonably good statement that you were physically located near that person at a certain point in time, roughly what that time was, and roughly where (geographically) it happened.
Better than that, though, signatures point to other keys.  And self-signatures are signatures, too.
I'll send you some stuff.

@_date: 2010-03-01 11:27:31
@_author: David Shaw 
@_subject: David's findings 
Thanks, Rob, for being such a good sport about this test.
If I had known I was being scored on number of 'hits', I'd have given more of them.  :)  There were more items I could have given, but they would have revealed the source I used, so I did not list them.  I found most of the hits in around 20 minutes, and then things dried up for another 10 (I was hunting for high school information and it went nowhere), so I stopped, as 30 minutes seemed like a good stopping point.  I never actually looked at your home page (it felt a bit like cheating, somehow).
In terms of confidence, I had fairly high confidence in most of the answers, except for (perhaps not surprisingly) the ones that turned out I was wrong about (i.e. in retrospect, I shouldn't have guessed).  Both the religion (not sure why this was counted as two 'misses') and Halo were guesses based on not much evidence.  I'd call the GnuPG/PGP one (high confidence) a draw - I said "GnuPG rather than PGP", but the answer was "GnuPG and PGP" (as the key was generated with one, but actually used with both).  I was only medium confident about the vehicle color (an educated guess), but ended up getting that one right.
In any event, I - partially - agree with your comments in that I'm quite sure that a private investigator, or someone with actual training in this sort of research, would have been able to find everything I found without looking at keys at all.  Without knowing the key information or even what OpenPGP was, most likely.   What struck me was that I was able to find all that in around *20 minutes*, after being prompted by information on the keys.  It's not just about getting the data.  It's also about getting it as quickly and as easily as possible, and the key data made my job dramatically easier.  It means the attacker can attack more people, pay less for each attack, and be less trained.  A piece of information that can be reached via multiple different paths is also more likely to be found than information that can only be reached via one.
I don't believe I would have been able to find out the vehicle color, age of the house, or one of the names without the hints provided by the key data, or at least not within the 30 minute window.  You mention a name above as something available from Google, but I actually found two different names from two different sources for this individual.  I listed them both in my mail to you, but the one that turned out to be right was not the one reachable from a Google search.
Perhaps I got lucky.  I do think it is safe to say that access to the key gave me more (in both quantity and speed) than I would have been able to get otherwise, which is what I was trying to show, so I'm content to leave it there.
I don't want to give the impression that OpenPGP keys, signatures, or keyservers are somehow evil here.  They're not.  It's just that, like any number of other things on the net, keys and their contents can serve as a channel for information leakage.  This shouldn't be news to anyone on this list.

@_date: 2010-03-01 13:57:48
@_author: David Shaw 
@_subject: Offline Primary Key 
What you need to do is an --export-secret-subkeys (there is no such command as --delete-primary-keys).  So, starting from a state where your whole key (primary and all secondaries) are all imported to your GPG instance, do:
   gpg --export-secret-subkeys (thekeyid) > my-secondary-keys-only.gpg
Then import my-secondary-keys-only.gpg into whichever GPG you want to use it with.  If you want to use it with the same one you just exported from, then do:
  gpg --export-secret-key (thekeyid) > my-real-secret-key.gpg
  gpg --delete-secret-key (thekeyid)
  gpg --import my-secondary-keys-only.gpg
(i.e. save a copy of the full key, delete it from the keyring, and replace it with the secondary-key-only copy).
Make sure you save my-real-secret-key.gpg in a safe place!
Didn't someone write a nice HOWTO about offline private keys at one point?  I thought there was one out there, but can't find it at the moment.  Can anyone post the URL for Philip?

@_date: 2010-03-01 15:37:28
@_author: David Shaw 
@_subject: Offline Primary Key 
Ah, thanks!  I knew I remembered that it was out there, but just could not find it for some reason.

@_date: 2010-03-01 15:37:41
@_author: David Shaw 
@_subject: Offline Primary Key 
It has to do with how keys are specified.  In GnuPG, you can specify a key in a number of ways - by name, by (any) fingerprint, and by (any) key ID.  So if you have a key named "foobar", and the key ID is AAAAAAAA and the subkey ID is BBBBBBBB, you could refer to that key with any of "foobar", "AAAAAAAA", or "BBBBBBBB".  When you say "--delete-secret-key BBBBBBB", you're actually saying delete the whole key.

@_date: 2010-03-01 16:13:33
@_author: David Shaw 
@_subject: Offline Primary Key 
Not for deletion.  There is no way to delete a primary key "in place" while leaving the subkeys intact.  Such an ability is very dangerous since if you delete that primary key without a backup, you'll never be able to make more subkeys, issue a revocation certificate, or sign someone elses key.  The current design effectively forces people to manually move the valuable primary key out of the way before clobbering it with the subkey-only copy of the key.

@_date: 2010-03-01 17:15:40
@_author: David Shaw 
@_subject: How to give the keywork from command line. 
Indeed.  If you have to encode a passphrase in a batch file or other piece of code that calls GPG, it's worth asking yourself why you have a passphrase there at all.  You might want to just remove the passphrase altogether.

@_date: 2010-03-02 23:00:26
@_author: David Shaw 
@_subject: Migrating from PGP to GPG question 
OpenPGP keys contain several algorithm lists, one each for cipher algorithms, hash algorithms, and compression algorithms.  Among other things, these lists are used to guarantee that someone doesn't send you a message that you can't handle.  For example, if the list of ciphers on your key didn't have AES-256, then nobody should use AES-256 when sending you a message.
The warning message above means that your key 96B12847, aka "pss", has a listing for cipher 1 (called "IDEA"), but your copy of GPG doesn't have IDEA.  This sets up a potentially frustrating situation where someone might send you a message using IDEA (after all, your key claims that you can handle it), but you won't be able to read the message because you really can't handle it.
The right answer, I'm afraid, is to say "yes" to the prompt and update your preferences, and re-distribute the key in question (96B12847 "pss").  This isn't a problem with any other key you have.
Alternately, you can re-build GPG to have IDEA support.  Note, though, that there are legal implications to this.  Unlike all of the other ciphers that are defined by OpenPGP, IDEA is patented and not free to use (the patent runs out in the US in January 2012, I believe, so we're not there yet).  If you have a license to use IDEA, you can download the code from  and use it legally.  Unfortunately, the company that owns the rights to IDEA has more or less disappeared (subsumed into another company, if I recall) and does not seem to be issuing licenses any longer.  This puts those people who really need IDEA in an unfortunate situation.
If you're lucky, it's possible that the various vendors don't use IDEA either and would thus ignore the fact that your key allows it, but I really recommend just updating your preferences and re-distributing the "pss" key.  It's likely the least painful solution here.

@_date: 2010-03-03 15:30:42
@_author: David Shaw 
@_subject: key question 
I basically agree.  I'd say it a little differently as "Using OpenPGP as it is commonly used on the net (with keyservers, and signing parties, and such) as a tool for committing crimes is kind of stupid.".   I think you could do very well using OpenPGP in a nefarious manner, but you'd have to use it in a different way than it is commonly used on the net.  Which is fine - the various OpenPGP implementations are tools, and tools can be used in many different ways, both correctly (meaning "accomplishing what I'm trying to do in a safe and sane way") and incorrectly (meaning "not").
Yes.  Alas.

@_date: 2010-03-04 13:12:31
@_author: David Shaw 
@_subject: Changing & verifying the --max-cert-depth in Windows 
I suspect you don't have any ultimately trusted keys to build your trustdb from.  Run gpg --edit-key on your own key and set the trust to ultimate.  Then try the --update-trustdb again.  GPG will then follow the paths from your key, to keys you have signed, to keys they have signed, etc.

@_date: 2010-03-04 13:22:28
@_author: David Shaw 
@_subject: Changing & verifying the --max-cert-depth in Windows 
Oops - quite right.  I read it too fast.  Change that to: "I suspect you haven't signed any other keys *with* your ultimately trusted key".

@_date: 2010-03-04 17:22:44
@_author: David Shaw 
@_subject: Changing & verifying the --max-cert-depth in Windows 
The "signed" value only counts signatures made on keys that you have in your keyring.  Those 83 keys may have made more certifications, but you don't have local copies of the other keys that they may have signed.

@_date: 2010-03-04 18:13:17
@_author: David Shaw 
@_subject: manipulating the set of keys that can decrypt a file/message 
You might be able to hack something together using the GnuPG sources.  Certainly all of the parts you need are in there - you'd just have to put them together.  Alternately, take a look at  for a library that you might also borrow some code from.

@_date: 2010-03-05 08:59:54
@_author: David Shaw 
@_subject: Migrating from PGP to GPG question 
This would be my advice as well.  The web of trust is generally a useful thing, but in environments where the keys are only provided by the batch owner, it does not add much that is useful to the equation.

@_date: 2010-03-05 11:20:32
@_author: David Shaw 
@_subject: manipulating the set of keys that can decrypt a file/message 
I'd look at the GnuPG 2 code, or more specifically, the GnuPG 2 code plus libgcrypt (the crypto library that GnuPG 2 uses).  This allows you to more easily write something standalone outside of GnuPG.
I don't know if this is a generally useful thing (you're not the first person to suggest this, but you are not more than the 3rd in the past 5-8 years or so).  Each additional feature adds complexity to the code base.  If you are going to write something, I'd recommend a standalone tool using libgcrypt for the crypto part.  That way the feature exists, and it doesn't have to be carried along with GPG.  That's what I did when I wrote 'paperkey'.  It could have been part of GPG (as a new output format), but it didn't really make sense as a built in.

@_date: 2010-03-07 12:53:51
@_author: David Shaw 
@_subject: key question 
There is no 'now' here.  This is not new behavior in GPG, and the expert flag never had anything to do with it (indeed, the behavior predates the existence of the --expert flag).  When GPG asks you for an email address, just hit return.  GPG doesn't care one way or the other.

@_date: 2010-03-11 10:45:55
@_author: David Shaw 
@_subject: Implications Of The Recent RSA Vulnerability 
Basically, no, and for several reasons.  There are a few things that need to be understood about the new attack.  Briefly, this is an attack that relies on manipulating the power supply to the CPU, in order to cause it to make errors in RSA signatures.  If you process a lot of these errored signatures, you can recover the secret key.
In practice, and with GPG, however, it's a pretty hard attack to mount.  First of all, you have to have access to and the ability to manipulate the power supply to the CPU.  If someone had that kind of access to your machine, there are better attacks that can be mounted (keyboard sniffer, copying the hard drive, etc.)   Secondly, your 4096 bit key is much larger than the 1024-bit keys the researchers were able to break.  Thirdly, the attacker needs thousands and thousands of signatures with errors in them.  This takes time to gather, increasing the amount of time that the attacker needs to be manipulating your power supply.  Lastly, and perhaps most significantly, GPG has resistance to this particular attack anyway: it checks all signatures after creation to make sure that nothing like this happened.  If an attacker managed to make the CPU hiccup and make an error when generating the signature, the signature check would see the signature was invalid and cause GPG to exit with an error.

@_date: 2010-03-11 17:53:03
@_author: David Shaw 
@_subject: Paperkey  (Was: Re: ) 
Paperkey doesn't care what size the key is.  Try doing that same command line, but use "wc -c" instead of the dmtxwrite part to check that the output is larger than with a 2048 bit key.  Perhaps dmtxwrite is having a problem?

@_date: 2010-03-11 21:36:03
@_author: David Shaw 
@_subject: Question about passphrase-fd 
The "bad key" error doesn't mean the passphrase is wrong (that would be "invalid passphrase").  It often means that the file you are decrypting is corrupt.  Was the file you are decrypting encrypted with a passphrase only or with a public key?

@_date: 2010-03-12 17:14:38
@_author: David Shaw 
@_subject: updprefs command and changing key 
This is exactly correct.  The prefs are just a field attached to the key.
However, your 3rd party should not have rejected the key.  The OpenPGP preferences system is designed to *always* reach a valid answer.  Every preference list contains Triple-DES, whether you explicitly list it there or not, and every OpenPGP program is compatible with Triple-DES.  If no other compatible ciphers are found, the answer is Triple-DES.

@_date: 2010-03-12 17:24:03
@_author: David Shaw 
@_subject: Question about passphrase-fd 
No.  You need to specify it for encryption, but on decryption (except in certain special cases, and this is not one of them) GPG can see what cipher was used directly from the encrypted file and handle it automatically.

@_date: 2010-03-12 19:07:08
@_author: David Shaw 
@_subject: updprefs command and changing key 
Patch the source :)
There is no way other than that.  3DES is a required part of OpenPGP, so if you remove it, you're not going to play well with the other programs out there.

@_date: 2010-03-13 07:43:24
@_author: David Shaw 
@_subject: updprefs command and changing key 
We were discussing this in the context of the cipher preferences system (Subject "updprefs command and changing key").  You cannot remove 3DES from the preferences, even with disable-cipher-algo.  You can positively force any cipher algo you like via cipher-algo (rather than by removing one from the available list), but cipher-algo disables preferences altogether (with the usual shoot-yourself-in-the-foot ability that grants you).

@_date: 2010-03-13 07:45:06
@_author: David Shaw 
@_subject: updprefs command and changing key 
Try it - make a key that has only 3DES in its preferences, and then try encrypting to it with --disable-cipher-algo 3DES set.  You'll end up with 3DES anyway.  The way the code is structured, if the cipher selection algorithm fails (and it will in this case - the key requires 3DES, but you've disabled 3DES) so GPG has to resolve the crisis somehow - and it resolves it by using 3DES as it "knows" that OpenPGP requires it to be present.

@_date: 2010-03-13 07:58:40
@_author: David Shaw 
@_subject: updprefs command and changing key 
It won't work anyway.  You can't remove 3DES from the cipher preferences with disable-cipher-algo.  The best you can do is set a personal-cipher-preferences with ciphers other than 3DES and then simply decline to communicate at all with people who have a 3DES-only key.  To make matters worse, not only does it not work in preventing 3DES being selected via preferences, disable-cipher-algo also has the unpleasant side effect of making the user unable to *decrypt* 3DES messages as well.
So setting disable-cipher-algo 3DES both doesn't accomplish what it was intended to, and also breaks other things.  I'd avoid it ;)
There will eventually come a day when 3DES will have to go.  We're not there yet, and it'll be a big deal from the OpenPGP perspective, given the special position that 3DES has within the protocol.

@_date: 2010-03-13 08:25:45
@_author: David Shaw 
@_subject: Paperkey (Was: Re: ) 
paperkey can generate text output (which has the comments on top) and raw output.  The raw output is binary (so not directly printable as text, and obviously no comments), but has the advantage of being significantly smaller as one byte is one byte, rather than the 3 bytes it takes up in text form.  If you are piping to something like dmtx, you should use raw output (--output-type raw).

@_date: 2010-03-13 21:49:34
@_author: David Shaw 
@_subject: updprefs command and changing key 
Sure.  If you just don't list AES in your preferences, nobody will use it when encrypting to you.  Similarly, if you have personal-cipher-preferences and you leave off AES, you won't use it when encrypting to someone else.  You can do that for any cipher that isn't 3DES.  3DES is the only special one here.

@_date: 2010-03-14 09:19:46
@_author: David Shaw 
@_subject: updprefs command and changing key 
Potential problems.  If you have AES in your key preferences, but you disable it, you are telling people to use AES - but then not decrypting it.
Basically, you can guarantee you won't encrypt to anyone using AES if you disable it, but this also means you won't be able to decrypt anything that comes to you in AES.

@_date: 2010-03-14 11:43:28
@_author: David Shaw 
@_subject: updprefs command and changing key 
Correct.  And if a sender forced that algo, they would be doing so in violation of OpenPGP.  GnuPG will decrypt the message anyway, but it will print a warning that the sender violated your preferences (this warning is actually required by the OpenPGP spec).
Not in general use.  It's handy for testing and debugging.

@_date: 2010-03-16 11:18:03
@_author: David Shaw 
@_subject: Should I set cert-digest-algo? 
It depends on who you are communicating with.  If they're using a fairly recent version of GnuPG or PGP, then it's fine.  If there is someone using old software in the mix, then you'll be preventing them from using your key and any signatures you make.

@_date: 2010-03-19 18:23:13
@_author: David Shaw 
@_subject: gpg symmetric to Java JCA decryption 
GnuPG encrypts using the OpenPGP standard.  The Java cryptography architecture doesn't follow that spec (that "file format" if you like). If you want to do OpenPGP in Java, I suggest  which is a provider for the cryptography architecture.

@_date: 2010-03-20 10:50:16
@_author: David Shaw 
@_subject: AUTO: Richard Hamilton is out of the office (returning 03/22/2010) 
There was *one* auto-reply message, and it has not reoccured.  Whatever was wrong is clearly resolved.  Let's move on.  There is nothing else to see here.

@_date: 2010-03-20 11:12:00
@_author: David Shaw 
@_subject: Secure unattended decryption 
Being helpful on mailing lists is similarly a skill worth learning.  If there is a particular paper you want to point to, give the cite.  Why make someone guess that you were referring to yourself, then search for the paper you carefully didn't mention the title of, then try and find a free-to-download version - and then scold them for not succeeding?  This isn't a puzzle game.
For the archives, the paper in question is "Implementing BitLocker Drive Encryption for Forensic Analysis".  You can download it at

@_date: 2010-03-20 20:57:04
@_author: David Shaw 
@_subject: Keyservers 
The easy answer is that is doesn't matter.  With few exceptions, you can think of the keyserver world as having only two servers: "keyserver.pgp.com", and "everybody else".  The PGP.com one does some validation (by mailing the user ID on the key) that the keyholder is reachable via that address.  The other servers do not validate, but have the advantage of more keys.  You get to pick which you want more - there is no one right answer, and GnuPG will happily talk to either.  (At the risk of reopening the recent discussion of whether people can/should upload someone else's keys to a keyserver, it's worth noting that keyserver.pgp.com only accepts key submissions from the address named on the key).
Anyway, if you choose "everybody else", at least in theory, it doesn't matter which of the "everybody else" servers you hit.  They synchronize with each other, so will have the same keys.  In practice, there are a bunch of servers around the world, which might go up or down, so some folks have set up a special server name that round-robins among several running servers.  It checks the various servers twice a day and only includes healthy ones in the list.
All that is a longwinded way of saying to try "pool.sks-keyservers.net". ;)

@_date: 2010-03-20 23:28:55
@_author: David Shaw 
@_subject: Generating a new key 
As a rule of thumb, only deviate from the defaults if there is a particular reason to do so.  The defaults are carefully chosen to be a reasonable choice for the majority of people.
No worries here.
It's the default anyway, so that's fine.
I wouldn't do this.  The default is SC (sign+certify).  If you want an authentication key at some point in the future, I recommend a subkey.  If you make your primary key the authentication key, you need to have that key online, and lose the ability to store it offline someday.
30k is a little big, but don't shrink its dimensions.  Instead, shrink its color depth and perhaps lower the JPEG quality level a bit.
Frankly, you don't have much to worry about with a 2048 bit key either.  It also is slightly odd to use an encryption key that is so much larger than your signing key.  Another reason to not go 4096 is it removes the ability to use a smartcard in the future.  The smartcard is (currently) limited to 3072-bit keys.
I'd leave this at the default value.

@_date: 2010-03-21 00:10:17
@_author: David Shaw 
@_subject: Generating a new key 
It's what GnuPG uses (in combination with a few other things) to convert your typeable-by-a-human passphrase into the symmetric key used to encrypt the secret key: S2K stands for "String to Key".  It's okay to use SHA-256 here, but note that it means you might have problems moving your secret key to a different program that doesn't support SHA-256.  There aren't a vast number of current programs that don't support SHA-256 these days, but there are some pretty old installations out there.
Incidentally, you don't have to set s2k-digest-algo before you generate your key.  If you want to "upgrade" an existing key passphrase so it is mangled via SHA-256, just set the s2k-digest-algo and change the passphrase (you can even change it to what it is currently set to - it's the change at all that causes the passphrase to be remangled).
A somewhat larger risk here is that the s2k-digest-algo also applies to symmetrically encrypted data (i.e. gpg --symmetric).  You need to make sure your recipient can handle it before using it.
And also your own key (in the self-signatures that contain the preferences and other key items).
Yes, they are outdated, but they do exist.  How common they are depends on your community.  If you're talking about the open-source community or people on this list, for example, I'd be surprised to see more than a small number.  If you're talking about code that was installed a while back, then you'd likely see more that can't handle it.

@_date: 2010-03-21 00:35:57
@_author: David Shaw 
@_subject: Generating a new key 
GnuPG supports an offline key setup where the primary key is kept offline and the subkeys are kept online (and yes, you can store an authentication subkey separate from the main key).  This works very well for the common OpenPGP case where the primary key is the most important one (as it is used to certify new subkeys, among other things).  If you lose/compromise/etc your online subkeys, just use the offline primary to revoke them and make new subkeys.  The primary isn't kept with the subkeys, so it is much less likely to be lost/compromised along with them.

@_date: 2010-03-21 19:29:12
@_author: David Shaw 
@_subject: Generating a new key 
And more specifically, it is not used in OpenPGP or GnuPG.

@_date: 2010-03-22 10:30:36
@_author: David Shaw 
@_subject: 2.0.14 --gen-key interface nit 
That is by design, though the reason why is different for primary keys and subkeys.  For primary keys, OpenPGP requires this.  All primary keys must be able to certify.  For subkeys, the web of trust is built between signatures on primary keys, so a certifying subkey would not actually serve any purpose (signatures from it would be ignored).  Note there is no official standard web of trust document that defines this, but it is the convention that all current programs that use the web of trust adhere to.
That was my intent when I added that feature.  That doesn't make it ideal, of course :)
I'm open to changing it, but ideally this would be in a backwards compatible way.

@_date: 2010-03-22 16:40:48
@_author: David Shaw 
@_subject: using a smartcard without keytocard 
Yes.  If I understand what you are asking, the easiest way to do this is to delete the secret key on those systems, then insert the card, and do a 'gpg --card-status'.  That recreates the secret key stub so GPG knows to look at the card for that key.

@_date: 2010-03-23 10:27:10
@_author: David Shaw 
@_subject: 2.0.14 --gen-key interface nit 
Issuing a web of trust signature or signing production keys *are* certifications.  If key couldn't certify, it couldn't even make self-sigs on itself (so no user IDs, or subkeys either)

@_date: 2010-03-23 14:13:53
@_author: David Shaw 
@_subject: 2.0.14 --gen-key interface nit 
Sure, a key is a key.  What you can do with it (i.e. the concepts of "primary" or "subkey") is defined by the protocol, not by something inherent in the key itself.  If a subkey is changed into a primary key, it can do whatever a primary key can do.

@_date: 2010-03-24 09:53:40
@_author: David Shaw 
@_subject: gnupg 1.4.7 vs. pgp 6.5.3 
PGP 6.5.3 is really, really old now, and predates a good amount of stuff that is now part of the OpenPGP standard, including some things that were added for security reasons.  The real answer here is to get company 2 to upgrade to something newer.  It doesn't have to be GPG - any recent PGP would be fine as well.
Since that may not be under your control (I assume you are "company 1" in the above), you can try adding the "--pgp6" option to your GPG command line.  This tells GPG to internally "backdate" itself, so it won't generate any messages using features or algorithms that were added to the standard after PGP 6.   Even so, note that the --pgp6 option backdates to PGP 6.5.8, and company 2 is using a version even older than *that*.

@_date: 2010-03-28 21:26:22
@_author: David Shaw 
@_subject: URGENT: GNuPG 1.2.1 - secret keys help 
Based on the error, it looks like your secret keyring is corrupt.  Do you have a backup of it?

@_date: 2010-04-30 19:44:28
@_author: David Shaw 
@_subject: Crypto Stick released! 
Looks very interesting.  I'm curious how this differs from the SIM-sized card in a SIM-sized USB reader?  For example, the regular 2.0 OpenPGP card in a SCR3320 USB stick reader (

@_date: 2010-05-06 23:19:28
@_author: David Shaw 
@_subject: Wrong signature hash detection? 
I think there is a misunderstanding.  This is absolutely a SHA1 signature.  Why do you think it isn't?

@_date: 2010-05-07 08:25:12
@_author: David Shaw 
@_subject: Wrong signature hash detection? 
The RSA signature size is based on the size of the RSA key (a bigger key means a bigger signature).  DSA signature sizes are based on the size of a value called "q", used when generating the key.  Usually, this is loosely tied to the hash and also the key size, but it doesn't have to be.

@_date: 2010-05-10 09:37:45
@_author: David Shaw 
@_subject: genkey for DSA with 2048 bit 
I assume you are doing a --batch key generation (as that is the one that uses a "Key-Type" field).  To generate a > 1024 bit DSA key, just generate a regular DSA key and request a Key-Length that is larger than 1024 bits.  You need a recent version of GPG (1.4.4 for the 1.x branch), and until the latest release, you had to provide --enable-dsa2 as well.
Only 1.4.4 and later for the 1.x branch.  I don't recall which 2.x version added support.

@_date: 2010-05-11 20:43:28
@_author: David Shaw 
@_subject: Encryption to key with multiple subkeys 
In this example, where one of the two computers is compromised, people encrypting to both of your subkeys guarantees that the attacker can decrypt your communications.  In the current behavior of encrypting to the most recent subkey, the attacker only has a 50% chance of getting your communications.  You should hope that the older PC is the one that gets compromised :)

@_date: 2010-05-18 22:16:57
@_author: David Shaw 
@_subject: Crypto-related domain name auction to benefit FSF and FSFE 
Hi everyone,
I have a few crypto-related domain names that I bought a few years ago for one project or another.  (Among other ideas, I had once thought to set up a 'who will sign my PGP key?' exchange, but then biglumber.com did it so well, there was little point in doing it all over again).  I've been sitting on the domains for a while, but they're not really doing anyone any good like that.  So, rather than just letting them expire and be snapped up by link farms, I thought I could do something more useful for the community - auction them off and donate the money to the FSF and FSFE.
The 5 domain names are:
  keyservers.net
  keyservers.org
  (I don't own keyservers.com - it's parked by someone with advertising links on it)
  keysigners.com
  keysigners.net
  keysigners.org
I figured a two-week auction period would do it, but if someone feels strongly that isn't enough time, let me know.  The basic idea is that people can send me their bids for each domain name, and I will post the current high bids (without identifying the bidder) on After the auction is over, I will notify the high bidder for each domain that they are the winner.  The auction winner is responsible for sending the winning bid directly to the FSF or FSFE (winner's choice).  An easy way to do this is via Paypal to donate at fsf.org or paypal at fsfeurope.org, but other means are available if necessary.  Once the FSF or FSFE confirms to me the donation has arrived, the auction winner and I can do the usual domain name transfer process.
Any questions or comments?  I'd like to start the auction on Monday (May 24th).  Feel free to forward this note to anyone who might be interested in the domains.

@_date: 2010-05-24 10:39:39
@_author: David Shaw 
@_subject: Crypto domains for auction to benefit FSF and FSFE 
Hi everyone,
I have a few crypto-related domain names that I bought a few years ago for one project or another.  I've been sitting on the domains for a while, but they're not really doing anyone any good like that.  So, rather than just letting them expire and be snapped up by link farms, I thought I could do something more useful for the community - auction them off and donate the money to the FSF and FSFE.
The 5 domain names are:
  keyservers.net
  keyservers.org
  (I don't own keyservers.com - it's parked by someone with advertising links on it)
  keysigners.com
  keysigners.net
  keysigners.org
The auction had started and will run through June 7th.  More information and current high bids are available at Please feel free to forward this note to anyone who you think might be interested in the domains, or let me know and I'll ping them.  I'm sending this to gnupg-users and sks-devel to start with.
Bid early and often - it's for a good cause!

@_date: 2010-11-07 21:28:35
@_author: David Shaw 
@_subject: Overflow bug in bzip2 
You can only list bzip2 as a preference if you actually have bzip2 support.  Having bzip2 installed on your machine is only half the issue - you also have to have a GnuPG that is compiled to actually *use* that bzip2.  If "gpg --version" does not display "bzip2" as one of the supported algorithms, then you will need to build a GnuPG that has bzip2 support enabled.

@_date: 2010-11-15 16:42:20
@_author: David Shaw 
@_subject: Examine a key file 
Just run gpg on the file (i.e. "gpg my-base-64-exported-key.asc").  No special arguments needed.

@_date: 2010-11-15 16:46:00
@_author: David Shaw 
@_subject: Examine a key file 
It does not import the key unless you explicitly say --import.

@_date: 2010-11-19 10:58:30
@_author: David Shaw 
@_subject: GPG does not build on SuSE SLES 11 
I was the one who originally tracked this down.  Virtually always, when people suspect a problem with gcc or libc, the problem is really in their own code.  This was one of the very rare exceptions, and the gcc folks fixed the optimizer issue.  I'm not sure I see any benefit in looking at or changing the GPG code in an effort to not trigger a bug in a quite old - and long since replaced - version of gcc.

@_date: 2010-11-21 11:05:33
@_author: David Shaw 
@_subject: Remove a recipient from a message without viewing it 
Yes, this is doable, but I don't know of any code already written to do it.
OpenPGP encrypted messages are constructed of a number of packets, some containing other packets when opened.  So for example, you can have an encrypted packet that contains a data packet, or an encrypted packet that contains a compressed packet that contains a data packet.
In your case, I'd recommend experimenting with the 'gpgsplit' program that comes with GPG.  It will break your message M into its component pieces, and you can re-stitch them together using 'cat' or the like.  Run gpgsplit on your encrypted M, and you will end up with multiple files tagged "pk_enc", and one file tagged "encrypted".  Each pk_enc is an encrypted session key for a particular recipient (Sam, John, or Bob).  If you reassemble a single pk_enc with the encrypted file, you will have a message that is only readable by that recipient.  The same thing can be done to put together an encrypted message that only two of your three recipients can handle - just include the appropriate pk_enc before the encrypted file
You can see RFC-4880 for the internals of how packets are put together, if you're interested in the file details.

@_date: 2010-11-24 13:56:39
@_author: David Shaw 
@_subject: minimum_ownertrust 
Yes.  And the ownertrust can only be set to a level equal to or above the minimum ownertrust.
Unknown - it depends on whether there are any trust signatures on the key.  Just making it ultimately trusted (or the presence of a secret key) doesn't change the minimum.

@_date: 2010-10-06 15:12:31
@_author: David Shaw 
@_subject: Remove key from an encrypted file? 
You can remove a single key's access to the file, but it might not work the way you intended.
That is correct.
An encrypted message consists of several OpenPGP packets, concatenated together.  So for example, if I encrypt a file to Alice, Baker, and Charlie's keys, I'll end up with something that looks like this (somewhat simplified - see RFC-4880 for the actual bits):
     (session key encrypted to Alice) + (session key encrypted to Baker) + (session key encrypted to Charlie) + (encrypted data)
If I wanted to remove Alice's access to the file, I could just strip off her packet, thus leaving:
     (session key encrypted to Baker) + (session key encrypted to Charlie) + (encrypted data)
Now, Alice won't be able to decrypt that file.  However (and this is the potential gotcha), it does not affect any copies of the file that Alice already has.  So if you encrypt your data for three users, and one of those users makes a copy of the encrypted file before you strip his access, that user can still decrypt since he's working off a copy that still has the session key encrypted to him.
Note that this isn't a problem specific to stripping a single key from a file.  The same problem exists when re-encrypting to the remaining people.  Either way, if Alice makes a copy before you strip or re-encrypt, she has the file and can decrypt it.

@_date: 2010-10-21 19:28:53
@_author: David Shaw 
@_subject: Is there a maximum length for an OpenPGP UID? 
Yes, but it's huge: 4,294,967,295 characters long.  That's the OpenPGP answer.  In practice, however, using GnuPG, the maximum is 2048 characters.

@_date: 2010-10-22 13:46:45
@_author: David Shaw 
@_subject: Changing secret key encryption algorithms 
If you ever need a handy reference for which algorithm maps to which number, just run "gpg -v --version".  It will print out which ciphers it has support for, and their algorithm numbers.

@_date: 2010-09-01 00:39:09
@_author: David Shaw 
@_subject: Generating smart-card stubs on a clean computer? 
Do you have the public key corresponding to the card key on that box?  You need the public key plus a run of --card-status to generate the stubs.

@_date: 2010-09-21 23:01:28
@_author: David Shaw 
@_subject: Overflow bug in bzip2 
Hi folks,
This isn't a GnuPG bug per se, but given that many (most?) people using GnuPG have it linked against libbz2, please read  and upgrade appropriately for your platform.
To tell if your installation of GnuPG is using libbz2, run "gpg2 --version" (or "gpg --version").  If you see "BZIP2" on the "Compression" line, then you are linked with libbz2.

@_date: 2010-09-24 09:54:41
@_author: David Shaw 
@_subject: multiple keys vs multiple identities 
It's really a matter of taste.  Some people like using different keys for different roles in their life (similar to how they'd use different email addresses for home and work).
Arguing for different keys: if one key is compromised, the other one isn't.  Some people have a different machine at home and in the office, so leaving the home key on the office computer is less than optimal.
Arguing for the same key: it's easier to build a web of trust if you don't have to get signatures twice.
Personally, I'd use different keys, but again, this is a matter of taste.
It won't work with the current generation of OpenPGP smartcards.  It also will be dreadfully slow if you (or someone you are communicating with) ever uses the key on a small machine (think smart phone).  If you are usually on a "full power" computer, then they generally have the CPU to spare for this sort of thing, and you'll rarely if ever notice a difference.

@_date: 2010-09-24 11:53:17
@_author: David Shaw 
@_subject: per-user data signatures [was: Re: multiple keys vs multiple 
There is actually a defined field for this in OpenPGP (see section 5.2.3.22, Signer's User ID).  I don't think anyone implements it though.
It works for me.  I even cut and paste your exact command line.

@_date: 2010-09-24 12:57:06
@_author: David Shaw 
@_subject: per-user data signatures [was: Re: multiple keys vs multiple 
Hmm.  It's a v3 sig which can't carry a notation.  Do you have force-v3-sigs set anywhere?  Or any of the --pgpX options (which set force-v3-sigs) ?

@_date: 2010-09-27 09:57:18
@_author: David Shaw 
@_subject: how slow are 4Kbit RSA keys? [was: Re: multiple keys vs multiple 
Sort of, yes.  You are measuring verify performance.  At it happens, that is the operation that RSA really excels at, CPU-wise.  Try measuring signing or decryption performance instead.  People on smartphones don't just verify signatures :)
"Dreadfully" is a difficult thing to enumerate anyway.  For me, FWIW, it would be "over 1-2 seconds".

@_date: 2010-09-27 22:51:24
@_author: David Shaw 
@_subject: per-user data signatures [was: Re: multiple keys vs multiple 
No real reason.  Nobody has ever shown a major need for it - it's been in the spec for almost 12 years without much fanfare.  Even if it were implemented today, it would suffer from the fact that all the software to date assumes that a valid signature is a valid signature, and does not take into account which "hat" the signer was wearing at the time.

@_date: 2010-09-28 12:00:10
@_author: David Shaw 
@_subject: per-user data signatures [was: Re: multiple keys vs multiple 
You are correct.  The manual is incorrect.  Setting force-v3-sigs *disables* ask-sig-expire, sig-policy-url, etc.
I've applied something similar (also fixing ask-sig-expire which had a similar problem).

@_date: 2011-04-01 11:01:09
@_author: David Shaw 
@_subject: Public keys on smartcard 
You should take a look at It gives all of the details of what is stored, which operations are available and how they are called.

@_date: 2011-04-09 10:48:44
@_author: David Shaw 
@_subject: default keyserver-options [was: Re: keys not available for signed 
I agree that include-subkeys should be on by default.  That only makes sense, especially now that subkeys are frequently used for signing.
I'm not so sure about include-revoked, though.  For that one, context matters.  If the user is doing a --refresh-keys, then yes, revoked keys are necessary.  If the user is searching by name for a key they don't currently have, then including revoked keys is noisy and potentially confusing (remember that anyone can fake a revocation for any one else's key on a keyserver).

@_date: 2011-04-11 13:50:49
@_author: David Shaw 
@_subject: default keyserver-options [was: Re: keys not available for signed 
I think my objection here is to the expectation of getting any real information out of the keyservers in cases like this.
If Charlie had include-revoked set he'd see two keys: Alice's, with a REVOKED marked on it, and Bob's, without the REVOKED.  I suspect he'd then pick Bob's.  After all, it's not inherently suspicious for Alice to have a revoked key.
The only real answer is to have Charlie download all candidate keys (and there may be quite a few) and find a trust path to them locally.  He can't really trust anything that is told to him by the server.
In any event, I think there is a bit of confusion here.  Both include-subkeys and include-revoked *are* the defaults.  In the case of include-revoked, the manual even tells people not to turn it off, and why:
              include-revoked
                     When searching for a key with --search-keys, include keys
                     that are marked on the keyserver as  revoked.  Note  that
                     not  all  keyservers  differentiate  between  revoked and
                     unrevoked keys, and for such keyservers  this  option  is
                     meaningless.  Note  also that most keyservers do not have
                     cryptographic verification of  key  revocations,  and  so
                     turning  this option off may result in skipping keys that
                     are incorrectly marked as revoked.

@_date: 2011-04-14 09:24:23
@_author: David Shaw 
@_subject: Creating signatures with expiration time 
"cert" is short for certification.  "sig" is short for signature.  Basically, cert applies when signing keys, and sig applies when signing data (i.e. anything that isn't a key).

@_date: 2011-04-15 09:31:54
@_author: David Shaw 
@_subject: Question regarding the migration of the pgp keyring to gpg 
Yes.  PGP 6.5.8 keyring files are directly importable into GnuPG.  Just find your pubring.pkr and secring.skr files and do:
  gpg --import /path/to/pubring.pkr
  gpg --import /path/to/secring.skr
That will import all of the keys at once.

@_date: 2011-04-18 08:25:02
@_author: David Shaw 
@_subject: --s2k-count: correct value in config file needed? 
Yes, the --s2k-count is written in the key.  It doesn't matter what you set it to in the config file/command line when reading an existing key, since the copy in the key is what is used.

@_date: 2011-04-18 22:21:49
@_author: David Shaw 
@_subject: [OT] passphrases Was: Re: Allowing paste into pinentry-gtk-2? 
Actually around 58 months: just under 5 years.
Are you asserting that there exists a group that can brute-force a 64-bit key in a few seconds?

@_date: 2011-04-26 16:49:43
@_author: David Shaw 
@_subject: Updating signature cert-level 
Not really worse or better in practice.  The semantics are slightly different for the two cases, but the end result is the same.  In the revocation case, you have sig1+revoke1+sig2, so the end result is to use sig2.  In the superseding case, you have sig1+sig2, and the end result is also to use sig2.

@_date: 2011-04-27 08:59:49
@_author: David Shaw 
@_subject: Updating signature cert-level 
Given the people involved in a key signing (the signer, the signee, and a third party who sees the signature later), more than anything else, it's an informational (only) message from the signer to the third party.  Since by default it doesn't really change how the key signature is interpreted (that is, level 2 == level 3 == level 0), most people don't bother to set one.
Incidentally, it is possible to tweak the trust calculations to take signature level into account.  GnuPG supports reading a trust "map" generated by an external process that can use whatever trust rules it likes.  I don't know of anyone using this ability offhand.

@_date: 2011-04-27 13:48:33
@_author: David Shaw 
@_subject: Updating signature cert-level 
Yes, as I said in the part of the email you didn't quote :)

@_date: 2011-04-27 14:03:22
@_author: David Shaw 
@_subject: Passphrase 
It depends.  If you have a strong passphrase, you're pretty much out of luck.  After all, if it was easy to brute force a strong passphrase, it would defeat a lot of the point of the crypto here.
That said, frequently when someone forgets their passphrase, they half remember it.  They know it starts with such-and-such characters, or that it ends with a number, or has a hyphen in there... that sort of recollection.  For those cases, there are tools that might be useful to you, since your half memory of the passphrase reduces the search space that will need to be brute-force.  If you can manage to remember enough of the passphrase, you might be able to use a tool like  to brute force the missing parts.
There is also a commercial product from Elcomsoft that claims very fast distributed brute forcing.  I haven't tried it myself.

@_date: 2011-04-29 15:07:00
@_author: David Shaw 
@_subject: Centralizing Private and Public Keys From Multiple Boxes with 
Nope, that's exactly how it works.  Note that the option is "--local-user" (or "-u"), and not "--user" though.

@_date: 2011-08-02 11:43:30
@_author: David Shaw 
@_subject: decrypt adding ^M characters at the end of each line 
This sort of thing can happen when the sender and receiver machines have different conventions for what ends a line of text.  Unix machines use LF, Windows uses CRLF, etc.  GPG has built-in support for handling this confusion, but you have to tell it that the input file is text.
So, on the *encrypting* side, add "--textmode" to the command, and that will tell GPG to store things appropriately, and the decrypting side will recognize this and use the appropriate line endings in the resulting file.

@_date: 2011-08-02 12:55:35
@_author: David Shaw 
@_subject: decrypt adding ^M characters at the end of each line 
There is just textmode, which is something the sender sets.  On the recipient side, GPG follows the encoding inside the message.  If that message is not textmode (i.e. no transformation) then GPG won't touch the content, so you need to break out the sed.

@_date: 2011-08-11 14:52:37
@_author: David Shaw 
@_subject: Trust model - trust level 1 and 2 
Given the text strings you're quoting, I assume you're referring to ownertrust (i.e. "--edit-key ..... trust").  Ownertrust is how you express your confidence in how well the owner of the key checks other people's keys (or put another way, how much weight do you want to give key signatures made by that key).
There is really no practical difference between the two in the default trust model of GPG - either way, you're not giving key signatures made by that key any weight in your web of trust.

@_date: 2011-08-12 17:11:16
@_author: David Shaw 
@_subject: Implementation question: validating left two of signatures 
I can't speak for other implementations, but GnuPG does not look at the left two at all, and jumps right into checking the whole signature. It *generates* the quick check bytes, of course, as that is mandated by the standard, but it does not look at them itself.
I think that behavior is fine - the real check is the signature itself.
You might also try the ietf-openpgp list:

@_date: 2011-12-01 16:00:31
@_author: David Shaw 
@_subject: Gnupg: display p and q lengths of DSA public keys? 
Yes.  When listing a DSA key or subkey, the lengths given in pkd:0 or pkey[0] are for "p", and the lengths given in pkd:1 or pkey[1] are for "q".

@_date: 2011-12-16 13:28:13
@_author: David Shaw 
@_subject: keyserver spam 
Essentially, yes.  Things are theoretically removable, but it takes carefully-timed manual editing on the part of all the keyserver operators to expunge something (or the bad data will just come back). The system is just not designed for that.
Yes, but only in a few smallish cases.  As far as I recall, nobody has ever done multiple thousands of keys.
I'd be more worried about photo IDs on keys.  Imagine what could be done with someone using the keyserver network to distribute illegal photos.  To be sure, if the point is photo distribution, there are more efficient ways to go about it, but if your goal is to hurt the keyserver network?

@_date: 2011-12-17 10:17:30
@_author: David Shaw 
@_subject: keyserver spam 
There is such a keyserver, made by the PGP company (now run by Symantec, I suppose): It's an interesting server, with different semantics than the traditional keyserver net that we were talking about earlier.  Most significantly, it emails the keyholder (at the address on the key) before accepting the key into the server.  It also signs keys that are submitted to it, which allows people to leverage this email checking in their own trust calculations, but can also "litter" keys with repeated signatures.  If I recall, it is (or perhaps was) the default keyserver for PGP installations.
Of necessity, this server does not synchronize with other keyservers, which is either a good or bad thing, depending on who you ask ;)

@_date: 2011-12-17 10:42:04
@_author: David Shaw 
@_subject: keyserver spam 
Yes.  The PGP folks say as much on the site.  This was extensively discussed when the server was first put in place.  The intent is not to be all things, but rather to be better than just trusting any key based on some text string (i.e. doing nothing).  There are those who disagree that this is better, and of course, nobody is forcing them to use the server.

@_date: 2011-12-28 11:57:40
@_author: David Shaw 
@_subject: Short ID Collision 
The proper title of the article should have been "Easy method for making a OpenPGP short collision re-discovered.  Again."  To his credit, the original blog poster more or less says that.  Unfortunately, as various other sites picked it up, the issue and focus mutated a bit.
Short key ID collisions are nothing new.  They're obvious, and handling them is built into the system.  It's also not hard to make one - just generate keys over and over until you get a collision.  On a fast system, that won't take very long at all.
Now to the "bug", such as it is.  Using the key from the blog post, if I do:
  gpg --recv-keys 70096AD1
I'll get two keys.  The reason for that is that I am requesting something ambiguous.  There are two keys with that short key ID, so the server (correctly) returns both.  It's up to the caller (me) to decide which is the "right" one, using the web of trust, or whatever means I want to verify keys.  The keyserver is just a database, and does not say that a given key is right or wrong.  That's not the problem.
However, if I do:
  gpg --recv-keys EC4B033C70096AD1
I'll also get two keys.  Even though I gave enough information to specify one of the keys in particular, I still got both.  The reason why is due to the history of PGP keyservers.  When the GPG side of the keyserver code was written, the server side (a program called pksd) was not capable of understanding anything *other* than the short key ID.  Because of this, GPG intentionally truncates all key IDs to their short representation when requesting keys from that type of keyserver.  Other keyservers (LDAP) did not have that limitation, and so the longest possible representation is used there.
Since that code was written, time has moved on, and the old pksd server is dead and replaced by the sks server, which is capable of understanding more than the short key ID.  So given that there aren't any pksd servers to support any longer, it has been suggested (see  that we should do like we do for LDAP, which never had this limitation in the first place, and send the longest key ID we can.  It's a reasonable thing to do - if the user gives us 64 bits, use all 64 bits.
So is this a security problem?  No, for many reasons, most of which were mentioned in the responses to the blog post.  Allow me to add one more reason: keyservers aren't capable of saying if a key is the right one or not.  They're just a searchable database that anyone can submit to.  A person who trusts a particular key is correct just because they found it on a keyserver is fooling themselves.  That's what we have a web of trust and/or fingerprint checking for.

@_date: 2011-12-29 12:19:43
@_author: David Shaw 
@_subject: How to sign my own public key? 
It is important, and so GnuPG does it automatically for you.  That page dates from a long while ago back when PGP version 2 didn't automatically do it.

@_date: 2011-12-29 12:21:12
@_author: David Shaw 
@_subject: How to sign my own public key? 
The OpenPGP spec actually doesn't require it, for compatibility with the original spec which also didn't require it.  The implementations do tend to require it (which makes sense, as it is important for many reasons).  These days, if you see a non-self-signed key, something is wrong.

@_date: 2011-02-03 10:02:56
@_author: David Shaw 
@_subject: Add/remove recipient without re-encrypting 
You understand correctly.
This is technically possible, but GnuPG doesn't have it as a feature.  You could use the 'gpgsplit' tool that comes with GnuPG to *remove* recipients by splitting the file into its packets, deleting the packet for the recipient you want to get rid of, and then using cat to put the packets together.  Adding new recipients is more difficult, though you could probably hack it into GnuPG if you really wanted it.

@_date: 2011-02-03 18:30:23
@_author: David Shaw 
@_subject: moving user ID Comments to --expert mode 
I'm afraid I'm not parsing your point here.  Comments are part of the user ID field.  When you make a certification, they are included in the hash.  You can't sign part of a user ID.
Are you saying that you don't sign things with comments?  ("Comments don't get certified").
Or are you arguing the *meaning* of the certification (you may or may not sign the user ID, but if you did sign it, the comment part should be considered null and void in terms of your particular certification)?
Or something else?
I suppose I don't really have particularly strong feelings about whether "comment" is put under --expert or not, but either way this argument is not a good one.  We have made many changes to the keygen prompts over time, and no doubt will continue to do so in the future.  The only scriptable interface for key generation in GPG is --batch --key-gen, and it is documented as such.

@_date: 2011-02-15 17:50:11
@_author: David Shaw 
@_subject: ld.so.1: gpg: fatal: libusb.so.1: open failed: No such file or 
That's an error from your loader.  It can't run gpg, because the gpg binary is built with USB smartcard reader support via libusb, but your system doesn't have libusb available within your LD_LIBRARY_PATH.  This isn't a gpg error - gpg never even got executed here.
The fix is to either figure out where you have libusb and include that in your path, to get libusb, or rebuild gpg to not require libusb.

@_date: 2011-02-16 00:02:43
@_author: David Shaw 
@_subject: ld.so.1: gpg: fatal: libusb.so.1: open failed: No such file or 
In future I will always ensure to use my time machine when replying, since clearly people replying to a message from 4:26 should know the information revealed in a completely different message from one hour later at 5:25.
Really, it's just a shame we don't all have your amazing skills for reading messages that haven't been sent yet.

@_date: 2011-02-16 01:26:05
@_author: David Shaw 
@_subject: on possible ambiguity in Key IDs [was: Re: Help with OpenPGP 
Here's a fun example: Compare his last name to his key ID :)
Way back when, there was actually a tool ("Abattoir") that you could give a chosen (short) key ID to and it would just generate keys over and over until it hit it.  Given the improvements in CPU speed since then, this should be even easier now.

@_date: 2011-02-16 01:31:10
@_author: David Shaw 
@_subject: on possible ambiguity in Key IDs [was: Re: Help with OpenPGP 
One of the engineers working on PGP had generated a key and the keyserver had rejected it as non-unique.  Unfortunately, the engineer chucked the key and made a new one...
 at imc.org/2011-01/msg00027.html

@_date: 2011-02-19 11:18:03
@_author: David Shaw 
@_subject: Some SHA-2 news 
I doubt it.  The idea behind this is interesting, but OpenPGP already has digests of that size, and in the amount of time it will take to get these new hashes into code and deployed widely enough to be useful, we'll be right around SHA-3 time anyway.

@_date: 2011-02-25 13:00:45
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
This is a crucial point.  I'm much more concerned that a mail client can display a PGP/MIME-signed message at all than I am about having support for message verification.  Message verification is very useful, but if the mail client can't display the message at all, then it is not compliant with MIME, much less PGP/MIME.

@_date: 2011-02-26 09:44:22
@_author: David Shaw 
@_subject: Default hash 
No.  It works like this (not literally in this order, but conceptually):
1. User wishes to encrypt mail to you, so your cipher preferences in your public key are pulled.
2. The cipher preferences for all other recipients to that mail are also pulled (very frequently, the sender is also encrypting to his or herself, so that is another recipient).
3. If not already present, 3DES is added to the end of all lists.
4. All the cipher preferences are grouped together into a set.  The sender then compares the list of ciphers that exist in their version of OpenPGP with the list of ciphers in this set.  Any cipher that is not in both groups is discarded.  This is because we don't know if all recipients can handle it.
5. Now we rank the ciphers that haven't been thrown out yet by using the scores given to them by the users.  The first cipher in the list gets 1 point, the second cipher in the list gets 2, etc.
6. Pick the lowest numbered cipher.
This gives us three things:
A) A guarantee that no cipher will be used that cannot be handled by all recipients.  This is crucial, as if we used a cipher that wasn't available for everyone, we'd cut off communication.
B) A guarantee that all users can communicate.  Since every user can handle 3DES, by defintion, it is not possible that the above algorithm will finish without picking a cipher.
C) We will pick the cipher that recipients like the most, overall.
A) & B) are vital, and required by the OpenPGP standard.  C) is optional, but nice to have.
So the bottom line here is to set your preferences to the list of ciphers that you are willing to use, in the order in which you like them.  You will only get messages encrypted to one of these ciphers, and, at least if your correspondents are using GnuPG, will tend to favor the ciphers that you rank higher.

@_date: 2011-02-26 12:06:51
@_author: David Shaw 
@_subject: Default hash 
Not nine months - 4.5 days on average.  At least that was the performance of the DES cracker in 1998.  If it were done today, it would probably do better (or at least do it cheaper).
3DES doesn't use 3 of the same 56-bit key.  3DES (at least the 3DES used in OpenPGP) uses three different 56-bit keys.
3DES is still quite secure.  It's main problem is that it's *slow*.

@_date: 2011-02-27 17:17:03
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
Can I see the HCI study that MIME attachments confuse people? ;)

@_date: 2011-02-27 18:03:29
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
I disagree with this.  Obviously a bad signature doesn't say much (except perhaps "check your mail system - it's breaking things"), but there is still value in the continuity between multiple signed messages.  It's important to not make of that more than it is: for all I know there are 200 people all sharing key 1CF3A917, but it does raise the bar for someone who wants to claim to be Martin.
(and insert key ID collision attack here!)

@_date: 2011-02-27 22:02:08
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
I'm not at all surprised that you had those results.  A limited subset of people have support for OpenPGP signatures.  A limited subset of those people actually verify signatures.  A limited subset of those people actually pay attention to what those signatures say.
Still, that experiment doesn't exactly measure what I'm suggesting.  In your experiment, you all kept quiet and waited for other people to notice.  It is reasonable that if someone was being masqueraded, that person would speak up and challenge the forger (e.g. "Hey, you're not Martin!  I'm the real Martin, and I can prove it by signing this message with the same key I've used all along....").  If the real Martin waited for someone else to notice, well, he may end up waiting for a long time.

@_date: 2011-02-27 22:15:20
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
I wouldn't hope that.  Or perhaps, I might hope that, but certainly not expect it.  Do you check the signatures on each message you get on PGP-Basics of GnuPG-Users?  I certainly don't.  The fact that a message is signed on a public list is of little interest to me.  Barring a situation like the Martin/Fake Martin we're talking about (i.e. if someone felt they were being spoofed and called the group's attention to it), I probably wouldn't bother to look at the signatures at all.
I think we're missing each other here.  We have Martin (the real one), the fake Martin (let's call him "Marty"), and various other people on a mailing list.  Martin always signs his messages.  One day Marty shows up and tries to pretend to be Martin.  Martin, not wanting someone else to pretend to be him, can easily say: "You're not Martin.  I am Martin, and I can prove it: I have signed this message with the same key that I've used for all my other messages".

@_date: 2011-02-27 22:40:03
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
I'm not talking about proving who is *named* Martin and who isn't.  That's not very important (or doable on a mailing list anyway).  What is significant is that the "Martin" that has been posting on the list and signing their messages has a continuity he can point to.
If I were Martin, I'd respond: I am the Martin that has been using this mailing list for the past few months.  I've had many interesting conversations here, and signed them all.  I am signing this message too.  I am the same Martin that you all have been conversing with.  This man claims to be Martin too.  Whether he is or not, *he's not the guy you've been talking to for months*.  Or put another way, he's the Martin that they know.
There is nothing dramatically new about this idea.  It's how nym users have identified themselves for years.

@_date: 2011-02-27 23:13:05
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
I suspect that given a client that properly implements MIME (meaning in this case that it would show the regular text, whether or not they were capable of verifying the signature), inline would be more confusing, for reason of numbers.  For users of those mail clients, they see a signed message as much the same thing they'd have seen if the mail hadn't been signed at all.  For example, Apple's various mail programs do this (I suspect some common code there).
For those clients, inline (where you see something) is bound to be more confusing than MIME (where you see nothing) for the simple reason that something is more visible than nothing.  Like you, I have no study to point to, but it seems reasonable.
Of course, your phone notwithstanding, how large the set of clients that properly implement MIME is an open question...
Personally, when I need to make a signature, I usually just consider the audience.  For a list like this, I'd probably PGP/MIME it.  For other audiences, perhaps not.

@_date: 2011-02-27 23:17:09
@_author: David Shaw 
@_subject: Question regarding shared keys 
It depends on what you mean by a "shared key".  There is just giving a copy of the key to multiple people (in which case any one of them can use it), or there are various key splitting algorithms where a key is broken into a number of pieces, and a specified subset of those pieces can come together, reconstruct the key, and do whatever they need to do.
Which do you mean?
The OpenPGP standard (which specifies how different implementations can interoperate) does not really specify shared keys, beyond acknowledging that they exist.  The PGP *implementation* of the standard, has a shared key feature in the break-the-key-into-multiple-pieces sense.  The GnuPG implementation does not have this feature.

@_date: 2011-02-27 23:29:23
@_author: David Shaw 
@_subject: Android PGP/MIME test results 
Not exactly Android, but FWIW, an iPod touch (which has the same mail program as an iPhone) displays PGP/MIME just fine (as in shows the mail - but doesn't verify the signature).

@_date: 2011-02-27 23:56:57
@_author: David Shaw 
@_subject: Rebuilding the private key from signatures 
It's worth mentioning that a variant of this is what caused the Elgamal signing key problem back in 2003 (and indirectly, what caused Elgamal signatures to be dropped from the OpenPGP standard altogether).  See  for the details.
In that attack, all you usually needed was the public key alone, since most Elgamal signing keys were primary keys, and primary keys issue signatures over the user ID, giving you the signature needed to mount the attack.

@_date: 2011-02-28 09:02:07
@_author: David Shaw 
@_subject: Question regarding shared keys 
No. Encryption is always possible by anyone.  The shared key only needs to be rejoined for decryption or to change the details of the shared key (adding or removing people who have a share, or changing the minimum number of people needed to restore the key), or other secret-key only operations.
Interesting!  They have no backups of the key, no key sharing set up, and didn't use the ADK (Additional Decryption Key) feature of PGP?

@_date: 2011-02-28 09:09:35
@_author: David Shaw 
@_subject: Security of the gpg private keyring? 
You can do quite a lot with stuff like this.  Who signed who can tell you who this person has met, and often where.  If you see a bunch of signatures around a particular date, look for a keysigning party on that date - now you have evidence they were there.  Email addresses can reveal an enormous amount of information about a person.  Robert and I did an experiment a few months ago where starting only from his public key, I was easily able to find out real-world addresses, parents names, siblings, etc.
However, all of this information is available in the *public* key as well.  There is no need for an attacker to get this from your secret key when he can just get it from a handy keyserver.
Assuming you have a good passphrase on your secret key, the attacker can't get into it any more than he could get into a message you send.

@_date: 2011-02-28 09:12:33
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
Unfortunately, barring the case where you have an actual trust path to either Martin, key signatures don't tell you much.  After all, FM could easily make up dozens of fake people keys and use them to sign his key.
In this particular case, though, key signatures aren't even necessary - RM just needs to prove that he is the same entity that signed the other messages to the list.  That is, he's "real" in the sense that he is the Martin that the list knows and has been conversing with.
"What's in a name? That which we call a rose
By any other name would smell as sweet."

@_date: 2011-02-28 12:10:57
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
Well, I suppose that's up to you whether you want to trust RM or not.  A question on trustworthiness is outside crypto, and not what the discussion was about here in any event.

@_date: 2011-02-28 17:33:28
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
That experiment, while interesting, is not relevant to the "real Martin" / "fake Martin" situation we've been talking about.  If both Real Martin and Fake Martin have the same secret key, then there is no way to tell them apart using signatures.

@_date: 2011-02-28 17:49:34
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
You know what?  I'm finished with this silliness.  You're (again) playing debate club games, and I'm just bored of it.
See ya.

@_date: 2011-01-02 00:05:06
@_author: David Shaw 
@_subject: Is self-signing necessary? Basic questions. 
They are calculated by hashing the public key(s), and truncating to fit.  The key ID is actually the lower 64 bits of the fingerprint.  The *displayed* key ID is the lower 32 bits of that.
Traditionally, yes, but this is not a requirement.  The only guarantee is that the primary key must be able to certify other keys (i.e. sign other keys or make new subkeys).  In practice, a common setup (in fact, the default setup in GnuPG) is to have a primary key to sign and a subkey to encrypt.
In common usage, yes.  Subkeys do in fact have fingerprints, but by convention, the fingerprint of the primary key is used as shorthand to refer to the whole key.
No, when you sign a key, you are signing their primary key, plus a specified user ID.  In effect, you are making a statement that "I believe that this particular user ID and this particular primary key belong together".
If there are multiple user ID, you can sign them all (if you believe all of them are valid), or some.  It's your choice.
There is a way to sign a key alone, without signing any user IDs.  Nobody supports it for 3rd party signatures like these.
By default, yes.  You can override this, but it is not a good idea.  After all, if the owner of the key hasn't asserted that a particular user ID is valid, why would you trust it?
Yes.  The "delsig" command in the --edit-key menu can delete signatures.  Note that if the signatures are on a keyserver, they'll just come back the next time the key is refreshed though.
delsig is capable of removing self-signatures.  I'm not sure what you mean by "changing" a subkey, but delkey in the --edit-key menu can delete it, revkey can revoke it, etc.  Similarly, there is deluid and revuid for user IDs.

@_date: 2011-01-02 10:01:35
@_author: David Shaw 
@_subject: Is self-signing necessary? Basic questions. 
You can't.  Like I said, nobody supports it.  Non-owner use of the direct key signature is one of those odd corners in OpenPGP that is needed in the spec to cover all possible cases, but is not needed in reality since nobody uses it.  It would break the current model of the WoT, which is another knock against it.
The only significant use of the direct-key signature is for key owners to add designated revokers to their key.  Designated revokers are carried in a subpacket on a direct key signature.
Only that which is contained inside the signature subpackets of the signature itself.  For example, if someone wanted to attach a notation to the key.

@_date: 2011-01-02 10:08:51
@_author: David Shaw 
@_subject: Encryting both file contents and file name with GnuPG 
GPG can use whatever filename you like.  For example:
  gpg --output szstt.asd --encrypt ....... etc.
Note that GPG does save the original ("mySecrets.txt" in your example) filename inside the encrypted bundle.  It does not, however, use it when decrypting later.  See the --use-embedded-filename option if you want to use that, but read the caveats in the man page about that option.

@_date: 2011-01-02 10:28:36
@_author: David Shaw 
@_subject: Encryting both file contents and file name with GnuPG 
GPG does not do this.  GPG gives you the necessary hooks to do it yourself (i.e. the --output) option, but does not do it for you.

@_date: 2011-01-02 16:07:57
@_author: David Shaw 
@_subject: Is self-signing necessary? Basic questions. 
No, a revocation certificate is its own sort of signature.  Unlike a direct key signature where various pieces of meaning are carried as subpackets, a revocation signature carries the revocation meaning inherently.  (Signature class 0x1F vs class 0x20).

@_date: 2011-01-06 18:23:53
@_author: David Shaw 
@_subject: --digest-algo ignored on gnupg-1.4.9? 
--digest-algo specifies the digest for making signatures.  It is not related to symmetric-only ("-c") encryption, where the digest is used as part of the S2K to mangle your passphrase into a symmetric key.  You want the --s2k-digest-algo option.  As the documentation says:
      --s2k-digest-algo name
              Use name as the digest algorithm used to mangle the passphrases.
              The default algorithm is SHA-1.
Incidentally, RIPEMD/160 is not being used:
hash 2 is SHA-1, which is the proper default for --s2k-digest-algo.  RIPEMD/160 is hash 3.

@_date: 2011-01-11 12:51:34
@_author: David Shaw 
@_subject: How to create non-standard key pair 
You'll have to patch the code.  GnuPG won't do this by itself.
What are you trying to accomplish?  Those keys are insanely large.

@_date: 2011-01-12 00:52:59
@_author: David Shaw 
@_subject: What is the benefit of signing an encrypted email 
No.  It was generally felt that this was more of an attack on the user of crypto, rather than on the crypto itself.
See this thread from when the paper was first published:  at wasabisystems.com/msg00259.html
And especially:  at wasabisystems.com/msg00261.html

@_date: 2011-01-12 11:27:29
@_author: David Shaw 
@_subject: What is the benefit of signing an encrypted email 
With (c), you can then have some assurance that their untrustworthiness has been faithfully maintained in the message since it was signed... ;)

@_date: 2011-01-12 14:37:18
@_author: David Shaw 
@_subject: What is the benefit of signing an encrypted email 
Or keyholder (of which there might be multiples of), but basically yes.
The examples aren't really great, since "worth" isn't really easy to quantify here, and is somewhat subjective as well.  The a) case is the only one where a message with no signature and one with an incorrect signature are effectively the same thing: an unsigned message.

@_date: 2011-01-12 23:29:12
@_author: David Shaw 
@_subject: Prosecution based on memory forensics 
We've taken some measures, but they are not infallible (it's hard for them to be infallible since hibernation can happen at a layer below us - and we don't necessarily get any notification in userspace that we're about to be suspended).  In short, don't count on GnuPG alone to save you here.
The manual mentions this:
       Note also that some systems (especially laptops) have  the  ability  to
       ``suspend  to  disk''  (also known as ``safe sleep'' or ``hibernate'').
       This writes all memory to disk before going into a low  power  or  even
       powered off mode.  Unless measures are taken in the operating system to
       protect the saved memory, passphrases or other sensitive  material  may
       be recoverable from it later.
So GnuPG can't do this alone, but there are ways to configure GnuPG alongside other packages and/or the OS to be safe(r) here.  For example, if you can arrange to run some commands as you are hibernating, you could get gpg-agent to dump its passphrase, etc.
This is similar in many ways to the old "key material ending up in swap" problem, though that was considerably easier to deal with since userspace had the necessary tools so GnuPG could handle the whole problem by itself.

@_date: 2011-01-15 12:27:58
@_author: David Shaw 
@_subject: What does the "sub" entry of a key mean? 
Yes, the number is the bit length of the key.  The letters are:
RSA       == R
DSA       == D
Elgamal == g (only seen in subkeys)
Historically there was a "G" for an Elgamal key that could both encrypt and sign, but that was dropped from OpenPGP.  The current lowercase "g" Elgamal is an encrypt-only key.
Sub is for subkeys.  They are other keys that go along with the main, or primary, key.  A common usage pattern is for the primary to be used for signing, and the subkey used to encryption.
There is a minimum of 1.  There is no maximum.  There are also "uat" lines, of which there are zero or more.  A uat is used to store other things aside from text (for example, photo IDs).
It is possible to have several.
I note that you are trying to parse the output, though.  That is a bad idea, as the format is intended for human consumption, and not machine parsing.  The machine format is stable, and the human format is subject to change.  Use the --with-colons option to enable machine parsing.

@_date: 2011-01-19 11:46:07
@_author: David Shaw 
@_subject: Missing 'END PGP MESSAGE' not detected 
Not really (or at least, not within GnuPG).  The thing is, it doesn't really matter in practice.  OpenPGP has its own corruption detection called a MDC, that applies even if part of the armor (the "END PGP MESSAGE") is missing.  A truncated message won't decrypt.
MDC is turned on by default, but it is worth checking to confirm there isn't something switching it off.  To do this, take one of your truncated files and run:
 gpg --list-packets the-truncated-file.asc
Look for a line that reads "mdc_method: 2".  If you see that, you are protected from truncation no matter what your transport system does.

@_date: 2011-01-19 12:46:10
@_author: David Shaw 
@_subject: Missing 'END PGP MESSAGE' not detected 
You can either use --status-fd and look for:
  [GNUPG:] GOODMDC
  [GNUPG:] BADMDC
Or just check the return code from the gpg binary.  If it fails (for whatever reason), the return code won't be zero.

@_date: 2011-01-19 13:32:00
@_author: David Shaw 
@_subject: Missing 'END PGP MESSAGE' not detected 
If I remember correctly, GPG only complains for invalid CRC.  A missing CRC is legal, as the CRC is a MAY.

@_date: 2011-01-25 08:12:29
@_author: David Shaw 
@_subject: MacGPG2 v2.0.17 released! 
Yes, it is.  In fact, 3k is the maximum size for a RSA key on the OpenPGP smartcard.

@_date: 2011-01-26 11:45:50
@_author: David Shaw 
@_subject: Future plans for implementation of other algorithms 
The smaller size of ECC is also useful for embedded systems, which tend to be both memory and CPU constrained.

@_date: 2011-07-02 20:38:33
@_author: David Shaw 
@_subject: Change key prefs; few questions 
That is correct.  Changing the various preferences does not change the fingerprint.  The fingerprint remains constant no matter what you do to the key (changed/new preferences, new subkeys, new user IDs, etc).
You can ask them to update, if you like.  It's up to you if the change you made to the preferred list is important enough.  Some people refresh their keys periodically anyway.

@_date: 2011-07-03 10:24:15
@_author: David Shaw 
@_subject: Change key prefs; few questions 
It is CAST5 by default, but you can change it.  To change the cipher, you need to set the passphrase since that's when the encryption for the secret key is set.  You can take the opportunity to change the passphrase, or just use the same one as before.
This will set your private key cipher to AES:
   gpg --s2k-cipher-name aes --edit-key (thekey) passwd save
It's configurable in the same way that changing the encryption is: you need to do it while changing the password.  Add "--s2k-count XXX" to the above command line and you can set how many iterations are done.  It can range from 1024 to 65011712, and the default is 65536.  Note that not all possible values are legal, and if you pick an illegal value, GnuPG will round it up to the next higher legal value.

@_date: 2011-07-03 11:45:33
@_author: David Shaw 
@_subject: Change key prefs; few questions 
There are some obscure edge cases where you must have a 3DES or AES encrypted private key, but for the overwhelming majority of people, no, there is no reason to do this.  The default (CAST5) is quite strong (which the original poster acknowledged).  It's just helpful to know what the "knobs" are to understand how something as complex as OpenPGP is put together.

@_date: 2011-07-03 23:01:39
@_author: David Shaw 
@_subject: Change key prefs; few questions 
GnuPG generally has its defaults updated every now and then.  While some of the new possible defaults (DSA/Elgamal keys becoming RSA/RSA, new default key sizes) do require the generation of a new key to use, others (default preferences, secret key protection, and secret key iteration count) are available to any key.  Since secret key cipher and iteration count are tied to the encryption of the secret key (via the passphrase), if you just change your passphrase with that new version of GnuPG, you'll automatically pick up a new cipher and iteration count.
PGP has a clever trick to set an appropriate s2k-count without knowing anything about the various processors it will be run on: it simply figures out how many iterations it can do in 1/10 of a second (which always results in a value higher than 65536 these days), and uses that.  I believe that the newer GPG (2.x) has some support for this design, but I don't recall offhand if it is using it fully yet.  We should probably raise the (static) GPG 1.x count as well at some point.  It's been 65536 for a long time (over a decade).
It's not unreasonable to raise your s2k-count for your secret key.  If you pick a value that is too high and you find it annoying, you can always set it back down to something lower.  It doesn't cause any real harm if you go too high - just wastes some of your time (which is sort of the point!)  That's for secret keys, of course.  More complex is sending passphrase-encrypted messages (which also have a s2k-count), where you don't know the CPU capabilities of the recipient.  There was a case a year or two back where receiving an OpenPGP message with a too-high s2k-count would cause a device to hit its deadman timer since it spent so much time iterating passphrases.  Someone had created the message on a fast machine (and so didn't notice the delay), and sent it to someone on a slow machine which was clobbered by it.
Of course, if you want extra security against brute forcing, even better than bumping up your s2k-count would be to just add a character or three to your passphrase.

@_date: 2011-07-08 12:31:10
@_author: David Shaw 
@_subject: Check that s2k-count has changed 
Yes.  Note that the list-packets output shows the internal packed value: 6553600 should come out to 201.  The default of 65536 would encode to 96.
You might file an enhancement bug to print the decoded value in --list-packets.  We already print it for symmetric encryption, and it's reasonable to print it for secret keys as well.

@_date: 2011-07-08 15:08:02
@_author: David Shaw 
@_subject: Check that s2k-count has changed 
Brace yourself.  This is not pretty:
 S2K_DECODE_COUNT(_val) ((16ul + ((_val) & 15)) << (((_val) >> 4) + 6))
OpenPGP historically has a bit of a phobia about using two or four bytes when it could be squeezed into one.  Or even better, part of one.  That's why the range of valid s2k-count values is 1024 through 65011712, but not all values are actually possible.
It's using SHA512 for passphrase mangling.  The SHA1 protection it is referencing is a checksum on the while secret key packet itself.  You can see the details in section 5.5.3 of RFC-4880, but basically it was added in response to the Klima-Rosa attack (which involved modifying the secret key in a way that the simple checksum used previously could not detect).

@_date: 2011-07-11 16:59:19
@_author: David Shaw 
@_subject: Calculating ciphertext sizes 
The single largest thing that affects your output is the compression used, and how well your input compresses.  For example, if you are encrypting straight text, you will get much better compression than if you are encrypting a movie file (which is generally already compressed, so can't be compressed much more, if at all).  On top of that there is a bunch of general OpenPGP overhead (encrypted session key, etc).
The cipher does make a difference here, but it's small and dwarfed by other factors.

@_date: 2011-07-13 09:48:50
@_author: David Shaw 
@_subject: Why sign as well as encrypt files stored on untrusted drives? 
Yes.  This was an concern in early PGP that was addressed in OpenPGP.  Given the sort of encryption used (CFB), it was possible to chop/mangle the end of an encrypted blob and still have it decrypt properly.  A contrived example would be "Hey, give $1,000,000 to Fred.  Just kidding!".  Fred could then arrange to mangle the end.  (It's not that simple, as there are other issues involved, and Fred has to get access to the file anyway, etc, etc, but you get the idea).
Signing does eliminate this possible problem, yes, which is possibly why you saw that advice out there (though you have to remember to check the signature).  However, OpenPGP has a built-in protection for this sort of thing: the MDC.  This is a hash of the message contents, included in the encrypted message, that protects against message tampering like this.  When decrypting, you would see something like "WARNING: encrypted message has been manipulated!" if the MDC turned out bad.  The MDC has been on by default for many years now, so it is likely you have it enabled for your key, unless it is very old.  To check, run:
  gpg --edit-key (yourkey) showpref
Look in the "Features" line for "MDC".
So short answer is that you most likely don't need to sign your files just to avoid tampering - there was a reason for signing at one point, but it's no longer there.
Back to your original issue though, note that if Fred can get access to your (untrusted) drive, he can just replace the whole file with whatever he likes (since he just needs your public key to encrypt a new file), with no fussy message tampering needed.  That may or may not be an issue in your situation.  Signing does help there since Fred presumably doesn't have access to your secret key.

@_date: 2011-07-14 00:14:12
@_author: David Shaw 
@_subject: keysigning parties 
Are you looking to find a party to get your key signed?  If so, check out   That has both individual people as well as events (parties).
Are you looking for information about what happens at the parties (i.e. the keysigning protocols)?  If so, check out the "methods" links under   That site has some event info as well.
There are other sites, but those are good starting points.

@_date: 2011-07-27 22:38:01
@_author: David Shaw 
@_subject: Including public key 
It depends on what you're trying to accomplish.  In my experience, it's generally felt to be somewhat impolite (just as any 32+ line .sig file would be), especially when a simple link to the keyserver is so easy to include.

@_date: 2011-07-28 18:04:21
@_author: David Shaw 
@_subject: Creating a quickly expiring signature 
When GPG asks you for the value, enter "seconds=X".  You can go down to as low as a single second.

@_date: 2011-06-13 14:45:34
@_author: David Shaw 
@_subject: Generate digest and signature seperately 
It effectively ignores it.  No OpenPGP program currently accepts certifications from subkeys.  The standard doesn't say yes or no on the subject, but there is no code that does it today.
Trust models aren't really dealt with in any real depth in the standard - there were discussions at one point of making a different trust model RFC for that.

@_date: 2011-06-13 22:58:47
@_author: David Shaw 
@_subject: Generate digest and signature seperately 
No, it's the other way.  A PGP signature does embed information about all sorts of things, including whether it is the signature of a file or signature over a certificate.

@_date: 2011-06-14 15:19:56
@_author: David Shaw 
@_subject: Aspects of trust 
Sort of.
For signatures on keys (certifications), when building the web of trust, you get to specify a trust value (called "ownertrust") that is fed into the web of trust calculations.  This is not "do I trust this keyholder", but rather "do I trust this keyholder to make good signatures".  This influences which keys are marked as valid in the web of trust ("valid" meaning "we're pretty sure this key belongs to the person who it claims to belong to").
For example, a signature from someone who you trust to make good signatures can cause the key they sign to be valid, but you might want two signatures from two people who you only trust a little bit to make good signatures to make a key valid.
For signatures on data, this doesn't directly apply.  A signature from a valid key on data is valid.
So the web of trust seeks to give you a), and you have the ability to customize the web of trust based on your opinion of how well the keyholders make signatures on other keys.

@_date: 2011-06-15 15:09:51
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
A minor point about notations.  The " notations are not non-standardized.  They are just not standardized by the IETF via the RFC process.  The " notations are owned by whatever domain appears on the right hand size of the string.  So mynotation at example.com is defined and controlled by whoever runs example.com.  It is completely appropriate for you to define a notation under any domain (including your own) that gives you permission to do so.  These notations are not in any way less good than an IETF notation.
For example, the PGP people saw the need for a notation to hint whether a person can understand PGP/MIME or only inline.  They drew up a spec for the preferred-email-encoding at pgp.com notation, and published it.  It's their standard.

@_date: 2011-06-15 15:10:45
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
It is not currently possible.  The code to do it is trivial, but nobody has really pushed for it before.
That said I'd probably suggest notations for this, even though 0x40 exists in the standard.  0x40 signatures are a bit of a leftover tail in the standard, and are not well specified (0x40 sigclass - is it a binary signature?  a text signature?).  Using notations also gives you more flexibility since you can do key=value stuff and specify different variations on timestamp signatures.

@_date: 2011-06-15 17:14:54
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
It matters for text input.  That's why there are actually two different forms of data signature: 0x00 for data, and 0x01 for text where line endings are canonicalized.  This is so a signed text message created on one platform is verifiable on a different platform with different line endings.
There is only one 0x40, so it's either data or text, but cannot be both.

@_date: 2011-06-15 17:19:33
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
I'm not sure I agree with that.  Essentially, this notation is a way for a user to say "This is what I mean by this signature".  Meaning and intent is difficult for GnuPG to divine :)
In practice, the critical flag tells GnuPG to reject the signature (mark it as invalid) if it doesn't know about the notation.  Why does GnuPG need to know about this notation?  Or more specifically, what should GnuPG do differently for a timestamp-only signature compared to a regular signature?
I'm not against the user deciding to mark the notation as critical if he chooses to do so.  I just wouldn't have it automatically and always critical.  Unless I'm misunderstanding your point, I don't see that the semantics of a timestamp notation require that.

@_date: 2011-06-15 17:54:17
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
I think that's fine and reasonable.  My only difference is that I would not mandate it being marked as critical, and let the signer decide whether they want that or not.  Note that marking it as critical means that all current code will reject it.  Updating that code won't happen quickly.
My question still remains though: what should GnuPG do differently for a timestamp-only signature compared to a regular signature?  Print "good timestamp from David Shaw" instead of "good signature from David Shaw"?
Out of curiosity, as long as we're talking about things that current code will reject, does the 0x50 signature meet the semantics desired here?  This all sounds vaguely notary-like ("I saw this document on such-and-such date") to me, and the intent of 0x50 is a notary signature.  The nice thing about a 0x50 signature is that it is a signature on a signature, so the timestamp service doesn't need to see the document - just the (detached) signature.
(To be sure, you could implement this this with the current timestamp services by hashing the original document and/or signature and getting the hash timestamped)

@_date: 2011-06-15 18:40:06
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
The 0x50 signature should not be interpreted as the output of a real-world notary (whose task varies in different locations anyway).  It is merely analogous to a notary in that the "notary" sees a signature, and affixes a seal to it indicating "I saw this" (oversimplification, but forgive me).
OpenPGP calls this signature a "Third-Party Confirmation signature".  It is merely a signature on a signature for whatever purpose is desired by the signer.
Because as already noted, the 0x40 signature is not fully specified in the standard.  There is not enough information to know how to generate one.

@_date: 2011-06-15 22:44:20
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
RFC-4880 says that.  And speaking as the person who suggested it, I can tell you my intent ;)
The draft spec actually called it a "notary signature", but after discussion, the name was intentionally changed to "Third-Party Confirmation signature" explicitly to avoid any confusion with a real-world notary or what they do.  The word notary is just an analogy.
No more than any other signature in the standard, no.

@_date: 2011-06-15 23:54:30
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
Forget the word notary.  Just erase it from your head.  If you don't like the analogy, then don't use it.  It's just a third-party confirmation signature.  It means only that a third party wants to make a signature on a signature.  It's just like 0x00, except where the data is a signature packet.
The reason you might want a signature on a signature is because the 0x50 gives you something really useful in the context of time stamping: it means the stamper entity/process/person doesn't need to see the original data.  I can sign the data myself, then send the signature alone to the stamper.  The stamper then signs my signature, using the notation we've already discussed to indicate they are making a timestamp alone.
As you phrase the question, the stamper needs to see the original data ("why am I not signing the data").  That's not always desirable.
As I noted before, you can more or less create this by sending hashes around and timestamp-notation signing them, but 0x50 is cleaner and easier to machine parse.
It doesn't matter in any event.  0x50 isn't implemented in any deployed code any more than 0x40 is.  I'd use a notation.

@_date: 2011-06-16 00:54:44
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
I'm not sure how much more this dead horse needs to be beaten.  Fact: the standard used to call this a "notary signature".  Fact: the people behind the standard removed all but one mentions of the word "notary" for fear of confusing people, and the one remaining mention explicitly calls it an analogy.  Evidently, it's still confusing.  I'm not sure how many different ways I need to try and get past the horrible word "notary", but it seems to be at least one more than I'm willing to.  The original proposal for 0x50 as well as every discussion on the meaning and interpretation is online, including the thread where the title "notary" was removed, and the explicit intent of the 0x50 is restated.  I'm done with this.  If you feel it's unclear, there is a ready solution to that.
You use a regular old 0x00 signature.  0x50 gives you capabilities that 0x00 doesn't.  That doesn't mean 0x50 takes over all purposes of an 0x00.  0x00+notation or 0x50+notation covers either set of semantics.
I don't see any particular need beyond a straightforward "timestamp-only" at most.  Clock drift and clock resolution seems like massive overkill and overcomplexity to me, but if someone else wants it, that's the nice thing about notations - anyone can define them to whatever semantics they like.
Pick critical or not depending on the semantics you want: critical means more or less "the receiving system needs to understand this notation to properly understand/handle the signature".  It causes (intentional) incompatibility with all deployed code.  If those are the desired semantics, then you have no choice, but it's a bit of a hamper (months to years) to adoption.

@_date: 2011-06-16 09:31:36
@_author: David Shaw 
@_subject: Understanding the "--refresh-keys" output 
The repeated line is a warning that the key itself has a timestamp that is *after* one of the signatures on it.  This indicates that either the key or the signature in question has a wonky timestamp.
Line 8 means you are using the PGP trust model, and you have configured it so that it takes 3 marginal signatures or one complete signature to treat a key as valid.  See the manual options --trust-model, --marginals-needed, and --completes-needed.  Briefly, these are the terms that GPG will follow when building the web of trust, to decide what keys are valid and what are not.
Line 9 is just a key count.  You have 17 valid keys.  All of them ("u") are ultimately trusted, which suggests that you have 17 keys that you have generated as ultimate trust is generally used for people's own keys.  (If you can't trust yourself, who can you trust?)

@_date: 2011-06-16 09:53:59
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
I can make a key signature 0x10 with 0x00 as well (heck, I can make a 0x01 signature using 0x00 as well).  It doesn't make it a smart thing to do since GPG can't automatically canonicalize the data.
The point of 0x50 is that *GPG understands it's a sig-on-a-sig* and can treat it differently, using signature canonicalization (otherwise, why would we have created 0x50 in the first place?)  Thus 0x50+notation means we can make timestamp signatures over other signatures.  That's a good thing.  It means the proposed notation can be used in multiple places.
You still don't understand.  You are proposing a new feature for OpenPGP, so it needs to consider the various interactions this new "timestamp-only" flag has with different signature types.  These are the sorts of comments and questions that need to be looked at when adding a new feature to the standard.  This is not adversarial!   The goal is to have the best possible design that considers how this new thing fits in to the OpenPGP standard as a whole and that there aren't any gotchas or "Ugh, I wish we would have done xxxx" later.

@_date: 2011-06-16 09:58:47
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
I got into this discussion because there was talk of new subpackets or sigclasses and a misunderstanding of how notations worked.  I don't have a particular desire or need for a timestamp signature, but I do have a particular desire for OpenPGP and GPG to grow cleanly.
I see two parts to this: one, the definition of a new notation to indicate timestamp-only and what that means and how it is used, and two, the incorporation of new code in GPG to use the new notation.
On the first part, my feeling is that if someone needs a notation and wants it to be as widely useful and well designed as possible, they should treat it a a new subpacket would be treated on ietf-openpgp: propose, discuss, revise, etc, and consider it in the context of the whole standard.  Very frequently, a subpacket could be more generally useful than a single original purpose, and it's worth looking at things from that perspective.  For example, one of the proposed notations is a timestamp accuracy notation - could that be also useful for regular non-timestamp signatures?  New subpackets or notations can also be dangerous or at least confusing: what does a timestamp-only key signature mean?  Unless it's marked critical, the web of trust code in both GPG and PGP will treat those signatures as fully qualified ones and not just timestamp-only, yet if it is marked critical, it's not very useful without code changes.  All of that is solvable, of course, but it should be addressed.
In this particular case, people seem to want a notation under the gnupg.org domain, arguing that it will be more likely to be adopted as the gnupg.org domain lends some cachet.  I don't agree with that, but don't care enough to argue it.
In terms of the second part, GPG itself, I don't yet see a need for any code change, which will have to be written and then maintained in the code (semi-)indefinitely.  Perhaps I'm cynical, but I don't really see a lot of people clamoring for this or blocked for the lack of it, especially given that if people desire to tag their signatures as timestamp-only, they can do that now via --notation-data, and look for its presence via show-notations, which is the default anyway.

@_date: 2011-06-16 10:10:19
@_author: David Shaw 
@_subject: Problem with "hkp server wwwkeys.eu.pgp.net" 
wwwkeys.eu.pgp.net is intended to be a round-robin of all EU keyservers.  In practice, it's only one server at the moment, which does seem to be down.  I think your best bet is to mention this on sks-devel where most of the keyserver operators hang out.  See

@_date: 2011-06-16 13:32:51
@_author: David Shaw 
@_subject: Problem with faked-system-time option 
Daniel raised the question of using sigclass 0x40 (not subpacket).
The misunderstanding about notations was that the non-IETF namespace was some sort of temporary place where things could be tried out until IETF standardization came.  You said, and I quote:
That's not how notations work.
You know, I actually started responding to the rest of this note, and your actively hostile and accusatory other email, but there is really little point.  You seem to want what you want, and see any discussion as an attack.  Many responses to you on both the subthread of why someone would want this, and also this subthread of how to do it have been met with hostility and condescension.  I'm out.  I have better things to spend time on.

@_date: 2011-06-16 13:44:00
@_author: David Shaw 
@_subject: Understanding the "--refresh-keys" output 
Just 17?  My current GPG test VM used for development:
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:  154  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 154u
Seriously, though, Daniel is right.  If those 17 keys aren't just endless test keys like mine, you might be doing something you didn't intend to.

@_date: 2011-06-16 13:51:02
@_author: David Shaw 
@_subject: Question regarding the migration of the pgp keyring to gpg 
Probably your best bet for IDEA support is to build it right into the binary.  To do this, take the idea.c file and put it in the "cipher" directory of the GnuPG distribution (you said earlier you were using 1.4.11).  Then do the usual ./configure and make as you normally do.   The build scripts have code to recognize this case and will incorporate IDEA directly into the resulting gpg binary.

@_date: 2011-06-16 19:58:49
@_author: David Shaw 
@_subject: Understanding the "--refresh-keys" output 
Run "gpg --check-trustdb".  By default --refresh-keys calls --check-trustdb for you automatically, but you can call it yourself if you like.

@_date: 2011-06-23 16:24:10
@_author: David Shaw 
@_subject: DH Key 
It's one of those historical oddities.  Back in the 1990s, Cylink offered the PGP company a free patent license if PGP called Elgamal Diffie-Hellman instead.  Cylink was pushing that name for marketing reasons.  The name stuck in PGP for the simple reason that it would confuse people if they suddenly saw their keys change type after upgrading to a newer version of PGP.  Note that this is only true in the PGP Desktop - PGP command line calls it Elgamal.
That which we call a rose by any other name would smell as sweet...

@_date: 2011-02-28 18:38:31
@_author: David Shaw 
@_subject: Security of the gpg private keyring? 
I think the problem here is the large size of the deployed infrastructure that expects user IDs to have email addresses in them combined with the relatively few people who are asking for this feature.  To make this change, you'd have to have a keyserver that could search in that manner, plus client support to make the hashes when talking to the keyserver, etc.  You'd have to handle the very-small-but-non-zero chance of a hash collision in the user ID, too.
It's a pretty big bite, and while it is an interesting idea, I suspect that there aren't enough people who want it for it to happen.

@_date: 2011-02-28 19:40:55
@_author: David Shaw 
@_subject: Security of the gpg private keyring? 
This flag actually exists in OpenPGP already (and what's more, GnuPG even sets it by default).  The catch is that none of the other infrastructure (keyservers, mainly) checks it, and given the current design of the keyservers and how they sync key data between them, they can't easily check it.  It would be a very large (I'd say even larger than the hashed user ID example above) task to make this flag truly useful.

@_date: 2011-03-01 09:34:18
@_author: David Shaw 
@_subject: Why do we use a different key to sign than to encrypt 
There is no one reason, but a few reasons that, taken together, makes this useful.
One reason is that it enables the use of sign-only or encryption-only algorithms, which if one key had to do it all, would not be usable.   Another reason is that it helps prevent a complete compromise - if only a subkey is compromised, the whole key is not compromised.  It allows for the best-algorithm-for-the-job decision to be made (for example, many people like signing with DSA because the signatures are physically smaller and thus not so obvious in email). It allows easier key changes without changing the main "identity" key by expiring or revoking just a subkey and making a new one.  And so on.  Some of these reasons overlap as well.
OpenPGP supports both the single-key and multiple-key models, so you're not forced to do it one way or the other.  The default in GnuPG is multiple key.

@_date: 2011-03-01 09:35:48
@_author: David Shaw 
@_subject: need help on non-interactive gnuPG binary 
The regular 1.4.10 binary supports non-interactive key generation.  See the file 'doc/DETAILS' in the GnuPG distribution, and specifically the section "Unattended key generation".

@_date: 2011-03-01 18:46:39
@_author: David Shaw 
@_subject: Security of the gpg private keyring? 
For that matter, you could just emit the warning for any key that you don't also have the secret part for.  That is, keys that have a higher chance of not being yours.
I would worry about the warning being invisible after a while though.

@_date: 2011-03-02 23:17:06
@_author: David Shaw 
@_subject: PGP/MIME considered harmful for mobile 
The premise (more or less) was that a guy named Martin (RM) was on a mailing list and signed all his mail.  After some time, a new guy (FM) shows up and claims that he is, in fact, Martin.  FM may have his own key or may not have a key at all.  It doesn't matter, because the members of the mailing list can see, by means of RM's signatures, a continuity of communication.  They can tell RM apart from FM, simply because only RM can issue the signatures they've been seeing on his messages.
Now, there are limits to this technique.  They can't tell who is really "Martin" (i.e. they can't bind the name to a real-world person) without some other information, but in the context of Internet communication that frequently doesn't matter.  They can tell which one is the guy they've been talking with for all this time.  Which one is *their* Martin, if you like.
Despite all the noise in the thread, it's nothing terribly odd.  It's just the way nym keys work.

@_date: 2011-03-09 09:27:04
@_author: David Shaw 
@_subject: signed messages take an eternity to be formatted by evolution 
Strange.  Keyservers should not need to time out if they do not have a key.  They should be able to return a no-answer response immediately.  It looks like something is not healthy on wwwkeys.eu.pgp.net (and it only has one server in the pool), so pool.sks-keyservers.net will probably improve things.
Incidentally, the keyserver timeout is configurable.  If you want to stop waiting earlier, you can change this by sticking "keyserver-options timeout=XXXX" (XXXX is in seconds) in your config file.

@_date: 2011-03-11 08:33:25
@_author: David Shaw 
@_subject: non-exportable OpenPGP certifications [was: Re: hashed user IDs ] 
As a general rule, most gpg options can be shortened, so long as they are still unique.  So the real name for the option is "export-local-sigs", but "export-local" or even "export-l" is fine (and "export" would not be as gpg can't tell if you mean export-local-sigs, or export-attributes, or...)
If you're documenting or scripting things, it's good practice to give the full name since you never know if we're going to add a "export-lovely-sigs" option or some such, and thus make "export-l" non unique.

@_date: 2011-03-11 13:35:19
@_author: David Shaw 
@_subject: Compression used in an encrypted message 
You can't tell which compression is used in any arbitrary message since you need to be able to decrypt it first.  If the message is to you, however, you can run 'gpg --list-packets' on it.
When running list-packets, you should see a line like this:
   :compressed packet: algo=2
Algo 1 == ZIP
Algo 2 == ZLIB
Algo 3 == BZIP2
If there is no "compressed packet" line at all, then the message is uncompressed.

@_date: 2011-03-11 14:25:52
@_author: David Shaw 
@_subject: Compression used in an encrypted message 
Not directly, no.  OpenPGP just encapsulates the compressed stream, so you'd have to extract the compressed data and examine it.  I'm not sure if a single-number answer is available even then.  Basically, if you can get the level from a regular compressed .gz or .bz2 file, then you can get it here, but either way, GPG does not have visibility into that.

@_date: 2011-03-11 15:14:38
@_author: David Shaw 
@_subject: hashed user IDs [was: Re: Security of the gpg private keyring?] 
That's the on-disk SKS database format, and so contains a good bit of non-key data and other inefficiencies.  A dump of just key data is around 3.5G nowadays.

@_date: 2011-03-14 00:35:55
@_author: David Shaw 
@_subject: RSA Versus DSA and EL GAMAL 
This is a very frequently asked question on this list.  You might hit Google and see some of the previous discussions.  Basically though, the argument between RSA and Elgamal is like comparing a 9999-foot wall vs a 10000-foot wall (and I'm not saying which is the 9999 and which is the 10000).  Does the difference really matter, as long as you can't climb over either one?
The short answer: use RSA.  It's the default for various little fiddly operational reasons, none of which are relevant to the question of "which is more secure".

@_date: 2011-03-15 10:34:47
@_author: David Shaw 
@_subject: GPG and PGP 
While I'm no great fan of 2.x v3 keys, I agree with this, and would like to see IDEA included once the various patents expire.  PGP 2.x was used for a long time, and there is a lot of encrypted material out there, at least some of which is still needed.  I wouldn't put it in the default preferences or anything like that, but just having the cipher present would be a kindness to long-time PGP users.
(I know that IDEA is a possible cipher for v4 keys as well, but given that PGP made it a non-default to use IDEA in v4, and given that GPG never supported IDEA without a special plugin, a v4 key using IDEA is rare).

@_date: 2011-03-15 17:28:23
@_author: David Shaw 
@_subject: GPG and PGP 
I'm not quite sure what you mean.  The MDC can be used on any OpenPGP cipher, no matter what the size.

@_date: 2011-03-15 19:42:48
@_author: David Shaw 
@_subject: GPG and PGP 
That is not quite right.  Whether the MDC is used or not is a key preference similar to the cipher preferences, to ensure that all recipients can handle the message.  Using --force-mdc overrides that, and similar to overriding the cipher preferences, runs the risk of sending a message that a particular recipient can't read.
The 256-bit cipher thing is a bit of a neat trick - when putting together RFC-4880, it was observed that all implementations that had 256-bit ciphers also had the MDC, so using a 256-bit cipher could be used to infer the ability to do a MDC.  GnuPG does that as well, since using the MDC is a good thing.
GnuPG does the MDC by default whenever all the keys can handle it (or if the chosen cipher is 256 bits)
All keys generated in GnuPG since the MDC preference was added (in 1.0.7, if I recall) have this flag set by default.  Anyone who wants to set the flag on a key that does not have it can use the usual --edit-key / setpref method with the keyword "mdc".

@_date: 2011-03-15 23:41:52
@_author: David Shaw 
@_subject: GPG and PGP 
Strictly speaking, it's anything with a cipher blocksize that isn't 128 bits.  In the case of OpenPGP, that means AES (any of them) or Twofish.  GnuPG will flip on the MDC when it sees any of those ciphers in the preferences, or failing that, it does the blocksize test.

@_date: 2011-03-15 23:50:35
@_author: David Shaw 
@_subject: GPG and PGP 
Err - meant to say "anything with a cipher blocksize that isn't 64 bits".  AES & Twofish are of course 128 bits.

@_date: 2011-03-16 10:18:39
@_author: David Shaw 
@_subject: GPG and PGP 
None.  It's not a key type, but a feature/detail of the implementation, like supporting a particular cipher.  The user IDs have a flag on them to indicate whether an MDC can be used.
Run gpg --edit-key on your key and enter "showpref".  Look at the "Features" line(s).  They should say (among other stuff) "MDC".  That's the flag.
Forcing the use of the MDC is similar to forcing the use of a cipher: it might work (probably will, these days), but if someone is using an implementation that doesn't understand the MDC, they won't be able to decrypt your message, any more than they would be if you forced the use of a cipher their implementation doesn't understand.

@_date: 2011-03-19 22:36:29
@_author: David Shaw 
@_subject: what are the sub keys 
OpenPGP keys are made up of a single primary key, and any number of subkeys (including, in some cases zero).  This allows the user to pick particular key types for particular purposes.  For example, a common usage is to use the primary key for signing things and the subkey for encrypting things.
As to your other question, it was asked earlier this week.  See

@_date: 2011-03-21 16:05:35
@_author: David Shaw 
@_subject: Revoke signature from key 
While the common usage for regular users is to sign based on checking identity, signatures can be just as well used as a token to indicate membership.   For example, the PGP product has the concept of a "Corporate Signing Key", which is used to sign employee keys to indicate they are genuine (and their keyserver can actually enforce this).  They are not signing to say that Alice is Alice, they are signing to say that Alice is Alice, and works for Company X (i.e. they would not sign Alice's personal key).
If I was going to do this with a group, like above, I'd probably make a special Group Signing Key to issue the membership signatures to avoid confusing my personal signatures with the group membership ones, though.

@_date: 2011-03-21 18:04:24
@_author: David Shaw 
@_subject: Revoke signature from key 
I think this is more flexible of an answer, but it requires client support that doesn't currently exist.  Without the client support, users will have to check such signatures by hand and their web of trust cannot be automatically built by the client.
Having a corporate signing key addresses the issue on current clients in two steps: import and then (l)sign the CSK.  The PGP product actually does this sort of thing automatically (new users can be configured to automatically import and lsign the CSK whenever they generate a key, so this "just works" for them).

@_date: 2011-03-21 18:33:00
@_author: David Shaw 
@_subject: Revoke signature from key 
I think in this situation, you wouldn't want the classic trust model with Alice setting marginal ownertrust on D.   Rather (and I believe this is the more common use of a CSK), you'd use the CSK as a fully trusted introducer (via trust signatures, and the domain restriction).
So a single trust signature from the Example Corp CSK would cause any key matching xxxx at example.com to become fully valid, but Bob or whoever is the administrator of the key (CSKs are commonly shared keys, requiring a few people to agree on their use) could only forge userIDs within There is no real web of trust inside example.com using a CSK in this way - the CSK dictates (in a very top-down way), which example.com keys are valid and which, by omission, are not.  This makes sense in the corporate world, as it's not up to Alice to decide which corporate keys are valid.  It *is* up to Alice to decide which non-example.com keys are valid, of course.

@_date: 2011-03-21 23:39:27
@_author: David Shaw 
@_subject: Deniability 
In addition to the size and type information, there is also an interesting attack that can be done against speculative key IDs.  It doesn't (directly) help a third party know who the recipients are, but it does let any recipient try to confirm a guess as to who another recipient might be.
Let's say you encrypt a message to Alice and Baker and hide the key IDs.  Alice gets the message and knows there is one other recipient aside from herself.  She considers who the message came from and what the message was about and makes an educated guess that the other recipient is Baker.  To confirm her guess, all Alice needs to do send a specially rigged speculative key ID message to Baker.  If Baker responds, then Alice knows he was the other recipient.
Throw-keyids has some good usages (posting a message for pickup in a public place, for example), but it's just a tool.  It's important not to rely solely on it.

@_date: 2011-03-22 11:28:25
@_author: David Shaw 
@_subject: Deniability 
Sorry, yes, that's re-using the session key (didn't mean to be mysterious).  Since Alice, as a recipient, can find the session key, she can encrypt a new message to Baker with that session key, prefix it with the unknown recipient's encrypted session key, and send the whole message to Baker.  If Baker can read it, then it reveals who the unknown recipient is.
Of course, if Baker can't read it, it might tip him off that Alice is probing him...
Unfortunately there is random data in the encrypted session key format, so the test encryption would not match Baker's encrypted session key.

@_date: 2011-03-22 15:05:02
@_author: David Shaw 
@_subject: Deniability 
Hmm.  I'm not sure you and I are on the same page with this attack.  I don't think that Alice's rigged message to Baker necessarily needs to be forged to come from the original sender.  Alice can send the message to Baker as herself, with no special signing or other trickery to fool Baker about the origin of the message.  She can even sign it (as herself) if she wants.  The contents of the message just need to be something Baker would naturally reply to.

@_date: 2011-03-22 15:37:08
@_author: David Shaw 
@_subject: Deniability 
Probably the easiest way is to not send messages with speculative key IDs encrypted to more than one recipient. :)
That ensures that Alice knows as little as possible about the other recipients (including whether there are any in the first place).  It does put an additional burden on the sender, though, as they now need to send out more messages (which might be hard for some senders).

@_date: 2011-03-23 16:50:39
@_author: David Shaw 
@_subject: Deniability 
Yes.  My concern with this is that the ability (if not the desire) to "ask the right one" is growing so rapidly, and the cost of asking is dropping.
For example, I do genealogy as a hobby, and figuring out how person A was related to person B 100 years ago would involve trips to the town in question, and poring over a hand-kept records book in the town hall.  These days, there are a number of websites that have brought that sort of information online.  The information from old town record book is essentially unchanged, but the ability to access it is dramatically easier.  Such easy access enables all sorts of cross-referencing and data mining across multiple databases that were (strictly speaking) possible a hundred years ago, but also extremely unrealistic.

@_date: 2011-03-24 15:29:00
@_author: David Shaw 
@_subject: export a public subkey isolated 
I'm afraid this is not possible.  An isolated subkey is not a valid OpenPGP "key".
You might be able to do byte-surgery on the keyblock to turn your subkey into a primary key (and then get it to sign a user ID since your current user ID wouldn't be signed by the right key).  That would probably cause as many headaches as it solves.
Why not talk to the RIPE people and ask them to support subkeys?  They're a standard part of OpenPGP and have been for a long time.

@_date: 2011-03-31 15:39:34
@_author: David Shaw 
@_subject: Public keys on smartcard 
The card stores the parameters from the RSA algorithm (i.e. a series of numbers).  Some of these numbers are considered public (and can be retrieved from the card), but this is not the same as what people generally call a "public key" in the OpenPGP/GnuPG sense.  The OpenPGP public key contains those numbers in a particular format, plus the user ID(s), plus a signature for each user ID, etc.
Basically, the answer to your question is strictly speaking yes, but for practical purposes no.
That just stores the fetched key in your pubring.  The card is not modified.

@_date: 2011-03-31 15:55:07
@_author: David Shaw 
@_subject: Public keys on smartcard 
I've sometimes thought it would be nice to be able to keep the pubring with the smartcard, and since it can't be on the card, it could be on the reader.  There is at least one reader out there (SCM MAXX lite) that combines a SIM-sized reader with 2GB of flash storage in a single USB stick.  I haven't tried it, but it would seem to be a reasonable solution to have everything together in one place.  2GB could store a lot more than just your public keyring, too.

@_date: 2011-05-01 20:12:37
@_author: David Shaw 
@_subject: Syncing Keys between multiple computers? 
The issue about future versions is that you probably won't be able to import a keyring file directly.  At the moment, a keyring file and the exported keyring format happen to be the same, but this is likely to change.  A method that should work equally well today and in the future is:
 gpg --export-secret-keys > my-secret-keyring.gpg
 gpg --export-options export-local-sigs --export > my-public-keyring.gpg
(copy the files over)
 gpg --import my-secret-keyring.gpg
 gpg --import-options import-local-sigs my-public-keyring.gpg
It's an export plus an import, but you don't need to explicitly state which key(s) you want to play with.  Just bring the whole ring over.

@_date: 2011-05-02 11:39:57
@_author: David Shaw 
@_subject: Offline Master Key 
No problems unless your correspondent is using a very old version of PGP that doesn't properly handle subkeys.  I wouldn't worry about that too much in 2011.
It should be seamless.  This is a reasonably common thing to do.  I do it myself, in fact.
There is/was a HOWTO document for this method of handling keys written at one point.  I can't seem to find the link at the moment, but if someone has it handy, please do post it.

@_date: 2011-05-04 20:13:25
@_author: David Shaw 
@_subject: scripting gpg 
You're looking for the "--trust-model always" option.  Add that to your options, and the trust model becomes "if it's on my keyring, it's fully trusted".  It's up to you to make sure that only keys that are fully trusted are on your keyring, of course. :)

@_date: 2011-05-07 21:50:09
@_author: David Shaw 
@_subject: Best practice for periodic key change? 
Nothing more than would stop someone from cutting and pasting (in the old scissors-and-paste sense of the term) a signature from one document to another, then copying the whole thing to make it look right.  It's just easier and looks better with a graphics program than with scissors and glue.
Incidentally, speaking of bitmap signatures - a "signature" made via a rubber stamp of a signature can be binding under certain circumstances as well (at least in the US - I don't know about elsewhere).

@_date: 2011-05-07 22:53:15
@_author: David Shaw 
@_subject: Best practice for periodic key change? 
Yes.  I was referring to the UCC, where they define the term "signature" fairly expansively as a signed name, a trade name, or pretty much any other mark.  The intent to authenticate is the point, not that fact that it's a written name, signed name, or other scribble.
I knew a man (a lawyer, as it happened) who always signed documents with several loops in a row.  When I asked him why he didn't use a "real" signature (i.e. why he didn't sign his name), he just grinned and said "Who's to say this isn't my signature?"   My own signature is sufficiently unreadable that it could safely be described as a "mark".

@_date: 2011-05-07 23:15:28
@_author: David Shaw 
@_subject: Best practice for periodic key change? 
They're certainly still coming up on alt.security.pgp.  Here is the one for last week:

@_date: 2011-05-07 23:32:04
@_author: David Shaw 
@_subject: Best practice for periodic key change? 
I bookmarked this at one point: He gives a few recommendations (cross your own lines frequently, consistency is important, think about using a different signature for legal matters vs correspondence, etc).  How good the advice is I couldn't say, but I found it and some other documents on the site interesting reading.

@_date: 2011-11-28 17:17:30
@_author: David Shaw 
@_subject: [gpgtools-users] [gpgtools-devel] Joint OpenPGP (JS) 
I had to do it for years.  For each release of GPG that I contributed to, I sent an email containing a pointer to the new source code to the Commerce Department.  The rules changed slightly in 2004, so that you could send a single email and then be done until the information in that email changed, so I just sent " and haven't bothered with the email since.
The rules: The 2004 rule change:

@_date: 2011-11-29 15:07:16
@_author: David Shaw 
@_subject: keys.gnupg.net 
Yes, you can.  It's different options per keyserver, not per type.

@_date: 2011-11-30 01:21:23
@_author: David Shaw 
@_subject: PGP decryption and "built-in" integrity checking? 
The encrypted file contains more than just the original data.  There are also various headers and other structure given to the file by OpenPGP.  There is a built in integrity check in OpenPGP called the MDC, which covers the original data.  Any tampering to that "area" of the file will result in an error indicating an MDC failure.  If there is tampering to the OpenPGP structures, it may not cause an MDC error (in your example of a single byte truncation at the end, for example, it won't), but it will most likely cause the file to not parse correctly and thus return a (different) error.
Note that the MDC is on by default, but can be turned off, either via the command line/config file or by a particular key.

@_date: 2011-11-30 11:25:07
@_author: David Shaw 
@_subject: Possible IPv6 bug for --keyserver option 
Hmm.  GnuPG uses libcurl to do the HTTP part of fetching keys, so this might actually be a Curl question.  Curl (at least on Linux) uses getaddrinfo to resolve out the IPv4 vs IPv6 question.  What happens if you do "curl -v  on the command line?
See also

@_date: 2011-11-30 12:31:50
@_author: David Shaw 
@_subject: Possible IPv6 bug for --keyserver option 
Yes, but look at the error message.  It matches what you saw from GnuPG.  It looks like libcurl tries the IPv4, fails, then the IPv6, and fails again.  It only displays an error message for the IPv6 as that was the last thing tried.  The keyserver handler uses libcurl as well, and is doing the same thing.

@_date: 2011-10-03 17:59:59
@_author: David Shaw 
@_subject: Multiple signatures 
Just repeat -u as many times as you need:
  gpg -u the-first-key -u the-second-key -u the-third-key -u etc --sign thefile

@_date: 2011-10-16 10:42:32
@_author: David Shaw 
@_subject: Why do I receive keys I wouldn't expect 
You managed to hit a (presumably natural) keyid collision.  It's rare, but not impossible.  Your primary key has the keyid of D870A352.   The other key happens to have a subkey with the keyid of the same D870A352.  OpenPGP keyids are made by chopping down the full key fingerprint (40 characters) into a long keyid (16 characters) or a short keyid (8 characters).  In this case, the full fingerprints and long keyid does not match - you just happened to collide in the lower 8 characters.
This is why it's important to check the whole fingerprint when signing keys.

@_date: 2012-04-09 13:56:38
@_author: David Shaw 
@_subject: List-packets help 
You don't need to do that.  GnuPG does it for you automatically.  When encrypting to a particular set of user IDs, GPG ensures that the algorithms and features that are chosen are acceptable to all recipients.
In your example, if algo 9 (AES256) isn't available for a particular recipient, GPG will use something else.

@_date: 2012-08-08 16:53:48
@_author: David Shaw 
@_subject: Malformed Revokation Certificate? 
A revocation certificate is a bare certificate, not attached to the key that it revokes.  This is an extension to the spec that GnuPG implements (as it is easier to save/print/archive a bare certificate).  If you want the keyservers to accept them, you need to talk to the keyserver folks.  As this is an extension, they aren't required to support it.
Alternately, if you set any of the PGP compatibility options (--pgpX) in GnuPG, it turns off the extension and outputs a public key along with the revocation certificate, ready for directly sending to keyservers.

@_date: 2012-08-09 15:17:39
@_author: David Shaw 
@_subject: Malformed Revokation Certificate? 
That's a good point.  There is no easy way to undo an accidental revocation once it hits a keyserver.

@_date: 2012-12-02 10:23:08
@_author: David Shaw 
@_subject: [Sks-devel] SRV records and HKPS requests 
Somehow I didn't notice this mail when it originally came through.  Anyway, thanks for the report.  Clearly the port supplied in the SRV should be honored.
Can you try the attached patch (against 2.0)?

@_date: 2012-12-02 23:46:02
@_author: David Shaw 
@_subject: [Sks-devel] SRV records and HKPS requests 
Hmm.  Were you intending to test with the internal HTTP support or with libcurl?  You're currently built with internal support:
Looking at the internal support, it seems not to work on platforms with getaddrinfo(), which is odd as that part works in the 1.4 code.  Anyway, try the attached patch in addition to the original one, and you should hopefully have better results.  I also fixed an issue where the Host: header was not being set correctly after a SRV.  It seems to me that like SNI, the Host header should be the SRV name, and thus should never have a :port attached.
I tried talking to keytest.spodhuis.org to test, but all the ports returned in the SRV were not listening.  Or at least, not listening to me ;)
$ telnet keyserver.spodhuis.org 11373
Trying 94.142.241.93...
telnet: connect to address 94.142.241.93: Connection refused
$ telnet keyserver.spodhuis.org 11374
Trying 94.142.241.93...
telnet: connect to address 94.142.241.93: Connection refused

@_date: 2012-12-05 23:32:44
@_author: David Shaw 
@_subject: [Sks-devel] SRV records and HKPS requests 
It's working, it's just misleading since the SRV replacement happens after the debug logging so the actual URL that is hit is not the one that is being logged.  If you look at netstat, you can see it's connecting to the right port.
Try this new patch (by itself, not on top of an earlier one) - it logs before and after the SRV replacement so it's clear what is going on.

@_date: 2012-02-14 23:32:50
@_author: David Shaw 
@_subject: Interesting real world short ID collision 
As pointed out in Debian bug 659905, on the keyservers, the primary key 171CAA4A (dated 2002) collides (presumably naturally) with a subkey on primary key 1C8BB5A7 (dated 2000).
It seems the owner of one went to a keysigning party, and an attendee was rather surprised to find two keys coming back from the keyserver for that ID...

@_date: 2012-02-21 13:42:41
@_author: David Shaw 
@_subject: Trust signatures with unbounded regular expressions 
If I understand, you were trying to accept "mail1.example.com" and "mail2.example.com".  Try this regexp:
  <[^>]+[
That will match both mail1.example.com and mail2.example.com, and is accepted by the GPG parser.
Two caveats:
1) You'll have to hack the code to create it since you can't type it in.  Once created, though, any unmodified GPG should be able to handle it.
2) It will match some things other than mail1.example.com and mail2.example.com as well (like mailQ.example.com, or foobar.mail1.example.com, etc).

@_date: 2012-02-25 12:12:17
@_author: David Shaw 
@_subject: Encrypted large files cant decrypt 
Since small files work, and 2.79gb doesn't, one thing to check is whether your whole pipeline (including the remote ftp server) can handle large (i.e. greater than 2^31 bytes) files.  That would manifest itself as things starting to break at the 2gb mark.

@_date: 2012-01-22 15:15:08
@_author: David Shaw 
@_subject: Creating a key bearing no user ID 
It won't work.  The OpenPGP standard requires at least one user ID on a key.  It does not require that it has an email address or even your real name, so you can legally have a user ID of "Anonymous" or similar, but you do need something there.  Note that if you are intending to get your key signed by others, most people won't sign a user ID that just reads "Anonymous".

@_date: 2012-01-28 01:21:25
@_author: David Shaw 
@_subject: Why hashed User IDs is not the solution to User ID enumeration 
It does not support it.  With keyserver.pgp.com, it's sort of as if no-modify is always on, but in a limited sense: the keyserver will only allow new user IDs or a new key from the key owner (though enforced via "who can read email at your address", rather than cryptographically), but it allows anyone whose key is on keyserver.pgp.com to sign a key and send the update to the keyserver.  So you can always sign someone else's key if you desire.

@_date: 2012-07-10 11:18:29
@_author: David Shaw 
@_subject: why is SHA1 used? How do I get SHA256 to be used? 
Your key is a 1024-bit DSA key.  That key can only use a 160-bit hash, so you can use either RIPEMD160 or SHA-1.  The rules for hash choice in DSA were relaxed a bit later, to allow for a 160-bit hash *or* a larger hash truncated to fit.  To enable that, you can use "--enable-dsa2", and you should be able to get SHA256 - but note it's SHA256 truncated down to 160 bits.  You can't use more than 160 bits without a larger DSA key.

@_date: 2012-07-11 13:28:12
@_author: David Shaw 
@_subject: cert-digest-algo clarification 
Not exactly.  For signing keys ( there are no preferences, so there is nothing to override.  It's just whatever you set cert-digest-algo to.  Note, though, that this includes signing your own key, so if you make a subkey or add a user ID, the binding signature will also use that digest.  For  you do understand correctly.

@_date: 2012-07-11 13:57:58
@_author: David Shaw 
@_subject: scope of standard authority (was: Re: How to "activate" gpg.conf 
The standard specifies how algorithms are chosen and ensures that communication can always take place (eg. "if all else fails, pick 3DES").  It does not mandate that the message must be sent.
It is obviously legal for a client to say "I settled on 3DES, but you don't permit 3DES, so I give up - I'm not able to continue".  The standard controls how messages are generated, and if the client gives up before generating the message, the standard is not involved.  It is not legal for the client to say "I settled on 3DES, but you don't permit 3DES, so I'm going to use AES instead".
It's important to differentiate between signing and encryption here.  For encryption, 3DES is the fallback algorithm, and the standard is very clear - it's an explicit MUST NOT to use any algorithm that isn't in the preference list.  For signing, it's not as simple - for example, there is no explicit recipient (and therefore no preference list) when signing without encrypting, such as is done on a mailing list.  The standard acknowledges this and leaves it up to the signer to pick an algorithm, with the obvious caveat that the signer can make a message that can't be verified.

@_date: 2012-07-12 08:45:41
@_author: David Shaw 
@_subject: cert-digest-algo clarification 
cert-digest-algo has no preferences (no ranked lists, etc). - it defaults to SHA-1, but you can override it as desired.  Note that you can only override with an algorithm that works for the key you are making the certification with.  For example, you can't use RIPEMD-160 with a DSA-2048 key.

@_date: 2012-07-24 10:10:09
@_author: David Shaw 
@_subject: asymmetry of 'adduid' and 'deluid' 
To add a UID, GnuPG needs to generate a binding signature from the primary key.  To generate a signature, we of course need the passphrase.  To delete a UID, GnuPG just needs to throw away packets.  No signature needed, so no passphrase needed.
Note that to revoke (rather than delete) a UID involves making a signature as well, and will also require a signature.

@_date: 2012-07-29 00:48:25
@_author: David Shaw 
@_subject: Possible bug in gpg? 
I haven't examined this file extensively, but assuming it isn't corrupt, or specifically engineered to be not decryptable in some way, I'm suspecting this is an example of a quick check failure.  In OpenPGP, a message is made up of different packets.  In your case you have a symmetric key encrypted session key packet (essentially instructions on how to mangle the passphrase into a session key), followed by an encrypted data packet, which is encrypted to the session key that results from the first packet.  Normally, when decrypting, the client will read the first packet, prompt the user for a passphrase, and mangle the passphrase into a session key.  Then it reads the second packet, and uses the session key to decrypt the data.
However, people being people, they can easily typo the passphrase, and given the method above, if the passphrase is wrong, the session key will be wrong, and the data decrypted will be gibberish.  To combat this, OpenPGP has two "quick check" bytes in the encrypted data packet.  Basically, they're a repetition of two random bytes from earlier in the message.  The idea is that if the session key is wrong (i.e. the passphrase is wrong), the original random bytes won't match their repetition, and the client can immediately say "Wrong passphrase!" rather than blithely continue and potentially decrypt lots of data that won't turn out to be valid.
The practical upshot of this design is that while it works most of the time (in that virtually all incorrect passwords will be immediately flagged as such), each symmetrically encrypted message has the chance for other, incorrect, passphrases that nevertheless will pass the quick check.  Obviously, these cannot decrypt the message, but they mangle into (invalid) session keys that just so happen to decrypt the data so that the 16-bit quick check matches, allowing the client to proceed, and decrypt (incorrectly) the rest of the data.  Usually this fails fairly quickly afterwards as the data decrypted is not valid OpenPGP structures, so the client will stop with an error message about being unable to read the file.
In this particular case, the !=X passphrase passes the quick check, and the incorrectly decrypted data happens to look like a packet of packet type 0, of length 942141745.  GPG ignores the invalid packet (there is no packet type 0), and so no output is generated.
So, assuming my guess is right, it's not a bug in OpenPGP or GnuPG (though perhaps giving an error when it saw the packet type of 0 would have been better), but a pretty unlikely confluence of events.  How did you come up with the !=X passphrase?  Exhaustive search?  I'd be curious to find out what the real password is, once it is revealed.
Incidentally, these quick check bytes were used as the basis for an ingenious attack against OpenPGP a few years ago.  See

@_date: 2012-07-29 12:11:54
@_author: David Shaw 
@_subject: Possible bug in gpg? 
The attack a few years ago was chosen-ciphertext.  For those who don't recall, if you have a system that will decrypt messages submitted to it, and will return an error if the message doesn't decrypt (i.e. you've made an oracle), you can use this attack to get 2 bytes out of every cipher block in 2^15 attempts on average, per block.  It's not necessary for the attack, but if you know the first 2 bytes of the plaintext that helps start the chain (and in OpenPGP you can virtually always guess the contents of the first 2 bytes).
This is not a weakness of the cipher in question (it applies to all OpenPGP ciphers), but is due to the OpenPGP CFB "stutter" of the quick check.
Read the whole paper at   It's interesting work.
This happened before RFC-4880 was published, so there is some discussion of it in there as well.  It is why GnuPG (and possibly PGP - I don't recall offhand) ignores the quick check bytes when decrypting a public key encrypted message.  We do still use them for symmetric messages for obvious reasons, which is why the original poster saw the oddity he did.  I'm guessing he set up a brute force password cracker for that message and was surprised to see just how many passphrases "succeeded", but didn't manage to decrypt the message.

@_date: 2012-07-30 11:14:11
@_author: David Shaw 
@_subject: Oracle behavior in Gnupg?  // (was 'possible bug in gpg?') 
Yes, this is expected behavior.  It follows from what I explained earlier in this thread.  When you use --override-session-key, you bypass the quick check (after all, you gave the override key - what is there to check?) so you are seeing GnuPG choke on the invalid OpenPGP structures resulting from the garbage decryption.
It's only an oracle if you return this output to the attacker, or in some other way allow the attacker to see differences (timing, for example) in the responses to what he submits to you.
Don't do that ;)

@_date: 2012-06-04 11:26:31
@_author: David Shaw 
@_subject: no password needed to export secret-keys? 
The secret key is encrypted via your passphrase, so it is safe to export.  GPG is just copying some bytes from a file on disk, and you could copy the whole file yourself via 'cp' just as easily.
Still, you can do things with SELinux to prevent any process from reading the secret key file except GPG, and in that case, it might be reasonable to request a passphrase before exporting the key.

@_date: 2012-06-08 15:54:12
@_author: David Shaw 
@_subject: Documentation bug 
The fonts in question are actually called "TEMPEST fonts" in the PGP documentation (or at least they were last time I looked - I haven't seen the docs for the Symantec PGP).   The bug here would seem to be the word "resistant".  TEMPEST should be capitalized, too.
Does anyone happen to have Symantec PGP and know if they even still do this?

@_date: 2012-06-14 14:54:47
@_author: David Shaw 
@_subject: RFE: --update-before-use 
This comes up every now and then.  A recent go-round on the subject is at   See also bug I actually started down this road once (when I was doing auto-key-locate, as it happens - they share a lot of similar backend concepts).  I didn't pursue it for a few reasons:
1) If the keyserver (of whatever type) isn't reachable at that moment, simple GPG operations can take a long time (multiple minutes) to allow for the fetch to fail and fall back to the current copy of the key.
2) Concern that enough people turning this feature on would add significant load to the keyserver network, which is run as a public service.  I was hoping to get some keyserver operators to weigh in on the subject.
3) It leaks information more than auto-key-retrieve or auto-key-locate does.  AKR only fires when verifying signatures, and only fires once (if you have the key, it isn't re-fetched).  AKL only fires when trying to communicate with someone who you do not have a key for, and it also only fires once.  An auto-key-refresh would refresh on every use, which essentially tells the keyserver operator every time you communicate with someone, and who.
 can be handled by configuration - a "how long am I willing to wait for automatic updates" variable that can be set lower than the current keyserver-option "timeout".
 can be handled by asking ;)
 is a problem? obviously documenting the leakage is a start, and having the feature off by default is important.
If someone wants to pick this up again, it would be nice if this could be done on particular keys, rather than globally.  That helps with all three problems, to varying degrees.  It would also be nice if the basic concept could be used to refresh at different intervals (i.e. "refresh on every use" vs "refresh on every use but not more than once a week", etc).

@_date: 2012-06-14 23:10:52
@_author: David Shaw 
@_subject: RFE: --update-before-use 
It's a similar problem in type as auto-key-retrieve or auto-key-locate, but it's a different problem in degree: both AKR and AKL fire only as needed (either when a key is needed for sig verification, or when a key is needed to encrypt to).  That's a single fetch for the life of the key (you might fetch it more via other means, but AKR and AKL (barring special configuration) will never fetch a key you already have).  Fetching the key on each usage means it leaks each time you use the key.  Plus remember that by default, GPG honors keyserver URLs on the key, which if combined with this new feature enables IP-address tracking of a person encrypting to a particular key (it's the same web-bug trick as AKR, but with encryption).
I don't think this should prevent such a feature from being added.  As with many tools, one person's foolish usage is another person's useful feature.  Like I said earlier, though, it does need to be off by default, as AKR and AKL are, and also like AKR and AKL, documented so people can make an informed decision on whether to use it or not.
Werner also showed a way to configure AKL to always fetch a key from a keyserver, which can be done with today's code.

@_date: 2012-06-16 17:32:36
@_author: David Shaw 
@_subject: RFE: --update-before-use 
Yes, I understand that spreading out keyserver requests can help avoid this sort of tracking, but remember that the keyserver URL feature allows the keyholder to bypass the keyserver chosen by the user, and send the requests anywhere they like.  I don't care how the keyserver round-robins are run if I can get a target GPG to not use them.
To really combat tracking, you need to route your keyserver requests through TOR or something similar.

@_date: 2012-06-17 11:47:24
@_author: David Shaw 
@_subject: way to see what cipher/algo was used to create your key? 
--edit-key -> pref shows you the preferences on that specific key (try using "showpref" instead for a more user friendly display).  It does not show what what ciphers are chosen for generating a new key.  You can change the preferences whenever you like via --edit-key -> setpref
OpenPGP doesn't really have the notion of a default cipher (or other preference).  Rather, it has lists, ranked in order of preference, for ciphers, hashes, and compression algorithms.  These do double duty, in that they tell someone encrypting to your key both what algorithms you can handle (i.e. if your implementation couldn't handle CAST5, it wouldn't be on your list at all), and also which algorithms you prefer to use (i.e. if you like AES more than CAST5, you'd list AES before CAST5 in the list).
Here's how it works - when encrypting to a bunch of keys, GPG needs to send a message that is usable by all recipients (as what's the point of sending a message to someone that they can't read?).  To do this, it has to find a set of algorithms (cipher, compression, etc) that every recipient can handle.  The method is simple: read everyone's preference lists, and find the intersection of the preferences.  This intersection is a list of algorithms that every recipient can handle.  Pick an algorithm from this list, and you are safe that no recipient won't be able to read the message.
To deal with the case where there is no intersection (say, Alice put CAST5 and AES in her list, and Baker put TWOFISH and BLOWFISH in his list), the standard requires that all cipher lists have 3DES in them somewhere, all hash lists have SHA-1 in there somewhere, and all compression lists have "uncompressed" in there somewhere.  If the user doesn't explicitly put it in, it is assumed to be there at the end of the list.  This guarantees that there will aways be at least one algorithm in the intersection (and also requires all OpenPGP programs to implement these algorithms).
Methods vary in how to pick an algorithm from the list - all the standard requires is that it comes from the list at all.  GPG actually ranks each algorithm so that more "votes" for that algorithm can increase the chance of it being chosen, but it is equally correct (though perhaps not particularly friendly) for an implementation to always pick 3DES, for example.

@_date: 2012-06-17 16:18:04
@_author: David Shaw 
@_subject: RFE: --update-before-use 
Yes, hence the suggestion to route keyserver requests through TOR.  Then the keyholder knows that someone is requesting his key (and can probably make a fairly good guess matching the request up to a given encrypted message if there are a small number of requests and after each request he gets an encrypted message), but does not know the real IP of the person making the request.
It's the default because without it, the person encrypting to the key may not know that the key has been compromised and should not be used.  If someone does not keep their key on the keyserver network, without a keyserver URL there is no (in band) way for people to know where to get updates from.
Users of course have the ability to turn it off:
  keyserver-options no-honor-keyserver-url
But then of course, the user is responsible for finding updates themselves.
Yes.  I suggested this as well - a "update on each use, but no more often than once a day/week/etc".  It cuts down on the leakage.

@_date: 2012-06-20 13:33:29
@_author: David Shaw 
@_subject: choice of encryption algorithms  
Yes, it does.  The public key contains a list of all algorithms that you can (or are willing to) accept (you can see your own list with --edit-key and the "showpref" command).  By default, the sending GPG consults this list when picking an algorithm to ensure it does not pick one that you can't/won't handle.
However, note that the sender (if they choose to), can override this default and pick whatever they like.  This is not recommended as it can result in a message that you, the recipient, can't read, but senders do have that power.

@_date: 2012-06-20 14:30:20
@_author: David Shaw 
@_subject: choice of encryption algorithms 
Note that just the ranking of preferences is advisory.  The use of algorithms that are on the list, however, is required by the spec:
  An implementation MUST NOT use a symmetric algorithm that is not in the recipient's preference list. and later
   If an implementation can decrypt a message that a keyholder doesn't
   have in their preferences, the implementation SHOULD decrypt the
   message anyway, but MUST warn the keyholder that the protocol has
   been violated.
So if you ever get a warning message like:
  gpg: WARNING: cipher algorithm AES256 not found in recipient preferences
That means the sender violated the spec (perhaps most likely by having an old copy of your key with a pref that you removed at some point, but you never know).

@_date: 2012-06-21 09:15:24
@_author: David Shaw 
@_subject: "SHA1 Protection" from way to see what cipher/algo was used to 
It means that the secret key is has (in addition to the passphrase) an internal SHA-1 hash to detect tampering.  It's basically a large checksum, used to foil attacks that involve modifying the secret key.  It's not related to the hash algorithm you use when signing things.

@_date: 2012-06-21 12:54:06
@_author: David Shaw 
@_subject: choice of encryption algorithms 
You are correct.  default-preference-list is to give the, well, default preference list for new keys or the list that is set when you do "updpref" in --edit-key and don't give an explicit list.

@_date: 2012-06-22 11:23:11
@_author: David Shaw 
@_subject: ideal.dll 
There is more than one attack against V3.  There is the "bit sliding" attack, where you can forge the whole fingerprint, but as a side effect it changes the keysize, and there is the DEADBEEF attack where you can forge the key ID, but not the fingerprint.  I believe Daniel is referring to DEADBEEF here.
Using DEADBEEF, I can make a V3 key with a 64-bit key ID without affecting the keysize.  It's an old attack, but is receiving more interest recently for some reason.
I just sent you a private mail containing a key with your key ID ;)

@_date: 2012-03-05 13:40:09
@_author: David Shaw 
@_subject: invalid gpg key revocation 
A revocation appears as a signature on the key.  Anyone who has (write) access to the key can add such a signature (if it exists).  However, only the holder of the secret key can generate such a signature.  In other words, if you really never made a revocation (many howto documents recommend making one and saving it when you generate your key), and the revocation you found on your key is genuine (if gpg confirms it is revoked), then I recommend you check if someone has access to your secret key.
You can examine the revocation certificate with:
 gpg --export (your key id) | gpg --list-packets
The piece you are interested in will look like this.  It's usually the second packet in an exported key:
:signature packet: algo 1, keyid 7296AD3DA736CEC5
Note the sigclass is "0x20", which is the revocation class.  The keyid would be that of your key (or it's a revocation for someone else, and is not relevant to your key).  "Created" is the epoch timestamp of when the revocation was supposedly generated, echoed in "sig created".  The "revocation reason" is the reason given when generating the revocation:
0 == no reason given
1 == revoked because the key was compromised
2 == revoked because the key was superseded by another key
3 == revoked because the key is no longer used
The string in parenthesis is a human readable note given by the revoker.
Anyway, that's what can be looked at, but - and this is important - virtually all of those fields are settable to whatever the revoker wants to set them to, so you can't trust them.  For example, they could set their clock to whatever date they wanted and make the revocation from that date.  They could give any revocation reason they like, or no reason.  They can put whatever they want to in the string.  What they can't do (modulo serious crypto failure and/or bugs) is generate a revocation without access to the secret key.

@_date: 2012-05-23 16:12:25
@_author: David Shaw 
@_subject: Draft of nine new FAQ questions 
Very nice work.
I have just three minor notes:
 explains why we default to 2048-bit keys, but not why RSA.  What NIST stated about key strength is true for any 2048-bit OpenPGP key (DSA or RSA).  The reason why we switched to RSA in 2009 was mainly for reasons of being able to use a larger primary key.  DSA was inherently capped at 1024 bits (and a 160-bit hash), and while DSA2 existed (so we could theoretically have used a 2048-bit DSA key instead of RSA), it was not nearly as widely implemented across the OpenPGP user base as RSA was.
The answer you have for  is not exactly wrong, but it is not complete.  GnuPG doesn't support 4096-bit keys just because PGP (the product) does.  It also supports a range of key sizes because OpenPGP (the standard) does.  And it also supports a range of key sizes because people want/need them (local policy for key length, for example, as you note in the answer to   GnuPG is a powerful and flexible tool, and that includes the power and flexibility to do things that are not necessarily recommended by the GnuPG developers.
For  it might be worth mentioning something about the use of different hash lengths (q) for the different DSA sizes.  The two sort of go hand in hand.  Or for that matter, perhaps a question  "How come my signatures from my 2048-bit DSA key use a different hash than those from my 1024-bit DSA key?" would be interesting.

@_date: 2012-05-23 17:40:03
@_author: David Shaw 
@_subject: Draft of nine new FAQ questions 
The fact that RSA can have different key sizes is clearly stated, since you need that information to interoperate, and that's what I was referring to.  I don't mean to say that one of the several reasons GnuPG supports 4096-bit keys is because the OpenPGP spec says they are better.  I mean to say that one of the several reasons GnuPG supports 4096-bit keys is because the OpenPGP spec says they *exist* (there is some implementation art here - we don't support 8192-bit keys even though they obviously exist as well).
The way you stated it in the revised FAQ covers this very well.
The standard is indeed mostly silent on the topic on why you would *want* to pick a particular key size over a different key size.  That is appropriate for a message format document - it's not really taking sides.  Pretty much all it says is to be careful and notes that 4096 was the common limit at publication time:
 * OpenPGP does not put limits on the size of public keys.  However,
       larger keys are not necessarily better keys.  Larger keys take
       more computation time to use, and this can quickly become
       impractical.  Different OpenPGP implementations may also use
       different upper bounds for public key sizes, and so care should
       be taken when choosing sizes to maintain interoperability.  As of
       2007 most implementations have an upper bound of 4096 bits.
Excellent.  One note on the new text - it states that 2048-bit DSA keys use a 224-bit hash.  In fact, a 2048-bit DSA key can use either 224 or 256-bit hashes.  GnuPG uses 256 here (but will of course accept a 224 generated elsewhere), so we're either using 160 or 256 unless someone forces 224 by picking an odd DSA key size like 1536.

@_date: 2012-05-29 13:47:30
@_author: David Shaw 
@_subject: changing the default for --keyid-format [was: Re: getting an 
I think that it would bring more confusion than benefit, unfortunately.  There is a significant amount of documentation (and even code) that uses OpenPGP in terms of 32-bit key IDs, and if that if we were to change, we'd cause all sorts of problems.  Defaults should be conservative.
That doesn't mean we can't start encouraging people to use 64-bit IDs, but I don't expect it to be a quick process.
What is your concern here, though - accidental or intentional collision?

@_date: 2012-05-29 13:47:31
@_author: David Shaw 
@_subject: changing the default for --keyid-format 
No doubt.  V5 is a rather nice way to handle the problem: if a new key format came about, it's reasonable that the "handle" used to refer to it is different.  Just like when things went from v3 to v4 and the fingerprint format changed, people understood that these were two different key types and accepted that they would appear different in a UI.
I daresay that designing a V5 key format might even be accomplished sooner than rooting out all the (now-incorrect) FAQs and general knowledge of people using OpenPGP to get them to use 64-bit key IDs instead of 32. ;)

@_date: 2012-05-29 14:18:37
@_author: David Shaw 
@_subject: changing the default for --keyid-format [was: Re: getting an 
The reason I bring it up is that using the v3 key attack, 64-bit key IDs have no particular benefit over 32-bit IDs for intentional collisions (i.e. an attacker generating a key with the same key ID as the victim in order to confuse matters and/or steal traffic).  It's just as easy to forge 64 bits as it is to forge 32?

@_date: 2012-05-29 16:43:07
@_author: David Shaw 
@_subject: changing the default for --keyid-format [was: Re: getting an 
While I don't think the world is ready for a change in default visibility from 32 to 64 bit key IDs, I am in favor of this by default.

@_date: 2012-11-05 09:39:52
@_author: David Shaw 
@_subject: Is the signature encrypted 
It is.  You can manually construct other arrangements if you so desire, but the built in "--sign --encrypt" in GPG is:
   encrypt ( compress ( sign ( data ) ) )

@_date: 2012-11-05 10:01:02
@_author: David Shaw 
@_subject: Is the signature encrypted 
No.  If you're going manual, you're pretty much going manual all the way down (writing your own scripts to verify things, etc).
Virtually always you *want* your signature to be encrypted.  Why would you want something else?

@_date: 2012-11-05 10:59:45
@_author: David Shaw 
@_subject: Is the signature encrypted 
The fact that it is signed at all, and who signed it.  But again, you're not forced into this way.
As far as I recall, PGP/MIME (speaking strictly for the standard and not any particular implementation) can do this just fine.  Forgive me if my memory fails, but you should be able to do this by creating the message complete, with all of the headers you want to protect, and including it whole as an attachment (i.e. message/rfc822) to a signed message.  The outer message headers are the one that the MTAs use to get the message to you.  The inner ones are tamper-proof. You just need to check the inner signature and then compare the inner and outer headers to verify.
Now, I'll be the first to say that I don't know of any clients that actually do this, but barring the aforementioned memory, the spec allows for it just fine.  That said, given what havoc email gateways can wreak on the outer headers, I think you might get a bunch of failures matching the outer and inner headers.

@_date: 2012-11-16 01:00:50
@_author: David Shaw 
@_subject: setting primary UID of other's keys and allowing direct UID 
This violates the spec:
   Implementing software should interpret a self-signature's preference
   subpackets as narrowly as possible.  For example, suppose a key has
   two user names, Alice and Bob.  Suppose that Alice prefers the
   symmetric algorithm CAST5, and Bob prefers IDEA or TripleDES.  If the
   software locates this key via Alice's name, then the preferred
   algorithm is CAST5; if software locates the key via Bob's name, then
   the preferred algorithm is IDEA.  If the key is located by Key ID,
   the algorithm of the primary User ID of the key provides the
   preferred symmetric algorithm.
and later:
   The symmetric algorithm preference is an ordered list of algorithms
   that the keyholder accepts.  Since it is found on a self-signature,
   it is possible that a keyholder may have multiple, different
   preferences.  For example, Alice may have TripleDES only specified
   for "alice at work.com" but CAST5, Blowfish, and TripleDES specified for
   "alice at home.org".  Note that it is also possible for preferences to
   be in a subkey's binding signature.
It would violate Alice's desires to use alice at home's preferences when emailing alice at work.  She specified what algorithms she wants for each location (say, for example, that her work has policies about which algorithms are permissible for work mail).  Changing which user ID is primary does something similar - it changes what algorithm will be used without her permission.
This is legal, but possibly overkill.   If the intent is to say "encrypt to user at example.com, but I want the one attached to key 0x12345678" then I'd do it as something like "gpg -r 0x12345678:user at example.com".  There is no need to use a hash of the user ID here, as it doesn't disambiguate any more or any less than the actual string does (given the same user ID string, you'll have the same hash each time).
That said, it does seem like overkill.  How much of a problem is this in practice?

@_date: 2012-11-29 18:26:45
@_author: David Shaw 
@_subject: Paperkey with ECC support 
Hi folks,
I've updated paperkey to work with elliptic curve OpenPGP keys.  I would really appreciate it if anyone out there could give this devel version a try (either with ECC or regular keys, or ideally both).
Source: Source + Win32 binary:

@_date: 2012-10-09 12:16:27
@_author: David Shaw 
@_subject: RNG: is it possible to spoil /dev/random by seeding it from 
The message is from three years ago, so I'm honestly not sure where I was going with that thought at the time.  Most likely, I was thinking about someone using an evil device for entropy directly rather than through a /dev/random that deals with the evil source case.
To be clear: I do not know of some way an evil input can somehow subvert the output of /dev/random on Linux.  My understanding was that it was designed to prevent that.

@_date: 2013-04-17 23:54:00
@_author: David Shaw 
@_subject: Privacy concerns 
I think this could go either way, depending on the communities and identities (and people) involved.  For me, if I made a work key, I'd probably cross sign (or at least sign my work key using my personal key) as it would give a better path to the work key in the web of trust.  At the same time, though, if I made a key for a particular community where I wasn't directly known as "David Shaw", I'd probably not cross sign for the reason you imply - I wouldn't want the two identities linked.

@_date: 2013-04-26 13:28:29
@_author: David Shaw 
@_subject: Confusion with signature digest type. 
The answer to your question from your original mail is that you're using the "check if SHA-1 is in my preferences" test to instead of the "check if my selfsig is SHA-1" test.  The proper test for checking your selfsig from the document you were referencing is:
  gpg --export-options export-minimal --export  | gpg --list-packets |grep -A 2 signature|grep 'digest algo 2,'

@_date: 2013-08-01 22:11:53
@_author: David Shaw 
@_subject: How to detect fingerprint and type of the key from 
I think "method" in the example above is just indicating that this is a PGP key.  That is, there may be other types than PGP that RIPE supports, but you'd have to ask them about that.
No.  The fingerprint is based on the key material only.  You can add/change UIDs without the fingerprint changing.

@_date: 2013-08-02 08:53:40
@_author: David Shaw 
@_subject: How to detect fingerprint and type of the key from 
Not directly.  There isn't some special tag that says "this is a PGP key" that lets you tell it apart from (say) some new image format that just happens to have a similar packet structure.  If you think about it, that's not possible since some other file format might accidentally trip the detector since there is no global registry of tags.
Many people use heuristics, based on the format in the spec.  (For example, the 'file' program does this).  Or the ultimate heuristic: if it looks like a PGP key, can you parse it and import it?
SHA-1.  The exact bytes that get fed into the hash are given in RFC-4880, but basically it's the public key material with a few bytes of structure around it.

@_date: 2013-08-02 22:48:12
@_author: David Shaw 
@_subject: Is it possible to sign a key again after revoking a signature? 
Yes.  So long as the date on the most recent signature is after the date of the revocation, the signature will take effect.
Leaving aside a bunch of more complex cases like non-revocable signatures, and signatures with expired expiration dates for now, in the simple case, the algorithm used for deciding if a signature is valid is to find the latest signature from a given key.  If that signature is a revocation, then it's considered revoked.  If the latest signature isn't a revocation, that signature takes effect.
An easy way to see what GnuPG considers a valid signature is to run "clean" on the key from the --edit-key menu.  GnuPG will strip off everything that it isn't using for trust calculations (so, revoked signatures are removed, runs of multiple signatures are collapsed down to the most recent, and so on).

@_date: 2013-08-06 08:38:56
@_author: David Shaw 
@_subject: Identifying your private key by the public KeyID 
The public and private keys, by design, have the same fingerprints and key IDs.  I'm not quite sure what you're referring to here.  Is it possible you're looking at the primary key and subkey?  Subkeys do have their own fingerprint and key ID, but that doesn't have anything to do with whether it is public or private - the subkey on a public key is public, and the subkey on a private key is private.

@_date: 2013-08-06 10:44:03
@_author: David Shaw 
@_subject: Identifying your private key by the public KeyID 
Ah, that clarifies it.  Yes, as a few people have suggested, that's the subkey ID.  It's not inherently public or secret, but just another key attached to your primary key.  In OpenPGP, "your key" refers to a primary key, plus some number of subkeys (occasionally zero, but that's fairly rare).  The primary key is the one that the user IDs (email addresses, etc) are attached to, and the one that gathers signatures from other people if you get your key signed.
The subkey(s) are keys attached to the primary key, that can be used for encryption or signing.  The idea is that since it is difficult to change your primary key (you'd need to get it re-signed, and re-print your business cards, and the like) you should be able to change the subkey quickly and easily.  A common methodology (and in fact the default for many programs) is to use the primary key for signing, and a subkey for encryption.  There are interesting variations that can be used with this basic design: some people leave their primary key offline completely, only taking it out to make new subkeys.  Some people use different passphrases on different subkeys.
To answer your original question, though, traditionally the key-as-a-whole is referred to by its primary key ID and fingerprint.  The subkeys are effectively along for the ride. Some programs make a point of telling you which subkey is in use at a particular time.  Some do not.

@_date: 2013-08-09 00:09:29
@_author: David Shaw 
@_subject: Question about notations and domains 
There are two namespaces here.  If a tag is defined by the IETF process, then there is no  at all.  The  tags are used when regular users want to define a tag.
Anyway, so it's true that you can use the  notation to differentiate between a tag you use and the same tag used by someone else, but this shouldn't be interpreted as that you should always use the local domain.  The domain is set by whoever defines the tag.
For example:
In this case, the preferred-email-encoding tag was defined by the pgp.com people.  Thus preferred-email-encoding at pgp.com is the proper string to use.

@_date: 2013-08-09 11:10:22
@_author: David Shaw 
@_subject: Question about notations and domains 
Sort of.  Basically, if you want the semantics of the tag as defined by a particular person, you use their tag.  If you want different semantics, you can use your own tag (possibly using the same tag name, but @ your own domain).  In the case of the issuer-fpr tag specifically, I'd use dkg's tag.  It's straightforward and well defined.

@_date: 2013-08-12 18:25:06
@_author: David Shaw 
@_subject: understanding GnuPG "--clearsign" option 
The timestamp and the signer's key ID are both present in the binary blob.  The signer's user ID is not, as GPG is using the signer's key ID to look up the signer's key and shows the user ID from there.
It's not always SHA-1, and there are other things included in the hash, but at a very high level, this is basically accurate.  The exact construction of a signature and how the input is calculated is given in RFC-4880, the OpenPGP specification.

@_date: 2013-08-19 08:49:30
@_author: David Shaw 
@_subject: Issue with --sign option 
I think this is a corrupt secret keyring.  Regardless of the issue of "-sign" vs "--sign", an abort like that shouldn't happen.  I don't know what version of GnuPG this is, but the only BUG() call in the lookup function is one that fires if the packet it sees in the secret keyring is not a secret key.

@_date: 2013-08-22 10:55:36
@_author: David Shaw 
@_subject: Serpent? 
I think it was implemented in GnuPG first, but it's not a GnuPG extension.

@_date: 2013-08-22 11:35:50
@_author: David Shaw 
@_subject: Serpent? 
If anyone wants the xml2rfc source for RFC-5581, just let me know.  You can make almost any "add this cipher algorithm to OpenPGP" draft with very little more than cut and paste on top of that.  Of course, that's just gives you a draft document.  There are quite a few more steps in producing a RFC.

@_date: 2013-08-29 16:28:15
@_author: David Shaw 
@_subject: GNUPG and Cast6 
There never was a really good reason to support it.  The OpenPGP working group added TWOFISH as a 256-bit cipher (and not incidentally a 128-bit blocksize), and later AES.  There is nothing specifically wrong with CAST6, but given that OpenPGP has both TWOFISH and AES, there isn't really a pressing reason to include CAST6 too.

@_date: 2013-12-17 11:57:34
@_author: David Shaw 
@_subject: encryption algorithm 
The short answer is that not every OpenPGP program supports all algorithms.  The only algorithm that MUST be present is Triple-DES.  Some algorithms are recommended, and some are totally optional, but 3DES is a hard requirement.  It's possible that they simply don't have AES-256.
It's not quite accurate that you can choose an algorithm for your machine and whoever you communicate with can choose another.  Rather, algorithms in OpenPGP are ranked.  Each user (i.e. each key) has their own list, in order, of algorithms.  Triple-DES, the required algorithm, is always on this list (if you leave it off, GnuPG acts as if it's at the bottom of the list).  This list serves several purposes at the same time - first, it means that an algorithm that a particular user can't use (say their OpenPGP program doesn't support it) is guaranteed never to be used.  If it's not on the list somewhere, it won't be used.  Secondly, it allows users to indicate which algorithms they prefer.  If you prefer AES-256, above AES-128, then you list them in that order.  (In practice, GnuPG usually supports all of the algorithms, so the ordering functionality is more useful than the "don't use an algorithm I don't have" functionality.)
Different programs take this ordering into account in varying ways.  For GnuPG specifically, it tries to make as many people as happy as possible.  For example, if a message is being encrypted to three people, two of whom have AES-256 as their first choice, and one who has something else, the likely result will be that AES-256 is chosen.
So you pick your favorites, and people you communicate with pick their favorites, and the OpenPGP protocol handles the rest.

@_date: 2013-12-17 13:37:03
@_author: David Shaw 
@_subject: encryption algorithm 
gpg --edit-key (thekey)
You can see your own, or anyone else's preference list that way.  Note that each user ID (or photo ID) has its own preference list.

@_date: 2013-12-17 14:42:34
@_author: David Shaw 
@_subject: encryption algorithm 
Search me.  The defaults are reasonable defaults.  Of course, not everyone agrees :)

@_date: 2013-12-18 14:51:28
@_author: David Shaw 
@_subject: encryption algorithm 
Plus the related reason why Camellia is ordered the same way: because it would look strange to have AES 256,192,128 and then Camellia 128,192,256 !
Now that we have the preference list scoring, though, the above change is no longer necessary.  Instead of using the command line ordering, the score code handles it the same way regardless.  In the above example, AES (not AES256) would be chosen no matter what the order.  The rationale from back then was:
I don't think it's worth changing the default ranking back at this point though.

@_date: 2013-12-19 21:28:17
@_author: David Shaw 
@_subject: Import "Raw" RSA Secret Key? 
If you can manage to make a RFC 4880 secret key packet, you should be able to combine it with a user ID packet (either generate one yourself - no crypto needed - or just copy one from another key), and then import the result with --allow-non-selfsigned-uid.  That should skip the need for a self-signature.  Once you have it imported, you can self-sign it via GPG, using "--edit-key xxxxxx sign".

@_date: 2013-02-07 09:09:30
@_author: David Shaw 
@_subject: influence of signature type on trustdb 
Basically correct.  All of the signature types are equal except for the influence of --min-cert-level.  By default, that's set to 2, so the 0x11 "persona" signature is ignored when building the trustdb.  A signature whose very definition indicates that the person didn't check before making it, is probably one you want to skip :)

@_date: 2013-02-07 11:25:12
@_author: David Shaw 
@_subject: influence of signature type on trustdb 
Nope, this could be done.  There are a few reasons it hasn't, including that it would make the trust model incompatible (in the sense that a path that exists using GnuPG might not exist in PGP and vice versa) with other implementations.
There is no reason why someone couldn't write an *additional* trust model that takes that into account, though.  It just takes someone who wants it badly enough.  The OpenPGP standard doesn't have much to say about different trust models - it's mostly left up to the implementations to decide how to resolve whether a key is considered usable or not.

@_date: 2013-02-10 00:09:01
@_author: David Shaw 
@_subject: Best way to catch INSECURE unverified sig status when shelling 
The option you're looking for is "--status-fd".  Using that, you can get a stream of localization-safe string tags that can tell you the exact status of a signature.  See the DETAILS file from the GnuPG distribution for the specific tags.

@_date: 2013-02-12 15:20:30
@_author: David Shaw 
@_subject: how to use invald e-mail? 
gpg --allow-freeform-uid --gen-key
       --allow-freeform-uid
              Disable all checks on the form of the user ID while generating a
              new one. This option should only be used in very  special  envi?
              ronments  as  it does not ensure the de-facto standard format of
              user IDs.

@_date: 2013-02-19 22:34:04
@_author: David Shaw 
@_subject: default keyring file formats 
Keyrings of that type are just files with multiple keys concatenated together.  The format is effectively the same no matter what the filename is.
I've often seen foo.pub / foo.sec as a single key (while the pubring.gpg, pubring.pgp, or pubring.pkr) is the keyring, but that's just convention.

@_date: 2013-01-03 23:42:07
@_author: David Shaw 
@_subject: Paperkey 1.3 
Hash: SHA1
Hi folks,
Paperkey 1.3 is released.  This adds ECC key support (both ECDH and
ECDSA) as well as a few more minor tweaks.
Source and Win32 binaries are available at:

@_date: 2013-01-03 23:52:05
@_author: David Shaw 
@_subject: "New" packet headers and gpg 
No.  GPG automatically uses the old packet headers for those packets that can be described that way (i.e. packets numbered less than 16) and new packet headers for all other packets (16 and up).

@_date: 2013-01-04 08:54:43
@_author: David Shaw 
@_subject: gnupg not working with RHEL 4 
This means that you are trying to import a key with a version of GnuPG that is too old to understand it.  That key uses a feature (called DSA2) that didn't exist in version 1.2.6 of GnuPG.
While you don't have to upgrade Linux on server 1, you do need to at least upgrade GnuPG.
Go to  and grab the latest 1.4 version of GnuPG (at the moment, it's 1.4.13).  That is the easiest replacement for 1.2.6, and will handle that DSA2 key just fine.

@_date: 2013-01-04 11:31:16
@_author: David Shaw 
@_subject: "New" packet headers and gpg 
You could patch the code (look in build-packet.c) fairly easily if you need this.  Out of curiosity, why do you want to use only new packet headers?

@_date: 2013-01-04 12:31:14
@_author: David Shaw 
@_subject: Paperkey 1.3 
Sure, paperkey supports piping the output into whatever code generator you like:
  gpg --export-secret-key mykey | paperkey --output-format raw | your-bar-code-generator
However, 2D bar codes have some of the problems that paperkey is intended to address.  You need a 'thing' (a process, a device, etc) to read them, and part of the point of paperkey is that it's supposed to be the backup of last resort, and thus readable by a human without any special hardware involved.
You could also back up your whole key via a 2D bar code (without using paperkey at all) but then you're backing up a lot of redundant data, giving you a larger image.  Of course, this may not be a big deal if the intent is to scan it back in again rather than type it back in again.

@_date: 2013-01-04 14:30:43
@_author: David Shaw 
@_subject: Paperkey 1.3 
That's a very good point.  Do you know of any studies on the projected life of flash when used as backup?  I've read anecdotal numbers as low as 5 years, and marketing claims are always huge (100 years!), but most of what I see is about the lifespan is when the flash is actively used (so running out of read/write cycles), rather than the on-the-shelf lifespan of already written data.
The few numbers I've seen at manufacturers websites about retention specifically, suggest it's around 10 years (depending on how well the flash is stored - heat makes it die quicker, etc).

@_date: 2013-01-04 15:18:17
@_author: David Shaw 
@_subject: Paperkey 1.3 
0xA1BC4FA4 is a subkey on 0x99242560.  It should be available on the keyserver network.

@_date: 2013-01-04 15:36:32
@_author: David Shaw 
@_subject: gnupg not working with RHEL 4 
You could upgrade to 1.4.5, but this is not recommended.  There have been a number of bug fixes between 1.4.5 and 1.4.13, and using the most recent version is usually the best course of action.

@_date: 2013-01-04 19:17:13
@_author: David Shaw 
@_subject: paperkey //  recommended OCR font ? 
I've done this, with regular old Courier.  It basically worked, with a few glitches that I had to correct by hand.  Paperkey has a checksum on each line so you can easily tell which line got the glitch.  I suspect a OCR font would have done better.

@_date: 2013-01-13 23:39:59
@_author: David Shaw 
@_subject: Paperkey 1.3 
This is exactly the point.  Algorithms may stay around, but if have to reconstruct printed data given only knowledge of the encoding algorithm (without the hardware intended to read it, or the software intended to reconstruct the data), well, it's possible, but sure as heck won't be quick or cheap for someone with image processing experience, or even possible for the majority of people without that knowledge.
Paperkey often spawns this discussion about how we could use scannable paper images using x, y, or z encoding, or favorite brands of burnable CDs that will last, etc. No doubt, favorite flash brands will be discussed in the future.  These are all interesting discussions, but it's sort of missing the point.  Paperkey is a way to store your key in a way that needs nothing more than eyes and a keyboard to restore, and uses a medium that can last for many times the greatest human lifespan.  The disadvantage is that it's potentially annoying to recover a key from paper (i.e. typing in a several hundred hex bytes without error).  There are per line checksums to make this easier, so you know where a mistake is, and you can use OCR to save on typing, but still, you have to get the bytes from paper into a computer somehow.  All that is fine, as paperkey does not, and is not intended to, replace a backup of your secret keys. It's not where you should be going if your primary storage goes poof.
Exactly.  Keep proper backups!  Paperkey is for when that backup fails, for when your CD stops working, for when the driver for your scanning pen isn't maintained on your new computer, or for when cosmic rays have rendered your flash corrupt.  It's the backup of last resort, and as such should need nothing other than nothing other than the ability to read numbers and type them in again to restore, hence my comment about not favoring a 2D barcode paperkey.

@_date: 2013-01-31 15:41:06
@_author: David Shaw 
@_subject: gpg: WARNING: message was not integrity protected - MDC 
============================== START ==============================
Note that the message you see is just a warning.  It does not affect decryption - it's just telling you that the sender didn't protect the message.
There are several ways to enable MDC.  The most common way is a flag on your key that instructs the customer's PGP to enable MDC (i.e. "I can handle MDC, so you're free to use it").  So the first thing you should do is check your key to see if it has the MDC flag on it.  To do this, run:
  gpg --edit-key (yourkey)
and enter "showpref" at the prompt.  The final line is "Features".  If "MDC" is on that line, then you have the MDC flag, and anyone communicating with you should use a MDC if they support it.  That said, I see that your customer is using PGP 7.1, which is incredibly old at this point.  I don't recall offhand if it supports MDC or not (I have a vague recollection that PGP only started supporting it in PGP 8 - which is itself very old at this point).
If your key has the MDC flag, then the problem is most likely that the customer's PGP doesn't support MDC.  Since you probably can't upgrade the customer, you can use the --no-mdc-warning on your side.  This doesn't change the fact that the message you got isn't protected, but does prevent the warning from being printed.

@_date: 2013-06-19 09:07:39
@_author: David Shaw 
@_subject: cleartext signature: digest determination 
It's an ordering issue.  Cleartext signatures are designed to be able to be read in a single pass - thus the need for the Hash header at the beginning of the document, so the receiving program doesn't have to read to the end, find out what hash is in use, then jump back to the beginning to actually hash the document.

@_date: 2013-03-25 09:55:20
@_author: David Shaw 
@_subject: IDEA License 
It was a patented algorithm which required a license.  The patent has since expired (and in fact it was difficult to even purchase a license for the past few years anyway), so there is no license required.
That said, IDEA is somewhat old technology at this point, and it has mostly been supplanted by newer algorithms like AES.  If you have don't have a need for IDEA specifically, you might want to look more widely.

@_date: 2013-11-13 20:29:33
@_author: David Shaw 
@_subject: How to add information about purpose/security of sub keys? 
There isn't a standard way to do this - the encrypting client is free to pick either b or f, as it desires, when encrypting to your key.   That said, many (most?) clients will pick the most recent key, so if you generate b after f, you should get what you want, at least most of the time.
The standard way to express how you intend to use your key is via a notation or a policy URL pointing to some document where you set out your desires.  It does not display when importing your key, but is present if anyone cares to look for it.  Do note that few people read these documents unless they have a specific reason to (you're in control of what you generate - you can't place requirements on how people process it).
Notations are a signature subpacket (i.e. live on a signature themselves), so if the signature was issued by the master key, then yes, they're signed by the master key.  If you're making a notation on a self-signature (like the one binding your user ID or a subkey), then this would of course be issued by the master key.
Yes.  All parts of the UID string are signed by the master key.

@_date: 2013-11-20 15:37:53
@_author: David Shaw 
@_subject: Theoretical and maybe stupid questions about security 
Not at all easily, *if* you have a good passphrase on your private key(s).
In OpenPGP, a S2K (string-to-key) algorithm is used, where the passphrase entered by the user is hashed multiple times (with added salt) to transform it into the key used to decrypt the secret key.

@_date: 2013-11-20 17:58:53
@_author: David Shaw 
@_subject: Setting encryption algorithm for specific key 
Not really.  This is one of the limitations of the preference algorithm in OpenPGP (well, a limitation of most algorithms): GIGO.  There is no easy workaround for a key falsely claiming support for a particular algorithm.
If you really can't get her to change her key, probably the best you can do is use personal-cipher-prefs to remove IDEA from the list of algorithm you'll consider.  That's a good bit better than hardcoding a particular algorithm, but is still global rather than per key or recipient.
There is a ugly hack you could use, which would be to create a dummy key, and set the preferences to not include IDEA.  Then make a group alias for her name that includes both her real key, and the dummy key.  Thus, when encrypting to the alias, you'll be encrypting to both her and the dummy.  Since the dummy doesn't allow IDEA, IDEA cannot be chosen overall.  That's per recipient, but pretty messy.

@_date: 2013-10-10 14:10:37
@_author: David Shaw 
@_subject: my gpg key does not conform to rfc4880? 
Probably, but without seeing the key it is hard to be completely sure.  Most likely, you could just strip the poison signature from your key and keep using it.  If it's a self-signature, you'll have to make another one.  If it's a signature from someone else, you can either disregard it, or ask them to re-sign your key.
Can you say what the software that rejected your key is?  If you think about it, rejecting a key because of a bad signature could lead to an denial of service attack - just upload a signature that is noncompliant enough to cause the key to be rejected, but compliant enough to make it onto a keyserver.  Is your key with the bad signature on a keyserver?

@_date: 2013-10-15 21:43:14
@_author: David Shaw 
@_subject: better handling of importing local signatures 
Have you tried doing this?  The code (at least in 1.4.x) already works this way.

@_date: 2013-10-16 09:51:59
@_author: David Shaw 
@_subject: trust your corporation for keyowner identification? 
It's an interesting question, but it would not be enough for me.  If you think about it, this is effectively the same as Alice signing Baker's key, and then Charlie signing Baker's key because Charlie knows Alice (and not necessarily Baker).  If I were Charlie, I would not be willing to sign Baker's key, even if I knew and trusted Alice, without verifying Baker myself.
A somewhat related case would be when the corporation itself has a corporate signing key and on HR/IT approval, signs employee keys.  (This sort of thing is one of the classic uses for trust signatures).  In that case, you can either trust the corporate signing key or not, as you like.

@_date: 2013-10-24 20:07:20
@_author: David Shaw 
@_subject: 2048 or 4096 for new keys? aka defaults vs. Debian 
Heh, you might dig through the mail archives from this list from around that time.  In short, some people will call it zealotry.  Some people will call it necessary.  Some people are in the middle.  Reasonable people can disagree about these things, and there isn't one right answer for everyone.
However, in regards to the GnuPG default, that isn't an oversight.

@_date: 2013-10-24 20:10:44
@_author: David Shaw 
@_subject: (GnuPG) 1.4.2 - Signature Verification Issue 
The first thing to ask whenever people put FTP and signatures together is whether the files are transferred via ascii or binary mode in FTP, and the related question of whether the files you are transferring are in ascii armor or not.  Transferring non-armored files via ascii mode in FTP can cause various corruption problems.

@_date: 2013-09-13 16:17:10
@_author: David Shaw 
@_subject: lsign produces exportable signatures when used for self-sigs 
This is by design (hence the warning message), as an unsigned user ID is not really meaningful as anyone could add it against the will of the keyholder, and a locally signed user ID is effectively unsigned.

@_date: 2013-09-25 11:46:03
@_author: David Shaw 
@_subject: Magic numbers for keyring files? 
Do you mean OpenPGP keyrings (i.e. "transferable public/secret keys", a la RFC-4880)?  If so, it's statistical magic only.  There are binary headers you can look for that don't quite ensure it's a OpenPGP keyring, but can leave you fairly confident.
Take a look at the "file" magic database as a start.  It's not 100%, but should get you going.

@_date: 2013-09-26 16:53:27
@_author: David Shaw 
@_subject: GPG Private Key Export Question 
Yes.  This isn't an actual public key packet - just the contents of the public key packet at the end of the secret data, so it doesn't show up as a ":public key packet:" in --list-packets.
Not exactly, but (at least using GPG) you get the same effect.  If you import a secret key and you don't have the public key, GPG will use the embedded public key data to recreate the public key, so effectively an exported secret key is like exporting a key pair.
It's based only on the public key information.

@_date: 2013-09-27 10:40:07
@_author: David Shaw 
@_subject: GPG Private Key Export Question 
It's part of the secret key packet, immediately before the encrypted stuff.  So a secret key is effectively a public key, with a few more fields of secret stuff tacked on the end.
Your assumption is correct, for both.  When GPG imports a secret key, it creates a public key and imports it alongside the secret key.

@_date: 2014-04-02 00:37:22
@_author: David Shaw 
@_subject: Encrypted file-size approximation with multiple recipients 
This can change pretty significantly given different key lengths, different algorithms, and perhaps most significantly, how compressible the original document is (by default GPG compresses data before encryption).  An input file of text will compress very differently than an input file that's a jpeg (as jpegs are already compressed, and so do not benefit much from a second layer of compression).
Not really.  If you constrain the problem as you have (everyone gets 2048 bit keys, etc), and constrain the input to a particular type of data, you can get a better approximation, but as soon as you open the problem up, the file sizes vary.

@_date: 2014-04-07 09:16:36
@_author: David Shaw 
@_subject: Removing old preferences from exported key 
When you change preferences you add another selfsig for your user ID that contains the new preferences.  If you want to make the old preferences go away completely, you can simply delete the old selfsig via delsig (you only need one selfsig, and the newer one is already present).  However, this won't necessarily do what you want - since keyservers are strictly additive, even if you delete the old selfsig, when you upload to a keyserver, any keyserver that has seen the key with the old selfsig will put it back.  Similarly, if someone had your key with the old selfsig, sending them the new preference will cause them to have both.
Luckily in practice, this isn't a problem - most implementations will ignore the old selfsig/preference in favor of the newer one.

@_date: 2014-04-23 23:14:24
@_author: David Shaw 
@_subject: best practice for pgp mail service, revoking keys 
I haven't looked extensively at your design, so this isn't a suggestion as to what you should do, but just to mention a possibility you may have missed:
5. User appoints you (or a designated key) as their designated revoker.  This allows your key to issue a revocation on their key.  Pro: no need to store revocation certificates for all of your users, which could leak.  Con: the revocation only works if the person checking has both your key and their key.
It's similar in many ways to 3.

@_date: 2014-04-23 23:14:25
@_author: David Shaw 
@_subject: GPG cannot import public key 
It doesn't look like it's self-signed, but without looking at the key itself, I couldn't say for sure.  Is it posted anywhere on the net?
In any event, you can override the check for encryption with the same flag you used to override the check on import.  So:
  gpg -r 845F5188 --allow-non-selfsigned-uid -e the-file-i-am-encrypting-etc.txt

@_date: 2014-04-23 23:25:10
@_author: David Shaw 
@_subject: GPG cannot import public key 
I should add, though, that overriding these checks is something you should do with suitable verification of the key.  Don't override the check unless you know what you're doing, and have assured yourself that the key you are encrypting to is really owned by the person/group that you believe it is.  Those checks are there for a reason.

@_date: 2014-04-24 13:55:07
@_author: David Shaw 
@_subject: GPG cannot import public key 
Interesting!  This definitely has a selfsig, but the key itself is very odd.  It's an RSA sign-only key, which is deprecated in OpenPGP.  The subkey is similarly odd - a RSA encrypt-only key, also deprecated.  The header says it came from "Encryption Desktop", which is a Symantec product (well, it is now).  I don't know why that key is using deprecated key types, but certainly something is odd there.
RFC-4880 (published back in 2007) says:
   RSA Encrypt-Only (2) and RSA Sign-Only are deprecated and SHOULD NOT be
   generated, but may be interpreted.
Weirder, the selfsig says it's a RSA signature (not RSA_S), so you have the odd situation of a key (RSA_S) and its self-sig (RSA) being from different algorithms.
So, it's legal for GPG to not accept this key (using deprecated algorithms), though the error message you got seems misleading to me.
GPG 1.4.5 treats RSA_S and RSA_E as identical to RSA for existing keys, but does not allow generating them.  This is legal as per the spec (i.e. don't generate them, but it's optional to use them).
I'm afraid I don't have immediate access to the GPG 2.x code base to check, but I wonder if your problem is simply that 2.x doesn't accept RSA_S and RSA_E keys?

@_date: 2014-04-30 13:25:21
@_author: David Shaw 
@_subject: Get expiration date by searching on keyservers 
GPG's keyserver code is capable of displaying expiration date, if the keyserver provides it.  Not all do.
But - and this is important - like all key data (from expiration date, to revocation status, to the user IDs, etc), the info returned by a keyserver is only informational.  You cannot rely on it until you download the key and check it yourself.  The keyservers are simply storage, and do not verify the keys sent to them (and you shouldn't trust them even if they claimed to).

@_date: 2014-04-30 16:26:09
@_author: David Shaw 
@_subject: Access to www.gnupg.org only via TLS 
There were questions early on whether grabbing secret keys was possible via Heartbleed or not.  Since then, it's been proven that it is definitely possible.  At least one company set up a server and invited people to try and steal the secret key via Heartbleed.  It took less than a day:
  Here's a program that automates the process.  Just run it and wait:
  I can't speak to whether actual (meaning "not example keys put there for the purpose of stealing") secret keys have been compromised by Heartbleed, but it's definitely not impossible (or all that difficult now that someone has done the hard part - just start a script and walk away).

@_date: 2014-08-11 18:08:35
@_author: David Shaw 
@_subject: =?windows-1252?Q?Re=3A_=5Bopenpgp=5D_SHA-2_support_should_be_man?= 
Rather than fixing RFC-1991 support, why not go in the other direction and make it clear that it isn't supported, and won't work?  I did a bunch of work to make --pgp2 work well and interoperate with PGP 2.x over a decade ago.  Even then it was intended as a stopgap measure until people finally stopped using PGP 2.x.  Over 10 years later, it's well past time to kill it.

@_date: 2014-08-12 23:41:19
@_author: David Shaw 
@_subject: =?windows-1252?Q?Re=3A_=5Bopenpgp=5D_SHA-2_support_should_be_man?= 
How about remove the functions in 2.1, and add a warning (in the docs, and perhaps upon use in the code) that the functions will be going away in 2.0?  That might be aggressive, but then, 2.1 isn't officially released yet, so it's not unreasonable to make a larger change there.  What do you think?
I need to look at the code and see if there are any places where removal of --pgp2 (or --pgpX in general) will leave things in a messy state.  One place that comes to mind is in --gen-revoke.  GPG can import a bare revocation certificate.  No version of PGP can, so there is code to push out a minimal public key before the revocation certificate.  We'd need to add some sort of flag to indicate to include the minimal public key, and that's sort of reinventing --pgp again.
Maybe the answer is to remove the things to generate PGP 2 messages specifically, and leave the other stuff?  That feels a bit messy.
I'd remove them as well.  They're much easier to remove than --pgp2 as they only affect very specific (and few) places in the code.

@_date: 2014-08-13 17:51:19
@_author: David Shaw 
@_subject: Seeking clarification with a few GPG concepts 
Try this:
  gpg2 --expert -u (thekey) --edit-key (thekey)
     Select the uid you want to un-revoke
  sign
     You'll get a prompt like "XXXX was already signed by key YYYYY.  Do you want to sign it again anyway?".  Say "yes".

@_date: 2014-08-14 07:23:06
@_author: David Shaw 
@_subject: =?windows-1252?Q?Re=3A_=5Bopenpgp=5D_SHA-2_support_should_be_man?= 
I agree.  But I wasn't clear enough - the "other stuff" I'm referring to above is the (PGP6 || PGP7 || PGP8).  That is, removing --pgp2 and leaving the others.  On second consideration, though, the --pgpX options are at least theoretically OpenPGPish (some more than others!), so having those options stay is reasonable.

@_date: 2014-08-14 07:23:20
@_author: David Shaw 
@_subject: =?windows-1252?Q?Re=3A_=5Bopenpgp=5D_SHA-2_support_should_be_man?= 
I think the context has been lost in that sentence.  The "other stuff" I was referring to was --pgp6, --pgp7, etc.  The --pgpX options in general.  There was never a question of removing the ability to decrypt PGP 2 messages.  As you say, that would destroy the ability to decrypt old messages.

@_date: 2014-08-14 07:26:13
@_author: David Shaw 
@_subject: Seeking clarification with a few GPG concepts 
It may be appropriate to not need --expert for this specific case of re-signing a revoked user ID.  --expert is odd corner cases and "don't try this at home" sort of stuff, and re-signing a UID is perhaps uncommon, but certainly a straightforward operation in OpenPGP.
I'll take a look.

@_date: 2014-08-14 07:33:17
@_author: David Shaw 
@_subject: what is "correct" for users' Preferred keyserver ? 
It can be either.  The definition of that option in the protocol is:
   This is a URI of a key server that the key holder prefers be used for
   updates.  Note that keys with multiple User IDs can have a preferred
   key server for each User ID.  Note also that since this is a URI, the
   key server can actually be a copy of the key retrieved by ftp, http,
   finger, etc.
GnuPG supports both the keyserver, and link-to-key cases.

@_date: 2014-08-14 07:47:36
@_author: David Shaw 
@_subject: what is "correct" for users' Preferred keyserver ? 
Perhaps the problem here is not the option, but the behavior on failure.  If querying the preferred keyserver does not return a response during a refresh (for whatever reason), maybe GPG should continue on and try to get the key from the standard --keyserver location.
After all, it's a "preferred" keyserver.  Not an "exclusive" keyserver.

@_date: 2014-08-14 09:18:25
@_author: David Shaw 
@_subject: HP-UX and GnuPG 
While GPG can make use of an EGD, EGD is not part of GPG.
That said, I'm not very familiar with HP-UX, but I was under the impression that 11.11 either had, or could download a package from HP, that gives you a true /dev/random (which GPG can then use).  Have you read  ?

@_date: 2014-02-22 17:38:00
@_author: David Shaw 
@_subject: Newbie problem 
Enter "expire" and follow the prompts.  It will ask you for the new expiry date, and then ask for your passphrase to encode it onto the key.

@_date: 2014-02-23 09:18:29
@_author: David Shaw 
@_subject: Size of main key... 
If you're limited to using RIPEMD160 for some reason (or SHA-1, also a 160-bit hash), then you are limited to a 1024-bit DSA key.  You are not limited to using DSA though: you can make a RSA main key of whatever size you desire, as RSA key sizes are not tied to the size of the hash.

@_date: 2014-02-23 11:12:25
@_author: David Shaw 
@_subject: Size of main key... 
No.  You can't add bits to a key, so the only way to do that is to make a new key, which would naturally give you a new key ID.  It is possible to generate many keys over and over until you randomly hit the key ID you want, but that could take a while.  It's not too bad to match the 32-bit (8-digit) key ID you see usually, but note that internally GnuPG uses 64 bits (16 digits) for most purposes, and no matter what you do, your fingerprint won't be the same in any case.

@_date: 2014-02-26 12:01:21
@_author: David Shaw 
@_subject: GPG key trust after a signing party 
A (slightly) simplified way to think of it is:
  1) You sign someone's key to say "I assert that this key belongs to the person identified".
  2) You assign trust to someone's key to say "I believe this person is responsible enough to do number 1 well".
 is a public statement from you (your key) to the world.   is a private note in your own GPG setup.
The two don't necessarily go together.  If you think someone makes terrible signatures (for example, doesn't check sufficiently before signing), then you may still sign their key (after all, you're not making a statement as to their reliability, just as to their identity), but you probably wouldn't want to assign trust to their key.  In other words, you believe their key belongs to them, but you don't "trust" them to make good signatures on other people's keys.
At a keysigning party, it's quite common to be able to sign someone's key (you check some ID, verify their email address works via a cookie, and so on), but yet have no idea if the person is worth trusting to sign someone else's key.  After all, in many cases, you've never even met them before.
p.s. There are variations here like the trust signature that combines both identity and trust into a single statement, and the local signature which is like a regular signature but not a public statement, but in the context of a keysigning party, they're much less common.

@_date: 2014-01-27 15:12:20
@_author: David Shaw 
@_subject: pgp export private key with password 
I'm not sure I understand what you're trying to do.  --export-secret-keys doesn't add or remove a passphrase.  If the key has a passphrase, the exported one still does.  If the key has no passphrase, neither does the exported one.
If your secret key has a passphrase, then "--armor --export-secret-keys xxxxx" generates an armored key file with a passphrase.

@_date: 2014-01-27 15:40:28
@_author: David Shaw 
@_subject: pgp export private key with password 
Interesting.  I wonder why it does that - perhaps it stores the key unencrypted internally?  What happens if you provide your regular key passphrase to the app on import?

@_date: 2014-01-28 10:11:45
@_author: David Shaw 
@_subject: old pgp2.6x keys imported in gpg (compile pgp 2.6) 
Yes and no.  PGP 2.6.2 keys (version 3 keys) are compatible with RFC-4880, but that does not necessarily mean that every implementation supports them.  Version 3 key support is optional in the standard, so it is possible that the iPGmail app only supports OpenPGP (version 4) keys.
(Frankly, if I was writing a OpenPGP program today, I'd probably leave out version 3 support as well).

@_date: 2014-06-01 10:52:14
@_author: David Shaw 
@_subject: Why create offline main key without encryption capabilities 
One reason is that in some places there are legal issues around this.  You can be legally required to give up your encryption key to the authorities or suffer the consequences (arrest / jail / etc).  The idea is that if you have a different encryption and signing/certification key, you can easily give up the encryption (sub)key without compromising your (much more valuable) main key.  At least that's the theory - I don't know offhand if this "I'll give you this key, but not that one" trick has been tested in practice, and if so, which legal jurisdiction it was tried in, and whether it worked or not.  (I'd be curious to find out, if anyone has any pointers).
For the sake of argument, let's say it worked, though: the authorities have your encryption key and can now decrypt as they like.  You promptly make a new encryption key using your (uncompromised) main key and continue on.  They can read your old mail, but not the new, and notably cannot make signatures as you, and cannot make new keys as you.
As a side note, when doing a key signing with someone, I send them a message and request they sign it to prove ownership of the key.  I require that this signature comes from the main key - that's the key I'm signing, so that's the key I need to prove ownership of.  The subkeys are not really relevant here.

@_date: 2014-06-02 11:01:11
@_author: David Shaw 
@_subject: Why create offline main key without encryption capabilities 
One problem with multiple encryption subkeys is that the person encrypting to you doesn't know which one to use. As things stand in OpenPGP clients today, unless the person encrypting explicitly specifies which subkey to use (and not all clients even offer a choice at all) they'll *a* subkey, which may or may not be the one you (or they) would have wanted.
This problem doesn't exist in exactly the same way for multiple signing subkeys since which key is used is under your control (the signer), but there is a related problem in that you'd have a "low security" signing key and a "high security" signing key. How does the recipient know which is the intended one at any given time?  From the recipient's perspective, it's just a good signature. There is no "this is a good signature from my high security key" (there is a "good signature from key XXXXX", but they don't know what additional meaning you give to that key in particular).
To be sure, OpenPGP does have enough hooks and capabilities to implement what you're talking about (signature notations to say "this is my high security key", for example) but it isn't done at this time.

@_date: 2014-06-02 11:47:51
@_author: David Shaw 
@_subject: Why create offline main key without encryption capabilities 
This is the GPG behavior, but this is just what GPG does.  It's not mandated by the OpenPGP standard, so other clients may do other things.  It would be equally as correct for a client to choose the key created earlier, or indeed to choose randomly.
There is some interesting discussion of key selection in   They argue (as part of a PFS scheme) that the key most near its expiration time should be chosen.

@_date: 2014-06-03 22:43:22
@_author: David Shaw 
@_subject: Google releases beta OpenPGP code 
Likely of interest to this group:
  Briefly, it's a Chrome extension for doing OpenPGP.  It can import and use RSA keys generated elsewhere, but only has code to generate ECC keys internally.
I haven't looked at the fine details yet, but on the surface it seems like they're aiming at Gmail (mainly, but not solely).

@_date: 2014-06-04 11:56:54
@_author: David Shaw 
@_subject: Google releases beta OpenPGP code 
If we look at it cynically, I think this is a win-win for Google.  They get a lot of good press about "increasing user security" for nearly no cost to their business model.  This still requires manual steps to encrypt which pretty much rules it out for the overwhelming majority of users, and like you say, even for those relatively few users who start encrypting, Google still has access to traffic patterns.
I don't think they're being that cynical though.  The code is real, and presumably does what it is described to do.  It's not a complete solution (which for me would be automating it somehow), but it's a nice step.  And this is an 800 pound gorilla throwing some more weight behind encryption in general and OpenPGP in particular.  I'm quite pleased to see this.

@_date: 2014-06-25 14:30:18
@_author: David Shaw 
@_subject: more bikeshedding about offline primary keys &  auth subkeys 
I think the confusion here is with the term "authenticate".  The ability to sign someone else's key is to "certify".  To "authenticate" is to prove your identity (for example, using an OpenPGP keys for ssh).  You can only certify with a primary key, and all primary keys are capable of certification (you literally can't turn the ability off).  Authentication is a different capability.

@_date: 2014-06-27 15:44:47
@_author: David Shaw 
@_subject: riseup.net OpenPGP Best Practices article 
My understanding is that the YubiKey Neo applet supports up to 2048 bit RSA.  Thus there are some keys that will work with the V2 SmartCard but not on the Neo.
I do admire the Neo form factor though.

@_date: 2014-06-27 18:35:00
@_author: David Shaw 
@_subject: On the advisability of stronger digests than SHA-1 in OpenPGP 
My notes say that PGP 8.1 can verify sigs made with SHA-256, but won't generate it.  I'm afraid I don't have a copy of 8.1 handy any longer to check.
Incidentally, since subkeys have come up in this thread, I seem to recall a few strange bugs with 8.x (8.0? 8.1?) that make it difficult to use if the key you are encrypting to has a signing subkey.  8.x didn't always handle signing subkeys properly, so could end up failing to encrypt (it wasn't 100% of the time - it depended on which subkey was dated first).  If anyone is curious, I'll dig out my notes for this.  I submitted the bug to PGP, and I know it was fixed in a later version.

@_date: 2014-06-28 09:22:17
@_author: David Shaw 
@_subject: On the advisability of stronger digests than SHA-1 in OpenPGP 
Yes, that was it.  It got particularly strange when someone was using an RSA signing subkey or auth key (as they would do if they had a smartcard).  In that case, the PGP encryption would actually succeed (after all, RSA is capable of it, despite what the key flags instructed for use) but the GnuPG recipient would be unable to decrypt as from their perspective, that key was sign or auth only.
I put a limited workaround in GnuPG at the time - that's why the encryption key is always written to the card after the auth key (so the encryption key would always be the "newest".  Of course, that didn't handle existing keys.  The real fix was needed in PGP, and it was fixed.

@_date: 2014-06-29 09:50:20
@_author: David Shaw 
@_subject: On the advisability of stronger digests than SHA-1 in OpenPGP 
Ha, sure enough.  Looks like that was quite a few years ago.  I won't guess how many people are still using PGP 8, but if they're out there, they're likely not using it to interoperate with people using smartcards.  Given the lack of bug reports since this change way back in 2009, I'll go out on a limb and wager that the intersection between PGP 8 users, if they still exist, and smartcard users isn't exactly large.

@_date: 2014-03-13 08:08:11
@_author: David Shaw 
@_subject: Encrypting File with passphrase 
In short, yes (though you don't need to provide a passphrase at all to encrypt to a public key - the passphrase has no meaning there).  Encrypting to a public key does not use a passphrase at all.  Only decrypting with the private key uses a passphrase.

@_date: 2014-03-13 18:27:45
@_author: David Shaw 
@_subject: Multiple Subkey Pairs 
Probably escaping the exclamation mark to prevent it from being interpreted by the shell.  In bash, at least, it's not necessary as a trailing ! mark doesn't get interpreted by the shell.  Doesn't hurt to escape it though.

@_date: 2014-03-17 11:14:55
@_author: David Shaw 
@_subject: Can't check signature, 
The key may be fine, but the signature is invalid.  DSA keys specify how many bits of hash are necessary to make a signature.  This key says it needs a 256-bit hash:
                    ^^^^^^^^^^^^
But the signature is strange.  It claims to be SHA-1:
          ^^^^^^^^^^^^^
But is way too large:
         ^^^^^^^^^^^^^^^
Basically, the signature failed verification because it's mangled somehow.  I'm not sure how they managed to create it, but it's broken.

@_date: 2014-03-17 11:19:45
@_author: David Shaw 
@_subject: Can't check signature, 
It doesn't matter if you specify --digest-algo sha1.  Regardless of the setting of enable-dsa2, it the key wants a 256-bit hash, gpg won't allow you to sign with SHA-1.  There is no way to generate that signature, at least in gpg.

@_date: 2014-03-23 20:26:03
@_author: David Shaw 
@_subject: OpenPGP smartcard and RSA 8192 bit 
No.  You can store three 4096-bit RSA keys.  Larger than that is not possible on the card (and not supported in GnuPG even not using a smartcard).

@_date: 2014-03-27 09:35:21
@_author: David Shaw 
@_subject: GnuPG encryption with key file 
Not really, but you can sort of weakly approximate it via something like this:
   base64 -w0 binary-file-for-passphrase | gpg --passphase-fd 0 --symmetric file-to-encrypt
Limitations of the method are that it's not really using the binary file as a key, but rather as a passphrase (so it gets the usual hash treatment), and there is a size limit on how large the passphrase can be (it's in the thousands of characters, but there is a limit).  The reason for the base64 is that passphrase-fd stops reading after \n for obvious reasons, and text passphrases can't have \0 in them, so a naturally-occuring \n or \0 in the binary file will truncate your "passphrase".  Same reason for the -w0, which tells base64 not to add any \n of its own.

@_date: 2014-03-31 15:14:45
@_author: David Shaw 
@_subject: Use own key with symmetric encryption? 
============================== START ==============================
No.  Not without patching the source.

@_date: 2014-05-02 22:28:12
@_author: David Shaw 
@_subject: new keys vs. sub-keys vs. uids 
Briefly, no.  The signature is issued from the key, not by a particular identity using that key.  There is an optional feature in OpenPGP to say "I meant that signature to come from *this* user ID", but that doesn't really solve your problem either - it doesn't hide the fact that there are other identities or what those identies are, but rather indicates the one (of several) that you're using at the moment.  In any event, GPG doesn't support that feature (neither does PGP).
If you have a key with multiple user IDs, anyone looking at that key can see all of those identities.  The standard method for doing what you are trying to do is to have two separate keys.

@_date: 2014-05-05 23:08:34
@_author: David Shaw 
@_subject: improving validity calculation: external program 
Believe it or not, this almost exists.  Way back in 2003, I added the concept of an "external" trustdb.  The intent was exactly for what you mention: to allow people to make up and experiment with their own ideas in trust handling without having to have GPG support them all directly.
The trustdb in GPG is essentially a frozen image of what ownertrust you've set on which keys, and which users IDs are valid, and to what degree (partial, full, etc).  When you run --check-trustdb and/or --update-trustdb, you're rebuilding the trustdb image.
An external trustdb is just like any other trustdb, except that GPG follows it directly, and does no trust calculations of its own.  So GPG is capable of reading this special trustdb that can encode any behavior you like.  The catch is that I never had time to write a generic trustdb "compiler" where you could feed it the key/user ID/validity relationships you desire, and have it spit out the resulting trustdb.  A reasonably good programmer should be able to write one in short order though.  You just need to follow the format used in tdbio.c, and tag it as TM_EXTERNAL so GPG knows to treat it as special and refuse to run check-trustdb or update-trustdb on it.
Note that while you may choose to use a nonstandard notion of trust and/or validity, that of course only applies to you.  Just like the standard trust models, just because A sees B's key as valid, it doesn't necessarily imply that B sees A's key as valid.

@_date: 2014-05-13 23:30:21
@_author: David Shaw 
@_subject: "gpg --with-fingerprint $FILE" is not listing the keyfingerprint 
Looks like a bug.  Note that on each of the keys that didn't work there is a direct signature on the key.  This is not very common, and is usually used for a designated revoker (i.e. "I permit so-and-so to revoke my key for me").   I suspect there is a bug printing the fingerprints on a key from a key file (rather than from a keyring) for keys with a direct signature.

@_date: 2014-05-14 15:40:47
@_author: David Shaw 
@_subject: Future inclusion of Threefish in Gnupg? 
Yes.  GnuPG follows the OpenPGP standard, so any new algorithms would need to go through that process first.

@_date: 2014-05-22 15:41:37
@_author: David Shaw 
@_subject: How are primary key  binding signatures (0x19) handled by gpg? 
When verifying a signature from a subkey without a 0x19 binding signature (aka "backsig"), you should get an error:
 WARNING: signing subkey XXXXXX is not cross-certified
 please see  for more information
and the signature verification will fail.
If you own the key in question, you can add a backsig to it via "gpg --edit-key 0549B8A5640444E6" and then "cross-certify".

@_date: 2014-11-10 08:32:52
@_author: David Shaw 
@_subject: DSA key sizes 
FIPS-186-3, the document that specifies DSS (aka DSA with some additional restrictions as to algorithm, key length, etc) specifies 4 key sizes:
  1024 bit key, 160 bit hash
  2048-bit key, 224 bit hash
  2048-bit key, 256 bit hash
  3072-bit key, 256 bit hash.
To be closer to FIPS, GnuPG rounds up to the next 1024-bit boundary when making DSA keys.  The hash rules are keys 2048 bits and over use a 256-bit hash, keys over 1024 bits use a 224 bit hash, and 1024 and under use a 160 bit hash (classic DSA).  GnuPG skips the 2048/224 option in favor of 2048/256.
In --expert mode you can select whatever key size you like without rounding, but the same hash size rules still apply.

@_date: 2014-11-10 10:04:50
@_author: David Shaw 
@_subject: DSA key sizes 
No, four. Section 4.2 of FIPS-186-3:
  This Standard specifies the following choices for the pair L and N (the bit lengths of p and q, respectively):
  L = 1024, N = 160
  L = 2048, N = 224
  L = 2048, N = 256
  L = 3072, N = 256
Remember that the FIPS-186 documents cover DSS, not DSA.  There was a < 1024-bit DSS, but it didn't make it into FIPS-186-3.
It's also not the case the GnuPG never supported 512-bit DSA.  You could generate a 512-bit DSA until 1024 was made the minimum in late 2004.  Even today, it's possible to generate a 512 bit DSA key in 1.4.x if you use --expert.  (Not that you should).

@_date: 2014-09-15 09:47:21
@_author: David Shaw 
@_subject: encrypting to expired certificates 
I disagree with this.  Expiration is the way the key owner (the person who knows best whether the key should be used or not) tells the world, "Do not use this key after this date".  If someone encrypts to the key anyway, they are going against the key owner's statement.
I'm sure people can come up with particular scenarios where it is either okay or very not okay to use a key after it is expired, but either way, the key owner gave a date.  Who are we to disregard that?

@_date: 2014-09-15 16:16:07
@_author: David Shaw 
@_subject: encrypting to expired certificates 
I suspect that the word "expired" was expected to be clear on its own in the RFC.  If there was some non-common meaning of expired, the term would have been explicitly defined.  RFCs don't seek to confuse things.  5.2.3.6 defines it as "the validity period of the key".  In other words, after that specified time has elapsed, the key is not valid.
Are you arguing that in other places we allow people to use non-valid keys, so why not here as well?  I don't agree with that, but I do understand it.  ("valid" being a fairly weakly defined term without, yes, policy).
In any event, the choice being presented here between "use an expired key" vs "send in plain text" strikes me as misleading.  There is a third case, which is "Stop.  Something is wrong.  Figure it out before proceeding."

@_date: 2014-09-17 16:49:31
@_author: David Shaw 
@_subject: encrypting to expired certificates 
Both keys and UIDs can have expiration dates in OpenPGP.  Though both date fields live on the UID self-sig, they're not the same thing and aren't necessarily set to the same value.
GnuPG, like most OpenPGP clients, only really implements key expiration, though it should properly honor a UID expiration if someone generates it elsewhere.

@_date: 2015-01-13 10:34:06
@_author: David Shaw 
@_subject: Vanity Keys 
I'm sort of amused by vanitykeys.io.  If you read the HN thread, the author is pretty willing to accept this isn't the greatest idea, and has updated the page to say that.  (Of course, he hasn't taken the thing down completely either..)
I like the idea of adding a proper fingerprint to signature packets.  I seem to recall this was suggested once in the past, but I don't recall why it wasn't pursued.

@_date: 2015-01-13 15:52:07
@_author: David Shaw 
@_subject: Vanity Keys 
OpenPGP uses the 64-bit key ID to locate keys.  If two people have the same 64-bit key ID, it doesn't mean that person A can impersonate person B, but it does mean that if both person A and person B's keys are on a given keyring, the verifying program will not know which key to use to check the signature.  Only the right key will actually work for verification, but the program may not be able to find that right key.
The fingerprint is a 160-bit key ID - effectively impossible (given today's knowledge) to impersonate.

@_date: 2015-01-13 22:42:41
@_author: David Shaw 
@_subject: Vanity Keys 
Unfortunately, it doesn't matter if users only use fingerprints when deciding to import a key or not.  Internally, keys are looked up using the 64-bit key ID.  This is a limitation of OpenPGP - the "issuer" of a signature is 64 bits long.  If the user manages to get two keys that happen to have the same 64-bit key ID (the lowest 64 bits of the fingerprint, for OpenPGP keys) then this problem applies to them.
The discussion on gnupg-devel is about adding a larger issuer that contains the complete fingerprint.

@_date: 2015-01-16 10:45:25
@_author: David Shaw 
@_subject: relationship between primary keys and subkeys 
No.  Primary keys own/parent subkeys.  There is no nesting beyond that.
It's not really something that needs interpretation or calculation.  Essentially you trust a subkey exactly the same way you trust the parent key for that subkey.   The interpretation and calculation is done for the parent key.

@_date: 2015-01-17 20:02:06
@_author: David Shaw 
@_subject: Hash selection failure on 2.1.1 
That's basically how it works for "personal-digest-preferences", but you're showing your "default-preference-list".  They're very different.  default-preference-list sets the default preferences for new keys and is not part of the digest choice when signing.
Not in this case.  That's a clearsigned message above, and so GnuPG has no way to know who your recipient is.  If you were encrypting & signing, it could know based on the recipient key, but there is no "recipient key" for a signed (only) message.  Without a recipient, there are no preferences for it to consult beyond stuff (personal-digest-preferences, usually) in your config file.
There are a bunch of steps GnuPG follows when selecting a digest for signing without a recipient, but outside of the cases when it is forced to use a particular algorithm (due to DSA size requirements, smartcard capabilities, or the like), the main steps are "If digest-algo is set, use that.  Otherwise, if personal-digest-preferences is set, use that.  Otherwise, use SHA-1."
Do you have a personal-digest-preferences (or even digest-algo) set in your config file?

@_date: 2016-08-22 18:12:42
@_author: David Shaw 
@_subject: File Encrypted with Primary key 
I have seen this before - basically the Moveit code is using a buggy/older OpenPGP engine that does the wrong thing and ignores key flags.  Your key has an RSA primary key, and their engine sees that and concludes that since it's RSA, it can encrypt to it.  GPG properly respects key flags so uses the subkey.
There is only one fix for this, but two workarounds:
1 (the true fix): Get Moveit to fix their OpenPGP engine.  That's likely not an easy task since Moveit most likely purchased it from an upstream vendor (I'm going to guess Symantec - I have a vague recollection the previous time I saw this was with the Symantec code), so the actual fix would need to be from the upstream vendor, then Moveit would have to integrate it, and then whoever you're communicating with would have to update Moveit.  Given that this problem still exists in 2016, I'm going to guess that a fix here is not going to happen any time soon!
2 (workaround A): You can generate a key that explicitly permits encrypting to the primary key.  Then both GPG and Moveit will encrypt to the primary and everyone can interoperate.  This is not ideal as it is best practice to split the signing and encryption capabilities, but should solve your immediate problem.
3 (workaround B): Don't use an RSA primary key.  Instead of generating a RSA primary key with an RSA subkey, generate a DSA primary key with an Elgamal subkey (or for that matter, an RSA subkey - what matters here is the primary is DSA).  This pretty much forces the Moveit code to encrypt to the subkey since there is no way to encrypt to a DSA primary key (it's a signature-only algorithm).
My advice would be to try workaround B first.  If they're using the same engine that I saw before, it was smart enough to handle that case and would properly use the subkey.

@_date: 2016-02-25 13:04:33
@_author: David Shaw 
@_subject: Possible values for --compress-level and --bzip2-compress-level 
1 through 9, with 1 being the least compression (but generally runs faster) and 9 being the most compression (but generally runs slower).

@_date: 2016-03-08 09:19:03
@_author: David Shaw 
@_subject: Remove photos from OpenPGP key in the keyservers 
Alas, no.  Like other key items (user IDs, signatures, subkeys), the keyservers are strictly additive.  Once you add something, the servers have no means to remove them.
The most you can do is revoke those photos (like you'd revoke a user ID).  That does not remove them, but at least marks them as no longer intended.

@_date: 2017-01-17 22:03:02
@_author: David Shaw 
@_subject: Trust signature domain 
The value is a regular expression internally, but you don't need to enter it as one.   GnuPG automatically takes what you enter into the domain field and converts it to a regexp.  For example:
  example.com
  <[^>]+[
Can you post the actual user IDs of the keys you are testing with (or a similar example.com set) so I can try them as well?

@_date: 2017-05-16 11:37:13
@_author: David Shaw 
@_subject: suspicious key found 
There are many such fake keys on the keyservers.  I have one as well.  It's trivial to forge the short (8 hex digit) key ID - just keep generating keys over and over until you match the lower 32 bits.  Note that the fingerprints do not match, as there is no (current) way to forge an entire fingerprint.
See  - they made the keys as a demonstration, but didn't upload them.  It's an excellent demonstration why people should never trust the short key ID for anything.

@_date: 2017-10-31 23:29:24
@_author: David Shaw 
@_subject: GnuPG public key vulnerability? 
Recently, a flaw in the firmware for some Infineon hardware crypto was found.  RSA keys that were generated with this faulty firmware are not nearly as strong as their key length would imply.
You mention a Yubikey 4 nano, and unfortunately, that is one of the devices that used Infineon components.  In the case of a Yubikey and OpenPGP, if you generate the key *on* a vulnerable Yubikey, you may have a problem.  If you generate the OpenPGP key elsewhere and *import* the key to your Yubikey, you are not affected.
The Yubico people have a site up to check your device serial number to see if it is vulnerable and are offering a replacement program.  See There has been some discussion of the implications of this vulnerability on this list.  Search the list archives for "ROCA" to see more.
The original paper is at

@_date: 2018-06-20 07:01:31
@_author: David Shaw 
@_subject: [paperkey] Always output "interrupt" 
Hi Damien,
Which version of paperkey is this?  The latest is 1.5 (and support for EdDSA keys was only added in that version), so if you're using an old version can you try the latest?
If that doesn't resolve your problem, can you send me a sample secret key (not your real secret key, of course - just generate a dummy one) that exhibits the problem?  I'll make it work.

@_date: 2018-06-20 15:17:51
@_author: David Shaw 
@_subject: [paperkey] Always output "interrupt" 
I tested this on my regular development box and it worked fine.  Just for completeness, I spun up a Fedora 28 VM and it worked fine there as well.  It occurs to me that given the pipeline you were using, the "interrupt" error may have come from gpg2 rather than paperkey:
What happens if you do this:
$ gpg2 --export-secret-key "FooBar" > /tmp/foo.key
$ paperkey < /tmp/foo.key
