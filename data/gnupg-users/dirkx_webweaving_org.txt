
@_date: 2017-08-08 14:00:31
@_author: Dirk-Willem van Gulik 
@_subject: gpgsm, keygrip 
Lovely - we just checked against the master/head of an hour ago - and that tiny change greatly simplifies a lot of our scripts.
Thanks !

@_date: 2017-08-17 15:39:28
@_author: Dirk-Willem van Gulik 
@_subject: export secret subkeys 
I am trying to understand the man page with regards to secret subkey exports.       --export-secret-subkeys
              Same  as --export, but exports the secret keys instead.  The exported keys are written to STDOUT or to the file given with option --output.  This command is often
              used along with the option --armor to allow easy printing of the key for paper backup; however the external tool paperkey does a better job for  creating  backups
              on paper.  Note that exporting a secret key can be a security risk if the exported keys are send over an insecure channel.
This had me believe that export-secret-subkeys would just export a subkey.
Instead the output of --list-packets (and the file size) suggests that both the master and the subkey are exported.
Output below - followed by a script to reproduce.
Or am I misreading this ?
With kind regards,
# off=0 ctb=95 tag=5 hlen=3 plen=533
:secret key packet:
# off=536 ctb=b4 tag=13 hlen=2 plen=30
:user ID packet: "Tess von Testy "
# off=568 ctb=89 tag=2 hlen=3 plen=595
:signature packet: algo 1, keyid 774BFCB80257A25B
# off=1166 ctb=9d tag=7 hlen=3 plen=1862
:secret sub key packet:
# off=3031 ctb=89 tag=2 hlen=3 plen=572
:signature packet: algo 1, keyid 774BFCB80257A25B
set -e
set -x
LAST="von Testy"
MOI="${FIRST} ${LAST} "
export RANDFILE=~/.openssl.rand.state
export DAYS=365
export SUBDAYS=120
killall scdaemon gpg-agent || echo Already dead
killall scdaemon gpg-agent || echo Already dead
if test -f /usr/bin/hdiutil; then
       		/usr/bin/hdiutil hdiutil create -attach -stdinpass -quiet \
       		-encryption -size $SIZE -fs HFS+ \
       		-volname ${VOLNAME} ${TMPSTORE} set -e
export GNUPGHOME cd $GNUPGHOME
cat > ${GNUPGHOME}/gpg.conf < ${GNUPGHOME}/gpg-agent.conf < ${GNUPGHOME}/scdaemon.conf < sub-enc.sec
cat sub-enc.sec | gpg --list-packets  snip other unit tests

@_date: 2017-08-17 16:17:42
@_author: Dirk-Willem van Gulik 
@_subject: export secret subkeys 
Thank you !
Clear. So I need to figure out why paperkey outputs more than I am expecting when minimalizing.
Ok. And it is. Thanks for helping to narrow this down,
Kind regards,

@_date: 2017-07-20 20:04:48
@_author: Dirk-Willem van Gulik 
@_subject: (pre)cache password rather than use allow-loopback-pinentry  
With gpg2; it seems that as soon as you cat a batch.command sequence in - one can no longer use a pure terminal style TTY approach to having the agent fetch your password (gpg: signing failed: Inappropriate ioctl for device, gpg: make_keysig_packet failed: Inappropriate ioctl for device) as soon as the TTY is used for the patch file.
Instead on 2.1.15 one has to use allow-loopback-pinentry in the gpg-agent.conf to make constructs such as:
possible to make this work.  And that works fine.
Now obviously that leaves the tasks of getting the password to something to put it in file, filedescriptor or cmd-arg. Which is not ideal. As gpg-agent and pineentry are made for that.
So - is there any way to allow a (for the occasionally specially started gpg-agent) to ask and pre-cache the password ?
And then let the batch.commands (which does a complex dance of subkey renewal and some chip card shuffling) run against that ?
Or to somehow use a pure TTY based pinentry in such a setting (it is an off line machine with barely more than a serial connection).
Insights much appreciated !

@_date: 2017-07-21 10:05:22
@_author: Dirk-Willem van Gulik 
@_subject: (pre)cache password rather than use allow-loopback-pinentry 
Ok - I?ll need to investigate as to why this does work for our setting (auto renewal of expiry date of keys on chipcard (included below).
Thanks - that is a nice treasure trove you unearthed for me. Thanks !
So this we have working.
What I was hoping that there is a way to ?trigger? a ?real? pinentry request by gpg-agent (and allowing it to cache the result for N seconds) prior to going to gpg2 into command mode.  I.e. to warm up the cache.
As to rely as much as possible on the existing security of gpg-agent and its cache (cleanup) management.
set -e
if [ $# != 1 ]; then
        echo Syntax: $0 \ > /dev/stderr
        exit 1
if !  test -f $PWFILE; then
        echo No pwd $PWFILE > /dev/stderr
        exit 1
cat <

@_date: 2017-07-21 10:32:48
@_author: Dirk-Willem van Gulik 
@_subject: (pre)cache password rather than use allow-loopback-pinentry 
Those ?quick commands are a huge help. The one thing missing seems to be one for the routine extension of the expiry of subkeys.
Or is there a clever syntax for the ?fpr of the primary key to refer to a subkey by number or otherwise (referring to it by fingerprint gives me a ? is not the primary fingerprint? ?
Kind regards,

@_date: 2017-07-21 11:37:06
@_author: Dirk-Willem van Gulik 
@_subject: (pre)cache password rather than use allow-loopback-pinentry 
Thanks. That is exactly what I am doing ? updating the scripts to move from disk-based to openpgp card applets.
Keep up the good work! That december/2.1.17 addition made things a lot simpler already.
And I really would not mind to be able to refer to subkeys by number -and- fpr; as the fpr of a subkey is a but cumbersome to extract afaik (double ?fingerprint).

@_date: 2017-07-29 20:24:07
@_author: Dirk-Willem van Gulik 
@_subject: (pre)cache password rather than use allow-loopback-pinentry 
Works absolutly spendlidly (tested in 2.1.22 on openbsd). And has made things much more robust with smart-card subkeys.
Thanks !
Lovely. Is there any way one can suppress the fingerprint of the primary key (as when doing line oriented things; bith the ?sec? and ?ssb? line are followed by structurally identical ?fpr? lines)?

@_date: 2017-07-30 12:39:34
@_author: Dirk-Willem van Gulik 
@_subject: gpgsm, keygrip 
Tools such as require the 40 character keygrip. The manpage of gpg-preset-passphrase(1) suggest that this is best extracted from and that works nicely
 gpgsm --dump-secret-key | grep keygrip:
      keygrip: 1234567890123456789012345678901234567890
however a 'nice to parse' version of that:
does not seem to emit the keygrip.
Any way of rectifying that - or another place to get the keygrip in a robust parsable format ?

@_date: 2017-07-30 14:52:14
@_author: Dirk-Willem van Gulik 
@_subject: gpgsm, keygrip 
Replying to my own question ? the man page of of gpg-preset-passphrase  should perhaps suggest to use ?gpg ?with-keygrip ..? or ?gpg ?with-colons ..?.

@_date: 2017-07-30 15:26:33
@_author: Dirk-Willem van Gulik 
@_subject: caching of keys (passwords) during signing v.s. during 
When I pre-cache a password of a fresh key:
I find that this works spendidly on a normal sign operations
but fails on a quick-key-add:
Which then goes into the usual pinentry sequence (which completes fine when given the password).
The gpg-agent.conf has longish TTLs and lax settings:
Is there any setting that needs to be added to allow the ?special? sort of sign case ?
With kind regards.
set -e
set -x
export DAYS=5
export SUBDAYS=2
# Use an emphemeral disk if we can.
if test -f /usr/bin/hdiutil; then
       		/usr/bin/hdiutil hdiutil create -attach -stdinpass -quiet \
       		-encryption -size $SIZE -fs HFS+ \
       		-volname ${VOLNAME} ${TMPSTORE} export GNUPGHOME cat > ${GNUPGHOME}/gpg-agent.conf <<EOM
# Bit annoying we need this - despite no user interaction.
pinentry-program /usr/bin/pinentry-curses
default-cache-ttl 300
max-cache-ttl 300
# batch
debug-level guru
log-file /tmp/sc.log
${PGP} --verbose --homedir ${GNUPGHOME} \
set $( ${PGP} --homedir ${GNUPGHOME} --list-secret-keys --with-colons | grep ^fpr: )
LEN=$(/bin/echo -n $FPR | wc -c)
if [ $LEN -ne 40 ]; then
# gpg-preset-passphrase
# set $(${SM} --homedir ${GNUPGHOME} --dump-secret-key | grep keygrip:)
# KEYGRIP=${2}
# set $( gpg-connect-agent --homedir ${GNUPGHOME} 'keyinfo --list' /bye | head -1 )
# KEYGRIP=${3}
set $( ${PGP} --homedir ${GNUPGHOME} --with-keygrip --list-secret-keys --with-colons | grep ^grp: )
${PRESET} --homedir ${GNUPGHOME} --preset -P "${PASSWD}" ${KEYGRIP} # Chehck that siging forks.
echo foo | ${PGP} --homedir ${GNUPGHOME} --sign --armour ${PGP} --homedir ${GNUPGHOME} \
       --batch  \
       --quick-add-key \
${PGP} --homedir ${GNUPGHOME} \
       --batch \
       --quick-add-key \
${PGP} --homedir ${GNUPGHOME} \
       --batch \
       --quick-add-key \
${PGP} --homedir ${GNUPGHOME} \
? lots of validation stuff snipped ?.
gpgconf --kill gpg-agent
gpgconf --kill scdaemon
gpgconf --kill dirmngr
if test -f /usr/bin/hdiutil; then
exit $E

@_date: 2017-07-30 19:29:29
@_author: Dirk-Willem van Gulik 
@_subject: Scripted reset of PINs on smartcards. 
Am I right in understanding that, unless one wants to get into chat-expect and a fair bit of state logic behind a `fake? pinentry ? one cannot easily edit the PINs on a (fresh) smartcard by piping in a command sequence?
And in order to do so - does one really have to talk to the scdaemon directly ? Or is there a way to pass the (binary) PINs? through a normal gpg-connect-agent channel (with the SCD prefix) ?
# Factory default
# Reset the OpenPGP applet on the card.
cat <<EOM | gpg-connect-agent
scd serialno
??..snipped ?..
scd apdu 00 44 00 00
# Set the PINs to non-factory defaults.
) |  nc -U  $XXXX/S.scdaemon

@_date: 2017-07-30 22:19:22
@_author: Dirk-Willem van Gulik 
@_subject: 'sign (and cert)' or just 'cert' on a master key with subkeus 
I see a growing number of keys that have well managed & expired separate subkeys for Signing, Encryption and Authentication switch from ?SC? on the master key to just ?C? (all RSA, ignoring DSA).
Would anyone know if there is some documented best practice ?

@_date: 2017-07-31 17:49:00
@_author: Dirk-Willem van Gulik 
@_subject: 'sign (and cert)' or just 'cert' on a master key with subkeus 
For what it is worth - the various best practices at `riseup.net?[1] seem to strike a good middle ground.
This was also were my question came form; while historically (given DSA & patents of that time) it made sense to have S or SC on the master key ? the contemporary use seems to be mainly ?C?.
So one could surmise that the historic default of SC for a non DSA (e.g. RSA or ECC) is a bit out of date.
Hence the question as to what good practice is today.
1:   et.al.

@_date: 2018-11-01 18:42:43
@_author: Dirk-Willem van Gulik 
@_subject: Slightly OT - i need the proper wording for a signed document 
May just be stumbling over a specific extension. We had to do
a few years ago for a few edgecases at D-Trust.

@_date: 2019-08-21 21:43:58
@_author: Dirk-Willem van Gulik 
@_subject: BSI withdraws approval of GnuPG for confidential documents 
FWIIW - in the past I've found the BSI a highly professional & responsible organisation - with key staff answering (every very detailed technical questions) very quickly, comprehensively and in great technical detail.
So I would just ask.

@_date: 2019-12-09 18:21:20
@_author: Dirk-Willem van Gulik 
@_subject: v2.1 openpgp smartcard -- packing in after a `key to card' 
During a pretty standard create key; key to card cycle (scripted) - I got an error
just after the ?save? in the ?edit-key. A subsequent status check gives me:
with below scdaemon log information. The key moved onto it was a rsa1024 key:
i.e the second of (key 1):
Does this ring a bell with anyone ? With kind regards,
2019-12-09 18:15:06 scdaemon[47159] DBG: chan_7 <- GETINFO version
2019-12-09 18:15:06 scdaemon[47159] DBG: chan_7 -> D 2.2.17
2019-12-09 18:15:06 scdaemon[47159] DBG: chan_7 -> OK
2019-12-09 18:15:06 scdaemon[47159] DBG: chan_7 <- SERIALNO openpgp
2019-12-09 18:15:06 scdaemon[47159] ccid open error: skip
2019-12-09 18:15:06 scdaemon[47159] ccid open error: skip
2019-12-09 18:15:06 scdaemon[47159] ccid open error: skip
2019-12-09 18:15:06 scdaemon[47159] detected reader 'SCM Microsystems Inc. SPR 532'
2019-12-09 18:15:06 scdaemon[47159] detected reader 'ACS ACR122U PICC Interface'
2019-12-09 18:15:06 scdaemon[47159] detected reader 'OMNIKEY AG CardMan 3121'
2019-12-09 18:15:06 scdaemon[47159] reader slot 0: not connected
2019-12-09 18:15:07 scdaemon[47159] pcsc_control failed: not transacted (0x80100016)
2019-12-09 18:15:07 scdaemon[47159] pcsc_vendor_specific_init: GET_FEATURE_REQUEST failed: 65547
2019-12-09 18:15:07 scdaemon[47159] reader slot 0: active protocol: T1
2019-12-09 18:15:07 scdaemon[47159] slot 0: ATR=3B DA 18 FF 81 B1 FE 75 1F 03 00 31 C5 73 C0 01 40 00 90 00 0C
2019-12-09 18:15:07 scdaemon[47159] AID: D2 76 00 01 24 01 02 01 00 05 00 00 57 2D 00 00
2019-12-09 18:15:07 scdaemon[47159] Historical Bytes: 00 31 C5 73 C0 01 40 05 90 00
2019-12-09 18:15:07 scdaemon[47159] Version-2+ .....: yes
2019-12-09 18:15:07 scdaemon[47159] Extcap-v3 ......: no
2019-12-09 18:15:07 scdaemon[47159] Button .........: no
2019-12-09 18:15:07 scdaemon[47159] SM-Support .....: no
2019-12-09 18:15:07 scdaemon[47159] Get-Challenge ..: yes (2048 bytes max)
2019-12-09 18:15:07 scdaemon[47159] Key-Import .....: yes
2019-12-09 18:15:07 scdaemon[47159] Change-Force-PW1: yes
2019-12-09 18:15:07 scdaemon[47159] Private-DOs ....: yes
2019-12-09 18:15:07 scdaemon[47159] Algo-Attr-Change: yes
2019-12-09 18:15:07 scdaemon[47159] Symmetric Crypto: no
2019-12-09 18:15:07 scdaemon[47159] KDF-Support ....: no
2019-12-09 18:15:07 scdaemon[47159] Max-Cert3-Len ..: 2048
2019-12-09 18:15:07 scdaemon[47159] Cmd-Chaining ...: no
2019-12-09 18:15:07 scdaemon[47159] Ext-Lc-Le ......: yes
2019-12-09 18:15:07 scdaemon[47159] Status-Indicator: 05
2019-12-09 18:15:07 scdaemon[47159] GnuPG-No-Sync ..: no
2019-12-09 18:15:07 scdaemon[47159] GnuPG-Def-PW2 ..: no
2019-12-09 18:15:07 scdaemon[47159] Key-Attr-sign ..: RSA, n=2048, e=32, fmt=std
2019-12-09 18:15:07 scdaemon[47159] Key-Attr-encr ..: RSA, n=1024, e=32, fmt=std
2019-12-09 18:15:07 scdaemon[47159] Key-Attr-auth ..: RSA, n=2048, e=32, fmt=std
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S SERIALNO D27600012401020100050000572D0000
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> OK
2019-12-09 18:15:07 scdaemon[47159] sending signal 31 to client 47158
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 <- LEARN --force
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S READER OMNIKEY AG CardMan 3121
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S SERIALNO D27600012401020100050000572D0000
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S APPTYPE OPENPGP
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S EXTCAP gc=1+ki=1+fc=1+pd=1+mcl3=2048+aac=1+sm=0+si=5+dec=0+bt=0+kdf=0
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S DISP-NAME
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S DISP-LANG de
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S DISP-SEX 9
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S KEY-FPR 2 26CFCE98D4681687B9665A273341725A21249687
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S KEY-TIME 2 1575909434
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S CHV-STATUS +0+32+32+32+3+0+3
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S SIG-COUNTER 0
2019-12-09 18:15:07 scdaemon[47159] pcsc_transmit failed: not transacted (0x80100016)
2019-12-09 18:15:07 scdaemon[47159] apdu_send_simple(0) failed: general error
2019-12-09 18:15:07 scdaemon[47159] reading public key failed: General error
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> S KEYPAIRINFO 2AF8CE28A1F0B6E3194C2505C682357407ACC3B3 OPENPGP.2
2019-12-09 18:15:07 scdaemon[47159] pcsc_transmit failed: not transacted (0x80100016)
2019-12-09 18:15:07 scdaemon[47159] apdu_send_simple(0) failed: general error
2019-12-09 18:15:07 scdaemon[47159] reading public key failed: General error
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> OK
2019-12-09 18:15:07 scdaemon[47159] sending signal 31 to client 47158
2019-12-09 18:15:07 scdaemon[47159] DBG: Removal of a card: 0
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 <- READKEY OPENPGP.2
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> ERR 100663406 Card removed 2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 <- RESTART
2019-12-09 18:15:07 scdaemon[47159] DBG: chan_7 -> OK

@_date: 2019-12-26 23:04:16
@_author: Dirk-Willem van Gulik 
@_subject: Automatically generating subkey revocation certificates 
When you generate the main key (even with a programmatic --quick-key-generate) - it nicely puts revocation certificats in the revocs.d directory of GNUPGHOME.
But this does not seem to happen when doing a --quick-add-key subkey. Is this intentional ? Or is there a flag one can set ?

@_date: 2019-12-26 23:06:26
@_author: Dirk-Willem van Gulik 
@_subject: Reason string revocation 
Is there a flag that shows you the 'reason/explanation' string and cause when examining a revocation msg with gpg2 ?
It seems that both --import and a simple 'gpg2 revoc.asc' show you the key - but not the rest of the info ?
PS: and while on the topic - is there a deeper reason that --no-armour does not work on revoc generation ?

@_date: 2019-12-27 20:59:52
@_author: Dirk-Willem van Gulik 
@_subject: Automatically generating subkey revocation certificates 
Thanks - had not though of it in that fashion (in our use case - the governance is a bit less personal - and we want to be able to revoke a sub-key without much (additional) interaction -- so pre-generating them & leaving them domestic makes sense).

@_date: 2019-02-01 20:01:58
@_author: Dirk-Willem van Gulik 
@_subject: OpenPGP on paper (was: Where can I find some papers to read on 
Yes - if you look at the next  pages in the example - that is what is being done there.
With specific care taken to minimise what one has to enter.
So one can either OCR the written text, use the QR code or enter it by hand.
Over the years we've come to rely on this a lot - and regularly had to resort to manual entry or OCR ing of the numbers.

@_date: 2019-02-01 17:53:09
@_author: Dirk-Willem van Gulik 
@_subject: OpenPGP on paper (was: Where can I find some papers to read on 
It is a bit of a hack - and quite setting specific for us - but we?ve been using
and had to occasionally recover keys (every few years or so).
Typical output below.

@_date: 2020-12-22 14:54:40
@_author: Dirk-Willem van Gulik 
@_subject: Rationale/reasons for splitting Sign and Authenticate into two 
Keep in mind that in some workplaces the building of that trust explicitly includes the need for counter-intelligence - and hence a legitimate use of fake signatures.
Though I have a hard time imagining a use case in the european private sector for that.

@_date: 2020-12-22 16:19:47
@_author: Dirk-Willem van Gulik 
@_subject: Rationale/reasons for splitting Sign and Authenticate into two 
It is a very common requirement that you find in gov. procurement documents/requirements of cryptographic technology that lives in a chipcard, HSM, etc -- the need to be able to forge signatures for counter intelligence.
