
@_date: 2016-08-21 00:11:45
@_author: Karol Babioch 
@_subject: Deleting SSH key(s) from agent 
Hi all,
I'm experimenting with using GPG as SSH agent. This basically works
fine, although I'm missing some advanced features, which the original
ssh-agent(1) provides.
More specifically it seems to be impossible to delete identities from
the agent once they are added. ssh-add -D returns: "All identities
removed.". However, it is actually not removed and is still available
It seems to be possible to deactivate the key through the sshcontrol
file, i.e. by commenting it out. While this removes it temporarily from
the agent, simply commenting it back in, activates the key again, At
least as long as the TTL is not yet expired. All in all this is not a
great solution.
The same is true for locking the agent down. This feature seems to be
not implemented at all. I can lock the agent, but it makes no difference
whether or not it is actually locked or unlocked, it always operates
Are these "advanced" features simply not implemented, or am I missing
something here? How are you dealing with this?
Thanks in advance!
Best regards,
Karol Babioch

@_date: 2016-08-23 02:54:39
@_author: Karol Babioch 
@_subject: OpenPGP Smartcard recommendations 
Am 22.08.2016 um 23:22 schrieb Anthony Papillion:
I'm pretty sure you've done something wrong here. I just placed and
received an order last week.
Besides the smartcards from kernelconcepts, you can also become an FSFE
member to get such a card [1].
Personally I absolutely love the YubiKey (4 Nano) [2]. It meets all of
your criteria and can do a lot more (U2F, PIV, token, HOTP, TOTP, etc.).
It is also a lot smaller than a real smartcard and can be left in the
USB port all of the time. The Gemalto USB token (and/or real smartcards)
are rather unhandy - at least for me.
Best regards,
Karol Babioch
P.S.: I should also mention that there is some debate about the open
source nature of the YubiKey 4, since its firmware is not open to review
any longer. Should this be a criterion for you, you have to go with
another solution. You'll find details on the story at [3].
[1]: [2]: [3]:

@_date: 2016-08-23 10:20:58
@_author: Karol Babioch 
@_subject: Deleting SSH key(s) from agent 
Am 21.08.2016 um 12:27 schrieb Peter Lebbing:
Thank you very much. I even knew about gpg-connect-agent, but didn't
connect the dots. I was too focussed on getting it to work through the
ssh-add interface. It does indeed work as outlined.
However it seems to be more complicated than before, since I need to
keep track of keygrips now. How are you guys dealing with multiple SSH
keys while making sure the correct one is being used?
Best regards,
Karol Babioch

@_date: 2016-08-23 10:46:24
@_author: Karol Babioch 
@_subject: Deleting SSH key(s) from agent 
Am 23.08.2016 um 10:36 schrieb Peter Lebbing:
I'm pretty sure you are right, so this is not my concern.
However, it is annoying to be prompted for passphrases for each key in
the keyring. This is even true for cases in which the public key of my
smartcard is the first and only entry in authorized_keys on a SSH server.
ssh-add -L lists the public key of my smartcard also first in the first
place, so I'm not sure why I always get asked for other keys. On the
other hand I do not want to have keys lying around unencrypted on disk.
I could possibly get away with making a configuration using the
Identity* directives from ssh_config(5), but this seems to be a PITA.
Is it somehow possible for gpg-agent to _NOT_ ask for passphrases it
does not need, e.g. to enforce that the smartcard is tried first for
Best regards,
Karol Babioch

@_date: 2016-08-23 11:51:33
@_author: Karol Babioch 
@_subject: SSH agent prompts for all passphrases 
Hi again,
Am 23.08.2016 um 11:29 schrieb Peter Lebbing:
Ok, it was my mistake. Looking through the verbose output of the SSH
client, I realized that I'm using a jump host, which still had my other
public keys in authorized_keys, so I was being asked for the appropriate
passphrase. Removing them fixed this.
However, there is still something that bothers me. The client offers the
disk-based keys first (id_rsa, id_ed25519, etc.). This is not a problem
in case only the smartcard's key is stored in authorized_keys, but as
soon as I put a fallback key there, it is being offered first and I'm
asked for the passphrase.
Can I somehow control the order in which the client presents its keys to
the server? Is this something the agent controls, or the SSH client itself?
Thanks again for your help, it is very much appreciated.
Best regards,
Karol Babioch

@_date: 2016-08-23 12:51:20
@_author: Karol Babioch 
@_subject: OpenPGP Smartcard recommendations 
since we are commenting here, I want to put out my two cents also, as
this is a topic I'm deeply interested in.
Am 23.08.2016 um 11:17 schrieb Peter Lebbing:
Yes, this is a problem, and to my knowledge there are no real solutions
to it. Even with software alone its hard to verify that the binary you
are running was indeed built from the correct source (i.e. reproducible
builds), but with firmware and hardware devices it gets pretty much
impossible. Open source is fine and dandy, but it doesn't solve this
problem. And I'm saying this as a big open source enthusiast.
Yes, you are absolutely right and I think the blog post is mixing things
up here. Not making the source available has nothing to do with
field-updatable firmware.
I'm playing a little bit of a devil's advocate here. In general I would
agree with your statement. Security by obscurity is a bad idea.  No one
should come up with a new secret encryption standard and claim that it
is secure. It has been shown time and again that these claims are mostly
bullshit. These things should, as you said, be completely open, peer
reviewd, pounded upon and only rely on a secret key.
However for me this mostly applies to the cryptographic concepts itself
and maybe software implementing them, not necessarily to physical
devices that have to withstand various forms of physical attacks. When
it comes to the real world, I'm not sure if this concepts holds
completely true, though.
If the revelations of Snowden taught us anything, than that it is hard
to implement crypto correctly in the real world. Yes, RSA, AES and such
are probably computationally secure enough, so that even the NSA cannot
break it. However, they don't have to, because in the real world there
are easier ways.
For the most part, not attacking the crypto system itself is the
weakness, but various side channels and other indirect vectors like
that. I tend to think that hidden "traps" in a hardware design do
actually improve security, and consider this to be kind of a
defense-in-depth approach. We shouldn't rely too much on "secret
sausage", but it definitely makes things harder for attackers when they
do not know everything about a hardware design and have to reverse
engineer it for themselves. This way key material can be wiped and
hardware destroyed when tampering is detected. This costs them time and
money, and hence reduces the potential revenue.
I think a good analogy is the design of alarm systems and safes. Usually
you won't find too much details about such things and they kind of rely
on the fact that an attacker does not know too much about it.
Obviously there are limits to this and I would like to be convinced
otherwise, but in the end it always comes down to trust, e.g. in this
case: Do you trust Yubico to have done everything that is reasonably
possible to protect your keys.
Once again I'm not sure if the real world is black-and-white like this.
Just making something "open source" is not making it secure. Take the
recent PRNG vulnerability in GnuPG as example (CVE-2016-6313). It was
there for nearly two decades, and nobody spotted it.
Obviously the same is true for all certifications and a hardware device
is not secure, just because it is certified. Unfortunately these
certifications (e.g. things like Common Criteria) are basically the only
thing we have to make sure a product is designed with security in mind.
It makes sure that there are clearly defined goals that can be met,
tested and implemented. It makes sure that the people involved
understand a thing or two about security and products tend to be better
(i.e. more secure) with higher levels of certifications.
Once again, I'm playing the devil's advocate here. I'm in no way, shape
or form connected with Yubico and do not want to defend them, but I
think arguments can be made for both sides here.
Best regards,
Karol Babioch

@_date: 2016-08-23 14:03:07
@_author: Karol Babioch 
@_subject: SSH agent prompts for all passphrases 
Am 23.08.2016 um 12:03 schrieb Peter Lebbing:
After having played around with this for a while, I could solve this in
the following way. I've created a pub file containing the public key of
my smartcard and placed an appropriate IdentityFile directive within the
ssh configuration file, so my smartcards gets now used by default.
Seems to work fine, so I'm quite happy with my setup now.
Thanks again.
Best regards,
Karol Babioch

@_date: 2016-07-05 17:55:47
@_author: Karol Babioch 
@_subject: Migrating key to smartcard 
I've recently bought an OpenPGP smartcard and am now looking into ways
to migrate my existing key onto this smartcard. I've created my key a
couple of years back and have gathered some signatures, so I don't want
to start over.
Right now I have a master key with the "SC" key usage flags and a subkey
for encryption ("E" key usage flag). Both of them are RSA 4096 keys.
The smartcard expects three different keys, though: One for signing,
encrypting and authenticating. What is the recommended way to migrate to
the smartcard? I've read some threads about hacking the source code to
be able to change the key usage for keys, and I'm fine with that.
However, I'm not exactly sure what the end result should look like.
Right now I'm thinking of creating two new subkeys (one for signatures,
one for authentication) and signing them with the _old_ master key. I
would also re-use the old sub-key for encryption (since it already has
the "E" flag set and is well known). Then I would remove the master key
from the computer (storing it only offline). I would then move the
identity (including subkeys) onto the smartcard and remove the private
keys from my keyring.
Is this a good approach? Are there other and/or better ways? I'm also
not sure what I would need the master key from this point onward. Since
I would have a subkey with the "S" flag, couldn't I use this for signing
other keys? Or would I still need to sign other keys with my master key?
I'm grateful for any clarification and some hints. Thanks in advance.
Best regards,
Karol Babioch

@_date: 2016-07-05 21:27:57
@_author: Karol Babioch 
@_subject: Migrating key to smartcard 
Am 05.07.2016 um 20:07 schrieb Damien Goutte-Gattat:
Ok, although I quite don't like the idea and prefer option That sounds more reasonable to me, since my master key would be
completely offline and only be used on the rare occasions when signing
other keys. I could even use an offline computer for that purpose.
Yes, I want to use for SSH authentication.
I know that, but thanks for the reminder.
I knew this as well. I was referring to putting a set of keys into the
smartcard when talking about "moving my identity".
Is this a limitation of GPG and my premises or is this something
inherent to the OpenPGP standard? With other public-key infrastructures
(e.g. X509) it is perfectly fine to use signed (sub)keys to sign other
keys and building chains in this very way. This would allow me to use
the GPG smartcard for basically everything (including signing other keys).
Storing the master key offline and having to import it whenever I want
to sign other keys might actually decrease security, since it offers
enough of a possiblity to mess things up (e.g. forget to remove it again
or for malware to get ahold of it, since its only bits in memory (and/or
on the storage device).
Thanks for your input so far, its very much appreciated!
Best regards,
Karol Babioch

@_date: 2016-09-06 09:17:41
@_author: Karol Babioch 
@_subject: How to detect patched versus bugged gpg binary 
Am 06.09.2016 um 06:43 schrieb Mike Ingle:
Yes, I'm afraid that is the only feasible way - at least to my knowledge.
You could also check some hashes. However dpkg (AFAIK) does not offer an
"--verify" option, so you have to do it for your own. Apparently some
checksums are also stored in /var/lib/dpkg/info/.md5sums, but
probably not all. Furthermore there is a debsums package [1].
First of all you obviously need to browse the package sources and try to
find out which version(s) have a particular patch already applied.
Best regards,
Karol Babioch
P.S.: My personal opinion: The whole Debian approach is a mess. Rather
than contributing upstream and trying to improve the code there, they
are making frankenstein builds that were never intended in this way by
the upstream projects. Nobody knows which patches they do and do not
backport and in general Debian packages are massively outdated.
