
@_date: 1999-08-26 18:40:52
@_author: Frank Tobin 
@_subject: Trusted... NOT! 
You need to verify the key also, either by having the secret key for it,
or by signing the public key.

@_date: 1999-08-31 10:19:30
@_author: Frank Tobin 
@_subject: Scripting and CGI use of GPG 
Visit the all-encompassing CPAN (  There are a couple

@_date: 1999-08-26 18:40:52
@_author: Frank Tobin 
@_subject: Trusted... NOT! 
You need to verify the key also, either by having the secret key for it,
or by signing the public key.

@_date: 1999-08-31 10:19:30
@_author: Frank Tobin 
@_subject: Scripting and CGI use of GPG 
Visit the all-encompassing CPAN (  There are a couple

@_date: 1999-12-01 16:23:44
@_author: Frank Tobin 
@_subject: New UK crypto law and an idea on how to defeat it 
Hash: SHA1
Billy Donahue, at 17:11 on Wed, 1 Dec 1999, wrote stuff.
I don't want to step too far out of line here, but I think this thread is
starting to really get out of line with its purposes, and I
recommend that it stop here.
There are better places for these privacy-related discussions than the
GnuPG users list (e.g., cypherpunks).
Please only reply to this off list.

@_date: 1999-12-21 22:57:51
@_author: Frank Tobin 
@_subject: gpg from cronjobs 
Hash: SHA1
Personally, I just say go for the key without a passphrase.
Here's thoughts on the issue:
Normally, the security of your secret keys relies on the usage two things,
the security of your system, and the security of the passphrase in your
head.  The passphrase you use for your key really isn't necessary to the
use of OpenPGP; it's just a security mechanism for your protecting your
secret key.  Regardless, abiding by convention and using a passphrase to
encrypt your secret key requires that two different things be compromised
before your OpenPGP communication is compromised, and having layring in
security like this gives people a warm feeling all over.
In your case, you are trying to achieve communication using OpenPGP
without securing your private key withou a passphrase.  Now, assuming you
were just communicating between two points, this could be just as bad as
using a human-generated secret passphrase; in this example, the secret of
the communication is probably more easily broken by brute-forcing the
shared secret passphrase or breaking into the system.  However, in your
case, the security of your OpenPGP communication is reliant soley on the
security of your system, and this could be a very, very, very bad thing,
especially if you have any idea how often various vulnerabilities become
exposed for virtutally ever operating system.
If this is sensitive information, the only hope of really keeping your
system secure is for no users to be on the system, and no daemons are run
on the system; get your information from a 'suck' (e.g., wget), and hope
your wget program is secure; preferably, run it in a tight, tight
environment (I smell chroot).
Of course, if this really isn't that sensitive sensitive enough of
information, you are free to use it on your normal machine without all the
lockdowns of disabling your daemons and users; however, your vunerability
points skyrocket when doing so (especially whlie having local
users).  Just keep in mind the security of your communications is is
solely reliant on the ability of someone not being able to break your

@_date: 1999-12-01 16:23:44
@_author: Frank Tobin 
@_subject: New UK crypto law and an idea on how to defeat it 
Hash: SHA1
Billy Donahue, at 17:11 on Wed, 1 Dec 1999, wrote stuff.
I don't want to step too far out of line here, but I think this thread is
starting to really get out of line with its purposes, and I
recommend that it stop here.
There are better places for these privacy-related discussions than the
GnuPG users list (e.g., cypherpunks).
Please only reply to this off list.

@_date: 1999-12-21 22:57:51
@_author: Frank Tobin 
@_subject: gpg from cronjobs 
Hash: SHA1
Personally, I just say go for the key without a passphrase.
Here's thoughts on the issue:
Normally, the security of your secret keys relies on the usage two things,
the security of your system, and the security of the passphrase in your
head.  The passphrase you use for your key really isn't necessary to the
use of OpenPGP; it's just a security mechanism for your protecting your
secret key.  Regardless, abiding by convention and using a passphrase to
encrypt your secret key requires that two different things be compromised
before your OpenPGP communication is compromised, and having layring in
security like this gives people a warm feeling all over.
In your case, you are trying to achieve communication using OpenPGP
without securing your private key withou a passphrase.  Now, assuming you
were just communicating between two points, this could be just as bad as
using a human-generated secret passphrase; in this example, the secret of
the communication is probably more easily broken by brute-forcing the
shared secret passphrase or breaking into the system.  However, in your
case, the security of your OpenPGP communication is reliant soley on the
security of your system, and this could be a very, very, very bad thing,
especially if you have any idea how often various vulnerabilities become
exposed for virtutally ever operating system.
If this is sensitive information, the only hope of really keeping your
system secure is for no users to be on the system, and no daemons are run
on the system; get your information from a 'suck' (e.g., wget), and hope
your wget program is secure; preferably, run it in a tight, tight
environment (I smell chroot).
Of course, if this really isn't that sensitive sensitive enough of
information, you are free to use it on your normal machine without all the
lockdowns of disabling your daemons and users; however, your vunerability
points skyrocket when doing so (especially whlie having local
users).  Just keep in mind the security of your communications is is
solely reliant on the ability of someone not being able to break your

@_date: 1999-07-08 16:25:45
@_author: Frank Tobin 
@_subject: comments 
Hash: SHA1
This solution worked for me on HP/UX 10.20.  However, for me, in
g10/Makefile, I changed -lz to ../zlib/libzlib.a instead of -l../libzlib.a
(two differences: no -l and the zlib dir is added).

@_date: 1999-07-17 16:51:09
@_author: Frank Tobin 
@_subject: strange behavior when encrypting 
BTW, this option '--always-trust' is not specified in the 0.9.8 manpage.

@_date: 1999-07-21 12:08:44
@_author: Frank Tobin 
@_subject: Encrypting Web Forms 
Hash: SHA1
One should have a key which is solely meant for use on that machine by
root-running scripts, with no password; the concept behind this is that
any signed messages are just as verifiable as secure as the root account
of the machine, and no more.  If root was broken into, then there could be
many more modifications.

@_date: 1999-07-28 11:57:09
@_author: Frank Tobin 
@_subject: large pub key import 
Hash: SHA1
0.9.9 compiles fine under FreeBSD 3.2-STABLE, using BSD make, from the
ports tree. FreeBSD 2.2.7 is well out of date, and not supported anymore.  I recommend that the user upgrade to at least FreeBSD 2.2.8-STABLE and try
compiling then from the ports tree.  I do note these lines from the FBSD
ports tree:
CONFIGURE_ARGS= --with-included-gettext
.if ${OSVERSION} < 300000

@_date: 1999-07-31 00:28:20
@_author: Frank Tobin 
@_subject: gpg: Warning: using insecure memory! 
Hash: SHA1
You have two options; either make the gpg binary setuid root so it can do
memory-locking (preferred), or have simply have gpg not print out the
error message by putting the following line in your ~/.gnupg/options file:
Note: this option is not documented in the 0.9.9 manpage.

@_date: 1999-07-08 16:25:45
@_author: Frank Tobin 
@_subject: comments 
Hash: SHA1
This solution worked for me on HP/UX 10.20.  However, for me, in
g10/Makefile, I changed -lz to ../zlib/libzlib.a instead of -l../libzlib.a
(two differences: no -l and the zlib dir is added).

@_date: 1999-07-17 16:51:09
@_author: Frank Tobin 
@_subject: strange behavior when encrypting 
BTW, this option '--always-trust' is not specified in the 0.9.8 manpage.

@_date: 1999-07-21 12:08:44
@_author: Frank Tobin 
@_subject: Encrypting Web Forms 
Hash: SHA1
One should have a key which is solely meant for use on that machine by
root-running scripts, with no password; the concept behind this is that
any signed messages are just as verifiable as secure as the root account
of the machine, and no more.  If root was broken into, then there could be
many more modifications.

@_date: 1999-07-28 11:57:09
@_author: Frank Tobin 
@_subject: large pub key import 
Hash: SHA1
0.9.9 compiles fine under FreeBSD 3.2-STABLE, using BSD make, from the
ports tree. FreeBSD 2.2.7 is well out of date, and not supported anymore.  I recommend that the user upgrade to at least FreeBSD 2.2.8-STABLE and try
compiling then from the ports tree.  I do note these lines from the FBSD
ports tree:
CONFIGURE_ARGS= --with-included-gettext
.if ${OSVERSION} < 300000

@_date: 1999-07-31 00:28:20
@_author: Frank Tobin 
@_subject: gpg: Warning: using insecure memory! 
Hash: SHA1
You have two options; either make the gpg binary setuid root so it can do
memory-locking (preferred), or have simply have gpg not print out the
error message by putting the following line in your ~/.gnupg/options file:
Note: this option is not documented in the 0.9.9 manpage.

@_date: 1999-11-03 00:18:30
@_author: Frank Tobin 
@_subject: detached-signature fd 
Hash: SHA1
Similar to the --status-fd, and --passphrase-fd, is there an undocumented
option for passing in detached-signature information?  For the purposes of
scripting, passing in a filename is very inconvenient; piping is
preferred.  Has this been designed yet, and if not, could I ask it to be
put on the wishlist?

@_date: 1999-11-03 00:18:30
@_author: Frank Tobin 
@_subject: detached-signature fd 
Hash: SHA1
Similar to the --status-fd, and --passphrase-fd, is there an undocumented
option for passing in detached-signature information?  For the purposes of
scripting, passing in a filename is very inconvenient; piping is
preferred.  Has this been designed yet, and if not, could I ask it to be
put on the wishlist?

@_date: 1999-10-13 09:42:03
@_author: Frank Tobin 
@_subject: Diable comment string on a per-message basis? 
Hash: SHA1
Oops, my bad.  That'll teach me to assume things.

@_date: 1999-10-13 09:42:03
@_author: Frank Tobin 
@_subject: Diable comment string on a per-message basis? 
Hash: SHA1
Oops, my bad.  That'll teach me to assume things.

@_date: 1999-09-04 04:20:22
@_author: Frank Tobin 
@_subject: Single Private Key (not secret/public key pair) 
One doesn't generate to generate a key for these situations; the key
(possible mutated with a hash) is simply a passphrase, which gpg should
prompt you for when you use the -c flag.  Generating keys is only needed
for public/private keypairs.

@_date: 1999-09-04 04:20:22
@_author: Frank Tobin 
@_subject: Single Private Key (not secret/public key pair) 
One doesn't generate to generate a key for these situations; the key
(possible mutated with a hash) is simply a passphrase, which gpg should
prompt you for when you use the -c flag.  Generating keys is only needed
for public/private keypairs.

@_date: 2000-04-05 02:23:11
@_author: Frank Tobin 
@_subject: GPGnet? 
Hash: SHA1
Note that PGPnet has little to nothing to do with the OpenPGP protocol, or
even PGP in that matter.  The name PGPnet, I'm guessing, is more
marketting than anything else to get you to associate the security that
comes with PGP together with PGPnet, even though they are weakly related.

@_date: 2000-04-05 03:23:47
@_author: Frank Tobin 
@_subject: GPGnet? 
If you are calling PGP the entire suite of tools, there is no blanket
security that you can apply to the entire suite.  You have to break the
issue down more; you can't abstract it that much.  Saying PGPnet and the
unnamaed program that implements OpenPGP are equal is ridiculous; just
because they use similar algorithms has no effect on the possible
insecureness of the protocols involved.  Given your style of argument, I
could abstract the Kerberos and ssh systems (public key logins, to
simplify) to say that the protocols are as secure as one another (given
that they are using similar algorithms).

@_date: 2000-04-06 15:48:37
@_author: Frank Tobin 
@_subject: Key Generation 
What operating system are you running?  Different systems gather stuff for

@_date: 2000-04-06 16:13:19
@_author: Frank Tobin 
@_subject: Key Generation 
Hash: SHA1
On FreeBSD, you need to pass in IRQ's to rndcontrol(8) to get it to gather
entropy from other sources than the keyboard.  Boot-time settings to
rndcontrol(8) can be set in /etc/rc.conf; I have:
rand_irqs="1 10 12 14 15"       # Stir the entropy pool (like "5 11")
This depends on your hardware, of course.  I've got IDE devices, a PS/2
mouse, network and soundcard.  I forget which IRQ is for which device; I
used xosview to find out which IRQ's are doing something.

@_date: 2000-04-07 01:04:49
@_author: Frank Tobin 
@_subject: with-colons info 
Hash: SHA1
I've been going over the DETAILS file and the --with-colons information,
and I'm wondering about Field 2, which is used to indicate the calculated
trust/validity.  The value 'u' can be given for a uid's validity, which
means it is 'ultimately' trusted; however, if I'm not mistaken, uid's are
not trusted; they have calculated validity.  The use of the idea of
'ultimate trust' on a uid is confusing, I think; somehow we should be
conveying validty instead of trust.

@_date: 2000-04-07 01:22:03
@_author: Frank Tobin 
@_subject: successive calls to list-keys 
Hash: SHA1
If I make two successive calls to --list-keys and with-colons --list-keys,
can I be ensured that the keys presented will appear in the same
order, assuming the keyring is not altered by the user during this

@_date: 2000-04-10 14:18:54
@_author: Frank Tobin 
@_subject: Decrypting programmatically. 
This is not allowed because on pretty much all unixes one can see everyone
else's command-line arguments; hence, the passphrase could be seen by any
other user on the system.
The general way of passing in a passphrase to GnuPG is to do so via a
handle specified in the passphrase-fd option; I don't know if you can
accomplish this with Java though.  There are Perl modules that allow you
to accomplish this farily easily, though.

@_date: 2000-04-10 14:21:37
@_author: Frank Tobin 
@_subject: gpg to sign cgi output? 
I recommend using one of the several Perl modules on CPAN that are
designed for GnuPG interaction.

@_date: 2000-04-11 03:55:13
@_author: Frank Tobin 
@_subject: request for input on name of GnuPG Perl module 
Hash: SHA1
I'm currently in the process of almost releasing a totally reworked Perl
module to handle GnuPG; it's based off the same IPC-style ( communication
via handles ) as my PGP::GPG::MessageProcessor, but it is more powerful
and better designed (in particular it can fully parse --with-colons
information and can create useful "Key" objects).
Since the interface and powerfulness do much more than "message
processing", I've been tempted to call it PGP::GnuPG::Interface.  However, the bareword "PGP" is not that good of a choice, I feel, because
it is used to relate to NAI's product, which this module does not support.
OpenPGP::GnuPG::Interface might be okay, but there is the fact that my
module itself doesn't implement OpenPGP; GnuPG does that for me.  However, "OpenPGP" is a new top-level CPAN directory, so I'm hesitant to
use this, as I plan putting it on CPAN.
Simply GnuPG::Interface also is an option, but once again, GnuPG is a new
top-level CPAN name.
If anyone has comments on these possible names, or has good suggestions,
please let me know.

@_date: 2000-04-14 10:34:09
@_author: Frank Tobin 
@_subject: Compatibility 
Hash: SHA1
No, the nice thing about GnuPG is that it conforms to an
internet-recognized specification for exchanging OpenPGP messages.  This
standard is available for anyone to view and create a new implementation
of.  If these standards did not exist we wouldn't have working protocols
like TCP or HTTP.
Three are currently two major things which break compatibility:
encumbering patents, and PGP.
RSA and IDEA are not supported by default in GnuPG because they are not
free algorithms.  These are SHOULD's in the OpenPGP specifiction.  RSA
will likely be supported when the patent runs out this fall.  IDEA's
patent does not run out for several years.
NAI's PGP breaks the OpenPGP specifiction with it's new packets such as
the photo-id.  I can see that NAI wants to further extend the powers of
PGP, and that is fine with me; however, users should be aware that there
is an open standard with free implementations which anyone can use, and
that not abiding by this standard has a good chance of alienating those
who abide by it.
This the same reason why use of Word documents is highly discouraged over
other open, standards-based forms such as HTML; it would be silly to think
that HTML should try to replace Word, or compensate for it.  Sure, MS
wants to further the complexity and power of a Word document, but that
does not in any way mean that the designers of HTML should want or try to
Oh, and by the way, when I refer to free I mean Open Source Free.

@_date: 2000-04-14 10:47:51
@_author: Frank Tobin 
@_subject: Compatibility 
Hash: SHA1
Hehehe.  Of course, there is _nothing_ stopping Len from editing GnuPG
himself, making the modification, releasing, and continuing to track the
source, to see if users would prefer his modified version.  Mmmm, GPL'd
software, crunchy on the outside, soft and gooey in the middle :)

@_date: 2000-04-14 16:10:38
@_author: Frank Tobin 
@_subject: Compatibility 
Are you implying that creating unrestricted, free software is not a "vey
good reason"?  Remember, the FSF has strong philosophies which have
changed things for many of us, because of this good reason.
If this is true, I'll stop arguing this point; I'm sure you've become more
intimate with PGP's internals and the RFC than I have.

@_date: 2000-04-14 16:16:12
@_author: Frank Tobin 
@_subject: GPL & GnuPG 
I totally agree with you on this point.  However, I'm interpreting
Warner's statment as expressing his disappointment that people are
'foolishly' still trying to use the concept of license keys to restrict
software.  Kinda goes against everything the FSF is against; not that it
minds _that_much_ that people still exhausting energy trying :)

@_date: 2000-04-14 16:33:01
@_author: Frank Tobin 
@_subject: key storage 
Removable drives (e.g., floppy), or other input devices such as serial
ports provide a decent means of having an 'air-wall' between your secret
keys and the OpenPGP application when they are not in use.  There are a
whole bunch of fun/exotic/paranoid measures one could go to to protect
one's secret keys.  Lots of them cut down on your productivity,
though.  Pick your favorite game.

@_date: 2000-04-16 17:15:53
@_author: Frank Tobin 
@_subject: ann: release of GnuPG::Interface 0.01 
Hash: SHA1
I am pleased to announce the first release of GnuPG::Interface.  GnuPG::Interface, the successor to PGP::GPG::MessageProcessor, is a Perl
module interface to interacting with GnuPG.  It implements a rich set of
bidirectional communications with GnuPG through filehandles and includes a
rich GnuPG-key object organization structure, which has information filled
in by parsing GnuPG's key listing's with-colons option.
While this module is at 0.01, I have done extensive testing to help ensure
that the module works correctly.  Comments are welcomed.
The current homepage of GnuPG::Interface is at:

@_date: 2000-04-17 01:31:21
@_author: Frank Tobin 
@_subject: Determining Key Algorithm? 
Hash: SHA1
The "with-colons" options should achieve what you want.  Details are
spelled out in GnuPG's DETAILS file.

@_date: 2000-04-18 21:07:51
@_author: Frank Tobin 
@_subject: Unidentified subject! 
Hash: SHA1
As far as I know, there are no problems for cryptographic software
arriving in the US, only the other way around (and is changing, too, for
the better).
I don't see why this would have any bearing on anything.  GnuPG is
released under the GPL, which means it can be used for commercial and
non-commercial purposes.

@_date: 2000-04-20 09:19:37
@_author: Frank Tobin 
@_subject: Delete key from a keyserver 
Hash: SHA1
Nope, you can't remove them.  The simple 'because' is that you can't
verify yourself to the keyserver to tell it you don't want your key on it,
because you don't have access to your key/passphrase.

@_date: 2000-04-20 09:28:20
@_author: Frank Tobin 
@_subject: Secure connections 
It sounds like you really need to look through the FAQ or README that is
distributed with GnuPG.
Why do you think the random number generation in GnuPG is bad?  I'm
assuming you're using an OS, of course, that has a _real_ /dev/random,
such as Linux or the BSD's.
Oh, and DES won't do the job.  Use something that is trusted and has a
decent keysize, such as maybe 3DES.  Look at  for

@_date: 2000-04-20 14:04:32
@_author: Frank Tobin 
@_subject: RES: Secure connections 
Hash: SHA1
Werner has said before that he does not plan to produce an sdk; see the

@_date: 2000-04-21 01:54:58
@_author: Frank Tobin 
@_subject: Signatures on GnuPG 
Hash: SHA1
Werner doesn't do the RPM's; he signs the source.  The key you are
referring to is most likely the RPM builder's key.

@_date: 2000-04-21 11:23:47
@_author: Frank Tobin 
@_subject: Exit status and failed decryption of session key 
There are so many issues that can happen as the result of an OpenPGP
operation.  One could verify a signature, but not have the public key or a
web-of-trust line, or one could have the issue you talked aobut,
etc.  What you should really look into is parsing the output of the option
"status-fd", which has information described in GnuPG's DETAILS file.

@_date: 2000-04-22 13:47:40
@_author: Frank Tobin 
@_subject: Windoze PGP Compatability 
Hash: SHA1
The problem I would guess, is that the default symmetric algorithm used to
encrypt GnuPG secret keys is Blowfish, which is not supported by PGP.
I don't know how you could go about resolving this issue; that is, I don't
know how you could get GnuPG to change the algorithm used to encrypt an
already-created secret key.  There is an option "s2k-cipher-algo", but
according to the documentation in the manpage, is not clear that this may
have any effect while not generating a key.

@_date: 2000-04-22 14:27:25
@_author: Frank Tobin 
@_subject: failing to import PGP 5.0 key 
If what you are asking is how that person got RSA and IDEA enabled, you
can find the dynamically-loadable modules at
Documentation on how to use them is described in the header of the source.

@_date: 2000-04-22 14:47:35
@_author: Frank Tobin 
@_subject: Exit status and failed decryption of session key 
The question is what does "successful" mean?  There can be warnings, total
failure, partial success/failure, etc.  Your wrapper really should try to
do some processing and parse status-fd.

@_date: 2000-04-23 13:45:46
@_author: Frank Tobin 
@_subject: Exit status and failed decryption of session key 
In GnuPG you don't follow options with equals '='.
gpg --bach --status-fd 2 --encrypt -r fw

@_date: 2000-04-24 18:07:39
@_author: Frank Tobin 
@_subject: compiling idea,rsa modules for use with gnupg 
Documentation on how to use them is described in the header of the source.

@_date: 2000-04-27 14:03:08
@_author: Frank Tobin 
@_subject: Lib's 
Something concerning this should really be on the GnuPG website, up front,
given I've answered it so many times.

@_date: 2000-04-28 12:26:21
@_author: Frank Tobin 
@_subject: Pass/fail test on gpg implimentation on PINE 
This may soon be an optional feature (turned off by default) in

@_date: 2000-04-05 02:23:11
@_author: Frank Tobin 
@_subject: GPGnet? 
Hash: SHA1
Note that PGPnet has little to nothing to do with the OpenPGP protocol, or
even PGP in that matter.  The name PGPnet, I'm guessing, is more
marketting than anything else to get you to associate the security that
comes with PGP together with PGPnet, even though they are weakly related.

@_date: 2000-04-05 03:23:47
@_author: Frank Tobin 
@_subject: GPGnet? 
If you are calling PGP the entire suite of tools, there is no blanket
security that you can apply to the entire suite.  You have to break the
issue down more; you can't abstract it that much.  Saying PGPnet and the
unnamaed program that implements OpenPGP are equal is ridiculous; just
because they use similar algorithms has no effect on the possible
insecureness of the protocols involved.  Given your style of argument, I
could abstract the Kerberos and ssh systems (public key logins, to
simplify) to say that the protocols are as secure as one another (given
that they are using similar algorithms).

@_date: 2000-04-06 15:48:37
@_author: Frank Tobin 
@_subject: Key Generation 
What operating system are you running?  Different systems gather stuff for

@_date: 2000-04-06 16:13:19
@_author: Frank Tobin 
@_subject: Key Generation 
Hash: SHA1
On FreeBSD, you need to pass in IRQ's to rndcontrol(8) to get it to gather
entropy from other sources than the keyboard.  Boot-time settings to
rndcontrol(8) can be set in /etc/rc.conf; I have:
rand_irqs="1 10 12 14 15"       # Stir the entropy pool (like "5 11")
This depends on your hardware, of course.  I've got IDE devices, a PS/2
mouse, network and soundcard.  I forget which IRQ is for which device; I
used xosview to find out which IRQ's are doing something.

@_date: 2000-04-07 01:04:49
@_author: Frank Tobin 
@_subject: with-colons info 
Hash: SHA1
I've been going over the DETAILS file and the --with-colons information,
and I'm wondering about Field 2, which is used to indicate the calculated
trust/validity.  The value 'u' can be given for a uid's validity, which
means it is 'ultimately' trusted; however, if I'm not mistaken, uid's are
not trusted; they have calculated validity.  The use of the idea of
'ultimate trust' on a uid is confusing, I think; somehow we should be
conveying validty instead of trust.

@_date: 2000-04-07 01:22:03
@_author: Frank Tobin 
@_subject: successive calls to list-keys 
Hash: SHA1
If I make two successive calls to --list-keys and with-colons --list-keys,
can I be ensured that the keys presented will appear in the same
order, assuming the keyring is not altered by the user during this

@_date: 2000-04-10 14:18:54
@_author: Frank Tobin 
@_subject: Decrypting programmatically. 
This is not allowed because on pretty much all unixes one can see everyone
else's command-line arguments; hence, the passphrase could be seen by any
other user on the system.
The general way of passing in a passphrase to GnuPG is to do so via a
handle specified in the passphrase-fd option; I don't know if you can
accomplish this with Java though.  There are Perl modules that allow you
to accomplish this farily easily, though.

@_date: 2000-04-10 14:21:37
@_author: Frank Tobin 
@_subject: gpg to sign cgi output? 
I recommend using one of the several Perl modules on CPAN that are
designed for GnuPG interaction.

@_date: 2000-04-11 03:55:13
@_author: Frank Tobin 
@_subject: request for input on name of GnuPG Perl module 
Hash: SHA1
I'm currently in the process of almost releasing a totally reworked Perl
module to handle GnuPG; it's based off the same IPC-style ( communication
via handles ) as my PGP::GPG::MessageProcessor, but it is more powerful
and better designed (in particular it can fully parse --with-colons
information and can create useful "Key" objects).
Since the interface and powerfulness do much more than "message
processing", I've been tempted to call it PGP::GnuPG::Interface.  However, the bareword "PGP" is not that good of a choice, I feel, because
it is used to relate to NAI's product, which this module does not support.
OpenPGP::GnuPG::Interface might be okay, but there is the fact that my
module itself doesn't implement OpenPGP; GnuPG does that for me.  However, "OpenPGP" is a new top-level CPAN directory, so I'm hesitant to
use this, as I plan putting it on CPAN.
Simply GnuPG::Interface also is an option, but once again, GnuPG is a new
top-level CPAN name.
If anyone has comments on these possible names, or has good suggestions,
please let me know.

@_date: 2000-04-14 10:34:09
@_author: Frank Tobin 
@_subject: Compatibility 
Hash: SHA1
No, the nice thing about GnuPG is that it conforms to an
internet-recognized specification for exchanging OpenPGP messages.  This
standard is available for anyone to view and create a new implementation
of.  If these standards did not exist we wouldn't have working protocols
like TCP or HTTP.
Three are currently two major things which break compatibility:
encumbering patents, and PGP.
RSA and IDEA are not supported by default in GnuPG because they are not
free algorithms.  These are SHOULD's in the OpenPGP specifiction.  RSA
will likely be supported when the patent runs out this fall.  IDEA's
patent does not run out for several years.
NAI's PGP breaks the OpenPGP specifiction with it's new packets such as
the photo-id.  I can see that NAI wants to further extend the powers of
PGP, and that is fine with me; however, users should be aware that there
is an open standard with free implementations which anyone can use, and
that not abiding by this standard has a good chance of alienating those
who abide by it.
This the same reason why use of Word documents is highly discouraged over
other open, standards-based forms such as HTML; it would be silly to think
that HTML should try to replace Word, or compensate for it.  Sure, MS
wants to further the complexity and power of a Word document, but that
does not in any way mean that the designers of HTML should want or try to
Oh, and by the way, when I refer to free I mean Open Source Free.

@_date: 2000-04-14 10:47:51
@_author: Frank Tobin 
@_subject: Compatibility 
Hash: SHA1
Hehehe.  Of course, there is _nothing_ stopping Len from editing GnuPG
himself, making the modification, releasing, and continuing to track the
source, to see if users would prefer his modified version.  Mmmm, GPL'd
software, crunchy on the outside, soft and gooey in the middle :)

@_date: 2000-04-14 16:10:38
@_author: Frank Tobin 
@_subject: Compatibility 
Are you implying that creating unrestricted, free software is not a "vey
good reason"?  Remember, the FSF has strong philosophies which have
changed things for many of us, because of this good reason.
If this is true, I'll stop arguing this point; I'm sure you've become more
intimate with PGP's internals and the RFC than I have.

@_date: 2000-04-14 16:16:12
@_author: Frank Tobin 
@_subject: GPL & GnuPG 
I totally agree with you on this point.  However, I'm interpreting
Warner's statment as expressing his disappointment that people are
'foolishly' still trying to use the concept of license keys to restrict
software.  Kinda goes against everything the FSF is against; not that it
minds _that_much_ that people still exhausting energy trying :)

@_date: 2000-04-14 16:33:01
@_author: Frank Tobin 
@_subject: key storage 
Removable drives (e.g., floppy), or other input devices such as serial
ports provide a decent means of having an 'air-wall' between your secret
keys and the OpenPGP application when they are not in use.  There are a
whole bunch of fun/exotic/paranoid measures one could go to to protect
one's secret keys.  Lots of them cut down on your productivity,
though.  Pick your favorite game.

@_date: 2000-04-16 17:15:53
@_author: Frank Tobin 
@_subject: ann: release of GnuPG::Interface 0.01 
Hash: SHA1
I am pleased to announce the first release of GnuPG::Interface.  GnuPG::Interface, the successor to PGP::GPG::MessageProcessor, is a Perl
module interface to interacting with GnuPG.  It implements a rich set of
bidirectional communications with GnuPG through filehandles and includes a
rich GnuPG-key object organization structure, which has information filled
in by parsing GnuPG's key listing's with-colons option.
While this module is at 0.01, I have done extensive testing to help ensure
that the module works correctly.  Comments are welcomed.
The current homepage of GnuPG::Interface is at:

@_date: 2000-04-17 01:31:21
@_author: Frank Tobin 
@_subject: Determining Key Algorithm? 
Hash: SHA1
The "with-colons" options should achieve what you want.  Details are
spelled out in GnuPG's DETAILS file.

@_date: 2000-04-18 21:07:51
@_author: Frank Tobin 
@_subject: Unidentified subject! 
Hash: SHA1
As far as I know, there are no problems for cryptographic software
arriving in the US, only the other way around (and is changing, too, for
the better).
I don't see why this would have any bearing on anything.  GnuPG is
released under the GPL, which means it can be used for commercial and
non-commercial purposes.

@_date: 2000-04-20 09:19:37
@_author: Frank Tobin 
@_subject: Delete key from a keyserver 
Hash: SHA1
Nope, you can't remove them.  The simple 'because' is that you can't
verify yourself to the keyserver to tell it you don't want your key on it,
because you don't have access to your key/passphrase.

@_date: 2000-04-20 09:28:20
@_author: Frank Tobin 
@_subject: Secure connections 
It sounds like you really need to look through the FAQ or README that is
distributed with GnuPG.
Why do you think the random number generation in GnuPG is bad?  I'm
assuming you're using an OS, of course, that has a _real_ /dev/random,
such as Linux or the BSD's.
Oh, and DES won't do the job.  Use something that is trusted and has a
decent keysize, such as maybe 3DES.  Look at  for

@_date: 2000-04-20 14:04:32
@_author: Frank Tobin 
@_subject: RES: Secure connections 
Hash: SHA1
Werner has said before that he does not plan to produce an sdk; see the

@_date: 2000-04-21 01:54:58
@_author: Frank Tobin 
@_subject: Signatures on GnuPG 
Hash: SHA1
Werner doesn't do the RPM's; he signs the source.  The key you are
referring to is most likely the RPM builder's key.

@_date: 2000-04-21 11:23:47
@_author: Frank Tobin 
@_subject: Exit status and failed decryption of session key 
There are so many issues that can happen as the result of an OpenPGP
operation.  One could verify a signature, but not have the public key or a
web-of-trust line, or one could have the issue you talked aobut,
etc.  What you should really look into is parsing the output of the option
"status-fd", which has information described in GnuPG's DETAILS file.

@_date: 2000-04-22 13:47:40
@_author: Frank Tobin 
@_subject: Windoze PGP Compatability 
Hash: SHA1
The problem I would guess, is that the default symmetric algorithm used to
encrypt GnuPG secret keys is Blowfish, which is not supported by PGP.
I don't know how you could go about resolving this issue; that is, I don't
know how you could get GnuPG to change the algorithm used to encrypt an
already-created secret key.  There is an option "s2k-cipher-algo", but
according to the documentation in the manpage, is not clear that this may
have any effect while not generating a key.

@_date: 2000-04-22 14:27:25
@_author: Frank Tobin 
@_subject: failing to import PGP 5.0 key 
If what you are asking is how that person got RSA and IDEA enabled, you
can find the dynamically-loadable modules at
Documentation on how to use them is described in the header of the source.

@_date: 2000-04-22 14:47:35
@_author: Frank Tobin 
@_subject: Exit status and failed decryption of session key 
The question is what does "successful" mean?  There can be warnings, total
failure, partial success/failure, etc.  Your wrapper really should try to
do some processing and parse status-fd.

@_date: 2000-04-23 13:45:46
@_author: Frank Tobin 
@_subject: Exit status and failed decryption of session key 
In GnuPG you don't follow options with equals '='.
gpg --bach --status-fd 2 --encrypt -r fw

@_date: 2000-04-24 18:07:39
@_author: Frank Tobin 
@_subject: compiling idea,rsa modules for use with gnupg 
Documentation on how to use them is described in the header of the source.

@_date: 2000-04-27 14:03:08
@_author: Frank Tobin 
@_subject: Lib's 
Something concerning this should really be on the GnuPG website, up front,
given I've answered it so many times.

@_date: 2000-04-28 12:26:21
@_author: Frank Tobin 
@_subject: Pass/fail test on gpg implimentation on PINE 
This may soon be an optional feature (turned off by default) in

@_date: 2000-08-02 09:35:35
@_author: Frank Tobin 
@_subject: GPG/PGP and Mail 
Hash: SHA1
Unfortunately, AFAIK, pgpenvelope does not do this :P
But I hope to get it in sometime.  Honest :)

@_date: 2000-08-02 11:11:47
@_author: Frank Tobin 
@_subject: GPG/PGP and Mail 
Hash: SHA1
Glad you asked.  Look into the piping (| command) of Pine.  It can let me
process a message directly.  Things are looking up.
Eh, but some people might trust their system enough, have a key dedicated
to encrypted email, and keep the key stored on the filesystem.  I know I
wouldn't, but I'm not everyone (yet) :)

@_date: 2000-08-03 17:34:01
@_author: Frank Tobin 
@_subject: GPG/PGP and Mail 
Hash: SHA1
Erm, well, that's not entirely correct; eventually pgpenvelope is going to
handle PGP/MIME by using the Pipe command to process the raw message.  We
just have to get out of the rut of simply using the display-filter option

@_date: 2000-08-03 21:55:25
@_author: Frank Tobin 
@_subject: GPG/PGP and Mail 
Hash: SHA1
Ah, yes, this will pose a problem for encrypted messages.  I don't know a
solution for this yet.

@_date: 2000-08-03 23:47:19
@_author: Frank Tobin 
@_subject: I dont know anything about this 
Hash: SHA1
Yes, manpages are nice to refer to, but they are not a tutorial.  They are
The GnuPG documentation project appears to have a lot of good
information; I just came its url in the README:

@_date: 2000-08-22 12:34:32
@_author: Frank Tobin 
@_subject: Insecure memory 
You do not really have the 1.0.2 manpage, then.
       --no-secmem-warning
                 Suppress the warning about "using insecure  mem-
                 ory".

@_date: 2000-08-22 14:11:34
@_author: Frank Tobin 
@_subject: suggest a keyserver 
I personally horowitz.surfnet.nl.
I have found  to be a good listing of

@_date: 2000-08-23 19:10:40
@_author: Frank Tobin 
@_subject: valid sig, invlalid key? 
Hash: SHA1
While I personally haven't used PGP in years, "Invalid" is likely PGP's
terminology for something being "not validated"; that is, the receiving
end has not validated through the Web Of Trust that the key actually
belongs to "My Company".
Personally, I really don't like term "invalid" in these scenarios, because
"invalid" is not really the inverse of "valid"; "invalid" positively
reflects something being corrupted, while "valid" positively reflects
authenticity.  The situation is more in the middle; "unknown validity".

@_date: 2000-08-28 01:38:28
@_author: Frank Tobin 
@_subject: GnuPG::Interface 
Hash: SHA1
I advise capturing the stderr of GnuPG using a
GnuPG::Handle->stderr() handle, and seeing if GnuPG emits any
warnings.  Also, write a short script that is not via CGI (just
command-line) to help debug.

@_date: 2000-08-31 17:30:20
@_author: Frank Tobin 
@_subject: Windows IPC (was: Pb decrypting with PGP 6.5.3 and GnuPG) 
Hash: SHA1
Why do that when Secret Agent is available?

@_date: 2000-08-02 09:35:35
@_author: Frank Tobin 
@_subject: GPG/PGP and Mail 
Hash: SHA1
Unfortunately, AFAIK, pgpenvelope does not do this :P
But I hope to get it in sometime.  Honest :)

@_date: 2000-08-02 11:11:47
@_author: Frank Tobin 
@_subject: GPG/PGP and Mail 
Hash: SHA1
Glad you asked.  Look into the piping (| command) of Pine.  It can let me
process a message directly.  Things are looking up.
Eh, but some people might trust their system enough, have a key dedicated
to encrypted email, and keep the key stored on the filesystem.  I know I
wouldn't, but I'm not everyone (yet) :)

@_date: 2000-08-03 17:34:01
@_author: Frank Tobin 
@_subject: GPG/PGP and Mail 
Hash: SHA1
Erm, well, that's not entirely correct; eventually pgpenvelope is going to
handle PGP/MIME by using the Pipe command to process the raw message.  We
just have to get out of the rut of simply using the display-filter option

@_date: 2000-08-03 21:55:25
@_author: Frank Tobin 
@_subject: GPG/PGP and Mail 
Hash: SHA1
Ah, yes, this will pose a problem for encrypted messages.  I don't know a
solution for this yet.

@_date: 2000-08-03 23:47:19
@_author: Frank Tobin 
@_subject: I dont know anything about this 
Hash: SHA1
Yes, manpages are nice to refer to, but they are not a tutorial.  They are
The GnuPG documentation project appears to have a lot of good
information; I just came its url in the README:

@_date: 2000-08-22 12:34:32
@_author: Frank Tobin 
@_subject: Insecure memory 
You do not really have the 1.0.2 manpage, then.
       --no-secmem-warning
                 Suppress the warning about "using insecure  mem-
                 ory".

@_date: 2000-08-22 14:11:34
@_author: Frank Tobin 
@_subject: suggest a keyserver 
I personally horowitz.surfnet.nl.
I have found  to be a good listing of

@_date: 2000-08-23 19:10:40
@_author: Frank Tobin 
@_subject: valid sig, invlalid key? 
Hash: SHA1
While I personally haven't used PGP in years, "Invalid" is likely PGP's
terminology for something being "not validated"; that is, the receiving
end has not validated through the Web Of Trust that the key actually
belongs to "My Company".
Personally, I really don't like term "invalid" in these scenarios, because
"invalid" is not really the inverse of "valid"; "invalid" positively
reflects something being corrupted, while "valid" positively reflects
authenticity.  The situation is more in the middle; "unknown validity".

@_date: 2000-08-28 01:38:28
@_author: Frank Tobin 
@_subject: GnuPG::Interface 
Hash: SHA1
I advise capturing the stderr of GnuPG using a
GnuPG::Handle->stderr() handle, and seeing if GnuPG emits any
warnings.  Also, write a short script that is not via CGI (just
command-line) to help debug.

@_date: 2000-08-31 17:30:20
@_author: Frank Tobin 
@_subject: Windows IPC (was: Pb decrypting with PGP 6.5.3 and GnuPG) 
============================== START ==============================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Why do that when Secret Agent is available?

@_date: 2000-12-14 15:38:21
@_author: Frank Tobin 
@_subject: Question regarding clearsigning emails automatically 
Hash: SHA1
    And on a slow box (mine) it even freezes during signature
    verification. It would be much better if Mutt has an option to
    check signatures on demand and not every time you open that
    message.
One system that pgpenvelope adopted was the ability to check signatures
through procmail; this modifies the body of the message, but one can store
the original in a backup folder trivially.

@_date: 2000-12-14 15:38:21
@_author: Frank Tobin 
@_subject: Question regarding clearsigning emails automatically 
Hash: SHA1
    And on a slow box (mine) it even freezes during signature
    verification. It would be much better if Mutt has an option to
    check signatures on demand and not every time you open that
    message.
One system that pgpenvelope adopted was the ability to check signatures
through procmail; this modifies the body of the message, but one can store
the original in a backup folder trivially.

@_date: 2000-01-31 20:44:45
@_author: Frank Tobin 
@_subject: PG and public key servers 
I find William H. Geiger's page to be very helpful here:

@_date: 2000-02-19 15:51:21
@_author: Frank Tobin 
@_subject: Bus error on Irix 6.5.* 
The same problem occurs for me.  GnuPG is also not able to import keys; it
does not bus-error, but it hangs there chewing up CPU.  This also happened
to me on IRIX 6.2.

@_date: 2000-02-20 11:03:43
@_author: Frank Tobin 
@_subject: Bus error on Irix 6.5.* 
This also worked for me to compile to get GnuPG 1.0.1 to compile on:
IRIX64  6.5 07151439 IP27

@_date: 2000-02-20 11:06:12
@_author: Frank Tobin 
@_subject: Bus error on Irix 6.5.* 
Correcting myself: this got it to _work_ so that it can at least generate
a key and import a key.  Compiling was never a problem.

@_date: 2000-02-23 02:40:50
@_author: Frank Tobin 
@_subject: GNUpg v1.01/FreeBSD-20000214-CURRENT 
You just need to wait this out.  Give it a couple minutes.  Doing
intensive things on your system helps to increase the data available to

@_date: 2000-02-27 16:36:35
@_author: Frank Tobin 
@_subject: request for comments: GnuPG Interface Library 
Hash: SHA1
Greetings all,
I have been working on designing a useful, flexible, and extensible
interface for those who interact with GnuPG with Perl.  As GnuPG grows
more and more in popularity, a good Perl library to interact with GnuPG
will be needed because GnuPG is so powerful. Harnessing this power for the
programmer in an easy-to-user manner will allow GnuPG to thrive in at
least Perl environments.
I've provided a detailed description of my current ideas on a good
interface that could be implemented fairly easily in Perl, and hopefully
in other languges also at:
Please feel free to provide feedback on this design; I _am_ going to write
an interface; it's just a matter of getting the design done well.  To do
this well I feel I need outside eyes; hence I'm appealing especially to
those who write Perl to provide comments.
Thank you for your time.

@_date: 2000-01-31 20:44:45
@_author: Frank Tobin 
@_subject: PG and public key servers 
I find William H. Geiger's page to be very helpful here:

@_date: 2000-02-19 15:51:21
@_author: Frank Tobin 
@_subject: Bus error on Irix 6.5.* 
The same problem occurs for me.  GnuPG is also not able to import keys; it
does not bus-error, but it hangs there chewing up CPU.  This also happened
to me on IRIX 6.2.

@_date: 2000-02-20 11:03:43
@_author: Frank Tobin 
@_subject: Bus error on Irix 6.5.* 
This also worked for me to compile to get GnuPG 1.0.1 to compile on:
IRIX64  6.5 07151439 IP27

@_date: 2000-02-20 11:06:12
@_author: Frank Tobin 
@_subject: Bus error on Irix 6.5.* 
Correcting myself: this got it to _work_ so that it can at least generate
a key and import a key.  Compiling was never a problem.

@_date: 2000-02-23 02:40:50
@_author: Frank Tobin 
@_subject: GNUpg v1.01/FreeBSD-20000214-CURRENT 
You just need to wait this out.  Give it a couple minutes.  Doing
intensive things on your system helps to increase the data available to

@_date: 2000-02-27 16:36:35
@_author: Frank Tobin 
@_subject: request for comments: GnuPG Interface Library 
Hash: SHA1
Greetings all,
I have been working on designing a useful, flexible, and extensible
interface for those who interact with GnuPG with Perl.  As GnuPG grows
more and more in popularity, a good Perl library to interact with GnuPG
will be needed because GnuPG is so powerful. Harnessing this power for the
programmer in an easy-to-user manner will allow GnuPG to thrive in at
least Perl environments.
I've provided a detailed description of my current ideas on a good
interface that could be implemented fairly easily in Perl, and hopefully
in other languges also at:
Please feel free to provide feedback on this design; I _am_ going to write
an interface; it's just a matter of getting the design done well.  To do
this well I feel I need outside eyes; hence I'm appealing especially to
those who write Perl to provide comments.
Thank you for your time.

@_date: 2000-01-16 05:19:13
@_author: Frank Tobin 
@_subject: having a library pass GnuPG options 
I'm the developer of a Perl module to interact with GnuPG, and I've had a
hard time deciding how certain options should be handled when giving them
to GnuPG, as GnuPG's argument handling seems to have changed a lot in the
long time I've known it.  I understand that much of this arises from
GnuPG's notion of 'option' arguments versus 'command' arguments.
Currently, when the user want the module to clearsign a message, this is
considered a supplement to to general notion of signing the message.  The
module implements this, however, by calling GnuPG with:
gpg --clearsign
I now notice that GnuPG now graciously handles:
gpg --sign --clearsign
What is the 'preferred' call?  As I am developing for a module, I need to
heavily think about forward compatibility.  The same question go for
detached signatures; interestingly, '--clearsign' seems to override
If there is any reference library that interacts with GnuPG I'd like to
know about it.  I'd use mutt, except for the fact it is not a library; it
conforms to a strict routine, if I'm not mistaken.  I've once looked at
pgpglue but that seems sorely out of date.

@_date: 2000-01-20 09:31:16
@_author: Frank Tobin 
@_subject: pass phrase 
Please don't tell me you are using shell.  Use Perl or some other
system-level scripting language.  There are modules on CPAN for
interacting with GnuPG.

@_date: 2000-01-20 15:07:22
@_author: Frank Tobin 
@_subject: pass phrase 
In FreeBSD-STABLE, the only reason you are able to see the arguments of
other people's processes is because programs such as 'ps' and 'top' are
setgid "kmem"; without kernel-memory access via the group kmem, you can
only read the arguments of your vectors.

@_date: 2000-01-20 15:08:44
@_author: Frank Tobin 
@_subject: pass phrase 
The problem is that Perl has features in it designed for security (e.g.,
Taint mode).   You can be much more careful about processing information
when in Perl then you can with awk and friends.

@_date: 2000-01-20 15:14:32
@_author: Frank Tobin 
@_subject: pass phrase 
Personally, I'd like to hear an argument from Werner about this.  True, on
some systems such as Linux, one does not require special privileges to
read other's arguments, but on other systems, such as FBSD, it requires
kmem access.  If the setgid flags are removed from certain files, one
cannot see other's arguments, hence nullifying the problem with seeing
other's arguments.

@_date: 2000-01-20 15:21:50
@_author: Frank Tobin 
@_subject: pass phrase 
Ummm, my module doesn't (PGP::GPG::MessageProcessor)  :)  I solely use
pipes to interact with GnuPG.  I take it you were looking at GnuPG.pm
(which I don't even seen on CPAN).

@_date: 2000-01-21 16:23:06
@_author: Frank Tobin 
@_subject: A last word on --passphrase-fd 
What I think some are wanting to say is that they don't only want 'tricky'
ways to handle passing the passphrase to GnuPG; some languages don't have
all the niceties of finding the numerical fd, and then being able to pass
it down to GnuPG via a fd.
I'm not saying that passphrase-fd is bad.  Rather, I think it's a very
good interface given the non-anonymity design of most unixes.  However, I
just don't think that there is anything inherently wrong with passing it
in via an argument; it is only a problem if other users on the system can
see the argument list of other users's processes.  And this should not be
taken for granted, just because most people use Linux where this is
Therefore, I think there is no reason _not_ to allow the information to
passed in as an argument.  It's the programmer's responsibility to handle
the situation correctly for his environment.  I feel that making this
decision for him is a bad thing.  There's More Than One Way To Do It
(TMTOWTDI - Perl Motto).
I could create other scenarios.  For example, consider an example where
the daemon process only has access to the secrets (passphrase and secret
key)  some of the time.  What do I mean?  Well, consider a scenario where
the passphrase file is mounted over a networked filesystem.  The host only
allows clients to connect at certain times; the reasons for this could be
several, including easier control, monitoring, analysis of what is going
on.  This also allows for separation of secrets.  The secret key's
passphrase file is mounted at certain times, allowing the daemon access to
it.  The same could be done with the secret keyfile.  This separation of
secrets could actually be useful in somesituation.  I'm not saying this
system is currently feasible or secure; I'm only using it to demonstrate
that that there definitely could be situations that you don't think of.  Once again, There's More Than One Way To Do It.

@_date: 2000-01-16 05:19:13
@_author: Frank Tobin 
@_subject: having a library pass GnuPG options 
I'm the developer of a Perl module to interact with GnuPG, and I've had a
hard time deciding how certain options should be handled when giving them
to GnuPG, as GnuPG's argument handling seems to have changed a lot in the
long time I've known it.  I understand that much of this arises from
GnuPG's notion of 'option' arguments versus 'command' arguments.
Currently, when the user want the module to clearsign a message, this is
considered a supplement to to general notion of signing the message.  The
module implements this, however, by calling GnuPG with:
gpg --clearsign
I now notice that GnuPG now graciously handles:
gpg --sign --clearsign
What is the 'preferred' call?  As I am developing for a module, I need to
heavily think about forward compatibility.  The same question go for
detached signatures; interestingly, '--clearsign' seems to override
If there is any reference library that interacts with GnuPG I'd like to
know about it.  I'd use mutt, except for the fact it is not a library; it
conforms to a strict routine, if I'm not mistaken.  I've once looked at
pgpglue but that seems sorely out of date.

@_date: 2000-01-20 09:31:16
@_author: Frank Tobin 
@_subject: pass phrase 
Please don't tell me you are using shell.  Use Perl or some other
system-level scripting language.  There are modules on CPAN for
interacting with GnuPG.

@_date: 2000-01-20 15:07:22
@_author: Frank Tobin 
@_subject: pass phrase 
In FreeBSD-STABLE, the only reason you are able to see the arguments of
other people's processes is because programs such as 'ps' and 'top' are
setgid "kmem"; without kernel-memory access via the group kmem, you can
only read the arguments of your vectors.

@_date: 2000-01-20 15:08:44
@_author: Frank Tobin 
@_subject: pass phrase 
The problem is that Perl has features in it designed for security (e.g.,
Taint mode).   You can be much more careful about processing information
when in Perl then you can with awk and friends.

@_date: 2000-01-20 15:14:32
@_author: Frank Tobin 
@_subject: pass phrase 
Personally, I'd like to hear an argument from Werner about this.  True, on
some systems such as Linux, one does not require special privileges to
read other's arguments, but on other systems, such as FBSD, it requires
kmem access.  If the setgid flags are removed from certain files, one
cannot see other's arguments, hence nullifying the problem with seeing
other's arguments.

@_date: 2000-01-20 15:21:50
@_author: Frank Tobin 
@_subject: pass phrase 
Ummm, my module doesn't (PGP::GPG::MessageProcessor)  :)  I solely use
pipes to interact with GnuPG.  I take it you were looking at GnuPG.pm
(which I don't even seen on CPAN).

@_date: 2000-01-21 16:23:06
@_author: Frank Tobin 
@_subject: A last word on --passphrase-fd 
What I think some are wanting to say is that they don't only want 'tricky'
ways to handle passing the passphrase to GnuPG; some languages don't have
all the niceties of finding the numerical fd, and then being able to pass
it down to GnuPG via a fd.
I'm not saying that passphrase-fd is bad.  Rather, I think it's a very
good interface given the non-anonymity design of most unixes.  However, I
just don't think that there is anything inherently wrong with passing it
in via an argument; it is only a problem if other users on the system can
see the argument list of other users's processes.  And this should not be
taken for granted, just because most people use Linux where this is
Therefore, I think there is no reason _not_ to allow the information to
passed in as an argument.  It's the programmer's responsibility to handle
the situation correctly for his environment.  I feel that making this
decision for him is a bad thing.  There's More Than One Way To Do It
(TMTOWTDI - Perl Motto).
I could create other scenarios.  For example, consider an example where
the daemon process only has access to the secrets (passphrase and secret
key)  some of the time.  What do I mean?  Well, consider a scenario where
the passphrase file is mounted over a networked filesystem.  The host only
allows clients to connect at certain times; the reasons for this could be
several, including easier control, monitoring, analysis of what is going
on.  This also allows for separation of secrets.  The secret key's
passphrase file is mounted at certain times, allowing the daemon access to
it.  The same could be done with the secret keyfile.  This separation of
secrets could actually be useful in somesituation.  I'm not saying this
system is currently feasible or secure; I'm only using it to demonstrate
that that there definitely could be situations that you don't think of.  Once again, There's More Than One Way To Do It.

@_date: 2000-07-03 15:34:46
@_author: Frank Tobin 
@_subject: keysigning ?= UIDsigning 
Hash: SHA1
Seems to work fine when using PGP BEGIN/END in Pine; dunno if Pine is just
hacking it, though.

@_date: 2000-07-04 04:29:12
@_author: Frank Tobin 
@_subject: keysigning ?= UIDsigning 
Hash: SHA1
Ah, I see.  I didn't grasp it since Pine's sending filters enact before
any encoding, so plugin-signing programs such as pgpenvelope sign 8bit,
not quoted-printable.

@_date: 2000-07-04 16:08:26
@_author: Frank Tobin 
@_subject: problem loading rsa extension to use with 2.6.3i key (SOLVED) 
Hash: SHA1
You need to also get the IDEA module, another patented algorithm used by
PGP 2.x.

@_date: 2000-07-04 22:52:06
@_author: Frank Tobin 
@_subject: GnuPG and CGI 
You can do it yourself, of course.  The modules are designed to make your
life easier, though.

@_date: 2000-07-05 00:14:44
@_author: Frank Tobin 
@_subject: explicit command for examining keys 
Hash: SHA1
Given a keyblock and no command argument, GnuPG defaults to examining the
keyblock, and spits out the relevant key information.  For the purpose of
clarity/safety, however, is there a command to explicity invoke this

@_date: 2000-07-07 10:42:05
@_author: Frank Tobin 
@_subject: list-subkeys with-colons not showing expiration date 
Could I get an affirmation either way whether GnuPG will continue to not
show an expiration date for subkeys of secret keys, but will for public
keys?  I have test scripts for GnuPG::Interface that I'd like to get right
before the next major release of GnuPG.

@_date: 2000-07-07 10:42:05
@_author: Frank Tobin 
@_subject: list-subkeys with-colons not showing expiration date 
Could I get an affirmation either way whether GnuPG will continue to not
show an expiration date for subkeys of secret keys, but will for public
keys?  I have test scripts for GnuPG::Interface that I'd like to get right
before the next major release of GnuPG.

@_date: 2000-07-08 16:29:11
@_author: Frank Tobin 
@_subject: Bug when signing text? 
Hash: SHA1
Cleartext messages must be dash-escaped. See

@_date: 2000-07-20 23:52:17
@_author: Frank Tobin 
@_subject: addressbook? 
Hash: SHA1
Has there been any thought to GnuPG support an addressbook style of
looking up keys?  Many of us have multiple keys out there, with no way of
distinguishing a particular key of mine (or someone else's) that I'd use
most often, without resorting to cheap hacks like environment variables.
It would be great if I could do something like
"gpg --list-keys mykey" where somehow "mykey" is aliased to something like
my key's fingerprint, 4F863BBBA8166F0A340F600356FFD10A260C4FA3.
Browsers, MUA's, and shells have their equivalent of addressbooks:
bookmarks for urls, addressbooks for email addys, and aliases for
commands, respectively.  It's a good time to have our key-tracking
software to do the same.

@_date: 2000-07-23 22:23:20
@_author: Frank Tobin 
@_subject: Commercial use of GnuPG 
Hash: SHA1
Concerning restricted algorithms, GnuPG does not use any, so those are
not an issue.
The GNU General Public License, which GnuPG is under, has no restrictions
on the actual use; I quote section 0 of the GPL:
"Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope. The act of running
the Program is not restricted, and the output from the Program is covered
only if its contents constitute a work based on the Program (independent
of having been made by running the Program). Whether that is true depends
on what the Program does."

@_date: 2000-07-25 14:48:54
@_author: Frank Tobin 
@_subject: GnuPG: what email client should i use? 
There are two solutions you can use to avoid this problem; procmail using
formail's duplicate detection (man procmailex(5)) or nodupmail,

@_date: 2000-07-28 02:04:29
@_author: Frank Tobin 
@_subject: Looking for a decrypting script 
Since you're dealing with successive encrypted messages, you could
actually very likely process the file using pgpenvelope's
( pgpenvelope_decrypt program, even
though you aren't using Pine or such things.
pgpenvelope_decrypt is flexible and can correctly handle multiple OpenPGP
blocks in messages; this is ideal for your task.  It reads from stdin, and
writes to stdout, and was designed for handling the bodies mail messages
which contain OpenPGP blocks.  The only modification that would be made
would be to made off the top of my head would be to pass in the passphrase
directly to GnuPG instead of having the user enter it.
As sen_ml stated in a different reply, this entire thing is fairly trivial
to accomplish with a Perl module, and this is exactly what
pgpenvelope_decrypt does, using GnuPG::Interface.

@_date: 2000-07-29 11:41:59
@_author: Frank Tobin 
@_subject: Looking for a decrypting script 
You have two solutions you could use.
1) Use a passphrase-caching wrapper for GnuPG, such as secret-agent,
available at:
2) To have pgpenvelope_decrypt remember and enter your passphrase for you,
you could apply this patch to it:
*** pgpenvelope_decrypt	Sun Jul 23 22:19:49 2000
--- pgpenvelope_decrypt.new	Sat Jul 29 11:39:31 2000
*** 34,39 ****
--- 34,40 ----
  use FindBin;
  use sigtrap 'handler' => 'die_signal_handler', 'normal-signals';
+ use Term::ReadKey;
  use GnuPG::Interface 0.10;
  use PGPEnvelope::Common;
*** 95,100 ****
--- 96,107 ----
  my $gnupg = GnuPG::Interface->new();
  $gnupg->options->meta_interactive( not $is_filter );
  $gnupg->gnupg_call( $program_call );
+ + print "Please enter a passphrase: ";
+ ReadMode 'noecho', $terminal->input_handle();
+ my $passphrase = ReadLine 0, $terminal->input_handle();
+ ReadMode 'restore', $terminal->input_handle();
+ $gnupg->passphrase( $passphrase );
  PGP_MESSAGE: while (  )
  {

@_date: 2000-07-30 21:57:28
@_author: Frank Tobin 
@_subject: GPG on different machines 
Hash: SHA1
I'm not quite sure what you are asking here.
Ordinary servers such as horowitz.surfnet.nl are fine.  Look into the
'keyserver' option for GnuPG in the manpage.

@_date: 2000-07-03 15:34:46
@_author: Frank Tobin 
@_subject: keysigning ?= UIDsigning 
Hash: SHA1
Seems to work fine when using PGP BEGIN/END in Pine; dunno if Pine is just
hacking it, though.

@_date: 2000-07-04 04:29:12
@_author: Frank Tobin 
@_subject: keysigning ?= UIDsigning 
Hash: SHA1
Ah, I see.  I didn't grasp it since Pine's sending filters enact before
any encoding, so plugin-signing programs such as pgpenvelope sign 8bit,
not quoted-printable.

@_date: 2000-07-04 16:08:26
@_author: Frank Tobin 
@_subject: problem loading rsa extension to use with 2.6.3i key (SOLVED) 
Hash: SHA1
You need to also get the IDEA module, another patented algorithm used by
PGP 2.x.

@_date: 2000-07-04 22:52:06
@_author: Frank Tobin 
@_subject: GnuPG and CGI 
You can do it yourself, of course.  The modules are designed to make your
life easier, though.

@_date: 2000-07-05 00:14:44
@_author: Frank Tobin 
@_subject: explicit command for examining keys 
Hash: SHA1
Given a keyblock and no command argument, GnuPG defaults to examining the
keyblock, and spits out the relevant key information.  For the purpose of
clarity/safety, however, is there a command to explicity invoke this

@_date: 2000-07-07 10:42:05
@_author: Frank Tobin 
@_subject: list-subkeys with-colons not showing expiration date 
Could I get an affirmation either way whether GnuPG will continue to not
show an expiration date for subkeys of secret keys, but will for public
keys?  I have test scripts for GnuPG::Interface that I'd like to get right
before the next major release of GnuPG.

@_date: 2000-07-07 10:42:05
@_author: Frank Tobin 
@_subject: list-subkeys with-colons not showing expiration date 
Could I get an affirmation either way whether GnuPG will continue to not
show an expiration date for subkeys of secret keys, but will for public
keys?  I have test scripts for GnuPG::Interface that I'd like to get right
before the next major release of GnuPG.

@_date: 2000-07-08 16:29:11
@_author: Frank Tobin 
@_subject: Bug when signing text? 
Hash: SHA1
Cleartext messages must be dash-escaped. See

@_date: 2000-07-20 23:52:17
@_author: Frank Tobin 
@_subject: addressbook? 
Hash: SHA1
Has there been any thought to GnuPG support an addressbook style of
looking up keys?  Many of us have multiple keys out there, with no way of
distinguishing a particular key of mine (or someone else's) that I'd use
most often, without resorting to cheap hacks like environment variables.
It would be great if I could do something like
"gpg --list-keys mykey" where somehow "mykey" is aliased to something like
my key's fingerprint, 4F863BBBA8166F0A340F600356FFD10A260C4FA3.
Browsers, MUA's, and shells have their equivalent of addressbooks:
bookmarks for urls, addressbooks for email addys, and aliases for
commands, respectively.  It's a good time to have our key-tracking
software to do the same.

@_date: 2000-07-23 22:23:20
@_author: Frank Tobin 
@_subject: Commercial use of GnuPG 
Hash: SHA1
Concerning restricted algorithms, GnuPG does not use any, so those are
not an issue.
The GNU General Public License, which GnuPG is under, has no restrictions
on the actual use; I quote section 0 of the GPL:
"Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope. The act of running
the Program is not restricted, and the output from the Program is covered
only if its contents constitute a work based on the Program (independent
of having been made by running the Program). Whether that is true depends
on what the Program does."

@_date: 2000-07-25 14:48:54
@_author: Frank Tobin 
@_subject: GnuPG: what email client should i use? 
There are two solutions you can use to avoid this problem; procmail using
formail's duplicate detection (man procmailex(5)) or nodupmail,

@_date: 2000-07-28 02:04:29
@_author: Frank Tobin 
@_subject: Looking for a decrypting script 
Since you're dealing with successive encrypted messages, you could
actually very likely process the file using pgpenvelope's
( pgpenvelope_decrypt program, even
though you aren't using Pine or such things.
pgpenvelope_decrypt is flexible and can correctly handle multiple OpenPGP
blocks in messages; this is ideal for your task.  It reads from stdin, and
writes to stdout, and was designed for handling the bodies mail messages
which contain OpenPGP blocks.  The only modification that would be made
would be to made off the top of my head would be to pass in the passphrase
directly to GnuPG instead of having the user enter it.
As sen_ml stated in a different reply, this entire thing is fairly trivial
to accomplish with a Perl module, and this is exactly what
pgpenvelope_decrypt does, using GnuPG::Interface.

@_date: 2000-07-29 11:41:59
@_author: Frank Tobin 
@_subject: Looking for a decrypting script 
You have two solutions you could use.
1) Use a passphrase-caching wrapper for GnuPG, such as secret-agent,
available at:
2) To have pgpenvelope_decrypt remember and enter your passphrase for you,
you could apply this patch to it:
*** pgpenvelope_decrypt	Sun Jul 23 22:19:49 2000
--- pgpenvelope_decrypt.new	Sat Jul 29 11:39:31 2000
*** 34,39 ****
--- 34,40 ----
  use FindBin;
  use sigtrap 'handler' => 'die_signal_handler', 'normal-signals';
+ use Term::ReadKey;
  use GnuPG::Interface 0.10;
  use PGPEnvelope::Common;
*** 95,100 ****
--- 96,107 ----
  my $gnupg = GnuPG::Interface->new();
  $gnupg->options->meta_interactive( not $is_filter );
  $gnupg->gnupg_call( $program_call );
+ + print "Please enter a passphrase: ";
+ ReadMode 'noecho', $terminal->input_handle();
+ my $passphrase = ReadLine 0, $terminal->input_handle();
+ ReadMode 'restore', $terminal->input_handle();
+ $gnupg->passphrase( $passphrase );
  PGP_MESSAGE: while (  )
  {

@_date: 2000-07-30 21:57:28
@_author: Frank Tobin 
@_subject: GPG on different machines 
Hash: SHA1
I'm not quite sure what you are asking here.
Ordinary servers such as horowitz.surfnet.nl are fine.  Look into the
'keyserver' option for GnuPG in the manpage.

@_date: 2000-06-18 01:20:49
@_author: Frank Tobin 
@_subject: list-subkeys with-colons not showing expiration date 
I'm curious why using listing secret keys with-colons does not show the
expiration date for subkeys, while listing public keys does:
Example using GnuPG 1.0.1e:
gpg --homedir test --with-colons --list-public 0xF950DA9C 2>&1 | grep sub
gpg --homedir test --with-colons --list-secret 0xF950DA9C 2>&1 | grep ssb
Interestingly, this lack of an expiration date does not occur in GnuPG

@_date: 2000-06-18 03:13:22
@_author: Frank Tobin 
@_subject: not supported public key 
For reference, the RSA library is in:
Documentation is in the source.

@_date: 2000-06-29 17:42:24
@_author: Frank Tobin 
@_subject: Howto integrate (G/P)GP into sendmail -D?! 
Hash: SHA1
This is not a good idea, as there are several flaws that can occur.  First, you have to automate deciding which keys you want to encrypt to,
and this is likely not a system-wide thing you want to enforce.  Second,
you would need to be able to handle things like errors from GnuPG and
such.  And there are a bunch more issues.  It's not a plug-and-play
GnuPG is designed for user-level usage, as OpenPGP is generally designed
as an user-to-user protection.  Trying to setup something system-wide
would not advised.

@_date: 2000-06-29 17:45:29
@_author: Frank Tobin 
@_subject: How to change the install dir? 
Hash: SHA1
RPM's and FreeBSD don't mix :) For FreeBSD, your best bet is going to be
to compile it by hand.  Fortunately, it compiles painlessly on normal
systems (although I haven't tried the 'h' release yet).

@_date: 2000-06-18 01:20:49
@_author: Frank Tobin 
@_subject: list-subkeys with-colons not showing expiration date 
I'm curious why using listing secret keys with-colons does not show the
expiration date for subkeys, while listing public keys does:
Example using GnuPG 1.0.1e:
gpg --homedir test --with-colons --list-public 0xF950DA9C 2>&1 | grep sub
gpg --homedir test --with-colons --list-secret 0xF950DA9C 2>&1 | grep ssb
Interestingly, this lack of an expiration date does not occur in GnuPG

@_date: 2000-06-18 03:13:22
@_author: Frank Tobin 
@_subject: not supported public key 
For reference, the RSA library is in:
Documentation is in the source.

@_date: 2000-06-29 17:42:24
@_author: Frank Tobin 
@_subject: Howto integrate (G/P)GP into sendmail -D?! 
Hash: SHA1
This is not a good idea, as there are several flaws that can occur.  First, you have to automate deciding which keys you want to encrypt to,
and this is likely not a system-wide thing you want to enforce.  Second,
you would need to be able to handle things like errors from GnuPG and
such.  And there are a bunch more issues.  It's not a plug-and-play
GnuPG is designed for user-level usage, as OpenPGP is generally designed
as an user-to-user protection.  Trying to setup something system-wide
would not advised.

@_date: 2000-06-29 17:45:29
@_author: Frank Tobin 
@_subject: How to change the install dir? 
Hash: SHA1
RPM's and FreeBSD don't mix :) For FreeBSD, your best bet is going to be
to compile it by hand.  Fortunately, it compiles painlessly on normal
systems (although I haven't tried the 'h' release yet).

@_date: 2000-03-08 18:28:30
@_author: Frank Tobin 
@_subject: trusting an imported key which is the only key in a ring? 
Hash: SHA1
While I do not have a great answer to this situation, I feel it is an
interesting predicament that needs to be looked at.  I agree that one
should not have to have a local secret key in order to initiate the
validity/trust tree.  True, one could have a throw-away local key to start
the tree, and just sign keys locally, but this is cumbersome and among
other things, requires the key to be generated, which can be an
undesirable process.  It also undesirably requires another file to hold
the secret key (I'm not concerned about 'space' here but 'cleanness' and
Perhaps what is needed is for each user to have an maximally insecure,
unprotected, (virtually blank) 'dumby', non-exportable secret key which is
used solely for the purpose of initiating validity trees.  This could take
the form of an option, say "--trust-key 0x000000" (note I don't know if
this key ID is even valid).  A user could then use '--lsign' and friends
to initiate validity.
Perhaps there are reserved key ID's in OpenPGP that I haven't noticed that
GnuPG could use locally for this purpose.

@_date: 2000-03-09 15:21:38
@_author: Frank Tobin 
@_subject: trusting an imported key which is the only key in a ring? 
I think what is desired is not for the key to be "trusted" but rahter
"valid"; that is, having the desired effect equal to having the key signed
with a trusted key.

@_date: 2000-03-09 15:23:42
@_author: Frank Tobin 
@_subject: Q: device not configured 
Option "no-tty" is undocumented in 1.0.1's manpage (I don't have "c" yet).

@_date: 2000-03-16 04:32:07
@_author: Frank Tobin 
@_subject: 1.0.1 dumps on --with-key-data --list-secret-keys 
Something tells me that GnuPG should play nice here; 1.0.1 dumps with
"--list-secret" together with "--with-key-data".  (Of course I know that
it can't display the key data, but it should be graceful about it :) ).
isr4033 ~> gpg --with-key-data --list-secret-keys $MYKEY
sec:u:1024:17:56FFD10A260C4FA3:1999-04-22:2001-04-21:::Frank J. Tobin
gpg: Segmentation fault caught ... exiting

@_date: 2000-03-16 23:00:03
@_author: Frank Tobin 
@_subject: PGP 5.x and GnuPG 
Hash: SHA1
The v3 keys that PGP5 and earlier created are vulnerable to certain
attacks.  That is the reason they are now deprecated.  In the RFC there
are SHOULD's and MUSTS.  From the RFC, 5.5.2:
"OpenPGP implementations SHOULD create keys with version 4 format. An
implementation MAY generate a V3 key to ensure interoperability with
old software; note, however, that V4 keys correct some security
deficiencies in V3 keys. These deficiencies are described below. An
implementation MUST NOT create a V3 key with a public key algorithm
other than RSA."
You might be interested in browsing the section of the RFC entitled
"Implementation Nits":

@_date: 2000-03-23 04:36:39
@_author: Frank Tobin 
@_subject: if someone steals your key... 
Hash: SHA1
Your private key is encrypted symmetrically with a hash of your
passphrase.  Given that the algorithm used is good, the best attack lays
in the way of brute-forcing the passphrase.  Hence, if the passphrase is
poor, it will be relatively easy to break the key, while if the passphrase
is strong it will be more difficult.  Useful information and references
can be found at:

@_date: 2000-03-24 16:58:47
@_author: Frank Tobin 
@_subject: gpg --recv-key option 
Hash: SHA1
Please qualify this remark.  Signatures on keys solves the issue of
downloading 'untrusted' keys.
Currently, there is a problem with some keyservers that assume that only
accept one of any short key ID, but this is an implementation issue, not a
trust one.

@_date: 2000-03-24 17:55:12
@_author: Frank Tobin 
@_subject: gpg --recv-key option 
Hash: SHA1
It is not wrong.  GnuPG could very easily handle this.  The standard
keyservers don't seem return a keyblock for non-ID searches; they return a
list of possible keys, describing their size, hexID, user ids, etc.  GnuPG would then present these user ID's to the user, and then the user
would select which hexID(s) to download.  There is no need to get every
match for "Bob Smith".
How does this solve the issue?  How do you know which Bob Smith to choose?

@_date: 2000-03-27 01:42:18
@_author: Frank Tobin 
@_subject: gpg --recv-key option 
Hash: SHA1
You should be able to search the keyserver by fingerprint.  You would have
already obtained this fingerprint through another channel which would not
have been conducive to transmitting the entire key (for example,
handwritten on paper).

@_date: 2000-03-08 18:28:30
@_author: Frank Tobin 
@_subject: trusting an imported key which is the only key in a ring? 
Hash: SHA1
While I do not have a great answer to this situation, I feel it is an
interesting predicament that needs to be looked at.  I agree that one
should not have to have a local secret key in order to initiate the
validity/trust tree.  True, one could have a throw-away local key to start
the tree, and just sign keys locally, but this is cumbersome and among
other things, requires the key to be generated, which can be an
undesirable process.  It also undesirably requires another file to hold
the secret key (I'm not concerned about 'space' here but 'cleanness' and
Perhaps what is needed is for each user to have an maximally insecure,
unprotected, (virtually blank) 'dumby', non-exportable secret key which is
used solely for the purpose of initiating validity trees.  This could take
the form of an option, say "--trust-key 0x000000" (note I don't know if
this key ID is even valid).  A user could then use '--lsign' and friends
to initiate validity.
Perhaps there are reserved key ID's in OpenPGP that I haven't noticed that
GnuPG could use locally for this purpose.

@_date: 2000-03-09 15:21:38
@_author: Frank Tobin 
@_subject: trusting an imported key which is the only key in a ring? 
I think what is desired is not for the key to be "trusted" but rahter
"valid"; that is, having the desired effect equal to having the key signed
with a trusted key.

@_date: 2000-03-09 15:23:42
@_author: Frank Tobin 
@_subject: Q: device not configured 
Option "no-tty" is undocumented in 1.0.1's manpage (I don't have "c" yet).

@_date: 2000-03-16 04:32:07
@_author: Frank Tobin 
@_subject: 1.0.1 dumps on --with-key-data --list-secret-keys 
Something tells me that GnuPG should play nice here; 1.0.1 dumps with
"--list-secret" together with "--with-key-data".  (Of course I know that
it can't display the key data, but it should be graceful about it :) ).
isr4033 ~> gpg --with-key-data --list-secret-keys $MYKEY
sec:u:1024:17:56FFD10A260C4FA3:1999-04-22:2001-04-21:::Frank J. Tobin
gpg: Segmentation fault caught ... exiting

@_date: 2000-03-16 23:00:03
@_author: Frank Tobin 
@_subject: PGP 5.x and GnuPG 
Hash: SHA1
The v3 keys that PGP5 and earlier created are vulnerable to certain
attacks.  That is the reason they are now deprecated.  In the RFC there
are SHOULD's and MUSTS.  From the RFC, 5.5.2:
"OpenPGP implementations SHOULD create keys with version 4 format. An
implementation MAY generate a V3 key to ensure interoperability with
old software; note, however, that V4 keys correct some security
deficiencies in V3 keys. These deficiencies are described below. An
implementation MUST NOT create a V3 key with a public key algorithm
other than RSA."
You might be interested in browsing the section of the RFC entitled
"Implementation Nits":

@_date: 2000-03-23 04:36:39
@_author: Frank Tobin 
@_subject: if someone steals your key... 
Hash: SHA1
Your private key is encrypted symmetrically with a hash of your
passphrase.  Given that the algorithm used is good, the best attack lays
in the way of brute-forcing the passphrase.  Hence, if the passphrase is
poor, it will be relatively easy to break the key, while if the passphrase
is strong it will be more difficult.  Useful information and references
can be found at:

@_date: 2000-03-24 16:58:47
@_author: Frank Tobin 
@_subject: gpg --recv-key option 
Hash: SHA1
Please qualify this remark.  Signatures on keys solves the issue of
downloading 'untrusted' keys.
Currently, there is a problem with some keyservers that assume that only
accept one of any short key ID, but this is an implementation issue, not a
trust one.

@_date: 2000-03-24 17:55:12
@_author: Frank Tobin 
@_subject: gpg --recv-key option 
Hash: SHA1
It is not wrong.  GnuPG could very easily handle this.  The standard
keyservers don't seem return a keyblock for non-ID searches; they return a
list of possible keys, describing their size, hexID, user ids, etc.  GnuPG would then present these user ID's to the user, and then the user
would select which hexID(s) to download.  There is no need to get every
match for "Bob Smith".
How does this solve the issue?  How do you know which Bob Smith to choose?

@_date: 2000-03-27 01:42:18
@_author: Frank Tobin 
@_subject: gpg --recv-key option 
Hash: SHA1
You should be able to search the keyserver by fingerprint.  You would have
already obtained this fingerprint through another channel which would not
have been conducive to transmitting the entire key (for example,
handwritten on paper).

@_date: 2000-05-01 17:09:26
@_author: Frank Tobin 
@_subject: quick question 
I recommend using a GnuPG perl module available from CPAN.

@_date: 2000-05-02 17:05:12
@_author: Frank Tobin 
@_subject: Decryption through CGI/Perl script 
Hash: SHA1
Why can't you use this without managing your server?  Just install to a
private path, and make sure you 'use lib'.

@_date: 2000-05-05 19:45:31
@_author: Frank Tobin 
@_subject: Conflict with SSL 
Try using GnuPG's homedir option to decide where its home directory (and
subsequently where it tries to write to).
On a side note, I think that this situation shows the need for a separate
option in GnuPG, say tempdir, which decides which directory GnuPG uses for
its temporary files.  This can be very useful in instances where the home
directory is read-only, but temporary files still need to be created.

@_date: 2000-05-06 09:06:10
@_author: Frank Tobin 
@_subject: Key servers 
These sort of questions are becoming more and more common, and I think it
has to do with the poor layout of the GnuPG website (even I have to dig
around for the mailing list info if I have to reference it).  I think
there should be a top-level section of the website entitled
"Community"; this is a generic name that could encompass
currently-misplaced things such as keysigning parties and mailing lists.

@_date: 2000-05-11 02:55:35
@_author: Frank Tobin 
@_subject: Newbie question ... 
Read the BUGS section of the manpage, and search for the
'no-secmem-warning' option.

@_date: 2000-05-16 15:35:27
@_author: Frank Tobin 
@_subject: Help! :( 
echo 'rand_irqs="1 10 12 14 15"' >> /etc/rc.conf
man rndcontrol
By default FreeBSD uses nothing but the keyboard (low source of
entropy) for it's entropy pool.  The above settings get it from several
sources (I forget which numbers are what..I used xosview to find out which
interrupts were being used on my system.  You'll need to make sure I
quoted stuff correctly above there and reboot after the changes are made,
or else use "rndcontrol -s num" for each number listed above.

@_date: 2000-05-17 08:44:14
@_author: Frank Tobin 
@_subject: Help! :( 
I was lazy and used the port xosview to see blinking lights matching with
interrupts. :)

@_date: 2000-05-18 01:02:47
@_author: Frank Tobin 
@_subject: GnuPG with Netscape Messenger? 
You wish :P  I wouldn't hold your breath waiting for a positive answer :)

@_date: 2000-05-18 14:26:52
@_author: Frank Tobin 
@_subject: decrypting input, not a file... 
While I think using shell for anything sensitive is ridiculous...this
might work.  I don't recommend passing in passphrases to stdin, however,
in case you run situations where the passhrase isn't needed, and is
processed as part of the normal message by GnuPG.
echo "$passphrase\n$string" | gpg --passphrase-fd 0 --decrypt
It is advisable for you to subscribe.  Lots of goodies for those who do :)

@_date: 2000-05-25 08:31:45
@_author: Frank Tobin 
@_subject: Calling GPG from Perl from Procmail from... 
Hash: SHA1
Already done in pgpenvelope:
Note you don't need to use the Pine functionality of pgpenvelope if you
don't want.  It won't be sad.
The Perl module it uses is GnuPG::Interface; you may be interested in
looking into it:
The exit status is a bad way to check if the signature was verified; the
exit status best represents that GnuPG exited properly.  Check the
signature status via the status-fd filehandle.  Read the DETAILS file with
GnuPG for, well, details.
You need to pass --no-tty.

@_date: 2000-05-30 11:12:24
@_author: Frank Tobin 
@_subject: installation errors 
I can't help you much with the error you are getting, but you might want
to try the RPM instead.

@_date: 2000-05-30 17:13:26
@_author: Frank Tobin 
@_subject: installation errors 
Your version of gcc is not the recommended stable version.  According to
 the current stable version is gcc 2.95.2, but gcc
2.8.1 might be okay too.  This might be a source of problems.
RedHat Package Manager.  Sorta of a pre-compiled distribution installation
system.  I can't remember offhand who is distributing the RPM for GnuPG
(it's not official from Werner, IIRC).  Can't provide you with details on
how to handle it on a Slackware system either.

@_date: 2000-05-01 17:09:26
@_author: Frank Tobin 
@_subject: quick question 
I recommend using a GnuPG perl module available from CPAN.

@_date: 2000-05-02 17:05:12
@_author: Frank Tobin 
@_subject: Decryption through CGI/Perl script 
Hash: SHA1
Why can't you use this without managing your server?  Just install to a
private path, and make sure you 'use lib'.

@_date: 2000-05-05 19:45:31
@_author: Frank Tobin 
@_subject: Conflict with SSL 
Try using GnuPG's homedir option to decide where its home directory (and
subsequently where it tries to write to).
On a side note, I think that this situation shows the need for a separate
option in GnuPG, say tempdir, which decides which directory GnuPG uses for
its temporary files.  This can be very useful in instances where the home
directory is read-only, but temporary files still need to be created.

@_date: 2000-05-06 09:06:10
@_author: Frank Tobin 
@_subject: Key servers 
These sort of questions are becoming more and more common, and I think it
has to do with the poor layout of the GnuPG website (even I have to dig
around for the mailing list info if I have to reference it).  I think
there should be a top-level section of the website entitled
"Community"; this is a generic name that could encompass
currently-misplaced things such as keysigning parties and mailing lists.

@_date: 2000-05-11 02:55:35
@_author: Frank Tobin 
@_subject: Newbie question ... 
Read the BUGS section of the manpage, and search for the
'no-secmem-warning' option.

@_date: 2000-05-16 15:35:27
@_author: Frank Tobin 
@_subject: Help! :( 
echo 'rand_irqs="1 10 12 14 15"' >> /etc/rc.conf
man rndcontrol
By default FreeBSD uses nothing but the keyboard (low source of
entropy) for it's entropy pool.  The above settings get it from several
sources (I forget which numbers are what..I used xosview to find out which
interrupts were being used on my system.  You'll need to make sure I
quoted stuff correctly above there and reboot after the changes are made,
or else use "rndcontrol -s num" for each number listed above.

@_date: 2000-05-17 08:44:14
@_author: Frank Tobin 
@_subject: Help! :( 
I was lazy and used the port xosview to see blinking lights matching with
interrupts. :)

@_date: 2000-05-18 01:02:47
@_author: Frank Tobin 
@_subject: GnuPG with Netscape Messenger? 
You wish :P  I wouldn't hold your breath waiting for a positive answer :)

@_date: 2000-05-18 14:26:52
@_author: Frank Tobin 
@_subject: decrypting input, not a file... 
While I think using shell for anything sensitive is ridiculous...this
might work.  I don't recommend passing in passphrases to stdin, however,
in case you run situations where the passhrase isn't needed, and is
processed as part of the normal message by GnuPG.
echo "$passphrase\n$string" | gpg --passphrase-fd 0 --decrypt
It is advisable for you to subscribe.  Lots of goodies for those who do :)

@_date: 2000-05-25 08:31:45
@_author: Frank Tobin 
@_subject: Calling GPG from Perl from Procmail from... 
Hash: SHA1
Already done in pgpenvelope:
Note you don't need to use the Pine functionality of pgpenvelope if you
don't want.  It won't be sad.
The Perl module it uses is GnuPG::Interface; you may be interested in
looking into it:
The exit status is a bad way to check if the signature was verified; the
exit status best represents that GnuPG exited properly.  Check the
signature status via the status-fd filehandle.  Read the DETAILS file with
GnuPG for, well, details.
You need to pass --no-tty.

@_date: 2000-05-30 11:12:24
@_author: Frank Tobin 
@_subject: installation errors 
I can't help you much with the error you are getting, but you might want
to try the RPM instead.

@_date: 2000-05-30 17:13:26
@_author: Frank Tobin 
@_subject: installation errors 
============================== START ==============================
Your version of gcc is not the recommended stable version.  According to
 the current stable version is gcc 2.95.2, but gcc
2.8.1 might be okay too.  This might be a source of problems.
RedHat Package Manager.  Sorta of a pre-compiled distribution installation
system.  I can't remember offhand who is distributing the RPM for GnuPG
(it's not official from Werner, IIRC).  Can't provide you with details on
how to handle it on a Slackware system either.

@_date: 2000-11-08 06:28:33
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
In GnuPG 1.0.4, during key generation, the question concerning key
expiration defaults to no expiration.  I think most users would be better
served by having the default option be some expiration, possibly 1 year.  Generally, new users will make fatal mistakes when generating/using their
first keys, and having a reasonably short expiration could minimize the
possibiliy of the the bad effects of these keys being "forever" (e.g.,
without expiration).
Also, after key generation is completed, it might be useful for GnuPG to
display a link to some documention concerning what one should do with
newly-created keys.  This documentation could provide such information
such as how to create backups of the secret keys, how to create backup
revocation certs, and other useful information.  I feel that many new
users create new keys without much knowledge of what they are doing, or
what steps they should take after creating the key; providing a reference
to such documentation would help them a lot.

@_date: 2000-11-08 17:22:03
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
Just a suspisicion, but I'd guess new users lose access to their keys
before they would realize this :(

@_date: 2000-11-08 17:27:32
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
Sure, they should have keys, even if revoked.  Your jump to "therefore, it
is better that those keys have no date of expiry" does not follow,
Expiration does not prevent anyone from doing anything.  It is merely

@_date: 2000-11-08 17:31:55
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
They key question one has to ask oneself is "what would be best for new
users", for that is what "defaults" are good for.  The idea is to help the
user make a good decision, without the user needing to research everything
beforehand.  And, in my opinion, having an expiration, is, in most cases,
a "good thing".

@_date: 2000-11-09 05:38:17
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
The idea is to let it be a short, but reasonably useful expiration.  I
think 1 year is a good balance.

@_date: 2000-11-09 05:44:56
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
The expiration is stored in a self-signatures.  Signatures are considered
additive by keyservers, so one can have multiple expirations on one key.  How the OpenPGP implementation handles multiple situations is up to the
implementation, if I'm not mistaken.  Two reasonable choices could be
made; consider only the shortest expiration, or consider the expiration
that was most recently created.

@_date: 2000-11-09 14:28:32
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
1 year is a good default, I feel.  This gives new users enough time to
understand how OpenPGP systems work, and extend their keys if necessary
(even if only through creating a new key, signed by the old one).

@_date: 2000-11-20 08:58:03
@_author: Frank Tobin 
@_subject: confirmation for --export-secret-key 
Hash: SHA1
    If you have acccess to .mutrc you have alos access to
    .gnupg/secring.gpg - so who cares.
While I may not agree with the initial author's request to have a prompt
for exporting the secret key, Werner's statement here is not necessarily
correct, and implies people are only working with a 'standard' system.  On some of my systems, I use CFS (cryptographic filesystem) to encrypt my
ssh and gnupg dirs.  These dirs are only "available" at certain times
(specifically, when I cattach them).
On a side note, it's really bad to assume the standard unix notion of
"user gets full access to all his stuff".  Through some means, the user
might restrict his standard access through means as CFS, TCFS, or a
system-level restrainer, but then can gain higher priviles by
authenticating with the system through a more stringent method (note: this
is not the same as su-ing to a different user).  True, most unixes don't
have the capability to divide up a user's capabilities yet, but that's
because unix could, ehem, use a bit of work in its capabilities model.

@_date: 2000-11-08 06:28:33
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
In GnuPG 1.0.4, during key generation, the question concerning key
expiration defaults to no expiration.  I think most users would be better
served by having the default option be some expiration, possibly 1 year.  Generally, new users will make fatal mistakes when generating/using their
first keys, and having a reasonably short expiration could minimize the
possibiliy of the the bad effects of these keys being "forever" (e.g.,
without expiration).
Also, after key generation is completed, it might be useful for GnuPG to
display a link to some documention concerning what one should do with
newly-created keys.  This documentation could provide such information
such as how to create backups of the secret keys, how to create backup
revocation certs, and other useful information.  I feel that many new
users create new keys without much knowledge of what they are doing, or
what steps they should take after creating the key; providing a reference
to such documentation would help them a lot.

@_date: 2000-11-08 17:22:03
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
Just a suspisicion, but I'd guess new users lose access to their keys
before they would realize this :(

@_date: 2000-11-08 17:27:32
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
Sure, they should have keys, even if revoked.  Your jump to "therefore, it
is better that those keys have no date of expiry" does not follow,
Expiration does not prevent anyone from doing anything.  It is merely

@_date: 2000-11-08 17:31:55
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
They key question one has to ask oneself is "what would be best for new
users", for that is what "defaults" are good for.  The idea is to help the
user make a good decision, without the user needing to research everything
beforehand.  And, in my opinion, having an expiration, is, in most cases,
a "good thing".

@_date: 2000-11-09 05:38:17
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
The idea is to let it be a short, but reasonably useful expiration.  I
think 1 year is a good balance.

@_date: 2000-11-09 05:44:56
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
The expiration is stored in a self-signatures.  Signatures are considered
additive by keyservers, so one can have multiple expirations on one key.  How the OpenPGP implementation handles multiple situations is up to the
implementation, if I'm not mistaken.  Two reasonable choices could be
made; consider only the shortest expiration, or consider the expiration
that was most recently created.

@_date: 2000-11-09 14:28:32
@_author: Frank Tobin 
@_subject: suggestions surrounding key generating 
Hash: SHA1
1 year is a good default, I feel.  This gives new users enough time to
understand how OpenPGP systems work, and extend their keys if necessary
(even if only through creating a new key, signed by the old one).

@_date: 2000-11-20 08:58:03
@_author: Frank Tobin 
@_subject: confirmation for --export-secret-key 
Hash: SHA1
    If you have acccess to .mutrc you have alos access to
    .gnupg/secring.gpg - so who cares.
While I may not agree with the initial author's request to have a prompt
for exporting the secret key, Werner's statement here is not necessarily
correct, and implies people are only working with a 'standard' system.  On some of my systems, I use CFS (cryptographic filesystem) to encrypt my
ssh and gnupg dirs.  These dirs are only "available" at certain times
(specifically, when I cattach them).
On a side note, it's really bad to assume the standard unix notion of
"user gets full access to all his stuff".  Through some means, the user
might restrict his standard access through means as CFS, TCFS, or a
system-level restrainer, but then can gain higher priviles by
authenticating with the system through a more stringent method (note: this
is not the same as su-ing to a different user).  True, most unixes don't
have the capability to divide up a user's capabilities yet, but that's
because unix could, ehem, use a bit of work in its capabilities model.

@_date: 2000-10-02 13:34:21
@_author: Frank Tobin 
@_subject: GnuPG::Interface 
Hash: SHA1
I should put this up as a FAQ in SourceForge's documentation for
GnuPG::Interface.  Your problem is likely due to permissions problems,
such as readability of $gnupg->options->homedir(), and the public keys
related.  Capture the output of GnuPG's stderr, print it to your stdout.
Let me know how you solved the problem so I can make a good canned

@_date: 2000-10-05 21:48:36
@_author: Frank Tobin 
@_subject: exported GPG keys seemingly not behaving in PGP 
Hash: SHA1
In order to be compatible with older versions of PGP which do not
accept v4 signatures, you need the following options:
compress-algo 1

@_date: 2000-10-13 20:05:15
@_author: Frank Tobin 
@_subject: GPG 1.0.3 doesn't detect modifications to files with multiple 
Hash: SHA1
I would like to take the moment to thank Werner for the quick analysis and
professional response.

@_date: 2000-10-17 14:30:23
@_author: Frank Tobin 
@_subject: verifying signatures in .forward/.qmail files 
You might be interested in using the Perl module GnuPG::Interface for this
task, while reading the GnuPG::Handles->status_fh() filehandle.  GnuPG
spits out verification information concerning the validity of the
signature and which was the signing key in through the status-fd.

@_date: 2000-10-18 14:20:08
@_author: Frank Tobin 
@_subject: GnuPG 1.0.4 does not create ~/.gnupg/ 
Hash: SHA1
GnuPG 1.0.4 does not appear to create ~/.gnupg/ automatically if it does
not exist.
palanthas ~> gpg --version
gpg (GnuPG) 1.0.4
palanthas ~> test -e ~/.gnupg ; echo $?
palanthas ~> gpg --keyserver horowitz.surfnet.nl --recv-key 0x260C4FA3
gpg: Warning: using insecure memory!
gpg: keyblock resource `/home/ftobin/.gnupg': file open error
gpg: keyblock resource `/home/ftobin/.gnupg': file open error
gpg: requesting key 260C4FA3 from horowitz.surfnet.nl ...
gpg: no default public keyring
gpg: error reading `[stream]': general error
gpg: Total number processed: 0

@_date: 2000-10-18 20:11:00
@_author: Frank Tobin 
@_subject: Insecure Memory Warning! ???. 
Hash: SHA1
Seriously, given the amount of times this is posted to this mailing list,
this warning needs to disappear, or point the user to some relevant
documentation on why it is appearing, and how to remedy it.

@_date: 2000-10-19 14:06:30
@_author: Frank Tobin 
@_subject: Insecure Memory Warning! ???. 
Hash: SHA1
As mentioned as the second part of my post, the warning, if not removed,
should have a pointer to documentation describing the warning.  If you
want people to read the manpage, tell them:
  gpg: Warning: using insecure memory!  See BUGS in the manpage.
And in addition, add the following to BUGS in the manpage:
  If this program is not installed as setuid(root), you may get a warning
  such as "Warning: using insecure memory!".  To ignore this warning, add
  the option "no-secmem-warning" to your ~/.gnupg/options file.
If these two steps were done, I think this would solve a lot of user's
questions/problems/postings.  Documenation is one thing one shouldn't
skimp on by any means.  And having FAQ's is not the only way; you need
_linking_ between the documentation (hypertext or just plain textual
references is fine).  Expecting users to blindly lookup answers in a FAQ
which isn't usuably available to 'normal' users is pretty unreasonable.  The only documentation available is the manpage, and there is no reference
to a FAQ in the manpage.

@_date: 2000-10-19 14:13:33
@_author: Frank Tobin 
@_subject: Perl Wrapper for GPG? 
Hash: SHA1
Why would anyone want to re-implement OpenPGP in Perl when one should be
relying on existing implementations?  OpenPGP functionality cannot simply
be wrapped inside a "crypt" call.  The sanest way to handle the operation
is to hand off the data to GnuPG in some form.  This is what GnuPG.pm and
GnuPG::Interface do (two CPAN-available modules).

@_date: 2000-10-22 04:43:09
@_author: Frank Tobin 
@_subject: keyblock resource: file open error 
Hash: SHA1
It's been reported and a fix is in the works.

@_date: 2000-10-29 19:41:47
@_author: Frank Tobin 
@_subject: Can I wipe the original un-encrypted file in GPG? 
Hash: SHA1
This is not the responsibility of GnuPG to perform; there are other tools
to perform this action.  In any case, trying to perform 'good wipes' is
generally wild goose chase, full of problems and holes, and often not
possible to do in any fashion.

@_date: 2000-10-02 13:34:21
@_author: Frank Tobin 
@_subject: GnuPG::Interface 
Hash: SHA1
I should put this up as a FAQ in SourceForge's documentation for
GnuPG::Interface.  Your problem is likely due to permissions problems,
such as readability of $gnupg->options->homedir(), and the public keys
related.  Capture the output of GnuPG's stderr, print it to your stdout.
Let me know how you solved the problem so I can make a good canned

@_date: 2000-10-05 21:48:36
@_author: Frank Tobin 
@_subject: exported GPG keys seemingly not behaving in PGP 
Hash: SHA1
In order to be compatible with older versions of PGP which do not
accept v4 signatures, you need the following options:
compress-algo 1

@_date: 2000-10-13 20:05:15
@_author: Frank Tobin 
@_subject: GPG 1.0.3 doesn't detect modifications to files with multiple 
Hash: SHA1
I would like to take the moment to thank Werner for the quick analysis and
professional response.

@_date: 2000-10-17 14:30:23
@_author: Frank Tobin 
@_subject: verifying signatures in .forward/.qmail files 
You might be interested in using the Perl module GnuPG::Interface for this
task, while reading the GnuPG::Handles->status_fh() filehandle.  GnuPG
spits out verification information concerning the validity of the
signature and which was the signing key in through the status-fd.

@_date: 2000-10-18 14:20:08
@_author: Frank Tobin 
@_subject: GnuPG 1.0.4 does not create ~/.gnupg/ 
Hash: SHA1
GnuPG 1.0.4 does not appear to create ~/.gnupg/ automatically if it does
not exist.
palanthas ~> gpg --version
gpg (GnuPG) 1.0.4
palanthas ~> test -e ~/.gnupg ; echo $?
palanthas ~> gpg --keyserver horowitz.surfnet.nl --recv-key 0x260C4FA3
gpg: Warning: using insecure memory!
gpg: keyblock resource `/home/ftobin/.gnupg': file open error
gpg: keyblock resource `/home/ftobin/.gnupg': file open error
gpg: requesting key 260C4FA3 from horowitz.surfnet.nl ...
gpg: no default public keyring
gpg: error reading `[stream]': general error
gpg: Total number processed: 0

@_date: 2000-10-18 20:11:00
@_author: Frank Tobin 
@_subject: Insecure Memory Warning! ???. 
Hash: SHA1
Seriously, given the amount of times this is posted to this mailing list,
this warning needs to disappear, or point the user to some relevant
documentation on why it is appearing, and how to remedy it.

@_date: 2000-10-19 14:06:30
@_author: Frank Tobin 
@_subject: Insecure Memory Warning! ???. 
Hash: SHA1
As mentioned as the second part of my post, the warning, if not removed,
should have a pointer to documentation describing the warning.  If you
want people to read the manpage, tell them:
  gpg: Warning: using insecure memory!  See BUGS in the manpage.
And in addition, add the following to BUGS in the manpage:
  If this program is not installed as setuid(root), you may get a warning
  such as "Warning: using insecure memory!".  To ignore this warning, add
  the option "no-secmem-warning" to your ~/.gnupg/options file.
If these two steps were done, I think this would solve a lot of user's
questions/problems/postings.  Documenation is one thing one shouldn't
skimp on by any means.  And having FAQ's is not the only way; you need
_linking_ between the documentation (hypertext or just plain textual
references is fine).  Expecting users to blindly lookup answers in a FAQ
which isn't usuably available to 'normal' users is pretty unreasonable.  The only documentation available is the manpage, and there is no reference
to a FAQ in the manpage.

@_date: 2000-10-19 14:13:33
@_author: Frank Tobin 
@_subject: Perl Wrapper for GPG? 
Hash: SHA1
Why would anyone want to re-implement OpenPGP in Perl when one should be
relying on existing implementations?  OpenPGP functionality cannot simply
be wrapped inside a "crypt" call.  The sanest way to handle the operation
is to hand off the data to GnuPG in some form.  This is what GnuPG.pm and
GnuPG::Interface do (two CPAN-available modules).

@_date: 2000-10-22 04:43:09
@_author: Frank Tobin 
@_subject: keyblock resource: file open error 
Hash: SHA1
It's been reported and a fix is in the works.

@_date: 2000-10-29 19:41:47
@_author: Frank Tobin 
@_subject: Can I wipe the original un-encrypted file in GPG? 
Hash: SHA1
This is not the responsibility of GnuPG to perform; there are other tools
to perform this action.  In any case, trying to perform 'good wipes' is
generally wild goose chase, full of problems and holes, and often not
possible to do in any fashion.

@_date: 2000-09-11 15:15:38
@_author: Frank Tobin 
@_subject: Problem with gpg instalation 
Hash: SHA1
You may want to explore other GnuPG modules available at CPAN if GnuPG.pm
is giving you problems.

@_date: 2000-09-12 22:26:54
@_author: Frank Tobin 
@_subject: Creating a private/public key... 
Hash: SHA1
This fine, as long as you are in control of the server, and you can
connect securely to it.
Likely because you do not have enough entropy (randomness) in the system.  Make your computer work hard (e.g., "find /" ), and this will help during
key-generation.  If you are using FreeBSD, look into rndcontrol.
You need to export your secret key from the windows machine, and then
import it into GnuPG.
It might be good to read some of the documentation available at
 specifically "How PGP works".

@_date: 2000-09-13 05:00:43
@_author: Frank Tobin 
@_subject: Improved verification of messages 
Hash: SHA1
This is a bad approach, does not provide you with any real security, and
makes you semi-believe you've got some sort of authentication by having
orders encrypted with a specific public-key.  Your security needs to come
from authenticating that orders come from your webserver to your
processing forms correctly, and from your processing forms to you
correctly.  Or, why not just accept any form as being valid?  Use the
payment options as authentication.

@_date: 2000-09-13 22:45:48
@_author: Frank Tobin 
@_subject: "--clearsign" bug? 
No, this is not a gnupg bug.  This is GnuPG dash-escaping the dashes.

@_date: 2000-09-14 14:33:05
@_author: Frank Tobin 
@_subject: Groups 
Hash: SHA1
As I wrote to the pgpenvelope-users list, a good way to approach this
would be to just write a wrapper for GnuPG, which looks at all the
arguments which take key-indidcators as arguments, and then try to match
any of these key-indicators with a lookup table (addressbook).
E.g., given the following table:
cia-operatives: bob abc
mom: judy
mykey: 0xABCD1234
myotherkey: 0x1234ABCD
...and a wrapper program rgpg:
rgpg --default-key myotherkey --sign --encrypt -r cia-operatives -r mom
...it would expand this to and exec:
gpg --default-key 0x1234ABCD --sign --encrypt -r bob \
    -r abc -r judy
This wrapper would be _very_ simple to write, and I'll probably do it real

@_date: 2000-09-17 17:42:39
@_author: Frank Tobin 
@_subject: clearsigning perl ? 
Hash: SHA1
Your best solution is to make a real perl package, full with the
Makefile.PL., and then sign the tar.gz.  Perl, when it installs
perl scripts, changing the beginning line automatically; however,
one checks the sigs before even untarring/ungzipping, so this is
not a problem.
If you are new to Perl package management, I can personally recommend
pgpenvelope, at  as an example of how
to approach it.  Feel free to mail me off-list for further questions about

@_date: 2000-09-25 15:58:30
@_author: Frank Tobin 
@_subject: Unsupported public key algorithm 
Hash: SHA1
The R in 1022R means RSA.  Get GnuPG 1.0.3 (the RSA patent has
expired) and you'll be able to import the key.

@_date: 2000-09-26 09:54:27
@_author: Frank Tobin 
@_subject: GnuPG 1.03, RSA/IDEA, and cipher-algo preferences 
Hash: SHA1
It does?  Doesn't sound like that to me.  What it means is that you
specify not a default cipher for the key, but a cipher to use for that
session.  That is, you use --cipher-algo in conjunction with --encrypt or
similar command.

@_date: 2000-09-11 15:15:38
@_author: Frank Tobin 
@_subject: Problem with gpg instalation 
Hash: SHA1
You may want to explore other GnuPG modules available at CPAN if GnuPG.pm
is giving you problems.

@_date: 2000-09-12 22:26:54
@_author: Frank Tobin 
@_subject: Creating a private/public key... 
Hash: SHA1
This fine, as long as you are in control of the server, and you can
connect securely to it.
Likely because you do not have enough entropy (randomness) in the system.  Make your computer work hard (e.g., "find /" ), and this will help during
key-generation.  If you are using FreeBSD, look into rndcontrol.
You need to export your secret key from the windows machine, and then
import it into GnuPG.
It might be good to read some of the documentation available at
 specifically "How PGP works".

@_date: 2000-09-13 05:00:43
@_author: Frank Tobin 
@_subject: Improved verification of messages 
Hash: SHA1
This is a bad approach, does not provide you with any real security, and
makes you semi-believe you've got some sort of authentication by having
orders encrypted with a specific public-key.  Your security needs to come
from authenticating that orders come from your webserver to your
processing forms correctly, and from your processing forms to you
correctly.  Or, why not just accept any form as being valid?  Use the
payment options as authentication.

@_date: 2000-09-13 22:45:48
@_author: Frank Tobin 
@_subject: "--clearsign" bug? 
No, this is not a gnupg bug.  This is GnuPG dash-escaping the dashes.

@_date: 2000-09-14 14:33:05
@_author: Frank Tobin 
@_subject: Groups 
Hash: SHA1
As I wrote to the pgpenvelope-users list, a good way to approach this
would be to just write a wrapper for GnuPG, which looks at all the
arguments which take key-indidcators as arguments, and then try to match
any of these key-indicators with a lookup table (addressbook).
E.g., given the following table:
cia-operatives: bob abc
mom: judy
mykey: 0xABCD1234
myotherkey: 0x1234ABCD
...and a wrapper program rgpg:
rgpg --default-key myotherkey --sign --encrypt -r cia-operatives -r mom
...it would expand this to and exec:
gpg --default-key 0x1234ABCD --sign --encrypt -r bob \
    -r abc -r judy
This wrapper would be _very_ simple to write, and I'll probably do it real

@_date: 2000-09-17 17:42:39
@_author: Frank Tobin 
@_subject: clearsigning perl ? 
Hash: SHA1
Your best solution is to make a real perl package, full with the
Makefile.PL., and then sign the tar.gz.  Perl, when it installs
perl scripts, changing the beginning line automatically; however,
one checks the sigs before even untarring/ungzipping, so this is
not a problem.
If you are new to Perl package management, I can personally recommend
pgpenvelope, at  as an example of how
to approach it.  Feel free to mail me off-list for further questions about

@_date: 2000-09-25 15:58:30
@_author: Frank Tobin 
@_subject: Unsupported public key algorithm 
Hash: SHA1
The R in 1022R means RSA.  Get GnuPG 1.0.3 (the RSA patent has
expired) and you'll be able to import the key.

@_date: 2000-09-26 09:54:27
@_author: Frank Tobin 
@_subject: GnuPG 1.03, RSA/IDEA, and cipher-algo preferences 
Hash: SHA1
It does?  Doesn't sound like that to me.  What it means is that you
specify not a default cipher for the key, but a cipher to use for that
session.  That is, you use --cipher-algo in conjunction with --encrypt or
similar command.

@_date: 2001-04-02 23:08:00
@_author: Frank Tobin 
@_subject: tty error 
gpg: cannot open /dev/tty: Device not configured
Use the --no-tty option.

@_date: 2001-04-03 01:27:05
@_author: Frank Tobin 
@_subject: Password Prompt 
How do I avoid password prompt to --clearsign a document? How do I
    do the same for email? It would become really annoying to type a
    password each time you want to send a signed email.
Quintuple Agent:

@_date: 2001-04-04 18:37:06
@_author: Frank Tobin 
@_subject: Gnupg and X509 certificates 
2) Why in GPG X509 certificates were completely ignored (More
    theoretical question, but important for me to understand)?
GnuPG, first and foremost, is an implementation of the OpenPGP standard
(RFC 2440), which is a competing infrastructure, different from X509.
They are both public-key cryptosystems, but how the public keys are
actually handled is different in the two systems.

@_date: 2001-04-07 00:58:01
@_author: Frank Tobin 
@_subject: [Announce] new gnupg snapshot 
IIRC, if you have a secret key it is ultimately trusted by default.
    Persuading you to import a secret key could, therefore, subvert your
    web of trust.
There are two issues here:
1) importing trust
2) importing a secret key
Your arguments seem to state that importing a secret key implies importing
trust.  Why would GnuPG _ever_ import trust without direct user knowledge?
I'm not clearly seeing why importing a secret key, alone, is any threat.

@_date: 2001-04-07 19:54:09
@_author: Frank Tobin 
@_subject: [Announce] new gnupg snapshot 
> Well, it can't happen without the user noticing it anymore. Till now
    > you could import a bunch of public keys and this didn't prevent
    > importing of a secret key hidden amongst them. Now you see that
    > there's somebody trying to feed you with a secret key. You can of
    > course import it (in a second go with the --allow-secret-key-import
    > switch), but it doesn't work without you noticing it.
Aargh, noone has yet said why importing a secret key is bad, and should be
limited in any way.
They have talked about why importing trust is bad, but importing trust !=
importing a secret key.

@_date: 2001-04-07 22:26:01
@_author: Frank Tobin 
@_subject: [Announce] new gnupg snapshot 
> They have talked about why importing trust is bad, but importing trust !=
    > importing a secret key.
    Not with GnuPG.  Importing a secret key implies importing trust.
Umm...then maybe _this_ is our problem?  Why are the two being considered
together at all?
Trust is something that is maintained separately in GnuPG, no?

@_date: 2001-04-09 17:33:23
@_author: Frank Tobin 
@_subject: keyblock resource, file open error? 
When I start to create a new key pair for the first time I get this error.
       gpg: keyblock resource `/root/.gnupg': file open error
mkdir ~root/.gnupg
The failure of GnuPG to create this for you is a bug.

@_date: 2001-04-09 17:36:01
@_author: Frank Tobin 
@_subject: Revoking old keys 
Hash: SHA1
    I have some old, expired keys that are listed in the various
    keyservers.  How do I go about sending the revocation certificate
    to them?
Import the revocation certificate to your keyring, then send the public
keys to the keyserver.  The revocation cert will be attached, and merged
into the keyservers' copy of key.

@_date: 2001-04-22 06:29:01
@_author: Frank Tobin 
@_subject: thoughts on options and commands 
Hash: SHA1
I've been thinking about the difference between options and commands, and
how one is supposed to arrange them on the command line.
Currently, the layout is:
  gpg options command arguments
I think this layout is not very friendly.  Generally, a user naturally
thinks to layout more in terms of how cvs does it.
  cvs global-options command command-options arguments
There is an analogy between cvs and gnupg's interface; each one is a sort
of 'meta-interface', with sub-commands.  E.g., cvs has "update" and
"commit", while gnupg has "encrypt" and "sign".  Each one has "global"
options which apply to each command: cvs has "-d" (the cvsroot), and gnupg
has "--homedir".  Each one has command-specific optoins, such as
"cvs update -A", and "gpg -r recipient --encrypt".
Given this analogy, I think that cvs's approach is better.  It certainly
is more "intuitive" (dare I use that word?), I feel.  Consider this:
a user does not say "I want the recipient to be Bob, and I want to
encrypt".  No, rather, a user thinks "I want to encrypt, with the
recipient being Bob".  Hence, the command-line should be layed out like:
  gpg encrypt -r Bob
As a side benefit, if GnuPG commands didn't have dashes in the front, like
cvs, there would be less confusion between the difference of the two (I
think many users don't understand the difference).
So, given this argument (no pun intended), I think that in the next major
release of GnuPG, the command-line interface should be revamped to be more
like cvs's.

@_date: 2001-04-22 16:13:01
@_author: Frank Tobin 
@_subject: New GnuPG command line option. 
Hash: SHA1
    Maybe you're nuts, what do I know ... :-) But anyway, you should
    be able to accomplish this with Frank Tobin's salias, I think.
     I haven't tested this, but
    Frank will probably tell me if I'm completely off track here ...
    :-) I salias is not the answer, writing a perl wrapper script
    shouldn't be too hard ...
salias will do exactly what you want.

@_date: 2001-04-22 16:21:02
@_author: Frank Tobin 
@_subject: New GnuPG command line option. 
Hash: SHA1
    > Is the "alias" option still on the schedule to be implemented some
    > time, or off the charts?  Just curious whether it's been dismissed
    > altogether, or I can still hope for it. :)
    When I started to implement it, I noticed that it was somewhat more
    complicated than I tought - can't remember the exact reason.  So I
    tought it was not worth the time.
The tricky issue I came across while writing salias was deciding how users
should specify aliase in a config file in a meaningful manner, while also
handling things like "repeated-options", such as GnuPG's -r.
salias can do things like expanding:
  gpg -r friends --encrypt
  gpg -r 0xABCD1234 -r funckyperson -r ABCD1234ASDF4545 --encrypt
Note salias is a general tool, not specific to GnuPG, and can be used with
any program.  For example, I use it to also alias:
    ssh-add all
    ssh-add /home/ftobin/.ssh/identity /home/ftobin/.ssh/id_dsa

@_date: 2001-04-22 19:25:01
@_author: Frank Tobin 
@_subject: thoughts on options and commands 
Hash: SHA1
    The problem with a change of the command-line argument syntax is
    that this change will break all the thousands of scripts and
    programs which call GnuPG. I don't think a more "intuitive"
    command-line interface is worth all the trouble it will undoubtly
    cause.
Purposely, I said the next "major" release (which means we can break
things :).  It would be dreadfully sad if GnuPG's ease of use is held back
forever just because of a command-line syntax that was thought up back in
the early alphas, and is clearly (IMO) surpassed by a cvs-style syntax.
I promise I'll update GnuPG::Interface if we change syntax.  :)

@_date: 2001-04-23 15:22:02
@_author: Frank Tobin 
@_subject: Re[2]: AW: GnuPG with PHP 
Hash: SHA1
    Unfortunately, the GPL's lack of freedom would prevent you from
    helping others by making your solution available to the public.
Yes, we all know how we "help others" by not providing them with Free
The GPL doesn't have have a lack of freedom; if PHP was under a Free
Softare license (even something laxer than the GPL), you could link to
GnuPG; it is just that the "combination" would become under the GPL.

@_date: 2001-04-23 21:49:01
@_author: Frank Tobin 
@_subject: Key switch 
Hash: SHA1
    5) Make my new kew the default.
Look at --default-key in the manpage.

@_date: 2001-04-23 23:06:01
@_author: Frank Tobin 
@_subject: Key switch 
Hash: SHA1
    Hmm. But as far as I can tell, that's on a per-invokation basis.
You can put options in the options file.

@_date: 2001-04-28 19:20:01
@_author: Frank Tobin 
@_subject: ordering the user-id listing 
In 1.0.4h, what determines the user-id sorting?  I noticed it changed
(breaking a lot of GnuPG::Interface regression tests).  Is it possible to
make the ordering an option?

@_date: 2001-04-28 19:31:02
@_author: Frank Tobin 
@_subject: PGP/MIME and RFC2440 ? 
Am I correct in presuming that PGP/MIME is part of RFC2440? If so,
    I cannot find reference to it, so if my presumption is correct,
    would some kind Member please direct me to the appropriate section
    in the RFC?
You would be incorrect in that presumption.

@_date: 2001-04-28 19:55:01
@_author: Frank Tobin 
@_subject: thoughts on options and commands 
> things :).  It would be dreadfully sad if GnuPG's ease of use is held back
    > forever just because of a command-line syntax that was thought up back in
    > the early alphas, and is clearly (IMO) surpassed by a cvs-style syntax.
    We have first to check what the GNU coding standards say to this.
Reading the GNU coding standards for "Standards for Command Line
Interfaces", it recommends using POSIX guidelines for CLI options.  Using
a cvs-style syntax would break this a bit, but cvs-style syntax can be
thought more of a "two-stage" argument processing (e.g., processing argv
up to the command "encrypt", then processing the argv after "encrypt").

@_date: 2001-04-28 20:04:01
@_author: Frank Tobin 
@_subject: ordering the user-id listing 
Can you rewrite your regression tests?  I know that this is a lot
    of work, but we have never defined a sorting order either ;-)
Well, given that different versions of GnuPG display the order
differently, I have just decided to not test user-id stuff anymore.
BTW, it was regression tests that caught the bit about the secret-key
subkeys not being listed.

@_date: 2001-08-15 00:01:01
@_author: Frank Tobin 
@_subject: How to encrypt streaming data realtime? 
is there a way to encrypt, lets say audio-streams? Realtime, of
   course :) , what shouldnt be a problem on a fast machine...
Best to not use GnuPG for this, except possible to exchange symmetric
cipher keys, which could then be used to encrypt the stream with a
symmetric cipher.  Sorta of like re-implementing the concept of OpenPGP up
a level.

@_date: 2001-08-15 00:02:01
@_author: Frank Tobin 
@_subject: License issues 
I'd like to use gnupg as an external encryption program for a
   shareware program I'm authoring. My program would just be a frontend
   which calls gnupg. Is this okay license-wise? Are there any
   commercial products using gnupg as a third-party utility?
While I am not an authority on the implications of the GNU GPL, it depends
on "how" you care "calling" GnuPG.  If you are doing so via pipes or
command-line, you should be fine.  If you are doing so via library
invocations, you might need to take a different approach.

@_date: 2001-02-01 17:46:05
@_author: Frank Tobin 
@_subject: gnupg.org mailing list memberships reminder 
Gotta love a mailing list devoted to email security that sends your password
    to you in cleartext once a month whether you like it or not.  I assume
    there's still no way to turn this off in mailman?  (I last asked a few years
    ago.)
First of all, the mailing list is not devoted to email security.  Anyone
who thinks OpenPGP is limited to email needs to re-think what it's good
When it comes to public mailing lists, the most important thing is to have
the least frustration for the end users and easiest management for the
administration.  While it does have the offset of lowering security, I
feel that in the end it provides for a much better experience of the
majority of end-users and administration to have monthly reminders.
There are multiple levels of security, and your email-subscriptions to
public mailing lists should really rank way down at the bottom of the

@_date: 2001-02-06 02:41:00
@_author: Frank Tobin 
@_subject: Make groups of keys in GnuPG? 
Hash: SHA1
    How can I do this in GnuPG? Do I have to make a script that runs
    gpg -e  -e  ...
I've created a genreric wrapper program called salias that can handle
aliasing program arguments.  In the most straightforward calling, it's
easy to set it up to do something like:
   salias gpg -r friends --encrypt
...and have it run:
  gpg -r fred -r bob -r sam --encrypt
You can transparently wrap salias by using shell aliasing:
  alias gpg="salias gpg"
or using the included salias-wrapper program.
salias is available at

@_date: 2001-02-06 18:42:01
@_author: Frank Tobin 
@_subject: Make groups of keys in GnuPG? 
> or using the included salias-wrapper program.
    I moved gpg and put this wrapper script in /usr/bin/gpg:
            base=`basename $0`
      salias --context $base /usr/bin/real/$base $@
This looks correct.  I think I just found the problem; if some of the
options/arguments to GnuPG have whitespace (e.g., like many
comments do), the shell script passes them on like:
   gpg --comment pgpenvelope 2.9.0 --encrypt
...which is obviously an illegal call; somehow I've just got to get the
wrapper-script to perform the proper quoting/argument passing.  I'll have
a new release as soon as I find a solution.
    I tried to remove the shell-script-wrapper and put the gpg back in its
    usual location (/usr/bin). An then I set the alias: alias gpg='salias gpg'
    But mailcrypt does not seem to recognize or use the alias at all:
Correct; this is actually primary reason for the making of salias;
programs calling GnuPG cannot handle the shell aliases/env vars.

@_date: 2001-02-06 19:18:04
@_author: Frank Tobin 
@_subject: Make groups of keys in GnuPG? 
Hash: SHA1
    ...which is obviously an illegal call; somehow I've just got to get the
    wrapper-script to perform the proper quoting/argument passing.  I'll have
    a new release as soon as I find a solution.
Okay, I fixed the problem; all that really needed to be done was to put
the $@ in quotes ("$ this has been reflected in the sample bundled
salias-wrapper script and in the documentation.
salias 0.1.2 is now on the release page incorporating these fixes.
Thanks for reporting the bug!

@_date: 2001-02-17 15:00:00
@_author: Frank Tobin 
@_subject: Suggestion 
Hash: SHA1
    I think it would be a nice addition if GnuPG asked for your passphrase
    when exporting the secret key with --export-secret-key. I know that it
    is not necessary, but it would make it safer against misuse as the key
    couldn't be extracted unattended, ... IYSWIM.
If you're trying to make this a "security measure", then your attacker
could copy your whole secret keyring file instead of having GnuPG export a
particular key.

@_date: 2001-02-17 15:04:10
@_author: Frank Tobin 
@_subject: secret key compromised? 
Hash: SHA1
    i exported my secret key so i could import it into another
    computer (i wanted to sign / decrypt @ another computer).
    however, someone managed to get a copy of that exported key.
    should i be worried?  a secret key isn't usable without the
    passphrase... and I have a pretty good one.
This is exactly why you have a passphrase on your secret key.  The more
you trust the notion that your passphrase is good, then the more you can
feel safe in the notion that your private key will not be compromised.
Of course, now change your password on your copy of your key you still
use, so that if your password is leaked out while using it somehow
(sniffer or something), it can't be retroactively applied to your old key.
If you change your password finding out the new password won't help
decrypt the compromised copy of your secret key.

@_date: 2001-02-21 10:10:02
@_author: Frank Tobin 
@_subject: [Announce] pgp4pine-1.75-6 - expired public keys (from: 
Hash: SHA1
    Pine user should read the following advisory.  I have not checked it
    because I don't use Pine.
Just a note: pgpenvelope, a "competitor" to pgp4pine :) is not succeptible
to this bug, because pgpenvelope runs GnuPG in interactive mode.  Because
of this, GnuPG will prompt the user concerning the
expiredness/uncertainty, and the user can make an informed decision
whether or not to continue.
Additionally, pgpenvelope will always abort sending mail if GnuPG exits
with a non-zero value (which indicates error).

@_date: 2001-02-23 09:02:41
@_author: Frank Tobin 
@_subject: Using GPG to encrypt raw data from a Perl Script 
Of course, this doesn't work; GPG never returns (although it did seem to get
    the passphrase), and the read on  hangs forever.  Does anyone know
    of a way to get GPG to read from my Perl script and write back to it?  I
    know that I could use temporary files to store $data and/or  but I'd
    like to do this without incurring a disk-access execution penalty.
First of all, you might be interested in using a CPAN module that
interfaces with GnuPG.
Second, buffering issues can prohibit sending large inputs into GnuPG.
Hook up GnuPG to an already-opened temporary file by dupping.  See
GnuPG::Interface for how this might be possible.

@_date: 2001-01-03 12:20:58
@_author: Frank Tobin 
@_subject: Signing files from a script in batch 
Is there a way the pass-phrase could be asked for ahead of time and
    then held in secure memory, somehow?  Any thoughts on this matter would
    be greatly appreciated.
You might be interested in Secret Agent, which caches passphrases for use
in programs such as GnuPG.

@_date: 2001-01-06 23:24:26
@_author: Frank Tobin 
@_subject: Newbie question: GnuPG and PGP 
Hash: SHA1
    Because users need a keyid that identifies the key.  A second
    keyid doesn't seem useful because  subkeys can be transitive.
    Multiple keyid's for a person's key can cause unnecessry
    confusion.
I'm not sure what you mean by "transitive" in this context.
    Werner, what benefit is there to displaying the keyid for a
    subkey?
I'm not Werner, but i can answer your question.  Remember, most OpenPGP
keys are two keys: the primary (for signing), and the subkey (for
encryption).  Keys are allowed to have multiple subkeys, meaning you can
encrypt to any one of the subkeys.  Hence, these must be uniquely
identifiable, and hence, we have subkey id's.
Reminds me that I have to put this feature into pgpenvelope...

@_date: 2001-01-10 12:25:04
@_author: Frank Tobin 
@_subject: Changing my preferences 
BTW, I just saw that the list managing software doesn't
    automatically add a Reply-To header. Shouldn't it?
I don't want to get too OT here, but it's a controversial thing.  There
are valid reasons for having it either way (with or without a header).
What Reply-To "means" (affecting how it should be used) is up for debate.

@_date: 2001-01-03 12:20:58
@_author: Frank Tobin 
@_subject: Signing files from a script in batch 
Is there a way the pass-phrase could be asked for ahead of time and
    then held in secure memory, somehow?  Any thoughts on this matter would
    be greatly appreciated.
You might be interested in Secret Agent, which caches passphrases for use
in programs such as GnuPG.

@_date: 2001-01-06 23:24:26
@_author: Frank Tobin 
@_subject: Newbie question: GnuPG and PGP 
Hash: SHA1
    Because users need a keyid that identifies the key.  A second
    keyid doesn't seem useful because  subkeys can be transitive.
    Multiple keyid's for a person's key can cause unnecessry
    confusion.
I'm not sure what you mean by "transitive" in this context.
    Werner, what benefit is there to displaying the keyid for a
    subkey?
I'm not Werner, but i can answer your question.  Remember, most OpenPGP
keys are two keys: the primary (for signing), and the subkey (for
encryption).  Keys are allowed to have multiple subkeys, meaning you can
encrypt to any one of the subkeys.  Hence, these must be uniquely
identifiable, and hence, we have subkey id's.
Reminds me that I have to put this feature into pgpenvelope...

@_date: 2001-01-10 12:25:04
@_author: Frank Tobin 
@_subject: Changing my preferences 
BTW, I just saw that the list managing software doesn't
    automatically add a Reply-To header. Shouldn't it?
I don't want to get too OT here, but it's a controversial thing.  There
are valid reasons for having it either way (with or without a header).
What Reply-To "means" (affecting how it should be used) is up for debate.

@_date: 2001-01-29 01:44:01
@_author: Frank Tobin 
@_subject: several recipients 
is it possible to encrypt to several recipients? Can I define a group
    of recipients with one name?
In response to your first question, yes: simply do this:
    gpg -r friend1 -r friend2 --encrypt
In response to your section question, GnuPG does not provide this
functionality internally, but I've got a wrapper script that is capable of
doing such a thing so that you could do:
    salias gpg -r friends --encrypt
...and it would expand to:
    gpg -r friend2 -r friend2 --encrypt
Tools to create an invisible wrapper functionality are also available.
It's actually project "salias" on SourceForge, but I haven't been able to
create a release yet since their CVS is broken, and my net connection on
my developement box is getting quirky.

@_date: 2001-07-10 10:01:02
@_author: Frank Tobin 
@_subject: Ann: Release of Python GnuPGInterface 0.1.0 
I just released the first version of Python GnuPGInterface, a Python
module interface with GnuPG (don't ask me why I added "Interface" to the
end of the module name; it's primarily to avoid namespace collisions).
GnuPGInterface concentrates on interacting with GnuPG via filehandles,
providing access to control GnuPG via versatile and extensible means. It
does high provide high-level access such as GPGME; rather, it is for doing
stuff with GnuPG when you know what you're doing, and love reading status
filehandles, and piping galore.
The API is reminiscent of my Perl GnuPG::Interface module, for those of
you who have used that.  I hope the quality of this module lives up to its
sibling's reputation.
This is the first release of this module, and might be buggy.  However, it
fully implements all features described in the documentation.  It's not a
big module, but it helps get things done.
Documentation and downloads can be followed from links at:

@_date: 2001-07-11 08:34:01
@_author: Frank Tobin 
@_subject: use of --passphrase-fd in batch symmetric encryption 
I am apparently too dumb to figure this out -> I've tried
    reading the man page, faq, and other docs at the gnupg site, to no
    useful avail. I can't seem to figure out how to symmetrically
    encrypt a batch of files at once, using the same passphrase, and
    entering the passphrase only once for the whole batch. I tried the
    following (and I am no pearl programmer, beware):
I highly recommend using GnuPG::Interface, a Perl module to help
interacting with GnuPG via filehandles.  It is available from CPAN, or
from

@_date: 2001-07-12 18:53:02
@_author: Frank Tobin 
@_subject: GPG in a chroot env 
> Has no one done this before?  Or does it just not work?
    GnuPG is a pretty standard Unix program and should not have problems
    if you run it chrooted.  You just have to take the usual steps to make
    a program run there.  As you probably don't have access to the tty you
    should use the option --no-tty.
What about /dev/random access?

@_date: 2001-06-07 21:57:01
@_author: Frank Tobin 
@_subject: Perl, GPG, and --passphrase-fd 
"How do I invoke decryption with a passphrase and avoid getting prompted
    for a passphrase?"
    That is great! - but I cannot seem to figure how to get at the file
    descriptor that Perl is looking to use.  Has anyone used this option?
If you want to do it from Perl, try GnuPG::Interface,
This module will handle passing the passphrase for you, if you wish, or
you can do it yourself using the module with ease.

@_date: 2001-06-10 18:41:01
@_author: Frank Tobin 
@_subject: Perl, GPG, and --passphrase-fd 
umm, correct me if I'm wrong, but doesn't hardcoding the passphrase in a
    text file somewhere Completely break, destroy, invalidate, and otherwise
    mangle the whole point of encryption?
No, it doesn't.  Having a passphrase protect a secret key merely helps the
security of the secret key, and is only possible when an external entity
(e.g., a human user) needs access to the key.  If two machines are trying
to keep secrets (e.g., ipsec), then of course, the secret key will not be
protected by a passphrase that is as secure.

@_date: 2001-06-14 05:54:02
@_author: Frank Tobin 
@_subject: Mail clients 
I am trying to find a mail client that supports gnupg and IMAP,
    runs on a Gnome/Redhat 7.1 system and doesn't require 4 hours of
    perl module downloads on my T1.
Unfortunately, you shouldn't put down a software project because it uses a
lot of modules.  In fact, you might consider it a plus, because the
software might be more reliable since it didn't re-invent the wheel.

@_date: 2001-06-18 22:54:02
@_author: Frank Tobin 
@_subject: Decryption using GnuPG:Interface and Perl 
I am trying to wrap some of the GnuPG functions in Perl so I can enforce
    some logging (an a few other reasons).  l am running into a problem when I
    attempt decrypt an pass in a bad passphrase - a scenario that is quite
    possible.  I get a "Broken pipe" printed to STDOUT and my script cannot
    continue.  Is there a way to catch the fact that the passphrase was bad
    before attempting to print the encrypted file's contents to stdin as given
    in the GnuPG::Interface examples?
Three things you can do, off of the top of my head:
1: Get the PID of the running GnuPG process (the return from "decrypt"),
and check if it's still running (send a signal of 0).
2: Read the status-fd from GnuPG; it would report a bad/good passphrase
before you had to send in the input.
3: Use the test_default_key_passphrase method of GnuPG::Interface to
pre-check the passphrase.

@_date: 2001-06-19 20:51:01
@_author: Frank Tobin 
@_subject: Decryption using GnuPG:Interface and Perl 
Can't seem to get  to work - do you have an example?
It would go something like this:
my ( $stdin, $pass, $status )
  = ( IO::Handle->new(), IO::Handle->new(), IO::Handle->new() )
my $handles = GnuPG::Handles->new( stdin => $stdin,
                                   status => $status
                                   passphrase => $pass );
$gnupg->decrypt( handles => $handles );
$passphrase->print( "three little pigs" );
while ( <$status> )
  if ( /BAD_PASSPHRASE/ or /MISSING_PASSPHRASE/ )
  {
    die "Whoops!";
  }
  last /GOOD_PASSPHRASE/; # yay!
$stdin->print( $encrypted_stuff )

@_date: 2001-03-05 19:49:01
@_author: Frank Tobin 
@_subject: beginner questions, 
> 2) Is there any way to output the signature as part of the document
    > upon decrypting a signed doc?
    Sorry, I don't understand what you want to do.
If I guess correctly, he wants to preserve the signature for the data
after decryption, so that others can can verify the data.
I've heard of this request before, and I seem to recall that Werner was
putting this functionality into GnuPG, but I don't know of any progress.

@_date: 2001-03-22 07:08:01
@_author: Frank Tobin 
@_subject: openpgp bug 
> It sounds to me like a failure of the secret keyring file format and
    > not of OpenPGP per se.
    Explain. The secret key ring format is part of OpenPGP... so I fail to
    grok your logic here.
IINM, the format to exchange secret keys is covered by OpenPGP, but the
keyring itself is not covered (I don't see why it would be; it's a
client-side issue).

@_date: 2001-03-31 18:12:07
@_author: Frank Tobin 
@_subject: Stored Passwords 
============================== START ==============================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
    	i'm the only user of my linux system, and i want to send encrypted
    and/or signed messages without being prompted for a password. Is it ok or
    accept with regards to security and how can it be done ?
The easy way to go about this is to simply use a blank passphrase for your
secret key.  You can use "gpg --edit-key secret-keyid" to change your
The other solution is to use a passphrase-caching program "Quintuple
Agent" previously known as "Secret Agent".

@_date: 2001-05-23 02:17:01
@_author: Frank Tobin 
@_subject: GnuPG Daemon? 
So, my idea is to provide this idea of a `session' in a better way
    by separating it from whatever agent (MUA, shell etc.) you are
    using, and placing it in a daemon (gpgd?) which, say, receives the
    passphrase at the start of a session, and stores it in secure
    memory ready to dole out to whatever needs it until the session
    ends.
Simply use Quintuple Agent.

@_date: 2001-05-25 18:09:02
@_author: Frank Tobin 
@_subject: pgpenvelope slow after perl upgrade 
Hash: SHA1
    After upgrading to perl 5.6.0 I found that pgpenvelope
    takes approx 7 seconds to display the first prompt/message.
    This is especially annoying when automatically verifying signed
    messages. Reading security related mailing lists becomes a real
    PITA.
    I am not familiar enough with perl to be able to tell why the slowdown
    occurred. It sure was a lot snappier with earlier versions (perl5).
    I am running perl 5.6.0 / pgpenvelope 2.9.0 / pine 4.31 on a 200Mhz PII
    Debian box.
First of all, this is a thing meant for
pgpenvelope-users not gnupg-users, so I'm cc'ing
there, and bcc'ing gnupg-users (don't want start nasty cross-posting).
This is very strange; I don't have 5.6.0 on any box I have access to, so I
can't reproduce this behaviour.  It's possible that 5.6.0 made it's
library-loading mechanisms slower, but I find it strange that it would
increase significatnly in a version upgrade.
I have heard bad things about perl 5.6.0 on   Also, note that 5.6.1
is out.
Concerning signature verifications, I highly recommend using pgpenvelope's
procmail-filtering system, which pre-verifies signatures before your
mailer gets them.  How to set this up is documented in the pgpenvelope
Also, pgpenvelope 2.10.0 is out (though no performance upgrades are in
