
@_date: 2002-12-09 02:14:02
@_author: Richard Laager 
@_subject: Robot CA at toehold.com 
Hash: SHA1
So far, I agree with you.
How does signing the robot's key allow people to gain trust through
the robot? If we were talking about people, instead of robots, here's
how I'm interpreting what you're saying:
1. Alice signs Bob's key and sets his ownertrust to full.
2. Bob signs Charlie's key. Alice can now be sure she's dealing with
Charlie's authentic key because she trusts Bob. (This is the basic
ownertrust principle.)
3. Charlie signs David's key.
Does this mean Alice can be sure she's dealing with the authentic key
of David? No. Bob can, IF he trusts Charlie. For Alice to be sure
she's working with David's authentic key, she needs to trust Bob to
make "trusted introducer" signatures.
With all this discussion taking place, I looked at the Robot CA. I
saw only three signatures on the Robot CA key. The first is the
self-signature. The second is from Kyle Hasselbacher. The third is
from Jason Harris. I don't know Kyle Hasselbacher, so his signature
is meaningless. I do know Jason Harris (at least to the extent of the
criteria he uses to make a 0x11 signature -- see my key for an
example). If I set Jason's ownertrust to full, the Robot CA key is
going to appear fully trusted.
Is this a problem? I would say so. I don't want to trust all of his
(or anybody else's) signature levels the same. But, is this Jason's
fault for making the signature. No. He's acting within his set policy
for giving 0x11 signatures. I think this is an issue with the OpenPGP
user agent, in this case GPG.
I've always wanted to see a feature in GPG that would let me decide
on a per-key AND per-signature type level the amount of trust to
give. I want to be able to encode something like this: "I want keys
signed by the Robot CA, the Thawte Freemail keys, and the TC
TrustCenter Class 1 keys to be marginally trusted as valid keys
(unless another rule applies more trust) with no ownertrust." I
realize this is not simple to codify by any means. I wish I was
familiar with the GPG internals, so that I could start coding this.
But, alas, I'm not.
I don't care about the impact of signature types on keyanalyze
reports. I found plenty of people willing to give me 0x11 signatures
by confirming that I could decrypt encrypted mail to my e-mail
address. All it would take to get a ton of keys into the strong set
would be to get a 0x11 signature from someone already in the strong
set, and then sign every key on a keyserver. One can't place too much
faith in the "strong set" because all signature types, and more
importantly, all signers are given the same weight. Furthermore,
Jason Harris mentioned that keyanalyze doesn't do cryptographic
verification of signatures. One could easily make a ton of bogus
signatures and ruin the keyanalyze statistics. The same applies to
the pathfinder.
I do have some concern over the effects 0x11 signatures have on PGP
users. However, they are in the OpenPGP standard. In fact, they were
initially created for PGP, IIRC. If GPG gains the ability to do
fine-grained trust management, it will find its way into PGP, if PGP
customers want it. Besides, GPG has been, in my opinion, a leading
implementation of the OpenPGP standard. I don't see why GPG needs to
limit it's (user agent) functionality to match PGP. One can't argue
that it needs to be done for compatibility, because PGP will continue
to handle trust issues as it does now.
Richard Laager

@_date: 2002-12-09 04:54:03
@_author: Richard Laager 
@_subject: Robot CA at toehold.com 
Hash: SHA1
I can see your point.
I see two benefits. First, I can't assign a trust level to an invalid
key. Perhaps I don't want to fully trust the robot operator's key
just to give validity to the robot's key. (Yes, a local signature
will suffice here.) As another person mentioned on this thread, it's
nice to see signatures on the robot's key. I guess it doesn't really
help anything. You've got a good point here.
I agree. The main problem with adding advanced features for advanced
users is that it confuses the newbie. I can't say I have a solution
for that one. My comments didn't take into account the newbie,
because I was talking about a feature *I* wanted and I've already
figured out the WoT. (Of course, it was very confusing to me at
Okay. My bad. I thought keyanalyze did it's own parsing. Perhaps I
shouldn't comment on things I don't know. My suggestion that bogus
signatures could be used was added to that paragraph as an
Poor data? I don't really see the difference between having a human
verify my e-mail address and sign my key, and having a robot verify
my e-mail address and sign my key.
Yep. Working together is good. I just don't think GnuPG should be
held back because PGP isn't going to support something. In this case,
GnuPG and PGP are both in the dark as far as advanced trust
management. So, we have a level playing field that's broken. I'm not
sure what the best solution is.
Richard Laager

@_date: 2002-12-10 18:49:02
@_author: Richard Laager 
@_subject: Robot CA at toehold.com 
Hash: SHA1
Can signing subkeys be used to make signatures on other keys? I
believe the answer is no, from this post:
If signing subkeys could be used for key signatures, the robot would
only need the secret portion of a subkey. If that machine was
compromised, that subkey could be revoked, and another subkey could
be used. Also, this would allow for the signing subkey to expire
without having to expire the main robot key. This provides the
advantage that those trusting the robot key don't need to worry about
finding and trusting a new robot key.
Adding this capability would surely break compatibility with other
OpenPGP applications, right? I'm not suggesting this should be
implemented, I'm just thinking out loud.
Richard Laager

@_date: 2002-12-10 22:38:02
@_author: Richard Laager 
@_subject: Robot CA at toehold.com 
Hash: SHA1
Get a new robot? Do you mean reinstalling the same robot software on
a new (secured) system with a new keypair? If that's the case, things
are no more secure than reinstalling the same robot software on a new
(secured) system with a new subkey pair. This senario assumes that it
was not the robot software that caused the break-in. If it was the
robot software, presumably, the hole would be patched before setting
up a new box.
I've had servers of mine compromised. Did I stop trusting the
software I ran on them? Sort of. I knew that I needed a patched
version, but that's all I could do. Are you going to switch operating
systems and all userland software after a compromise because the same
stuff might get compromised again? I know I wouldn't. As long as the
hole is patched and everything is reinstalled on a clean system, I
can trust it as much as (or more than) the old system.
But, as others have mentioned, it's probably easier to have a master
robot signing key that signs robot keys. That doesn't break
compatibility with PGP, et al.
I really wish it was possible to use signing subkeys. I wouldn't even
need the secret portion of my primary signing key to be on my system
except when I needed to add/revoke a subkey. After all, the results
of having a primary signing key compromised are disasterous. But, it
would be a bad idea to break compatibility.
Richard Laager

@_date: 2002-11-05 22:18:02
@_author: Richie Laager 
@_subject: UID revocation 
Hash: SHA1
It sounds like you only deleted the user ID (with the deluid
command). You need to revoke the self-signature on the UID in
question and then synchronize that with the keyserver. The UID will
stay on your key, but it won't be considered valid, since it doesn't
have a valid self-signature. (The self-signature it has is revoked.)
I hope this helps.
Richard Laager

@_date: 2002-11-06 06:21:02
@_author: Richie Laager 
@_subject: UID revocation 
Hash: SHA1
Why not? Let's say for example that I'm modifying my key. I
accidentally type something wrong in the user id and miss it in the
confirmation box. I could then delete the UID and all would be well,
as long as I hadn't sent the changes to a keyserver.
The issue here is not the PGP spec, it's the way keyservers and user
agents work. If keyservers simply stored a new key, instead of
merging changes, deleting a UID would work. (This assumes that user
agents would follow similar behavior.)
I could create many examples. Most would probably be odd cases. But,
if I find myself in one of those odd cases, it's nice to have the
functionality there.
To summarize quickly: Because of the way the keyservers work,
deleting UIDs isn't a common practive, in my experience.
Richard Laager

@_date: 2002-10-14 01:24:02
@_author: Richie Laager 
@_subject: Key e-mail address 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Yeah, I did. Sorry about that.
Richard Laager

@_date: 2002-10-25 20:52:02
@_author: Richie Laager 
@_subject: E-Mail Encryption: Why Isn't Everyone Doing It? 
Hash: SHA1
Or, just use different levels of signatures (0x10, 0x11, 0x12, 0x13).
Ideally, GPG would have a setting that allows one to specify distinct
levels of trust on a per-person per-signature class level. This is
something that I've always wanted to see implemented. I'm hoping to
learn the GPG internals some day, so that I could implement this.
Richard Laager

@_date: 2002-10-30 01:23:01
@_author: Richie Laager 
@_subject: Determining the trust path to a particular key 
Hash: SHA1
I've heard of gpgwww. Jason Harris runs it on his keyserver. The URL
below will trace the path between my key and yours, for example.
Since trust paths do not have to be symmetrical, the trust path in
the opposite direction can differ. The path between our keys is like
this for example. To trace the path from your key back to mine,
simply reverse the arguments:
I don't know about running this locally. It would be nice to have a
tool that would take into account your GPG trust levels. I don't know
if such a tool exists.
Richard Laager

@_date: 2003-04-08 22:20:02
@_author: Richard Laager 
@_subject: export single UID of a key 
Hash: SHA1
If I'm understanding you correctly, a key like the following would be
a problem:
pub Alice sig Alice uid Alice In this case, eve would get a signature for that user id.
However, this would only be possible if the process implementing above wasn't validating self-sigatures. What motive* would Alice have
to add a fake userid to her key and add a self-signature to it? If
she wanted to be associated with root for
example, this wouldn't work, unless she could intercept the e-mail
message with the signature. And, if she can intercept mail at that
address, then the signature is valid -- she can in fact read messages
sent to the address.
* I acknowledge the possibility that she might want to annoy someone
with lots of signed uid messages.
The other way I'm interpreting this is that the encryption key used
for encrypting the e-mail might not be the one owned by the primary
key owner. Here again, though, the binding signatures must be
This technique is what the Robot CA at toehold.com uses, as far as I
can tell. The whole premise is that the signatures mean nothing at
the time of singing. Only by virtue of the recipient decrypting them,
importing them, and sending them to a keyserver do they have meaning.
So yes, there isn't strong proof, but that seems to be a design
Am I anywhere on target here? Can you clarify what you meant by "If
you follow  above..."?
Richard Laager

@_date: 2003-02-23 19:19:01
@_author: Richard Laager 
@_subject: Certs by a revoked key 
Hash: SHA1
What does the timestamp have to do with this? By my interpretation,
the RFC is saying that if a key is revoked with a reason of 0x02 (Key
material has been compromised), 0x00* (No reason specified), or this
subpacket is missing* altogether, then all of the key's signatures
are suspect and must be ignored. However, if any other reason
(currently 0x01 (Key is superceded) or 0x03 (Key is retired and no
longer used)) is given, then the signatures should be used in trust
No comparison to the timestamp of the revocation dare be used. Many
people make revocation certificates when they generate their keys.
Besides, the timestamp is wholly irrelevant -- this is a matter of
trusting all the sigs or none of them.
There's no reason that someone's trust should be altered because they
retire an old key.
* I added 0x00 and the missing subpacket because if either of these
conditions are true, one cannot tell if they key has been compromised
or not. For safety, one has to assume the worst. This is not
explicitly stated in that section of the RFC, though.
Richard Laager

@_date: 2003-02-24 20:55:01
@_author: Richard Laager 
@_subject: Certs by a revoked key 
Hash: SHA1
I take it this is because multiple revocation certs are not
supported. Is this the case? Or, is this based on an assumption that
after a key is retired, it could be compromised and the legitimate
owner wouldn't notice?
In either case, this might be an issue to take up on the IETF-OpenPGP
mailing list. If there are significant flaws with handling
revocations the way the RFC lists, then it should be updated.
Richard Laager

@_date: 2003-02-24 21:42:02
@_author: Richard Laager 
@_subject: Certs by a revoked key 
Hash: SHA1
Indeed. I believe that's the reason for having these classifications.
RFC 2440bis says, "There are important semantic differences between
the reasons..."
If I'm revoking my key with a 0x01, it's because I intend to move on
to a new key. There's no reason to lose all the trust of the old key.
It can be passed on (in a sense) by signing my new key with my old
key prior to revocation.
If I'm revoking my key with a 0x03 signature, it's because I no
longer use my key. But, if Alice has signed my key, and I've signed
Charlie's key, there's no reason Alice can't continue to view
Charlie's key as valid through the signature chain, as she had
Richard Laager

@_date: 2003-02-25 00:12:01
@_author: Richard Laager 
@_subject: Certs by a revoked key 
Hash: SHA1
Well, according to the letter of the RFC, "...old signatures are
still valid." If one was to count new signatures as valid, then the
revocation would be pretty much useless. So, I would consider Alice's
signature on Baker's key valid and her signature on Charlie's key
As a threat model, an attacker could still cause problems by forging
the timestamp on signatures made after the revocation. But, then
again, if an attacker has your private key, all bets are off. The
only way to prevent this sort of attack would be to use a
"compromised" revocation reason (or not give a reason).
I don't believe that timestamps are untrustworthy though. Computers
have clocks which should be set properly. If you're not going to set
your clock properly, it shouldn't surprise you that certain things
like this may appear "wrong". As for embedded devices without RTCs: I
don't have an easy answer. It's very difficult to implement OpenPGP
properly without a clock. Filling in bogus timestamps is going to
cause problems. Again, you should see that coming when you're using
known-bogus information.
Richard Laager

@_date: 2003-02-25 01:17:02
@_author: Richard Laager 
@_subject: Certs by a revoked key 
Hash: SHA1
Good point.
Jason Harris and I had a conversation a while ago regarding the
proper handling of revoked keys in keyanalyze, pathfinder, etc.
(IIRC, keyanalyze currently ignores all revoked keys, and pathfinder
currently accepts all revoked keys.) This was when I came up with the
stance that I have now. It's interesting that this is in the RFC the
same way I imagined.
Define "globally useful". I see the use in this in my own keyring's
trust calculations, so it would have some use right away. If this was
to be put off until other implementations do it first, then GnuPG
will be lagging.
Also, I'm looking at this from the point of view that some day I'm
going to need to replace my 1024 DSA key with something bigger. It'd
be nice to avoid losing all of the trust if I revoke my key with a
superceded reason, which IMHO would be the correct procedure.
As for the keyservers, they're broken in too many ways to count.
That's a separate issue for a separate mailing list. I've been filing
bug reports and feature requests against PKS in SourceForge, so we at
least have somewhere to track these issues. I can't speak for other
key server implementations.
ACK 100% If Alice is manipulating timestamps, there's no way for us
to tell if that's the case. It could be that she had made the
signatures in the past and they never found their way to use until
the current time.
Richard Laager

@_date: 2003-01-24 16:27:02
@_author: Richard Laager 
@_subject: Create Subkey Binding 
Hash: SHA1
Yes, that's what I want to do.
Yes, it seems similar to hushmail in concept. I've never used either
of them before yesterday. The key was generated by a Java applet on
my machine and sent to s-mail via SSL. All client/sever transactions
are encrypted by SSL. I went to their export secret key page, and it
gave me a PGP keyring (.skr file).
I'm not really too interested in using s-mail. I'm perfectly capable
of doing PGP messages the way I have been. However, a contact of mine
has created an s-mail account and I'm interested in exchanging
encrypted and signed mail with him.
I realize that subkeys without bindings are insecure. However, in
this senario, a MITM attack isn't needed. To replace this file as I
was downloading it probably means they have access to my secret key
anyways. And, if they've broken the SSL to do that, they also have my
passphrase that I sent to s-mail in the same transaction.
Richard Laager

@_date: 2003-01-24 18:31:02
@_author: Richard Laager 
@_subject: Create Subkey Binding 
Hash: SHA1
Nobody can use the subkey unless it has a proper binding. This is how
it should be. Nobody has the public key yet. S-Mail doesn't publish
them on a keyserver that I've found yet. If I could get the subkey
binding made, then the key would be useable, and I could post it to a
keyserver. However, this is probably a moot point since S-Mail likely
doesn't support encrypted messages arriving from outside their
I've sent them some information on the issue. I don't know what'll
happen, but I did what I could. Unless S-Mail follows my suggestions,
there service is basically a webmail account that happens to use
OpenPGP internally. However, their client is the only thing that sees
the OpenPGP encryption, and so the user can't verify what its doing
anyways. Since the encryption (and signing) are for S-Mail to S-Mail
users only, very little protection is offered over a standard mail
Richard Laager

@_date: 2003-01-28 21:03:01
@_author: Richard Laager 
@_subject: different keys for different machine? 
Hash: SHA1
Will you be using the key for signing or encryption or both? Will you
be doing the same functions (signing/encryption/both) on each
Richard Laager

@_date: 2003-05-11 04:45:03
@_author: Richard Laager 
@_subject: Photo ID Display Behavior 
Using version 1.2.1 of GPG, I discovered the following behavior: If a
key has multiple photo IDs, all will be displayed when doing a
"showphoto". This seems appropriate. However, the photo IDs are
displayed even if the self-signature on the photo ID is revoked. I
didn't test it, but all the evidence seems to suggest that the photo ID
would be displayed if the self-signature was absent or expired. I
believe this is the current intended behavior. PGP (only tested with
6.5.8ckt) displays all photo IDs in a scrolling list, even those that
are revoked, etc.
I'd like to suggest that the behavior be modified. Just as revoked user
IDs are hidden when doing a gpg --list-key, I suggest that only photo
IDs with a valid* self-signature be displayed. The advantage to doing so
would be that a user could replace his/her photo ID every so often, just
as a photo on a passport** is replaced every 10 years or so. By either
revoking or letting the self-signatures on old photos expire, the user
could have a current photo displayed with his/her key. The old photos
would simply be hidden, without having to be deleted.
* By valid, I mean an unrevoked, cryptographically valid signature with
a creation time in the past, and an expiration date in the future.
** I realize the major flaw in this analogy. Passports are reissued with
new photos. :-)
Richard Laager

@_date: 2003-05-17 04:06:04
@_author: Richard Laager 
@_subject: User attributes and audio IDs (was: Trouble signing) 
Hash: SHA1
Well, this could be useful for voice verification of fingerprints. One
could then match the user on the phone to the key or something like that.
;-) I don't know how much it would be worth though.
There's no reason you couldn't select a key by a photo id in a GUI
environment. Simply show a bunch of photos and let the user choose.
Personally, I'd really like to see a keyserver interface that shows things
like this. I think that would be a great application of photo IDs.
=========== BTW David, did you happen to have any thoughts on the handling of photo IDs
with revoked self-signatures, etc. as I talked about in a message a few
days ago? The same issues would likely apply to the other types of
non-traditional uids.
Richard Laager

@_date: 2003-05-17 05:50:03
@_author: Richard Laager 
@_subject: User attributes and audio IDs (was: Trouble signing) 
Hash: SHA1
Well, it does provide a little security. If I found a key with a photo ID
with a valid self-signature and met the key's purported owner at a
keysigning, he or she had better look something like the photo. In other
words, if the key's real owner (the owner of the private key that made the
self-sig on the photo) claims to be the person in a certain picture, then
nobody who can't be the person in the picture should claim to be the key's
Also, while I'm on the topic of keysignings and photo IDs, the photo IDs
are handy if you make plans to meet someone in a public place for a
keysigning. If you have their key in advance and it has a photo ID, you can
tell who to look for! :-)
Richard Laager

@_date: 2004-04-28 19:12:15
@_author: Richard Laager 
@_subject: pksd error 
Hash: SHA1
For new installations, you really should be using SKS. It was written
from the ground up to fix all of the fatal flaws in PKS. See this
website: Richard Laager

@_date: 2004-06-17 02:53:57
@_author: Richard Laager 
@_subject: Duplicated User IDs arisen 
Hash: SHA1
Keyservers are not trusted, by definition. Key signatures provide the
requisite security.
All publicly available patches for PKS that I'm aware of have been
applied to the tree available at  The latest CVS
version there has been updated to use Berkeley DB 4. However, I think
SKS should be used instead of PKS if possible. PKS has a number of
bugs inherent in its design and is not being actively developed.
Richard Laager

@_date: 2004-09-06 19:53:24
@_author: Richard Laager 
@_subject: Q: Local keyring security, attacks and lsign 
There are two sides to this issue:
1. I wish to remain anonymous, but publish verifiable messages.
Obviously, I'm going to generate a key pair and sign all of my messages
with the private key. I know that as I build up an "integrity" record
(with regard to my published messages/articles/whatever), people will
begin to find my signatures valuable: They will have the ability to
recognize a new message as having been written by the same author as the
historical messages they trusted.
The OpenPGP format basically requires that some sort of user ID is
generated for a given key. What name do I put on the key? Let's start
with the easiest. Am I going to use the same real e-mail address for all
(or most) of these messages? If so, I'll put the e-mail address on the
key. If I'm not using a real e-mail address (or e-mail addresses aren't
applicable to these communications), my best bet is to make up a
pseudonym and use that on the key and as my signature.
2. I wish to verify the messages from someone else who wishes to remain
anonymous and is following the procedures listed in A while back, I was part of a discussion about keysigning practices. I
forget which mailing list it was. I held that signing a key is based on
the signer's knowledge that the key is held by the person _the signer
believes_ is the person represented by the User ID. For example, if PGP
existed back when Samuel Clemens was publishing books under the name
"Mark Twain", I would've had no problem signing his key with a user ID
of "Mark Twain ". According to my signature policy,
I would give that key a 0x12 signature. I only issue 0x13 after checking
a government identity document. Under this policy, I would be willing to
sign (after some sort of verification), the key from  with the
The point I'm making here is that it's possible for a key to be in WoT
that exists to link anonymously published articles together.
Slightly off the topic, as an interesting exercise, one could publish a
series of articles completely anonymously, signing them with separate
signing subkeys. Later, if one wanted to link some/all together, a
public key could be released with the appropriate subkeys bound to it.
(Back-signatures from the subkeys to the primary key would be required
for this to be trustworthy.)
If a key is not in the WoT and you've imported it and wish to "protect"
it, the easiest way to do this is to sign it locally and set the owner
trust according (which will probably be that you do not trust the
owner). This way, GPG will show document signatures as valid, but will
not cause other potentially untrusted keys to become valid. In your
example, you need to trust that Werner is signing a good copy of the
GnuPG source code. However, you may not want to trust him to make key
signatures. (This is a purely academic statement, applied to the example
of Werner because that's what your posting used. I'm not in any way
suggesting he's not trustworthy for signing keys.)
Now, why would you want to sign (locally or otherwise) a key which you
could not be sure belonged to the owner? If you have not verified the
key, you should probably let GPG scream at you about the key being
untrusted because it is. You don't want to forget that later. However,
local signatures are useful when you've done some verification like 1)
checking that the key you have matches the fingerprint of Werner's key
in e-mails, etc. 2) you've decided to trust the path from your key to
his (when such a path exists). By locally signing the key and setting
the trust to nothing, you can avoid having to "tweak" the trust levels
of others to make his key valid, thus avoiding the problem you mentioned
(other people's keys becoming valid as a side effect).
Now, I'd like to caution you in this whole exercise. This sort of
"protection" would be very important if you keep your public keyring on
a USB key fob, for example. Someone could steal it and change public
keys. The key signatures from your key would allow you to detect such a
change, provided that your configuration file was not tampered with and
specified your key as the only ultimately trusted key.
However, in your case, you said that you're using a relatively public
machine. You also said that root could tamper with your keyrings. In
such a case, there's nothing to stop root from tampering with your GPG
executable to do anything he or she wants.
Richard Laager

@_date: 2005-04-10 10:59:20
@_author: Richard Laager 
@_subject: potentially serious problem (was Re: WinPT on Windows NT 
While I totally agree with your points, I'd like to offer just one
thought: If your operating environment provides a proper package
manager, you can have dependencies like shell32 >= 4.32. When you tried
to install WinPT, the package manager should tell you that you don't
have the right version of shell32.dll, which is provided by the package
"Internet Explorer". This makes it pretty clear what you need to do.
The Microsoft approach involves having applications ship copies of DLLs
that they didn't make. This is VERY BAD. It leads to DLL Hell. It also
makes system maintenance a nightmare because you have multiple copies of
the same DLL all over the machine. Finally, it totally defeats the point
of DLLs because you end up loading multiple copies into memory.
I've never had trouble making this work. The best way to do it is to use
GTK+ as distributed by Gaim, I think.
Richard Laager

@_date: 2005-01-04 01:09:14
@_author: Richard Laager 
@_subject: Compression when encrypting the output of tar? 
No. Tar does not compress data by default. You have to either pipe the
output through a compression program or use the -z or -j flag which asks
tar to pipe the output through gzip or bzip2, respectively.

@_date: 2005-07-27 09:04:28
@_author: Richard Laager 
@_subject: I have the public key, but not the private... 
You're out of luck. If you generated a revocation certification and
still have that, you can revoke the key so people will know not to
encrypt to it any more. Either way, you need to make a new key.
Richard Laager

@_date: 2005-05-22 00:32:46
@_author: Richard Laager 
@_subject: 2 noob problems 
You'd leave the signature revocation though, right? That way if the
revoked signature was imported from another source that didn't have the
signature revocation with it, the signature wouldn't be shown as valid.
Richard Laager
