
@_date: 2003-12-03 16:10:47
@_author: Dennis Lambe Jr. 
@_subject: GPG Recipients List 
GnuPG splits its command-line arguments up into options and commands. Any option can also be specified in your config file, ~/.gnupg/gpg.conf,
which will cause it to be in effect for every gpg command you run.  As a
result of this, the documentation lists a lot of command-line switches
that are of little use on the command line, but useful as part of your
config file.  The "group" option is one of these.
If you specify a group on the command line, that group only exists for
the lifetime of the command that you are running (and is therefore nigh
useless).  If you specify a group in the config file, that group will
exist to gpg whenever you run it, allowing you to specify it as a
recipient of encrypted messages (-r groupname).
It looks like you're expecting the --group command-line option to create
a group which persists for longer than the lifetime of the gpg process
you gave it to.  That's not how configuration works in GnuPG.  Any
change that you want to make to the behavior of all subsequent gpg
processes must be made in the config file.

@_date: 2003-12-22 01:53:39
@_author: Dennis Lambe Jr. 
@_subject: key history on keyservers 
When working with PGP data, an important rule of thumb to bear in mind
is this:
You cannot remove information from the world once you have placed it
there, you can only add to it.
When you place PGP information on a keyserver, or anywhere else, each
individual chunk of data (Primary key, UID, subkeys, etc.) bears your
signature, a mark that it is authentic and approved by you.  If you wish
to later reverse that statement, your only option (as per the rule of
thumb) is to add another signature to the data with a flag stating that
you disavow the signed information.  This kind of signature is called a
"revocation certificate" and is the only way that you can effectively
"take back" any part of a public key once you've put it out there.
If you wish to remove a UID (because you're unhappy with the comment
part of it) and create another, your only sure way to do so is to revoke
the old UID and create a new one, which will then have to be signed by
all of your original signatories.
The old comment will always be a part of your key, but it will bear a
revocation signature that nullifies it, and most PGP software will
ignore it unless told specifically to do otherwise.
The "delete" feature of the --edit-key prompt is really only useful to
remove packets on your key that haven't been released publically yet.
The system is set up that way so that someone other than yourself can't
delete parts of your key and then upload them to a keyserver.  There is
no way to remove any part of a key without verifying (via a signature)
that you have the right to do so, and this is a major feature, not a

@_date: 2003-12-27 18:40:55
@_author: Dennis Lambe Jr. 
@_subject: Encrypting and decrypting directories under Linux 
From whom are you trying to secure the directories?
If you're trying to secure one user's home directory from another, file
permissions are the easiest way to go, and work fine if you keep up with
security patches.
If you're trying to secure the entire /home tree from a remote attacker,
close all unneccessary ports, install a firewall, and keep up with
security patches.
If you're trying to secure the entire /home tree from an intruder with
physical access to the machine room, your best bet (though not foolproof
if the computer has any physical Human Interface devices) is to use
Linux's crypto functionality to encrypt the entire volume /home is
mounted on using a symetric cypher.  This will make the hard drive, if
removed from the machine, useless.  On the other hand, it will require
that you type in a password to mount /home.
If you're trying to secure users data from someone with superuser
access, then instructing your users to protect their sensitive data with
some symetric cypher (using GPG's symetric encryption capabilities if
you like) will accomplish that.
GPG is a public key encryption program that allows one person to encrypt
data so that another person, and only that person, can decrypt it.  It
is rarely the best solution when a single person wishes to protect his
own data from someone else (except when it is used as a convenient
implementation of popular symetric cyphers with the -c switch).

@_date: 2003-12-28 03:11:49
@_author: Dennis Lambe Jr. 
@_subject: Encrypting and decrypting directories under Linux 
In that case, the best place to start is the Disk-Encryption HOWTO:
It explains how to add CryptoAPI to a 2.4 kernel and set up the mounting
of encrypted file systems.  If you are using a 2.6 kernel, bear in mind
that CryptoAPI has been merged into the main kernel sources as of 2.6,
so you will most likely not need to patch a 2.6 kernel to take advantage
of the advice in that HOWTO.
Let me know how it goes, this is an interesting topic.

@_date: 2003-12-30 15:55:24
@_author: Dennis Lambe Jr. 
@_subject: outdated documentation 
malsyned malsyned $ gpg --list-key lambe
pub  4096R/F53BA904 2003-04-21 Dennis Patrick Lambe Jr.
           ^ Key-ID            ^ User-ID ("UID" for short)
When you want to refer to a key on the command line, you must do it via
its key-id or any unique substring of its UID.  So if i wanted to, for
example, generate a revocation certificate for my key, any of these
command lines would get the job done:
gpg -o revoke.asc --gen-revoke F53BA904
gpg -o revoke.asc --gen-revoke "Dennis Patrick Lambe Jr."
gpg -o revoke.asc --gen-revoke lambe
     (assuming no one else's UID contains the substring "lambe")
Note that you can refer to a key via the Key-ID of its primary (signing)
key, or any of its (encrypting or signing) subkeys, and by any part of
any UID attached to it.
Good luck,

@_date: 2004-04-13 03:53:22
@_author: Dennis Lambe Jr. 
@_subject: Use of public key servers 
This isn't always true.
If someone signs your key, what they're doing is asserting "This key
belongs to the person named in the ID."  From then on, as long as
someone trusts one of your key's signers, they can trust your key that
they downloaded from the public server.
At some point, someone will have to have used an out-of-band method to
verify someone else's key, but that person doesn't have to be you or I,
just someone one of us knows and trusts, or someone that someone one of
us trusts trusts, or...

@_date: 2004-04-16 22:09:25
@_author: Dennis Lambe Jr. 
@_subject: Problems importing public key 
It had better, Evolution generated it!
P.S. What exactly are the issues with Evolution and PGP/MIME?  People
keep saying "it doesn't work quite right" but I've never had a problem,
and nobody's ever said how it fails when it does, or why.

@_date: 2004-02-22 16:59:06
@_author: Dennis Lambe Jr. 
@_subject: MS and PKI (was RE: Mutt/GnuPG-Outlook-plugin diffs...) 
I don't really understand this conflict between 3rd-party cert systems
and PKI systems.  Perhaps I'm missing some subtle nuance, but isn't PKI
a proper superset of 3rd-party cert?  That is, couldn't OpenPGP be used
to the same effect simply by assigning full trust to VeriSign, Thawte,
CACert, etc.'s hypothetical OpenPGP public keys?  Coupled with some kind
of secure-ish key distribution (like the physical media + holography
that Windows defaults to trusting) don't you have exactly the same
security as with MS's X.509 implementation, with the addition of PKI and
encryption at your option?

@_date: 2004-02-23 15:09:40
@_author: Dennis Lambe Jr. 
@_subject: What is the purpose of all files in ~/.gnupg ? 
gpg.conf     : Configuration of the gpg-program
pubring.gpg  : Stores all public keys
pubring.gpg~ : an older backup of pubring.gpg
random_seed  : ?
secring.gpg  : Stores all secret keys
trustdb.gpg  : Stores the amount of trust you've assigned to each of the keys in your public keyring
You should back up at least the information in pubring.gpg and
secring.gpg, but as Peter said, the --export-*-key and --import commands
are a cleaner way to do it.
