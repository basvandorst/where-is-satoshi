
@_date: 2009-03-11 16:15:20
@_author: Andrew Flerchinger 
@_subject: gpg doesn't fail on target file existing when decrypting 
I'm in windows trying to run gpg (GnuPG) 1.4.9 (Gpg4win 1.1.4) in batch
mode, completely non-interactive. I can encrypt a file like this:
gpg --passphrase **PASS** --trust-model always --batch --output
"test.txt.pgp" --sign --recipient **RECIP** --encrypt "test.txt"
and it runs fine. If I do it a second time and the output file exists, it
exits with a non-zero error code. Passing in --yes overwrites the file and
success is returned. So far, so good.
When I decrypt a file, I use a very similar command:
gpg --passphrase **PASS** --trust-model always --batch --output "test.txt"
--decrypt "test.txt.pgp"
It mostly works fine. If the output file doesn't exist, it creates it
properly. If it does exist and I add --yes, it overwrites it properly. My
problem is when I don't tell it to overwrite and the target exists, it looks
like it properly decrypted the file, except it does nothing. The return code
is still zero and the output looks exactly the same as when the file doesn't
exist and it creates it.
I'm trying to figure out if I'm doing something wrong, it's a bug, or if the
intended behavior is not the same between encryption and decryption. If I
remove --batch from either encrypt or decrypt, both prompt me for a
replacement file name. I was assuming both would fail given the option. Can
anyone shed some light on this for me?

@_date: 2009-03-16 09:10:31
@_author: Andrew Flerchinger 
@_subject: gpg doesn't fail on target file existing when decrypting 
But it is. If I pass in --yes, it does indeed overwrite as I'd expect. If I
don't, it does NOT overwrite the file. The data in the file stays the same
and the altered date on the file does not change. It doesn't overwrite,
which is as expected, it's just not telling me there was a problem with
decryption like it does when I'm encrypting something.
Are you seeing that behavior? GPG is always overwriting on decryption, even
without --yes?
Thanks for the reply (and sorry, vedaal, if you got this twice, my first
didn't include the mailing list).

@_date: 2009-03-16 14:48:25
@_author: Andrew Flerchinger 
@_subject: gpg doesn't fail on target file existing when decrypting 
Yes, I do see that behavior. The primary difference is that I never want it
to prompt me for anything, since I'm writing a headless wrapper. Try
including the --batch parameter, which suppresses any interaction. I can't
find any indication that it failed to overwrite the destination by return
code or program output.
It works just fine when encrypting, though, which is what has me confused. I
can work around it (mostly, the operation won't be atomic, but it's probably
close enough for me), but the inconsistency between encrypt/decrypt gave me

@_date: 2009-03-16 17:48:18
@_author: Andrew Flerchinger 
@_subject: gpg doesn't fail on target file existing when decrypting 
You're right, I could do that to make my work-around act atomic. Or
are you saying that even the functional encrypt behavior isn't "safe?"
I'm assuming that's essentially what gpg is already doing.
I guess I'm still trying to determine the reason for the inconsistent
behavior between encryption and decryption functions. If it's a bug,
I'd like to report it. If it's a design decision, I'd like to know the
rationale behind why. If it's something else, I'd love to be

@_date: 2009-03-17 09:50:08
@_author: Andrew Flerchinger 
@_subject: gpg doesn't fail on target file existing when decrypting 
Okay, I can work around it in a satisfactory fashion. My personal
problem is solved.
Now, assuming that --batch is supposed to make gpg run in an
unattended fashion, as documentation indicates, and behavior differs
in this case between encrypt and decrypt, is there any reason this
isn't a bug (albeit very minor) that should be reported? If so, should
I start with the gnupg-devel mailing list, or create an account with
the bug tracking system and create there?
Thank you all for your help.

@_date: 2009-03-18 18:01:35
@_author: Andrew Flerchinger 
@_subject: OT: file operations atomicity 
That's still what I'm confused about. What is a reason for, under the
same conditions, intentionally making encrypt throw an error but
making decrypt pass on as successful? Why wouldn't it be consistent?
