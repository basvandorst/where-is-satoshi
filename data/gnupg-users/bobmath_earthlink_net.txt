
@_date: 2002-12-10 21:00:01
@_author: Bob Mathews 
@_subject: Third party information 
Hash: SHA1
This is all trivial to fake. Duplicating a 32-bit key ID takes a matter o=
hours on a PC. The creation date is not a problem. Adding the UIDs is a=20
no-brainer. Getting 90 signatures is easy if you can invent 90 bogus keys=
 to=20
sign with.
This is where you hope the trusted introducer can be trusted not to sign =
without verifying the fingerprint. Ask yourself, do you want to be a lax=20
As to how _likely_ it is that all this is fake... it seems unlikely. But=20
security is like programming Satan's computer, as they say. You have to=20
assume that it's going to purposely do the worst possble thing at the wor=
possible time, and try to defend against that.
 - bob mathews

@_date: 2002-11-14 22:02:01
@_author: Bob Mathews 
@_subject: gnupg and corrupted files 
Hash: SHA1
If the file was encrypted with no compression (--compress-algo 0 on the=20
command line), the uncorrupted parts will decrypt correctly, minus one (8=
 or=20
16 byte) cipher block. I just tried this, and it works. If compression wa=
used, or the file was compressed to begin with, recovering the data after=
 the=20
corruption is difficult or impossible.
If the file is signed, the signature will fail to verify, of course.
 -bob mathews

@_date: 2002-11-16 14:22:01
@_author: Bob Mathews 
@_subject: Problem with Key Protection 
Hash: SHA1
Algorithm 254 is used with the new SHA-1 protected secret key format, whi=
was introduced in gpg 1.0.7. To turn it off for compatibility with 1.0.6,=
 use=20

@_date: 2002-11-19 06:46:02
@_author: Bob Mathews 
@_subject: Will GPG use Dual Processors under Windows ? 
Hash: SHA1
There's no opportunity for parallelism here. The XOR has to wait for the=20
output from the cipher before it can proceed. The next cipher block has t=
wait for the output of the XOR before it can proceed.
You might be thinking of OFB mode.
 -bob mathews

@_date: 2002-11-21 16:53:02
@_author: Bob Mathews 
@_subject: Moving subkeys around 
Hash: SHA1
GPG will create a new binding signature on a subkey when you change its=20
expiration date, but, for some reason, only if the subkey already has a=20
binding signature on it. The signature doesn't have to be valid, it just =
to be there, so you can use one from a different subkey of the new master=
=2E Of=20
course, GPG won't import a subkey with an invalid binding, but you can ge=
around that by writing it directly into the keyring files yourself. I don=
recommend this procedure for the faint of heart. Make a backup first. Voi=
where taxed, licensed, or restricted.
 -bob mathews

@_date: 2002-10-24 21:58:02
@_author: Bob Mathews 
@_subject: validating other keys on your public keyring 
Hash: SHA1
Checking the 32-bit key ID is 100% insecure. I have a program that can fo=
any desired 32-bit key ID on a DSA key, in only a couple of days running =
an old 350 MHz Pentium-II. It took me just a few hours to write, includin=
the time it took to learn to use the OpenSSL library. The same technique=20
should work with El Gamal keys. Forging a 64-bit key ID would be far more=
difficult, but might be possible for someone willing to spend millions of=
dollars in the attempt (that seems unlikely to me, though). Forging the f=
160-bit fingerprint is pretty much impossible.
With old version 3 keys, the key ID is simply the lower bits of the RSA p=
modulus, so it's trivially easy to forge a key with someone else's 64-bit=
 key=20
ID on it.
 -bob mathews
