
@_date: 2014-11-21 20:17:38
@_author: Patrick Schleizer 
@_subject: Update existing key to ECC? 
is it possible to update an existing (RSA) gpg key to ECC?
Or would a usual transition process be required?

@_date: 2015-04-02 13:29:39
@_author: Patrick Schleizer 
@_subject: gpg-bash-lib - gpg file verification bash library - first public 
gpg-bash-lib is a gpg file verification bash library, addresses
comprehensive threat model, that covers file name tampering, indefinite
freeze, rollback, endless data attacks, etc.
Writing bash scripts that do file verification using gpg that really is
secure and passes a comprehensive threat model, that covers indefinite
freeze, rollback, endless data attacks, etc. is hard.
gpg-bash-lib's goal is to provide a bash library that we can
collaboratively develop, audit and abstract the hard work into reuseable
Checking gpg exit codes only is insufficient. Quote Werner Koch [1]
(gnupg lead developer):
    "there is no clear distinction between the codes and for proper
error reporting you are advised to use the --status-fd messages."
(For a definition of these attacks, see TUF [2] (The Update Framework)'s
[3] threat model [4] [5].)
Mini Demo:
After installation, if you would run the following command.
You would see the following output.
your_script_begin: ...
verification: BEGIN
verification: END
your_script_output: BEGIN
gpg_bash_lib_output_failure_status: false
gpg_bash_lib_output_gpg_verify_exit_code: 0
gpg_bash_lib_output_goodsig_status: true
gpg_bash_lib_output_validsig_status: true
gpg_bash_lib_output_signed_on_unixtime: 1422049448
gpg_bash_lib_output_signed_on_date: March 01 13:56:27 UTC 2015
gpg_bash_lib_output_notation[$file at name]: test-file
gpg_bash_lib_output_file_name_tampering: false
gpg_bash_lib_output_freshness_status: true
gpg_bash_lib_output_freshness_detail: current
- Freshness: Signature is current.
- valid-max: Signatures are valid up to 30 days.
- Signature Creation Date: March 01 13:56:27 UTC 2015
- Current System Date    : March 02 16:0:55 UTC 2015
- Local System Clock: Your clock seems okay.
- Relative Signature Creation Time: According to your system clock,
signature was created 2 days 26 minutes 3 seconds ago.
gpg_bash_lib_output_alright_status: true
your_script_output: END
All information (Signature Creation Date, etc.) are easily accessible
through separate variables, which are all documented.
Usage examples:
Main code file:
Specifically, does the status-fd parsing code look sane?
Could you leave some feedback please?
Anyone else interested to contribute?
[1] [2] [3] [4] [5]

@_date: 2015-01-12 02:19:18
@_author: Patrick Schleizer 
@_subject: How to detect extraneous content in clearsigned (--clearsign) files? 
Suppose a file has been `--clearsign`ed. Then an adversary pretended or
appended extraneous content.
How can such a situation be detected? Any gpg built in way or would one
have to use a third party solution or invent one?
Perhaps code talks more:

@_date: 2015-01-12 18:44:06
@_author: Patrick Schleizer 
@_subject: How to sign the name of the name as well, not just the file? 
When using "gpg --armor --detach-sign some-file-version-c" a file:
some-file-version-c.asc will be created.
But an adversary position to arbitrarily change file names on a mirror
or so could rename it to some-file-version-d and some-file-version-d.asc.
That could trick the verifier into believing having received a more
recent version than expected. The adversary could use this to mount
rollback [1] (downgrade) or indefinite freeze [2] attacks.
Is there a way to make gnupg sign the name of the file as well? So
verification would fail if file names were renamed?
I know, one could create a sha512sum (or so) file that contains the hash
and the name of the file, then gpg sign that file. But I find that
method more complex, complicated, cumbersome. Is there any easier and/or
gpg built in way?
[1] [2] Defined as per TUF (The Update Framework) - Attacks and
Weaknesses - Threat Model:

@_date: 2015-01-12 18:52:53
@_author: Patrick Schleizer 
@_subject: How to detect extraneous content in clearsigned (--clearsign) 
Werner Koch:
Tried your syntax. And also tried this one:
gpg --output ./out --verify ./sha512sums.asc
Never created an "out" file for me.
However, what works for me is this:
gpg --output ./out --verify ./sha512sums.asc
When it exits 0, then this approach is sound, sane and fine?
Is there a way to detect, that a file looks like this:
vs a file looking like this:
prepended content
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512
appended content
Any way to distinguish both states?

@_date: 2015-01-12 20:46:25
@_author: Patrick Schleizer 
@_subject: How to sign the name of the name as well, not just the file? 
Added Hauke, because he seems interested in OpenPGP notations [1] that I
will talk about below.
Robert J. Hansen:
Hm. That's one way. Thanks for taking time answering me. Respectfully, I
must say, sounds still non-ideal. Doesn't get me too excited.
Software shipped by the project I am working on are ova files. Virtual
Box image files. Which are already compressed. Packing them into just
another tar archive would only add up build time and complicate steps a
user has to do. That is, unpack, figure out that there is no some
seemingly useless sub folder. And the naming of that sub folder could
still be overlooked.
You mean as in creating something like a software updater system?
What about OpenPGP notations?
gpg --armor --set-notation file at name="x" --detach-sign x
gpg --armor --verify-options show-notations --verify x.asc
That would be secure? Given that, users are available of notations and
use the unpopular "--verify-options show-notations". Probably few would
know. But perhaps we can train at least a few users to check.
Any suggestion for a better OpenPGP notation name than 'file at name="..."'?
Couldn't that be turned into a good feature request for gnupg?
1) To have a standardized OpenPGP notation that includes the file name.
2) When another "check file name" OpenPGP notation is set, let gpg say
"bad signature" if the file name has been tampered with?
[1]

@_date: 2015-01-13 18:24:55
@_author: Patrick Schleizer 
@_subject: How to detect extraneous content in clearsigned (--clearsign) 
Werner Koch:
What I wanted to write in my previous mail...
However, what works for me is this:
gpg --output ./out --decrypt ./sha512sums.asc
Adding --decrypt or not has the same result?

@_date: 2015-01-13 19:03:36
@_author: Patrick Schleizer 
@_subject: Are there cases where gpg --verify will exit 0, even if verification 
In another thread...
Werner Koch
Are there cases where gpg --verify will exit 0, even if verification failed?
(Suppose one uses a separate --homedir where only legitimate signing
keys are imported.)

@_date: 2015-01-13 19:38:11
@_author: Patrick Schleizer 
@_subject: How to detect extraneous content in clearsigned (--clearsign) 
Patrick Schleizer:
Can answer my own question:
Using --decrypt for verification only is a really bad idea in scripts -
gpg would still exit 0 if file is encrypted, but unsigned.

@_date: 2015-01-14 16:40:34
@_author: Patrick Schleizer 
@_subject: Are there cases where gpg --verify will exit 0, 
Werner Koch:
Do you mean, for example, the signature could be valid, but the key that
signed it could be revoked and gpg would still exit 0?
Or can you tell another example please where gpg would exit 0, but where
where the signature is bad?

@_date: 2015-01-14 16:44:47
@_author: Patrick Schleizer 
@_subject: Is there a shell script or bash library for parsing gpg's --status-fd 
Is there a shell script or bash library for parsing gpg's --status-fd
I mean, I could code it myself. But why duplicate effort and risk
messing up. Maybe there is some existing or even recommended or even
official library to do this?
(What I mean by parsing is: to get from lines such as "[GNUPG:] GOODSIG
416..." to variables such as goodsig=true, fingerprint=416... and so forth.)

@_date: 2015-01-16 18:28:13
@_author: Patrick Schleizer 
@_subject: gpg-bash-lib - parsing gpg's --status-fd - feedback desired - was: 
apparently something like gpg-bash-lib didn't exist.
Created one:
Could you leave some feedback please?
Main code file:
No usage instructions yet, see unit test:
Specifically, does my status-fd parsing code look sane?
Anyone else interested to contribute?

@_date: 2015-01-26 17:14:27
@_author: Patrick Schleizer 
@_subject: gpg-bash-lib - parsing gpg's --status-fd - feedback desired - 
output?
Patrick Schleizer:
Comprehensive documentary and examples have been written.
Please leave feedback.

@_date: 2015-03-19 17:39:07
@_author: Patrick Schleizer 
@_subject: --verify --status-fd separator for multiple signatures? 
when using --verify combined with --status-fd [or --status-file], how
can one notice in scripts, that processing the one signature is done and
that further status-fd messages belong to the next message?
I mean, sometimes it shows SIG_ID, but not in case of ERRSIG.
So is there some line / separator that can be reliably used?

@_date: 2015-03-20 09:20:15
@_author: Patrick Schleizer 
@_subject: --verify --status-fd separator for multiple signatures? 
Doug Barton:
No. Using --status-file. --with-colons does not seem to affect that.

@_date: 2015-03-20 18:41:10
@_author: Patrick Schleizer 
@_subject: --verify --status-fd separator for multiple signatures? 
Werner Koch:
Well, I don't speak C, so I can't make head or tail of "what we do in
Maybe let's put it this way. If there is no guarantee to get a NEWSIG or
other separator... Is there a limited combination of start and end keywords?
What I mean... Here is an example...
start: [GNUPG:] ERRSIG [...]
end__: [GNUPG:] NODATA [...]
start: [GNUPG:] SIG_ID [...]
end__: [GNUPG:] TRUST_[...]
start: [GNUPG:] ERRSIG [...]
end__: [GNUPG:] NO_PUBKEY [...]
Is there a complete list of all possible start/end keyword combinations?

@_date: 2017-09-18 13:50:00
@_author: Patrick Schleizer 
@_subject: using --keyserver but still getting gpg: no keyserver known (use 
gpg --keyserver hkp://pgp.mit.edu:11371 --search-keys my at e-mail.com
gpg --keyserver=hkp://pgp.mit.edu:11371 --search-keys my at e-mail.com
gpg: no keyserver known (use option --keyserver)
gpg: keyserver search failed: No keyserver available
What am I doing wrong?
