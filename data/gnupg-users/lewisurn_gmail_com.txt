
@_date: 2016-12-09 23:11:18
@_author: Lou Wynn 
@_subject: What is pubring.kbx? 
I just happened to read this page today, and it's still open in my browser.
The public keyring using a different format. This file is sharred with
gpgsm. You should backup this file.

@_date: 2016-12-14 23:34:20
@_author: Lou Wynn 
@_subject: Smartcards and tokens 
I've come cross a simple and secure approach at this post:
In the MAKING BACKUPS section, this method simply places your gnupg
directory in an encrypted usb drive and make a symlink to it like this:
ln -s /Volumes/EncDrive/gnupg ~/.gnupg
That's all. As long as you use a good passphrase, this is very secure
method to me. When you unplug the USB, your keys are gone. If your USB
drive is lost, its content is encrypted by your passphrase, so no worry
about it.

@_date: 2016-12-15 11:24:07
@_author: Lou Wynn 
@_subject: Smartcards and tokens 
If the host machine is compromised, what's the purpose of doing
encryption on the SmartCard? Attackers don't need to know the key to get
your plaint ext, because it is on the host machine.
I guess that what you meant was signing, using a SmartCard to sign has
the benefits you mentioned, but not encryption.

@_date: 2016-12-15 13:02:08
@_author: Lou Wynn 
@_subject: Smartcards and tokens 
Hi Martinho,
After I thought about it more, I have kind of drawn the conclusion that
even for signing, only using a SmartCard cannot achieve authenticity.
With a write-only SmartCard which computes signature on the card, it's
true that it can protect the signing key. However, if it's used in a
hacked machine or malicious environment, the hash sent to the card can
be modified to be the hash of something else, not the hash of the
document that you think you're reading on screen. Even if your signing
key is kept secret on the card, but it blindly signs a fake hash. What's
good about this?
So using a write-only SmartCard alonewithout a secure host environment
cannot give you the security level you think you get. Unless I missed
something from your original description.
This actually boils down a minimal trusted computing base (TCB).
SmartCard itself does not form a complete TCB, which must include
certain trusted host environment.

@_date: 2016-12-15 14:32:52
@_author: Lou Wynn 
@_subject: ways to ensure that GPG public key belongs to right person in 
Let me analyze your steps to see what you'd like to achieve in each of them.
0. Alice and Bob knows each other's email addresses: alice at A and bob at B.
1. Bob sends Alice his public key at Alice email address alice at A.
2. Alice relies to Bob with her public key.
3. Alice calls B's support and asks to get Bob on the phone.
4. Bob tells Alice the fingerprint of his public key, and Alice checks
it against what she received at (1).
5. Alice tells Bob her public key fingerprint, and Bob verifies it.
You try to use step 4 and 5 to verify step 1 and 2, but it doesn't work.
Suppose that Ted sends Alice his public key impersonating Bob by a faked
from address but replies to Ted. Ted can be B's support guy who answers
phones. Then your method makes Alice think that Ted is Bob. Step 4 and 5
don't add much value because Bob's public key fingerprint is public, and
the guy in Step 3 doesn't have to be Bob. Basically, step 3 is useless,
and step 4 and 5 are like PGP's web of trust: if someone says Bob's has
that public key, then let's just believe it.
The real value starts with 0, which makes Alice believe that she knows
the owner of email of bob at B when sending to that address. The same holds
true for Bob. In step 2, you should make Alice send her public key to
the bob at B address because that's all the knowledge she has about Bob in
terms of reachability, not reply.
I'm working on a PGP key management system for organizational email
communication. In this system, what I verify is not the identity of a
person; instead, it's the owner of an email address. When I send to an
email address with some secret and get the reply, then I know that I've
been in contact with the owner of the email. I don't care about the real
name of the person who owns the email, or I don't care if it's a shared
email used by several people. All I care about is that I've been in
contact with the email address. The security of organizational email
system starts from here. If you're interested in this concept and trying
out this system, I'll be happy to introduce you more, but it's off topic
to this thread.

@_date: 2016-12-16 10:33:48
@_author: Lou Wynn 
@_subject: Smartcards and tokens 
I agree that a SmartCard can protect a private key, but that's a
marginal benefit because the bottom line of using a SmartCard is the
same as that of using an encrypted USB drive, which is
Do not use it in an untrusted or compromised host environment.
If you stick to the bottom line, then there is no point to emphasize the
The difference only comes in when you violate the bottom line and want
to use it in an untrusted or compromised host and "wish" that you could
get security. In this case, SmartCard can prevent your key from being
read. However, I would suggest anyone who uses a SmartCard not to do it
at all because using it in such an environment cannot give you security:
either signature or encryption.
I'd like to say more about "brute force" since you seem to misunderstand
the basic threat model of modern cryptography, whose design goal is only
to allow brute force attacks. However, it's computationally infeasible
in practice to guess the correct key by using brute force. A successful
cryptographic design is one where there is no systematic way to break it
unless an opponent can enumerate over the key space. SmartCard is no
immune to this. A brute force attack doesn't need to read the card, and
it simply enumerates keys in the key space used by the SmartCard. What
you said--limiting the number of reads on the card--is not a measure
against brute force. It is a measure to prevent reading secret materials.

@_date: 2017-01-02 10:27:35
@_author: Lou Wynn 
@_subject: export encryption (subkey) only? 
I'm developing a key management solution for an organization. For an
employee, I'd like to generate two keys: one for signing and the other
for encryption. In my proposed solution, the encryption key should be
backed up in an organizational central server for auditing purpose, and
the signing key is only accessible to an user without being saved in
another location. This means that I have to separate the encryption key
from the signing key.
However,  the current GPG makes the signing key the master key and the
encryption the subkey. PGP standard seems not to allow transfer a single
subkey (RFC4880 Section 11) because it is always preceded by the master key.
I tried to export an encryption subkey only with GPG2, but importing the
subkey also lists the primary key. The man page of
--export-secret-subkeys reads:
   The second form of the command has the special property to render the
   secret  part  of  the primary key useless; this is a GNU extension to
   OpenPGP and other implementations can not be expected to successfully
   import  such a key.  Its intended use is to generated a full key with
   an additional signing subkey on a dedicated machine  and  then  using
   this  command  to  export the key without the primary key to the main
   machine.
It means that although the primary key is imported and listed, it is not
Has anyone have experience with this and been able to confirm it?
I'm also thinking about making two separate master keys, and doing so
seems to make me avoid the confusion of master-subkeys and make the
solution more portable in different implementations.
What's your opinion?

@_date: 2017-01-02 13:33:33
@_author: Lou Wynn 
@_subject: export encryption (subkey) only? 
How about this: I use another company encryption key for auditing
purpose only. When employees send emails, they always use this
encryption key as well as the public keys of recipients for encryption.
This way, I don't have to backup employees' encryption keys, and can
even simplify to use a single key for each employee (this might be
arguable, but it's hard for me to convince myself that it's worthwhile
to use separate encryption key in this case). But I'm not sure if I need
to customize some PGP implementation in order to do so.

@_date: 2017-01-02 20:41:07
@_author: Lou Wynn 
@_subject: Counterarguments Supporting GnuPG over Off The Record (OTR) 
The author's stand is hilarious to me. He is
"My day-to-day work is in the field of information security and
especially incident handling, analysis and response. "
That's is to say, he's a security expert. But he compares himself with
Johnny by quoting "Why Johnny Can?t Encrypt?
Actually, there is a more recent paper called
"Why Johnny Still, Still Can?t Encrypt: Evaluating the Usability of a
Modern PGP Client"
In my observation, what this type of papers point out is obvious:
It is non-trivial for non-technical people to make PGP work.

@_date: 2017-01-03 14:45:57
@_author: Lou Wynn 
@_subject: export encryption (subkey) only? 
I overlooked this point, and it's important in the PGP world. One of my
goals is simplifying key management for organizational employees, and
it's nice to keep it interchangeable with people outside.
Thank everyone for helpful discussion.

@_date: 2017-01-04 13:29:50
@_author: Lou Wynn 
@_subject: exported subkey usage? 
I created a master key and two subkeys with one subkey being signing and
the other encryption. I then exported the two subkeys only.
However, when I used pgpdump to inspect packet types, both subkeys are
been marked as "RSA Encrypt or Sign (pub 1)." When I used another
program whose backend is BouncyCastle's PGP engine, the program cannot
tell which subkey is for what.
I deleted the key in my keyring and used GPG2 to import the two subkeys
back. To my surprise, they are correctly marked as [S] and [E].
What is going on here? Does GPG2 use some special way to mark the usage
of a subkey? How can I make it interchangeable with other programs?
I've attached the master key and the two subkeys to this letter so that
you can inspect them (I made up other info just for testing, so don't
worry about it). The OneMasterTwoSubkey has the master key with two
subkeys, and the other only has the subkeys. The passphrase is "1".

@_date: 2017-01-16 23:41:26
@_author: Lou Wynn 
@_subject: Trust signature domain 
I also want to know if someone is actually using trust levels in
practice. You're the first one whom I came across, so I obviously can't
answer your question.

@_date: 2017-06-18 23:00:04
@_author: Lou Wynn 
@_subject: Creating Unique Fingerprint 
According to my understanding of crypto theory, your only way is to
generate keys and compare their fingerprints and with the value you
want. I would be surprised that you can find one in your lifetime. Or
it'd be a breakthrough in cryptography if you managed to do it somehow.

@_date: 2017-06-29 17:33:32
@_author: Lou Wynn 
@_subject: SHA1 depreciation ?? 
As for the current version v4, SHA1 is used to compute the fingerprint.
Are there other mandatory places?
Others such as signature hash and password hash do not depend on SHA1.
Do you know any time frame and significant changes of v5 specs?

@_date: 2018-02-27 19:59:40
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
No, there is no S/MIME implementation because the PKI model it relies on
is inherently precarious for enterprise usage because of using
third-party certificates. Once a 3rd party CA is trusted, all users it
certified becomes trusted while those users have no business
relationship with the enterprise.
The short answer is that neither S/MIME's PKI or OpenPGP's web-of-trust
is suitable for organizational uses in term of defining trusted people
for the organization. In addition, current clients of both require
considerable efforts at the end-user side to configure and use. For a
longer analysis, here is a white paper:

@_date: 2018-01-02 23:02:08
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
I saw some interests in this mailing list about PGP's certification and
web-of-trust. I've been working on a system for enterprise customers
that dramatically changes how PGP key signing and verification work and
would like to discuss it here to see if someone is interested in it.
1. Goals of the system
a. An organization does not depend on third-party certificate authorities.
b. Its employees and business partners do not manually manage their own
keys and trust relationship, and the administrator centrally manages all
certificates and trustworthiness for the organization.
c. Business units can flexibly define trust boundaries. For example, the
security department can have some black hats as business partners but
these black hats should be not be trusted by other employees of the
d. Providing end-to-end security with public key ciphers. An end user's
private key should not be exposed to anyone, namely, only the end user
has access to his or her private key to ensure valid signature and
e. Support auditing of encrypted messages.
2. Current system design
After building a prototype based on PGP, I'd like to share the parts
that are closely related to, or dramatically different from, PGP.
a. The new "autonomous certificate authority" trust model. In this
model, an enterprise has a root key (RK) and a certifying key (CK). The
RK is used to certify the CK, and the CK is used to certify keys of
employees and business partners. Keys that are ultimately certified by
the same RK are "potentially" considered trusted to each other. The RK
represents the only certificate authority of the organization. The RK
can be stored offline, and the CK is online for normal certification
operations for security reasons. If the CK is compromised, then the RK
can be used to revoke it and certify a new CK.
b. Certificate verification. An organization has two types of users:
employees and business partners. Accordingly, the system distinguishes
two type of certificates: employee certificate and partner certificate.
For a communication pair (the receiver and the sender), two keys are
considered in the same trust realm if they are ultimately certified by
the same RK (through the CK chain) and one of the certificate types is
the employee certificate. Keys in the same realm are automatically
considered as trusted to each other.
When keys of business partners are certified by the CK, the above two
design principles place the employees and business partners in the same
trust realm and therefore trust each other, but not between two business
partners because two business partners are not in the same trust realm.
c. Trust groups. The employees and the administrator share security
responsibility of business partner's certificates. Employees know
business processes and understand which email addresses are business
partners, and the administrator does not have this knowledge. Therefore,
an employee invites an email address as a business partner by using an
automated process that certifies the partner's key. The administrator
can monitor which employee invites which email address as a business
When the employee invites a business partner, the former can specify or
name a trust group for the latter and optionally add other partners and
employees into the group. When the partner's key is certified by the CK,
the group information is hashed in the certificate. In addition, other
group members' certificates are updated to include the group information
automatically. Now the certificate verification process has an
additional constraint besides belonging to the same trust realm: the two
certificates must share a common group in order to be considered
trusted. However, this constraint is not applied if the two certificates
are both employee certificates. This ensures that two employees always
trust each other, but a business partner can only enter a trust group,
not the realm, that is defined by the group owner which is an employee.
This gives an organization the ability to define trust boundaries
according to its own business needs.
d. Auditing key. An organization also has an auditing key (AK) besides
the RK and CK. When a user certified by the organization sends an
encrypted email, the client plugin automatically encrypts the message
with the AK besides receiver's key. As a result, goals 1.d and 1.e can
be both achieved at the same time with help of other system design. The
administrator only needs to use the AK private key at the auditing
appliance to conduct business auditing or message scans.
3. System components. Since this has less relationship with PGP, I just
mention that the entire system includes four major components: an
organization key management system which runs the CK, the server which
manages all user keys and certificates securely, a web user interface
for the administrator, and a client plugin that performs encryption and
certificate verification. The client plugin is a traditional PGP client
with the above enhancement. I've implemented a chrome extension to demo
a simple end-user interface in Gmail, whose snapshots are available at
4. It's worth of mentioning that I've used PGP's notation to hold the
certificate type and trust group information. There is much left unsaid
about the system, especially the management of user keys and
certificates which are critical to zero-configuration on end-user side,
but I would like to say this post is just my first-try to see if there
is enough interest to this new trust model and its application for
enterprise environments. Please feel free to ask questions or make
comments if you're interested in learning more about or discussing the

@_date: 2018-01-03 13:04:38
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
Yes, "trusted" keys do not mean much without contexts. There are few
contexts to see what trustworthiness means.
1. From certificate verification point of view, a trusted key means that
the certificate is verified to be in the same trust realm or in the same
trust group with the receiver.
2. From the user interface point of view, a trusted key is reflected by
marking the sender's signature is verified, and an untrusted key is
marked by the warning that the signature cannot be verified. An
automated or manual process can be applied to delete or quarantine
messages whose signature verification fails. The screenshots on the web
link show this intuitive UI. Of course, the final decision about what to
do with such messages is up to the receiver. The warning of signature
verification makes the receiver aware of the sender status, which is
either certified to be in the same trust realm/group or not being
certified as such.

@_date: 2018-01-03 13:46:16
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
I just realized that I overloaded the meaning of signature verification.
Here, signature verification, both in my previous discussion and in the
receiver's UI, also includes the certificate verification described in
2.b, in addition to traditional signature verification.

@_date: 2018-01-03 17:34:30
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
Hi MFPA,
The short answer is for both. End users do not need to manage their
keys, both private and public; nor do they need to trust the company key
as described in your reference "It is up to you if you wish to trust the
company key to sign others, but we recommend you trust it to sign any
 or  email addresses on keys".
Your first comment above mentioned no 3rd-party CA is needed for PGP
users, but the reference still requires users to manage their trust. In
my opinion, PGP has an unnecessarily complicated trust management
recommendation: the web of trust, when used in an enterprise
environment. My goal is to simplify user-side trust management work to
zero, and the result is the concept of trust realm and trust group. They
are explicitly validated by certificate verification which is carried
out together with the signature verification when a message is received.
The management of users' private key is a little more complicated. I use
two levels of protection. One level is at the organization. An
organization actually has a fourth key, which I call the guard key, to
encrypt the password of user's private key. This guard key is also
managed by the key management system. In addition, a user can choose
another her own password to encrypt the key password too.
No, there is no business unit level certifying key. An enterprise only
has one root key, which is the ultimate certificate authority for its
own employees and business partners.
That is correct technically. A goal here is to make this process as
transparent to users. As I mentioned above, the only operation for a
user to do with key management is choosing a user own password to
protect the private key.
Totally agree, I've designed the trust realm and the group to establish
trustworthiness between employees and their immediate business partners,
not among partners.

@_date: 2018-01-03 17:46:55
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
When I said for "both," I might have misunderstood what you meant by a
shared keyring? Can you explain it a little bit? My system doesn't share
anything that is related to user private keys, except for that encrypted
private keys are saved in a database. An analogy is placing two people's
encrypted PGP secret keyring on a file server, and decryption is still
done at the client side. I'm not sure if this is what you meant by a
shared keyring.

@_date: 2018-01-03 20:42:07
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
This is what happens in my system, so it is not a shared keyring.
My system uses a customized PGP client, which acts like a special web
client. It has a client key and uses it to log into the server, which is
similar to SSH key authentication, to retrieve the private key after
authentication. It does not save the private key locally on storage
devices after decrypting it; it only keeps the private key in memory
until session times out, when it cleans the private key from memory. But it caches public keys locally though. In this sense, you could say
that the client has local public key rings and a remote private key ring
if you like to compare it with GnuPG implementation.

@_date: 2018-01-03 21:10:34
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
It's true for OpenPGP because OpenPGP is a distributed system, there is
no single CA, or it doesn't have the concept of CA at all. My original
implicit reference is PKI based S/MIME.
The autonomous certificate authority model is different from both PKI
and web of trust. As I explained in one of my previous posts that this
model clearly defines what trustworthiness is. The short version is:
A trusted key or trustworthiness means that the sender's certificate is
verified to be in the same trust realm or in the same trust group with
the receiver, besides traditional signature verification.
In this model, end users are freed from managing trust relationship
completely because the trustworthiness can be checked mechanically and
it makes sense to organizational usages.

@_date: 2018-01-04 13:21:31
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
There is no key escrow in my design because a user's private key should
not be accessible to anyone else including the administrator. For an
organization, granting the administrator too much, unnecessary privilege
is dangerous especially when he leaves.
Let me try to explain it in another way. Each end user has an email key.
When she uses multiple email clients, each client plugin has a key pair
serving as the identity of the client plugin. The client plugin
registers itself on the server with its public key when the client
plugin is installed or initialized. This key belongs to the plugin and
is used for the plugin to log into the server. The administrator and/or
the end user can monitor how many client plugins the user uses. The
administrator may disable the login of a particular client plugin if it
is compromised such as an employee loses his computer.
In addition, the administrator may optionally set up a policy that
requires the user to choose a login password except for the public-key
authentication of the client plugin.
After a client plugin logs in successfully, the server sends the user's
encrypted email key to the client.

@_date: 2018-01-04 13:58:06
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
It's doable, but I'd like to make sure that I understand what you mean
by "within corporate infrastructure?" Do you mean the client plugin
sends requests to the server to decrypt and verify received messages?
This is definitely a trade-off between key security and performance. But
I don't see any obvious benefits given that the user's computer that
runs the client plugin also belongs to corporate infrastructure. If the
user's computer is compromised, then the administrator simply clean up
the computer and re-install or re-initialize user's email client, which
includes the client plugin.
In my design, each end user does not have a permanent identity like in
OpenPGP where he needs to accumulate his reputation for
"trustworthiness." The only authority is the organization's root key.
Among other things, a user's key is simply a way of declaring that the
email message is authorized by the user who has been certified by the
organization's root key. In this situation, a user's key is not more
important than his email account.

@_date: 2018-01-04 14:04:05
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
Can you explain what the problem is? I don't really know what you mean,
but I've love to hear.

@_date: 2018-01-04 14:14:41
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
Compared to using two CAs, my design introduces two properties to a
certificate. One is the certificate type, which is "p" for a partner and
"e" for an employee. The other property is the trust group, which is a
list of groups and tells the certificate verifier the groups that the
key belongs to. These two properties are implemented as notations of the

@_date: 2018-01-04 14:24:35
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
I see. The gateway solution is contradictory to my end-to-end email
security goal, which requires that only the end user can use his own
private key. The gateway is a total disaster if the gateway is breached.
I guess that you missed the auditing key part. I introduced it to meet
auditing requirements or scanning of messages without using end user's
private keys.

@_date: 2018-01-04 15:51:38
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
This is exactly the reason for my modernizing web of trust. I cannot
find a way to make it compatible with rfc4880 and meet all my goals. I'd
love to hear your alternatives if it is possible. For example, I'd like
to deprecate how trust is assigned values and used in the rfc. However,
I'd love to use existing good mechanisms as many as possible, such as
the entire PGP data format.
As for changes to PGP, I do require new certificate properties and
certificate validations to enforce trust realms and groups.

@_date: 2018-01-04 16:04:05
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
I don't get the exact meaning of this paragraph.
I'll try to explain a little. If the administrator sets up the auditing
policy (which implies that the auditing is an option), then the plugins
of employees will also use the auditing key to encrypt a message besides
receiver's public key. This is a little different from what I said
earlier about users' plugins because this is a design decision which has
not been finalized: whether to make employees or employees plus partners
to use the auditing key. This might become an option too.

@_date: 2018-01-04 16:12:20
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
I guess that you've missed somewhere I said in my previous posts that
the end user chooses his own password to protect his key password, which
is meant to prevent others from using his private keys.

@_date: 2018-01-04 16:31:12
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
I think that I simplified my original description too much. The two
levels of protection works like this.
1. The employee chooses his own password, which is used to encrypt his
private key.
2. Then the encrypted key is encrypted with the guard key.
When a client plugin passes authentication, the sever decrypts from 2's
result and sends it to the client. This key material is still encrypted
by the employee's own password. The decryption of 1 happens at the
client plugin.
My estimates is that there exist different types of organizations. Some
want to access employee's key, and some don't. So For the former, they
can choose to skip the first level of protection. For the latter, they
can require to use it. An organization can only change from using the
second protection only to using both, but not the other way around.

@_date: 2018-01-04 16:42:27
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
I'm sorry for missing another step in sending a key to the client. After
the server decrypts the encrypted key material with the guard key, it
uses the public key of the client plugin to encrypt it and sends it to
the client. The client plugin decrypts it first with the plugin key, and
then the user's own password is required to decrypt the private key.
The guard key and the plugin key here are used to defy the
man-in-the-middle in either direction and provide secure channels.

@_date: 2018-01-04 16:46:16
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
Sorry, I don't get it. Can you explain your question again? What data,
in which scenario?

@_date: 2018-01-05 00:41:57
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
This reason is vague and invalid. The purpose of a private key is
two-fold: encryption and message authorization. The only need for an
organization to access their data is decrypting the encrypted data,
which is satisfied by the auditing key. I don't see any valid reason to
damage message authorization. I'd suggest you read Ben McGinnes's post.
If you still insist that there is value in accessing employees' private
key, then I would say that you belong to the type of organizations that
*want* to access employee's private keys although doing so causes more
damages. I described the two categories of organizations when replying
Ben's post.
This is another reason that I want to modernize PGP for organizations
because when people use PGP in such an environment they tend to make
dangerous decisions such as key escrow or encryption gateway to meet
organizational management requirements while compromising message

@_date: 2018-01-05 08:29:39
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
The auditing key is certified by the root key and stays with the latter
in my design. Only the administrator can make policy to turn on/off
auditing, the client plugin takes corresponding actions automatically.
End users don't need to do anything, namely, using or not using the
auditing key to encrypt is completely transparent to end users. As a
result, there is no such issue of "forgetting to add it."

@_date: 2018-01-05 08:47:29
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
This is just one of the benefits enabled by my goals which I stated at
the beginning, and it is most related to central management of keys.
There are systems that have attempted to solve one or two of them with
the cost of sacrificing others. My take is doing them all with the new
trust model and its supporting mechanisms.

@_date: 2018-01-05 15:23:57
@_author: Lou Wynn 
@_subject: Modernizing Web-of-trust for Organizations 
If you asked about the auditing key compatibility, then it is probably
not the right question because RFC4880 does not talk about it at all. My
client plugin takes automatic action to encrypt a message with two keys
and sends to one receiver, which I don't think violates the RFC.
However, there is a potentially issue related to compatibility for the
system as a whole depending on the direction. For example, if you import
your current PGP key into my system, then you can still use the key
without a problem because as a part of the importing process the server
adds a new certificate with necessary properties made by the certifying
key. The client plugin of my system will recognize your key as valid
once you have this certificate.
In the other direction, if you export a key from my system and want to
use it in your current PGP client, you can do so because a key in my
system is still a valid PGP key. However, you don't have any benefits of
my system such as trust realm/group support because your current PGP
client does not enforce the autonomous certification authority model.
