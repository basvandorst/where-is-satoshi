
@_date: 2008-11-18 09:52:49
@_author: Andreas Heinlein 
@_subject: appending to gpg file? 
David Shaw schrieb:
filesystem encryption like eCryptfs or encrypted
loopback/dm_crypt/TrueCrypt/etc. That would imply, however, that access
to the file/volume can be restricted securely as long as it's open.

@_date: 2008-11-25 09:54:31
@_author: Andreas Heinlein 
@_subject: Elementary Question 
Jorge Luis schrieb:
I doubt this is possible, but it is possible to use multiple keyrings
with gnupg using the --keyring option and set the one to import new keys
to with the --primary-keyring option.
This way, you could have a separate keyring for mailing list keys or you
could just use a temporary keyring which you delete afterwards.

@_date: 2009-03-26 14:43:08
@_author: Andreas Heinlein 
@_subject: cloudy understanding of asymmetric cryptography 
Felipe Alvarez schrieb:
I think the latter is the more important point nowadays. I do not
believe doing complete RSA encryption would take too long on modern
hardware for reasonable file sizes. But if you encrypted a file of 10MB
to 10 recipients this way, it would become around 100MB in size.
No, I don't think that's possible.

@_date: 2011-06-02 11:57:30
@_author: Andreas Heinlein 
@_subject: Working with a system-shared keyring 
Am 02.06.2011 00:41, schrieb Dan McGee:
I'd try not relocating the homedir, but only the keyring location. If
you have a means of distributing a gpg.conf to everyone's home
directory, you could insert
    no-default-keyring
    keyring /etc/pacman.d/gnupg
Not sure about the secret keyring, though. It should not try to use
~/.gnupg/secring.gpg, so trying to import a secret key or generate a new
one should give an error. I assume that's what you intend.
A home directory with wrong permissions and/or read-only is granted to
give problems with various applications.

@_date: 2011-05-05 08:52:44
@_author: Andreas Heinlein 
@_subject: Best practice for periodic key change? 
I hope you can give me some advice on the following problem:
We have a OpenPGP key which we use for signing our software releases.
That key should be changed yearly and carry an expiration date to
enforce this change. However, for the signatures to be useful, the key
has to be signed by quite a lot of well-known people and institutions,
which means a considerable effort.
If we just regenerate the whole key every year, we would have to get all
these signatures again. I have a feeling that generating new subkeys
might be a solution, but I have never worked with subkeys before, so I
thought you could give me some advice what would be the best thing to do.

@_date: 2011-05-06 08:22:45
@_author: Andreas Heinlein 
@_subject: Best practice for periodic key change? 
Am 05.05.2011 22:10, schrieb Doug Barton:
Well, there are several reasons.
The first is that there is always the chance that the key is cracked
brute-force. Remember that the x-zillion years which are often cited are
only an average. One might always be lucky and find the right one within
the first 0.0001% of keyspace, taking only a few days or weeks. Chance
is very low, but then almost every week someone wins the lottery... ;-)
More likely your key gets compromised some other way, e.g. it is stolen
from your computer by a trojan, a malicious website or whatever. A good
passphrase mitigates this risk somewhat, but most people choose
passphrases which are weaker and easier to brute-force than the actual key.
Here comes the third point; even if you notice your key was compromised,
you need to revoke it *and* make sure the revocation reaches all users
of your key. Like Werner said, many people never refresh their keys, so
expiring is indeed a way to force them to do that. ( I admit that, in
our case, even this will not help, since gpg will happily verify a
signature made by an expired key. It will tell you that it's expired,
but verify anyway. The 'hard' way would be to just refuse to do anything
with an expired key or even delete it automatically, but that's another
Much depends on the use case you're using GPG for, there's another
discussion currently on this topic. Werner's approach still doesn't
satisfy me, as it doesn't protect you from someone else using your
(compromised) key as long as you don't notice it.

@_date: 2011-05-10 08:37:59
@_author: Andreas Heinlein 
@_subject: Problem with the pgp to gpg key migration 
Am 09.05.2011 14:43, schrieb Pramod.R:
First of all, it is not always necessary to "migrate" keyrings. Renaming
then to pubring.gpg resp. secring.gpg and putting them in ~/.gnupg
(under Unix) or wherever your GPG keyrings go, should work.
If for some reason that doesn't work for you, you can also try importing
the two PGP keyrings directly, with gpg --import
pubring.pkr/secring.skr. "--allow-secret-key-import" is obsolete, as the
man page states.
For the secret keys to show up, that should be --list-secret-keys, IIRC.
When importing secret keys, you need to manually set owner trust in GPG
or import the trust values as well with --import-ownertrust. That should
not affect decrypting, though.

@_date: 2011-05-27 08:10:58
@_author: Andreas Heinlein 
@_subject: I can't stop encryption being done with a wrong key 
Am 26.05.2011 21:26, schrieb Charly Avital:
Thunderbird (or the enigmail extension you're most likely speaking of)
uses the mail addresses on the keys UID to choose which key to use. If
there is more than one key with the same mail address on the keyring,
engimails behaviour becomes somewhat unpredictable and sometimes chooses
the old key, sometimes the new one.
You could either override it with explicit recipient rules, or remove
the old key from the keyring. Since you said the old key became
"corrupt", I see no point in keeping it anyway.

@_date: 2017-08-09 20:07:10
@_author: Andreas Heinlein 
@_subject: System-wide gnupg.conf? 
after reading today's announcement of GNuPG 2.1.23, I had the idea of
having a system-wide /etc/gnupg.conf, to disable the new
auto-key-retrieve etc. User's gnupg.conf should still be used and
override the same options in the system-wide conf.
Has something like this ever been discussed?

@_date: 2017-07-06 12:30:55
@_author: Andreas Heinlein 
@_subject: Questions using GPGME 
I am currently taking first steps using GPGME with the Python interface.
I am facing two questions:
1.) I'm looking for a way to get the recipients of encrypted data which
I can not/do not want to decrypt. I.e. a message for which I do not have
the private key. Enigmail tells me "This message was encrypted for ..."
in such cases, and the gpg command line does the same. Is this possible
with GPGME? Calling 'decrypt' just raises a GPGMEError in this case and
does not return a result.
2.) Is there a way to safely distinguish "User clicked cancel when asked
for the passphrase" from other errors? I think an application should
abort silently in this case, but I'm getting another GPGMEError without
any clue to the reason.
I wonder if these are just problems with the python interface or if the
functionality is missing from libgpgme. I am currently using gpgme 1.8.0
because that's what is packaged with Debian 9, but if you tell me I need
to upgrade, I will ;-)

@_date: 2017-07-06 14:48:47
@_author: Andreas Heinlein 
@_subject: Questions using GPGME 
Am 06.07.2017 um 14:01 schrieb Justus Winter:
Thank you for the quick answer. I gave it a try with 3 tests, one
decrypt with cancel'ing the pinentry, one with missing private key and
one with a truncated input file. All three gave
print str(e): Invocation of gpgme_op_decrypt_verify: GPGME: Decryption
print e.getcode(): 152
So this doesn't help. But good to know someone is working on this; I'd
be happy to help where I can. I am not a C developer, though, but I
could test if neccessary.

@_date: 2017-07-06 17:14:16
@_author: Andreas Heinlein 
@_subject: Option to select "Which topic categories would you like to 
Am 06.07.2017 um 14:50 schrieb S via Gnupg-users:
*I don't think the mailing list software could handle this. Thunderbird
can ignore and hide topics, so you would have to 'opt-out' of every new

@_date: 2017-07-13 09:48:16
@_author: Andreas Heinlein 
@_subject: Questions using GPGME 
Am 13.07.2017 um 09:27 schrieb Werner Koch:
I know, I filed the bug report ;-)
Thanks again.

@_date: 2017-07-13 14:30:37
@_author: Andreas Heinlein 
@_subject: use policy of the GnuPG-card 
Am 13.07.2017 um 13:44 schrieb Andrew Gallagher:
+1 for that. If one can install software on a machine, one can
completely take it over. No way to prevent that.
For a private machine, you could encrypt the whole hard drive, making
attacks on the OS level require physical access two times: once for
installing a compromised boot loader that intercepts the password and
once again for decrypting the drive with the stolen password and
compromising the OS.
With physical access, there are still attack vectors using firmware or
hardware manipulation which also work with physical access only once.

@_date: 2017-07-18 22:20:02
@_author: Andreas Heinlein 
@_subject: A Quick Supplement 
Am 18.07.2017 um 15:36 schrieb Robert J. Hansen:
Sorry if I'm asking dumb questions, but given that a) I am using the
same GnuPG version on all machines and b) I am excluding random_seed,
what would be wrong with sync'ing the whole gnupg directory (or the
whole user profile / home directory) with rsync/duplicity/whatever ?
Also, can you point me to a more in-depth explanation on the security
implications of re-using random_seed? I can imagine what you mean, but
I'd like to know more.

@_date: 2017-07-25 22:49:15
@_author: Andreas Heinlein 
@_subject: How to use a the same generated keypair on enigmail/thunderbird 
Am 25.07.2017 um 20:34 schrieb Robert J. Hansen:
I still would not recommend that to non-technical people. While the
users on this list probably know what a 'decent' passphrase is, most
normal users don't. They tend to choose passwords which are too short,
contain dictionary words - or they are written down right under the
keyboard... Having a second line of defense, i.e. keeping the private
key secure, is usually a good idea. That's the whole point of the
OpenPGP smartcard, after all.

@_date: 2017-07-26 13:27:20
@_author: Andreas Heinlein 
@_subject: How to use a the same generated keypair on enigmail/thunderbird 
Am 26.07.2017 um 11:27 schrieb MFPA:
Surely not. I guess most "normal users" don't even know that such a
thing exists.
Besides that, AFAIK the NFC-functionality on several SmartCards is not
for use with OpenPGP, it's just there for additional purposes with other

@_date: 2017-07-26 16:12:14
@_author: Andreas Heinlein 
@_subject: How to use a the same generated keypair on enigmail/thunderbird 
Am 26.07.2017 um 14:05 schrieb dekkzz78 at gmail.com:
Actually the one OpenPGP smartcard I know of is sold by FLOSS-Shop
This one has an NFC chip but which is not for use with OpenPGP.
There may be other smartcards out there which can also be used with
GnuPG but they're usually not called "OpenPGP card".

@_date: 2017-09-19 15:53:46
@_author: Andreas Heinlein 
@_subject: Automating and integrating GPG 
Am 18.09.2017 um 23:45 schrieb Daniel Kahn Gillmor:
None, as it seems. I have started developing with python-gpg and gpgme
some weeks ago, but haven't yet done anything with smartcards yet. But
as far as I can tell from the docs, gpgme completely hides the internals
of key storage, to gpgme it doesn't matter whether the key is located on
disk or stored in a smartcard or token.
Having said that, I must say that your goal is somewhat difficult to
achieve. Handling of the passphrase is about one of the most sensitive
tasks when dealing with encryption. I currently can think of no way you
could handle passphrases on your own in python which I would call
'secure'. Don't pass it on the command line to a gpg subprocess, that
will be readable in the process list for everyone. But even if you pass
it along with e.g. gpgme, it might be possible to read the memory of
that python process and steal the passphrase. That part of the memory
might also be swapped out. Read the relevant part of the FAQ:
Furthermore, for me one of the best reasons for using smartcards is that
you don't enter the PIN/passphrase on the (potentially compromised)
computer at all, but use a class 2 or 3 smartcard reader for that. Using
a class 1 reader and juggling around the PIN in scripts defeats 50% of
the purpose of a smartcard to me (the other 50% being that you can't
copy the secret key from the card, this stays untouched). I guess you
just have no choice when you say you are "required to", but keep that in
If you must use python and cannot use gpgme, your best bet might be to
write the passphrase out to a file which only you can read, and pass it
to the gpg command line using '--passphrase-file' or "--passphrase-fd'.
You will need to trust root on that machine in any case.

@_date: 2017-09-21 11:03:05
@_author: Andreas Heinlein 
@_subject: Automating and integrating GPG 
Am 20.09.2017 um 09:02 schrieb Werner Koch:
Interesting. I haven't found anything smartcard related in the GPGME
docs. I am really not good at C, but I took a look at the sources of
GPA, specifically the change_pin function in cm-openpgp.c, and it looks
like GPA is using assuan protocol through gpgme here:
???????????????? reset_mode??"?--reset":"",?pinno+1);
?????????????????????????????????????????? &operr);
I hadn't thought of that possibility. Python-GPG should support this,
too - take a look at assuan.py in the examples folder. But I haven't yet
found any documentation of the assuan commands you need here.
This probably isn't as easy as a Python programmer might expect...
