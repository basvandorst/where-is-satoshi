
@_date: 2004-01-27 14:59:34
@_author: Jim Hurd 
@_subject: struggling with potential keyid conflicts 
GPG seems to handle keyid conflicts very awkwardly.
I was playing a bit with the 0xDEADBEEF id (famously conflicted keyid).
recv-keys downloads multiple keys with the same key id, but gpg only uses the "first" one (I don't know the definition of first, maybe it is date?). The only way to access the second (assume for the moment that user id's are identical, or also conflicted in a different way) seems to be to delete the one I don't want, then sign the one I do want. But is this a reasonable way to proceed? Am I missing some part of the design idea here? I am writing documentation for GPG use for a group of organizations where it makes some sense to use keyservers to distribute keys, but the threat of forged keyid's is a concern.

@_date: 2004-01-27 17:34:21
@_author: Jim Hurd 
@_subject: struggling with potential keyid conflicts 
Thanks! I didn't realize that 64 bit ids and fingerprints are accepted interchangeably with 32 bit ids.
Do you know where keyservers are with this issue? I tried:
gpg --keyserver pgp.mit.edu --recv-key  0x5BD18B6A42B9247EF79214B7F87A2B53DEADBEEF
And it gives the same result as
gpg --keyserver pgp.mit.edu --recv-key  0xDEADBEEF
So either GPG or pgp.mit.edu is peeling off the lower 32 bits and calling it good enough. I suppose no harm is done, since if I know the fingerprint I want there is no serious harm in loading the extraneous keys.
----- Original Message ----- Sent: Tuesday, January 27, 2004 10:22 AM
