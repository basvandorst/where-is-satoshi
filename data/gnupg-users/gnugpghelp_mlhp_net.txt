
@_date: 2002-07-20 20:12:01
@_author: Will Morgan 
@_subject: Decryption Automation Question 
That is a FAQ. Please check the list archives.
How to automate gpg on windows is certainly a FAQ, but i do not believe it
is a question answered clearly in the archives, perhaps because of different
behavior of different versions of windows.
Check the recent thread "bad passphrase error passing it into GPG on Windows
98 using stdin"  for a lot of good help on trying to pass the passphrase in
using file handles.  Try the file handle translation utility Leigh wrote
which i haven't had the time to test out.
The way i finally got automation to work from access 2000 / Visual Basic for
Applications on Windows 98 was by writing a file to disk with the
passphrase, then writing out a batch file referencing that file, then
running the batch file with the CreateProcess API call:
Write your passphrase to a file, call it pf.txt,
then create a batch file, say dec_batch.bat, the contents of which might
look like this:
type c:\pf.txt |gpg --passphrase-fd 0 -o c:\clearout.txt --decrypt
Then execute the dec_batch.bat file using CreateProcessa documented on
support.microsoft.com in
KB Q129796, with a cmdline of "dec_batch.bat"
Shell() might be just as good a way to launch the batch file as i don't
believe the exit code is passed through the batch file from gpg using this
technique... I was able to capture stdout programmatically using pipes.. see
 for more on
doing that,
just could never pass the passphrase in via stdin.
Thanks to all who have responded to this question!!!
I believe the fact that out of practical need i and others are writing
passphrases out to disk is strong evidence for the wisdome of implementing a
pgp style command line passphrase option in gpg.  It could well be that i am
a relatively unskilled batch programmer, and that i don't see enough of the
big picture, but i don't feel so unique among current and future gpg users.
IMHO a command line passphrase option would increase the _effective_
reliability and security of gpg.

@_date: 2002-07-20 20:18:02
@_author: Will Morgan 
@_subject: bad passphrase error passing it into GPG on Windows 98 using stdin 
Belated follow up...
Being a C programmer rather than a VB programmer I don't
know for sure what the easiest way for you to get the file
descriptor converted would be.
I do know that there is a
Visual C runtime library in every copy of Windows, so if there's
no VB function to do the job, then the option of calling the
function osf_filehandle in the .dll from VB is viable.
I couldn't find a sample declaration for that call but if the .exe works (
thanks for the tool!  alas i have not had time to test it yet) i think that
function could be called in vb.
For the benefit of thread walkers in the archives i'll dupe what i just
wrote in response on the "RE: Decryption Automation Question" thread:
The way i finally got automation to work from access 2000 / Visual Basic for
Applications on Windows 98 was by writing a file to disk with the
passphrase, then writing out a batch file referencing that file, then
running the batch file with the CreateProcess API call:
Write your passphrase to a file, call it pf.txt,
then create a batch file, say dec_batch.bat, the contents of which might
look like this:
type c:\pf.txt |gpg --passphrase-fd 0 -o c:\clearout.txt --decrypt
Then execute the dec_batch.bat file using CreateProcessa documented on
support.microsoft.com in
KB Q129796, with a cmdline of "dec_batch.bat"
Shell() might be just as good a way to launch the batch file as i don't
believe the exit code is passed through the batch file from gpg using this
technique... I was able to capture stdout programmatically using pipes.. see
 for more on
doing that,
i just could never pass the passphrase in via stdin.
Thanks for all those who helped on this one!!
----- Original Message -----
Sent: Wednesday, June 26, 2002 11:52
Gnupg-users mailing list

@_date: 2002-06-26 20:51:01
@_author: Will Morgan 
@_subject: bad passphrase error passing it into GPG on Windows 98 using stdin 
Hello, I've been wallowing around for a few days and would really appreciate
some help!
Using the latest posted windows executable - 1.06 - I've got code going in
VB / Microsoft Access on Windows '98 that appears to succesfully write and
read STDIO via pipes to GPG.EXE but i have not been able to decrypt
anything, getting a bad passphrase error that does not occur when i do this
interactively.  At this point I'd be happy to pass the pass phrase pretty
much any which way i can, the following method of using stdin is what i've
tried without success, any ideas about what i might do differently with this
technique or others to front end decrypting a batch o messages on win 98?
Thanks! Will
- Problem Description:
--- versions
gpg (GnuPG) 1.0.6-2
( latest windows executable available on  )
called from VB / Microsoft Access running on Windows 98
--- commandline
gpg -o c:clearout.txt --passphrase-fd 0 --decrypt c:\cypherin.txt
--- input / stdin
I've tried setting the stdin string to "mypass phrase", "mypass phrase" &
vblf and "mypass phrase" & vbcrlf.    ( I believe vblf is the same as /n )
--- output
gpg: encrypted with 1024-bit ELG-E key, , created 2002-05-22
gpg: public key decryption failed: bad passphrase
gpg: decryption failed: secret key not available
gpg: block_filter 0049775C: read error (size=8269,a->size=16777293)
gpg: block_filter: pending bytes!
--- Full text to code including winapi declarations at
--- i believe the crux o' the code lines:
   ret& = CreatePipe(hReadPipe3, hWritePipe3, sa, 0)
   ret& = CreatePipe(hReadPipe2, hWritePipe2, sa, 0)
   ' Initialize the STARTUPINFO structure:
   start.cb = Len(start)
   start.dwFlags = STARTF_USESTDHANDLES
   start.hStdInput = hReadPipe3
   start.hStdError = hWritePipe2
   start.hStdOutput = hWritePipe2
   ret& = WriteFile(hWritePipe3, szStdIn, Len(szStdIn), lbytesWritten, 0&)
   Call CloseHandle(hWritePipe3)
   ret& = CreateProcessA(0&, cmdline$, sa, sa, 1&, NORMAL_PRIORITY_CLASS,
0&, 0&, start, proc)
The process returns instantly with the error, if i don't write to the pipe
gpg says its waiting on fd-0.
