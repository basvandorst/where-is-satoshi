
@_date: 2009-11-25 23:06:24
@_author: Ciprian Dorin, Craciun 
@_subject: Backup of private key 
:) I kind of had the same problem. My solution to this one was (in
order of commodity, but not reliability):
    1) backup the files from ~/.gnupg to an off-line storage medium
(USB stick, CD/DVD-ROM, another computer, etc.) (usable mainly for
full-restore); (the offline-store should be as secure as your desktop
    2a) export the secret keys and store them off-line (usable for
re-import in case the binary databases from ~/.gnupg break) (as
security the same as above):
        gpg --armor --export-secret-keys
    or
        gpg --armor --export-secret-keys {id}
    2b) the same as above but protected by an extra password (the keys
are already protected by a password) (for more vulnerable offline
stores, like Brian said):
        gpg --armor --export-secret-keys {id} | gpg --armor --sign
--symmetric --force-mdc
    4a) by using paperkey [1] I can create a ASCII file that is quite
small and contains only the needed secret bits of the secret key; the
idea with this one is that nothing outlives paper, and thus if
something happens with my previous backups I could just feed a scanned
version of the printed file (only one page) through an OCR; (or worse
I could just enter by hand the data, because it's quite small); (the
file must be stored somewhere quite safe;)
    4b) I use the same idea as the previous one, but instead of
printing the text file I feed it (or a part of it) through a QRcode
[2] encoder and print the resulting image. Thus restoration implies
only photographing the printed page, and feeding it through a decoder;
(I've tried this one and works flawlessly.)
    Please someone correct me if I'm doing something wrong
somewhere... My keys depend on it. :)
    Ciprian.
    [1]     [2]

@_date: 2009-11-28 16:42:06
@_author: Ciprian Dorin, Craciun 
@_subject: GnuPG private key resilience against off-line brute-force attacks  
(I'll try to start a new thread from the following quotes.)
    Related to the same problem (strength of the secret key data
encryption measures), I've posted some months ago an email on the
scy.crypt Usenet group, but I didn't got a satisfactory (that is
factual) answer. (See below.)
    Maybe someone could clear this out (at least from GnuPG part). (My
original post was related with both GnuPG an OpenSSH).
~~~~~~~~~~ Original post:
    (I have a very basic question that to most of the persons reading
this news-group might seem trivial. But anyway...)
    My concern (as stated in the subject) is related to the security
strength of GnuPG and OpenSSH secret / private keys in the following
    * the secret / private keys are encrypted by using a password that
only me (the owner) knows;
    * an attacker is in possession of my secret / private key files;
    * the attacker wants to gain access to the secret / private key
(thus being able to impersonate me);
    * the attacker chooses as attack method to brute-force the files
off-line, by trying to guess my password;
    * (by guessing the password I mean trying all possible passwords
that fit a given pattern; the password is not a dictionary word, but
instead is (truly) randomly created (i.e. DiceWare);)
    The question is: what does GnuPG or OpenSSH do to slow down
password brute-force? I mean does the password derivation function use
some iterations? If so how many? Can I configure them? I guess so but
I couldn't find any data on the net on a quick search. (Any references
are appreciated.)
    Also, how many bits of security should my password have in order
to withstand an attack from a small / medium enterprise? (Government
is out of the question as they could get access to my infrastructure
by force...)
    Thank you for your patience and your wisdom,
    Ciprian Craciun.

@_date: 2009-11-28 18:55:25
@_author: Ciprian Dorin, Craciun 
@_subject: GnuPG private key resilience against off-line brute-force attacks 
Thank you for the quick reply. (This is the kind of answer I was
hopping to get. :) ) It seems that `s2k-count` escaped me. :)
    Maybe there should be an entry in the FAQ about this topic.
    Related with my question about the password bit strength there
still is a vale on my eyes. So I guess (sorry for not being properly
documented here):
    * the private / public key pair is generated by using whatever
means (RSA / DSA);
    * my password is taken and fed into "Iterated and Salted S2K" to
obtain the secret key encryption.
    * the private key data is taken and fed into '????' algorithm that
uses as password what has been obtained at the previous step.
    So my question about key strength is: what symmetric key algorithm
is used to safeguard the key. (Again I'm not properly documented
here.) And based on the identity of this algorithm, I can use the site
cited ( to determine a "best practices" key
length. (Other wise I'll have to go with the generic term "symmetric
key encryption"... :) )
    By key strength I mean the bits of entropy given by the password
generation pattern. For example a 4-digit PIN number has only 13.3
bits of entropy, even though we need at least 16 bits to store it.
(This was also pointed out by Farami in his reply.)
    Thanks again,
    Ciprian.
    P.S.: I'm also aware of the fact that iterations do not help at
all, if a big-budget agency (NSA and the like), is going to build a
hardware based brute-force key breaking, as they can build a pipeline
of iteration functions that would try one key in O(1) time. :) (Or I'm
wrong here?)

@_date: 2009-11-29 01:49:03
@_author: Ciprian Dorin, Craciun 
@_subject: GnuPG private key resilience against off-line brute-force attacks 
On Sun, Nov 29, 2009 at 12:29 AM, Mario Castel?n Castro
    Again, as I've replied to Mario (off-the-list, below the excerpt
for the rest of the list), by pipe-lining I assumed something like a
hardware SIMD architecture.
    But I do agree that for a software-based implementation the
iteration count does imply O(iteration_count) time complexity (which
is constant). But not for a hardware implementation, where I can trade
O(1) (and by `1` I don't mean constant, I actually mean `one
heart-beat or a small number of hardware cycles`) in time with a O(n)
in hardware complexity.
    In short:
    Could someone prove me wrong? (I'm not a hardware expert, but I
believe it's technical possible.)
    Ciprian.
On Sat, Nov 28, 2009 at 7:20 PM, Ciprian Dorin, Craciun

@_date: 2009-10-12 14:58:04
@_author: Ciprian Dorin, Craciun 
@_subject: gpg-agent --daemon running in foreground 
Hello all!
    I'm facing the following problem: I need to run gpg-agent, but
without him going into background. Is there any solution to this one?
    Thanks,
    Ciprian.

@_date: 2009-10-12 16:57:49
@_author: Ciprian Dorin, Craciun 
@_subject: gpg-agent --daemon running in foreground 
So I have the following situation: I want to be able to run
gpg-agent inside a runsv process (part of runit package), that
monitors the process, and in case it breaks, it shall restart it.
Unfortunately gpg-agent forks into background, and thus I cannot
monitor if it's running from inside runsv.
    Thus I need to make gpg-agent behave just like `gpg-agent
--server` (not forking into background), but using the sockets (just
like --daemon).
    Anyway, I've modified the latest source code (2.0.13), file
agent/gpg-agent.c, to add another option --daemon-fg, that shall not
fork in background. (The patch is attached.) (I'm not very proud of
the patch but it does the job. Hope I've not broken anything... :) )
    So I would like to ask the maintainer of gpg-agent to look upon
it, and either include it, either (if time allows him) provide such an
    Thanks,
    Ciprian.

@_date: 2009-10-29 13:42:37
@_author: Ciprian Dorin, Craciun 
@_subject: Howto For DNS Key publishing. 
Hello!
    Nice tutorial! I've tried to apply your methods (for now I'm just
at the PKA method).
    But it seems that there is a problem with auto-key-locate option.
For example for the following command:
        mkdir /tmp/gpg-test
        gpg2 --homedir /tmp/gpg-test --auto-key-locate pka --recipient
ciprian at volution.ro --encrypt /dev/null
    it gives me the following error:
gpg: requesting key A6FD8839 from http server stores.volution.ro
gpg: /tmp/gpg-test/trustdb.gpg: trustdb created
gpg: key A6FD8839: public key "Ciprian Dorin Craciun
" imported
gpg: no ultimately trusted keys found
gpg: Total number processed: 1
gpg:               imported: 1
gpg: error retrieving `ciprian at volution.ro' via PKA: Unusable public key
gpg: ciprian at volution.ro: skipped: No public key
gpg: /dev/null: encryption failed: No public key
    Now, searching on the net for a solution, I've stumbled upon the
following thread:
            It seems that there was a bug in GnuPG. So the question is:
    * am I doing something wrong?
    * or is the bug still present in GnuPG?
    Thanks,
    Ciprian.

@_date: 2009-10-30 11:55:55
@_author: Ciprian Dorin, Craciun 
@_subject: Howto For DNS Key publishing. 
Ops! Sorry!
    Yesterday evening I came upon the same conclusion and prolonged
the expiration date... (But I didn't connect the dots with my
    Sorry for wasting time! :)
    Anyway, good tutorial! Thanks!

@_date: 2010-01-23 11:59:00
@_author: Ciprian Dorin, Craciun 
@_subject: gpg-agent --daemon running in foreground 
On Mon, Oct 12, 2009 at 3:57 PM, Ciprian Dorin, Craciun
    Sorry to bother you guys again. Have you looked at my patch
(related with the my previous comments)?
    (It allows gnupg-agent to behave normally like a daemon, but not
go into the background.)
    Is there something wrong with it?
    Thanks,
    Ciprian.

@_date: 2010-01-23 12:07:45
@_author: Ciprian Dorin, Craciun 
@_subject: gpg-agent --daemon running in foreground 
On Sat, Jan 23, 2010 at 11:59 AM, Ciprian Dorin, Craciun
    Forgot to attach the patch again. :)

@_date: 2010-03-13 08:52:27
@_author: Ciprian Dorin, Craciun 
@_subject: Paperkey (Was: Re: ) 
I've used the `dtmx` tool to export some GPG keys (exactly a 4096
bits one) and it worked.
    What I did was something like:
        paperkey --secret-key ./key.gpg --output ./key.paperkey
--output-type raw
        dmtxwrite --encoding 8 --format png --resolution 72
<./key.paperkey >./key.png
    And everything worked just perfectly.
    But after looking through my scripts (because I've automated the
entire process), I see a test where I check if the size of the file to
be encoded is less than 1555 bytes, because it seems that dtmx (in
fact the specification?) doesn't allow files larger than this.
    Another quirk that I've found is that decoding back that image
after being printed, photographed and put back in my computer worked
Ok for small sizes (~200-300 bytes), but for other files (closer to
~1000 bytes) I was not able to decode the image back even after some
image processing that enhances the contrast, sharpens the colors, etc.
(I haven't tried a scanner, but I guess that would have worked.)
    (But the original file spitted out by dtmx was decoded just fine.)
    Ciprian.

@_date: 2012-07-30 22:15:55
@_author: Ciprian Dorin Craciun 
@_subject: pipe passphrase to unlock key 
Hope my feedback is not too late... But either way I don't think
it would help too much as neither solution is straight-forward...
    So the only workaround -- that I know of, but I'm not a GnuPG
developer -- is to either:
    * implement your own "fake" `gpg-agent` which I have no ideea what
actually implies;
    * implement your own "fake" `pinentry` which would be much simpler
as it only has to implement the assuan protocol; but you'll have to
start a separate instance of `gpg-agent` just for this situation,
which unfortunately will background and you'll have to "hunt it down"
once your done, or you could use that to start your command as a child
of `gpg-agent` which is a horrible hack;
    * (preferably) implement a fake `gpg` which does the following:
opens a pipe as you have done in your example, writes the password and
then calls the real `gpg` with an additional argument
`--passphrase-fd`; (this works only as long as Git uses the `gpg` tool
and not the library... fortunately this is true today and I guess it's
unlikely to change...)
    Related to this last option, and assuming you are on Linux and are
using a recent BASH version (mine is 4.x), you could do what you want
as bellow (code not tested):
env \
    GPG_PASSPHRASE_FD=<( printf -- "${password}" ) \
    PATH="a-folder-where-your-gpg-wrapper-is:${PATH}" \
    git ...
    Notes:
    * the syntax <( ... ) replaces the token with the path of a pipe
ready to read from the sub-command in the parenthesis; (see the Bash
    * as you can't send arguments to `gpg` via Git you use environment
    * the password is not visible in the environment of the `git` or
its children, but could be read from that descriptor;
    * depending on Bash it could actually be stored on the file system
thus maybe leaked to permanent storage...
    Where your `gpg` wrapper would be (not tested but adapted from
another script of mine):
# see Bash manual for the magic in the following line... :)
set -e -E -u -o pipefail || exit 1
_self_path="$( readlink -e "${0}" )"
_self_name="$( basename "${0}" )"
# this would contain each resolved file in the path
# if we are a wrapper then the first is the wrapper
# and the second must be the real one
_paths="$( which -a -- "${_self_name}" )"
while read _path
        _path="$( readlink -e "${_path}" )"
        test "${_path}" != "${_self_path}" || continue
        _next="${_path}"
        break
done <<<"${_paths}"
# it will silently fail if we haven't found the real gpg
test -n "${_next}"
# we assume that someone has exported the `GPG_PASSPHRASE_FD`
# and that there we have a path to a pipe to read from
# we also assume that we have at least another argument
exec "${_next}" --passphrase-fd "${GPG_PASSPHRASE_FD}" "${
exit 1
    Hope this helps you (one moth later) although it is a crude hack... :(
    But the real problems is still open and should be solved by
extending both Git and GnuPG...
    Ciprian.
    P.S.: If you don't like the Bash script I have an neat idea on how
to simply implement it in C, in a similar fashion, which would
guarantee you zero file system exposure.

@_date: 2012-07-31 13:54:08
@_author: Ciprian Dorin Craciun 
@_subject: pipe passphrase to unlock key 
Not necessarily if you use the `--batch`, `--no-use-agent`, or
`--no-tty` (or a mix of the I'm not sure right now, but the manual
    I completely agree with you on this. But the above didn't imply
saving the password in the script... `password=...` was just a
suggestion that you need to somehow obtain the password, and then use
it with the Bash `<( ... )` feature. (Although I've suggested it might
bee leaked to the file system.)
    But on the other side, not always you have the option of running a
`gpg-agent` (for example on server side of a background job, etc.),
thus I guess this method has its uses.
    Although I once more agree with you that if you need to automate
password handling maybe it's better not to use it. The only exception
I could think of is if you hold the password entirely into memory of a
daemon process that delegates signatures, but you feed it manually at
boot-up, this way at least if someone steals your device it will have
a harder time getting your actual key. (I completely ignore the "warm"
boot attacks, root-kits or the like... As in these cases your done
fore regardless...)
    To complete my response, this is what I've replied privately to
the original poster, about the solution not involving Bash.
    Ciprian.
    [How to give the password to `gpg` while not controlling its invocation.]
    The solution is quite simple and I think it is also portable. But
it still uses the customized `gpg` wrapper, it only solves the
potential password leaking to the file system.
    I'll just highlight the solution, the details being quite simple:
    * use the `pipe2` syscall (and use the `O_NONBLOCK` flag just to be sure);
    * write the password to the pipe, then close the write end; (the
read end is still open;)
    * (maybe be sure that the descriptor value is above or equal to 3;)
    * export an environment variable holding the file descriptor value;
    * `exec` your `git` process which will inherit the open end of the pipe;
    * (in turn your `gpg` wrapper will inherit the descriptor and the
environment variable;)
    What it gains you:
    * first of all the password is now stored only inside the pipe and
can't be recovered from the arguments or environment of the processes
(via `/proc/$pid/cmdline` or `.../environ`);
    * the password can be read exactly once by at most one process
(see below for the caveat);
    * you have no other extra process running (as would happen in the
`<( ... )` Bash solution);
    * if `gpg` would have accepted a `GPG_PASSPHRASE_FD` environment
variable you wouldn't have needed a wrapper script for `gpg`; (this
works for some other programs;)
    What it doesn't grant:
    * complete password secrecy, as anyone with proper rights (usually
any of your processes) could still quickly open `/proc/$pid/fd/$num`
and read the password;
    If you need the password multiple times, this still can still be
done but you'll have to complicate the wrapper too, by:
    * exporting both the read and write ends;
    * the wrapper executes exactly one `read` operation, it writes it
again to the write end; (it doesn't close either ends;)
    * it then creates another pipe and applies the trick as initially
described which is passed to `gpg`;
    * (this works because POSIX mandates that a write less than a page
(4kb on Linux) must match exactly a read operation, thus maintaining
data boundry;)

@_date: 2012-07-31 18:53:50
@_author: Ciprian Dorin Craciun 
@_subject: pipe passphrase to unlock key 
(Sorry I didn't knew you've implemented it.) :)
    Mmm... Didn't read the "fine print" of the manual... (Which isn't
that fine print...)
       --no-use-agent
              This is dummy option. gpg2 always requires the agent.
    Then I'm a little bit at unease...
    First of all I would really have liked the tool to not just ignore
the `--no-user-agent` flag and bail out...
    Then if I use the `--batch` option it doesn't ask for a password,
thus what is the purpose of the agent anymore? (Except handling cards
which isn't the case in most instances...)
    I bet you can run it on servers. And I bet it works nicely.
    What I also bet is that it leaves dangling "background" processes
lying, because -- if I'm correct -- the following happens:
    * if I implement a service that isn't started with an `gpg-agent`
properly set up, then
    * each invocation of `gpg2` will start its own, but not as a
child, but by making it double fork in the background;
    * but unfortunately the tool won't be able to export that
environment variables to its parent...
    * and also after the invocation the agent would just remain there;
    Maybe the tool would check if someone listens on the socket and
not restart another agent, but still we have at least one agent
running, and for no purpose as there is no password to enter...
    Or?
    Ciprian.
    P.S.: Maybe you remember that I've sent a patch in the past that
adds an option to the agent not to double fork (which was rejected)...
I really still strongly believe that double forking is very bad, and
should be done only in exceptional cases... (And the GnuPG or SSH
agents aren't one of those cases...)

@_date: 2012-09-20 11:50:57
@_author: Ciprian Dorin Craciun 
@_subject: encryption/decryption without files 
Not necessarily, because a text editor could do the following...
    Context:
    * it's clear that most editors use `ncurses` (or similar) to
interact with the console;
    * and it seems that `ncurses` does use stdin and stdout;
    But:
    * when starting a text editor could check if stdin or stdout are
pipes and not TTY's;
    * at the same time it should check that stderr is a TTY; (this is
mandatory for the following to work);
    * if so it could `dup` the stdin and stdout descriptors to obtain
a "copy" of the pipes;
    * and it should `dup2(2,0); dup2(2,1)` to replace the stdin and
stdout with a "copy" of the TTY; thus `ncurses` would be very happy;
    * use the "copy" pipes to take the text, edit it, and write the text out.
    Thus someone could write something similar like:
gpg2 -a -d file-v2.asc
    Of course (to my knowledge) none of the "mainstream" editors seem
to do this.
    You could also try to "fool" some editors by something like (not
tested) (but be careful to save the file as `/dev/fd/5`):
gpg2 -a -d ... \
     4<&0 0&1 1>/dev/tty \
    Ciprian.
    P.S.: For some years I'm using my own "homegrown" text editor that
does exactly what I've described in the first section.
          !!! BUT !!! It's written in Python (thus swap is your disclosure
enemy), and if it crashes it writes a copy of the text to `/tmp`
    P.P.S.: I've though for some time to implement something similar in Go...

@_date: 2014-06-04 15:45:35
@_author: Ciprian Dorin Craciun 
@_subject: Google releases beta OpenPGP code 
Although I find such a plugin welcomed --- at least for trying to
bridge PGP-based security to the browser, like the defunct Firefox
GnuPG plugin did a few years ago --- I also think that the purpose of
such a tool is limited to either public education (getting them used
to the idea of "better" privacy), experimentation (being written
solely in JavaScript), or in the worst case marketing.  (Though I'm
sure its developers have only the best in mind.)
    The reason I'm stating this is based solely on what they write on
the project's page [1] regarding to the "security" of the solution,
it's threat-model, implementation, etc.  For example looking at the
section "How safe are private keys in memory?":
Please note that enabling Chrome?s "Automatically send usage
statistics and crash reports to Google" means that, in the event of a
crash, parts of memory containing private key material might be sent
to Google.
    Personally I won't use any browser plugin that operates on
cryptographic material inside it's own process.  Instead I would
expect it to delegate such operations to something similar to the
GnuPG agent.
    However I would love to see again a Firefox GnuPG plugin,
    Ciprian.
    [1]

@_date: 2015-02-02 22:49:22
@_author: Ciprian Dorin Craciun 
@_subject: Prioritizing secret keys when deciphering 
I encounter a very anoing issue...  If a certain "packet" is encrypted
to multiple private keys, and I happen to have two (or multiple) of
them in my secret keychain, then when decrypting, although GPG always
tries them in the same order, the order is not the one I would
Thus, is it possible to tell GPG in which order to try the secret keys
in case it finds multiple of them that are in the secret key ring?
P.S.: Why do I have two secret keys that I own in the same "packet"?
Because one of the keys is the one put by the default `encrypt-to`
option, and the other one is a shared private key used by me and my

@_date: 2015-02-06 08:54:05
@_author: Ciprian Dorin Craciun 
@_subject: pinentry-curses unusable with gpg-agent --no-detach 
Welcome to my worst nightmare:  trying to make GnuPG agent (and for
that matter the SSH agent) runnable in the foreground.  (My purpose
was to run it under a process supervisor like `runit` or `s6`, but
Short answer:  you can't convince any of these agents to behave and
run in the foreground.
What is worse is that no matter how you configure GnuPG agent or
`pinentry-curses` to use a certain TTY, it will always "finds" the
"current" TTY your GnuPG is running on.  (And I've tried to write my
own `pinentry-curses` wrapper that was set to GnuPG agent with
`--pinentry-program`, and the wrapper calls `pinentry-curses` with all
the right parameters like `--ttyname`.)
However hope is not lost...  I did modify that wrapper script to
actually mangle the protocol and always replace the `OPTION ttyname`
(and others) commands with hardcoded values.  Below is the portion of
the wrapper script you might find useful. (Just replace `/dev/tty`
with a proper value. In my case the uses some tricks to open it on the
11th virtual console).
Thus run `gpg-agent` like you would normaly do (i.e. let it fork into
the background), and use this trick.
pinentry-curses \
        --timeout 6 \
        --display __none__ \
        --ttyname /dev/tty \
        --ttytype linux \
        --lc-ctype en_US.utf8 \
        --lc-messages en_US.utf8 \
< <(
    exec sed -u -r \
            -e 's|^OPTION display=.*$|OPTION display=__none__|' \
            -e 's|^OPTION ttyname=.*$|OPTION ttyname=/dev/tty|' \
            -e 's|^OPTION ttytype=.*$|OPTION ttytype=linux|' \
            -e 's|^OPTION lc-ctype=.*$|OPTION lc-ctype=en_US.utf8|' \
            -e 's|^OPTION lc-messages=.*$|OPTION lc-messages=en_US.utf8|'
For the record I've opened a similar thread on this subject in 2009
and then 2010 without any real solution:
   at gnupg.org/msg12323.html
Hopefully you are more lucky,
P.S.:  I really like GnuPG, and I salute the developers effort.
However the way the GnuPG agent integrates with other software (mainly
process supervisors) and the PIN entry, are really abysmal...  Some
updates in this regard are welcome and in fact quite easy.
Below is a patch I did in 2009 to add a new option `--daemon-fg` which
makes GnuPG agent behave like in `--daemon` mode but without forking
into the background.  (Although the patch was trivial was not
   at gnupg.org/msg12323.html

@_date: 2018-08-06 09:38:45
@_author: Ciprian Dorin Craciun 
@_subject: Encrypt USB-HDD with LUKS using OpenPGP smartcard? 
I have a similar setup where at boot time I use GnuPG to decrypt my
drive with keys protected by GnuPG (instead of using LUKS).
I have managed to instruct GnuPG to use `systemd-ask-password` to
retrieve the password.  However I imagine that with some "tinkering"
one can implement a simple PIN-entry application to use
`systemd-ask-password`, and thus manage to make the whole setup work
with a smart card.
My script and systemd service file can be found at the following link:
  You just need to place these somewhere, update your paths (especially
in the `.service` file by replacing `store` and `lvm` with appropriate
tokens), and it should work by just updating your `/etc/fstab`.
(These were developed and tested only on OpenSUSE.)
Hope it helps,
P.S.:  I really love GnuPG for its crypto-related features, but on the
flip-side I really hate it for it's "integration" related features
within environments where it shouldn't double fork processes (like its
agent), muck with the TTY (like when reading passwords by the agent),
and in general just be "well behaved"...

@_date: 2018-08-15 14:49:11
@_author: Ciprian Dorin Craciun 
@_subject: Encrypt USB-HDD with LUKS using OpenPGP smartcard? 
Basically I just looked at how a similar file was generated by systemd
for other `/etc/crypttab` targets and adapted.

@_date: 2019-02-26 11:02:59
@_author: Ciprian Dorin Craciun 
@_subject: Question about the security of the GnuPG Agent with regard to 
Hello all!
Given the recent survey in password managers security [1], which
concluded with their failure to properly sanitize / scrub the
sensitive data (i.e. "master key") in "running locked state", I was
wondering how does GnuPG Agent fare in this regard?
More specifically:
* let's assume that one uses GnuPG Agent;  (only for PGP;)
* the user enters the password for a particular private key;
* (one assumes that the password was used to get the private key
cryptographic material, and then scrubbed;)
* then `--max-cache-ttl` seconds passes;
* one assumes that the private key cryptographic material is now scrubbed;
Is this expectation correct?
Is there some external analysis about the security of the agent with
regard to the scrubbing of both passwords and cryptographic material?
[1] P.S.:  My interest in this subject is because I have a "custom"
password-manager implemented on-top of GnuPG, which I'm sure leaks
passwords all over the place (because it's written in Bash, and uses
various X tools, none made for security).  However I am curios how
"safe" the actual GnuPG agent really is.

@_date: 2019-02-26 13:54:01
@_author: Ciprian Dorin Craciun 
@_subject: Question about the security of the GnuPG Agent with regard to 
I know about that tool, however it is unfortunately written also in
Bash, which as my own implementation has countless ways to
(permanently) leak the password.
For example take the following commit:
    Which has the following change:
- $GPG -e "${GPG_RECIPIENT_ARGS[ -o "$passfile" "${GPG_OPTS[
<<<"$password" || die "Password encryption aborted."
+ echo "$password" | $GPG -e "${GPG_RECIPIENT_ARGS[ -o "$passfile"
"${GPG_OPTS[ || die "Password encryption aborted."
In was committed in 2018, but the tool is from 2015, thus in the
interim all the passwords were leaked into `$TMPDIR` and thus on the
disk, which in most cases is actually the `rootfs`.  Thus without much
effort, one can take out the HDD, and just run a file-system recovery
tool to recover deleted files, or dump ASCII tokens, and thus get
access to the used passwords.
I'm not criticizing the `pass` tool, as I know myself how hard it is
to write a tool that doesn't leak data, however any such tool should
come with a big warning to its users.
Unfortunately on the project page there is no mention of its security
weaknesses or any hint to the users about possible data leaks.
