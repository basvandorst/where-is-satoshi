
@_date: 2015-12-03 01:18:23
@_author: Andrey Utkin 
@_subject: question about gpg2 and passphrase 
Have you tried generating a key with empty passphrase?

@_date: 2015-12-03 06:25:27
@_author: Andrey Utkin 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
Thank you for your hints Peter.
The following tiny changes allow exporting and importing to succeed
Is the approach of using "s2kmode = 0" and "protection sha1" together
correct? Shouldn't "protection none" be used?

@_date: 2015-12-06 22:41:48
@_author: Andrey Utkin 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
Just for note.
This can be worked around the following way (works in both 1.4 and 2.1,
didn't test in 2.0).
1. Export key, giving any non-empty passphrase.
2. Import key on new location supposed for automated key usage.
3. `gpg --edit-key `, there type "passwd", enter old passphrase,
enter empty line twice, strike Ctrl+D, confirm changes saving. This
works identically in both 1.4 and 2.1.
If importing location has no capability of passphrase changing
(--edit-key) - e.g. Android Open Keychain - import it to 1.4 keychain,
then export it, it will let you export it without passphrase (won't even
ask for it).
Thank you Peter for pointing out that this is solvable without fixing
the issue in code, but your suggested solution wasn't enough, so I had
to go a few steps further :)
I'd like to state this explicitly (due to rational point made by Peter)
that the link to my private GnuPG git fork with a patch is not supposed
a working solution - it is an experimental work in progress which is not
assured for being interoperable. It is a fruit of uneducated reckless
tinkering with original code.

@_date: 2015-12-10 00:05:58
@_author: Andrey Utkin 
@_subject: Please consider joining Bountysource Salt to collect recurring 
This request targets GnuPG maintainers to register a team on that
(and/or others, e.g. Gratipay) croudfunding platform.
GnuPG users are welcome to comment whether they would support such
Occasional GnuPG contributors are welcome to comment whether they would
like to become "bounty hunters" (an opportunity on subj site).
I am not affiliated to these platforms.

@_date: 2015-12-10 03:22:58
@_author: Andrey Utkin 
@_subject: Please consider joining Bountysource Salt to collect recurring 
Wow, actual Donate page turned out to be a secret area, not obvious to
get to it (it looks like a menu header, not a menu entry).
Without regard to that:
- subj enables recurring donations (personally I am not willing to make
large one-time transcation),
- subj is a place where people eager to give go to find whom to give,
- subj is new, it gains popularity and gets people attention, so
somebody would consider GnuPG when reviewing projects available for funding.

@_date: 2015-12-11 15:51:49
@_author: Andrey Utkin 
@_subject: Please consider joining Bountysource Salt to collect recurring 
The Salt project has released this spring or this autumn, I don't
remember for sure.
There's competing project Gratipay (former Gittip, rebranded recently),
and some more, so there's also a fragmentation.
Yes you are right that these platforms (and recurring donation to FOSS
projects in general) is far from being as popular as it should be. But
basically this is a network, and the value of network is bound to number
of members in it. If nobody is in, nobody considers joining worth. The
more time passes, the more projects and backers join and the more is
money flow.
I was surprised to become first backer of FFmpeg project, which was
already set up :)
Also I am not aware how much hassle is it for you to set up your
donation-collecting account on these networks, but I hope it's not that
Werner, Donate menu entry got better, but there's another issue - when
cursor pointer moves from menu header down to menu entries, menu
dropdown tends to disappear, it takes many attempts to catch it :)
Thanks for all the comments.

@_date: 2015-11-24 03:16:31
@_author: Andrey Utkin 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
$ gpg --export-secret-keys
(pops a Xorg dialog window from my console, driving me nuts)
(i give empty passphrase)
(it asks me whether i am sure I want no passphrase)
(I say yes)
gpg: key XXXXXXXX: error receiving key from agent: No passphrase given -
Why is there such a _policy_?
Maybe I am lost and I am using Windows which re-asks everything and
still refuses to do what I want?

@_date: 2015-11-27 14:58:01
@_author: Andrey Utkin 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
Thanks to everybody for caring about my issue, and for showing that I'm
not alone with it.
So this already has been reported in
 and has been discussed in
So it just needs to be patched. Does anybody knows what works well if I
am ready to donate (not a ton) and want to have it done soon?
P. S. I haven't received 2 of 3 replies to my gmail mailbox, had to go
to maillist archive to review the thread. Have this happened to anybody
else, is this a known issue?

@_date: 2015-11-27 23:55:18
@_author: Andrey Utkin 
@_subject: [RFC] Keychain for GPG, SSH, X.509 etc. (inspired by Split GPG) 
TL;DR: Generalization of "Split GPG" concept.
Any comments?
Anybody likes the idea?
Ready to join development or early adoption?
What is this: Concept of flexible solution for usage of private keys
without disclosing them. Key usage is always confirmed by user (as a
form of AnyNumber-factor auth).
What is planned to guard: OpenPGP keys, SSH keys, X.509 client certificates.
Inspiration: Split GPG (
PGP-smartcards, SSH-smartcards.
Implementation form: portable libraries/toolkit.
 - keychain server (KS): the process which is accessible via specified
protocols and has access to the unprotected keys, so that it can use them:
 --- encrypt/decrypt/sign;
 --- create challenge responses;
 - keychain key usage client (KUC): the process which makes requests for
key usage;
 - keychain confirmation server (KCS): the process conveying User's
decision (approval or rejection) to each key usage request;
The following elements must run in trusted environment (including
trusted physical security system, trusted hypervisor, trusted machine OS);
 - keychain server;
 - keychain confirmation server.
Keychain key usage client can work in entirely hostile environment.
Keychain usage client (KUC) may be entirely spoofed by attacker, no data
from KUC is trusted and it must be verified by User.
The above restriction is not a show-stopper ("oh, too much restricted
scheme - how to get such trusted environments?"). It is an improvement
comparing to default scheme, which supposes secret keys exposition in
same hostile environment. The point is in decoupling these three
essential entities of key material, key usage agent (gpg-agent,
ssh-agent) and key control (usually underdeveloped in mainstream systems
- you just MAY get asked to enter passphrase if you use it).
This scheme is an improvement comparing to hardware smartcard usage
because it brings flexiblility and fine-grained control to key usage
confirmation procedure.
Q: How confirmation happens?
A: This function is outsourced to plugin system. Different systems would
find different ways as most fit. Used/allowed plugins configuration is
set up in keychain server. It possibly will look similar to Linux PAM.
Q: How to have keychain server data encrypted?
A: As long as KS must actually use the keys in their unencrypted form,
it is required that safety of KS is trusted. If we cannot assume KS
environment trusted, then keys are compromised as soon as they get
loaded in unencrypted form. See  "I
proudly use empty passphrases on all of my private keys...". Encryption
of KS data is out of scope of this scheme, but it may be implemented as
the adopter decides, as additional safety measure.
Q: How to ensure unspoofability of confirmation dialog?
A: Confirmation app must run in trusted environment, so this is not
needed. If environment is not trusted, the unspoofability of
confirmation dialog is only one of countless unresonvable security issues.
Q: Which protocols are used to convey key usage dialogs and confirmation
A: The ones that can be considered handy and trusted in specific case.
The following ones are offered for adopters consideration:
 - SSH;
 - other end-to-end (KUC-KS, KS-KCS, KUC-KCS) encrypted connections:
 --- XMPP via TLS chat with PGP or OTR encryption;
 --- HTTPS online session with realtime notifications;
 --- encrypted VoIP or VVoIP call communication (smart audio
synthesis/recognition software are probably required);
 --- confirmation HTTPS link in encrypted email;
 - NFC (near-field communication protocol, hardware) - NFC crypto chip
prepares signature which shows approval to KS;
 - (bad, use as fallback) SMS, PSTN call;
It should be stated that KC may want to gather more than one approval,
by more than one communication channel (thus we have multi-factor
authorization). Or system may query several confirmation channels in
parallel or serial fashion.
Examples of viable platforms for trusted elements (KC, KCS), review of
potential risks:
 - Android device: so-so to bad (depending on whether the system is
fully dedicated, and on system configuration):
 --- risk for KC: vendor-provided OS system services tend to spy on user;
 --- risk for KC: normally every app has its kernel-guarded storage, but
processes with system privilegee (gained by exploit or by user
permission) may access this data;
 --- risk for KCS: potential spoofing of KCS app dialogs;
 - Remote sever: bad to so-so to good (depending on whether VPS or owned
and guarded physical machine):
 --- risk for any component: remote attack (TODO elaborate, review more
 - Pluggable micro-PC with dedicated system (like
 potentially good, but there's
lack of interactive peripheral for dialog, a gadget like androids
without bloatware would be nice.
 - Virtual machines: good, but must be used properly - untrusted env
mustn't be supervising trusted env.
 - Different UNIX system accounts from untrusted component: bad, trusted
elements are owned on privilege escalating exploitation.
 - LXC: same as with UNIX accounts (kernel exploit owns everything)?
Example elements layouts:
 - keychain server (KC) and confirmation server (KCS) on Android device,
keychain usage client (KUC) on a workstation: simple, affordable, bad
 - keycnain server (KC) on remote server, usage client (KUC) on a
workstation, confirmation client (KCS) on another, trusted workstation:
pretty good, if remote server is safe;
Further expansion of this scheme:
 - X.509 client cert auth challenge forwarding (using browser plugin);
 - HTTP DIGEST auth challenges forwarding from KUC (using browser
plugin) to KS;
 - forwarding requests for file access, i.e. implementation of
filesystem in userspace, with manual access control on sensitive data
exposed to untrusted environment.

@_date: 2015-11-30 21:10:07
@_author: Andrey Utkin 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
Is it impossible straight from RFC 4880 in any defined mode, or is it
just a wrong behaviour in GnuPG/Libgcrypt? Empty passphrases are banned
in several places in this software:
gnupg: agent/protect.c: 1218 (hash_passphrase())
libgcrypt: cipher/kdf.c: 245 (_gcry_kdf_derive())
I haven't learned the RFC yet, so any quick tips are very appreciated.

@_date: 2015-12-01 00:20:46
@_author: Andrey Utkin 
@_subject: [RFC] Keychain for GPG, SSH, X.509 etc. (inspired by Split GPG) 
Thanks for your interest.
Your joke describes one of usage scenarios quite well :)
Let me describe how exactly this is supposed to work when key must be used.
The whole process still looks similar to smartcard key usage, especially
regarding user's action to enable key access operation (PIN entry). So
it is easier to start with looking at using smartcard.
Note: I have no practical experience with actual OpenPGP smartcards and
I'm not convinced with their usability enough to spend couple of
hundreds of bucks or more (with shipping cost) to try them. As far as I
see there is a common problem with reviewing what exactly is being
encrypted/signed. I was told on another forum that this issue is solved
by pinpads with displays, like this one (sorry for russian):
 , but this is what I
otherwise see for "pgp smartcard pinpad":
Why not to make such review and confirmation operation fully
software-defined, overcoming limitations of hardware appliances? This
idea is even more appealing when you consider the accessibility of both
VPSs and handheld devices with great displays? VPS or handhelds are
attackable, but their availability allows user to set up one dedicated
to keys operation, keeping attack surface of key vault minimal.
This is what is wrong with the case of smartcards in my opinion.
In a word:
- costs money ( -> won't be chosen by a lot of people despite the rise
of interest to privacy);
- costs even more money and/or time to get it in far countries (good
stuff is not quite available locally, or is, but for very high price);
- key length limitations on certain hardware solutions (can't say for
all, but I guess that 's true for majority of available hardware);
- hard to use large set of keys.
Let's also look at the case when we use local keys just on a local
machine (as I do now, being unwilling to go with smartcards).
Consider the case that user has just one full-blown workstation at hand,
and needs to use untrustworthy software like browsers and closed-source
apps. The workstation is not powerful enough to jail all untrusted
applications to virtual machines like Qubes OS project proposes. (Even
if it is powerful enough, Qubes OS is far from being production-ready,
and manual AppVM handling without Qubes is pain.) In this case, what is
primarily important is to store keys (and, well, all sensitive data)
anywhere but locally. This looks like the situation with SSH agent
forwarding to untrusted host (regarding that we don't want to store keys
on it), but with the difference that we _start_ on an untrusted machine
and we are not ssh-ed to it from anywhere. So even without confirmation
control, remoting the keys operation is beneficial. And if we add user
confirmation interface, then we eliminate the risk of what you have
described as "Compromised PC opens whole host of SSH connections
purporting to be you".
The confirmation interface can be implemented in any convenient way.
E.g. the confirmation dialog may be raised on a network-enabled
smartphone; keys may be stored on smartphone or on a remote server.
So, my speculations make me think that I want to implement what I have
described in original posting, and that I would want it the same way
even if I used smartcards daily.
I am sorry if all my long posts don't explain a lot to you or don't make
a lot of sense. I raised the discussion here in hope to gather opinions
or get directed towards ready-to-use solutions not known to me before.
Now I see that it probably makes sense to try to implement this schema
in a limited scope, see how it goes, describe it comprehensively (with
mushroom clouds, as requested) and present it here for review.

@_date: 2015-12-01 00:54:06
@_author: Andrey Utkin 
@_subject: Why gpg 2.1.9 cannot export secret key without passphrase? 
Thanks for clarification. I'd be glad to help Werner to fix it if he has
no time.
Could you please direct me to exact S2K-stuff modes for exporting it
which would be compliant with earlier GnuPG branches 1.4 and 2.0? Then I
would have a chance to accomplish the fix in finite time.
Surely these two ways are distinguishable. But for unattended processing
cases, I'd like a mode that makes utils skip all passphrase entry
prompts. I guess the no-encryption case ("trivially cracked by anyone")
is needed here.
Which of the mentioned modes was used in 1.4 and 2.0 for exporting
without passphrase?

@_date: 2016-01-18 22:40:06
@_author: Andrey Utkin 
@_subject: Constant "gpg: keyserver refresh failed: Invalid IPC response" 
This happens all the time with default key server hkp://keys.gnupg.net,
with pgp.mit.edu it's the same, but slightly higher chance to get a
proper result.

@_date: 2016-01-24 00:41:24
@_author: Andrey Utkin 
@_subject: How to export ASCII armored secret key without passphrase? 
In Gentoo this is the case. And it also currently doesn't allow to have
two installation at the same time. There's concept of slots, but nobody
has cared enough to implement different slots for it.

@_date: 2016-01-25 15:17:40
@_author: Andrey Utkin 
@_subject: Master Key Best Practice with SmartCard 
I'd report an issue to encrypt.to maintainer.
encrypt.to also doesn't handle correctly the case when more than one key
matches speceificed short key id, e.g. the shown fingerprint doesn't change when you change selection.

@_date: 2016-01-31 14:20:26
@_author: Andrey Utkin 
@_subject: User experience of --hidden-recipient encryption 
Leakage of exact number of hidden recipients can be mitigated by adding
random number of pseudo-recipients (e.g. generate some more keys on your
localhost and add them to recipients).
