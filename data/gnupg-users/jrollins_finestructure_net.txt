
@_date: 2010-02-24 23:10:58
@_author: Jameson Rollins 
@_subject: Migrating from PGP to GPG question 
Just for clarification, GnuPG is software tool that is actually an
implementation of the OpenPGP specification [0].  OpenPGP is not
actually a piece of software itself, nor is GnuPG a specification.
[0]

@_date: 2010-02-25 10:58:02
@_author: Jameson Rollins 
@_subject: Migrating from PGP to GPG question 
I'm not familiar with OpenPGP, the software.  I'm familiar with the PGP
Corporation's implementation (which I think is just called "PGP"), but
not an implementation called "OpenPGP".  Having trouble finding any
references to anything other than OpenPGP the spec as well.  Would you
mind passing on a link?  Thanks.

@_date: 2010-01-13 10:54:16
@_author: Jameson Rollins 
@_subject: fragility of --edit-key interface [was: Re: Changing trust in GPGME] 
Hello Werner et. al.  My understanding is that one of the main
advantages of GPGME is that it provides a stable API to gnupg
functionality.  I understand that GPGME doesn't yet provide all the
functionality that a user might need, but I think that suggesting
developers use "gpg --edit-key" to achieve their desired functionality
should include a strong warning that the interface to "gpg --edit-key"
is fragile and may change unexpectedly and without warning.
For instance, as of v1.4.10 (and v2.0.13), the edit-key interface to
generate a subkey on an existing key ('addkey') in expert mode changed
such that the "RSA (set your own capabilities)" selection in the key
type chooser moved from entry 7 to entry 8.  As far as I can tell,
this change was not documented, at least not in the any of the
changelogs associated with recent gnupg releases.  The Monkeysphere
project [0] is using this capability and this undocumented change
recently caused problems.
Developers looking for the stable interface that GPGME is supposed to
provide should be duly warned that the "gpg --edit-key" interface is
not as stable, and that they should be on the look out for changes to
that interface in the future.
[0]

@_date: 2010-07-01 06:41:07
@_author: Jameson Rollins 
@_subject: How to sign a remote repository, i.e. forward agent 
Hey, Carsten.  It just occurred to me that maybe you could use sshfs to
accomplish this.  You could mount the needed reprepro directory locally
with sshfs, and then sign the needed files locally without having to
actually move the files around or forward the gnupg agent.  I just tried
signing something over an sshfs mount and it seemed to work fine.
sshfs is fabulous.  hth.

@_date: 2010-06-03 10:58:55
@_author: Jameson Rollins 
@_subject: Crypto Stick released! 
That's strange.  What is the limitation with the bit length and GnuPG in
regards to the Crypto Stick?  Is that something that can be patched, or
is it a limitation of the communication protocol?

@_date: 2010-06-10 11:53:43
@_author: Jameson Rollins 
@_subject: Keyserver spam example 
Not to mention that the bother of a couple of extra spams is completely
dwarfed by the benefit of having the public keyserver network.

@_date: 2010-06-10 12:39:25
@_author: Jameson Rollins 
@_subject: Keyserver spam example 
Speaking of spam, I'm getting more spam from some sort of automated
ticketing system that seems to be subscribed to this list that I ever
have from a keyserver.  The mail seems to come from:
and it often sets the From: to be from someone else.  This is totally
uncool.  Is there a list moderator that can permanently ban anything
From this address from the list?

@_date: 2010-06-11 07:33:23
@_author: Jameson Rollins 
@_subject: Test mail to gnupg.user@seibercom.net 
I think if he had wanted you to respond to it he would have asked you to
respond to it.

@_date: 2010-06-20 14:32:48
@_author: Jameson Rollins 
@_subject: keyserver queries over TLS [was: Re: auto refresh-keys] 
This is turning into a separate thread, but while we're on it, I just
wanted to point out that the Monkeysphere Project [0] currently provides
a means for doing OpenPGP-based site authentication/encryption over TLS,
and has discussed building a gpg plugin that can do OpenPGP validation
of hkps keyserver queries:
[0]

@_date: 2010-06-22 09:51:58
@_author: Jameson Rollins 
@_subject: local signatures: should they be importable by default in some 
I think that is a red herring.  Charlie could also make a myspace page
that talks about what great friends Alice and Bob are.  No one can
forcibly guarantee that all their linkages are kept secret.  Alice has
to ultimately trust Charlie on some level that he won't maliciously make
those linkages public.
I think the situation Daniel points out is one of the better usages for
local signatures, and probably the main reason for having them in the
first place.
But that creates a different trust path than the one Daniel describes.
Just as with exportable signatures, Alice's certification of Bob is
different in Charlie's eyes that Charlie's own certification.  Charlie
wouldn't (or shouldn't) make an exportable signature of someone whose
identity he hasn't verified, so why should he make even a local one?
According to your logic, everyone should just sign the keys of everyone
they wish to have trust paths too, whether they've actually met them or
not, just based on the fact that others they know have signed their
keys, rather than relying on the calculated validity through known trust
The point of the scenario that Daniel is pointing out is that Alice and
Charlie can use OpenPGP to *cryptographically* verify Bob's identity,
without Charlie having to make certifications he otherwise wouldn't

@_date: 2010-06-22 10:13:39
@_author: Jameson Rollins 
@_subject: local signatures: should they be importable by default in some 
Actually, looking at the RFC 4880 now, I see that the original
definition definitely was that local signatures were intended to *only*
be used by the issuer.  From section 5.2.3.11 [0]:
  Non-exportable, or "local", certifications are signatures made by a
  user to mark a key as valid within that user's implementation only.
  Thus, when an implementation prepares a user's copy of a key for
  transport to another user (this is the process of "exporting" the
  key), any local certification signatures are deleted from the key.
  The receiver of a transported key "imports" it, and likewise trims any
  local certifications.
[0]

@_date: 2010-10-15 14:49:41
@_author: Jameson Rollins 
@_subject: Confirmation for cached passphrases useful? 
Without use confirmation in the agent, a malicious program running under
your account could access your secret key without you knowing it.  That
is clear and indisputable.  If there was no worry of this happening,
then there would also be no need to passphrase-protect your secret key.
Since everyone seems to agree that one should passphrase-protect your
secret key, then there are obviously plausible attack vectors here.
I am also strongly in favor of use confirmation in the agent, and I'm
having a hard time understanding the opposition to it.
FWIW, ssh-agent implements use confirmation, so they clearly thought
there were plausible attack vectors as well.

@_date: 2010-10-15 17:04:41
@_author: Jameson Rollins 
@_subject: Confirmation for cached passphrases useful? 
Ok, then this protects against malicious programs that are not
intercepting the dialog box.  Just because a fix for one problem doesn't
solve all possible problems does not mean that it should be ignored.
Don't let the perfect be the enemy of the good.

@_date: 2010-10-15 19:04:28
@_author: Jameson Rollins 
@_subject: Confirmation for cached passphrases useful? 
Do you use ssh-agent?  Do you think their implementation of the same
thing is not good?  If so, have you complained to them about it, or
asked why the implemented it?

@_date: 2010-10-15 19:26:14
@_author: Jameson Rollins 
@_subject: Confirmation for cached passphrases useful? 
I strongly agree with this point.  Let's think about it another way:
what if the user is themselves doing something that is unintentionally
accessing the key?  They might prefer to know about it rather than have
it accessed without their knowledge.  I would say that's good enough
reason to have confirmation right there.

@_date: 2010-10-15 19:29:50
@_author: Jameson Rollins 
@_subject: Confirmation for cached passphrases useful? 
No, I was just curious why, if you were an ssh-agent user, you would be
ok with the implementation there but not for gpg-agent.  If you're not
an ssh-agent user then you have nothing to get defensive about.

@_date: 2010-10-21 23:28:24
@_author: Jameson Rollins 
@_subject: gpgkey2ssh 
Hi, Aaron.  You might be interested in some of the tools that come with
the Monkeysphere [0] package, which deals with a lot of OpenPGP for SSH
stuff.  It comes with the utility openpgp2ssh, which translates OpenPGP
keys to SSH keys (and is well documented).  From openpgp2ssh(1):
     openpgp2ssh < mykey.gpg
     gpg --export $KEYID | openpgp2ssh $KEYID
     gpg --export-secret-key $KEYID | openpgp2ssh $KEYID
Monkeysphere also has a command to import an authentication-capable
OpengPGP subkey directly into an ssh-agent:
$ monkeysphere subkey-to-ssh-agent
It's available in Debian, Ubuntu, and some other distros [1].
[0] [1]

@_date: 2010-09-27 10:55:26
@_author: Jameson Rollins 
@_subject: how slow are 4Kbit RSA keys? [was: Re: multiple keys vs multiple 
I think this is really a UI issue, in which case "real" is what you
really care about.
An operation that takes >1s is annoying if it needs to be done
frequently, but I'm not sure the operations we're talking about here
really ones that are done that frequently.

@_date: 2010-09-27 15:51:10
@_author: Jameson Rollins 
@_subject: how slow are 4Kbit RSA keys? [was: Re: multiple keys vs multiple 
We should be careful not to overstate the impatience of users too much.
I've seen plenty of people wait many seconds for google maps to load on
phones without giving up on the whole process.  I also have an extremely
slow machine were I routinely have to wait a long time (many seconds)
for certain operations to complete.  It's certainly not ideal, but I
don't give up on those operations just because they take a little
longer.  I get used to it and figure out ways to deal.
I'm not saying we shouldn't care about operations taking a noticeable
amount of time, but I wouldn't state out-right that users will revolt
and refuse to do something just because it takes more than a second.

@_date: 2011-08-25 11:22:44
@_author: Jameson Graef Rollins 
@_subject: Signing multiple keys 
This should be very easy to script.  See the following options:
--keyring FILE
and the DETAILS file included with the gpg documentation
(/usr/share/doc/gnupg/DETAILS.gz in Debian).

@_date: 2011-08-25 10:56:53
@_author: Jameson Graef Rollins 
@_subject: Signing multiple keys 
Do you want to sign every key in your keyring?  If so, it's not hard to
get gpg to enumerate all of your keys in a machine-parsable format (see
--with-colons output).  If you just want to sign a subset then you
obviously have to enumerate all the keys yourself, so either of the
above solutions seems pretty easy to me.

@_date: 2011-02-03 14:22:38
@_author: Jameson Rollins 
@_subject: moving user ID Comments to --expert mode 
I have to agree with Daniel that I have in fact honestly never spoken to
anyone who was *not* confused by that field.  I can't ever remember
seeing a comment field used in any way that made sense to me.
I'm not sure I understand this comment.  Certifications are over user
IDs.  The comments are in the user IDs.  By certifying the full user ID
you are also certifying the comment.
I think this is why his original suggestion was to move it instead to
--expert.  Moving it to --expert makes a lot of sense to me.

@_date: 2011-02-03 15:09:42
@_author: Jameson Rollins 
@_subject: moving user ID Comments to --expert mode 
Just out of curiosity, can you explain why you wouldn't sign dkg's
hypothetical user ID?

@_date: 2011-02-24 17:45:03
@_author: Jameson Rollins 
@_subject: PGP/MIME considered harmful for mobile 
Yikes!  I thought we were almost done killing inline signatures!  Don't
revive it now!
If PGP/MIME is broken on android, we need to get them to fix it, not go
backwards to inline pgp.

@_date: 2011-01-15 15:21:01
@_author: Jameson Rollins 
@_subject: What does the "sub" entry of a key mean? 
Hi, Bo.  There should be a file called DETAILS (in doc/DETAILS in the
gnupg source, or maybe included with your local installation) that
describes in detail the meaning of the --with-colons output.  It's
exactly the reference you're looking for when writing a program to parse
the --with-colons output.
Good luck!
$ head gnupg2-2.0.14/doc/DETAILS
                                                              -*- text -*-
Format of colon listings
First an example:
$ gpg --fixed-list-mode --with-colons --list-keys \
   --with-fingerprint --with-fingerprint wk at gnupg.org
$

@_date: 2011-01-30 20:37:21
@_author: Jameson Rollins 
@_subject: How to handle user passphrase input from python script 
You might try using one of the many python gpg interface libraries that
exist out there.  With a cursory look I see three such packages in

@_date: 2011-03-01 11:12:15
@_author: Jameson Rollins 
@_subject: Why do we use a different key to sign than to encrypt 
Hi, Guy.  This prompt is definitely confusing, but yes, options (1) and
(2) create two key pairs, one primary key used for signing and
certifying, and a second subkey used for encryption.  Options (3) and
(4) only create a single primary key used for signing and certifying.
You can create an arbitrary number of subkeys if you'd like.  It's
common to create one for authentication, for instance.

@_date: 2011-11-01 08:41:09
@_author: Jameson Graef Rollins 
@_subject: How can I know all the recipients of a GPG encrypted message 
How do you know it was encrypted to 10 other people?
Since message headers aren't encrypted, you should just be able to look
at the To: or Cc: fields to see the recipients.  Otherwise the message
was at least effectively a Bcc:, in which case I don't think there is
any other way.

@_date: 2012-01-21 16:41:30
@_author: Jameson Graef Rollins 
@_subject: ssh and gnupg 
Hi.  You might also look at the Monkeysphere project, whose goal is to
ease the use of OpenPGP/gnupg for ssh authentication:
