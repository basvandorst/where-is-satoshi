
@_date: 2015-12-10 13:28:34
@_author: Tankred Hase 
@_subject: CORS requests not working in SKS 1.1.5 
Tankred from OpenPGP.js / Whiteout.io here. I?m currently testing HTTP CORS request to SKS via JS in the browser after having read the announcement on v1.1.5 ( Unfortunately I?m getting a 502 (Bad Gateway) response. Upon further analysis I saw that only the following header is set:
The Access-Control-Allow-Origin: *
Tested using: This is indeed a requirement for CORS requests, but not sufficient. Without the following headers, CORS requests from the Browser will fail as an OPTIONS preflight check is required:
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
'Access-Control-Allow-Headers?: Content-Type
You can test how it should look here:  at gmail.com
Would it be possible to add the headers? It would allow me the remove the need for our proprietary key server proxy and send requests directly to SKS server from the web. Thanks!

@_date: 2015-12-11 11:08:11
@_author: Tankred Hase 
@_subject: CORS requests not working in SKS 1.1.5 
It seems I just some connection problems yesterday that caused the 502. Thanks to Daniel Roesler to providing help. I?ve implemented initial HKP support to OpenPGP.js. Comments welcome:

@_date: 2016-03-23 10:20:24
@_author: Tankred Hase 
@_subject: AES-GCM and AEAD Protected Data Packet (IETF draft) 
I?ve implemented initial support for AES-GCM in OpenPGP.js using the IETF draft for authenticated encryption:
I?ve created a pull request on GitHub for the implementation. The specification leaves quite a bit of wiggle room and I?ve listed my thoughts here: I?ve already contacted the specification author to give feedback, but being the most widely adopted OpenPGP implementation out there, I also wanted to get the GnuPG community's thoughts. Making GCM the new standard mode for symmetric encryption would give us a modern and performant alternative to OpenPGP's CFB mode. Especially with regards to the WebCrypto api, where GCM is natively supported, but not CFB (currently marked as a 'WontFix' in the chromium bug tracker):
Together will ECC asymmetric encryption, GCM should give OpenPGP a modern cipher suite supported natively in browsers. This will hopefully also allow the community to deprecate some older crypto down the road. Looking forward to your feedback.
P.S. Just for reference, here are the GitHub issues tracking ECC in OpenPGP.js. We have not started implementing them, but the plan is to move ahead after GCM is merged:

@_date: 2016-03-24 00:04:59
@_author: Tankred Hase 
@_subject: AES-GCM and AEAD Protected Data Packet (IETF draft) 
Hi Werner,
thanks for quick response.
Could you kindly point me to the discussion on the WG list? I?m new to the IETF world. Thanks.
I have no objections against supporting multiple authenticated modes, including OCB. Like I said, the reason I would advocate for GCM is because of its support in the WebCrypto api [1]. Until now, OpenPGP.js has relied on JavaScript implementations of crypto primitives. These are are not only slower, but are also subject to well known side channel attacks. WebCrypto is now widely supported [2] and browsers also offer hardware acceleration for GCM [3].
Several application like Mailvelope and ProtonMail use OpenPGP.js and with the emergence of frameworks like electron and Microsoft?s Universal JS apps on Windows 10, probably more application will in the future.
[1] [2] [3]

@_date: 2016-03-24 08:44:31
@_author: Tankred Hase 
@_subject: AES-GCM and AEAD Protected Data Packet (IETF draft) 
Hi again,
I've done some research concerning patents. It seems OCB is not unencumbered by patents [1][2] while GCM is patent free [3][4]. A least according to Wikipedia and Matthew Green?s blog...
"GCM. Galois Counter Mode has quietly become the most popular AE(AD) mode in the field today, despite the fact that everyone hates it. The popularity is due in part to the fact that GCM is extremely fast, but mostly it's because the mode is patent-free. GCM is 'on-line' and can be parallelized, and (best): recent versions of OpenSSL and Crypto++ provide good implementations, mostly because it's now supported as a TLS ciphersuite. As a side benefit, GCM will occasionally visit your house and fix broken appliances."
Would this change your perception of GCM in regards to GnuPG adoption?
[1] [2] [3] [4]

@_date: 2016-03-24 18:41:14
@_author: Tankred Hase 
@_subject: AES-GCM and AEAD Protected Data Packet (IETF draft) 
Sounds interesting. I might as well join in.
Understood. That makes sense.
My main concern is not the developer experience, but rather the user experience:
# Security
Crypto primitives written in JS are widely considered to be insecure due to timing attack vectors. This is why the WebCrypto api was introduced in the first place. Browsers all ship with TLS stacks like NSS and OpenSSL/BoringSSL that already include primitives like AES-GCM. These are well tested and subject to release process with timely security updates. This means that web developers should not be rolling their own crypto and always use the WebCrypto api provided by browsers.
# Performance
I have done some benchmarks using Chrome's GCM implementation and it's about 30x faster than an optimized JS implementation on my Corei5:
# Platform support
There are good reasons why OFB has not been standardized for TLS. As Matthew Green points out in his post, probably due to patent issues. Even if the patent issues are gone in 5 years, GCM will still have better support in browsers and other runtimes/libraries due to its head start. In 5 years we probably won't care about OFB anyway since we'll all be using a modern primitive like DJB's ChaCha20-Poly1305 (which is already being used in Chrome on mobile devices that don't have hardware acceleration for GCM).
JavaScript in contrast to programming in a native environment like C/C++ simply has certain constraints, which makes us more dependent on the rest of the ecosystem. I understand that GnuPG does not have these constraints. But given that OpenPGP strives to be an interoperable open standard focused on growing its user base, these factors should be considered when choosing a new authenticated mode.

@_date: 2016-03-25 09:08:44
@_author: Tankred Hase 
@_subject: AES-GCM and AEAD Protected Data Packet (IETF draft) 
I'm aware with all the other arguments. Most are not problems of JavaScript. Together with constant time implementations of crypto primitives provided by native apis, programming the rest of the OpenPGP code in a memory safe language has many advantages. The problems are the way some applications choose to package their crypto. Using signed/installed applications and runtimes that enforce a strict Content Security Policy like browser extensions, Chrome Apps (see WhisperSystem's Signal-Desktop app) or Electron, developers can mitigate the web's attack vectors.
Whether we like it or not the fact remains that most users today use webmail. Browser extensions like Mailvelope allow us to go to where the user is.
But you're right this is not a JavaScript only discussion and I don't want to start a JS vs. native discussion.
Thanks. That was a good read indeed.
Just out of interest... Given that you're advocating Curve25519 for OpenPGP in your IETF draft. What do you think about ChaCha20-Poly1305 in regards as an alternative to AES-OCB?
But it is a problem. I love the fact that GnuPG  and OpenPGP.js are free software and they can still be used in proprietary software (at least OpenPGP.js' LGPL allows this).
By adopting OCB we would be ignoring this fact and telling other software vendors to "build free software or get out". It's not our place to make that decision for them, nor will it work. It will simply prevent then from using OCB and build forks of OpenPGP implementations without OFB. Or worse adopt a competing authenticated ciphermode that is incompatible.
For the sake of experimenting and to gain insight on the IETF draft, OpenPGP.js will go ahead and merge the AEAD pull request based on the current AES-GCM proposal. The feature will hidden behind a flag and disabled by default. But it will allow applications that do not require interoperability to opt-in and experiment with the security/performance benefits.
Once there is agreement and a finalized RFC, we will update our implementation accordingly.
I don't buy IV reuse argument to be honest. Users of OpenPGP libraries are shielded from that potential mistake, since a new random IV is generated for them in the AEAD package before package encryption. See the following code:
Is there potential to do this wrong? Of course, but that's exactly why you use engineering best practices like code reviews and security audits for crypto libraries. Without those, there are a million other way to screw up.
Despite our disagreement on the topic, I'm enjoying the exchange and learning a lot. Looking forward to the IETF WG session :)
