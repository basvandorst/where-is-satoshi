
@_date: 2017-06-10 16:48:31
@_author: Kirill Elagin 
@_subject: Overwriting a fingerprint in card-status 
I have a key on a smartcard and at some point I added it as a subkey
to a different primary key by giving its keygrip in `--expert` mode.
This works great but I recently realised that when this was done its
fingerprint changed and as a result a wrong fingerprint is now stored
in the card metadata, as shown by `--card-status`. (Now I am a little
confused by the fact that gnupg is still able to locate the key and
use it.)
Given that the key material on the card is correct, is there a way to
forcibly overwrite the fingerprint that is displayed by

@_date: 2017-06-19 06:30:08
@_author: Kirill Elagin 
@_subject: Creating Unique Fingerprint 
The easiest strategy, of course, is to simply use gpg to generate a key and
check its fingerprint until you get the one you need (see batch mode).
Generation of an RSA 2048 key is taking around a second, so e.g. for your
example  (four bytes fixed) we are talking tens of hours or ones of days.
In case you need something better, you?ll have to get inside the public key
packet. Basically, fingerprint is a hash of the actual public key material
and its creation timestamp, so if you do not care much about creation
timestamps, you can bruteforce _them_, which will be much faster. This way
you might get a timestamp that doesn?t make sense (e.g. in the future) and
some implementations can potentially become upset, so you either accept
that or choose timestamps carefully.
If you don?t need the key to actually work, that is, be able to
encrypt/decrypt, then you can safely brute force its other parameters, such
as p, q and e.
I do not know if there are tools around, but hacking GnuPG code should not
be too difficult.

@_date: 2017-06-19 15:56:47
@_author: Kirill Elagin 
@_subject: Creating Unique Fingerprint 
Google is a pretty great tool for this kind of things.
Here is one of the results I found:
As far as I can tell from the source, it uses the method I suggested,
decreasing timestamp one by one, and it finds a fingerprint that ends in a
given string of bytes. This last part is not exactly what you need, so
you?ll have to adjust the test yourself, but other than that it seems to be
a reasonable ?plug-and-play? solution for your task.
