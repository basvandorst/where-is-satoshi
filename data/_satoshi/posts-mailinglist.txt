-----
Source: All mailinglists
Name: Satoshi Nakamoto
Date: n/a
-----
I've developed a new open source P2P e-cash system called Bitcoin.  It's
completely decentralized, with no central server or trusted parties,
because everything is based on crypto proof instead of trust.  Give it a
try, or take a look at the screenshots and design paper:
Download Bitcoin v0.1 at http://www.bitcoin.org
The root problem with conventional currency is all the trust that's
required to make it work.  The central bank must be trusted not to
debase the currency, but the history of fiat currencies is full of
breaches of that trust.  Banks must be trusted to hold our money and
transfer it electronically, but they lend it out in waves of credit
bubbles with barely a fraction in reserve.  We have to trust them with
our privacy, trust them not to let identity thieves drain our accounts.
Their massive overhead costs make micropayments impossible.
A generation ago, multi-user time-sharing computer systems had a similar
problem.  Before strong encryption, users had to rely on password
protection to secure their files, placing trust in the system
administrator to keep their information private.  Privacy could always
be overridden by the admin based on his judgment call weighing the
principle of privacy against other concerns, or at the behest of his
superiors.  Then strong encryption became available to the masses, and
trust was no longer required.  Data could be secured in a way that was
physically impossible for others to access, no matter for what reason,
no matter how good the excuse, no matter what.
It's time we had the same thing for money.  With e-currency based on
cryptographic proof, without the need to trust a third party middleman,
money can be secure and transactions effortless.
One of the fundamental building blocks for such a system is digital
signatures.  A digital coin contains the public key of its owner.  To
transfer it, the owner signs the coin together with the public key of
the next owner.  Anyone can check the signatures to verify the chain of
ownership.  It works well to secure ownership, but leaves one big
problem unsolved: double-spending.  Any owner could try to re-spend an
already spent coin by signing it again to another owner.  The usual
solution is for a trusted company with a central database to check for
double-spending, but that just gets back to the trust model.  In its
central position, the company can override the users, and the fees
needed to support the company make micropayments impractical.
Bitcoin's solution is to use a peer-to-peer network to check for
double-spending.  In a nutshell, the network works like a distributed
timestamp server, stamping the first transaction to spend a coin.  It
takes advantage of the nature of information being easy to spread but
hard to stifle.  For details on how it works, see the design paper at
The result is a distributed system with no single point of failure.
Users hold the crypto keys to their own money and transact directly with
each other, with the help of the P2P network to check for double-spending.
Bitcoin 0.2 is here!
Download (Windows, and now Linux version available)
New Features
Satoshi Nakamoto
- Multi-processor support for coin generation
- Proxy support for use with TOR
- Fixed some slowdowns in the initial block download
We also have a new forum at
Many thanks to Martti (sirius-m) for all his development work, and to
New Liberty Standard for his help with testing the Linux version.
Announcing the release of Bitcoin, a new open source peer-to-peer
electronic cash system that's completely decentralized, with no central
server or trusted parties.  Users hold the crypto keys to their own
money and transact directly with each other, with the help of the P2P
network to check for double-spending.
Windows NT/2000/XP/Vista.  Open source C++ code is included.
Download: http://www.bitcoin.org
- Unpack the files into a directory
- Run BITCOIN.EXE
- It automatically connects to other nodes
If you can keep a node running that accepts incoming connections, you'll
really be helping the network a lot.  Port 8333 on your firewall needs
to be open to receive incoming connections.
You can get coins by getting someone to send you some, or turn on
Options->Generate Coins to run a node and generate blocks.  I made the
proof-of-work difficulty ridiculously easy to start with, so for a
little while in the beginning a typical PC will be able to generate
coins in just a few hours.  It'll get a lot harder when competition
makes the automatic adjustment drive up the difficulty.  Generated coins
must wait 120 blocks to mature before they can be spent.
There are two ways to send money.  If the recipient is online, you can
enter their IP address and it will connect, get a new public key and
send the transaction with comments.  If the recipient is not online, it
is possible to send to their Bitcoin address, which is a hash of their
public key that they give you.  They'll receive the transaction the next
time they connect and get the block it's in.  This method has the
disadvantage that no comment information is sent, and a bit of privacy
may be lost if the address is used multiple times, but it is a useful
alternative if both users can't be online at the same time or the
recipient can't receive incoming connections.
Total circulation will be 21,000,000 coins.  It'll be distributed to
network nodes when they make blocks, with the amount cut in half every 4
years.
first 4 years: 10,500,000 coins
next 4 years: 5,250,000 coins
next 4 years: 2,625,000 coins
next 4 years: 1,312,500 coins
etc...
When that runs out, the system can support transaction fees if needed.
It's based on open market competition, and there will probably always be
nodes willing to process transactions for free.
Announcing version 0.3 of Bitcoin, the P2P cryptocurrency!  Bitcoin is a
digital currency using cryptography and a distributed network to replace
the need for a trusted central server.  Escape the arbitrary inflation
risk of centrally managed currencies!  Bitcoin's total circulation is
limited to 21 million coins.  The coins are gradually released to the
network's nodes based on the CPU power they contribute, so you can get a
share of them by contributing your idle CPU time.
What's new:
- Command line and JSON-RPC control
- Includes a daemon version without GUI
- Transaction filter tabs
- 20% faster hashing
- Hashmeter performance display
- Mac OS X version (thanks to Laszlo)
- German, Dutch and Italian translations (thanks to DataWraith, Xunie
and Joozero)
Get it at www.bitcoin.org, and read the forum to find out more.
This is a minor release to add some DoS protection.
Changes:
- Added some DoS limits, though it's still far from DoS resistant.
- Removed "safe mode" alerts.
It's similar in that it uses digital signatures for coins, but different
in the approach to privacy and preventing double-spending.  The
recipient of a Bitcoin payment is able to check whether it is the first
spend or not, and second-spends are not accepted.  There isn't an
off-line mode where double-spenders are caught and shamed after the
fact, because that would require participants to have identities.
To protect privacy, key pairs are used only once, with a new one for
every transaction.  The owner of a coin is just whoever has its private key.
Of course, the biggest difference is the lack of a central server.  That
was the Achilles heel of Chaumian systems; when the central company shut
down, so did the currency.
There is a limited supply of money.  Circulation will be 21,000,000
coins.  Transactions only transfer ownership.
Thank you for your questions,
That's do-able.  It can be programmed to follow any set of rules.
I see Bitcoin as a foundation and first step if you want to implement
programmable P2P social currencies like Marc's ideas and others
discussed here.  First you need normal, basic P2P currency working.
Once that is established and proven out, dynamic smart money is an easy
next step.
I love the idea of virtual, non-geographic communities experimenting
with new economic paradigms.
Indeed, it is much like Pekunio in the concept of spraying redundant
copies of every transaction to a number of peers on the network, but the
implementation is not a reputation network like Wizard Rabbit Treasurer.
In fact, Bitcoin does not use reputation at all.  It sees the network
as just a big crowd and doesn't much care who it talks to or who tells
it something, as long as at least one of them relays the information
being broadcast around the network.  It doesn't care because there's no
way to lie to it.  Either you tell it crypto proof of something, or it
ignores you.
As trust systems go, Ripple is unique in spreading trust around rather
than concentrating it.
It would be best to refer to the C++ source code.  I plan to implement
interfaces for using the software to send and receive transactions from
any language, so server side code can easily use it for web based
e-commerce sites.
It's fully operational and the network is growing.  If you try the
software, e-mail me your Bitcoin address and I'll send you a few coins.
We just need to spread the word and keep getting more people interested.
I'll forward the release introduction in the next message.
I have been following the recent development about the block size limit. The initial purpose of block size limit is to limit the bandwidth so that it is easy for people to record the blockchain on their computer rather than on some cloud-based center authorities. In this way, the DOS attack with an enormous fake block can also be prevented. At that time, 1M is a good number to keep the network going and,Â therefore, the experiment.
As Bitcoin grows, the number should grow too. I believe a number suitable for mid-term, perhaps, is around 200M, which is sufficient for a transaction rate much higher than the sum of any current center authority banks.
However, that would cause insane traffic for most people. The Lightning thing is also not a perfect solution, as it made a second level architect, it need more trust and may encourage center authority and Paypal-like companies.
The blockchain is designed so that the whole blockchain is not needed to verify itself. People only need one hash to make sure that the entire blockchain is genuine. So the limit can be removed. Any hard limits thatÂ prevent people fromÂ using Bitcoin as frequently as they want toÂ should not exist. To solve the traffic problem, nodes can exchange theÂ hash stream only and verify it against information provided by full nodes;Â the security of the whole blockchain, scalability, and speed can both be achieved. This can be a temporary solution. Network speed and storage space should be able to increase in the future so that big block is possible for all the clients(even for mobile clients) in time.
In this way, the proof-of-work should always be carefully verified before itÂ startsÂ the receiving process to prevent a DOS attack against the network. Moreover, theÂ router's IP should also be checked to avoid a single user broadcastingÂ an insane number of transactionsÂ (fees may apply in this situation).
I believe thatÂ Bitcoin is not only an experiment anymore. It is a newborn currency. Removing the limit will remove its final barrier. But still, decades are needed. The community needs to be united to bring it along, even though I can't be there anymore.
I have been following the recent block size debates through the mailing list.  I had hoped the debate would resolve and that a fork proposal would achieve widespread consensus.  However with the formal release of Bitcoin XT 0.11A, this looks unlikely to happen, and so I am forced to share my concerns about this very dangerous fork.
The developers of this pretender-Bitcoin claim to be following my original vision, but nothing could be further from the truth.  When I designed Bitcoin, I designed it in such a way as to make future modifications to the consensus rules difficult without near unanimous agreement.  Bitcoin was designed to be protected from the influence of charismatic leaders, even if their name is Gavin Andresen, Barack Obama, or Satoshi Nakamoto.  Nearly everyone has to agree on a change, and they have to do it without being forced or pressured into it.  By doing a fork in this way, these developers are violating the "original vision" they claim to honour.
They use my old writings to make claims about what Bitcoin was supposed to be.  However I acknowledge that a lot has changed since that time, and new knowledge has been gained that contradicts some of my early opinions.  For example I didn't anticipate pooled mining and its effects on the security of the network.  Making Bitcoin a competitive monetary system while also preserving its security properties is not a trivial problem, and we should take more time to come up with a robust solution.  I suspect we need a better incentive for users to run nodes instead of relying solely on altruism.
If two developers can fork Bitcoin and succeed in redefining what "Bitcoin" is, in the face of widespread technical criticism and through the use of populist tactics, then I will have no choice but to declare Bitcoin a failed project.  Bitcoin was meant to be both technically and socially robust.  This present situation has been very disappointing to watch unfold.
Version 0.1.5 is now available.  It includes the fix for the problem
Nicholas had, checking for disk full and changes to try to improve
things that were confusing.
Special thanks to Nicholas and Dustin for all their help and feedback!
Another factor that would mitigate spam if POW tokens have value:
there would be a profit motive for people to set up massive
quantities of fake e-mail accounts to harvest POW tokens from
spam.  They'd essentially be reverse-spamming the spammers with
automated mailboxes that collect their POW and don't read the
message.  The ratio of fake mailboxes to real people could become
too high for spam to be cost effective.
The process has the potential to establish the POW token's value
in the first place, since spammers that don't have a botnet could
buy tokens from harvesters.  While the buying back would
temporarily let more spam through, it would only hasten the
self-defeating cycle leading to too many harvesters exploiting the
spammers.
Interestingly, one of the e-gold systems already has a form of
spam called "dusting".  Spammers send a tiny amount of gold dust
in order to put a spam message in the transaction's comment field.
If the system let users configure the minimum payment they're
willing to receive, or at least the minimum that can have a
message with it, users could set how much they're willing to get
paid to receive spam.
I would be surprised if 10 years from now we're not using
electronic currency in some way, now that we know a way to do it
that won't inevitably get dumbed down when the trusted third party
gets cold feet.
It could get started in a narrow niche like reward points,
donation tokens, currency for a game or micropayments for adult
sites.  Initially it can be used in proof-of-work applications
for services that could almost be free but not quite.
It can already be used for pay-to-send e-mail.  The send dialog is
resizeable and you can enter as long of a message as you like.
It's sent directly when it connects.  The recipient doubleclicks
on the transaction to see the full message.  If someone famous is
getting more e-mail than they can read, but would still like to
have a way for fans to contact them, they could set up Bitcoin and
give out the IP address on their website.  "Send X bitcoins to my
priority hotline at this IP and I'll read the message personally."
Subscription sites that need some extra proof-of-work for their
free trial so it doesn't cannibalize subscriptions could charge
bitcoins for the trial.
It might make sense just to get some in case it catches on.  If
enough people think the same way, that becomes a self fulfilling
prophecy.  Once it gets bootstrapped, there are so many
applications if you could effortlessly pay a few cents to a
website as easily as dropping coins in a vending machine.
Announcing the first release of Bitcoin, a new electronic cash
system that uses a peer-to-peer network to prevent double-spending.
It's completely decentralized with no server or central authority.
Windows only for now.  Open source C++ code is included.
- Unpack the files into a directory
- Run BITCOIN.EXE
- It automatically connects to other nodes
If you can keep a node running that accepts incoming connections,
you'll really be helping the network a lot.  Port 8333 on your
firewall needs to be open to receive incoming connections.
The software is still alpha and experimental.  There's no guarantee
the system's state won't have to be restarted at some point if it
becomes necessary, although I've done everything I can to build in
extensibility and versioning.
You can get coins by getting someone to send you some, or turn on
Options->Generate Coins to run a node and generate blocks.  I made
the proof-of-work difficulty ridiculously easy to start with, so
for a little while in the beginning a typical PC will be able to
generate coins in just a few hours.  It'll get a lot harder when
competition makes the automatic adjustment drive up the difficulty.
Generated coins must wait 120 blocks to mature before they can be
spent.
There are two ways to send money.  If the recipient is online, you
can enter their IP address and it will connect, get a new public
key and send the transaction with comments.  If the recipient is
not online, it is possible to send to their Bitcoin address, which
is a hash of their public key that they give you.  They'll receive
the transaction the next time they connect and get the block it's
in.  This method has the disadvantage that no comment information
is sent, and a bit of privacy may be lost if the address is used
multiple times, but it is a useful alternative if both users can't
be online at the same time or the recipient can't receive incoming
connections.
Total circulation will be 21,000,000 coins.  It'll be distributed
to network nodes when they make blocks, with the amount cut in half
every 4 years.
first 4 years: 10,500,000 coins
next 4 years: 5,250,000 coins
next 4 years: 2,625,000 coins
next 4 years: 1,312,500 coins
etc...
When that runs out, the system can support transaction fees if
needed.  It's based on open market competition, and there will
probably always be nodes willing to process transactions for free.
I mean a node only needs the pending-tx pool for the best branch it
has.  The branch that it currently thinks is the best branch.
That's the branch it'll be trying to make a block out of, which is
all it needs the pool for.
I think I've got the peer networking broadcast mechanism covered.
Each node sends its neighbours an inventory list of hashes of the
new blocks and transactions it has.  The neighbours request the
items they don't have yet.  If the item never comes through after a
timeout, they request it from another neighbour that had it.  Since
all or most of the neighbours should eventually have each item,
even if the coms get fumbled up with one, they can get it from any
of the others, trying one at a time.
The inventory-request-data scheme introduces a little latency, but
it ultimately helps speed more by keeping extra data blocks off the
transmit queues and conserving bandwidth.
I believe I've worked through all those little details over the
last year and a half while coding it, and there were a lot of them.
The functional details are not covered in the paper, but the
sourcecode is coming soon.  I sent you the main files.
(available by request at the moment, full release soon)
Right, it's ECC digital signatures.  A new key pair is used for every
transaction.
It's not pseudonymous in the sense of nyms identifying people, but it
is at least a little pseudonymous in that the next action on a coin
can be identified as being from the owner of that coin.
There is no reliance on identifying anyone.  As you've said, it's
futile and can be trivially defeated with sock puppets.
The credential that establishes someone as real is the ability to
supply CPU power.
Section 11 calculates the worst case under attack.  Typically, 5 or
10 blocks is enough for that.  If you're selling something that
doesn't merit a network-scale attack to steal it, in practice you
could cut it closer.
This is a version 2 problem that I believe can be solved fairly
satisfactorily for most applications.
The race is to spread your transaction on the network first.  Think 6
degrees of freedom -- it spreads exponentially.  It would only take
something like 2 minutes for a transaction to spread widely enough
that a competitor starting late would have little chance of grabbing
very many nodes before the first one is overtaking the whole network.
During those 2 minutes, the merchant's nodes can be watching for a
double-spent transaction.  The double-spender would not be able to
blast his alternate transaction out to the world without the merchant
getting it, so he has to wait before starting.
If the real transaction reaches 90% and the double-spent tx reaches
10%, the double-spender only gets a 10% chance of not paying, and 90%
chance his money gets spent.  For almost any type of goods, that's
not going to be worth it for the scammer.
Information based goods like access to website or downloads are
non-fencible.  Nobody is going to be able to make a living off
stealing access to websites or downloads.  They can go to the file
sharing networks to steal that.  Most instant-access products aren't
going to have a huge incentive to steal.
If a merchant actually has a problem with theft, they can make the
customer wait 2 minutes, or wait for something in e-mail, which many
already do.  If they really want to optimize, and it's a large
download, they could cancel the download in the middle if the
transaction comes back double-spent.  If it's website access,
typically it wouldn't be a big deal to let the customer have access
for 5 minutes and then cut off access if it's rejected.  Many such
sites have a free trial anyway.
I'll try and hurry up and release the sourcecode as soon as possible to serve as a reference to help clear up all these implementation questions.
Only the buyer signs, and there's no blinding.
Identities are not used, and there's no reliance on recourse.  It's all prevention.
No challenges or secret shares.  A basic transaction is just what you see in the figure in section 2.  A signature (of the buyer) satisfying the public key of the previous transaction, and a new public key (of the seller) that must be satisfied to spend it the next time.
Right, if it's equal in length, ties are broken by keeping the earliest one received.
There's no need for reporting of "proof of double spending" like that.  If the same chain contains both spends, then the block is invalid and rejected.
Same if a block didn't have enough proof-of-work.  That block is invalid and rejected.  There's no need to circulate a report about it.  Every node could see that and reject it before relaying it.
If there are two competing chains, each containing a different version of the same transaction, with one trying to give money to one person and the other trying to give the same money to someone else, resolving which of the spends is valid is what the whole proof-of-work chain is about.
We're not "on the lookout" for double spends to sound the alarm and catch the cheater.  We merely adjudicate which one of the spends is valid.  Receivers of transactions must wait a few blocks to make sure that resolution has had time to complete.  Would be cheaters can try and simultaneously double-spend all they want, and all they accomplish is that within a few blocks, one of the spends becomes valid and the others become invalid.  Any later double-spends are immediately rejected once there's already a spend in the main chain.
Even if an earlier spend wasn't in the chain yet, if it was already in all the nodes' pools, then the second spend would be turned away by all those nodes that already have the first spend.
Right.  They also refresh whenever a new transaction comes in, so L pretty much contains everything in A all the time.
It's a Hashcash style SHA-256 proof-of-work (partial pre-image of zero), not a signature.
If you're thinking of it as a CPU-intensive digital signing, then you may be thinking of a race to finish a long operation first and the fastest always winning.
The proof-of-work is a Hashcash style SHA-256 collision finding.  It's a memoryless process where you do millions of hashes a second, with a small chance of finding one each time.  The 3 or 4 fastest nodes' dominance would only be proportional to their share of the total CPU power.  Anyone's chance of finding a solution at any time is proportional to their CPU power.
There will be transaction fees, so nodes will have an incentive to receive and include all the transactions they can.  Nodes will eventually be compensated by transaction fees alone when the total coins created hits the pre-determined ceiling.
Right.
Every transaction is one of these.  Section 9, Combining and Splitting Value.