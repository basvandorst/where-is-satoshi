
@_date: 2012-02-04 15:03:25
@_author: thomasV1@gmx.de 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
Just another question concerning BIP21:
On the wiki, the description of the "message" parameter reads:
"message that shown to the user after scanning the QR code"
I believe that the purpose of this parameter is to contain a description of the  transaction. This has use cases that go beyond QR codes.
If I am right, then I would say that naming it "message" is misleading. In fact, "message" suggests that a message will be sent to someone (the recipient of the funds? a third party?), which is not the case here. That parameter should probably be called "description".

@_date: 2012-01-30 19:07:16
@_author: thomasV1@gmx.de 
@_subject: [Bitcoin-development] BIP 21 (modification BIP 20) 
I too support BIP21 over BIP20. However, I do not understand the "Sending money via private key" feature; in which situation would such a URI be useful?
Also, I posted a proposal in the forum, to extend the URI syntax with signatures. The goal would be to provide a proof of identity of the recipient; genjix told me that it would be more appropriate to post that here.
My proposal is described here: My original forum post is here:

@_date: 2012-01-31 07:54:44
@_author: thomasV1@gmx.de 
@_subject: [Bitcoin-development] BIP 21 (modification BIP 20) 
No. The main idea is to protect the consumer against a malicious seller pretending that he has not been paid. Please read the forum.
The bitcoin address that is used to sign URIs will establish the online reputation of the merchant. If a merchant has received a payment and pretends not to have received it, the signed URI will prove him wrong. In principle it would be possible to use HTTPS signatures for that purpose, but this is not really the way HTTPS is supposed to work, and it has disadvantages:
- HTTPS is not always available; there are other communication channels.
- A website, even a single page, may contain URIs posted by various merchants; we need to distinguish the identity of the merchant from the identity of the website.
- with signed URIs, a Bitcoin client can easily keep track of the signatures for all the payments it made. if we used the HTTPS signature of the webpage as receipts, then users would need to save them manually. To my knowledge, nobody does that.
yes, that too. see my proposal here:

@_date: 2012-07-09 20:29:43
@_author: thomasV1@gmx.de 
@_subject: [Bitcoin-development] Random order for clients page 
I agree with Alan.
I too am happy to see my client listed on bitcoin.org, and I don't mind Bitcoin-Qt being listed first. I have no problem with a "czar" approach if it can solve conflicts.
I believe that it is useful to keep the 'clients' page on bitcoin.org, because it contributes to clarifying the difference between the Bitcoin client and Bitcoin as a protocol/network/ecosystem. It shows that Bitcoin is much more than its original implementation. It is a sign of health.
-------- Original-Nachricht --------

@_date: 2013-11-02 10:44:58
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Thanks for the explanation. Here is how I understand how it works, please correct me if I'm wrong:
The user's computer picks a random number a, the Trezor picks a random number b.
Trezor adds a and b in the secp256k1 group, and this creates a master private key k.
Trezor sends the corresponding master public key K to the computer.
Thus, the computer can check that K was derived from a, without knowing b.
This also allows the computer to check that any bitcoin address derived from K is derived from a, without leaking b. (and reciprocally)
However, it seems to me that this property will work only with bip32 public derivations; if a private derivation is used, don't you need to know k?

@_date: 2013-11-02 11:10:13
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Le 31/10/2013 12:18, slush a ?crit :
even if metadata is only 8 bits ? (that's about 256 hashes)

@_date: 2013-11-03 08:03:54
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Le 03/11/2013 07:41, Timo Hanke a ?crit :
I was just asking a question, in order to understand how this device works, and what are its requirements.
if you think you can help, please explain.

@_date: 2013-11-03 09:39:42
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Le 03/11/2013 08:40, Timo Hanke a ?crit :
I'm not sure how this differs from what I wrote...
However, if this is how it works, then my question remains:
The computer has no proof to know that pubkeys derived through bip32's private derivations are derived from its own entropy...
This verification would only work for public (aka type2) derivations.
.. but maybe Trezor works in a different way? I think an explanation from slush would be needed.
I guess you have to trust Trezor that it derives R from r

@_date: 2013-11-04 12:40:00
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Electrum version 1.9 
Electrum version 1.9 is now released.
This version connects to multiple servers, and it also checks the SSL certificates of servers it knows.
Please note that the BIP32 features are postponed (to version 2.0), due to the discussions about mnemonic seed format.
Here is the changelog:
# Release 1.9
* The client connects to multiple servers in order to retrieve block headers and find the longest chain
* SSL certificate validation (to prevent MITM)
* Deterministic signatures (RFC 6979)
* Menu to create/restore/open wallets
* Create transactions with multiple outputs from CSV (comma separated * New user interface for text mode, named "stdio" (does not use curses)
* Plugins are no longer tied to the qt GUI, they can reach all GUIs
* Proxy bugs have been fixed

@_date: 2013-10-24 19:29:18
@_author: thomasV1@gmx.de 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
I would like to propose a new BIP, that replaces BIP0039.
My initial problem was that BIP0039 is not backward compatible with Electrum. When trying to solve that, I realized that the seed encoding used in Electrum does not help, because it does not contain a version number information. However, BIP0039 suffers the same shortcoming: it does nothing to help a future replacement, it wants to be final. My first recommendation is to allocate a few bits of the mnemonic, in order to encode a "version number" along with the checksum bits.
The second problem is the wallet structure. There are multiple ways to use a BIP32 tree, and each client will certainly handle this differently. For Electrum, it is important to be able to recover an entire wallet from its mnemonic, using no extra information. Thus, the client needs to know which branches of the BIP32 tree are populated by default. This means that the "version number" I mentioned will not only be about the seed encoding, but it should also give some information about the wallet structure, at least in the case of Electrum.
The third problem is the dictionary. I do not like the dictionary proposed in BIP0039, because it contains too many short words, which are bad for memorization (I explained here how I designed the dictionary used by Electrum:  I had some discussions with slush about this, but I do not think it will ever be possible to find a consensus on that topic. BIP0039 also suggests to use localized dictionaries, with non-colliding word lists, but it is not clear how that will be achieved; it seems to be difficult, because languages often have words in common. It looks like a first-come-first-served aproach will be used. For these reasons, I believe that we need a dictionary-independent solution. This will allow developers to use the dictionary they like, and localization will be easy.
I would like to suggest the following solution:
1. Define a target of k bits: this target contains the metadata ("version number"), plus some extra bits for the checksum. For example, with k=16, we can allocate 8 bits for the version number, and 8 bits for checksum.
2. Pick a random number of length n+k bits, where n is the desired entropy of the seed, and k is the number of bits needed for the metadata (checksum, version number)
3. Translate this random number to a mnemonic string, using a dictionary.
4. Compute a hash of the mnemonic string (utf8 encoded).
5. Repeat steps 2, 3 and 4 until the k first bits of the hash are equal to the target defined in 1.
6. Use the final hash as input for bip32 (as the master seed)
This means that we "mine" for the seed, until the desired metadata is obtained in the hash. This "mining" also adds a bit of difficulty to the process of finding a seed (on average, it will require 2^k iterations). The entropy of the final hash is n, the number of unconstrained bits.
This solution makes it possible for developers to define new dictionaries, localized or adapted to a particular need. The resulting mnemonics will always be usable with other clients, even if they do not know the dictionary. I am willing to write a new BIP where this proposal is specified in detail.

@_date: 2013-10-25 11:27:24
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
slush wrote :
I was wrong, and I fully acknowledge it.
My concern was that adding extra information would make the mnemonic longer than 12 words.
In addition, you proposed to allocate these extra bits for a checksum, not for metadata.
However, a checksum does not really add any information, because Electrum checks the existence of a wallet directly from the blockchain.
So, my feeling at that time was that adding extra bits would increase the risks (a longer seed is harder to memorize, increases the probability of mistakes, etc), and did not bring any real benefit.
However, you showed since then how to solve this by using a slightly longer dictionary, and I do like your solution, I find it absolutely In addition, I realize now that metadata (ie a "version number") is crucially needed, for the reasons mentioned in my previous post.
BIP32 gives a lot of freedom to wallet developers: it does not specify which branches of the HD tree shall be used for which purpose.
However, if you want to recover a wallet from its mnemonic (a requirement for Electrum), then you need to know which branches to explore.
In Electrum 1.9 I had to make some choices about branch allocation. However, the decisions that I made are certainly not final, so it is important to be able to change them in the future. Thus, this metadata needs to be added to the mnemonic.
The solution I propose is very different from BIP39, and it does not require to predefine a dictionary.
My proposal is actually somewhat similar to Pieter Wuille's proposal, which I discovered after his recent post.
(  )
No, there are not so many words that are frequent enough.
Overlapping will be an issue, especially if we go for a 4096 words You are right, this encoding is not symmetric.
Bi-directionality has never been a requirement for Electrum. May I ask why you need bi-directionality in Trezor?
(the only reason I can think of is if you want to export a bip32 branch into another wallet, but this would create a very long mnemonic string)
it makes it possible to hash a utf8 string, and to retrieve the metadata from the hash.
Thus we don't need to spend ages arguing about the best choice of a dictionary, and to set it in stone.

@_date: 2013-10-26 17:24:50
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
here is a simple implementation, with some ideas on how to format the

@_date: 2013-10-31 10:13:43
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Indeed, I want to include a version number in the seed phrase because there are
multiple ways to define the tree structure used with BIP32. It is certainly too early
to make final decisions on that, or to achieve a common standard.
Also, I can imagine that bip32 itself might be superseeded in the future.
I understand that encapsulating a version number in the seed phrase might
not be as important for other wallets as it is for Electrum. So it is probably not
necessary to propose another BIP for that. I will simply implement it for Electrum,
and I will try to do it in such a way that other wallets can use the same format.
The other question we might be solving is strenghtening (your proposal). I consider
that this is not a strong requirement for Electrum, because it does not let the user
choose their seed phrase. However, if a few bits of the seed phrase are for metadata, then I guess strenghtening can be part of it. That's another good
reason to have a version number encapsulated in the seed.
I too wonder why the transformation needs to be bidirectional in bip39.
Le 26/10/2013 23:30, Pieter Wuille a ?crit :

@_date: 2014-04-08 15:59:36
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
I would prefer that solution...
Le 08/04/2014 15:53, Pieter Wuille a ?crit :

@_date: 2014-04-09 18:09:06
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
Le 09/04/2014 17:54, Gregory Maxwell a ?crit :
Electrum uses two large indexes:
     address -> utxo
(patricia tree, aka "ultimate blockchain compression", see thread started by Alan Reiner in the bitcointalk forum)
     address -> spent history
The first index is not going to grow larger than what bitcoind already needs to store, because bitcoind will always need to store utxos.
The second index threatens to become large. However, Electrum servers do not keep the full histories, they prune older entries. Without adapting Electrum clients, it would even be possible to keep only one bit per address (to know whether that address has been used or not), and that information is only used to restore wallets from seed, not during normal If the first index (patricia tree) was implemented in bitcoind, that would obviously be a big relief for electrum servers.

@_date: 2014-04-21 10:52:56
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] "bits": Unit of account 
Let me make a sacrilegious proposal: keep using the name "bitcoin", and
shift the decimal point.
There would be a short adaption period, where people will need to talk
about "new bitcoins" and "old bitcoins" in order to disambiguate them.
However, Bitcoin users are techies, so I don't think that the ambiguity
will be a big issue. I don't think lots of people will mistakenly send
1000 times more than the amount they intended.
The name "bitcoin" has a huge advantage over any other proposal, because
it is already established. No marketing is needed.
This kind of renaming has already taken place many times in history,
because the currency was debased. Bitcoin would be the first time it
happens in the other direction.

@_date: 2014-04-24 08:54:23
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 23/04/2014 21:44, Luke-Jr a ?crit :
To clarify:
Electrum plans to have bip32 accounts; Multibit will not, afaik.
I think Pavol just wanted to make an example.

@_date: 2014-04-24 09:42:30
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 24/04/2014 09:10, Pieter Wuille a ?crit :
yes, I saw that.
In particular, bip64 stipulates that the wallet "never mixes coins
across different accounts". This is not what Electrum does currently.
The UI allows you to chose between two modes: activate a single account
(and the wallet will only use UTXOs from that acccount), or activate all
accounts (and spend from all of them simultaneously).
Concerning multisig addresses, I have changed my mind: Electrum will use
parallel BIP32 trees. A wallet will not mix standard and multisig
accounts. I think that is better in terms of UX.
I agree with Mike Hearn's view that wallets with multiple accounts are
probably too difficult to deal with for most users. If a user feels the
need to have different "accounting identities", they will probably
create different wallet files, instead of creating bip32 subwallets.
However, since multiple subwallets have been asked by many users,
Electrum will propose them. But this should not be the default. More
important, multiple accounts should never be required (in my previous
implementation, they were required for multisig, because the wallet was
creating multisig addresses in dedicated multisig accounts)

@_date: 2014-04-24 10:15:18
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 24/04/2014 09:21, Gregory Maxwell a ?crit :
No, Electrum will not be limiting itself in this way. I believe that we
are only at the beginning of exploring the different possibilities
opened by HD wallets. It will probably take years until we have clear
ideas on what users need, what choices they make, and how to organize
everything. Therefore it is too early to take decisions that might limit
future functionality.
I can see that it is very difficult today to find a consensus on wallet
structure between wallet developers. In addition, I changed my mind
several times on these questions, so I guess I will probably need to
change things again in the future.
This is why I decided to include a version number in Electrum seeds. The
version number will be updated everytime the wallet structure changes. I
know many developers do not follow me on this, but that is something I
am quite sure Electrum needs, despite all the other things I am not sure
about :)
I think it is too early to aim for inter-wallet compatibility today. I
guess we should postpone this goal, and move on with software releases.
As Andreas pointed out, we should just make sure that we do not import
an incompatible seed in another wallet, because not recovering all your
bitcoins would be a terrible user experience; the version number built
in the seed will ensure that for Electrum.

@_date: 2014-04-26 12:08:02
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure for P2SH multisig 
Le 26/04/2014 11:43, Mike Hearn a ?crit :
I agree with that.
Perhaps the only thing that needs to be standardized is the order of
public keys in the redeem script: I think they should be sorted, so that
the p2sh address does not depend on the order of pubkeys.

@_date: 2014-04-26 12:36:51
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] BIP32 "wallet structure" in use? Remove 
I totally agree with gmaxwell here. The cost of interoperability is too
high. It would force us to freeze all features, and to require a broad
consensus everytime we want to add something new.
In addition, some partial level of compatibility would probably lead to
users not able to recover all their funds when they enter their seed in
another wallet. That is not acceptable, and should be avoided.
Le 25/04/2014 17:46, Gregory Maxwell a ?crit :

@_date: 2014-01-05 19:43:58
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] BIP proposal: Authenticated prefix trees 
Hello and happy new year to this mailing list!
Thank you Mark for the incredible work you've been doing on this.
I am following this very closely, because it is of primary importance
for Electrum.
I have written a Python-levelDB implementation of this UTXO hashtree,
which is currently being tested, and will be added to Electrum servers.
My implementation follows Alan Reiner's idea to store the tree as items
in a key-value database. I believe that a C++ implementation like yours
will be at least an order of magnitude faster, and I am looking forward to it.
I too believe that BIPs should define interoperability points, but probably
not implementation details. For the UTXO hashtree, this means that a BIP
should at least specify how the root hash is constructed. This might be the
only thing that needs to be specified.
However, I see no pressing issue with writing a BIP; it might be preferable
to implement and test different options first, and learn from that.
Le 20/12/2013 02:47, Mark Friedenbach a ?crit :

@_date: 2014-01-07 07:31:57
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] BIP proposal: Authenticated prefix trees 
Le 07/01/2014 01:21, Mark Friedenbach a ?crit :
You are right. The 256-way branching follows from the fact that
the tree was implemented using a key-value database operating
with byte strings (leveldb). With this implementation constraint,
a different branching would probably be possible but wasteful.
My recent code creates one leaf per unspent, and uses 56-byte
keys built as:
   H(scriptPubKey) + txid + txpos
(This is not pushed yet, it needs cleanup. Previous code created one leaf per address)
Partial prefix queries are possible with database iterators.
I see the advantage of doing that, but this looks really far-fetched..
My understanding is that it would require a complete change in the
way clients and miners work. Could such a change be brought iteratively?

@_date: 2014-01-21 01:00:43
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] BIP0039: Final call 
Hi slush,
Thank you for your new proposal; it seems to be a compromise.
 Biocca:
If the wordlist becomes part of the standard, then we will run into
problems of collisions once users ask for wordlists in every language.
IMO the right approach is to implement checksums that do not depend
on the wordlist (eg the 'brute force' method, Hash(mnemonic||1) mod 2^k == 0 )
this would also allow us to implement sipa's variable stretching proposal.
I understand this is not possible because of the computational
requirements of devices such as trezor.
I am leaning toward considering these devices as a nonstandard case,
instead of enforcing a given wordlist in the standard.
Le 21/01/2014 00:18, slush a ?crit :

@_date: 2014-01-24 17:47:21
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] BIP0039: Final call 
Le 24/01/2014 10:05, Peter Todd a ?crit :
slush, correct me if I'm wrong, but I don't think that's the only reason:
They want to generate a seed by combining entropy from the trezor device and from the user's computer;
In addition, they want the computer to be able to check that the seed actually was derived from the entropy it provided, using only a master public key (the computer does not have access to the seed)
This is why they designed bip39 that way.
I think the new bip39 proposal could be used in Electrum as an option for trezor, but I am reluctant to make it default, because it imposes its own dictionary.

@_date: 2014-06-24 15:24:42
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Plans to separate wallet from core 
Le 24/06/2014 11:44, Wladimir a ?crit :
Thanks for that :)
Note that my goal is to make the Electrum servers as trustless as
possible, and not to rely on some sort of 'reputation'.

@_date: 2014-03-11 16:37:42
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Multisign payment protocol? 
Sorry for not joining the discussion earlier.
I have postponed the release of bip32 features in Electrum due to ongoing discussions with Trezor and bitcoinj developers.
I planned to post a summary in a separate thread, but this info is also relevant for this thread, so I'm posting here.
(sorry if this is a bit offtopic, though)
I plan to create a 2-factor authentication service that uses p2sh addresses in Electrum.
All addresses are derived from the wallet root seed, and should be recoverable from it.
(of course this departs from scenarios where master keys are generated my opinion is that both should be possible)
So, when the user activates 2fa protection, the root private key is deleted from their hard drive, as well as the
master private key of one of the branches used to create p2sh addresses (which is sent to a remote server).
See this (fairly old) description here for more details: Since I still want to be able to generate 1of1 accounts after the 2fa protection is activated,
1of 1 accounts should not be generated directly from the root of the tree.
Thus, an extra level must be inserted in the tree.
For example, 1of1 addresses can be derived as follows:
where n is the account index, and "reserved" is an index that indicates the type of address.
(0 would be reserved for 1of1 addresses)
slush suggested that another layer of derivation would be useful, in order to use wallets
with altcoins on the same seed. This lead to this type of derivation:
where "coin" would be 0 for Bitcoin, and "reserved" would be 0 for 1of1

@_date: 2014-03-16 14:24:43
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Electrum 1.9.8 release 
I am happy to announce the release of Electrum 1.9.8.
This release includes some features initially planned for version 2.0.
Packages are available on  (signed by me)
Binaries for windows and mac will be available in the coming days
RELEASE NOTES
# Release 1.9.8
(This release includes features initially planned for version 2.0)
* Electrum servers were upgraded to version 0.9. The new server stores
   a Patrica tree of all UTXOs, an idea proposed by Alan Reiner in the
   bitcointalk forum. This property allows the client to directly
   request the balance of any address. The new commands are:
      1. getaddressbalance       2. getaddressunspent       3. getutxoaddress  * In addition, two commands for message encryption were added:
      1. encrypt        2. decrypt     The encryption algorithm is ECIES, and code was was borrowed from
     In order to know the public
   key corresponding to a Bitcoin address in your wallet, you can use
   the 'getpubkeys' command. The 'decrypt' command assumes that the
   wallet has the private key corresponding to the public key passed as
   argument.
* The encrypt and decrypt functions are available in the Qt GUI (from
   the menubar, or right click on one of your addresses if you want to
   use its public key).
* Command-line commands that require a connection to the network spawn
   a daemon, that remains connected and handles subsequent
   commands. The daemon terminates itself if it remains unused for more
   than one minute. The purpose of this is to make scripting more
   efficient. For example, a bash script using many electrum commands
   will open only one connection.

@_date: 2014-03-16 15:31:24
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Electrum 1.9.8 release 
thanks for your feedback!
I was not aware that that implementation was flawed.
I will see how I can fix that code and get back to you.
Le 16/03/2014 14:54, Gregory Maxwell a ?crit :

@_date: 2014-03-16 16:48:21
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] Electrum 1.9.8 release 
Thanks again for having a look.
Given these problems, I have decided to remove
the encryption methods from the current release.
I retagged 1.9.8 and updated the packages.
Le 16/03/2014 15:39, Gregory Maxwell a ?crit :

@_date: 2014-03-27 11:57:42
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 27/03/2014 00:37, Andreas Schildbach a ?crit :
I believe you have a good point here: we should not advertise wallets as
compatible if they are not 100% compatible.
One issue that I have is bandwidth: Electrum (and mycelium) cannot
watch as many addresses as they want, because this will create too
much traffic on the servers. (especially when servers send utxo merkle
proofs for each address, which is not the case yet, but is planned)
For this reason Electrum imposes a constraint on the number of virgin
addresses provided to the user. Although the current strategy used by
Electrum can certainly be improved, it will not scale up to having every
client watching thousands of addresses.
This constraint is not so important for bloom-filter clients. So I guess it makes sense for Multibit to provide hundreds, or even thousands of addresses to the user, regardless of how they are used. Such a wallet will
in general not be recoverable in Electrum, unless the user "helps" the
recovery procedure. (or the seed has metadata telling the software that
this is a Multibit wallet). So we have a problem here, if we advertise wallets as compatible.
My opinion, as far as Electrum is concerned, is that merchant accounts
should behave differently from regular user accounts: While merchants
need to generate an unlimited number of receiving addresses, it is also
acceptable for them to have a slightly more complex wallet recovery (for example, the wallet might show an option to "search for more and it might not need to watch "old" addresses anymore)
OTOH, I don't think we can ask regular users to do this, not only because it
adds complexity to the wallet recovery procedure (which makes it scarier),
but also because we want fully automated synchronization between different
instances of a wallet, using only no other source of information than the blockchain.
The first versions of Electrum allowed users to set the "gap limit" in their GUI preferences, but I removed it from GUI after I realized it was a bad
idea (users messed with it and did not understand what happened..)
With bloom filter clients I guess the distinction between these two use is not really necessary, because watching addresses is cheap. So it would be
good to hear what you and Mike think about this problem. If you decide to let
the user create hundreds of unused addresses (and I think it perfectly sense for you), then I guess it would be better for Electrum to give up on
compatibility, rather than running the risk of seeing only a subset of Another option is to handle these seeds as "merchant" accounts.

@_date: 2014-03-27 12:20:57
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 26/03/2014 21:49, Mike Hearn a ?crit :
yes, this was intended to create multisig addresses from the same seed.
cointype was proposed after that.

@_date: 2014-03-27 13:06:34
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 27/03/2014 12:30, Marek Palatinus a ?crit :
Yes, I was planning to increase the number of available unused addresses to 10 or 20 in the bip32 version of Electrum.
Related to this, here is another idea I would like to submit:
Instead of using a "gap limit" (maximal number of consecutive unused addresses), I think we should get rid of the topology, and simply count the number of unused addresses since the beginning of the sequence. Indeed, the topology of the sequence of addresses is of no interest to the user. Users often misinterpret "gap limit" as the "number of unused addresses available", so I think we should just give them what they want :) This is easier to understand, and it makes things more predictable, because the wallet will always display the same number of unused addresses (except when it is waiting for confirmations).

@_date: 2014-03-27 14:30:18
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 27/03/2014 12:39, Mike Hearn a ?crit :
To be honest, I have not carried out a comprehensive examination of server performance. What I can see is that Electrum servers are often slowed down when a wallet with a large number (thousands) of addresses shows up, and this is caused by disk seeks (especially on my slow VPS).
The master branch of electrum-server is also quite wasteful in terms of CPU, because it uses client threads. I have another branch that uses a socket poller, but that branch is not widely deployed yet.
I reckon that I might have been a bit too conservative, in setting the number of unused receiving addresses watched by Electrum clients (until now, the default "gap limit" has always been 5). The reason is that, if I increase that number, then there is no way to go back to a smaller value, because it needs to be compatible with all previously released versions. However, Electrum servers performance has improved over time, so I guess it could safely be raised to 20 (see previous post to slush).
In terms of bandwidth, I am referring to my Android version of Electrum. When it runs on a 3G connection, it sometimes takes up to 1 minute to synchronize (with a wallet that has hundreds of addresses). However, I have not checked if this was caused by addresses or block headers.
Heh, may I suggest 20 in the receive branch?
For the change branch, there is no need to watch a large number of unused addresses, because the wallet should try to fill all the gaps in the sequence of change.
(Electrum does that. It also watches 3 unused addresses at the end of that sequence, in order to cope with possible blockchain reorgs causing gaps. As an extra safety, it also waits for 3 confirmations before using a new change address, which sometimes results in address reuse, but I guess a smarter strategy could avoid that).
well, it depends what we mean by "merchant". I was thinking more of a website running a script, rather than a brick and mortar ice cream seller. :)
Oh, I was not referring to label sync, but only to the synchronization of the list of addresses in the wallet. Label sync is an Electrum plugin that relies on a centralized server. Using a third party server is acceptable in that case, IMO, because you will not lose your coins if the server fails.

@_date: 2014-03-27 14:49:32
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 27/03/2014 13:49, Mike Hearn a ?crit :
Here is what I understand:
2^128 iterations is not brute forcable today, and will not be for the foreseeable future.
An EC pubkey of length n can be forced in approximately 2^(n/2) iterations (see  Thus, Bitcoin pubkeys, which are 256 bits, would require 2^128 iterations. This is why unused addresses (160 bits hash) are better protected than already used ones.
However, people tend to believe that a public key of size n requires 2^n iterations. This belief might have been spread by this popular image:

@_date: 2014-03-27 14:53:35
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Le 27/03/2014 14:44, Pavol Rusnak a ?crit :
I agree with that. I was planning to do the same (no gap)
Note: Maybe we could just look at the first address of each account, instead of the first 10 ?

@_date: 2014-03-27 16:04:31
@_author: Thomas Voegtlin 
@_subject: [Bitcoin-development] New BIP32 structure 
Sorry if I was not clear, but no, I was not proposing that... I propose to count the number of unused addresses in each account, independently.
Here is an explanation with pictures:
Currently, Electrum does this:
x = used address
o = unused address
x x x o o x x x x o o o o o
           ????????? 5 unused addresses at the end (gap limit =5)
      existing gap, size 2
Case 1:
Suppose the user decides to use the 4th address starting from the end:
x x x o o x x x x x o o o o
After 3 confirmations, Electrum will create one extra address:
x x x o o x x x x x o o o o o
                     ????????? 5 final address (one new)
Case 2:
The user, who understands nothing about topology, decides to use the final address:
x x x o o x x x x o o o o x
After 3 confirmations, Electrum will create 5 new addresses:
x x x o o x x x x o o o o x o o o o o
        ????????? 5 new addresses
                  new gap (size 4)
You see that this leads to a number of newly created addresses that depends on the address picked by the user. This is the behaviour that I want to fix. I think it is bad for two reasons: First, because it is unpredictable (I had a user who set his gap limit to 100, and then was systematically using the last address of the list, ending up with a lot of wasted addresses). Second, because the worst case scenario (case 2) creates large gaps, which are less robust to blockchain reorgs than in case 1. A reorg in case 1, where the last tx is cancelled will create no gap. A reorg in case 2 can result in a gap that is larger than the limit (5), if another transaction uses the final addresses. (this is why Electrum has to wait for a few confirmations before adding addresses)
So, what I propose is to always have a constant number of unused addresses in each account, instead of something that depends on the topology. (this number can be 10 or 20, I don't mind, but I guess Mike might prefer 20...)
