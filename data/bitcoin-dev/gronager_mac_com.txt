
@_date: 2012-04-04 10:35:12
@_author: =?iso-8859-1?Q?Michael_Gr=F8nager?= 
@_subject: [Bitcoin-development] Signature Blocks and URI Sign Requests 
Hi Alan,
I am using an approach similar to your proposal in a service I am developing. I have, however, chosen to sign using the following scheme:
1. take sha512 of document (=hash512)
2. take ripemd160 of hash512
3. create 512 bit data structure, where the first 352bits are '0', and the rest is the ripemd160 of our hash512
4. sign it with the key
This procedure prevents an evil site from fooling you to sign a transaction spending your own coins. So bottom like never sign a full sha512 with a key for any other purpose than a transaction. (The above could easily well have been implemented as just truncating the hash512 to 256 bits, feel free to propose the optimal scheme).

@_date: 2012-12-13 10:00:55
@_author: gronager@mac.com 
@_subject: [Bitcoin-development] Zero-length scripts 
Normally I would consider it an error of the parsing script of blockchain (seen that before), however, this seems genuine enough.
the second transaction is the most amusing - it has an output script which is:
OP_HASH256 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f OP_EQUAL
The hash is the most famous bitcoin hash... - so if you can come up with something that, when hashed with sha256 yields the genesisblock hash you can claim one BTC ;)
It is actually very easy to do (!), however, it is a game only for miners, as non_standard transactions are not relayed between standard clients. So now a miner can have a go creating a transaction redeeming this 1BTC.
Perhaps, Eligius creating that block, might be playing a little christmas game :)
Michael Gr?nager
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager at mac.com

@_date: 2012-07-23 11:00:49
@_author: =?iso-8859-1?Q?Michael_Gr=F8nager?= 
@_subject: [Bitcoin-development] Scalability issues 
I would guess that you are running the blockchain download through the tor-proxy - that would give you the times you mention. Further, encrypting your disk (aes stuff) will not help you much either, and encrypting a the storage of a public blockchain seems to me a bit odd ?
I get a full blockchain from scratch in 45 minutes on my laptop, but, I still agree with Gregory that scalability improvements are needed, but the problem is far from critical in the sense outlined here.

@_date: 2012-07-24 10:25:09
@_author: =?iso-8859-1?Q?Michael_Gr=F8nager?= 
@_subject: [Bitcoin-development] Scalability issues 
Hi Steve,
45-90 minutes - note that its numbers from March/April, so a bit longer today, but far, far away from the 12 hours. I am using libcoin and the bitcoind build based on this. Libcoin is based on the Satoshi client, but refactured to use an async concurrency model. I also did a minor tweeks to the db parameters. It has earlier been tested up against Satoshi bitcoin where on some OS'es it performs similarly (at least on some linuxes) and on some faster (e.g. mac). What is your CPU load during a block download ? (both initially/up to the point where verification sets in and after). The initial download is typically disk I/O bound, the verification stage CPU bound, though I lean to believe that even there it is disk I/O bound (at least on my system ~50% CPU load). What should be better in libcoin is the concurrency model. The Satoshi client uses a pure reentrant mutexes model, that is not generally believed to motivate the best coding practice nor performance, you might end up without the concurrency you initially strived for *). As mentioned earlier libcoin uses a pure async concurrency model (and so does libbitcoin btw). I would like to stress again that these numbers will depend largely on the system running the test - I would call my laptop a bit over the average today (MB Pro, 2.66Ghz i7 dual core, 8GBRAM, 512GB SSD). But again 12 hours - I only reach such numbers on some of my VPS'es (linode 1024) that are known for notoriously slow disk I/O. (here I have a few % CPU load during the verification indicating indeed that the disk i/o is the culprit).
*) I like this Dave Butenhof quote: "The biggest of all the big problems with recursive mutexes is that they encourage you to completely lose track of your locking scheme and scope. This is deadly. Evil. It's the "thread eater". You hold locks for the absolutely shortest possible time. Period. Always. If you're calling something with a lock held simply because you don't know it's held, or because you don't know whether the callee needs the mutex, then you're holding it too long. You're aiming a shotgun at your application and pulling the trigger. You presumably started using threads to get concurrency; but you've just PREVENTED concurrency."

@_date: 2012-07-25 11:45:33
@_author: =?iso-8859-1?Q?Michael_Gr=F8nager?= 
@_subject: [Bitcoin-development] Scalability issues 
Hi Steve,
I see dramatic differences in performance on virtual machines vs running directly on the iron. I am not an expert in virtual machines, but it seems to me that they are weak when it comes to disk i/o. And berkeley DB, as used by bitcoin is a sucker for disk i/o. In top I easily hit >1/ in top wa, meaning that the cpu doing the blockchain download is just waiting for the disk all the time.
I would like to do a test keeping database log files in memory. It should not matter for durability of the wallet, as it flushes at each write anyway. As for the blockindex, it will remain consistent, but might be lagging some blocks behind at startup, which shouldn't really matter (except that the same block could end up appearing twice in the block00X files, inelegant, but not really a problem).
Otherwise the system you describe (raid0 over 6 disks) should perform like crazy wrt disk i/o, at least on par with SSD. It is your virtualization I am worried about.
Have a safe trip to down under!

@_date: 2012-03-03 18:08:57
@_author: =?iso-8859-1?Q?Michael_Gr=F8nager?= 
@_subject: [Bitcoin-development] getmemorypool BIP process 
Well, I think what Stefan had in mind was http keep-alive combined with an event system. So similar to the way a web chat application work, just for json-rpc. BitcoinJS already uses this for realtime updating a webwallet. Libcoin is also prepared for this with a quite advanced, non-blocking, http server so I second Stefan that an update function could indeed be of relevance.
Btw - question to Stefan as the JavaScript guru - what do you consider the standard/defacto-standard/right/best-practice way of doing S->C json-rpc, what (javascript) library do you use for this?

@_date: 2012-03-05 15:14:07
@_author: =?iso-8859-1?Q?Michael_Gr=F8nager?= 
@_subject: [Bitcoin-development] Proposal for a new opcode 
Sounds interesting, however, even after a couple of days, I cannot see how you maintain protection against double spend using OP_CHECKEXPSIG. It is not until you redeem the OP_CHECKEXPSIG transaction that you reveal which former transactions that was involved?
I guess I am missing a point here?
Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager at ceptacle.com
Web:

@_date: 2012-03-31 13:16:56
@_author: =?iso-8859-1?Q?Michael_Gr=F8nager?= 
@_subject: [Bitcoin-development] 0.7 merge recommendations/status 
If you are interested, I could push libcoin to bitcoin (e.g. bitcoin/libcoin) and then you could build bitcoind bitcoin-qt on libcoin.
libcoin solved most of the problems you list below. And if you worry about the copyright/license I am also willing to change that to make it fit.
libcoin have no global thread mutexes and and there is no blocking of the main thread due to rpc methods (except for a sendto), further, e.g. a reorganize only locks the main thread for a split second while the final commit is done. The libcoin rpc supports keep_alive and pipelining, runs in its own thread (but can also run in the same thread as the node) and uses async operation. Ipv6 is easy to implement in libcoin as the CAddress/Endpoint class is implemented as a subclass of boost::endpoint, only thing holding back is deciding on an ipv6 format on IRC, and, I then I would really like to reverse the order of the last 12 bytes in the address db (they are opposite to boost).
Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager at ceptacle.com
Web:

@_date: 2012-05-29 10:52:49
@_author: =?iso-8859-1?Q?Michael_Gr=F8nager?= 
@_subject: [Bitcoin-development] Punishing empty blocks? 
Peter, I like the idea of being able to know what fees to expect from different miners (it is like a service description / SLA for their service), but I would prefer a more distributed discovery mechanism for the information on the fees (Spent 10 years on Grid Computing...).
Miners could e.g. include a pointer to a webpage (or even their min fee) in the coinbase (encoded properly, like the "/P2SH/" string for BIP0016). That way clients could look it up them selves or you could create sites accumulating this information from the chain it self.
So something like :
        const char* service_sla = "|
        COINBASE_FLAGS << std::vector(service_sla, service_sla+strlen(service_sla));
The format of the sla.php page should then be specified too - but it could be a json-rpc call returning a json object like (as result):
{     sla_version: "0.1",
    accept_no_fee_tx: false,
    min_fee: 50000,
    big_tx_fee: 10000, // extra fee pr kb
I guess miners could work out a more suitable set of fees...
Seems like this calls for a BIP ?
Michael Gronager, PhD
Director, Ceptacle
Jens Juels Gade 33
2100 Copenhagen E
Mobile: +45 31 45 14 01
E-mail: gronager at ceptacle.com
Web:

@_date: 2013-07-17 10:31:52
@_author: Michael Gronager 
@_subject: [Bitcoin-development] SPV bitcoind? (was: Introducing 
Hi Wendell,
What Peter describes (a hash of the current set of UTXOs as part of the coinbase) is already implemented in libcoin, on which you can easily build both a bitcoind and any client. Libcoin is a library originally based on the satoshi client, and as such it is compatible/replacable with "master". Have a look at github.com/libcoin/libcoin and look in the BlockChain.h/cpp and the MerkleTrie classes then you can see how it works.
What is missing from libcoin is a scheme to bootstrap the hash of UTXOs, there is some stub code for a p2pool like mining scheme ensuring several UTXO hashes every 10 minutes, but I will not have time to finalize it the first few months - anyone are of course welcome to help out ;)

@_date: 2013-07-17 18:26:39
@_author: Michael Gronager 
@_subject: [Bitcoin-development] SPV bitcoind? (was: Introducing 
The 90 minutes is not - the blockchain has grown quite a lot since last year, and as for the 3.5 speed, I havn't tested it since Pieter's ultraprune - libcoin also has something similar to ultraprune, done directly in the sqlite database backend, but I should run a head to head again - could be fun. I would assume, though, that the result would be similar timings.
However, by having a merkle tree hash of all UTXOs they become downloadable in a trusted manner from any other client - something that enables bootstrap in minutes, so the old numbers becomes less relevant in this setting.

@_date: 2013-07-18 09:03:12
@_author: Michael Gronager 
@_subject: [Bitcoin-development] SPV bitcoind? (was: Introducing 
Hi Bazyli,
I actually do my main development on Mac OSX, so it surprises me to hear - I build Xcode projects with libcoin daily on Mac OSX and linux, on Windows it is agreeable more of a fight to build. QT is really not needed, I kept it there for BitcoinQT, that was once part of the tree too, will remove it as the qt part got split out.
Building clean on Mac requires OpenSSL, BDB and Boost - all can be installed using homebrew, also remember to use the latest cmake, and a normal cmake xcode call: cmake -GXcode should do the job. Otherwise pls send me the debug output. A few quick notes for building stuff there:
 - try with coinexplorer, it is the base code I am using - it splits out the wallet from the server, nice if you e.g. want to build a webcoin like server.
 - The wallet parts from bitcoind I don't use personally, so if you have problems with these I need to have a closer look.
Also note that as the first version of libcoin was a direct refactorization of bitcoin, the current one add a lot of different features and handles things quite differently - you can e.g. lookup any unspent output by script (bitcoin address) in milliseconds (nice for web wallets).
Finally: As I mentioned it also compiles on Linux (gcc) - gcc is quite savvy when it comes to templates - I agree that the template stuff from Database.h is quite involved, but as I mentioned before try with coinexplorer.
- I will try to do a from scratch recompilation to see if I experience similar issues...
Also - if you are good at creating frameworks on Mac OSX using cmake, help would be appreciated! I think that libcoin by defaults build using shared libs, this configurable from ccmake using the dynamic library option.

@_date: 2013-07-18 09:16:44
@_author: Michael Gronager 
@_subject: [Bitcoin-development] SPV bitcoind? (was: Introducing 
Hi Bazyli,
Just did a fresh build based on git (Xcode) - had one issue: the paillier and account tests were missing - please comment them out in tests/CMakeLists.txt, then coinexplorer should build nicely.
Note I did a git push as well, so you need to do a git pull first.

@_date: 2013-07-23 10:45:51
@_author: Michael Gronager 
@_subject: [Bitcoin-development] HTTP REST API for bitcoind 
Hi Andreas / Jeff,
Access to the UTXO set can be done using libcoin (see the coinexplorer example), which also has a rest interface. Access to the UTXO set pr address/script requires indexing of all scripts, which was easy in libcoin as the blockchain is stored in a sqlite database. Integrating this in bitcoind would require setting up and maintaining such an index ad hoc.

@_date: 2013-07-23 11:53:07
@_author: Michael Gronager 
@_subject: [Bitcoin-development] HTTP REST API for bitcoind 
The MerkleTrie I have in libcoin is indexed on UTXOs only. However, adding
an extra index for scripts would be pretty easy (half day of coding), or even having the two merged into one index.
The burden imposed on validating nodes for keeping such an index is really minimal. When using the UTXO MerkleTrie I switch off the sqlite index of these and vise versa, so there are hardly any measurable timing difference.
However, the MerkleTrie index is currently re-build on startup (which takes ~30 sec on my laptop), keeping it synced with disk would be optimal and in the long run necessary as even the UTXO set will grow over time.

@_date: 2014-02-19 15:11:51
@_author: Michael Gronager 
@_subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with 
Why introduce a new transaction version for this purpose ? Wouldn't it be more elegant to simply let:
1. the next bitcoin version "prettify" all relayed transactions as deterministic transactions fulfilling the scheme 1-6 effectively blocking any malleability attack? If miners would upgrade then all transactions in blocks would have a deterministic hash. 2. In a version later one could block relay of non deterministic transactions, as well as the acceptance of blocks with non-confirming transactions.
To non-standard conforming clients this "prettify" change of hash would be seen as a constant malleability attack, but given the "prettify" code it is to fix any client into producing only conforming transactions, just by running the transaction through it before broadcast.
There is a possible fork risk in step 2. above - if a majority of miners still havn't upgraded to 1 when 2 is introduced. We could monitor % non conforming transaction in a block and only introduce 2. once that number is sufficiently small for a certain duration - criteria:
* Switch on forcing of unmalleable transactions in blocks when there has been only conforming transactions for 1000 blocks.

@_date: 2014-02-19 21:28:24
@_author: Michael Gronager 
@_subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with 
Twisting your words a bit I read:
* you want to support relay of transactions that can be changed on the fly, but you consider it wrong to modify them.
*  is already not forwarded, but you still find it relevant to support it.
Rational use cases of  will be pretty hard to find given the fact that they can be changed on the fly. We are down to inclusion in blocks by miners for special purposes - or did I miss out something?
I think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.

@_date: 2014-02-20 11:59:22
@_author: Michael Gronager 
@_subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with 
As I see the BIP it is basically stressing that ver 1 transactions are malleable.
It then addresses the need for unmalleable transactions for e.g. spending unconfirmed outputs in a deterministic way (i.e. no 3rd party can sabotage) - this transaction type is defined as ver 3.
A lot of clients today spend unconfirmed outputs (even bitcoin-qt) and as such make an implicit assumption that this is kind of safe, which it is not - it can be intervened and sabotaged through tx malleability.
What I suggested was to ensure that a subclass of version 1 transactions become unmalleable - namely those with sighash=all. Note that only the sender can modify the sighash as it is part of the hash signed. So instead of defining a version 3, we could constrain version 1 txes with sighash=all to have a unmalleable hash. If you e.g. would like to still have a sighash=all type of transaction with malleable features you can simply use that sighash=all today is checked for using sighash&0x1f=sighash_all, so just OR'ing with 0x20 or 0x40 will get you the 'old' feature.
I do however buy the argument of Peter and Gregory that there might exist unpublished transactions out there that does not even conform to the DER rules etc, and as such we cannot forbid them from being mined, nor can we timestamp them and include 'only the old ones'. Hence we cannot change the consensus rule for version 1 transactions - and only changing the relay rules will not provide a certain guarantee.
So, I think the two line argument for the BIP is as follows:
1. We cannot change the consensus rules for version 1 transactions as that might invalidate unpublished non-standard transactions (= voiding peoples money, which is a line we don't want to cross)
2. The prime usecase for unmalleable transactions is being able to spend unconfirmed outputs - this is done today by almost all clients, but it is really broken. Hence a need for a fix asap.
I am all in favor for the BIP, but I expect the realistic timeline for enforced version 3 transactions is roughly one year, which is better than two, but it would have been nice to get it faster...
