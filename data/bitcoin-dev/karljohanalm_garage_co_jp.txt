
@_date: 2017-07-12 10:22:59
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] Updating the Scaling Roadmap 
Bitcoin development differs from Linux kernel development in a number
of obvious ways, such as the fact Bitcoin is being "patched in
flight". The current political situation over Bitcoin development is
also quite different, with scalability being a major concern for a lot
of users, and conflicting views leading to risky technical gambles.
Having *something* like a roadmap that gives the average user some
insights into what exactly is being planned for Bitcoin is very
desirable, arguably even necessary, in particular for the scaling
solutions. Putting deadlines and dates in would of course be highly
irresponsible, as no one can predict how much of their free time
volunteer developers will put into the project in advance (or whether
they will stick around for the next X months or stop being
I think there is necessity for a document that describes the project
intentions for scaling solutions, but I don't think adding dates and
deadlines is appropriate. That may or may not be a roadmap. I imagine
such a document would be updated regularly as appropriate, which means
it may be less of a roadmap than the traditional kind.

@_date: 2017-06-01 11:11:48
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] Block Filter Digest profiling 
I have spent a fair bit of time trying to nail how exactly block
filter digests[1] should be done to optimize bandwidth, space,
resource usage.
The report can be found here: This graph shows bandwidth use of 200 wallets simulated over 5000
blocks:  (black line is "sync once per
block" wallet, yellow is "sync once per 144 blocks" wallet, red is
average across all wallets).
An interesting insight made during the experiments: when allowing
digests to contain multiple blocks, the false positive rate of high
block count digests can be higher than normal, because the probability
of a false positive hit for a given entry in multiple digests,
assuming their sizes differ, is almost completely independent.
The results look rather promising to me, but I would like to hear
comments, in particular on the approach taken, if I made any faulty
assumptions, bad math mistakes, etc.
I am also curious what people consider to be acceptable costs in terms
of bandwidth use and memory (I couldn't find any stats on bandwidth
use of bloom filters). In the profiling, I restricted the field sizes
to 2^27 = 128 MB. I assumed this was appropriate as these fields are
very short lived, and in worst case, a client *could* do the scan and
decode simultaneously, without allocating up the space for the field
at all. For high block count digests (e.g. 1024 blocks), this is
sometimes overfilled. I wonder if 2^28 (256 MB) fields would be at all
acceptable or if an over-filled (high false positive rate) field is
For that matter, I am not entirely sure 1024-block digests are
necessary, but they do come with an average 15 kb/block which is
pretty good.
I also wonder if the serialization approach taken is overkill or not.
It does save some space instead of simply storing "BBBAAAAA" but adds
some complexity that may not be warranted.
[1]

@_date: 2017-06-02 15:00:30
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
Really wish I'd known you were working on this a few weeks ago, but
such is life. Hopefully I can provide some useful feedback.
On Fri, Jun 2, 2017 at 4:01 AM, Olaoluwa Osuntokun via bitcoin-dev
Is it necessary to maintain the index all the way to the beginning of
the chain? When would clients request "really old digests" and why?
I haven't tried the tool yet, and maybe it will answer some of my questions.
On what data were the simulated wallets on actual data based? How did
false positive rates for wallets with lots of items (pubkeys etc) play
out? Is there a maximum number of items for a wallet before it becomes
too bandwidth costly to use digests?
I will definitely try to reproduce my experiments with Golomb-Coded
sets and see what I come up with. It seems like you've got a little
less than half the size of my digests for 1-block digests but I
haven't tried making digests for all blocks (and lots of early blocks
are empty).
On the BIP proposal itself:
In Compact Filter Header Chain, you mention that clients should
download filters from nodes if filter_headers is not identical, and
ban offending nodes. What about temporary forks in the chain? What
about longer forks? In general, I am curious how you will deal with
reorgs and temporary non-consensus related chain splits.
I am also curious if you have considered digests containing multiple
blocks. Retaining a permanent binsearchable record of the entire chain
is obviously too space costly, but keeping the last X blocks as
binsearchable could speed up syncing for clients tremendously, I feel.
It may also be space efficient to ONLY store older digests in chunks
of e.g. 8 blocks. A client syncing up finding a match in an 8-block
chunk would have to grab those 8 blocks, but if it's not recent, that
may be acceptable. It may even be possible to make 4-, 2-, 1-block
digests on demand.
How fast are these to create? Would it make sense to provide digests
on demand in some cases, rather than keeping them around indefinitely?

@_date: 2017-06-05 11:06:32
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
Ahh, so you actually make a separate digest chain with prev hashes and
everything. Once/if committed digests are soft forked in, it seems a
bit overkill but maybe it's worth it. (I was always assuming committed
digests in coinbase would come after people started using this, and
that people could just ask a couple of random peers for the digest
hash and ensure everyone gave the same answer as the hash of the
downloaded digest..).
I noticed an increase in FP hits when using real data sampled from
real scriptPubKeys and such. Address reuse and other weird stuff. See
"lies.h" in github repo for experiments and chainsim.c initial part of
main where wallets get random stuff from the chain.
I created digests for all blocks up until block  and actually
ended up with 5.8 GB, which is 1.1 GB lower than what you have, but
may be worse perf-wise on false positive rates and such.
For comparison, creating the digests above (469805 of them) took
roughly 30 mins on my end, but using the kstats format so probably
higher on an actual node (should get around to profiling that...).

@_date: 2017-06-07 10:11:25
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] User Activated Soft Fork Split Protection 
One thing about BIP148 activation that may be affected by this is the
fact that segwit signalling non-BIP148 miners + BIP148 miners may hold
majority hash power and prevent a chain split. With this SF, that will
no longer be the case, right? Or am I completely confused on the
On Wed, Jun 7, 2017 at 9:56 AM, James Hilliard via bitcoin-dev

@_date: 2017-05-08 11:48:54
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] BIP Proposal: Rate Limiting with server specified 
I am proposing a new feature for rate limiting purposes where nodes
can make and solve arbitrary PoW challenges in return for connection
slots (to be expanded to cover e.g. bloom filters or other DoS risky
The BIP currently includes two proofs of work (sha256 and
cuckoo-cycle) which can be combined (e.g. sha256(cuckoo-cycle) or
sha256(sha256(sha256)), etc).
Link: Feedback welcome.

@_date: 2017-05-09 10:15:25
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] BIP Proposal: Rate Limiting with server specified 
I'm not entirely sure what you mean, but right now you can make an
arbitrary chain of challenges, and the BIP includes methods for
determining an approximate time to solve (nodes will, at the very
least, discard any challenge which will on average take longer time to
solve than the expiration of the challenge itself, for example, i.e.
the "nope too hard" part).
Others mentioned this approach. I haven't given it much thought.
Admittedly it would be an effective way to prevent DoS but it also has
some unwanted side effects that need to be cleared up (e.g. in a
no-gains scenario like the BIP proposes, the node requesting PoW done
doesn't *gain* anything from lying to the node performing the work).

@_date: 2017-05-19 13:09:29
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] BIP Proposal: Rate Limiting with server specified 
Some time has passed since this was initially posted, and I have not
received any negative feedback. If no objections are raised, I would
like to have a BIP number assigned.
On Mon, May 8, 2017 at 11:48 AM, Karl Johan Alm

@_date: 2017-05-23 15:30:01
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
Essentially, if we make a potentially very harmful option easy to
enable for users, we are putting them at risk, so yes, this is about
protecting users of the base Bitcoin Core implementation. Users have,
hopefully, come to appreciate this implementation for the peer
review-based strict development process, and making a hasty decision
due to time constraints (segwit activation expiration) may have
undesirable consequences. Opinions among the regular contributors are
split on the matter, which to me is an indication we should be
cautious and consider all aspects before making a decision on the

@_date: 2017-11-01 12:36:07
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] Mempool optimized fees, etc. (Scaling Bitcoin) 
This is the paper detailing the research behind my talk "Optimizing
fee estimation via the mempool state" (the presentation only covers
part of the paper) at Scaling Stanford (this coming Sunday). Feedback

@_date: 2017-09-13 08:27:36
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] Merkle branch verification & tail-call semantics 
On Wed, Sep 13, 2017 at 4:57 AM, Mark Friedenbach via bitcoin-dev
Sidenote-ish, but I also believe it would be fairly trivial to keep a
per UTXO tally and demand additional fees when trying to respend a
UTXO which was previously "spent" with an invalid op count. I.e. if
you sign off on an input for a tx that you know is bad, the UTXO in
question will be penalized proportionately to the wasted ops when
included in another transaction later. That would probably kill that
DoS attack as the attacker would effectively lose bitcoin every time,
even if it was postponed until they spent the UTXO. The only thing
clients would need to do is to add a fee rate penalty ivar and a
mapping of outpoint to penalty value, probably stored as a separate
.dat file. I think.

@_date: 2018-04-04 15:06:19
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] proposal: extend WIF format for segwit 
I took the liberty of turning this into a BIP proposal -- the
formatted version can be seen here:
  BIP: XXX
  Layer: Applications
  Title: Typed Private Keys
  Author: Karl-Johan Alm   Comments-Summary: No comments yet.
  Comments-URI:   Status: Draft
  Type: Standards Track
  Created: 2018-04-04
  License: CC0-1.0
== Abstract ==
An extension to the private key (WIF) format to specify what kind of
public key the private key corresponds to.
== Motivation ==
There are several types of public keys which can all be associated
with a given private key: P2PKH (legacy 1... format),
P2SH-P2WPKH (SegWit public key inside P2SH), P2WPKH (bech32), etc.
While private keys have a 1-byte suffix indicating whether the
corresponding public key is compressed (0x01) or not
(0x00), there is no way of knowing what kind of public
keys were associated with the private key. As a result, when importing
a private key, the wallet has to assume all kinds, and keep track of
each possible alternative.
By extending the suffix, we can specify what kind of public key was
associated with the given private key.
== Specification ==
Currently, private keys are stored as a uint256 (private key data)
followed by a uint8 (compressed flag). The latter is extended to
specify the public key types:
{|class="wikitable" style="text-align: center;"
key. Unknown public key format
key. Unknown public key format
public key format (1...)
in BIP16 P2SH
When a wallet imports a private key, it will have two outcomes:
* the key is using one of the legacy types, in which case all types
must be accounted for
* the key is using one of the extended types, in which case the wallet
need only track the specific corresponding public key
== Rationale ==
== Compatibility ==
This proposal is not backwards compatible, in that software that does
not recognize the new types will not understand the compressed flag.
It would be trivial to change this, by keeping the 'uncompressed'
state as it is (0) and changing 'compressed' to be 'anything not 0',
as opposed to 'the value 1'.
The proposal *is* backwards compatible in that new wallet software
will always understand the old WIF format, however. It will, as it
does today, assume that any kind of public key is possible, and will
have to track all of them, as it has to today.
== Acknowledgements ==
This BIP is based on the initial proposal by Thomas Voegtlin
 on the Bitcoin Dev mailing
and the Electrum 3.0
== Reference implementation ==
There is a partial implementation which adds, but does not use, the
types described in this BIP here:
== References ==
== Copyright ==
This document is licensed under the Creative Commons CC0 1.0 Universal license.
On Mon, Sep 18, 2017 at 12:36 AM, Mark Friedenbach via bitcoin-dev

@_date: 2018-04-10 11:54:08
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] proposal: extend WIF format for segwit 
I made slight modification to the BIP, dropping the 0x80 jump to 0x10:
I will make the corresponding changes to the reference implementation shortly.
If there are no objections I would also like to request a BIP number.
On Wed, Apr 4, 2018 at 3:06 PM, Karl Johan Alm

@_date: 2018-04-11 14:21:10
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Few questions regarding ListTransaction 
It is trusted if (1) it is final (i.e. it can't be replaced), (2) it
is not in a block that was reorged out (negative confirmation count),
(3) the 'spend zero conf change' option is set, (4) it is in the
mempool, and (5) all inputs are from us.
A transaction is conflicted if a different transaction exists that
spends the same inputs. A transaction gets -N confirmations if it is
mined in a block, and that block is orphaned away, and a different
transaction is mined in the new block so that the transaction becomes
a double spend.

@_date: 2018-04-11 14:22:42
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Few questions regarding ListTransaction 
Clarification on one part below:
On Wed, Apr 11, 2018 at 2:21 PM, Karl-Johan Alm
"can't be replaced" here means it cannot be replaced through
conventional means. It is always possible to replace a transaction
that has not yet been confirmed, e.g. by asking a miner to mine a
conflicting transaction directly.

@_date: 2018-04-11 17:10:43
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Few questions regarding ListTransaction 
I was of the impression that final transactions (sequence=0xffffffff)
cannot be RBF'd.

@_date: 2018-06-05 13:33:06
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
I don't understand this comment. The bandwidth gains are not from
address reuse, they are from the observed property that false
positives are independent between two filters. I.e. clients that
connect once a day will probably download 2-3 filters at most, if they
had nothing relevant in the last ~144 blocks.

@_date: 2018-03-14 04:09:20
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
I am considering writing a replacement for the message signing tools
that are currently broken for all but the legacy 1xx addresses. The
approach (suggested by Pieter Wuille) is to do a script based
approach. This does not seem to require a lot of effort for
implementing in Bitcoin Core*. Below is my proposal for this system:
A new structure SignatureProof is added, which is a simple scriptSig &
witnessProgram container that can be serialized. This is passed out
from/into the signer/verifier.
RPC commands:
sign   [=false]
Generates a signature proof for  using the same method that
would be used to spend coins sent to .**
verify    [=false]
Deserializes and executes the proof using a custom signature checker
whose sighash is derived from . Returns true if the check
succeeds, and false otherwise. The scriptPubKey is derived directly
from .**
Feedback welcome.
(*) Looks like you can simply use VerifyScript with a new signature
checker class. (h/t Nicolas Dorier)
(**) If  is true,  is the sighash, otherwise

@_date: 2018-03-14 23:01:03
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
I'm not sure I see the problem. The scriptPubKey is derived directly
from the address in all cases, which means the unknown witness version
would have to be committed to in the address itself.
So yeah, I can make a P2SH address with a witness version > 0 and a to
me unknown pubkey and then fool you into thinking I own it, but I
don't really see why you'd ultimately care. In other words, if I can
SPEND funds sent to that address today, I can prove that I can spend
today, which is the purpose of the tool, I think.
For the case where the witness version HAS been upgraded, the above
still applies, but I'm not sure it's a big issue. And it doesn't
really require an old node. I just need to set witness version >
current witness version and the problem applies to all nodes.
All right.
I assume by inputs you mean addresses/keys. The address field could
optionally be an array. That'd be enough?
I'd love to not have to reveal the public key, but I'm not sure how it
would be done, even with MAST.
That seems sensible to me. A warning would probably be useful, in case
the verifier is running old software.

@_date: 2018-03-15 07:25:21
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
Good question.. Since you don't really have the input(s), I think it's
fine to always assume sufficient time/height on CLTV/CSV checks.
I think it would just use the default (SIGHASH_ALL?) for simplicity.
Is there a good reason to tweak it?

@_date: 2018-03-15 07:36:48
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
Re-reading this, I think what you mean is it should be possible to
create a proof for (a) specific UTXO(s), hence "inputs". That sounds
pretty useful, yeah!
So you could provide a mix of addresses and inputs (as txid:vout) and
it would generate a proof that signs the message for each input
(taking scriptPubKey from address or from the UTXO data directly on
the blockchain).

@_date: 2018-03-16 00:38:06
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
By saying "not necessarily specific UTXOs", are you saying it may be
spent outputs? I'm a little confused I think.
Good point!
I think the sighash flag affects the outcome of the actual
verification, but I could be mistaken.

@_date: 2018-03-16 02:04:51
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
You'd basically have to provide an entire transaction rather than just
the signature, so there's some overhead. (Copy-pasting may become
unwieldy quicker.)

@_date: 2018-03-27 17:09:41
@_author: Karl Johan Alm 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
Thanks for the feedback. Comments below:
I think the double verify approach seems promising. I assume old nodes
consider new consensus rule enforcing transactions as non-standard but
valid. If this is always the case, it may be an idea to simply fail
verification with a message indicating the node is unable to verify
due to unknown consensus rules.
Yes, I initially thought it would be better to not use it as the
legacy behavior could be depended on god knows where, but I think
adding a legacy mode or simply doing the old way for 1xx is
Eek.. good point...

@_date: 2018-05-18 15:28:39
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
There is also the idea of multi-block filters. The idea is that light
clients would download a pair of filters for blocks X..X+255 and
X+256..X+511, check if they have any matches and then grab pairs for
any that matched, e.g. X..X+127 & X+128..X+255 if left matched, and
iterate down until it ran out of hits-in-a-row or it got down to
single-block level.
This has an added benefit where you can accept a slightly higher false
positive rate for bigger ranges, because the probability of a specific
entry having a false positive in each filter is (empirically speaking)
independent. I.e. with a FP probability of 1% in the 256 range block
and a FP probability of 0.1% in the 128 range block would mean the
probability is actually 0.001%.
Wrote about this here:  (but the filter
type is different in my experiments)

@_date: 2018-09-05 12:00:39
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Testnet3 Reest 
On Fri, Aug 31, 2018 at 9:43 PM Gregory Maxwell via bitcoin-dev
I am currently working on an implementation that simply puts a global
mapping of block hash to signature that is transparently
(de)serialized in the block header.
We were looking into various ways to stuff the signature into the
actual header itself without changing its size, but this looked like
it required truncating the prevblock/merkleroots and such, which
seemed a bit too invasive.
I don't think my approach with a global mapping to sig differs in any
meaningful way from your suggested union, but corrections welcome.
The code is here: I believe jtimon is interested in helping out, and Jeremy Rubin has
also said he wants to help.

@_date: 2018-09-11 13:41:57
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] RFC: BIP 322: Generic Signed Message Format 
[note: BIP number was assigned to PR before this email was sent; I did
not self-assign the BIP number]
Below is a proposal to extend the existing sign/verifymessage format
to a more generalized variant relying on the script verification
mechanism in Bitcoin itself for message signing/verification, based on
the original discussion
PR is here: A formatted version of this text can be seen here:
Note: I am not sure how to best deal with CLTV/CSV stuff here, ultimately.
Note 2: I have received suggestions from several people to use a
Bitcoin transaction instead. If someone could explain why this is
beneficial, it would be very helpful. I'm not against it, just feels
like the whole transaction part is unnecessary complexity/overhead.
  BIP: 322
  Layer: Applications
  Title: Generic Signed Message Format
  Author: Karl-Johan Alm   Comments-Summary: No comments yet.
  Comments-URI:   Status: Draft
  Type: Standards Track
  Created: 2018-09-10
  License: CC0-1.0
== Abstract ==
A standard for interoperable generic signed messages based on the
Bitcoin Script format.
== Motivation ==
The current message signing standard only works for P2PKH (1...)
addresses. By extending it to use a Bitcoin Script based approach, it
could be made more generic without causing a too big burden on
implementers, who most likely have access to Bitcoin Script
interpreters already.
== Specification ==
A new structure SignatureProof is added, which is a
simple serializable scriptSig & witnessProgram container.
Two actions "Sign" and "Verify" are defined.
=== SignatureProof container ===
{|class="wikitable" style="text-align: center;"
excluding NUL termination
multiple proofs? In particular with proof of funds, it is
non-trivial to check a large number of individual proofs (one per
UTXO) for duplicates. Software could be written to do so, but it seems
more efficient to build this check into the specification
The above is followed by [entries] number of signature entries:
{|class="wikitable" style="text-align: center;"
In some cases, the scriptsig may be empty (scriptsiglen=0).
=== Signing ===
The "Sign" action takes as input a scriptPubKey and a message (e.g.
"hello world"). It succeeds or fails.
# FAIL if scriptPubKey already exists in scriptPubKeys set, otherwise
insert itWhy track duplicates? Because a 3-entry
proof is not proving 3 scriptPubKeys unless they are all distinct, or
unless they are proving different UTXO:s (see Future Extensions)
# Derive the private key privkey for the scriptPubKey, or FAIL
# Define the message pre-image as the sequence "Bitcoin Message:"
concatenated with the message, encoded in UTF-8 using Normalization
Form Compatibility Decomposition (NFKD)
# Let sighash = sha256(sha256(scriptPubKey || pre-image))
# Generate a signature sig with privkey=privkey, sighash=sighash
Repeat the above operation for each scriptPubKey, retaining the
scriptPubKeys set. As noted, if the same scriptPubKey appears more
than once, the sign operation must fail.
=== Verifying ===
The "Verify" action takes as input a standard flags value, a
scriptPubKey, a message, a script sig, and a witness program.
It emits one of INCONCLUSIVE, VALID, INVALID, or ERROR.
# Return ERROR if scriptPubKey already exists in scriptPubKeys set,
otherwise insert it
# If one or more of the standard flags are unknown, return INCONCLUSIVE
# Define the message pre-image as the sequence "Bitcoin Message:"
concatenated with the message, encoded in UTF-8 using Normalization
Form Compatibility Decomposition (NFKD).
# Let sighash = sha256(sha256(scriptPubKey || pre-image))
# Verify Script with flags=standard flags, scriptSig=script sig,
scriptPubKey=scriptPubKey, witness=witness program, and
# Return VALID if verify succeeds, otherwise return INVALID
Repeat the above operation for each scriptPubKey, retaining the
scriptPubKeys set. As noted, if the same scriptPubKey appears more
than once, the verify operation must fail with an ERROR.
* If a verification call returns ERROR or INVALID, return ERROR or
INVALID immediately, ignoring as yet unverified entries.
* After all verifications complete, return INCONCLUSIVE if any
verification call returned INCONCLUSIVE.
* Return VALID if and only if every verification returned VALID.
== Future Extensions ==
=== Proof of Funds ===
The specification can be extended to handle proof of funds in the
following manner:
* Let the message be prefixed with "POF:", followed by a
newline-terminated stringWhy not just the UTXO
data? We want the verifier to be able to challenge the prover
with a custom message to sign, or anyone can reuse the POF proof for a
set of UTXO:s once they have seen it, and the funds have not yet been
spent, followed by [entries] series of hex-encoded transaction
ID:vout pairs, separated by a single space (" ") character
* Fail if the number of txid:vout pairs is not exactly equal to [entries]
* Retain the message as is for all sighash operations (i.e. all sign
and verify operations should sign and verify the entire list of
UTXO:s)Why use same sighash? The prover is
proving that they have a set of UTXO:s at their disposal. Taking a
sub-set of the proofs and turning them into a new proof should not be
* Add a verification that the txid/vout is a valid UTXO according to a
synced up Bitcoin node, and that its corresponding scriptPubKey
matches the one given by the proof. Return ERROR if scriptPubKey
mismatch, and SPENT error if spent
* Extend the scriptPubKeys set check to only fail if the same
scriptPubKey and proof-of-funds txid/vout combination is encountered
== Compatibility ==
This specification is not backwards compatible with the legacy
signmessage/verifymessage specification. However, legacy addresses
(1...) may be used in this implementation without any problems.
== Rationale ==
== Reference implementation ==
To do.
== Acknowledgements ==
== References ==
# Original mailing list thread:
== Copyright ==
This document is licensed under the Creative Commons CC0 1.0 Universal license.

@_date: 2018-09-12 15:13:56
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale 
A potential problem is that it would be a new attack vector to simply
color something to appear as e.g. 10x more than it really is, if
everyone started using this system.
On Sun, Aug 19, 2018 at 5:27 AM Martin Damgaard via bitcoin-dev

@_date: 2018-09-12 16:56:25
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] RFC: BIP 322: Generic Signed Message Format 
(The quoted proposal is already outdated, and I recommend you check
out the up to date formatted version here:
The PR with comments is here: A big part of the feedback boils down to conflicts of opinion related
to whether or not proofs should be given as transactions or not.
I am attempting to write down the pros and cons below, some of which
are contradictory/complementary based on multiple people's opinions.
Pros of using transaction format:
1. works out of the box with existing HSM:s, some of which may be
purposefully built to not be upgradable for security reasons (unless
sighash modified; see below)
2. easier to incorporate into existing software
3. forward compatible with bitcoin extensions (e.g. mimblewimble,
confidential transactions, etc)
4. HSM:s *should* be blind to whether or not a transaction or a
message or proof of funds is being signed (see Con 1. dangerous if challenger is able to convince prover to sign a
message that corresponds to an actual transaction; modifying sighash
is suggested, but defeats pro  above; can define in tx to have txin
as sighash to guarantee invalid on chain
2. unupgraded software are unable to make distinction between message
sign and transaction sign
3. if HSM:s do not support it and do not support upgrading, this is by
design, and message signing should be explicitly supported or not be
possible (see Pro 4. severely cripples UX for hardware wallets that actually show the
contents of the transaction during the signing
If anyone has comments on this, it would be tremendously appreciated.
There is also a divided opinion on whether an "OP_MESSAGEONLY" opcode
should be introduced, but I'd like to address the above first, if
On Tue, Sep 11, 2018 at 1:41 PM Karl-Johan Alm

@_date: 2019-08-11 15:08:48
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] 32-byte public keys in Schnorr and Taproot 
It makes no sense to me to not switch to 32-byte keys. There are
literally no (or very mild) disadvantages to this, from what it
appears like. I don't think refraining from updating a proposal just
because it's been out there for awhile is a valid reason, personally.
On Sat, Aug 10, 2019 at 3:17 AM Pieter Wuille via bitcoin-dev

@_date: 2019-07-17 16:44:13
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] BIP: Signet 
I have written a BIP describing the Signet network. Feedback requested!
Pasted in its entirety below, with formatting issues left as is. See
above link for styled version.
BIP: XXXX
Layer: Applications
Title: Signet
Author: Karl-Johan Alm Comments-Summary: No comments yet.
Comments-URI: Status: Draft
Type: Standards Track
Created: 2019-03-20
License: CC0-1.0
== Abstract ==
A new type of test network where signatures are used in addition to
proof of work for block progress, enabling much better coordination
and robustness (be reliably unreliable), for persistent, longer-term
testing scenarios involving multiple independent parties.
== Motivation ==
Testnet is a great place to try out new things without risking real
money, but it is notoriously unreliable. Huge block reorgs, long gaps
in between blocks being mined or sudden bursts of blocks in rapid
succession mean that realistic testing of software, especially
involving multiple independent parties running software over an
extended period of time, becomes infeasible in practice.
A new type of test network would be more suitable for integration
testing by organizations such as exchanges, or testing of next
generation Layer-2 protocols like Eltoo or sidechain pegs. The goal is
not to be perfectly reliable but rather to have a predictable amount
of unreliability. You want a test network to behave like mainnet (i.e.
no thousands of block reorgs) while also making it easier to trigger
expected but rare events like a 6-block reorg. Regtest is not suitable
for longer-term scenarios involving multiple independent parties
because creating blocks costs nothing, so any party can completely
control the test network.
== Specification ==
A new type of network ("signet"), which takes an additional consensus
parameter called the challenge (scriptPubKey). The challenge can be a
simple pubkey (P2PKH style), or a k-of-n multisig, or any other script
you would want.
The witness commitment of the coinbase transaction is extended to
include a secondary commitment (the signature/solution):
1-4 bytes - Push the following (x + 4) bytes
4 bytes - Signet header (0xecc7daa2)
x bytes - Solution (sigScript)
Any push operations that do not start with the 4 byte signet header
are ignored. Multiple push operations with the 4 byte signet header
are ignored except for the first entry.
Any signature operations contained within the challenge use
SHA256d(modifiedBlockHash), i.e. the double-SHA256 digest of the
following data as the sighash:
{|class="wikitable" style="text-align: center;"
The modifiedMerkleRoot hash is obtained by generating the
merkle root of the block transactions, with the coinbase witness
commitment as is, without the signet extension. This means the merkle
root of the block is different from the merkle root in the signet
commitment, but in return, the block nonce value is the only component
that the signet signature does not commit to. When grinding proof of
work, the extended nonce cannot be used as it would invalidate the
signature. Instead, simply resigning the same (or an updated) block
will give a new search space.
A block is considered fully validated if the above commitment is
found, and its solution is valid. This verification should be done
directly before or after the witness commitment verification.
== Compatibility ==
This specification is backwards compatible in the sense that existing
software can use Signet out of the box.
Simply by adding the network parameters for signet (magic number,
etc), a client can connect to and use any signet network without
further modifications. The block headers have valid proof of work, so
clients can trivially check that blocks are "probably" valid.
However, anyone can mine blocks that are accepted by the client for
any given signet network. These blocks do not contain the required
signatures, however, so any fully validating node will promptly reject
them. As such, clients need to either validate the block signature
inside the coinbase transaction, or connect to trusted peers.
Other software need not add block signature validation code that they
will not use in production. This is adequate for non-production test
purposes where the goal is to have a network behave as much like
mainnet as possible.
== Reference implementation ==
WIP implementation at == Acknowledgements ==
== References ==
# Original mailing list thread:
# Bitcoin Wiki entry: == Copyright ==
This document is licensed under the Creative Commons CC0 1.0 Universal license.

@_date: 2019-07-24 00:09:02
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Absent authors and BIP updates 
People come in as Bitcoin developers all the time, but sometimes
people also leave permanently. In the case of BIP authors, when a user
leaves and does not respond to (reasonable) requests to change their
BIPs, we are sort of stuck right now.
BIP-2 states that anyone is allowed to request a change of a
draft/proposed BIP to "rejected" status after 3 years of inactivity,
but sometimes BIPs are accepted, after which the author leaves.
See e.g. There are a couple of ways to address this:
1. We allow anyone to request a change of a draft/proposed BIP to
"accepted", at any time. It is upon the requester to prove within
reason that the BIP does fulfill the criteria as given in BIP-2. Such
a request does not need the approval of the BIP author.
2. We allow BIPs to expire after 3 years, and allow the BIP repository
maintainer to assign a new champion, once/if such a champion appeared.
3. We do neither, and when such is warranted, we make new BIPs with
new assignations which supercede the old BIP, sort of like how BIP 2
supercedes BIP 1. Without the author to sign off on the change though,
it may not be obvious enough since we can't modify the original BIP.
4. Other approach / fine as it is.

@_date: 2019-03-08 14:54:46
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Signet 
As some of you already know, I've been working on a network called
"signet", which is bascially a complement to the already existing testnet,
except it is completely centralized, and blocks are signed by a specific
key rather than using proof of work.
Benefits of this:
1. It is more predictable than testnet. Miners appear and disappear
regularly, causing irregular block generation.
2. Since it is centrally controlled, it is easy to perform global testing,
such as reorgs (e.g. the network performs a 4 block reorg by request, or as
3. It is more stable than testnet, which occasionally sees several thousand
block reorgs.
4. It is trivial to spin up (and shut down) new signets to make public
tests where anyone can participate.
Anyone can create a signet at any time, simply by creating a key pair and
creating a challenge (scriptPubKey). The network can then be used globally
by anyone, assuming the creator sends some coins to the other participants.
Having a persistent signet would be beneficial in particular to services
which need a stable place to test features over an extended period of time.
My own company implements protocols on top of Bitcoin with sidechains. We
need multi-node test frameworks to behave in a predictable manner (unlike
testnet) and with the same standardness relay policy as mainnet.
Signets consist of 2 parameters: the challenge script (scriptPubKey) and
the solution length. (The latter is needed to retain fixed length block
headers, despite having an additional payload.)
I propose that a default persistent "signet1" is created, which can be
replaced in future versions e.g. if the coins are unwisely used as real
money, similarly to what happened to previous testnets. This signet is
picked by default if a user includes -signet without providing any of the
parameters mentioned above. The key holder would be someone sufficiently
trusted in the community, who would be willing to run the system (block
generation code, faucet, etc). It could be made a little more sturdy by
using 1-of-N multisig as the challenge, in case 1 <= x < N of the signers
disappear. If people oppose this, it can be skipped, but will mean people
can't just jump onto signet without first tracking down parameters from
Implementation-wise, the code adds an std::map with block hash to block
signature. This is serialized/deserialized as appropriate (Segwit witness
style), which means block headers in p2p messages are (80 +
solution_length) bytes. Block header non-contextual check goes from
checking if block header hash < target to checking if the payload is a
valid signature for the block header hash instead.
Single commit with code (will split into commits and make PR later, but
just to give an idea what it looks like):
I don't think this PR is overly intrusive, and I'm hoping to be able to get
signet code into Bitcoin Core eventually, and am equally hopeful that devs
of other (wallet etc) implementations will consider supporting it.
Feedback requested on this.
Attribution: parts of the signet code (in particular signblock and
getnewblockhex) were adapted from the ElementsProject/elements repository.
When PR is split into atomic commits, I will put appropriate attribution

@_date: 2019-03-10 09:43:43
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Signet 
Hi Matt,
Keeping the PoW rule and moving the signature would mean DoS attacks
would be trivial as anyone could mine blocks without a signature in
them, unless you ramped up the difficulty, which would mean it's just
another testnet. It's a test network, admittedly, but I think it would
kind of defeat the purpose.
Not sure how this would work in practice. The idea with signet is to
have an actual network that is occasionally reorged, i.e. it's a
global network (for those participating) that everyone agrees on. Not
sure how you would have choices there.

@_date: 2019-03-10 10:02:34
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Signet 
Hi Lautaro,
Using regtest is not ideal for public networks, as anyone anywhere can
just rewrite the blockchain at their whim by mining a ton of blocks.

@_date: 2019-03-12 14:44:29
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Signet 
Hello all,
I started writing code that puts the signature in the coinbase
transaction similar to the witness commitment, and encountered a
potential issue. See inline comments below.
This sounds sensible. One issue here is that the "proper" signer will
be orders of magnitude slower than the fake miner when constructing
blocks. Because the signature is now stuffed into the coinbase
transaction, it becomes a part of the block merkle root, so the true
miner now has to (1) create a block, (2) sign it, (3) check if hash <
target, (4) nudge nonce if not, and then repeat from step (2) until it
finds a valid block. I.e. it has to sign the entire thing for every
That's pretty cool. The plan I had was to set up some simple interface
where anyone could "order" reorgs whenever they wanted to. It would
reorg/double spend people on request (e.g. "send 1 signetcoin to
signet1qfoobar and then double spend it in a reorg 3 blocks deep") and
so on.
With that kind of tool, I don't know if you need the alternate signing
approach you described, but I could be mistaken.

@_date: 2019-03-14 10:07:20
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Signet 
Hi Anthony,
This seems to be what everyone around me thinks is the best approach.
I.e. signet is a "p2p level agreement" that an additional signature is
required for a block to be considered fully valid.
It has the added complexity that a signature-aware signet node talking
to a non-signature-aware signet node should reject/discard headers
sent from the peer, or you will run into situations where a node
doesn't know if the headers are valid or not and has to hold onto them
indefinitely, which is a situation that currently does not occur in
"regular" nets.
If you detach the signature from the header, you also end up with
cases where a malicious user could send garbage data as the signature
for a valid header, forcing peers to mark that header as invalid, even
though it isn't. That is regardless of whether a fix is in place for
the above, too.
Yeah that is one of the ideas we had early on, and I think it's a good
one to do. It doesn't mean someone cannot spam a bunch of invalid
headers at block height current_tip+1, but at least you can get all
but the latest signature now. So as long as you are able to fetch the
latest signature, you should theoretically be able to verify the
entire chain just from the blocks + that one sig.

@_date: 2019-03-14 10:17:31
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Signet 
Hi Varunram,
On Wed, Mar 13, 2019 at 3:41 PM Varunram Ganesh
For starters, I assume that the signer would run an automated script
that generated blocks on regular intervals without requiring manual
interaction. So even if the signer went on a vacation, the network
would keep on ticking. I also assume the signer would be running a
faucet service so users could get coins as needed. Ultimately though,
if a signer ended up vanishing or being unreliable, people would just
set up a new signet with a different signer and use that instead, so
ultimately it's not a big deal.

@_date: 2019-10-11 11:00:51
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] BIPable-idea: Consistent and better definition of 
I've proposed bitcoin invoice for awhile now. See
I like bitcoin invoice address into bitcoin address as proposed by Chris.
On Fri, Oct 11, 2019 at 12:45 AM Emil Engler via bitcoin-dev

@_date: 2019-10-15 11:54:28
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Is Signet Bitcoin? 
The pull request to the bips repository for Signet has stalled, as the
maintainer isn't sure Signet should have a BIP at all, i.e. "is Signet
My argument is that Signet is indeed Bitcoin and should have a BIP, as
this facilitates the interoperability between different software in
the Bitcoin space.
Feedback welcome, here or on the pull request itself:

@_date: 2020-12-21 14:37:38
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] BIP-0322 (generic signmessage) improvements 
Thanks a lot for taking the time to brush up the BIP. For what it's
worth, I am all for these changes, and I see them as clear
improvements all around.
IIRC Pieter was the one who originally suggested the two-checks
approach (invalid, inconclusive, valid) which is being modified here,
so would be good if you chimed in (or not -- which I'll assume means
you don't mind).
On Sat, Dec 19, 2020 at 12:27 AM Andrew Poelstra via bitcoin-dev

@_date: 2020-01-30 20:55:13
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] New tool to assist in BIP 340-342 review: tap 
One of the tools I am maintaining called btcdeb (Bitcoin Script
Debugger) has a new experimental branch "taproot", which builds on top
of the WIP taproot pull request to Bitcoin Core, and contains a new
command line tool called "tap".
Tap allows you to compose taproot and/or tapscript outputs, both for
funding and spending.
There is a detailed tutorial on how this works here:
Feedback welcome.

@_date: 2020-03-04 15:23:53
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion 
I noticed recently that a PR to Bitcoin Core that pretty much touched
everything my BIP-322 pull request touches (around the same
complexity) was merged without a thought given to BIP-322
compatibility, despite the BIP-322 PR being open for 2x the time. I
can only conclude from this that people dislike BIP-322 in its current
form, which the 9 month old pull request stagnating can probably
attest to.
There are several things that I can do to make this a bit more
appealing to people, which would hopefully kick the progress on this
forward. I have already put in a non-trivial amount of energy and
effort into maintaining the pull request as is, so I'd prefer if
people were harsh and unfiltered in their criticism rather than polite
and buffered, so I can beat this thing into shape (or abandon it, in
the worst case).
1. People use signmessage as a way to prove funds. This is misleading
and should be discouraged; throw the sign message stuff out and
replace it entirely with a prove funds system.
I know in particular luke-jr is of this opinion, and Greg Maxwell in
leans towards this opinion as well, it seems.
2. Use a transaction rather than a new format; make the first input's
txid the message hash to ensure the tx cannot be broadcasted. This has
the benefit of being able to provide to an existing hardware wallet
without making any modifications to its firmware.
I think Mark Friedenbach and Johnson Lau are of this opinion, except
Johnson Lau also suggests that the signature hash is modified, see
 --
which defeats the benefit above since now hw wallets can no longer
Prusnak (I think he works at Trezor; apologies if I am mistaken) is
against this idea, and proposes (3) below:
3. Use Trezor style
See This has the benefit of already being adopted (which clearly BIP-322
is failing hard at right now), but has the drawback that we can no
longer do *generic* signing; we are stuck with the exact same
limitations as in the legacy system, which we kinda wanted to fix in
the updated version.
4. Introduce OP_MESSAGEONLY
Quoting Johnson Lau at
 :
OP_MESSAGEONLY means the script following the code would never be
valid. For example, a scriptPubKey:
OP_IF OP_MESSAGEONLY  OP_ELSE  OP_ENDIF OP_CHECKSIG
For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is
ignored. A message could be signed with either key_m or key_s.
For spending, only key_s is valid.
I don't think it is a big problem to consume a op_code. If this is a
real concern, I could modify it as follow: in message system,
OP_RETURN will pop the top stack. If top stack is msg in hex, it is
ignored. Otherwise, the script fails.
5. Some other solution

@_date: 2020-03-04 16:03:34
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion 
I forgot one:
5. The current BIP itself is poorly written and/or unnecessarily
complex: e.g. remove the multi-proof support, and/or remove the
extensibility stuff for a future proof-of-funds extension, and/or
focus solely on the generic sign message stuff.
6. Some other solution
On Wed, Mar 4, 2020 at 3:23 PM Karl-Johan Alm

@_date: 2020-03-05 15:43:03
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Signet: static genesis block, 
I am proposing a modification to BIP-325 to make the genesis block
static and to rely on the message start to avoid collision between
signets when multiple nets exist simultaneously:

@_date: 2020-03-25 15:31:56
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion 
I propose simplifying BIP-322 down to the single-proof case, and
removing some abstractions (e.g. the "actions"/"purposes" stuff):
Feedback welcome.
New version below:
BIP: 322
Layer: Applications
Title: Generic Signed Message Format
Author: Karl-Johan Alm Comments-Summary: No comments yet.
Comments-URI: Status: Draft
Type: Standards Track
Created: 2018-09-10
License: CC0-1.0
== Abstract ==
A standard for interoperable generic signed messages based on the
Bitcoin Script format.
== Background ==
* Assume two actors, a prover P and a verifier V.
* P wants to prove that they own the private key
k associated with a given address A (which
in turn is derived from the pubkey kG).
* Let V generate a message M and hand this
to P.
* P generates a signature S by signing the
message M using k. Given S,
V can prove that P has the private key
associated with A.
The astute reader will notice that the above is missing a critical
part, namely the pubkey kG, without which the verifier
cannot actually verify the message. The current message signing
standard solves this via a cryptographic trick, wherein the signature
S above is a special "recoverable signature" type. Given
the message M and the signature S, it is
then possible to recover the pubkey kG. The system thus
derives the address for the pubkey kG, and if it does not
match A, the proof is deemed invalid.
While this is a neat trick, it unnecessarily restricts and complicates
the message signing mechanism; for instance, it is currently not
possible to sign a message for a P2SH address, because there is no
pubkey to recover from the resulting signature.
== Motivation ==
The current message signing standard only works for P2PKH (1...)
addresses. By extending it to use a Bitcoin Script based approach, it
could be made more generic without causing a too big burden on
implementers, who most likely have access to Bitcoin Script
interpreters already.
== Specification ==
A new structure SignatureProof is added, which is a
simple serializable scriptSig & witness container.
=== SignatureProof container ===
{|class="wikitable" style="text-align: center;"
each one prepended with a varint of its size
In some cases, the scriptsig or wit may be empty. If both are empty,
the proof is incomplete.
=== Result Codes ===
A verification call will return a result code according to the table below.
{|class="wikitable" style="text-align: center;"
== Signing and Verifying ==
If the challenge consists of an address is in the P2PKH (legacy)
format, sign using the legacy format (further information below).
Otherwise continue as stated below.
For both cases, generate a sighash based on the given scriptPubKey and
message as follows:
# Define the message pre-image as the sequence "Bitcoin Signed
Message:\n" concatenated with the message, encoded in UTF-8 using
Normalization Form Compatibility Decomposition (NFKD)
# Let sighash = sha256(sha256(scriptPubKey || pre-image))
A private key may be used directly to sign a message. In this case,
its P2WPKH bech32 address shall be derived, and used as the input.
=== Signing ===
The signature is generated as follows:
# Derive the private key privkey for the scriptPubKey; FAIL if not VALID
# Generate and return a signature sig with privkey=privkey, sighash=sighash
=== Verifying ===
Verify a proof, given a standard flags value, a script sig, an
optional witness, and a derived sighash as described above.
While omitted below, ERROR is returned if an unforeseen error occurs
at any point in the process. A concrete example of this is if a legacy
proof is given as input to a non-legacy address; the deserialization
of the proof will fail in this case, and this should result in an
ERROR result.
# Verify Script with flags=consensus flags (currently P2SH, DERSIG,
NULLDUMMY, CLTV, CSV, WITNESS), scriptSig=script sig,
scriptPubKey=scriptPubKey, witness=witness, and sighash=sighash
# Return INVALID if verification fails
# Verify Script with flags=standard flags (above plus STRICTENC,
MINIMALDATA, etc.), scriptSig=script sig, scriptPubKey=scriptPubKey,
witness=witness, and sighash=sighash
# Return VALID if verification succeeds, otherwise return INCONCLUSIVE
== Legacy format ==
The legacy format is restricted to the legacy P2PKH address format.
Any other input (i.e. non-P2PKH address format) must be signed using
the new format described above.
=== Signing ===
Given the P2PKH address a and the message m,
and the pubkey-hash function pkh(P) =
# let p be the pubkey-hash pkh(P) for the
pubkey P, contained in a
# let x be the private key associated with P
so that pkh(xG) = p
# let digest be SHA56d("Bitcoin Signed Message:\n"||m)
# create a compact signature sig (aka "recoverable ECDSA
signature") using x on digest
The resulting proof is sig, serialized using the base64 encoding.
=== Verifying ===
Given the P2PKH address a, the message m,
the compact signature sig, and the pubkey-hash function
pkh(P) = ripemd160(sha256(P)):
# let p be the pubkey-hash pkh(P) for the
pubkey P, contained in a
# let digest be SHA56d("Bitcoin Signed Message:\n"||m)
# attempt pubkey recovery for digest using the signature
sig and store the resulting pubkey into Q
 fail verification if pubkey recovery above fails
# let q be the pubkey-hash pkh(Q) for the
pubkey Q
# if p == q, the proof is valid, otherwise it is invalid
== Compatibility ==
This specification is backwards compatible with the legacy
signmessage/verifymessage specification through the special case as
described above.
== Reference implementation ==
# Pull request to Bitcoin Core: == Acknowledgements ==
Thanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille,
and many others for their feedback on the specification.
== References ==
# Original mailing list thread:
== Copyright ==
This document is licensed under the Creative Commons CC0 1.0 Universal license.
== Consensus and standard flags ==
Each flag is associated with some type of enforced rule (most often a
soft fork). There are two sets of flags: consensus flags (which result
in a block being rejected, if violated), and policy flags (which
result in a transaction being accepted only if it is contained within
an actual block, and rejected otherwise, if violated). The policy
flags are a super-set of the consensus flags.
BIP322 specifies that a proof that validates for both rulesets is
valid, a proof that validates for consensus rules, but not for policy
rules, is "inconclusive", and a proof that does not validate for
consensus rules is "invalid" (regardless of policy rule validation).
The ruleset sometimes changes. This BIP does not intend to be
complete, nor does it indicate enforcement of rules, it simply lists
the rules as they stand at the point of writing.
=== Consensus rules ===
* P2SH: evaluate P2SH
BIP16]) subscripts
* DERSIG: enforce strict DER
BIP66]) compliance
* NULLDUMMY: enforce NULLDUMMY
* CHECKLOCKTIMEVERIFY: enable CHECKLOCKTIMEVERIFY
* CHECKSEQUENCEVERIFY: enable CHECKSEQUENCEVERIFY
* WITNESS: enable WITNESS
=== Policy rules ===
All of the above, plus (subject to change):
* STRICTENC: non-strict DER signature or undefined hashtype
* MINIMALDATA: require minimal encodings for all push operations
* DISCOURAGE_UPGRADABLE_NOPS: discourage use of NOPs reserved for upgrades
* CLEANSTACK: require that only a single stack element remains after evaluation
* MINIMALIF: Segwit script only: require the argument of OP_IF/NOTIF
to be exactly 0x01 or empty vector
* NULLFAIL: signature(s) must be empty vector if a CHECK(MULTI)SIG
operation failed
* LOW_S: signature with S > order/2 in a checksig operation
* DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM: v1-16 witness programs are
non-standard (i.e. forbidden)
* WITNESS_PUBKEYTYPE: public keys in segregated witness scripts must
be compressed
* CONST_SCRIPTCODE: OP_CODESEPARATOR and FindAndDelete fail any
non-segwit scripts
== Test vectors ==
(TODO: update test vectors, which are based on previous iteration
where signature proofs contained additional data)
== Native segwit test vector ==
address = bcrt1qe7nte4zk4ayly5tc53dtdjupgkz0lr8azx3rzz
scriptpubkey = 0014cfa6bcd456af49f25178a45ab6cb814584ff8cfd
message = hello
preimage = 0014cfa6bcd456af49f25178a45ab6cb814584ff8cfd426974636f696e205369
(scriptpubkey || "Bitcoin Signed Message:\nhello")
sighash = 790eef86c204f0bff969ff822121317aa34eff0215dbd30ccf031e7b2f3f0cc1
(sha256d(preimage), displayed in big-endian)
The proof becomes:
HEX: 01000000010002473044022075b4fb40421d55c55462879cb352a85eeb3af2138d3f0290
Base64: AQAAAAEAAkcwRAIgdbT7QEIdVcVUYoecs1KoXus68hONPwKQLJFD8Shw9fcCIBGcKZXBZhE4
Split into components:
{|class="wikitable" style="text-align: center;"
3899c1fd6d1af7e790e0e081be72db9ce7bf5b5b932901||Witness stack item 1
7c1dee9ea6e2dcd869||Witness stack item 2
The above test vector is for a bech32 P2WPKH (native segwit) address.
(Once BIP solidifies, will add test vector for other types.)

@_date: 2020-10-01 17:56:15
@_author: Karl-Johan Alm 
@_subject: [bitcoin-dev] Message signing (again) 
I have updated the signmessage proposal (BIP-322) to use the same
approach as signet uses, which brings out of the box support for psbt
and such, and removes the need for a custom signer and validator
(well, sort of anyway).
In the process, I've also replaced the concatenation approach
(hash("Bitcoin Signed Message || ")) with a
BIP340-tagged-hash approach (h/t Not much remains of the old BIP, so I am tentatively submitting this
as a replacement proposal. I'd be totally fine with submitting this as
an updated BIP-322 though, if people prefer that.
Pull request is here:
Viewable version:
Inline version:
BIP: ????
Layer: Applications
Title: Generic Signed Message Format
Author: Karl-Johan Alm Comments-Summary: No comments yet.
Comments-URI: Status: Draft
Type: Standards Track
Created: 2020-10-01
License: CC0-1.0
Replaces: 322
== Abstract ==
A standard for interoperable generic signed messages based on the
Bitcoin Script format.
== Background ==
* Assume two actors, a prover P and a verifier V.
* P wants to prove that they own the private key
k associated with a given address A (which
in turn is derived from the pubkey kG).
* Let V generate a message M and hand this
to P.
* P generates a signature S by signing the
message M using k. Given S,
V can prove that P has the private key
associated with A.
The astute reader will notice that the above is missing a critical
part, namely the pubkey kG, without which the verifier
cannot actually verify the message. The current message signing
standard solves this via a cryptographic trick, wherein the signature
S above is a special "recoverable signature" type. Given
the message M and the signature S, it is
then possible to recover the pubkey kG. The system thus
derives the address for the pubkey kG, and if it does not
match A, the proof is deemed invalid.
While this is a neat trick, it unnecessarily restricts and complicates
the message signing mechanism; for instance, it is currently not
possible to sign a message for a P2SH address, because there is no
pubkey to recover from the resulting signature.
== Motivation ==
The current message signing standard only works for P2PKH (1...)
addresses. By extending it to use a Bitcoin Script based approach, it
could be made more generic without causing a too big burden on
implementers, who most likely have access to Bitcoin Script
interpreters already.
== Specification ==
This BIP follows the specification of BIP-325 challenges and solutions.
Let there be two virtual transactions to_spend and to_sign.
The "to_spend" transaction is:
nVersion = 0
nLockTime = 0
vin[0].prevout.hash = 0000...000
vin[0].prevout.n = 0xFFFFFFFF
vin[0].nSequence = 0
vin[0].scriptSig = OP_0 PUSH32[ message_hash ]
vin[0].scriptWitness = []
vout[0].nValue = 0
vout[0].scriptPubKey = message_challenge
where message_hash is a BIP340-tagged hash of the message, i.e.
sha256_tag(m), where tag = "BIP????-signed-message", and
message_challenge is the to be proven (public) key script.
The "to_sign" transaction is:
nVersion = 0
nLockTime = 0
vin[0].prevout.hash = to_spend.txid
vin[0].prevout.n = 0
vin[0].nSequence = 0
vout[0].nValue = 0
vout[0].scriptPubKey = message_signature
It may include other inputs, to facilitate a proof of funds.
A message signature is considered valid, inconclusive, or invalid
based on whether the to_sign transaction is a valid spend of the
to_spend transaction or not, according to the following steps (also
see Consensus and standard flags section further down):
1. Valid, if it is a successful spend according to the current
consensus rules (sometimes called "policy").
2. Inconclusive, if it is a successful spend according to consensus
rules, but NOT according to policy rules
3. Invalid, if it is not a successful spend according to consensus rules
A proof is the base64-encoding of the message_signature as is. A
validator takes the to be proven pubkey and the proof and transforms
it to virtual transactions as described above.
== Legacy format ==
The legacy format is restricted to the legacy P2PKH address format.
Any other input (i.e. non-P2PKH address format) must be signed using
the new format described above.
=== Signing ===
Given the P2PKH address a and the message m,
and the pubkey-hash function pkh(P) =
# let p be the pubkey-hash pkh(P) for the
pubkey P, contained in a
# let x be the private key associated with P
so that pkh(xG) = p
# let digest be SHA56d("Bitcoin Signed Message:\n"||m)
# create a compact signature sig (aka "recoverable ECDSA
signature") using x on digest
The resulting proof is sig, serialized using the base64 encoding.
=== Verifying ===
Given the P2PKH address a, the message m,
the compact signature sig, and the pubkey-hash function
pkh(P) = ripemd160(sha256(P)):
# let p be the pubkey-hash pkh(P) for the
pubkey P, contained in a
# let digest be SHA56d("Bitcoin Signed Message:\n"||m)
# attempt pubkey recovery for digest using the signature
sig and store the resulting pubkey into Q
 fail verification if pubkey recovery above fails
# let q be the pubkey-hash pkh(Q) for the
pubkey Q
# if p == q, the proof is valid, otherwise it is invalid
== Compatibility ==
This specification is backwards compatible with the legacy
signmessage/verifymessage specification through the special case as
described above.
== Reference implementation ==
== Acknowledgements ==
Thanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille,
and many others for their feedback on the specification.
== References ==
# Original mailing list thread:
== Copyright ==
This document is licensed under the Creative Commons CC0 1.0 Universal license.
== Consensus and standard flags ==
Each flag is associated with some type of enforced rule (most often a
soft fork). There are two sets of flags: consensus flags (which result
in a block being rejected, if violated), and policy flags (which
result in a transaction being accepted only if it is contained within
an actual block, and rejected otherwise, if violated). The policy
flags are a super-set of the consensus flags.
This BIP specifies that a proof that validates for both rulesets is
valid, a proof that validates for consensus rules, but not for policy
rules, is "inconclusive", and a proof that does not validate for
consensus rules is "invalid" (regardless of policy rule validation).
The ruleset sometimes changes. This BIP does not intend to be
complete, nor does it indicate enforcement of rules, it simply lists
the rules as they stand at the point of writing.
=== Consensus rules ===
* P2SH: evaluate P2SH
BIP16]) subscripts
* DERSIG: enforce strict DER
BIP66]) compliance
* NULLDUMMY: enforce NULLDUMMY
* CHECKLOCKTIMEVERIFY: enable CHECKLOCKTIMEVERIFY
* CHECKSEQUENCEVERIFY: enable CHECKSEQUENCEVERIFY
* WITNESS: enable WITNESS
=== Policy rules ===
All of the above, plus (subject to change):
* STRICTENC: non-strict DER signature or undefined hashtype
* MINIMALDATA: require minimal encodings for all push operations
* DISCOURAGE_UPGRADABLE_NOPS: discourage use of NOPs reserved for upgrades
* CLEANSTACK: require that only a single stack element remains after evaluation
* MINIMALIF: Segwit script only: require the argument of OP_IF/NOTIF
to be exactly 0x01 or empty vector
* NULLFAIL: signature(s) must be empty vector if a CHECK(MULTI)SIG
operation failed
* LOW_S: signature with S > order/2 in a checksig operation
* DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM: v1-16 witness programs are
non-standard (i.e. forbidden)
* WITNESS_PUBKEYTYPE: public keys in segregated witness scripts must
be compressed
* CONST_SCRIPTCODE: OP_CODESEPARATOR and FindAndDelete fail any
non-segwit scripts
== Test vectors ==
