
@_date: 2014-12-29 21:34:07
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] BIP: Voluntary deposit bonds 
Hash: SHA256
If a miner includes pay-to-fee transactions in a block, those fees
could be claimed by another miner in the case the first miner's block
is orphaned.
Inputs to a generation transaction can not be similarly poached.
That difference makes some services possible that would can not be
safely achieved with pay-to-fee transactions.

@_date: 2014-12-30 13:16:56
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] BIP: Voluntary deposit bonds 
Hash: SHA256
I don't know what Sergio Lernet meant about miners paying themselves
and future network security.
If miners wanted to offer value-added services, especially if those
services involved adding specific scripts to the outputs of the
generation transaction, the most natural way for their customers to
pay them is to allow inputs to the generation transaction.
It could also be done with pay-to-fee transactions, but that would
make the services more expensive due to risk premium.

@_date: 2014-10-22 16:01:57
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Two Proposed BIPs - Bluetooth 
Hash: SHA256
You also have things like BIP43 that encourage people to reserve BIP
numbers to avoid namespace collisions even if their work does not
affect any other project.
There should be an efficient process for informational BIPs of this type.

@_date: 2015-04-24 22:00:46
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Reusable payment codes 
Hash: SHA1
This link contains an RFC for a new type of Bitcoin address called a
"payment code"
Payment codes are SPV-friendly alternatives to DarkWallet-style stealth
addresses which provide useful features such as positively identifying
senders to recipients and automatically providing for transaction refunds.
Payment codes can be publicly advertised and associated with a real-life
identity without causing a loss of financial privacy.
Compared to stealth addresses, payment codes require less blockchain data
Payment codes require 65 bytes of OP_RETURN data per sender-recipient pair,
while stealth addresses require 40 bytes per transaction.

@_date: 2015-04-25 02:20:59
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Fwd:  Reusable payment codes 
I agree that the output associated with notification transactions would
require special handling to avoid privacy leaks. At a minimum they'd
require mixing or being donated to miners as a transaction fee.
Communication is only one way, except for the case in which the recipient
wants to send a refund. Assuming no refund and only a single anonymous
donation in the lifetime of the sender's identity, payment codes would
require 65 bytes vs 40 bytes for stealth addresses.
As soon as the sender sends more than one donation to the same recipient,
payment codes show an space advantage over stealth addresses.
This kind of binding was intentionally designed out of the stealth
address proposal;  I think this scheme can be made to work without any
With 97 byte standard OP_RETURN values the ephemeral public
key could be appended to the chain code, but that's undesirable for other
This is fundamentally more expensive to compute; please don't specify
Taking the SHA512 of something less than 512 bits seemed wrong.
I agree. I could not find a straightforward way to express a multisignature
payment code in less than 80 bytes.
I suspect this is a case where we just can't have all the features we want.
In this proposal I optimized for non-reliance on third party services and a
guaranteed ability to recover spendable funds from a seed backup.
Gaining those two features resulted in some tradeoffs as you noted, but I
think there are enough benefits to make them worthwhile.
In particular, payment codes could be the basis for a Heartbleed-free
payment protocol that can positively identify customers and automatically
provide refund capabilities in a merchant-customer relationship. A merchant
only requires one payment code which they can safely use for all their
customers, meaning they only ever need to associate 65 bytes with their
identity to allow customers to make sure they are paying the right entity.
Exchanges could restrict bitcoin withdrawals to a single payment code known
to be associated with their identified customer. This would make thefts
easier (without involving address reuse as in locking withdrawals to a
single P2PKH address).
In some jurisdictions the ability to prove that withdrawals are sent to a
positively-identified party, rather than arbitrary third parties, might
move some Bitcoin businesses out of money transmitter territory into less
onerous regulatory situations.

@_date: 2015-04-25 02:21:20
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Fwd:  Reusable payment codes 
I have pushed an updated version of the proposal which incorporates some of
the received feedback and adds a note about the consequences of sharing a
payment code-enabled walled on multiple devices:

@_date: 2015-04-25 02:22:30
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Fwd:  Reusable payment codes 
Taking the hash of the secret would then require an extra step to make sure
the hash is valid for secp256k1.
Using the x value directly avoids the need for that check.
On Fri, Apr 24, 2015 at 10:35 PM, Patrick Mccorry (PGR) <

@_date: 2015-04-25 04:34:13
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Fwd: Reusable payment codes 
The goal of the notification transaction is to send the same payment code
to every recipient, but obscure the identity of the sender of the
notification transaction from third party blockchain observers.
The shared secret is used for that purpose, and the sender's public key
used for ECDH can't be one derived from the payment code since the
recipient doesn't yet know the payment code.
The notification transaction needs to communicate the 65 byte payment code
along with one ephemeral public key used for ECDH. If that ephemeral key is
not located in a signature script, it has to be somewhere else (such as in
the same OP_RETURN output as the payment code.)
Already fixed in
but it would be good to get confirmation of whether the way I fixed it is
I'm not sure what you mean by "the requirement for inputs is a guaranteed
dependency on third party
At the proposal currently stands, an SPV wallet will have no trouble
sending or receiving notification transactions without access to a third
party service. The recipient just needs to see the transactions associated
with its notification address.
The point about restricting the types of scripts used as inputs is valid,
but I think workarounds are available. If nothing else, the sender can make
a suitable input using it's own (suitably mixed) coins first.
I considered defining an additional path level for deterministic m-of-n
multisig and adding a few bytes to the payment code to express those
parameters, but thought it would be too limiting since it would preclude
multisig with truly independent keys. It is a thing that could be done,
Cold storage is still available (if admittedly less convenient than in
traditional wallets).
I would expect exchanges in practice to allow for payment codes to be
changed, just with non-trivial waiting periods and plenty of human
overview. It would be an infrequent event compared to the frequency of
Various schemes which use public key authentication instead of passwords
for web site authentication could be used to continually verify that the
user hasn't lost access to the key.

@_date: 2015-04-26 16:50:00
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Fwd: Reusable payment codes 
Payment codes establish the identity of the payer and allow for simpler
methods for identifying the payee, and automatically provide the payee with
the information they need to send a refund.
If merchants and customers were using payment codes, they would not need
the BIP70 equivalents.
I think the best way to explain payment codes is that they add the missing
"from address" to transactions which users want, but we've had to tell them
they can't have.
A payment code behaves much more like an email address than a traditional
Bitcoin address.

@_date: 2015-04-27 15:54:36
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Reusable payment codes 
Hash: SHA1
SPV clients that connect exclusively to hidden services through Tor
could mitigate this, especially if those clients broadcast their
transactions through different peers than the ones they use for
checking their balance.
Maybe they should even go the opposite way in terms of the false
positive rate.
A client could create a filter that *only* matches their notification
address and use that filter with a selected peer.
All the rest of their addresses would be contained in a different
filter that is never sent to the same full node which is watching
their notification address.
I'm not sure this problem is solvable in general.
Any entity which has sent bitcoins to a known user could use that
knowledge to attempt to find their bloom filter (if they use one).
I think that for SPV to have any privacy at all clients need to get a
lot smarter about how they use bloom filters overall, such as by
connecting to more than one peer, only putting a subset of their
addresses in a single filter, and temporally varying the addresses
which they watch.

@_date: 2015-04-27 17:02:36
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Reusable payment codes 
Hash: SHA1
I expect that mappings would begin to develop between payment codes
and government / real name identities, at least as far as that
businesses which are required to collect that kind of information
would associate it with the payment code(s) known to be used by their
customers for their own use.
I proposed payment codes in this form because I'd rather see that kind
of mapping be limited to the application layer and kept away from the
blockchain/network layer.
Even if it makes certain kind of application-layer distasteful
behavior easier, it's a good trade if doing so can simultaneously
provide resistance to graph analysis and make transaction-level
censorship more difficult.

@_date: 2015-01-20 11:47:23
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] The legal risks of auto-updating wallet 
Hash: SHA1
One suggestion you didn't mention was jurisdictional arbitrage - don't
be located in the same country as the majority of your users.
Or, from the other perspective, users should be strongly encouraged to
get their wallet software from companies/organizations not located in
the same country as them.

@_date: 2015-01-20 13:31:14
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] The legal risks of auto-updating wallet 
Hash: SHA1
Depending on the threat model, the incentive to force confiscation
might also be lower.

@_date: 2015-07-02 10:45:05
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] RFC: HD Bitmessage address derivation based on 
The primary purpose is to allow Bitmessage users to benefit from
eternal key backups by generating their addresses from a seed.
In addition, they can use the same seed for a Bitcoin wallet and a
Bitmessage client.
This method also enables future use cases where senders calculate
Bitmessage addresses based on a recipient's extended public key and
some other index value.
On Wed, Jul 1, 2015 at 12:07 PM, Kristov Atlas

@_date: 2015-06-16 23:44:45
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Lost proposals from FellowTraveler/Monetas 
Hash: SHA512
The only two proposals we sent to the mailing list were attached to this
The rest of the proposals in that respository, as well as those the fork
were never submitted because we decided to use alternative identifiers in
leiu of BIP numbers to serve as the purpose code in the HD path.

@_date: 2015-06-30 17:53:05
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] RFC: HD Bitmessage address derivation based on BIP-43 
Monetas has developed a Bitmessage address derivation method from an
HD seed based on BIP-43.
We're proposing this as a BIP per the BIP-43 recommendation in order
to reserve a purpose code.

@_date: 2015-03-17 11:26:10
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Improving resistance to transaction 
Hash: SHA1
The ability of entities with large numbers of nodes to track the
origination of Bitcoin transactions is very similar to an attack on
the Freenet project.
The Freenet project addressed this weakness by via a technique they
called "Darket" - which means that nodes would only connected to a
defined set of trusted peers instead of being open to all connections
(Opennet) An individual Freenet node can operate in Opennet mode, or
Darknet mode, or mixed mode. [1]
This approach would be beneficial to Bitcoin as well to reduce privacy
leaks due to harvesting attacks.
Allow Bitcoin nodes to create authenticated connections with trusted
peers via CurveCP [2]. Nodes that have at least one CurveCP peer only
broadcast their transactions to those peers.
Use of CurveCP requires both sides of the connection to know each
other's long term public key. This key can be packaged in a structure
similar in concept to a Freenet node reference.
A Bitcoin node reference consists of a JSON structure containing one
or more "externalip" elements followed by one "pubkey" element. The
structure is then clearsigned by the long term CurveCP public key
contained in the "pubkey" element.
Users who wish to set up a secure connection between their nodes would
first use an API command to generate their node references, exchange
these files, and copy them to the ~/.bitcoin/curvecp directory with a
.ref extension. The node only accepts CurveCP connections from, and
attempts CurveCP connection to, peers whose references are present in
that directory.
Instead of listening both for regular TCP and CurveCP connections on
the same port, CurveCP connections would take place on a separate
port, designated by -bind_curvecp, -port_curvecp, and -externalip_curvecp
If -bind_curvecp is specified, the node will always listen for
incoming CurveCP connections, -listen=0 can be set to disallow
non-authenticated incoming connections.
Relationship with Tor:
This proposal would work along with, or independently of Tor usage.
The same network monitoring techniques which can track an originating
transaction to a particular IP address could do the same thing for a
node which is listening as a hidden service, and any technique for
deanonymising hidden services could then identify the point of origin.
Currently the only way to configure a node to submit its transactions
anonymously to the network is to make the node non-listening, which
means it can not contribute to the network.
This proposal would allow nodes to contribute to the network as
listening nodes, while retaining privacy with regards to transactions
originating from themselves.
SPV peers:
CurveCP connections also can be created between full nodes and SPV
nodes, in which case transactions originating from the SPV peers would
be routed as if they originated from the full node.
[1] [2]
