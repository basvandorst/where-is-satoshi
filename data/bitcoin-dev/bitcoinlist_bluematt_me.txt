
@_date: 2011-08-03 13:38:19
@_author: Matt Corallo 
@_subject: [Bitcoin-development] DNS seeds returning gone peers 
Its actually much, much less.  You forgot to grep for filtered, which
are also worthless and you didn't make an actual connection to the node,
meaning there is no way to tell if the node has its connection slots
full (a node which has the maximum connection count will ack a syn, but
will drop the connection after the first message, so nmap thinks the
port is open).
I just tested and I show 0 accepting from bitseed.xf2.org and 0 from
bitcoin.bitcoin.co.uk.  dnsseed.bluematt.me rotates every 2 minutes to
the most recently checked so it tends to be pretty good if you get it
right after a rotate, if you wait to long, those slots fill up quick.
Point him to  it could use a bit
of cleanup, but it works.
If a different DNS Server were used to could pull directly from the
database in a more dynamic way it would probably work better too (it was
originally set up on MySQL and PowerDNS, but that is quite a resource
hog compared to SQLite and BIND, but the original backend is still there
and could work if you have a beefy enough server).

@_date: 2011-08-03 17:32:00
@_author: Matt Corallo 
@_subject: [Bitcoin-development] DNS seeds returning gone peers 
They were redone in .24 to the point that they should not cause any such
issues in the future.

@_date: 2011-08-04 16:14:54
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Blitcoin? (Black Hat 2011) 
Sounds like Dan wrote a tool which attempts to connect inputs/outputs
and make a map of a person on the network, or at least thats my blind
guess.  Something people have been saying was easily possible for some
time, but for some reason people insist on refusing their precious
Bitcoin isnt anonymous.

@_date: 2011-08-04 19:45:17
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
There really is no reason to add the extra network complexity for this.
First of all (as you point out) no one buying a Ferrari will refuse to
wait an hour for the payment to confirm.  If someone is attempting to
pull a similar trick on, say, a vending machine however it might make
sense.  But that changes the equation.  In order for these two scammers
to pull it off, some effort is required in terms of communicating the
time to send the coins and the nodes of the targets (vending machines or
whatever) must be figured out.  So now its less of "make it impossible"
and more of "make it really hard to the point that it is no where near
worth the effort".
Lets simplify the scenario a bit so that one scammer can pull it off.
Send one copy of your transaction to the target node and another to
large mining operations so that the payment transaction is considered
invalid to miners and a transaction which pays you is confirmed.
If you are the vending machine, your goal is not to figure out any
transactions which are yours, but to figure out which transactions which
are yours are going to be confirmed.  So, you peer with the largest
miners (a "Bitcoin backbone" or large miners and merchants has been
suggested over and over again and really hasn't happened) and modify
your client to, instead of dropping transactions which are
double-spends, keep both in memory pool and consider them both invalid
until one of them confirms.
This will work with 1, 2, or n scammers, doesn't require any additional
network messages, and offers just as good, if not better security over a
double spend message.
Additionally, in the future, when(/if) Bitcoin payment processors exist,
most merchants will rely on those, which can handle such double-spend
checks and tell a merchant a transaction is confirmed in ten seconds for
small transactions, an hour for large ones, or anywhere in between.
Such payment processors could also mine or have contracts with large
miners which allows them to influence the transactions which are to be
confirmed, allowing for even quicker confirmations and the offering of
insurance against unconfirmed transactions being invalidated.

@_date: 2011-08-04 20:39:56
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
But why? It results in slightly more network traffic which is exactly
what we don't want, and it adds yet another message people have to know
Ferraris aren't exactly small ;)
No one cares about what the network thinks is the right transaction, its
only what miners believe that matters.
Even if the vending machine doesn't keep the full chain and doesn't
accept incoming connections, its still the target node.  What other
nodes on the network think doesn't matter as long as you get the target
to think a transaction that won't be confirmed will be.  If it doesn't
accept incoming connections you want to find nodes that do that are
connected to your target.
That is exactly my point.
Its much easier to create than to change the network code to relay info
on double-spend transactions.
No, thats not what happens now.  Currently if your node gets a
transaction which conflicts with one it already knows about, it silently
drops it without a second thought.  My point is if you actually dealt
with such cases and made good connections, you would be able to prevent
double spends nearly perfectly.
No, my suggestion is not to relay the second transaction.  The second
transaction should continue to not be relayed as it currently is,
however receiving such a transaction should trigger the node to notify
the user that the transaction should not be accepted until it makes it
into a block (in fact, you could already do this if you implemented a
debug.log parser and made well-placed connections).
Bitcoin is absolutely still an experiment and no one thinks that any
kind of future is guaranteed.  This was not meant as an argument, but
simply as "if bitcoin does end up going somewhere, it will likely be
done like this".

@_date: 2011-08-04 22:33:29
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
Exactly, why add more network traffic for something that you can get
better without doing that?
Again though, adding more crap to the protocols is something we want to
avoid, especially if it offers no gain.
Nope, the network decides nothing, only the miners decide.
Then your whole attack scenario is broken and it becomes a 50/50 (or
more likely less) guess.
No, its easier for people who care to make sure they are peered with
well-connected nodes than for us to change the network protocol.
Yep, which is what my suggestion does.
If it only ends up on a few isolated nodes, then you dont care as the
ones that you dont know about will never be confirmed.  If it ends up on
a node you peer with, you will be able to fetch both transactions and
then you know about the double spend.  Hence why you have to have
well-connected peers.
No one is against making changes if they offer clear incentive.  This
one doesnt.  Additionally, whether its an experiment or not, people have
money stored in it and a mistake could mean the loss of tens of
thousands or hundreds of thousands of dollars.  Lastly, no one is (yet)
paid to work on Bitcoin, sorry the developers dont spend enough time
merging for your liking.
I think having the ability to detect double-spends rapidly is something
that is needed, my point is that you already can with relatively little
effort, no point adding more stuff to make it no easier.

@_date: 2011-08-04 22:38:25
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
They already do if they provide the IP of their node (or a proxy node on
top of theirs which would be recommended for security).  This has been
my whole point the entire time.

@_date: 2011-08-05 00:16:13
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
I stand with satoshi here.  No need to add more stuff to the network
protocol, a well-connected node can easily monitor the miners(/network)
for double-spends and alert whoever may need to know that the
transaction should not be accepted.  True, not everyone has the
resources to try to implement this, however the number of people who
have the resources to implement a Bitcoin storefront and not implement
this (vs those who will/do use a payment processor who handles such
things), I would think, are fairly small.
Additionally, keep in mind that many storefronts don't need to care if a
transaction confirms in 10 seconds or 1 hour.  Only digital goods and
physical purchases could benefit from such speed increases.
Since nobody else has mentioned it: There is another (more pragmatic?) This is exactly what I've been suggesting this whole time.

@_date: 2011-08-05 00:21:53
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
I've been thinking about going through my logs to see how many nodes I
am connected to that are clearly bad (like those), but I suppose you
beat me to it.  Should such connections not be dropped over time as they
are clearly not functioning nodes?

@_date: 2011-08-05 14:00:02
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
It used to be enabled by default on virtually all routers a couple years
ago, but too many "security researchers" complained that it was a "huge
security vulnerability" (I guess they hadn't heard of stun or outgoing
connections) so its not typically disabled on most routers.

@_date: 2011-08-05 14:06:09
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
Number of connections is something that needs serious thought.  Too many
and you fill everyone's connection slots and no one can make
connections.  Too few and you don't have a network but just a bunch of
islands which would also cause serious problems.
If you aren't relaying, each connection takes almost no bandwidth, so
the question is how many do you need to be considered secure.

@_date: 2011-08-05 23:30:50
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Double spend detection to speed up 
Mike and me were talking about outgoing connection count, not incoming,
which is another thing entirely.
However, to your point: having 1000 Bitcoin connection is still almost
no traffic, the only timt you really hit much traffic is when you get a
peer with a client who doesn't have the full chain as they will start
downloading the chain maxing your bandwidth.  My bandwidth of Bitcoin is
something like avg 3GB/month for 125 connections which is nothing.
However it has very brief spikes of my entire outgoing bandwidth.
Thus, neither bandwidth nor connection count are really good metrics for
choosing your number of incoming slots.

@_date: 2011-08-10 12:14:49
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Change to multiple executables? 
I would argue its less clear for the user.  Instead of opening either
bitcoind or bitcoin to get RPC or GUI, now you have to open bitcoin and
bitcoind or bitcoincl and bitcoind.  Now, obviously bitcoin and
bitcoincl can open bitcoind for you, but I think adding more executables
complicates things for little clear advantage.
As you pointed out, we have bitcoind for just this reason.
Making RPC optional for GUI users would be an interesting addition.
All this said, I totally agree with the more clear split of the source
into separate library-ish components (I'm working on part of that now).
However, I don't like the idea of splitting into more executables.  If you are suggesting this so that bitcoin-qt can be distributed being
built off of bitcoind, I would say go ahead and pull-request bitcoin-qt.
I'm of the opinion that it should be merged whether we have autotools or
not (we already have 5 makefiles, whats a few more options in those?)
and jgarzik seemed to indicate that he would agree (Gavin?, sipa?

@_date: 2011-08-10 18:59:14
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Roadmap/schedules 
We really don't have too many metrics here.  AFAIK the only real metric
keeping place would be my dnsseed (as well as the one run by IO- ) and
they don't look good (I show about 3x as many 0.3.23 nodes listening as
0.3.24, likely due to the rate that 0.3.23 nodes will drop connections,
made worse by recent block size increases).
Very much needed, didn't TD say something about a friend who wanted to
do research in this area?
Sipa had begin looking at doing some redoing of the locking system (to
support more broad stuff like read-only locks, etc) to solve that exact
bug, but I never heard anything about if he actually started writing
code or how far he got.
I was under the impression all that was left on the to-do for 0.4 was
wallet import/export testing and merge (and a few bug fixes like I agree  should be pulled sometime soon, but maybe for 0.4 just the
IsStandard parts in 0.4 as those need to get out first anyway?
Personally, I'd like to see a better bug tracking system used anyway, ie
one with a full feature set, better tagging system, etc (I really hate
github's system here, but moving would be hard...).  Anyway, many of
them are future "would be nice to have things" or a minor or annoying
bug which effects almost no one (or is at least doesnt keep anyone from
using the client) but require a lot of effort to fix.
Would be really nice.  I'm looking to move the jenkins server somewhere
(moving to college means move as much as possible to VPSs instead of my
parent's basement where I can't manage it) but it could allow for pretty
good sanity tests on patches (which they often currently fail) including
unit tests and build tests.  If someone trusted wants to part with a VPS
or can spare some bitcoins so I can grab one myself, it would be much
appreciated (or if someone wants to take over that server, that would be
Need to talk here, I started work on splitting the block/transaction
check/store and net with the ultimate goal of making a nice api that
they communicate over (as well as wallet and potentially other) and
allowing for a different block/transaction check module for lightweight
nodes.  It would also mean a bit cleaner codebase which could allow for,
say, a partial rewrite of net code without far-reaching changes.
Whether or not its even a good idea, I don't know, but I've written some
code anyway.
I was under the impression the plan was for this to go in 0.4 aka next
release, but personally, I don't care too much either way.
Sipa did some good thinking through for algorithms that could be really
useful here, but I don't think any code was ever written, nor did he
finish (is he off doing the studying thing?)
Not sure what is meant here.  Personally, I'm animately against any kind
of notification to spread through the network in case of a double spend,
and I really think it double-spend detection could be very efficiently
done now.  I was under the impression block-chain splits were fairly
efficiently handled already?

@_date: 2011-08-11 10:48:09
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Roadmap/schedules 
My fault, Ill write something up on the train back today.
Jenkins + a large enough test suite could do very nice automatic sanity
testing IMHO...that is what it is designed for (even if not to
automatically test pre-merge, but it could be adapted).  Many pull
requests build on Linux, but not on MinGW, OSX, etc so just that would
be useful IMHO.
Sipa's stuff is quite good IMHO, it still has some problems left to
solve (like choosing minor details of the underlying priority algorithm)
but aside from those, I think it could work.  I'm not sure if sipa wants
to just publish the stuff he did so far and let this list debate on the
remaining details and eventual implementation, or if he wanted to come
up with something complete before publishing, it up to him, but it is

@_date: 2011-08-22 16:45:18
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Introduction 
Nice to meet you.  Its always nice to have more dedicated developers.
autotools yay.  Also, have you seen jenkins.bluematt.me?
No one has complained too much about mine yet, so I think you are safe.
And Id bet everyone here is exited to have you.

@_date: 2011-08-29 21:09:03
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Project status 
Hopefully working on something that would help do this now.
Also my build update pull would be much appreciated.

@_date: 2011-12-12 18:52:45
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
Firstbits isn't acceptable for anything.  As Amir originally pointed
out, it doesn't scale well and worst of all it fills the blockchain with
a ton of crap to get 1 satoshi at an address so that it is
"registered".  Firstbits is unacceptable because it causes unnecessary harm to each
Bitcoin node.  However, if one were to use a chain specifically crafted
for such a purpose isn't terrible.  That said, it still doesn't scale
well and if it becomes popular virtually every implementation would have
to rely on trusted servers at which point you are better off going back
to an HTTPS/DNSSEC-based implementation

@_date: 2011-12-15 21:48:17
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
I'm not against this, but I think its way overcomplicated when compared
to the DNS or HTTPS methods.
OK, not too debatable, but considering how terrible bitcoind's account
handling is, the second might not be easy to get right...
This is where I think this method becomes way overcomplicated.  Not only
do you have to update the IP-Transaction code, but now you have to
implement the full DNS System that is the other option as well.  Note
that to make this secure, we have to have a full DNSSEC-capable resolver
built-into bitcoind (there are libs, but it has to happen).  Yes you can
ask the user "does this fingerprint look right to you? Y/N" but that
always opens you up to a ton of users getting screwed out of coins and I
don't think it should be enabled, except in bitcoind, and since the main
target of this whole alias system is bitcoin-qt users, well...

@_date: 2011-12-17 11:15:46
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Pubkey addresses 
Under no circumstances should the use of firstbits ever be supported.
It doesn't scale, not even close, especially as we (hopefully) move
towards SPV clients.  Also, it provides incentives for people to spam
the chain to get a firstbits address.  Never should that be supported.

@_date: 2011-12-25 13:15:22
@_author: bitcoin-list@bluematt.me 
@_subject: [Bitcoin-development] IMPORTANT: if you are running latest git 
Couldn't your net testing code be modified to do that to some extent?

@_date: 2011-12-30 01:02:22
@_author: Matt Corallo 
@_subject: [Bitcoin-development] upnp isnt working 
I believe the issue isn't lack of working, but lack of re announcing to
the router that the port needs to remain open.

@_date: 2011-07-01 02:07:18
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.3.24 
Due to the flood control limits becoming an issue again, it would appear
we need a 0.3.24 release.  The idea is to have sipa's flood limit fix
( dnsseed on by default, and maybe UPnP enabled by default as well.
I just got a DNSSeed up with reliable hosting which dynamically fills
its hostname with random nodes known to be up and accepting connections
(and on port 8333 and on version 0.3.19 or higher) (dnsseed.bluematt.me)
and I hope others follow suit with
 (its poorly done but works just
fine).  This was added to master in 44d16327. Since its no longer a
static list, I think its time to enable dnsseed by default (I have one
or two connections by the time the GUI opens when I use -dnsseed
Also, I think UPnP by default would be a good idea as it could increase
the percent of nodes which accept incoming connection (and other P2P
applications which depend on the ability to accept incoming connections
have it on by default as well, such as Skype).  Jgarzik has also
suggested this, and I really dont see much of a reason not to.
 should be included to fix the no-connections-up segfault.

@_date: 2011-07-01 14:40:16
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.3.24 
Not sure about OS differentiation, seems...wrong?  Maybe disabled by
default on bitcoind but on by default on bitcoin?

@_date: 2011-07-01 18:25:27
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
1) Native Long Polling Support
Not sure about this one, it would be useful, but preferably done once
Bitcoin is cleaned up anyway. A probable good way would be a central
notification interface which net, wallets, etc all connect to, including
things like a pool server. Thus I'm not sure about merging something
like this now.
2) A fix from Luke Dash Jr.
His branch is at
 and I would say it would be good to merge. gmaxwell indicated that hes been running this for a while and it is stable.
3) Hub Mode
Why? We dont have enough nodes listening to begin with, this generates a
ton of net usage on other listening nodes, which is not good. If you
open up your ports, you will get just as many, if not more connections
very easily.
4) RPC Turbocharge
Yep, this is something that is needed, there is also the other asio pull
request on github, not sure how/if these compare.
5) Resource Leak Fix
Looks good to me.

@_date: 2011-07-01 19:50:40
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.3.24 
Totally agree it really shouldnt be a vote, in the end UPnP is bad for
an individual (more bandwidth usage, etc), but good for the network.
That means people will vote against it, but in the end someone has to
make the tough decision and turn it on.
Also, bitcoind is prebuilt in the daemon folder on the download archives
(though Im not sure about OSX)

@_date: 2011-07-02 00:03:37
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.3.24 
It would appear that we are all explaining why we agree...so, can we get
ACKs on UPnP by default on bitcoin and disabled by default on bitcoind
from everyone (specifically Gavin), as well as ACKs in general on 0.3.24
coming out with the originally listed things?

@_date: 2011-07-02 02:46:18
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.3.24 
Personally, I have little preference, sipa and gmaxwell fall on the side
of cherry-pick, but I think it might be good to do a broad-base test of
CWallet in 0.3.24 so potential bugs can be found in it before crypto and
0.4. In either case, I dont think we should spend too much time as this
is just a minor update release, just get it out the door so we can focus
on 0.4 (hopefully) without interruption.

@_date: 2011-07-02 03:12:51
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.3.24 
No, a bug was found where it no longer opened ("Error: unable to load
wallet.dat") when the ~/.bitcoin folder was empty/not present.

@_date: 2011-07-02 13:30:14
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Reconsider build system change? 
I dont think anyone really made a conscious decision one way or the
other, someone submitted an autotools patch and thus people started
talking about when we were going to merge autotools.  That said, the
autotools stuff needs redone before it would be merged anyway. So it
would be up to whoever writes the build system. However, autotools is
more standard than CMake, and since its a shell script, you dont have to
install CMake which doesnt come standard on almost any distros (AFAIK).

@_date: 2011-07-03 03:58:40
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.3.24 
Sorry this took so long, I got distracted...
Anyway 0.3.24 RC1 builds available at
bb829e037aef86c5d9da384c0ff3c91ce8b11d5a  Bitcoin 0.3.24 RC1.tar.bz2
Builds gitian signed and email signed as always.
Couple things need fixed up before release wrt build engineering:
 (still haven't had a
chance to dig up a copy of Win98 and spin up a VM to test any results of
this one).
Build on Ubuntu 8.04 instead of 10.04 so that oder libcs can work (and
do thorough testing of that resulting binary on newer libcs specifically
openSUSE 11.04, see  )
Sorry to hold up release on this crap that is still unfixed after

@_date: 2011-07-04 19:52:53
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Encrypted Wallet Backward Compatibility 
joric rightly points out that there are currently backward-compatibility
issues with Wallet encryption. As it stands now:
In version 0.3.23, Bitcoin dies with "ReserveKeyFromKeyPool() : unknown
key in key pool" after writing one unencrypted private key to the
(otherwise) encrypted wallet.
In version 0.3.22 (and I'd assume prior versions as well), Bitcoin opens
fine and displays transactions, however shows a total balance of what is
help only in unencrypted keys (of which it also writes a minimum of one
before opening), and each transaction shows only confirmation count,
date, no description, and a debit/credit of 0.00.  When you try to
perform any action which attempts to read keypool, you get the
"ReserveKeyFromKeyPool() : unknown key in key pool" error.
So, the question is how best to work around Bitcoin's overwillingness to
load wallets with keys that it has no clue about.
There were several suggestions of renaming wallet.dat for encrypted
wallets.  Obviously this has many advantages and disadvantages.  It
breaks backup scripts, old clients will now create a new wallet instead
of using the old one, potentially causing users to (wrongfully) assume
their wallet is encrypted if they accidentally start opening an old
version.  Im not a huge fan of this one, mostly because if a user opens
an old version, they will get a blank transactionless wallet which IMO
is worse than an odd error message.  "My wallet is gone, Ive lost
everything, wtf???" vs "My wallet got corrupted, crap need see what I
can recover from it, I hope I dont lose much"
Another option is to simply do nothing, and let old clients get mad.  If
a user goes back to an old client, it cant spend coins using the
encrypted keys no matter what is done.  If the new client handles
multiple key types gracefully, however, it can simply say "Hey, I see
you have a mix of key types here, can I have your password to encrypt
the unencrypted ones?" and move on with no harm done.  IMO, I would much
prefer old users see error messages and be unable to use their wallet,
then accidentally create multiple wallets, and give them a screen making
them think their coins are all gone.  Comments?
PS. to prevent this in the future, Bitcoin really shouldn't continue on
as if nothing had happened when faced with unknown keys:

@_date: 2011-07-04 22:39:32
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Encrypted Wallet Backward Compatibility 
For some reason my mail client let me respond off-list here, didnt mean
Not strictly true, if the keys are loaded, but not added to
mapAddressBook or setKeyPool, they wont be used for any new
transactions, or shown to the user, but the user is still able to
receive Bitcoins to those keys.
Not really, most backupwallet-based scripts will backup wallet.dat,
encrypt wallet.dat, upload wallet.dat.  Now it backups up wallet.dat and
the encrypt part fails because there is no wallet.dat, only
wallet_e.dat.  If we rename to wallet.dat on output, now the user's
restore might not work...
True, but that is only a solution for Linux and Mac and then you are
back to unreadable error on Windows load and other unforeseeable errors
for odd scripts.
I suppose I just really dont like the idea of renaming wallet.dat,
everything knows the filename and is used to it.
Yep, just something simple that says, no reading this to old versions is
needed, IMO the older version should freak out if it sees keys that it
doesn't know about (as it could also indicate wallet corruption in some
rare cases), but nMinVersion works just as well, in any case this should
only very rarely be a problem...how often will we change the wallet

@_date: 2011-07-05 03:10:39
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Encrypted Wallet Backward Compatibility 
Despite this being quick, I really want to get 0.3.24 out and rolling so
that we have us much lead time on 0.4 as possible so that any solution
to this problem that is better in 0.3.24 can be in as many hands as
possible, and so that the network issues can be resolved.
All that needs to happen for that is to agree on either
 or
 thus, I would ask that we
get acks on those and then continue this discussion.  Frankly, I prefer
378 as it is simpler and means that you dont have to keep track of what
features you have or have not used in a wallet, but instead just write
and let the keys take care of themselves.  However, I'm game for either,
I just want to get 0.3.24 out the door ASAP (ie preferably rc2 tomorrow
and release by the end of the week).

@_date: 2011-07-06 02:56:35
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.3.24 RC3 Build 
0.3.24 RC3 tar uploaded to I still disagree that 0.3.24 shouldn't handle incompatible wallets
cleanly, but I digress.
af85f46201bfffaf38fe4d64f3aa357ac03b51e1 Bitcoin 0.3.24 RC3.tar.bz2
gitian-win32.yml is broken (my fault) just remove the lines
  cp WSPiApi.h $HOME/build
  #
and you should be on the same one as me.
Build gitian signed and email signed as always,

@_date: 2011-07-10 16:21:17
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Encrypted Wallet Backward Compatibility 
At Luke's suggestion, I did a bit more digging and was able to find a
data structure in wallet settings that should cause all versions (well
all versions since Bitcoin was in github, and probably before then) to
crash on load instead of making a new wallet or opening in some bizarre
half-state.  I just put an empty object in addrIncoming (nfc what it was
used for, but it will get the desire effect and it isnt used anywhere in
the code aside from its definition).
You can see the commit at
Does anyone disagree and think a different solution would work better?
This resolves all known issues and suggestions that I know of on newenc
except for the invalid mlock calculations, which I will go fix right
now.  So...aside from that bug does anyone have any remaining
suggestions/blockers on newenc and, if not, can we get final ACKs on it?

@_date: 2011-07-10 21:12:12
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
No, no, no, no, no.  This has been discussed several times and provides
little to no advantage for miners and has the potential to severely harm
the network.
Some form of patch that implements these does need to be pulled soon, I
would say 0.4.1 or maybe sooner.
Seems to be a feature for such a minority that until the codebase is
cleaned a ton we shouldn't add features for small minorities.  We have
seen even one or two line patches cause regressions so I, personally,
think we should really focus on cleaning the codebase (CWallet was a
great start) and then add all these minority features once the backend
stuff is really clean and efficient.
Yes, should be in for 0.4 and I think there is a pull request for it.
I think there is already a pull request, which should be merged for 0.4
Seems like you are the only one who would benifit here, as noone else
but eligius changes coinbase output to a random set.
We don't need something that just generically changes the functions to
allow whatever fee you want, we need something more generalized to allow
more custom settings, not just blind accept if fee is x per kb or
something.  Sipa has suggested various things that should allow for more
fee control by the users while still preventing users from sending
transactions that lock their coins in limbo.
No, and no.  Just because you are willing to accept lower fees doesn't
mean the incentives are right to prevent DDoS.  The fees aren't there to
support the miners (not for a while, at least) they are there to prevent
stupid users from DDoSing and just generally wasting everyone else's
resources for no reason.
These are cool numbers to know, but I'm not sure if they have any real
uses making them just useless feature creep.
URI support would be nice.

@_date: 2011-07-11 00:58:30
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
Read what I wrote again, and don't reply off-list.

@_date: 2011-07-11 01:36:53
@_author: Matt Corallo 
@_subject: [Bitcoin-development] overall bitcoin client code quality 
Yep, anyone with the time can gladly comment up the code, it would be
much appreciated, but as it stands now there are more important things
to do...like many of the things here:
Yes, thats one of the general development goal, sipa's CWallet was an
excellent start, but much more work needs done in terms of clear
splitting of the code.
My bad, was just following the previous comments...
At the time Bitcoin began being built, Ubuntu 9.04 (or was it 9.10?) was
used, as it offered the oldest libc on the newest OS.  Ubuntu 9.04 just
happened to only have db4.7.  For backward compatibility, db4.7 has been
used ever since (except, for some reason, the osx builds).  In 0.4,
db4.8 will be used.  If you are asking why bdb was used to begin with,
why not? its an excellent db and why reinvent the wheel?
Though satoshi was clearly brilliant, he didn't care much for code
cleanliness.  This is one of the next development goals (IMO).
This is something that will come with general code cleanup and
modularization.  The locks will become specific to the object (as they
should be) and the performance and clarity will be fixed.
Though it would be ideal to rewrite 90% of Bitcoin just to fix code
clarity, that is way more work than anyone has time for, in the mean
time there is more than just code cleanup that needs done.  It has to be
done in chunks.
Header files could stand to be cleaned up a bit, though all the
implementation stuff is limited to one or two lines (though sometimes
thats too much).  If you want to rewrite Bitcoin sans-boost, please do,
however Boost really isnt a huge barrier as its a build-once thing.  If
you are on Linux, all you have to do is install a bunch of packages and
build wx.  If you are on Windows, why are you on Windows? ;)
Its not due to the current coders, its due to how it was originally
This one is an interesting debate.  There is no real reason to do this
aside from some questionable code cleanup.  Also, there is no reason to
encourage improperly-implemented alternate chains.  Alternate chains
should be designed in such a way as to share the main chain's difficulty
as described by Mike on the forum, not just make a new chain and hope it
Really no reason to do that.  Although the code is messy in terms of
global usage and poorly-implemented RPC/net/etc, most of the code is
absolutely fine.  Just throw it in clearly-defined methods and classes
and it would be much more readable and less prone to mistakes.
Additionally, the things that are poorly-implemented can be slowly
changed over time in a clean and independent fashion instead of having
to rewrite massive chunks at a time.  Even if we had a full-time
development team of many, many developers, this isn't the right way to
do it.  The code itself is cleaner that it first appears, even if its
global structure is not.
True, but it is much higher priority to clean up the code than comment
it better, plus there are various other features/more user-facing issues
that need fixed as well, so...
Don't think so, the code sucks in terms of cleanliness, everyone knows
it, its just a question of who is going to and when its going to get

@_date: 2011-07-13 02:17:59
@_author: Matt Corallo 
@_subject: [Bitcoin-development] overall bitcoin client code quality 
I had been planning on, and putting off starting work on, a central hub
infrastructure to Bitcoin until fairly recently.  Its a central hub
where net/main/wallet/etc can subscribe to get notified of new
blocks/txes/etc, push new blocks/txes/etc and can get information about
blocks/txes/etc.  I started work fairly recently, but hopefully it will
be functional sometime in the not-too-distant future.
As I said earlier, the Bitcoin code base really isn't all that messy,
its only its lack of clear lines between classes that makes it seem that
way.  It does some things inefficiently, however its general algorithms
are quite good the way they stand.  (though net could probably stand a
ground-up rewrite of the backend).  If you want to rewrite for a more
optimized handling of p2p connections/etc, it would be apprecitated and
(assuming its done well) certainly merged.
I can't speak for satoshi here, but I would agree with his decision on
the grounds that BDB offers a good mix.  Compared to a sql-driven
library, it offers a much lighter-weight footprint.  Compared to rolling
our own, its much, much simpler to use the existing code that people
have spent years writing/optimizing/fixing/etc.  It also provides good
Database transactioning which Bitcoin does depend on on some (rare,
though hopefully less so as time goes on) circumstances.
Interesting might have been the wrong word.  Let me rephrase that too
"of hot topic if you ask several people who incessantly create new
chains for no reason other than to create new chains".
Neither the original client nor any other client or patch currently
implements work-sharing, I don't think you understood my statement here.
I was referring to Those parameters are available, though I don't think they show up in
--help output.  If someone had the time to go back and document the
parameters not in --help, it would be much appreciated ;)
That is yet another debated issue.  The transaction (relay) fees are
there for a reason much more than just for the hell of it.  If
transaction (relay) fees were easily changeable, they would serve no
purpose as they would all be set to 0.  Transaction fee handling needs a
rethinking and recoding, but offering each user the option to just relay
every transaction off the wire is not an option.
That was not at all the point of that comment.  Trying to fix bugs on an
old codebase while rewriting a new one is worthless and just creating
way more effort than is necessary.

@_date: 2011-07-14 16:13:04
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Notifications from client/wallet 
This sounds cool, I started implementing the other half of this a couple
days ago.  My broad idea of a source cleanup (that sipa largely wrote)
is to have a central notification interface which wallet(s)/net/block
store/etc all communicate with, and then an interface, like the one
proposed here, which GUI/RPC/etc use to communicate with wallet/net.
This should allow for very clean separation of pieces and large-scale
rewrites of one or another part (or drop-in replacements) without
touching anything but the parts that are being redone.  This should also
allow for cool programs (like pushpoold/a block notification server/etc)
to use Bitcoin as a library fairly efficiently.

@_date: 2011-07-16 12:54:39
@_author: Matt Corallo 
@_subject: [Bitcoin-development] The forums... 
If we had the moding power, yes, but we don't have nearly enough people
who could mod such a forum.

@_date: 2011-07-17 12:46:20
@_author: Matt Corallo 
@_subject: [Bitcoin-development] The forums... 
Its not that people dislike the forums or dislike having the forums.
Its that they are giving bitcoin a very, very bad name with all the
illegal crap, etc in them to the point of even possibly creating legal
risk in the future.  So its best that the forums are marked as
unofficial and not part of Bitcoin proper but just some group of kids
who for some reason think Bitcoin is good for their drug-buying habits.

@_date: 2011-07-26 03:35:56
@_author: Matt Corallo 
@_subject: [Bitcoin-development] bitcoin DNS addresses 
Using URIs is much simpler and can be more useful in terms of being able
to give different addresses and/or values per user.
Also, despite DNSSec being "out there" DNS is still very insecure to
transmit something that will result in money transfer...some idiot tries
it on public WiFi and a MITM steals your coins...DNS is really just not
well suited for this kind of thing.
If you want nice name->address mapping, a simple HTTPS server with
addresses and client support (there are some patches around for this)
works much better in the end.

@_date: 2011-07-26 15:23:39
@_author: Matt Corallo 
@_subject: [Bitcoin-development] bitcoin DNS addresses 
Yes, DNSSEC is great if you are running your own recursive name server.
However, that is probably something like 0.01% of the people out there.
If this were to be made secure, one would have to implement a full
recursive nameserver inside of Bitcoin with the root trust anchors
hardcoded in.  This seems like way overkill to do name->address mapping.
(My attack scenario here is coffee shop wifi with the default DNS
resolvers being somewhere at the ISP and a ARP (or other) MITM attack
intercepting and playing with your DNS queries).
Additionally, HTTPS mapping offers some advantages such as ease of
offering up different to different people by eg. IP address (could be
done by setting DNS TTL to 0 and assuming all users will be using a
built-in resolver, but its still not guaranteed that other clients would
use a built-in resolver and then the IP of the resolver is not the same
as the IP of the Bitcoin node).  Not that DNS is a terrible idea, but there are clear advantages for
using HTTPS (or similar) mapping over DNS and I see no clear advantage
for using DNS over HTTPS (aside from the "that is what it is designed
for" argument, which I would claim is an invalid argument as you have to
consider the technology, not its intent).
Hold on there, Bitcoin is still tiny, I highly, highly doubt it will
make a difference to DNSSEC adoption.

@_date: 2011-07-26 18:24:36
@_author: Matt Corallo 
@_subject: [Bitcoin-development] bitcoin DNS addresses 
For some reason my mail client is being thick and not responding
on-list, sorry about that...
If you are using a self-signed cert to do any kind of important data
transfer you are just being stupid.  Here I am assuming your computer
isnt actually compromised, but only the network is, which I think is a
fairly good assumption.
No, DNSSEC is very well done, this thread is specifically about the
security implications of using DNSSEC for Bitcoin address communication.
IMO it is not a good idea, as for it to be secure against a coffee-shop
network MITMer you have to implement a full resolver with root trust
anchors and knowledge of root servers in Bitcoin, which does not seem
like a good idea.
I totally agree, however I don't think DNS-based resolving is a good
idea here.  HTTPS does have several advantages over a DNSSEC-based
solution without any significant drawbacks that I can see.

@_date: 2011-07-26 19:18:27
@_author: Matt Corallo 
@_subject: [Bitcoin-development] bitcoin DNS addresses 
That is one point, but yes.
Because it allows for the giving of different addresses to each client
based on IP much easier.  Its possible with DNS by setting TTL to 0 and
hoping that Bitcoin clients will be using their own resolver, but that
is far from guaranteed.  Additionally, HTTPS stuff has already been
coded and implemented, so there's that...
Frankly, HTTPS' advantages are very small here, but since they exist,
and DNS has no advantages that I can see, I don't see any reason to go
with DNS here.  I much prefer using a HTTPS library (of which there are
many which have had much more thorough security audits) than a
DNSSEC-implementing DNS recursion library with the root trust anchors
and root servers built-in (are there any?).
Maybe I'm missing something here?

@_date: 2011-07-26 19:18:42
@_author: Matt Corallo 
@_subject: [Bitcoin-development] bitcoin DNS addresses 
That is one point, but yes.
Because it allows for the giving of different addresses to each client
based on IP much easier.  Its possible with DNS by setting TTL to 0 and
hoping that Bitcoin clients will be using their own resolver, but that
is far from guaranteed.  Additionally, HTTPS stuff has already been
coded and implemented, so there's that...
Frankly, HTTPS' advantages are very small here, but since they exist,
and DNS has no advantages that I can see, I don't see any reason to go
with DNS here.  I much prefer using a HTTPS library (of which there are
many which have had much more thorough security audits) than a
DNSSEC-implementing DNS recursion library with the root trust anchors
and root servers built-in (are there any?).
Maybe I'm missing something here?

@_date: 2011-07-27 18:47:22
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Seeking advice: Encouraging bug-fixing 
Gavin leads the effort just fine (when he's not on vacation or in
Australia...) but I do agree with paying him, though I'm not sure how
much time he has to spend on development over PR and other
project-building efforts.

@_date: 2011-07-28 01:07:39
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Seeking advice: Encouraging bug-fixing 
I do think it would motivate some people to fix a bug or two, though I
would say it wouldn't encourage long-term contributors, just a bunch of
hacked together patches which "fix" a bug.
I know jgarzik hates the idea of branching for releases, but quite a few
projects do that, and it seems to work fairly well.  I would support the
idea of starting with 0.4 and branching for bugfixes to an 0.4 branch,
then adding new features to a head branch to be eventually called 0.5.

@_date: 2011-07-28 13:21:06
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Bitcoin components. 
Yay, yet another person who wants to write their own client from scratch
who will get the net code done, work a bit on wallet code and move on to
something more exciting.  Seriously, at this point it seems everyone and
their mother are writing their own, or planning to write their own,
Bitcoin's code actually can be fairly well segmented into the necessary
pieces (CWallet was the first big chunk, more are coming) and comments
are being added as a part of that effort.
The current code is much, much more trustworthy than anything someone
new will start to code, even if they have 20 lines of comments for each
line of code.  If you want to help the project, please dont write yet
another new client library, just look for an existing one you can help
with, or help with the original client.

@_date: 2011-07-28 21:28:29
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Forking personal "vanity" versions... 
Seriously? This is the very reason most people dont use the forums
anymore.  This is just a one-off email that says nothing, doesn't ask a
question doesn't make a statement, and doesn't do anything remotely
useful, keep this kind of crap to yourself.

@_date: 2011-07-30 16:07:01
@_author: Matt Corallo 
@_subject: [Bitcoin-development] bitcoin DNS addresses 
That was my point, it already has been written...twice IIRC.

@_date: 2011-07-30 16:07:54
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Seeking advice: Encouraging bug-fixing 
We already have boost testing framework implemented, it just doesn't
have many tests.

@_date: 2011-07-31 14:24:10
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Unit tests 
============================== START ==============================
See pull 363 and 442 :)
From witchspace81  Sun Jul 31 12:46:54 2011
Great. I really hope these get pulled ASAP, having the tests all over the
place in different forks is really confusing :(

@_date: 2011-06-27 03:20:23
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [PULL] Wallet Private Key Encryption Take 3 
Rebased onto wallet class and ready for "wtf is this crap" messages ;)
Matt

@_date: 2011-06-28 03:33:46
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [PULL] Wallet Private Key Encryption Take 
OK, after a lot of good discussion and a tiny bit of results, I would
submit that Wallet Encryption is in a pull-able state.  Can I get final

@_date: 2011-06-28 13:54:31
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Fwd: Live mtgox.com trade matching bug. 
And this is also no where near the right place to be disclosing security
vulnerabilities.  Whether you like the guy/site or not, keep those prive
for a reasonable amount of time for them to be fixed (that means more
than an hour).

@_date: 2011-06-28 21:50:28
@_author: Matt Corallo 
@_subject: [Bitcoin-development] satoshi client v0.4 priorities 
============================== START ==============================
I believe he meant rebase onto wallet encryption.

@_date: 2011-10-05 10:37:55
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Mac libboost_thread or thread-mt? 
The -mt suffix means built in multithreading aware mode (what this means
for a threading library I have no idea), however that suffix was removed
from Linux and Mac builds in 1.42.  If you are linking against 1.42+ on
Linux/Mac, adding/removing the -mt suffix means nothing AFAICT.

@_date: 2011-09-06 23:51:05
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Testing commits 
When did it switch from 0.4 to 4.0?
I feel like the user-facing quality of the software should not be
over-emphasized when it really is very beta in quality.
 (a bit outdated, but it
should still work fine)
If the instructions were updated with fresh links/versions/etc, they
should work 100%.
No package needed, just apt-get the relevant packages?
doc/build-unix.txt is (though in some cases somewhat ubuntu-specific)
quite good IMHO.
If you are feeling lazy, I can convince jenkins.bluematt.me to churn out
windows and ubuntu builds almost identical to those that will come out
of gitian (ie the same build as the official release builds) if you
Something like the current jenkins scripts could also be easily hacked
up to automatically sanity-test pull requests as they come in and catch
common errors (or just sanity failures).

@_date: 2011-09-08 11:20:42
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Alert System 
The alert system requires a signature verification when it receives an
alert, but so do blocks and transactions so it really isn't a DoS target
(remember that the alert system requires alerts to be signed by a key
that only gavin and satoshi have).
The alert system could prove very, very valuable.  In much software it
carries the risk for abuse or simply seems wrong that the developers can
send a message to everyone's computer to notify them of something, but
keep in mind that Bitcoin is financial software.  If there is an urgent
problem (like the overflow bug) there must be a way to notify people to
upgrade immediately, which is exactly what alerts provide.  Since alerts
no longer carry the ability to put Bitcoin into RPC safe-mode, they are
literally just a message and I see no reason why they should be removed.

@_date: 2011-09-08 11:20:42
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Alert System 
The alert system requires a signature verification when it receives an
alert, but so do blocks and transactions so it really isn't a DoS target
(remember that the alert system requires alerts to be signed by a key
that only gavin and satoshi have).
The alert system could prove very, very valuable.  In much software it
carries the risk for abuse or simply seems wrong that the developers can
send a message to everyone's computer to notify them of something, but
keep in mind that Bitcoin is financial software.  If there is an urgent
problem (like the overflow bug) there must be a way to notify people to
upgrade immediately, which is exactly what alerts provide.  Since alerts
no longer carry the ability to put Bitcoin into RPC safe-mode, they are
literally just a message and I see no reason why they should be removed.

@_date: 2011-09-08 12:16:51
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Alert System 
Gavin does
Meh, why make the key-holder send out two alerts for old clients and new
clients.  I also highly doubt satoshi would let his key get compromised.
That said, keep in mind they are literally just messages, they make no
functional difference.

@_date: 2011-09-09 19:49:17
@_author: Matt Corallo 
@_subject: [Bitcoin-development] 0.4 Release Candidate 2 
I'm too lazy to make nice tars so here is the raw gitian output (I plan
on working out gitian-downloader stuff sometime in the next couple
Also, setup exe still not deterministic so theres that...
fd886d79bf48ba0d90f2f99fdd19d96946662bf5  bitcoin-ubuntu-v0.4.00rc2.zip
703712859ecdce423020116ebf65d087b179997d  bitcoin-win32-v0.4.00rc2.zip

@_date: 2011-09-23 00:57:06
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Bitcoin 0.4 Release 
Gavin tagged 0.4 release today, so here are my gitian builds.
These zips are in gitian-download format which means they can be
automatically downloaded and pgp-verified using the gitian-updater
script (see
 Currently they only contain my sig, but if other devs have time to gitian build and re-roll the same zip with other sigs added as well it would make updating via gitian scripts easy and secure :).
3794ec0ce8a3ea96200b3970937c5f224313267d  bitcoin-0.4.0-linux-gitian.zip
a4857b2238a102d8f4ba9a2bdfed74ddd985ad3d  bitcoin-0.4.0-win32-gitian.zip
Email PGP signed as always.

@_date: 2011-09-27 14:56:18
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Pull request for translation - who 
Most developers treat the forums as write-only or just ignore them all
together, they are way too full of junk to bother reading.
Translation updates are pretty much just blindly pulled unless someone
opposes. No one is responsible for translations in Bitcoin, though it would be
nice to have people agree to keep their translations up-to-date when
they submit new ones...
Anyone can make a pull request, people who can push to the bitcoin repo
(ie can pull a pull request) are Gavin, tcatm, sipa, jgarzik, and

@_date: 2012-08-15 02:26:31
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Bloom Filter Implementation 
I spend some time implementing some of the changes discussed in the
previous thread "New P2P commands for diagnostics, SPV clients", and
wanted to field comments before I write up a BIP.
I have implemented a simple bloom filter that works on transactions as
well as a new block relay type which relays blocks as header+coinbase tx
+vector which allows for faster relay for clients which already
have transactions in memory pool.
In order to request that all future MSG_TX inv messages and blocks (only
those relayed in the new format) are filtered, SPV clients will send a
filterload message with a serialized bloom filter.  Nodes can also send
filteradd messages which add particular data blocks to the filter (not
recommended for anonymity) and call filterclear which disables filtering
on a node's connection until re-enabled.
The filter will match any tx which:
     1. Has a script data element in either a scriptPubKey or scriptSig
        which matches the filter.
     2. Spends an input who's COutPoint is in the filter.
     3. Has a hash in the filter (see  for why this matters).
     4. Has a script data element in a prevout's scriptPubKey.  This
        allows for matching pay-to-pubkey transactions without sending a
        new filter after each transaction which matched (which would
        cause some nasty timing issues where you may miss transactions
        if you get transactions back-to-back before you can send a new
        filter).  Matching of prevouts only occurs on free txes, not
        those in blocks.  Thus, before requesting a block, SPV clients
        should update the remote node's filter, if required, to be sure
        it includes the hash of any transaction which would not
        otherwise match the filter so that the node knows when its
        transactions are included in blocks.
I can't say I'm a big fan of requiring SPV nodes constantly update the
filter when they learn about new transactions (could get nasty during
IDB, if the node has a lot of transactions, as you could end up
re-requesting blocks many times), but I really don't think its worth
loading all prevouts when a node is in IBD to fix it.
The branch can be found at

@_date: 2012-08-20 12:06:14
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Warning to rawtx creators: bug in 
If you are playing around with the current rawtx API, be careful using
When parsing a transaction input, which uses a SIGHASH_SINGLE signature,
and the given input's index is >= the total number of outputs in the
current transaction, bitcoind doesn't sign anything useful, it signs the
constant 1.
Thus, if anyone were to create such an invalid transaction, any future
outputs to the public key which created the signature would be
immediately steal-able by anyone.
The conclusion on how to fix the issue was to fix the rawtx API to block
such transactions instead of creating a hardfork-risk or further
complicating transaction verification.
Code (in script.cpp:SignatureHash, under SIGHASH_SINGLE):
        if (nOut >= txTmp.vout.size())
        {
            printf("ERROR: SignatureHash() : nOut=%d out of range\n", nOut);
            return 1;
        }

@_date: 2012-02-04 12:15:02
@_author: Matt Corallo 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
I changed the description of the message parameter to be a bit more
descriptive, however, I dont want to change the name of the parameter
because some clients have already implemented that and I really prefer
to make as minor of changes as possible to this BIP even if it is
officially only a Draft.

@_date: 2012-02-29 17:38:13
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Duplicate transactions vulnerability 
In other words when we roll out the update, we have to make sure we have
other words we just have to be very, very vocal about the change when it
happens and make sure miners are all on board.

@_date: 2012-01-02 13:24:12
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Meeting 21:00 UTC #bitcoin-dev Freenode 
Because many made the mistake and it isnt specified in this email, this
meeting is tomorrow (not 30 minutes ago).

@_date: 2012-01-27 19:36:31
@_author: bitcoin-list@bluematt.me 
@_subject: [Bitcoin-development] BIP 0020: URI Scheme 
It was implemented in the waylaying client with the merge of Bitcoin-Qt for drag and drop, and just recently for system URI handling in  However the version on the wiki armed as BIP 20 has a ton of extraneous crap in it's number encoding which is not implemented in Bitcoin-Qt since it was explicitly voted against at the time the spec was being discussed. If that stuff were removed, I would agree that it is final.
It's been Final (even according to BIP 1 standards) since late January 2011. The only change recently is assigning it a BIP number for formality.
Once P2SH is deployed, it will probably make good sense to revisit the URI Scheme for revision, and eventually move BIP 20 to Replaced/Superceded status.
Try before you buy = See our experts in action!
The most comprehensive online learning library for Microsoft developers
is just $99.99! Visual Studio, SharePoint, SQL - plus HTML5, CSS3, MVC3,
Metro Style Apps, more. Free future releases when you subscribe now!
Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net

@_date: 2012-01-27 21:12:11
@_author: bitcoin-list@bluematt.me 
@_subject: [Bitcoin-development] BIP 0020: URI Scheme 
I'm really not gonna reopen this debate.  You made a poll that was worded in the most biased way I could think of and still lost.  The multiple implementations were written but you and I know of no sites that actually had links to your version.

@_date: 2012-01-29 18:02:30
@_author: Matt Corallo 
@_subject: [Bitcoin-development] All pre-BIP BIPs are not valid 
I have to say, I agree with Luke here, this was Finalized a long time
ago.  The version that was agreed on can be seen at
Also see  and Luke's three
biased polls at

@_date: 2012-01-31 11:04:59
@_author: Matt Corallo 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
The send crap was not in the original spec, is not implemented anywhere,
and should have been removed as part of the BIP 21 copy/paste.  It is
now gone.
As for the expire time, well thats a bit problematic IMHO.  Technically
BIP 21 is still a draft, but it is implemented in all versions of
Bitcoin-Qt for drag and drop and adding a field which restricts the
validity of a URI for new clients, but which old clients will gladly
accept could result in some ugly situations IMO.

@_date: 2012-01-31 13:22:25
@_author: Matt Corallo 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
OK, so I just did some heavy changes to the methods for forward
compatibility in BIP 21.  Instead of a version number, now new variables
will be added either as-is or with a mustimplement: prefix.  If a
clients does not know what the variable is that is after mustimplement:,
it should consider the entire URI invalid and either notify the user or
just drop it silently.  That way things like expiretime can be added
without worrying about old clients ignoring the field.  All that said, I dont think its an ideal solution, depending on the
names of variables to provide information is ugly.  If anyone has a
better idea on how to do backward compatibility, please suggest it.
In terms of the expiretime field being implemented now, I dont think its
appropriate.  Because some clients already have an old implementation,
the possibility of it getting ignored is too large.  The BIP now states
that "It is recommended that additional variables prefixed with
mustimplement: not be used in a mission-critical way until a grace
period of 6 months from the finalization of this BIP has passed in order
to allow client developers to release new versions, and users of old
clients to upgrade."  Mostly, however, I want to keep the list of
changes from the Bitcoin-Qt implementation to this BIP very, very
minimal this late the 0.6 release cycle (I want to get this BIP
finalized and implemented for 0.6, so that at least Bitcoin-Qt will have
no version which support OS URI opening with a broken implementation).

@_date: 2012-01-31 16:42:48
@_author: Matt Corallo 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
OK, I went ahead and changed mustimplement out for req (required).  Its
not quite as expressive, but its much shorter and still makes sense
(IMHO).  I also explicitly stated that numbers shouldnt contain commas
and should use period to separate whole numbers and fractional decimal
fractions (to avoid any localization concerns).

@_date: 2012-01-31 17:47:57
@_author: Matt Corallo 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
============================== START ==============================
Odd, here I was thinking I checked that.  Just goes to show how useful
sources other than the rfc itself are... Anyway, Ill change it to a

@_date: 2012-07-23 18:11:43
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Coinbase script parse failures 
I mentioned this on IRC a week or so ago, noticing that though they are
not executed and required to be well-formed, we still count any sigops
that appear in them (which I guessed may be an interesting attack if you
could get a miner to put a byte in there that is the equivalent of
OP_CHECKSIG because we dont count the sigops in the coinbase scriptSig
during mining, however luke pointed out that we always push the content
of coinbase scriptSigs properly by default, and those modifying the code
should spend time researching this stuff anyway, so if they break it,
its their fault (and now they can find this email)).

@_date: 2012-07-23 18:40:36
@_author: Matt Corallo 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
AFAIK there was no implementation.  I pushed one for bitcoinj+bitcoind
today that compiles, but I haven't tested it much further (though its
really quite a simple implementation):
My implementation has yet to implement block filtering, for now its only
tx inv filtering.  However, its really not that complicated and doing a
scan of any individual transaction is very fast.  So during the download
phase, it really isn't much of any extra load on block chain providers
(aside from having to load inputs in the current implementation, but
that could be optimized some).
Though I like the idea of having a "give me all unspent outputs for my
pubkeys" command, I see quite a future for clients somewhere between "I
store nothing but pubkeys and don't know about the chain" and "I store a
full chain" and the bloom filters as described are pretty useful for
many clients in that in between.  Also, for clients that are "Really
lightweight clients" (given that they don't know about the chain) should
probably just stick with an electrum-style server-client system with
specialized servers (IMHO) instead of relying on P2P nodes to provide
them with a list of unspent outputs/etc.
In response to Mike's what-the-filter-should-match:
The way it is now, it just checks each input+output to see if the
hash160 of the dest addr, hash160 of the pubkey or hash160 of the p2sh
sh matches the filter as-is.
specific outpoint to a filter would be nice.
However, in terms of data elements in txes, Im not so sure.
Its by no means a bad idea, and it wouldnt be too much overhead, but
making filters match a very broad set of criteria seems like a bit much
to me, but maybe others disagree?

@_date: 2012-07-31 16:39:45
@_author: Matt Corallo 
@_subject: [Bitcoin-development] script tests - invalid script in 
============================== START ==============================
I wrote a simple block chain tester (that is capable of forking,
checking invalid blocks, etc) as a part of the bitcoinj test suite.  Its
more targeted at testing bitcoinj directly and keeping the bitcoinj test
suite light weight, so if it were to be more generic some tweaks could
be done (not requiring tweaking the minimum difficulty/genesis block
hash/etc would be first).  It doesn't have that many test cases yet, but
it is capable of sanity-testing reorgs/etc.  Its mostly the first two
commits listed at

@_date: 2012-06-15 15:08:55
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Near-term scalability 
The idea can be more generalized in that there are many cases where the
generator of a transaction doesn't care about confirmation times, and
would really be willing to make their transaction lower priority than
other 0-fee transactions.  This enables the first point with lower
confirmation times for a while longer.
As it turns out, we already have an indication that someone is willing
to wait longer for confirmations - rapid reuse of an address.  1) Green Addresses: The whole point of a green address is that you are
trusted based on your address, not necessarily based on confirmations of
your transactions.  In this case, you are generally willing to wait a
bit longer for confirmations than the average user depositing coins into
their Mt. Gox account.  2) Donation Addresses: If you are using a publicized donation address,
you probably aren't depending on getting your coins *now* to turn around
and ship a product and, again, you are a bit more willing to tolerate
longer confirmation times.
3) Lazy (or overworked) coders: If, for whatever reason, someone
designing a bitcoin site decides that it is simply easier to make users
pay to a single address for everything, such actions should generally be
discouraged.  Such a setup is worse for end-user privacy.  Also, such
laziness (or likely just overworked and not having time to fix the
issue) is likely also laziness across the board including ignoring
multisend for payouts.  If you discourage such address use forcing site
designers to implement more sane policies, hopefully they will do enough
research to also do multisend.  Note that though this is where one
addresses sites like SatoshiDice, its also the one where we are likely
to have the least impact...
One of the ways to implement such deprioritization of rapidly-reused
addresses is to limit the count of address re-uses by default in memory
pool.  By limiting relaying of such transactions, you a) give nodes
across the network some small say in the transactions which they have to
deal with relaying outside of blocks, instead of relying on miners to
make decisions which are good for the total network load, but which are
worse for them.  b) You allow sites which wish to re-use addresses to do
so initially to keep the time-to-launch the same as it is today, but
force them to re-think their design decisions as they grow to
(hopefully) decrease their impact on the average Bitcoin full-node
operator.  Sites which begin to see their transactions rate-limited have
several options:
1) Make a deal with a miner to feed them their list of now-non-relayed
transactions outside of the regular p2p network and have them manually
added to blocks.  Id argue that such setups are going to become more
common in the future and such out-of-band transaction relaying should be
encouraged.  This also shifts the delay for other transactions from a
constant delay getting into blocks until there is room for additional
0-fee transactions to a spike on each block from the given miner.  I
highly prefer this, as you would see usually only one or two block delay
getting your transaction confirmed at the worst case, instead of a very
fuzzy unknown delay that could stretch on for some time.
2) Use rotating addresses.  This is likely the simplest to implement,
and I would absolutely think this is what most sites would end up doing.
Though it doesn't result in a decreased load on the transaction-relaying
nodes, it does at least allow for a minor improvement in user privacy.  In the end, it boils down to an optional transaction deprioritization.
I think all of the above are largely no brianers to everyone.
Definitely something that is very appealing as we need to scale up.
My point was that the easiest way to do it would be to ship a pruned
snapshot with Bitcoin, and such a system, while verifiable, would
increase Bitocin's centralization.  Though it is quite possible to prune
the chain while downloading at checkpoints or when blocks are N deep, it
complicates the initial download if no one has the chain to begin with. Another point I made was that by doing chain pruning by default, we may
see a decrease in non-fClient nodes (for compatibility, I would assume
pruned nodes have to set fClient) which is what old clients look for to
connect to, possibly complicating using Bitcoin for clients that either
wish to run a full IBD or older clients which need a non-fClient node
before they are happy (which could be an issue when you look at the very
poor "upgrade-apathy" in the Bitcoin community with people running
long-outdated versions because they don't feel like upgrading).
All that said, I do believe pruning will eventually have to come to
encourage p2pool and other getmemorypool-based pool mining, but
(obviously) its something that needs careful consideration in its
overall effects across the network before its applied.

@_date: 2012-06-15 15:19:06
@_author: Matt Corallo 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
I believe its because it allows the node which will have to use the
bloom filter to scan transactions to chose how much effort it wants to
put into each transaction on behalf of the SPV client.  Though its
generally a small amount of CPU time/memory, if we end up with a drastic
split between SPV nodes and only a few large network nodes, those nodes
may wish to limit the CPU/memory usage each node is allowed to use,
which may be important if you are serving 1000 SPV peers.  It offers a
sort of negotiation between SPV client and full node instead of letting
the client specify it outright.
A series of CMerkleTx's might also end up redundantly encoding branches
of the merkle tree, so, yes as a part of the BIP/implementation, I would
say we probably want a CFilteredBlock or similar

@_date: 2012-06-15 16:39:44
@_author: Matt Corallo 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
IMHO it already is.  A node requests a filter using filterinit by
specifying the false positive rate it wants and a guessed number of
items.  The node which will have to hold that filter then responds with
the closest filter to what the SPV node requested that it is willing to
provide.  If the SPV node responds with a filterload command, it has
accepted the offer, otherwise it will simply disconnect and find a
better full node.  I'd much rather have an overloaded node respond with 50% fp rate filters
as an option if there aren't many full nodes available than simply
disconnect SPV clients.
At least thats my thinking, but you may be right that it is too heavy
for too little gain.

@_date: 2012-06-15 16:56:52
@_author: Matt Corallo 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
If vector is sorted in the order of the merkle tree, you dont need
to forward the merkle tree to non-filtered nodes, further saving some
small amount of bandwidth.  For filtered nodes, you would still need to
forward merkle branches anyway.
I really dont think it would be /that/ difficult to make it getmerkletxs
vector. And then respond with a partial merkle tree to those

@_date: 2012-06-15 18:18:36
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Near-term scalability 
Its arguably not a change to network rules as its something that users
can already do today by patching their clients.  Obviously any
implementation would have sane defaults which allowed for a significant
number of transactions to/from a given address at a time, avoiding
whacking random people unless they are large enough that they should
really already be fully aware of how bitcoin works.
I would think SD would switch to using fresh addresses for each bet.
But even that is a good thing, at least where user privacy is concerned.
However, I would hope that SD would see the rule tweak and, in order to
avoid having to generate a number of new addresses per second (or, if
they went the pool route, having a huge pool of many thousands of
addresses), they would consider implementing sendmulti support.
I agree, free transactions isnt something we should aggressively push as
a feature of Bitcoin, its simply not.  However, in the current system
free transactions are usually confirmed within a small number of blocks,
and for a number of users, that is an important feature that draws them
to get through the initial hurdles of converting money to Bitcoin and
understanding enough of the system to trust it.  I believe that if we
can incentive large transaction creators to avoid delaying free
transactions, we should and giving them the option to delay their own
transactions seems like a perfectly reasonable way to do so.  Even if
you drop all the per-address limit stuff, allowing transaction creators
to add a simple flag to transactions seems reasonable when they want to
encourage Bitcoin to continue to grow as it does today.  Obviously
keeping free transactions confirming won't be possible forever, but
hopefully that will be as a result of natural growth which can encourage
further growth without the need for free transactions and not as a
result of a few actors in the community creating a transaction volume
significantly greater than their user-base.
ACK, thats an important thing to implement IMO, but I really dont see it
as something that replaces the option to deprioritize your own
transactions to below 0-fee transactions.  It could even allow users who
receive payouts which are below 0-fee transactions to place a fee on the
subsequent transactions to allow the payouts to confirm quicker (if done
I would be surprised if more than a handful of devs audit such a thing.
And I would say that does define an increase in centralization.
Sadly, old nodes do not know where to look for such data, and I'm fairly
certain people running old nodes don't read the forums enough to catch
when it is announced that old nodes should make sure to
-connect=archive.bitcoin.org in order to avoid initially having horrible
initial bootstrap times and eventually not being able to connect to
full-chain-serving nodes at all.
Sadly, disk space isnt the issue.  Each connection to bitcoind (not that
it cant be fixed, but currently) eats a nice chunk of memory.  An
organization that wants to provide nodes for old nodes to connect to
would need to have a significant number of open incoming connection
slots, have plenty of bandwidth for nodes that are in IBD and have
plenty of memory and CPU to manage all the connections.
Sadly, BDB's infamous database corrupted messages appear all too often,
and the usual response is "delete the chain and resync."  I have a hard
time believing that old nodes will rarely be in IBD.  I agree that its very possible to have archival nodes available and to
make it work, but I have yet to see anyone doing any work to actually
get commitments to run archival nodes and I have yet to see any
discussion of what, exactly, that would entail.

@_date: 2012-06-15 18:20:27
@_author: Matt Corallo 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
I dont particularly care either way, but I have a feeling miners will
really want that so that they can get fee-paying transactions right

@_date: 2012-06-19 21:09:58
@_author: Matt Corallo 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
Agreed, I was largely giving a reason why one may want to negotiate the
filter settings in response to your question as to why it was done.  As
long as there are sane limits (you cant make a 1GB filter by specifying
0% fp and some crazy number of entires), filter negotiation largely isnt
worth it (also prevents any floats from appearing in the p2p protocol,
though in either case it shouldn't be able to cause issues).

@_date: 2012-03-22 01:24:11
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Adding callback hooks to the satoshi 
I spent some time changing the internal bitcoin code to use callback
hooks, but its far from complete (or even really usable from anything
other than the code in the satoshi client itself, it doesnt even have
any deregister methods!).  As it sits now, it is likely to get more
eyeballs and merged for 0.7.  If you need additional specific callbacks,
adding them would be cool, though I wouldn't recommend relying on the
blockstore API to remain even remotely stable for the foreseeable

@_date: 2012-03-22 01:39:06
@_author: bitcoin-list@bluematt.me 
@_subject: [Bitcoin-development] Adding callback hooks to the satoshi 
You might also want to check out libcoin. Its a fork of the satoshi client: Hey, guys.
I've been writing a number of apps that require realtime event
notifications, where the JSON-RPC API clearly doesn't suffice.
There are two approaches I've been taking to this end:
1) Writing my own library for dealing with raw bitcoin structures and
connecting to bitcoin nodes via the bitcoin protocol.
2) Making custom builds of the satoshi client putting callback hooks
in key points.
Neither of these two approaches is ideal. (1) involves a lot of code
duplication, (2) involves patching the satoshi client source
each time I grab a later version, with the everpresent risk of
something breaking and the need to continue maintaining these patches.
Moreover, unfortunately many of these key points happen to be in files
like main.cpp which see frequent changes.
I would like to propose adding these callback hooks to the main
branch. I am willing to help locate these key points, reorganize the
to place these methods in separate source files, define a callback
mechanism, and contribute source code.
-Eric Lombrozo
This SF email is sponsosred by:
Try Windows Azure free for 90 days Click Here Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net

@_date: 2012-11-21 13:38:37
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Draft BIP for Bloom filtering 
Meh, sure, whatever...I dont really think the seed values matter
significantly (Murmur3 isnt that bad of a hash function...) (and the
original algorithm wont result in a significant bit difference between
the seeds in many cases).
I think there is some consensus here, and I have no problem doing it
this way (in large part, filteradd should not be used at all).
I'm not sure here, if you are sending a filter just to use filteradd to
add things to it manually, you are doing something very, very, very
wrong... Though we could certainly do some kind of compressed bloom
filter encoding to allow for small filter loads (loading the few things
you need to filteradd right away) where you anticipate adding
significantly more filter elements down the road (can anyone even come
up with a case where you anticipate doing this?), the filter is small
enough (max 36kB) that I see little benefit for the large increase in
complexity (or is this another repeat of the merkle branch discussion?)

@_date: 2012-10-24 15:00:33
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Draft BIP for Bloom filtering 
I believe you meant NOT complicating?
Sadly that requires (potentially) more DoS potential because you require
nodes to store each transaction that could be requested instead of just
going ahead and forwarding them.  I agree the BIP should not specify
that the sending node is required to keep track of which transactions
have been announced/sent to clients, however since the reference client
does so currently, that implementation is significantly simpler (note
that it is a bounded set in the reference client, so even the reference
client doesn't really fully comply with the BIP as stated here).

@_date: 2012-09-10 15:53:33
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Segmented Block Relaying BIP draft. 
It seems to me the whole idea of segmenting blocks would add very little
(to nothing) with any sane block size.  Sure, if a block were to be
10GB, it may make sense.  However, even in that case, it would be easier
to relay a list of tx hashes (which may be a bit expensive) and txes
separately instead of using a notion of block segments.  That said, I
don't see blocks ever being that large and if they do become that large,
as only a few full nodes will remain, upgrading their protocol would be
(relatively) easy.  I would instead encourage focus on decreasing block
relay times for the current network and as blocks approach 10MB (so that
they can approach 10MB).

@_date: 2012-09-25 16:41:17
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Bitcoin Testing Project 
Although Jenkins may not be the best system, we already have jenkins and
pull-tester (which is a dumb python script I wrote to test all incoming
pull requests from github).  They both run the same set of scripts, namely those at
 (its pretty basic right now,
but since it is on github, I was hoping someone would find the
inspiration to add to it).
I dont really care if we keep using jenkins, but I figure we might as
well keep all the tests in one place?
Anyway, I'm all for more testing (I'm always complaining about how we
need more tests for stuff...).

@_date: 2012-09-26 20:53:26
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Bitcoin Testing Project 
For a mantis plugin, sure, I guess...
Jenkins currently just runs the test script after each new commit to
bitcoin (and provides binaries to anyone who wants them), so its pretty
basic (though jenkins has way more features than we use).  The bitcoin
one lives at We currently keep a changelog at  (I
went back and added tons of logs a while back and it got updated, though
0.7 seems to be missing...) anyway, automating that would be nice...
Having more info on that changelog page would be nice.
I have been meaning to catch up with the various attempts at better
bitcoin testing that have started up a few times, but I keep never
getting around to it...
Even if unit tests are considered separate, having it all run in one
huge test script makes it quite easy to implement new things (like
pull-tester) which test some arbitrary bitcoind commit in the same way
as every other tester.  The BitcoinjBitcoindComparisonTool.jar file which is run as a part of
the test scripts tries to hit as many block acceptance edge cases as
possible (I'm sure I missed a ton, but it hits a lot too).  I've also
been pushing alternate implementation implementors to use it to test
their own implementations.
As far as I'm concerned more test cases are more test cases, it may get
unwieldy to maintain, but at least we'd have more test cases :)
In terms of general testing strategies, I really prefer to script it
all, jenkins is quite nice in that it can have slave workers using a
different OS which run their own tests and then report back to the main
jenkins instance.  Getting a real Windows slave to run the installer and
test that thoroughly as well as basic Mac things (I know OSX uses a very
different build system...) would be nice (though I dont really have time
to write all those tests...)
re: GUI testing is hard: I've heard Qt's unit test framework is really
powerful and can even include things like click scripting and analysis
of the current views (though, I agree, its still no doubt hard).

@_date: 2013-04-05 13:33:43
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Integration testing for BitCoin 
These tests are run on each pull requests and on each new commit to
master.  They arent very complete, but they do test a lot of block
acceptance rules.

@_date: 2013-04-24 17:09:32
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [RFC] Fees/Minimum Priorities based on 
I hacked together a new min fee/prio calculator and memory-limited
mempool a while back and figured Id post the code here to get some
comments.  Its more of a discussion-starter than a strict proposal and
has a few obvious holes (hence posting here instead of pull-requesting).
It works as such (note that all constants are really place-holders, so
please recommend reasonable constants):
1) Watches when transactions enter mempool and calculates minimum
fee/priority based on a fairly dumb algorithm... It finds the highest
FEE_POLICY_TOP_N_TX (10) fee/prio transactions in mempool that have been
in mempool at least FEE_POLICY_DETERMINATION_BLOCKS (6) blocks and
averages together their fee/prio then multiplies by FEE_POLICY_FACTOR
2) It limits mempool size to a default of 10*MAX_BLOCK_SIZE (bringing it
down to 9*MAX_BLOCK_SIZE each time it has to throw out transaction).
When transactions are throw out, it keeps 2/9 of the mempool size in
highest-prio transactions and 7/9 of the mempool in highest-fee
transactions.  3) Any transactions which have a fee lower than the lowest-fee
transaction thrown out of the mempool and a priority lower than the
lowest-priority transaction thrown out of the mempool will not be
accepted into the mempool at all.  Obvious bugs:
1) It doesnt yet do anything for minimum fee/prio when it hasnt seen at
least FEE_POLICY_TOP_N_TX (10) transactions sitting in mempool for at
least FEE_POLICY_DETERMINATION_BLOCKS (6) blocks (ie hasnt been running
for 6 blocks or blocks are being filled completely).  The likely way to
address this is to look at previous blocks and find the lowest fee/prio
transactions included in them.
2) It will relay all transactions until the mempool has filled up (or if
the mempool never fills).  Something should be done initially to limit
DoS potential.
Code is at

@_date: 2013-08-17 10:03:41
@_author: bitcoin-list@bluematt.me 
@_subject: [Bitcoin-development] Combining bloom filters? 
Under some conditions, yes. The filters must have the same parameters (tweak, size, hash count). Bitcoinj implements this in its BloomFilter class.

@_date: 2013-08-19 16:15:08
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Proposal: remove "getwork" RPC from 
ACK, I see no reason to leave broken things in that a) arent necessary
and b) no one has the developer resources to fix.

@_date: 2013-12-24 00:34:53
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Bitcoin difficulty sanity check suggestion 
An attacker with some small hashpower isolates you (as an individual)
from the network by MITMing your network. You just switch the the
attackers chain as if nothing happened because of the network rule
that defines it as OK. Today, you will see that you're behind and warn
the user.
Was it really so hard to write a three-sentence paragraph to clarify
the attack instead of insulting people? Still, posting ideas here
without spending time to ensure you understand the Bitcoin network
well is frowned upon.
Rapidly troubleshoot problems before they affect your business. Most IT

@_date: 2013-12-29 11:27:52
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Looking for GREAT C++ developer for 
I'm not sure where you got the idea that Bitcoin-development was ideal for hiring scamcoin developers, but it's not. Most of the people on this list are smart enough to realize posts like this are dumb ideas backed by greedy "entrepreneurs" who don't understand the system they're trying to improve 99.9% of the time.

@_date: 2013-12-31 13:33:54
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
============================== START ==============================
We already have a wonderful system for secure updating - gitian-downloader. We just neither use it not bother making actual gitian releases so anyone can use it to verify signatures of downloads.

@_date: 2013-01-10 22:59:11
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Draft BIP for Bloom filtering 
First of the two is done.
Is a part of the larger API changes mentioned above.
The flags mentioned have been implemented, both to disable
autoexpansion, enable it for all outputs, enable for only pay to pubkey
outputs (the most likely use-case), or use a set of templates.  The
matched templates part isn't properly tested and I would like comments
on that part (see the last few commits at
Ive been missing lately, when is 0.8 targeted for freeze?

@_date: 2013-01-16 10:00:47
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Draft BIP for Bloom filtering 
Actually, there is one more minor algorithmic change I would like to
make to the way the hash function is computed really quick before it
gets merged, I'll have that finished up by the end of today.

@_date: 2013-06-27 14:29:30
@_author: bitcoin-list@bluematt.me 
@_subject: [Bitcoin-development] [ANN] Micropayment Channel Implementation 
As of today, a full implementation of micropayment channels has been merged
onto bitcoinj's master branch (to be released in the next version). It is
designed to make it easy for users to create payment channel servers and
clients based on the design at
by creating a simple TCP socket and exchanging protobufs to initialize and
make payments.
It supports various levels of abstractions, allowing users to drive the
state machines which do basic channel init/verification themselves, allow
bitcoinj to handle all the complexity of channel management/expiry/etc and
simply exchange protobufs over whatever whatever connection they wish to
make with the server, or let bitcoinj handle opening a TCP socket and do
all the work. See
 for
details on how to use the implementation in bitcoinj.
A more full protocol description will be written up in the form of a BIP as
the code matures a bit more (with the hope that other implementations can
appear), but, generally:
1. Client and server exchange version handshake, and client may
optionally request that an existing channel be reopened (the channels last
for 24 hours by default, so if the connection gets killed, reopening an
existing channel is useful).
2. The protocol described on the wiki is followed, exchanging
(canonical!) signatures and transactions until a multisignature contract is
established and broadcast which locks money into the channel, and a refund
transaction is created and signed which allows the client to spend the
entire multisignature transaction to wherever they want
(SIGHASH_NONE|SIGHASH_ANYONECANPAY) after some lock time (by default, 24
hours). Both client and server store a copy of the channel in their wallet
so that if the app itself crashes the refund transaction can still be
broadcast/the channel can still be resumed. At this point either the whole wallet should be backed up or the total value in payment channels at any
given time should be kept reasonably low (because payment channels are
designed to combine micropayments into confirmable payments, this shouldn't be an issue)
3. The client increments payments by sending the server new signatures
spending the multisig contract partially back to themselves and allowing
the server to do what they want with the rest
4. When the client sends a CLOSE message or the channel approaches the
refund transaction unlock time, the server adds any necessary fees to the
latest payment transaction and broadcasts it, closing the channel, disconnecting the client if the connection is still open and removing the stored channel state from its wallet.
See  for the protobuf/protocol description.

@_date: 2013-05-07 23:07:50
@_author: Matt Corallo 
@_subject: [Bitcoin-development] limits of network hacking/netsplits (was: 
I really beg to differ on this one.  If you're an Ubuntu user who is
behind only one distro (quantal) you're stuck on version 0.6.2 with no
updates since 2012 (yes, that means on May 15th you'll be lost). For those still on Debian Squeeze (ie barely out of date), you get
0.3.24! Yes, 0.3.24 including every issue we've fixed since
( and
bitcoin is not available in wheezy.
Those are just the two I bothered to look up, but, additionally, nearly
every distro I know of links bitcoin against libdb5.1 (latest Ubuntu,
Arch, etc) which means wallets run once with those packages will never
be usable an "official" Bitcoin build ever again.  I can't necessarily
fault them for this since 4.8 is quite old, but its certainly not "doing
mostly a pretty good job"

@_date: 2013-05-10 17:49:16
@_author: bitcoin-list@bluematt.me 
@_subject: [Bitcoin-development] Automated Weekly Testnet Alerts 
In order to provide developers with a reasonable way to test their alert-handling code, starting next Thursday, automated weekly alerts will be made on testnet.
They will contain the message "[TEST] This is a test alert broadcast at $TIMESTAMP" (where $TIMESTAMP is the unix timestamp of initial broadcast), will expire in between 2 and 4 hours and will have varying prioriry.  They will be announced at 13:00 UTC (currently 9am EST).

@_date: 2013-11-06 00:50:21
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [ANN] High-speed Bitcoin Relay Network 
Recently, there has been a reasonable amount of discussion about the
continued fragility of the public Bitcoin network on IRC and elsewhere
(1). To this extent, I'm organizing a system of peering between nodes in
the network by creating a system of high-speed relay nodes for miners
and merchants/exchanges. This system will a) act as a fallback in the
case that the public Bitcoin network encounters issues and b) decrease
block propagation times between miners.
It is NOT designed to in any way replace or decrease the need for the
public Bitcoin P2P network. It is NOT any kind of attempt at
centralization, and I still encourage interested parties to establish
their own private peering agreements with large miners as needed.
Currently the network consists of one specially-designed relay node, but
I hope to bring more online in the coming days.
This network is open to everyone via a few public relay nodes, but also
will have nodes which are made available only to large miners and
merchants/exchanges to mitigate the ability of malicious parties to DoS
the network.
To peer with the public relay nodes, simply select the closest region
out of us-west (West Coast US), us-east (East Coast US), eu (Western
Europe), au (Australia), or jpy (Japan) and add
public.REGION.relay.mattcorallo.com to your addnode list. Note that
since all of the relay nodes will relay between each other, you gain no
latency advantage by peering with more than the closest node to you (and
currently all the regions map to one node, so there they're redundant
For each relay node, you can connect to either port 8334 or 8335.
Connecting on port 8334 will relay only blocks, and port 8335 will relay
both blocks and transactions. The relay nodes will request any
transactions which appear in your invs no matter which port you connect to.
Relay node details:
 * The relay nodes do some data verification to prevent DoS, but in
order to keep relay fast, they do not fully verify the data they are
relaying, thus YOU SHOULD NEVER mine a block building on top of a
relayed block without fully checking it with your own bitcoin validator
(as you would any other block relayed from the P2P network).
 * The relay nodes do not follow the standard inv-getdata-tx/block flow,
but instead relay transactions/blocks immediately after they have done
their cursory verification. They do keep some track of whether or not
your nodes claim to have seen the transactions/blocks before relaying,
but you may see transactions/blocks being sent which you already have
and have not requested, if this is a problem for you due to bandwith
issues, you should reconsider your bandwith constraints and/or are
peering with too many nodes.
 * The relay nodes will all relay among themselves very quickly, so
there is no advantage to peering with as many relay nodes as you can
find, in fact, the increased incoming bandwidth during block relay
spikes may result in higher latency for your nodes.
 * The relay nodes are NOT designed to ensure that you never miss data,
and may fail to relay some transactions. Additionally, because the relay
nodes do not respond to standard getdata requests, if you miss a relay
and then reconnect, that data will not be sent again by the relay nodes.
The relay nodes are NOT a replacement for having peers on the standard
P2P network, they are only there to augment the existing P2P network.
If you are a merchant/exchange/large miner/other important node operator
and wish to gain access to additional domain names which map to relay
nodes with fewer peers, please fill out the form at
You can find the source for the relay nodes at
If you have any comments/concerns/suggestions, please do not hesitate to
email bitcoin-peering at mattcorallo.com
(1) There has been extended discussion on  as well as
 of the very small number of active, listening nodes.
Additionally, because many of those nodes are versions prior to 0.8.4,
it seems very likely that maliciously creating network splits or at
least drastically reducing the number of peers for most nodes would not
be particularly challenging in the current network. Also,
noted that they were able to single-handledly decrease the network-wide
orphan rate by around 50% by improving network peering. Finally, you've
all seen the recent discussion on malicious mining algorithms. Though
those are not entirely prevented by reducing block propagation times,
they can be significantly limited compared to the current, rather
disjoint, network.

@_date: 2013-11-06 18:35:34
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [ANN] High-speed Bitcoin Relay Network 
No, the transactions relayed are piped through a bitcoind first (ie
fully verified by a bitcoind). For blocks, for which the timing needs to
be tighter, bitcoinj does SPV-validation. Though it is possible to
create a block which passes SPV validation but causes a DoS score, doing
so would cost a miner a full block's worth of profits, which they are
fairly unlikely to do. In any case, if it every becomes a problem, its
not hard to adapt addnode to allow higher DoS scores for individual nodes.

@_date: 2013-11-13 21:11:35
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [ANN] High-speed Bitcoin Relay Network 
Thanks, fixed.
Yes, I've done some initial outreach and plan on doing another major
round now that the initial network is up and Im working on running some
relay time benchmarks. Finding someone to help push peering would be
nice, if you have any suggestions, Im all ears.
Agreed, improving relay times across the regular P2P network would be
nice, however I really dont see this as a part of the P2P network. Its
more of a backup relay network that just happens to follow the P2P
protocol (mostly, it doesnt do full block verification, so technically
it breaks spec). In this model, this is really a nice augment to the P2P
network no matter what improvements are made. Having more protocols/ways
blocks are relayed is always nice (anyone wanna launch a satellite?)

@_date: 2013-11-13 21:14:57
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [ANN] High-speed Bitcoin Relay Network 
In the short-term, maybe. Keep in mind that the code for tx relay is
fairly different and the bandwidth for transaction relay on these
nodes is already lower than it is for blocks (by design). That said,
I'd like to look into doing tx-less block relays for transactions that
peers already have to limit block relay times even for large blocks,
in which case tx relay is very much required.

@_date: 2013-11-21 10:28:58
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Who or what is /Satoshi:0.8.99/Gangnam 
No, mine identifies as BitcoinJ, RelayNode, version string

@_date: 2013-09-15 14:13:54
@_author: Matt Corallo 
@_subject: [Bitcoin-development] More appropriate XDG menu category for 
(Finally) got around to this, sorry for the delay. 0.8.5 has the new
category and pull request is at

@_date: 2014-04-01 15:11:01
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Finite monetary supply for Bitcoin 
I disagree with this proposal both in spirit and in practice.
We all know satoshi was the best programmer like no one ever was. Clearly he intended this monetary supply from the beginning, who are we but mere mortals to go against satoshi's will?
Also, should we really do this with a soft fork when we can take this opportunity to redesign the whole system with a hard fork? This is out chance to switch to a whole new script engine!

@_date: 2014-04-01 17:51:16
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Finite monetary supply for Bitcoin 
I move to reclaim bip 42 as reserved for a bip containing either a reference to musical dolphins or towels in the name.

@_date: 2014-04-12 11:34:46
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Ubuntu LTS Packaging? 
Hmm? It's up to date... 0.9.1 doesn't change anything for dynamically-linked-to-openssl builds.

@_date: 2014-08-03 00:56:54
@_author: Matt Corallo 
@_subject: [Bitcoin-development] [ANN] High-speed Bitcoin Relay Network 
For those who have been using this to get faster relays to/from the
network, you may have noticed some instability recently. This is because
the nodes were all being upgraded to use some new relaying code which
should cut down on duplicate transaction relaying in blocks, improving
relay speed within the network and to nodes which run new clients which
use the same relaying technique. Essentially instead of relaying entire
blocks, nodes keep a rolling window of recently-seen transactions and
skip those when relaying blocks.
You can find a simple client which connects to a local bitcoind and a
relay node at  and the source
for the whole thing at

@_date: 2014-08-28 20:21:30
@_author: Matt Corallo 
@_subject: [Bitcoin-development] RIP Hal Finney 
I'm sure many of you have already seen this, but Hal Finney passed away
on Tuesday. While his body is being cryogenically preserved, we should
all take a moment to thank Hal for everything he did for the cypherpunk
community, specifically helping hugely in the early days of Bitcoin as
well as PGP.

@_date: 2014-12-09 21:30:34
@_author: Matt Corallo 
@_subject: [Bitcoin-development] ACK NACK utACK "Concept ACK" 
Also utACK ("untested ack") and "tested ack" when people are being explicit.

@_date: 2014-12-20 08:57:53
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Area of Focus 
There was recently some discussion around dnsseeds. Currently some
dnsseeds are getting blocked by ISPs because the hosts they pick up
(which run bitcoin core nodes) often run rather web servers alongside
which serve malware or whatever else and thus end up on IP-based malware
Of course we really dont want to move off of DNS because it has this big
built-in anonymity network where the DNS seed servers only get
information about your ISP, not you, and its cached so you dont get as
much information about how many users are making those requests.
A potential solution might be supporting some subdomain which has
results XORed with some constant mask to tweak the real IP.
Additionally, it might be cool to stuff a TXT/AAAA/whatever record with
a signature of the results provided by the DNSseed operator.

@_date: 2014-12-20 21:20:53
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Area of Focus 
Well, some ISPs, when they see an IP address serving malware, will
(apparently) simply replace DNS results for anything returning that IP
with a warning page.
One solutions is to just blindly block everything with HTTP(S), as
Christian has done, but this is a rather ugly solution, since many
perfectly good nodes will get caught in the crossfire. Hiding what
actual IPs we're returning in the results seems much cleaner, despite
being an ugly hack.

@_date: 2014-07-22 20:01:45
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Policy for DNS seeds 
Absolutely not. Time and time again we've seen "anonymized" data sets
that dont work out so well. I'm sure its possible to do but there are
too many factors and we dont want to succumb to this.
Also, these generally look good (and essentially the same as what had
been a gentleman's agreement for those who read IRC actively, the
purpose of codifying this is essentially that we ended up adding a lot
of DNS Seeds run by people who dont follow development closely and/or
are not aware of the issues involved).
Thanks for writing this up,

@_date: 2014-05-16 18:53:26
@_author: Matt Corallo 
@_subject: [Bitcoin-development] DNS seeds unstable 
This is very strange...when did you run this test and can anyone else
reproduce this?

@_date: 2014-11-06 22:05:54
@_author: Matt Corallo 
@_subject: [Bitcoin-development] The difficulty of writing consensus 
Depends, without BIP62 a /lot/ of the even basic contracts that people
want to use today (or wanted to use 18 months ago) are unusable, in
fact, without BIP62, the atomic swaps suggested as important for
sidechains are not secure. While redoing Bitcoin in a hardfork is nice,
its a very long-term thing, so I'm not sure about making people wait for
a large hardfork just to use payment channels.
Also, I echo the difficulty of writing consensus-compatible code and
highly suggest anyone with money behind an implementation that is doing
script verification in code that isnt Bitcoin Core rethink that decision.

@_date: 2014-10-02 04:46:43
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Decreasing block propagation time 
It already is Well, ok, a variation on the idea is.

@_date: 2014-10-13 17:18:53
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Fwd: [Bug 24444] Named Curve Registry 
See-also: this related bug on Curve25519 and some MS Research curves
that generated far more discussion.

@_date: 2014-10-27 20:17:34
@_author: Matt Corallo 
@_subject: [Bitcoin-development] DS Deprecation Window 
It is a very bad idea to delay relaying/accepting blocks based on
information which is only local to your node (ie would create the
ability for people to split the network by sending out lots of
double-spends to different parts of the network at the same time). Thus,
miners are incentivized to go connect to everyone on the network and
look for double-spends, not including them in their blocks to avoid
being delayed (which is OK, except having to connect to everyone is bad).
There is a related concept of "discouraging" blocks which generally only
refers to mining on a previous block, but you have to be careful doing
that so you dont break consensus.

@_date: 2015-06-18 12:24:14
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Concerns Regarding Threats by a Developer 
Ive been trying to stay out of these increasingly useless shit-throwing contests, but I wanted to take objection to this... I highly, highly doubt any seriously technical person is making any kind of decision on block size issues based on their own personal network. If you're assuming this is a serious motivating factor for anyone, then I'm not sure you've even been reading your email or listening to the conversations you've had with people over the last year or more.

@_date: 2015-03-16 22:22:13
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Relative CHECKLOCKTIMEVERIFY (was CLTV 
In building some CLTV-based contracts, it is often also useful to have a
method of requiring, instead of locktime-is-at-least-N,
locktime-is-at-least-N-plus-the-height-of-my-input. ie you could imagine
an OP_RELATIVECHECKLOCKTIMEVERIFY that reads (does not pop) the top
stack element, adds the height of the output being spent and then has
identical semantics to CLTV.
A slightly different API (and different name) was described by maaku at
which does a better job of saving softfork-available opcode space.
There are two major drawbacks to adding such an operation, however.
1) More transaction information is exposed inside the script (prior to
CLTV we only had the sigchecking operation exposed, with a CLTV and
RCLTV/OP_CHECK_MATURITY_VERIFY we expose two more functions).
2) Bitcoin Core's mempool invariant of "all transactions in the mempool
could be thrown into one overside block and aside from block size, it
would be valid" becomes harder to enforce. Currently, during reorgs,
coinbase spends need checked (specifically, anything spending THE
coinbase 100 blocks ago needs checked) and locktime transactions need
checked. With such a new operation, any script which used this new
opcode during its execution would need to be re-evaluated during reorgs.
I think both of these requirements are reasonable and not particularly
cumbersome, and the value of such an operation is quite nice for some
protocols (including settings setting up a contest interval in a
sidechain data validation operation).

@_date: 2015-05-04 02:15:47
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Relative CHECKLOCKTIMEVERIFY (was CLTV 
Yes, as discussed on IRC months ago when the first email was sent, the
assumption is that you would require N be at least 100. That way you are
reorg safe up to the same limit as coinbase transactions, which are also
only reorg safe in the case of no 100-block reorgs. Its not ideal in
some contracts, but keeping the no-second-nLockTime-equivalent property
is worth it IMO, and its still incredibly useful in many contracts.

@_date: 2015-05-06 22:12:14
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase 
Recently there has been a flurry of posts by Gavin at
 which advocate strongly for increasing
the maximum block size. However, there hasnt been any discussion on this
mailing list in several years as far as I can tell.
Block size is a question to which there is no answer, but which
certainly has a LOT of technical tradeoffs to consider. I know a lot of
people here have varying levels of strong or very strong opinions about
this, and the fact that it is not being discussed in a technical
community publicly anywhere is rather disappointing.
So, at the risk of starting a flamewar, I'll provide a little bait to
get some responses and hope the discussion opens up into an honest
comparison of the tradeoffs here. Certainly a consensus in this kind of
technical community should be a basic requirement for any serious
commitment to blocksize increase.
Personally, I'm rather strongly against any commitment to a block size
increase in the near future. Long-term incentive compatibility requires
that there be some fee pressure, and that blocks be relatively
consistently full or very nearly full. What we see today are
transactions enjoying next-block confirmations with nearly zero pressure
to include any fee at all (though many do because it makes wallet code
This allows the well-funded Bitcoin ecosystem to continue building
systems which rely on transactions moving quickly into blocks while
pretending these systems scale. Thus, instead of working on technologies
which bring Bitcoin's trustlessness to systems which scale beyond a
blockchain's necessarily slow and (compared to updating numbers in a
database) expensive settlement, the ecosystem as a whole continues to
focus on building centralized platforms and advocate for changes to
Bitcoin which allow them to maintain the status quo[1].
[1]

@_date: 2015-05-06 23:12:17
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase 
Replies inline.
Indeed, "the bitcoin community of users and miners can decide to do
whatever they want", but this is univeral - "they" could decide whatever
they want if "they" want to hardfork. That said, "we" should be having a
rigorous technical discussion about whether it is sane to recommend a
given course of action by releasing software which makes it happen.
The point of the hard block size limit is exactly because giving miners
free rule to do anything they like with their blocks would allow them to
do any number of crazy attacks. The incentives for miners to pick block
sizes are no where near compatible with what allows the network to
continue to run in a decentralized manner.

@_date: 2015-05-06 23:13:22
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase 
For now, lets leave the discussion to JUST the block size increase. If
it helps - everyone should assume that their pet feature is included in
a hard fork or, if you prefer, that no other features are included in a
hard fork.

@_date: 2015-05-06 23:41:37
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase 
Sure, of course.
Yes, but this does NOT make an actual policy. Note that the vast
majority of miners already apply their own patches to Bitcoin Core, so
applying one more is not all that hard. When blocks start to become
limited (ie there is any fee left on the table by transactions not
included in a block) there becomes incentive for miners to change that
behavior pretty quick. Not just that, the vast majority of the hashpower
is behind very large miners, who have little to no decentralization
pressure. This results in very incompatible incentives, mainly that the
incentive would be for the large miners to interconnect in a private
network and generate only maximum-size blocks, creating a strong
centralization pressure in the network.

@_date: 2015-05-07 17:26:10
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase 
People have been sharing the same objections as on this list for months,
I'm not sure what is new here.
I think this is a huge issue. You've been wandering around telling
people that the blocksize will increase soon for months, when there is
very clearly no consensus that it should in the short-term future. The
only answer to this that anyone with a clue should give is "it will
very, very likely be able to support at least 1MB blocks roughly every
10 minutes on average for the next eleven years, and it seems likely
that a block size increase of some form will happen at some point in the
next eleven years", anything else is dishonest.

@_date: 2015-05-07 19:03:52
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase 
Replies inline.
No, I dont think Gavin is being deliberately dishonest, and I'm rather
confident he phrased everything in a way that is technically true (ie
the quote in his response). However, others have definitely not taken
away the correct interpretation of what he said, and this is a serious
problem. Setting expectations correctly as this is a very contentious
issue and one that does not appear to be reaching consensus quickly in
the technical community is important.
More generally, consider the situation we're in now. Gavin is going off
pitching this idea to the general public (which, I agree, is an
important step in pulling off a hardfork) while people who actually
study the issues are left wondering why they're being ignored (ie why is
there no consensus-building happening on this list?).
The appropriate method of doing any fork, that we seem to have been
following for a long time, is to get consensus here and on IRC and on
github and *then* go pitch to the general public (either directly or by
releasing software) that they should upgrade. I admit that hardforks are
a bit different in that the level of software upgrade required means
additional lead time, but I'm not sure that means starting the
public-pitching phase before there is any kind of consensus forming
(actually, I'd point out that to me there seems to be rahter clear
consensus outside of you and Gavin that we should delay increasing block
As far as I can tell, there has been no discussion of block sizes on
this list since 2013, and while I know Gavin has had many private
conversations with people in this community about the block size, very
little if any of it has happened in public.
If, instead, there had been an intro on the list as "I think we should
do the blocksize increase soon, what do people think?", the response
could likely have focused much more around creating a specific list of
things we should do before we (the technical community) think we are
prepared for a blocksize increase.
A specific credible alternative to what? Committing to blocksize
increases tomorrow? Yes, doing more research into this and developing
software around supporting larger block sizes so people feel comfortable
doing it in six months. I acknowledge that Gavin has been putting a lot
of effort into this front, but, judging by this thread, I am far from
the only one who thinks much more needs done.

@_date: 2015-05-07 19:14:48
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase 
On a related note, I'd like to agree strongly with Peter Todd that we
should get away from doing forks-only-in-releases. We can add code to do
a fork and then enable it in 0.11.1 or 0.11.11 if Gavin prefers more 11s.

@_date: 2015-05-07 21:29:01
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase 
No, I'm very concerned about both.
I agree, thats why this mailing list was created in the first place
(well, also because bitcointalk is too full of spam, but close enought :))
Its true, just like its true the general public can opt to run any
version of software they want. That said, the greater software
development community has to update /all/ the software across the entire
ecosystem, and thus provide what amounts to a strong recommendation of
which course to take. Additionally, though there are issues (eg if there
was a push to remove the total coin limit) which are purely political,
and thus which should be up to the greater public to decide, the
blocksize increase is not that. It is intricately tied to Bitcoin's
delicate incentive structure, which many of the development community
are far more farmiliar with than the general Bitcoin public. If there
were a listserv that was comprised primarily of people on
 I might have suggested a discussion there, first, but
there isnt (as far as I know?).
Yes....I'm gonna split the topic since this is already far off course
for that :).
Let me answer that in a new thread :).

@_date: 2015-05-07 22:02:09
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase Requirements 
OK, so lets do that. I've seen a lot of "I'm not entirely comfortable
with committing to this right now, but think we should eventually", but
not much "I'd be comfortable with committing to this when I see X". In
the interest of ignoring debate and pushing people towards a consensus
at all costs, ( ;) ) I'm gonna go ahead and suggest we talk about the
Personally, there are several things that worry me significantly about
committing to a blocksize increase, which I'd like to see resolved
before I'd consider supporting a blocksize increase commitment.
 * Though there are many proposals floating around which could
significantly decrease block propagation latency, none of them are
implemented today. I'd expect to see these not only implemented but
being used in production (though I dont particularly care about them
being all that stable). I'd want to see measurements of how they perform
both in production and in the face of high packet loss (eg across the
GFW or in the case of small/moderate DoS). In addition, I'd expect to
see analysis of how these systems perform in the worst-case, not just
packet-loss-wise, but in the face of miners attempting to break the system.
 * I'd very much like to see someone working on better scaling
technology, both in terms of development and in terms of getting
traction in the marketplace. I know StrawPay is working on development,
though its not obvious to me how far they are from their website, but I
dont know of any commitments by large players (either SPV wallets,
centralized wallet services, payment processors, or any others) to
support such a system (to be fair, its probably too early for such
players to commit to anything, since anything doesnt exist in public).
 * I'd like to see some better conclusions to the discussion around
long-term incentives within the system. If we're just building Bitcoin
to work in five years, great, but if we want it all to keep working as
subsidy drops significantly, I'd like a better answer than "we'll deal
with it when we get there" or "it will happen, all the predictions based
on people's behavior today say so" (which are hopefully invalid thanks
to the previous point). Ideally, I'd love to see some real free pressure
already on the network starting to develop when we commit to hardforking
in a year. Not just full blocks with some fees because wallets are
including far greater fees than they really need to, but software which
properly handles fees across the ecosystem, smart fee increases when
transactions arent confirming (eg replace-by-fee, which could be limited
to increase-in-fees-only for those worried about double-spends).
I probably forgot one or two and certainly dont want to back myself into
a corner on committing to something here, but those are a few things I
see today as big blockers on larger blocks.
Luckily, people have been making progress on building the software
needed in all of the above for a while now, but I think they're all
very, very immature today.
> On Thu, May 7, 2015 at 3:03 PM,

@_date: 2015-05-29 23:25:27
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase Requirements 
Sadly, this is very far from the whole story. The issue of miners
optimizing for returns has been discussed several times during this
discussion, and, sadly, miners who are geographically colocated who are
optimizing for returns with a free-floating blocksize will optimize away
50% of the network!
I'll talk about transaction fees in a second, but there are several
problems with this already. As pointed out in the original mail, gfw has
already been known to interfere with Bitcoin P2P traffic. So now by
"little" miners, you mean any miner who is not located in mainland
China? Whats worse, the disadvantage is symmetric - little miners are at
a disadvantage when *anyone* mines a bigger block, and miners dont even
have to be "evil" for this to happen - just optimize for profits.
I dont know what you're referring to with this. Are you claiming little
miners today optimize for relay times and have good visibility into the
Bitcoin network and calculate an optimal block size based on this (or
would with a 20MB block size)?
You dont make any points here with which I can argue, but let me respond
with the reason /I/ think it is a problem worth thinking a little bit
about...If we increase the blocksize sufficiently such that transaction
fees are not the way in which miners make their money, then either
miners are not being funded (ie hashpower has to drop to very little),
or the only people mining/funding miners are large orgs who are
"running" Bitcoin (ie the web wallets, payment processors, big
merchants, and exchanges of the world). Sadly, this is no longer a
decentralized Bitcoin and is, in fact, pretty much how the banking world
works today.
I'm not sure who, if anyone, claims Bitcoin is novel or interesting for
any reason other than its decentralization properties, and, in a world
which you are apparently proposing, the "natural" course of things is to
very strongly centralize.
Yes, I am arguing that by increasing the blocksize the incentives to
actually make Bitcoin scale go away. Even if amazing technologies get
built, no one will have any reason to use them.

@_date: 2015-05-30 19:32:22
@_author: Matt Corallo 
@_subject: [Bitcoin-development] Block Size Increase Requirements 
If, for example, the majority of miners are in China (they are), and
there is really poor connectivity in and out of China (there is) and a
miner naively optimizes for profit, they will create blocks which are
large and take a while to relay out of China. By simple trial-and-error
an individual large miner might notice that when they create larger
blocks which fork off miners in other parts of the world, they get more
income. Obviously forking off 50% of the network would be a rather
extreme situation and assumes all kinds of simplified models, but it
shows that the incentives here are very far from aligned, and your
simplified good-behavior models are very far from convincing.
The disadvantage is small with 1MB blocks, but already non-zero. 20MB
blocks are much, much worse (lots of things here dont scale linearly,
even just transfer over a high-packet-loss-link). I mentioned this in my
original email as something which doesnt make me comfortable with 20MB
blocks, but something which needs simulation and study, and might
actually be just fine!
Defaults? Dumb designs? Most miners just use the default 750K blocks, as
far as I can tell, other miners probably didnt see transactions relayed
across several hops or so, and a select few miners are doing crazy
things like making their blocks fit in a single packet to cross the gfw,
but that is probably overkill and not well-researched.
Do you have convincing evidence that at 20MB miners will be able to
break even on transaction fees for a long time? (The answer is no
because no one has any idea how bitcoin transaction volumes are going to
scale, period.)
Sure, do you have a value of hashpower which is "secure enough" (which
is a whole other rabbit hole to go down...).
Oh? You mention at that "I struggle with wanting to stay true to Satoshi?s original vision
of Bitcoin as a system that scales up to Visa-level transaction volume".
That is in direct contradiction.
"it is not a panacea", but everyone in the community seems to be taking
it as one. You've claimed many times that many of the big
webwallet/payment processors/etc have been coming to you and saying they
need bigger block sizes to continue operating. In reality, they dont, it
just makes it easier.
