
@_date: 2011-08-04 19:43:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
Definitely want _some_ path to HTTP/1.1 persistent connections, either
this or async I/O, Based on field usage, it sounds like the above, threaded rpc, is more
stable.  So my only question remaining, for which I've not yet
reviewed the code, is:  what is the behaviour under assault from lots
of new incoming TCP connections?  One very common problem with
threaded TCP servers is blindly creating new threads without any
filtering or checking of incoming connections, thereby quickly
reaching thread limits, possibly causing other parts of the program to
Any amount of RPC request volume, miner or not, sent to the present
implementation winds up using a lot of socket resources due to the
constant disconnect/reconnect demanded of the current HTTP/1.0 code.
This patch addresses that key issue, providing positive impact for all
production bitcoin sites using RPC.
Miners are hitting these problems now, and Gavin's right that mainnet
miners are a small portion of the total population, but our RPC server
implementation really is bloody awful at present.  Reliable,
production TCP servers use either threads or async I/O, or a
combination of both (thread pool + async I/O == win).  Deploying
HTTP/1.1 persistent connections will make a positive impact at any
site heavily using RPC.
Did I leave something out, when merging
     commit 67ed7d9d4929d8fe1c5f976c184c72dff02d83b7
     Author: JoelKatz      Date:   Mon Jul 25 15:06:45 2011 -0700
I think we need this, but have not yet reviewed/thought about it.
Sounds nice to have.
     Jeff
P.S.  I'm moving my home computer lab setup to a new house.  Internet
will be spotty until August 11, and you won't see much of me at all on

@_date: 2011-08-05 01:52:05
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Blitcoin? (Black Hat 2011) 
Unfortunately the nodes accepting incoming connections are small
enough in number (7000?) that you can shut down a lot by attacking
those nodes.
This was part of the motivation of turning on upnp by default in the
GUI version, but maybe we need to go further than that...
Yes, that is correct.  Bitcoin resends wallet transactions with zero
confirmations, and both sent and received transactions fall within the
"wallet tx" superset.
TBH I had forgotten about the resend on the receiver side, though.
It, of course, makes plenty of sense in the context of importing
transactions from foreign sources, e.g. receiving transactions via a
USB flash drive.
Well, it -is- possible to implement TCP over UDP   The TCP
connection sequence over UDP helps to work against spoofing, while UDP
helps to open an inbound UDP port as you describe.
Not that I'm endorsing a bitcoin-internal TCP stack... just sayin'  :)

@_date: 2011-08-10 15:48:10
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Change to multiple executables? 
In kernel land there exists "linux-next"  Stephen Rothwell maintains a
tree that is linux -tip, plus a list of trees & branches to pull from
various individual developers.  For example, linux-next pulls my SATA
tree from libata-dev.git branch NEXT.
Each developer is expected to publish changes they feel are ready for
upstream.  Developers are expected to "play nicely" and coordinate
amongst themselves when two trees include conflicting changes.
Trivial merge conflicts are handled by Stephen Rothwell, who does
merging, build testing and such of the final set-of-N-trees result.
More difficult merge conflicts are coordinated by the developers
themselves, who work together to create a temporary "merge tree" that
is then pulled by the linux-next maintainer.
linux-next is the always moving, regenerated daily target where
developers stage [in their opinion] upstream-ready changes.
Thus Linus's linux.git development process really looks like the
following, when linux-next is included in the picture:
1. Version X-1 is released, on day 0.
2. Merge window for version X opens, on day 0.
3. Linus pulls all changes that have seen testing in linux-next, over
the -rc window (step  below)
4. Merge window closes, on day 7.
5. Version X-rc1 is released, on day 7.
6. Only bug fixes are accepted now (hopefully seen at least 24 hours
of testing in linux-next, unless urgency demands otherwise).  All new
development is done in developer trees and branches, and is
automatically published nightly in linux-next.
7. Version X is released, on day 90.
Thus "upstream" stays almost constantly stable, except for the short
1-week merge window period, and linux-next comprises the rolling
"development version" where new changes are staged.
Note the subtle but important distinction between this and maintaining
a strict 'bugfix' and 'development' branch system like John Smith
described.  The underlying linux-next dependent trees may be rebased
at any time, and so linux-next is constantly regenerated, rather than
being a cumulative history of choatic development.  Major changes can
and will be staged, de-staged, and re-staged during development, and
maintaining a strict "official development branch" methodology is less
Here is an example linux-next report.  Stephen sends one, daily, with
each linux-next tree generated:
As it applies to bitcoin, this "bitcoin-next" approach may simply be
layered on top of the current methodology.  All it requires is a
volunteer who maintains this tree-of-trees, and wha-la:  bitcoin has a
development branch.

@_date: 2011-08-10 15:57:29
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Change to multiple executables? 
This is true -- though there is value to having a list of "things we
think people should focus on" for the motivated, and for new people
interested in tackling a project, but not sure what project to tackle.
A centrally managed development branch on bitcoin/bitcoin.git is not
the way to do it, however.  See the description of linux-next, in my
previous email, for a more distributed method which can easily be
layered on top of the existing bitcoin dev structure by any motivated
Think distributed.  :)  The community does not need Linus's help
(linux-next) or Gavin's help (bitcoin-next) to do this.  linux-next
became so widely used and useful that Linus requires almost all
changes to be first staged in linux-next.

@_date: 2011-08-10 16:41:26
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Roadmap/schedules 
Seems like this would be a useful companion website + project.
bitcoin/networkmon.git could be a central point for contributors to
add various monitors and tests.
Getting on-going network health information is critical to bitcoin's
success.  We need to know if incoming nodes are getting DDoS'd...
IMO the only thing lacking is docs.  There is no real admin guide
describing how to prepare bitcoind installations for encryption;
doc/README does not mention RPC encryptwallet at all, nor does it
describe the various states your wallet may be in, when before and
after encryptwallet has been run.  The information is very general,
and not adequate for a competent admin to be able to evaluate.  It
does not describe encryption method or other security parameters.  It
does not describe the specific technical relationship between the
master key and other keys.
I have never seen an open source project with a successful Bug Czar,
unless that is an actively compensated position.
I think Q/A will naturally grow out of some sort of dedicated support
organization, rather than have a dev fiat requirement.  Testing like
that is always desireable in the "I'd love it, if it were this way"
vein, but not always realistic at all for open source projects.
Especially with open source, time has shown that the best testing
comes from the field, and we have the biggest test lab in the world:
the Internet.  So IMO focus less on roadblocks to publishing software,
and more on widely distributed test software.
For new features, simple "it works" test at a minimum seems
reasonable, most of the time.  But in open source the testing and such
tends to happen in the periphery, by organizations and individuals
with the incentive to focus on those issues.
In my recent emails describing linux-next and a proposed
"bitcoin-next", one attribute of linux-next is that it is run through
automated tests on a daily basis, right after the merge is complete.
It forms a useful layer on top of the primary linux project & tree.
Although I do agree, remember that it is the nature of open source
that you always have less control than you'd like :)
If the Iron Fist of Developer Justice squeezes too tightly, people
will simply route around the bottleneck with their own trees and
software releases.  genjix is already pushing for his libbitcoin
branch, for example.
Nice to have, but I think it's just a short term fix.  Long term, it
will be SPV clients vs. full nodes, and bringing up a full node will
be so costly that you'll just mirror the block database directly out
of band, then boot the node at 99%+ block height.
Yes.  I was hoping to get that for 0.4.
Not a big deal to me, I never use GUI :)
Has anyone actually come up with a good idea to code?
This is a widely acknowledged problem, sure, but where are the good
solutions, even on paper?
Parting shot:  there is a reason Linus specifically says there is no
roadmap for the kernel.  That's because it is always driven by the
community, and like a free market, the collective motivations and
goals of the group.
Projecting into the future, _and then attempting to stick to that
roadmap_, will end in much frustration.
Open source contributions are far more organic and unpredictable.
Roadmaps work better in fiat organizations where developers do what
they're paid/told to do :)

@_date: 2011-08-10 17:35:01
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Change to multiple executables? 
Breaking backwards compatibility means breaking people's access to
their own money.
If you remove an "unnecessary" step that existing nodes expect, then
the cost of disrupting monetary access seems higher than the value of
that breaking change.
My own 'supernode' proposal also includes using the nServices bits.
There's nothing fundamentally incompatible or wrong about that.
Compatibility issues?
I could see value in querying a bitcoind node over JSON-RPC for
pending transactions... and by extension, supporting that as an RPC on
various miners' pool servers.  Having a local dump of pending TX's
would be useful.
As an optional bitcoin P2P protocol command, available to anyone,
seems to negatively impact privacy.
Consensus has already approved this one, AFAIK.
Do you mean headers without bodies?  Gavin wants to work on
headers-only, from what I've read, but others are welcome to
contribute patches.
Compatibility issues?
Compatibility issues?
Compatibility issues?
Does consensus want this?
Link to elaboration of use case and need?
Well, one unfortunate current aspect of bitcoin is...  there seem to
be problems aplenty right now :)
However demotivating it may be, keeping the current system running
must take priority over new features.
I also heartily encourage others to do something I always want to do,
but for lack of time:  work on the design for bitcoin v2 ("theme: any
breaking change is acceptable, it is a new block chain")  There you
may improve the protocol, get rid of the patent-cloudy ECDSA, use
google's protocol buffers for encoding, make the proof-of-work
algorithm memory-intensive, and other excellent, thoughtful
breaking-change suggestions that have been made.
Securing the integrity of money means that a lot of implementation
decisions have been cemented into stone, however much we may
personally dislike them.  Backwards compatibility is paramount.

@_date: 2011-08-10 22:45:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] DragonFly BSD bitcoind patches 
Looks good at first glance.  Creating pull requests @ github for these two.

@_date: 2011-08-10 23:20:25
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Change to multiple executables? 
The above has been discussed on the forums.  The community seems to
consider that option one of last resort, because the consequences of
-not- upgrading immediately become "I cannot access my money."  The
community also seems rather hard-wired against breaking changes like
that, because it implies that we lowly dev peons are daring to mess
with the Blessed Satoshi Design that has received extensive study, and
100% communal agreement.
If the community changes its mind, and there are strong calls to make
a breaking change, we can certainly do that.  Bitcoin is not only open
source but very much democratic -- people vote by choosing which
client software to use.
Historically speaking, the protocol has had minor tweaks, if you check
the patch history.  Adding new protocol commands is pretty easy, for
example.  Removing commands tends to be high cost for low benefit
("protocol removes a harmless redundancy"), if you're messing with the
initial negotiation sequence.  IMO verack is not redundant, anyway.
But the answer is "what do the users want" not "no"  At the end of the
day we're here to adequately reflect the needs of our userbase at all.
 And so far, the userbase seems highly conservative when it comes to
incompatible changes.  Correct me if I'm wrong...
It's negative to weight costs vs. benefits?  That is what I expect any
good engineer to do.
In any case, our -users- are not clamoring for breaking changes of the
type you describe above, as far as I can see.  Just the opposite.  So
if you want to deploy a breaking change, the burden is on you to
convince the bitcoin users and miners that it's a good idea.
If the bitcoin dev team is not accurately reflecting the desire of its
users, then that should be corrected, and we want to hear feedback.

@_date: 2011-08-24 15:19:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [PATCH] Boost filesystem v3 support 
Your change appears to be technically correct.  It is disappointing
for  to crap up the code, though...

@_date: 2011-08-24 15:29:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [PATCH] Boost filesystem v3 support 
Yeah, I think it is fair to apply.  Just saying... a nicer version
would be... nice.  Most projects work a bit to hide this stuff in
headers, so that the actual code is a bit clean.
Now, this is a general guideline, not a hard rule.  We have plenty of
 windows code already, for example.

@_date: 2011-12-17 20:07:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Protocol extensions 
Well, the block chain data itself is internally self-validating.  As
long as you know the latest block's hash -- a big "if" -- there is no
problem downloading all other block chain data from DHT or any other
untrusted source.
In a malicious case, you would notice latest-hash differs from
non-malicious and wind up downloading multiple chains, when walking
hashes backwards through a DHT/lookup table.  So, a bit more work but
nothing fundamentally less secure _on a trust basis_.
Of course, I was focusing on data validation, which ignores other
factors such as DoS'ing the DHT.

@_date: 2011-12-21 12:12:43
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Changes for version 0.6 are being pulled 
This is not "accepted" as discussed yesterday on IRC.  You need to
find buy-in from some other miners to make sure this is what "they"
want, rather than just what "you" want.

@_date: 2011-12-21 12:17:57
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Changes for version 0.6 are being pulled 
Quoting IRC yesterday,
 jgarzik:  I defer to your judgement on coinbaser, I don't care.
Then post data backing up that vague statement.

@_date: 2011-06-30 23:23:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
This was posted to IRC:
Includes several useful features that all the big pools have been
screaming for...  notably HTTP/1.1 keep-alive support.

@_date: 2011-07-01 04:39:24
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] 0.3.24 
No objections...  I could get out 0.3.24-rc1 post-sleep, presuming
this plan (or something like it) receives Holy Alpaca Pee.

@_date: 2011-07-01 19:42:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] 0.3.24 
OK I pulled a couple other minor bits.
The only remaining question, IMO, is whether or not we should pull
     Make UPnP default on Bitcoin but not on Bitcoind.
     We are all kicking the can on this decision to Gavin I believe I think the two strong arguments for upnp are
     - other p2p apps widely deployed, notably skype, use it
     - it will make a significant positive impact in the number of
       nodes supporting incoming connections
so my personal (read: not speaking for anyone else) opinion is to turn
on upnp for bitcoin _and_ bitcoind.
Other than that, here's what we're looking at for 0.3.24:
Dawid Spiechowicz (1):
      added polish translation
Doug Huff (1):
      Add OSX App bundle and correct build instructions to reflect reality.
Eric Hosmer (1):
      Updated Visual C++ makefile.
Gavin Andresen (1):
      Boost unit-testing framework.     make -f makefile.{unix,osx,mingw} test_b
Giel van Schijndel (2):
      rpc server: send '403 Forbidden' to rejected clients
      rpc: don't send 403 when using SSL to prevent DoS
Han Lin Yap (3):
      Double check translation and improved a translation string
      Update swedish translation
      Consistent Bitcoin example address
James Burkle (1):
      Edited init.cpp to include a check that -datadir exists
Jeff Garzik (4):
      FormatFullVersion: build fix related to recent translation improvement
      doc/release-process.txt: minor updates
      CWalletTx::GetAmounts(): pass NULL for CKeyStore*, rather than false     t
      Enable DNS seeding by default.
Joerie de Gram (1):
      Fix connection failure debug output
Jordan Lewis (8):
      Only include irc.h when needed
      Only include db.h when we have to.
      Only included rpc.h when necessary
      Only include net.h when we have to
      Only include init.h when we have to
      Only include strlcpy.h when we have to
      Remove some globally unused headers from headers.h
      Only include certain boost headers if necessary.
Matt Corallo (3):
      Update translations and remove obsolete translations.
      Add new DNSSeed dnsseed.bluematt.me.
      Only use dnsseeds and static seeds when not on testnet.
Pieter Wuille (5):
      move wallet code to separate file
      CWallet class
      Bugfixes walletclass
      Fix segfault when creating new wallet
      Limit response to getblocks to half of output buffer size
Shane Wegner (1):
      Fix missing includes needed for Boost 1.46.
Wladimir J. van der Laan (1):
      add GetTotalBlocksEstimate() function, move magic number to constant

@_date: 2011-07-01 20:37:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] 0.3.24 
Hum, it sounds like there was some misunderstanding, on my part at
least.  On IRC, people are talking about a cherry-picked release,
basically 0.3.23 + a couple specific fixes, rather than what is
current in upstream git.  I had assumed people meant releasing current
git + some specific fixes not yet in git.
Wearing the Release Mangler hat, cherry-picked branches have a few
* you're throwing away the testing people have done on upstream git
* the new branch would have zero testing, as most people have been
testing 0.3.23 or upstream git
* it would be a dead-end branch, never touched after release.  bug
reports for such a release might not necessarily be applicable to last
version or current upstream or anywhere in between.
That is the convention wisdom, anyway.  But to paraphrase Pirates of
the Caribbean, release management rules aren't really rules, they're
more like... guidelines.  :)
The cherry-picked 0.3.24 release, according to IRC wisdom, wouldn't
have to worry about shipping CWallet, which needs a fix or two from
I can live with, and roll a release for, either (a) 0.3.23 + select
fixes or (b) current upstream + pull   My preference is (b), but
this is a community and Holy Alpaca decision, not just a call I will
make on my own.
Comments welcome...

@_date: 2011-07-02 23:09:11
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin v0.3.24 release candidate available 
Bitcoin v0.3.24 release candidate  is now available for download at
This is another bug fix release.  We had hoped to have wallet
encryption ready for release, but more urgent fixes for existing
clients were needed.  Wallet encryption is ready for testing at
 for the git-savvy, and
-hopefully- will follow shortly in the next release, v0.4.
Notable fixes in v0.3.24:
F1) Block downloads were failing or taking unreasonable amounts of
time to complete, because the increased size of the block chain was
bumping up against some earlier buffer-size DoS limits.
F2) Fix crash caused by loss/lack of network connection.
Notable changes in v0.3.24:
C1) DNS seeding enabled by default.
C2) UPNP enabled by default in the GUI client.  The percentage of
bitcoin clients that accept incoming connections is quite small, and
that is a problem.  This should help.  bitcoind, and unofficial
builds, are unchanged (though we encourage use of "-upnp" to help the
C3) Initial unit testing framework.  Bitcoin sorely needs automated
tests, and this is a beginning.  Contributions welcome.
C4) Internal wallet code cleanup.  While invisible to an end user,
this change provides the basis for v0.4's wallet encryption.
Full changelog ("git shortlog v0.3.23.."):
Dawid Spiechowicz (1):
      added polish translation
Doug Huff (1):
      Add OSX App bundle and correct build instructions to reflect reality.
Eric Hosmer (3):
      Updated Visual C++ makefile.
      Further updated Visual C++ makefile.
      Add keystore.h to makefile.vs's header list.
Gavin Andresen (1):
      Boost unit-testing framework.     make -f makefile.{unix,osx,mingw} test_b
Giel van Schijndel (2):
      rpc server: send '403 Forbidden' to rejected clients
      rpc: don't send 403 when using SSL to prevent DoS
Han Lin Yap (3):
      Double check translation and improved a translation string
      Update swedish translation
      Consistent Bitcoin example address
James Burkle (1):
      Edited init.cpp to include a check that -datadir exists
Jeff Garzik (6):
      FormatFullVersion: build fix related to recent translation improvement
      doc/release-process.txt: minor updates
      CWalletTx::GetAmounts(): pass NULL for CKeyStore*, rather than false     t
      Enable DNS seeding by default.
      Bump version to 0.3.24.
      Bump OSX version to 0.3.24 (missed in previous commit)
Joerie de Gram (1):
      Fix connection failure debug output
Jordan Lewis (8):
      Only include irc.h when needed
      Only include db.h when we have to.
      Only included rpc.h when necessary
      Only include net.h when we have to
      Only include init.h when we have to
      Only include strlcpy.h when we have to
      Remove some globally unused headers from headers.h
      Only include certain boost headers if necessary.
Matt Corallo (5):
      Update translations and remove obsolete translations.
      Add new DNSSeed dnsseed.bluematt.me.
      Only use dnsseeds and static seeds when not on testnet.
      Make UPnP default on Bitcoin but not on Bitcoind.
      Give more detailed error messages for connection failure.
Pieter Wuille (5):
      move wallet code to separate file
      CWallet class
      Bugfixes walletclass
      Fix segfault when creating new wallet
      Limit response to getblocks to half of output buffer size
Shane Wegner (1):
      Fix missing includes needed for Boost 1.46.
St?phane Gimenez (1):
      Fix AddressBook syncrhonization between a CWallet and CWalletDB
Wladimir J. van der Laan (1):
      add GetTotalBlocksEstimate() function, move magic number to constant
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
5340ee00a777e5b87a0d742ea931760916a1fac4  bitcoin-0.3.24rc1-linux.tar.gz
f7f941a4fc33da7225262ccaad6147352dd2b342  bitcoin-0.3.24rc1-src.tar.gz
efcdf578bb60a056c43f8dd40505461ea7d7c930  bitcoin-0.3.24rc1-win32-setup.exe
0b2560b3facba4301562441f6b8dea9eb2249d77  bitcoin-0.3.24rc1-win32.zip

@_date: 2011-07-04 22:45:38
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Encrypted Wallet Backward Compatibility 
Yeah, same thoughts here.
Tagged -tip as -rc2.
Bug reports are mostly quiet, so maybe we can even get the release
before you leave.

@_date: 2011-07-06 16:05:01
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin v0.3.24 release candidate 
Bitcoin 0.3.24rc3 has been uploaded.
Fixes appeared after -rc2 was tagged, so we just skipped straight to -rc3.
Maybe final release on Friday?
Changes since 0.3.24rc1:
Gavin Andresen (2):
      Block-chain lock-in at 134444
      Do not use comma as thousands separator     Using the comma as thousands s
Matt Corallo (3):
      Added a couple minor things to match newer build process.
      Revert "Make UPnP default on Bitcoin but not on Bitcoind."
      Enable UPnP by default on bitcoin, but not on bitcoind (on gitian)
Pieter Wuille (1):
      Fix synchronization of default key
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
dec9ff63fe6d0cffb2abc723281a4135c22f19ef  bitcoin-0.3.24rc3-linux.tar.gz
c171c6e5128d570d5d7d5a6896b672fcab778933  bitcoin-0.3.24rc3-src.tar.gz
d4b5425eff673551a326d5326b92a06359dc1a3d  bitcoin-0.3.24rc3-win32-setup.exe
0653302ac7f8b052d58667ae30da53c4f6230be5  bitcoin-0.3.24rc3-win32.zip

@_date: 2011-07-07 12:51:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Reconsider build system change? 
autotools is indeed "the devil we know" which works automatically on
all supported platforms save VC++  It is also the easiest to package,
as all distros already have macros and scripts specifically designed
to integrate autotools packages into their package build systems.
cmake simply does not have that level of uptake.

@_date: 2011-07-08 17:35:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin v0.3.24 released 
Bitcoin v0.3.24 is now available for download at
This is another bug fix release.  We had hoped to have wallet
encryption ready for release, but more urgent fixes for existing
clients were needed -- most notably block download problems were
getting severe.  Wallet encryption is ready for testing at
 for the git-savvy, and
-hopefully- will follow shortly in the next release, v0.4.
Notable fixes in v0.3.24, and the main reasons for this release:
F1) Block downloads were failing or taking unreasonable amounts of
time to complete, because the increased size of the block chain was
bumping up against some earlier buffer-size DoS limits.
F2) Fix crash caused by loss/lack of network connection.
Notable changes in v0.3.24:
C1) DNS seeding enabled by default.
C2) UPNP enabled by default in the GUI client.  The percentage of
bitcoin clients that accept incoming connections is quite small, and
that is a problem.  This should help.  bitcoind, and unofficial
builds, are unchanged (though we encourage use of "-upnp" to help the
C3) Initial unit testing framework.  Bitcoin sorely needs automated
tests, and this is a beginning.  Contributions welcome.
C4) Internal wallet code cleanup.  While invisible to an end user,
this change provides the basis for v0.4's wallet encryption.
Full changelog ("git shortlog v0.3.23.."):
Dawid Spiechowicz (1):
      added polish translation
Doug Huff (1):
      Add OSX App bundle and correct build instructions to reflect reality.
Eric Hosmer (3):
      Updated Visual C++ makefile.
      Further updated Visual C++ makefile.
      Add keystore.h to makefile.vs's header list.
Gavin Andresen (3):
      Boost unit-testing framework.     make -f makefile.{unix,osx,mingw} test_b
      Block-chain lock-in at 134444
      Do not use comma as thousands separator     Using the comma as thousands s
Giel van Schijndel (2):
      rpc server: send '403 Forbidden' to rejected clients
      rpc: don't send 403 when using SSL to prevent DoS
Han Lin Yap (3):
      Double check translation and improved a translation string
      Update swedish translation
      Consistent Bitcoin example address
James Burkle (1):
      Edited init.cpp to include a check that -datadir exists
Jeff Garzik (6):
      FormatFullVersion: build fix related to recent translation improvement
      doc/release-process.txt: minor updates
      CWalletTx::GetAmounts(): pass NULL for CKeyStore*, rather than false     t
      Enable DNS seeding by default.
      Bump version to 0.3.24.
      Bump OSX version to 0.3.24 (missed in previous commit)
Joerie de Gram (1):
      Fix connection failure debug output
Jordan Lewis (8):
      Only include irc.h when needed
      Only include db.h when we have to.
      Only included rpc.h when necessary
      Only include net.h when we have to
      Only include init.h when we have to
      Only include strlcpy.h when we have to
      Remove some globally unused headers from headers.h
      Only include certain boost headers if necessary.
Matt Corallo (8):
      Update translations and remove obsolete translations.
      Add new DNSSeed dnsseed.bluematt.me.
      Only use dnsseeds and static seeds when not on testnet.
      Make UPnP default on Bitcoin but not on Bitcoind.
      Give more detailed error messages for connection failure.
      Added a couple minor things to match newer build process.
      Revert "Make UPnP default on Bitcoin but not on Bitcoind."
      Enable UPnP by default on bitcoin, but not on bitcoind (on gitian)
Pieter Wuille (6):
      move wallet code to separate file
      CWallet class
      Bugfixes walletclass
      Fix segfault when creating new wallet
      Limit response to getblocks to half of output buffer size
      Fix synchronization of default key
Shane Wegner (1):
      Fix missing includes needed for Boost 1.46.
St?phane Gimenez (1):
      Fix AddressBook syncrhonization between a CWallet and CWalletDB
Wladimir J. van der Laan (1):
      add GetTotalBlocksEstimate() function, move magic number to constant
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
4909c17a1cc025c6f6c88d036f0b487c51c510f6  bitcoin-0.3.24-linux.tar.gz
58531249230f769fdc755822b41e0f18ba59512c  bitcoin-0.3.24-src.tar.gz
d4b5425eff673551a326d5326b92a06359dc1a3d  bitcoin-0.3.24-win32-setup.exe
520aed70ee28a0a91ed49dd983639cb1fab2a93c  bitcoin-0.3.24-win32.zip

@_date: 2011-07-10 19:31:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] overall bitcoin client code quality 
agreed -- contributions welcome
It is a long term goal to move towards 'libbitcoin"
agreed -- contributions welcome
very low priority.
contributions to existing style guide welcome
very low priority
We know the code isn't what people would prefer, but that's what we've
inherited.  Everybody has suggestions, but given limited development
resources we're swamped as is.  (hence all the "contributions welcome"

@_date: 2011-07-12 01:19:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] overall bitcoin client code quality 
This is about the last thing we should do, and it's one of the worst
coding practices of many C++ projects (and unfortunately carried over
to Java by force).  See Knuth and his work on literate programming.
Putting logically similar code -together- is often more impactful and
meaningful than splitting up files into dozens (hundreds or thousands,
in large projects) of tiny, 20-line files.
A project attains zen in the -balance-.  Bitcoin was not well served
by "everything in main.cpp" approach -- but neither is it well served
by splitting wallet / transaction / etc. logic across a great many
files.  We should not have to ask ourselves, Is This Code In
WalletFactory.cpp, WalletTx.cpp, WalletStore.cpp, WalletKey.cpp,
WalletCrypt.cpp, or in s/$F.cpp/$F.h/ ?
Strict, unthinking rules do not buy anything, and can cost us much.
Plus, no matter how you slice it, bitcoin is Hard To Learn and there's
no getting around that.

@_date: 2011-07-16 19:35:17
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] The forums... 
I agree completely.
While the owner of the forums and bitcoin.org is Missing In Action and
has not responded to emails in more than a week, we do have access to
change the main  home page, to link to another forum.
Or we could simply de-link the current forum, as a first step.

@_date: 2011-07-16 22:00:01
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] The forums... 
Hopefully sirius will do this when he moves forum.bitcoin.org to
But sirius is the only one with keys to bitcoin.org DNS, so....

@_date: 2011-07-18 20:17:21
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin v0.3.24 released 
Mac OSX version of bitcoin client finally posted at
Updated sums (stored as SHA1SUMS.asc on SF):
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
4909c17a1cc025c6f6c88d036f0b487c51c510f6  bitcoin-0.3.24-linux.tar.gz
fed0afebe0b0c0f77a637600ac4abecbe5d098ed  bitcoin-0.3.24-macosx.zip
58531249230f769fdc755822b41e0f18ba59512c  bitcoin-0.3.24-src.tar.gz
d4b5425eff673551a326d5326b92a06359dc1a3d  bitcoin-0.3.24-win32-setup.exe
520aed70ee28a0a91ed49dd983639cb1fab2a93c  bitcoin-0.3.24-win32.zip

@_date: 2011-07-27 20:15:44
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Seeking advice: Encouraging bug-fixing 
Linux kernel has not solved this problem; developers simply want to
work on interesting stuff, rather than debug, I think.
The best Linus has done so far it making certain periods of time
bugfix-only, refusing to take new feature pushes during the stability
period.  If there are critical bugs, refusing to release the kernel
until a developer fixes the regressions they added.
Linux is large enough, though, that the ecosystem has grown a support
network, where companies pay for support (one big way my employer
stays in business), which includes bug fixes.  So the paid support
orgs, like Red Hat, wind up going a lot of grunt work fixing because
they are the closest contact to actual users in the field encountering
problems with the Wonderful New Features bestowed upon them by
"drop and run" coding is a term for developers who appear, commit a
new feature, and then disappear without addressing bug reports or
other feedback regarding their contribution.

@_date: 2011-06-11 22:23:58
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Preparing 0.3.23-rc1 release 
Current git HEAD has been proposed to Gavin & the rest of the dev team
as 0.3.23-rc1.
As soon as Gavin gives his ACK, we have builds ready to upload.
We wanted this to be a fast, bugfix-only release.  The main focus was
to deploy a fix for connections taking forever, due to a large portion
of the network not accepting incoming TCP connections.
git shortlog for 0.3.23-rc1 (presuming Gavin's ACK):
Dean Lee (1):
      Updated Chinese Simp translation
Doug Huff (3):
      Fix rfc1918 and rfc3927 compliance for ignoring non-internet-routable host
      Add common temp files to .gitignore.
      Demystify a few magic numbers.
Han Lin Yap (2):
      Added Swedish translation
      Remove unused variable
Jeff Garzik (4):
      Bump version to 0.3.23.
      Reduce minimum TX fee for new transactions, to 0.0005.
      Lower minimum relay TX fee to 0.0001 (from 0.0005) BTC.
      Add minimal release process docs.
Matt Corallo (1):
      Fix CPU Usage bug when using -nolisten and have no connections.
Nils Schneider (1):
      create keypool in LoadWallet()
Pieter Wuille (3):
      Update transactions already in the wallet when rescanning.
      Fix for small change outputs
      Faster timeout when connecting

@_date: 2011-06-12 00:48:10
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [ANN] Bitcoin v0.3.23 release candidate 
Win32, Linux and source releases for bitcoin v0.3.23rc1 have been uploaded to
This is another quick bugfix release, trying to deal with the influx
of new bitcoin users.
Main items of note:
* P2P connect-to-node logic changed to reduce timeout a bit.  The
network saw a huge influx of new users, who do not permit incoming
connections.  This change is a short-term hack, to more quickly hunt
for useful P2P connections.  Better "leaf node" logic is in the works,
but this should let us limp along until then.
* Transaction fee reduced to 0.0005 for new transactions (NOTE: free
transactions are, of course, still supported as they always were)
* Client will relay transactions with fees as low as 0.0001 BTC
Full git changelog:
Dean Lee (1):
      Updated Chinese Simp translation
Doug Huff (3):
      Fix rfc1918 and rfc3927 compliance for ignoring non-internet-routable host
      Add common temp files to .gitignore.
      Demystify a few magic numbers.
Han Lin Yap (2):
      Added Swedish translation
      Remove unused variable
Jeff Garzik (4):
      Bump version to 0.3.23.
      Reduce minimum TX fee for new transactions, to 0.0005.
      Lower minimum relay TX fee to 0.0001 (from 0.0005) BTC.
      Add minimal release process docs.
Matt Corallo (1):
      Fix CPU Usage bug when using -nolisten and have no connections.
Nils Schneider (1):
      create keypool in LoadWallet()
Pieter Wuille (3):
      Update transactions already in the wallet when rescanning.
      Fix for small change outputs
      Faster timeout when connecting

@_date: 2011-06-13 05:09:53
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bootstrapping via BitTorrent trackers 
It seems to offer few benefits over DNS seeding, while potentially
potentially creating a vulnerable hot spot in the DHT.  Sybil attacks
on DHTs are well documented.

@_date: 2011-06-13 05:56:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bootstrapping via BitTorrent trackers 
And how does the client discover HTTP trackers?  You're either
hardcoding -those- into the client, or adding an additional bootstrap
step to discover them.  Either way, it has the same problems as other
current methods.
The history and experience of gnutella's web caches vs. UDP host
caches seems highly relevant here.

@_date: 2011-06-13 12:51:02
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bootstrapping via BitTorrent trackers 
No advantage over DNS (you're talking about IRC)
No advantage over DNS (you're talking about IRC)
False.  A proper DNS seed actively samples the bitcoin network for live nodes.
Irrelevant -- it's still a bunch of additional code.  We "already use"
DNS lookups as well, so I could apply similar logic to DNS seeding.
This is an invalid assumption, based on an overly simplistic sampling.
 DNS seeds are perfectly capable of returning new and useful peers on
each query.

@_date: 2011-06-13 16:16:14
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bootstrapping via BitTorrent trackers 
Agreed.  I'll see if I can put together a couple different solutions,
and stick them in there.  ETA 3-4 weeks though, given current bugfix
workload + personal issues (moving to a new house).
I had a thought related to this, but readily admit I haven't thought
this through:  create an RPC in bitcoin that returns a random
selection of fresh P2P node addresses, from addr.dat.  One problem I
was running into was accessing this data from outside bitcoin.
Using ArtForz' half-a-node as a base was a possibility, but creating
"getnodes" RPC seemed far easier.
djbdns (tinydns) is great for this:  it is highly scalable and stable,
and its input is a -very- simple text format, easier to generate than
BIND zone files.
Great!  A big missing piece is simply trusted people running DNS seeds
on stable connectivity, once the DNS software is there.

@_date: 2011-06-13 16:44:11
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Ready for 0.3.23 release? 
(cc'd the devs that I'm not sure are on the dev mailing list yet)
Version 0.3.23 doesn't seem to have major issues, and testing has been
unremarkable.  I think we can go ahead and push it out.
ACK for final release of 0.3.23?

@_date: 2011-06-13 19:46:16
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin v0.3.23 released 
Win32, Linux and source releases (MacOSX soon) for bitcoin v0.3.23
have been uploaded to
This is another quick bugfix release, trying to deal with the influx
of new bitcoin users.
Priority for next version:  wallet encryption
Main items of note:
    * P2P connect-to-node logic changed to reduce timeout a bit.  The
network saw a huge influx of new users, who do not permit incoming
connections.  This change is a short-term hack, to more quickly hunt
for useful P2P connections.  Better "leaf node" logic is in the works,
but this should let us limp along until then.
    * Transaction fee reduced to 0.0005 for new transactions (see note below)
    * Client will relay transactions with fees as low as 0.0001 BTC
(see note below)
NOTE:  There has been some fee confusion recently.  Free transactions
are supported and relayed as they always have been, according to
special anti-spam rules.  See
 for details.
Full git changelog:
Dean Lee (1):
      Updated Chinese Simp translation
Doug Huff (3):
      Fix rfc1918 and rfc3927 compliance for ignoring non-internet-routable host
      Add common temp files to .gitignore.
      Demystify a few magic numbers.
Han Lin Yap (2):
      Added Swedish translation
      Remove unused variable
Jeff Garzik (4):
      Bump version to 0.3.23.
      Reduce minimum TX fee for new transactions, to 0.0005.
      Lower minimum relay TX fee to 0.0001 (from 0.0005) BTC.
      Add minimal release process docs.
Matt Corallo (1):
      Fix CPU Usage bug when using -nolisten and have no connections.
Nils Schneider (1):
      create keypool in LoadWallet()
Pieter Wuille (3):
      Update transactions already in the wallet when rescanning.
      Fix for small change outputs
      Faster timeout when connecting
There were no changes between -rc1 and -final.  Wanted to get this out
ASAP, and move on to wallet crypto.

@_date: 2011-06-13 19:59:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Release priorities for v0.4? 
With increased reports of stolen wallets, I humbly submit that wallet
crypto should be a top priority for the next version.
Anyway...  start pulling :)

@_date: 2011-06-14 13:14:21
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bumping up against flood control limits 
The main goal was not flood control but preventing an internal buffer
memory explosion.  We already have the block chain on disk, so in
theory, if we can -eliminate- the outgoing network buffer and simply
use a pointer into the block chain file, we can send as much data as
we want.
HTTP servers certainly don't buffer huge amounts in memory; they would
keel over if so.  HTTP servers have been working on the reverse, in
fact:  moving the data-pushing over to sendfile(2) syscall and similar
This is an unfortunate relic of how bitcoin P2P code is written.  If
the remote side has reduced their TCP window to zero, bitcoin will
still buffer so that it may continue processing other P2P traffic from
other nodes.  That makes sense in the case of tiny, 31-byte address
messages -- one must handle the case of a half-sent message before
write(2) refuses additional data -- but not huge block chain download
The P2P code just wasn't written for huge amounts of streaming data,
and needs some serious thinking...  I agree 100% that it is an issue
we will start bumping into, if we haven't already.

@_date: 2011-06-15 02:06:26
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Protocol versioning 
This issue has been simmering for a while...
I agree with the following general principles, and it sounds like
others on the forums do too:
GP1) Alternative implementations of a protocol are beneficial to the ecosystem.
GP2) Tying together protocol and client version is sub-optimal, and
undesirable long term.
The current, coarse-grained scheme was clearly preferred by satoshi.
He knew what a chore creating a fully compliant client would be, and
when I joined (July 2010), was actively discouraging alternative
client efforts.  Also, tying protocol and client version together
certainly eased the deployment of changes.
Protocol development has clearly slowed, and we have at least one
major alternative client in the works (bitcoinj), so it seems fair to
revisit those assumptions and preferences.
Here are several mini-proposals for the Satoshi Client (anyone got a
better nickname?) along these lines, which should better prepare the
bitcoin protocol for the long term:
MP1) Avoid creating four-component version numbers (W.X.Y.Z), and use
pszSubVer as a client identification string.  This proposal originally
came from Mike Hearn, IIRC.
MP2) remove IP transactions in v0.4
MP3) create constants for protocol version, and audit code to split
client version from protocol version.  This is a THORNY patch, and far
more difficult than implies.  The code has various data structures and such versioned, so
it is difficult to pick out at quick glance which 'version' is which.
MP4) split protocol and client versions in v0.4 -- though you will not
actually notice a change until v0.4.1, when the client version changes
but the protocol version does not.
MP5) Use a single bit inside 'nServices' to indicate the presence of
an optional "capabilities" message.  The purpose of this is to enable
minor protocol changes without having to change the protocol version.
Thus, nodes may advertise /features/ rather than simply "I support all
features >= version X".  Most mature protocols support this sort of
thing, rather than the simpler, coarse-grained version number system.

@_date: 2011-06-15 12:50:31
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Release priorities for v0.4? 
That's what -datadir is for.  Unfortunately -all- databases must be in
the datadir, because wallet.dat is a berkeley db, and we need a
transactional environment.  That makes it difficult to move just one

@_date: 2011-06-16 13:59:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Development priorities 
Agreed, though security professionals (and luke-jr) are already
pointing out the wallet crypto mainly eliminates a bit of bad PR,
rather than being a major crime deterrent.
zooko on IRC had a pretty good suggestion:  introduce a built-in
facility for air-gapped wallets (multiple wallets), so that loss of
your everyday transactional wallet does not mean loss of everything.
You can do this manually, but we need something for all the people who
(a) don't know crypto, and (b) simply download and run the client
without thinking much about security.
Three points, on testing:
T1) autotools has a minimal testing framework built into it.  "make
check" builds, and then runs tests.  Each test is a program or script,
that returns 0 on success and 1 on failure.  "make distcheck" builds,
runs tests, and then creates the distribution tarball if the tests
T2) I wouldn't narrow the focus to "unit tests", as stress tests and
other comprehensive, automated tests are quite useful as well
but most importantly...
T3) Don't hold v0.4 release for this.  As we say in kernel-land, we
have a test lab called "the internet"  Test suites have clear software
engineering value, but they largely "guard the past" -- making sure
you don't repeat past mistakes, rather than being a good indicator of
possible upcoming problems.  The best testing is always in the field.
That always finds more problems than unit testing ever does.

@_date: 2011-06-16 17:51:16
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin v0.3.23 released 
Some minor updates to the released files:
1. Linux tarball regenerated with properly named directory inside.
2. Win32 .zip archive added.
3. PGP-signed SHA1SUM.asc added to SF
The following are the updated checksums:
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
d7a34e1151dedfba5af1bf7496ed041f5b4955e5  bitcoin-0.3.23-linux.tar.gz
42e8a86a97edcafb12d09fa69b56ad0451baa140  bitcoin-0.3.23-macosx.zip
779c6bb227801a51084be9594dc185d0a054ed53  bitcoin-0.3.23-src.tar.gz
12952b1c4a15ce55564500dace18ee22eb2feaa8  bitcoin-0.3.23-win32-setup.exe
89194d3b3ee87f450f520cf365b863e0fab8bc9f  bitcoin-0.3.23-win32.zip

@_date: 2011-06-17 18:59:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Roadmap for autotools / Qt gui merge 
I've started calling the github/bitcoin/bitcoin.git the Satoshi
Client, GUI or not.

@_date: 2011-06-18 22:12:32
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Wallet class merged -- rebasing needed 
OK, sipa pulled his wallet code movement + wallet class stuff.
Wallet import/export and crypto will need a rebase.  Other code will
too, but those are the big ticket items that we want to merge in the
short term.

@_date: 2011-06-28 13:48:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] satoshi client v0.4 priorities 
(copying part of a conversation from IRC)
IMO, wallet crypto and wallet import/export are the two "must have"
features for v0.4.  wallet crypto rationale is obvious.  sipa's wallet
import/export might need a rebase, but it seems important for further
wallet security, such as printing out and storing a private key in a
bank's safety deposit box.
autotools and other stuff can wait, if they hold up the release of
wallet crypto.

@_date: 2011-11-03 00:46:12
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Lock protocol version numbers 
On Wed, Nov 2, 2011 at 7:22 PM, Christian Decker
That's how I take it to mean:  "satoshi client" is the client
-started- by satoshi, that is actively distributed through
github.com/bitcoin/bitcoin and bitcoin.org-linked downloads.  Changing
to QT doesn't change the lingo.

@_date: 2011-09-06 22:59:38
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Testing commits 
May we assume you're working with / building upon the existing gitian
build stuff?

@_date: 2011-09-20 14:54:46
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Issue / Pulls timers 
We need to avoid a user/contributor experience of:  "my pull request
was abruptly closed with no warning"
Contributors might not track the state of the tree on a day-to-day
basis.  Thus, following the example of bugzilla.redhat.com and many
other "tracker" applications, outdated issues first initiate an
automated warning email -- usually by adding a comment to the bug
report -- that describes the policy, why the policy (closing outdated
reports) exists, and how to avoid automated report closure.
In our case, this means a "we will close pull req, unless you update
this commit in 15 days" comment should be added to the pull req.  The
comment should describe in broad terms, with links, how to rebase a
commit, what standard expectations are, etc.
Closing with no warning should be avoided.

@_date: 2011-09-20 15:10:16
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] 0.4.x stable branch 
This is the way it works for the kernel, the process on which I've
suggested we follow with bitcoin, to a small extent:
- Version X is released.  Linus now begins accepting pull requests
into torvalds/linux.git for X+1 ("merge window opens").  It is
strongly recommended that all pull requests have seen some exposure to
the public via "linux-next", which is a tree-of-trees generated from
pulling the trees of top developers.  linux-next is maintained by
another volunteer, Stephen Rothwell.
- After a week, Linus stops taking pull requests from subsystem
maintainers ("merge window closes").  At this point, a 2.5-month
stabilization and bug fix period begins.  No new features are merged
into torvalds/linux.git, and developers are expected to focus on bug
fixing.  Developers, of course, accept new features and changes into
their own trees and branches.  linux-next publishes these, while the
main torvalds/linux.git remains in bug fix mode.
- Three months after version X is released, version X+1 is released
from torvalds/linux.git top-of-tree, and the process begins anew.
- From time to time, _not_ every version, a Linux "enterprise"
distribution like Red Hat Enterprise Linux (plug plug) or Ubuntu LTS,
will maintain a kernel for a long time, for the benefit of their
customers who need stability over new feature.  Or, the community
simply decides that a kernel should be maintained for a longer period
of time.
In particular, Greg Kroah-Hartman (gregkh) maintains stable trees for
version X-1 and X-2, where he will accept fixes provided that the fix
(or a variant thereof) has been accepted in upstream.
In that case, an employee or volunteer maintains a stable branch of
the kernel.  They "backport" fixes from the main torvalds/linux.git
tree into their own gregkh/stable-2.6.36-linux.git tree.
Thus, we observe a few things that may be applied to bitcoin:
- decentralized operation, where stable branches and bitcoin-next are
not maintained by the core team
- the community decides which versions are important to maintain long term
- the core team may maintain a merge/stabilize/merge/stabilize
workflow, introducing new features without huge negative impact to
existing userbase

@_date: 2011-09-27 23:45:48
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Deprecating "midstate" in getwork? 
I think one of the pools was already working on something like that?
I'm pretty sure it can be removed, and I'm pretty sure somebody has
already field-tested that guess.

@_date: 2011-09-27 23:44:43
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Miscommitted version 
No.  Technically speaking this most recent release was 0.4.0.  That is
what is serialized in the build, and what is tagged.
Any stable version based off the most recent release would be 0.4.0.1.
And of course you're following the "upstream must have merged this fix
first" rule, right?

@_date: 2012-04-02 12:32:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Network version increase 
It would be nice to have 100000 as the baseline, "frozen" protocol.

@_date: 2012-04-11 13:00:25
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 31 
See pull  which makes a few minor revisions along these lines.
Mike's original pull still has my ACK, FWIW, too.  Can pull either.

@_date: 2012-04-12 13:12:09
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Adding request/reply id in messages 
If the peer is misbehaving, then disconnect.  Your protocol change
does not offer any clear benefits in this area, as these sorts of
attacks/misbehaviors/bugs are still just as possible, and just as
damaging (or not).
Just disconnect the strange peer!
Stateless protocols have a lot of value.  They are easiest to
implement, and easier to prove correct.  Existing clients like
ArtForz' half-a-node, variants of which are deployed all over the
place in bitcoin-land, rely on the stateless-ness to one degree or
Stateful protocols, too, have their problems as well.  One must add
code to help remain "synchronized" between local and remote states,
which your suggested change only hints at.  NFSv4 and RPC have a long
history of dealing with stateful-ness issues.  Obviously bitcoin P2P
is nowhere near as complex, but the history of NFS development offers
several lessons applicable to your proposed change.
Overall, IMO your listed reasons for needing this major change
(stateless->stateful) do not really justify the change.  Handling
initial block download can be accomplished in a number of ways, and
peer(s) may crash or return odd results.  You must handle these cases
properly, regardless of the presence of req/reply id's.

@_date: 2012-04-12 14:38:43
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin TX fill-or-kill deterministic behavior 
Not sure whether this rises to the level of a BIP or not, as it is
largely an implementation change.
One of my From-Day-One complaints about bitcoin is that transactions
behavior could be far more deterministic (predictable), from a user
standpoint.  Transactions in the current system can easily remain in
limbo forever.
One big step in making transactions behave more predictably would be
to remove transactions from the memory pool, if they have not made it
into a block for a couple days.  i.e.
1.  N = 1 or 2 or whatever the community prefers.  Ideally enough time
for a third-tier miner, mining strange TXs, finds a block.
2.  H1 = height of block chain, when a TX is received
3.  H2 = H1 + (144 * N)
4.  If block chain height reaches H2, and TX has not made it into a
block, drop TX from memory pool
Although this only impacts a small amount of TX's ultimately, what it
does do is give us the ability -- once miners have upgraded to this
rule -- to tell bitcoin users that their transactions "expire" after N
Backwards compatibility should not be an issue; clients are free to
retransmit their TX at any time, as usual, thereby "resetting the
clock" for all peers who have forgotten the TX in question.
Once in place, clients may then implement code that notices a TX has
expired (read: likely to have been forgotten by the network, assuming
they themselves have stopped retransmitting it).  Then you can start
working on wallet/coin recovery, perhaps resending with a higher fee
The above change is not really "fill-or-kill" but it should be a big
step, opening the door to deterministic TX behavior.

@_date: 2012-04-12 15:26:25
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin TX fill-or-kill deterministic 
Do you have a -specific- concern that you feel may be exploited?
Expiration already occurs at random, as nodes shut down and restart,
log on and log off the network.

@_date: 2012-04-13 12:41:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin TX fill-or-kill deterministic 
ACK, agreed
Correct.  As mentioned, this change should impact few TXs on the
existing network.
It's mostly about getting everyone to collectively agree that
transactions should expire, if they don't make it into a block.
(excl. nLockTime stuff)  A minor technical step, but also a useful
policy step.
Yes -- I think there is near-universal agreement on this user experience point.
So, to be specific... a A->B chain of transactions, that collectively
meet the network's fee requirements?  It seems quite reasonable to
accept that, sure.  ACK on concept.  A chain of length 2 seems like it
would be most common, and limiting total chain length (to 10? 100?)
for any one chain in the memory pool seems prudent.
As to the larger issue of fees...  I will readily admit I have no good ideas.
The user's experience is pretty poor:  while it might make economic
sense, from the network's standpoint, to charge for the service of
verifying and storing a transaction, the user has limited means to
determine an ideal fee.  There are also other valid economic models
(receiver pays fee) out there that may successfully sustain the
Ideally the fee, if any, is market based and negotiated.  The current
method is loose-consensus, mainly aimed at (a) combating dust spam or
(b) ensuring it becomes increasingly more expensive to fill a block,
up to the current 1MB maximum.  I think almost everyone agrees the
current fee system is an ugly, warty hack.  Problem is... like
democracy, no matter how ugly it is, people have trouble finding a
better system :)
Furthermore, many of these ideas -- like sending TX's directly to the
merchant -- involve far more direct payee<->payer communication on the
part of the wallet client than is currently envisioned by the bitcoin
P2P network design, which is broadcast-oriented.  So, it remains an
open question whether we want the base bitcoin layer to even worry
about real-time fee negotiation and direct TX transmission.
It is possible that an instant-payments layer evolves on top of the
base bitcoin block chain layer, with bitcoin transactions evolving
largely into settlements between instant-payment intermediaries large
and small.

@_date: 2012-04-14 16:20:50
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin TX fill-or-kill deterministic 
ACK on the concept
Agreed.  A TX is just a signed message.  No reason why it -must- use
mainnet's distributed notary service.
IIRC pay-to-IP was removed because it was unreliable -and- detrimental
to privacy?  ISTR Satoshi specifically disliking the privacy elements
of p2ip.
But I also have a "gut feeling" that these sorts of payments and
direct communication should be done via a wholly separate protocol
than the bitcoin P2P protocol.  Doing p2ip as it was done originally,
inside the bitcoin P2P protocol, was a mistake.  Extensible as it is,
I think a better job -- and faster evolution -- can be done with a
separate protocol on a separate port.
Some HTTP derivative would probably make life easier for mobile
payments and firewalled scenarios, and for client->merchant
communications, for instance.

@_date: 2012-04-14 18:49:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin TX fill-or-kill deterministic 
Looks like you're already headed in the right direction :)

@_date: 2012-04-15 11:17:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin TX fill-or-kill deterministic 
2012/4/15 Jorge Tim?n :
No, not changing the protocol.
Further, adding a field to TX would imply the client needed to rewrite
the TX for each retransmit, changing the hash.  Not good at all.
Typically no, because 99.9% of TX's make it throughout the network in
seconds.  But yes it is possible, just like it is possible today to
receive a TX at various times.

@_date: 2012-08-02 12:43:25
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Version 0.7 release planning 
There seems to be consensus that we should go ahead and do a release,
before leveldb or ultraprune or anything major lands.  There is no
major landmark feature, but just a useful collection of small changes.
 It seems like a good time to Release Early, Release Often and make a
checkpoint release.
Some rough draft release notes were dumped in
Opening the floor...  What do we collectively want to happen, before
0.7 release?  What is the todo list for 0.7?
After cleaning out some pull requests yesterday, and looking at the
list today, I see
1) CreateNewBlock: Child-pays-for-parent / Add transaction fee later
luke-jr 2) Translations update 2012-08-01 (fetched from Transifex)
Diapolo 3) Add address groupings RPC from coderrr's coincontrol patches.
gmaxwell 4) Add 'mempool' P2P command, and extend 'getdata' behavior
jgarzik 5) PROBABLY NOT, BUT MAYBE: Relay blocks as a "preview" before
checking the transactions in them
luke-jr 6) JSON-RPC method: prioritisetransaction  luke-jr 7) HOPEFULLY: Addnode optimization and addnode access via RPC
BlueMatt 8) MAYBE: Transition to requiring block height in block coinbases
gavinandresen 9) WE MUST PICK ONE: RPC: lock push-down, preparing for
parallelization opportunities
jgarzik     or
RPC: add facility to enable RPCs to run outside cs_main, wallet locks
jgarzik 10) I THINK WE WANT THIS?  Make IPv6 support optional again (defaults
to enabled)
luke-jr 11) MAYBE: getblocktemplate ('getmemorypool', post IRC debate)
luke-jr Devs -- feel free to commit directly to doc/release-notes.txt if there
is a missing commit, or something that may be better described.

@_date: 2012-08-02 12:45:29
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Version 0.7 release planning 
Procedural note:  since Gavin is on vacation, this release obviously
won't occur for at least a couple weeks.
If Gavin appears on email or IRC, though, I might try to pounce on him
and convince him to let us go ahead with 0.7-rc1, if the other devs
are happy.

@_date: 2012-08-13 10:24:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP: Custom Services 
heh, this is not a new idea.  I even implemented a pull request for
service discovery myself, which simply consisted of querying the list
of supported commands:
On IRC, I proposed several alternatives including modifying 'version'
(which you did) and a new "getcaps" (get capabilities) command to be
added in protocol_version X.
gmaxwell seems continually unenthused, and made a valid point about
service advertisement:  these capabilities are not advertised with
CAddress, so how does one usefully discover and make use of them?
What are real world use cases, that cannot be solved with nService
My only response is a weak one:  inevitability.  It seems likely that
-somebody- will implement their own P2P commands for their own client
subset, even if only a simple "use 'getstatus' with strSubVer matching
Therefore, if it is inevitable, we might as well make some basic rules
about how to extended your P2P command set.

@_date: 2012-08-13 11:57:59
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Protocol changes for SPV clients: mempool, 
A small change to the protocol is proposed for satoshi client v0.7
(upcoming release):
    Add 'mempool' P2P command, and extend 'getdata' behavior
    The genesis of this command is to permit SPV clients to access the
memory pool, but secondary uses include diagnostics and miner download
(so that miners won't miss lucrative TX's due to node restart).
"getdata" behavior is extended to include any memory pool transaction,
relaxing a previous "getdata" restriction.
Didn't feel this warranted a BIP, but can write one if people really want one.

@_date: 2012-08-16 13:32:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 35: add mempool message 
Consensus was we should do a BIP for all P2P changes, so here it is...
 feedback requested.
See

@_date: 2012-08-16 14:04:13
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 35: add mempool message 
A simple guarantee of 1:1 correspondence between request and response.
 The bitcoin protocol sometimes simply elides a response when the
response would be empty, and this makes it difficult to know whether a
request is timing out or already processed.
Sending a ping(nonce) after each P2P command is another way of achieving same :)
An nServices bit would be a better fit for this optional service, but
nServices bits seemed like a scarce resource, so I elected to be
Absent the scarce-resource concern, I'd vote for an nServices bit.

@_date: 2012-08-16 17:05:58
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 35: add mempool message 
On MSG_MEMTX:  The current version has a much higher Just Works value.
On empty "inv":  It is generally better to do something
unconditionally, than have a response generated only under certain
And Alan is correct to note that unknown messages are ignored
(intentionally, for expansion).  However, unconditionally returning a
response has little to do with feature probing/discovery.  It is
simply a clear, deterministic indication that processing is complete,
for each invocation.

@_date: 2012-08-17 12:51:33
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 35: add mempool message 
OK, just updated 'mempool' branch to not return "inv" if mempool is empty.
MSG_MEMTX is not a good idea for this use case.  Just sent a ping(nonce).
Bitcoin P2P processes requests in-order, and responds accordingly.
The remote end may insert asynchronous messages into the response
stream, certainly, but responses to queries are processed and returned
in-order.  A 'getdata' response is fully sent before a 'ping' response
is sent, etc.

@_date: 2012-12-03 17:34:12
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
His point (pun intended) stands.  SMTP uses "." terminator, which also
causes annoying confusion.
You shouldn't need to escape and unescape data that is not being
interpreted in any way.

@_date: 2012-12-12 16:37:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] RFC: Updating dust output definition, 
URL: 1) Create COIN_DUST constant, to represent the dust spam limit used.
2) Decrease COIN_DUST to 0.001 BTC
Rationale: With the increase in bitcoin value (US$13.67 as of this
writing), it seems reasonable to reduce the value level of which we
consider "dust spam."
3) Update TX miner and relay fee defaults to 0.001 / 0.0005 BTC respectively
Rationale: Reflects growth of dust spam in unspent transaction output dataset.
Review of impact:
a) Definition of COIN_DUST reduced from 0.01 to 0.001.
b) Miners who mine with this code will require a fee >= 0.001 to
include TX's with outputs <= COIN_DUST
c) Normal clients will require a fee >= 0.0005 to relay TX's with
outputs <= COIN_DUST

@_date: 2012-12-16 21:18:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
On Sun, Dec 16, 2012 at 4:15 PM, Melvin Carvalho
I thought this had already been covered up-thread?
When creating something that must be hashed and/or compared, the data
structure must be created and reproduced precisely, byte-for-byte.
JSON offers significant -disadvantages- in this regard.  With JSON,
you would therefore require an additional middle layer, between JSON
and application, ensuring that all fields are output in the same
order, all whitespace is not only perfectly preserved -- but reliably
generates identical whitespace output for identical inputs, given two
separate JSON implementations.

@_date: 2012-01-15 17:37:05
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoin.org SOPA/PIPA blackout 
There are always issues that raise ire and moral outrage.  I would
rather that bitcoin.org stay apolitical -- our users will appreciate
this in the long run.

@_date: 2012-07-06 11:10:48
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 34: Block v2, Height in Coinbase 
Please review and comment...
Block v2, Height in Coinbase
  BIP: 34
  Title: Block v2, Height in Coinbase
  Author: Gavin Andresen   Status: Draft
  Type: Standards Track
  Created: 2012-07-06
Bitcoin blocks and transactions are versioned binary structures. Both
currently use version 1. This BIP introduces an upgrade path for
versioned transactions and blocks. A unique nonce is added to newly
produced coinbase transactions, and blocks are updated to version 2.
1.    Clarify and exercise the mechanism whereby the bitcoin network
collectively consents to upgrade transaction or block binary
structures, rules and behaviors.
2.    Enforce block and transaction uniqueness, and assist unconnected
block validation.
1.    Treat transactions with a version greater than 1 as non-standard
(official Satoshi client will not mine or relay them).
2.    Add height as the first item in the coinbase transaction's
scriptSig, and increase block version to 2. The format of the height
is "serialized CScript" -- first byte is number of bytes in the number
(will be 0x03 on main net for the next 300 or so years), following
bytes are little-endian representation of the number.
3.    75% rule: If 750 of the last 1,000 blocks are version 2 or
greater, reject invalid version 2 blocks. (testnet3: 51 of last 100)
4.    95% rule ("Point of no return"): If 950 of the last 1,000 blocks
are version 2 or greater, reject all version 1 blocks. (testnet3: 75
of last 100)
Backward compatibility
All older clients are compatible with this change. Users and merchants
should not be impacted. Miners are strongly recommended to upgrade to
version 2 blocks. Once 95% of the miners have upgraded to version 2,
the remainder will be orphaned if they fail to upgrade.
 and

@_date: 2012-07-06 12:49:12
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 34: Block v2, Height in Coinbase 
With the existing setup (sans height in coinbase), you might not have
unique transactions, with all that entails.
Gavin wrote some notes on upgrades and BIP16 lessons-learned at
Jeff Garzik
exMULTI, Inc.
jgarzik at exmulti.com

@_date: 2012-07-09 16:44:50
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Random order for clients page 
Agreed, and this would be why I support revert -- pull requests are
for anything non-trivial.  This practice of pull requests clearly
should be followed in the case of controversial changes.

@_date: 2012-07-16 19:47:02
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoin.org - remove hackathon 
ACK on removing outdated material
Vladimir does raise a fair point, though.  Hackathon seems appropriate
for bitcoin.org as it is focused on dev-related activities.  (full
disclosure: speaking at bitcoin2012.com)  The conference might or
might not be.  The conference does seem community focused, so I don't
object to it being on bitcoin.org...  But if consensus prefers
otherwise, that's OK too.
PS.  This seems like material for pull requests, which is preferred
over mailing list email + git push.  When working on the satoshi
client, we all ACK each other's pull req for anything beyond the

@_date: 2012-07-22 15:16:59
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [ANN] pynode: Simple bitcoin P2P node 
Github URL: pynode is a simple bitcoin P2P client, based on ArtForz' half-a-node,
which maintains a blockchain database and TX memory pool.
It is intended to be a useful base for another projects, such as
network monitoring nodes.
At present, it is mainly for developers and not end users.  Here is
what pynode does NOT do:
*    RPC
*    key management (wallet)
*    script verification
*    chain re-org
Here are the limited things that pynode can do at present:
*    Outgoing TCP connection to a single remote P2P node
*    Initial blockchain download
*    Maintain a transaction memory pool, with TX's removed as they are
confirmed in blocks
*    Maintain an indexed blockchain database
Over time it will become more capable, but this is an alpha quality
release for developers at present.
Contributions welcome!  It is intended to become a full, wallet-less
node over time (though if somebody wanted to contribute a wallet
module, that is OK too)

@_date: 2012-07-23 02:07:39
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Coinbase script parse failures 
While writing the script engine for pynode, I ran a test to validate
my script tokenizer -- a python script which does nothing more than
split up scriptPubKey and scriptSig into component opcodes and data
elements.  No execution, just tokenization of the script's data
Scanning the entire blockchain, my script found over 8,000
tokenization failures, and 100% of those were in coinbase
transactions' scriptSig.  The scripts used to generate this can be
found at The following data dump are just the first few, and most recent few,
of the invalid scripts I found in the blockchain:
Scanning block  000000000000046acff93b0e76cd10490551bf871ce9ac9fad62e67a0
7ff1d1e (1 tx)
   TX 50cfd3361f7162b3c0c00dacd3d0e4ddf61e8ec0c51bfa54c4ca0e61876810a9
      txin 0 parse failed
Scanning block  0000000000000743c432f84ad688b7b60d1474ccd7baa3d762df0b3f5
1205712 (1 tx)
   TX 587da4d4870515e57efc27623aa92fae0b7aef5908162de57fef0bbe6382be73
      txin 0 parse failed
Scanning block  00000000000007fe6ecd20a8c454cd43c78d912b499c46a1179e30f7c
ff002b3 (1 tx)
   TX 4c8f43c5115c5f29f3761176fa59cde2de2ad976efcbc5faae8ee79fa5dd6264
      txin 0 parse failed
Scanning block  00000000000006a0bc3be527033c02d3bcfa72af2f4213c4b0feec923
9573342 (336 tx)
   TX f0ba80ce080eb49148b69c47d744bbb85e4e07e4e4d0273b402c0989d79c359c
      txin 0 parse failed
Scanning block  00000000000001c3bacc869917cacdafb6e00c552ac294835107b574a
44a0362 (38 tx)
   TX 4c91f5ad0616df92165819902d0b117d9e68345f5fe964de6146f89838b9295e
      txin 0 parse failed
Scanning block  00000000000000e3d3eaf93600684b085df7d58f84ef952c91e84eb4a
251d5d8 (128 tx)
   TX 5ee371d65e323934570566b1d92dceb8456e887814da8ef2a53971683bd11da4
      txin 0 parse failed

@_date: 2012-07-26 01:50:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin script opcode counts 
Just run a query over the entire blockchain, looking at script opcode
use. I counted the number of times each opcode was used, in total:
(data in full)
OP_0 104
OP_1 27
OP_2 12
OP_2OVER 182
OP_2SWAP 182
OP_3 16
OP_4 1
OP_CHECKMULTISIG 22
OP_CHECKSIG 12188693
OP_CODESEPARATOR 14
OP_DEPTH 182
OP_DROP 19
OP_DUP 11699991
OP_EQUAL 88
OP_EQUALVERIFY 11699985
OP_HASH160 11700067
OP_IF 182
OP_IFDUP 182
OP_MIN 4
OP_NOP1 1
OP_NOP2 15
OP_NOP 5
OP_PUSHDATA1 18
OP_PUSHDATA2 4
OP_PUSHDATA 32350369
OP_SHA256 2
OP_VERIFY 182

@_date: 2012-07-29 14:48:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] script tests - invalid script in 
+1  they are a useful, cross-platform test tool.
pynode will be making use of them shortly.

@_date: 2012-06-13 16:46:37
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, SPV clients 
An IRC discussion today covered additional needs of lightweight
clients.  Here is a draft of proposed new P2P commands, and associated
behavior changes.  This is not meant to be a formal, detailed
specification but rather rough picture of the preferred direction.
     -----
filterinit(false positive rate, number of elements): initialize
per-connection bloom filter to the given parameters.  if the
parameters create a too-large table, the operation fails.  returns a
'filterparams' message, with bloom filter construction details.
filterload(data): input a serialized bloom filter table metadata and data.
filterclear(): remove any filtering associated with current connection.
filteradd(hash data): add a single hash to the bloom filter.  WARNING:
although easier to use, has privacy implications. filterload shrouds
the hash list; filteradd does not.  it is also less efficient to send
a stream of filteradd's to the remote node.
mempool():  list TX's in remote node's memory pool.
     -----
'filterload' and 'filteradd' enable special behavior changes for
'mempool' and existing P2P commands, whereby only transactions
matching the bloom filter will be announced to the connection, and
only matching transactions will be sent inside serialized blocks.
A lightweight ("SPV") client would issue 'filterload', sync up with
blocks, then use 'mempool' to sync up to current TX's.  The
'filterload' command also ensures that the client is only sent 'inv'
messages etc. for the TX's it is probably interested in.
The 'mempool' command is thought to be useful as a diagnostic, even if
a bloom filter is not applied to its output.
A bloom filter match would need to notice activity on existing coins
(via CTxIn->prevout) and activity on a bitcoin address (via CTxOut).

@_date: 2012-06-15 09:26:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
This is a fair point that sipa raised.
Consensus concluded that 'filterload' includes all necessary metadata
required to initialize a bloom filter.  That implies 'filterinit'
would only be needed for 'filteradd'.  If we don't think 'filteradd'
has a compelling use case, filterinit + filteradd can be dropped.
Yes, the format is something that must be hashed out (no pun
intended).  Need input from potential users about what information
they might need.

@_date: 2012-06-15 11:32:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
Here's the "mempool" implementation:
SPV nodes would definitely want to sync up their mempool upon startup.
 As for full nodes... I like the organic growth and random nature of
the mempools.  On the fence, WRT full node mempool sync at startup.

@_date: 2012-06-15 12:40:46
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] New P2P commands for diagnostics, 
filterload loads a whole new bloom filter from scratch, in one atomic
operation.  Params set, table sized, data input into table.  A
separate filterinit does not make sense for filterload.

@_date: 2012-06-15 13:17:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] SatoshiDice and Near-term scalability 
Changing the block size is an item for the hard-fork list.  The chance
of the block size limit changing in the short term seems rather low...
 it is a "nuclear option."
Hard-fork requires a very high level of community buy-in, because it
shuts out older clients who will simply refuse to consider >1MB blocks
Anything approaching that level of change would need some good, hard
data indicating that SatoshiDice was shutting out the majority of
other traffic.  Does anyone measure mainnet "normal tx" confirmation
times on a regular basis?  Any other hard data?
Clearly SatoshiDice is a heavy user of the network, but there is a
vast difference between a good stress test and a network flood that is
shutting out non-SD users.
Can someone please help quantify the situation?  kthanks :)

@_date: 2012-06-15 20:13:21
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposed new P2P command and response: 
Outside of major features advertised network-wide in nService bits,
P2P protocol lacks a good method of enumerating minor features or
extensions.  The version number increment is coarse-grained, and is
not self-documenting.  A simple extension which lists supported
commands is added, as demonstrated in this pull request:
     Another option is for verack to return this information at login,
eliminating the need for a separate command/response.

@_date: 2012-06-17 11:19:53
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposed new P2P command and response: 
What is missing here is some perspective on the current situation.  It
is -very- easy to make a protocol change and bump PROTOCOL_VERSION in
the Satoshi client.
But for anyone maintaining a non-Satoshi codebase, the P2P protocol is
already filled with all sorts of magic numbers, arbitrarily versioned
binary data structures..  already an unfriendly zoo of complicated and
potentially buggy interactions.  There is scant, incomplete
documentation on the wiki -- the Satoshi source code is really the
only true reference.
I see these problems personally, trying to keep ArtForz' half-a-node
running on mainnet (distributed as 'blkmond' with pushpool).
In an era of HTTP and JSON, NFS and iSCSI, bitcoin's P2P protocol is
woefully backwards, fragile, limited and inflexible when it comes to
parameter/extension exchange and negotiation.  Even iSCSI, that which
is implemented on hard drive firmware, has the ability to exchange
key=value  parameters between local and remote sides of the RPC
Calling the current P2P protocol "simple" belies all the
implementation details you absolutely -must- get right, to run on
mainnet today.  Satoshi client devs almost never see the fragility and
complexity inherent in the current legacy codebase, built up over

@_date: 2012-05-02 19:04:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] new bitcoin.org clients page 
Personally, all this seems far too focused on a centralized website
(bitcoin.org), and presents far too many choices at once to the user.
On bitcoin.org (registered by Satoshi), I would rather see the Satoshi
reference client and perhaps an "other clients" link on the wiki.
Modern websites are working hard to _reduce_ the number of download
links, not _increase_ them.  See, e.g.
 where a single download choice
is presented, and then an "other options" link is below the great big
download button.
Rather than fighting over what a particular bitcoin.org page should
look like, why not maintain an independently managed
BitcoinClients.org website?  Or GetBitcoinClient.org or somesuch.
Solve this problem in a distributed fashion, rather than stuffing it
all onto bitcoin.org.  Bitcoin.org, IMO, is the home of the "reference
project" not the entire bitcoin community.  Emphasizing that months
ago was why the forum was moved to bitcointalk.org.

@_date: 2012-05-11 21:42:32
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] IPv6 bitcoin support now live 
sipa just pushed out IPv6 support to bitcoin/bitcoin.git, and we have
a few IPv6 nodes live on the network already.
If you have IPv6, please pull the latest bitcoin and test!
(and if you do not yet have IPv6, visit  and get some)

@_date: 2012-05-16 14:22:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 33 - Stratized Nodes 
Makes sense.
In an idealized model of a client as a set of private keys, they will
want to (a) notice new activity on these keys, (b) notice increased
confidence on existing transactions with those keys [confirmations],
and (c) be able to submit to the network new transactions.  Your
proposal covers those bases, I believe.

@_date: 2012-05-16 14:18:27
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] P2P feature discovery (was Re: BIP 33 - 
I do not object to the concept, but the discovery process should be
improved.  Even venerable SMTP has a better, more flexible
capabilities discovery process.
Instead of further overloading service bits in the version message, or
altering the version message, let us instead make feature discovery an
easy, flexible, extensible process.
We can add new commands without impacting older nodes, so let's create
a new command "get-features" (or pick your name) that returns a list
of key/value pairs.  The key is a string, the value type is determined
by the key.
Standard behavior of clients would be to send "get-features" after
seeing remote version info, as part of the initial connection
In any case, the basic point is to move FAR away from fighting over a
limited, inflexible resource (service bits in "version" msg) to
something string-based and easily extensible.
I can create this as BIP 34, if people wish.

@_date: 2012-05-16 14:38:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] P2P feature discovery (was Re: BIP 33 - 
If the peer list becomes too, um, stratified maybe that's a Big Hint
that said clients should be using another network entirely, and not
overloading bitcoin's P2P network for wholly unrelated tasks.  The
bitcoin P2P network is not a general message transit network.
Another argument against the proposal, IOW, if you ask me....

@_date: 2012-05-24 12:33:12
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Punishing empty blocks? 
There appears to be some non-trivial mining power devoted to mining
empty blocks.  Even with satoshi's key observation -- hash a fixed
80-byte header, not the entire block -- some miners still find it
easier to mine empty blocks, rather than watch the network for new
Therefore I was wondering what people thought about a client
implementation change:
     - Do not store or relay empty blocks, if time since last block < X
       (where X = 60 minutes, perhaps)
or even stronger,
     - Ensure latest block includes at least X percent of mempool
unconfirmed TXs
The former is easier to implement, though there is the danger that
no-TX miners simply include a statically generated transaction or two.
The latter might be considered problematic, as it might refuse to
relay quickly found blocks.
Comments?  It wouldn't be a problem if these no-TX blocks were not
already getting frequent (1 in 20).

@_date: 2012-05-24 13:23:44
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Punishing empty blocks? 
Work in this area is already progressing, though it is outside the
scope of this proposal regarding lazy miners and empty blocks.

@_date: 2012-05-24 14:16:51
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Punishing empty blocks? 
Yes.  This was stated in the original email.
At current rates it is potentially years before that point is reached

@_date: 2012-05-24 17:00:42
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Punishing empty blocks? 
This is simply not true given current available data, i.e. the current
blockchain and ongoing not-spam transaction rate/pool.
According to your own numbers even, this is not true.  99% of the
network runs a wide variety of rules and versions.  Even with a
"critical" security announcement, the percentage of those running the
latest version is not large.
Miners are not the -only- ones that get a say in what is spam, and
what is not.  If miners are generating garbage, network users have the
right to veto that garbage.

@_date: 2012-05-24 20:51:09
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Punishing empty blocks? 
Look at the time since last block, and correlate with the number of
non-spam TX's in the memory pool at the time.  It is obvious which
ones are quick blocks (<60 seconds since last block, no big deal) and
which ones are the lazy miners (> 120 seconds since last block).

@_date: 2012-05-24 21:17:53
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Punishing empty blocks? 
The times in your log are very accurate, assuming your system clock is
remotely accurate.

@_date: 2012-11-25 00:42:51
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin and ISO 
A forum post worth tracking: Every little standardization helps.

@_date: 2012-11-26 18:52:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
1) Payment message should include ability to specify the transaction
_or_ a transaction id sent via normal means over the network.
2) I think a significant bitcoin userbase will want to operate outside
the full root-CA chain.  Just look at https:// websites now.
Self-signed certs are quite common, because it is easier, while being
more secure than http://
So some provision for self-signed certs, a use case in wide use
elsewhere, or equivalent thereof, seems reasonable.

@_date: 2012-11-27 15:34:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [ANNOUNCE] picocoin and libccoin -- C-based 
Source code URL:  I'd like to announce another bitcoin implementation, which is really
two useful pieces in one:
     libccoin - a bitcoin library, written in C
     picocoin - A lightweight, C-based SPV bitcoin wallet client
libccoin supports all key network datastructures (block, transaction,
etc.), script parsing and validation, transaction and block
validation, a "headers-only" or full block database, and many other
features essential to any bitcoin client.  libccoin passes all key
encoding, script and transaction tests available in the Satoshi
reference bitcoin client.
picocoin is much more under construction.  When complete, it will be a
very low resource, command line / JSON-driven bitcoin wallet.
Advanced security features already implemented include required wallet
encryption, fork-based process separation of P2P networking and wallet
(and chroot/SELinux jailing coming soon), something that the reference
Satoshi client does not even support.
Status:  Alpha quality, developer release.  Passes reference client
base58/script/transaction tests, but is still a developer-only
Feature list:
    Intended to be a full-feature bitcoin support library.  The
library will not be limited to "what picocoin needs."
    Supports all core data structures and network messages
    Full script implementation
    Passes hundreds of available reference client tests
    Supports multiple block chains: main or testnet3
    Very low resource usage (cpu, disk, and memory)
    Small codebase (both source code and compiled object)
    Supports advanced thin-client features such as "bloom filtering",
an upcoming proposal that will reduce client bandwidth usage.
    Works on big endian machines, as well as little endian machines
    Multi-platform: Linux supported currently.  Should work on
OSX/BSD/Windows with minimal modifications.
    libccoin should work on Windows.  picocoin will work on Windows,
but be a bit less secure than other platforms due to lack of fork.
    Improved security:  fork-based process separation firewall between
networking and wallet code -- your wallet is never directly exposed to
the network.
    Follows the philosophy of "do, not hype."  This library is already
far more secure and capable than other libraries hyped as the "future
of bitcoin" by their authors.
Code contributions are welcome (see github URL above).
Comments are welcome.
Donations are welcome too (1BrufViLKnSWtuWGkryPsKsxonV2NQ7Tcj).

@_date: 2012-10-02 14:07:05
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment protocol thoughts 
To be specific, do you mean
a) paid twice
     or
b) sent BF coins, then sent the same coins elsewhere
Double-spend is a specific technical term....
Jeff Garzik
exMULTI, Inc.
jgarzik at exmulti.com

@_date: 2012-10-03 13:43:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] performance testing for bitcoin 
You have to be specific about what you're measuring, because
"performance" is vague.
You can measure many aspects of blockchain performance by importing
blocks via -loadblock=FILE.
Other performance measurements like "how fast does a block relay
through the network" cannot be as easily measured.

@_date: 2012-10-03 15:53:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] 0.7.1 release 
Agree, though needs testing
Agree, though sipa raised a valid issue.  lockunspent, like the
existing listunspent, is wallet based.
As raw transactions might spend outputs _not_ in the wallet,
lockunspent would miss those.
I think this is OK, because listunspent is already wallet-based, but
it should be noted.

@_date: 2012-10-09 19:12:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] On bitcoin testing 
Copying from a response posted to "Bitcoin software testing effort"
 as it is relevant to
a recent thread here...
Any level of testing is useful and appreciated.  Various types of
testing that are helpful:
* "it works" testing:  Simply run the latest Release Candidate (or
latest version, if released).  Make sure all the basics work (for
whatever definition of "basics" you desire).  This is the level most
accessible to casual users.
* Major features testing:  Develop a short checklist of must-work
features, and organize volunteers to work together and go through that
checklist, item by item.  Test each major feature on each major
* Stress and fuzz testing:  Attempt to "stress" the system somehow, or
randomly corrupt bits of data.  See what breaks.
* Regression testing:  Record bugs fixed, and develop automated test
cases that successfully reproduce the bugs on older versions, and
verify newer versions remain fixed.
* Unit function testing:  Rigorously exercise each C++ class to ensure
it behaves as expected at a micro level.
* Full peer automated testing:  Automated testing of RPC and P2P
functions is non-existent, because of the difficulty in doing so.
Find a solution to this problem.
* Data-driven tests: If possible, write software-neutral, data-driven
tests.  This enables clients other than the reference one (Satoshi
client) to be tested.  Embed tests in testnet3 chain, if possible.
The community at large can be a big help simply by doing the first
item:  download and run the Release Candidates and the latest version,
and report any problems.  Even reporting success is fine by me, for
example: "Version 0.7.1 works for me on Windows 7/32-bit" posted on a
forum thread.
It is always very difficult to organize any sort of testing regime
with open source volunteers that come and go.  Each volunteer chooses
their level of involvement.  Any amount of testing and test-case
writing, large or small, is helpful to bitcoin.

@_date: 2012-10-10 14:40:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Post-0.7.1 tree freeze for ultraprune 
Proposal:  following 0.7.1 release, freeze the tree.  Do not pull
anything, until ultraprune is pulled (or rejected, but I think the
latter is unlikely).
Common sense exceptions still apply (critical bug fixes, etc.)
Ultraprune does not need to be "perfect" to be pulled... this pull
would occur at the beginning of 0.8, leaving lots of room for
hammering out final details in-tree.  The main hurdle is really
getting everyone to ACK the overall design and direction of the
ultraprune branch, especially Gavin.
Collecting those high-level design ACKs is more important to bitcoin
overall than even fine-grained code review; code mistakes can be fixed
in-tree during 0.8 development, once we all agree this is the correct
_design_.  The real code mistakes and "sharp edges" will only be found
now with wide field testing.
For the record:  yes, Design-ACK from me.

@_date: 2012-10-11 15:20:16
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] 0.7.1 release candidate 1 ready for 
On Thu, Oct 11, 2012 at 1:51 PM, Arklan Uth Oslin
As you like, but... bitcoin-devel is quite low traffic, so there is
not exactly an issue of crowding.  And a separate list means people
cannot chime in as easily.

@_date: 2012-10-12 15:30:32
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin cookbook 
Created a forum thread "Bitcoin cookbook", to collect real world, step
by step examples of some of the more advanced uses of bitcoin:
If you have a recipe to contribute, create a new thread, then mention
your thread in the cookbook.
Maybe some of this will migrate to the wiki, but the wiki itself tends
to be a poor place for discussion and questions.

@_date: 2012-10-24 17:55:34
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Draft BIP for Bloom filtering 
Correct me if I'm wrong but...  I do not think there is any bound on
mempool size.
My proposal to age-out long-unconfirmed transactions is related, but
does not completely solve the unbounded-size issue.

@_date: 2012-09-14 03:40:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] separate out blockchain db and wallet to 
Indeed.  See many threads on the forum discussing this...  a
frequently requested feature.
As Wladimir says, it's a database constraint at the moment.

@_date: 2012-09-22 03:28:05
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Atomic coin swapping? 
Forum URL: gmaxwell was talking about colored coins[1] in IRC recently.  They are
potentially interesting in the context of distributed bonds[2], which
I am currently pursuing with pybond[3].
Here is the problem I am trying to solve, does the crowd have an answer?
1. Alice transfers a 1-satoshi colored coin to Bob.
2. Bob transfers 100 BTC to Alice.  May be restricted to 1 txout, if
that eases implementation details.
3. Steps  and  happen as an atomic unit, all-or-none.
4. Alice and Bob must both approve this atomic transfer of coins, with
appropriate signatures.
Is this possible within the current bitcoin system?  As far as I can
see, the answer is "no" but maybe I'm missing something.
My best guess to the answer is "possible, but requires a new SIGHASH_* type"?
[1] [2] [3]

@_date: 2012-09-22 13:09:16
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Atomic coin swapping? 
Yes, SIGHASH_ALL was the crucial piece I was missing.
I have updated the post to add a concrete example with as much detail
as necessary for programmers to recreate.  Review requested:

@_date: 2012-09-23 16:30:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Large backlog of transactions building up? 
Yeah, my public nodes currently have 2200+  Over time, it gets
cluttered naturally due to the disconnect between what miners mine and
what relayers relay.
I've long argued that all mempool implementations should limit the
lifetime of any TX to a specific number of blocks.  Rationale:
- bitcoin clients retransmit until TX is confirmed
- provides a deterministic lifetime for a TX; if you KNOW a TX will
disappear 144 blocks (24 hours) after you stop transmitting, then it
is probably safe to initiate recovery procedures and perhaps revise
the transaction
- prevents zombie TXs from littering memory... they hang around,
wasting resources, but never get confirmed
No one has strenuously argued against this, so I suppose it is down to
writing a patch, and coming up with a good number we (as a network)
can agree upon.

@_date: 2012-09-26 13:10:31
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin Testing Project 
As a goal or general principle, this is agreeable.
But slavish attention to this will only get ignored.  There is finite
developer resources, and regression tests for certain types of bugs,
like prickly P2P network interaction bugs or RPC API bugs, could
potentially involve many days or weeks of coding, to sufficiently
simulate the environment.  The ability to easily, automatically and
programmatically reproduce certain classes of bugs is simply out of
reach right now, and nobody is going to shut down development to fix
that problem.
We should move towards this direction, yes, but bitcoin test cases are
not always going to be as easy as writing (say) a compiler testcase.
We can always use the help of a few good QA coders:  simulating a P2P
environment and checking the RPC API are two examples of very
complicated problems that -can- be automated for testing... with a lot
of work.

@_date: 2013-04-02 23:51:45
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoin pull requests 
Correct, that rules out github, AFAICS.
Though, honestly, when I ACK that means I read the code, which is more
important than the author really.  github seems fine for that still,
though I do wonder if there is a race possible,
* sneak uploads innocent branch sneak/bitcoin.git * sneak creates pull req
* just before I click "pull", sneak rebases the branch to something evil

@_date: 2013-04-08 01:42:39
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] DOS-Attacks on bitcoin-client? 
BTW, check out the blockchain torrent, as one way of offloading some
of the download bandwidth used from the P2P network:
     Bitcoin blockchain data torrent

@_date: 2013-04-08 21:22:10
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] On-going data spam 
petertodd: yeah somebody put a file upload tool into the chain
and then tried to upload the entire amibios source code to it. stupid.
 someone thinks it's a lot more important than it really is
 TD: and 2.5MB of wikileaks data, and a whole bunch of GPG
encrypted stuff, and the hidden wiki cp/jb sections (no idea if it's
all the same person)
 jgarzik:
iirc this is gpg symmetric key encrypted
 jgarzik: (I wrote a tool to download the tool to download data)
 MC1984_: just checked, surprisingly no-one has put
*anything* into the litecoin chain at all, strings returns nothing

@_date: 2013-04-09 10:50:10
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] On-going data spam 
Well, I'm not fundamentally opposed to a blacklist, but it would have
to be done in a VERY open manner.  I do think the community would
agree that storing big data transactions is not the primary purpose of
However, there should be some metrics and heuristics that take care of
this problem.  Notably the dev consensus (sans you, Mike :)) seems to
be that uneconomical outputs should be made non-standard.
Here is one approach:
    Block uneconomic UTXO creation
    I would like to see at least a stopgap solution to data spam in 0.8.2,
as it is a clear and present problem.

@_date: 2013-04-09 11:01:09
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] On-going data spam 
"wait" is only an option if there is an alternate solution already
coded and ready for 0.8.2.

@_date: 2013-04-19 00:55:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Anti DoS for tx replacement 
On Fri, Apr 19, 2013 at 12:38 AM, John Dillon
I cannot speak for Gavin, but speaking more generally, large attackers
tend to belong in a thought-class all their own.
Example 1:  if some super-ASIC miner arises with 90% of hash power,
and he starts behaving in a way contrary to the useful functioning of
bitcoin, the community might decide to change the PoW algorithm at
block height N.
Example 2:  If someone large DDoS's the entire P2P network, which is
possible, manual intervention would be required to straighten out the
In each case, it's more about the community's mutual defense actions
than any prepared defense.
Speaking even more generally, bitcoin may be a billion-dollar
invention, but that doesn't mean it has any funding for network
defense!  Unless cost structures and user attitudes change,
development and deployment of major defense strategies seems unlikely.
 Which implies the community will simply wait for a [attack |
explosion | crisis], and then hope we can unwind/repair the damage

@_date: 2013-04-30 14:04:59
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Fwd: Service bits for pruned nodes 
On Tue, Apr 30, 2013 at 12:14 PM, Rebroad (sourceforge)
Speaking generally, I've always been a supporter of finding new and
creative ways to store and transmit blocks.  The more diversity, the
less likely bitcoin can be shut down worldwide.
HTTP is fine, but you run into many issues with large files.  You
would need a very well defined HTTP-retrievable layout, with proper
HTTP headers along the entire path, if you want web caches to function
properly.  You need HTTP byte range support, HTTP 1.1 keep-alives, and
other features for resuming large, interrupted downloads.
The format currently used by bitcoind would be just fine --
blocks/blkNNNN.dat for raw data, size-limited well below 1GB.  Just
need to add a small metadata download, and serve the raw block files.

@_date: 2013-04-30 16:11:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Fwd: Service bits for pruned nodes 
Hardly.  The storage format is bitcoin protocol wire format, plus a
tiny header.  It is supported in multiple applications already, and is
the most efficient storage format for bitcoin protocol blocks.
You don't have to create anything on the fly, if you store blocks in
their native P2P wire protocol format.
This is a whole new client interface.  It's fun to dream this up, but
it is far outside the scope of an efficient HTTP protocol that
downloads blocks.
Your proposal is closer to a full P2P rewrite over HTTP (or a proxy thereof).

@_date: 2013-01-11 00:02:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Draft BIP for Bloom filtering 
0.8rc1 will probably happen when the core ultraprune/leveldb stuff is stable.

@_date: 2013-01-25 21:23:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Testnet DNS seed 
How long do you plan to run this?  Indefinitely [presuming there is
interest and users]?
No objection
Yes, IRC must remain enabled
Yes.  Usually nanotube does the update when poked.  That can happen,
or something different.
A nice alternative might be a simple script that transforms Pieter's
seeds.txt into pnSeed[]

@_date: 2013-01-27 11:14:02
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Testnet DNS seed 
Cool.  ACK on adding your seed to the ref client.
That's fine.  The main point was to create something scripted and
repeatable.  Then pnSeed[] becomes easier to maintain _and_ easier to
audit.  Right now it is a bit opaque with a list of hex constants.  A
script or makefile rule could do
     cd src
     ../contrib/gen-seeds.py > seeds.h
and seeds might look like
   __SEEDS_AUTOGEN_H__ etc.
  unsigned int pnSeed[] = {
    0xABCD1234, /* IP addr 12.34.56.78 */
  };
I think Satoshi liked them opaque and not easily searchable, so
printing the readable IP address in a comment may not be desired.
Anyway, that output would make updating the list more transparent and
easy to maintain.

@_date: 2013-03-07 22:19:05
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] python-bitcoinlib: Comprehensive bitcoin 
GitHub URL: Repository: git://github.com/jgarzik/python-bitcoinlib.git
The python library for pynode has matured sufficiently to have a home
of its own.  The python-bitcoinlib project attempts to present a
lightweight, modular, a la carte interface to bitcoin data structures
and network protocols.
 *   Easy object interface to all bitcoin core data structures: block,
transaction, addresses, ...
 *   Full transaction script engine
 *   Fully verifies main and testnet block chains (via pynode)
 *   ECDSA verification (OpenSSL wrapper)
 *   Object interface to all known network messages
 *   Binary encoding/decoding (serialization) for full bitcoin
protocol interoperability
 *   Passes many of the tests shipped with the bitcoin reference
client (bitcoind/Bitcoin-Qt)
Like pynode, this library is currently a developer-only release, not
recommended for highly secure production sites.
Pull requests, comments, questions and donations always welcome.

@_date: 2013-03-08 12:04:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Blockchain torrent on SourceForge d/l area? 
Would like to upload bootstrap.dat.torrent to
sourceforge.net/projects/bitcoin/files/Bitcoin/blockchain/ or
Any objections?

@_date: 2013-03-11 13:18:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Blocking uneconomical UTXO creation 
While 100% agreed, I do think there is space in the alt-currency world
for a well-done coin THAT IS NOT BITCOIN (i.e. merge-mined or
whatever) with a finite lifespan.  Call it "tempcoin"   For example:
any coin older than (144 * 365 * 4) blocks may be reclaimed by a
Even though, sadly, many of the alt-coins have been pre-mined scams,
the alt-coin concept in general is great for experimenting.  If the
idea can be proven in the field without modifying mainnet bitcoind,
then perhaps it should go onto the mainnet hard fork wishlist, many
years in the future.
That's the great thing about open source.  People can experiment with
these ideas, and bitcoin.git need not change at all :)

@_date: 2013-03-23 03:17:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] A bitcoin UDP P2P protocol extension 
Here is a rough draft implementation of a UDP P2P protocol extension
for bitcoin:
          Protocol specification (such that it is):
- UDP, bound to same port as TCP P2P (normally 8333)
- Active, simultaneous TCP P2P connection required (useful against DoS
and other attacks)
- Same message format as TCP P2P, same pchMessageStart conventions,
etc. (my CNetMessage pull req would be helpful here)
- Multiple P2P messages per UDP packet permitted
- Max UDP packet size 100*1024 bytes
- Advertises NODE_UDP in nServices
- New "getudpcook" TCP P2P command returns a "udpcook" message,
containing a yummy cookie
- UDP P2P commands "inv", "tx" and "addr" are handled as if received via TCP
- UDP P2P command "udpsub" sets a mask, that subscribes to one or more
data broadcasts.
- When USM_INV_BCAST mask bit is set, receive "inv" messages via UDP
rather than TCP.
Project and design goals (or, why do this?):
- It is theorized that UDP may be useful for some messages we
broadcast throughout the network
- A productive discussion STARTS with code, otherwise discussion
continues forever.
- Investigate improving "inv" relay speed
- Investigate unconditional "tx" broadcasting via UDP, as "inv"
alternative, for small tx's.
- Investigate improving block relay speed (or perhaps block header relay speed)
- Open up new design avenues, for P2P patterns more suited to UDP than
TCP in general.

@_date: 2013-03-23 11:24:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] A bitcoin UDP P2P protocol extension 
It depends on the usage.  Simply broadcasting a TX or INV to a remote
peer does not require a connection, clearly...  but you probably want
to signal acceptance of those messages somehow.
But other uses, like subscribing to a broadcast, does require some
notion of an association.
In the rough draft, a parallel TCP connection with version/verack
sequence is required, and you may make use of it if a connection is
But that is just one approach.  A more robust, heavyweight UDP P2P
might be a hole-punching TCP alternative.  It's up to the community
and results of experimentation.
Bittorrent has evolved a full transfer protocol over UDP, to get
around firewalls and the like.

@_date: 2013-03-23 12:16:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Upcoming network event: block v2 lock-in 
Once a supermajority (95%) of mining reaches block version 2,
nVersion==1 blocks will be rejected.  This event seems likely to occur
in the next week.
Version 2 block specification: Watching for the event:   The text
is at the bottom:
"We are currently at 100 out of the latest 1000 blocks on version 1
(10.00%) and 899 out of the latest 1000 blocks on version 2 (89.90%)"
Users should not be impacted.  Some ancient miners will produce
newly-invalid blocks (v1), that will get ignored.  The easy solution
is to mine using a recent bitcoind (0.7 or later).  If you are a miner
and need help upgrading to v2, ping us on  or
bitcoin-development at lists.sourceforge.net.

@_date: 2013-03-23 13:47:46
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Upcoming network event: block v2 lock-in 
Sure, that is largely the pool server layer.  But it is misleading to
imply that bitcoind is nowhere in the stack.

@_date: 2013-03-23 13:28:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Upcoming network event: block v2 lock-in 
slush, BTC Guild, ozcoin too I think, several others.

@_date: 2013-03-23 14:21:32
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Upcoming network event: block v2 lock-in 
Again, not strictly true.
bitcoind's 'getblocktemplate' RPC call used by some supplies the block
version, selects transactions for the miner, and other tasks integral
to the implementation of the miner and BIP 34.

@_date: 2013-03-23 22:08:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] A bitcoin UDP P2P protocol extension 
Darn near everything can be shoehorned into a "message"   So
absolutely agreed... in theory.  Been an SCTP fan for years.
Firewall practices tend to put a damper on cool new protocols like that, though.

@_date: 2013-05-01 09:46:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Service bits for pruned nodes 
In general, I support this, as anybody on IRC knows.
Though it does seem to open the question about snapshotting.
Personally, it seems important to enable running a fully validating
node, that may bootstrap from a UTXO snapshot + all blocks since that
NODE_BLOCKS_2016, in particular, is too short.  For users, I've seen
plenty of use cases in the field where you start a network sync after
a 2-week period.
Set a regular interval for creating a UTXO snapshot, say 3 months
(6*2016 blocks), and serve all blocks after that snapshot.  For older
nodes, they would contact an archive node or torrent for >3 month
blocks, and then download normally <= 3 month blocks (if the archive
node didn't serve up to present day).
Where are we on nailing down a stable, hash-able UTXO serialization?

@_date: 2013-05-01 10:26:57
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Fwd: Service bits for pruned nodes 
That posits -expanding- blocks from their native form into a larger
form, and then squashing them back down again upon request.  A lot of
extra work from the point of view of clients downloading blocks
But sure, if you want to do it, yes, it is possible to design an
interface like that.
Correct, Apache today could easily serve an HTTP-based layout of
blkNNNN.dat, plus a tiny JSON metadata file.
That's not "no schema", just a different layout.
In the context of this thread: distributing and downloading blocks.
All current users require the native binary block format.
A generalized HTTP REST query protocol would be a nice addition... it
is just off-topic for this thread.  On IRC yesterday, we discussed an
HTTP query interface like you suggested.  It was agreed that it was a
nice interface, and might be a nice addition to bitcoind.
That is a separate topic for a separate email thread, though.
As an example, see the pull request I wrote for an HTTP REST interface
that downloads an encrypted wallet backup:

@_date: 2013-05-04 14:55:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Service bits for pruned nodes 
On Sat, May 4, 2013 at 2:07 PM, John Dillon
Let's not confuse bootstrapping with overall peer discovery.
Peer exchange between P2P nodes is the primary and best method of
obtaining free peers.
Obviously you need to bootstrap into that, though.  DNS seed and fixed
list are those bootstrap methods (IRC code was deleted), but are only
used to limp along until you can contact a real P2P node, at which
point peer discovery truly begins.

@_date: 2013-05-06 12:20:12
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Discovery/addr packets (was: Service bits 
Indeed, the DNS seeds are just servers run by trusted individuals anyway.
In either case, bitcoinj definitely wants fixing for its over-reliance
on DNS seeds.  This has been noted as a problem for a while.

@_date: 2013-05-06 13:25:32
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Discovery/addr packets (was: Service bits 
You know my feelings about Java ;p but for hidden services, there
really does need to be a lib for server apps.
A proxy server approach is much more fragile, in certain scenarios,
than directly implementing an internal Tor hidden service node, and
handling the TLS connections within your own network framework.

@_date: 2013-05-08 21:08:34
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] 32 vs 64-bit timestamp fields 
Guffaw :)  The year 2038 is so far in the future that it is not really
relevant, from that angle.
We need a hard fork to break the 1MB limit, and Satoshi explicitly
presumed that would happen sometime in the future.

@_date: 2013-05-13 14:38:15
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] merged mining hashcash & bitcoin (Re: 
Don't forget:  4. destroy-via-miner-fee, which is useful because it
provides funding for a public service (bitcoin transaction
(a tangent, but related)
I've been thinking about a decentralized way to create an anonymous
identity, something I think it key to any number of decentralized, P2P
and anonymous markets.  My main focus, for this identity project, is
to develop a decentralized protocol for generating a UUID-like unique
identifier (bitstring), in a way that has some amount of creation cost
attached (to prevent creating a billion of such tokens etc.).  I call
it a system identifier, or SIN.
Once you have a SIN, you may associate the SIN with a GPG fingerprint,
email address, real name, login credentials, etc.  eBay-like
marketplaces publish SIN ratings (though it displays on screen as
"jgarzik" not "1234-abcd-5678-def0").  Standard-and-Poors style
ratings agencies would similarly rate a business's SIN.  SIN's build a
reputation and trust over time, while controlling their own anonymity
(or lack thereof).  Anybody may abandon a SIN at any time. Ownership
of a SIN is cryptographically proven via digital signature.
Getting back on topic, somewhat, one idea I had for creation cost of a
SIN was associating the creation cost of a SIN with a bitcoin
transaction's miner fee.  Anybody in the world could, therefore,
create a SIN in a decentralized fashion, simply by following a
published protocol for burning a specified amount of bitcoins via
miner fee.  It can be cryptographically proven with 100% certainty who
made such a transaction, and the miner fee attaches a creation cost to
ensure that SINs are not -too- cheap.
Burn-via-miner-fee is a useful tool outside of this example.  It funds
a public service, providing a positive feedback loop for miners who
receive fees via such services.

@_date: 2013-05-13 18:00:27
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] merged mining hashcash & bitcoin (Re: 
When a transaction's input value exceeds its output value, the
remainder is the transaction fee.  The miner's reward for processing
transactions is the 25 BTC initial currency distribution + the sum of
all per-transaction fees.  A destroy-by-miner fee transaction is a
normal bitcoin transaction sent by any user, that might look like
Input 1: 1.0 BTC
Output 1: 0.5 BTC
(the miner fee is implicitly 0.5 BTC, paid to whomever mines the
transaction into a block)
Sadly the bitcoin protocol prevents zero-output,
give-it-all-to-the-miner transactions.

@_date: 2013-05-14 12:50:27
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] merged mining hashcash & bitcoin (Re: 
That evaluation largely depends on the needs of the service in question.
In my decentralized identity (SIN) example, you merely need to prove
to the cloud that you sacrificed some bitcoins to any-miner.  The
confirmed, in-chain, non-coinbase transaction becomes the root node
for off-chain identity data.
The penalty for the user withholding the sacrifice transaction is that
their SIN is not created.  That incentive may not exist in that way,
in another service.
Just referring to a standard, fee-bearing, user-created bitcoin
transaction, where output_value < input_value.  The fee is paid to the
first miner who includes that transaction in a block, as part of the

@_date: 2013-05-16 11:47:07
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Service bits for pruned nodes 
That's just about the worst thing you could do for bitcoin.  DoS one
part of the DHT, you DoS the entire blockchain by breaking the chain.

@_date: 2013-05-20 22:45:13
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] UUID to identify chains (payment protocol 
This proposal seems closer to Version 5 than Version 4, in spirit.
But given that useful content may be deduced from UUID, it is not
truly applicable to either.  A bitcoin-specific version 6, if you
Note that, as this example unintentionally implies, humans are going
to want a side-by-side mapping /anyway/, just to make it readable and
usable to humans.
Almost all useful multi-chain software will require a readable
shortname string anyway, the thing this proposal wishes to avoid.

@_date: 2013-05-22 00:12:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] is there a way to do bitcoin-staging? 
Note that testnet operates under the threat of being reset at any
time, if someone comes along and destroys its usefulness with spam or
mining or whatnot.  That guarantees it remains a testing tool, and not
a real alt-currency.  The current testnet is the third iteration,
hence you see "testnet3" in some source code.
This option is always available for any merge-mined chain as well,
ensuring little real value is assigned to the test chain.
But that is a binary decision:  If you don't have a reset-the-chain
policy, you have a de facto "it is a real currency" policy.
A fork of the bitcoin.git codebase has the nice attribute of making it
easy to "upstream" any useful changes that are not specific to that
one alt-coin.
What's neat about bitcoin is that it invented a whole new /category/
of technology.  It's not just /an/ invention, but opened up all this
new experimentation with the new concept of money itself.
However for the bitcoin.git reference implementation, it makes more
sense to focus on supporting existing bitcoin users.  That permits
alt-coins to bubble up (or not) organically, and at the same time
reduces user confusion.  We have enough trouble explaining the basics
of bitcoin to the world; trying to keep follow every alt-coin
bandwagon just muddies the waters from a messaging standpoint.
alt-coin changes fall into two categories:
1) Rule changes.  We don't want these.
2) Generic bug fixes, cleanups, changes etc.  It would be nice to see
improvements bubble up, benefitting everybody.

@_date: 2013-05-22 10:07:51
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] UUID to identify chains (payment protocol 
What does this mean?  It seems extremely unlikely that two different
genesis blocks will have the same hash.

@_date: 2013-05-22 10:20:22
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] UUID to identify chains (payment protocol 
That has really, really bad side effects.  The whole point of the
bitcoin consensus algorithm is to avoid situations like this.
We don't want to encourage that behavior with code.

@_date: 2013-05-22 10:55:42
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] UUID to identify chains (payment protocol 
OK, let me qualify.  Layers on top are one thing, but we really do not
want to support cases like the fork that leaves the genesis block
intact, and leaves the subsidy at 50.0 BTC forever.

@_date: 2013-05-23 11:26:30
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Changing PGP identities/keys 
As part of the process of moving to BitPay, I'll be switching to
jgarzik at bitpay.com as a PGP identity, with brand new signing keys.
Here is a message, signed by jgarzik at exmulti.com's key (the one listed
on bitcoin.org), proving they are the same person.
If a couple people would run through this and verify that "I am me", I
would appreciate it.  A sig check and IRC ack would be great.  Thanks!
 bitcoin.org will be updated after this.
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Jeff Garzik's business identity and PGP information is:
pub  2048R/7ADCA079 2013-05-23 Jeff Garzik
