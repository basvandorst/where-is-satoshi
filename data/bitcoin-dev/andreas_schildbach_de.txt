
@_date: 2011-09-23 21:42:08
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin 0.4.0 released 
Thanks everyone for this great release!
Can you post secure file checksums somewhere, preferably not on Sourceforge?
I'd rather not install something directly from SourceForge.

@_date: 2012-04-15 10:12:37
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin TX fill-or-kill deterministic 
Just to let you know, Bitcoin Wallet for Android already supports
directly sending transactions via NFC and QR-Code. Currently, receiving
such a transaction is handled the same way as if it was received via P2P.
This means the sender does not need to have internet access the moment
he pays. The transaction is being broadcast into the P2P network by the

@_date: 2012-12-22 19:39:59
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Testnet3 difficulty transition problem? 
Both blocks
38304 00000000015bb4069249fa1f41ae61d8a7447aaacc33c50dacd3c3654377fa43
40320 000000008011f56b8c92ff27fb502df5723171c5374673670ef0eee3696aee6d
are difficulty transition blocks. However, block 40320 has a difficulty
of 1. I know there is this special testnet rule that allows mining a
block at difficulty 1, but I always thought you can't use this exception
on difficulty transition blocks.
As a result, bitcoinj based clients do not advance their blockchain past
block 40319.

@_date: 2012-01-28 17:32:15
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 0020: URI Scheme 
Bitcoin Wallet for Android implements only parts of this spec:
The hexadecimal notations (x) and exponent notations (X) feel horribly
redundant to me and are thus not implemented.
"label" and "message" parameters are not implemented right now, but will
probably be in a later version.
"send" is also not implemented.

@_date: 2012-01-31 09:23:40
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 21 (modification BIP 20) 
Generally I prefer BIP 21 over BIP 20.
I'm neutral on the 'send' parameter - present in both BIPs - which I
don't understand. I think a practical usecase should be given in the BIP.
Also, the 'version' parameter is unclear. What does it mean? Is an oder
defined on versions (1.0b > 1.0)? Why is it an ";" parameter rather than
a normal "&" parameter?

@_date: 2012-01-31 12:55:01
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 21 (modification BIP 20) 
IMHO its standard that unknown URL parameters are simply ignored. I
think we should not change this principle.
In this case, you'd need to refuse *all* parameters you don't know
about. In consequence, all extensions would break older clients.

@_date: 2012-01-31 23:14:32
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
Is the ':' sign actually allowed in URL parameter names
(unescaped/unencoded)? If not, I'd propose an unrestricted char instead,
maybe '_'.

@_date: 2012-07-09 12:55:51
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin Wallet for Android 
I'd suggest adding two links for each client.
One for getting the binary, and one for getting the source. (Obviously,
source being optional if you allow non-opensource clients.)

@_date: 2012-07-16 10:16:58
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Accepting broken QRcodes 
The problem with this "accept everything even if broken" approach is
that people will probably never fix the broken stuff. So we likely end
up with a fragmented de-facto standard.
That does not mean I am totally against accepting broken URLs, but there
should be at least a promise that they will be fixed at the source.

@_date: 2012-05-03 09:16:57
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] URI Handling in Bitcoin-Qt 
Bitcoin Wallet for Android currently ignores both fields. At least
temporarly displaying the transaction message is on my short-term todo list.

@_date: 2012-05-03 09:28:50
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] new bitcoin.org clients page 
Can we add Bitcoin Wallet? I'm not very good at writing descriptions, so
I would just add this for starters:
Bitcoin Wallet is a standalone wallet for Android devices. Its primary
focus is ease of use and being independant of central network components
(servers). It supports initiating transactions via QR code,  Bitcoin
URIs or near-field communication (NFC). It has a useful currency
conversion calculator.
Platforms: Android
Market: Project:

@_date: 2012-05-03 11:53:33
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] new bitcoin.org clients page 
I never measured exactly, but Bitcoin Wallet takes about an hour to
update its blockchain initially on good WLAN (lightweight approach,
headers only).
After that, Bitcoin Wallet is just as fast as any other client.
The advantage of that approach is that you are not dependent on any
server (like Spinner or Electrum). Essentially you're carrying the
blockchain in your pocket.

@_date: 2013-04-24 15:35:45
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP21 bitcoin URIs and HTML5 
I had another amendment, which roughly (can't remember the details) has
to do with case-sensitivity of the scheme part and parameter names. If I
remember right, BITCOIN:1d4...?AMOUNT=0.1 would be a correct URI but not
valid in the sense of BIP21 currently.

@_date: 2013-08-20 01:02:41
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Proposal: remove "getwork" RPC from 
Here, too. If I'm too impatient to wait for the next block that is.
I think it'd be a pity if the easy way to mine blocks would be removed.

@_date: 2013-12-01 13:15:04
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Floating fees and SPV clients 
Thanks taking the initiative and writing this up!
As long as the tx is not confirmed (by a broadcast), apps can offer to
bump up the fee a little bit.

@_date: 2013-12-01 17:50:10
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Floating fees and SPV clients 
(my post hasn't shown up for an hour, so I'm sending it again)
I assume you're right, since I do not have so much experience with game
About the UI:
Generally, for pending tx I'd like to measure time they're not being
broadcast-confirmed and count blocks that they missed being included.
Both can be combined into adapting the current generic messages ("This
payment should become spendable shortly" for incoming and "This payment
has not been transmitted yet" for outgoing transactions). Hint:
Statistics could be offered by bitcoinj.
For outgoing transactions, if it is very clear that they're never going
to be confirmed, I'd like to see a "Revoke" button. This would have
saved us some support hassles with the transmit bugs. It could also
offer a "Top up fee" button, which would replace the tx by a new one.
I'm aware about a possible double spend but who cares? It doesn't matter
which of the two transactions gets into the chain, as long as not both
will be included.

@_date: 2013-12-01 18:40:55
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Floating fees and SPV clients 
Well, for starters I'd suggest something like
"This payment did not become spendable since xxx minutes. Check with the
sender if s/he paid the Bitcoin network fee. Check if your internet
connection is working properly." (incoming)
"This payment still has not been transmitted. Check if your internet
connection is working properly." (outgoing)
This is the wrong way around because it?s the recipient who cares about
double spending risk, not the sender. That?s why merchants keep running
into issues with people attaching zero fees. Of course they attach zero
fees. They know they aren?t going to double spend. It?s the merchant who
cares about getting the security against that.
Guess you're right. But as you said, we're not there yet.
fees anywhere, IMO.
Agreed, if the sender does not need to pay a fee any more. On the
receiving side it of course needs to be mentioned. (Or the other way
round, as of today.)
Someone needs to sit down and figure out what the UI *should* look like,
in the ideal world, and then work backwards to figure out what needs to
be done to get us there.
(The ideal world doesn't need a UI for money.)
doesn?t confirm. Period. I know there have been bugs with bitcoinj that
could cause this in the past, but they were bugs and they got fixed/will
get fixed.
possibility will just encourage people to think of it as normal, when it
should not be so.
I fully understand your point of view. However, its not the reality
currently. (Hopefully it is, after the fixes to bitcoinj.)

@_date: 2013-12-16 23:32:30
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Fees UI warning 
One way would be to explicitly warn against some services. For example,
on the "Choose you wallet" page of bitcoin.org.

@_date: 2013-01-19 10:51:04
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Draft BIP for Bloom filtering 
Matt, I saw your commit and immediately started using it for testing.
Now I think the bitcoinj side needs some love because not one
transaction is being confirmed (all just pending) when replaying the

@_date: 2013-07-17 16:32:27
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] SPV bitcoind? 
Android apps do whatever they are programmed to do. They become active
when the user installs and inactive when they are uninstalled.
Inbetween, they are not limited in runtime.
That said, the current programming is that when receiving a block, it
stays connected for at least ~2 more minutes. This generally allows the
chain to catch up while at the same time avoiding endless battery drain
because something gets stuck. Upon sending or receiving of a
transaction, it stays connected for at least ~8 more minutes, because it
is likely the wallet will see more activity.
Additionally, on the send and request coins screens and the network
monitor it stays connected for as long as the screen is on and the app
in the foreground (= resumed state).

@_date: 2013-07-23 10:27:19
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] HTTP REST API for bitcoind 
Is it planned to expose the UXTO set of a given address? That would be
useful for SPV wallets to be able to swipe a previously unknown private
key (e.g. paper wallet).

@_date: 2013-07-23 12:17:33
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] HTTP REST API for bitcoind 
I certainly don't want to push ideas that won't work for whatever
reason. So I fully respect whatever you decide regarding that feature.
Personally I have never felt any need for being able to sweep paper
wallets, I am more or less just relaying the need of users.
Let me just say this:
Sweeping paper wallets is a common feature request. People switch to
centralized services just for getting that.
It is my understanding that for the usecase, an address-indexed UXTO is
enough. So you probably don't need to worry about script-indexed for now.
Security issues could be mitigated by applying trust to the REST server,
e.g. because its your own or the one of your apps vendor. Of course,
link-level security would be needed for this (e.g. SSL).
Paper wallets that include the necessary additional information is
something I have been thinking about. I see some issues:
- Paper wallets are already quite widespread. You still won't be able to
sweep those.
- Some people like to "top up" a paper wallet or even just sweep a
portion of it. That would not be possible, and in some cases even lead
to loss of coins because of the "involuntary fee" you described.
- Does the necessary info fit into a QR code?

@_date: 2013-07-23 12:29:34
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] HTTP REST API for bitcoind 
Yes, I understand that. For this reason, I would vote for adding the
usual HTTP authentication/SSL stuff to the REST API. That way, SPV users
can decide to run their own instance of the API (providing the needed
resources themselves).
Or, a trusted party can set up a server. For example, I would be willing
to set it up for users of Bitcoin Wallet. I don't expect shitloads of
paper wallets sweeps for the forseeable future.

@_date: 2013-10-21 17:46:47
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
I accept the nomination as a backup (-:
So the duty of the editor is merging pull requests and/or proxying
between email and git for those who do not use git?

@_date: 2013-10-28 10:26:24
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Feedback requested: "reject" p2p message 
HTTP also defines success codes (2xx). Are we also talking about ACK
messages now, rather than just REJECT messages?

@_date: 2013-09-25 12:28:53
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol: BIP 70, 71, 72 
While it's good to save space, I'm at the moment not convinced that
taking a de-route via an URL is a good idea to begin with.
The main problem is trust. If you scan a QR code from a foreign phone,
you trust that that phone is owned by the one you want to send money to.
By adding the HTTP request that trust is voided.
As soon as there is a BIP70 implementation, I will begin playing with
putting the payment request directly into the QR code.

@_date: 2013-09-25 13:33:09
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol: BIP 70, 71, 72 
Why do you think that? Of course, I would skip the certificate, as its
unnecessary if you see your partner in person.
HTTPS trust is utterly broken unless you fix it by adding the
certificate or a fingerprint to the QR code. Bluetooth is not present in
every case, e.g. QR codes scanned from the web. (Also, we currently
don't have a concept of allowing both. The receiver forces you to either
use BT or HTTP.)
So yes, MITM is what I'm worrying about. When I'm scanning a QR code
from a phone, you don't have that problem (unless sophisticated optical
attacks emerge). Also, the HTTP request can fail and/or be slow, making
the whole payment process more difficult than necessary.

@_date: 2013-09-25 13:59:52
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol: BIP 70, 71, 72 
Now you're dver-dramaticing (-:
I'm just skipping one feature which I think is useless for QR codes
scanned in person.
Thanks. A typical request would be around 60 bytes, which should produce
an URL with around 100 chars. That should be fine for scanning, but I
will experiment.
Good to hear. Let's see if it gets momentum.
Sure. I was talking about QR codes scanned in person.
Yeah, will look at that as soon as we're implementing the payment
protocol fully.

@_date: 2014-04-07 15:43:52
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
They're _not_ phasing out into SPV wallets from what I can say. At
around the 24th of February, there has been a sharp change of the
"current installs" graph of Bitcoin Wallet. That number used to grow at
about 20.000 per month. After that date until now, it just barely moves
My guess is that a large number of users have lost interest after they
lost their money in MtGox. The 24th of February coincides with the
"final" shutdown, according to

@_date: 2014-04-08 16:49:43
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] New BIP32 structure 
While there is an agreement that a standard would be useful for sharing
wallets, we certainly didn't agree on every aspect of a standard. At
least not on this thread, and also not at the Berlin meeting.
I understand each client will implement things a little bit different,
for example the current plan is bitcoinj will hold all keys in memory
and start reusing keys on low resources. Electrum uses a chain for their
private purpose. Etc.
If we cannot 100% agree on a standard and also agree it will not be
extended in future, I think we should not even try. It's dangerous for
the money of users.
I propose we keep our chains deliberately separate and only try
standardizing after each of us has a feel for the specific requirements.

@_date: 2014-04-08 17:58:03
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] New BIP32 structure 
There is no "bare minimum". Either you implement the "BIP" fully or not.
There is no inbetween. Likewise, the standard cannot be extended unless
you create a new standard that is based on the old (without re-using the
path, of course).
We're lightyears away from a BIP. Lets first create implementations and
see if they are compatible in all possible combinations and situations.
The moment any two apps have a different view on their wallets generated
from the same seed, they're incompatible. In this case they should
either fix the issue or intentionally choose incompatible paths, so that
they don't see and spend "subsets" of each other.

@_date: 2014-04-25 12:23:05
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP32 "wallet structure" in use? Remove it? 
Does anyone use or plan to use the "wallet structure" part of the BIP32
I suggest removing it from the document and maybe instead point at
BIP43. That new specification proposal just defines a "purpose" and
leaves everything else to the inventor of that purpose. The idea it that
over time a standard will evolve naturally rather than top-down.
I'd volunteer to submit a pull request if I can see some level of
consent here.

@_date: 2014-04-26 00:33:36
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Error handling in payment protocol 
These two BIPs are not accepted yet, so feel free to submit PRs for them.
Note BIP70 is almost agnostic to transport layer. For example, I have
implemented it for NFC, QR-codes, Bluetooth, e-mail and In-app payments
in Bitcoin Wallet -- doesn't make much sense to put HTTP status codes
into the spec.
Max message sizes make sense. I also thought about adding a guarantee
that the payment_url is valid for as long as the payment request is valid.

@_date: 2014-08-05 18:11:39
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] How to create a pull tester JAR 
FWIW, I filed a wishlist item here:
and here, for the old Ubuntu versions of Maven:

@_date: 2014-02-03 22:25:53
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70: Canceling Payments 
Have a look at my post "Payment Protocol for Face-to-face payments". In
short: I implemented BIP70 using combinations of either QR-code or NFC
plus Bluetooth. You can download a working preview app from:

@_date: 2014-02-08 00:15:43
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
I have refreshed the Bitcoin Wallet preview version with beta version
3.32. It now implements BIP72 aka "URI extension for payment protocol".
There is one important deviation from the standard though: Bitcoin URI
address and amount fields need to correspond to the data from the
payment request. The makes sure the signature really signs the URI
(which you've gotten directly from the payee) and not a malicious
payment request introduced by a MITM. Note the memo isn't protected like
that, so it can still be MITM'ed.
I know this means that for the time being Bitcoin URIs must be
"backwards compatible". That should not be an issue since we will be in
transition phase for many months anyway. Until then, I hope we will have
agreed on a more sophisticated approach, e.g. a separate hash in the URI.
(also published to the corresponding channels on Google Play)

@_date: 2014-02-18 18:31:04
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70 proposed changes 
I'm starting a thread on proposed changes on BIP70 based on my
experience in implementing the payment protocol in Bitcoin Wallet:
- certificate chain in pki_data: I think it should be required that is
most contain the first certificate PLUS all intermediate certificates
(if any), but NOT the root certificate. Reason: We want to be able to
verify offline.
- definition of timezone: Its not clear if times (e.g. expires) are in
UTC or local. I suggest to require UTC. If if we can't agree on this,
there should be a sentence about timezones in the spec.
(probably more to be added...)

@_date: 2014-02-18 22:40:13
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70 proposed changes 
I would like to understand why this happens at BitPay? If this is
because people use cut and paste to copy the address and then type the
amount by hand... well this kind of usage will go away.
A program (like an app) should be capable of paying the exact amount. If
not, that's a bug of the app not the protocol.
Sounds interesting, let us know as soon as you have anything.
In which case does it make sense to duplicate the root cert? I'm asking
because it should already be present in the trusted root store, right?
Maybe can you tell about which measures you needed to take to get X.509
working? To me it felt there very several problems.
TLS? We're not using that for pki_data -- its just a byte array.
-->

@_date: 2014-01-13 18:44:18
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment protocol and reliable Payment 
Can you explain what the problem is here? The payment message can be
transmitted after the payment has been received through the P2P network.
Am I missing something?
Furthermore, if we give up the robustness of the P2P network, we will
likely end up with more failed payments. There is so much that can go
wrong when trying to connect via HTTP (proxies etc.), Bluetooth
endpoints can go away, etc. At least we should provide fallback
payment_url's in this case.
As for you proposal, just be aware I'd like to use the payment protocol
for face to face payments as well. That meant payment request via NFC or
QR, payment message and payment confirmations via Bluetooth. I think it
can be done by putting a Bluetooth mac address into the payment_url.

@_date: 2014-01-13 23:24:58
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment protocol and reliable Payment 
Thanks for the explanation.
Looks good so far. Just wanted to keep you aware (-:

@_date: 2014-01-14 10:40:58
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment protocol and reliable Payment 
I was thinking about this some more. Generally I think you have a point.
However, there is one case I'm worried about.
Imagine you get a good offer (payment request) from a merchant. You
would like to accept that offer, however the merchant has changed his
mind. If you don't broadcast the payment to the blockchain, you won't
have a chance to accept and legally bind the offer. The merchant will
silently discard your payment messages.
At some point, you will involve a judge. If you can present the payment
request and the payment from the block chain, you're in a much better
position than if you just present a request but no confirmed payment.
I think in some cases you might want to broadcast your txn to the P2P
network, even if the payment messages get lost. What do you think?

@_date: 2014-01-14 12:01:08
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment protocol and reliable Payment 
It was my understanding of the spec that a payment request is legally
binding one side for the specified amount of time.
Basically I offer you to sell you these 10 eggs (described in the memo)
for this amount if you accept until this time. I have even signed this
so you can know its me who made you the offer. If you accept (by
paying), the contract is valid and there should be nothing I can do
about it (except for extreme cases which are covered by law already).
Actually what good is the payment request if its not binding?
Why do we have an expiry time in the message?

@_date: 2014-01-26 22:11:47
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70/71 issue, RFD 
I'm experimenting with BIP70/71 (payment protocol) usage in face to face
payments (more on that soon).
I've excountered an issue with the protobuf format. Protobufs are not
self-delimiting. That means if you're reading from an undelimited
stream, you will read endlessly because you don't know how much to read.
The current BIP70 implementations probably work because they're reading
either from a file or from an HTTP resource which sets the
Content-Length header. Trouble is the Content-Length header is optional,
and also there are many kinds of streams that don't have this built-in
delimiting mechanism.
The Java protobuf API solves this by offering delimited I/O, like
This writes the size of the message as a varint before writing the data.
I don't know about protobuf implementations for other languages but I'd
expect them to offer something compatible.
However, this leading varint is an incompatible change and would need to
be added to the spec.
I specifically encountered this with PaymentMessage and PaymentACK, but
it might be a good idea to apply this to all messages if any. Open for

@_date: 2014-01-26 22:32:52
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70/71 issue, RFD 
Bluetooth, Wifi Direct, HTTP request/responses via broken proxies, smoke
signals... basically anything that is a stream rather than a file.
Right, NFC NDEF and QR codes are not affected, so we can skip the
delimiter for these mediums.

@_date: 2014-01-26 22:56:11
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70: PaymentACK semantics 
The BIP70 is very brief on what a PaymentACK is supposed to mean. Quote:
"it [PaymentACK] is sent from the merchant's server to the bitcoin
wallet in response to a Payment message"
Does it simply mean we received a syntactically correct Payment message?
Does it mean the Payment is valid?
Does it mean the Payment is valid and confirmed?
How long can we delay the ack until all conditions for payment are met?
I assume its not a good idea to keep the HTTP (or Bluetooth, for that
matter) connection open for an hour while waiting for a blockchain

@_date: 2014-01-26 23:14:52
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70/71 issue, RFD 
Just keep in mind that if it turns out we need to retrofit messages with
length prefixes I fear we will have to restart with new mime-types. The
nature of prefixes being always at the start means this rules out simply
incrementing a protocol version number.
Correcting myself:
Of course I only mean the "root" messages, namely PaymentRequest,
Payment, and PaymentACK. The embedded messages don't need length prefixes.

@_date: 2014-01-27 12:59:25
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
As promised I'd like to present my work done on leveraging the payment
protocol for face-to-face payments. The general assumption is that
individuals don't own X.509 certificates. Their devices may be only
badly connected to the internet or in some cases not at all. I've
implemented a prototype on a branch of Bitcoin Wallet. It is using
bitcoinj 0.11 (not released).
TAP TO PAY
First I looked at the NFC tap-to-pay usecase. The way it works as
currently rolled out: A BIP21 URL is published using an NDEF URI
message. The URL is supplemented by a Bluetooth MAC address that can be
connected in order to finish the payment. Once connected, a very simple
custom protocol transmits the signed transaction(s) in
bitcoin-serialized form to the payee, who replies with an ack or nack.
The way I prototyped it to work in future: Instead of the BIP21 URL a
BIP70 payment request is published using an NDEF MIME message (mime-type
as per BIP71). The paymentUrl field can (and in the face-to-face case
should) contain a Bluetooth URL which contains the MAC address of the
payee. Because I could not find any standard for Bluetooth URLs, I made
up my own: "bt:112233445566" means MAC address 11:22:33:44:55:66. Once
connected, Payment message and PaymentACK reply are used to finish the
payment. Since Bluetooth sockets are streams, I had to use the delimited
variant of the protobufs for Payment and PaymentACK messages. This
prepends them with a VARINT containing the message length.
All of the above should be easy to migrate. NFC implementations are
rare, and the current Bluetooth protocol is implemented only by Bitcoin
Wallet afaik. Fallbacks are provided where necessary.
In future, I'd like to add encryption to the Bluetooth connection, maybe
using SSL and some DH key exchange.
SCAN TO PAY
For scan-to-pay, the current landscape looks different. I assume at
least 50% of Bitcoin transactions are initiated by a BIP21 URL encoded
into a QR-code. Nevertheless, I tried to encode a payment request into
the bitcoin URL. I used my existing work on encoding transactions into
QR-codes. Steps to encode:
1. The payment request is protobuf-serialized. For a simple payment
request, this results in only ~50 bytes thanks to the efficiency of
2. The bytes are encoded using "Base43", which is the same as
Base64/Base58, but its alphabet consists of the characters allowed in
so-called "alphanumeric" QR-codes, minus the characters not allowed in URLs.
3. The resulting string is prefixed by "BITCOIN:"
4. All of that goes into a QR-code, and because it only contains
"alphanumeric" characters, it will produce a very efficient code. For
simple payment requests, I could not notice any difference in scanning
There are some limitations however:
- Obviously such QR-encoded payment requests cannot grow in size as much
as using other media. In particular, I expect PKI signed requests are
out of question. However, in face to face payments the value of a sig
based on PKI is highly questionable, and the fact the sig cannot be
verified without TCP connectivity doesn't help. There should be some
headroom for multiple-output requests and moderately more complex
scripts though.
- I chose to re-use the "bitcoin:" URL scheme, because it's already
whitelisted in web browsers, QR-code scanners and so on. In order to
differentiate "payment requests URLs" from BIP21 URLs, I test for
uri.startsWith("BITCOIN:") because you'll get letters in all-caps from
alphanumeric QR-codes. I will investigate into a better solution.
- Due to wide deployment of BIP21 QR-codes, migration needs to happen in
distinct phases. Ability to parse "payment protocol URLs" comes first,
default to presenting them to users has to come (much) later.
CLICK TO PAY
Finally this is the usecase the payment protocol was invented for and
it's not face-to-face. I don't have much to add, just one thing. As a
byproduct of the above, "payment protocol URLs" can be used for links
published on web pages as well. This might provide a nice replacement
for the imho rather ugly BIP72 specification once the payment protocol
is widely deployed.
Open for discussion.

@_date: 2014-01-27 16:20:39
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70: PaymentACK semantics 
Thanks for the clarification. So I am *always* supposed to reply with an
ack. I was assuming that if I actually send a nack, I would just close
the connection without sending an ack.
Maybe that should be mentioned in the spec explicitly. I must admit that
I think the name of the message is misleading -- PaymentResponse would
make this clearer.

@_date: 2014-01-27 18:39:53
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
That's exactly what I have prototyped. I am putting a Bluetooth MAC
address into the payment_url. Have a look at the TAP TO PAY paragraph
for details, its mostly the same mechanism.

@_date: 2014-01-27 19:18:11
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
I'm not saying I'm against signed payment requests, but unfortunately
they are just too big for QR-codes. Then again, QR-codes *can* take up
to 2 KB. How big would a very basic trust chain plus signature be?
I was under the impression that addresses will go away. Can you
elaborate on the mechanism?
Ok, that's good news (to me). However, you are going to manage trust
stores (adding and revoking) without TCP?
Well I'm thinking the other way round. Use Bitcoin where its already
used today -- face to face.
Yes, but where is the problem?
Sad story, but it's really a special case. Using a printed QR-code is
clearly the wrong tool for his task, for several reasons.
And again, how is he going to provide the payment request to the payer
without TCP?
We don't want to force people to sign up anywhere. Bitcoin is instant-on.
Which is why I said we need some transition time.
That's a good point. I'll implement this asap.
Interesting, did not know about this BIP. However I don't understand the
usecase. Its not like my browsers always display QR-codes with URL of
the page being shown. And if the page in question bothers to show a QR
code, it could just as well also link to a payment request resource (as
suggested above).

@_date: 2014-01-27 21:53:49
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Experiment with linking payment requests via 
It doesn't look too good. I've tried Chrome, the AOSP browser and
Firefox. All insist on handling the link with their download manager,
which would involve an additional click. In the case of Chrome and AOSP,
that download manager a separate component that is not updatable with
the browser (rather its tied to the OS version afaik).
If you click on the file in the download manager of Chrome and AOSP it
opens as expected. On Firefox, it just ignores the click.
I registered the correct mime type and also set the mime type of the
href just in case. In case you want to have a look at the href, its on
 and links to Gavins generator.
I didn't try suffixes, but I'd assume it behaves similar.
Any ideas what else to try?

@_date: 2014-01-30 11:46:50
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Just a small update. I merged the code to my bitcoinj-0.11 branch and
put up binary .apk files for experimentation. Just make sure to tick
"BIP70 for tap-to-pay/scan-to-pay" in the labs settings.

@_date: 2014-07-01 11:48:44
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
I think the way to go here is using multiple r= parameters.
Either that, or just use the other ones as a fallback. Currently,
Bitcoin Wallet just falls back to BIP21 if fetching the PR via the r=
URL fails.
Its "specced" in code and implemented by several parties. I think its
clear that link-layer encryption has to be an add-on to the current
unencrypted connection, just like HTTPS is on top of HTTP. Anyway,
that's unrelated to the question of how to provide fallback URLs.
One more thought: We have a similar problem with the BIP70 payment URL.
It doesn't allow for fallbacks either. I brought this issue up in the
discussion phase of BIP70, but it was dismissed I think because of
"let's not get too complex for the first version". The fallback here is
to send the transaction via the P2P network.
(I think BIP70 via P2P radio will get used more often in future. I plan
to look into Bluetooth 4 LE as soon as I have devices and wanted to try
WIFI Direct again also. I hope we can skip BIP72 for both of those, but
lets see.)

@_date: 2014-07-01 16:59:07
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Does r[]= really need to be encoded as r%5B1%5D= ? In this case, I'd
advocate for a simple array parameter name, like rs= ("plural" of r).
Length really does matter for QR codes.
I'm fine with either multiple r= params or exactly one r= plus zero to
many r[]= params. Although I think it is a violation of the (current)
spec to choke on more than one r= parameters, I admit that bitcoinj is
currently implemented that way. (We could however fix this in a
maintenance release.)
However, r= should also allow all other protocols, exactly like any of
the r[]= params. I don't think we should do a distinction here. Also
because of backwards compatibility to the status quo.

@_date: 2014-07-01 17:39:42
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Ok, one more idea:
r= is used for the first URL, and we *think* of it as r0=
additional URLs are appended as
and so on. This would also define an ordering in case we need it.

@_date: 2014-07-15 15:19:29
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
I think generally control-characters (such as \u0000) should be
disallowed in passphrases. (Even the use of whitespaces is very
I'm ok with allowing pile-of-poo's. On mobile phones there is keyboards
just containing emoticons -- why not allow those? Assuming NFC works of

@_date: 2014-07-15 17:32:59
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
Can you provide the rationale for standard practice? For example, why
should whitespace be allowed? I regularly use trim() on any passphrase
(or other input ftm).
So what's the action point? Should we amend the spec to filter control
characters? That would get rid of the \u0000 problem.

@_date: 2014-07-16 11:17:44
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
Guys, you are always talking about the Unicode astral plane, but in fact
its a plain old (ASCII) control character where this problem starts and
likely ends: \u0000.
Let's ban/filter ISO control characters and be done with it. Most
control characters will never be enterable by any keyboard into a
password field. Of course I assume that Character.isISOControl() works
consistently across platforms.

@_date: 2014-07-16 12:46:02
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
I will change the bitcoinj implementation and propose a new test vector.

@_date: 2014-07-16 13:04:08
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
Damn, I just realized that I implement only the decoding side of BIP38.
So I cannot propose a complete test vector. Here is what I have:
Passphrase: ????? (\u03D2\u0301\u0000\U00010400\U0001F4A9; GREEK
UPSILON WITH HOOK, COMBINING ACUTE ACCENT, NULL, DESERET CAPITAL LETTER
LONG I, PILE OF POO)
Passphrase bytes after removing ISO control characters and NFC
normalization: 0xcf933034303066346139
Bitcoin Address: 16ktGzmfrurhbhi6JGqsMWf7TyqK9HNAeF
Unencrypted private key (WIF):
Can someone calculate the encrypted key from it (using whatever
implementation) and I will verify it decodes properly in bitcoinj?

@_date: 2014-07-17 00:02:45
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
Please excuse me. I had a more thorough look at the original problem and
found that the only problem with the original test case was that you
cannot specify codepoints from the SMP using \u in Java. I always tried
\u010400 but that doesn't work.
Here is a fix for bitcoinj. The test now passes.
We can (and probably should) still need to filter control chars, I'll
have a look at that now again.

@_date: 2014-07-17 00:22:57
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
Ok, I just fixed the String filtering so that it can handle SMP chars
and my implementation behaves exactly like in your modified testcase
quoted below.
Bitcoinj code available on this branch, in case we decide to change the

@_date: 2014-07-17 13:27:57
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
Here is a good article that helped me with what's going wrong:
Basically, Java is stuck at 16 bits per char due to legacy reasons. They
admit that for a new language, they would probably use 32 (or 24?) bits
per char.
\u literals express UTF-16 encoding, so you have to use 16 bits. I
learned that for codepoint 0x010400, I could write "\uD801\uDC00", which
is the UTF-16 encoding of that codepoint.
Other languages have literals for codepoints. E.g. Python can use
u"\U00010400" or HTML has êêÄ  Unfortunately, Java is missing such
a construct (at least in Java6).

@_date: 2014-07-30 10:27:03
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin development (testing & where to 
Are you aware of bitcoinj?
It contains everything to plug together a basic SPV wallet and runs in
the JVM.

@_date: 2014-06-11 16:24:21
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
Thanks Alex, you're my hero of the day (-:
Your seed works well for me. Here is a PR for bitcoinj:

@_date: 2014-06-14 14:57:55
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] instant confirmation via payment protocol 
Just a quick comment:
The supports_instant field seems redundant to me. First, as per your
spec, you can derive it from trusted_instant_providers. And second, why
do you need it at all? Protobuf is designed so it will simply ignore
fields you don't know. So you can just send the instant_* fields in the
Payment message without harm.

@_date: 2014-06-15 14:46:09
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] instant confirmation via payment protocol 
Yes I meant only the "supports_instant" is not needed.
"trusted_instant_providers" makes sense to me.
Generally I like the simplicity of this BIP. Still, I have more questions:
What is the use of the Transactions message? Note the Payment message
already contains a transactions field that could be signed. Can you
briefly describe the whole flow of messages on an example, including the
BIP70 messages?
Should we allow adding multiple signatures (from different instant
providers or maybe while transitioning to another PKI)?

@_date: 2014-06-24 17:43:51
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Proposed BIP 70 extension 
I think it should be made more clear what's the reference price for the
discount. In Germany, we generally don't use credit cards but rather
"EC-Cards", which is already much cheaper. Or maybe for some merchants
the only alternative is cash, and they would still offer a Bitcoin discount.
Also, currently PR are created by the payment processors afaik. How can
they know what other payment option the merchant provides and what's the
conditions? Maybe we should first solve the signature delegation problem
so that the merchant can create the request.
Although I'm sure this feature will get abused, I (as a wallet author)
would be willing to give it a try. I agree with Jeff that the name of
the field should start with something like "marketing".

@_date: 2014-03-02 10:47:48
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
I've written up a document about all the different methods on how the
payment protocol (both the old one and BIP70) is used in Bitcoin Wallet.
It only provides an overview -- I plan to go into details with separate
(BIP?) documents where needed.
If you have any questions about compatibility, don't hesitate to contact me.

@_date: 2014-03-02 16:20:34
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP70 extension to allow for identity 
I somehow think that it is too early for this heavy kind of extension,
given that the first version of BIP70 isn't even deployed widely let
alone *used*.
By reading your proposal I get the idea that the current spec doesn't
allow two (or three) different PKIs at once -- we would want this for
migration purposes as you wrote and also because different people prefer
different kinds of PKIs. And that's perhaps something we want to fix in
the current (version 1) spec to prevent us running into a wall and be
doomed to patch around the spec. Note I assume a potential PGP or
Bitcoin-based infrastructure would also be called 'PKI'.
I would prefer if your fix would stay local to X.509 (and thus only
change X.509 specific structs rather than the top-level PaymentRequest).
And for a future PKI we would implement identity delegation in a
straight forward, non-kludgy way.

@_date: 2014-03-06 12:26:20
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Instant / contactless payments 
I'm not sure if iso-dep is the way to go here. Afaik as soon as you pick
up the phone the connection breaks. It's ok if some people decide to let
the app do risk analysis, but you cannot force it onto users by picking
a protocol that cannot deal with manual verification. Users should
always have the choice to verify their payment without time pressure and
by holding the device of their choice at their individual viewing distance.
Besides, how do you plan to risk-analyse the memo field?
In current phone implementations, the screen must be on already for NFC
to be active. Also it must be unlocked, although I certainly hope future
OSes will allow payment apps on the lock screen, just like they allow
music players.
It's already very short if you can do without Android Beam, e.g. on
Android 2.3. I'd say <200 ms for an BIP21 payment request. Bootup of the
app and everything else happens after -- no need to continue contact.
Indeed most of the bootup time goes into loading complex wallets. Our
long standing plans to clean up the wallet and archieve transactions
should help. Also, if Bitcoin catches on the app will just stay in memory.
The most obvious optimization to speed up signature checking is to make
it lazy. The user can already inspect the payment while signatures are
being checked. Even transaction signing could already happen in advance,
if it can be made sure that no signed transaction "escapes" the dialog
without the users consent.
Even the current ~10 second roundtrip is a huge improvement to the
status quo. I recently tried to buy a subway ticket and it took me 7
full minutes (just for the payment process)!

@_date: 2014-03-06 15:51:09
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Instant / contactless payments 
Ok, that would be an option.
The memo field (and its logical evolution, an invoice) also needs to be
verified, since its part of the contract. Imagine sitting in a
restaurant and you're being presented the bill, most people will do a
quick scan of the meals and drinks consumed (and non-malignant errors
are frequent in that business).
Everything except Beam bypasses Beam (-:  Beam is an Android-specific
protocol. I assume it would also be possible to write an own NDEF
implementation on top of the low level NFC APIs. I want to try as soon
as I have a second NFC-capable phone, preferably Android 4.4.
You can't really blame the subway for a broken payment process.
Yes, it was a complete disaster. Obtaining a ticket took even longer --
ca. 45 minutes. Boarding the train took some additional seconds,
compared to no overhead in Germany where we simply don't have any gates.
On top of that, you walk more (in tunnels) than you get driven around,
get tracked on each movement and if you want to get your (monetary)
change, you need to wait for another 45 minutes.
The upside is, when going by public transport in England I always feel
like Mr. Freeman in City 17  (-:

@_date: 2014-03-06 17:46:53
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Instant / contactless payments 
Thanks for the video! It's always good to see these things in action so
you can start believing in it.
Supporting Bluetooth is optional in the sense that if a wallet should
not support it, you will still receive the transaction via the P2P
network. So I'd say definately go for Bluetooth.
I wonder about the receipt step -- are you generating a PDF on device
and sending it via NFC? This is something that could be supported by the
BIP70 payment protocol. We should try to avoid the second tap, its not
Contactless cards? Last I was to London, the Oyster card was already
contactless. Have there ever been magnet-strip-based Oyster cards?
Neat thought (-:

@_date: 2014-03-06 17:55:53
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Instant / contactless payments, IsoDep 
One of the first things to explore is if its possible to dispatch
different isodep applications to different apps. I know you can add an
intent filter matching action=android.nfc.action.TECH_DISCOVERED and a
custom "tech filter" android.nfc.tech.IsoDep. However, as long as there
is no mime type or similar concept, apps will always fight for access to
IsoDep endpoints. We will want to avoid that situation.

@_date: 2014-03-07 09:45:43
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Instant / contactless payments, IsoDep 
I doubt that this is possible (with the Android API). But I'll try.

@_date: 2014-03-07 09:59:43
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Instant / contactless payments 
Sure, take all the time you need.
All I wanted to say is you don't need to break Bitcoin URI compatibility
in order to support direct payments via Bluetooth. It's simply an
add-on, both in the BIP21 and the BIP70 cases.

@_date: 2014-03-07 11:23:28
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Instant / contactless payments 
Thanks for the pointer! Good to hear there is finally a decent
documentation for HCE.
Good news: HCE offers the required dispatch ability -- they call it AID
(Application ID).
Bad news: It seems - at least CATEGORY_PAYMENT - very credit card centric.
HCE seems to cover only the payer side. I wonder if there is also an API
for "reader emulation" which we would need for apps to support the payee
Since Android 4.4 market penetration is quite far off, I suggest we
focus on the already established NFC payment protocol(s) for now, it
works pretty well. I will investigate into IsoDep and HCE and see if we
can make it enhance usability.
Interesting side note: They recommend messages transmitted via NFC to
not exceed 1 KB in order for a snappy experience. This (again) questions
usage of bulky X.509 certificates in our payment request messages.
Bitcoin Wallet currently does not sign payment requests, so I could not
try how it would feel.

@_date: 2014-03-08 20:08:32
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] New IRC name: aschildbach 
Hash: SHA1
I just renamed myself on IRC (freenode) to aschildbach. The old name
was Goonie. I will most likely only use the new name from now on, at
least for Bitcoin-related purposes (-:

@_date: 2014-03-10 20:28:53
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Instant / contactless payments 
Just a small clarification here. Bitcoin Wallet supports the customer
side of the protocol since 2011, without any "Labs enabling"! This means
you've got an install base of half a million devices that you can
interoperate with. Sure, a lot of users will have Bluetooth switched
off. The UI flow to enable it while paying is pretty smooth though.
The merchant side used to have the Labs enabling but this is gone since
a few weeks.

@_date: 2014-03-13 14:40:12
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Indeed. And users were crying for mBTC. Nobody was asking for ?BTC.
I must admit I was not aware if this thread. I just watched other
wallets and at some point decided its time to switch to mBTC.

@_date: 2014-03-14 15:05:25
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] moving the default display to mbtc 
btw. None of Bitcoin Wallet's users complained about confusion because
of the mBTC switch. In contrast, I get many mails and questions if
exchange rates happen to differ by >10%.
I suspect nobody looks at the Bitcoin price. It's the amount in local
currency that matters to the users.

@_date: 2014-03-14 15:49:40
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] moving the default display to mbtc 
How much do you pay for an Espresso in your local currency?
At least for the Euro and the Dollar, mBTC 3.56 is very close to what
people would expect. Certainly more familiar than ?BTC 3558 or BTC
Anyway, I was just sharing real-world experience: nobody is confused.
Learn Graph Databases - Download FREE O'Reilly Book

@_date: 2014-03-14 16:02:59
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] moving the default display to mbtc 
By that definition 3.56 is a price. Maybe I misunderstood you and you're
lobbying for mBTC?

@_date: 2014-03-14 16:30:00
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] moving the default display to mbtc 
I don't know about financial software.
I really don't get what you mean by weird notation? Bitcoin Wallet is
made for ordinary users. They are used to real-world prices like EUR
1.63 / USD 2.26 (that would be the Espresso example). How can mBTC 3.56
be weird to these people?
Granted, there are exceptions, like in Japan. Maybe those would be
better served with ?BTC as default. Maybe. Up to now, outside of this
mailing list nobody requested ?BTC. Then again, Japanese userbase is
tiny compared to US.

@_date: 2014-03-14 16:56:23
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Indeed, rounding is the obvious easy fix. Bitcoin Wallet rounds all
amounts except if you type amounts with a higher precision.

@_date: 2014-03-20 09:08:45
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
We could use Bluetooth in the "r" parameter, not unlike we use Bluetooth
in the payment_url. However, since multiple devices could access your
machine at the same time, we need some for of adressibility of different
payment requests. Something like
Well, do we need to be compatible? If the dev community decides Base43
PR QR's (or whatever other self-contained format) is the way to go, we
just implement, roll it out and use it.
Alphanumeric QR codes have an alphabet of 45 chars, of which I am using
43. I skipped Space and '%' because they're not allowed in URIs. When I
invented the Base43 format back in 2011, wanted it to be URI compatible
so we can use the Android intent dispatcher.
If we let go of the URI requirement, we can use binary QR codes as well.
This means users will always have to manually start their Bitcoin app
first. (Also, there is an implementation issue with the ZXing scanner
I'm using, it returns Strings rather than a byte array so it will choke
on \0 characters.)
I took this into consideration. It would be space inefficient.
The Base58-encoded address from BIP21 forces the QR code into binary
mode. Still you can't encode the payment request extension (probably an
URL parameter) as binary because it needs to stay compatible to the URI
standard (RFC 3986). You could use one of the Base64 variants for the PR
in this case, but still it would be inefficient.

@_date: 2014-03-20 09:09:39
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Afaik, BIP73 needs an external server (the web server).

@_date: 2014-03-21 10:47:03
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Agreed. I used the dash because I feared a slash would need to be
escaped if used in an URL parameter.
Thought of that as well. On the other hand, HTTP might be overkill and
we inherit its potential downsides as well.
Agreed. All I wanted to say support for QR is still small enough that we
might be able to switch to an incompatible standard. If we're determined
that is.
Base 64 via binary QR:   64 chars / 256 chars
                         ==> 6 bit / 8 bit = 0.75
Base 43 via alphanum QR: 43 chars / 45 chars
                         ==> 5.43 bit / 5.49 bit = 0.99
That would be efficiency in terms of PR data size vs. amount space used
in a QR code. Of course, the visual QR encoding also plays a role, for
example its size is increased in discrete steps.

@_date: 2014-03-21 11:25:59
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Technically 3 KB. In my experience codes above 1.5 KB become impossible
to scan (ZXing scanner, 3 years ago). You will want to stay below 500
bytes for convenient scanning. That said, I'm convinced there is a lot
of room for scanning improvements.
As said in the OP, a minimal PR uses 50 bytes. X.509 seems to put about
4000 bytes on top of that.
As you can see, we have quite some room for improvements to PR payload
(PaymentDetails). X.509 certification will probably not be possible via
QR, at least not until specialized CA's will issue space-efficient certs
(using ECDSA?).

@_date: 2014-03-21 11:28:22
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Unfortunately it still is. At least here in Germany.

@_date: 2014-03-21 11:43:27
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
I couldn't do a better job at describing my motivation behind trying to
stuff payment requests into QR codes.

@_date: 2014-03-21 15:51:42
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
can be
Quoting from RFC 3986, Section 3.4. Query:  "The characters slash ("/")
and question mark ("?") may represent data within the query component."
Thanks for testing this. It would be interesting to know what device and
software you used for scanning. But anyway, it falls into the same
ballpark as my tests.
So BIP72 with a BT URI in the 'r' parameter?

@_date: 2014-03-21 16:20:40
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Btw. we could also consider SPDY. I'm not sure about the advantages, but
its probably quicker and leaner.

@_date: 2014-03-27 00:20:49
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
But these cases are the norm, rather than the exception. Of all these
places I spend my money at during the day I hardly ever know their
official name. I'm thinking in terms of "bakery", "indian restaurant" or
"snack vending machine".
In Germany usually businesses are named like the people that run it.
That usually just one or two random family names plus the legal form of
the company.

@_date: 2014-03-27 00:37:46
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] New BIP32 structure 
Thanks for starting the discussion on finding a better structure.
For me, the most important thing is either we're 100% interoperable or
0%. There should not be anything inbetween, as users will delete seeds
without knowing there is still money in them on another implementation.
I heard from multiple sources that using this standard some wallets will
only see a subset of the addresses/keys of some other wallets.
Implementation differences can always happen (and should addresses as
bugs), but I think its unacceptable that this source of issues is by design.
I suggest we agree on an even simpler least common denominator and
wallets that want to implement some feature on top of that can do but
are encouraged to pick a totally different "cointype". I guess that
would mean removing reserved and account.
I'm still thinking it might be a good idea to have a separate chain for
"refunds". Refunds will be rarely used and thus need a much slower
moving window than receiving addresses or change.

@_date: 2014-03-28 12:25:53
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 70 refund field 
I see the problem.
However, I don't see how PaymentDetails can be an answer. None of the
fields (other than outputs and network) can be known in advance (at the
time of the initial payment).
You're probably aiming for an expires field? How would you refund a
payment after expiry? Note its not your choice wether to refund a
payment -- it can be ordered by a court years after the payment happened.
Btw. another problem is that the refund address is currently unprotected.

@_date: 2014-03-28 17:59:52
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 70 refund field 
Ok, why don't fix this in the spec for now, by defining a fixed expiry
time. In the EU, most products are covered by a 2 years warranty, so it
seems appropriate to pick 2.5 years (30 months) -- allowing for some
time to ship the product back and forth.

@_date: 2014-03-28 21:56:57
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 70 refund field 
It depends on usage stats, script size, etc...
Usually yes. The next smaller "unit of time" in Germany would be two
weeks, the so-called "Fernabsatzgesetz". It allows you to send back
mail-orders and usually you want the money back. Don't know if that made
it into EU law or how it applies to other countries.

@_date: 2014-03-30 19:21:26
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP 70 refund field 
I'd prefer 3 months to 2 just because a quarter of year is a more common
But of course its just paint shedding, so 2 sounds good for me too (-:

@_date: 2014-05-15 13:50:29
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
I'm bringing this issue up again. The current Bitcoin DNS seed
infrastructure is unstable. I assume this is because of we're using a
custom DNS implementation which is not 100% compatible. There have been
bugs in the past, like a case sensitive match for the domain name.
Current state (seeds taken from bitcoinj):
seed.bitcoin.sipa.be			OK
dnsseed.bluematt.me			OK
dnsseed.bitcoin.dashjr.org		SERVFAIL, tried multiple ISPs
seed.bitcoinstats.com			OK
testnet-seed.bitcoin.petertodd.org	SERVFAIL, just from Telefonica
testnet-seed.bluematt.me		OK (but only returns one node)
Note: Telefonica is one of Europe's largest ISPs.
I would try to improve DNS myself, but I'm not capable of writing C. My
"fix" would be to reimplement everything in Java -- I doubt you guys
would be happy with that.

@_date: 2014-05-16 11:15:34
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
I just used "nslookup", after seeing the issues in bitcoinj.
I agree that clients should be robust regarding DNS lookups (and
bitcoinj isn't), but still I think the first step needs to be
maintaining a quality infrastructure.

@_date: 2014-05-16 18:34:36
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
Apparently British Telecom also cannot speak to Peter Todd's server.
That another very large ISP in Europe.

@_date: 2014-05-16 21:43:08
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
For example just now:
$ nslookup testnet-seed.bluematt.me
Server:		127.0.1.1
Address:	127.0.1.1
Non-authoritative answer:
testnet-seed.bluematt.me	canonical name = bitcoin-seednode.bluematt.me.
bitcoin-seednode.bluematt.me	canonical name = desktopv2.bluematt.me.
Name:	desktopv2.bluematt.me
Address: 152.23.202.18
And that address doesn't connect on port 18333.

@_date: 2014-05-17 13:39:40
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
I think the best way to contribute to the infrastructure is actually
what we're doing: Test the current infrastructure and point out where it
is not working. Trying to find solutions for problems.
There is nothing gained by throwing additional hardware at a problem if
the problem itself isn't understood well.

@_date: 2014-05-17 14:39:25
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
Yes, that's my understanding too.
Yes, definately.
Afaik this is what most of the other seeds are using, yes.
Sound great! Let me know if you've got something to test.

@_date: 2014-05-18 14:14:51
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Paper Currency 
I think you'd need multiple factors to protect against that attack. Like
encrypting with a key that is printed on the note as an QR code.

@_date: 2014-05-18 15:50:56
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Paper Currency 
Jerry, some feedback on generating space-efficient QR codes. QR codes
have 4 possible encodings, see "Storage":
The encoding you're proposing in BIP81 switches you to binary mode
without actually using all the bits. So you'll end up with bloaty QR
codes. One fix would be of course use all the available bits.
However, binary QR codes cannot be used to auto-dispatch to apps on
Android. If you want a wallet app to automatically open upon scan, you
need to encode your data as an URI. That pretty much locks you into
using alphanumeric mode QR codes.
I've implemented that in Bitcoin Wallet for efficiently encoding
transactions and BIP70 payment requests into QR codes. Since the allowed
alphabet is 43 chars, I've named the encoding Base43 (it uses the same
algorithm as Base58 or Base64). Tell me if you're interested in the details.

@_date: 2014-05-21 13:03:29
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
Great, thanks for this contribution!
Do you plan to have your seeds reachable on port 53 eventually?
Currently bitcoinj cannot deal with nonstandard ports I think.

@_date: 2014-05-21 13:26:21
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] DNS seeds unstable 
Hmmm, not for me:
$ nslookup bitcoin-seed.alexykot.me
Server:		127.0.1.1
Address:	127.0.1.1
** server can't find bitcoin-seed.alexykot.me: SERVFAIL
$ nslookup testnet-seed.alexykot.me
Server:		127.0.1.1
Address:	127.0.1.1
** server can't find testnet-seed.alexykot.me: SERVFAIL
Can you look up in the logfile what requests I just made?

@_date: 2014-05-25 21:12:10
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] testnet-seed.bitcoin.petertodd.org is up 
Thanks for looking at the issue.
Unfortunately, it still fails for me:
$ nslookup testnet-seed.bitcoin.petertodd.org
Server:		127.0.1.1
Address:	127.0.1.1
** server can't find testnet-seed.bitcoin.petertodd.org: SERVFAIL
Like I said, can you look at the logfiles how the requests arrive?
What particular thing did you fix? It would be good to know for future

@_date: 2014-05-27 00:12:05
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] testnet-seed.bitcoin.petertodd.org is up 
You're very quick to point at others. Especially since they run software
that had the time to mature for about 30 years, and the protocol didn't
really change since then...
The last time it didn't work, the bug -- non RFC-conformance -- was on
the bitcoin seeders side. ISPs do weird things with DNS, but usually
they stay within the RFC.
Anyway, without logs we don't have a chance to debug this issue. Any
chance you could add simple logging to the seeder?
DNS via HTTP? Never heard of that, at least it sounds weird as well.

@_date: 2014-05-27 01:19:39
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] testnet-seed.bitcoin.petertodd.org is up 
I'm already volunteering. At least I don't get paid for my efforts in
debugging the seed infrastructure.
Can you verify if your copy of the seeder contains the commit
8dcc006e6256cb746c2b025daf3df41baa26353e ?
It fixed a bug that has exactly the symptoms we currently see.
I wonder if the restart of your server actually changed/fixed
anything. If you got a SERVFAIL this may be because you were traveling
through parts of the world that can't reach your server. Did you
actually try at home, before the restart?

@_date: 2014-05-30 17:40:06
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] testnet-seed.bitcoin.petertodd.org is up 
I maybe have made this suggestion in the past, but why don't we teach
the seeder (or maybe even plain bitcoind) how to write a zone file and
then use matured DNS servers to serve this zone?
I admit I never ran my own DNS so I'm not sure if that can work -- but
to me it sounds like the easiest approach plus everyone can just use
stock server software.

@_date: 2014-09-12 11:29:42
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP72 amendment proposal 
This is the discussion post corresponding to this PR:
"Amend BIP72 by an "h" parameter, which contains a hash of the
PaymentRequest message that is fetched via the "r" parameter.
The hash is meant to link the trust anchor (e.g. the QR code) to the
payment request message in a secure way. This will solve the problem
several apps are comparing address+amount fields as a workaround
instead, preventing some advanced BIP70 usecases. When these apps read a
matching hash, they need not compare any of the other fields.
Thanks to Julian Haight for helping with the standard."

@_date: 2014-09-12 13:07:27
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP72 amendment proposal 
Hard to say, but here is my last assertion:
- Bitcoin Wallet
- Hive Bitcoin Wallet (checked by source)
- countless (> 300) forks/clones of Bitcoin Wallet
Since you're planning an advanced BIP70 usecase, you'll also have to
deal with the many wallets that don't support BIP70 at all.

@_date: 2014-09-12 16:36:41
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP72 amendment proposal 
To put that into perspective, here is how a bitcoin: URI would look like:
(obviously for real-world usage you would optimize the "r" parameter)
I looked at the list in this doc to evaluate what's easily available:
I thought SHA1 has a bad reputation these days, and we don't save much
by using it. I don't know anything about Murmur. MD5 is clearly broken.
What hash function would you recommend?
It is. People can't check names. People don't want to check names.
People can't get certificates for lots of reasons. X.509 is centralized.
X.509 has had serious security issues in the past. And shit continues to
To sum up, X.509 can't replace the trust anchor that is established by
scanning a QR code or tapping two devices together.
Sure. But signing is harder than just calculating a hash.

@_date: 2014-09-15 09:12:03
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP72 amendment proposal 
I agree that this would be another way of achieving the same goal. I'd
be fine with that if there is a majority.
However, I also see downsides of this approach:
1. It's more complicated. It touches more BIPs, and although signing is
terribly difficult its still more difficult than just hashing. E.g.
signing the payment request twice (ECC + X.509) poses the question in
which order you sign, and which signature fields to null for signing.
2. Isn't it discouraged to disclose the public key you're going to
receive coins on? (not sure about that)
3. Unlike an hash we can just re-assign to different objects (see my
proposal) I think we cannot easily do the same with a signature. It's
probably not very important to have this option, but still it should be
4. I'm afraid of the idea of re-purposing the BIP21 address. Someone
might send money to it although it isn't meant to receive money any more
(service is already using an advanced BIP70 usecase). A clear separation
into two parameters would prevent such mistakes, and as soon as the
address can go away the URL needn't be longer than it used to be.
5. A hash can be checked without knowing a secret. Are we excluding
stateless devices (e.g. proxies, smartwatches)?
Generally about the URL length discussion:
Currently we have address, amount and r, and it works well. In future we
would have h and r.
So all we need to do is make sure h not longer than address+amount. I
think this is already the case with untruncated SHA256 hashes. But I'd
be fine with truncating to maybe 192 bits to save a few characters.

@_date: 2014-09-15 09:43:32
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] BIP72 amendment proposal 
Although it currently does not seem to be used that way, I'd like to see
merchants sign their payment requests but store them on their payment
processors server. Currently if you buy from Humble Bundle, all you see
is Coinbase which is unfortunate.
I think that's unrealistic. HTTP is already in use, and also the
proposed spec is open to other transports, e.g. Bluetooth which is also
already in common use.

@_date: 2015-08-21 10:31:48
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Revisiting NODE_BLOOM: Proposed BIP 
None of these wallets (except Electrum maybe) could gain a significant
amount of new users during the last year or so, if you look at the stats
of Google Play.
Specifically Mycelium lost a significant amount of users during the last
stress test when their centralized infrastructure was overloaded. As a
consenquence, their developer announced on Reddit to try moving the
wallet to SPV.

@_date: 2015-08-29 20:07:26
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration 
Good thinking! It might make sense to look at the existing de-facto
standard (e.g. blockexplorer.com, blockchain.info):

@_date: 2015-02-02 13:38:53
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Export format for xpub 
It's h=bip32 for the hierarchy used and
c=123456 for the creation date of the wallet (in seconds since epoch).
I pondered about if we should add a scheme (e.g. "bitcoin-xpub:") but
decided to start without. The only advantage I currently see would be it
could be used on Android to dispatch intents to the right app(s).

@_date: 2015-02-02 15:17:41
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Export format for xpub 
Yes, except that BIP32-hierarchy and BIP44 differ in some requirements
(e.g. gap limit).
Those strings are not meant to be read by humans. YYYYMMDD is more
complicated than necessary, given that Bitcoin deals with seconds since
epoch everywhere.

@_date: 2015-02-03 01:02:28
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Export format for xpub 
Pavol's suggestion saves 2 chars only because its just a date. I think
the creation date should be at least precise to the hour, if not to the
But anyhow, if everyone prefers a human readble date format I will bow
to the majority.

@_date: 2015-02-03 01:05:06
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Export format for xpub 
I don't think that parameterizing will work, we can't predict future
BIPs. It's the same as for BIP43, in the end we agreed on just putting
the BIP number.

@_date: 2015-02-03 11:34:31
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Export format for xpub 
It should follow the spec. I know BIP32-hierarchy is short on gap
limits, which is why (amongst other reasons) I expect
BIP32-hierarchy-based wallets migrate to a better standard at some time.
If it follows BIP32, h=bip32 is fine.

@_date: 2015-02-03 11:37:31
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Export format for xpub 
Not really IMHO. Keys can be used on multiple blockchains.

@_date: 2015-02-05 14:46:44
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Proposal for P2P Wireless (Bluetooth LE) 
Thanks Paul, for writing up your protocol!
First thoughts:
For a BIP standard, I think we should skip "bitcoin:" URIs entirely and
publish BIP70 payment requests instead. URIs mainly stick around because
of QR codes limited capacity. BIP70 would partly address the "copycat"
problem by signing payment requests.
In your Motivation section, I miss some words about NFC. NFC already
addresses all of the usability issues mentioned and is supported by
mobile wallets since 2011. That doesn't mean your method doesn't make
sense in some situations, but I think it should be explained why to
prefer broadcasting payment requests over picking them up via near field

@_date: 2015-02-06 09:40:35
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Two Proposed BIPs - Bluetooth 
I'm all for extending the BT: scheme to Bluetooth LE. If you have
ideas how this can be done please let us know. I haven't had a chance to
play around with LE because none of my devices support it.
I suspect the way how Bluetooth LE transfers files (like payment
requests) is opening a plain old Bluetooth socket. If this is true, I'm
afraid Bluetooth LE would not add anything for sending the BIP70
messages back and forth. Note signed payment requests can easily be 4 kB
in size, so speed *does* matter.

@_date: 2015-02-23 01:48:29
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin at POS using BIP70, 
Jan, this is great stuff! Thanks for sharing your experiences.
I think the 4k payments requests issue must be solvable somehow. I had
no trouble transmitting that amount via NFC, although yes a bit of delay
was noticable.
About payment_url: Protobuf allows changing optional to repeated and yes
it's backwards compatible. Which is why I'm personally against parsing
two fields rather than just one.
No it isn't. It's implemented in bitcoinj though.

@_date: 2015-02-23 01:58:42
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin at POS using BIP70, 
I think it will cause too much chaos. My recommendation for the
payment_url field is prefer the same mechanism that was used for
fetching the payment request. Only if the recommendation fails use the
alternatives in order (or in reverse order, I'm not sure at the moment).
I think it can know. The method for catching these intents is very
similar and you can reuse almost all code, but in fact you need to add
an additional line to your AndroidManifest.xml.
Many? Bitcoin Wallet and its forks were the only ones for about a year.
Only recently Mycelium caught up and the others still do not care I guess.
I agree whatever we do must be robust. However I see no reason why NFC
can't be robust, see my previous post.
Ack on Airbitz, and ack on our relationship to Apple (-:
I'm not against improving this point, but I felt the BT enhancements and
the r,r1,r2 proposals are already getting complex enough. I would like
to simplify the proposal by moving unrelated things to somewhere else.

@_date: 2015-02-23 02:02:03
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin at POS using BIP70, 
I think the "trust by proximity" is the best we've got. If we don't
trust the NFC link (or the QR code scan), what other options have we
got? Speaking the session key by voice? Bad UX, and can be eavesdropped
as well of course.

@_date: 2015-02-23 02:05:31
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin at POS using BIP70, 
Of course this is just a minor detail, but Base64Url is well defined,
almost always more efficient than Base58 and never less efficient, and
implemented in way more libraries and OSes than Base58. Base58 was
designed for copy-typing by humans.

@_date: 2015-02-23 10:49:17
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin at POS using BIP70, 
I think at this point I'd like to bring back my original suggestion of
using DHKE (Diffie-Hellman) or simlar. I know we'd still need to
transmit some secret that could be eavesdropped, but at least the
session could not be decrypted from recordings.
Anyway, establishing a "mostly secure" session is clearly an improvement
to no protection at all. If we can't find a solution to the dilemma of
how to exchange the secret, I suggest going ahead with what we have and
make the best from it.

@_date: 2015-02-23 12:58:11
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin at POS using BIP70, 
I read from your answer that even if we use ECDHE, we can't use it for
every situation. So in any case we need the simple bootstrap via a
session key parameter. My suggestion is defer ECDHE for now but keep it
in mind. We can add it later I think.
I happily step up and do the implementation work on the app side. A
first step could be:
- If there is an "s" parameter present wrap the Bluetooth connections
with AES. Sounds good?

@_date: 2015-02-26 10:32:15
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Providing Payment Request within URI 
Yeah, you'd be limited to simple usecases. X509 signing or lots of
outputs will make the QR code hard to scan. However, if all you want to
do is send to a custom script (without using P2SH) I invite you to have
a look at
Basically it's "BITCOIN:-" plus the payment request in Base43 encoded
form. I picked Base43, because that's optimized for QR codes.

@_date: 2015-02-26 13:11:48
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Providing Payment Request within URI 
Both Base58 and Base64 force QR codes into binary encoding. Base64 can
take 6 bits per char, binary of course has 8 bits per char. So you're
wasting 25% of space if you use Base64, a little bit more with Base58.
Base43 takes log2(43) = 5.43 bits per char, while each char uses up 5.5
bits in QR codes in 'Alphanumeric' encoding. So that's a waste of 1.3%.
Source for QR code standard:

@_date: 2015-02-26 13:30:38
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin at POS using BIP70, 
What if the script doesn't use any key at all?
Somehow this "re-using" the fallback address idea feels less and less
appealing to me. I think we should add our own parameter and let go of
fallback addresses as soon as possible. If will waste space during the
transition period, but after that it should make no difference any more.

@_date: 2015-02-26 13:37:05
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Bitcoin at POS using BIP70, 
It's the same with Bluetooth. More and more people use audio via
Bluetooth, mostly because they use a headset or stream their music to
their stereo at home.
Those that still switch off Bluetooth all the time can simply press a
button. It can't be any easier.
True, but those people who switch off Bluetooth will also simply not
install the app because of that permission.
If only Android had optional permissions... )-:

@_date: 2015-07-21 10:20:17
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] QR code alternatives (was: Proposal: extend bip70 
Hmm, the advanced QR code standards are perhaps even useful if we don't
change anything about BIP7x. Because if we can cram more data without
loosing scanning performance this maybe means also we can stay with the
data we have but improve scanning?

@_date: 2015-03-02 08:09:12
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
Congrats on the release! Electrum is a very nice wallet.
Dive into the World of Parallel Programming The Go Parallel Website,

@_date: 2015-03-11 16:31:06
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
Thanks Thomas, for sharing your experience!
I'd like know why you think it's a problem that BIP43 is tied to BIP32?
I understand we all agreed at least on the BIP32-derivation spec
(excluding the BIP32-hierarchy spec)?

@_date: 2015-03-12 11:28:25
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
That doesn't work for mobile wallets, because we need to consider the
offline case. To fix this, we'd need to extend BIP70 to tell the
merchant where to forward the half-signed transaction to. Then again I'm
not sure if we want that, for privacy reasons. In any case, practical
multisig is still a looong way off.

@_date: 2015-03-12 11:41:03
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
For reasonably skilled users your points are valid, but I'm sure you
also ? like me ? encountered the kind of user who has absolutely no clue
but thinks he understands. S/he will ignore warnings and run into
troubles. This generates a huge amount of support cases and likely tears
about lost coins.
The simple fact that someone elses broken RNG implementation/wrapper
could compromise the security of my software frightens me.

@_date: 2015-03-12 11:43:57
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
Thy, your message threading is broken. Can you make sure your mail
program uses the correct message ID when replying?

@_date: 2015-03-12 19:51:14
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
I'm afraid this will never fly. Wallets are just too different and
that's a good thing! For example, by design choice Bitcoin Wallet and
bitcoinj doesn't support multiple accounts. How would it ever import
wallets from MultiBit or Mycelium?
Bitcoinj-based wallets could probably share the bitcoinj protobuf wallet
format (or whatever format we will be at the time of the "merge" ? we
already have tons of requirements piling up!). This would mean bitcoinj
is the "consensus library equivalent" you were mentioning.

@_date: 2015-05-09 21:00:33
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] A suggestion for reducing the size of the 
Actually your assumption is wrong. Bitcoin Wallet (and I think most, if
not all, other bitcoinj based wallets) picks UTXO by age, in order to
maximize priority. So it keeps the number of UTXOs low, though not as
low as if it would always pick *all* UTXOs.

@_date: 2015-05-25 22:29:26
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] A suggestion for reducing the size of the 
Yes, that's the issue. Because you're connecting only to one node, you
don't get any instant confirmations -- due to a Bitcoin protocol
limitation you can only get them from nodes you don't post the tx to.

@_date: 2015-05-26 14:40:28
@_author: Andreas Schildbach 
@_subject: [Bitcoin-development] A suggestion for reducing the size of the 
It should work, I'm testing this regularly. Can you report an issue
through the app and attach your log when this happens again?

@_date: 2015-10-27 10:12:52
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Bitcoin URI for multiple addresses without using 
You can do this using a BIP70 payment request. It allows you to specify
several scripts (addresses) to pay to, and the individual amounts for
each script.
BIP70 payment requests can be transmitted via NFC, Bluetooth, HTTP(S),
Mail... see
 for
an overview.

@_date: 2016-08-24 15:47:08
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP Status updates (including to Active/Final 
FWIW, BIP44 also doesn't encode a seed birthday. This needed so that SPV
wallets do not need to scan from the beginning of the blockchain.
That doesn't mean BIP44 could not be final. There are some wallets that
interoperate on that standard and that's fine. The whole reason I
insisted on separating BIP43 from BIP44 is that someone else can come up
with a better "BIP44+" standard and not get into the way of existing
standards. I think BIP43 should be made final as well, if it isn't already.

@_date: 2016-01-26 15:37:15
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment 
Discussion about reasoning of OP_RETURN aside, I think your
specification needs to be more precise/less ambiguous.
Here is what BIP70 currently says about PaymentDetails.outputs:
"one or more outputs where Bitcoins are to be sent. If the sum of
outputs.amount is zero, the customer will be asked how much to pay, and
the bitcoin client may choose any or all of the Outputs (if there are
more than one) for payment. If the sum of outputs.amount is non-zero,
then the customer will be asked to pay the sum, and the payment shall be
split among the Outputs with non-zero amounts (if there are more than
one; Outputs with zero amounts shall be ignored)."
As you can see, zero outputs are not ignored at all. They are used as an
indication to allow the user to set an amount. So if you'd come up with
one zero-amount OP_RETURN output, it would pop up an amount dialog.
Certainly not what you want, right?

@_date: 2016-06-21 11:43:15
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070 
Protobuf vs. JSON was a deliberate decision. Afaik Protobuf was chosen
because of its strong types, less vulnerability to malleability and very
good platform support. Having coded both, I can say Protobuf is not more
difficult than JSON. (Actually the entire Bitcoin P2P protocol should be
based on Protobuf, but that's another story.)
Yes, all extensions to BIP70 should go into new BIPs. Note the plural
here: if you have orthogonal ideas I strongly suggest one BIP per idea
so they can be discussed and implemented (or rejected) separately.

@_date: 2016-06-23 13:50:16
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070 
What Andy said, plus there is an (unencrypted) version of BIP70 via
Bluetooth already in place. And its used in several thousand
face-to-face trades per day.

@_date: 2016-03-11 12:54:52
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP75 - Out of Band Address Exchange 
I think it's a bad idea to pollute the original idea of this BIP with
other extensions. Other extensions should go to separate BIPs,
especially since methods to clarify the fee have nothing to do with
secure and authenticated bi-directional BIP70 communication.

@_date: 2016-03-12 15:40:11
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP75 - Out of Band Address Exchange 
Yes, it makes sense. A BIP is something people refer to, either just by
its number or by URL, and with multiple orthogonal "sub-BIPs" it's
difficult to refer to. We have this problem with BIP32 already -- all HD
wallets implement the derivation part of BIP32 but almost none do
implement the hierarchy part (and use BIP43/44 instead). I tried to
split up BIP32 into two BIPs later (without any content changes), but it
was declined because of its final state.
There is no harm in using a BIP only for a small thing, BIP numbers are

@_date: 2016-03-12 16:00:17
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP75 - Out of Band Address Exchange 
Replying to the "fee" part of BIP75 (which as already noted should go to
a different BIP number imho):
It makes to sense to let the payee define a fee *rate*. The payee
doesn't know anything about how the payer's wallet is structured. In
extreme cases, as a payer I would keep all my tiny UTXOs (which would be
unspendable in a economic way) for the one payee who is willing to pay a
high enough rate...
Rather, I propose an absolute amount that the payee is willing to cover
should be declared.
Also, in order to avoid disputes I suggest the amount should be deducted
from the BIP70 payment message amount already. A wallet which
understands BIP75fee would add these two up for *display* puposes only.
The wallet should continue to use the existing fee policies. If it can
send the amount as specified by BIP70 and the fee is below the BIP75fee
amount, it would not mention any fees to the user. If it exceeds, it
would display just the exceeding amount.

@_date: 2016-05-14 09:00:27
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Bip44 extension for P2SH/P2WSH/... 
The whole idea of BIP43 (which BIP44 bases on) is that how these BIPs
define balance retrieval never changes. This is to make sure you always
see the same balance on "same BIP" wallets (and same seed of course).
So if you want to add paths, it has to be a new BIP.

@_date: 2016-09-21 14:00:23
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
Just glancing over your BIP, I wonder if we should use Protobuf. It uses
this "flexible" format already and is quite compact/binary. We use
Protobuf already for the payment protocol, and there is very good tool

@_date: 2016-09-21 17:02:56
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] On-going work: Coin Selection Simulation 
The correct name is Bitcoin Wallet, or Bitcoin Wallet for Android (if
you want to refer to the Android version).

@_date: 2017-04-06 18:13:55
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP proposal: Inhibiting a covert attack on the 
Do you plan to release details about this, or is it already documented

@_date: 2017-07-04 13:50:30
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP proposal: No chaining off replaceable 
Your BIP would take away the only way the *receiver* has to raise the
fee: CPFP. And the receiver is arguably the more important party in this
question. After all the sender has no real incentive for his payment to
be confirmed; it's receiver who has.

@_date: 2017-06-01 07:54:37
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] [RFC] Lightning invoice/payment format draft 
In order for such messages to be dispatchable between apps, I suggest
prepending with an URI scheme, similar to the already existing
"bitcoin:" scheme.
Also I suggest defining a MIME type, e.g. for usage in NFC NDEF messages
or emails.
What is the relation of this BIP to BIP21 and BIP70-72? Is there a
reason for not extending BIP70?

@_date: 2017-06-19 13:58:18
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
I'm not sure if this has been brought up elsewhere in this thread.
This proposal doesn't seem to be a complete replacement of BIP37: It
doesn't provide a filter for unconfirmed transactions like BIP37 does.
That means that most light clients will continue to use BIP37 even if
they may use this BIP as a supplement. Otherwise users would not get
timely notification of incoming payments any more.

@_date: 2017-06-19 17:43:14
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
Just to give you a number: based on the statistics of the Bitcoin Wallet
app there are at least 2 million wallets depending on BIP37. Not all
would need instant notification but based on the daily support enquiries
instant notificaton is the most asked property of Bitcoin.

@_date: 2017-06-19 17:59:57
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
Another number: I'm answering dozens of support inquiries about
delayed/missing transactions per day. Over the 7 years of Bitcoin
Wallet's existence, I estimate about 50000 inquiries.
On the other hand, I remember only 1 (one) inquiry about the privacy
problems of BIP37 (or privacy at all).
everyone would take it for free, but certainly not if it a) delays
incoming payments or b) quickly eats up your traffic quota.

@_date: 2017-06-19 22:49:17
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
Most SPV wallets make it quite clear that unconfirmed transactions are
just that.

@_date: 2017-03-07 00:14:13
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Currency/exchange rate information API 
Yes, it is. Basically all incoming transactions are historical, as your
wallet is likely not online when it happens.

@_date: 2017-03-21 17:16:30
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] A BIP proposal for segwit addresses 
Why use Base 32 when the QR code alphanumeric mode allows 44 characters?
In Bitcoin Wallet, I use Base 43 (alphabet:
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$*+-./:") for most efficient QR
code encoding. I only leave out the space character because it gets
replaced by "+" in URLs.

@_date: 2017-03-29 12:07:40
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] A BIP proposal for segwit addresses 
I'm not convinced that transmitting addresses via voice should be a
usecase to target at. I don't understand your comment about non-english
speaking users. Obviously they cannot voice-communicate at all with
only-english-speaking users, so there is no need to communicate
voice-communicate addresses between them.
Addresses in QR codes, addresses in URLs and addresses in NFC NDEF
messages are the three most used forms.
Speaking of URLs, actually Base 32 (as well as Base 43) makes QR codes
*bigger* because due to the characters used for URL parameters (?&=)
those QR codes are locked to binary mode. To make them shorter, we'd
need to use something like "Base 64url" (or ideally Base 94 -- all
printable ASCII characters).

@_date: 2017-09-06 00:13:12
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts 
Generally I like the idea, but maybe we should come up with a
(Bech32-based?) new standard that also includes the key birthdate (aka
"wallet birthdate").
Also I heard Core will mix addresses of all types on the same HD chain.
What prefix would it pick? "*pub"?

@_date: 2017-09-07 21:35:49
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Proposal: Extended serialization format for 
I think that would work.
In case of Bitcoin Wallet, the depth is not null (m/0'/[0,1]) and still
we need this field. I think it should always be present if a chain is
limited to a certain script type.
There is however the case where even on one chain, script types are
mixed. In this case the field should be omitted and the wallet needs to
scan for all (known) types. Afaik Bitcoin Core is taking this path.

@_date: 2017-09-28 12:09:59
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Address expiration times should be added to 
This feels redundant to me; the payment protocol already has an
expiration time.

@_date: 2017-09-28 16:13:48
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Address expiration times should be added to 
The payment request message is just as one-way as an address is. It is
already being emailed and printed on an invoice, in fact it often acts
as the invoice.
Even more problematic, if you were to include an expiry date in a
BIP-173 address and put that into a payment request, wallets wouldn't be
allowed to parse that expiry date from the script without violating the
BIP70 spec.

@_date: 2017-09-28 17:06:56
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Address expiration times should be added to 
I've not yet progressed that far in segwit support, but I can't think of
a reason why not. You can request coins to any script using the payment
Regarding size, I've had no problems putting (unsigned) payment request
messages into QR codes. I doubt paying to a native segwit address will
change much in size. Protobuf is very efficient.
The BIP70 spec doesn't limit you on this, I guess either does exist.
Having two (or more!) optional expiration date adds unnecessary
complexity to the specs and implementations. E.g. what if the two do not
match up?
What do you mean by "scan the date"?

@_date: 2017-09-29 10:44:11
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Address expiration times should be added to 
Hasn't caught on? It is used for virtually all merchant transactions,
plus person to person transactions between Bitcoin Wallet users.

@_date: 2017-09-29 14:45:32
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Address expiration times should be added to 
I regularly pay with Bitcoin, and I haven't seen the payment protocol
not being in use in ages.
15+ Mio Coinbase users
~10 Mio BitPay users
8 Mio Bitcoin Wallet users
Plus Bitcoin Core, Electrum, etc (sorry no numbers)
Probably the only usecase for naked addresses is paper wallets, right?
I'm not sure if paper wallets can expire.

@_date: 2017-09-30 17:33:01
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Why the BIP-72 Payment Protocol URI Standard is 
Generally agreed. This is why I nack'ed BIP72 years ago when we
discussed about standardization.
However, there are many ways to use BIP70 without BIP72. BIP72 is just a
kludge to biggy-pack the payment protocol onto BIP21. And also, as you
note, BIP72 can be easily fixed using a hash parameter.

@_date: 2018-04-13 17:32:15
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BloomFilter issue with segwit addresses 
Anton, a developer on the bitcoinj maiing list, recently made me aware
[1] of a compatibility issue between segwit and BIP37 (Bloom Filtering).
The issue affects only P2WPKH and the special case of transactions
without change outputs (such as when emptying a wallet). In this case,
neither inputs not outputs contain any data elements that would cause a
match for the filter. The public key, which would match, goes to the
witness but not to the input.
My suggestion was to include an OP_RETURN output with a matching public
key in such transactions. Anton confirmed that this workaround is indeed
working. But of course it nullifies some of the segwit's size improvements.
I wonder if Bitcoin Core would be willing to extend the BIP37 matching
rules such that data elements in the witness are also matched against?
[1]

@_date: 2018-04-15 20:37:45
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BloomFilter issue with segwit addresses 
Yes, I guess the quicker filter exhaustion must be the reason why
bitcoinj doesn't make use of outpoints in filters for standard
transactions. I'll look into if I can change that.

@_date: 2018-11-07 22:28:54
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP Proposal - Address Paste Improvement 
Copying addresses to the clipboard should be discouraged, rather than
It is an inherently insecure mechanism. Regardless of the OS used, any
application can monitor the clipboard for Bitcoin addresses and replace
any address with their own, usually without any specific permission or
confirmation by the user. Effectively this steals Bitcoins if the user
doesn't compare addresses manually.
This is a real risk, as this kind of malware has already been seen.
Never copy & paste Bitcoin addresses!

@_date: 2018-11-08 16:28:41
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] BIP Proposal - Address Paste Improvement 
- QR code scanning of a Bitcoin URI
- On Android: A "bitcoin:" URI intent or a BIP70 payment message intent
- On desktop OSes there are similar mechanisms to launch Apps from the
browser (e.g. for mailto: links)
For editing the clipboard your computer doesn't need to be compromised!
*Any* app can do it, without special permission.
For cases where the payee is a well-known entity the BIP70 payment
protocol has authentication via certificates. That doesn't work for the
"the person in front of you is the only trust anchor you have" usecase

@_date: 2019-07-22 00:56:33
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
An estimated 10+ million wallets depend on that NODE_BLOOM to be
updated. So far, I haven't heard of an alternative, except reading all
transactions and full blocks.
It goes without saying pulling the rug under that many wallets is a
disastrous idea for the adoption of Bitcoin.
I asked many people, even some "core developers" at meetings, but nobody
ever was able to explain the DoS vector. I think this is just a myth.
Yes, you can set an overly blurry filter and thus cause useless traffic,
but it never exceeds just drinking from the full firehose (which this
change doesn't prohibit). So where is the point? An attacker will just
switch filtering off, or in fact has never used it.
Why don't you anticipate that? People almost never change defaults,
especially if it's not for their own immediate benefit. At the same
time, release notes in general recommend updating to the latest version.
I *do* anticipate this will reduce the number of nodes usable by a large
enough amount so that the feature will become unstable.
There is no such alternative.
I strongly recommend postponing this change until an alternative exists
and then give developers enough time to implement, test and roll out.
I also think as long as we don't have an alternative, we should improve
the current filtering for segwit. E.g. testing the scripts themselves
and each scriptPubKey spent by any input against the filter would do,
and it also fixes the main privacy issue with server-side filtering
(wallets have to add two items per address to the filter).

@_date: 2019-07-23 16:47:18
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
(Rather than replying individually, I try to address questions and add
my remarks in one post.)
BIP 157/158 is not an alternative to BIP 37:
1) It causes way too much traffic for mobile users, and likely even too
much traffic for fixed lines in not so developed parts of the world.
2) It filters blocks only. It doesn't address unconfirmed transactions.
3) Afaik, it enforces/encourages address re-use. This stems from the
fact that the server decides on the filter and in particular on the
false positive rate. On wallets with many addresses, a hardcoded filter
will be too blurry and thus each block will be matched. So wallets that
follow the "one address per incoming payment" pattern (e.g. HD wallets)
at some point will be forced to wrap their key chains back to the
beginning. If I'm wrong on this one please let me know.
4) The filters are not yet committed to the blockchain. Until that
happens we'd have to trust a server to provide correct filters.
Bitcoin Wallet, Breadwallet, BISQ and many smaller ones.
Last I checked none of the seeds did. But I agree this would be nice to
I'm disappointed to learn that supporting 10M wallets gets discredited
down to "no contribution". Each node of course supports just a number of
them, but still...
I suspect this is a fallacy. BIP37 doesn't need to be extended for
SegWit. See Bitcoin Wallet and Breadwallet, both support SegWit and use
the original BIP 37.
It's true however that BIP 37 could be made simpler to work with, more
future-proof and more private by simply matching output scripts.
This claims to be a proof of concept, but it's missing the concept. I
could not find a description of the attack and why is it likely to be
exploited (and why it hasn't been exploited yet).
If such an attack exists, it should be easy to defend against. Filter is
using too much CPU time ? disconnect and blacklist the IP for some time.
I vaguely remember the infrastructure for misbehaving peers is already
present in bitcoind.
As a side note, Coinbase just announced their 30M'th wallet. I'm
convinced this massive run into custodial wallets is caused by the
public realizing around Dec 2017 that Bitcoin fails to scale. IMHO, BIP
37 is the only scaling technology that has proven successful and could ?
if supported and improved rather than choked ? continue to help holding
against the bitbanks trend.

@_date: 2019-03-06 17:49:20
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Removal of reject network messages from Bitcoin 
Reject messages cannot be replaced for debugging user problems. At least
unless you plan to make RPC or bitcoind logfiles available via the P2P
protocol (both probably not a good idea).
The typical case is, I get mailed a wallet logfile with reject messages
and that's all I have. I cannot access the bitcoind logfile(s) of the
node(s) that generated the reject message in the first place. Nor can I
access their RPC interface.
I strongly suggest re-enabling reject messages by default before 0.18.

@_date: 2019-03-06 18:14:52
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] bitcoinj 0.15 (segwit) 
In case anyone missed the announcement: bitcoinj 0.15, with support for
native segregated witness, has recently been released.
For operability testing, I just released new versions 7.0 of Bitcoin
Wallet. For now, they still create a keychain of legacy addresses but
they can send to native segwit addresses via Bech32.
(At the time of this writing, you need to opt into beta in order to
receive 7.x: Receiving to native segwit addresses and spending from them will follow
in the coming days and weeks.

@_date: 2019-03-07 18:58:01
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Removal of reject network messages from Bitcoin 
Yes, I'm talking about P2P connections.
First and foremost, reject messages are an indication that the
transaction isn't going to confirm. Without these messages, we'd need to
revert to pre-BIP61 behaviour of using a timeout for reception of
network confirmations.
Regarding the content, these cases are useful to distinguish:
- Not enough fee
- UTXO already spent
- Tx validity/standardness (e.g. invalid signature)
While the last one in theority wouldn't be necessary if you produced
your software bug-free to begin with, this just isn't how software
development works. Developers need any indication they can get.
The first two happen even in the ideal case. Fees are impossible to
predict, and unintentional double spends happen because users clone
their wallet state.

@_date: 2019-03-12 18:08:52
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Removal of reject network messages from Bitcoin 
(Posting again, since my previous reply didn't appear)
These two cases are understood and handled by current code. Generally
the idea is take reject messages serious, but don't overrate the lack
of. Luckily, network confirmations fill the gap. (Yes, a timeout is
still useful. But at least it almost never happens.)
Nevertheless, it has been proven as useful in debugging (just recently
when I implemented the witness signature hash in bitcoinj). I think
Wilmer Paulino summed up this point quite nicely in his reply to this

@_date: 2019-03-13 15:29:43
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Removal of reject network messages from Bitcoin 
It's implemented in bitcoinj's TransactionBroadcast class. Received
reject messages are collected and -- if a certain consensus (currently:
half of connected peers) is reached -- a RejectedTransactionException is
The handling of that exception in Bitcoin Wallet is extremely
rudimentary. I think it still only shows the exception message. But
certainly I was hoping to improve on this soon.

@_date: 2019-10-17 21:38:53
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Removal of reject network messages from Bitcoin 
Is there a NODE_* bit we can use to pick peers that support this
(useful!) feature?

@_date: 2019-10-21 10:44:16
@_author: Andreas Schildbach 
@_subject: [bitcoin-dev] Removal of reject network messages from Bitcoin 
I guess then the best way to discover nodes that have reject messages
enabled is connecting/disconnecting to random nodes and send them
invalid transactions and keep the ones which reply with a reject message.
