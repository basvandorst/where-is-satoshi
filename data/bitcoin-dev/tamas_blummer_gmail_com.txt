
@_date: 2017-12-24 05:26:04
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP Proposal: Utilization of bits denomination 
I see further arguments supporting the ?bit" denomination:
huge benefit:
nice to have:
Tamas Blummer

@_date: 2018-06-03 00:02:11
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
Without block commitment mobiles would have to use trusted filter provider or implement a complex data hungry algorithm and still remain as insecure as with BIP 37.
Years of experience implementing wallets with BIP 37 taught us that an outpoint + output script filter is useful. Committing such a filter to the block can not be an error.
We could roll this out on P2P prior to a soft fork adding the commitment, but I would not expect its use to pick up before that.
Therafter BIP 37 could be rightfully decommissioned, herby offering both security and privacy enhancement at modest data cost.
Tamas Blummer

@_date: 2018-06-03 07:14:34
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
Lighter but SPV secure nodes (filter committed) would help the network (esp. Layer 2) to grow mesh like, but add more user that blindly follow POW.
On longer term most users' security will be determined by either trusted hubs or POW.
I do not know which is worse, but we should at least offer the choice to the user, therefore commit filters.
Tamas Blummer

@_date: 2018-06-03 18:50:17
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
- Output script + spent script filters (Wuille?s (b)) have sizes of ca. 2% of block size.
Tamas Blummer

@_date: 2018-06-03 18:44:04
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
I processed bitcoin history assuming filters using with P=19 M=784931.
- Output script + spent script filters (Wuille?s (b)) have sizes of ca. 0.2% of block size.
- Output script + spent script filters (Wuille?s (b)) are ca. 10% smaller than output script + spent outpoint filters (Wuille's (a)). Savings here however trend lower since years.
Graphs attached.
Tamas Blummer

@_date: 2018-05-28 20:18:12
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
Hi Jim,
A ?basic? combined filter would mean up to 0.5 GB filter data per month (with 100% segwith use). Considering that 1 GB is the usual data quota for an entry level mobile phone contract, this could be a too high barrier for adoption.
I repeated your calculations and produced a slightly different graph that shows the fraction of cummulative filter size to cummulative blockchain size. This is less noisy but otherwise confirms your measurement.
I think that the data supports separation of filters as a combined filter does not seem to come with significant savings. (basic  size ~= txid + input points + output scripts sizes)
My calculations are repeatable with:
that is using a Rust implementation of an SPV client built on top of other libraries we work on in the rust-bitcoin GitHub community ( Yes, this is a shameles plug for the project hoping to attract more developer.
Tamas Blummer

@_date: 2018-05-28 20:28:16
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
Forgot to mention: The link I sent is to a branch that is patched to produce the filter stats. This is the main project and the BIP158 implementation: Tamas Blummer

@_date: 2018-05-31 16:27:50
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP 158 Flexibility and Filter Size 
I processed the historic blockchain to create a single filter populated with spent input scripts and output scripts. The Golomb parameter was P=2^20
The resulting chart shows a volatile history of same-block address re-use with a notable drops in relative filter size during the early history and in the time window where SatoshiDICE was popular, since then trending higher.
The history of only the last half year suggests a current filter size of between 2.0% - 2.5% of block sizes.
Since most outputs are spent within a short time period, but apparently not that often in same blocks, I think it was worth considering filter series that match over a windows of 2^n blocks (n=(0?10)). Applications could then bracket the range of interest and then narrow down requesting finer filters or blocks.
Then I created 1600 random (P2SH) scripts and totaled the false positive block download data size if observing 100, 200, 400, 800, 1600 of them. The result suggests that even for 1600 the false positive overhead is less than 0.1% of blockchain data size. I agree with Greg that we should optimize the parameters for a small observed set as those will be running on mobile devices.
As of Pieter?s findings the simulation parameters were optimal for ca. 1000 observed scripts which is maybe to many for a ?small? application.
On the other hand we do not know the needs of future popular mobile applications.  With parameters of the simulation the current minimal data burden on a mobile wallet would be ca. 0.1 GB / Month.
Simulations with other parameters could be executed using this patch branch:  A run takes a few hours on a fast machine with release build and local bitcoind.
The calculation can not be reduced to the recent history as the process builds in-memory utxo from genesis.
The result of executing the binary is a CSV file containing:
blocknumber, blocksize, utxo size, filter size, false positive data size for 100, false positive data size for 100, ? false positive data size for 100
Tamas Blummer

@_date: 2019-04-04 04:35:03
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Smart Contracts Unchained 
Hi ZmnSCPxj,
Thought provoking, thank you!
Something I dislike in the scheme, that one could not tell which party colluded with the escrow agent.
Tamas Blummer

@_date: 2019-08-14 04:32:40
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] side memory - Transient memory of an other peer to 
It appears to me that there is a generic design pattern for peer to peer networks,
that we might call side memory.
The name is justified with some similarity to side chains. Side memory is however
not about a persistent store, but some transient memory of an other peer to peer network.
The UTXO set is the shared transient memory of the bitcoin network.
Just like we can link the bitcoin block chain with a side chain, we can link
the transient memory of an other network with the UTXO set of bitcoin.
The other network?s transient memory would hold an item until a uniquelly associated
a coin in the UTXO set is unspent. There are many ways to associate data with
an UTXO. How this is done is not a concern here. The method must however allow
the coin to be spent again, so the UTXO set can also trigger eviction of the associated
data from the other network?s memory.
The utility of such association is to impose control and the scarcity of bitcoin to
some other network?s transient memory.
Since the number of possible UTXOs is huge (21 million * 100million) an
associated peer to peer network will want to raise the bar for UTXOs eligible
to enter its store.
An obvious choice for raising the bar is requiring more satoshis to be committed.
The other network may dynamically tailor this requirement or let users compete
for a fixed capacity by committing higher amounts.
Observing the UTXO set is however not a cheap operation. Nodes of the other
network would have to also run a bitcoin node to be sure they do not miss
changes of the UTXO.
There is however a way to significantly simplify this task by using time locks and
SPV validation as follows:
The UTXO committing to associated data would have a relative timelock, such that
it can not be spent within n blocks after it entered the UTXO set. (with OP_CSV)
A network node that originally publishes the data would also send an SPV proof
of the inclusion of associated commitment into the bitcoin blockchain to its peers.
Other network nodes would therefore only need to observe the progress of
bitcoin?s header chain to validate the proof, which is the commitment transaction
and the path to merkle root, before accepting data into their transient store.
The commitment transaction also tells them how long the output can not be spent,
therefore they are relived the burden of watching for UTXO spends. Instead they
can evict the associated data from their transient store as soon as the header
chain they oberve is progressed past the relative locktime.
Nodes that publish new data would have to listen to all blocks after they
broadcast the commitment, until they see it confirmed and can extract the proof.
This could be further optimized if BIP158 filters were available and committed.
The network nodes could use IBLTs (Invertible Bloom Lookup Tables) to distribute
associated data.
Such an associated network would be lightweight since only observing and
storing bitcoin?s header chain and its own peer to peer network.
I will soon release the code of a network that implements this design pattern,
with the SPV optimization and IBLTs, and am looking for help to test it in a
limited deployment, before letting it out into the wild.
Please drop me a mail if you?d like to help there.
Prior art that I summed up as side memory:
The idea of linking names with UTXO goes back to the first fork of Bitcoin and
was significantly upgraded in the numerifides proposal[1] of tyzbit
ZmnSCPxj proposed an advertizement network in which the network's content
is controlled by associated UTXOs in [2].
I observed that time locked commitments would uncover to bitcoin?s internal
riskless interest rate [3].
The pattern is useful as sybill attack protection of coinjoin networks as time locked
commitments can act as fidelity bonds [4]
Tamas Blummer
[1] [2] [3] [4]

@_date: 2019-02-03 21:15:25
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP157 server Murmel introduced, 
TLDR: I suggest to add outpoint filter to BIP158 as it proved to be useful while developing a filter server and allows further checks in filter client.
Murmel is my project within the rust-bitcoin community. Its goal is to provide a lightweight, at least SPV security, settlement layer for the Lightning Network implementation in Rust. Murmel relies on BIP157 (Client Side Block Filtering). Since Bitcoin Core does not yet support this protocol extension, I also added filter and block server functionality to Murmel and this might be useful for development purposes any other BIP157 client project.
You may compile and run a Murmel filter server to support your client development. It bootstraps within a few hours. Follow the instructions at: While implementing both client and server side I made an observation that should be considered for BIP158:
BIP158 specifies base filter containing all scripts spent or created by a block (except those with OP_RETURN). I found it useful to also compute a filter on spent and created outpoints.
The Murmel filter server consults these outpoint filters to find the transactions with the spent scripts while computing the base script filter. Since outpoints usually getting spent shortly after created, this approach works well enough to
keep up with the blockchain, although far too slow to rely on it while bootstrapping. An advantage of this approach of looking up UTXO is that there is nothing to be recomputed at re-org, filters are consulted following
the path from current tip back to genesis. This fits well with Murmel?s storage, that is my other project Hammersbald  a highly efficient truly append only blockchain store in Rust.
Filter matching is also nicely parallelizable looking up subsets of spent outputs in parallel. A lightweight client can use outpoint filters to efficiently validate spent coins or miner reward, which goes beyond SPV guarantees. This is probabilistically possible now, and definitely once filters are committed.
For above reasons I suggest to also add outpoint filter to BIP158, so filter servers may support it, as does Murmel. Murmel is moving quickly; I tagged the version as of this mail with DEVLIST for later reference.
Tamas Blummer

@_date: 2019-02-04 12:41:20
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Interrogating a BIP157 server, BIP158 change proposal 
TLDR: a change to BIP158 would allow decision on which filter chain is correct at lower bandwith use
Assume there is a BIP157 client that learned a filter header chain earlier and is now offered an alternate reality by a newly connected BIP157 server.
The client notices the alternate reality by routinely asking for filter chain checkpoints after connecting to a new BIP157 server. A divergence at a checkpoint means that the server disagrees the client's history at or before the first diverging checkpoint. The client would then request the filter headers between the last matching and first divergent checkpoint, and quickly figure which block?s filter is the first that does not match previous assumption, and request that filter from the server.
The client downloads the corresponding block, checks that its header fits the PoW secured best header chain, re-calculates merkle root of its transaction list to know that it is complete and queries the filter to see if every output script of every transaction is contained in there, if not the server is lying, the case is closed, the server disconnected.
Having all output scripts in the filter does not however guarantee that the filter is correct since it might omit input scripts. Inputs scripts are not part of the downloaded block, but are in some blocks before that. Checking those are out of reach for lightweight client with tools given by the current BIP.
A remedy here would be an other filter chain on created and spent outpoints as is implemented currently by Murmel. The outpoint filter chain must offer a match for every spent output of the block with the divergent filter, otherwise the interrogated server is lying since a PoW secured block can not spend coins out of nowhere. Doing this check would already force the client to download the outpoint filter history up-to the point of divergence. Then the client would have to download and PoW check every block that shows a match in outpoints until it figures that one of the spent outputs has a script that was not in the server?s filter, in which case the server is lying. If everything checks out then the previous assumption on filter history was incorrect and should be replaced by the history offered by the interrogated server. As you see the interrogation works with this added filter but is highly ineffective. A really light client should not be forced to download lots of blocks just to uncover a lying filter server. This would actually be an easy DoS on light BIP157 clients.
A better solution is a change to BIP158 such that the only filter contains created scripts and spent outpoints. It appears to me that this would serve well both wallets and interrogation of filter servers well:
Wallets would recognize payments to their addresses by the filter as output scripts are included, spends from the wallet would be recognized as a wallet already knows outpoints of its previously received coins, so it can query the filters for them.
Interrogation of a filter server also simplifies, since the filter of the block can be checked entirely against the contents of the same block. The decision on filter correctness does not require more bandwith then download of a block at the mismatching checkpoint. The client could only be forced at max. to download 1/1000 th of the blockchain in addition to the filter header history.
Therefore I suggest to change BIP158 to have a base filter, defined as:
A basic filter MUST contain exactly the following items for each transaction in a block:
Tamas Blummer

@_date: 2019-02-04 21:59:44
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Interrogating a BIP157 server, 
I participated in that discussion in 2018, but have not had the insight gathered by now though writing both client and server implementation of BIP157/158
Pieter Wuille considered the design choice I am now suggesting here as alternative (a) in:  In his evaluation he recognized that a filter having spent output and output scripts would allow decision on filter correctness by knowing the block only.
He did not evaluate the usefulness in the context of checkpoints, which I think are an important shortcut here.
Yes, a filter that is collecting input and output scripts is shorter if script re-use is frequent, but I showed back in 2018 in the same thread that this saving is not that significant in recent history as address reuse is no longer that frequent.
A filter on spent outpoint is just as useful for wallets as is one on spent script, since they naturally scan the blockchain forward and thereby learn about their coins by the output script before they need to check spends of those outpoints.
It seems to me that implementing an interrogation by evtl. downloading blocks at checkpoints is much simpler than following multiple possible filter paths.
A spent outpoint filter allows us to decide on coin availability based on immutable store, without updated and eventually rolled back UTXO store. The availability could be decided by following the filter path to current tip to genesis and
check is the outpoint was spent earlier. False positives can be sorted out with a block download. Murmel implements this if running in server mode, where blocks are already there.
Therefore I ask for a BIP change based on better insight gained through implementation.
Tamas Blummer

@_date: 2019-02-05 21:10:09
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Interrogating a BIP157 server, 
Hi Laolu,
The only advantage I see in the current design choice is filter size, but even that is less
impressive in recent history and going forward, as address re-use is much less frequent nowadays
than it was Bitcoin?s early days.
I calculated total filter sizes since block 500,000:
input script + output script (current BIP): 1.09 GB spent outpoint + output script: 1.26 GB
Both filters are equally useful for a wallet to discover relevant transactions, but the current design
choice seriously limits, practically disables a light client, to prove that the filter is correct. Clear advantages of moving to spent outpoint + output script filter:
1. Filter correctness can be proven by downloading the block in question only.
2. Calculation of the filter on server side does not need UTXO.
3. Spent outpoints in the filter enable light clients to do further probabilistic checks and even more if committed.
The current design choice offers lower security than now attainable. This certainly improves with a commitment, but that is not even on the roadmap yet, or is it?
Should a filter be committed that contains spent outpoints, then such filter would be even more useful:
A client could decide on availability of spent coins of a transaction without maintaining the UTXO set, by checking the filters if the coin was spent after its origin proven in an SPV manner, evtl. eliminating false positives with a block download. This would be slower than having UTXO but require only immutable store, no unwinds and only download of a few blocks.
Since Bitcoin Core is not yet serving any filters, I do not think this discussion is too late.
Tamas Blummer

@_date: 2019-02-06 09:09:55
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Interrogating a BIP157 server, 
Hi Laolu,
space savings come with the rather serious current disadvantage, that a light client is not in the position to check the filter. Also the advanced uses you mention are subject to this, for now. Building more on a shaky fundament does not make it look better.
Now that we have seen advantages of both filters, what keeps us from offering both by Core?
Computing the addional spent-outpoint output-script filter is cheaper than the current one as it can be done with the block as only context, it does not need UTXO nor undo blocks no journals or whatever else. I do not see how my statement regarding this was incorrect.
There is a political issue though, why I favor better provable uncommitted filter:
I am skeptical that commitment of any filter will come into Core soon.
The reason of my skepticism is political, not technical.
A committed filter makes light clients much more reliable and attractive, for some taste too much more.
Clients that follow PoW are not significant on the current network. Core nodes enforce many more rules,
some as important as miners' reward. A committed filter would strengthen light clients significantly, such that perhabs too many were compelled using them instead of a Core node. Would the remaining Core nodes be sufficient to enforce checks not covered? I see how this is a dilemma.
Is this a dilemma because we think black-white? Light(er) clients might implement checks that are more than blind PoW trust even if less than all Core checks. Has the time come to allow for this?
Tamas Blummer

@_date: 2019-02-06 19:48:09
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Interrogating a BIP157 server, 
I do not think this ad hominem attack of you on me was justified.
I wrote code, gathered and shared data now and back in 2018. I showed
understanding of non technical issues. Is there an actual action that
defies my observation that a commitment is not yet in sight?
Is there anything technically wrong in what I wrote?
If not you should stop.
Tamas Blummer
On Wed, 6 Feb 2019, 18:17 Gregory Maxwell  On Wed, Feb 6, 2019 at 8:10 AM Tamas Blummer

@_date: 2019-02-06 21:17:17
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Interrogating a BIP157 server, 
The attack was in your implication that I would assume  ill intent of those
contributed to the proposal. That is not my position. I explained why, I
think, rolling out a commitment could face opposition. This foreseable
opposition, that must not come from you makes me prefer a provable
uncommitted filter for now.
I am myself concerned of the implications if many nodes would blindly
follow POW.
I did restart the discussion which I read and participated in at its first
instance because implementing the current proposal taught me how
problematic as is until not committed and because I have not seen a sign to
assume commitment was imminent.
This is not just missing code. AFAIK we do not even have a consensus on how
any future soft fork would be activated.
While trying to build a useful software I have to make assumtions on the
timeline of dependencies and in my personal evaluation commitment is not
yet to build on.
I and others learned in this new discussion new arguments such as that of
atomic swaps by Laolu. If nothing else, this was worth of learning.
It appears me that it is rather you assuming ill intent on my side, which
hurts given that I do contribute to the ecosystem since many years and have
not ever been caught of hurting the project.
Tamas Blummer
On Wed, 6 Feb 2019, 20:16 Gregory Maxwell  On Wed, Feb 6, 2019 at 7:48 PM Tamas Blummer

@_date: 2019-07-02 07:08:53
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
In other words you now see the utility of a register offered by UTXOs that are only temporary availability to current owner. If there is a utility there is also a value in it for them.
I am glad we are on the same side on this utility and thanks to you and ZmnSCPxj we now have two additional uses cases for UTXOs that are only temporarily accessible to their current owner.
Since ZmnSCPxj also raised the question if covenants are needed at all, let me continue my thoughts on this in reply to his mail.
Tamas Blummer

@_date: 2019-07-02 08:38:55
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Good morning Eric and ZmnSCPxj,
All above aligns with my intuition that: on one side giving up temporary control of UTXOs represent opportunity cost and on the receiver side having temporary control can unlock utility they would pay for.
If the techical setup is trustless and return of control to those who gave it up temporarilty is certain, then this in combination means that HODLer are able to earn riskless interest by giving up control of their UTXOs temporarily.
Yes, your example does not need the covenant as the one who gave up temporary control is still involved in any motion of the UTXO, therefore able to enforce own interest that reclaiming the UTXOs remains possible.
A covenant is needed only if it is against the interest of all parties involved in transfers of the UTXO, in which case consensus must enforce that it is carried forward.
The added strength of the covenant is that the one who gives up temporary control does not have to be involved in using the UTXO until it is given back.
Note that the advertizing service provider would need temporary access to UTXOs of signficant value, so opportunity cost and thereby cost of advertizing becomes significant.
Covenants would allow the separation of the advertizing service from HODLer funding it with significant UTXOs.
HODLer could give temporary control to the service and the service could broker those to others, but the original HODLer was sure to receive the UTXOs back and the HODLer would not be bothered with the operation of the service.
The covenant I proposed would add an alternate taproot validation path stacked onto previously existing ones.
This means that one could give others temporary access for a shorter time period than one?s own temporary access.
One could however not override the delayed access secured for the HODLer.
Does this remind you of something? Yes, the service provider would act like a bank, matching depositor, the HODLer, with those who need temporary control of UTXO for advertizing purposes.
This shows why temporary control with covenant can be understood as loan in a full reserve banking, which started my exploration of this topic.
Current technical means do not allow trustless and hands-off coordination of provider of UTXOs (that is capital) with provider of arbitary services that monetize the use of Bitcoin?s unforgable registry.
In other words we need covenants to enable Bitcoin applications to trustlessly and flexibly deal with foreign capital.
One other thing the consensus would have to ensure is that inputs with covenants are merged only into outputs with same covenant.
Which makes UTXOs with a particular covenants obey rules earlier known for colored coins and transactions moving it form a distinct embedded chain.
Adding same covenant establishes fungible coinbases of same embedded chain and dropping the covenant makes them again fungible with common UTXOs.
I could not be more excited of what boost this could give to the Bitcoin economy, unlocking the use of its unforgeable registry to track any asset with the same security guarantees it offers for its own cash token.
Best to you,
Tamas Blummer

@_date: 2019-07-02 11:30:31
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hello ZmnSCPxj,
The advertiser would thereby put the funds of the HODLer on risk of his misbehavior, which means the HODLer would have to trust the advertizing service.
This is not the trustless separation the covenant achives.
Tamas Blummer

@_date: 2019-07-02 11:47:09
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hello ZmnSCPxj,
I share your goal to move everything possible off-chain.
The discussion of covenant is not an on/off-chain discussion, but if covenant is needed to solve problems we currently can not and which unlock significant innovation.
Consensus support of the covenant is only needed if an unchained setup using it is closed uncooperatively, otherwise there is not even a reason to disclose on-chain that a covenant was used.
Tamas Blummer

@_date: 2019-07-02 12:14:32
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hello ZmnSCPxj,
To be more precise, the value of the UTXO is severaly damaged that it is governed by rules of a de-facto side chain with different rules.
Therefore its value to those renting it from the advertizer is just that of the advertizement, which is not neccesarily following the opportunity cost.
The covenant supported temporary access is transitive, therefore anyone who is in temporary control of an UTXO can recover its cost by sub-renting.
The opportunity (riskless) interest provides a baseline of value on top of which you may have utility that is the advertizement.
Tamas Blummer

@_date: 2019-07-02 14:51:31
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hello ZmnSCPxj,
You are right. I noticed after sending my reply and then I sent two other. I apologize for being noisy.
Let me consolidate my thinking, here.
If there is a use for UTXOs with temporary control, then those who want that use will pay for it.
A user of a service that requires temporary control UTXOs would need to cover:
1. fees required by the service
2. the opportunity cost of temporary ownership paid to the original holder who gave up control.
If the service is operated by an entity billing user then it can use UTXOs of minimal value for its operation and practically ignore opportunity interest.
This is the case with theater tickets just and other simple colored coin like use of Bitcoin. Also in case of the unchained advertizement, if the service bills its user
for its internal re-allocation of an UTXO, then why would it need to use significant value temorary control UTXOs? Actually why not use plain UTXOs, to start with?
If however the service is a common good, a network without owner and therefore not billing on behalf of someone, but wants to protect itself from spam, then it is could require temporary access to significant value UTXOs and thereby induce opportunity cost to user. Alternatively it could require burning ordinary UTXOs. Burning indirectly benefits all HODLer, temporary control benefits those who consciously gave up control. I dislike burning as it is unsustainable.
If the implementation of temporary use is enforced by consenus such that it is transitive, then temporary use could be re-rented or sold to recover opportunity cost for no longer needed temporary access, making it useable for an other service.
Temporary access UTXOs with covenants allows us to build spam limited public services that are not owned by an operator and financially benefit HODLer offering them riskless interest.
Tamas Blummer

@_date: 2019-07-04 19:10:31
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hi Eric,
there are some other ways to impose cost on use without direct billing, e.g.:
- Burn Bitcoins to use the service, as you mentioned. This could work and would benefit remaining Bitcoin owner, but is unsustainable.
- Pay high fees in self dealing transactions. This could work and would benefit miner.
- Time lock own Bitcoins. This is forgoing control of an UTXO for a time period, which implies opportunity cost. This could be done with CLTV (OP_HODL). It damages the current owner but benefits no one. The problem is one might not have substantial UTXO to  imply high enough opportunity cost.
- Pay someone else to time lock. This is paying someone to lock an UTXO for a time span. Payment and time lock could be combined in the same transaction.
- Transferable borrowed Bitcoin.  This needs the covenant. This benefits those who consciously give up control for a time span. Its advantage is that since transferable it can be sold if no longer needed, thereby shortening the term of the original arrangement. It coul be re-rented for a shorter time period.
Tamas Blummer

@_date: 2019-07-06 12:12:44
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
My proposal would separate the owner of the funds from the one using the advertizement service. Yes, the owner lock up until maturity. But those using the UTXO for the advertizement service could transfer (sell) the UTXO to someone else as soon as they do not need it, so it is dynamic maturity for them The new owner could use them for an other advertizement or for an entirely different purpose.
Regarding burning: I think burning is unsustainable as usage of services is unlimited while coin suply is limited.
I also struggle to communicate to Eric and likely many other reader the generic utility of temporary control of an UTXO. Let me try again:
Bitcoin offers a memory with remarkable properties:
- it can be read by anyone anywhere
- anyone anywhere who knows a key controlling an UTXO, and only them, can initiate an update to the memory
- global replicas guaranteed to apply updates of the memory within a short time period.
This is a utility that is sufficient to implement money.
Such a reliable shared memory could have however more uses than tracking money, It could keep track of, and thereby make scarce, arbitary other things.
We can unlock these uses by separating the money use of memory from other uses.
The covenant achives this separation temporarily. A UTXO with a covenant that guarantees that current owner re-gains control at a later time means,
that the current owner temporarily forgoes the UTXOs use as money and thereby allows its temporary use to keep track of something else.
UTXOs with different covenants or without covenant are not fungible.
Why use UTXOs of significant value to track something that is not money? Because the reason the registry is used is to create scarcity and scarcity can be tailored to more or
less severe by requiring more or less satoshis to track something.
The current owner of a regular UTXO will want to be paid for temporarily giving up control, and that payment represents interest. Riskless, since it is certain to re-gain control.
Tamas Blummer

@_date: 2019-07-06 15:34:31
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hi Eric,
If you have to forgo using your money while using a service that encumbers you. You incur opportunity cost proportional to time you use the service and the amount you waived to use elsewhere.
No crypto is needed to understand this.
Not any, but one with significant value, so a service with limited bandwith can prioritize by that.
Tamas Blummer

@_date: 2019-07-07 11:18:04
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hi Eric,
Your cryproeconomic theories may describe correctly Bitcoin as money, but fall short of describing a Bitcoin that would also offer reliable memory for other uses.
In consequence you miss, that:
1. If the reliable memory that enables money would have more uses then even temporary use of the memory would have utility, therefore value. Bitcoin as is, does not have consensus rules to enable reliable alternate uses.
2. Finite supply of coins implies a finite memory capacity of Bitcoin. Alternate use of the memory requires that units at least temporarily become un-fungible, enforced by consensus. Alternate uses would then have to compete for units of memory, which would give rise to a price paid to those enabling alternate use, even if temoprarily.
3. If giving up control temorarily has a positive price (through 2) and return of control is certain (enforced by consenus) then the price paid is riskless interest for those giving up temporary control.
4. If a use requires more units of memory then it imposes higher cost to use and it since memory units are finite it imposes more severe scarcity.
Further certainly subjective remarks:
Although burning and loss is unavoidable and therefore Bitcoin (as is) is unsustainable we should design systems that they sustain it as long as possible (as is). Therefore a requirement to burn for any of unlimited number of uses should be avoided.
We currently perceive borrowed money just as good as (fungible with) any other money. This is a consequence that money actually comes into existence through someone borrowing it. Money on your account is a loan you gave the bank and even paper cash is a loan you gave the central bank.
Bitcoin is different as it just is, it is not borrowed into existence. Therefore it is not fungible with borrowed version of itself. This however does not imply that its borrowed version is worthless as it might be worth something if there is a use for it.
Tamas Blummer

@_date: 2019-07-09 22:32:53
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Good morning ZmnSCPxj,
thank you very much for sharing your BCAN idea and thought process in detail.
I add some thoughs that very likely occured to you, but not formulated explicitelly:
1. The unique feature of such advertisement network is that it has no owner, just like the Bitcoin network.
If it had an owner, that owner could simply bill for use, but would also be forced to restrict access or apply some sort of censorship.
This is why usage costs is imposed through opportunity cost and not billed.
2. Since opportunity cost of one Bitcoin for a short time period is magnitudes less than its face value, one would need significant
Bitcoin amounts to impose meaningful costs so they have the chance to be included into BCANs purposedly limited bandwidth.
Those who would want to place an ad will often not have sufficient amount of Bitcoin holdings which lets them borrow UTXOs.
3. If borrowed Bitcoin is certain to be returned (as in your construction) then this offers riskless interest for HODLer.
4. Bitcoin?s most popular use is storing wealth whereby this use currently completely relies on the assumption that ?the number goes up?.
A service that delivers interest on HODLed coins without exposing the HODLer to credit risk of the borrower is a huge game changer.
5.This scheme allows HODLer a concious decision whom or what project they fund.
For above reasons I think that this is a crucial design pattern to build censorship resistant networks which also give rise to riskless interest on Bitcoin.
My finance examples where abstract and less interesting for this audience but the BCAN should ring the bell for many.
As you said BCAN is possible with current Bitcoin, therefore we should no longer discuss it under the covenant topic.
The idea of debt covenant will likely resurface as soon as this design pattern proves to be useful in practice and one is looking for
a more flexible solution. I am confident we will get there, but not as fast as I initially thought.
Tamas Blummer

@_date: 2019-07-26 09:45:19
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
Hi Justus,
It might be helpful to consult the Rust implementation  of BIP158 here:
It has a cleaner structure than Core or Neutrino, includes server and client side
and passes Core's test vectors.
Tamas Blummer

@_date: 2019-07-26 10:10:15
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
Hi Chris,
yes, fidelity bonds can impose cost to make sybill attacks more expensive therefore less likely.
I prefer the flavor with CHECKSEQUENCEVERIFY which imposes opportunity cost, just as effective
as burning, but is sustainable.
Imposing opportunity costs however requires larger time locked amounts than burning and the
user might not have sufficient funds to do so. This is however not a restriction but an opportunity
that can give rise to an additional market of locking UTXOs in exchange of a payment.
This would give rise to a transparent interest rate market for Bitcoin an additional huge benefit.
Tamas Blummer

@_date: 2019-07-28 16:17:35
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
Hi David,
Aquiring coin age is hard not only for an attacker but for any user that
happened to move his funds lately.
Even if coin age is available, proofs of using it to fund a particular operation
are not sybill resistant. Only a centralized service would know for sure that
proof is only used once and such centralization would defeat the purpose.
In contrast time locking such that it is uniquely linked with the operation
is always possible as funds could also be rented to lock in a decentralized manner.
Tamas Blummer

@_date: 2019-07-28 20:29:34
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
In summary I see three mechansims of making use costly:
1. burn
2. time locked funds, locker will incure opportunity cost
3. proven coin age, holder did incure opportunity cost
I dislike burn as usage of a service is infinite while coin supply is finite.
I prefer time locked funds over coin age as locked funds do not need proof of
unspentness, they can not be spent. Therefore time locked funds can be sufficiently
proven with SPV. The user of the service could post SPV proof with the request.
Tamas Blummer

@_date: 2019-06-08 20:59:09
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] WORKVERIFY: uncensorable contracts hedging biggest 
In an earlier post [1] I suggested an approach to create native Bitcoin contracts that reduce mining's income volatility and received very helpful comments on implementation from Pieter Wuille [2] and Natanael [3]
After processing those comments I instead suggest the following restricted interpretation of nSequence and a new opcode WORKVERIFY that in combination is easier to implement and reason about as it follows the implementation pattern of CHECKSEQUENCEVERIFY[5]
Accumulated work on the blockchain is strictly increasing, therefore transaction eligibility rule with a >= condition on it would need no re-evaluation for descendant blocks, in mempool or at re-org, since additional blocks or re-org can only increase the accumulated work. Accumulated work is just like time, it is actually an alternate measure of time through computation[6], therefore analogous to MTP based restriction implemented with BIP68 [4].
=== (the implementation proposal) ===
(needs soft fork for two reasons, activation logic tbd.)
I. Stricter interpretation of nSequence to optionally refer accumulated work:
Only if bit 31 AND bit 30 is set in nSequence can the transaction be included into any block. This is a restricting a rule of BIP68 [4] that only required bit 31 to be set for unrestricted inclusion into blocks. Otherwise nSequence refers to accumulated work (see encoding later) and it is only viable to include the transaction into a block if the block has >= work accumulated. This would define the meaning of one additional bit in nSequence, but leave all other freedom of later improvement left by BIP68.
II. New WORKVERIFY opcode redefining a NOPx in transaction script as:
Terminate script with false for any reason described in BIP112 or if bit 31 is set but bit 30 is not set and 256 bit unsigned integer on stack is higher than (nSequence &0xffff)>> 6 * 2^((nSequence & 0x3f) + 84)
=== (end proposal) ===
Notes on the work encoding:
Total accumulated work as of now is > 2^90 and if we assume that mining capacity keeps increasing with Moore?s law (double every year) for the next 50 years, then it could sum up to 2^140. We have much less bits available in nSequence therefore we have to encode accumulated work in a floating point number with sufficient precision.
The work accumulated during the current difficulty adjustment cycle is > 2016 * 2^74 which is > 2^84. It is rather unlikely that accumulated work in a difficulty adjustment period drops below 2^80 ever again in future which means we need not be more precise than  2^80/2^90 or 2^-10 to allow for contracts that reference increment until the next adjustment. Therefore a mantissa of 10 bits should be sufficient. Using 6 bits of exponent and an offset of 2^84 we can express the range of [2^84, 2^148) that should be sufficient now and for foreseeable future. Please let me know if the approach is not optimal or future proof in your opinion.
Why, should we build this into Bitcoin ?
The most influential risk factor in miners' investment decision is the anticipated change of difficulty over the time horizon of the mining equipment's expected lifetime. Their investments secure the network. The ability to create contracts that reduce income volatility would lead to additional investment into mining.
A native Bitcoin contract is far superior to alternatives that could be offered on traditional markets as:
a native Bitcoin contract would be:
- uncensorable: It requires only the agreement to terms between those financially involved
- fully collaterized: no counterparty risk which means Miner could buy hedging contracts from any unkown and un-trusted actor that is able to commit collateral
- no oracle is needed
- no disagreement on the settlement
- publicly observable: allow to observe market opinion on future difficulty
- the length of the contract could match miner's investment horizon extending over several difficulty adjustments.
Why not on a side-chain ?
Work is fundamental and intrinsic to the base layer. A contract that reduces earnings volatility helps to attract more capital for mining and therefore increase security on the base layer.
How would this be used?
Miner and Speculator sign a transaction that has an nLockTime of S in the future. This gives both parties the option to alternatively spend committed output in case the other would not follow through and publish committing the collateral until S.
Speculators contribution to collateral is higher than that of the Miner. Miner?s collateral is the premium for the insurance provided by Speculator.
The single output of the transaction has following script:
         CHECKSIGVERIFY
         WORKVERIFY DROP
         CHECKSIGVERIFY
This allows the speculator to take back its collateral plus the option premium after the maturity time point, which would however only be possible if it was not taken earlier by Miner as sufficient work was reached.
The contract in finance terms is an american digital call option with maturity and sufficient work as strike. The Miner profits of the contract if work accumulated is more than contracted in which case he would also have lower mining income, hence the contract would reduce earnings shortcome. The Speculator would earn the option premium if the contracted work was not required until maturity. In this case higher mining income through higher market share compensates Miner for the loss of option premium.  In both cases Miner?s income volatility is reduced. The Speculator may find it attractive to enter the contract if the probability weighted option premium represents an attractive interest on the capital committed.
Contracted work would reflect the consenus of expected difficulty increase over future time horizons. Observing above contracts on the blockchain would allow calculation of market implied forward curve of mining difficulty and its implied volatility which again would help evaluating investment proposals into mining.
An alternate more flexible setup would be a Lightning Network like re-allocation of total collateral. Which would allo parties to mark the option to market (observed work and volatility) as time passes and allow for cooperative unwind.
Tamas Blummer
[1] [2] [3] [4] [5] [6]

@_date: 2019-06-13 10:14:02
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK 
ZmnSCPxj already observed in [1] that these ops would enable introspection of any field of the transactions and make both `OP_CHECKLOCKTIMEVERIFY` and `OP_CHECKSEQUENCEVERIFY` superfluous.
There is much more to this as enumerated in generic terms by Russel O?Connor below and I would like to add a concrete example.
We could implement oracle less difficulty contracts without the need the of a CISC type OP_WORKVERIFY but instead through resurrection/extension of OP_CAT, OP_GREATERTHANOREQUAL and introduction of a new RISC opcode OP_CHECKBLOCKATHEIGHT[3] suggested by Luke Dashjr. Thanks for the pointer to Nathan Cook [4]
Technically we could resurrect and add them without burning more than one OP_NOP by redefining it as a prefix (OP_EXTENSION), such as:
OP_EXTENSION OP_CAT would become a two byte opcode pointing to a resurrected implementation of OP_CAT.
This could be soft forked in.
A concrete oracle less difficulty contract could look like:
It is an european digital call option on target difficulty after maturity and 10 blocks notice period. I gave you reasons while having these would increase bitcoin's security in [2]
       CHECKSIGVERIFY
insurance premium could be collected by the seller of the insurance after maturity + 10 blocks if target difficulty was not reached
miner would get back its insurance premium plus collateral of the seller if target difficulty was not reached at maturity. Miner has 10 blocks time after maturity to claim with:
The stack would be in second case processed as:
1: after pushes
2: after OP_DUP:
3: after push
4: after OP_CHECKBLOCKATHEIGHT OP_VERIFY is successful proving that prevhash is the block at maturity block height - 1
5: after OP_SWAP
6: after OP_CAT
7: after OP_CAT
8: after OP_HASH256
9: after push
10: after OP_GREATERTHANOREQUAL OP_VERIFY proves that contracted target was reached
Tamas Blummer
[1]  [2]  [3]  [4]  [5]

@_date: 2019-06-28 10:27:16
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable riskless or 
I start with a formalisation of loans as common in finance:
A zero bond is a contract between two parties Alice and Bob whereby Alice receives an amount less than P and has to pay back P at a later time point called maturity.
The difference between the amount received and P is the interest implied by the contract. E.g. receiving 1 Bitcoin (

@_date: 2019-06-28 21:21:56
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hi Eric,
Thank you for your questions as they show what concepts need further explanation, so you understand the potential of this proposal and how it is helpful to the ecosystem.
Riskless zero bond is in fact the most basic concept of financial engineering. Yes, there are engineers of finance, those who create and price financial derivatives (e.g. options, swaps) and structure products such as e.g. ABS, CDO etc.
I used to be one of them.
A zero bond formalizes the observation that 1 unit of currency in the future has different value than 1 unit available now. It is called riskless if it is certain to receive the payment in the future.
If we put this difference of vaue in relation to the amount then we get the ?risk freee rate of return?, that you heard of.
E.g if one is willing to exchange 1 BTC unconditionally available now for 1.1 BTC certainly available in a year but not earlier, then the implied ?risk free rate of return? is apparently 10% pa. for Bitcoins.
The transaction I construct in the first example achives exactly this, because:
Bob forgoes his ability to use his unconditionally available coins by giving them to Alice with a covenant that ensures that Bob will receive them back later.
Bob does this because Alice pays for this in advance.
Alice can further transfer the coins encumbered by the covenant, but they will unconditionally return to Bob in the future.
The utility of these encumbered coins is that they prove that the loan is fully covered by reserves.
How valuable this utility is will be decided by the market and that value will be interest received by those who temporarily give up control. I am guess the value will be low but positive.
Lending does not mandate fractional or full reserves. These are choices the market or regulators enforce. Full reserve banking is not a fiction but is how things worked before introduction of gold receipts. A bank could only lend gold coins it possesed. Perils of fractional reserve were felt repeatedly by the Bitcoin ecnomy e.g. in the collaps of MtGox.
The idea to return to full reserve banking is not unique to gold bugs or Bitcoin but recently a popular vote was initiated in Switzerland to force Swiss banks to full reserves with respect to lending. This popular vote achived  24% support [1] which is quite remarkable if considered that the topic is not trivial as also our exchange shows.
I published today a writing in medium, that explains the concept of fractional vs. full reserve banking in conjunction with this proposal. Please read:  I would welcome feedback on the generalized covenant construct or its implementation, as I think it can open up much more uses than the few examples I gave.
Tamas Blummer
[1] Vollgeld Initiative:

@_date: 2019-06-29 07:53:57
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenant to implement side chains 
I introduced you to gerneralized covenants[1] earlier, but in a domain specific context that de-routed us from technical discussion. Let me demonstrate the concept in a more generic use:
A covenant
or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
would put a coin under the alternative control of a Transfer and Exit keys together with the script in control of the current owner.
Additional transaction level validations of transactions spending input with covenants apply as in [1]
Owner of such coins would be able to transfer them to others provided an addtional Transfer signature, in which case the coin remains encumbered with the same covenant.
If Exit and owner signs the covenant is dropped on the output, it becomes a plain Bitcoin again.
The Thransfer and Exit signatures could be threshold signatures of a federation, whereby member decide if the proposed transfer transaction complies with whatever unique rules they impose.
The result is a federated side chain embedded into the Bitcoin block chain.
Bob could purchase some asset guarded by the federation with a transaction:
100.0001 pk(Bob)
0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
99.9 pk(Transfer)
Transfer to Alice with consent of the transfer validators:
0.1 or(and(pk(Transfer), pk(Bob)), and(pk(Exit), pk(Bob)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
100.001 pk(Alice)
0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
100 pk(Bob)
Alice might be approved to exit with the exit signature of the federation:
0.1 or(and(pk(Transfer), pk(Alice)), and(pk(Exit), pk(Alice)) covenant or(and(pk(Transfer), _) covenant transitive, and(pk(Exit),_) covenant drop)
99.9 pk(Transfer)
99.9999 pk(Alice)
Tamas Blummer
[1]

@_date: 2019-06-30 12:56:46
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
Hi Eric,
Coins encumbered with the described covenant represent temporary control of a scarce resource.
Can this obtain value? That depends on the availability of final control and ability to deal with temporary control.
An example where final control is not available are areas and jurisdictions where land can not be bought only long time rents are offered.
People pay high prices there to step in place of the renter in an existing long term rent contract and they figured out the contracts that work under these restrictions.
Bitcoin?s predominant use is already store of value. Many assume not only wealth preservation but that it would allow to purchase of more goods in the future than now.
This leads to unwillingnes to give up final control, which can resolve in two ways:
- Increasing fiat prices for final control. We see this, and is actually further reinforcing unwillingnes to give up final control.
- dealing with temporary control. We do not yet have the technical means of even representing this. Developing them is my goal.
I think you do not show the neccesary respect of the market.
Your rant reminds me of renowed economists who still argue final control Bitcoin can not have value, you do the same proclaiming that temporary control of Bitcoin can not have value.
I say, that temporary control does not have value until means dealing with it are offered, and that is I work on. Thereafter might obtain value if final control is deemed too expensive or not attainable, we shall see.
Tamas Blummer

@_date: 2019-06-30 18:57:06
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenant to implement side chains 
Hello ZmnSCPxj,
Yes, representation of debt is more interesting here as it requires the covenant, wheras this example, as you point out, was less convincing given alternatives.
I created this example to avoid discussion of topics not approriate on this list.
Thank you for the suggestion of unchained execution of transfers with cut-through exit transaction as this made the example much stronger:
The most important question for someone who trusts his coins to some unchained platform is probably the question of how exit is guaranteed if one is unhappy with what one gets.
With the exit covenant exit conditions are set in stone, since validated on-chain. If the exit key is owned by a trusted arbiter other than the federation governing the unchained platform
then one at least have the option to cut losses at some point by presenting the arbiter a chain of valid transactions and asking to sign the exit.
Participants in the unchained platform would also be interested to regularly snapshot the economic effect of offchain transactions with cut-through transactions as such cut-through shortens the chain of transactions
they would need to get on chain if chosing the exit without consent of the federation governing the transfers.
So the convenant needed is: 'covenant or(_ covenant transitive, and(pkExit, _) covenant drop)' which gives unrestricted flexibility to the unchained platform with the exception that it has to maintain the exit option.
Tamas Blummer

@_date: 2019-06-30 19:50:21
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenant to implement side chains 
I made an error proposing the new covenant. It should be unchanged as in the original example:
?covenant or(and(_, pk(Transfer)) covenant transitive, and(pk(Exit), _) covenant drop)?
since the placeholder stays for the control of the rightful owner without transfer signature on or off chain.
The exit could be alternatively automatic allowing to exit a stalling unchained platform:
?covenant or(and(_, pk(Transfer)) covenant transitive, and(delay(100), _) covenant drop)?
There remains the question why the rightful owner is not enforcing the covenant instead of having it enforced by on-chain consensus.
I do not yet have a good answer for that as in contrast to the debt example, here it is aligned with the interest of the current owner to have the covenant.
Tamas Blummer

@_date: 2019-06-30 20:35:33
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
There is a deeper utility of Bitcoin than it can be traded for something else. That utility is to use its unforgeable register.
We have only one kind of units in this register and by having covenants we would create other kinds that are while encumbered not fungible with the common ones.
Units are certainly less desirable if encumbered with a debt covenant. You say no one would assign them any value.
I am not that sure as they still offer the utility of using the unforgeable register, in this case a register of debt covered by reserves.
You also doubt forcing debt to be covered by reserves is a good idea, I got that, but suppose we do not discuss this here.
If there are people who think it is a good idea, then they would find having an unforgeable register of it useful and therefore units needed to maintain that register valuable to some extent.
You are not explaining an existing market but claim that market that is not yet there will follow your arguments.
I meant with control the control of entries in the register which I think is the deeper utility of Bitcoin. Final control is meant to be the opposite of temporary which is the time limited control with some expiry.
Thank you for your thoughts as they help to sharpen my arguments.
Tamas Blummer

@_date: 2019-06-30 21:55:41
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
I guess we agree that some way of keeping track of ownership is prerequisite for something to aquire value.
We likely also agree that the security of that ownership register has great influence to the value.
The question remains if a register as utility in itself gives value to the thing needed to use that register.
I think it does, if people are interested in what it keeps track of, for whatever reason, even for reasons you find bogus.
It was not intentional, but I think I just explained why Ethereum aquired higher market value by being register of ICO tokens.
Now back to the coins encumbered with the debt covenant:
Transactions moving them constitute a register of covered debt and you need them to update that register.
Should some people find such a register useful then those coins needed to update this register will aquire value.
Does not matter if you think the concept of covered debt is just as bogus as ICOs.
Here some good news: If they aquire value then they offer a way to generate income for hodler by temporarily giving up control.
Tamas Blummer

@_date: 2019-06-30 22:26:29
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenants with taproot enable 
prevent credit inflation through fractional reserve
My argument does not need the comparison with ICOs.
They were just an example that people pay for the utility of register even though others think the tokens they keep track of are worthless.
Tamas Blummer

@_date: 2019-07-01 00:25:03
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Generalized covenant to implement side chains 
============================== START ==============================
Any meaningful covenant must be one that is reducing control by the current owner.
I can think of countless predicates reducing control, but try to explore the least invasive first,
and see if they unlock a new use.
Offering alternate control paths is what taproot was designed for, therefore a covenant
that requires that a control path is inherited seems a fit. That is all the
debt covenant needs.
There are other predicates with exciting use, such as one on total work performed by miner
which I tried to explore earlier. Pieter Wuille said it could be a candidate for the annex.
Tamas Blummer

@_date: 2019-03-07 11:57:03
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] BIP - Symbol for satoshi 
It is highly unikely that non-engineers will adopt scientific notation or mili/nano/pico prefixes for money. All common currencies either have no change or one that is 1/100 of the base unit. This is the convention that practically all existing finance software and non-Bitcoin related UI that deals with money assumes.
Ignoring evident cultural preference and all pre-existenting finance related software is blatant Bitcoin engineering blindness.
We already had a BIP for bits, which I support for above reasons. Tamas Blummer

@_date: 2019-05-23 19:42:35
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets) 
Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
I think we could do much better than them natively within Bitcoin.
A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into. The output script may then decide comparing that value with a strike which key can spend it. The input of the transaction would be a multi-sig escrow of those who entered the bet. The winner would broadcast. Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.
I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin?s aim not to introduce 3rd party to do so.
Do you see a fault in this proposal or want to contribute?
Tamas Blummer

@_date: 2019-05-23 21:10:53
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets) 
The parameter used is property of the block just like the block height is a property and is already evaluated in scripts,
so no new kind of dependency or encapsulation break.
The transaction itself was not invalid in a re-org but evtl. others spending it if the difficulty on that fork is different,
this is however intended as then on that fork the other was the winner.
Tamas Blummer

@_date: 2019-05-23 21:18:06
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets) 
That opcode would not help as it fetches block hash and not the content of the header.

@_date: 2019-05-23 21:45:58
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets) 
I see. The uncompressing needs to be done either to compare. How are chances for that BIP?
This BIP would be explicitly offering risk managment of miners biggest risk.
Doing so without relying on external markets or oracle, self cointained would be an impressive and adequate feature.
Tamas Blummer

@_date: 2019-05-23 21:54:43
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets) 
Block hash can suggest much higher difficulty than what is in effect, so OP_CHECKBLOCKATHEIGHT would not work to decide if difficulty is above the level of the bet.

@_date: 2019-05-23 22:26:49
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets) 
Thanks for these suggestions I will follow up while preparing the BIP.
This is the best reception I could have hoped for :)

@_date: 2019-05-24 18:23:38
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets) 
yes, log2work is already computed and would be a strictly increasing value, like time. Thank you for this suggestion. I think attempting an implementation will give further clues it this more suitable to express the same.
Tamas Blummer

@_date: 2019-09-14 15:21:28
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Introcing a side memory network to bitcoin for ads 
I introduced you to the pattern of a side memory to bitcoin in [1] and
promised an implementation of it.
Here you are.
defiads is a side memory network to bitcoin, implemented in Rust, built
on top of rust-bitcoin, murmel, hammersbald, rust-bitcoinconsenus,
rust-wallet, all Rust open source free to grab at
defiads builds a peer-to-peer network to distribute textual ads, as
first suggested by ZmnSCPxj[4]. I hope that it will serve decentralized finance applications with an infrastructure to distribute
ads, order books, coinjoin proposals etc.
Every defiads node maintains a copy of a network-wide shared 1GB memory
pool of current ads.
An ad is replicated to other nodes as long as there is some bitcoin
locked to it on the bitcoin network. Locking means someone transferred
some sats to an address that is associated with the ad using the
pay-to-contract protocol[2]. The address does not release the bitcoins
until a predefined time span that is the duration of the advertizement,
this is accomplished with OP_CSV. The ad will be evicted from the pool
as soon as the coins locked to it are spendable again.
defiads  ranks advertizements by the ratio of used space divided by
bitcoins locked and will only replicate the top 1GB of this ranked list.
You may read the ads by starting a defiads process of your own and
the query the content through its JSON-RPC API.
You may place ads by performing the following steps, with its JSON-RPC API
1. deposit some bitcoins into your defiads node's wallet
2. prepare an ad, providing its category, abstract and content
3. fund the ad by locking some of the bitcoins to it for a limited term
of the advertizement
4. you may withdraw your coins from the defiads node's wallet after the
advertizement expires
defiads handles the association with ads, locking and unlocking coins.
Implementation notes
defiads connects to both the bitcoin and its own peer-to-peer network.
You do not need to run a bitcoin node as defiads? only needs a small
fraction of the information on the bictoin blockchain and retrieves that
on its own, as an SPV node. The defiads node's wallet is compatibe with that of TREZOR, Ledger,
Greenwallet and many other wallets that support BIP38, BIP44, BIP48,
BIP84 key generation and use standards.
defiads uses Invertible Bloom Lookup Tables[3] to synchronize the ads
pool with its peers.
It seems to work, but you should not yet use with real bitcoins,
therefore by default it connects the bitcoin's test network.
There is no discovery for the network yet, so you will have to know some
peer in the network to see other than your own ads. Write me a direct
email if you'd like to connect to my node.
Future developent
Should the use become popular then 1GB pool become tight, then people
will have to compete for its use. Some might not have enough bitcoin's
to lock and might therefore pay others to lock theirs to fund an
advertizement. defiads network could match both sides and thereby give
rise to bitcoin's first truly risk less interest rate market.
defiads is currently downloading, but not storing, the blocks after its birth date. This will no longer be needed once
BIP158 filters are served and committed by Bitcoin Core.
I hope that someone builds a nice UI on top of the JSON RPC as that is
not my area of expertise.
Tamas Blummer
[1] [2] [3] [4]

@_date: 2019-09-21 23:16:25
@_author: Tamas Blummer 
@_subject: [bitcoin-dev] Block Batch Filters for Light Clients 
Hi Aleksey,
Yes, BIP158 uses the block hash to seed the hash function, which makes distinct block filters non-aggregatable for common values. Aggregate fiters on ranges of blocks would have to use some other seed and then achive significant savings using the same design.
I think that the most likely use of filters is to decide if a newly announced block should be downloaded and not scanning over the entire chain, where aggregate filters would help. I also suspect that whole chain scans would be better served with plain sequential reads in map-reduce style.
Typical clients do not care of filters for blocks before the birth date of their wallet?s keys, so they skip over the majority of history which is a bigger saving than any aggregate filter.
I wish we get a filter committed as commitment would unlock more utility than any marginal savings through
more elaborate design.
Tamas Blummer
