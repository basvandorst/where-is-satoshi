
@_date: 2015-02-19 11:33:11
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] What's what with addr relaying? 
Hi, plugging away at my C# Bitcoin node "Lego.NET" Thashiznets/Lego.NET now I am currently working on addr relaying. I am as we speak wiring up my DB in Azure, and ready to start plopping net_addrs in my DB, all good however I'm reading two different specification docs that seem to be wildly varying. I mean the first one here Developer Reference - Bitcoin?didn't mention that version message now has the 4 byte checksum and no?time in the net_addrs?and I was getting reject malformed?messages until I found the other document which informed me we now use the 4 byte checksum in version and no time in the net-addrs in version message. So?I solved that and here is the other doco. I have found other variances like one document said that the heartbeat AND disconnect were 30 minutes, but then in the other document I read that Heartbeat is 30 minutes and disconnect is 90 minutes which seems far more sensible so I went with that and modified my code. Is there any other variations between these two spec docos?that perhaps some of you devs know about that I need to look out for! Thanks! Shizzle.
 ?
 ?
 ? ?

@_date: 2015-02-19 11:37:17
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] What's what with addr relaying? 
Oh and I realised I stuffed up the subject and it talks about the addr relay but I actually answered my own question on the addr relaying, I had just miss interpreted one document I thought it was talking about subtracting 2 hours before relaying but I see we subtract 2 hours on receipt not relay?because the if it hadn't been seen for 60 minutes previously it now becomes 3 hours and we use but don't relay makes sense.   Hi, plugging away at my C# Bitcoin node "Lego.NET" Thashiznets/Lego.NET now I am currently working on addr relaying. I am as we speak wiring up my DB in Azure, and ready to start plopping net_addrs in my DB, all good however I'm reading two different specification docs that seem to be wildly varying. I mean the first one here Developer Reference - Bitcoin?didn't mention that version message now has the 4 byte checksum and no?time in the net_addrs?and I was getting reject malformed?messages until I found the other document which informed me we now use the 4 byte checksum in version and no time in the net-addrs in version message. So?I solved that and here is the other doco. I have found other variances like one document said that the heartbeat AND disconnect were 30 minutes, but then in the other document I read that Heartbeat is 30 minutes and disconnect is 90 minutes which seems far more sensible so I went with that and modified my code. Is there any other variations between these two spec docos?that perhaps some of you devs know about that I need to look out for! Thanks! Shizzle.
 ?
 ?
 ? ?

@_date: 2015-03-05 01:40:57
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Useless Address attack? 
Hi, so just a thought as my node relays addresses etc. If I wanted to really slow down communication over the P2P network, what's stopping me from popping up a heap of dummy nodes that do nothing more than exchange version and relay addresses, except I send addr messages with all 1000 addresses pointing to my useless nodes that never send invs or respond to getdata etc so clients connect to my dumb nodes instead of legit ones. I'm thinking that if I fill up their address pool with enough addresses to dumb nodes and keep them really fresh time wise, it could have a bit of an impact especially if all 8 outbound connections are used up by my dumb nodes right?
I don't want to do this obviously, I'm just thinking about it as I'm building my node, what is there to stop this happening?

@_date: 2015-03-05 03:18:54
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Useless Address attack? 
Thanks Kevin, I now need to research this and include such protections in my node.?
Also (I am fuzzy on the details for this), Bitcoind will detect when a node is misbehaving and (I believe) it will blacklist misbehaving nodes for a period of time so it doesn't continually keep trying to connect to tarpit nodes, for example.
Bitcoind protects against this by storing the addresses it has learned about in buckets. The bucket an address is stored in is chosen based on the IP of the peer that advertised the addr message, and the address in the addr message itself. The idea is that the bucketing is done in a randomized way so that no attacker should be able to fill your database with his or her own nodes.
 Hi, so just a thought as my node relays addresses etc. If I wanted to really slow down communication over the P2P network, what's stopping me from popping up a heap of dummy nodes that do nothing more than exchange version and relay addresses, except I send addr messages with all 1000 addresses pointing to my useless nodes that never send invs or respond to getdata etc so clients connect to my dumb nodes instead of legit ones. I'm thinking that if I fill up their address pool with enough addresses to dumb nodes and keep them really fresh time wise, it could have a bit of an impact especially if all 8 outbound connections are used up by my dumb nodes right?
I don't want to do this obviously, I'm just thinking about it as I'm building my node, what is there to stop this happening?

@_date: 2015-03-12 02:16:38
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
That's disappointing the Electrum 2.0 doesn't use BIP39.
Changing the wordlist in the future has ZERO effect on derived seed, whatever mnemonic you provide will always generate the same seed, BIP39 is not mapping the words back to numbers etc to derive seed.
Version is something that can be dealt with after the fact, hopefully standardised (curious why didn't you work with the BIP39 to insert version instead of do something different to BIP39?)
So most of what you are suggesting as problems are not.
As for the common words between languages, I have discussed this with the provider of the Chinese wordlists as they shared some words between simplified and traditional, but I found it easy to look for a word in the mnemonic that is unique to that language/wordlist and so straight away you can determine the language, remembering you get minimum 12 goes at doing that :)
Also then I asked myself, do we really care about detecting the language? Probably not because we don't need to use the wordlist ever again after creation, we literally accept the mnemonic, normalise it then hash it into a seed. From what I'm reading, Electrum 2.0 really should have BIP39, it would take almost no effort to put it in and I think you should do that :) I don't have any interest in BIP39 other than it being a standard. I think TREZOR may have an interest in it?
Thomas V:
"Thanks Mike, and sorry to answer a bit late; it has been a busy couple
of weeks.
You are correct, a BIP39 seed phrase will not work in Electrum, and vice
versa. It is indeed unfortunate. However, I believe BIP39 should not be
followed, because it reproduces two mistakes I did when I designed the
older Electrum seed system. Let me explain.
The first problem I have with BIP39 is that the seed phrase does not
include a version number.
Wallet development is still in an exploratory phase, and we should
expect even more innovation in this domain. In this context, it is
unwise to make decisions that prevent future innovation.
However, when we give a seed phrase to users, we have a moral obligation
to keep supporting this seed phrase in future versions. We cannot simply
announce to Electrum users that their old seed phrase is not supported
anymore, because we created a new version of the software that uses a
different derivation. This could lead to financial losses for users who
are unaware of these technicalities. Well, at least, that is how I feel
about it.
BIP39 and Electrum v2 have a very different ways of handling future
innovation. Electrum v2 seed phrases include an explicit version number,
that indicates how the wallet addresses should be derived. In contrast,
BIP39 seed phrases do not include a version number at all. BIP39 is
meant to be combined with BIP43, which stipulates that the wallet
structure should depend on the BIP32 derivation path used for the wallet
(although BIP43 is not followed by all BIP39 compatible wallets). Thus,
innovation in BIP43 is allowed only within the framework of BIP32. In
addition, having to explore the branches of the BIP32 tree in order to
determine the type of wallet attached to a seed might be somewhat
The second problem I see with BIP39 is that it requires a fixed
wordlist. Of course, this forbids innovation in the wordlist itself, but
that's not the main problem. When you write a new standard, it is
important to keep this standard minimal, given the goal you want to
achieve. I believe BIP39 could (and should) have been written without
including the wordlist in the standard.
There are two ways to derive a master key from a mnemonic phrase:
?1. A bidirectional mapping between words and numbers, as in old
Electrum versions. Pros: bidirectional means that you can do Shamir
secret sharing of your seed. Cons: It requires a fixed wordlist.
?2. Use a hash of the seed phrase (pbkdf). Pros: a fixed wordlist is not
required. Cons: the mapping isn't bidirectional.
Electrum v1 uses (1). Electrum v2 uses (2).
Early versions of BIP39 used (1), and later they switched to (2).
However, BIP39 uses (2) only in order to derive the wallet keys, not for
its checksum. The BIP39 checksum uses (1), and it does requires a fixed
wordlist. This is just plainly inconsistent. As a result, you have
neither wordlist flexibility, nor Shamir secret sharing.
Having a fixed wordlist is very unfortunate. First, it means that BIP39
will probably never leave the 'draft' stage, until all languages of the
world have been added. Second, once you add a wordlist for a new
language, you cannot change it anymore, because it will break existing
seed phrases; therefore you have to be extremely careful in the way you
design these wordlists. Third, languages often have words in common.
When you add a new language to the list, you should not use words
already used by existing wordlists, in order to ensure that the language
can be detected. It leads to a first come first served situation, that
might not be sustainable in the future.
In order to support the old Electrum v1 seeds, all future versions of
Electrum will have to include the old wordlist. In addition, when
generating new seed phrases, Electrum now has to avoid collisions with
old seed phrases, because the old ones did not have a version number.
This is painful enough, I will not repeat the same errors twice.
Electrum v2 derives both its private keys and its checksum/version
number using a hash of the seed phrase. This means that wordlists can be
added and modified in the future, without breaking existing seed
phrases. It also means that it will be very easy for other wallets to
support Electrum seedphrases: it requires about 20 lines of code, and no
wordlist is required."
Le 02/03/2015 16:37, Mike Hearn a ?crit :

@_date: 2015-03-12 02:38:29
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
Right you are!
I saw Thomas's email about Electrum 2.0 not supporting BIP39.
It seems he had the idea that the wordlist was a strict requirement yet it is not, it is unfortunate that Electrum did not go the route of BIP39. The wordlist is irrelevant and merely used to help build mnemonics.
Also as I've shown, you can work a version into it, I was going to actually propose it to the BIP39 authors but didn't think it was an issue.
I think BIP39 is fantastic.
Unfortunately there's more incompatibility than just the date issue:
* seed: some follow BIP39, and some roll their own
* HD structure: some follow BIP44, some BIP32 derivation, and some roll
their own
So actually very few wallets are seed-compatible, even ignoring the date
That's a reasonable solution.

@_date: 2015-03-12 03:54:18
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Testnet3 
Hi, so I have my .NET node communicating on the P2P network just fine, so I figured as I'll now start looking at making and validating transactions etc I should probably migrate to test net. Now I see that we are up to the third generation testnet testnet3, and I am sending my messages now using packet magic 0x0b110907 and I'm using Wireshark and I can confirm that my messages are going out with that packet magic.
Now what is interesting is that when I try connect to a test node obtained from DNS seed testnet-seed.bitcoin.petertodd.org, I send it a version message with the testnet3 packet magic, yet I get no verack or version in response???? In fact, the only thing I get back is a ping and then the connection is severed by the?remote node.
What is going on? Also, it works fine with the?mainnet packet magic value of 0x0f9beb4d9 and I am debuging my code and ensuring it is looking for the testnet3 packet magic, but I am not getting a response from the node?

@_date: 2015-03-12 04:21:59
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
?"I agree that it's true that a static wordlist is
 required once people have started using BIP39 for anything real and
 changing the word lists will invalidate any existing mnemonics"
^ This is incorrect I think Neill, the reason is that the only thing that happens when you change the wordlist is that entropy points to different words. But remember, entropy is disposed. Yes in my code I allow for the keeping of entropy etc, it also lets me "hot swap" between different language wordlists etc but in real world implementation the entropy is forgotten and not stored. So changing the wordlist merely allows new mnemonic phrases to be generated but it has a nil impact on previously generated mnemonics UNLESS you are trying to rebuild from entropy but you wouldn't do that. You would be rebuilding from the Mnemonic in real world scenario. You really can have a word list of total rubbish in BIP39 as long as it is 2048 words long that is all! If you input the mnemonic made out of rubbish words so for e.g "uyuy jkjasd sdsd sdsdd yuuyu sdsds iooioi sdasds uyuyuy sdsdsd tyyty rwetrtr" and no matter what BIP39 implementation you put it in, it will always generate the same seed bytes thus allowing for complete and universal seed derivation without any reliance on word list. The word list is merely to generate a mnemonic, after that it has no role in seed generation so you can change it at anytime and it will never effect future mnemonics.
Agreed, but I don't know the full background on this.
That's true for generating new mnemonics (i.e. same entropy can
generate any combinations of words), but not for converting a mnemonic
to a seed (i.e. a specific wordlist/passphrase should always generate
the same seed).? I agree that it's true that a static wordlist is
required once people have started using BIP39 for anything real and
changing the word lists will invalidate any existing mnemonics (unless
your 'new' wordlist simply substitutes one word for another and the
index mapping is made public ... which means it's not really an
arbitrary word list).
I don't see how this can work given the BIP39 spec as it is today
(there's simply no room for a version in the bits).? I do think
versioning would be nice, but as of now, I'm in the camp that thinks
complete wallet interoperability is a bit of a myth -- so long as you
can fundamentally move into/out of wallets at will.

@_date: 2015-03-12 05:12:47
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
Yes I agree with this sentiment.
As for the version, don't forget we can kinda "brute force" our way to determine a version, because lets say there is 10 versions, we can generate the seed for all 10 versions and then check to see which seed was in use (has transacted) and then use that seed. If no transactions are found, we could restore the wallet with the seed of the latest and greatest version. Not really any need to store the version, sure it may save some time but as Marek rightly says, this is for restoration of a wallet from cold storage not an everyday thing so the extra time to brute force the version etc is acceptable as a trade off for not forcing the remembering of a version.
BIP39 is beautiful.
   - Electrum v2 with a version number but no date
   - myTREZOR with no version and no date and BIP44 key derivation. Some seeds I believe are now being generated with 24 words instead of 12.
   - MultiBit HD with no version and a date in a custom form that creates non-date-like codes you are expected to write down. I think BIP32 and BIP44 are both supported (sorta).
   - GreenAddress with no version, no date and BIP32
   - Other bitcoinj based wallets, with no version and a date written down in normal human form, BIP32 only.
To my knowledge, myTREZOR, Multibit HD and GreenAddress uses BIP39, just different scheme for key derivation (myTREZOR uses full BIP44, Multibit HD uses BIP44 with first account only and GreenAddress uses another scheme because it's multisig only wallet).
I disagree with the need of some version "magic flags" or creation date stored in the mnemnonic, for those reasons:
a) If we fail in the way how mnemonic algo is defined, then some magic, extra version flag won't save our asses, because we'll fail in meaning of its meaning. Then it will be completely useless, as implementations cannot rely on it. I know Thomas was sound proponent of this solution, but he was unable to give any reasonable rules about who/how define meaning of version flag.
b) "Creation date" is just a short-term hack. Considering that mnemonic words are kind of cold storage (longterm storage), it *really* does not make much difference in 2020, if your wallet has been created in 02/2014 or 10/2016. If there's performance issue with scanning of the blockchain, creation date don't save our asses. We need to find another solution, and as a bonus, we don't need users to know some weird numbers on top of mnemonic itself.
Exactly! After some community feedback, we changed BIP39 algo to be one-way only, which means you can use *any* wordlist to create the mnemonic, and any other implementation can derive BIP32 root node even without knowing that particular wordlist. Namely this has been changed because of constructive criticism of ThomasV, and from discussion on the mailing list I had a feeling that we've found a consensus. I was *very* surprised that Electrum 2.0 started to use yet another algo "just because".
Shortly said, I think BIP39 does perfect job and there's no need to use anything else.

@_date: 2015-03-12 05:58:12
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
? Why on earth would you want to derive the mnemonic from the wallet seed? Ever?
Remembering that as an attacker doesn't actually have to do any key stretching, they can just keep trying (what is it 64 bytes from memory?) at a time without any PBKDF2 to attack a seed, it seems that the PBKDF2 is just to slow down anyone attempting to attack through an interface such as a web service or to a TREZOR or whatever, in a real world attack you would not even be performing PBKDF2 you would just brute force the raw bytes and?force them into the BIP32 wallet?as there is no Authentication scheme that hashes and compares against the result. It purely limits abuse through an online wallet provider or something like that by slowing down seed generation attempts THROUGH that API, it doesn't really add any security to the seed in a real world brute force attack! So yea I think the 2048 iteration count is sufficient for it's purpose because even if it only forces an extra 1ms per seed generation through the API, it is still slower than just brute forcing the 64 bytes straight up, and so they would have no reason to abuse your API that is all :)
"meh... the fact that you can't derive the seed phrase from the wallet seed, and that the password key stretching is so weak as to be ineffectual security theater bugs me. Feels like a pretty big compromise to work on current generation low power embedded devices when the next generation will be more than capable. But I understand the motivation for the compromise.
Aaron Voisine
co-founder and CEO

@_date: 2015-03-12 06:36:02
@_author: Thy Shizzle 
@_subject: [Bitcoin-development] Testnet3 
Strangely enough, it has started to work properly and I didn't even touch my code just had it sitting there in the loop/ping circuit it was performing and capturing with wireshark.....that is quite odd!
"Hi, so I have my .NET node communicating on the P2P network just fine, so I figured as I'll now start looking at making and validating transactions etc I should probably migrate to test net. Now I see that we are up to the third generation testnet testnet3, and I am sending my messages now using packet magic 0x0b110907 and I'm using Wireshark and I can confirm that my messages are going out with that packet magic.
Now what is interesting is that when I try connect to a test node obtained from DNS seed testnet-seed.bitcoin.petertodd.org, I send it a version message with the testnet3 packet magic, yet I get no verack or version in response???? In fact, the only thing I get back is a ping and then the connection is severed by the?remote node.
What is going on? Also, it works fine with the?mainnet packet magic value of 0x0f9beb4d9 and I am debuging my code and ensuring it is looking for the testnet3 packet magic, but I am not getting a response from the node?"
