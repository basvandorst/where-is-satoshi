
@_date: 2014-10-04 02:44:30
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] bitcoinj 0.12 
Congrats, and thanks for your hard work.
I hate to reply to a release that includes a huge number of new features
with yet another feature request, so -- with apologies -- any plans for
bitcoinj to support stealth address sending and/or receiving?
Kristov Atlas

@_date: 2015-08-30 15:45:07
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] Open Bitcoin Privacy Protect Privacy 
Hi Wei,
As you know, I'm not a developer of Bitcoin-Qt, but we'll need to make our
best guesses for these answers if the developers won't reply. I'm going to
post my best guesses here so that people reading the list have a short
window of opportunity to correct me if they wish.
On Fri, Aug 7, 2015 at 2:46 PM, Wei via bitcoin-dev <
No, Bitcoin-Qt does not try to make non-mixing transactions look like
mixing transactions.
Not yet BIP 69. These notes suggest that outputs are randomized:
4.      Does your application fully implement BIP 62?
Here's a detailed answer on stack exchange:
By item, my extremely brief interpretation:
Non-DER encoded ECDSA signatures: BIP66 soft fork has happened, so this is
presumed to be implemented
Non-push operations in scriptSig: Implemented
Push operations in scriptSig of non-standard size type: Implemented in 0.9.0
Zero-padded number pushes: Implemented in 0.10.0 (current available version
is 0.11.0)
Inherent ECDSA signature malleability: ...implemented?
Superfluous scriptSig operations: implemented 0.6.0
Inputs ignored by scripts: Only partly addressed by 0.10.0.  It appears
that the rest would require changes to consensus rules, so Bitcoin-Qt is as
compliant as it can be.
Sighash flags based masking and New signatures by the sender: Can't be
implemented without changes to consensus rules.
I would summarize this as a "yes."
It doesn't. There's an issue for CoinJoin here:
No donation feature last time I checked.
No, it just downloads the whole blockchain and performs local queries.
100%, unless a user bootstraps downloading the blockchain. Bootstrapping
will potentially limit the user's anonymity set to other people who have
downloaded that bootstrap.dat file.
No. Just download blocks and processes that information locally.
If Tor is set up as a SOCKS proxy, you can configure Bitcoin-QT download
the blockchain and broadcast txs through a single Tor circuit. This can be
configured once before opening Bitcoin-Qt.
8.      Does the applications route outgoing transactions independently
No, you can only configure a single proxy.
No built-in support for multiple identities. You can hotswap wallet files
to crudely simulate this. You'd have to manually change the Tor connection
outside of Bitcoin-Qt to create the effect of making the network
connections independent.
Blocks are downloaded and tx broadcasts received/relayed rather than
querying the utxo set for a particular address. When swapping between
wallet files, some information may be leaked e.g. the client may be at the
same block height in terms of what it has downloaded from the p2p network,
which may leak to global passive adversaries/AS's or sybil attackers the
fact that a single client was used for multiple wallets.
Transactions from multiple identities would not be routed at the same time.
I'm not clear what happens if you have a single wallet (identity) open and
then open a new wallet (identity) without closing Bitcoin-Qt -- some of the
same routing paths may still be used such that an attacker might observe
transactions broadast signed by private keys from multiple wallets
(identities) and observe that they appear to come from the same wallet
client. OBPP should assume the worst unless prevented contrary evidence.
Identity is primarily tied to a wallet.dat file. Deleting it will remove
most of the evidence that the wallet was installed on that device, but
there may be some extra information in ancillary files that should also be
deleted.  This is an OS-level function, as there is no operation built into
the client to delete a wallet file (identity).
No. Backups are local, and no email or SMS is linked. No web queries
related to backup.
Yes, some connections to known p2p full nodes to bootstrap the connection
to the Bitcoin p2p network. This is configurable, but there are defaults.
An ISP is likely to be able to identify a customer as running the
Bitcoin-Qt client in particular on this basis.
BIP12 specifies format for user agents:
It appears that the Bitcoin-QT leaks specific information about its client
version through User Agent. This file defines the current client version:
Various other files seem to use this to build up the UA string, which is
transmitted to other peers.
Probably depends on the platform. Last time I checked, I think Bitcoin-Qt
leaves behind a .bitcoin directory on most platforms even after you run an
uninstall script.
You can encrypt the wallet file with a password. The wallet is "locked"
until the password is entered, preventing decryption of the private keys.
No -- any wallet.dat file can be opened and the public keys inspected
without the password.
No -- any wallet.dat file can be opened and the metadata inspected without
the password.
A single password for the wallet file.
No custodianship.
No obvious telemetry data being sent.
Yes, I think that's the point of the gitian stuff.

@_date: 2015-01-20 13:52:14
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Request for Comment: Bitcoin Wallet Privacy 
The Open Bitcoin Privacy Project is seeking public comment on our ratings
criteria for Bitcoin wallet privacy. Please provide your feedback within
the next week through Jan 23, 2015 to ensure that it will be considered for
version 1.0 of the document.
In conjunction with a scoring matrix that will determine the weight of each
sub-category, this criteria will be used to evaluate and score a variety of
Bitcoin wallets, which will be published on our website at
Feedback through this mailing list is, of course, welcome; if you have a
GitHub account, this is the preferred medium for proposing changes to the
The current version of the criteria was authored by myself, as well as
other OBPP members including Justus Ranvier (Monetas), Chris Pacia (Bitcoin
Authenticator), and Samuel Patterson (Open Bazaar).
Thank you in advance for your feedback,
Kristov Atlas
kristovatlas at gmail.com
author at anonymousbitcoinbook.com

@_date: 2015-07-01 13:07:23
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] RFC: HD Bitmessage address derivation based on 
Hi Justus,
What are the potential applications for this BIP?
On Jun 30, 2015 1:53 PM, "Justus Ranvier"

@_date: 2015-06-04 18:32:50
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Tough questions for Peter Todd, 
Viacoin}
Why would Peter be accountable to you in any shape or form? What contact
did he sign onto with you?

@_date: 2015-06-05 20:12:08
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Lexicographical Indexing of Transaction 
Hello all,
I have written a draft of a BIP to standardize the sorting of tx inputs and
outputs for privacy and security reasons. A few colleagues have reviewed
this and provided feedback privately, but now it's ready for feedback from
a wider audience.
If there is positive sentiment about the proposal after feedback is
integrated, I aim for a bip number to be assigned and have it accepted into
For your convenience, here's the abstract:
"Currently there is no standard for bitcoin wallet clients when ordering
transaction inputs and outputs. As a result, wallet clients often have a
discernible blockchain fingerprint, and can leak private information about
their users. By contrast, a standard for non-deterministic sorting could be
difficult to audit. This document proposes deterministic lexicographical
sorting, using hashes of previous transactions and output indices to sort
transaction inputs, as well as value and locking scripts to sort
transaction outputs."
Kristov Atlas
Open Bitcoin Privacy Project Contributor, Blockchain.info Security
Engineer, etc.
Twitter: Blog: kristovatlas.com

@_date: 2015-06-06 02:24:47
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Lexicographical Indexing of Transaction 
Hey Stephen,
Thanks for your feedback
On Fri, Jun 5, 2015 at 11:20 PM, Stephen I considered defining the comparison of txids in terms of integers;
however, I am concerned that this definition may be ambiguous when applied
to a variety of languages and platforms without a similar amount of
explanation as currently exists. For example, if a web wallet uses an API
to receive transaction information, this is traditionally expressed in
terms tx id strings rather than 256-bit integers. My intent is that wallets
can implement the algorithm however they wish, but should ensure that their
output is compliant with the BIP definition. IMHO the algorithm stated in
the BIP should target test cases rather than implementation, and should
leave as little room for ambiguity as possible.

@_date: 2015-06-06 20:06:56
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Lexicographical Indexing of Transaction 
I've updated the draft BIP in two ways:
-Making it clear that sorting is algorithmically agnostic, but should
conform to the output of the example algorithms written in python
-The BIP now handles schemes that create an input/output dependency, such
as SIGHASH_SINGLE:
Handling Input/Output Dependencies
Some uncommon forms of transactions create an ordering dependency between
inputs and outputs of a transaction. Wallets forming these transactions
should first sort inputs according to the methodology outlined in section
?Transaction Inputs? of this BIP. Then, they should fix the output indices
that depend on the input order, and sort the remaining outputs around them.
If there are no outputs that do not depend on input order, then all outputs
will simply be ordered based on the expected scheme. The following are the
known cases of input/output dependency that must be handled specially:
* SIGHASH_SINGLE hash type. [5] Clients seeking to verify LI01 compliance
for a transaction must inspect the last byte of the scriptSig of each input
to determine the signature hash type. In the case of SIGHASH_SINGLE (0x03)
for input ?n?, the verifier should expect that output ?n? will be fixed
when considering output ordering.
I'm satisfied with this adjustment, as it is unlikely that any software
that wants to verify compliance with the BIP will not have access to the
scriptSig of each input.
On Sat, Jun 6, 2015 at 2:24 AM, Kristov Atlas

@_date: 2015-06-08 18:53:54
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Lexicographical Indexing of Transaction 
Hey Peter, thanks for your experienced feedback.
That makes sense. I updated the language as follows -- your thoughts? Keep
in mind this BIP is informational, and so people are free to ignore it.
"Applicability: This BIP applies to all transactions of signature hash type
SIGHASH_ALL. Additionally,  software compliant with this BIP that allows
later parties to update the transaction (e.g. using signature hash types
SIGHASH_NONE or a variant of SIGHASH_ANYONECANPAY) should emit
lexicographically sorted inputs and outputs, although they may later be
modified. Transactions that have index dependencies between transactions or
within the same transaction are covered under the section of this BIP
entitled ?Handling Input/Output Dependencies.?"
Thanks for the heads-up; removed.
I'm not a frequent C programmer, so I'd prefer to let someone else take
care of it, as a frequent committer of code would do a faster and more
stylistically consistent job of it. If no one else will, however, I will.

@_date: 2015-06-10 19:36:22
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Lexicographical Indexing of Transaction 
Thanks for the feedback. I think I have reflected all of your requested
changes in the latest version, in the BIP and sample code:

@_date: 2015-06-12 17:36:56
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Lexicographical Indexing of Transaction 
Since everyone's busy, I went ahead and made a pull request to add this as
an informational BIP 79 to the bips directory.

@_date: 2015-06-14 12:29:37
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] Lexicographical Indexing of Transaction 
Update: BIP 79 has been implemented in the latest release of Electrum,

@_date: 2015-06-15 00:01:36
@_author: Kristov Atlas 
@_subject: [Bitcoin-development] [RFC] Canonical input and output ordering 
I'm not clear on why this is a problem, so long as the canonical ordering
BIP is *optional*. Unless there is a specific plan to soft fork a change
that would break the BIP and it is fairly imminent, I see this only as a
reason not to integrate it into isStandard().
Maybe they shouldn't be doing that. :-P
In my reading of various wallet client sources, it is common that wallet
clients will use cryptographically weak sources of randomness to sort
outputs -- that is, the ones that actually bother to randomly sort. I can
hunt down some examples if this would substantially contribute to the
As an alternative to this proposal the ordering can be privately
This sounds similar to an idea that Sergio pitched to me privately, which
was for wallets to have a private sorting key that they can use to sort
inputs and outputs. However, I suspect that adding yet another key which
will necessarily require special key rotation rules and maybe special
backup procedures will mean that this standard will not be widely adopted
any time soon. Ideally, I'd like to see someone write a different BIP with
the sorting key idea and let them compete in the wallet client market
rather than trying to anticipate what is best for all clients and
distilling two good ideas into one artificially.

@_date: 2015-06-24 18:09:32
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] [Bitcoin-development] [RFC] Canonical input and 
Following up on this topic...
gmaxwell has reserved BIP 69 for my proposal.
It has been implemented by Electrum in v2.3.2:
Rusty has kindly tweaked his original canonical ordering proposal
implementation for Bitcoin Core's wallet client to fit my proposal:
 (needs testing)
Outstanding objections appear to me to boil down to two points:
1) Some transactions cannot comply with this BIP because there are input
and/or put index dependencies.
My response: No big deal, it's informational. They simply won't be
compliant with the BIP, and that's fine with me.
2) If we set a standard now for transactions that is not apparently random
ordering from the perspective of passive blockchain observers, transactions
that can't comply with this BIP will stand out. Also, if we change our
collective minds in the future about how ordering should be handled, those
future transactions would stand out. Therefore, the "safe" course of action
is to come up with another scheme that appears to be random ordering from
the perspective of a passive blockchain observer.
My response: Apparently-random but owner-verifiable ordering is doable.
Discussion of this has revolved around what I have called a "sorting key"

@_date: 2015-10-22 17:05:39
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] [Bitcoin-development] Reusable payment codes 
The consequence of previous ECDH address proposals "not designing around
current software" is a sustained ~70% of transactions reusing addresses, as
you saw in my Reddit post recently.
If you have a fear that an inferior proposal will gain popularity, you can
always propose a superior one. If it's *actually* superior, it will win out.
On Thu, Oct 22, 2015 at 4:43 PM, Luke Dashjr via bitcoin-dev <

@_date: 2015-09-01 11:50:35
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] push tx fuzzing 
I am interested in finding or writing a fuzzer for push tx APIs. I did not
find one after a brief search. Has anyone found otherwise, or is she in the
process of writing one?
If not, what features would people recommend for a new push tx fuzzer?
Endpoints I would like to test include:
The fuzzer should be able to send random data, invalid characters, etc. but
also fuzz particular aspects of the transaction format such as malformed
P2SH and P2PKH transactions, fields such as lock time, size, # inputs,
version number, vin size, etc. It should also be able to fuzz a variety of
valid and invalid script formats using odd op codes, changing the order of
op codes, etc.
If anyone has recommendations about how such a fuzzer should be structured,
please let me know.
Finally, if you are interested in collaborating, please contact me via
private message.

@_date: 2015-09-11 11:13:18
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] Named Bitcoin Addresses 
I applaud your brainstorming efforts! :) But I dislike just about
everything about this proposal.
Bitcoin addresses should never be reused, for privacy and security reasons
documented extensively online.
I definitely do not want my computer to maintain a registry of every
address in the world any more than I want to maintain a list of all email
addresses, web addresses, etc. This cannot be scaled and is wasteful since
most participants in the network don't need to transact.
If we need naming conventions, I'd rather see a name registry system
off-chain attached to bip47 reusable payment codes.
On Sep 10, 2015 5:32 PM, "Mark Friedenbach via bitcoin-dev" <

@_date: 2016-04-29 14:22:32
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] segwit subsidy and multi-sender (coinjoin) 
============================== START ==============================
Has anyone thought about the effects of the 75% Segregated Witness subsidy
on CoinJoin transactions and CoinJoin-like transactions? Better yet, has
anyone collected data or come up with a methodology for the collection of
"Segwit improves the situation here by making signature data, which does
not impact the UTXO set size, cost 75% less than data that does impact the
UTXO set size. This is expected to encourage users to favour the use of
transactions that minimise impact on the UTXO set in order to minimise
fees, and to encourage developers to design smart contracts and new
features in a way that will also minimise the impact on the UTXO set."
My expectation from the above is that this will serve as a financial
disincentive against CoinJoin transactions. However, if people have
evidence otherwise, I'd like to hear it.
I noticed jl2012 objected to this characterization here, but has not yet
provided evidence:
A sample of the 16 transaction id's posted in the JoinMarket thread on
BitcoinTalk shows an average ratio of 1.38 or outputs to inputs:
As we know, a "traditional" CoinJoin transaction creates roughly 2x UTXOs
for everyone 1 it consumes -- 1 spend and 1 change -- unless address reuse
comes into play.
Please refrain from bringing up Schnorr signatures in your reply, since
they are not on any immediate roadmap.

@_date: 2016-02-10 16:36:05
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] RFC for BIP: Best Practices for Heterogeneous Input 
BIP: TBD
Title: Best Practices for Heterogeneous Input Script Transactions
Author: Kristov Atlas  Status: Draft
Type: Informational
Created: 2016-02-10
# Abstract
The privacy of Bitcoin users with respect to graph analysis is reduced when
a transaction is created that merges inputs composed from different
scripts. However, creating such transactions is often unavoidable.
This document proposes a set of best practice guidelines which minimize the
adverse privacy consequences of such unavoidable transaction situations
while simultaneously maximising the effectiveness of privacy-improving
techniques such as CoinJoin.
# Copyright
This BIP is in the public domain.
# Definitions
Heterogenous input script transaction (HIT): A transaction containing
multiple inputs where not all inputs have identical scripts (e.g. a
transaction spending from more than one Bitcoin address)
Unavoidable heterogenous input script transaction: An HIT created as a
result of a user?s desire to create a new output with a value larger than
the value of his wallet's largest unspent output
Intentional heterogenous input script transaction: An HIT created as part
of a protocol for improving user privacy against graph analysis, such as
# Motivations
The recommendations in this document are designed to accomplish three goals:
1. Maximise the effectiveness of privacy-enhancing transactions:
Privacy-sensitive users may find that techniques such as CoinJoin are
counterproductive if such transactions have a distinctive fingerprint which
enables them to be censored or subjected to additional scrutiny.
2. Minimise the adverse privacy consequences of unavoidable heterogenous
input transactions: If unavoidable HITs are indistinguishable from
intentional HITs, a user creating an unavoidable HIT benefits from
ambiguity with respect to graph analysis.
3. Limiting the effect on UTXO set growth: To date, non-standardized
intentional HITs tend to increase the network's UTXO set with each
transaction; this standard attempts to minimize this effect by
standardizing unavoidable and intentional HITs to limit UTXO set growth.
In order to achieve these goals, this specification proposes a set of best
practices for heterogenous input script transaction creation. These
practices accommodate all applicable requirements of both intentional and
unavoidable HITs and render the two types indistinguishable to the maximum
extent possible.
In order to achieve this, two forms of HIT are proposed: Standard form and
alternate form.
# Standard form heterogenous input script transaction
 Rules
An HIT is Standard form if it adheres to all of the following rules:
1. The number of unique output scripts must be equal to the number of
unique inputs scripts (irrespective of the number of inputs and outputs).
2. All output scripts must be unique.
3. At least one pair of outputs must be of equal value.
4. The largest output in the transaction is a member of a set containing at
least two identically-sized outputs.
 Rationale
The requirement for equal numbers of unique input/output scripts instead of
equal number of inputs/outputs accommodates privacy-enhancing UTXO
selection behavior. Wallets may contain spendable outputs with identical
scripts due to intentional or accidental address reuse, or due to dusting
attacks. In order to minimise the adverse privacy consequences of address
reuse, any time a UTXO is included in a transaction as an input, all UTXOs
with the same spending script should also be included in the transaction.
The requirement that all output scripts are unique prevents address reuse.
Restricting the number of outputs to the number of unique input scripts
prevents this policy from growing the network?s UTXO set. A standard form
HIT transaction will always have a number of inputs greater than or equal
to the number of outputs.
The requirement for at least one pair of outputs to be of equal value
results in optimal join transactions, and causes intentional HITs to
resemble unavoidable HITs.
Outside controlled laboratory conditions, join transactions will not
involve identically-sized inputs due to a lack of accommodating volume.
Without the ability to cryptographically blind output values on the
blockchain, every join transaction leaks information in the form of output
sizes. Requiring a pair of identically sized outputs creates the desired
ambiguity for spend outputs, but in most cases makes change outputs
linkable to inputs.
# Alternate form heterogenous input script transactions
The formation of a standard form HIT is not possible in the following cases:
The HIT is unavoidable, and the user?s wallet contains an insufficient
number or size of UTXOs to create a standard form HIT.
The user wishes to reduce the number of utxos in their wallet, and does not
have any sets of utxos with identical scripts.
When one of the following cases exist, a compliant implementation may
create an alternate form HIT by constructing a transaction as follows:
 Procedure
1. Find the smallest combination of inputs whose value is at least the
value of the desired spend.
  i. Add these inputs to the transaction.
  ii. Add a spend output to the transaction.
  iii. Add a change output to the transaction containing the difference
between the current set of inputs and the desired spend.
2. Repeat step 1 to create a second spend output and change output.
3. Adjust the change outputs as necessary to pay the desired transaction
Clients which create intentional HITs must have the capability to form
alternate form HITs, and must do so for a non-zero fraction of the
transactions they create.
# Non-compliant heterogenous input script transactions
If a user wishes to create an output that is larger than half the total
size of their spendable outputs, or if their inputs are not distributed in
a manner in which the alternate form procedure can be completed, then the
user can not create a transaction which is compliant with this procedure.
A working draft of this document is here:
A few points of anticipated discussion:
1. It's possible for a CoinJoin transaction to decrease privacy by adhering
to the Standard Form in this BIP, depending on the utxos available for
creating it. For example, a typical two-person CoinJoin might look like:
input_A, input_B => spend_A, change_A, spend_B, change_B
In order to comply with the standard form, one or more parties would have
to add inputs to make this something like:
input_A_1, input_A_2, input_B_1, input_B_2 => spend_A, change_A, spend_B,
If spend_A and spend_B are the same value, then input_A_1 and input_A_2 may
be linked based on the value of change_A and input_B_1 and input_B_2 may be
linked based on the value of change_B via sudoku analysis.
In that situation, wallets can opt to use the alternate form instead, or
stick with the standard form but enjoy a non-utxo set increase and a
significantly increased inter-transactional privacy set from other BIP
2. In a naive simulation of a wallet randomly containing 1 to 10 utxos of
random value 1 to 10 and a desired spend of random value between 1 and the
sum of the utxos, the simulated wallet is able to create an alternate form
HIT 40% of the time. If we assume that half of all desire spends are a
value half or less of the total wallet balance, this improves to around
60%. Unfortunately, I don't have any good data on what values are found in
average wallets and what desired spends look like on average.
3. In the long-run it's better for all clients to participant in
CoinJoin-like operations, but this should significantly increase the cost
and decrease the signal of passive blockchain analysis attacks until that
becomes feasible.
Thanks in advance for your feedback.

@_date: 2016-05-19 00:18:15
@_author: Kristov Atlas 
@_subject: [bitcoin-dev] RFC for BIP: Best Practices for Heterogeneous 
I've updated the language of the BIP. New version:
  BIP: TBD
  Title: Best Practices for Heterogeneous Input Script Transactions
  Author: Kristov Atlas   Status: Draft
  Type: Informational
  Created: 2016-02-10
The privacy of Bitcoin users with respect to graph analysis is reduced when
a transaction is created that contains inputs composed from different
scripts. However, creating such transactions is often unavoidable.
This document proposes a set of best practice guidelines which minimize the
adverse privacy consequences of such unavoidable transaction situations
while simultaneously maximising the effectiveness of user protection
This BIP is in the public domain.
* '''Heterogenous input script transaction (HIT)''': A transaction
containing multiple inputs where not all inputs have identical scripts
(e.g. a transaction spending from more than one Bitcoin address)
* '''Unavoidable heterogenous input script transaction''': An HIT created
as a result of a user?s desire to create a new output with a value larger
than the value of his wallet's largest existing unspent output
* '''Intentional heterogenous input script transaction''': An HIT created
as part of a user protection protocol for reducing uncontrolled disclosure
of personally-identifying information (PII)
The recommendations in this document are designed to accomplish three goals:
# Maximise the effectiveness of user-protecting protocols: Users may find
that protection protocols are counterproductive if such transactions have a
distinctive fingerprint which renders them ineffective.
# Minimise the adverse consequences of unavoidable heterogenous input
transactions: If unavoidable HITs are indistinguishable from intentional
HITs, a user creating an unavoidable HIT benefits from ambiguity with
respect to graph analysis.
# Limiting the effect on UTXO set growth: To date, non-standardized
intentional HITs tend to increase the network's UTXO set with each
transaction; this standard attempts to minimize this effect by
standardizing unavoidable and intentional HITs to limit UTXO set growth.
In order to achieve these goals, this specification proposes a set of best
practices for heterogenous input script transaction creation. These
practices accommodate all applicable requirements of both intentional and
unavoidable HITs while maximising the effectiveness of both in terms of
preventing uncontrolled disclosure of PII.
In order to achieve this, two forms of HIT are proposed: Standard form and
alternate form.
==Standard form heterogenous input script transaction==
An HIT is Standard form if it adheres to all of the following rules:
# The number of unique output scripts must be equal to the number of unique
inputs scripts (irrespective of the number of inputs and outputs).
# All output scripts must be unique.
# At least one pair of outputs must be of equal value.
# The largest output in the transaction is a member of a set containing at
least two identically-sized outputs.
The requirement for equal numbers of unique input/output scripts instead of
equal number of inputs/outputs accommodates user-protecting UTXO selection
behavior. Wallets may contain spendable outputs with identical scripts due
to intentional or accidental address reuse, or due to dusting attacks. In
order to minimise the adverse consequences of address reuse, any time a
UTXO is included in a transaction as an input, all UTXOs with the same
spending script should also be included in the transaction.
The requirement that all output scripts are unique prevents address reuse.
Restricting the number of outputs to the number of unique input scripts
prevents this policy from growing the network?s UTXO set. A standard form
HIT transaction will always have a number of inputs greater than or equal
to the number of outputs.
The requirement for at least one pair of outputs in an intentional HIT to
be of equal value results in optimal behavior, and causes intentional HITs
to resemble unavoidable HITs.
==Alternate form heterogenous input script transactions==
The formation of a standard form HIT is not possible in the following cases:
# The HIT is unavoidable, and the user?s wallet contains an insufficient
number or size of UTXOs to create a standard form HIT.
# The user wishes to reduce the number of utxos in their wallet, and does
not have any sets of utxos with identical scripts.
When one of the following cases exist, a compliant implementation may
create an alternate form HIT by constructing a transaction as follows:
# Find the smallest combination of inputs whose value is at least the value
of the desired spend.
 Add these inputs to the transaction.
 Add a spend output to the transaction.
 Add a change output to the transaction containing the difference between
the current set of inputs and the desired spend.
# Repeat step 1 to create a second spend output and change output.
# Adjust the change outputs as necessary to pay the desired transaction fee.
Clients which create intentional HITs must have the capability to form
alternate form HITs, and must do so for a non-zero fraction of the
transactions they create.
==Non-compliant heterogenous input script transactions==
If a user wishes to create an output that is larger than half the total
size of their spendable outputs, or if their inputs are not distributed in
a manner in which the alternate form procedure can be completed, then the
user can not create a transaction which is compliant with this procedure.
