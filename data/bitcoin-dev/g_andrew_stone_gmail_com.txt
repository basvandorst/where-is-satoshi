
@_date: 2015-07-31 14:04:53
@_author: G. Andrew Stone 
@_subject: [bitcoin-dev] A compromise between BIP101 and Pieter's proposal 
There's a large array of solutions that are bigger than the cheapest home
broadband, but smaller then renting hardware in a data center.  Every
company with internet service to their location purchases one of these
options.  If Bitcoin full node bandwidth requirements ever exceed a
hobbyist's reach, s/he can always pool resources with other individuals to
purchase one of these solutions, and a 1-room office.
How many of you have connected to multiple ISPs and are routing internet
traffic between them?  But TCP is still permissionless.
Bitcoin node requirements will grow beyond a hobbyist reach (but not that
of the garage entrepreneur).   The truth is that as technologies grow and
mature, the hobbyists move on but anyone who has a real reason to continue
using it stays.  This fact does not destroy its decentralization.
I do not think that reasonable scaling will significantly affect full node
quantity (historical downtrends are conflated with the simultaneous
transition from hobbyist to professional).
At the same time the ability to create an independent full node is a
tremendous force keeping existing full nodes honest -- this potential is
more powerful then the fact.
Which would you choose, a 10 thousand node strong bankCoin, or a 1000 node
open source permissionless Bitcoin?
On Fri, Jul 31, 2015 at 12:22 PM, Dave Scotese via bitcoin-dev <

@_date: 2016-03-07 15:06:12
@_author: G. Andrew Stone 
@_subject: [bitcoin-dev]  Services bit for xthin blocks 
The Bitcoin Unlimited client needs a services bit to indicate that the node
is capable of communicating thin blocks.  We propose to use bit 4 as AFAIK
bit 3 is already earmarked for Segregated Witness.

@_date: 2016-03-07 21:35:21
@_author: G. Andrew Stone 
@_subject: [bitcoin-dev] Services bit for xthin blocks 
Included at the bottom of this mail is a BIP concerning our impending use
of a particular services bit.
I am making a good-faith effort to notify the community of this use and
follow the BIP submission rules with a correctly formatted BIP sent to Luke
jr.  He has informed me that such a BIP should be discussed on the mailing
list (which is this thread) and that the BIP should document the extreme
thin block protocol.
Not an unreasonable request, however while I personally respect the many
great accomplishments of individual engineers loosely affiliated with
"Core", Bitcoin Unlimited has our own process for documentation and
discussion on an uncensored forum located here:
  We
would love to have any interested engineer join us there with ideas and
But since Bitcoin Unlimited already has a process, it would be redundant
and time consuming for us to adhere to your process.  If a "Core" engineer
would like to spend the time to move this BIP through your process I would
be eternally grateful and be willing to use a different bit or make other
changes that make mutual sense.  If not, then it is up to "Core" as a group
to decide whether they would like to preserve interoperability as the
protocol intended by avoiding use of bit 1<<4  (except to indicate the
presence of a compatible Xthin implementation), or whether they will force
clients to take the sub-version field into account when determining client
Andrew Stone
Developer, Bitcoin Unlimited
  BIP: XXX
  Title: Extreme thin block service bit
  Author: Andrew Stone   Status:
  Type: Standards Track
  Created: 2016-03-07
Nodes need to communicate to each other whether or not thin block
communication messages are supported.
# Ensure Satoshi client interoperability
Clients will use this functionality to choose peers, so a service bit is
the most appropriate location.
# Bit (1 << 4) of the nServices flags enum located in protocol.h shall
indicate the ability to handle thin block communication messages.
==Backward compatibility==
All older clients are compatible with this change. Users and merchants
should not be impacted.
enum {
  ...
    // NODE_XTHIN means the node is capable of and willing to handle Xthin
    NODE_XTHIN = (1 << 4),
  ...
This document is Public Domain.

@_date: 2016-03-09 13:11:34
@_author: G. Andrew Stone 
@_subject: [bitcoin-dev] Services bit for xthin blocks 
Thanks for your offer Luke, but we are happy with our own process and,
regardless of historical provenance, see this mailing list and the BIP
process as very Core specific for reasons that are too numerous to describe
here but should be obvious to anyone who has been aware of the last year of
Bitcoin history.

@_date: 2017-02-23 13:28:18
@_author: G. Andrew Stone 
@_subject: [bitcoin-dev] A Better MMR Definition 
Can an insertion ordered MMR allow an efficient nonexistence proof?
On Feb 23, 2017 1:20 PM, "Peter Todd via bitcoin-dev" <

@_date: 2017-02-28 11:43:29
@_author: G. Andrew Stone 
@_subject: [bitcoin-dev] A Better MMR Definition 
I can understand how Bram's transaction double sha256 hashed UTXO set
patricia trie allows a client to quickly validate inputs because the inputs
of a transaction are specified in the same manner.  So to verify that an
input is unspent the client simply traverses the patricia trie.
It also makes sense that if transaction inputs were specified by a [block
height, tx index, output index] triple we'd have a much more size-efficient
transaction format.  This format would make look up pretty simple in
Peter's pruned time-ordered TXO merkle mountain range, although you'd have
translate the triple to an index, which means we'd have to at a minimum
keep track of the number of TXOs in each block, and then probably do a
linear search starting from the location where the block's TXOs begin in
the MMR.  (The ultimate option I guess is to specify transaction inputs by
a single number which is essentially the index of the TXO in a (never
actually created) insertion-ordered TXO array...)
But since transactions' prevouts are not specified by [block height, tx
index, output index] or by TXO index, I don't understand how an insertion
ordered TXO tree can result in efficient lookups.  Can you help me
understand this?
On Sat, Feb 25, 2017 at 1:23 AM, Bram Cohen via bitcoin-dev <

@_date: 2020-08-24 09:59:26
@_author: G. Andrew Stone 
@_subject: [bitcoin-dev] Generalizing feature negotiation when new p2p 
Since discussion around allowing unknown messages or not allowing them
seems contentious, I'd like to offer up another possibility: create a
single new message, XVERSION, (and bump the protocol rev) which is a
key-value array of arbitrary data.  Any protocol extension can then choose
a new key (with a 32 or 64 bit keyspace you can basically hand out prefixes
to any implementation that wants one)  and publish custom data via this
message without needing to bump the protocol rev field.  Typical "custom
data" would be the min and max supported version of some specific extended
protocol, but any data is possible since the "value" field can be
serialized via the same network serialization format.  It therefore doubles
as a "configuration" message as well as protocol extension negotiation.
For example, we use it to communicate the maximum unconfirmed chain a node
will commit to the mempool, and peers don't bother to send transactions
that exceed this limit.
You can find a specification here:
Code has been deployed for a long time.
On Mon, Aug 24, 2020 at 5:44 AM Suhas Daftuar via bitcoin-dev <
