
@_date: 2014-12-15 13:35:11
@_author: Cory Fields 
@_subject: [Bitcoin-development] Recent EvalScript() changes mean 
It would appear as though you're trying to drum up controversy here,
but the argument is quite a stretch, and contrary to some other
arguments you're making in parallel. There seem to be three themes in
your above complaint, so I'd like to address them individually.
1. Pr  specifically. The argument seems to be that this was not
properly reviewed/tested, and that it is an unnecessary risk to the
consensus codebase.
Looking at the PR at github, while I certainly don't agree with those
conclusions, I suppose I can understand where they're coming from.
There's plenty of context missing, as well as sidebar discussions on
IRC and other PRs. To an outside observer, these changes may look
under-tested and unnecessary.
The context that's missing is the flurry of work that was going on in
parallel to modularize this (and surrounding code).  was one of
the first pieces necessary for that, so some of the discussion about
it was happening in dependent pull requests.
You can point to a lack ACKs in one place for that PR, but that
doesn't mean that the changes weren't tested/reviewed/necessary. You
could also argue that ACKs should've been mirrored on the PR in
question for posterity, which would be a perfectly reasonable argument
that I would agree with.
2. These changes conflict with a rebased version of your
CHECKLOCKTIMEVERIFY changes. OK? You have a tree that's a few months
old, and you find that you have conflicts when rebasing to master. It
happens to all of us. Do as the rest of us do and update your changes
to fit. If you missed the review of  and think it should be
reverted, then call for a revert. But please give a concrete reason
other than "I've picked this commit series for a crusade because it
gave me merge conflicts".
What is the conspiracy here? There's a signature cache that is
implementation-specific, and in a parallel universe, you might be
arguing that we should rip it out because it adds unnecessary
complexity to the consensus code. The PR provides a path around that
complexity. For some reason, your reaction is to cry foul months later
because you missed reviewing it at the time, rather than cheering for
the reduced complexity.
3. You seem to think that 1. and 2. seem to point to a systemic
failure of the review process because modularization "shouldn't come
at the cost of safety". I agree that it shouldn't come at the cost of
safety, but I see no failure here. There has been a HUGE effort to
modularize the code with a combination of pure-code-movement and small
interface reworks. Please take a moment to grep the git logs for
"MOVEONLY" in the 0.10 branch.
You'll notice that script verification is now 100% free of bitcoind
state, threading, and third-party libraries (other than openssl for
now). That constitutes a massive reduction in code complexity, future
review overhead, etc. I'll point out here that those were my reasons
for my contributions to the libbitcoinconsensus effort. I have no
interest in altcoins or sidechains.
Those milestones were thanks to an effort which included  If you
have issues with these changes and/or how they were made, please call
out individual failures and proposed solutions _in context_. That they
conflict with CHECKLOCKTIMEVERIFY may be a valid concern, and it may
be worth evaluating how separate coding efforts may more effectively
Without pointers to specific failures or solutions, I'm not sure what
you were trying to communicate here, other than maybe stirring the
social networks with: "I
personally would recommend *not* upgrading to v0.10 due to these
issues." That's fine I suppose, but it does nothing to solve whatever
issue you're trying to call out here.

@_date: 2014-12-15 13:42:27
@_author: Cory Fields 
@_subject: [Bitcoin-development] Recent EvalScript() changes mean 
That's exactly what happened during the modularization process, with
the exception that the code movement and refactors happened in
parallel rather than in series. But they _were_ done in separate
logical chunks for the sake of easier review. The commit tag
"MOVEONLY" developed organically out of this process, and a grep of
the 0.10 branch for "MOVEONLY" is a testament to exactly how much code
moved 1:1 out of huge files and into logically separated places and/or
new files.
Perhaps it's worth making "MOVEONLY" (which as the name implies, means
that code has been copied 1:1 to a new location) use an official dev
guideline for use in future refactors.

@_date: 2014-12-15 16:19:16
@_author: Cory Fields 
@_subject: [Bitcoin-development] Recent EvalScript() changes mean 
I won't argue that at all because it's perfectly logical, but in
practice that doesn't translate from the macro level to the micro
level very well. At the micro level, minor code changes are almost
always needed to accommodate useful code movement. Even if they're not
required, it's often hard to justify code movement for the sake of
code movement with the promise that it will be useful later.
Rather than arguing hypotheticals, let's use a real example:
 . That one's pretty
simple. The point of the PR was to unchain our openssl wrapper so that
key operations could be performed by the consensus lib without
dragging in bitcoind's structures. The first commit severs the
dependencies. The second commit does the code movement from the
now-freed wrapper.
I'm having a hard time coming up with a workflow that would handle
these two changes as _separate_ events, while making review easier.
Note that I'm not attempting to argue with you here, rather I'm
genuinely curious as to how you'd rather see this specific example
(which is representative of most of my other code movement for the
libbitcoinconsensus work, i believe) handled.
Using your model above, I suppose we'd do the code movement first with
the dependencies still intact as a pull request. At some later date,
we'd sever the dependencies in the new files. I suppose you'd also
prefer that I group a bunch of code-movement changes together into a
single PR which needs little scrutiny, only verification that it's
move-only. Once the code-movement PRs are merged, I can begin the
cleanups which actually fix something.
In practice, though, that'd be a massive headache for different
reasons. Lots in flux with seemingly no benefits until some later
date. My PR's can't depend on eachother because they don't actually
fix issues in a linear fashion. That means that other devs can't
depend on my PRs either for the same reason. And what have we gained?
Do you find that assessment unreasonable?

@_date: 2014-10-15 14:58:57
@_author: Cory Fields 
@_subject: [Bitcoin-development] BIP process 
Sounds like this is what you're after, it's a fairly new feature:
I've been meaning to use it in a PR to try it out.

@_date: 2015-08-14 17:10:20
@_author: Cory Fields 
@_subject: [bitcoin-dev] libconsensus assertion fails if used in multiple 
Ugh, what an unfortunate oversight!
The good news is that this issue should be solved in future versions
when we switch to the new libsecp256k1 lib for validation.
For now, I've thrown together a quick hack to allow a user-specifiable
callback for libbitcoinconsensus. I think it's not worth messing with
the official API since it will be fixed soon, but rather hacked in as
a temporary work-around as needed. It _should_ be documented as an
issue with the current version, though.
Please see here for a work-around to try:
Unfortunately it's not pretty, but it works fine here. Note that you
should give this some _serious_ testing before deploying in any real
way. It should mimic the way we do it in Core, though.
That's on top of current master, but it should be trivial to apply to
release tags.
Please let me know how it works out.
On Fri, Aug 14, 2015 at 12:37 PM, Tamas Blummer via bitcoin-dev

@_date: 2015-08-18 01:03:40
@_author: Cory Fields 
@_subject: [bitcoin-dev] libconsensus assertion fails if used in multiple 
Back to the list (from github) in case anyone finds this via Google.
The patch that I posted here a few days ago did not fix the issue for Tamas.
I spent some time tracking down this edge-case because
libbitcoinconsensus needs to be as bullet-proof as possible. Thanks to
Tamas for creating a bare-bones test case after some discussion.
I finally managed to reproduce the issue on OSX. It's subtle and
likely rare in the real-world, though obviously not impossible given
the report here. For posterity, here's a rundown (braindump) of the
When calling EC_KEY_new_by_curve_name(), openssl internally checks to
see how to setup the curve's EC_METHOD (simple, montgomery, or nist).
Unfortunately, in all released OpenSSL versions (as far as I can tell
master is the only branch that has fixed this issue), it's tested like
- Try a method. If it fails, set a global error and return.
- If the global error is set, try a different method.
Prior to OpenSSL 1.0.0, these were tested in the order:
EC_GFp_nist_method -> EC_GFp_mont_method. The secp256k1 curve fails
the ec_GFp_nist_group_set_curve test and sets the global error. That
error is then checked for failure, and EC_GFp_mont_method is tried
(and succeeds).
Obviously that global error usage is dangerous, especially since it
happens for _each_ transaction verification in libbitcoinconsensus. In
a multi-threaded environment, a crash is guaranteed within a few
However, OpenSSL 1.0.1 reversed the order, trying EC_GFp_mont_method
first, so that the global error doesn't end up being used:
This was backported from master back to 1.0.1, but not to 1.0.0 or 0.9.8.
So that change (accidentally) "solved" the problem. As you can see,
it's still possible to hit the reversed order in the
!defined(OPENSSL_BN_ASM_MONT) case. That's easily tested by building
OpenSSL with the -no-asm config option. It's probably also the case
for obscure architectures and OSs, but I haven't looked deeply into
that. In that case, it's reasonable to assume that this crash would
likely occur on such platforms.
Also, OSX, even the latest version (10.10 as of now), still ships with
OpenSSL 0.9.8. Which is how Tamas ran into it.
Since Bitcoin Core and libbitcoinconsensus are switching away from
OpenSSL for verification in the near future, I don't think this is
much of an issue. Especially since the problem manifests as a
controlled assertion failure/abort. However, I've prepared a patch for
anyone who may run into the issue in the short-term:
I'll open a pull-request for Bitcoin Core to discuss whether it's
worth merging or not.

@_date: 2015-08-18 13:25:39
@_author: Cory Fields 
@_subject: [bitcoin-dev] libconsensus assertion fails if used in multiple 
See responses inline.
A few points there. First, Core is switching to libsecp256k1 for
several reasons, and one of them is speed. I seem to recall it being
up to 8x faster than OpenSSL.
Also, it can depend heavily on compiler switches and optimization
levels. For example, In playing with my test-case for hitting the
OpenSSL race issue, I managed to get a ~100% speedup by simply using
-O3 and lto.
Well I'd say you're a bit biased in this case ;)
It's only those using ancient (0.98 or 1.00) versions of OpenSSL who
are affected, or those with OPENSSL_BN_ASM_MONT support disabled or
missing. Note that official releases of libbitcoinconsensus are
compiled against a much newer version and shouldn't have any issues.
The earlier patches for locking callbacks should be unnecessary.
Well it's not a good thing by any means, but it's certainly better
than incorrect results! In any undefined/error condition for the
consensus library, aborting is the right thing to do. If we can't
explain how we've reached a certain "unreachable" condition as is the
case here, the only reasonable recourse is to shut down. Otherwise we
risk network forks, DOS, etc.
It will likely be unnecessary for the next release, but I do think
it's worth backporting to the 0.10 and 0.9 series.
I believe the libsecp256k1 guys are generally happy with the lib these
days, but I'll avoid guessing at a timeline. We can discuss that on
the PR for this fix, which I'll do today.

@_date: 2015-07-22 19:42:10
@_author: Cory Fields 
@_subject: [bitcoin-dev] Bitcoin Core and hard forks 
I'm not sure why Bitcoin Core and the rules and policies that it
enforces are being conflated in this thread. There's nothing stopping
us from adding the ability for the user to decide what their consensus
parameters should be at runtime. In fact, that's already in use:
./bitcoind -testnet. As mentioned in another thread, the chain params
could even come from a config file that the user could edit without
touching the code.
I realize that it'd be opening Pandora's Box, and likely met with very
loud and reasonable arguments about the obvious terrible implications,
but it's at least an alternative to the current status quo of Core's
conflation with the consensus rules. The idea really is no different
than suggesting that someone fork the codebase and implement their own
changes, it just cuts out most of the work required.
With that in place, consensus changes would be more about lobbying and
coalitions, and less about pull requests.
On Wed, Jul 22, 2015 at 6:40 PM, Raystonn via bitcoin-dev

@_date: 2015-07-22 20:05:53
@_author: Cory Fields 
@_subject: [bitcoin-dev] Bitcoin Core and hard forks 
Not sure if serious, so I'll assume you are :)
Why? The idea in this case would be to allow the user to decide
between (say) "./bitcoind -1mbchain" and "./bitcoind -2mbchain" at
runtime rather than the likely alternative of "./bitcoind" vs
Chain params may be identical other than the value of some future
event (miner vote for example), in which case the configs would run
identically until that point.
If your concern is about nodes with different configs communicating
with eachother, I'd like to reiterate: the idea really is no different
than suggesting that someone fork the codebase and implement their own
changes, it just cuts out most of the work required.

@_date: 2015-07-22 20:34:23
@_author: Cory Fields 
@_subject: [bitcoin-dev] Bitcoin Core and hard forks 
Again, why? If someone wants to create a scamcoin, they can. If
someone wants to burn money on a scamcoin, equally, they can. I'm not
sure how this is any different. If someone manages to garner realistic
support for a hard-fork, I don't see the benefit in forcing them to
use forked software.. that only leaves Core in the middle because it's
forced to choose a side (not choosing is unfortunately a side as
well). It doesn't remove the reality of the split.
Well of course. It would be a terrible idea. People would try it and
fail, and lose money. But for those crying foul at Core for being the
consensus/policy gatekeeper, it seems to me that user-selectable
params is the only logical solution.

@_date: 2015-11-12 13:16:03
@_author: Cory Fields 
@_subject: [bitcoin-dev] Post-conference hacking in Hong Kong 
Hi all
As some of you may recall, I tried to throw together a small
code-sprint after the Scaling Bitcoin event in Montreal. There were
several problems stemming from the last-minute-ness and some confusion
about the scope and goals, but I think it was a good thing overall.
Most importantly, it pointed out that many devs are interested in
face-time for technical/code discussions.
For those of you attending the Hong Kong conference next month, I'd
like to invite you to stay an extra day or two and join in on some
in-person hacking, code-review, and technical discussion.
If there was one take-away from the Montreal sprint, it was this:
trying to stick to a pre-defined set of goals with so many people is
counter-productive. The plan was to review a few long-standing Bitcoin
Core pull-requests in-person in order to knock them out quickly, but I
think it was the organic tangents and ad-hoc discussions that proved
to be more interesting. So let's encourage that!
The plan:
Thanks to Pindar and Cyberport, we have two rooms available the two
days after the conference. These will be treated as general meeting
rooms for technical discussion; anything goes as long as it's
technical and Bitcoin-related. Personally, I'll be bringing my laptop
and demoing some recent code to others who might be interested (or
anyone who will listen!). It's also a great opportunity for nascent
devs to ask veterans questions questions about development processes,
hard-to-understand code, etc. Miners are encouraged to come as well,
for discussing any technical hurdles or questions that may benefit
from some real-time technical discussion or debugging.
Attendees are encouraged to self-organize and huddle up as necessary.
Topics are by no means limited to Bitcoin Core, so feel free to
discuss/learn about projects outside of your usual bubble. If you find
yourself saying "I'd like to look at that code with you later" at the
conference, plan a time to meet and do it! While this isn't associated
with Scaling Bitcoin or its organizers, it's obviously meant to
piggy-back off of the event. If it becomes too chaotic, we may throw
together a sign-up sheet, but the intent is to let things happen
What it's not:
This is a venue for technical discussion. It should not be treated as
a place for discussing politics, agendas, plans for world domination,
etc. Let your code speak for you!
The location:
Video Conferencing Rooms 2 and 3, Level 3, Core C
Cyberport 3
100 Cyberport Rd,
Telegraph Bay,
Hong Kong
Room 2 seats 20 people around a conference table, room 3 seats 12.
The time:
Tuesday December 8 at 8:00am - Wednesday December 9 at midnight.
Coffee/tea/water will be provided, but food is not arranged. Likely
some herds will form and venture out for food, but we can also order
in. Wifi/whiteboards provided as well.
See you all in Hong Kong!

@_date: 2016-02-01 13:41:06
@_author: Cory Fields 
@_subject: [bitcoin-dev] SegWit GBT updates 
Thanks for getting this started, Luke.
Noticeably absent here is the "default_witness_commitment" key, as
added by the current reference implementation[0].
I assume (please correct me if I'm wrong) that this has been omitted
for the sake of having clients create the commitment themselves as
opposed to having it provided to them.
I don't think that the two approaches (providing the default
commitment for the complete tx set as well as the ability to create it
from chosen transactions) are with each-other, rather it
merely allows for a simpler approach for those who are taking tx's
as-is from bitcoind. It's obviously important for the clients to be
able to chose tx's and create commitments as they desire, but it's
equally important to allow for simpler use-cases.
The issue in particular here is that a non-trivial burden is thrust
upon mining software, increasing the odds of bugs in the process. I'd
like to point out that this is not a theoretical argument. I've
already fixed a handful of bugs relating to serialization or
commitment creation in the mining/pool software that I've worked on
for segwit [1][2][3][4]. Asking them to handle more serialization and
calculation of complex structures needlessly increases the complexity
for zero benefit in the case where the tx's are to be used as-is.
I'll PR this change to the BIP, as I can't really come up with an
argument against. At worst, it can simply be ignored.
[0]: [1]: [2]: [3]: [4]: On Sat, Jan 30, 2016 at 1:50 PM, Luke Dashjr via bitcoin-dev

@_date: 2016-02-01 16:43:33
@_author: Cory Fields 
@_subject: [bitcoin-dev] SegWit GBT updates 
I think that's a bit of a loaded answer. What's to keep a pool from
building its own commitment and requiring miners to use that? I don't
see how providing the known-working commitment for the
passed-in-hashes allows the pool/miner to do anything they couldn't
already, with the exception of skipping some complexity. Please don't
confuse encouraging with enabling.
What's the DoS vector here?
Agreed. However for the sake of initial adoption, it's much easier to
have a known-correct value to use. Even if it's just for the sake of
checking against.
I didn't mean this as an insult/attack, quite the opposite actually.
Thanks for doing the integration :)
I was merely pointing out how easy it is to introduce subtle bugs here.
You're right, thanks. The current code breaks on heights of (for ex)
16513. I'll fix up my changes to take the sign bit into account.
Heh, that only reinforces my point above about introducing bugs :p

@_date: 2016-02-01 20:40:49
@_author: Cory Fields 
@_subject: [bitcoin-dev] SegWit GBT updates 
But your suggestion is "use libblkmaker" which will build the trees
for me. By that logic, isn't libblkmaker making a centralized
implementation easier? Shouldn't that usage be discouraged as well?
And along those lines, shouldn't the fact that it's used as a pool <->
miner protocol be discouraged rather than touted as a feature?
I don't wish to sound hostile, I'm just trying follow the logic. I
can't rationalize why GBT shouldn't expose the commitment that it
knows to be correct (when paired with the transactions it provides),
purely to make things difficult.
It's being provided to them. And if they're using a modified set of
tx's, they'll need to re-calculate it in order to verify the result
anyway. I suspect I'm not understanding this argument.
How about exposing it as a feature/capability, then? That way pools
can expect it from bitcoind, but won't be required to expose it
Using 16513 as an example:
serialized by bitcoind: 0x028140
serialized by ckpool: 0x03814000
ckpool works because blocks after 32768 end up looking the same, but
it will break again at 2113664.

@_date: 2017-09-27 17:20:26
@_author: Cory Fields 
@_subject: [bitcoin-dev] Bitcoin Assistance 
Hi Mark
Thank you very much for posting the findings. I took a look through our
repository and I think I can provide a bit of context.
I'll go through each one, annotating what I've found.
This is used by a few java files in the libsecp256k1 project. That library
(which lives here:  is a
sub-module created and maintained by Bitcoin Core developers. The files in
question are bindings that allow other applications to use libsecp256k1
from Java. Bitcoin Core makes no use of them.
This comes from tinyformat.h. Bitcoin Core indeed uses it.
I'm unable to find any 2-clause BSD licensed files.
This comes from leveldb, which is database software used by Bitcoin Core.
Because database software version inconsistencies can cause accidental
forks (this actually happened in 2013), we include these files in our
repository and use them rather than linking to arbitrary versions at
There are a few non-upstream files we use in our leveldb tree to provide
windows support. Quoting from src/leveldb/util/env_win.cc:
  This file contains source that originates from:
  Those files don't have any explicit license headers but the
  project ( lists the 'New BSD License'
I didn't manage to find any CC-licensed files. The match probably comes
from our gui svg icons, which contain an xml tag with a link to
creativecommons.org. This seems to be the default behavior of inkscape,
which was used to create those icons. Any icons that we have not created
ourselves are listed in contrib/debian/copyright (they're all expat/public
See MIT.
The debian folder, which holds the files used to create debian/ubuntu
packages is licensed gplv2+. These are packaging resources only,
unnecessary for use of the code.
Additionally, some gplv2 m4 macros are used to bootstrap the code that is
used to build the Bitcoin code. These contain the additional exception:
   As a special exception, the respective Autoconf Macro's copyright owner
   gives unlimited permission to copy, distribute and modify the configure
   scripts that are the output of Autoconf when processing the Macro. You
   need not follow the terms of the GNU General Public License when using
   or distributing such scripts, even though portions of the text of the
   Macro appear in them. The GNU General Public License (GPL) does govern
   all other use of the material that constitutes the Autoconf Macro.
The macdeploy script, useful for creating DMG files for macOS is gplv3. It
is not necessary for any other platform, and is only used during the build
process. Additionally, it is not the only way to create DMG files (apple's
native tools can be used as well).
Additionally, config.guess and config.sub are gplv3 scripts used to build
our buildsystem.
authproxy.py, A python script used in our test suite is licensed lgpl
v2.1+. It is only necessary for running optional tests during development.
This references a comment cuckoocache.h. No code from the site is used. The
link to the site was added after the code, as the site provides a helpful
explanation for the technique used.
Another m4 file. As explained with the others above, this is a macro which
builds code which builds code. It is used in the build process only.
The primary and default license for all contributions.
clang-format-diff.py, a python script optionally used by developers to
clean up code changes.
tl;dr: Best I can tell, all source files that comprise Bitcoin Core
binaries are licensed (excluding the public domain ones) as MIT, BSD, or
It's also worth repeating Omar's point that many of the files in the
Bitcoin Core repository are used for optional programs/libraries. None of
the artwork, for example, is needed for the primary bitcoin daemon.
Hope that helps!

@_date: 2018-01-31 20:14:45
@_author: Cory Fields 
@_subject: [bitcoin-dev] New Bitcoin Core macOS signing key 
A public key was published recently for future macOS releases. Sadly,
that key was created the wrong way (iPhone OS instead of macOS), so
another had to be generated.
The new, working pubkey for Bitcoin Core releases starting with
0.16.0rc1 is included in the message below. That message is signed
with the key mentioned in the previous mail.
It can be verified with: openssl smime -verify -noverify -in msg.pem
Sorry for the noise.
-----BEGIN PKCS7-----
-----END PKCS7-----
On Fri, Jan 12, 2018 at 5:14 AM, nullius via bitcoin-dev

@_date: 2018-02-13 14:08:02
@_author: Cory Fields 
@_subject: [bitcoin-dev] Possible change to the MIT license 
I agree that this is a bad idea. When trying to work around a social
issue for a highly technical project, a legal hack is certainly not
the answer. As Daniel pointed out, the result of such a change would
simply be that 100% of all Bitcoin companies would be told by their
legal teams to use the last MIT-licensed version of Bitcoin Core as
they would have no idea how to prove that they're not in violation. So
I think it would succeed in exactly the _opposite_ of its intended
As Patrick said:
Bitcoin is a Kleenex, a Q-Tip, a Xerox in the crypto world. I think we
should just accept that as a feature at this point. Let other projects
faff about with copyright litigation and trademark dilution concerns
Besides, I assume many/most developers would be unwilling to accept
such a change. Speaking for only myself at least, I would not
contribute under that license.
I must admit, though, that it would be fun to read codified
No-True-Scotsman appeals in a software license :p.
On Tue, Feb 13, 2018 at 12:28 PM, Felix Wolfsteller via bitcoin-dev

@_date: 2018-01-12 00:04:44
@_author: Cory Fields 
@_subject: [bitcoin-dev] New Bitcoin Core macOS signing key 
Hi all
As discussed in a few of the last weekly meetings, Bitcoin Core's
macOS code signing certificate expired today.
We are (Greg is ;) in the process of establishing a new threshold
signing scheme that will allow us to handle code signing without any
single point of failure. But until then, releases will be signed as
before, just with a new certificate.
As a matter of record, I used the old code-signing key/certificate to
sign a message containing the pubkey that matches the new
key/certificate. It's attached at the end of this message.
The pkcs7 format is rather clunky, but I wanted to include the current
signing certificate to make verification easier. I'll leave it to the
reader to extract the certificate from a previous release in order to
make sure that they match. It was also in the Core git repo until it
was removed recently.
To verify, you can use something like:
openssl smime -verify -in sig.pkcs7 -inform pem -ignore_critical -purpose any
- "ignore_critical" setting tells openssl to ignore the Apple-specific
critical extensions that it doesn't understand.
- "-purpose any" allows the "purpose == smimesign" check to be
skipped. This would otherwise fail because this certificate is only
authorized to sign code, not arbitrary messages.
By now, the signature will probably fail to validate because the
certificate has expired.
The signed message below is timestamped on the Bitcoin blockchain
using OpenTimestamps. See the attached ots file containing the
timestamp proof. If the attachment gets scrubbed and doesn't make it
to the list, don't be afraid to nag Peter Todd about a mail-friendly
format for these proofs :)
-----BEGIN PKCS7-----
-----END PKCS7-----

@_date: 2018-07-10 16:24:15
@_author: Cory Fields 
@_subject: [bitcoin-dev] Weekly IRC Meeting Time Poll 
Hi all
This is a bit offtopic for bitcoin-dev, but I'm sending here since
many core devs are subscribed.
As discussed in last week's meeting, it would be helpful to have an
idea of what times devs are generally available to meet online. With
better data, we could potentially reschedule the weekly IRC meetings
to a time that would exclude fewer people.
I've thrown together a quick poll, please watch for a mail from
civs at cs.cornell.edu and follow the link to vote. To keep it simple,
the day of the week (Thursday) is fixed for now.
The initial list of voters is based on previous meeting participation.
If you regularly attend the weekly meetings (or can't now but may be
able to attend at a different time), but do not receive a link to vote
in the next hour, please reply here or ping me on IRC so that I may
add you.
Polling will conclude at the end of the scheduled IRC meeting on July 19.

@_date: 2018-07-11 18:15:19
@_author: Cory Fields 
@_subject: [bitcoin-dev] Weekly IRC Meeting Time Poll 
Hi Simon
The poll is intended for regular Bitcoin Core contributors, who meet
once a week to discuss what they're working on. It is a mundane
software meeting, unrelated to the research and discussion of Bitcoin
itself. The meetings are open to all, but it makes sense to constrain
scheduling decisions to the current active contributors. If you'd like
to attend but are unable, meeting transcripts are always made
available online afterwards.
Please see the Contributing doc [0] if you're interested in becoming a
regular contributor to Bitcoin Core :)
0:

@_date: 2018-05-16 12:36:35
@_author: Cory Fields 
@_subject: [bitcoin-dev] UHS: Full-node security without maintaining a full 
Tl;dr: Rather than storing all unspent outputs, store their hashes. Untrusted
peers can supply the full outputs when needed, with very little overhead.
Any attempt to spoof those outputs would be apparent, as their hashes would not
be present in the hash set. There are many advantages to this, most apparently
in disk and memory savings, as well as a validation speedup. The primary
disadvantage is a small increase in network traffic. I believe that the
advantages outweigh the disadvantages.
Bitcoin?s unspent transaction output set (usually referred to as ?The UTXO
set?) has two primary roles: providing proof that previous outputs exist to be
spent, and providing the actual previous output data for verification when new
transactions attempts to spend them. These roles are not usually discussed
independently, but as Bram Cohen's TXO Bitfield [0] idea hints, there are
compelling reasons to consider them this way.
To see why, consider running a node with the following changes:
- For each new output, gather all extra data that will be needed for
  verification when spending it later as an input: the amount, scriptPubKey,
  creation height, coinbaseness, and output type (p2pkh, p2sh, p2wpkh, etc.).
  Call this the Dereferenced Prevout data.
- Create a hash from the concatenation of the new outpoint and the dereferenced
  prevout data. Call this a Unspent Transaction Output Hash.
- Rather than storing the full dereferenced prevout entries in a UTXO set as is
  currently done, instead store their hashes to an Unspent Transaction Output
  Hash Set, or UHS.
- When relaying a transaction, append the dereferenced prevout for each input.
Now when a transaction is received, it contains everything needed for
verification, including the input amount, height, and coinbaseness, which would
have otherwise required a lookup the UTXO set.
To verify an input's unspentness, again create a hash from the concatenation of
the referenced outpoint and the provided dereferenced prevout, and check for
its presence in the UHS. The hash will only be present if a hash of the exact
same data was previously added to (and not since removed from) the UHS. As
such, we are protected from a peer attempting to lie about the dereferenced
prevout data.
 Some benefits of the UHS model
- Requires no consensus changes, purely a p2p/implementation change.
- UHS is substantially smaller than a full UTXO set (just over half for the
  main chain, see below). In-memory caching can be much more effective as a
  result.
- A block?s transactions can be fully verified before doing a potentially
  expensive database lookup for the previous output data. The UHS can be
  queried afterwards (or in parallel) to verify previous output inclusion.
- Entire blocks could potentially be verified out-of-order because all input
  data is provided; only the inclusion checks have to be in-order. Admittedly
  this is likely too complicated to be realistic.
- pay-to-pubkey outputs are less burdensome on full nodes, since they use no
  more space on-disk than pay-to-pubkey-hash or pay-to-script-hash. Taproot and
  Graftroot outputs may share the same benefits.
- The burden of holding UTXO data is technically shifted from the verifiers to
  the spender. In reality, full nodes will likely always have a copy as well,
  but conceptually it's a slight improvement to the incentive model.
- Block data from peers can also be used to roll backwards during a reorg. This
  potentially enables an even more aggressive pruning mode.
- UTXO storage size grows exactly linearly with UTXO count, as opposed to
  growing linearly with UTXO data size. This may be relevant when considering
  new larger output types which would otherwise cause the UTXO Set size to
  increase more quickly.
- The UHS is a simple set, no need for a key-value database. LevelDB could
  potentially be dropped as a dependency in some distant future.
- Potentially integrates nicely with Pieter Wuille's Rolling UTXO set hashes
  [1]. Unspent Transaction Output Hashes would simply be mapped to points on a
  curve before adding them to the set.
- With the help of inclusion proofs and rolling hashes, libbitcoinconsensus
  could potentially safely verify entire blocks. The size of the required
  proofs would be largely irrelevant as they would be consumed locally.
- Others?
 TxIn De-duplication
Setting aside the potential benefits, the obvious drawback of using a UHS is a
significant network traffic increase. Fortunately, some properties of
transactions can be exploited to offset most of the difference.
For quick reference:
p2pkh scriptPubKey: DUP HASH160 [pubkey hash] EQUALVERIFY CHECKSIG
p2pkh scriptSig:    [signature] [pubkey]
p2sh scriptPubKey:  HASH160 [script hash] EQUAL
p2sh scriptSig:     [signature(s)] [script]
Notice that if a peer is sending a scriptPubKey and a scriptSig together, as
they would when using a UHS, there would likely be some redundancy. Using a
p2sh output for example, the scriptPubKey contains the script hash, and the
scriptSig contains the script itself. Therefore when sending dereferenced
prevouts over the wire, any hash which can be computed can be omitted and only
the preimages sent.
Non-standard output scripts must be sent in-full, though because they account
for only ~1% of all current UTXOs, they are rare enough to be ignored here.
 Intra-block Script De-duplication
When transactions are chained together in the same block, dereferenced prevout
data for these inputs would be redundant, as the full output data is already
present. For that reason, these dereferenced prevouts can be omitted when
sending over the wire.
The downside would be a new reconstruction pass requirement prior to
 Data
Here's some preliminary testing with a naive POC implementation patched into
Bitcoin Core. Note that the final sizes will depend on optimization of the
serialization format. The format used for these tests is suboptimal for sure.
Syncing mainnet to block 516346:
                      UTXO Node      UHS Node
  IBD Network Data:   153G           157G
  Block disk space:   175G           157G
  UTXO disk space :   2.8G           1.6G
  Total disk space:   177.8G         158.6G
The on-disk block-space reduction comes from the elimination of the Undo data
that Bitcoin Core uses to roll back orphaned blocks. For UHS Nodes, this data
is merged into to the block data and de-duplicated.
Compared to the UXTO model, using a UHS reduces disk space by ~12%, yet only
requires ~5% more data over the wire.
Experimentation shows intra-block de-duplication to be of little help in
practice, as it only reduces overhead by ~0.2% on mainnet. It could become more
useful if, for example, CPFP usage increases substantially in the future.
 Safety
Assuming sha256 for the UHS's hash function, I don't believe any fundamental
changes to Bitcoin's security model are introduced. Because the unspent
transaction output hashes commit to all necessary data, including output types,
it should not be possible to be tricked into validating using mutated or forged
 Compatibility
Transitioning from the current UTXO model would be annoying, but not
particularly painful. I'll briefly describe my current preferred approach, but
it makes sense to largely ignore this until there's been some discussion about
UHS in general.
A new service-bit should be allocated to indicate that a node is willing to
serve blocks and transactions with dereferenced prevout data appended. Once
connected to a node advertising this feature, nodes would use a new getdata
flag, creating MSG_PREVDATA_BLOCK and MSG_PREVDATA_TX.
Because current full nodes already have this data readily available in the
block-undo files, it is trivial to append on-the-fly. For that reason, it would
be easy to backport patches to the current stable version of Bitcoin Core in
order to enable serving these blocks even before they could be consumed. This
would avoid an awkward bootstrapping phase where there may only be a few nodes
available to serve to all new nodes.
Admittedly I haven't put much thought into the on-disk format, I'd rather leave
that to a database person. Though it does seem like a reasonable excuse to
consider moving away from LevelDB.
Wallets would begin holding full prevout data for their unspent outputs, though
they could probably back-into the data as-is.
 Serialization
I would prefer to delay this discussion until a more high-level discussion has
been had, otherwise this would be a magnet for nits. The format used to gather
the data above can be seen in the implementation below.
It should be noted, though, that the size of a UHS is directly dependent on the
chosen hash function. Smaller hashes could potentially be used, but I believe
that to be unwise.
 Drawbacks
The primary drawback of this approach is the ~5% network ovhead.
Additionally, there is the possibility that a few "bridge nodes" may be needed
for some time. In a future with a network of only pruned UHS nodes, an old
wallet with no knowledge of its dereferenced prevout data would need to
broadcast an old-style transaction, and have a bridge node append the extra
data before forwarding it along the network.
I won't speculate further there, except to say that I can't imagine a
transition problem that wouldn't have a straightforward solution.
Migration issues aside, am I missing any obvious drawbacks?
 Implementation
This code [2] was a quick hack-job, just enough to gather some initial data. It
builds a UHS in memory and never flushes to disk. Only a single run works,
nasty things will happen upon restart. It should only be viewed in order to get
an idea of what changes are needed. Only enough for IBD is implemented,
mempool/wallet/rpc are likely all broken. It is definitely not consensus-safe.
 Acknowledgement
I consider the UHS concept to be an evolution of Bram Cohen's TXO bitfield
idea. Bram also provided invaluable input when initially walking through the
feasibility of a UHS.
Pieter Wuille's work on Rolling UTXO set hashes served as a catalyst for
rethinking how the UTXO set may be represented.
Additional thanks to those at at Financial Crypto and the CoreDev event
afterwards who helped to flesh out the idea:
Tadge Dryja
Greg Sanders
John Newbery
Neha Narula
Jeremy Rubin
Jim Posen
...and everyone else who has chimed in.
[0] [1] [2]

@_date: 2018-05-17 13:16:46
@_author: Cory Fields 
@_subject: [bitcoin-dev] UHS: Full-node security without maintaining a 
Matt: That's a good point. I'll do up a chart comparing utxo size at each
block, as well as comparing over-the-wire size for each block. I think the
period of coalescing earlier this year should be a good example of what
you're describing.
Greg: heh, I was wondering how long it would take for someone to point out
that I'm cheating. I avoided using the word "compression", mostly to
side-step having the discussion turning into reworking the wire
serialization. But you're absolutely right, the de-duping benefits are
independent of the UHS use-case.

@_date: 2019-06-20 22:56:21
@_author: Cory Fields 
@_subject: [bitcoin-dev] Transcripts from coredev.tech Amsterdam 2019 
A belated thanks (as always) for the great notes, Bryan. This is so
On Fri, Jun 7, 2019 at 11:07 AM Bryan Bishop via bitcoin-dev <

@_date: 2020-09-18 21:39:16
@_author: Cory Fields 
@_subject: [bitcoin-dev] A Replacement for RBF and CPFP: Non-Destructive 
Conceptually this is so simple and explicit it almost seems like an obvious
Glossing over some of the design/policy decisions...
I wonder what the real-world privacy implications are due to the
dependencies now being encoded on-chain rather than requiring some effort
to watch the mempool?
On Fri, Sep 18, 2020, 20:52 Jeremy via bitcoin-dev <
