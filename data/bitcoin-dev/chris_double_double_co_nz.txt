
@_date: 2011-12-31 01:01:53
@_author: Chris Double 
@_subject: [Bitcoin-development] Alternative to OP_EVAL 
If you look at the archives of the concatenative programming mailing
list [1] you'll see lots of examples of people creating stack
languages with minimal operations that exploit similar functionality
to reduce the required built in operations. The discussion on the list
is mostly about stack based languages where programs can be pushed on
the stack and executed (eg. Joy [2]/Factor/Some Forths).
I don't think the scripting engine in bitcoin has the ability to
concatenate, append or otherwise manipulate scripts on the stack to be
eval'd though does it?
[1] [2]

@_date: 2011-09-04 01:52:19
@_author: Chris Double 
@_subject: [Bitcoin-development] Transaction limit size in 
In CWallet::CreateTransaction there is a call to 'GetSerializeSize' on
line 979 (
It looks like:
unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK)
if (nBytes >= MAX_BLOCK_SIZE_GEN/5)
  return false;
dPriority /= nBytes;
'wtxNew' is a CWalletTxn. So this gets the serialized size of the
transaction, including all the extra data held in the wallet for that
transaction, and uses that size for computation of priority. Is that
correct? Should it be only the size of the CTransaction* part of the
transaction that should be used?
It looks this was from the casting shenanigans but unless I'm
mistaken, that casting doesn't actually do anything. We get a pointer
to a CTransaction but then dereference it, so the template function
'GetSerializeSize' would get the most derived class, right?
So was the intent to use the CWalletTxn size, and the casting is
superfluous, or was it supposed to be the CTransaction* portion and
the cast is an incorrect way of doing that? Or am I suffering from
late night programmer syndrome and reading it wrong?

@_date: 2011-09-04 02:16:40
@_author: Chris Double 
@_subject: [Bitcoin-development] Transaction limit size in 
After a discussion on  it is indeed the latter. I was
under the mistaken believe that the GetSerializeSize method in
CTransaction and CWalletTxn were virtual, which would result in the
behavior I was thinking of. But they're not so it works. Please

@_date: 2013-08-13 17:26:50
@_author: Chris Double 
@_subject: [Bitcoin-development] SPV client in pure JavaScript? 
There's a Raw Sockets proposal at the W3C that provides TCP sockets:
Firefox OS has an API that is being discussed as part of that:
So there's a possibility of a standardized approach in the future.

@_date: 2013-06-01 10:20:05
@_author: Chris Double 
@_subject: [Bitcoin-development] Implementing batch processing for 
As others have said, queuing outside of bitcoind is a better approach.
I use zeromq for this situation. blocknotify runs a program which uses
zeromq's pub/sub to queue and the application subscribes to this to
get notified of the data.

@_date: 2013-06-01 11:47:17
@_author: Chris Double 
@_subject: [Bitcoin-development] Implementing batch processing for 
============================== START ==============================
I hadn't seen this, thanks! I've integrated zmq myself for block
notifications in bitcoin and the alt coins I use it on my bitparking
merge mining pool. I would love to see something official. I'll try
out the patch in the pull request.

@_date: 2013-10-01 13:20:40
@_author: Chris Double 
@_subject: [Bitcoin-development] bitcoind stops responding 
I see this as well with 0.8.2+. I don't see it on 0.8.1. I originally
hit the '4 keep alive thread limit' where four clients on the same
bitcoind would result in other clients not being able to connect. I
resolved that and still hit the RPC hanging issue. The most problem I've
had is using 'getwork' which I believe is going the wayside anyway.
