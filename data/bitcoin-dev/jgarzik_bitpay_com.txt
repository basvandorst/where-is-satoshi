
@_date: 2013-08-09 09:08:39
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] SPV client in pure JavaScript? 
Certainly.  BitPay is working on such a wallet:
wally uses node.js JavaScript, and not browser JavaScript, so not
exactly what you're talking about...

@_date: 2013-08-09 14:09:23
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] SPV client in pure JavaScript? 
Well, "wally" is just a demo application, a command line client to
prove a technology.
The main development is in places like "node-libcoin", where a wallet
platform is being developed.  While maintaining a strong commitment to
the blockchain engine side of bitcoind, BitPay has enterprise wallet
needs that do not necessarily mesh well with the standard bitcoind
wallet.  Multi-sig, P2SH and other advanced features are key to the
future use of bitcoin in large enterprises.  Managers, CEOs and other
functionaries at a corporation may each have their own wallets /
keyrings, and cooperate to sign large value, high security bitcoin
multi-sig transactions, for example.

@_date: 2013-08-17 10:00:32
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Combining bloom filters? 
Consider wallet A builds bloom filter A' and wallet B builds bloom
filter B'.  Can A' and B' be or'd together to form a single bloom
filter C' ?

@_date: 2013-08-19 12:27:01
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: remove "getwork" RPC from bitcoind 
Pull request  proposes to
remove "getwork" RPC from bitcoind: On mainnet, almost everybody uses a pool (and therefore, not "getwork"
directly to bitcoind).  Those few who solo mine use a pool server to
talk to bitcoind via "getblocktemplate" or other means.  Tests show
that attempts to solo mine on mainnet via "getwork" lead to delays and
On testnet, getwork has a better chance of continuing to work.
Nevertheless, the same tools (open source pool servers or p2pool) are
available for testnet, obviating the continued need to support
However, at one time, getwork to bitcoind was widely used.  I wanted
to poke the audience, to gauge response to removing "getwork."  If a
driving use case remains of which we're unaware, speak up, please.  We
don't want to break anybody needlessly.

@_date: 2013-08-19 16:34:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: remove "getwork" RPC from 
The internal miner is still actively used for testnet, here.

@_date: 2013-08-22 09:18:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: remove "getwork" RPC from 
Yes, that is currently being discussed in a separate pull request.  My
pull request does not impact setgenerate, but an added proposal does
remove the internal miner completely.

@_date: 2013-12-02 09:37:45
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Floating fees and SPV clients 
BitPay noticed this detail last week.  We were noticing that some
transactions were not even reaching our bitcoind border routers (edge
nodes), due to low/no fees.  That led to a long discussion of all
things fee-related.  SPV fees are a big issue.  Getting
child-pays-for-parent in some form out to miners is another.  Getting
a smart, dynamic fee market Gavin mentions is a big need.

@_date: 2013-12-02 09:47:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Floating fees and SPV clients 
Current rough timeline proposed for 0.9 was end-of-January, IIRC.

@_date: 2013-12-05 09:43:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Move authorative source for BIPs to git 
This entire discussion is recycled.  Please review the previous
discussion, before asking the same questions over again.
Properly done, there are FEWER hurdles.  In the previous discussion,
there was outlined a process whereby the BIPS Editor would receive an
email, and could take it from there.  No wiki login or bitcoin payment
required.  More advanced users may submit pull requests.
Compared with a hash-sealed git repo as primary source, the wiki is
second class.

@_date: 2013-12-09 03:32:34
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
I registered bitcointalk.org originally, then passed along control.
It is likely that the two domains are /not/ registered and controlled
in the same way.
The handling of bitcointalk.org was quite disappointing.  Even after
"control" passed from me to Sirius, he did not bother to change the
registrar credentials for months afterward, despite repeated urging.

@_date: 2013-12-09 21:10:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Monetary Authority for Bitcoin 
Your proposal has been met with widespread laughter.  Were I not ill
with the flu, mockery would ensue as well.

@_date: 2013-12-10 20:01:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Monetary Authority for Bitcoin 
It is simpler than that; simple numbers.  Bitcoin is volatile right
now, not for fundamental architecture reasons, but for reasons why
many other small issues are volatile.  Low liquidity and a small issue
implies that a single big player can easily the move the market.
Further, it is volatile because common financial tools available
elsewhere -- shorting, futures/options, etc. -- are not widely and
easily available.
None of these factors are special or specific to bitcoin.  See
However, this is getting WAY off-topic for a development mailing list.
Ryan successfully trolled the list.  Let's not further feed the trolls.

@_date: 2013-12-12 19:26:34
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Merge avoidance and P2P connection 
Absolutely.  This is a key address-non-reuse case we really need to
solve.  Miner payouts, BitPay salary payouts, etc. all use a
statically provided, manually changed address.
Rotating through multiple outputs is a stopgap -- but IMO a useful
one.  HD wallets will solve this in a better way, but existing randkey
systems will be around for a long time.

@_date: 2013-07-03 12:15:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] txtool: Advanced transaction building and fun 
URL: txtool is a command line tool written in node.js that interfaces with
Bitcoin-Qt/bitcoind, to automate or assist in building interesting,
unusual, complicated or just plain odd transactions.  The goal is to
demonstrate advanced bitcoin features, and make it easier for users to
experiment.  The intended audience has a basic awareness of how
bitcoin transactions look and work.
The theory of operation and full list of commands may be reviewed at
Initially, two working examples are presented:
* Easy multi-signature transaction building:
(similar to gmaxwell's P2SH multisig example)
* Passing around transactions (possibly multi-signature) for signing:
Further examples such as decentralized crowdfunding and atomic coin
swapping* will be demonstrated soon.
*

@_date: 2013-07-09 10:06:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: MultiBit as default desktop 
Indeed.  There is no reason to worry about download bandwidth these
days, for open source software downloads.
Move the downloads to a site where such worries do not exist.

@_date: 2013-07-09 11:59:13
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: MultiBit as default desktop 
Cloudflare is rapidly becoming a bitcoin community SPOF.

@_date: 2013-07-18 08:53:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Anti DoS for tx replacement 
What are the costs, benefits, and risks associated with scripts no
longer being stateless, as OP_DEPTH would seem to introduce?

@_date: 2013-07-22 15:42:45
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] HTTP REST API for bitcoind 
URL: Adding an HTTP REST API for bitcoind has been occasionally tossed
about as a useful thing.  Such an API would essentially provide a
decentralized block explorer capability, enabling easy external access
to transaction/address/block indices that we maintain.
The first two implemented API calls are simple, returning a block or
TX given a simple query string based on block hash, e.g.
     GET /rest/tx/TX-HASH
     GET /rest/block/BLOCK-HASH
This can be easily accessed via command line cURL/wget utilities.
Output formats -- binary, hex or json -- may be selected via a
"bitcoin-format" header.
The general goal of the HTTP REST interface is to access
unauthenticated, public blockchain information.  There is no plan to
add wallet interfacing/manipulation via this API.

@_date: 2013-07-24 09:52:33
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Linux packaging letter 
I'm working on a more digestable alternative:
Should be ready in another ~24 hours, as its obviously incomplete
right now.  Alas the publishing of the lame version (which yes, I did
ACK) didn't give me time to finish my version.
I worked on Fedora packaging while at Red Hat, so hopefully, I have a
bit of insight here.  Was also thinking about publishing this on

@_date: 2013-07-29 02:00:10
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Opcode whitelist for P2SH? 
Indeed.  Current designs are all based around pattern matching a
script template.  Satoshi even described lightweight clients as
needing no script engine at all, only the ability to match patterns.

@_date: 2013-07-30 10:01:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Tor and Bitcoin 
This has been discussed on IRC, and would be interesting to explore.
For several applications, linking directly with a Tor library is far
superior to the fragility of requiring a properly configured external
process.  Lacking such a Tor library right now, one must be written

@_date: 2013-06-02 13:35:10
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: soft-fork to make 
That seems fair.
In general, people are actively bloating the UTXO set with unspendable
outputs (that cannot be 100% proven unspendable).  Provably
unspendable seems like an improvement on long term UTXO health.
It is a fair criticism that this inches the incentives, a bit, towards
timestamping and other non-currency uses.  But those uses (a) cannot
be prevented and (b) have already been automated anyway (e.g. the
python upload/download tools stored in-chain).
I do think the overwhelming majority of users are invested in
bitcoin-the-currency (or bitcoin-the-commodity, take your pick), i.e.
the value proposition.  That's our 98% use case.  Given the relative
volumes of traffic, timestamping/data storage/messaging is essentially
getting a free ride.  So IMO it is worth continuing to explore
messaging, for the rare times where a clear currency-or-data-storage
incentive is available.

@_date: 2013-06-04 10:12:44
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: soft-fork to make 
I'm one of the people experimenting in this area.  I've long argued
that a zero-output transaction should be permitted -- 100% miner fee

@_date: 2013-06-04 13:42:53
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: soft-fork to make 
On Tue, Jun 4, 2013 at 10:55 AM, John Dillon
Absolutely.  It wholly depends on the security model, and
economic-incentives model.  Some use models simply don't care if the
miner created a transaction that gave the fee to themselves.  It might
even be /encouraged/ to do this!  Sure they are paying themselves, but
given bitcoin network difficulty is so high, simply obtaining
payments-go-myself-as-miner transactions is itself difficult.
Producing an identity (my goal) or whatever is just fine, and in such
case becomes simply an additional block reward -- an additional
incentive to buy into this identity creation/management system.
Or exchange "identity" with another token, for another data service of
your choice.
This is no longer a strict "proof of sacrifice" system, if such
behavior is encouraged, but it is nonetheless valid.

@_date: 2013-06-04 14:49:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: soft-fork to make 
Re-read what I wrote.  That's perfectly OK.  It is analogous to a pool
operator receiving merged mined coins, each time they mine a bitcoin
If you achieve the very high difficulty needed to create a valid
bitcoin block, you have achieved a very high bar.

@_date: 2013-06-17 11:16:01
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Decentralizing mining 
Interesting proposals, particularly this last.  The net result impact
is, however, that which was criticized in at least one forum thread:
In terms of packet size, I would like to look into the network-wide
costs of simply broadcasting block header + coinbase TX + TX list.  I
bet miners would love to opt into that.
With the onslaught of ASIC mining, most big pools are past a share per
second.  Variable difficulty or set-to-higher-difficulty quickly
became the norm, almost out of necessity.
Personally, I think most pools should target at _least_ 5-10 seconds
per share, no matter the strength of the miner.

@_date: 2013-06-20 09:35:11
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Missing fRelayTxes in version message 
That works until another field is added in the same manner.
Implementations are expected to follow the standard logic of
if (more data)
   parse field X
if (more data)
   parse field X+1
if (more data)
   parse field X+2
Ugly or not, there is no point in changing now.  Updating the version
message to a radically different design, for simply cleanliness
reasons, is not sufficient cause to migrate the entire bitcoin
universe to a new and different version/feature negotiation setup.
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.

@_date: 2013-06-22 15:28:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoind and C++ namespaces? 
Slowly warming to C++ namespaces.  How about starting small, and
wrapping most stuff inside a bitcoin namespace?  Bike shedding can be
done at any point; the main idea is to start small, and gain

@_date: 2013-06-27 12:16:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Double-Spending Fast Payments in Bitcoin 
On Thu, Jun 27, 2013 at 12:03 PM, Arthur Gervais
Certainly.  Though given current P2P network node version
distributions, it is increasing difficult to relay the older version
of transaction, and will only become more so in the future.
It also remains the case that merchants who accept zero confirmation
transactions are likely already aware of the risk level, and make a
business decision.  One can see tiny digital downloads often at zero
confirmation, but rarely a Porsche or house or bitcoin exchange

@_date: 2013-06-27 13:30:21
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: MultiBit as default desktop 
This is definitely a great discussion to have.  Here are some initial,
unprioritized thoughts.  As an engineer, there is never a clear
answer, but a balance of costs and benefits.
Arguments in favor of moving away from Bitcoin-Qt/bitcoind for wallet services:
* Bitcoin-Qt is admittedly a very simple wallet.  I see it's core
strengths more as a "P2P router" for the public blockchain data.
* Wallet feature innovation moves more slowly than
* Requires the full blockchain, which is resource-intensive versus SPV.
Arguments in favor of retaining Bitcoin-Qt/bitcoind default:
* More field experience, code review and testing on desktop than others
* Very real possibility of an overall net reduction of full nodes on P2P network
Arguments in favor of multibit default:
* Good user interface, perhaps more friendly for entry level users as
you describe
* Based on bitcoinj, which has field experience and a very large
installed base thanks to Bitcoin Wallet/Schildbach
Arguments against multibit default:
* Less testing, field experience on desktop
I'm sure others can come up with a few more.

@_date: 2013-06-27 17:56:46
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: MultiBit as default desktop 
Bitcoin Wallet for Android is a decentralized client w/ network sync,
and it works just fine.  Fast, easy to use.

@_date: 2013-05-31 09:05:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Implementing batch processing for 
Similar to other suggestions in this thread,
If your -blocknotify execution is too slow, then create a solution
that simply queues work.  There is no need to add this code to
bitcoind itself.
Another solution is modifying pynode to directly listen to a trusted
node (bitcoind), and monitor blocks as they arrive and are announced.
That does not fix the problem of slow block processing on your side,
but is another way to implement -blocknotify-like behavior.

@_date: 2013-05-31 15:25:44
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Implementing batch processing for 
This is not a compelling need to update bitcoind for this.
The vast majority of systems are currently capable of processing a
block, before another block arrives.
As for parallel processing, your "what if" has been a solved problem
for decade(s) now.

@_date: 2013-11-02 13:08:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Message Signing based authentication 
On Sat, Nov 2, 2013 at 12:52 PM, Melvin Carvalho
Yes:

@_date: 2013-11-05 13:37:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP proposal - patch to raise selfish 
That is quite ignorant.  Bitcoin is far more complex than standard IT
security "fix ASAP" mantra.  Distributed consensus is a new field of
computer science, and blindly applying standard logic to bitcoin will
quickly result in large problems.
Every fix has the chance of changing the game theory or economics of
bitcoin.  A change to the core consensus protocol within bitcoin --
mining -- is even more game-theory- and economically-critical to the
core system.  Changes thus have more impact, where any change
potentially reduces bitcoin's value to zero in the worst case.
Bitcoin is akin to medical device or avionics software.  We cannot
just change at will, without significant research, analysis and
testing.   "It is a bug, it must be fixed ASAP" is ignorant and
Further, this is at present a THEORETICAL problem, and the solution
presented has some obvious flaws, that would make our current, WORKING
SYSTEM more fragile, and less secure.

@_date: 2013-11-05 13:58:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP proposal - patch to raise selfish 
Correct.  There is significant potential that a fix can create other
problems...   and any major mistake could instantly destroy > $2
billion worth of value.

@_date: 2013-11-06 06:35:51
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] we can all relax now 
I will contribute 1 BTC to this bounty, under same terms and expiration.

@_date: 2013-11-06 06:42:01
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [ANN] High-speed Bitcoin Relay Network 
Good stuff.  I have been pushing for private peering agreeents and a
"backbone" for years. Even had a paltry effort going with exmulti.net + a
few manually connected parties.
I hope parties in the bitcoin space take it upon themselves to network with
major sites - miners, payment processors, exchanges, popular sites, etc.

@_date: 2013-11-14 17:03:03
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Go straight to uBTC. Humans and existing computer systems handle numbers to
the left of the decimals just fine (HK Dollars, Yen). The opposite is
untrue (QuickBooks really does not like 3+ decimal places).
     - Jeff

@_date: 2013-11-14 18:01:45
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Indeed.  The decimal place move would be an excellent time to switch.
     Jeff

@_date: 2013-11-14 19:05:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
While the sentiment is appreciated, it seems important to gently push
back a bit, and remind:
This is a decentralized currency, and we should avoid centralizing
decisions.  This is something that impacts the community at large, and
deserves input and discussion at every level.
I would suggest posting on all possible forums "proposal: switch to
uBTC, labelled as ISO prefers (XBT?)" and see what sort of discussion
is generated.  If the support is broad, it will be plain from the
responses if there is a consensus.  Perhaps everyone will agree it is
the best course, and we can make an easy change.
But we need less "core dev fiat" not more :)

@_date: 2013-11-21 10:27:30
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Who or what is /Satoshi:0.8.99/Gangnam 
Is that Matt's relay, which has reduced validity checking?

@_date: 2013-11-22 15:46:50
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [PATCH] bitcoind: whitelist nodes, 
Trying something new... a [simple] patch sent to the list, for
discussion.  Seems unlikely to be controversial.  github access is
temporarily disabled, so this is the best pull request avenue for the

@_date: 2013-11-22 16:01:51
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [PATCH, 
Easy enough to add.  There had also been requests for an IP blacklist,
which would need associated RPC/config gadgetry.

@_date: 2013-10-01 03:17:17
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoind stops responding 
Can you please describe more than "RPC stops working"?  What is your
precise RPC usage?  getwork?  getblocktemplate?  other calls?  What is
your OS?

@_date: 2013-10-01 03:26:59
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoind stops responding 
No, this is not correct at all.  RPC keepalive was present in 0.7.0,
possibly earlier.
Come on, it took a 30 second 'git checkout' session to verify this.
I was about to flame you with a "WTF is this fiction?" but it seems
true: 21eb5ada introduces this.
Unfortunately, it does so erroneously, introducing clearly buggy
behavior that did not exist with the thread-per-connection code that
provided keep-alive before commit 21eb5ada.
In my opinion, 21eb5ada half-changed the RPC code from
thread-per-connection to a worker-group model, without considering all
the consequences.

@_date: 2013-10-01 16:17:43
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoind stops responding 
What network activity was going on, during this test?  i.e. during the
call with 5.99 locktime, was bitcoind processing a block or sending a
large transaction?  There are plenty of valid reasons -- sadly -- that
the locks are held for a long time, during random network events.

@_date: 2013-10-04 11:05:29
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoind stops responding 
It's all still working around a problem unchanged since Satoshi wrote
it:  the HTTP server code paths use blocking I/O.
Amusingly, we do this through an async I/O library, which helps
facilitate SSL, but all our connections and operations are blocking.
That's why RPC was multi-threaded in part:  to work around the ugly
blocking nature of the code.  At least with multiple threads, one
thread will not stall another even if the network stalls (or a
software bug triggers a stall etc.)
Hopefully I can dive into the code and make is truly async I/O.  It
takes some work, and I'm happy if someone else steals the task, but
that's what really needs to be done.
I tried the multi-threaded approach, writing an entire boost::asio
skeleton JSON-RPC HTTP server: This is working, tested code that uses boost::asio properly.  It's
also quite a bit of LOC, and a bit messy to boot (four LOC per boost
async action and incomprehensible compiler errors in return for proper
A single thread with async I/O is likely sufficient for even heavy
uses of RPC -- since today it all goes through a big lock anyway.

@_date: 2013-10-14 14:21:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] is there a way to do bitcoin-staging? 
Quite a neat idea...
FWIW, litecoin devs are open to having litecoin be a bit of a staging
area for new bitcoin features.  Obviously there is some self-interest
there -- "we have new cool stuff first!" -- nevertheless, it is a live
test that could demonstrate problems with new features before they
land in bitcoin-stable.

@_date: 2013-10-20 20:27:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] A critique of bitcoin open source 
Agreed -- let's do it.  I nominate you to do the conversion, and we'll
put it up at github.com/bitcoin/bips.git.

@_date: 2013-10-21 10:30:22
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
This summarizes some rambling on IRC about revising the BIPS process.
Right now, the BIPS process is a bit haphazard.  Previously, BIPS were
in a git repo, and the BIPS on the wiki were locked against editing.
The BIPS editor at the time started off well, but was eventually
M.I.A.  So the BIPS "home" moved de facto to where everyone was
reading them anyway, the wiki.  They were made editable, and it became
easier to Just Pick A Number And Write One.  However, this inevitably
became a bit disorganized.  Further, there was a recent incident --
easily reverted -- where someone hopped on the wiki and started
arbitrarily editing an existing standard.
BIPs need to move back to git, in my opinion.  Standards should be
hash-sealed against corruption.  Anything less would be uncivilized,
and un-bitcoin.  However, many on IRC pointed out requiring a git pull
request might be a burdensome process, and discourage some
contributors.  The following is a sketch of an improved process.
1) BIP Draft.
Modelled after IETF drafts.  Anybody may submit a BIP draft, as long
as it meets two very loose requirements:
* At least somewhat related to bitcoin.  Note, I did not say "crypto-currency".
* Formatted similarly to existing BIPs (i.e. markdown, or whatever the
community prefers)
BIP drafts may be submitted via git pull request, or by emailing an
attachment to bips.editor at bitcoin.org.  This mirrors the Linux kernel
change submission process:  git is preferred, but there is always a
non-git method for folks who cannot or do not wish to use git or
BIP drafts are stored in git://github.com/bitcoin/bips.git/drafts/ and
are not automatically assigned a BIPS number.
2) Time passes.  Software for BIP drafts is developed, tested,
published, and publicly discussed in a typical open source manner.
3) If interest and use cases remain strong, a BIP number may be
requested, and the BIP draft is moved to
git://github.com/bitcoin/bips.git main directory.
4) If there is general consensus that the BIP should be adopted, the
BIP status is changed to "accepted."
There are no specified time limits.  Sometimes consensus about a BIP
is reached in days, sometimes 12+ months or more.  It varies widely
depending on the feature's complexity and impact.
As with the IETF, it will be q

@_date: 2013-10-21 10:34:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
Continuing.  (grumble gmail grumble)
As with the IETF, there will be a great many drafts that do not make
it to BIPS status.  That is normal, and a sign of a healthy process.
I'll volunteer as the BIPS editor.
There needs to be some backups with commit access to bips.git, in case
the BIPS editor is hit by a bus or goes crazy or on vacation.  This
can be some core devs, but I would like at least one or two folks who
are not Satoshi-client devs on the list.  Maybe Andreas, Michael G,
Alan R, and others working on non-Satoshi clients.

@_date: 2013-10-21 12:14:16
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
Correct.  And assigning BIP numbers.  Ideally a boring administrative
position.  :)
The main tensions will be in gauging whether there is sufficient
consensus and review to boost a draft into BIP/proposed status, and
then promoting a numbered BIP to the final/accepted status.

@_date: 2013-10-21 13:17:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
Added:  I'm happy with gmaxwell as BIP editor as well, as he is
apparently the current BIP-number-assigner-in-chief.  :)
The goal is to improve the process, hash-seal our specs, and create an
easy way for anyone with at least an email address to participate.

@_date: 2013-10-22 10:08:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
All that is good practice, but we should avoid adding burdensome
process that might discourage BIP writing.
Consider a distributed approach:  if you feel a draft needs more
sections or better language, submit a pull request yourself and help
community-edit the document.

@_date: 2013-10-24 06:39:24
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
Yes.  I had pointed people in IRC to Knuth's literate programming, as
an example of how we might document bitcoin.

@_date: 2013-09-08 00:13:48
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Blockchain archival 
This is all FAQ territory, and has been covered on the forums for years.
Balance-at-point-in-time is not completely trust-free, as it is a
dataset that must be bootstrapped into trust by... an earlier dataset.
 Continue this logic and you have a... chain.
There is plenty of on-going discussion on UTXO snapshotting -- UTXO
lockin for each block, or something.  This is /somewhat/ like
balance-at-point-in-time, but no one pretends it is trust-free.
The /only/ way to have a completely trust-free solution is to be able
to verify all data from genesis through $now. However, it is not
necessary for all bitcoin wallets to download and verify all those
gigabytes of data; that is what SPV mode is for.
      Jeff

@_date: 2013-09-25 10:31:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment Protocol: BIP 70, 71, 72 
BitPay experimented with QR codes in low light, restaurant and other
conditions.  QR codes become difficult to use even at 100 chars.
On the merchant side, we prefer a short URL that speaks payment
protocol if visited via bitcoin client, but will gracefully work if
scanned by a phone with zero bitcoin support -- you will simply be
redirected to a BitPay invoice page for a normal browser.
On Wed, Sep 25, 2013 at 7:59 AM, Andreas Schildbach

@_date: 2014-04-01 07:32:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] secure assigned bitcoin address directory 
Re-reading this, even with the most recent message, is still isn't
clear _precisely_ how your technology works, or why it is better than
namecoin.  User profiles (and distributed ledgers) need to reflect the
latest updates, and a stream of updates of over time is precisely what
bitcoin technology secures.
Keys expire or are compromised, and the public ledger needs to reflect
that.  There is a lot of computer science involved in making sure the
public ledger you see is not an outdated view.  A log-like stream of
changes is not the only way to do things, but other methods need less
hand-wavy details (show the code) before they are well recognized as

@_date: 2014-04-01 18:03:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Finite monetary supply for Bitcoin 
Similarly, everyone knows if you multiply both sides by zero, the
result is always a true statement.

@_date: 2014-04-02 09:08:51
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Okay, time to bring up bitcoin/bitcoin 
At first, this is a poor choice of URL.
But it really looks like a phishing attempt that no one should visit.

@_date: 2014-04-03 22:38:09
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
Discussion of whether you should or should not use SSS is separate
from whether you should or should not write a BIP.
If people are using SSS in the field, it is better to write a BIP than
not.  Informational BIPs describing existing practice can be useful.

@_date: 2014-04-04 09:19:33
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Finite monetary supply for Bitcoin 
+1 for all-numeric, easily computer parse-able without a lookup table,
and naturally sorts correctly in a lexicographic sort.
English (or any language) should never be in a date format, on a computer.

@_date: 2014-04-04 09:47:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Draft BIP for seamless website 
This is precisely why SINs use a different version byte from bitcoin
addresses.  There should never be any confusion between money/payments
and identity.

@_date: 2014-04-07 23:28:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Draft BIP for seamless website 
This is quite true.  I said the same about KryptoKit.  Incredibly cool
to do bitcoin + PGP in client...  but ultimately plugins reach 0.01%
of the user population.

@_date: 2014-04-07 23:44:14
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
Being Mr. Torrent, I've held open the "80% serious" suggestion to
simply refuse to serve blocks older than X (3 months?).
That forces download by other means (presumably torrent).
I do not feel it is productive for any nodes on the network to waste
time/bandwidth/etc. serving static, ancient data.  There remain, of
course, issues of older nodes and "getting the word out" that prevents
this switch from being flipped on tomorrow.

@_date: 2014-04-08 11:19:32
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Draft BIP for seamless website 
-You- are irrelevant, as am I.  We don't mind such things.
But based on personal observations as well as Mozilla and other
browser data, the user populace in general does not install plugins.
Flash is the LONE exception to that ironclad general rule.
PS. Google Earth is not a plugin :)

@_date: 2014-04-18 10:26:17
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] mid-term bitcoin security (Re: Warning 
And that is certainly how BitPay works today, including the language used.

@_date: 2014-04-23 00:22:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Double-spending unconfirmed transactions 
A lot of these "should the network..." questions depend on business
rules and business models.
Even if a 0-conf double spend is possible in a given business
situation, the incentives quite often are aligned to avoid
double-spend attempts in any case.  Any physical good being shipped
can "accept" the transaction, and then wait for confirmations before
shipping.  Digital goods might be accepted for 0-conf payment from
users who have a good history with the merchant.  The 0-conf attacker
will tend to /not/ be a regular user, and also have many other typical
markers of a fraudster.
The subset of (a) double-spend attackers making a one-time or
short-term attack on (b) a naive merchant with mistuned business rules
will tend to be very small.

@_date: 2014-04-26 12:03:31
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP32 "wallet structure" in use? Remove 
It is very young in bitcoin's life.  We don't know what features will
work out best, or need to be radically changed after initial
deployment in the field.
Loose coordination is good.  Good ideas will spread on their own.
Users will demand compatibility with certain features, and fail to
care incompatibilities in other features.
Tight interoperability at this stage is too confining.

@_date: 2014-04-27 21:37:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] New BIP32 structure for P2SH multisig 
Yes.  That solution is already implemented in a few wallets.

@_date: 2014-08-05 11:45:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] How to create a pull tester JAR 
Thanks for posting that (and implicitly archiving the knowledge).  Anything
that makes test improvement easier is welcomed.

@_date: 2014-08-05 13:48:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] deterministic transaction expiration 
Glad this was brought up.
Transaction expiration is something that I have wanted to see happen in
bitcoin for a long, long time.  The user experience of unconfirming
transactions setting around in limbo is just horrible.  Bitcoin software by
necessity has gotten better about attaching fees so this sort of behavior
is uncommon, but that does not eliminate the problem.
Of course, we cannot presume that a transaction will truly disappear -- The
Internet Never Forgets -- but given a bit of mempool adjusting, we can
achieve the next best thing:  the majority of the network "forgets" the
transaction and becomes willing to relay a respend of some or all of the
inputs.  This uses existing client logic where the client must rebroadcast
a transaction until it is confirmed.
In general, if a transaction has not made it into a block within 144*X
blocks, there is _some_ reason it is getting rejected by the miners.
The mempool janitor is a garbage collector design.  This is inferior to the
"superblock" model described at
   Other models can also
achieve similar results.
There are a lot of issues tied together here:  transaction expiration, the
desire to cap the mempool ram usage, scalability, DoS prevention, ...
mempool ties a lot together.

@_date: 2014-08-05 15:08:14
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] deterministic transaction expiration 
I feel like a lot of this will be driven by implementation, and costs of
changing the implementation.  Additional look-backs are of course doable,
but they incur some disk I/O costs.  The fields available in memory for
each mempool TX are
    uint256 tx_hash; // hash of next field
    CTransaction tx;
    int64_t nFee; // Cached to avoid expensive parent-transaction lookups
    size_t nTxSize; // ... and avoid recomputing tx size
    int64_t nTime; // Local time when entering the mempool
    double dPriority; // Priority when entering the mempool
    unsigned int nHeight; // Chain height when entering the mempool
As a first pass, we may prune the mempool without additional db lookups
quite easily based on time criteria.  Or, additional in-memory indexes may
be constructed to maintain hashes ordered by priority/fees.
Those techniques seem likely to be attempted before resorting to looking
back two or three TXs deep at coin age -- which I admit is an interesting

@_date: 2014-08-05 15:36:17
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] deterministic transaction expiration 
"reliably die off from mempools" leads into the land of "tightly
synchronizing memory pools across the network" which is a problem of...
large scope and much debate.  :)
For the moment, simply capping the mempool's size at each local node is a
much more reachable goal.  Capping, then, implies some culling policy.  In
general, bitcoind Tx mempool size is rather open ended, and that needs
sorting out.

@_date: 2014-08-06 08:55:51
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] deterministic transaction expiration 
...and existing users and uses of nLockTime suddenly become worthless,
breaking payment channel refunds and other active uses of nLockTime.
You cannot assume the user is around to rewrite their nLockTime, if it
fails to be confirmed before some arbitrary deadline being set.

@_date: 2014-08-06 11:08:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] deterministic transaction expiration 
...because nLockTime is the exact opposite of expiration.  A locked TX
begins life invalid, and becomes valid (not-expired) after nLockTime passes.
A new field containing expiration time would work.

@_date: 2014-08-06 12:15:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] deterministic transaction expiration 
A fork is not necessarily required, if you are talking about information
that deals primarily with pre-consensus mempool behavior.  You can make a
"network TX" with some information that is digitally signed, yet discarded
before it reaches miners.

@_date: 2014-08-06 13:24:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] deterministic transaction expiration 
That won't necessarily work through large reorgs.  You don't want to create
a situation where a miner cannot mine a previously mined transactions.

@_date: 2014-08-07 23:18:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Miners MiTM 
You don't necessarily need the heavy weight of SSL.
You only need digitally signed envelopes between miner and pool[1].
[1] Unless the pool is royally stupid and will somehow credit miner B, if
miner B provides to the pool a copy of miner A's work.

@_date: 2014-08-07 23:38:44
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] NODE_EXT_SERVICES and advertising related 
Link: It is not necessary to build all functionality into bitcoind, to form
a decentralized network. BitPay's insight open source block explorer
API project requires, and runs on top of, bitcoind. Therefore, at the
same IP address as bitcoind, other services are made available to the
public (scriptPubkey queries, other added-value queries). This results
in a decentralized network of "anyone running a full node and an
insight server", as a subset of the whole P2P net.  One then does not
need to trust BitPay's insight server, but may query any number of
insight servers from multiple operators, and survey the results.
Obviously, we want to build this in a generic, vendor-neutral way.  As
such, NODE_EXT_SERVICES is advertised via the "addr" P2P message.
Nodes that recognize the NODE_EXT_SERVICES bit may connect to that
node, query a services list via "getextsrv" P2P message, and then take
further action based on the results.  The results are quite
service name, service port (or -1 if undefined), list of string
key/value attribs
Services may only advertise added services if and only if the external
services are at the same IP address that is being advertised.
This is not a fully baked proposal by any means, but more of a trial
balloon to get discussion moving.
There is no need to implement all services inside bitcoind...

@_date: 2014-08-08 07:22:46
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] NODE_EXT_SERVICES and advertising related 
This is not a generic "I run a website!" advertisement feature.
NODE_EXT_SERVICES is tightly focused on services that exist
if-any-only-if a P2P bitcoin node (bitcoind) is reachable via the same
advertised address.
You may usefully create overlay networks of specialized services.
On Fri, Aug 8, 2014 at 6:41 AM, Christian Decker

@_date: 2014-08-08 07:33:37
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] NODE_EXT_SERVICES and advertising related 
It would be wrong to add NODE_INSIGHT, NODE_ELECTRUM_SERVER, etc. bits
even though you do have useful bitcoin-related APIs that exist on the
same system as bitcoind.

@_date: 2014-08-08 08:04:16
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] NODE_EXT_SERVICES and advertising related 
Yes, that is the one change I am still pondering:  adding categories
(classes), rather than one single bit.
Thus the modified proposal would become:
- eliminate NODE_EXT_SERVICES
- for a class of services, such as insight w/ added blockchain indexes
& queries, add NODE_EXT_INDEXED_CHAIN
- for another class of services, add NODE_EXT_xxxx
- Re-use the same P2P message and structure (CExtService,
"extservices" P2P message) for all NODE_EXT_xxx classes.
This preserves vendor/API neutrality, while saving effort on the part
of clients seeking these services.  The point about service discovery
necessitating some node walking is valid, which makes categories
somewhat attractive.
"Having the service run on some arbitrary other port isn't
particularly useful, IMO" --  A statement disproved by reality.
Multi-port is the method most commonly found in the field today.
Logically so, because it is the easiest to deploy:
* The most likely setup TODAY is multi-daemon: bitcoind + your own software
* The most likely configuration for multi-daemon is self-evidently
multi-port (versus two services appearing on the same port)
It is quite useful, and indeed, the most likely setup to be found in operation.

@_date: 2014-08-08 08:06:16
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] NODE_EXT_SERVICES and advertising related 
Seconded.  Command plug-ins and such seem like an idea worth exploring.
We don't need to shove everything into bitcoind.

@_date: 2014-08-08 08:11:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] NODE_EXT_SERVICES and advertising related 
Generally agreed, though for ZMQ it is a bit different than a P2P service.
IMO, ZMQ really wants to be a plug-in that registers some internal
signals.  It wants to capture the precise points where a block was
accepted internally.  PR  tries to lead by example:
A P2P service would be a slightly different sort of plug-in.

@_date: 2014-08-08 08:15:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] NODE_EXT_SERVICES and advertising related 
getutxos is a special case, since we already maintain that index as
part of normal operation.
While I dislike some aspects of getutxos (covered elsewhere), if
merged, it would be more appropriate as a special case to keep
getutxos fully internal to bitcoind for implementation reasons.

@_date: 2014-08-08 14:13:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] deterministic transaction expiration 
It cannot be assumed that transaction creation time and transaction
publish-to-outside-world time are the same, even though they often

@_date: 2014-08-08 14:21:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Miners MiTM 
gmaxwell noted on IRC that enabling TLS could be functionally, if not
literally, a DoS on the pool servers.  Hence the thought towards a
more lightweight method that simply prevents client payout redirection
+ server impersonation.

@_date: 2014-08-10 10:20:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Synchronization: 19.5 % orphaned blocks 
This issue is being worked on, under the category of "headers first
Until that is finished, it is recommended that you download
bootstrap.dat via torrent:

@_date: 2014-08-18 13:19:15
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Outbound connections rotation 
Simply by observing timing from sufficiently geo-graphically and
network-ly dispersed nodes, you may deduce the original broadcaster of
a transaction.  Rotating peers doesn't help.
That said, periodic rotation can be helpful.  Every 2-10 minutes is excessive.
On Mon, Aug 18, 2014 at 12:46 PM, Ivan Pustogarov

@_date: 2014-08-19 08:02:37
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Reconsidering github 
It would be nice if the issues and git repo for Bitcoin Core were not
on such a centralized service as github, nice and convenient as it is.
To that end, I note that Linux does its own git repo, and now requires
2FA: As a first step, one possibility is putting the primary repo on
bitcoin.org somewhere, and simply mirroring that to github for each

@_date: 2014-08-19 19:40:39
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: Encrypt bitcoin messages 
Encryption is of little value if you may deduce the same information
by observing packet sizes and timings.

@_date: 2014-08-19 20:21:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: Encrypt bitcoin messages 
Hardly.  For example, when a new block arrives on the network, a
single observer at a single location may obtain a binary "likely|not
bitcoin protocol" decision from a spike in usage correlated with
sudden, global network activity after a period of inactivity.  I'll
not detail all such metrics.

@_date: 2014-12-10 10:52:59
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] ACK NACK utACK "Concept ACK" 
Concept ACK -> like the idea; the code may need rewriting (or haven't

@_date: 2014-12-15 10:20:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Recent EvalScript() changes mean 
This is my opinion as well.  In the Linux kernel, we often were faced with
a situation where you have a One Big File driver with > 1MB of source
code.  The first step was -always- raw code movement, a brain-dead breaking
up of code into logical source code files.
Refactoring of data structures comes after that.
While not always money-critical, these drivers Had To Keep Working.  We had
several situations where we had active users, but zero hardware access for
debugging, and zero access to the vendor knowledge (hardware documentation,
engineers).  Failure was not an option.  ;p
Performing the dumb Break Up Files step first means that future, more
invasive data structures are easier to review, logically segregated, and
not obscured by further code movement changes down the line.  In code such
as Bitcoin Core, it is important to think about the _patch stream_ and how
to optimize for reviewer bandwidth.
The current stream of refactoring is really a turn-off in terms of
reviewing, sapping reviewer bandwidth by IMO being reviewer-unfriendly.  It
is a seemingly never-ending series of tiny
Some change is in order, gentlemen.

@_date: 2014-12-15 14:35:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Recent EvalScript() changes mean 
"That's exactly what was done except it wasn't"
Yes, in micro, at the pull request level, this happened
* Code movement
* Refactor
At a macro level, that cycle was repeated many times, leading to the
opposite end result:  a lot of tiny movement/refactor/movement/refactor
producing the review and patch annoyances described.
It produces a blizzard of new files and new data structures, breaking a
bunch of out-of-tree patches, complicating review quite a bit.  If the vast
majority of code movement is up front, followed by algebraic
simplifications, followed by data structure work, further patches are easy
to review/apply with less impact on unrelated code.
The flow of patches into the tree over time should be examined.  Simply
tagging patches as movement-only does not address the described problem at

@_date: 2014-12-15 16:54:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Recent EvalScript() changes mean 
If code movement is not compressed into a tight time window, code movement
becomes a constant stream during development.  A constant stream of code
movement is a constant stream of patch breakage, for any patch or project
not yet in-tree.  The result is to increase the work and cost on any
contributor whose patches are not immediately merged.
For the record, since this is trending reddit, I __do__ support the end
result of 0.10 refactoring, the work towards the consensus lib.
My criticism is of a merge flow which _unintentionally_ rewards only
certain types of patches, and creates disincentives for working on other
types of patches.

@_date: 2014-12-16 12:59:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Open development processes and reddit charms 
It can be useful to review open source development processes from time to
time.  This reddit thread[1] serves use both as a case study, and also a
moment of OSS process introduction for newbies.
*Dirty Laundry*
When building businesses or commercial software projects, outsiders
typically hear little about the internals of project development.  The
public only hears what the companies release, which is prepped and
polished. Internal disagreements, schedule slips, engineer fistfights are
all unseen.
Open source development is the opposite.  The goal is radical
transparency.  Inevitably there is private chatter (0day bugs etc.), but
the default is openness.  This means that is it normal practice to "air
dirty laundry in public."  Engineers will disagree, sometimes quietly,
sometimes loudly, sometimes rudely and with ad hominem attacks.  On the
Internet, there is a pile-on effect, where informed and uninformed
supporters add their 0.02 BTC.
Competing interests cloud the issues further.  Engineers are typically
employed by an organization, as a technology matures.  Those organizations
have different strategies and motivations.  These organizations will
sponsor work they find beneficial.  Sometimes those orgs are non-profit
foundations, sometimes for-profit corporations.  Sometimes that work is
maintenance ("keep it running"), sometimes that work is developing new,
competitive features that company feels will give it a better market
position.  In a transparent development environment, all parties are
hyperaware of these competing interests.  Internet natterers painstakingly
document and repeat every conspiracy theory about Bitcoin Foundation,
Blockstream, BitPay, various altcoin developers, and more as a result of
these competing interests.
Bitcoin and altcoin development adds an interesting new dimension.
Sometimes engineers have a more direct conflict of interest, in that the
technology they are developing is also potentially their road to instant
$millions.  Investors, amateur and professional, have direct stakes in a
certain coin or coin technology.  Engineers also have an emotional stake in
technology they design and nurture.  This results in incentives where
supporters of a non-bitcoin technology work very hard to thump bitcoin.
And vice versa.  Even inside bitcoin, you see "tree chains vs. side chains"
threads of a similar stripe.  This can lead to a very skewed debate.
That should not distract from the engineering discussion.  Starting from
first principles, Assume Good Faith[2].  Most engineers in open source tend
to mean what they say.  Typically they speak for themselves first, and
their employers value that engineer's freedom of opinion.  Pay attention to
the engineers actually working on the technology, and less attention to the
noise bubbling around the Internet like the kindergarten game of grapevine.
[2] Being open and transparent means engineering disagreements happen in
public.  This is normal.  Open source engineers live an aquarium life[3].
[3] *What the fork?*
In this case, a tweet suggests consensus bug risks, which reddit account
"treeorsidechains" hyperbolizes into a dramatic headline[1].  However, the
headline would seem to be the opposite of the truth.  Several changes were
merged during 0.10 development which move snippets of source code into new
files and new sub-directories.  The general direction of this work is
creating a "libconsensus" library that carefully encapsulates consensus
code in a manner usable by external projects.  This is a good thing.
The development was performed quite responsible:  Multiple developers would
verify each cosmetic change, ensuring no behavior changes had been
accidentally (or maliciously!) introduced.  Each pull request receives a
full multi-platform build + automated testing, over and above individual
dev testing.  Comparisons at the assembly language level were sometimes
made in critical areas, to ensure zero before-and-after change.  Each
transformation gets the Bitcoin Core codebase to a more sustainable, more
reusable state.
Certainly zero-change is the most conservative approach. Strictly speaking,
that has the lowest consensus risk.  But that is a short term mentality.
Both Bitcoin Core and the larger ecosystem will benefit when the "hairball"
pile of source code is cleaned up.  Progress has been made on that front in
the past 2 years, and continues.   *Long term*, combined with the
"libconsensus" work, that leads to less community-wide risk.
The key is balance.  Continue software engineering practices -- like those
just mentioned above -- that enable change with least consensus risk.  Part
of those practices is review at each step of the development process:
social media thought bubble, mailing list post, pull request, git merge,
pre-release & release.  It probably seems chaotic at times.  In effect,
git[hub] and the Internet enable a dynamic system of review and feedback,
where each stage provides a check-and-balance for bad ideas and bad
software changes.  It's a human process, designed to acknowledge and handle
that human engineers are fallible and might make mistakes (or be
coerced/under duress!).  History and field experience will be the ultimate
judge, but I think Bitcoin Core is doing good on this score, all things
At the end of the day, while no change is without risk, version 0.10 work
was done with attention to consensus risk at multiple levels (not just
short term).
*Technical and social debt*
Working on the Linux kernel was an interesting experience that combined
git-driven parallel development and a similar source code hairball.  One of
the things that quickly became apparent is that cosmetic patches,
especially code movement, was hugely disruptive.  Some even termed it
anti-social.  To understand why, it is important to consider how modern
software changes are developed:
Developers work in parallel on their personal computers to develop XYZ
change, then submit their change "upstream" as a github pull request.  Then
time passes.  If code movement and refactoring changes are accepted
upstream before XYZ, then the developer is forced update XYZ -- typically
trivial fixes, re-review XYZ, and re-test XYZ to ensure it remains in a
known-working state.
Seemingly cosmetic changes such as code movement have a ripple effect on
participating developers, and wider developer community.  Every developer
who is *not* immediately merged upstream must bear the costs of updating
their unmerged work.
Normally, this is expected.  Encouraging developers to build on top of
"upstream" produces virtuous cycles.
However, a constant stream of code movement and cosmetic changes may
produce a constant stream of disruption to developers working on
non-trivial features that take a bit longer to develop before going
upstream.  Trivial changes are encouraged, and non-trivial changes face a
binary choice of (a) be merged immediately or (b) bear added re-base,
re-view, re-test costs.
Taken over a timescale of months, I argue that a steady stream of cosmetic
code movement changes serves as a disincentive to developers working with
upstream.  Each upstream breakage has a ripple effect to all developers
downstream, and imposes some added chance of newly introduced bugs on
downstream developers.  I'll call this "social debt", a sort of technical
debt[4] for developers.
[4] As mentioned above, the libconsensus and code movement work is a net gain.
The codebase needs cleaning up.  Each change however incurs a little bit of
social debt.  Life is a little bit harder on people trying to get work into
the tree.  Developers are a little bit more discouraged at the busy-work
they must perform.  Non-trivial pull requests take a little bit longer to
approve, because they take a little bit more work to rebase (again).
A steady flow of code movement and cosmetic breakage into the tree may be a
net gain, but it also incurs a *lot* of social debt.  In such situations,
developers find that tested, working out-of-tree code repeatedly stops
working *during the process of trying to get that work in-tree*.  Taken
over time, it discourages working on the tree.  It is rational to sit back,
*not* work on the tree, let the breakage stop, and then pick up the pieces.
*Paradox Unwound*
Bitcoin Core, then, is pulled in opposite directions by a familiar
problem.  It is generally agreed that the codebase needs further
refactoring.  That's not just isolated engineer nit-picking.  However, for
non-trivial projects, refactoring is always anti-social in the short term.
It impacts projects other than your own, projects you don't even know
about. One change causes work for N developers.  Given these twin opposing
goals, the key, as ever, is finding the right balance.
Much like "feature freeze" in other software projects, developing a policy
that opens and closes windows for code movement and major disruptive
changes seems prudent.  One week of code movement & cosmetics followed by 3
weeks without, for example.  Part of open source parallel development
is *social
signalling*:  Signal to developers when certain changes are favored or not,
then trust they can handle the rest from there.
While recent code movement commits themselves are individually ACK-worthy,
professionally executed and moving towards a positive goal, I think the
project could strike a better balance when it comes to disruptive cosmetic
changes, a balance that better encourages developers to work on more
involved Bitcoin Core projects.

@_date: 2014-12-20 16:26:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Area of Focus 
Getting back to the original topic...
I would recommend first taking a look at how the current tests are built
(via autoconf/automake) in src/test.  There are several surfaces to test,
RPC, REST, P2P, internal unit tests, and more.  Then, Travis applies a
second level of testing via the bitcoinj-based regression tests.
Some automated tests that operate at the Qt level would be interesting.  In
general, the current tests only scratch the surface of what Needs To Be
Tested...  but part of figuring out a good test is (a) knowing bitcoin and
(b) knowing the current test regimes.
Join  IRC and ask questions.  Read the bitcoin wiki.

@_date: 2014-02-04 09:43:31
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh, 
Cryptographers smoke... hash, right?
(couldn't resist)

@_date: 2014-02-12 12:13:03
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with 
On Wed, Feb 12, 2014 at 10:12 AM, Rune Kj?r Svendsen
Yes, that is one proposal:  But it is not a complete solution for all transaction types.

@_date: 2014-02-21 01:09:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting 
[Meta: "Bitcoin Core" is the newfangled branding of bitcoind /
Bitcoin-Qt reference implementation, in case you wondering.]
Several sites, including BitPay, use bitcoind outside the standard
role of wallet software.  bitcoind can be used purely for payment
network access and management.  I call this the "border router" role.
Upcoming version 0.9 will feature the ability to disable the bitcoind
wallet at compile time or runtime. This permits a more optimized
border router profile, reducing process size by 40-200MB according to
some reports.
Recent IRC discussion have floated a rough proposal for a wallet
next-step:  Running the Bitcoin Core wallet as a separate process, a
separate binary, from the blockchain engine.  The wallet process would
communicate with the blockchain engine using existing RPC and P2P
channels, becoming a real SPV client.  This accomplishes a
longstanding security goal of sandboxing away wallet keys and
sensitive data from the network-exposed P2P engine, in a separate
process, among other benefits.
Simple forking was explored a bit.  I did some hacking in that
direction, as it seemed potentially lightweight and somewhat easy to
me:   fork+pipe is fine
for Linux and OSX/BSD.  However, Windows requires an exec-like
solution to create a new process.  MSDN does give us a Unix-pipe-like
solution:  Others pointed to boost interprocess communication APIs, which come
with their own set of caveats.  Such a solution would involve a brand
new IPC protocol, and lots of brand new glue code.
Separate programs seems better.  Windows forces us to achieve process
separation via exec-like method.  We already have IPC: RPC + P2P.
Modern OS's make localhost sockets just about as fast as other IPCs
methods.  Linux, at least, employs zero-copy for localhost sockets in
many situations, similar to the kernel's pipe tricks.
Pieter has been working on headers-first sync:
  Moving along this
wallet/blockchain engine split requires upping the review&test
bandwidth on Pieter's PRs, such as
Unsure how much of the separate-binary discussion Gavin saw, so cc'd
for emphasis.

@_date: 2014-02-21 01:50:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting 
RE "doesn't buy you anything"   Today, when unlocked, plaintext
private keys reside in the same address space as the blockchain engine
(BCE).  Process separation increases the difficulty of accessing key
data from the BCE, even presuming a normal, no-chroot, same-uid,
parent-child process relationship.  The attack surface is clearly
changed from "one buffer overflow can touch this data."
Regardless, the split makes sense given existing modularity and coding
directions.  I wouldn't micro-focus on the "sandbox" word.

@_date: 2014-02-21 21:08:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting 
On Fri, Feb 21, 2014 at 8:04 PM, Dustin D. Trammell
You mean running multiple wallets simultaneously?  Agreed.
Multiple wallets, used serially, works fine today.  I manage multiple
wallets using symlink replacement.

@_date: 2014-02-24 11:03:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release 
An update in forthcoming 0.9 release includes a change to make
OP_RETURN standard, permitted a small amount of metadata to be
attached to a transaction:
There was always going to be some level of controversy attached to
this.  However, some issues, perceptions and questions are bubbling
up, and it seemed fair to cover them on the list, not just IRC.
1) FAQ:  Why 80 bytes of data?  This is the leading programmer
question, and it was not really documented well at all.  Simple
answer:  2x SHA256 or 1x SHA512, plus some tiny bit of metadata.  Some
schemes are of the nature "BOND" rather than just plain hash.
A common IRC proposal seems to lean towards reducing that from 80.
I'll leave it to the crowd to argue about size from there. I do think
regular transactions should have the ability to include some metadata.
2) Endorsement of chain data storage.  Listening to bitcoin conference
corridor discussions, reading forum posts and the occasional article
have over-simplified the situation to "core devs endorse data storage
over blockchain!  let me start uploading my naughty movie collection!
IM over blockchain, woo hoo!"
Nothing could be further from the truth.  It's a way to make data
idea.  MasterCoin and other projects were doing -even worse- things,
such as storing data in forever-unspendable TX outputs, bloating the
UTXO for eternity.
It seems reasonable to have a release note to this effect in the 0.9
release announcement, IMO.

@_date: 2014-02-24 11:33:27
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release 
(fscking 'send' hotkey in GMail)
Not really - a MasterCoin or JPEG image transaction is not a "regular"

@_date: 2014-02-24 12:10:26
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release 
This PR reduces the size to 40 bytes:
(Note - this is not intended to close the discussion... please do keep
sending in feedback)

@_date: 2014-02-26 17:51:32
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Fee drop 
Just pushed out a mempool janitor change to
   The goal was to create
a simple bolt-on change, and /not/ rewrite the mempool code.
I'll be running some metrics on what does and does not get into the
mempools of my public nodes for 48 hours, ending Friday ~midnight EST.

@_date: 2014-01-15 15:44:17
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Stealth Addresses 
"static address" seems like a reasonable attempt at describing intended

@_date: 2014-01-15 18:07:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Stealth Addresses 
"Routing address" is pretty good too.  Unsure whether the synergy and
familiarity with bank routing numbers improves the situation, or

@_date: 2014-01-17 15:53:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin Core 0.9rc1 release schedule 
BitPay sure would like to see CPFP in upstream.
I think the main hurdle to merging was that various people disagreed
on various edge case handling and implementation details, but no
fundamental objections.

@_date: 2014-01-18 21:53:09
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin Core 0.9rc1 release schedule 
There's a reason why luke-jr's pull request for CPfP remains open.
There is general agreement that it appears to be useful.  CPfP works
to close the mismatch between how bitcoin transaction fees are
attached by the sender, versus modern economic situations where the
receiver is willing to pay a fee.

@_date: 2014-01-27 23:29:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Extension for BIP-0070 to support 
Yes, recurring payments and subscriptions is a frequently-requested
feature.  It needs a new BIP.  Here is an outline:
The situation is somewhat analogous to HTML5 local storage.  The
remote (merchant) wants to initiate a persistent behavior.
Note: This is ONE

@_date: 2014-01-27 23:43:58
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Extension for BIP-0070 to support 
Yes, recurring payments and subscriptions is a frequently-requested
feature.  It needs a new BIP.  Here is an outline:
The situation is somewhat analogous to HTML5 local storage.  The remote
(merchant) wants to initiate a persistent behavior.  This is bitcoin, so we
have a "push" model for payment, and the user has complete control.  The
merchant can, at most, send a "subscription request."  The user is
responsible for making on-time payments after that point.
Centralized services like coinbase.com or blockchain.info will have an easy
time of it.  An automated program on their backend, sending payments as
needed, is easy and direct.
More inventive services might employ multisig transactions, generating and
signing one signature of a TX, then sending that TX to the human for
further signing and publishing.  A few competing vendors could offer bots
that provide this signing service.
Decentralized, standalone wallet clients will be somewhat troublesome.  We
can store a local subscription request, and send recurring payments...  if
the wallet app is running.  If not, the user will be missing payments, that
perhaps they intended to make (rent!).
Each of these solutions can be cancelled at any time by the user.  As such,
a courtesy "subscription cancelled" message sent to the merchant is
recommended.  User controls the usage of their money at all times, the way
things should be.
And finally, you do not want to make it /too easy/ to send money over and
over again.  From a human-interface perspective, a textual reminder to send
money might be preferred over actual recurring payment automation: reminder
email + manual spend inserts a bit of additional human thought and review
into the process, with all that entails.

@_date: 2014-01-28 01:48:42
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Extension for BIP-0070 to support 
Let's keep fund raising off this mailing list, please.  PS bounties don't
On Tue, Jan 28, 2014 at 1:08 AM, Odinn Cyberguerrilla <

@_date: 2014-01-30 09:51:24
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP70: PaymentACK semantics 
Is this truly the intent?  That the merchant/processor takes full
responsibility for getting the TX confirmed?
It is within the customer's economic incentive -- and right as a free
person -- to work to get their transaction relayed to the network and
confirmed in parallel with whatever the merchant is doing.
BIP 70 states that the customer broadcasts the transaction, in
addition to sending the Payment message.

@_date: 2014-07-13 22:51:50
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Self-dependency transaction question... 
Correct.  A TX will not reference a later TX in the same block (or itself).
This would be a good invalid-block test to add to the test suite.  Any

@_date: 2014-07-14 13:16:12
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin Protocol Specification 
Firstly, it is an excellent document, and it should be useful in
educating others.
I do agree that "specification" is not a good word to use.

@_date: 2014-07-15 04:00:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
Proxying another's idea, from CoinSummit.
The request:   It would be useful to limit the lifetime of a bitcoin
address.  Intentionally prevent (somehow) bitcoins being sent to a
pubkey/pkh after the key expires.
You could append "don't ["permit"|confirm] after X [time|block]"  to
the address I suppose.  The metadata would not be digitally signed,
but it would be hash-sealed.  As "address" is a client-side notion,
wallet clients would be the ones enforcing such a rule.
Bitcoin protocol of course knows about keys, and key expiration is a
well known and useful concept in public key cryptography.  The best
insertion point in the protocol for key expiration is an open
question, if it's even a good idea at that level at all.  Some flag
"no more TxOuts exactly like this [after X block?]"?
I readily admit I don't have good answers, but it does seem valuable IMO to
* Prevent users from accidentally sending to an "expired" TxOut/pkh.
This happens in the field.
* Discourage address reuse
* Enable sites that generate lots of keys to rotate ancient keys off
their core systems.  (HD wallets mitigate this)

@_date: 2014-07-15 04:23:40
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
There are major gaps that the payment protocol doesn't cover.
There are several deployed use cases where you are provided/request an
address, an API provides one, and one or more incoming payments arrive
as the user sends them over minutes/hours/days/weeks.

@_date: 2014-07-15 10:02:40
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
BIP70 does not work well for unknown number of future payments of
unknown, unpredictable value.

@_date: 2014-07-15 11:11:25
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
Sure it's valid.  However, few users will appreciate "you ignored my
deposit" as a feature.
Payment protocol just doesn't well the use cases of,
* an on-going payment stream from, e.g. Eligius to coinbase
* deposit addresses and deposit situations

@_date: 2014-07-15 11:17:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
Unicode guarantees that null-terminated strings still work.  U+0000
terminates a unicode (or C) string.  strlen() gets the string byte
count.  mbstowcs() gets the character count.
Whitespace can be problematic, but should be allowed.  Control
characters should be filtered.  Emoticons probably cannot be filtered
without substandard approaches such as character blacklists, a road
you do not want to travel.
(all this is simply standard practice)

@_date: 2014-07-15 11:35:03
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
This is a well known problem of BIP 70 from day one, because BIP 70
functions at too-low a level.
What needs to be negotiated between parties is a _payment
relationship_ that exchanges HD wallet data. This is what is necessary
to establish and maintain an ongoing payment relationship.
BIP 70 is focused on singular payments with specific outputs and
values.  BIP 70 wants to transmit an actual transaction.  That does
not fit the use cases described.
Adding in a hack that makes zero-valued outputs behave different does
not change the granularity at which BIP 70 operates.
This is a key reason why I have not just ACK'd the BIP 70 subscription
stuff.  Subscriptions are another example of a longer term payment
relationship.  For such case, you want to exchange HD wallet payment
details.  You do not send or receive outputs.  You might not send
transactions directly to the party (coming instead asynchronously &
unpredictably via blockchain).
BIP 70 marries the _relationship_ with payment transmittal, and the
subscription extension does not change that.
Our "contract" language must get a bit smarter, and include HD wallet
payment details, not necessarily focus on outputs.

@_date: 2014-07-15 11:53:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP 38 NFC normalisation issue 
On whitespace:  Security UX testing I've seen shows it is mentally
easier for some users to memorize and use longer passphrases, if they
are permitted spaces.  I've not seen anything written on use of
tabs/NLs/FFs in passphrases.
I can see the logic of some systems, that convert \s+ into ' ' for
purposes of password hashing, even though that might frustrate a
security nerd or two.
I do think control characters should be filtered.
On Tue, Jul 15, 2014 at 11:32 AM, Andreas Schildbach

@_date: 2014-07-15 11:55:43
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
Actually, and this is key, there _are_ reasons why deposits might not
be able to use PaymentRequests.  Payments happen even when
wallets/computers are offline.
If you have negotiated HD wallet details, you can use a new address
every time, as mentioned.

@_date: 2014-07-16 08:11:39
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Draft BIP for geutxos message 
Thanks Mike.  The BIPS process is ideally an implementation & draft BIP,
like IETF RFCs.  Thanks for being a model citizen.  :)  Having an idea is
good; having an implementation is better.
Reviewing the code at the pull request, it appears OK, and I did give it a
quick test.  I have a few minor nits that I'll put in the PR, that are not
worth mentioning here.
Being able to query UTXOs is obviously useful.  Many existing applications
have been built on top of bitcoind (gettxout RPC), insight and other
existing tools that make this query available.  This is not a new feature.
That effectively reduces our evaluation to
     1. Why implement in P2P protocol, versus RPC or external API?
Neither your pull request nor email addresses this much.  I do understand
your app uses "getutxos"  But it is entirely fair and reasonable to ask why
all bitcoind users should carry this feature.
Turning to the protocol itself, "getutxos" does what is expected:  Return
that node's view of the UTXO set.  This bring us to the main issue I and
others raised in the pull request,
     2. This view of UTXO is entirely untrusted, may be malicious or
wrong.  Why export potentially dangerous information to victims?  What are
the consequences to the victims of receiving targeted, maliciously wrong
returned data?
Let us assume for the sake of progress that  is answered to
satisfaction.  In my view, the BIP (and implementation? haven't looked at
lighthouse) is missing
     3. An explicit solution to If one implements your BIP in a naive manner -- simply find a node, and
issue a single query -- they are dangerously exposed to malicious
information.  The BIP should describe this major security issue, and
describe at least one method of solving it (ditto implementation, if
lighthouse has not already solved this).
Comparison between this and BIP 35 (mempool command) are not apt, as miners
and full nodes treat "mempool" returned data just like any other randomly
solicited "tx" command on the network.  Unlike "mempool" cmd, this
"getutxos" cmd proffers post-verification trusted data.
I fear that this addition will lead to people building insecure apps, when
they could have just as easily queried a
slightly-more-trusted-than-just-a-random-P2P-peer network of N bitcoind's
or N Insight servers running somewhere (akin to Electrum servers).

@_date: 2014-07-16 10:25:17
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Draft BIP for geutxos message 
On the specific issue I raised, the BIP only says "Querying multiple
nodes and combining their answers can be a partial solution to this"
which is not very helpful advice.  That's a partial answer to my
question  with zero response for question This sort of thing really needs a warning label like "use only if you
don't have a trusted solution" and discussion of that choice is
completely absent (question

@_date: 2014-07-17 00:52:14
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Pay to MultiScript hash: 
Can you quantify "additional costs in terms of complicated control flows"?
When considering these costs, using a normal P2SH output + a script
with OP_IF and friends seems more straightforward?
Doing boolean logic with multisig groups is quite possible, e.g.
"group AND group", "group OR (group AND group)" etc.  Definitely a
valid use case.  I discussed how to do this on IRC with gmaxwell
several months ago.  I call it "multi-multisig" for lack of a better

@_date: 2014-07-17 02:21:42
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Pay to MultiScript hash: 
In a system like bitcoin, where the system has to keep running, you
have to consider how to roll out upgrades, and the costs associated
with that.
* the general cost of any network-wide change, versus P2SH which is
already analyzed by devs, rolled out and working
* the cost of P2SH output is predictable, versus less predictable outputs
* the cost of updating everybody to relay this new transaction type,
whereas P2SH Just Works already
* cost of increasing rate of UTXO growth versus P2SH
* "default public", versus P2SH's "default private"
It is true that publishing the script in the txout has the advantage
of being easily audited by third parties scanning the blockchain, but
in the interest of space efficiency you may accomplish the same thing
by offering the script upon request out-of-band.  The script is
hash-sealed by the P2SH address, enabling perfect proof.
Don't have a transcript handy, but these things are usually logged and
In any case, it would be nice to get together and start building a
"cookbook" of useful scripts like the ones you've been describing.
The power of bitcoin scripts is only beginning to be explored.  Use
cases and examples are very helpful.

@_date: 2014-07-17 12:14:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Decentralizing ming 
Define acceptable.  The 40% thing is marketing and a temporary
solution.  And people come down on both sides of whether or not
marketing "40%" is a good idea.
I think it is a baby step that is moving in the right direction.  You
want the numbers and sentiment moving in that direction (down, versus
"own the market! ").
The more critical piece is fleshing out the various proposals and
technical solutions for decentralized transaction selection and other
aspects of SPOF-proofing mining.
Historical note:  On one hand, Satoshi seemed to dislike the early
emergence of GPU mining pools quite a bit.  On the other hand, Satoshi
noted that the network would probably devolve down to a few big
players if we ever reached VISA/MC transaction levels.  Satoshi
clearly never figured this part out :)
Today, there is consensus on the need for a "keep bitcoin free and
open" technical solution, but it remains to be seen how much we
engineers can really do to make life fair.  Making transaction
selection a bit more independent from hashpower seems one step.  There
are several other proposals floating about.

@_date: 2014-07-18 09:39:15
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Decentralizing ming 
Before they got traction, yes.  But he projected a bit, as anyone
could, to see the trend.

@_date: 2014-07-18 09:44:07
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Decentralizing ming 
Yes.  That, and several other things.  If you can figure out how to
propagate a block without re-propagating all the transactions everyone
already has, you address the large-blocks-slower-to-relay problem, and
additionally create an incentive for miners to mine blocks consisting
of publicly broadcast transactions (versus a bunch of secret ones
mined with secret agreements).
Democratizing transaction selection takes a bit of power away from the
miners and gives it back to the network at large.  GBT is another
piece of that puzzle.

@_date: 2014-07-18 09:53:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Squashing redundant tx data in blocks on 
Yes, I would encourage thinking along these lines.  That was the
The intention was to experiment with sending block header + tx list +
coinbase, via UDP best effort broadcast.
If your neighbors receiving this message already have the TXs in the
TX list, then the block is complete, and may be relayed further.
If your neighbors do not have all TXs in the block, they must fetch
them at additional time/latency cost.
Thus, you have an incentive to relay blocks containing TXs already
distributed out into network mempools and cached in the signature
We want to capture that incentive in whatever protocol is eventually
used.  Miners have a TX fee incentive to include many transactions.
In theory, they want to include as many TX as possible.  It will help
us scale quite a bit to solve this problem.

@_date: 2014-07-18 11:06:23
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Squashing redundant tx data in blocks on 
Related implementation detail:  Having pursued this train of thought,
I noted that you don't want to include too-young transactions that you
received in the past few seconds, because those are likely still
propagating around the network.
Absolutely.  One path I would like to see pursued is multiple
p2pool-esque chains.  Each with their own policy, perhaps with their
own administrative team.  ie. you could have a fully decentralized
p2pool-like chain, or multiple such chains, each with a stated
policy/reward pattern.  Or, GHash/BTCGuild/Eligius could run a
semi-centrally managed chain ultimately guaranteed not only by
protocol but by administrators' digital signatures.
In each case, advertising technical attributes about your pool [chain]
policy would give nodes the better ability to predict what is in an
upcoming block.
And the flip side of that, such predictions are never perfect.  Need
to make sure the fallback case, while undoubtedly more costly than the
Fast Path, is not overly painful.

@_date: 2014-07-18 13:48:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Squashing redundant tx data in blocks on 
On a flood-fill network, you don't want to create a storm of "I
already have this" replies.

@_date: 2014-07-18 15:55:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Squashing redundant tx data in blocks on 
Related:  We must handle some legitimate miner-privately-mined cases,
such as miner payout TXs (outside coinbase) or side chain conditional
[1]

@_date: 2014-07-24 21:41:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Time 
Miners are free to set the block's timestamp to whatever they please,
within a certain +/- time window.  Time might even go backwards a tiny
bit from the last block to the next block.

@_date: 2014-07-30 09:22:23
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Abusive and broken bitcoin seeders 
Seeing this on one of my public nodes:
2014-07-30 13:13:26 receive version message:
us=162.219.2.72:8333, peer=11847
2014-07-30 13:13:33 receive version message:
us=162.219.2.72:8333, peer=11848
2014-07-30 13:14:21 receive version message:
us=162.219.2.72:8333, peer=11849
That is abusive, taking up public slots.  There is no reason to
connect so rapidly to the same node.
Other seeders are also rapidly reconnect'ers, though the time window
is slightly more wide:
2014-07-30 13:09:35 receive version message: /bitcoinseeder:0.01/:
version 60000, blocks=230000, us=162.219.2.72:8333, peer=11843
2014-07-30 13:12:42 receive version message: /bitcoinseeder:0.01/:
version 60000, blocks=230000, us=162.219.2.72:8333, peer=11846
The version message helpfully tells me my own IP address but not theirs ;p

@_date: 2014-06-04 08:15:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] # error "Bitcoin cannot be compiled 
Yes, check macros like that can be useful.
I like the kernel's policy, which parallels our direction:
1) Enable and use lightweight assertions for most users.
2) No assertions with side effects
If you want to compile them out, that's fine, but they should always
be present in production software.

@_date: 2014-06-06 15:00:13
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Wallet nLockTime best practices 
We are considering pulling in "Discourage fee sniping with nLockTime"
Comments from other wallet implementors in particular are welcomed.

@_date: 2014-06-06 20:57:04
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] # error "Bitcoin cannot be compiled 
Speaking very generally, the Linux kernel wisdom on this tends to be,
* Compile in as many cheap, compiler-predictable asserts as possible
into the production runtime.
* Debug builds are of limited value.  Users do not recompile software,
just to provide better bug reports/diagnostics.
* Make it as easy as possible for users to send reports that are
useful to programmers.
* Expensive diagnostics are fine. Compile in, but disable by default
at runtime (and make sure these features, when turned off, do not slow
down the system).
* Make sure the assert/dump provides a high level of diagnostics.
Stack trace of each thread + multi-threaded core dump are a good

@_date: 2014-06-06 21:55:31
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin miner heads-up: "getwork" RPC going 
"getwork" has long been unused on mainnet, and mostly unused elsewhere
as well.  It generates work by a method that cannot keep up with the
demands of the modern network.
As such, it is planned to remove "getwork" in the next release.  Most
if not all pool servers have switched away from "getwork" years ago.

@_date: 2014-06-10 09:02:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bloom bait 
Most of this description of disk activity is true, but it omits one
key point:  Total cached data (working set).  It is a binary, first
order question:  are you hitting pagecache, or the disk?  When nodes
act as archival data sources, the pagecache pressure is immense.  When
nodes just primarily serve recent blocks, that data is being served
out of pagecache. As I directly observed running public nodes, the
disks were running constantly, impacting all clients, even clients
downloading only recent blocks.
Luckily, headers are served out of RAM, so that part of the sync is always fast.
NODE_BLOOM -- and block download in general -- will tend to be slower
than it could be, due to the working set almost always being larger
than available pagecache.  Fix that problem, NODE_BLOOM will always
operate out of pagecache, and disk activity will not be an issue.
Once you start hitting the disk, you've already lost.

@_date: 2014-06-13 16:12:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Going to tag 0.9.2 final 
As a general principle, I agree.  Other projects have translation
freeze points to address this.  Although it is a small holistic risk,
in theory, someone could maliciously change strings at the last minute
in a language maintainers don't know well.

@_date: 2014-06-17 17:29:07
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: allocate 8 service bits for 
I wrote a patch for string-based name extensions, circa 2011-2012.  I
agree that is preferable to unreadable bits, for reasons you cite.
However, it was noted that extensions (or UUIDs etc.) would not be
propagated around the network in "addr" messages, as service bits are.

@_date: 2014-06-24 10:21:46
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposed BIP 70 extension 
heh, this is a cool idea.
It also seems like it would be subject to instant inflation, as it's
unprovable, and a rational economic actor may choose to exaggerate
such numbers.  It also seems collectively rational by some points of
view for all bitcoin actors to inflate this number.
At a minimum, I would either add "marketing_" to the field name
itself, or include additional comment caveats noting in BOLD language
that this field is informational, and should not be relied upon for
accounting/auditing purposes.
It just seems like a statistic that everyone has an incentive to exaggerate.

@_date: 2014-06-24 11:48:15
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposed BIP 70 extension 
I think there is nothing wrong with having a numeric memo field, which
is effectively what this is.  Structured rather than unstructured

@_date: 2014-06-25 11:43:05
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Wallet nLockTime best practices 
I'm inclined to merge which sets nLockTime on wallet-created transactions by default.  I
think this is good practice for wallets, long term.

@_date: 2014-06-25 14:10:58
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposed BIP 70 extension 
Remember the IETF RFC process.
1) RFCs are never updated.  Extensions go into new RFCs.
2) Build an implementation, write a draft, circulate both.  Then get a
BIP number.
3) As MH indicated, it would be useful to have a living payment
protocol document that _is_ updated.
4) Let's stop calling it BIP70.  That just reinforces the desire to
update the BIP70 document.

@_date: 2014-03-01 13:22:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Decentralized digital asset exchange with 
This is wandering far off-topic for this mailing list.

@_date: 2014-03-01 13:33:25
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Decentralized digital asset exchange with 
This is not bitcoin-philosophy, it's bitcoin-development.  Existential
philosophy belongs on IRC or the forums.

@_date: 2014-03-10 14:12:49
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
Payment protocol currently supports payments to multi-sig addresses.
In general, almost all wallet software sucks RE multisig.  Just try
any of these actions in Bitcoin-Qt or another wallet:
* obtain a public key you control, given a bitcoin address
* easily share public keys
* easily share partially signed transactions
* build a P2SH multisig address from public keys, reliably.  Right
now, participants have no idea about pubkey order, leading various N
possible P2SH addresses, given a list of public keys.  Reproducing the
P2SH address is harder than it should be.
* track "partially controlled" balance (balance of coins of which you
may sign at least 1 of N)
* support for remote oracles and services that provide 1-of-N signatures

@_date: 2014-03-10 20:14:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
All of that only melds with the payment protocol under an extremely
expansive definition of "payment."  The payment protocol is really
geared towards a direct one-to-one relationship.
We can make the payment protocol do all this, if you squeeze and push
and try reall hard; it is mainly a question of protocol design and
intended usage:  is PP intended to be, ultimately, an expansive,
universal protocol for gossiping with other parties about bitcoin
transactions in a not-flood-fill manner?

@_date: 2014-03-11 08:38:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
It also assumes a reality different from our current one.

@_date: 2014-03-11 10:13:48
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
Sure, but I don't see wallets being able to _assume_ _remote_ parties
have an HD wallet for a long, long time.  Interoperability common
sense implies the environment will be heterogenous, perhaps forever,
invalidating assume-each-party-uses-HD logic.

@_date: 2014-03-11 10:34:50
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
On Tue, Mar 11, 2014 at 10:23 AM, Gavin Andresen
Disagree.  It is an unnecessary restriction.  People are already
writing and starting to deploy multisig wallets in the field, that do
not match this assumption.
In general, HD is really cool, but even the barest amount of
infrastructure is lacking.  Popular libraries and the reference client
all lack support.  Building a protocol that assumes HD is optimistic
at this stage.

@_date: 2014-03-11 10:44:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
( )
Right now, HD is hot air.  Let us end the pie-in-the-sky assumptions
about how HD will save the day, with zero code to back it up.  Bitcoin
Wallet purportedly fails to rotate addresses, a privacy ugly, because
of this Waiting For Godot situation.  An attempt to add a simple,
stateless RPC stalled because we are all Waiting For Godot, also:
Until the major user wallets and bitcoind have -basic- HD support, it
is premature to build anything on top of HD.  We really have no clue
at this juncture how difficult will be the HD rollout.

@_date: 2014-03-12 11:35:45
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
The zero-length placeholder is not a new invention.
This is what bitcoind produces and expects by default, for a partially
signed transaction.

@_date: 2014-03-12 12:33:12
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
Partially signed and multisig transactions within bitcoind go through
the raw transaction API, which does absolutely nothing if the sig
pushes the TX to a higher fee level.

@_date: 2014-03-12 12:57:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Multisign payment protocol? 
It's the raw transaction API.  If you break something, you get to keep
both pieces.
On a related note, sipa has proposed a more useful raw transaction API
call, that figures out fees, change and other details:

@_date: 2014-03-13 08:56:01
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Resurrecting this topic.  Bitcoin Wallet moved to mBTC several weeks
ago, which was disappointing -- it sounded like the consensus was
uBTC, and moving to uBTC later --which will happen-- may result in
additional user confusion, thanks to yet another decimal place

@_date: 2014-03-13 09:45:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Based on this seeming consensus, BitPay was headed towards uBTC
internally, and hoped to coordinate messaging and rollout with others
in the community.  Ah well, proceed apace, and Bitcoin Wallet will
catch up, I suppose.
Multiple unit changes negatively impact users, but we are already there :/

@_date: 2014-03-13 10:32:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Such hand-wavy, data-free logic is precisely why community
coordination is preferred to random apps making random decisions in
this manner.
mBTC is problematic because you do not need 1000x shift in value to
produce annoyances for major accounting packages that are hard-limited
to two decimal places.  Further, spreadsheets hide information if
formatting is configured naively -- that is, if formatting is
configured for bitcoin the way it is configured for other currencies.
Fundamentally, more than two decimal places tends to violate the
Principle Of Least Astonishment with many humans, and as a result,
popular software systems have been written with that assumption.

@_date: 2014-03-13 12:29:03
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
mBTC now just means the issue -will- be revisited in the future.  Just
a question of when, not if.
People and software in various nations handle big numbers for small
values (e.g. Yen) just fine.
People and software do -not- handle extra decimal places well, field
experience shows.
  To roll out QuickBooks support --without converting
any numbers, a key financial attribute-- mBTC is simply insufficient
today, not in the future.
I also argue that it is a security risk, as follows:  To support
accounting packages limited to 2 decimal places, decimal point
conversion must be performed.  This produces a situation where your
accounting system shows numbers that do not visually match the numbers
in the bitcoin software.  That, in turn, making auditing more
difficult, particularly for outsiders.
Shipping with mBTC defaults was decidedly unwise, considering that --
like BTC -- it fails to solve existing, known problems that uBTC can
solve, and considering the inevitable mBTC->uBTC switch.

@_date: 2014-03-13 13:21:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Yes.  That was in Tamas's recursive link, and also brought up on
github by jcorgan.  +1

@_date: 2014-03-13 15:38:17
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Just saying that doesn't make it so, nor does it make it a good idea.

@_date: 2014-03-15 12:47:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] python-bitcoinlib v0.1 release - a 
Thanks -- though credit is really due to ArtForz, who kicked off this
project with his half-a-node:

@_date: 2014-03-15 12:47:53
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] python-bitcoinlib v0.1 release - a 
Sounds great.  I'm glad to see this with a more active maintainer.
Maintaining -three- client libs was a bit much for me.

@_date: 2014-03-15 13:21:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] python-bitcoinlib v0.1 release - a 
I am happy to do whatever makes the new maintainer and users most
happy.  That includes giving the new maintainer commit privs in my

@_date: 2014-03-20 13:31:44
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Extremely limited.  Preferably under 100 bytes.  You will see
increasingly poor operating in varying light conditions, such as
paying via QR code on a printed receipt in a pub at night.  That was
one of the motivations for BIP 73.
On Thu, Mar 20, 2014 at 4:09 AM, Andreas Schildbach
Yes.  Internet connectivity is not a rarity these days.  Near-field
web servers also work fine.

@_date: 2014-03-20 14:01:48
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
It really depends on the physical, real world size of the QR code.
If you have a big screen, and security permits displaying a larger QR
code, you can afford more bytes.  If you are displaying a tiny postage
stamp 1-2cm in size, the practical byte limit is very low.
Ideally, you test your QR codes in real world conditions, before
picking the best path.

@_date: 2014-03-22 12:35:43
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Let's not pull out silly examples.  Of course you can find locations
that lack Internet.
Those locations are completely unsuitable to bitcoin transactions,
since the receiver cannot verify double-spending or anything else
about the transaction.

@_date: 2014-03-22 13:24:43
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
One participant, yes.  Two participants lacking net would require a
serious revisit of BIP 70's security assumptions and some design, at a

@_date: 2014-03-25 13:37:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Tree-chains preliminary summary 
Peter, take this unprofessional, personal crap off-list.
Mike's anecdote of hostility is not an isolated one.  Just today, a
bitcore developer commented on "Peter Todd's ..apocalyptic vision
and... negative view on bitcoin" which turned off some other
developers from participating more interactively.
As I commented on IRC, open source projects are no strangers to people
who simultaneously (a) make useful contributions and (b) turn
potential contributors away with an abrasive or hostile attitude
toward others.  It's an unsolved problem in OSS, that I saw for 15+
years in the Linux kernel community.
For this list, as Mike suggested on IRC, introducing an openly stated
moderation policy may be the one route.

@_date: 2014-03-29 09:27:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
The comparison with multisig fails to mention that multi-signature
transactions explicitly define security at the transaction level.
This permits fine-grained specificity of what a key holder may
Shamir is much more coarse-grained.  You reconstitute a private key,
which may then be used to control anything that key controls.  Thus,
in addition to Shamir itself, you need policies such as "no key
My first impression of Shamir many moons ago was "cool!" but that's
since been tempered by thinking through the use cases.  Shamir has a
higher D.I.Y. factor, with a correspondingly larger surface of
things-that-could-go-wrong, IMO.
(None of this implies making an informational BIP lacks value; I'm all
for an informational BIP)

@_date: 2014-03-29 10:19:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Presenting a BIP for Shamir's Secret 
Disagree with "does not allow"  Review bitcoin's script language.
Bitcoin script can handle the use case you describe.  Add conditionals
to the bitcoin script, OP_IF etc.  You can do 'multisig AND multisig'
type boolean logic entirely in script, and be far more flexible than a
single CHECKMULTISIG affords.

@_date: 2014-05-04 01:15:03
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bug with handing of OP_RETURN? 
The carried data must all be contained within one pushdata.

@_date: 2014-05-04 09:25:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bug with handing of OP_RETURN? 
Not much more complex.
The template matches a two-chunk script with OP_RETURN + one pushdata
(or just OP_RETURN with no push).  The pushdata is further limited to
MAX_OP_RETURN_RELAY bytes.

@_date: 2014-05-05 13:30:02
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bug with handing of OP_RETURN? 
Correct, though that was somewhat unintentional.  The pushed-data size
is limited to <= 40 bytes, and as non-pushdata opcodes carry zero
pushed data, they are accepted.

@_date: 2014-05-13 05:19:07
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] ECDH in the payment protocol 
This is extremely simple-minded logic that encourages ephemeral, junk
data in the blockchain.  Not a scalable approach.
The implication is to put the communications medium in the blockchain
itself, which is wrong.

@_date: 2014-05-15 13:41:31
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] DNS seeds unstable 
While I agree that the problem seeds should be fixed, it also sounds
like a problem with bitcoinj / other layers, if a malfunctioning seed
is a problem for your app.
Seeds are fundamentally a backup for peer exchange.  You are going to
run into problems if you rely 100% on seeds, always.
Further, there are multiple seeds so that we are not impacted if a
couple seeds malfunction or die.  All bitcoin apps must take this into

@_date: 2014-05-17 00:02:46
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] DNS seeds unstable 
There are only two testnet seeds listed in bitcoind, and one of them
returns SERVFAIL (testnet-seed.bitcoin.petertodd.org) and the other
just returns one A record (testnet-seed.bluematt.me).  No idea what
seeds bitcoinj uses.
If you are going to depend on testnet, especially for an important
demo... contribute to the infrastructure!  This stuff doesn't just fix
itself for free.

@_date: 2014-05-19 03:11:37
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] About the small number of bitcoin nodes 
+1 for the sake of transparency
HOWEVER, the impact on this feature RE user population is
unpredictable.  Users may see bigger than expected numbers, and switch
off their node.
Meh.  I like example configs, perhaps tuned by the distro.  If the
distro (_not_ Bitcoin Core upstream) chooses to install a bitcoin.conf
in the proper location, that's up to them.
Agreed with conditions:
1) The distro MUST let bitcoin devs dictate which dependent libs are
shipped with / built statically into the bitcoin binaries/libs.
2) The distro MUST permit fresh updates even to older stable distros.
2) The maintainer(s) MUST be active, and follow bitcoin development,
release status, etc. on a near-daily basis, be able to respond quickly
if security issues arise, etc.
Matt C seems to do a good job of this in Ubuntu PPA, I'm told.
The best path for this is figure out what statistics you want to see,
and have bitcoind export those raw numbers to any willing consumer.
Then write your bitcoind-top on top of that.
In progress.  Disable-wallet support, at compile time or runtime, was
the first step.
No, you don't want this (and it's not possible in many cases anyway).

@_date: 2014-05-19 19:49:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] DNS seeds unstable 
Quite the opposite.  dnsseed data rotates through a lot of addresses
if available.  Using the bind/zone-xfer system would result in fewer
total addresses going through to the clients, thanks to the addition
of caching levels that the bind/zone-xfer system brings.
That said, if the choice is between no-service and bind, bind it is ;p

@_date: 2014-05-20 06:30:37
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] patents... 
There is the little-used "bitcoin-list" on SourceForge that claims a
rubric of "general discussion":
I just subscribed there.
We can "reboot" that list with a couple new rules such as
a) be good to each other.  consistent rude behavior gets the boot.
b) anything related to decentralization, consensus, proven data
structures or crypto is on-topic

@_date: 2014-05-20 15:17:46
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
Yes, i spec'd out the UDP traversal of the P2P protocol.  It seems
reasonable especially for "inv" messages.

@_date: 2014-05-20 16:22:27
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Why are we bleeding nodes? 
Indeed -- you must reinvent TCP over UDP, ultimately, to handle blocks
and large TXs.

@_date: 2014-05-21 10:32:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] PSA: Extending BIP 70 / payment protocol 
Please put any payment protocol extensions into a new draft BIP.  BIP
70 should not be updated continuously.
Mimic the IETF, where new RFCs are produced as protocols are extended.
 Once published, an IETF RFC is considered static.
That said, I think it is OK to be smart, and break the "static" rule a
bit for significant BIP bugs, or harmless maintenance of

@_date: 2014-05-22 14:06:10
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] PSA: Please sign your git commits 
Related:  Current multi-sig wallet technology being rolled out now,
with 2FA and other fancy doodads, is now arguably more secure than my
PGP keyring.  My PGP keyring is, to draw an analogy, a non-multisig
wallet (set of keys), with all the associated theft/data
destruction/backup risks.
The more improvements I see in bitcoin wallets, the more antiquated my
PGP keyring appears.  Zero concept of multisig.  The PGP keyring
compromise process is rarely exercised.  2FA is lacking.  At least
offline signing works well. Mostly.

@_date: 2014-11-04 20:56:35
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP62 and future script upgrades 
Moderately agreed.
Earlier in BIP 62 lifetime, I had commented on ambiguity that arose
from bumping tx version simply because we were bumping block version.
The ambiguity was corrected, but IMO remains symptomatic of potential
problems and confusion down the road.
Though I ACK'd the change, my general preference remains to disconnect
TX and block version.

@_date: 2014-11-06 23:11:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] The difficulty of writing consensus 
IMO, CHECKLOCKTIMEVERIFY should be included in that list, too.
RE soft fork vs. hard fork:  It's about this time at Mike Hearn will
chime in, on the side of hard forks.  Hard forks are in a sense much
cleaner, and permit solving problems not otherwise solvable with a
hard fork.  However, hard forks clearly have risks, notably the Big
Risk akin to a US Constitutional Convention:  once you open the door,
anything can happen, any rule no matter how "sacred" can be changed.
Soft forks are not without their own risks, e.g. reducing some things
to SPV levels of security.
Leaning towards soft fork, but it is a good discussion to have.  A
poorly implemented soft fork may potentially require a hard fork to
fix rollout bugs.

@_date: 2014-11-08 17:21:02
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Update on mobile 2-factor wallets 
Overall, super duper awesome.  :)  Tweeted this post.
I do have a concern about 2-of-2 arrangements.  To me, this screams
"twice as fragile" if not done properly; and I've seen a few naive
implementations in the field that seemed quite fragile.
2FA/2-of-2 does solve the common problem of single device compromise.
It also makes funds unspendable if -either- device's keys become lost.

@_date: 2014-11-26 08:51:31
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Deanonymisation of clients in Bitcoin P2P 
I don't recall being contacted directly, but the attack has been
discussed.  It relies on a number of conditions.  For example, if you are
over Tor, they try to kick the machine off Tor, _assuming_ that it will
fall back to non-Tor.  That's only true for dual stack nodes, which are not
really 100% anonymous anyway -- you're operating from your public IP anyway.

@_date: 2014-11-30 11:38:42
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] bitcoind as a library 
============================== START ==============================
Though I am highly biased :)  Compared to cbitcoin, picocoin's library
(libccoin) is valgrind-clean, can parse and index the blockchain, and
supports all core and P2P data structures.

@_date: 2014-10-03 19:12:11
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [BIP draft] CHECKLOCKTIMEVERIFY - Prevent 
RE " It's not like other software where people can choose to skip an
upgrade and things still work just like before."
If you're a minority, sure you can.  Still a few nutters out there on
a 0.3.x codebase, including one or two inattentive,
now-inconsequential miners.
There is some headroom built in for just that... less disruptive
upgrades that don't require 100%.

@_date: 2014-10-10 12:42:39
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Something people are forgetting about the 
The whole issue is a troll, and I'm afraid you got sucked in.
There are no plans to add a blacklist to Bitcoin Core.

@_date: 2014-10-22 20:00:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] side-chains & 2-way pegging (Re: is there 
Take the discussion of this site to another M-L, please.  It is off-topic.
Actual discussion of the paper and side-chains is on-topic.
This M-L is publicly archived.

@_date: 2014-10-25 14:12:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] death by halving 
"Flag day" herd behavior like this is unlikely for well informed and
well prepared market participants.

@_date: 2014-10-25 14:31:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] death by halving 
It is an overly-simplistic miner model to assume altruism is
necessary.  The hashpower market is maturing in the direction of
financial instruments, where the owner of the hashpower is not
necessarily the one receiving income.  These are becoming tradeable
instruments, and derivatives and hedging are built on top of that.
Risk is hedged at each layer.  Market players also forge agreements
with miners, and receive -negative- value if hashpower is simply shut
Simplistic models cannot predict what hashpower does in the face of
business-to-business medium- and long-term contracts.

@_date: 2014-10-27 07:37:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bitcoin Core 0.10 release schedule 
It would certainly be nice to start with a document that reflects the
new REST interface.  That makes a good starting point for further
In general the interface exports what information is already
available.  As Wladimir notes, there is no plan to turn this into a
full fledged block explorer, if that implies adding indices etc.
Feedback on the HTTP headers and form, and additional thoughts &
proposals are welcome.  My pull request is intended to present
something minimal, that is easy to review and merge.  My own list of
further to-dos includes
* last-modified and etag headers
* export UTXOs a la Mike Hearn's getutxos query
* eventually rebuild the RPC server to something multithreaded a la
PR  @

@_date: 2014-10-29 13:25:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Death by halving (pro-active proposals) 
Seconded - IMO a key future use of the chain will be securing other
chains.  I'm interested in pursuing the merged-mining angle.
Getting chain hashes to a miner, and getting that miner payment from
the chain, is key to this.  Consider a future where there are 10,000
chains secured by one block...
On Wed, Oct 29, 2014 at 10:34 AM, Sergio Lerner

@_date: 2014-10-30 19:34:12
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Increasing regularity of block times? 
That's what we do for testnet today:  If no block is found for 20 minutes, one minimum-diff block may be mined.

@_date: 2014-09-12 10:15:21
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP72 amendment proposal 
Indeed -- Every byte added to the QR code makes it more difficult to
be used in restaurants, pubs and other low-light conditions.  BitPay
tested some of these scenarios.
Scannability is absolutely impacted.

@_date: 2014-09-13 10:03:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Does anyone have anything at all signed 
That claim is horse manure :)  He never signed private emails sent to
me, nor the forum posts.
He -might- have signed the occasional thing related to releases, I'm not sure.

@_date: 2014-09-15 09:08:48
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Does anyone have anything at all signed 
Such guidelines are a perfect example of why PGP WoT is useless and
stupid geek wanking.
A person's behavioural signature is what is relevant.  We know how
Satoshi coded and wrote.  It was the online Satoshi with which we
interacted.  The online Satoshi's PGP signature would be fine...
assuming he established a pattern of use.
As another example, I know the code contributions and PGP key signed
by the online entity known as "sipa."  At a bitcoin conf I met a
person with photo id labelled "Pieter Wuille" who claimed to be sipa,
but that could have been an actor.  Absent a laborious and boring
signed challenge process, for all we know, "sipa" is a supercomputing
cluster of 500 gnomes.
The point is, the "online entity known as Satoshi" is the relevant
fingerprint.  That is easily established without any in-person

@_date: 2014-09-15 10:33:09
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Does anyone have anything at all signed 
It applies to OP, bitcoin community development and Satoshi.
"value of in person vetting of identity is undeniable"...  no it is
quite deniable. Satoshi is the quintessential example. We value brain
output, code.  The real world identity is irrelevant to whether or not
bitcoin continues to function.
The currency of bitcoin development is code, and electronic messages
describing cryptographic theses.  _That_ is the relevant fingerprint.
Governmental id is second class, can be forged or simply present a
different individual from that who is online.  PGP WoT wanking does
not solve that problem at all.

@_date: 2014-09-20 09:00:39
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Applying clang-format to Bitcoin Core 
We are slowly applying a consistent style to the C++ source, via
clang-format (LLVM) and $repo/src/.clang-format.
If you have a patch that is difficult to apply to the tree due to
reformatting, simply apply clang-format and then rediff.

@_date: 2015-04-09 07:22:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Build your own nHashType 
Think about what slow transaction verification speed means.  Slower
propagation across the network.  More work per node.  Greater opportunity
for algorithmic attacks, races and other shenanigans by attackers.

@_date: 2015-04-29 19:27:19
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Looking for a good bitcoin script 
python-bitcoinlib supports script parsing and execution.

@_date: 2015-02-03 14:22:07
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] [softfork proposal] Strict DER signatures 
+1   I just ran an it-works test on   Not exhaustive, but I do agree
it should be included w/ other DERSIG changes.
On Tue, Feb 3, 2015 at 1:19 PM, Gavin Andresen

@_date: 2015-02-06 07:08:50
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] determining change addresses using the 
Yes.  You can certainly add additional inputs and outputs -- and as such
you can increase privacy and defrag your wallet at the same time.

@_date: 2015-02-12 10:27:53
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
Repeating past statements, it is acknowledged that Peter's scorched
earth replace-by-fee proposal is aptly named, and would be widely
anti-social on the current network.
At a high level, we can see that this thread is contentious because
this covers _what we want bitcoin to be_, and that is an opinion
(versus engineering fact), and it varies from person to person.
However, hope is the denial of reality...instead we should walk
forward with our eyes open[1].  My interest in bitcoin originates from
the science fiction concept of "credits"[2], a universal money that
transcends national borders and even planets.  That is what I hoped
bitcoin would be.  "universal payments" is both a laudable goal and a
shopworn bitcoin marketing slogan.
The fundamental engineering truths diverge from that misty goal:
Bitcoin is a settlement system, by design.
The process of consensus "settles" upon a timeline of transactions,
and this process -- by design -- is necessarily far from instant.
Alt-coins that madly attempt 10-second block times etc. are simply a
vain attempt to paper over this fundamental design attribute:
consensus takes time.
As such, the blockchain can never support All The Transactions, even
if block size increases beyond 20MB.  Further layers are -- by design

@_date: 2015-02-21 17:47:28
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
"scorched earth" refers to the _real world_ impact such policies would
have on present-day 0-conf usage within the bitcoin community.
All payment processors AFAIK process transactions through some scoring
system, then accept 0-conf transactions for payments.
This isn't some theoretical exercise.  Like it or not many use
insecure 0-conf transactions for rapid payments.  Deploying something
that makes 0-conf transactions unusable would have a wide, negative
impact on present day bitcoin payments, thus "scorched earth"
Without adequate decentralized solutions for instant payments,
deploying replace-by-fee widely would simply push instant transactions
even more into the realm of centralized, walled-garden services.

@_date: 2015-02-21 23:06:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
Lacking a coded, reviewed alternative, that's only a platitude.
Widely used 0-conf payments are where we're at today.  Simply ceasing
the "maintaining [of] first seen policies" alone is simply not a
realistic option.  The negative impact to today's userbase would be
Instant payments need a security upgrade, yes.

@_date: 2015-02-23 20:11:26
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
Indeed.  0-conf risk calculus must include business conditions.
Business cases such as placing an order for a physical good, making an
in-person purchase at a brick-n-mortar store, or subscriptions already
have countermeasures in place if funds go astray.  Order fulfilment
can be stopped, subscriptions cancelled, photos handed to police.
A thief wants to maximize return, which usually means either stealing
a few large amounts or many small amounts.  Double-spending against a
SatoshiDICE clone is easy to automate.  Many other purchase situations
are difficult to repeat without getting caught, or the level of effort
(cost) is greater than the payout of double-spending a small amount.
0-conf is typically only used for small amounts, where useful theft
relies on high repetition.
Purely online, mostly anonymous services like SatoshiDICE will be
easily attacked if they accept 0-conf transactions as there is little
customer/reputation relationship to leverage.  However, that
observation cannot be easily applied to most other businesses.

@_date: 2015-01-09 08:22:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Bi-directional micropayment channels with 
Mike, Can you be more specific?  You reference "original design" without
saying how it was different/better.

@_date: 2015-01-14 15:32:57
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] convention/standard for sorting public 
Sounds like this warrants a micro-BIP just to get everybody on the same
On Wed, Jan 14, 2015 at 11:37 AM, Ruben de Vries

@_date: 2015-01-19 14:09:13
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
Text formats such as XML or JSON are far less deterministic, are more
loosely specified, have wide variance in parsing, are not very hash-able,
the list goes on.

@_date: 2015-01-19 14:34:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
None of those listed were in the context of performance.  Parsing of binary
or text is quite fast these days, and is not really a consideration versus
other needs such as a predictable encoding for a single data
representation.  XML and JSON both can represent the same post-evaluation
user data a million different ways, which is awful for anything you are
signing and hashing.  Text formats also transit binary data very poorly,
leading to unnecessary wrapping and unwrappiing (a programmatic, visibility
& bug; again performance not a primary concern).
This is evident because both XML and JSON have standards efforts under way
to correct some of these problems and make them more deterministic.
However, such standards are not field deployed and widely supported by
parsers and generators alike.

@_date: 2015-01-19 14:38:23
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
ASN.1 is not nearly as flexible when it comes to well-supported libraries,
generators, and the ecosystem that surrounds the actual encoding.  You
don't see ASN.1 compilers + language support packages for [all popular
programming languages], as you do with protobufs.
Google engineers were well aware it existed I'm sure.  There are wider
considerations beyond the low-level specified format.
Protobufs have their problems and aren't perfect, but ASN.1 ecosystem is
far less developed in the programming ecosystem, far less approachable for
programmers.  BIP70 wouldn't have been as easily and widely adopted if
ASN.1 had been chosen.
On Mon, Jan 19, 2015 at 2:19 PM, Matt Whitlock

@_date: 2015-01-19 16:21:54
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
Correct.  I should have said "more likely to be deterministic"  Bitcoin
Core does not *rely* on determinism in BIP70; I was referring to recent
upstream efforts to make protobufs usable in a deterministic fashion by

@_date: 2015-01-22 11:29:24
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] IMPULSE: Instant Payments using the 
The user experience is significantly more secure than today.
Presumably the future supports many payment facilitators, including m-of-n
oracles, and this is perfectly compatible with that.

@_date: 2015-01-28 11:04:58
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
Not to mention the tiresome and error-prone task of writing your own
JSON-to-schema marshalling code -- or something equivalent to the protobufs
compiler and libs for JSON.
protobufs -- and its modern competitors such as msgpack -- natively provide
type support in a way that must be hacked into JSON or XML.
The protobuf/msgpack design is engineered to avoid bugs routinely found in
JSON parsing code; due to the amount of code & effort involved in JSON
input sanity checking, bugs and inconsistencies inevitable arise.  We have
seen this in bitcoind with JSON-RPC.

@_date: 2015-01-28 12:29:53
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
It is not "fear", it is field experience.
JSON has proven to be a bug generator for the reasons already stated.
JSON does not include type marshalling and input validation.
Protobufs/msgpack/etc. engineered those to occur automatically, because
that is an area shown by field experience to be a constant source of bugs
and inconsistent parsing/validation behavior.
On Wed, Jan 28, 2015 at 11:52 AM, Nicolas DORIER

@_date: 2015-06-04 18:39:25
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Tough questions for Peter Todd, 
Viacoin}
Take this somewhere else, Mr. Berg.  This is a technical mailing list.

@_date: 2015-06-10 12:54:25
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Is SourceForge still trustworthy enough 
On Wed, Jun 10, 2015 at 11:59 AM, Andy Schroder spam folders, if they were not directly listed in the To/CC headers...

@_date: 2015-06-14 00:56:22
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] User vote in blocksize through fees 
Miner voting, while imperfect, is the least-worst of various solutions
which inject market input into the system.  It is is known quantity, field
tested, and must be sustained, in public, over a time span of months.  As
this thread shows, stakeholder and direct user voting is nigh impossible to
get right.
Choosing block size is fundamentally a central bank directive shaping the
fee market.  Whatever actor or algorithm or natural equilibrium picks the
block size, that choice will dictate the level of competition for fees, the
level of scarcity of an economically scarce resource.  Picking the block
size advantages some businesses over others, some business models over
others.  Software (and software devs) should not be the ones picking that
Checks-and-balances are also important.  BIP 100 notably includes two steps
at which user input is visibly and actively injected:   1) hard fork to
enable, and 2) a second hard fork if the system is to scale beyond 32MB.
The network users (not miners) twice approve the system.  Further, one must
remember all the basic miner incentives that do align with users, notably
that of maintaining the value of bitcoin tokens as their primary income
On Sun, Jun 14, 2015 at 12:16 AM, Stephen

@_date: 2015-06-14 00:59:03
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] User vote in blocksize through fees 
BIP 100 requires a hard fork to engage.  Users proactively opt-in.

@_date: 2015-06-14 01:13:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] User vote in blocksize through fees 
What is the alternative?  Have a Chief Scientist or Technical Advisory
Board choose what is a proper fee, what is a proper level of
decentralization, a proper growth factor?

@_date: 2015-06-14 01:36:45
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] User vote in blocksize through fees 
The choice is very real and on-point.  What should the block size limit
be?  Why?
There is a large consensus that it needs increasing.  To what?  By what
The size limit literally defines the fee market, the whole damn thing.  If
software high priests choose a size limit of 300k, space is scarce, fees
are bid high.  If software high priests choose a size limit of 32mb, space
is plentiful, fees are near zero.  Market actors take their signals
accordingly.  Some business models boom, some business models fail, as a
direct result of changing this unintentionally-added speedbump.  Different
users value adoption, decentralization etc. differently.
The size limit is an economic policy lever that needs to be transitioned
-away- from software and software developers, to the free market.
A simple, e.g. hard fork to 2MB or 4MB does not fix higher level governance
problems associated with actors lobbying developers, even if a cloistered
and vetted Technical Advisory Board as has been proposed.

@_date: 2015-06-14 10:42:17
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] User vote in blocksize through fees 
Since you missed it, here is the suggestion again:

@_date: 2015-06-14 11:07:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] User vote in blocksize through fees 
Exactly -- both block size proponents and block size change conservatives
seem to be glossing over this aspect - much to my dismay.
Choosing the size limit is choosing the size of a scarce resource.  By fiat.
It is wrong to think that a "technical consensus" can choose what is best
The block size limit defines the scope of a resource for which all fee
market actors bid.  That, in turn, defines who is in the fee market and how
they behave, what market choices are made.
It doesn't matter how or why the limit was originally enacted, what Satoshi
meant to do.  What matters, economically, is what is.  What the software
and our $3B economy & market knows and sees today.  (I think some block
size change proponents miss this!)
The solution lies in transitioning this size limit to the free market.  In
the end, the users must choose their desired level of growth,
decentralization, etc.  We cannot rely on some dev's idea of the proper
level of fee, proper level of growth, proper level of decentralization.
And IMO, a "floating limit with training wheels" is better and stronger for
bitcoin's health from a governance, user choice and free market perspective
than simply "hard fork to 2MB, come back again in 6 months."
On Sun, Jun 14, 2015 at 6:34 AM, Benjamin

@_date: 2015-06-14 11:15:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposal: Move Bitcoin Dev List to a 
* ACK on moving away from SourceForge mailing lists - though only once a
community-welcomed replacement is up and running
* ACK on using LF as a mailing infrastructure provider
* Research secure mailing list models, for bitcoin-security.  The list is
not ultra high security - we all use PGP for that - but it would perhaps be
nice to find some spiffy cryptosystem where mailing list participants
individually hold keys & therefore access.
On Sun, Jun 14, 2015 at 6:12 AM, Warren Togami Jr.

@_date: 2015-06-14 22:28:02
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] comments on BIP 100 
In the latest draft there is an explicit 32MB ceiling now.
Users will need to opt into growth beyond 32MB via a 2nd hard fork.
As a general principle, this is an area of market disagreement, and should
not be our call.  Encoding this into software veers into personal opinion
about what economic policy should be.
That said  -- BIP 100, as a compromise, includes a growth limiter.  Abrupt
change (1MB -> 32MB!) is awful on markets.  Good policies include a
measured pace of transition from policy A to policy B.  It gives the
community time to assess system effectiveness - while also allowing free
market input.
In the long run I hope the cap is removed (see below), and the intention is
to -slowly- and -transparently- move from the tightly controlled limit to
something the free market and users are choosing.
"paying with difficulty" has severe negative elements that will likely
cause it never to be used:
- complex and difficult for miners to reason
- fails the opportunity cost test - dollar cost lost losing the block race
versus value gained by increasing block size
- inherently unpredictable in the short term - user experience is that it's
possibly difficult to see a gain in utility versus the revenue you are
giving up
- REQUIRES informal miner collusion - probably less transparent than BIP
100 - in order to solve the who-goes-first problem.
- net result: tough sell
Paying bitcoins to future miners makes a lot more sense.  Initially I was a
fan of pay-with-diff, but freezing bitcoins (CLTV) or timelock'd
anyone-can-spend has much more clear incentives, if you want to go down
that road.
Problems with pay-to-increase-block-size:
- how much to pay?  You are inherently setting your growth policy on top of
bitcoin by choosing a price here.
- another who-goes-first problem
Anyway, there is a natural equilibrium block size that the free market and
user choice will seek.
Related:  There is a lot of naive "miner = max income = max block size"
reasoning going on, with regards to fees.  This is defining the bounds of
an economically scarce resource.  There are many reasons why a miner will
today, in the real world, limit their block size. WRT fee income, if block
size is too large the fee competition in the overall market is low-to-zero,
fee income rapidly collapses.  Then factor in price and demand elasticity
on top of that.
Quite frankly, there seems to be a natural block size equilibrium ceiling,
and I worry about miners squeezing the market by maximizing their fee
income through constrained block sizes and competition at the low end.
This is of course already possible today - miners may openly or covertly
collude to keep the block size low.

@_date: 2015-06-14 22:44:22
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] comments on BIP 100 
Adding - in re pay-to-FOO - these schemes are inherently short term, such
that it is near-impossible for the market to plan for what happens in 12+

@_date: 2015-06-15 13:15:14
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Scaling Bitcoin with Subchains 
On Mon, Jun 15, 2015 at 1:09 PM, Pieter Wuille As noted to Adam last night - although I agree it adds complexity - side
chains are one solution that will indeed help with scaling long term.
Similar to the graph you see with git repos and merges, having aggregation
chains that arbitrarily fork and then rejoin the main chain are both
feasible and useful.
That code & future is a ways away from production, so doesn't help us
here.  Still, let's not dismiss it as a solution either.

@_date: 2015-06-15 14:01:55
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Scaling Bitcoin with Subchains 
Side chains are a way to scale and shard horizontally while still retaining
primary security parameters of the main chain.
The future is an Internet of chains, a forest of chains with bitcoin as the
root chain for: factom / proofofexistence, ChainDB, Blockstream side
chains, merge mined side chains, and more.  A multi-chain design is much
more scalable in general.

@_date: 2015-06-18 10:53:24
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Concerns Regarding Threats by a Developer 
On Thu, Jun 18, 2015 at 8:29 AM, Pieter Wuille Indeed.  I think Mike is glossing over this major facet.
Consensus changes - worded another way - change Bitcoin's Constitution -
The Rules that everyone in the system is -forced- to follow, or be ignored
by the system.
Changing bitcoin's rules IS IN NO WAY like Wikipedia or other open source

@_date: 2015-06-18 10:56:33
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Concerns Regarding Threats by a Developer 
Impacts, yes, decider, no.  Multiple ACKs are required from developers who
will not act if the community will disagree with the change.
The users ultimately choose by deciding which software to download, and
that dictates the range of choices available.

@_date: 2015-06-18 09:28:43
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Concerns Regarding Threats by a Developer 
This is an engineering list.  The quote precisely describes how the bitcoin
consensus system functions.
Users' choice is largely binary:  Follow the rules, or bitcoin software
ignores you.

@_date: 2015-06-18 14:58:06
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Concerns Regarding Threats by a Developer 
Is that a forward-looking position?  It does not seem so.
The whole point is getting out in front of the need, to prevent significant
negative impact to users when blocks are consistently full.
To do that, you need to (a) plan forward, in order to (b) set a hard fork
date in the future.
"We don't see a need today" is therefore useless, because when you do reach
X day when need is apparent, the best solution then becomes an immediate
fork for which the network and markets are not prepared.
Failing to resolve the block size issue soon will simply result in most
businesses assuming relevant Bitcoin Core standards process is failing, and
proceed with the Bitcoin-XT fork.
As I've said on IRC, the "do nothing, for now" position is untenable.

@_date: 2015-06-18 15:52:48
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Concerns Regarding Threats by a Developer 
On Thu, Jun 18, 2015 at 3:33 PM, Mark Friedenbach This is a long, unreasonable list of work.  None of this exists and it
equates to "upgrade all wallets and websites everywhere"  It requires all
exchanges, payment processors, merchants, etc. to  - basically everybody
but miners - to update.
It is a far, far larger amount of work to write, test and deploy than
simply increasing the block size limit.
Think through roll-out of these ambitious suggestions, before suggesting as
an alternative!
Not a realistic alternative except in an alternate universe where (a)
developer work at all companies is cost free, plus (b) we can pause the
business universe while we wait for The Perfect Solution.

@_date: 2015-06-18 22:28:44
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] FYI - Mailing List Move Preparations 
Thanks for setting this up, Warren!
On Thu, Jun 18, 2015 at 9:57 PM, Warren Togami Jr.

@_date: 2015-06-19 08:39:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] F2Pool has enabled full replace-by-fee 
This is very disappointing.  "scorched earth" replace-by-fee implemented
first at a pool, without updating wallets and merchants, is very
anti-social and increases the ability to perform Finney attacks and
The community is progressing more towards a safer replace-by-fee model, as
indicated by the following code change:

@_date: 2015-06-19 08:42:53
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] F2Pool has enabled full replace-by-fee 
This is no excuse for further degrading the overall network security.
There are many issues to address in the bitcoin ecosystem.  It negatively
impacts users to roll out "scorched earth" replace-by-fee given today's
Yes, zero conf security is poor.  An outright attack on zero conf degrades
user security even more.

@_date: 2015-06-19 10:40:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] F2Pool has enabled full replace-by-fee 
Making multiple incompatible versions of a spend is a -requirement- of
various refund contract protocols.

@_date: 2015-06-19 10:50:15
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] F2Pool has enabled full replace-by-fee 
No.  You cannot know which is the 'right' or wrong transaction.  One tx has
obvious nSequence adjustments, the other - the refund transaction - may not.

@_date: 2015-06-19 13:44:52
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Mailman incompatibility with DKIM ... 
That seems to change Reply behavior for those recipients?  It would seem to
accidentally direct mail intended to DKIM-user + list to DKIM-user.

@_date: 2015-06-19 14:15:21
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] F2Pool has enabled full replace-by-fee 
Double spend detection is by definition best-effort.
The purpose of bitcoin is to provide security (confirmations) to otherwise
insecure, possibly double spent transactions.

@_date: 2015-06-20 23:45:34
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] F2Pool has enabled full replace-by-fee 
Can you be specific?  What precise technical steps would you have BitPay
and Coinbase do?  We upgrade our stuff to... what exactly?

@_date: 2015-06-21 09:54:08
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Question regarding transactions with 
Yes, that is correct.  The network will not relay until locktime reaches
"maturity", i.e. it can be confirmed into a block.
The wallet holds onto the transaction -- or simply does not generate --
until it can be confirmed.

@_date: 2015-06-21 12:49:41
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] F2Pool has enabled full replace-by-fee 
Already done -- BitPay merchants choose their level of transaction
security.  Level of confirmations is directly exposed to merchants, so that
they choose the level of risk for themselves.
Physically shipped orders and subscriptions are actually the easy cases and
are already handled.  These can accept 0-conf for an initial order phase,
then have the luxury of time to wait for confirmations before shipping /
canceling a subscription.
Electronic goods instantly delivered are the toughest use case.  Even
there, merchants choose their level of risk.
The system requests this information on orders yes.  Merchants also collect
this info as their needs dictate.
Definitely looking at or have implemented this sort of stuff.  I cannot get
into detail in public...

@_date: 2015-05-07 10:04:21
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
I have a lot more written down, a WIP; here are the highlights.
- The 1MB limit is an ancient anti-spam limit, and needs to go.
- The 1MB limit is economically entrenched at this point, and cannot be
removed at a whim.
- This is a major change to the economics of a $3.2B system.  This change
picks winners and losers.  There is attendant moral hazard.
- The core dev team is not and should not be an FOMC.
- The bar for "major economic change to a $3.2B system" should necessarily
be high.  In the more boring world of investments, this would accompanied
by Due Diligence including but not limited to projections for success,
failure scenarios, upside risks and downside risks.  Projections and
fact-based simulations.
- There are significant disruption risks on the pro (change it) and con
(keep 1MB) sides of the debate.
- People are privately lobbying Gavin for this.  That is the wrong way to
go.   I have pushed for a more public debate, and public endorsements (or
condemnations) from major miners, merchants, payment processors,
stackholders, ...   It is unfair to criticize Gavin to doing this.

@_date: 2015-05-07 11:04:58
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
On Thu, May 7, 2015 at 10:38 AM, Justus Ranvier heh - I tend to think people here want bitcoin to succeed.  My statement
refers to picking winners and losers from within the existing bitcoin
community & stakeholders.
The existential question of the block size increase is larger - will
failing to increase the 1MB limit permanently stunt bitcoin's growth?

@_date: 2015-05-07 11:09:18
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
100% agree, RE hard forks should be hard.
However, it is the paradox of growth, morale and adoption that bitcoin
might never reach the point where it is saturated & expensive to the point
where larger blocks are demanded by 95%+...  simply because people and
companies chose not to adopt bitcoin in the first place due to an unmoving,
[perceived | real] scalability roadblock.

@_date: 2015-05-07 11:17:03
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
Yes, that is a possibility.
This is absolutely not a trivial change.
It is a trivial *code* change.  It is not a trivial change to the economics
of a $3.2B system.

@_date: 2015-05-07 11:27:39
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
On Thu, May 7, 2015 at 11:16 AM, Justus Ranvier Avoid such narrow, binary thinking.
Referencing the problem described in
(not the solution - block size change - just the problem, tx/block Poisson
This problem - block creation is bursty - is fundamental to bitcoin.
Raising block size does not fix this problem (as [1] notes), but merely
kicks the can down the road a bit, by hiding it from users a bit longer.
Bitcoin is a settlement system, at the most fundamental engineering level.
It will never be an instant payment system for all the world's coffees (or
all the world's stock trades).  It is left to "Layer 2" projects to
engineer around bitcoin's gaps, to produce an instant, secure, trustless,
egalitarian payment system using the bitcoin token.  [1] also notes this.
It is therefore not a binary decision of leaving room for other projects,
or not.  Layer-2 projects are critical to the success of bitcoin, and
complement bitcoin.
[1] Holistic thinking implies you build a full-stack system with bitcoin

@_date: 2015-05-07 11:35:47
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
Yes - but you must recognize that is precisely 50% of the picture.
Others have made different assumptions - taking the [1MB-constrained]
market *as it exists today*, rather than in some projected future.
Raising the block size limit then becomes a *human decision* to favor some
users over others, a *human decision* to prevent an active and competitive
free fee market developing at 1MB, a *human decision* to keep transaction
fees low to incentivize bitcoin adoption, a *human decision* to value
adoption over decentralization.
These statements are not value judgements - not saying you are wrong -
these are observations of some rather huge, relevant blind spots in this

@_date: 2015-05-07 11:47:00
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
On Thu, May 7, 2015 at 11:33 AM, Justus Ranvier Incorrect; your question included built-in assumptions with which I
Bitcoin needs to be the best it can be (Layer 1), but all solutions cannot
and should not be implemented at Layer 1.
We need to scale up both bitcoin (L1) and solutions built on top of bitcoin

@_date: 2015-05-07 11:56:36
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
Dear list,
Apparently my emails are being marked as spam, despite being sent from
GMail's web interface.  I've pinged our sysadmin.  Thanks for letting
me know.

@_date: 2015-05-07 15:13:23
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
On Thu, May 7, 2015 at 3:03 PM, Matt Corallo This sub-thread threatens to veer off into he-said-she-said.
Agreed, but that is water under the bridge at this point.  You - rightly -
opened the topic here and now we're discussing it.
Mike and Gavin are due the benefit of doubt because making a change to a
leaderless automaton powered by leaderless open source software is breaking
new ground.  I don't focus so much on how we got to this point, but rather,
where we go from here.

@_date: 2015-05-07 15:54:13
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
Er, to be economically precise, "full" just means fees are no longer zero.
Bitcoin behaves as it always has.  It is no longer basically free to dump
spam into the blockchain, as it is today.
In the short term, blocks are bursty, with some on 1 minute intervals, some
with 60 minute intervals.  This does not change with larger blocks.
 [...]
1) Agree that 7 tps is too low
2) Where do you want to go?  Should bitcoin scale up to handle all the
world's coffees?
This is hugely unrealistic.  700 tps is 100MB blocks, 14.4 GB/day -- just
for a single feed.  If you include relaying to multiple nodes, plus serving
500 million SPV clients en grosse, who has the capacity to run such a
node?  By the time we get to fee pressure, in your scenario, our network
node count is tiny and highly centralized.
3) In RE "fee pressure" -- Do you see the moral hazard to a software-run
system?  It is an intentional, human decision to flood the market with
supply, thereby altering the economics, forcing fees to remain low in the
hopes of achieving adoption.  I'm pro-bitcoin and obviously want to see
bitcoin adoption - but I don't want to sacrifice every decentralized
principle and become a central banker in order to get there.

@_date: 2015-05-07 22:09:42
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
G proposed 20MB blocks, AFAIK - 140 tps
A proposed 100MB blocks - 700 tps
For ref,
Paypal is around 115 tps
VISA is around 2000 tps (perhaps 4000 tps peak)
I ask again:  where do we want to go?   This is the existential question
behind block size.
Are we trying to build a system that can handle Paypal volumes?  VISA
It's not a snarky or sarcastic question:  Are we building a system to
handle all the world's coffees?  Is bitcoin's main chain and network -
Layer 1 - going to receive direct connections from 500m mobile phones,
broadcasting transactions?
We must answer these questions to inform the change being discussed today,
in order to decide what makes the most sense as a new limit.  Any
responsible project of this magnitude must have a better story than "zomg
1MB, therefore I picked 20MB out of a hat"  Must be able to answer /why/
the new limit was picked.
As G notes, changing the block size is simply kicking the can down the
road: Necessarily one must ask, today, what happens when we get to the end of
that newly paved road.

@_date: 2015-05-08 06:00:37
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Assurance contracts to fund the network 
That reminds me - I need to integrate the patch that automatically sweeps
anyone-can-pay transactions for a miner.

@_date: 2015-05-08 11:49:48
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Block Size Increase 
To repeat, the very first point in my email reply was: "Agree that 7 tps is
too low"  Never was it said that bit
Therefore a reply arguing against the low end is nonsense, and the relevant
question remains on the table.
How high do you want to go - and can Layer 1 bitcoin really scale to get
It is highly disappointing to see people endorse "moar bitcoin volume!"
with zero thinking behind that besides "adoption!"  Need to actually
project what bitcoin looks like at the desired levels, what network
resources are required to get to those levels -- including traffic to serve
those SPV clients via P2P -- and then work backwards from that to see who
can support it, and then work backwards to discern a maximum tps.

@_date: 2015-05-10 10:33:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] A suggestion for reducing the size of the 
This has been frequently explored on IRC.
My general conclusion is "dollar bills" - pick highly common denominations
of bitcoins.  Aggregate to obtain these denominations, but do not aggregate
This permits merge avoidance (privacy++), easy coinjoin where many hide in
the noise (privacy++), wallet dust de-fragmentation, while avoiding the
over-aggregation problem where you have consolidated down to one output.
Thus a wallet would have several consolidation targets.
Another strategy is simply doubling outputs.  Say you pay 0.1 BTC to
Starbucks.  Add another 0.1 BTC output to yourself, and a final change
output.  Who can say which output goes to Starbucks?
There are many iterations and trade-offs between fragmentation and privacy.
On Sun, May 10, 2015 at 9:35 AM, Bob McElrath

@_date: 2015-05-12 09:05:44
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposed additional options for pruned 
A general assumption is that you will have a few archive nodes with the
full blockchain, and a majority of nodes are pruned, able to serve only the
tail of the chains.

@_date: 2015-05-12 12:38:20
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposed additional options for pruned 
One general problem is that security is weakened when an attacker can DoS a
small part of the chain by DoS'ing a small number of nodes - yet the impact
is a network-wide DoS because nobody can complete a sync.
On Tue, May 12, 2015 at 12:24 PM, gabe appleton

@_date: 2015-05-12 13:10:56
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Proposed additional options for pruned 
True.  Part of the issue rests on the block sync horizon/cliff.  There is a
value X which is the average number of blocks the 90th percentile of nodes
need in order to sync.  It is sufficient for the [semi-]pruned nodes to
keep X blocks, after which nodes must fall back to archive nodes for older
There is simply far, far more demand for recent blocks, and the demand for
old blocks very rapidly falls off.
There was even a more radical suggestion years ago - refuse to sync if too
old (>2 weeks?), and force the user to download ancient data via torrent.

@_date: 2015-05-20 08:54:33
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Virtual Notary. 
For what it's worth, a subsidiary of Dunvegan Space Systems is pursuing
exactly this as a business.
EMail JGarzik at DSS.co if you want to know more.

@_date: 2015-05-26 18:29:40
@_author: Jeff Garzik 
@_subject: [Bitcoin-development] Cost savings by using replace-by-fee, 
That attitude and doxxing is not appropriate for this list.
