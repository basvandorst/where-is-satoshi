
@_date: 2015-04-28 12:17:27
@_author: Oleg Andreev 
@_subject: [Bitcoin-development] 75%/95% threshold for transaction versions 
Can't we add requirement for RFC6979 signatures to mitigate this? Of course, multiple signers can still mutate transaction by choosing a different set (but not the order, thankfully) of signatures. Or when a single signer has multiple participating keys.
In some interesting to me scenarios mutation by signer is not critical: it is mutation by non-signers that creates a problem. Do you know of any edge cases when non-signers can mutate transactions which are not covered by BIP62? What would be a more robust approach than "whack-a-mole" to work around mutability? (Normalized tx ids?)

@_date: 2015-02-10 11:50:34
@_author: Oleg Andreev 
@_subject: [Bitcoin-development] Standardizing automatic pre-negotiation 
Why my wallet has to do anything with me being in some country? The webshop may detect my location and tell me if they ship to where I'm currently in. Why should I associate more private information (my location) with my wallet than strictly necessary? Why should I automatically advertise my shipping address to every webshop without my explicit consent?
The wallet must be convenient only as much as it allows for better security and privacy, but not trading off security and privacy for some unrelated convenience.

@_date: 2015-02-12 14:36:52
@_author: Oleg Andreev 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
How about a Ripple-like IOU-based payment network that is 100% decentralized, for "dumb and daily" payments only? IOUs will propagate from node to node and will trusted because of a "joint escrow" transaction between each pair of nodes (locking up certain amount on both ends in 2-of-2 multisig). Total amount of debt from one node to another will be limited to 50% of the locked amount (e.g. if both nodes lock up $20 each, they allow debt up to $10 in each direction). When debt is reaching its limit, it's being "cleared" by debtor via a real BTC transaction or simply by "closing" the contract transaction with correct proportion on outputs to pay off the debt.
Every node may require an arbitrary fee for a service of providing his funds to back IOUs, when making a payment, merchant/customer may find several possible "paths" and choose the quickest/cheapest one to use. Centralization is possible at a proportional capital expense. If some node wants to be Visa-scale with millions of contracts and a lot of fees to earn, they'll have to lock up huge amount of money. This puts natural limit on centralization or associated risk. I pay $10. The following path is discovered and signed off by the Merchant who accepts an ad-hoc 0.3% fee:
Me: $10 -> $9.99 (Alice) -> $9.98 (Bob) -> $9.97 (Merchant).
Now I owe $10 to Alice, Alice owes $9.98 to Bob, Bob owes $9.97 to Merchant. Clearing of debts happens independently between each participant based on their debt-to-capital ratio and whether any party wishes to exit. Of course, if several paths are discovered within a reasonable timeframe, Merchant will choose the cheapest one. And maybe abort transaction if the proposed path is too expensive (e.g. total fee is >1%).
- Decentralized.
- Mere seconds to settle a payment.
- Infinite scalability (no global consensus). Each payment involves 5-7 nodes only.
- No trusted parties or federation (trust is "purchased" using "joint escrow" txs on blockchain)
- No funny currency, IOUs denominated in BTC.
- No global consensus or protocol. Nodes can be semi-compatible, upgrade independently. All risks are local.
Political problems solved:
- No need to debate zeroconf transactions. We don't *need* them anymore to buy a coffee.
- No need to debate block size limit. It'd still be nice to raise it when needed, but for 99% of transactions we'll have a good decentralized solution off-chain, so the issue is less pressing.
- Some amount of cash needs to be locked up with random nodes most of the time. If one of the nodes is offline, payments can't be cleared through that node. Although, it could not be a big problem as the network is useful for small-ish payments and every node will have 10-15 contracts, so it will tolerate occasional unavailability of some of them.

@_date: 2015-02-12 18:24:40
@_author: Oleg Andreev 
@_subject: [Bitcoin-development] replace-by-fee v0.10.0rc4 
Here's value-free assessment of the issue here:
1. Zero-conf txs are unsafe.
2. We'd all want to have a safer instant payments solution if possible.
3. As a social artifact, today zeroconf txs happen to work for some people in some situations.
4. Replace-by-fee will break  and probably hasten development of The discussion boils down to whether we should make  happen sooner by breaking remnants of  sooner.
I personally would rather not break anything, but work as fast as possible on  so no matter when and how  becomes utterly broken, we have a better solution. This implies that I also don't want to waste time debating with Peter Todd and others. I want to be ready with a working tool when zeroconf completely fails (with that patch or for some other reasons).
TL;DR: those who are against the patch are better off building a decentralized clearing network rather than wasting time on debates. When we have such network, we might all want this patch to be used for all the reasons Peter has already outlined.

@_date: 2015-02-24 16:58:57
@_author: Oleg Andreev 
@_subject: [Bitcoin-development] Providing Payment Request within URI 
I wonder if there is a standard way to put Payment Request data into bitcoin: URI or directly into QR code. The goal is to allow device to generate a multi-output payment request on its own, without relying on the server and x509 certificates. When scanned via QR code from, say, POS, it's pretty secure, so no additional authentication needed.
I'd like something like this: If there's no standard for that, would it be a good idea to extend BIP72 this way?

@_date: 2015-02-26 10:48:49
@_author: Oleg Andreev 
@_subject: [Bitcoin-development] Providing Payment Request within URI 
Thanks for references. Yeah, I don't need X509 signing (if I could use certificates, I wouldn't need to include PR in the URL in the first place).
I presume you used "BITCOIN:-" instead of "bitcoin:?r=somescheme://" to make it more compact. I also tried to look up Base43, but I could not find any info on how it is specifically optimized for QR codes. Could you enlighten me?

@_date: 2015-02-26 12:14:22
@_author: Oleg Andreev 
@_subject: [Bitcoin-development] Providing Payment Request within URI 
Does it mean Base58 or Base64 take more space in QR code than Base43? Do you have an estimate of the gains?

@_date: 2015-07-31 14:32:53
@_author: Oleg Andreev 
@_subject: [bitcoin-dev] 
=?utf-8?q?ee_market_from_a_worried_local_trader?=
Fees should be compared not with the total revenue, but with the profit margin. If a miner invested/spends 24 BTC per block and earns 0.25 in fees, then his total profit is 1.25 BTC per block and fees comprise a whopping 20% of the profit. Today I think profit margins are quite high, so fees do not matter much. But it's not hard to imagine that in just a couple of years BTC may appreciate a lot more, attract more investors and even bigger foundries to, say, print chips and mine right at the foundry, thus driving profit margins lower. Fees will begin to matter regardless of the total subsidy. Just some hypothetical calculation.
Lets say in 2015 one block costs 5 BTC and fees bring 0.25 BTC. Profit is thus 20.25 BTC and fees comprise 1.2% of that amount.
Lets say in late 2016 halving happens, BTC appreciates and resulting competition drives up the cost to 6 BTC (yes, BTC itself is more expensive, but so is the profit too, so increased competition must drive down the profit margin). Now the block brings 6.75 BTC in profit. Fees, if unchanged now make 4% of the total profit.
If all goes well, in mid 2020 another halving happens (6.25 BTC/block) and even if the BTC-denominated cost stays the same miner now will earn 0.25 BTC profit from subsidy and fees now can account for 100% of that amount. Of course it's a very rough estimate and most likely to be far from reality, but it shows how fees can begin to matter rather quickly under pressure of separate factors: halving and growing valuation and mining competition.

@_date: 2015-11-06 10:32:02
@_author: Oleg Andreev 
@_subject: [bitcoin-dev] Dealing with OP_IF and OP_NOTIF malleability 
These two lines contradict each other. Minimally-encoded "zero" is an array of length zero, not one. I'd suggest defining this explicitly here as "IF/NOTIF argument must be either zero-length array or a single byte 0x01".

@_date: 2015-11-10 11:52:46
@_author: Oleg Andreev 
@_subject: [bitcoin-dev] Dealing with OP_IF and OP_NOTIF malleability 
OP_0 gives a zero length byte array because OP_0 == 0x00 which is equivalent to pushdata with zero length.
OP_EQUAL compares byte strings as-is. So it will push "false" because empty string is not the same as a single-byte string with 0x00 byte in it. Value "false" in turn is encoded as empty string, just like result of OP_0.

@_date: 2017-04-12 17:43:50
@_author: Oleg Andreev 
@_subject: [bitcoin-dev] Deploying CT in Bitcoin without extension blocks? 
(This is a sketch, not a fully-formed proposal, just to kick off the discussion.)
Confidential Transactions (by GMaxwell & Poelstra) require a new accounting model, new representation of numbers (EC points as Pedersen commitments) and range proofs per number. Setting aside performance and bandwidth concerns (3-4Kb per output, 50x more signature checks), how would we deploy that feature on Bitcoin network in the most compatible manner?
I'll try to present a sketch of the proposal. I apologize if this discussion already
happened somewhere, although I couldn't find anything on this subject, apart from Elements sidechain proposal, of course.
At first glance we could create a new extblock and transaction format, add a protocol to
"convert" money into and from such extblock, and commit to that extblock from the outer block's coinbase transaction. Unfortunately, this opens gates to a flood of
debates such as what should be the block size limit in such block, should we take opportunity to fix over 9000 of pet-peeve issues with existing transactions
and blocks, should we adjust inflation schedule, insert additional PoW, what would
Satoshi say etc. Federated sidechain suffers from the same issues, plus adds concerns regarding governance, although it would be more decoupled, which is useful.
I tried to look at a possibility to make the change as compatible as possible,
sticking confidential values right into the existing transaction structure and
see how that would look like. As a nice bonus, confidential transactions would have to fit into the hard-coded 1 Mb limit, preserving the drama around it :-P
We start with a segwit-enabled script versioning and introduce 2 new script versions:
version A has an actual program concatenated with the commitment, while version B has only the commitment and allows mimblewimble usage (no signatures, non-interactive cut-through etc). Legacy cleartext amount can nicely act as "min value" to minimize
the range proof size, and range proofs themselves are provided separately in the
segregated witness payload.
Then, we soft fork additional rules:
1. In non-coinbase tx, sum of commitments on inputs must balance with sum of commitments
   on the outputs plus the cleartext mining fee in the witness.
2. Range proof can be confidential, based on borromean ring signature.
3. Range proof can be non-confidential, consisting of an amount and raw blinding factor.
4. Tx witness can have an excess value (cf. MW) and cleartext amount for a miner's fee.
5. In coinbase tx, total plaintext reward + commitments must balance with subsidy,    legacy fees and new fees in the witness.
6. Extra fees in the witness must be signed with the excess value's key.
The confidential transactions use the same UTXO set, can be co-authored with plaintext inputs/outputs
using legacy software and maybe even improve scalability by compressing on-chain transactions
using mimblewimble cut-through.
The rules above could have been made more complicated with export/import logic to allow users
converting their coins to and from confidential ones, but that would require
more complex support from miners to respect and merge outputs representing "plaintext value bank",
mutate export transactions, which in turn requires introduction of a non-malleable TxID
that excludes miner-adjustable export/import outputs.
The rules above have a nice side effect that miners, being the minters of confidential coins, can sell them at a premium, which creates an incentive for them to actually support
that feature and work on improving performance of rangeproof validation (e.g. in GPUs).
Would love to hear comments and criticism of that approach.

@_date: 2019-02-01 09:56:49
@_author: Oleg Andreev 
@_subject: [bitcoin-dev] Predicate Tree in ZkVM: a variant of 
A follow-up comment: I've have sent this email right before Pieter's talk on miniscript at Stanford yesterday. I want to express my appreciation to the thinking about scripts/contracts that Pieter, Andy, Greg have been promoting for long time. These ideas influenced a lot the design decisions in ZkVM: "blockchain as a court", very limited functionality and clarity of scripts, and, as Pieter laid out yesterday, composition of policies. These are all the same values that I'm trying to reflect in ZkVM, that's why i think it might be interesting to this mailing list.
Also, Neha Narula asked a question this morning:
The answer: hopefully it's not a DoS vector, we are working on this right now. Programs for `call` and `delegate` have to be statically built into the transaction bytecode string, and cannot be constructed within the VM (so it's very similar to P2SH). ZkVM is similar to Bitcoin Script in that the execution cost is proportional to the program length: one cannot make a short program that would use loops or recursion into dynamically constructed programs to exhibit arbitrary validation cost. For those familiar with TxVM released last year, we are removing loops and dynamic program construction, and gas-like "runlimit" with them from ZkVM.
Another feature is inspired by old proposal by Pieter (IIRC) to treat checksig as all-or-nothing. ZkVM does not do dynamic branching based on outcomes of expensive operations. Signature checks, predicate tree traversal - all have to unconditionally succeed.
1. This makes the program execution (w/o ECC ops) very fast and proportional to the length of the program.
2. Then, all the collected ECC ops give precise metric of how expensive the rest of the validation would be.
3. Plus, the constraint system proof blob (that comes with the transaction) by itself gives an exact measurement of the bulletproofs validation cost.
The upstream protocol ("blockchain rules") can have soft- or hard- caps on both program length and amount of ECC operations (similar to the limit on sig checks per block in Bitcoin). That said, we haven't drilled into specifics what these caps should be and how they should be enforced, that's still in the works.

@_date: 2019-01-31 15:44:43
@_author: Oleg Andreev 
@_subject: [bitcoin-dev] Predicate Tree in ZkVM: a variant of Taproot/G'root 
============================== START ==============================
We've been working for a thing called ZkVM [1] for the last few weeks. It is a "blockchain virtual machine" in the spirit of Bitcoin, with multi-asset transfers and zero-knowledge programmable constraints.
As a part of its design, there is a "Predicate Tree" ? a variant of Taproot by Greg Maxwell [2] and G'root by Anthony Towns [3] that I would like to present here. Hopefully it is useful to the discussion, and I would appreciate any feedback.
 Background
In ZkVM there are linear types Contract and Value (in addition to plain data types), where Contract also implements "object capabilities" pattern: Contract "locks" a collection of data and Values under a "predicate" which is represented by a single group element ("point" in ECC terms). The predicate can be "satisfied" in a number of allowed ways which makes the contract unlock its contents, e.g. release the stored Value which can then be locked in a new unspent output.
 Predicate Tree
Predicate is a point that represents one of three things, which allows composing conditions in an arbitrary tree:
1. Public key
2. Program
3. Disjunction of two other predicates
Public key allows representing N-of-N signing conditions (and M-of-N with proper threshold key setup, although small combinations like 2-of-3 can be non-interactively represented as a tree of 3 combinations of 2-of-2 conditions):
   P = x*B  (x is a secret, B is a primary generator point)
Program commitment is a P2SH-like commitment:
   P = hash2scalar(program)*B2   (B2 is orthogonal to B, so one cannot sign for P, but must reveal the program)
Disjunction (asymmetric to allow happy-path signing with the left predicate):
   P = L + hash2scalar(L,R)*B
 VM instructions
To use the predicate trees, ZkVM provides 4 instructions:
1. `signtx` to verify the signature over the transaction ID treating the predicate as a pubkey.
2. `call` to reveal the committed program and execute it.
3. `left`/`right` to replace the contract's predicate with one of the sub-predicates in a disjunction.
4. `delegate` to check a signature over a program and execute that program (pay-to-signed-program pattern).
More details are in the ZkVM spec: `call` and `delegate` differ in that `call` reveals and runs a pre-arranged program (like in P2SH), while `delegate` allows choosing the program later which can be signed with a pre-arranged public key. `delegate` also enables use cases for SIGHASH: if a specific output or outputs or constraints must be signed, they can be represented by such program snippet. Likewise, a "revocation token" for the payment channel (LN) can be implemented with `delegate` instruction.
 Performance
For performance, the following rules are built into ZkVM:
1. All point operations are deferred. Signature checks, disjunction proofs, program commitment proofs - are not executed right away, but deferred and verified in a batch after the VM execution is complete. This enables significant savings, especially since half or third of the terms reuse static points B and B2.
2. `signtx` does not accept individual signatures, but uses a single aggregated signature for the whole transaction. All the pubkeys are remembered in a separate set and combined via MuSig-style [4] protocol to check the single 64-byte signature over txid in the end of the VM execution. In other words, signature aggregation is not optional for `signtx` (signatures over txid). Note: the `delegate` instruction permits arbitrary programs, so it uses one signature per program.
 What is different from Taproot/G'root
(1) No pure hash-based MAST: each time one peels off a layer of a tree, there's an ECC check which is more expensive than pure-hash merkle path check, but makes the design simpler and all ECC ops are batched alongside bulletproofs R1CS verification statement, making the performance difference unimportant.
(2) There is no designated blinding factor or a pubkey with the program commitment like in G'root. This is not something i'm particularly sure about, but will lay out the current rationale:
1. The happy-path one-time-key normally acts as a sufficient blinding factor for the program.
2. If the program needs a blinding factor, it can be embedded as a ` drop`.
3. The combo of "sign + programmatic constraints" is done by having instructions inside the program that wrap the value(s) in a transient contract with the required pubkey and leaving it on the stack.
 References
[1] [2] [3] [4]
