
@_date: 2014-05-12 18:21:44
@_author: Peter Grigor 
@_subject: [Bitcoin-development] Bitcoin Fee Formula Proposal 
This was originally submitted to the bitcoin github issue manager. I'm
re-posting here.
I propose the transaction fee should be calculated from a percentage of the
input amount divided by the confirmations of the input multiplied by the
number of inputs.
By using a percentage of the input amount the transaction fee will always
make sense no matter what the "price" of bitcoins may be in fiat; by
dividing the fee by the number of confirmations we discourage hasty spends
and reward savings (ie. old inputs); by multiplying the fee by the number
of inputs we discourage "payment fragmenting."
Let me further explain payment fragmenting by way of an example: Let's say
I get paid $2,500 in bitcoins per month from my job. If I then take that
$2,500 and pay for a coffee (right away, 1 confirmation) I'll be charged a
fee of $2.50 because I'm charged according to the *input amount*, not the
actual transaction size. Because of this it would behove my employer to pay
me the $2,500 as one transaction with, perhaps, 100 output addresses at $25
apiece so that when I pay for my coffee I use one of the $25 unspent
outputs. By multiplying the transaction fee be the number of inputs this
provides a disincentive for payment fragmenting as multiple inputs will be
required to pay for larger purchases.
Furthermore this provides an incentive for wallet software to use the
oldest input(s) which most closely match the transaction amount. For the
example above: In real life a user's wallet would have a number of inputs
to choose from and wouldn't use the newest "paycheck" input for the coffee
purchase. Furthermore, even if the $2,500 input was the only input
available, by waiting for 100 confirmations (less than a day) the
transaction fee would be 2.5 cents.
Transaction fees would then be calculated by the following formula:
((INPUT_AMOUNT * BASE_PERCENT) / CONFIRMATIONS) * NUMBER_OF_INPUTS
The INPUT_AMOUNT, CONFIRMATIONS and NUMBER_OF_INPUTS would be determined by
the creator of the transaction and should be optimized for the transaction
amount -- the BASE_PERCENT would be hard-coded in the bitcoind software.
The special case of zero CONFIRMATIONS will be treated as 1 confirmation in
order to avoid a divide by zero error.
For example: if I choose a BASE_PERCENT of 0.1% and one input it will cost:
   - $1 to send $1,000,000 that has 100 confirmations;
   - $0.10 (10 cents) to send $1,000,000 that has 1,000 confirmations
   (approx. 1 week);
   - $0.10 (10 cents) to send $100 which has 1 confirmation;
   - $0.01 (1 cent) to send $100 which has 10 confirmations;
   - $0.001 (1/10 cent) to send $100 which has 100 confirmations (less than
   a day);
I've put together a spreadsheet which shows the various fees by amount and
confirmations -- the spreadsheet assumes one input for a transaction:

@_date: 2015-06-30 16:41:29
@_author: Peter Grigor 
@_subject: [bitcoin-dev] A possible solution for the block size limit: 
The block size debate centers around one concern it seems. To wit: if block
size is increased malicious miners may publish unreasonably large "bloated"
blocks. The way a miner would do this is to generate a plethora of private,
non-propagated transactions and include these in the block they solve.
It seems to me that these bloated blocks could easily be detected by other
miners and full nodes: they will contain a very high percentage of
transactions that aren't found in the nodes' own memory pools. This
signature can be exploited to allow nodes to reject these bloated blocks.
The key here is that any malicious miner that publishes a block that is
bloated with his own transactions would contain a ridiculous number of
transactions that *absolutely no other full node has in its mempool*.
Simply put, a threshold would be set by nodes on the allowable number of
non-mempool transactions allowed in a solved block (say, maybe, 50% -- I
really don't know what it should be). If a block is published which
contains more that this threshold of non-mempool transactions then it is
If this idea works the block size limitation could be completely removed.
