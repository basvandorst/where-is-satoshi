
@_date: 2017-12-14 17:11:17
@_author: Clark Moody 
@_subject: [bitcoin-dev] BIP Proposal: Utilization of bits denomination 
An alternative to "training" users to understand SI prefixes could be to
make 100 satoshi = 1 mu, spelling out the Greek letter.
Although the Units  page on the wiki has
been brought up to argue against naming 10,000 satoshi = 1 finney, I would
like to support this designation. It seems to be gaining some popular
support on Twitter & podcasts. So at $10,000 BTC/USD, 1 finney = $1.00. The
smallest unit of value would be 0.0001 finney = 1 satoshi. Finney has a
natural abbreviation as fin, and 100 mu = 1 finney.
The Units page also refers to "bitcent" as 0.01 BTC, but if a "bit" is 100
satoshi, then what is a "bitcent" in that context?
 you're exactly right. There are already multiple uses of "bits"
within bitcoin itself.
 I don't think a redefinition of 'satoshi' is going to happen ;-)
On Thu, Dec 14, 2017 at 4:01 PM, Natanael via bitcoin-dev <

@_date: 2017-07-14 13:43:37
@_author: Clark Moody 
@_subject: [bitcoin-dev] A BIP proposal for conveniently referring to 
(copying from GitHub per jonasschnelli's request)
I can understand the desire to keep all reference strings to the nice
14-character version by keeping the data payload to 40 bits, but it
seems to place artificial limitations on the format (year 2048 & 8191
transactions). I also understand that this might be addressed with
Version 1 encoding. But current blocks are not that far from having
8191 transactions.
You could go with a variable-length encoding similar to Bitcoin's
variable ints and gain the benefit of having a format that will work
for very large blocks and the very far future.
Also, the Bech32 reference libraries allow encoding from byte arrays
into the base-5 arrays native to Bech32. It seems like bit-packing to
these 40 bits might be overkill. As an alternative you could have one
bit-packed byte to start:
# First two bits are the protocol version, supporting values 0-3
V = ((protocol version) & 0x03) << 6
# Next two bits are magic for the blockchain
# 0x00 = Bitcoin
# 0x01 = Testnet3
# 0x02 = Byte1 is another coin's magic code (gives 256 options)
# 0x03 = Byte1-2 is treated as the coin magic code (gives 65280 more options)
M = (magic & 0x03) << 4
# Next two bits are the byte length of the block reference
B = ((byte length of block reference) & 0x03) << 2
# Final two bits are the byte length of the transaction index
T = ((byte length of transaction index) & 0x03)
# Assemble into the first byte
Byte0 = V | M | B | T
This gives you up to 3 bytes for each block and transaction reference,
which is 16.7 M blocks, or year 2336, and 16.7 M transaction slots.
Data part: [Byte0][optional magic bytes 1-2][block reference bytes][tx
reference bytes]
So the shortest data part would have 3 bytes in it, with the reference
version 0 genesis coinbase transaction having data part 0x050000.
I know this is a departure from your vision, but it would be much more
flexible for the long term.

@_date: 2018-04-25 09:35:57
@_author: Clark Moody 
@_subject: [bitcoin-dev] Multi-signature and multi-coin HD wallet in one 
Thanks for the proposal, Paul.
*> - What address format is expected when discovering balances and creating
Your solution does not solve your first bullet point, since the xpub
encoding looks no different than any other xpub (BIP 44, 45, 49, etc). At
the least, you should propose new version bytes to change the "xpub" in the
encoding to some other string.
Alternatively, I would suggest that you use the xpub serialization format
described in SLIP-0032 (
 It includes
the derivation path within the xpub itself and uses Bech32 for encoding.
Given a normal xpub with no additional information, a wallet must scan the
address space for the various formats. SLIP-0032 solves this bootstrapping
problem and avoids the UX nightmare of users being required to know to
which BIP number the xpub conforms.
Also,  will give you a hard time to self-assigning a BIP number ;-)
On Wed, Apr 25, 2018 at 4:35 AM, Paul Brown via bitcoin-dev <

@_date: 2018-05-04 00:09:38
@_author: Clark Moody 
@_subject: [bitcoin-dev] Multi-signature and multi-coin HD wallet in one 
The current BIP-49 / 84 use the purpose field of the derivation path to specify
the address format.
?I think sticking with the one-BIP-one-format method works. Otherwise, you
would need to modify this proposed BIP each time a new format comes along.
In that case, existing wallets that claim BIP-XXXX compliance will be

@_date: 2018-10-18 09:20:45
@_author: Clark Moody 
@_subject: [bitcoin-dev] BIP for segwit compatibility URIs 
Since we don't know what sort of address changes will happen later on, you
could make this future-proof by passing a list of addresses to `addr`.
The syntax is
The addresses passed as a comma-separated list to the `addr` parameter are
in descending order of preference, with highest first. A consumer of this
URI should attempt to understand each address in the list before falling
back to the next address and finally to the base address after `bitcoin:`.
The spending wallet would attempt to spend to "fancyFutureEncoding0x01"
then to "bech32address1qx01" and finally to "3xBase58compatibleAddress".
On Sun, Oct 14, 2018 at 3:14 PM Srintuar via bitcoin-dev <

@_date: 2018-10-18 17:27:41
@_author: Clark Moody 
@_subject: [bitcoin-dev] BIP for segwit compatibility URIs 
I agree with spelling out the `address` field.
As for "value is either an address or an array of addresses", there is no
standard for specifying an array in a URI, and processing different
querystring schemes is application-specific. (see
Since those app-specific methods don't necessarily preserve order, which is
important here, the most compatible fallback is a delimiter-separated list
under one parameter. Most languages have library functions for splitting
strings on commas.
On Thu, Oct 18, 2018 at 5:13 PM vv01f via bitcoin-dev <

@_date: 2018-09-12 09:54:15
@_author: Clark Moody 
@_subject: [bitcoin-dev] Suggestion for a universal bitcoin value scale 
This is the sort of thing I expect to emerge from the places that use
Bitcoin "on the street." We should be watching how local wallet software
displays bitcoin amounts, letting the standards write themselves over time.
The units debate (bits, millibits, etc) has been going on nearly as long as
I've known about Bitcoin and yet most tools display standard bitcoin
amounts (1 unit = 1e8 satoshi).
On Wed, Sep 12, 2018 at 8:41 AM Martin Damgaard via bitcoin-dev <

@_date: 2019-11-12 20:56:54
@_author: Clark Moody 
@_subject: [bitcoin-dev] Bech32 weakness and impact on bip-taproot 
I agree on all points. The address space already brings enough confusion to
users out there. As it stands, we can use script version and program length
for address validity. Sneaking an alternate checksum into the mix for
different length programs lets us lean on our parsing libraries and not
increase cognitive load for users.
On Sun, Nov 10, 2019 at 7:02 PM Matt Corallo via bitcoin-dev <

@_date: 2020-11-25 09:43:10
@_author: Clark Moody 
@_subject: [bitcoin-dev] Formal specification of Miniscript in Alloy 
Thanks for this! I can't comment on the correctness of your implementation,
but I really appreciate the idea and effort.
By chance, did you come across any other spec definitions in alternate
formal grammars?
On Wed, Nov 25, 2020 at 5:35 AM Dmitry Petukhov via bitcoin-dev <
