
@_date: 2016-02-10 21:15:37
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Clearing up some misconceptions about full nodes 
I've been asked to post this to this mailing list too. It's time to
clear up some misconceptions floating around about full nodes.
=== Myth: There are only about 5500 full nodes worldwide ===
This number comes from this and similar sites: and it measured by trying to probe every nodes on their open ports.
Problem is, not all nodes actually have open ports that can be probed.
Either because they are behind firewalls or because their users have
configured them to not listen for connections.
Nobody knows how many full nodes there are, since many people don't know
how to forward ports behind a firewall, and bandwidth can be costly, its
quite likely that the number of nodes with closed ports is at least
another several thousand.
Nodes with open ports are able to upload blocks to new full nodes. In
all other ways they are the same as nodes with closed ports. But because
open-port-nodes can be measured and closed-port-nodes cannot, some
members of the bitcoin community have been mistaken into believing that
open-port-nodes are that matters.
=== Myth: This number of nodes matters and/or is too low. ===
Nodes with open ports are useful to the bitcoin network because they
help bootstrap new nodes by uploading historical blocks, they are a
measure of bandwidth capacity. Right now there is no shortage of
bandwidth capacity, and if there was it could be easily added by renting
cloud servers.
The problem is not bandwidth or connections, but trust, security and
privacy. Let me explain.
Full nodes are able to check that all of bitcoin's rules are being
followed. Rules like following the inflation schedule, no double
spending, no spending of coins that don't belong to the holder of the
private key and all the other rules required to make bitcoin work (e.g.
Full nodes are what make bitcoin trustless. No longer do you have to
trust a financial institution like a bank or paypal, you can simply run
software on your own computer. To put simply, the only node that matters
is the one you use.
=== Myth: There is no incentive to run nodes, the network relies on
altruism ===
It is very much in the individual bitcoin's users rational self interest
to run a full node and use it as their wallet.
Using a full node as your wallet is the only way to know for sure that
none of bitcoin's rules have been broken. Rules like no coins were spent
not belonging to the owner, that no coins were spent twice, that no
inflation happens outside of the schedule and that all the rules needed
to make the system work are followed  (e.g. difficulty.) All other kinds
of wallet involve trusting a third party server.
All these checks done by full nodes also increase the security. There
are many attacks possible against lightweight wallets that do not affect
full node wallets.
This is not just mindless paranoia, there have been real world examples
where full node users were unaffected by turmoil in the rest of the
bitcoin ecosystem. The 4th July 2015 accidental chain fork effected many
kinds of wallets. Here is the wiki page on this event
Notice how updated node software was completely unaffected by the fork.
All other wallets required either extra confirmations or checking that
the third-party institution was running the correct version.
Full nodes wallets are also currently the most private way to use
Bitcoin, with nobody else learning which bitcoin addresses belong to
you. All other lightweight wallets leak information about which
addresses are yours because they must query third-party servers. The
Electrum servers will know which addresses belong to you and can link
them together. Despite bloom filtering, lightweight wallets based on
BitcoinJ do not provide much privacy against nodes who connected
directly to the wallet or wiretappers.
For many use cases, such privacy may not be required. But an important
reason to run a full node and use it as a wallet is to get the full
privacy benefits.
=== Myth: I can just set up a node on a cloud server instance and leave
it ===
To get the benefits of running a full node, you must use it as your
wallet, preferably on hardware you control.
Most people who do this do not use a full node as their wallet.
Unfortunately because Bitcoin has a similar name to Bittorrent, some
people believe that upload capacity is the most important thing for a
healthy network. As I've explained above: bandwidth and connections are
not a problem today, trust, security and privacy are.
=== Myth: Running a full node is not recommended, most people should use
a lightweight client ===
This was common advice in 2012, but since then the full node software
has vastly improved in terms of user experience.
If you cannot spare the disk space to store the blockchain, you can
enable pruning as in:
 In Bitcoin
Core 0.12, pruning being enabled will leave the wallet enabled.
Altogether this should require less than 1.5GB of hard disk space.
If you cannot spare the bandwidth to upload blocks to other nodes, there
are number of options to reduce or eliminate the bandwidth requirement
found in  . These include
limiting connections, bandwidth targetting and disabling listening.
Bitcoin Core 0.12 has the new option -blocksonly, where the node will
not download unconfirmed transaction and only download new blocks. This
more than halves the bandwidth usage at the expense of not seeing
unconfirmed transactions.
Synchronizing the blockchain for a new node has improved since 2012 too.
Features like headers-first
( and
libsecp256k1 have greatly improved the initial synchronization time.
It can be further improved by setting -dbcache=6000 which keeps more of
the UTXO set in memory. It reduces the amount of time reading from disk
and therefore speeds up synchronization. Tests showed that the entire
blockchain can now be synchronized in less than _3 and a half hours_
Note that you'll need Bitcoin Core 0.12 or later to get all these
efficiency improvements.
=== How to run a full node as your wallet ===
I think every moderate user of bitcoin would benefit by running a full
node and using it as their wallet. There are several ways to do this.
* Run a bitcoin-qt full node (
* Use wallet software that is backed by a full node e.g. Armory
( or JoinMarket
* Use a lightweight wallet that connects only to your full node (e.g.
Multibit connecting only to your node running at home, Electrum
connecting only to your own Electrum server)
So what are you waiting for? The benefits are many, the downsides are
not that bad. The more people do this, the more robust and healthy the
bitcoin ecosystem is.

@_date: 2016-10-16 17:08:14
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Start time for BIP141 (segwit) 
Excellent news that segregated witness is nearing release for the mainnet.
I know I don't only speak for myself in saying that this has been
eagerly awaited for some time.
For the timing, I'd support segwit being usable on the network as soon
as is technically and safely possible.
We at JoinMarket are very interested in eventually using schnorr which
would allow signature aggregation and so reduce the cost of coinjoins.
Chris Belcher

@_date: 2017-08-30 17:15:56
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Payment Channel Payouts: An Idea for Improving P2Pool 
Pooled mining in bitcoin contributes to miner centralization. P2Pool is
one solution but has bad scalability; additional hashers require the
coinbase transaction to be larger, bigger miners joining increase the
variance of payouts for everyone else, and smaller miners must pay extra
to consolidate dust payouts. In this email I propose an improved scheme
using payment channels which would allow far more individual hashers to
mine on p2pool and result in a much lower payout variance.
== Intro ==
P2Pool is a decentralized pool that works by creating a P2P network of
hashers. These hashers work on a chain of shares similar to Bitcoin's
blockchain. Each hasher works on a block that includes payouts to the
previous shares' owners and the node itself. The point of pooling is to
reduce the variance of payout, even though on average the reward is the
same (or less with fees). The demand for insurance, and the liquid
markets for options show that variance does have costs that people are
willing to pay to avoid.
Here is an example of a p2pool coinbase transaction:
It is 5803 bytes in size, which at a fee rate of 350 sat/b is worth
0.02031050 btc of block space that p2pool cannot sell to any other
transaction. As bitcoin inflation goes down and miners are funded more
by fees, this puts p2pool at more and more of a disadvantage compared to
trusted-third-party mining pools.
As each hasher is paid to their own bitcoin address, this limits the
number of hashers taking part as adding more individual people to the
payout transaction increases its size. Also small payouts cost a
disproportionate amount in miner fees to actually spend, which hurts
small miners who are essential to a decentralized mining ecosystem.
This could maybe be solved by keeping a separate balance state for each
user that is independent from the payouts, and make payouts only when
that balance state exceeds some reasonable threshold. But this increases
the variance which goes against the aim of pooled mining.
== Payment Channels ==
What's needed is a way to use off-chain payments where any number of
payments can be sent to each individual hasher without using the
blockchain. Then the N of the pay-per-last-N-shares (PPLNS) of p2pool
can be increased to something like 6-12 months of shares and so as long
as a small miner can mine a share every few months they will always get
a payout when p2pool finds a block. The payment channels would be in a
hub-and-spokes system and would work in a similar way to coinswap,
lightning network, atomic cross-chain swaps or any other contract
involving hashlocks and timelocks.
There would still be a sharechain but with hashers paying the entire
block reward to a hub. This hub would have a one-way payment channel
open to every hasher in p2pool and there would be created a situation
where if the hub gets paid then the hashers cannot fail to get paid.
Because cheating is impossible, the hub and hashers will agree to just
release the money to each other without resorting to the blockchain.
The coinbase address scriptPubKey would be this, block rewards are paid
to here:
     2of2 multisig
     hub + successful hasher
  OR
     hub pubkey + H(X)
  OR
     successful hasher pubkey + OP_CSV 6 months
A 2of2 multisig between the hub and the "successful" hasher which found
the block, although with a hashlock and timelock. H(X) is a hash value,
where the preimage X is generated randomly by the hub and kept secret,
but X will be revealed if the hub spends via that execution path. The
OP_CSV execution path is there to stop any holdups or ransom, in the
worst case if the hub stalls then the successful hasher can steal the
entire coinbase as punishment after 6 months.
Each payment channel address has this scriptPubKey:
     2of2 multisig
     hub-C + hasher-C
  OR
     2of2 multisig + H(X)
     hub-U + hasher-U
The pubkeys hub-C/hasher-C refer to 'cooperative' pubkeys.
Hub-U/hasher-U refer to 'uncooperative' pubkeys. Before a hasher starts
mining the hub will open a one-way payment channel to the hasher, and
pays some bitcoin to it (let's say 0.5btc for example).
The hashers mine a sharechain, a solved share contains the hasher's
cooperative and uncooperative pubkey. The hub keeps up with the
sharechain and announces partially-signed transactions going to each
hasher. The transactions are updated states of the payment channel, they
pay money to each hasher in proportion to the work that the hasher
contributed to the sharechain. The transaction contains a signature
matching the hub-U pubkey, the hasher could sign it with their hasher-U
key and broadcast except they still need the value of X.
If a hasher is successful and finds a share that is also a valid bitcoin
block, they broadcast it to the network.
Now, the hub can spend the block reward money on its own but only by
revealing X. Each hasher could then take that X and combine it with the
partially-signed transaction and broadcast that to get their money. So
if the hub gets paid then the hashers cannot fail to get paid. Since
defecting is pointless, the hub signs the hub-C signature of the
partially-signed transaction and sends it to each hasher, then the
successful hasher signs the 2of2 multisig sending the block reward money
to the hub. The successful hasher gets a small bonus via an updated
payment channel state for finding the block, to discourage withholding
same as today's p2pool.
These payment channels can be kept open indefinitely, as new blocks are
found by p2pool the hub creates new partially-signed transactions with
more money going to each hasher. When the hasher wants to stop mining
and get the money, they can add their own hasher-C signature and
broadcast it to the network.
If there's ever a problem and the hub has to reveal X, then all the
payment channels to hashers will have to be closed and reopened with a
new X, because their security depends on X being unknown.
== Hubs ==
The hub is a central point of failure. It cannot steal the money, but if
it gets DDOS'd or just becomes evil then the whole thing would stop
working. This problem could be mitigated by having a federated system,
where there are several hubs to choose from and hashers have payment
channels open with each of them. It's worth noting that if someone has a
strong botnet they could probably DDOS individual p2pool hashers in the
same way they DDOS hubs or even centralized mining pools.
The hub would need to own many bitcoins in order to have payment
channels while waiting for blocks to be mined. Maybe 50 times the block
reward which today would be about 650 bitcoins. The hub should receive a
small percentage of each block reward to provide them with an incentive,
we know from JoinMarket that this percentage will probably be around
0.1% or less for large amounts of bitcoin. Prospostive hub operators
should write their bids on a forum somewhere and have their details
added to some list on github. Hashers should have an interface for
blacklisting, whitelisting, lowering and raising priority for certain
hubs in case the hub operators behave badly.
As well as the smart contract, there are iterated prisoner's dilemma
effects between the hub and the hashers. If the hub cooperates it can
expect to make a predictable low-risk income from its held bitcoins for
a long time to come, if it does something bad then the hashers can
easily call off the deal. The hub operator will require a lot of profit
in order to burn its reputation and future income stream, and by
damaging the bitcoin ecosystem it will have indirectly damaged its own
held bitcoins. A fair pricing plan will probably have the hub taking a
small percent to start with and then 12 months later that percentage
goes up to take into account the hub's improved reputation.
== Transaction Selection ==
All the hashers and hub need to know the exact value of the block reward
in advance, this means they must know what the miner fees will be. This
is probably the most serious problem with this proposal.
One possible way to solve this is to mine transactions into shares and
so use the sharechain to make all the hashers and hubs come to consensus
about exactly which transactions they will mine, and so exactly what the
total miner fee will be. A problem here is that this consensus mechanism
is slow, immediately after a bitcoin block is found all the p2pool
hashers will have to wait 30-120 seconds before they know what
transactions to mine, so this would make them uncompetitive as a mining
Another way to deal with this is to have the hub just choose all the
transactions, announcing the transactions, total miner fee and merkle
root for the hashers to mine. This would work but allows the hub to
control and censor bitcoin transactions, which mostly defeats the point
of p2pool as an improvement to bitcoin miner centralization.
Another way is to have the hashers and hub estimate what the total miner
fee value will be. The estimate could start from the median miner fee of
the last few blocks, or from the next 1MB of the mempool. The hub would
announce all the partially-signed transactions to every hasher, and then
periodically (say every 60 seconds) announce updated versions depending
on how the mempool changes. Let's analyze what happens if the estimated
and actual rewards are different. If the actual block reward is lower
than the estimated reward, then the hub can update the payment channel
state to slightly lower values to take that into account when it
announces the cooperative hub-C signatures. The hashers can't use the
higher channel state without knowing X. The successful hasher will get
their bonus for finding the block which should help in encouraging them
to actually sign the hub's payout transaction. If the actual block
reward is higher than the estimated reward, the hub would hopefully
still update the hasher's payment channel states because of the
interated-prisoners-dilemma effects. But if the actual reward is much
higher then the hub may find it profitable to burn its reputation and
take the money by revealing X, one situation where this might happen is
if someone accidently pays a very high miner fee and a hasher mines it
without it being taken into account in the hub's regular payment channel
state updates. Apart from that very specific situation, this scheme of
estimating the total miner fee should work.
== Some Notes ==
*) Block rewards are locked for 100 blocks before they can be spent, so
the cooperative signatures should be exchanged after 100 blocks just in
case the block gets made stale/orphaned. While the hashers are waiting
for the 100 reward maturity period, they should mine with another hub as
the payout.
*) Today's p2pool has a feature for donating to individual hashers, this
could be replicated in the payment channel system by having each share
also contain the hasher's bitcoin address for donations (or possibly
their LN payment code)
*) Each hasher should probably be made to pay some bitcoins into the
payment channel address too, to stop DOSers locking up all the hub's
bitcoins. If the hasher doesn't find a share within some timeout then
the hub should close the payment channel.
*) Now that we have segwit all these payment channel schemes are much
easier to code.
*) The hashers must keep their money locked up in the payment channel
for months before enough collects. This could be a problem because some
miners don't really want to hold bitcoin long term. I wonder if theres
some way to link up these channels to LN so they can sold straight away.
They could also use futures contracts to sell the coins today at a
discount and actually deliver the coins later when they close the channel.
== References ==
*)  how p2pool works
*) the scaleability problems of p2pool
*) making the PPLNS window longer
*) book: The Evolution of Co-Operation by Robert Axelrod, for explaining
iterated prisoner's dilemma effects in detail
Thanks to the p2pool developer veqtrus for reviewing this

@_date: 2017-02-17 00:28:59
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Committed bloom filters for improved wallet 
I believe this proposal still suffers from one problem that bip37 did,
albiet by a much lesser extent. Combining the partial information from
the block downloads with the transaction subgraph information from the
blockchain can in some cases still reveal which addresses belong to the
wallet. Nonetheless this proposal still has many benefits and is well
worth working on.
As a recap, probably the biggest and most problematic way that bip37 was
broken was by combining the partial wallet information from the bloom
filter with the transaction subgraph information from the blockchain
Suppose a wallet synchronizes it's history, if it spent a coin from its
address A, it must also also add the change address B to the bloom
filter, which is connected to A directly on transaction graph.
As an example, consider five typical transactions that consume one input
each and produce two outputs.
A, B, C, D, E refer to transactions. A1, A2, etc refer to addresses
within those transactions
          -> C1
A1 -> B2  -> C2
   -> B2  -> D1
          -> D2 -> E1
                -> E2
If a bip37 bloom filter matches addresses A1, B2, D2, E1 then it can be
seen that they form a "peel chain" [this terminology comes from
          -> X
A1 -> X   -> X
   -> B2  -> X
          -> D2 -> E1
                -> X
The same five transactions with non-matching addresses replaced by X.
The peel chain is visible, it's clear that B2, D2, E1 are change
addresses which belong to the same wallet as A1.
For a given false-positive rate fp and given length of peel chain C, the
odds of a false positive peel chain happening by chance is fp^C which
rapidly gets very small as the wallet makes more transactions (increases C).
If only one address was matched from the above group (for example B2)
then it likely to be a false positive by the fact that it doesn't make
any transactions to another address that also matches the bloom filter.
Another possibility is that the address is a payment output that the
wallet received but hasn't spent yet, but the wallet cant spend it
without adding the change address to the bloom filter and thus revealing
itself to the spy.
I believe the committed bloom filter proposal is vulnerability to this
same kind of attack because it still leaks information about which
addresses the wallet is interested in.
==Committed Bloom Filter Maths==
I'll try to analyze this now. I'll find the expectation value of the
number of transaction subgraphs in those blocks that appear just by
chance. If this expectation goes to zero, then the only transaction
subgraph left will be the real one that the wallet is actually
interested in. In that case it will be possible to spy on the wallet.
Assuming outputs have the same probability of being spent in each time
interval (i.e. they are spent in a Poisson process) This is
approximately true, see the graphs from
This means we can assign
a single probability P that an output is spent in each block.
Assume every transaction has one change address only and spending of
unconfirmed change doesn't happen (its more efficient to use RBF to add
additional outputs anyway)
Number of transactions per block = Q (about 1800 today)
Number of outputs per block = Z = 2*Q (approximately)
Length of peel chain = Number of transactions in wallet = C
Average time an output is unspent for = T (about 1 month, very roughly
estimating from the above blog post)
Probability an output being spent in any particular later block = P =
Assume no false positive blocks
Say wallet downloaded two blocks and they are ordered by block height
The expected number of tx subgraphs between them, E(
E( = number of outputs created in block 1 that get spent in block 2
      = Z*P
Say the wallet downloaded three blocks
Expected number of subgraphs going through them all
E( = number of outputs created in block 1 get spent in block 2, that
create a change address which gets spent in block 3
      = Z*P*P
Say the wallet downloaded C blocks
Expected number of tx subgraphs going through all the blocks by chance
E( = Z*P^C
which gets small quickly as C goes up, because P < 1
Now drop the assumption about no false positive blocks.
Let the number of candidate blocks be D.
This is how many blocks the wallet scans, it's related to how far in the
past the wallet's keys was created. At one extreme wallet was created at
genesis block and so D = ~450000, at other extreme created now so D = 0.
Note that D = 0 must also imply C = 0
Expected number of false positive blocks downloaded = F = fp*D
In all these situations the blocks are sorted by block height
Suppose have C=2, F=1, and false one is in the middle.
I want to find E( the expected number of transaction subgraphs
that appear just by chance, given C and F.
E( = how many outputs which are created in block 1 get spent in
block 3
         = Z*P
Same situation, but false one at the start instead of middle.
E( = how many outputs which are created in block 2 get spent in
block 3
         = Z*P
Same situation but false one could be anywhere, result in the sum of the
probability for any false block position
E( = C(3, 1)*Z*P = 3*Z*P
where C() is the number of order-independent ways of choosing 1 element
out of a set of 3 elements, also known as the binomial coefficient
Now suppose C=3 and F=1
The same argument leads to
E( = C(4, 1)*Z*P^2 = 4*Z*P^2
Now suppose C=3 and F=2, with fp blocks at the end
= how many outputs are created in block 1, are spent in block 2 and
change address spent in block 3
= Z*P^2
Same situation but fp blocks can be anywhere, add up all the possible
combinations of them within the rest
E( = C(5, 2)*Z*P^2 = 5*Z*P^2
With these same rules, its clear the general expression for any F and C
E( = C(F + C, F)*Z*P^(C - 1)
A more interesting value might be the time evolution of E(
Let B be the blocks in the blockchain since the wallet creation date, as you
know it increases at an average rate of one every ten minutes
w = wallet transaction creation rate, expressed per-block
C = w * B
F = fp * B
J = average blocks between wallet transactions = 1440 (10 days)
w = 1/J
E( = C((fp + w)*B, fp*B)*Z*P^(w*B - 1)
This goes to zero as B becomes big, although choosing very high values
of fp makes it go to zero slower.
This is only approximate maths, in actuality you cannot take the number
of false positive blocks to be fp*B, you have to sum over all blocks
weighted by probability. And outputs might not be spent in an exact
Poisson process so you cant just multiply by P each time. Plus if your
false positive rate is very high then some of your false positive blocks
will actually contain your real transactions, this analysis
double-counts them.
Using some reasonable values and plotting E( against B can show how
quickly it drops and therefore leaves only the true transaction subgraph.
(note: in LibreOffice Math and Microsoft Excel the binomial coefficient
function is COMBIN)
*) The expected number of transaction subgraphs that happen by chance
goes to zero eventually as the blockchain steps ahead. Unless the fp
rate is very high (close to 1) and time between wallet transaction very
long, in which case the binomial coefficient term gets larger more
quicker than the exponential decay P^B term gets smaller.
*) fp rate doesn't help in most cases that much compared to the
exponential drop-off from time ticking ahead requiring more downloading
of blocks
*) its good for privacy if bitcoin outputs are spent more frequently so
P is higher, because that creates more transaction subgraphs in the
anonymity set.
*) its good for privacy if more outputs are made per block, although
still only linearly which is no match for the exponential reduction from
the P^B term.
*) its good for privacy to make less of your own transactions (increase
J and reduce w), for low-activity users the privacy of committed bloom
filters can be actually pretty good, for high-activity users who use
bitcoin's blockchain all the time it's not very good
*) For the reasonable values I tried for a once-a-month user with fp=1%,
their chance-transaction-subgraph-count drops below 1 in about eight months.
*) Because of the exponential nature, E( goes from "billions of
billions" to "about 10" fairly quickly.
==Discussion of ways to mitigate this==
One way is to not use change outputs. This is unrealistic, doesn't match
people's behavior and money must be divisible.
A better way to mitigate this is to not leak the information that all
those blocks are interesting to the same wallet. Don't download all
blocks from the same archival node. If you download blocks from many
different nodes, it gives an incentive for surveillance startups to
create lots of sybil nodes they control and can then correlate together
block downloads with the wallet IP address. Many such startups are
already doing this today to try to detect the origin IP address of
broadcasted transactions.
Another solution could be to download a few blocks from different nodes
with new tor circuits used. This would delink the wallet IP address from
the downloads and would help a lot. This has the issue that tor is
slower (but still not as slow as downloading the entire blockchain)
Another way a wallet could be correlated with its block downloads is
timing correlations. At any one time only a certain number of peers
would be downloading blocks which narrows down which wallets are
downloading what. However even today Bitcoin Core downloads blocks in
parallel from many nodes so there's probably quite a large anonymity set
for lightweight wallets using committed bloom filters. Plus timing
correlation can be reduced simply by waiting longer. Wallets are not
sync'd from backup very often so it might be okay to wait.
Another way to improve privacy could be for the wallet to choose random
transaction subgraphs and download all the blocks related to them as well.
Wallet developers might choose to allow the user to configure their own
fp rate. This is probably not a good idea since the relationship between
fp rate and anonymity set is non-obvious. It might be better to ask the
user how often they expect to make transactions.
I think this committed bloom filter idea is very good and much better
than bip37, but for good privacy for when bitcoin is used often still
requires certain behavior namely downloading blocks
from many different peers with new tor circuits.
Note that I've been dealing with counting transaction subgraphs but
actually finding them from blocks might also be computationally
infeasible. Although a Bayesian approach worked very
well for similar transaction subgraph linking
It would also be interesting to analyze what information a spy can get
if they are missing some blocks that the wallet downloaded.
For the long term, private and high-volume bitcoin use will be best
served by off-chain transactions. They will probably be a huge win just
because the large and public blockchain is such a non-private
way of doing things.

@_date: 2017-03-05 14:33:06
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Moving towards user activated soft fork activation 
I think UASF is a great idea for the reasons mentioned before that it
more closely matches the balance of powers in bitcoin, and that its much
more opt-in.
Many people are comparing an UASF fork with a hard fork. I disagree with
this view and I think there is a difference between the two kinds of
forks. The situation between hard and soft forks is reversed.
In a fork between segwit-invalid and segwit-valid after a UASF, if the
segwit-valid chain ever ends up with more work then the segwit-invalid
chain will be annihilated in a big re-organization as
non-segwit-enforcing nodes move to the segwit-valid chain. The less-work
chain will simply cease to exist.
Only a miner that recodes their software can initiate such a fork,
because segwit transactions are non-standard and won't be relayed by
A closer situation is the accidental fork created soon after the BIP66
soft fork. The fork lasted a few blocks and did not mine any
transactions except the coinbase. It was annihilated with a monetary
loss to any miner that took part.
Here is an argument for why chain fork is unlikely to last long or be
created by a rational self-interested miner, assuming the bitcoin
economic majority even slightly enforces the UASF.
Because the segwit-invalid coins can be annihilated in this way and
segwit-valid coins cannot, segwit-invalid coins are more risky to hold
as an asset, all else equal.
A more risky asset has a lower price, all else equal. Because investors
demand higher risk premiums for holding it and also short sellers may
sell down the price in the hopes of making a profit if it's value goes
to zero.
In cryptocurrencies like bitcoin, hashpower follows price. This is very
clear from historical trends and the underlying economic forces.
A lower-hashrate chain will eventually be overtaken in work by a
higher-hashrate chain.
Therefore, the segwit-invalid chain will be annihilated sooner or later
if the price of its coin is higher.
Of course as the old saying goes markets can stay irrational longer than
we can stay solvent, which is why I think UASF should only go ahead if
we're sure that a big part of the economic majority will enforce it.
This will make the value and liquidity of the segwit-invalid chain very
low and make the annihilating re-organization happen faster.
User-activated means it _must_ be done by the users of bitcoin.

@_date: 2018-02-08 16:51:59
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Electrum Personal Server alpha release 
Electrum is a popular bitcoin wallet, but it is not a full node wallet
as it synchronizes itself using third-party Electrum servers. The
servers must be trusted to verify the rules of bitcoin, they can trick
Electrum wallets into accepting fake bitcoin transactions which, for
example, print infinite money. Bitcoin's security model requires that
most economic activity is backed by full nodes. The Electrum servers
must also be trusted with the user's privacy, as wallets send all their
bitcoin addresses to the server. Spying on wallets is not much more
complicated than simply grepping the server logs. Electrum wallets by
default also connect to servers using their own IP address, linking it
further to their revealed bitcoin addresses.
A way to avoid these problems is for users to run their own Electrum
server and connect their wallets only to it. But this requires
significant resource usage: the full unpruned blockchain, transaction
index and an extra address index, as well as more RAM and CPU usage
compared to just a full node. Servers are not well suited to being shut
down and started up again, they are typically always online.
Electrum servers store a database of every bitcoin address ever used,
which is inherently not scalable. This is resource-intensive and
therefore pushes users towards centralized solutions. An alternative way
would be to store only your own addresses and transactions.
Introducing Electrum Personal Server; an implementation of the Electrum
server protocol which fulfills the specific need of using the Electrum
UI with full node verification and privacy, but without the heavyweight
server backend, for a single user. It allows the user to benefit from
all of Bitcoin Core's resource-saving features like pruning, blocksonly
and disabled txindex. All of Electrum's feature-richness like hardware
wallet integration, multisignature wallets, offline signing, mnemonic
recovery phrases and so on can still be used, but backed by the user's
own full node.
An alpha version of Electrum Personal Server can be found on the
repository: Before using, the wallet user must configure Electrum Personal Server
with their master public key and those addresses are imported into
Bitcoin Core as watch-only. If the wallet contains historical
transactions then it must be rescanned. One of Electrum's motivating
features is "instant on", which is therefore traded away when using
Electrum Personal Server in return for full node verification and
privacy. Although if a brand new empty wallet is created there is no
need to rescan. A script like Electrum Personal Server is also well
suited to use private transaction broadcasting tech like dandelion or
broadcasting through tor.
Using Electrum with Electrum Personal Server is probably the most
resource-efficient way right now to use a hardware wallet connected to
your own full node. People who make use of Blockstream Satellite could
use it to have an off-the-grid node connected to Electrum if that is
their preferred wallet. In the situation of a traveller staying a cheap
hostels, they could sync their node every couple of days to download
recent blocks and use Electrum. Hopefully this software can be part of
the plan to get full node wallets into the hands of as many people as
The same kind of ideas could be applied to other lightweight wallets.
For example a full nodes can run on smartphones with pruning and
blocksonly, then a similar script would allow the user to connect their
Samourai Wallet, Breadwallet or GreenAddress app to their own full node.
Further Reading:
* *

@_date: 2018-01-23 01:55:07
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting 
This sounds like a useful idea for improving the privacy of coinswap.
Traditionally coinswap mixing had an anonymity set related to the number
of multisig transactions being used on the blockchain. With the new tech
of Schnorr, MAST and now this Taproot, with sufficient adoption
coinswap's anonymity set could be much higher, potentially including
almost every other on-chain transaction.
[1] [2]

@_date: 2018-03-29 13:07:04
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Electrum Personal Server beta release 
Electrum Personal Server is an implementation of the Electrum wallet
server protocol that allows users to point their Electrum wallet at
their own full node. It is compatible resource-saving features like
pruning, blocksonly and disabled txindex. It is much less
resource-intensive than other Electrum servers because it only stores
the user's own addresses, instead of every address that was ever used.
As such it makes tradeoffs, namely losing Electrum's "instant on" feature.
Right now using Electrum Personal Server is the easiest way to use a
hardware wallet backed by your own full node. It is very lightweight,
being a small python script that barely uses any CPU or RAM; much less
than the full node it's connected to. Hopefully Electrum Personal Server
can be part of the solution in putting full node wallets into the hands
of as many people as possible.
The project is now in beta release:
It now has all the essential features to make it practical for use;
Merkle proofs, deterministic wallets, bech32 addresses, SSL, Core's
multi-wallet support. Along with the features that were in the alpha
release of tracking new transactions, confirmations, block headers,
importing addresses.
There is a caveat about pruning. Electrum Personal Server obtains merkle
proofs using the `gettxoutproof` RPC call, if pruning is enabled and
that block has been deleted then the RPC will return null and so the
Electrum wallet will display `Not Verified`. Everything else will still
work, and this shouldn't be a problem in most situations because
Electrum usually only requests merkle proofs for recent transactions and
pruning keeps recent blocks. But in the long term it needs some thought
on the best way to fix this. I've been thinking about adding code for
Bitcoin Core that stores merkle proofs for each of the wallet's own
transactions in wallet.dat.
Further Reading:
*

@_date: 2018-05-10 23:44:36
@_author: Chris Belcher 
@_subject: [bitcoin-dev] MAST/Schnorr related soft-forks 
Thanks for the summary,
It may be worth emphasizing the fungibility aspects of all this.
That summary contains ideas to possibly have separate address types,
opcodes and scriptSigs/witnesses for different feature, at least to
start with. To me this would seem bad because it may miss out on the
fungibility gain from having everything look exactly the same.
With schnorr we may have a unique opportunity to greatly improve
fungibility. It's not too hard to imagine a world where users of
Lightning Network, coinswap, MAST, scriptless scripts, multisig,
taproot, graftroot, etc and regular single-signature on-chain payments
all appear completely indistinguishable. Tracking and data mining could
become pointless when coins can teleport undetectably to a different
place on the blockchain via any number of off-chain protocols.
Of course the downside of doing it like this is that every feature would
probably have to be developed, reviewed, tested and deployed together,
rather than one at a time.

@_date: 2018-10-23 15:29:30
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Transaction Input/Output Sorting 
Thanks for bringing our attention to this important topic.
According to ( around 60% of
transaction follow bip69 (possibly just by chance).
If its useful, a bitcoin wiki page that tracks wallets which use bip69
can be created. A similar page exists for bech32
( If we had this at least
we'd know which open source wallets we can write code for or which
closed source wallets we can bug about bip69.

@_date: 2019-08-02 10:21:57
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
There's a few different issues here.
Yes TXO fidelity bonds can be rented out, but that doesn't make a sybil
attack cheaper. The aim of the fidelity bond scheme is to require makers
to sacrifice value, renting out their fidelity bond coins doesn't avoid
that sacrifice because the sacrifice is the paid rent. Because of the
maths and market forces the rent paid by the attacker should be about
the same as the cost of just buying the bitcoins and locking them.
Centralization and decentralization are not ends in themselves, the main
aim in JoinMarket is to improve privacy while keeping the other
properties of bitcoin (e.g. censorship resistance). A single maker can
never deanonoymize coinjoins no matter how valuable their bond is,
because takers always choose multiple makers, and all of them need to be
controlled by the sybil attacker for the attack to succeed. If a sybil
attacker splits up their fidelity bonds (rented or not) amongst multiple
maker bots then they reduce the value of their bonds because of the V^2
Rented TXOs does destroy the effect of "A long-term holder probably
won't want to attack a system like JoinMarket which makes his own
investment coins more private and more fungible". However this is not
the main effect which would protect JoinMarket's privacy. The main
effect is the cost which for real-life numbers would be about 45-120
bitcoin sent to burner outputs.
Perhaps then rented TXOs is an argument against using coin age as a way
to create fidelity bonds. Hodlers would be far less likely to rent out
their coins if they have to specifically move them to a special
time-locked address. Another point is that for privacy reasons creators
of fidelity bonds should mix their coins before and after using them,
because those TXOs are revealed to the world. So it's likely that
fidelity bonds creators will need to install and run JoinMarket anyway.

@_date: 2019-08-05 20:04:26
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
Yes you're right. I should correct myself: Running a maker under the
proposal doesn't require a sacrifice of value, in fact you actually make
money doing it.
However, there _is_ a cost to being a sybil attacker. If we define
honest makers as entities who run just one maker bot, and dishonest
makers as entities who run multiple maker bots, then we can say that
running a dishonest maker operation requires a sacrifice of fee income,
because someone doing that would earn more money if they ran an honest
maker instead. This happens because of the quadratic V^2 term in the
formula calculating the fidelity bond value, which provides this
incentive for lumping together fidelity bonds. This V^2 is probably the
most important part for privacy.
The V^2 term also creates a bad incentive where multiple people might
choose to pool together their bitcoin hoard into one maker bot so that
each can earn a higher fee income. This can be done by renting out TXOs
signatures as you've said.
So what's needed is a way to make renting out TXOs impossible or very
difficult. We can note that fidelity bonds made of rented TXOs will be
made up of a large number of relatively small valued TXOs, so one
amelioration is to cap the number of TXOs that can be used in one
fidelity bond. This could be worked around by honest makers because they
can consolidate TXOs on the blockchain, which rented TXO owners can't do
because the TXOs are owned by different people.
Another way is to require the bond signature proofs to involve the
one-time taker identifier, and so be different every time. This
basically requires fidelity bond privkeys to be online in hot wallets,
and so should massively increase the difficulty of renting TXOs because
the maker and the TXO owner need to be in constant real-time communication.

@_date: 2019-08-06 11:27:17
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
We can be much more exact than saying makers get in on "many" coins. The
supporting document "Financial mathematics of JoinMarket fidelity bonds"
contains calculations for exactly this:
The document finds that with realistic real-world data, the makers with
the top 5 most valuable bonds will be chosen 48% of the time. So
approximately half:half success for one coinjoin. This isn't enough to
deanonymize every single coinjoin. For example, the tumbler script by
default makes around 16 transactions so the odds of a successful sybil
attack is (0.48)^16 = 8 parts per million, with the success probability
reducing exponentially after each additional coinjoin.
Hopefully it won't come to that and we can invent some other way to stop
renting TXOs. But if that's the only way then we'd have to code it in
order to protect the interests of takers.
The most dangerous source of rented TXOs seems to be the coin age form
of fidelity bond. Hodlers could have coins already in a hardware wallet
or cold storage and just sign proofs renting their UTXOs to earn an
extra income without changing their setup at all. Bonds from OP_CLTV and
OP_RETURN burned coins seems to me a much less likely source of rented TXOs.
Because of that, it seems to me only coin age fidelity bonds would be
required to be on hot wallets.
Another option worth considering is the have a separate lower interest
rate for coin age bonds compared to OP_CLTV bonds, this would reflect
the lower sacrifice for coin age (past sacrifices must be worth less
than future sacrifices, because of risk and uncertainty of the unknown
future, as well as the risk of rented UTXOs)
I think this is absolutely wrong, because sybil attackers give up some
fee income. Here is a worked example:
Let's say the sybil attacker is operating the top 5 most valuable maker
bots. If this attacker has X coins they would split them equally into 5,
so each maker has X/5 coins and their bond is worth (X^5)^2 = X^2/25,
with a total of 5 bots the fee income would be proportional to 5*X^2/25
= X^2/5. However if an honest maker had X coins they could create a
single bond which would be worth simply X^2 with a fee income
proportional to X^2. So the honest maker has a fee income higher by a
factor of 5 than the sybil attacker. The sybil attacker must take a 5x
hit to their fee income in order to sybil attack. This is the crucial
effect of the V^2 term.
The V^2 term is important, it just has the downside of incentivizing
renting of coins. If we can make that impossible then the problem would
go away.
Apart from the inability of developers to enforce any kind of price, I
don't think this scheme would fix the sybil attack problem, because a
sybil attacker still gets a higher gain (deanonymization + fees)
compared to honest makers (who earn just fees)

@_date: 2019-08-07 10:38:43
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
Good morning all,
Custodial solutions are much less worrying because they introduce so
much counterparty risk.
It's more risky to give bitcoins in custody than for fiat money because
there's no lender of last resort. People using JoinMarket in a
non-custodial way will always have a larger risk-adjusted return; The
return for running a JoinMarket yield generator isn't that big anyway to
start with. The non-custodial renting of TXO signatures is far more
Also, as described in my other email
starting "
Let's say the sybil attacker...") the superlinear V^2 term is essential
to the resistance of the fidelity bond system to sybil attacks. All
things considered the consolidation of makers due to renting TXOs is not
as bad as sybil attacks. Consolidation of makers means that the
privacy-relevant information is shared amongst fewer people than
otherwise, but at least those people are independent (otherwise they'd
merge together). In a sybil attack the privacy-relevant information is
not shared at all, but entirely known by just one person which is much

@_date: 2019-08-07 11:05:41
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
These are very creative schemes. At the very least they would stop the
easy mindless renting TXO method, where someone with coins on a hardware
wallet simply creates a signature and copypastes it into a website to
get free money. The workaround scheme with shared ownership of TXOs
requires brand new wallets to be created and hodlers must trust the
wallets enough to move their coins and hold them there for a long time.
Requiring fidelity bond TXOs to be held in hot wallets can also be
beaten as a scheme for stopping renting, because the rentee can put
their coin private keys on an always-on raspberry pi which is connected
to the maker's computer and constantly ready to give out signatures. The
coins would be in hot wallets yet still be rented out. As above the
raspberry pi setup would be much more of a hassle than copypasting a
signature into a website, so it could still be worth doing.
I wonder if there's a cryptographic way to prove that muSig and 2P-ECDSA
have not been used to create a certain pubkey/signature.

@_date: 2019-08-08 21:06:07
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
Hello list,
Two points:
* The V^2 term is the only thing in the whole scheme that provides any
sybil protection. I've already gone through the reasoning in an earlier
email and the maths is clear; in a scheme with linear V honest makers
have no economic advantage over sybil attackers. This is because only a
sybil attacker needs to split up their money into multiple fidelity
bonds, and that comes with a penalty under the V^2 rule.
It's worth reiterating that including a single evil maker in a
JoinMarket coinjoin does not ruin it's privacy. Privacy is only ruined
if *all* makers in a coinjoin are controlled by the same entity. So if
takers use one maker who has rented TXOs, then its no big deal as long
as the other included makers are controlled by other people. Therefore
when balancing the harms, consolidation into fewer makers is not as bad
as having no sybil protection (which as a reminder means that *all*
makers are controlled by one entity), and so the V^2 term does more good
than harm.
We can't condemn the V^2 rule because of consolidation without
acknowledging the good it does in penalizing sybil attacks.
* Regarding entities like exchanges running makers. They can also do
this today with JoinMarket, the proposed fidelity bond scheme doesn't
make that worse. It's an underlying assumption of JoinMarket that
coinjoining power is proportional to bitcoin ownership (in a similar way
that an underlying assumption of bitcoin is that transaction
confirmation power is proportional to hashpower). If those big exchanges
find that coinjoins involving them included just one maker controlled by
someone else then their aim of deanonymization will have failed. And
then those exchanges have to explain to their regulators why they helped
hide the origin and destination of some black market money.

@_date: 2019-12-24 17:06:01
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Base64-encoded descriptors 
I've recently been playing around with descriptors, and they are very
nice to work with. They should become the standard for master public
keys IMO.
One downside is that users cant easily copypaste them to-and-fro to make
watch-only wallet. The descriptors contain parenthesis and commas which
stop highlighting by double-clicking. Also the syntax might look scary
to newbs.
An obvious solution is to base64 encode the descriptors. Then users
would get a text blog as the master public key without any extra details
to bother them, and developers can easily base64 decode for developing
with them.
A complication might be the descriptor checksum. If there's a typo in
the base64 text then that could decode into multiple character errors in
the descriptor, which might be problematic for the checksum. Maybe the
descriptor could be base64 encoded without the checksum, then attach the
checksum to the end of the base64 text.
I didn't come up with these ideas, they came from discussions with achow101.

@_date: 2019-02-23 20:17:17
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Privacy literature review 
Hello list,
For the last few weeks I've been working on a literature review for
bitcoin privacy:
It aims to cover about all privacy issues in bitcoin, including
Lightning network, and has a bunch of examples to help demonstrate how
the concepts work in practice.
There is also a new wiki category with smaller related articles:

@_date: 2019-07-25 12:47:54
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil attacks 
JoinMarket[1] can be sybil attacked today at relatively low cost which
can destroy its privacy. Bitcoins can be sacrificed with burner outputs
and time-locked addresses (also called fidelity bonds), and this can be
used to greatly improve JoinMarket's resistance to sybil attacks.
With real-world data and realistic assumptions we calculate that under
such a fidelity bond system an adversary would need to lock up
30,000-80,000 bitcoins for months, or send 45-120 bitcoins to burner
addresses to have a good chance of sybil attacking the system if it were
added to JoinMarket.
This increased resistance to sybil attacks would most likely cause
coinjoin fees to rise. I think the added cost is worth it for the
greatly improved privacy, because today miner fees are the biggest cost
to JoinMarket takers not coinjoin fees which are very low. Users should
definitely share their opinion on fees after reading the document.
 Introduction
JoinMarket creates a market for coinjoins, allowing anyone to create
equal-amount coinjoins for any amount they want at any time they want.
In return they pay a fee for the liquidity made available to them. The
project has existed since 2015 and has probably created hundreds of
thousands of coinjoins since then. Today there is available liquidity
for creating coinjoins with amounts up to about 400 btc per coinjoin output.
 Sybil attacks
JoinMarket, like many other schemes where participants are free to
anonymously enter, can be targetted by sybil attacks. In JoinMarket this
would work by an attacker running lots of maker bots which attempt to be
all the makers in every coinjoin. If successful the attacker would have
enough information unmix every coinjoin.
One way to solve the problem of sybil attacks is centralization. For
example coinjoins could be constructed on a centralized server. Then
random anonymous participants cant sybil attack because they can't
control the coinjoin construction, but this comes at the cost that the
server can sybil attack very easily. So this solution is probably a bad
In general, sybil attacks are solved by making them expensive. For
example, bitcoin mining resists sybil attacks because it requires a
provable sacrifice of electricity to mine. A bitcoin user can calculate
the actual monetary value that an attacker must spend in order to
reverse their transaction.
Likewise in JoinMarket such a sybil attack is not free either as the
attacker needs to own enough bitcoins to run enough maker bots for all
the coinjoins.
 Today's low cost for sybil attacks
A paper on JoinMarket [M?ser, Malte and Rainer B?hme. ?Join Me on a
Market for Anonymity.? (2016).] calculates the requirement of such a
sybil attack in 2016 to be just 32,000 USD. According to the paper such
an attack would succeed 90% of the time and the investment is
recoverable afterwards so that figure for the requirement isn't even a
true cost.
JoinMarket has been improved since 2016 and more makers have joined, so
the true requirement is perhaps 2x or 3x higher today, but it is still
relatively low.
Even with future improvements like fixing issue  [2] the requirement
of a sybil attack would probably only rise another 2x.
Apart from the cost to sybil attack being low, there is also the odd
situation that smaller coinjoin amounts receive less sybil protection
than large ones. It costs 100x less to sybil attack a transaction of 0.1
btc than one of 10 btc. Why should smaller amounts receive less
sybil-resistance and therefore less privacy?
 Liquidity
When creating this project, it was expected that many more people would
enter the market as makers and so the cost of a sybil attack would be
very high. That has not happened. One reason is that everyone who wants
to create a coinjoin is able to even for large amounts. The fundamental
problem is that takers are paying-for and getting liquidity, but not
necessarily sybil-resistance.
Another smaller reason for the low cost of sybil attacks is that many
people don't want to store too many bitcoins on an computer connected to
the internet.
What is needed is a way to increase the cost of running in a maker in a
way that retains the anonymity and is attractive to long-term holders of
bitcoin. This can be done using time-locked addresses.
 Fidelity bonds
In bitcoin, a fidelity bond [3] is a mechanism where bitcoin value is
deliberately sacrificed to make a cryptographic identity expensive to
obtain. The sacrifice is done in a way that can be proven to a third party.
A way to create a fidelity bond is to burn an amount of bitcoins by
sending to a OP_RETURN output. Another kind is time-locked addresses
created using OP_CHECKLOCKTIMEVERIFY where the valuable thing being
sacrificed is time rather than money, but the two are related because of
the time-value-of-money.
Under this system, makers would sacrifice an amount of bitcoins and
publish a proof along with their coinjoin offers. Takers would choose
maker offers based on the sacrificed amount (as well as other factors),
knowing that a sybil attacker would also have to sacrifice a certain
amount of coins in order to unmix the taker's coinjoins. The sacrifice
would be an objective measurement that can't be faked and which can be
verified by anybody (just like, for example PoW mining)
Note that a long-term holder (or hodler) of bitcoins can buy time-locked
fidelity bonds essentially for free, assuming they never intended to
transact with their coins much anyway. A long-term holder probably won't
want to attack a system like JoinMarket which makes his own investment
coins more private and more fungible.
 Fidelity bonds in cold storage
The private keys of fidelity bonds can be kept offline. Signatures
potentially only need to be made when the timelock expires (every 6
months for example), or only once in the case of OP_RETURN burned coins.
This allows JoinMarket's sybil resistance to increase without the hot
wallet risk.
Burned coin signatures should still have a lifetime, in case the private
key associated with the IRC nick (which is online) is stolen, so that
the thief of that privkey can't impersonate the maker indefinitely. The
signature linking the burned coins and IRC nick could expire after
perhaps 6 months.
 Anonymity
Under this scheme makers would need to publish the transactions of their
fidelity bonds to the entire world. Those transactions could be subject
to blockchain analysis. So before makers do this they should make sure
their coins are anonymous (possibly by mixing with JoinMarket). Also if
they ever want to use their coins for something else apart from fidelity
bonds they should mix them.
 Value of a fidelity bond
See the other document (Financial mathematics of joinmarket fidelity
bonds)[4] for a formula expressing the value of a fidelity bond.
The value of a fidelity bond made by sending V bitcoins to a burner
address is:
    V^2
The amount of bitcoins is squared to get the fidelity bond value. This
has the effect that economic-rational makers have a strong incentive to
lump up all their coin sacrifices together into one maker bot, not to
split it up over several bots.
The value of a fidelity bond made by locking up V bitcoins in a
time-locked address for time period T is:
    V^2 (exp(rT) - 1)^2
To get an idea of the numbers, if we burn 2 btc then the value of the
fidelity bond is 4 BTC^2. If we lock up 100 BTC for one year, and have a
bitcoin interest rate r = 0.001 (0.1%) per year, then the value of that
fidelity bond is 0.01 BTC^2 which is the same as burning 0.1 BTC. That
is a relatively small valued bond. It can be increased by locking up
more bitcoins for longer (up to and including permanant locking via a
burner transaction).
 Taker algorithm for choosing makers
I suggest the following taker peer choosing algorithm: obtain the list
of offers and discard offers which the taker's user deems are too
expensive. One of the remaining offers is randomly chosen with weighting
determined by the fidelity bond value. Once an offer is chosen it is
removed from the list, and another offer is again randomly chosen, this
is repeated until the taker has chosen the desired number of
fidelity-bonded maker's offers.
Some people run makers not for profit but for their own privacy.
Therefore not all makers should be required to have bonds, because such
privacy-makers are useful to include in coinjoins too. We could have
taker allow say, an eighth (12.5%), of their coinjoin peers to be makers
without bonds. They can be chosen randomly from the orderbook without
any weighting based on fidelity bond values. Of course these are easy to
fake by an adversary so they dont contribute much to sybil resistance.
 Cost of sybil attacks
See the other document (Cost of sybil attacks) for discussion and
calculations on the sybil resistance given by the above maker-choosing
It can be calculated that the fidelity bond system dramatically
increases the cost of a sybil attack. With real-world data and realistic
assumptions we can calculate that a sybil attacker would need to lock up
30,000-80,000 bitcoins for 6 months, or send 45-120 bitcoins to burner
addresses to have a good chance of attacking the system by being all the
counterparties in everyone's coinjoin.
 Effect of fidelity bonds on CoinJoin fees
Someone might ask "why would anyone lock up coins for months or more,
let alone burn coins forever, just to run a maker bot". The only way
this would even happen is if makers can generate a higher income that
justifies the fidelity bond sacrifice. That higher income can only come
from taker's coinjoin fees (or possibly coinswap fees one day). We can
expect that makers with higher valued fidelity bonds will demand higher
coinjoin fees. So a big question is whether takers will accept paying
higher coinjoin fees. I think they will, because right now coinjoin fees
are only 10-1000 satoshi, and a far biggest cost of coinjoins is the
miner fee not the coinjoin fee. I'm pretty sure takers will recognize
that they get what they pay for, and that additional privacy is well
worth the cost. Any other takers reading this should definitely let me
know what they think.
 Technical ideas
JoinMarket's wallet could also create time-locked addresses. Locktimes
should be fixed to be midnight on the first day of each month, then each
public key corresponds to 12 addresses per year (1200 addresses per
century) which is very practical to all be monitored as watch-only
addresses. These wallets can be created offline and could safely hold
time-locked bitcoins.
The timelocked addresses public key can be used to sign an IRC nickname
proving that the nickname is the real owner of the TXO. OP_RETURN
outputs used for burning coins can include a pubkey hash used for the
same thing.
We don't want the cold storage keypairs to be held online. We can design
the system that the time-locked address keypair is held offline but it
signs another key pair which is held online. Every time the IRC bot
connects it can use this intermediate keypair to sign the IRC nickname
proving ownership. The signature from the time-locked address to the
intermediate keypair can be made to have an expiry date (for example 6
months). This all means that the time-locked bitcoins can be held
offline but still be used to prove ownership of an IRC nickname.
The existance of the UTXO of a time-locked coin can be proved by
revealing the TXID and vout, which full nodes can use to query the UTXO
set to check that the coin exists. SPV clients would need a merkle proof
as well. Burned coins and spent time-locked coins could have their
existence proved by sharing the transaction which created them along
with a block height and transaction position for an unpruned node, or a
merkle proof for a pruned node or SPV client. Note that from the point
of view of a pruned node, a merkle proof is a fully-verified proof of
existance of a transaction. It is not a proof with just SPV-security.
 Links / References
[1] [2] [3] [4] [6] First ever mention of fidelity bonds I found. The idea is basically
invented by Peter Todd: [7] Old idea for combining fidelity bonds with mixers:
[8] Suggestion that is very close to the fidelity bonds idea. He talks
about requiring a deposit from makers, but nobody is able to come up
with a way to make such a deposit decentralized and trustless:

@_date: 2019-07-30 22:27:17
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
Far future locks are problematic. In my proposal I've only considered
locked coins for only 6 months because of exactly these reasons. The
market competition between airdrops should still exist after 6 months so
lockers will still get a chance to sell their airdrops. And any
ECC-alternative or hash-function-alternative fork will probably take a
couple of months to be designed, implemented and deployed as well,
giving a chance for lockers to move coins.
I'm becoming more and more convinced that coin age is also a valid
method of proving a sacrifice. Using coin age also has a benefit that
less block space is used, because using timelocks requires a new
on-chain transaction to be made every 6 months or whatever the locking
period is.
Perhaps JoinMarket should accept all three methods of proving a
sacrifice: burning, timelocking and aging. I could imagine that makers
would first lock coins for 6 months to create a fidelity bond they could
immediately use, and after the timelock expires leave that coin unspent
and use its age as the fidelity bond.
For what its worth, I mostly considered burning coins because the maths
for it is easy (the value of such a bond is just V^2), and because it
provides a boundary condition (locking up coins for infinity time is the
same as burning them). I doubt anybody will actually do it in practice.
This scheme could be attacked using address reuse. An attacker could
create an aged coin on a heavily-reused address, which would force an
SPV client using this scheme to download all the blocks which contain
this reused address which could result in many gigabytes of extra
download requirement.
So to fix this: a condition for aged coins is that their address has not
been reused, if the coin is on a reused address then the value of the
fidelity bond becomes zero.

@_date: 2019-07-30 22:39:14
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil 
No the attacker does not. I believe renting out UTXO proofs does not
change the privacy properties, because of the quadratic term in the
fidelity bond formula. This is where a sacrifice of V bitcoins creates a
bond of value V^2. The formula provides a strong incentive for
profit-motivated makers to use all their fidelity bond coins with just
one maker, not spread them out over many makers. JoinMarket takers
always use multiple makers, so a single maker can never deanonymize a
coinjoin just they get chosen by takers a lot. (But they would make
loads of money in coinjoin fees, which should encourage other makers to
also sacrifice coins in order to compete with them and capture some of
that fee income)
If a sybil attacker wants to run multiple makers for the purpose of
deanomyization then they will take a substantial quadratic hit in their
effectiveness. This is explored the other document "Financial
mathematics of JoinMarket fidelity bonds"

@_date: 2019-10-09 20:32:13
@_author: Chris Belcher 
@_subject: [bitcoin-dev] BIPable-idea: Consistent and better definition of 
This is an excellent idea and I hope something like this happens.
I've had the idea of using an intermediate name to make the transition
easier, for example "Bitcoin address" becomes "Bitcoin invoice address"
which after 10 years becomes "Bitcoin invoice" (or "Bitcoin invoice").
"Invoice" would also work well because Lightning uses the name invoice
for the object which is used to receive payments. So it's easy to
imagine that the GUI text input presented to users can be called
"invoice" and users can put both kinds of invoices there leaving the
wallet to easily figure out whether it makes an on-chain transaction or
a Lightning Network transaction.
Changing a commonly-used name like this could be very hard, but the
gains in terms of privacy are immense.

@_date: 2020-04-28 14:03:36
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Fwd: (Semi)Traceless 2-party coinjoin off-chain 
Hello list,
A couple of thoughts on multi-transaction coinswaps:
* Users should never split up a single UTXO before doing a coinswap,
instead they should send the one UTXO to a coinswap address and get back
multiple UTXOs.
For example, this 1-to-3 TXO coinswap (The symbol ----> means bitcoin
    AliceA (10 BTC) ----> CoinSwap AddressA ----> BobA (10 BTC)
    BobB (3 BTC) ----> CoinSwap AddressB ----> AliceB (6 BTC)
    BobC (2 BTC) ----> CoinSwap AddressC ----> AliceC (3 BTC)
    BobD (5 BTC) ----> CoinSwap AddressD ----> AliceD (1 BTC)
Note that the Bob-to-Alice set of transactions add up to 10 BTC, the
entire CoinSwap is swapping the same amount.
Or written another way:
    Alice TXO (10 BTC) ----> Coinswap Protocol ----> Alice TXO1 (6 BTC)
                                               ----> Alice TXO2 (3 BTC)
                                               ----> Alice TXO3 (1 BTC)
This kind of thing could also be used for consolidation of many UTXOs
without necessarily leaking information that the same person owns them.
For example, if Alice owns 5 UTXOs:
    Alice TXO1 ----> Coinswap Protocol ----> Alice TXO
    Alice TXO2 ---->
    Alice TXO3 ---->
    Alice TXO4 ---->
    Alice TXO5 ---->
* It's helpful if any CoinSwap app is actually used for spending rather
than just mixing back to yourself. That will help avoid the problem of
users inadvertently co-spending all their coinswap outputs in the same
An example of Alice paying for a VPN anonymously:
    Alice TXO (10 BTC) ---> Coinswap Protocol ---> VPN Payment (0.1 BTC)
                                              ---> Change1 (6 BTC)
                                              ---> Change2 (3 BTC)
                                              ---> Change3 (0.9 BTC)
In this case Alice will never accidentally merge all her TXOs together,
because the VPN Payment TXO doesn't belong to her. Also this could
improve privacy because unlike in normal transaction the VPN provider
might not be able to figure out the lower bound of Alice's balance (10
BTC in this case).
* Multi-transaction CoinSwaps aren't truly an example of a subset-sum
problem, but "sparse subset sum", a related and easier problem.
The way its normally formulated, subset sum is about finding a subset
that adds up to a target value. But in multi-transaction coinswap
there'd only be three or four CoinSwap outputs, so the problem is
finding just three or four integers in a big set that add up to the target.
You could think of it mathematically that the n-choose-k function is
near-polynomial when k is near 0 or near n, and the function is
exponential when k is near n/2.
A more promising way to build privacy is to create a situation where an
adversary would find a huge amount of false positives which are very
close the amount being sent. So even if the adversary has enough
computational power to iterate all the amounts it won't help them much
due to the huge number of false positives.

@_date: 2020-04-29 16:06:01
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Fwd: (Semi)Traceless 2-party coinjoin off-chain 
Hello ZmnSCPxj,
A great benefit of a CoinSwap system is that the transactions are
steganographic. If equal-output-coinjoins were involved that benefit
would be lost. So it would be better if it didn't happen.
JoinMarket has many mixdepths (5 by default) because it's
equal-output-coinjoins easily leak change addresses. CoinSwap
transactions don't have this flaw because they're steganographic. Such a
system could also be coded to intentionally break the weaker change
output heuristics
Equal-output-coinjoins and JoinMarket also have a version of the
common-input-ownership-heuristic (CIOH), because its often possible to
separate the inputs into sets of their owners of a equal-output-coinjoin
using the input amounts. CoinSwap can be combined with something like
PayJoin or CoinJoinXT, which would genuinely break the CIOH, so such a
system wouldn't have this flaw either.
For those reasons I've been thinking a CoinSwap system wouldn't need as
many mixdepths, maybe it could use two or even just one.
If so, then it follows that multi-transaction CoinSwaps can be done by
having UTXOs come from the same mixdepth, as long as the inputs that
should be separate are not co-spent in the same transaction.
Remember that a passive surveillor of the blockchain doesn't see
mixdepths at all, they see addresses and transactions, and must use
heuristics to try to cluster them together. We can break these heuristics.
Someone who has the ability to write such code should also have the
awareness to realize that mixing equal-output-coinjoins with coinswaps
damages the privacy because it breaks the steganography of coinswaps.
Also, because CoinSwap is better than equal-output CoinJoin in almost
every way, we can expect users (who are takers) to stop using JoinMarket
and switch over to CoinSwap if the software becomes mature. So such a
JoinMarket maker won't get many customers, and so there wouldn't be much
point writing such maker code.
But for sure it would be good to reuse code in any eventual
implementation. Indeed Waxwing's implementation did:
A good way to do it could be for Alice to tell Bob that she wants 10 BTC
and let Bob figure out on his own how to get that amount, based on the
amounts he already has. If Alice is making a payment she can provide
that amount too, but all the other output amounts can be up to Bob.
Bob would often still have to split a UTXO he owns, but see below about
breaking change address heuristics.
If Bob needs to split a UTXO he'd do that with a change output. And
because we understand change detection heuristics we can intentionally
break them, for example if Bob's UTXO is on a p2sh-p2wpkh address and
the CoinSwap address is of that type too (because ECDSA-2P is being
used) then Bob could make his change output p2wpkh or p2pkh. Then anyone
using the script-type-heuristic would think that the CoinSwap address is
actually change and still belongs to Bob, and that the real change
address is actually the payment or CoinSwap address. i.e. the adversary
would assume that wallet software only uses one script type, in this
case it assumes that Bob's wallet is exclusively p2sh-p2wpkh.
I think we can get the false positive count up because the n-choose-k
function still gets quite large as k increases.
We can make a simplified reasonable assumption that outputs on the
blockchain follow a lognormal distribution. An adversary trying to unmix
a 3-transaction CoinSwap would have to find the sum of every
3-combination of the relevant outputs. For our case, the sum of three
lognormal distributions is another lognormal distribution with different
parameters, it's corresponding frequency distribution would get scaled
by n-choose-3. This frequency distribution is what the adversary would
find when searching, and that distribution would be quite tall because
of the scaling by n-choose-k. Suppose our CoinSwap is for 4 BTC then the
adversary would look at their frequency distribution at 4 BTC and find a
pretty big number, i.e. many other combinations of 3 outputs would add
up to 4 BTC just by chance. That is the false positive rate, and is our
anonymity set with respect to this attack.
To work this out precisely we'd need to study the distribution of output
values on the blockchain today, and see how it behaves when summed
together. But the lognormal distribution assumption is probably not too
far from the truth, as it appears all the time in economics and finance,
and there is a clear justification for why. And the scaling by
n-choose-k would still hold.
Along with that, some output amounts have very few significant figures
(e.g. 1 BTC, 0.1 BTC, 0.01 BTC), presumably because the user types just
one number on their keyboard when creating a transaction. We can use
that fact to add a bit of privacy by occasionally making one of our
outputs also be rounded like that.

@_date: 2020-04-30 18:18:03
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Fwd: (Semi)Traceless 2-party coinjoin off-chain 
============================== START ==============================
Hello ZmnSCPxj,
Yes I guess you're right. This part about mixdepths requires further
CoinSwap can be combined with some kind of CoinJoin (most likely
something similar to PayJoin or CoinJoinXT). That should help with the
reasoning about co-spending inputs and mixdepths, because other inputs
that are not owned by the taker will often be co-spent anyway.
Regarding coins which mustn't be co-spent being coinswapped to somebody
else, ideally that coinswap maker will receive coins from unrelated
takers too, so will merge their coins along with those as well. Also the
fact that a coinswap happened means there are two transactions between
the taker's-inputs-which-mustnt-be-merged and them actually being merged.
Great point on the receive addresses coins. Another use case of
mixdepths is to stop incoming payments from two different sources being
linked together.
Yep great point.
A benefit of Alice not specifying any amounts is that Bob is able to
improve privacy and reduce costs by creating fewer change outputs. A
downside is that this leaks Alice's intentions (self-mix vs payment) to Bob.
A solution could be to add randomness. Have Alice randomly specify
payment amounts with some probability even if she is only self-mixing.
Although this doesn't solve everything, because Alice not specifying any
amounts implies self-mixing. But at least specifying some amounts
doesn't imply a payment.
Not exactly. Here's another summary:
Suppose Alice has V bitcoins and mixes them with multi-transaction
CoinSwap, she receives transactions with amounts (w_0, w_1, w_2....)
which add up to V.
Privacy relying on the (sparse) subset sum problem works by making it
_computationally infeasible_ for an adversary to search the entire
blockchain for sets of transactions (w_0, w_1, w_2....) which add up to
V. I believe aiming for this kind of privacy isn't practical due to
block space considerations and others.
Privacy relying on false positives does not make any search
computationally infeasible, it works by having a large number of other
sets of transactions (w_0, w_1, w_2....) which add up to V just by
chance. Then the transactions received by Alice's will have a big crowd
to hide in. I believe this is practical because the numbers are
proportional to the n-choose-k function which can still be very large.

@_date: 2020-08-11 13:05:57
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Detailed protocol design for routed multi-transaction 
I'm currently working on implementing CoinSwap (see my other email
"Design for a CoinSwap implementation for massively improving Bitcoin
privacy and fungibility").
CoinSwaps are special because they look just like regular bitcoin
transactions, so they improve the privacy even for people who do not use
them. Once CoinSwap is deployed, anyone attempting surveillance of
bitcoin transactions will be forced to ask themselves the question: how
do we know this transaction wasn't a CoinSwap?
This email contains a detailed design of the first protocol version. It
makes use of the building blocks of multi-transaction CoinSwaps, routed
CoinSwaps, liquidity market, private key handover, and fidelity bonds.
It does not include PayJoin-with-CoinSwap, but that's in the plan to be
added later.
== Routed CoinSwap ==
Diagram of CoinSwaps in the route:
    Alice ====> Bob ====> Charlie ====> Alice
Where (====>) means one CoinSwap. Alice gives coins to Bob, who gives
coins to Charlie, who gives coins to Alice. Alice is the market taker
and she starts with the hash preimage. She chooses the CoinSwap amount
and chooses who the makers will be.
This design has one market taker and two market makers in its route, but
it can easily be extended to any number of makers.
== Multiple transactions ==
Each single CoinSwap is made up of multiple transactions to avoid amount
          (a0 BTC) --->     (b0 BTC) --->         (c0 BTC) --->
    Alice (a1 BTC) ---> Bob (b1 BTC) ---> Charlie (c1 BTC) ---> Alice
          (a2 BTC) --->     (b2 BTC) --->         (c2 BTC) --->
The arrow (--->) represent funding transactions. The money gets paid to
a 2-of-2 multisig but after the CoinSwap protocol and private key
handover is done they will be controlled by the next party in the route.
This example has 6 regular-sized transactions which use approximately
the same amount of block space as a single JoinMarket coinjoin with 6
parties (1 taker, 5 makers). Yet the privacy provided by this one
CoinSwap would be far far greater. It would not have to be repeated in
the way that Equal-Output CoinJoins must be.
== Direct connections to Alice ===
Only Alice, the taker, knows the entire route, Bob and Charlie just know
their previous and next transactions. Bob and Charlie do not have direct
connections with each other, only with Alice.
Diagram of Tor connections:
    Bob      Charlie
       /
      /
     /
      Alice
When Bob and Charlie communicate, they are actually sending and
receiving messages via Alice who relays them to Charlie or Bob. This
helps hide whether the previous or next counterparty in a CoinSwap route
is a maker or taker.
This doesn't have security issues even in the final steps where private
keys are handed over, because those private keys are always for 2-of-2
multisig and so on their own are never enough to steal money.
=== Miner fees ===
Makers have no incentive to pay any miner fees. They only do
transactions which earn them an income and are willing to wait a very
long time for that to happen. By contrast takers want to create
transactions far more urgently. In JoinMarket we coded a protocol where
the maker could contribute to miner fees, but the market price offered
of that trended towards zero. So the reality is that takers will pay all
the miner fees. Also because makers don't know the taker's time
preference they don't know how much they should pay in miner fees.
The taker will have to set limits on how large the maker's transactions
are, otherwise makers could abuse this by having the taker consolidate
maker's UTXOs for free.
== Funding transaction definitions ==
Funding transactions are those which pay into the 2-of-2 multisig addresses.
I = initial coinswap amount sent by Alice = a0 + a1 + a2
(WA, WB, WC) = Total value of UTXOs being spent by Alice, Bob, Charlie
               respectively. Could be called "wallet Alice", "wallet
               Bob", etc
(B, C) = Coinswap fees paid by Alice and earned by Bob and Charlie.
(M1, M2, M3) = Miner fees of the first, second, third, etc sets of
               funding transactions. Alice will choose what these are
               since she's paying.
multisig(A+B) = A 2of2 multisig output with private keys held by A and B
The value in square parentheses refers to the bitcoin amount.
Alice funding txes
  [WA btc] ---> multisig (Alice+Bob) [I btc]
                change [WA-M1-I btc]
Bob funding txes
  [WB btc] ---> multisig (Bob+Charlie) [I-M2-B btc]
                change [WB-I+B btc]
Charlie funding txes
  [WC btc] ---> multisig (Charlie+Alice) [(I-M2-B)-M3-C btc]
                change [WC-(I-M2-B)+C btc]
Here we've drawn these transactions as single transactions, but they are
actually multiple transactions where the outputs add up some value (e.g.
add up to I in Alice's transactions.)
=== Table of balances before and after a successful CoinSwap ===
If a CoinSwap is successful then all the multisig outputs in the funding
transactions will become controlled unilaterally by one party. We can
calculate how the balances of each party change.
Party   | Before | After
Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C
Bob     | WB     | WB-I+B + I               = WB+B
Charlie | WC     | WC-(I-M2-B)+C + I-M2-B   = WC+C
After a successful coinswap, we see Alice's balance goes down by the
miner fees and the coinswap fees. Bob's and Charlie's balance goes up by
their coinswap fees.
== Contract transaction definitions ==
Contract transactions are those which may spend from the 2-of-2 multisig
outputs, they transfer the coins into a contract where the coins can be
spent either by waiting for a timeout or providing a hash preimage
value. Ideally contract transactions will never be broadcast but their
existence keeps all parties honest.
M~ is miner fees, which we treat as a random variable, and ultimately
set by whichever pre-signed RBF tx get mined. When we talk about _the_
contract tx, we actually mean perhaps 20-30 transactions which only
differ by the miner fee and have RBF enabled, so they can be broadcasted
in sequence to get the contract transaction mined regardless of the
demand for block space.
(Alice+timelock_A OR Bob+hash) = Is an output which can be spent
                                 either with Alice's private key
                                 after waiting for a relative
                                 timelock_A, or by Bob's private key by
                                 revealing a hash preimage value
Alice contract tx:
    multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)
    [I btc]                   [I-M~ btc]
Bob contract tx:
    multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)
    [I-M2-B btc]                [I-M2-B-M~ btc]
Charlie contract tx:
    multisig (Charlie+Alice)  ---> (Charlie+timelock_C OR Alice+hash)
    [(I-M2-B)-M3-C btc]            [(I-M2-B)-M3-C-M~ btc]
=== Table of balances before/after CoinSwap using contracts transactions ===
In this case the parties had to get their money back by broadcasting and
mining the contract transactions and waiting for timeouts.
Party   | Before | After
Alice   | WA     | WA-M1-I + I-M~                   = WA-M1-M~
Bob     | WB     | WB-I+B + I-M2-B-M~               = WB-M2-M~
Charlie | WC     | WC-(I-M2-B)+C + (I-M2-B)-M3-C-M~ = WC-M3-M~
In the timeout failure case, every party pays for their own miner fees.
And nobody earns or spends any coinswap fees. So even for a market maker
its possible for their wallet balance to go down sometimes, although as
we shall see there are anti-DOS features which make this unlikely to
happen often.
A possible attack by a malicious Alice is that she chooses M1 to be very
low (e.g. 1 sat/vbyte) and sets M2 and M3 to be very high (e.g. 1000
sat/vb) and then intentionally aborts, forcing the makers to lose much
more money in miner fees than the attacker. The attack can be used to
waste away Bob's and Charlie's coins on miner fees at little cost to the
malicious taker Alice. So to defend against this attack Bob and Charlie
must refuse to sign a contract transaction if the corresponding funding
transaction pays miner fees greater than Alice's funding transaction.
There can also be a failure case where each party gets their money using
hash preimage values instead of timeouts. Note that each party has to
sweep the output before the timeout expires, so that will cost an
additional miner fee M~.
Party   | Before | After
Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~
Bob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~
Charlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~
In this situation the makers Bob and Charlie earn their CoinSwap fees,
but they pay an additional miner fee twice. Alice pays for all the
funding transaction miner fees, and the CoinSwap fees, and two
additional miner fees. And she had her privacy damaged because the
entire world saw on the blockchain the contract script.
Using the timelock path is like a refund, everyone's coin just comes
back to them. Using the preimage is like the CoinSwap transaction
happened, with the coins being sent ahead one hop. Again note that if
the preimage is used then coinswap fees are paid.
=== Staggered timelocks ===
The timelocks are staggered so that if Alice uses the preimage to take
coins then the right people will also learn the preimage and have enough
time to be able to get their coins back too. Alice starts with knowledge
of the hash preimage so she must have a longest timelock.
== EC tweak to reduce one round trip ==
When two parties are agreeing on a 2-of-2 multisig address, they need to
agree on their public keys. We can avoid one round trip by using the EC
tweak trick.
When Alice, the taker, downloads the entire offer book for the liquidity
market, the offers will also contain a EC public key. Alice can tweak
this to generate a brand new public key for which the maker knows the
private key. This public key will be one of the keys in the 2-of-2
multisig. This feature removes one round trip from the protocol.
    q = EC privkey generated by maker
    Q = q.G = EC pubkey published by maker
    p = nonce generated by taker
    P = p.G = nonce point calculated by taker
    R = Q + P = pubkey used in bitcoin transaction
      = (q + p).G
Taker sends unsigned transaction which pays to multisig using pubkey Q,
and also sends nonce p. The maker can use nonce p to calculate (q + p)
which is the private key of pubkey R.
Taker doesnt know the privkey because they are unable to find q because
of the ECDLP.
Any eavesdropper can see the nonce p and easily calculate the point R
too but Tor communication is encrypted so this isnt a concern.
None of the makers in the route know each other's Q values, so Alice the
taker will generate a nonce p on their behalf and send it over. I
believe this cant be used for any kind of attack, because the signing
maker will always check that the nonce results in the public key
included in the transaction they're signing, and they'll never sign a
transaction not in their interests.
== Protocol ==
This section is the most important part of this document.
fund = all funding txes (remember in this multi-tx protocol there can be
       multiple txes which together make up the funding)
A htlc = all htlc contract txes (fully signed) belonging to party A
A unsign htcl = all unsigned htlc contract txes belonging to party A
                including the nonce point p used to calculate the
                maker's pubkey.
p = nonce point p used in the tweak EC protocol for calculating the
    maker's pubkey
A htlc B/2 = Bob's signature for the 2of2 multisig of the Alice htlc
             contract tx
privA(A+B) = private key generated by Alice in the output
             multisig (Alice+Bob)
 Alice           | Bob             | Charlie         |
0. A unsign htlc ---->               |                 |
1.               <---- A htlc B/2    |                 |
2. ***** BROADCAST AND MINE ALICE FUNDING TXES ******  |
3. A fund+htlc+p ---->               |                 |
4.                 | B unsign htlc ---->               |
5.                 |               <---- B htlc C/2    |
6. ******* BROADCAST AND MINE BOB FUNDING TXES ******* |
7.                 | B fund+htlc+p ---->               |
8.               <---------------------- C unsign htlc |
9.    C htlc A/2 ---------------------->               |
A. ***** BROADCAST AND MINE CHARLIE FUNDING TXES ***** |
B.               <---------------------- C fund+htlc+p |
C. hash preimage ---------------------->               |
D. hash preimage ---->               |                 |
E.    privA(A+B) ---->               |                 |
F.                 |    privB(B+C) ---->               |
G.               <---------------------- privC(C+A)    |
== Protocol notes ==
0-2 are the steps which setup Alice's funding tx and her contract tx for
    possible refund
4-5 same as 0-2 but for Bob
8-9 same as 0-2 but for Charlie
3,7 is proof to the next party that the previous party has already
    committed miner fees to getting a transaction mined, and therefore
    this isnt a DOS attack. The step also reveals the fully-signed
    contract transaction which the party can use to get their money back
    with a preimage.
C-G is revealing the hash preimage to all, and handing over the private
    keys
== Analysis of aborts ==
We will now discuss aborts, which happen when one party halts the
protocol and doesnt continue. Perhaps they had a power cut, their
internet broke, or they're a malicious attacker wanting to waste time
and money. The other party may try to reestablish a connection for some
time, but eventually must give up.
Number refers to the step number where the abort happened
e.g. step 1 means that the party aborted instead of the action happening
on protocol step 1.
The party name refers to what that party does
e.g. Party1: aborts, Party2/Party3: does a thing in reaction
0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or
   money
1. Bob: aborts. Alice: lost no time or money, try with another Bob.
   Charlie: do nothing
2-3. same as 0.
4. Bob: aborts. Charlie: do nothing. Alice: broadcasts her contract tx
   and waits for the timeout, loses time and money on miner fees, she'll
   never coinswap with Bob's fidelity bond again.
5. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to
   coinswap with.
6. same as 4.
7. similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,
   because Bob will also have to broadcast his contract tx and will also
   lose time and money.
8. Charlie: aborts. Bob: broadcast his contract transaction and wait for
   the timeout to get his money back, also broadcast Alice's contract
   transaction in retaliation. Alice: waits for the timeout on her htlc
   tx that Bob broadcasted, will never do a coinswap with Charlie's
   fidelity bond again.
9. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:
   broadcast bob contract tx and wait for timeout to get money back,
   comforted by the knowledge that when Alice comes back online she'll
   have to do the same thing and waste the same amount of time and
   money.
A-B. same as 8.
C-E. Alice: aborts. Bob/Charlie: all broadcast their contract txes and
     wait for the timeout to get their money back, or if Charlie knows
     the preimage he uses it to get the money immediately, which Bob can
     read from the blockchain and also use.
F. Bob: aborts. Alice: broadcast Charlie htlc tx and use preimage to get
   money immediately, Alice blacklists Bob's fidelity bond. Charlie:
   broadcast Bob htlc and use preimage to get money immediately.
G. Charlie: aborts. Alice: broadcast Charlie htlc and use preimage to
   get money immediately, Alice blacklists Charlie's fidelity bond. Bob:
   does nothing, already has his privkey.
==== Retaliation as DOS-resistance ====
In some situations (e.g. step 8.) if one maker in the coinswap route is
the victim of a DOS they will retaliate by DOSing the previous maker in
the route. This may seem unnecessary and unfair (after all why waste
even more time and block space) but is actually the best way to resist
DOS because it produces a concrete cost every time a DOS happens.
== Analysis of deviations ==
This section discusses what happens if one party deviates from the
protocol by doing something else, for example broadcasting a htlc
contract tx when they shouldnt have.
The party name refers to what that party does, followed by other party's
reactions to it.
e.g. Party1: does a thing, Party2/Party3: does a thing in reaction
If multiple deviations are possible in a step then they are numbered
e.g. A1 A2 A2 etc
0-2. Alice/Bob/Charlie: nothing else is possible except following the
     protocol or aborting
3. Alice: broadcasts one or more of the A htlc txes. Bob/Charlie/Dennis:
   do nothing, they havent lost any time or money.
4-6. Bob/Charlie: nothing else is possible except following the protocol
     or aborting.
7. Bob: broadcasts one or more of the B htlc txes, Alice: broadcasts all
   her own A htlc txes and waits for the timeout to get her money back.
   Charlie: do nothing
8. Charlie: nothing else is possible except following the protocol or
   aborting.
9. Alice: broadcasts one or more of the A htlc txes. Bob: broadcasts all
   his own A htlc txes and waits for the timeout.
A. same as 8.
B. Charlie: broadcasts one or more of the C htlc txes, Alice/Bob:
   broadcasts all their own htlc txes and waits for the timeout to get
   their money back.
C-E1. Alice: broadcasts all of C htlc txes and uses her knowledge of the
      preimage hash to take the money immediately. Charlie: broadcasts
      all of B htlc txes and reading the hash value from the blockchain,
      uses it to take the money from B htlc immediately. Bob: broadcasts
      all of A htlc txes, and reading hash from the blockchain, uses it
      to take the money from A htlc immediately.
C-E2. Alice: broadcast her own A htlc txes, and after a timeout take the
      money. Bob: broadcast his own B htlc txes and after the timeout
      take their money. Charlie: broadcast his own C htlc txes and after
      the timeout take their money.
F1. Bob: broadcast one or more of A htcl txes and use the hash preimage
    to get the money immediately. He already knows both privkeys of the
    multisig so this is pointless and just damages privacy and wastes
    miner fees. Alice: blacklist Bob's fidelity bond.
F2. Bob: broadcast one or more of the C htlc txes. Charlie: use preimage
    to get his money immediately. Bob's actions were pointless. Alice:
    cant tell whether Bob or Charlie actually broadcasted, so blacklist
    both fidelity bonds.
G1. Charlie: broadcast one or more of B htcl txes and use the hash
    preimage to get the money immediately. He already knows both
    privkeys of the multisig so this is pointless and just damages
    privacy and wastes miner fees. Alice: cant tell whether Bob or
    Charlie actually broadcasted, so blacklist both fidelity bonds.
G2. Charlie: broadcast one or more of the A htlc txes. Alice: broadcast
    the remaining A htlc txes and use preimage to get her money
    immediately. Charlies's actions were pointless. Alice: blacklist
    Charlie's fidelity bond.
The multisig outputs of the funding transactions can stay unspent
indefinitely. However the parties must always be watching the network
and ready to respond with their own sweep using a preimage. This is
because the other party still possesses a fully-signed contract tx. The
parties respond in the same way as in steps C-E1, F2 and G2. Alice's
reaction of blacklisting both fidelity bonds might not be the right way,
because one maker could use it to get another one blacklisted (as well
as themselves).
== Conclusion ==
This document describes the first version of the protocol which
implements multi-transaction Coinswap, routed Coinswap, fidelity bonds,
a liquidity market and private key handover. I describe the protocol and
also analyze aborts of the protocols and deviations from the protocol.

@_date: 2020-08-20 23:15:34
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Detailed protocol design for routed 
Hello ZmnSCPxj,
Thanks for the review. My comments are inline.
Yes great point.
Right, so if the taker uses only a single maker then they must have more
than one UTXO.
This leak in the case of a taker spending a single UTXO also happens
when the taker needs to create a branching route. I described this in my
original email "Design for a CoinSwap implementation for massively
improving Bitcoin privacy and fungibility" under the section "Combining
multi-transaction with routing" (the second diagram).
I think this might be unavoidable. If the taker has just one UTXO they'd
be much better off using multiple makers for this reason.
Sounds like adding random delays would fix this. The protocol already
involves waiting for a confirmation (average waiting time 10 minutes, at
best) and might involve more confirmations for extra security and
privacy. So adding a random delay of up to 0.5-1 minutes shouldnt cause
too many issues.
Also the Tor network can be pretty laggy so that might add enough noise
Having the taker pay for just one UTXO will have an unfortunate side
effect of resulting in the maker's money being split up into a large
number of UTXOs, because every CoinSwap they take part in has an
incentive to increase their UTXO count by one. At the start of
JoinMarket this was an issue where then a taker wanting to CoinJoin a
large would come along and the result would be a huge CoinJoin
transaction with many many small inputs. Perhaps the taker could pay for
2-3 UTXOs to counteract this. (Of course the exact number would be
configurable by the taker user, but defaults usually don't get changed).
I'm still not convinced with having makers contribute to miner fees. In
JoinMarket we tried to get makers to contribute a little to miner fees
and simply they never did in any meaningful way. The market has spoken.
In terms of incentives makers are happy to wait a very long time, if we
assume they're just HODLers then even if they earn a few thousand
satoshis that's good.
I think RBF transactions are better because they ultimately use less
block space than CPFP.
There seems to be very little cost in signing many additional
precomputed RBF transactions. So the taker and makers could sign
transactions all the way up to 10000 sat/vbyte. I think this doesn't
apply to Lightning, because bandwidth seems to be more constrained
there: even a tiny micropayment for 1 satoshi would require 10x or 100x
more bandwidth if every lightning htlc used precomputed RBF.
Alice only pays the miner fees for the funding transactions, not the
contract transaction. The miner fees for the contract transactions are
taken from the contract balance. The contract transactions are 1-input
1-output, and whoever ends up with the money will be the one who paid
the miner fee.
Every off-chain protocol like this has the livelyness requirement. Each
party must always be watching the chain and be ready to broadcast
something in response. I'm not sure how any of this relates to the
choice of relative vs absolute time locks.
You're right that attempting such an move by the taker is riskless, but
its not costless. The taker sets up the entire CoinSwap protocol because
they wanted more privacy; but if the taker broadcasts the Alice contract
transaction and waits for the timeout, then all they've achieved is
spent miner fees, got their own coin back and draw attention to it with
the unusual HTLC script. They've achieved no benefit from what I see, so
they won't do this. Any taker or maker who attempts anything like this
will be spending miner fees.
I also envision that makers will run their own personal "watchtowers",
similar to watchtowers in the lightning world, which would watch the
blockchain and be ready to broadcast a transaction. In terms of
incentives, makers are HODLers and we can expect them to protect their
stash very carefully by running perhaps multiple redundant watchtowers
in multiple locations and multiple networks. Therefore a taker noticing
that a maker's .onion is down does not imply that all the maker's
watchtowers are down.
Of course we will choose the timelocks to be long enough so that
everyone has enough time to broadcast a transaction in response, even in
times of congested mempools.
I don't think this will happen very often. It's spending money on block
space for not much benefit. If the maker ever decides to shut down their
maker they can transfer all their coins in HTLCs to single-sig
transactions exclusively controlled by them, but in normal operation I
doubt it will happen.
I'll try to explain again with an example, hopefully it clarifies.
Recall the table of balances before/after CoinSwap using contracts
Party   | Before | After
Alice   | WA     | WA-M1-I + I-MA~                  = WA-M1-MA~
Bob     | WB     | WB-I+B + I-M2-B-MB~              = WB-M2-MB~
What the table says is that if the CoinSwap results in the HTLC
transactions being mined and the locktime branch being used, then both
Alice and Bob will see their wallet balance fall by two miner fees (in
Alice's case the miner fee of the Alice funding transaction plus the
miner fee of the Alice contract transaction).
The attack I describe works because Alice chooses both MA~ and MB~. The
attack is that Alice chooses MA~ to be a very low value (e.g. 1 sat/vb)
and chooses MB~ to be a very high value (e.g. 1000 sat/vb). Then Alice
intentionally sabotages the CoinSwap and forces it to go to the timeout
case, what happens is that Bob's wallet balance falls by much more than
Alice's, because MB~ > MA~. So this is a DOS attack: Alice can waste
Bob's resources without wasting much of her own.
Perhaps I chose confusing terminology, "Alice contract transaction"
means the transaction which pays money to Alice after a timeout. The
text you quoted is confusingly written, and it would've been better to
write: "Alice starts with knowledge of the hash preimage so the Alice
contract transaction must have a longest timelock."
Yes, I intend for 2p-ECDSA to be used eventually, but for the first
version I'll only implement regular multisigs with OP_CHECKMULTISIG.
Once all the other details of this protocol are implemented correctly
and mostly-bug-free then 2p-ECDSA can be added. It can be added in the
protocol steps 0-1, 3-5 and 7-9.
This document also doesn't talk about PayJoin-with-CoinSwap, but that
can be added later too.
I really hope that everyone (the makers at least) is running multiple
redundant watchtowers, so that anyone attempting this attack just wastes
money on miner fees and achieves nothing.

@_date: 2020-08-20 23:37:35
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Detailed protocol design for routed 
Hello Nadav and ZmnSCPxj,
Yes this looks right. In hindsight my text could be clarified by
changing the relevant lines to:
    p = nonce generated by taker, sent to maker
    P = p.G = nonce point calculated by taker
    R = Q + P = pubkey used in bitcoin transaction, calculated by taker
      = (q + p).G = same pubkey, calculated by maker
I don't think the key subtraction attack described by Nadav will work
I completely agree that 2of2 multisigs made with OP_CHECKMULTISIG are
lacking in terms of privacy, and that 2p-ECDSA is much better. However
this whole protocol is quite complicated and I thought it would be a
good move to first implement it with OP_CHECKMULTISIG, to get all the
other details right (miner fees, coinswap fees, private key handover,
contract transactions, tor hidden services, watchtowers, etc etc) and
then add 2p-ECDSA later. Of course in that case all this tweaking of
public keys would be superseded by the 2p-ECDSA protocol.

@_date: 2020-08-21 10:47:31
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Detailed protocol design for routed 
I write about multipath CoinSwap routes in the original design document,
under "Combining multi-transaction with routing"
Got it. I agree having a CPFP anchor output on the largest fee RBF is a
good idea then.
You can always put your node to sleep as a maker, and your watchtowers
will protect you.
What do you mean by the point about 100% online nodes getting more
feasible? Many bitcoin nodes have been always-on for years, I think I
missed something.
Yep you're right, I get it.
The biggest defense against theft will have to be multiple redundant
watchtowers. But as you say the attack is riskless and costless for the
taker to attempt, so they might try anyway even if the probability of
success is very low.
If this attack becomes widespread then it effectively breaks the
property that maker's coins remain unspent indefinitely. It seems like
that would lead to makers increasing their CoinSwap fees because they
know they'll always have to spend a bit of miner fees afterwards.
Hopefully the success rate for this attack can be low enough that
taker's human niceness will stop them trying. But for sure this is a
concerning problem.
A downside of using absolute timelocks is that it combines the two time
periods: the time period where a watchtower must respond and the time
period under which private keys must be used.
So for example if the absolute timelock is set to 3 weeks, that means
the maker has 3 weeks to spend their coins using the private keys which
is a nice long period. However if the CoinSwaps fails with the timeout
case then the maker has to wait 3 weeks to get their coins back, which
is a long time.
We can go the other extreme and set the absolute timelock to be 2 days.
Then the maker only has to wait 2 days in the unfortunate event that
their coinswap fails with the timeout case. But it means they must use
their private keys to spend coins within the short period of 2 days(!)
Though this still might be worth it to solve the riskless/costless
stealing attempts.
Right, but taking out the maker hardware isn't enough for funds to be
stolen, all the watchtowers would need to be taken out too.
I completely agree.

@_date: 2020-08-29 23:03:09
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Detailed protocol design for routed 
Hello Antoine,
Thanks for the very useful insights.
It seems having just one contract transaction which includes anchor
outputs in the style already used by Lightning is one way to fix both
these vulnerabilities.
For the first attack, the other side cannot burn the entire balance
because they only have access to the small amount of satoshi of the
anchor output, and to add miner fees they must add their own inputs. So
they'd burn their own coins to miner fees, not the coins in the contract.
For the second attack, the other side cannot do transaction pinning
because there is only one contract transaction, and all the protections
already developed for use with Lightning apply here as well, such as
CPFP carve out.
Another possible fix for both vulnerabilities is to separate the
timelock and hashlock cases into two separate transactions as described
by ZmnSCPxj in a recent email to this list. This comes at the cost of
breaking private key handover allowing coins to remain unspent indefinitely.
Another possible fix for the second attack, is to encumber the output
with a `1 OP_CSV` which stops that output being spent while unconfirmed.
This seems to be the simplest way if your aim is to only fix the second
These are all the possible fixes I can think of.

@_date: 2020-06-02 23:24:19
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Design for a CoinSwap implementation for 
Hello ZmnSCPxj,
The main benefit of PayJoin-with-CoinSwap is it breaks the
common-input-ownership heuristic, which is a major widely used
heuristic. It would be a big win if that heuristic could be broken.
PayJoin-with-CoinSwap would be useful if Alice is trying to recover some
privacy which was previously degraded, for example if she is spending
from a reused address or from an address linked to her identity. If she
does a PayJoin with the reused address then some other economic entity
would have his activity linked with Alice's.
Just the fact that PayJoin-with-CoinSwap exists would improve privacy
for people who don't use it, for example if someone buys bitcoin from an
exchange that knows their identity and then co-spends it with other
coins they obtained another way. The fact that PayJoin exists means an
adversary cannot assume for sure that this user really owns that other
address which was co-spent. This doesn't apply for regular CoinSwap,
which only ever breaks the transaction graph heuristic, so in our
example the destination the coins are sent *to* would be uncertain, but
that the co-spent inputs are owned by the same person would be certain
in a world where PayJoin didn't exist.
Opening up the possibility of spying for free is a real downside for
PayJoin-with-CoinSwap. Using decoy UTXOs as described in my design
document, rather than PoDLE, seems like a better way of resisting these
attacks. This is because at the cost of a little bit more bandwidth and
CPU its possible to make the probability of an attacker successfully
guessing the maker's real UTXOs to be as low as you want.
On the other hand, funds claiming in S6 is also ordered in time, so
someone paying attention to the mempool could guess as well the order of
I think this is wrong, and that it's possible for the funding
transactions of chained/routed swaps to all be in the same block as well.
In CoinSwap it's possible to get DOS'd without the other side spending
money if you broadcast your funding transaction first and the other side
simply disappears. You'd get your money back but you have to waste time
and spend miner fees. The other side didn't spend money to do this, not
even miner fees.
get DOS'd like this for free if we only broadcast our funding
transaction once we've seen the other side's funding transaction being
broadcast first. This should work as long as the two transactions have a
similar fee rate. There might be an attack involving hash power: If the
other side has a small amount of hash power and mines only their funding
transaction in a manner similar to a finney attack, then our funding
transaction should get mined very soon afterwards by another miner and
the protocol will continue as normal. If the other side has knowledge of
the preimage and uses it to do CPFP and take the money, then we can
learn that preimage and do our own CPFP to get our money back too.
So in a routed coinswap setup it should be possible for Alice the taker
to broadcast her funding transaction first, which will lead to all the
makers broadcasting their funding transactions as well once they see the
other side has broadcast first. Then it would be possible for all those
funding transactions to be confirmed in the same block.
I hope I haven't missed anything, because if this doesn't work and each
maker must wait for confirmations, then the UX of routed CoinSwap would
degrade: a CoinSwap route of 5 makers would require at least 5 blocks to
be mined.
Of course this setup can leak the ordering of the routes because the
funding transaction would appear in the mempool in that order, but this
could be beaten if some Alices choose to intentionally spread out the
funding transaction broadcasts among multiple blocks for privacy reasons.
An interesting tangent could be to see if it's possible to make private
key handover work with S6. A nice side-effect of private key handover is
that the transfer of possession of the coins happens off-chain, so then
paying attention to the mempool won't help an adversary much.
Chris Belcher

@_date: 2020-06-05 23:39:47
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Design for a CoinSwap implementation for 
Good day ZmnSCPxj,
Your RBF observation actually blows my idea out of the water. Not just
because of RBF but because of an attack by a miner.
Supposing that Alice starts with knowledge of the hash preimage, if she
uses RBF to make her funding transaction never confirm but allows Bob's
funding transaction to confirm, then Alice can use her preimage to take
the money from Bob's funding transaction. Bob will learn the value of
the preimage but it won't be much good to him because Alice's funding
transaction isn't valid anymore. Alice will get money from her funding
transaction and also money from Bob's funding transaction.
Because of this attack, it's pretty clear that a CoinSwap peer who
starts _without_ knowledge of the preimage must wait for the other
side's funding transaction to actually confirm, perhaps even with
multiple confirmations if they fear that the other side has access to
hashpower. For example, a miner could play the role of Alice and use
this attack to almost-risklessly steal Bob's coins using a finney attack.
That also seems to mean that a N-party routed CoinSwap requires at least
N blocks to be mined for all the funding transactions to be mined, which
is a slight setback for user experience. (Although even with today's
existing privacy tech, users must hang around waiting for coinjoins to
be signed, or waiting for multiple coinjoins to be confirmed.
Blockchains are inherently slow and we can't get around that.)
I think I'm having trouble understanding this, does it work like this:
Say we're in the 2-party coinswap case (Alice and Bob)
We have Alice's funding transaction:
   Alice UTXO ---> 2of2 multisig (Alice+Bob)
And we have the regular contract transaction
   2of2 multisig (Alice+Bob) ---> Alice+timelock1 OR Bob+hashlock
And you propose a second pre-signed transaction?
   2of2 multisig (Alice+Bob) ---> Bob+timelock2
Where timelock2 > timelock1
If that's the protocol, then it's vulnerable to an attack. Once the
preimage is revealed we should be in a situation where Bob can
unilaterally get his coins back by broadcasting the regular contract
transaction and using the preimage to immediately get his coins. That
means Alice will be happy to hand over her private key, just to save
miner fees and improve privacy. But if the second pre-signed transaction
exists then Alice could do an attack where she broadcasts it and gets it
mined (perhaps more successfully if she has some hashpower). Once it's
mined then the regular contract transaction becomes invalid and Bob
can't get his money, in other words Bob doesn't have unilateral control
over those coins.

@_date: 2020-06-10 11:15:36
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Design for a CoinSwap implementation for 
Good morning ZmnSCPxj,
Thanks for the explanation. I understand now, and I understand how this
makes it possible for all funding transactions in a coinswap route to be
confirmed in the same block.
However, I think this also breaks private key handover. Here's why:
Recall that in a Alice/Bob coinswap we have two funding transactions
(Alice --> multisig(Alice, Bob) and Bob --> multisig(Bob,Alice)), and
two contract transactions (multisig(Alice, Bob) -->
Alice+OP_CSV_timelock OR Bob+hashlock and multisig(Bob,Alice -->
Bob+OP_CSV_timelock OR Alice+hashlock). After the hashlock preimage
becomes known to all then Alice and Bob give their multisig privkey to
the other party.
Bob now has both privkeys in the multisig(Alice,Bob) so he can sign any
transaction he wants spending from it, but the contract transaction
still exists. So until Bob actually spends from the multisig he must
always be watching the blockchain, and if Alice broadcasts the contract
transaction then Bob must immediately spend from it using the hash
preimage branch. If Bob waits too long and the OP_CSV timelock value
passes then Alice can steal Bob's money by spending with that path. The
OP_CSV timelock only starts ticking when the contract transaction
actually confirms, and this is crucial for making privkey handover
practical because it means the coins in the multisig can stay unspent
However, I think this does not apply to the scheme you described which
uses nLockTime, because after the privkeys are handed over Alice's
backout transaction (Alice+Bob -(nLockTime=locktime1)-> Alice) still
exists, and Alice could broadcast it. Once locktime1 passes then Alice
can steal Bob's coins by broadcasting even though Bob holds both
privkeys to that multisig. And using relative nLockTime doesn't help
either because its timelock will start ticking down from when the
funding transaction is confirmed, not when the contract transaction is
confirmed, and so the coins in the multisig cant remain unspent
So fundamentally I think privkey handover gets broken here because it
requires relative timelocks. And those the relative timelocks need to
start ticking down only after a contract transaction is confirmed.
I was aware. In such a scheme we'd still require the other building
blocks like fidelity bonds, multi-transaction and routing. So I was
thinking to code the project using the simplest hash-time-locked
contracts and once it all works we can add things like ECDSA-2P
scriptless scripts or schnorr signatures when they get added. Making the
Spilman channel scheme work with that is an interesting idea, thanks for
the thought.
That's an interesting point, thanks for the thought. This scheme might
not be appropriate for every threat model and use case.
For example, if someone wants to use bitcoin just as a foreign currency
for its privacy and censorship-resistant properties. So for example if
they want to pay for a VPN anonymously, so they buy bitcoins and
immediately send all of them to the VPN merchant. The swap-on-receive
wouldn't be appropriate for them because they'll be doing a coinswap
straight away to the VPN merchant. So perhaps this plan could be an
optional mode of operation (which may or may not be the default). The
scheme obviously is useful when bitcoin is being used more as a
day-to-day money.

@_date: 2020-06-10 12:15:03
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Design for a CoinSwap implementation for 
Hello Lee,
Thanks for the review.
You are right to be concerned about scalability.
Here's a few of my thoughts on this:
An issue with Monero (or any cryptocurrency based on the ring signature
input signing scheme) isn't just that transactions are bigger in bytes.
Monero full nodes can't know when a TXO has been spent, so pruning is
impossible in Monero and the list of TXOs perpetually grows, this is
unlike in bitcoin where full nodes know if a UTXO has been spent and so
can delete it in pruning. The storage space needed for Bitcoin's UTXO
set sometimes actually gets smaller.
Note that Monero software actually has a feature called "pruning" so
sometimes the terminology gets confused when people say "wait, Monero
_does_ have pruning". But this pruning doesn't do the same thing as
Bitcoin's pruning, the disk space still grows as O(TXOcount) which is
much faster compared to Bitcoin's O(UTXOcount).
And when designing this CoinSwap system I've been careful to make sure
it doesn't break pruning (or other resources saving features, for
example CoinSwap can be made to work with the blocksonly feature of
Bitcoin Core). So bitcoin-with-CoinSwap's scalability isnt anywhere near
as bad as Monero's.
You're right to talk about decoys. Decoys are not a good way to obtain
privacy because they can be broken by repeated interactions.. I really
like this talk about why decoys are not a good solution to privacy in
many cases:
talk: Equal-output CoinJoins also work with decoys. Like in JoinMarket you
could analyze those CoinJoins to say that the inputs and outputs of the
makers in a CoinJoin are actually just decoys. Fixed-denomination
CoinJoins like in Wasabi or Samourai also use much more block space
because of the reduced divisibility, for example Wasabi coinjoins can
only be done with about 0.1 BTC, so if you want to mix 1 BTC then you
have to do 10 such CoinJoins, costing 10 times the block space.
CoinSwap doesn't work by adding decoys, it improves privacy in the same
way as Lightning: by moving information off-chain.
You could perhaps analyze CoinSwap as using decoys if you say that the
decoys are almost every other bitcoin transaction happening on the
blockchain, and that can be almost as big as you want. One full block
has about 3000 outputs, so if you wait a day between the CoinSwap
funding and spending transactions then that's 144*3000 = 432000 decoys
(this calculation is simplified, but it's a good starting point). If
CoinJoin or Monero transactions had that many decoys they would be
hundreds of MB each.
Because CoinSwap transactions can look exactly the same as regular
transactions, they would improve the privacy of users even if they don't
use CoinSwap.
So on twitter sometimes I see people talking about "making every spend a
CoinJoin". The suggestion would be very costly in block space, and isn't
necessary for CoinSwap. I think perhaps 5% of transactions being
CoinSwaps or PayJoin-with-CoinSwap (as long as they were spread roughly
equally across the economy) would be enough to destroy the transaction
graph heuristic and common-input-ownership heuristic. Then anyone
analyzing the blockchain couldn't be sure when they see coins going from
address A to B that the ownership actually went from A to B, or that if
they see multiple inputs they don't know whether those inputs are
actually owned by the same entity.
Also, CoinSwaps could be used as payment. For example take this 1-hop
CoinSwap where Alice owns 10 BTC and wants to deposit 5 BTC into her
exchange account.
      (3 BTC) -->     (5 BTC) --> Exchange
Alice (1 BTC) --> Bob (4 BTC) --> Alice change1
      (6 BTC) -->     (1 BTC) --> Alice change2
So on the last hop Alice sends 5 BTC as payment to the exchange (to
deposit) and the remaining outputs go back to Alice as change. The
exchange can't see Alice's UTXOs that she just spent, and also can't see
Alice's change outputs.
Additionally, even in the example you use where 12 times as much block
space is used as normal, this is still cheaper than Equal-Output
Coinjoins. For example with JoinMarket a single CoinJoin is
approximately 12 times bigger than a regular bitcoin transaction, and to
get good privacy using JoinMarket's tumbler algorithm the user typically
creates 7-15 of those CoinJoins. And even then those CoinJoins are very
obvious and don't improve the privacy of people who don't use them,
meaning we have to advocate the expensive and impractical slogan "make
every spend a CoinJoin". And they also don't provide as much privacy as
CoinSwap would, because their anonymity set is smaller than CoinSwap's.
Finally, we know that blockchains don't scale, and so its widely
expected that most day-to-day bitcoin transactions will happen off-chain
on something like Lightning network, which also brings us privacy.
CoinSwap then is mostly useful for the situations where on-chain
transfers are still needed, and also because good on-chain privacy is
necessary for Lightning to really be private, because otherwise the
on-chain channel UTXOs can be tracked.

@_date: 2020-06-10 12:19:53
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Design for a CoinSwap implementation for 
Hello ZmnSCPxj,
Right, I get it. Good explanation.
In your swap-on-receive example the exchange also can't tell how long
your coins remain unspent in your wallet, which they could in
swap-on-pay. This is very useful information for an exchange because it
tells them about what hodlers are doing, and they might trade against
them. (e.g. opening big short positions right after they see many long
term hodl'd coins being moved)

@_date: 2020-06-10 18:49:16
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Question about PayJoin effectiveness 
Adding to what other people have written, it's an important point that
PayJoin breaks the common-input-ownership heuristic. I.E. if PayJoins
become even moderately popular then it will no longer be a safe
assumption that all the inputs to a transaction are owned by the same
entity (taking away all the obvious breaks like equal-output-coinjoins).
This assumption is a huge reason why blockchain surveillance is so
effective. A good paper on that is here:
 (The Unreasonable Effectiveness of
Address Clustering Harrigan, Martin & Fretter, Christoph. (2016))
The assumption is mentioned by Satoshi in the whitepaper where he
laments that the privacy loss is unavoidable. (One of the few outright
errors in the paper, perhaps the only error). The fact that we have
technology to break this assumption is a massive deal, and that's a big
value-add of PayJoin.

@_date: 2020-06-10 21:10:19
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Tainting, CoinJoin, PayJoin, CoinSwap 
Hello nopara73,
There are two concepts here: Taint analysis and the detectableness of
privacy protocols.
Taint analysis is quite an old technique, I remember seeing the
blockchain.info explorer having a tool for calculating a value for taint
back in 2013, long before any widely-used CoinJoin implementations were
created. I think taint was first created to attack the privacy technique
of simply sending coins to yourself multiple times. If those coins were
for example stolen from an exchange's hot wallet then the taint between
the exchange addresses and the later addresses would still be 100% even
if the thief sent the coins to himself multiple times.
A very important point is that it's difficult to reason about taint
analysis algorithms because they are often hypothetical, likely
closed-source, not available to the public for review and changing all
the time. OP talks about the three categories "clean", "dirty" and
"suspicious" which is one possibility. I've read about other taint
analysis algorithms which result in a numerical score out of 100.
Blockchain.info's algorithm calculated taint as a number expressing the
relation between any two addresses, so it wouldn't make sense to say "an
address" is tainted, instead you have to talk about a pair of addresses
being tainted with each other. So even though it's hard to reason about
the exact algorithm we can still talk about likely situations, and
imagine what an adversary could do in the worst case or best case.
One way to resist a likely taint analysis attack is to involve other
parts of the bitcoin economy in your transactions. For example our
exchange thief could deposit and then withdraw his stolen coins through
a Bitcoin Casino or other bitcoin service hot wallet. His coins might no
longer be 100% tainted from the exchange hack but perhaps have 5%
exchange hack, 5% bitcoin ATM, 5% mined coins, etc etc. The numbers are
made up and they depend on the exact algorithm but the main point is
that involving the rest of the bitcoin economy in your transaction is
one practical way to stop taint analysis being a useful attack against
on you.
Another important point is that taint isn't part of bitcoin's code
anywhere. It is an external reality that surveillance companies impose
on users. The only reason taint has any influence is because of
censorship, for example an exchange which uses the services of a
surveillance company has the power to freeze funds (i.e. censor a
transaction) if they believe the user's deposit transaction is tainted.
Therefore a way to resist the taint analysis attack is to actually use
bitcoin as money, I.E. earn bitcoin, spend it with merchants, who then
spend it with other merchants or pay their employees, where most
entities along those links actually dont use a taint analysis algorithm.
This is a general principle of bitcoin privacy by the way, if every
entry- and exit-point requires giving up personal information then
privacy is dead, regardless of whether we use
CoinJoin/PayJoin/CoinSwap/whatever in between.
This is a good place to again shill this list of peer-to-peer exchanges:
So that's taint.
Now for privacy protocols like CoinJoin. They also involve the rest of
the bitcoin economy, because many different users link their coins
together when using CoinJoin/PayJoin/CoinSwap/etc, so such protocols can
be a way to resist taint analysis too just like the Bitcoin Casino
mentioned earlier.
However, what I think OP is talking about is the case where taint
algorithms are reprogrammed to not just track exchange hack addresses,
but also track privacy protocol transactions. So for example if the
hypothetical taint algorithm comes across an Equal-Output CoinJoin it
will assign it a different taint score even if its not linked to an
exchange hack or anything like that.
Such a reprogramming wouldn't be possible in undetectable privacy
protocols like PayJoin and CoinSwap. They will have the economy-mixing
effect of reducing taint (just like the Bitcoin Casino example above),
but as OP writes that can just lead to the wrong person being under
suspicion. And so such protocols on their own cant resist taint analysis
forever, which is the point is OP making as well.
The only permanent solution to taint analysis as I've mentioned is to
use bitcoin as money, away from centralized choke points that can censor
transactions and demand personal information. It's worth pointing out
that using bitcoin as money wont help our exchange hacker much, this
hacker will never be able to buy mansions or sports cars with their
stolen bitcoin, because the authorities already require proof of the
origin of funds before, for example, buying a big mansion.
Nonetheless, unobservable privacy is also useful for other reasons than
resisting taint analysis:
* It improves the privacy of people who do not use it.
* It helps stops censorship of privacy protocols (I.E. miners could one
day refuse to mine equal-output CoinJoin transactions but still mine
regular transactions)
* It typically uses less block space, because information is removed
from the blockchain rather than adding to the blockchain.
Chris Belcher

@_date: 2020-06-13 14:38:35
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Hiding CoinSwap Makers Among Custodial Services 
Hello ZmnSCPxj,
Would it be fair to summarize the idea in this way:
CoinSwappers can slow down the CoinSwap process which will give an
opportunity for makers to use batching.

@_date: 2020-06-14 00:25:00
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Hiding CoinSwap Makers Among Custodial Services 
It's definitely a good idea. As well as improving privacy by pretending
to be a service provider which uses batching, it may also be practical
just because CoinSwap takers will want to slow down the process for
greater privacy so that an adversary would have to search more of the
blockchain to attempt to deanonymize them. Also, by being prepared to
wait longer the takers will also save miner fees.

@_date: 2020-05-03 20:28:23
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Fwd: (Semi)Traceless 2-party coinjoin off-chain 
Hello ZmnSCPxj,
Chain analysis doesn't in fact know that 1-input-1-output transfers are
self-transfers, this is merely a heuristic that can be flawed. For
example I accept donations in bitcoin and a surprising number of them
are 1-input-1-output or multi-input-1-output, presumably the donators
did it for privacy reasons or cost reasons. Also I believe many people
use 1-input-1-output transactions for funding Lightning channels.
Although even so, your argument suggests that its better for at least
some of the time for Alice and Bob to create 2-output transactions and
mess with the change output detection heuristics to try to get chain
analyzers to assign the wrong output as change.
If the receiving end doesn't have a suitable UTXO for a PayJoin then
they won't get the CoinSwap deal. The liquidity market is a free market,
takers are the maker's customers and they have a wide choice. In such a
case the maker would have been outcompeted by other makers which do have
extra UTXOs.
Your discussion with Alice having two UTXOs she doesn't want to co-spend
is definitely interesting. Perhaps also another way to solve is for
Alice to spend her UTXOs in 2-output transactions and mess with the
change output detection heuristics, say CoinSwapping 0.5 BTC from one
coin and 0.7 BTC from the other, with the total 1.2 BTC going to Carol.
Of course if Alice specified an amount when she was actually
self-mixing, it would be easy for her to come up with a random value
that was close to some round number, either in BTC or another currency.
Private key turnover is a great idea. It could also help with the
earlier problem of 1-input-1-output transactions being markers, because
when the coins in 2-of-2 multisigs are spent they may end up being spent
in a wider variety of ways.
It's very unlikely for the 2 BTC subset sum to be uncommon but 1.5 BTC
to be common, because they are very close in value, and these functions
seem to end up being smooth and slowly-varying, at least in my brief
tests. It might be a concern when comparing 2 BTC to 20 BTC or 200 BTC.

@_date: 2020-05-12 22:05:46
@_author: Chris Belcher 
@_subject: [bitcoin-dev] On the scalability issues of onboarding millions 
Hello Lloyd,
The problem comes when a large part of the ecosystem gets scammed at
once, which is how such an attack would happen in practice.
For example, consider if bitcoin had 10000 users. 10 of them use a full
node wallet while the other 9990 use an SPV wallet. If a miner attacked
the system by printing infinite bitcoins and spending coins without a
valid signature, then the 9990 SPV wallets would accept those fake coins
as payment, and trade the coins amongst themselves. After a time those
coins would likely be the ancestors of most active coins in the
9990-SPV-wallet ecosystem. Bitcoin would split into two currencies:
full-node-coin and SPV-coin.
Now the fraud miners may become well known, perhaps being published on
bitcoin news portals, but the 9990-SPV-wallet ecosystem has a strong
incentive to be against any rollback. Their recent transactions would
disappear and they'd lose money. They would argue that they've already
been using the coin for a while, and it works perfectly fine, and anyway
a coin that can be spent in 9990 places is more useful than one that can
be spent in just 10 places. The SPV-wallet community might even decide
to use something like `invalidateblock` to make sure their SPV-coin
doesn't get reorg'd out of existence. There'd also likely be a social
attack, with every bitcoin community portal being flooded with bots and
shills advocating the merits of SPV-coin. This is not a hypothetical
because we already saw the same thing during the scalability conflict
Before you know it, "Bitcoin" would become SPV-coin with inflation and
arbitrary seizure. Any normal user could download software called
"Bitcoin wallet" which they trust and have used before, but instead of
using Bitcoin they'd be using SPV-coin. You may be one of the 10 wallets
backed by a full node, but that won't do much good to you when 9990
users happily use another coin as their medium of exchange.

@_date: 2020-05-12 23:50:10
@_author: Chris Belcher 
@_subject: [bitcoin-dev] SAS: Succinct Atomic Swap 
Hello list,
This proposal is very cool. It is very useful to have a coinswap scheme
requiring only two transactions.
As well as improving the scalability of the system by saving block
space, it also improves privacy because the coins could stay unspend for
a long time, potentially indefinitely. While in the original coinswap
proposal an analyst of the chain would always see a funding transaction
followed closely in time by a success transaction, and this could be
used as a fingerprint.
You could create an old-style coinswap scheme using relative timelocks
(with OP_CSV). The original proposal uses absolute timelocks but there's
no reason relative timelocks can't be used instead, as long as the party
who starts with knowledge of the preimage has a timelock further away in
the future.
Using relative timelocks and private key handover for old-style
coinswaps would give us the same two-transaction effect and the
corresponding efficiency and privacy gains.
Of course we still don't get the effect that the swap on the other side
never expires.
A fun fact is that the idea of private key handover was mentioned as
early as 2016 in the original Lightning Network paper. The bottom of
page 27 says: "Instead  of disclosing the BR1a/BR1b signatures, it?s
also possible to just disclose the private keys to the counterparty.
This is more effective as described later in the key storage section".
Although it looks like nobody thought to apply it to coinswap or
realized the benefits.

@_date: 2020-05-25 14:21:21
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Design for a CoinSwap implementation for massively 
=== Abstract ===
Imagine a future where a user Alice has bitcoins and wants to send them
with maximal privacy, so she creates a special kind of transaction. For
anyone looking at the blockchain her transaction appears completely
normal with her coins seemingly going from address A to address B. But
in reality her coins end up in address Z which is entirely unconnected
to either A or B.
Now imagine another user, Carol, who isn't too bothered by privacy and
sends her bitcoin using a regular wallet which exists today. But because
Carol's transaction looks exactly the same as Alice's, anybody analyzing
the blockchain must now deal with the possibility that Carol's
transaction actually sent her coins to a totally unconnected address. So
Carol's privacy is improved even though she didn't change her behaviour,
and perhaps had never even heard of this software.
In a world where advertisers, social media and other companies want to
collect all of Alice's and Carol's data, such privacy improvement would
be incredibly valuable. And also the doubt added to every transaction
would greatly boost the fungibility of bitcoin and so make it a better
form of money.
This undetectable privacy can be developed today by implementing
CoinSwap, although by itself that isn't enough. There must be many
building blocks which together make a good system. The software could be
standalone as a kind of bitcoin mixing app, but it could also be a
library that existing wallets can implement allowing their users to send
Bitcoin transactions with much greater privacy.
== CoinSwap ==
Like CoinJoin, CoinSwap was invented in 2013 by Greg Maxwell[1]. Unlike
CoinJoin it is relatively complicated to implement and so far has not
been deployed. But the idea holds great promise, and fixes many of the
problems of some kinds of CoinJoins. CoinSwap is the next step for
on-chain bitcoin privacy.
CoinSwap is a way of trading one coin for another coin in a
non-custodial way. It is closely related to the idea of an atomic swap.
Alice and Bob can trade coins with each other by first sending to a
CoinSwap address and having those coins then sent to Bob:
    Alice's Address 1 ----> CoinSwap Address 1 ----> Bob's Address 1
An entirely separate set of transactions gives Bob's coins to Alice in
    Bob's Address 2 ----> CoinSwap Address 2 ----> Alice's Address 2
Where the symbol ----> is a bitcoin transaction.
Privacy is improved because an observer of the blockchain cannot link
Alice's Address 1 to Alice's Address 2, as there is no transaction
between them. Alice's Address 2 could either be an address in Alice's
wallet, or the address of someone else she wants to transfer money to.
CoinSwap therefore breaks the transaction graph heuristic, which is the
assumption that if a transaction A -> B is seen then the ownership of
funds actually went from A to B.
CoinSwap doesnt break any of bitcoin's assumptions or features like an
auditable supply or pruning. It can be built on today's bitcoin without
any new soft forks.
CoinSwap can't improve privacy much on its own, so it requires other
building block to create a truly private system.
=== ECDSA-2P ===
The original CoinSwap idea uses 2-of-2 multisig. We can get a slightly
bigger anonymity set by using 2-of-3 multisigs with a fake third public
key. For a much greater anonymity set we can use 2-party ECDSA to create
2-of-2 multisignature addresses that look the same as regular
single-signature addresses[2]. Even the old-style p2pkh addresses
starting with 1 can be CoinSwap addresses.
Because the transactions blend in with the rest of bitcoin, an
application based on CoinSwap would provide much more privacy than the
existing equal-output coinjoin apps (JoinMarket, Wasabi Wallet and
Samourai Wallet's Whirlpool). CoinSwaps would also be cheaper for the
same amount of privacy, as CoinJoin users usually create multiple
CoinJoins to get effective privacy, for example JoinMarket's tumbler
script does between 7-12 coinjoins (which are bigger than regular
transactions too) when run with default parameters.
Schnorr signatures with Musig provide a much easier way to create
invisible 2-of-2 multisig, but it is not as suitable for CoinSwap. This
is because the anonymity set for ECDSA would be much greater. All
addresses today are ECDSA, and none are schnorr. We'd have to wait for
schnorr to be added to bitcoin and then wait for users to adopt it. We
see with segwit that even after nearly 3 years that segwit adoption is
only about 60%, and segwit actually has a sizeable financial incentive
for adoption via lower fees. Schnorr when used for single-sig doesn't
have such an incentive, as Schnorr single-sig costs the same size as
today's p2wpkh, so we can expect adoption to be even slower. (Of course
there is an incentive for multisig transactions, but most transactions
are single-sig). As schnorr adoption increases this CoinSwap system
could start to use it, but for a long time I suspect it will mostly be
using ECDSA for a greater anonymity set.
=== Liquidity market ===
We can create a liquidity market for CoinSwap very similar to how
JoinMarket works for CoinJoins. In our example above Alice would be a
market taker and Bob would be a market maker. The taker Alice pays a fee
to the maker Bob in return for choosing the amount of a CoinSwap and
when it happens. This allows an excellent user experience because Alice
can create CoinSwaps for any size she wants, at any time she wants.
Right now in JoinMarket there is liquidity to create CoinJoins of sizes
up to about 200 BTC, and we can expect a similar kind of thing with
=== Multi-transaction CoinSwaps to avoid amount correlation ===
This CoinSwap is vulnerable to amount correlation:
    AliceA (15 BTC) ----> CoinSwap AddressA ----> BobA (15 BTC)
    BobB (15 BTC) ----> CoinSwap AddressB ----> AliceB (15 BTC)
Where AliceA, AliceB are addresses belonging to Alice. BobA, BobB are
addresses belonging to Bob. If an adversary starts tracking at address
AliceA they could unmix this CoinSwap easily by searching the entire
blockchain for other transactions with amounts close to 15 BTC, which
would lead them to address AliceB. We can beat this amount correlation
attack by creating multi-transaction CoinSwaps. For example:
    AliceA (15 BTC) ----> CoinSwap AddressA ----> BobA (15 BTC)
    BobB (7 BTC) ----> CoinSwap AddressB ----> AliceB (7 BTC)
    BobC (5 BTC) ----> CoinSwap AddressC ----> AliceC (5 BTC)
    BobD (3 BTC) ----> CoinSwap AddressD ----> AliceD (3 BTC)
Now in the multi-transaction CoinSwap, the market taker Alice has given
10 BTC and got back three transactions which add up to the same amount,
but nowhere on the blockchain is there an output where Alice received
exactly 15 BTC.
=== Routing CoinSwaps to avoid a single points of trust ===
In the original CoinSwap idea there are only two parties Alice and Bob,
so when they CoinSwap Bob will know exactly where the Alice's coins
went. This means Bob is a single point of failure in Alice's privacy,
and Alice must trust him not to spy on her.
To spread out and decentralize the trust, we can create CoinSwaps where
Alice's payment is routed through many Bobs.
    AliceA ====> Bob ====> Charlie ====> Dennis ====> AliceB
Where the symbol ====> means one CoinSwap. In this situation Alice will
be a market taker in the liquidity market, and all the other entities
(Bob, Charlie, Dennis) will be market makers. Only Alice will know the
entire route, and the makers will only know the previous and next
bitcoin addresses along the route.
This could be made to work by Alice handling almost everything about the
CoinSwap on the other maker's behalf. The makers wouldn't have TCP
connections between each other, but only to Alice, and she would relay
CoinSwap-relevant information between them. The other makers are not
aware whether their incoming coins came from Alice herself or the
previous maker in Alice's route.
=== Combining multi-transaction with routing ===
Routing and multi-transaction must be combined to get both benefits. If
Alice owns multiple UTXOs (of value 6 BTC, 8 BTC and 1 BTC) then this is
easy with this configuration:
             Alice
    (6 BTC) (8 BTC) (1 BTC)
       |       |
       |       |
       v       v       v
              Bob
    (5 BTC) (5 BTC) (5 BTC)
       |       |
       |       |
       v       v       v
            Charlie
    (9 BTC) (5 BTC) (1 BTC)
       |       |
       |       |
       v       v       v
            Dennis
    (7 BTC) (4 BTC) (4 BTC)
       |       |
       |       |
       v       v       v
             Alice
Where the downward arrow symbol is a single CoinSwap hash-time-locked
contract. Each hop uses multiple transactions so no maker (Bob, Charlie,
Dennis) is able to use amount correlation to find addresses not directly
related to them, but at each hop the total value adds up to the same
amount 15 BTC. And all 3 makers must collude in order to track the
source and destination of the bitcoins.
If Alice starts with only a single UTXO then the above configuration is
still vulnerable to amount correlation. One of the later makers (e.g.
Dennis) knows that the total coinswap amount is 15 BTC, and could search
the blockchain to find Alice's single UTXO. In such a situation Alice
must use a branching configuration:
                          Alice
                         (15 BTC)
                            v
                           Bob
                          /   \
                         /     \
             <-----------       ----------->
                             |
  (2 BTC) (2 BTC) (2 BTC)        (3 BTC) (3 BTC) (3 BTC)
                             |
                             |
             v                             v
          Charlie                       Dennis
  (1 BTC) (2 BTC) (3 BTC)       (5 BTC) (3 BTC) (1 BTC)
       |       |             |       |       |
       |       |             |       |       |
     v       v       v             v       v       v
          Edward                          Fred
  (4 BTC) (1 BTC) (1 BTC)       (4 BTC) (2 BTC) (1 BTC)
       |       |             |       |       |
       |       |             |       |       |
     v       v       v             v       v       v
           Alice                         Alice
In this diagram, Alice sends 15 BTC to Bob via CoinSwap who sends 6 BTC
on to Charlie and the remaining 9 BTC to Dennis. Charlie and Dennis do a
CoinSwap with Edward and Fred who forward the coins to Alice. None of
the makers except Bob know the full 15 BTC amount and so can't search
the blockchain backwards for Alice's initial UTXO. Because of multiple
transactions Bob cannot look forward to search for the amounts he sent 6
BTC and 9 BTC. A minimum of 3 makers in this example need to collude to
know the source and destination of the coins.
Another configuration is branch merging, which Alice would find useful
if she has two or more UTXOs for which there must not be evidence that
they're owned by the same entity, and so they must not be spent together
in the same transaction.
           Alice                         Alice
          (9 BTC)                       (6 BTC)
                             |
                             |
             v                             v
            Bob                         Charlie
  (4 BTC) (3 BTC) (2 BTC)       (1 BTC) (2 BTC) (3 BTC)
       |       |             |       |       |
       |       |             |       |       |
      \       \       \           /       /       /
       \       \       \         /       /       /
        \       \       \       /       /       /
         >------->-------\     /-------<-------<
                          \   /
                          Alice
                         (15 BTC)
In this diagram Alice sends the two UTXOs (9 BTC and 6 BTC) to two
different makers, who forward it onto Alice. Because the two UTXOs have
been transferred to different makers they will likely never be co-spent.
These complex multi-transaction routed coinswaps are only for the
highest threat models where the makers themselves are adversaries. In
practice most users would probably choose to use just one or two hops.
=== Breaking change output and wallet fingerprinting heuristics ===
Equal-output CoinJoins easily leak change addresses (unless they are
sweeps with no change). CoinSwap doesn't have this flaw which allows us
to break some of the weaker change output heuristics[3].
For example address reuse. If an output address has been reused it is
very likely to be a payment output, not a change output. In a CoinSwap
application we can break this heuristic by having makers randomly with
some probability send their change to an address they've used before.
That will make the heuristics think that the real change address is
actually the payment address, and the real payment is actually the
change, and could result in an analyzer of the blockchain grouping the
payment address inside the maker's own wallet cluster.
Another great heuristic to break is the script type heuristic. If the
maker's input are all in p2sh-p2wpkh addresses, and their payment
address is also of type p2sh-p2wpkh, then the maker could with some
probability set the change address to a different type such as p2wpkh.
This could trick a chain analyzer in a similar way.
=== Fidelity bonds ===
Anybody can enter the CoinSwap market as a maker, so there is a danger
of sybil attacks. This is when an adversary deploys huge numbers of
maker bots. If the taker Alice chooses maker bots which are all
controlled by the same person then that person can deanonymize Alice's
transaction by tracking the coins along the route.
A solution to this is fidelity bonds. This is a mechanism where bitcoin
value is deliberately sacrificed to make a cryptographic identity
expensive to obtain. The sacrifice is done in a way that can be proven
to a third party. One way to create a fidelity bond is to lock up
bitcoins in a time-locked address. We can code the taker bots to behave
in a way that creates market pressure for maker bot operators to publish
fidelity bonds. These fidelity bonds can be created anonymously by
anyone who owns bitcoin.
Fidelity bonds are a genuine sacrifice which can't be faked, they can be
compared to proof-of-work which backs bitcoin mining. Then for a sybil
attacker to be successful they would have to lock up a huge value in
bitcoin for a long time. I've previously analyzed fidelity bonds for
JoinMarket[4], and using realistic numbers I calculate that such a
system would require about 55000 BTC (around 500 million USD at today's
price) to be locked up for 6 months in time-locked addresses. This is a
huge amount and provides strong sybil resistance.
==== Who goes first ====
Fidelity bonds also solve the "who goes first" problem in CoinSwap.
This problem happens because either Alice or Bob must broadcast their
funding transaction first, but if the other side halts the protocol then
they can cause Alice or Bob's to waste time and miner fees as they're
forced to use the contract transactions to get their money back. This is
a DOS attack. If a malicious CoinSwapper could keep halting the protocol
they could stop an honest user from doing a CoinSwap indefinitely.
Fidelity bonds solve this by having the fidelity bond holder go second.
If the fidelity bond holder halts the protocol then their fidelity bond
can be avoid by the user in all later CoinSwaps. And the malicious
CoinSwapper could pack the orderbook with their sybils without
sacrificing a lot of value for fidelity bonds.
As a concrete example, Alice is a taker and Bob is a maker. Bob
publishes a fidelity bond. Alice "goes first" by sending her coins into
a 2-of-2 multisig between her and Bob. When Bob sees the transaction is
confirmed he broadcasts his own transactions into another 2-of-2
multisig. If Bob is actually malicious and halts the protocol then he
will cost Alice some time and money, but Alice will refuse to ever
CoinSwap with Bob's fidelity bond again.
If DOS becomes a big problem even with fidelity bonds, then its possible
to have Alice request a "DOS proof" from Bob before broadcasting, which
is a set of data containing transactions, merkle proofs and signatures
which are a contract where Bob promises to broadcast his own transaction
if Alice does so first. If Alice gets DOSed then she can share this DOS
proof publicly. The proof will have enough information to convince
anyone else that the DOS really happened, and it means that nobody else
will ever CoinSwap with Bob's fidelity bond either (or at least assign
some kind of ban score to lower the probability). I doubt it will come
to this so I haven't expanded the idea much, but theres a longer writeup
in the reference[5].
=== Private key handover ===
The original proposal for CoinSwap involved four transactions. Two to
pay into the multisig addresses and two to pay out. We can do better
than this with private key handover[6]. This is an observation that once
the CoinSwap preimage is revealed, Alice and Bob don't have to sign each
other's multisig spend, instead they could hand over their private key
to the other party. The other party will know both keys of the 2-of-2
multisig and therefore have unilateral control of the coins. Although
they would still need to watch the chain and respond in case a
hash-time-locked contract transaction is broadcasted.
As well as saving block space, it also improves privacy because the
coins could stay unspent for a long time, potentially indefinitely.
While in the original coinswap proposal an analyst of the chain would
always see a funding transaction followed closely in time by a
settlement transaction, and this could be used as a fingerprint.
We can go even further than private key handover using a scheme called
SAS: Succinct Atomic Swap[7]. This scheme uses adapter signatures[8] to
create a similar outcome to CoinSwap-with-private-key-handover, but only
one party in the CoinSwap must watch and respond to blockchain events
until they spend the coin. The other party just gets unilateral control
of their coins without needing to watch and respond.
=== PayJoin with CoinSwap ===
CoinSwap can be combined with CoinJoin. In original CoinSwap, Alice
might pay into a CoinSwap address with a regular transaction spending
multiple of her own inputs:
    AliceInputA (1 BTC) ----> CoinSwap Address (3 BTC)
    AliceInputB (2 BTC)
This leaks information that all of those inputs are owned by the same
person. We can make this example transaction a CoinJoin by involving
Bob's inputs too. CoinJoin requires interaction but because Alice and
Bob are already interacting to follow the CoinSwap protocol, so it's not
too hard to have them interact a bit more to do a CoinJoin too. The
CoinJoin transaction which funds the CoinSwap address would look like this:
    AliceInputA (1 BTC) ----> CoinSwap Address (7 BTC)
    AliceInputB (2 BTC)
    BobInputA   (4 BTC)
Alice's and Bob's inputs are both spent in a same transaction, which
breaks the common-input-ownership heuristic. This form of CoinJoin is
most similar to the PayJoin protocol or CoinJoinXT protocol. As with the
rest of this design, this protocol does not have any special patterns
and so is indistinguishable from any regular bitcoin transaction.
To make this work Bob the maker needs to provide two unrelated UTXOs,
one that is CoinSwapped and the other CoinJoined.
==== Using decoy UTXOs to protecting from leaks ====
If Bob the maker was just handing out inputs for CoinJoins to any Alice
who asked, then malicious Alice's could constantly poll Bob to learn his
UTXO and then halt the protocol. Malicious Alice could learn all of
Bob's UTXOs and easily unmix future CoinSwaps by watching their future
To defend against this attack we have Bob maintain a list of "decoy
UTXOs", which are UTXOs that Bob found by scanning recent blocks. Then
when creating the CoinJoin, Bob doesn't just send his own input but
sends perhaps 50 or 100 other inputs which don't belong to him. For the
protocol to continue Alice must partially-sign many CoinJoin
transactions; one for each of those inputs, and send them back to Bob.
Then Bob can sign the transaction which contains his genuine input and
broadcast it. If Alice is actually a malicious spy she won't learn Bob's
input for sure but will only know 100 other inputs, the majority of
which have nothing to do with Bob. By the time malicious Alice learns
Bob's true UTXO its already too late because its been spent and Alice is
locked into the CoinSwap protocol, requiring time, miner fees and
CoinSwap fees to get out.
This method of decoy UTXOs has already been written about in the
original PayJoin designs from 2018[9][10].
=== Creating a communication network using federated message boards ===
Right now JoinMarket uses public IRC networks for communication. This is
subpar for a number of reasons, and we can do better.
I propose that there be a small number of volunteer-operated HTTP
servers run on Tor hidden services. Their URLs are included in the
CoinSwap software by default. They can be called message board servers.
Makers are also servers run on hidden services, and to advertise
themselves they connect to these message board servers to post the
makers own .onion address. To protect from spam, makers must provide a
fidelity bond before being allowed to write to the HTTP server.
Takers connect to all these HTTP message boards and download the list of
all known maker .onion addresses. They connect to each maker's onion to
obtain parameters like offered coinswap fee and maximum coinswap size.
This is equivalent to downloading the orderbook on JoinMarket. Once
takers have chosen which makers they'll do a CoinSwap with, they
communicate with those maker again directly through their .onion address
to transmit the data needed to create CoinSwaps.
These HTTP message board servers can be run quite cheaply, which is
required as they'd be volunteer run. They shouldn't require much
bandwidth or disk space, as they are well-protected from spam with the
fidelity bond requirement. The system can also tolerate temporary
downtimes so the servers don't need to be too reliable either. It's easy
to imagine the volunteers running them on a raspberry pi in their own
home. These message board servers are similar in some ways to the DNS
seeds used by Bitcoin Core to find its first peers on bitcoin's p2p
network. If the volunteers ever lose interest or disappear, then the
community of users could find new volunteer operators and add those URLs
to the default list.
In order to censor a maker, _all_ the message board servers would have
to co-operate to censor him. If censorship is happening on a large scale
(for example if the message board servers only display sybil makers run
by themselves) then takers could also notice a drop in the total value
of all fidelity bonds.
== How are CoinSwap and Lightning Network different? ==
CoinSwap and Lightning Network have many similarities, so it's natural
to ask why are they different, and why do we need a CoinSwap system at
all if we already have Lightning?
=== CoinSwap can be adopted unilaterally and is on-chain ===
Today we see some centralized exchange not supporting so-called
``privacy altcoins'' because of regulatory compliance concerns. We also
see some exchanges frowning upon or blocking CoinJoin transaction they
detect[11]. (There is some debate over whether the exchanges really
blocked transactions because they were CoinJoin, but the principle
remains that equal-output CoinJoins are inherently visible as such).
It's possible that those exchanges will never adopt Lightning because of
its privacy features.
Such a refusal would simply not be possible with CoinSwap, because it is
fundamentally an on-chain technology. CoinSwap users pay to bitcoin
addresses, not Lightning invoices. Anybody who accepts bitcoin today
will accept CoinSwap. And because CoinSwap transactions can be made
indistinguishable from regular transactions, it would be very difficult
to even determine whether they got paid via a CoinSwap or not. So
CoinSwap is not a replacement for Lightning, instead it is a replacement
for on-chain privacy technology such as equal-output CoinJoins which are
implemented today in JoinMarket, Wasabi Wallet and Samourai Wallet.
Ideally this design, if implemented, would be possible to include into
the many already-existing bitcoin wallets, and so the CoinSwaps would be
accessible to everyone.
This feature of CoinSwap will in turn help Lightning Network, because
those censoring exchanges won't be able to stop transactions with
undetectable privacy no matter what they do. When they realize this
they'll likely just implement Lightning Network anyway regardless of the
Bitcoin needs on-chain privacy as well, otherwise the bad privacy can
leak into layer-2 solutions.
=== Different ways of solving liquidity ===
Lightning Network cannot support large payment amounts. Liquidity in
payment channels on the Lightning network is a scarce resource. Nodes
which relay lightning payments always take care that a payment does not
exhaust their liquidity. Users of Lightning today must often be aware of
inbound liquidity, outbound liquidity and channel rebalancing. There
even exist services today which sell Lightning liquidity.
This CoinSwap design solves its liquidity problem in a completely
different way. Because of the liquidity market similar to JoinMarket,
all the required liquidity is always available. There are never any
concerns about exhausting channel capacity or a route not being found,
because such liquidity is simply purchased from the liquidity market
right before it is used.
It is still early days for Lightning, and liquidity has been a known
issue since the start. Many people are confident that the liquidity
issue will be improved. Yet it seems hard to imagine that Lightning
Network will ever reliably route payments of 200 BTC to any node in the
network (and it doesn't have to to be successful), yet on JoinMarket
today as I write these words there are offers to create CoinJoins with
amounts up to around 200 BTC. We can expect similar large amounts to be
sendable in CoinSwap. The liquidity market as a solution is known to
work and has been working for years.
=== Sybil resistance ===
CoinSwap can support fidelity bonds and so can be made much more
resistant to sybil attacks. We saw in the earlier section that realistic
numbers from JoinMarket imply a sybil attacker would have to lock up
hundreds of millions of USD worth of bitcoin to successfully deanonymize
It's difficult to compare this to the cost of a sybil attack in
Lightning network as such attacks are hard to analyze. For example, the
attacker needs to convince users to route payments through the
attacker's own nodes, and maybe they could do this, but putting numbers
on it is hard. Even so it is very likely that the true cost is much less
than 500 million USD locked up for months because Lightning nodes can be
set up for not more than the cost of hardware and payment channel
capacity, while CoinSwap makers would require expensive fidelity bond
As this CoinSwap design would cost much more sybil attack, its privacy
would be much greater in this respect.
== How are CoinSwap, PayJoin and PaySwap different? ==
PayJoin can also be indistinguishable from regular bitcoin transaction,
so why don't we all just that and not go further?
The answer is the threat models. PayJoin works by having the customer
and merchant together co-operate to increase both their privacy. It
works if the adversary of both of them is a passive observer of the
PayJoin doesnt help a customer at all if the user's adversary is the
merchant. This situation happens all the time today, for example
exchanges spying on their customers. CoinSwap can help in this
situation, as it doesn't assume or require that the second party is your
friend. The same argument applies to PaySwap.
Obviously PayJoin and PaySwap are still very useful, but they operate
under different threat models.
== Conclusion ==
CoinSwap is a promising privacy protocol because it breaks the
transaction graph heuristic, but it cant work on its own. In order to
create a truly private system of sending transactions which would
improve bitcoin's fungibility, CoinSwap must be combined with a couple
of other building blocks:
* ECDSA-2P
* Liquidity market
* Routed CoinSwaps
* Multi-transaction CoinSwaps
* Breaking change output heuristics
* Fidelity bonds
* PayJoin with CoinSwap
* Federated message boards protected from spam with fidelity bonds
CoinSwap transactions could be made to look just like any other regular
bitcoin transaction, with no distinguishing fingerprint. This would make
them invisible.
I intend to create this CoinSwap software. It will be almost completely
decentralized and available for all to use for free. The design is
published here for review. If you want to help support development I
accept donations at == References ==
- [1] "CoinSwap: Transaction graph disjoint trustless trading"
- [2]
- [3] - [4] "Design for improving JoinMarket's resistance to sybil attacks
using fidelity bonds"
- [5] - [6] - [7]
- [8]
- [9]
- [10] - [11]

@_date: 2020-10-03 11:36:22
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Detailed protocol design for routed 
Hello list,
This email is an appendium or modification of the earlier CoinSwap
protocol published on this list. It is intended to fix the problems
found in review. (Original email quoted here too)
== Miner fees ==
RBF is used on contract transactions as before, so each contract
transaction actually has many different versions each with a different
miner fee.
A possible vulnerability of using RBF is transaction pinning (see
 We solve this
issue by encumbering hashlock outputs with `1 OP_CSV`, so that it is not
possible to do CPFP on a contract transaction.
Another possible vulnerability (called post-coinswap-fee-burning) is
that after a successful CoinSwap, the party which no longer controls the
coins can still broadcast a high-fee RBF contract transaction in order
to burn coins to miner fees. This might be used by a malicious taker to
waste away the balance of a maker (the malicious taker might be another
maker who in the liquidity market is in competition with the victim
maker, and is using this exploit to attack their competitor).
=== Collateral payments ===
The post-coinswap-theft-attempt is an attack done after a CoinSwap is
finished. It works by the sender broadcasting their contract transaction
of the coins which no longer belong to him, they hope that the timeout
will expire and that they can sweep the coins. Their theft attempt is
very unlikely to actually succeed because of multiple redundant
watchtowers who will immediately spend the coins with the hashlock
branch, but the thief still might try because the attempt is essentially
riskless and costless.
Collateral payments are used to avoid this problem by making the theft
attempt not costless. (Although the cost is best kept very small,
corresponding to the risk of success being very low). (see
Post-coinswap-theft-attempts are already not costless for the taker,
because broadcasting the contract transactions damages privacy, which
the taker by construction wants to improve and has actually already paid
for. Privacy is reduced either by revealing the contract on-chain or by
reducing anonymity sets by having the coins spent immediately or very
soon). Therefore takers dont require collateral payments in this
protocol and this allows a taker to fully-spend their entire wallet in
one set of CoinSwaps (i.e. a sweep transaction with no change).
Collateral payments also solve the vulnerability of
post-coinswap-fee-burning for maker-maker CoinSwaps, because the miner
fee is taken from the collateral input and single-sig change, and not
from the CoinSwap contract.
==== Post-CoinSwap-fee-burning for takers ====
Collateral payments stop the post-coinswap-fee-burning attack but only
for makers, as takers dont use collateral payments.
However takers are unique in the way that takers pay CoinSwap fees. So
for a taker to attack a maker via post-coinswap-fee-burning they first
need to pay CoinSwap fees. So we just have makers refuse to sign RBF
transactions paying a fee higher than the CoinSwap fee they earn. (Or
perhaps a constant factor, for example a maker imposes the condition
that the RBF miner fee can only be 5x or 10x the CoinSwap fee).
== Funding transaction definitions ==
Same as in the v1 design doc.
== Contract transaction definitions ==
In the v1 design each party in a CoinSwap possessed the _same_ contract
transaction. This is no longer the case, and each party might know
slightly different versions, perhaps differing by miner fees or whether
a collateral payment is used.
As before the value in square parentheses refers to bitcoin amount. The
value in the round parentheses refers to script.
Contract transactions have this notation based on who knows them:
    contract tx for the Alice-Bob multisig, known only to Alice
  = contract tx Alice-Bob/Alice
  = contract tx AB/A
=== Contract txes known by receiver ===
These are contract transactions known by the receiver of coins from the
multisig. They are pretty much the same as in v1, except with added `1
OP_CSV` to the hashlock (not included here for clarity).
Alice-Bob/Bob contract tx:
    multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)
    [I btc]                   [I-M~ btc]
Bob-Charlie/Charlie contract tx:
    multisig (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)
    [I-M2-B btc]                [I-M2-B-M~ btc]
Charlie-Alice/Alice contract tx:
    multisig (Charlie+Alice) ---> (Charlie+timelock_C OR Alice+hash)
    [(I-M2-B)-M3-C btc]           [(I-M2-B)-M3-C-M~ btc]
=== Table of balances before and after a coinswap resolved with contract
txes known to recievers ===
If a CoinSwap is resolved with contract txes known to receivers, then
that means the parties had to get their money back by broadcasting and
mining the contract transactions, and spending the output using their
knowledge of the hash preimage. Each party has to spend the output
before the timeout expires, so that costs an additional miner fee M~.
Party   | Before | After
Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C-M~ - M~ = WA-M1-M2-M3-B-C-2M~
Bob     | WB     | WB-I+B + I-M~ - M~              = WB+B-2M~
Charlie | WC     | WC-(I-M2-B)+C + I-M2-B-M~ - M~  = WC+C-2M~
The makers earn their CoinSwap fees but pay an additional miner fee
twice, so they are incentivized to avoid this outcome compared to the
success case where they just earn their fees. Alice is incentivized to
avoid this outcome because she would pay for miner fees and coinswap
fees, and not get any privacy in return.
=== Contract txes known by the sender ===
The maker's contract transaction must include a collateral payment.
    Jb, Jc = value of a maker's (Bob, Charlie) collateral input
    K = collateral amount, which a maker loses if he broadcasts his
contract tx but doesnt get the money using the hash preimage
Alice-Bob/Alice contract tx:
    multisig (Alice+Bob) ---> (Alice+timelock_A OR Bob+hash)
             [I btc]          [I-M~ btc]
Bob-Charlie/Bob contract tx:
    multisig  (Bob+Charlie) ---> (Bob+timelock_B OR Charlie+hash)
              [I-M2-B btc]       [I-M2-B+K btc]
    singlesig (Bob)              (Bob)
              [Jb btc]           [Jb-K-M~ btc]
Charlie-Alice/Charlie contract tx:
    multisig  (Charlie+Alice)     ---> (Charlie+timelockC OR Alice+hash)
              [(I-M2-B)-M3-C btc]      [(I-M2-B)-M3-C+K btc]
    singlesig (Charlie)                (Charlie)
              [Jc btc]                 [Jc-K-M~ btc]
=== Table of balances before and after a coinswap resolved with contract
txes known to senders ===
If a coinswap is resolved with contract txes known to senders, then that
means the parties had to get their money back by broadcasting and mining
the contract transactions, and spending the output by waiting for the
Party   |Before | After
Alice   | WA    |WA-M1-I + I-M~                            = WA-M1-M~
Bob     | WB+Jb |WB-I+B + I-M2-B+K + Jb-K-M~               = WB+Jb-M2-M~
Charlie | WC+Jc |WC-(I-M2-B)+C + (I-M2-B)-M3-C+K + Jc-K-M~ = WC+Jc-M3-M~
Everyone gets their money back and pays for their own miner fees. And
the CoinSwap didn't happen, which is crappy considering money was lost
in miner fees but part of the point of fidelity bonds is to stop this
happening too much.
=== Table of balances before and after a successful CoinSwap but with
one post-CoinSwap-theft-attempt ===
Here the CoinSwap has succeeded but one maker (Bob in this case) does a
post-coinswap-theft-attempt, which fails, because the next party
(Charlie) uses the hash preimage to spend the coins. Most coins can
remain unspent on-chain because of private-key-handover, but the
Bob-Charlie/Bob contract transaction was broadcast and mined.
Party   | Before | After
Alice   | WA     | WA-M1-I + (I-M2-B)-M3-C  = WA-M1-M2-M3-B-C
Bob     | WB+Jb  | WB-I+B + Jb-K-M~ + I     = WB+Jb+B-K-M~
Charlie | WC     | WC-(I-M2-B)+C + I-M2-B+K = WC+C+K
As we see, Alice's outcome is the same as in the success case. Compared
to the success case, Bob loses K bitcoins and an extra miner fee while
Charlie gains K bitcoins.
Looking at these equations, I realize that the incentives against
post-coinswap-theft-attempt still work even if we set K = 0, because the
extra miner fee paid by Bob could be enough disincentive.
== Protocol ==
    A fund = Alice's funding tx
    AB/A us htlc = unsigned contract tx for the A-B multisig, where the
        fully-signed version is only meant to be known by A
    AB/A htlc B/2 = Bob's signature for contract tx for the A-B
        multisig, where the fully-signed version is only meant to be
        known by A
    p = nonce point p used in the tweak EC protocol for calculating the
        maker's pubkey, used to avoid one round trip
    privA(A+B) = private key generated by Alice in the A-B multisig
 Alice           | Bob             | Charlie         |
0.  AB/A us htlc ---->               |                 |
1.               <---- AB/A htlc B/2 |                 |
2.    ***** BROADCAST AND MINE ALICE FUNDING TX *****  |
3.    A fund + p ---->               |                 |
4.               <---- AB/B us htlc  |                 |
5. AB/B htlc A/2 ---->               |                 |
6.                 |  BC/B us htlc ---->               |
7.                 |               <---- BC/B htlc C/2 |
8.    ***** BROADCAST AND MINE BOB FUNDING TX *****    |
9.                 |    B fund + p ---->               |
A.                 |               <---- BC/C us htlc  |
B.                 | BC/C htlc B/2 ---->               |
C.               <---------------------- CA/C us htlc  |
D. CA/C htlc A/2 ---------------------->               |
E.   ***** BROADCAST AND MINE CHARLIE FUNDING TX ***** |
F.               <---------------------- C fund + p    |
G.  CA/A us htlc ---------------------->               |
H.               <---------------------- CA/A htlc C/2 |
I. hash preimage ---------------------->               |
J. hash preimage ---->               |                 |
K.    privA(A+B) ---->               |                 |
L.                 |    privB(B+C) ---->               |
M.               <---------------------- privC(C+A)    |
=== Protocol notes ===
0-2. Alice sets up her funding tx and contract tx for possible refund
     with timeout
3.   Alice convinces Bob that their multisig is funded, and therefore
     this whole thing isnt a DOS
4-5. Bob obtains his contract tx for the A-B multisig
6-8. Same as 0-2 but for Bob
9.   Same as 3. but for Bob/Charlie
A-B. Same as 4-5 but for Charlie
C-E. Same as 0-2 and 6-8 but for Charlie
F.   Same as 3 and 9 but for Charlie/Alice
G-H. Same as 4-5 or A-B but for Alice
H.   After this step every party's coins are locked up in multisig, and
     they can all get the coins back after the timeout, or if they know
     the hash preimage they can get different coins immediately.
I-J. Reveal preimages to everyone, making the coins do an off-chain hop
     ahead by one step.
K-M. Reveal private keys to each other. The incentive to do this is to
     save on miner fees, and improve privacy.
=== Analysis of aborts ===
Aborts are when one party halts the protocol (i.e. they had a power cut,
or they are a DOS attacker). Here we analyze how the other parties react.
As in v1, the number refers to the step number where the abort happened.
0. Alice: aborts. Bob/Charlie: do nothing, they havent lost any time or
   money.
1. Bob: aborts. Alice: lost no time or money, try with another Bob.
   Charlie: do nothing
2-3. Same as 0.
4. Bob: aborts. Charlie: do nothing. Alice: broadcasts contract tx AB/A
   and waits for the timeout, loses time and money on miner fees, she'll
   never coinswap with Bob's fidelity bond again.
5. Same as 0.
6. Same as 4.
7. Charlie: aborts. Alice/Bob: lose nothing, find another Charlie to
   coinswap with.
8. Same as 4.
9. Similar to 4 but Alice MIGHT not blacklist Bob's fidelity bond,
   because Bob will also have to broadcast his contract tx BC/B and will
   also lose time and money. Alice could take Bob's collateral from
   transaction BC/B, but the value K is small and Alice must spend time
   and miner fees on her funding transaction, so this isn't a way to DOS
   for free.
A. Charlie: aborts. Bob: broadcast his contract tx BC/B and wait for the
   timeout to get his money back, also broadcast Alice's contract
   transaction AB/B in retaliation. Alice: waits for the timeout on her
   contract tx that Bob broadcasted, will never do a coinswap with
   Charlie's fidelity bond again.
B. Same as 9.
C. Same as A.
D. Alice: aborts. Charlie: do nothing, no money or time lost. Bob:
   broadcast BC/B contract tx and wait for timeout to get money back,
   comforted by the knowledge that when Alice comes back online she'll
   have to do the same thing and waste the same amount of time and
   money.
E. Same as A.
F. Similar to A. but Alice MIGHT not blacklist Charlie's fidelity bond,
   because Charlie will also have to broadcast his contract tx CA/C and
   will also lose time and money.
G. Alice: aborts. Bob/Charlie: all broadcast their contract txes and
   wait for the timeout to get their money back.
H. Same as F.
I-K. Similar to G, but if Charlie knows the hash preimage he can use his
     contract tx to get the money immediately instead of waiting for the
     timeout. Bob can read that preimage from the blockchain and use it
     to also get his money immediately.
L. Bob: aborts. Alice: hopefully get Charlie's privkey, but if not then
   broadcast CA/A and use preimage to get money immediately, and never
   coinswap with Bob's fidelity bond again. Charlie: broadcast BC/C and
   use preimage to get money immediately.
M. Charlie: aborts. Alice: broadcast CA/A and use preimage to get money
   immediately, and never coinswap with Charlie's fidelity bond again.
   Bob: do nothing, already has Alice's privkey.
== Analysis of deviations ==
Deviations are when one party does something other than what's in the
protocol, for example broadcasting a contract transaction when they
shouldnt have.
The party name refers to what that party does, followed by other party's
reactions to it.
e.g. Party1: does a thing, Party2/Party3: does a thing in reaction.
If multiple deviations are possible in a step then they are numbered.
e.g. 5(1) 5(2) 5(3)
0-2. Alice/Bob/Charlie: nothing else is possible except following the
     or aborting.
3. Alice: broadcasts one or more of the AB/A contract txes. Bob/Charlie:
   do nothing, they havent lost any time or money.
4. Bob/Charlie: nothing else is possible except following the protocol
   or aborting.
5. Same as 3.
6. Bob: broadcasts one or more of the AB/B contract txes. Alice:
   broadcasts the remaining contract txes and waits for the timeout to
   get her money back, and never coinswaps with Bob's fidelity bond
   again. Charlie: do nothing.
7. Charlie: nothing else is possible except following the protocol or
   aborting.
8. Same as 6.
9(1). Same as 6.
9(2). Bob: broadcast BC/B contract txes. Alice: broadcast her AB/A
      contract tx and wait for the timeout to get her money back, and
      never coinswaps with Bob's fidelity bond again. Charlie: do
      nothing.
A. Charlie: broadcast BC/C contract tx. Bob: wait for the timeout to get
   his money back, also broadcast Alice's contract transaction AB/B in
   retaliation. Alice: waits for the timeout on her contract tx that Bob
   broadcasted, will never do a coinswap with Charlie's fidelity bond
   again.
B. Same as 9(1). and 9(2).
C. Same as A.
D. Alice: broadcast AB/A contract tx. Bob: broadcast his own BC/B
   contract tx and wait for the timeout to get his money back. Charlie:
   do nothing
E. Same as A.
F. Charlie: broadcast CA/C contract tx. Alice: broadcast her AB/A
   contract tx and wait for the timeout to get her money back, never do
   a coinswap with Charlie's fidelity bond again. Bob: broadcast his
   BC/B contract tx and wait for the timeout to get his money back.
G. Same as D. except Charlie must also broadcast his CA/C contract tx
   and wait for the timeout.
H. Same as F.
I-K(1). Alice: broadcast AB/A contract txes. Bob: broadcast BC/B
        contract txes and wait for the timeout, or use the hash preimage
        if he knows it. Charlie: broadcast CA/A contract txes and wait
        for timeout, or use hash preimage if known.
I-K(2). Alice: broadcast CA/A contract txes. Bob: broadcast AB/B and
        wait for the timeout, or use the hash preimage if its known.
        Charlie: broadcast BC/C and wait for timeout, or use the hash
        preimage if known.
I-K(3). Alice: broadcast both AB/A and CA/A contract txes. Bob:
        broadcast BC/B contract tx and wait for the timeout, or use the
        hash preimage if its known. Charlie: broadcast BC/C if Bob
        hasn't broadcast his, and wait for the timeout, or use the hash
        preimage if known.
L. Similar to I-K(n), Bob can broadcast one or both the sets of contract
   txes he knows. The other parties broadcast the remaining ones and
   either use the timeout or hash preimage value. Alice bans Bob's
   fidelity bond.
M. Same as L. but Charlie broadcasting. Alice bans Charlie's fidelity
   bond.
Unlike the v1 protocol, each CoinSwap party knows a different version of
the contract transactions, so the taker Alice always knows which maker
broadcast a certain set of contract transactions, and so can always ban
the correct fidelity bond.
== Conclusion ==
This document modifies the earlier version 1 detailed protocol design
for multi-transaction CoinSwap. It has each CoinSwap party knowing a
slightly different version of the contract transactions. It also uses
collateral payments. These features are both used to fix attacks found
during review of the v1 protocol.

@_date: 2020-09-03 10:00:00
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Detailed protocol design for routed 
Hello ZmnSCPxj,
Separating the timelock and hashlock cases into two separate
transactions is a nice way to solve many of these problems.
A big downside is that it really ruins the property of allowing coins to
remain unspent indefinitely. That has privacy implications: if a coin
remains unspent for longer than 2 weeks (or another short locktime) then
for sure the transaction was not a CoinSwap, and so the anonymity set of
the CoinSwap system would be far smaller For this reason I'm pretty
desperate to solve the vulnerability without losing the coins remaining
unspent indefinitely feature.
We need to solve the vulnerability you found, which I'll call the
riskless theft attempt problem. So what do you think of this solution:
== Building block 1: A, B and C having different contract txes ==
In the original proposal each CoinSwap peer has the same contract
transaction, and either side can broadcast it whenever they like. This
actually isn't necessary. We can have a contract transaction
fully-signed but only known to one peer, with a possibly-different
transaction transaction fully-signed and only known to the other peer.
Obviously for the CoinSwap to work both contract transactions must have
the same hash-time-locked contract, but they can differ in other ways.
== Building block 2: collateral payments ==
The riskless theft attempt problem happens because the previous owner of
the coins knows the fully-signed contract transaction and can broadcast
it at no cost to themselves. So to solve the problem we add a cost.
There is a 2of2 multisig made up of Bob's and Charlie's keys. The
associated contract transaction known to Bob must now also have one of
Bob's single-sig inputs. The outputs are such that some of the money
from Bob's input now ends up in the HTLC output. The result is that
after the CoinSwap if Bob broadcasts his contract transaction but fails
to take the money from the HTLC output, then Bob will have lost money.
I'm calling this idea collateral payments, by analogy with collateral
used for loans. A collateral is someone valuable a debtor puts on the
table, and if they don't repay the loan then they lose the collateral
(presumably the creditor sells it to repay the loan).
Here is a diagram of the contract transaction known to Bob:
    multisig (B+C) [I btc]---> (B+timelock_B OR C+hash) [I+K-M~ btc]
    collateral(B)  [J btc]     (Bob)                    [J-K btc]
    I = CoinSwap amount
    J = Value of Bob's collateral input
    K = Value that Bob loses if he broadcasts his contract tx but doesnt
get the money
    M~ = miner fee (random variable)
The value K is something that can be set by the protocol, and made high
enough so that doing a riskless theft attempt is not worth it. Probably
the value of K will be quite small because the odds of a riskless
payment attempt succeeding is very small (assuming the makers all use
multiple redundant watchtowers). Mostly likely K will be smaller than
M~, so if the collateral is lost to Bob then the miners will the ones to
gain, rather than Charlie.
The other contract transaction, known only to Charlie, does not contain
a collateral input or collateral value (K), because Charlie can't do a
riskless theft attempt to Bob.
If Bob ever spends his collateral input in another transaction, then his
contract transaction will become invalid. However Bob will only be
harming himself, so he'll never do this.
I think this might be a fruitful idea, and soon I'll modify my earlier
detailed design to include it, and see if it can be made to work with no
weird edge cases or attacks.
=== Appendix: Brief historical note about separate contract txes ===
Separating hash- and time-lock branches into different transactions as
in ZmnSCPxj's design is actually very similar to the way the original
2013 CoinSwap design worked:
The timelock branch was a transaction locked with nLockTime. And the
hashlock branch is another transaction spending to an output requiring
Carol's public key + hash preimage.
However Adam Gibson in 2017 found a vulnerability to this:
The vulnerability is that even though Carol doesn't know the hash
preimage, she can still broadcast the hashlock transaction, which sends
the coins _into_ the hashlock contract, and that invalidates Alice's
timelock transaction. Carol is the only one who can spend the coins but
she doesn't know the hash preimage. The protocol then degenerates to the
MAD (mutually assured destruction) case because the coins are locked
Adam Gibson's fix was to include the hashlock and timelock branches into
the same transaction known to both peers, which is exactly the design I
used and for which all these vulnerabilities were found.
I realize now there is another way to solve the vulnerability, which is
to include a (Alice pubkey + OP_CLTV timelock) in Carol's contract
transaction. This means that if Carol broadcasts her contract tx (called
TX_2 in the text) without knowing the preimage then Alice can still get
her money back after a timeout, breaking the MAD situation. The crucial
part making this work is that Alice won't know the fully-signed Carol
contract transaction, and so won't be able to unilaterally broadcast it.
I believe this fix makes the scheme equivalent to ZmnSCPxj's idea of
separated transactions, but without scriptless scripts (and so the
scheme is less useful)
Kind regards

@_date: 2020-09-03 11:50:57
@_author: Chris Belcher 
@_subject: [bitcoin-dev] Detailed protocol design for routed 
Hello ZmnSCPxj,
I'd argue its not even a small leak. A huge amount of coins remain
unspent for weeks, months and years, and it would be great to add them
to our CoinSwap anonymity set. And also have them benefit from
CoinSwap's anonymity set even if they didn't use CoinSwap.
Yes, in fact that's why in my example I talk about a CoinSwap between
two makers Bob and Charlie. Makers can be reasonably expected to own
multiple UTXOs, but takers cannot. As you say because collateral
payments breaks the ability of takers to sweep their entire wallet
through CoinSwap.
Happily, I think takers themselves don't need to use collateral
payments. Here's an argument to why:
Riskless theft attempts by the taker who no longer controls the coins
actually isnt riskless or costless: Because it reduces the privacy of
the previously-owned coins. If a taker genuinely wanted good privacy
(Which, after all, they're paying for via miner fees and CoinSwap fees)
then they would benefit if the coins they no longer own remain unspent
for a long time, because it increases their anonymity set by making them
hide among a greater crowd of coins which also don't get spent for a
long time.
Assuming that all peers, especially makers, deploy multiple redundant
watchtowers then we can assume the success rate of such a theft attempt
is very low. Because of the very low payoff, and privacy benefit of
leaving coins unspent, then it can be argued that taker software which
attempts such theft will never get popular.
Of course this privacy argument only applies to takers, and if the
CoinSwap contract is between two makers as part of a multi-transaction
CoinSwap then it doesn't apply. So a maker-to-maker CoinSwap must use
collateral payments.
== Leak of first hop ==
Collateral inputs only applying to maker-maker CoinSwaps adds an
additional information leak, which is that makers can now tell whether
their previous peer was a taker or maker, based on whether they used a
collateral input or not.
This should be okay because the first maker doesn't know the final
destination of the coins. This is similar to Tor, where this information
is already leaked, for example when the user connects to a Tor bridge.
The operator of the Tor bridge knows that everyone connecting to it is
not a Tor relay node but an actual user. The operator of the tor bridge
still has no idea where the user's internet traffic goes. Our situation
is actually better than Tor, because in Tor the final relay always knows
that they are an exit node, while the final maker in a CoinSwap might
not know that.
Also, if the taker does happen to own an extra UTXO, they may choose to
use a collateral input anyway, just to pretend that they're a maker.
