
@_date: 2017-12-20 14:50:42
@_author: Dan Libby 
@_subject: [bitcoin-dev] BIP Proposal: Crypto Open Exchange Protocol (COX) 
currencyCode and cryptoCurrencyCode seem to assume that merchants will
always want to sell for fiat.  But a merchant might want to sell for
another cryptocurrency instead.
Why not make it more generic, like buySymbol and sellSymbol?

@_date: 2017-07-11 23:17:24
@_author: Dan Libby 
@_subject: [bitcoin-dev] how to disable segwit in my build? 
Up to now, I have purposefully been running bitcoin releases prior to
0.13.1 as a way to avoid the (possible) segwit activation, at least
until such time as I personally am comfortable with it.
At this time, I would like to have some of the more recent features, but
without the possibility that my node will activate segwit, until I
choose to.
As I understand it, there is not any user setting that can disable
segwit from activating on my node.  If there was, I would use it.
Please correct me if wrong.
I am here to ask what is the simplest code change (fewest LOC changed) I
can make to 0.14.2+ code that would disable segwit from activating and
keep my node acting just like a legacy node with regards to consensus
rules, even if/when the rest of the network activates segwit.
I think, more generally, the same question applies to most any Bip9
versionbits feature.
I'm not looking for reasons NOT to do it, only HOW to do it without
unwanted side-effects.  My first untested idea is just to change the
segwit nTimeout in chainparams.cpp to a date in the past.  But I figured
I should ask the experts first.   :-)
ps: full disclosure:  I may be the only one who wants this, but if
successful, I do plan to release my changes in case someone else wishes
to run with status-quo consensus rules.

@_date: 2017-07-13 09:05:01
@_author: Dan Libby 
@_subject: [bitcoin-dev] how to disable segwit in my build? 
I understand it is not in any way a supported configuration.
Please lets not go into the weeds debating about my reasons.
I actually have nothing against segwit per-se, and think it is clever
tech.  I wish that it, or another malleability fix, had been baked in
from the start.  But it wasn't, and I dislike changing the consensus
rules except if critical flaws are found.
anyway, some of my reasons are:
I am content with status-quo consensus rules.
I see greatest long-term value in a fixed, unchanging set of rules
(though that is outside my control of course).
I have limited bandwidth and resources and prefer 1mb limit for that reason.
Prior to activation, I do not choose to signal for segwit in any way
shape or form.
I realize I could run a pre-segwit node forever, but would like to enjoy
more recent features and otherwise avoid bit-rot.
I am mule-headed and stubborn.  If network-wide activation should
happen, I will most likely upgrade to segwit at some point, but I intend
that point to be at my choosing, not because software defaults did it
for me.
I view it as a little bit of a personal challenge and experiment.
no that thought did not enter my mind.  still not sure I fully grok it
in fact, but no matter.

@_date: 2017-07-13 09:13:04
@_author: Dan Libby 
@_subject: [bitcoin-dev] how to disable segwit in my build? 
I wish to NOT signal for segwit if mining.
I wish to NOT enforce segwit consensus rules.
good point, thanks for clarifying.
I've set the nTimeout to 0 already.  I will look into the NODE_WITNESS
p2p bit.
I think that logically, if coded correctly, my node would have no more
risks than any other legacy (pre-segwit) node on the network...
fair enough.  But these are the same risks as running any pre-segwit
node, correct?    For example bitcoin-core 0.13.0, or any version of
btcd to date...

@_date: 2017-07-13 09:19:00
@_author: Dan Libby 
@_subject: [bitcoin-dev] how to disable segwit in my build? 
Right.  Well, if I never upgrade to segwit, then there seems little
(zero?) risk of having any segwit tx in my tx chain.
Thus this would be a way I could continue with a lower bandwidth cap and
also keep my coins "untainted", so to speak.
I'm not sure about it for the long run either.  more just something of
an experiment.

@_date: 2017-07-13 14:58:04
@_author: Dan Libby 
@_subject: [bitcoin-dev] how to disable segwit in my build? 
fair enough.  This actually wasn't an area I'd considered much before
Hampus brought it up.
I would like to understand it a bit better, as I think it applies
equally to any pre-segwit node, yes?   So let's say I am running 0.13.0
and someone sends me bitcoins to a P2PKH address, but that person
previously received them to a P2WPKH address.
If I understand correctly, my node will accept the incoming tx inputs
but obviously will not perform any segwit related validation, thus those
inputs are not fully validated.  I don't yet understand how my node
thinks they are valid at all given that it does not understand P2WPKH
address format, so either it doesn't need to, or P2WPKH is somehow
already valid.  I know this has all been discussed in the past, so if
someone can point me towards a document that explains it I'd be happy to
read that.

@_date: 2017-07-13 16:20:45
@_author: Dan Libby 
@_subject: [bitcoin-dev] how to disable segwit in my build? 
Hampus, thanks for the explanation!
sounds good, though I'm unclear on how exactly to achieve (2) given that
any party I have ever transacted with (or otherwise knows an address of
mine) can send me coins at any time.  So it seems the only possible way
to be certain is to run a node that has never published an address to a
3rd party.  Is that accurate?
Another thing that could be done is to modify my own node so that it
actually rejects such tx, but then I have modified consensus rules
myself, thus defeating the goal of remaining with status-quo rules, and
anyway the rest of the network would accept the tx.  I guess the benefit
is that I could be certain of the remaining funds I have.
I suppose that it would be possible without modifying any rule to
construct a "certain balance" and an "uncertain balance".
I don't intend to do such modifications! just grasping for understanding.
I read the relevant parts, thanks!

@_date: 2017-09-06 00:19:31
@_author: Dan Libby 
@_subject: [bitcoin-dev] BIP49 Derivation scheme changes 
small nit with 3.
It seems to me that the wallet would perform initial discovery on m/44
and m/49, and then would find transactions at one or the other, so it
can then record the type somewhere and from then on need only monitor
one branch.
Still, I agree it is ugly, makes initial discovery up to 2x slower, etc.
speaking as author of tools hd-wallet-addrs and hd-wallet-derive, I
agree this is problematic.
would be great if xpub/xprv could somehow encode their absolute path in
wallet for tools to read.  Users cannot be expected to know.

@_date: 2017-09-13 02:50:53
@_author: Dan Libby 
@_subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented? 
Hi, I am interested in the possibility of a cryptocurrency software
(future bitcoin or a future altcoin) that strives to have immutable
consensus rules.
The goal of such a cryptocurrency would not be to have the latest and
greatest tech, but rather to be a long-term store of value and to offer
investors great certainty and predictability... something that markets
tend to like.  And of course, zero consensus rule changes also means
less chance of new bugs and attack surface remains the same, which is
good for security.
Of course, hard-forks are always possible.  But that is a clear split
and something that people must opt into.  Each party has to make a
choice, and inertia is on the side of the status quo.  Whereas
soft-forks sort of drag people along with them, even those who oppose
the changes and never upgrade.  In my view, that is problematic,
especially for a coin with permanent consensus rule immutability as a
As I understand it, bitcoin soft-forks always rely on anyone-can-spend
transactions.  If those were removed, would it effectively prevent
soft-forks, or are there other possible mechanisms?  How important are
any-one-can spend tx for other uses?
More generally, do you think it is possible to programmatically
avoid/ban soft-forks, and if so, how would you go about it?

@_date: 2017-09-15 12:55:56
@_author: Dan Libby 
@_subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented? 
Ok, this is good stuff.  thanks for the thoughtful reply.
Regarding anyone-can-spend:
all of the examples you gave do not satisfy isStandard.  So if our
hypothetical cryptocurrency were to restrict all transactions to
isStandard at the consensus layer, would that not effectively prevent
Or more generally and with our thinking caps on, what would be the best
way to prevent anyone-can-spend, if that is our goal?
Regarding soft-fork = restrict:
Your example of miners running secret soft-fork code that blacklists
satoshi's utxo's is intriguing and somewhat troubling.
I think the main takeaways are that:
  1) there are other ways to soft-fork besides anyone-can-spend.
  2) it is impossible to prevent hidden soft-forks.
Is that accurate?
Still, I would put forth the following question:  If anyone-can-spend tx
were no longer allowed according to consensus rules (assuming that is
possible/practical), then could the network still be practically
"upgraded" with new features (eg opcodes) via soft-fork, and if so, what
would be the mechanism for backwards compatibility in this scenario?
or from another angle:  even if it is impossible to prevent all
soft-forks, can you see any way at all to make it logistically
infeasible to use soft-forks as a network-wide consensus change mechanism?
and another thought:  as I understand it, bitcoin is presently able to
add new opcodes via soft-fork because Satoshi added 10 unused opcodes
via hardfork. What will happen when these run out?  Can new opcodes
still be added without a hard-fork?
note: I ask these questions with the goal/vision of creating an
immutable altcoin or sidechain, not necessarily restricting bitcoin's path.

@_date: 2017-09-15 13:01:48
@_author: Dan Libby 
@_subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented? 
my concern is that the community can be manipulated via political means.
 marketing, social media, payoffs, fud, etc, etc, etc.  And essentially
degrades to tyranny of the majority.
So if there is any way to make opt-in forks impractical/infeasible for
purpose of network wide consensus rule change, I'd love to hear it.

@_date: 2017-09-15 13:15:36
@_author: Dan Libby 
@_subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented? 
Thanks for this link.  From my reading though, it seems that only
soft-forks that attempt to freeze funds are problematic on ethereum.
So in the general case ethereum can still soft-fork I think...

@_date: 2017-09-15 14:48:57
@_author: Dan Libby 
@_subject: [bitcoin-dev] hypothetical: Could soft-forks be prevented? 
sure, but in this scenario how would one meaningfully "upgrade" the
functionality, eg add a new opcode?  We couldn't, right?  so....
success!   Preventing new functionality is the primary goal of this
thought experiment.  I believe that common sense and market incentives
would prevent arbitrary tightening of the rules for no good reason...

@_date: 2017-09-29 10:29:17
@_author: Dan Libby 
@_subject: [bitcoin-dev] Paper Wallet support in bitcoin-core 
I'm writing to suggest and discuss the addition of paper wallet
functionality in bitcoin-core software, starting with a single new RPC
call: genExternalAddress [type].

@_date: 2017-09-29 12:34:57
@_author: Dan Libby 
@_subject: [bitcoin-dev] Paper Wallet support in bitcoin-core 
true that.  Though there's nothing stopping a diligent person from
installing bitcoin-core on a dedicated offline machine.  The blockchain
wouldn't need to be synced at all for key generation purposes.
yeah, so I noticed this issue about Paper Wallet generation not being
possible with bitcoin-core exactly because I was recommending to a
non-technical user to use paper wallets, but then I also had to point
out that really bitaddress code should be downloaded, audited, etc,
before use.  Things that are actually impossible for a non-technical user.
So I figured that instead I would make a simple script for them that
would use bitcoin-core to generate the addresses... and that's when it
dawned on me that it won't actually work with present day RPCs that are
all tied to internal wallet.
hence, this proposal.
yes, agreed.

@_date: 2017-09-29 13:13:59
@_author: Dan Libby 
@_subject: [bitcoin-dev] Paper Wallet support in bitcoin-core 
One additional thought:
It should be useful to also define a multi-sig generation RPC.
This would facilitate multi-sig paper wallets stored in different
physical locations, amongst other use-cases.
Something like:
    genexternalmultisigaddress ( "m", "n", "type" )
    Returns a new Bitcoin address and n number of private key(s).
    This address and associated keys is intended for external usage such
    as paper wallets and will not be used by internal wallet nor written
    to disk.
    Arguments:
    1. "m"           (integer, required) The number of required signers
                                         to send funds.
    2. "n"           (integer, required) The number of authorized
                                         signers
    3. "type"        (string, optional)  one of: p2sh-p2pkh, p2sh-p2wpkh
                                         default: p2sh-p2wpkh
    Result:
    {
        "address",   (string) The address in p2pkh or p2sh-p2wpkh
                              format.
        "privkeys": [
            (string) The private key in wif format.
        ]
    }
    Examples:
    > bitcoin-cli genexternalmultisigaddress 2 3

@_date: 2017-09-29 15:13:47
@_author: Dan Libby 
@_subject: [bitcoin-dev] Paper Wallet support in bitcoin-core 
It seems to me that the same statement can be made for *any* key storage
mechanism depending on one's security/threat model, including
bitcoin-core's internal wallet storage.  There certainly are cases where
a paper (or metal) offline wallet makes a lot of sense, particularly for
long-term offline storage... something that electronic media pretty much
sucks at.
Though if you care to elaborate I'd be interested to learn of your
specific critiques, if you have any beyond the generic statements here:
Regardless, the APIs I've proposed have uses beyond paper wallets.  It
can also be used by third party wallets, or any number of reasons that
individuals or devs might have to generate keys.

@_date: 2017-09-29 15:19:46
@_author: Dan Libby 
@_subject: [bitcoin-dev] Paper Wallet support in bitcoin-core 
Anyway, I'll count that as a NAK from Luke.  what do others here think?
I wish to guage if I were to submit a functional pull request for one or
both of these RPC calls, if would it be likely to be accepted.
If so I'm happy to contribute my time, otherwise...

@_date: 2017-09-30 00:06:42
@_author: Dan Libby 
@_subject: [bitcoin-dev] Paper Wallet support in bitcoin-core 
ok, thanks.  I will take the proposal there.
thanks for your feedback.
uhh.... do you apply this logic to the bitcoin-core wallet itself?
because clearly it generates keys and is intended to be used for signing
in online environments.  Lots of real-world use-cases depend on that today.
So if existing bitcoin-core wallet behavior is "ok" in any context then
how is it any worse for it to generate a key/address that will not be
stored in the internal wallet, and the user may do with it as they wish?
 That is all my proposed RPC call does and unlike the existing RPC calls
it never even stores the key or address to disk.  It is also useful when
run on an offline hardware device, such as a laptop connected to an
non-networked printer.
Further, you mention the word trust.  That's the crux of the matter.  As
a full node operator, I've already placed my trust in the bitcoin-core
developers and dev/release practices.  Why exactly should I trust the
software in this minimal offline hardware/os you mention if it is NOT
bitcoin core?  And even if open source software, does that not at least
double my workload/expense to audit theat software in addition to
I suppose that in your view then, dumpprivkey and dumpwallet RPCs should
be removed from bitcoin-core to fit this paradigm?
(Personally I actively avoid wallet software that takes this view and
treat users like children, preventing individuals direct access to the
keys for their own funds, which disempowers and sometimes results in a
form of lockin)
This is more relevant to an application layer above the 2 RPC calls I
proposed. Encryption could be implemented (or not) by whichever software
calls the proposed RPC apis.  And further the APIs can be called for
use-cases beyond just paper wallets.
