
@_date: 2011-12-16 01:07:58
@_author: slush 
@_subject: [Bitcoin-development] Fwd: [BIP 15] Aliases 
I really like this proposal with standard URLs. All other proposals like
DNS mapping or email aliases converted to URLs with some weird logic looks
strange to me.
Plain URLs (returning address in response body, redirecting to URI
"bitcoin:" or anything else) are very clear solution, easy to
implement in clients and very easy to understand by people. It's also
extremely flexible - almost everybody can somewhere setup static file
containing his "personal" addresses or it's very easy to integrate such
solution with eshops (providing custom address for given order) etc. I'm
definitely for this solution.

@_date: 2011-12-16 17:36:43
@_author: slush 
@_subject: [Bitcoin-development] Fwd: [BIP 15] Aliases 
OK, I'm ignoring your sarcastic style, I just wanted to support the URL
idea, which is KISS attitude, in the oposite of everything else proposed
here. I'm really affraid of over-engineering the aliases, which will make
it hard to implement in clients. Somebody noticed account implementation in
standard client - yes, it's good example of fail.
I still don't see any serious issue with the URL proposals. And sipa's idea
of posting back the transaction ID is also interesting, prividing yet
another flexibility in implementation and possible usage.
Btw, Rick, feel free to provide me some relevant RFCs which are solving
similar problems like BIP 15. And no, it's not sarcasm, I really want to
learn something new. Until now I just feel we're reinventing wheel or
raping some stuff which we should not touch at all (DNS).
On Fri, Dec 16, 2011 at 4:52 PM, Rick Wesson

@_date: 2011-12-16 20:54:35
@_author: slush 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
Khalahan, honestly, using namecoin for aliases is (for me) clean example of
over-engineering. I mean - it will definitely work if implemented properly.
I played with a namecoin a bit (as my pool was the first 'big' pool
supporting merged mining), but I think there's really long way to provide
such alias system in namecoin and *cleanly integrate it with bitcoin*.
Don't forget that people who want to do lookup need to maintain also
namecoin blockchain with their bitcoin client. It goes against my instinct
of keeping stuff easy.
For example, yesterday I implemented HTTPS lookup for addresses into my
fork of Electrum client. I did it in 15 minutes, it works as expected, it
does the job and the implementation is really transparent, becuase
implementation is 20 lines of code. There's no magic transformation, no
forced "?handle=" parameters or whatever. And I don't care if somebody
provide URL
And everybody can do the same in their clients, in their merchant
solutions, websites or whatever. Everybody can do HTTPS lookup. But try to
explain DNS, Namecoin, IIBAN, email aliases to other programmers...
Those IIBAN - well, why not. At least I see the potential in PR. So far I
understand it as some teoretic concept which is not supported by anything
else right now. Give it few years until it matures and then add IIBAN alias
to Bitcoin client too.
Maybe I'm repeating myself already, but the way to go is to make aliases as
easy as possible, so everybody can implement it in their own solution and
thus practially remove the need of using standard bitcoin addresses for
normal users. Using some superior technology, which is hard to implement or
even understand won't solve the situation, because it will ends up with
some reference implementation in standard client only and nobody else will
use it.

@_date: 2011-12-19 00:58:37
@_author: slush 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
Maybe I'm retarded, but where's the point in providing alliases containing
yet another hash in URL?

@_date: 2011-12-19 02:44:42
@_author: slush 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
Pieter, it was more rhetorical question than asking for explanation, but
thanks anyway. As an Internet application developer, I of course understand
security issues while using HTTPS and CA.
I have a gut feeling that there simply does not exist any single solution
which is both easy to use and secure enough. At least nobody mentioned it
yet. And if I need to choose between easy solution or secure solution for
aliases, I'll pick that easy one. I mean - we need some solution which will
be easy enough for daily use; it is something what we currently don't have.
But if I want to be really really sure I'm using correct destination for
paying $1mil for a house, I can every time ask for real bitcoin addresses,
this is that secure way which we currently have.

@_date: 2011-12-19 18:09:16
@_author: slush 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
I agree with Luke that HTTP standard has everything necessary and bloating
payload with json/xml is not necessary.
Btw that argument "we have json in client already" seems pretty wrong,
because json in server rpc solves another problem (and solve it in wrong
way, because of data type issues, but it's another story).

@_date: 2011-12-19 19:17:55
@_author: slush 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
In my opinion, there's not necessary any payload format (json, xml,
multipart). In keeping stuff KISS, everything we need is just an address in
response + potentially some stuff like HTTP redirects (for providing
additional compatibility for proposal of bitcoin URIs with "amount",
"label" and other parts). I don't see reason why we need some extra payload

@_date: 2012-12-04 22:23:59
@_author: slush 
@_subject: [Bitcoin-development] Roadmap to getting users onto SPV clients 
Jim, perfect idea with some logo indicating wallet compatibility! This
should cover BIP32 + some mnemonic algorithm for easy transferring of
wallets across various clients.
Btw I asked ThomasV for making BIP from his mnemonic algorithm and he
agreed, so I believe some proposal will be here pretty soon.

@_date: 2012-02-01 16:09:58
@_author: slush 
@_subject: [Bitcoin-development] Announcement: libcoin 
Very interesting. Do you have any plans to push your refactored code into
Bitcoin upstream for future releases someday?

@_date: 2012-02-14 07:09:30
@_author: slush 
@_subject: [Bitcoin-development] IRC meeting Tuesday, Feb 14, 21:00 UTC 
Hello Gavin,
excuse me, but do you think it's good idea to have IRC meeting on
Valentine's evening? Some of us have girlfriends :-).

@_date: 2012-01-17 01:59:25
@_author: slush 
@_subject: [Bitcoin-development] bitcoin.org SOPA/PIPA blackout 
I agree on this. Please don't turn Bitcoin project/homepage into some
political agitation. Not everybody care about political attitude of main
project developers.

@_date: 2012-01-31 15:33:38
@_author: slush 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
Hi Amir,
reason for breaking with tradition.
excuse me if it was already discussed, but maybe using satoshis instead of
decimal bitcoin would be better choice? We all know about pains with proper
handling decimal numbers across of all implementations - and it's not only
about json-rpc.
Otherwise I agree, BIP 21 is better than BIP 20 because it's easier to
implement all points of the standard.

@_date: 2012-07-09 15:11:43
@_author: slush 
@_subject: [Bitcoin-development] Bitcoin Wallet for Android 
I agree. Just imagine those two-inches newspaper titles - "Bitcoin
hacked! Backdoor in official bitcoin client!". We have already some
experience with shortcuts which journalists do...

@_date: 2012-03-06 18:34:15
@_author: slush 
@_subject: [Bitcoin-development] P2SH status update 
is there any status update from Deepbit? Why he still does not support

@_date: 2012-11-06 19:56:23
@_author: slush 
@_subject: [Bitcoin-development] IRC meeting agenda, 18:00 UTC Thursday 
It's not about BIP process, it's possibly about content of particular
There's no mess with stratum mining, except in your head. There's no
requirement to have BIP for everything what people do. Stratum is NOT
related to bitcoin protocol or bitcoin implementation, it is just custom,
pooled-mining extension and bitcoin network doesn't need to know about
Stratum existence at all.
There have been peer review of the protocol. You wanted to say "I was not
invited to do peer review", right?
Please don't start it AGAIN and stop bashing Stratum in your posts, at
least in bitcoin-dev mailing list.
I promised to write BIP draft for Stratum, I proposed and implemented
get_transactions method to allow Stratum jobs inspection. What more do you
want, seriously? I'm soo tired by you, Luke.
P.S. I'm sorry that other developers had to read such posts. I'll try to
sit on my hands next time.

@_date: 2012-11-29 09:16:31
@_author: slush 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
not sure if you already noticed, but I and my friends are actively working
on bitcoin hardware wallet. This should be pocket size device with
something like 256kB flash and 80 MHz CPU, talking with the computer over
USB. User will prepare transaction on the machine, send it to the device,
device shows target address on the display and user confirms it by pressing
the button.
We're trying to make bitcoin payments safe even on hacked computer. For
this reason we're also implementing SPV so device don't need to trust
computer with any kind of information. The biggest existing problem is that
user cannot be sure that the address displayed on computer screen is
correct and he's confirming valid address.
I don't have any solution for this problem yet. I just appreciate an
activity in payment protocol area, because it can (with some care) solve
this problem and my appeal si to keep all this simple. I'd be very happy
with simple payment protocol which can be implemented even on devices like
I'm working on, so device with few widely used certificates stored in the
memory will be able to display origin of the invoice and confirm its

@_date: 2013-08-15 10:22:19
@_author: slush 
@_subject: [Bitcoin-development] Version 0.9 goals 
We're planning to support payment protocol in Trezor as well, if it counts.
I think it's a missing piece in absolute security of hardware wallets.

@_date: 2013-08-15 16:32:22
@_author: slush 
@_subject: [Bitcoin-development] Version 0.9 goals 
Our plan is to add support for that into v1 firmware, but it also depends
on readiness of surrounding infrastructure; mainly if there'll be support
for payment protocol in multibit in the time of v1 release (I suppose that
the Multibit will be the first wallet  compatible with Trezor AND
supporting payment protocol).

@_date: 2013-03-13 19:35:11
@_author: slush 
@_subject: [Bitcoin-development] 0.8.1 ideas 
Agree. I quite like Mark's proposal. Yes, formally it is hard fork. But the
step 4) can come very far in the future, when the penetration of <0.8
clients will be mininimal.

@_date: 2013-11-02 01:04:11
@_author: slush 
@_subject: [Bitcoin-development] BIP39 word list 
Hi Brooks,
I've been already thinking about eat -> cat typing mistake. Actually there
may be simplier solution than having wordlist with duplicated words.
Because there's already a mapping of similar characters in the source code
(currently only in unit test, but it can be moved), when user type a word
which isn't in wordlist, application may try to use such mapping to find a
combination which actually is in the mapping. This may be disambiguous in
some cases, but giving a choice between few words may be better than hard
fail. And it is actually quite easy to implement. Although I think
application can do such smart suggestions and help user to recover badly
written mnemonic, I don't think it is necessary to standardize such method
directly into BIP. It may or may not be implemented by developers and it is
just nice to have feature.
user type ear, but it isn't in wordlist.
Regards the mapping,
E is similar to A, C, F, O
A is similar to E, C, O
R is similar to B, P, H
So application can calculate combinations of possible characters:
a) when app consider than the the user mistyped only one character
AAR, CAR, FAR, OAR
EER, ECR, EOR
EAB, EAP, EAH
b) when app consider than user maybe mistyped more characters, it may do
full combination matrix
AEB,  ACB, AOB,  ... OEH, OCH, OOH
and then ask user to select only these combinations which are actually
presented in the wordlist. In this particular case it may be only CAR or
FAR (both cannot be in the wordlist because of rules in similarity).

@_date: 2013-11-02 22:57:50
@_author: slush 
@_subject: [Bitcoin-development] Message Signing based authentication 
Glad to see that there are more and more people wanting to replace
passwords with digital signatures.
Although such method has been already used on other websites like Eligius
or bitcoin-otc, I dont think theres any standard way to doing so yet.
Two comments to your proposal:
A) message-to-be-signed need to be carefully composed to be both structured
and human readable. It should contain at least:
Desired username/identity handler
Server identifier (url)
Timestamp to prevent replay attack
Server challenge
Then the user can see what he's signing, instead of signing some binary
blob which can contain some evil data.
Same structured data should be a part of html page in some header tag,
ideally signed by server certificate to confirm that the request is valid.
Then the login request can be processed by machine automatically, without a
need of copy&paste by a user.

@_date: 2013-11-06 07:41:57
@_author: slush 
@_subject: [Bitcoin-development] Message Signing based authentication 
but although they will expose ECC via the NSS, I dont think bitcoin's
particular curve will be supported, because it's not NIST approved. If the
use case was presented though, they may add it.
Trezor, my friend.
Sent from mobile phone.

@_date: 2013-10-01 10:58:05
@_author: slush 
@_subject: [Bitcoin-development] bitcoind stops responding 
ad "RPC stops working":
* Client makes a 'getinfo' call and don't receive a response in a minute.
"What is your precise RPC usage? "
One process is asking getinfo every second as a fallback to possibly
misconfigured blocknotify. It also calls getblocktemplate every 30 second.
Second process is calling getinfo once a minute to check if bitcoind is
working. If it don't receive a response in a minute, it kills bitcoind and
starts it again.
That's all.
OS is Debian.

@_date: 2013-10-23 02:56:57
@_author: slush 
@_subject: [Bitcoin-development] BIP39 word list 
I think this is a good idea; I just pushed new unit test test_similarity()
to github which finds such similar words. Right now it identifies ~90
similar pairs in current wordlist, I'll update wordlist tomorrow to pass
this test.

@_date: 2013-10-24 15:26:32
@_author: slush 
@_subject: [Bitcoin-development] BIP39 word list 
I've just pushed updated wordlist which is filtered to similar characters
taken from this matrix.
BIP39 now consider following character pairs as similar:
        similar = (
            ('a', 'c'), ('a', 'e'), ('a', 'o'),
            ('b', 'd'), ('b', 'h'), ('b', 'p'), ('b', 'q'), ('b', 'r'),
            ('c', 'e'), ('c', 'g'), ('c', 'n'), ('c', 'o'), ('c', 'q'),
('c', 'u'),
            ('d', 'g'), ('d', 'h'), ('d', 'o'), ('d', 'p'), ('d', 'q'),
            ('e', 'f'), ('e', 'o'),
            ('f', 'i'), ('f', 'j'), ('f', 'l'), ('f', 'p'), ('f', 't'),
            ('g', 'j'), ('g', 'o'), ('g', 'p'), ('g', 'q'), ('g', 'y'),
            ('h', 'k'), ('h', 'l'), ('h', 'm'), ('h', 'n'), ('h', 'r'),
            ('i', 'j'), ('i', 'l'), ('i', 't'), ('i', 'y'),
            ('j', 'l'), ('j', 'p'), ('j', 'q'), ('j', 'y'),
            ('k', 'x'),
            ('l', 't'),
            ('m', 'n'), ('m', 'w'),
            ('n', 'u'), ('n', 'z'),
            ('o', 'p'), ('o', 'q'), ('o', 'u'), ('o', 'v'),
            ('p', 'q'), ('p', 'r'),
            ('q', 'y'),
            ('s', 'z'),
            ('u', 'v'), ('u', 'w'), ('u', 'y'),
            ('v', 'w'), ('v', 'y')
        )
Feel free to review and comment current wordlist, but I think we're slowly
moving forward final list.

@_date: 2013-10-24 20:09:52
@_author: slush 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Two years ago I proposed exactly this and you refused to add extra
information to mnemonic, because "it isn't necessary" and "it makes it
longer to mnemonization". What changed since then?
Hm, what exactly do you need to store about wallet structure? I lived in
opinion that everything is able to recover using CKD function to generate
new addresses and blockchain lookups for their balances.
Yes, that's true. It isn't possible to make everybody 100% happy. At least
I wanted to be constructive and asked you to replace the most problematic
words. No pull request from you so far.
Yes, it was original idea. So far I don't think this is a problem. Of
course some words may have some meaning across languages, but it should be
easy to avoid them. There are tens of thousands words in every language and
we need to pick "only" 2048 words to wordlist.
I would like to suggest the following solution:
If I understand this well, it is basically one-way algorithm "mnemonic ->
seed", right? Seed cannot be printed out as mnemonic, because there's
hashing involved, but the bi-directionality has been the original
requirement for such algorithm (at least in Electrum and bip39).
Then, how is this different to picking 12 random words from dictionary and
hashing them together? I don't see any benefit in that "mining" part of the
proposal (except that it is lowering the entropy for given length of
Are your worries about overlapping words across languages a real issue?

@_date: 2013-10-24 20:26:47
@_author: slush 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
We've reflected many comments about BIP39 wordlist from the community and I
think the wordlist is much better now. Specifically we removed many of
theoretically offensive words as well as we implemented algorithm for
detecting words with similar characters (cat/eat) and we resolved these
duplicities. I'm now quite happy with the wordlist and I want to ask you
for next (final?) round of comments.
hardening (against bruteforcing) using Rijndael cipher. This has been
chosen because its blocksize can be 128, 192 or 256 bits, so it fits length
of desired seeds. Also there are Rijndael implementations in every
language. Btw password protection has one interesting feature - plausible
deniability. It allows user to have one mnemonic and by using it with
different passwords, it will generate different BIP32 wallets.... (wink
I want to be pretty clear that we need to close this topic somehow, because
we want to use such algorithm in Trezor (which deadline is coming quick)
and also other wallet developers want to implement such algorithm into
clients to be compatible with Trezor. There were quite strict requirements
for such algorithm (like the possibility to convert mnemonic to seed as
well as seed to mnemonic) and I think we found a good solution. I'm wildly
asking you for constructive comments, but saying "it's a crap, I don't like
it" won't help anything.
On Thu, Sep 12, 2013 at 6:02 PM, Matthew Mitchell <

@_date: 2013-10-24 20:54:53
@_author: slush 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
On topic of "it wants to be final" and "it is incompatible with Electrum":
None of this is true. Firstly, it *is* possible to implement both algorithm
into the client at the same time, so user will be able to recover wallet
using Electrum or bip39 mnemonic and - what is worse - you already *know*
about this solution. Still you're spreading FUD about it on IRC, on emails
behind my back and here on mailing list.
The solution for Electrum client - as we discussed two weeks ago on IRC -
is that:
a) User type down the mnemonic (created with Electrum or BIP39)
b1) Only if *all* words are presented in both dictionaries and it has valid
BIP39 checksum (which is quite rare situation itself!), the mnemonic can be
consider to be both Electrum or BIP39.
b2) In most of cases we end up here, because the most common situation is
that with given words, only Electrum *or* BIP39 seed can be recovered.
c) Consider the mnemonic as Electrum. Create first few addresses and do a
lookup. If there are transactions in address history, this is Electrum
d) If there were no used address in c), build seed using BIP39 and do the
same lookup. If there's history, this is BIP39 mnemonic.
e) If there are no history on both algorithm, then pick prefered one for
given client (it should not hurt which one, because first use of given
mnemonic will "freeze" given algorithm for next time of mnemonic recovery).
Well, because only Electrum uses some mnemonic algorithm to this date, such
decision tree need to be implemented only in Electrum. You cannot tell that
"it is too complicated" or "ambiguous", because you're using the same
algorithm of deciding between Electrum deterministic / BIP32.
I must admit that I'm quite annoyed of such discussion, because we already
discussed all this privately, you didn't tell me any reason why this should
not work and still I see that this is coming back as a boomerang.

@_date: 2013-10-24 21:46:57
@_author: slush 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
I think that PoW concept in your proposal is quite smart! However the
problem that it isn't bidirectional; it don't allow to convert back and
forth between mnemonic and seed, which was one of basic requirement for
such algorithm.

@_date: 2013-10-24 21:37:43
@_author: slush 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
Well, I would say more "retype" than "remember". I really don't think that
common user will memorize it. But of course, it is still an option.
No, I dont' think it is stupid! Actually it was my concern as well.
Unfortunately I don't think it is "politically correct" to include all
bitches, assholes and motherfuckers in end user product :-).
Well, bip39 can have more dictionaries and *maybe* swearword dictionary
would gain some popularity ;).

@_date: 2013-10-26 22:47:41
@_author: slush 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Hi Thomas,
can you more elaborate on that "version" bits? What is exact meaning of it?
I still think this is more an implementation problem. What stops Electrum
to do the same algorithm for searching branches as it is now for used
These "version bits" need to be covered by the specification as well,
because if any client will use them differently (or won't use them at all),
it will break cross-compatibility between clients, which was another goal
of bip39.

@_date: 2013-10-31 11:41:27
@_author: slush 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Strange, I didn't receive the response from sipa in separate message, so
I'll respond to him at first place.
Le 26/10/2013 23:30, Pieter Wuille a ?crit :
Although many strange practices how to use whole bip32 space are possible,
I think that we may (should?) agree on some "good enough" way how to
discover already used addresses in bip32 space. I read Electrum sources
about bip32 and I see that Electrum still uses quite flat structure (fixed
amount of branches, indexes from 0 to n), which is of course very sane way.
So if I migrate seed to another (non-Electrum) software, I only need to
discover close neighbourhood of the path "0", similarly like Electrum is
doing with "gap limit" in plain old Electrum algorithm, except in two
dimensions (paths 0, 1, 2, 3, 4, 5, 0/0, 0/1, 0/2, 0/3, 0/4, 0/5, 1/0, 1/1,
...5/5 for gap limit "5"). I don't say such operation is cheap, but this
discovery needs to be done only during the import.
For the reason that I think this is the only sane algorithm of general use
of bip32 space, I still don't see why we do need some extra metadata. I
would understand this if Electrum will use for some strange reason
addresses in higher address space like 2^32-1 or so, but this is not going
to happen at least in Electrum.
Well, I can imagine that the bip32 compatible software will do full scan of
address space using some gap factor (actually I think "5" is too low by
default) or it can ask for wallet metadata like which software used such
tree before, to speedup scanning process.
I see that Thomas wants to make this automatic and hidden to user and
generally I agree that hiding the compexity to user is a good practice, but
actually this particular situation sounds to me as an exact oposite of
original statement "no metadata in mnemonic".
ECDSA has one very nice option - (almost) any random data can be used as a
private key. There are very nice schemas possible by using this feature and
requiring private key to be specially crafted just because the user wanted
to use mnemonic schema is very strong limitation to me.
To be specific, we (in cooperation with / inspired by Timo Hanke) developed
method how to prove that the seed generated by Trezor has been created
using combination of computer-provided entropy and device-provided entropy,
without leaking full private information to other computer, just because we
want Trezor to be blackbox-testable and fully deterministic (seed
generation is currently the only operation which uses any source of RNG).
To limit the complexity of such algorithm it is better to produce plain
seed (128, 192 or 256 bits, depends on settings) and then transform the
result of such "deterministic seed" to mnemonic, so for us the
bi-directionality is quite strong requirement. *Maybe* it would be possible
to combine such algorithm and one-way mnemonic together, but it would
complicate the design and I'm sure you understand that we want to keep
things as clear and simple as possible, especially while handling with seed
Agree (hardening is default in bip39).

@_date: 2013-10-31 12:11:02
@_author: slush 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Well, as we're the first pioneers of bip32, let's start using it in some
sane way and I'm sure the others will join. Just because they don't want to
incompatible software.
Actually I quite like that you're not wasting bip32 space by using some
dynamic allocatons in higher address space, so I'm happy to follow your
rules and I think we can agree on generic discover algorithm which maybe
won't be optimal, but will find all used addresses and won't need any
additional information directly in mnemonic.
As I wrote in previous post, in worst case I can imagine dropdown list on
import dialog, which will ask user which software has been handling the
seed before, to speedup the scan. But for now I don't see this necessary at
Also, I can imagine that bip32 itself might be superseeded in the future.
Although I can imagine that as well, I hope that it won't be the case. We
need to unite and integrate instead of making incompatible applications.
One disadvantage of bip32 is that in fact it is too much flexible, so we
even falled into the necessity of defining version of discovery algorithm.
Lets set up best practices how to use it and other will follow instead of
creating zillion cross-incompatible algorithms which won't understand each
to other.
Hardening and password protection are two unrelated requirements. Again,
there are some scenarios in which use can leak part of the mnemonic to
attacker, so hardening prevent to bruteforce the rest information by
attacker, even if the mnemonic isn't passphrase protected.
I'm especially refering to our algorithm of mnemonic import to Trezor
during disaster recovery (when Trezor is destroyed and user wants to import
the seed to another one), so that leak isn't just a theoretical concept,
but real-word scenario.
for metadata, then I guess strenghtening can be part of it. That's
Actually creating optional features of such algorithm only make things
complicated (and less cross-compatible). Every software still needs to
implement such hardening even if it is optional feature, to be compatible
with other clients. Then I don't see any reason why to have it optional.
Don't forget that the proposal uses only 4 bits of version, which isn't too
much combination for all these optional features ;-).
I too wonder why the transformation needs to be bidirectional in bip39.
Well, I wrote longer answer in previous  email. tl;dr; there's quite easy
way how to make the algorithm bi-directional, so I don't see a necessity to
drop potentially useful feature for no good reason.
I was thinking about your proposal and I realized that both our solutions
solves a bit different problem. Lets summarize features (and forget to
wordlist fights for moment):
+ bi-directional
+ passphrase protected
+ shorter mnemonic or shorter wordlist
- predefined wordlist
ThomasV proposal:
+ any software can has its own preferred worlist
? passphrase protected
- one-direction only
- longer mnemonic or longer wordlist
Back to wordlist fights
a) actually I think that the wordlist choice is far less important than it
may look at first glance. Thomas thinks that bip39 wordlist is disaster, me
and many other thinks it is ok, but mainly that it is very subjective.
b) I see the beauty of "custom wordlists" in Thomas proposal, still if it
means the algorithm is uni-direction only, it is very strong disadvantage
to our usecase.
c) I advocated our wordlist mainly because we put a lot of effort into it
and after many weeks of tuning it is already done; not because I think that
one method of picking the words is superior to other. I mean - if Thomas
can offer any other plain-english wordlist which he'll be happy with, I'll
vote for dropping our own wordlist and to use Thomas's version for the deal
that he'll accept our need for bi-directionality and he agrees on the rest
of bip39 ;-).

@_date: 2013-10-31 12:18:32
@_author: slush 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
Oh, I forgot to one practical aspect; the way how the mnemonic is "mined"
in Thomas proposal prevents usage in embedded devices, because difficulty
of generating proper mnemonic is simply too high for embedded
microcontrollers. Maybe this can be solved somehow by modifying the
proposal, but right now it is a showstopper for us.

@_date: 2013-09-10 18:52:26
@_author: slush 
@_subject: [Bitcoin-development] Python implementation of RFC 6979 
Hi all,
yesterday I found some time and implemented RFC 6979 into python-ecdsa
RFC 6979 proposes algorithm of calculating 'k' value for signature from
private key and signed data, so the 'k' is unique, but deterministic for
every signature. This enabled simple unit tests of code using ECDSA
signatures as well as some nice use cases for blackbox testing of 3rd party
software (you can calculate on your own if some software is making valid
signature, because there's no randomnes involved in the process). Yes, I'm
referring Trezor :-).
There's my fork of python-ecdsa with RFC 6979:
There's pull request waiting for python-ecdsa author aproval:
Aaand there's RFC 6979: tools.ietf.org/html/rfc6979

@_date: 2013-09-10 18:44:25
@_author: slush 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
Hi all,
we just finalized the draft and reference implementation of BIP39. Regards
to rules in BIP0001 we're asking for comments.
The aim of the proposal is to standardize algorithm across various clients
and fix some design problems of existing (but not yet standardized)
Electrum mnemonic algorithm.
BIP39 is a nice complement to BIP32, which allow users to (paper) backup
and share their wallet accross multiple clients easily.
Link to BIP: Thanks for your time,

@_date: 2013-09-10 22:50:58
@_author: slush 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
In many iterations of editing the wordlist we made our best to pick
words which are easy to remember, still "neutral". Unfortunately it's
almost impossible to exclude some words which may together create
negative co-notations.
Thankfully we removed all racist and religious words so I believe all
three authors mentioned in the BIP are safe against fundamentalist
bitcoin users :-).

@_date: 2013-09-11 00:47:51
@_author: slush 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
We're open to changes in the wordlist. We'll accept pull request
replacing potentially offensive words by another more neutral, which
also fits all other requirements.
Putting the wordlist together is really hard job and we spent few
sleepless nights on that. By the way, words "murder, black, people"
are contained also in Electrum wordlist and nobody complained yet :-).

@_date: 2013-09-30 22:44:57
@_author: slush 
@_subject: [Bitcoin-development] bitcoind stops responding 
during several weeks I'm observing more and more frequent issues with
bitcoind. The problem is that bitcoind stops responding to RPC calls, but
there's no other suspicious activity in bitcoind log, CPU usage is low,
disk I/O is standard etc.
I observed this problem with version 0.8.2, but it is still happening with
0.8.5. Originally this happen just one or twice per day. Today my
monitoring scripts restarted bitcoind more than 30x, which sounds alarming.
This happen on various backends, so it isn't a problem of one specific
node. Is there anybody else who's observing similar problem?

@_date: 2014-04-04 16:56:25
@_author: slush 
@_subject: [Bitcoin-development] Draft BIP for seamless website 
I'm cracking my head for many months with the idea of using TREZOR for web
auth purposes. Unfortunately I'm far from any usable solution yet.
My main comments to your BIP: Don't use bitcoin addresses directly and
don't encourage services to use this "login" for financial purposes. Mike
is right, mixing authentication and financial services is wrong. Use some
function to generate other private/public key from bitcoin's seed/private
key to not leak bitcoin-related data to website.

@_date: 2014-04-04 17:00:09
@_author: slush 
@_subject: [Bitcoin-development] Draft BIP for seamless website 
With all respect to your experience, I think you're wrong, for one reason.
2fa auth doesn't *remove* the need of password. It actually *adds* yet
another layer, which complicates stuff for average user. Common user, which
is not paranoid enough (like me) simply don't think he has anything to
hide, so they simply don't see why they should *complicate* their live with
2fa, backing up their phone etc.
In the oposite, authentication based on bitcoin wallet could make the
process much easier and remove the need of passwords at all, because people
*already* care about safe storage of their coins.

@_date: 2014-04-04 17:28:27
@_author: slush 
@_subject: [Bitcoin-development] Draft BIP for seamless website 
Ideally you should not reuse the address, so the website will need more
addresses or bip32 xpub anyway.
By using wallet address and accidentally using such address in some
transaction, you may be leaking your identity with with other business -
think about Silkroad (sorry Mike :-).
 By using derived key, you can be sure your identity won't be linked with
any other activity on the internet.
I mean, what is the difference between doing that, and id with a login/pass
== your identity.
*)  There's plenty of websites which do need authentication but don't need
to know your bank account / bitcoin address at all. Facebook, Gmail,
Twitter ...
Ideally, the user should not care about "what address do I use for this
service", because in the future user should not care about addresses at all
(handling of private keys is already eliminated by bip32, handling of raw
addresses may be eliminated soon by bip70 or similar solutions).
I can imagine that the private/public data will be derived automatically
from some secret master key (ideally derived from bip32 seed, which is
already secured well by the user) and the URL of the service.

@_date: 2014-04-04 17:42:35
@_author: slush 
@_subject: [Bitcoin-development] Draft BIP for seamless website 
I see the plugin as a temporary solution and we'll eliminate the plugin
once there'll be any way to talk to USB HID directly from browser (which is
not possible yet, but there's some effort already).

@_date: 2014-04-08 14:43:30
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
After some off-list discussion about details with wallet developers, it
seems that structure
fulfill requirements of all wallet developers around, including myTrezor,
Electrum, Multibit, Wallet32 and other software is willing to adapt once
anything will be standardized (i.e. they don't care).
Because I think that everybody told their comments to the topic already and
because it seems that there's quite wide agreement on that, I would like to
close the discussion and finally implement these paths into our software.

@_date: 2014-04-08 15:40:05
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
Of course it is purely client-side issue, but it matters.
There's actually no reason to generate, backup and store individual seeds
for various coins and purposes. User can handle all his identities and
altcoins with single seed, avoiding potential issues with using wrong seed
for other purposes.
Actually with accounts and cointypes in the path, you can have all your
crypto funds stored on single seed, which I see as very comfortable
But to gain advantages of such solution and avoid reusing the same path
across blockchains, we need to separate the space, which is achieved by
Serialization magic of bip32 seed is in my opinion completely unnecessary.
Most of software does not care about it anyway; You can use xprv/xpub pair
for main net, testnet, litecoin, dogecoin, whatevercoin.
Instead using the same seed (xprv) and then separate the chains *inside*
the bip32 path seems more useful to me.

@_date: 2014-04-08 15:43:49
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
It is dangerous to expect that other seed than "xprv" does not contain
bitcoins or that "xprv" contains only bitcoins, because technically are
both situations possible. It is still safer to do the lookup; the magic
itself is ambiguous.

@_date: 2014-04-08 17:41:06
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
I've discussed the solution of "Litecoin seed" in BIP32 HMAC with Litecoin
devs already, and after long discussion we've concluded that it is
generally bad idea.
When changing "Bitcoin seed" constant to something different, same
*entropy* will produce different *master node*. That's actually the
opposite what's requested, because xprv serialization format stores *node*,
not *entropy*. By changing HMAC constant, you still won't be able to store
one node and derive wallets for multiple coins at same time.
This is in practice almost the same as your suggestion, except that
Actually I don't understand why there's such disagreement about "cointype"
level here, what it breaks? I see it as the cleanest solution so far. It is
forward and backward compatible, does need any special extension to bip32
(to be strict, bip32 says "Bitcoin seed", so client using "Litecoin seed"
cannot be "bip32 compatible").
Of course, the problem of "cointype" can be solved in zillion ways, but
still using cointype in bip32 path seem to be the most elegant way so far,
because it fullfill all requirements for single backup, for separating
pubkeys and for handling all coins by one master...

@_date: 2014-04-08 17:46:04
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
We're going to write down BIP describing such structure. If any wallet want
to be BIP XX compatible, then it has chance to. Of course if any wallet
want to use another format, then it cannot call itself BIP XX compatible,
thus nobody will expect that such software will see/recover all keys
generated by BIP XX wallet.
It still doesn't mean that bitcoinj or Electrum cannot share the bare
minimum of BIP XX. Of course if somebody will use Electrum for 2to3
transactions and then move wallet to client which does not offer such
feature, it won't work. But I don't see that as a problem.
If some developers agree on some specific BIP, then it should be cross
compatible.  Of course if somebody implements BIP XX in different way, then
it isn't BIP XX compatible.
I propose we keep our chains deliberately separate and only try
Of course, if somebody don't want to generate compatible bip32 paths, no
problem. It will be the same situation as now.

@_date: 2014-04-08 18:24:14
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
I didn't mean "Bare minimum of some spec", but "spec describing bare
minimum", which is different. I'm sorry for confusion.

@_date: 2014-04-09 22:12:17
@_author: slush 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
I believe there're plenty bitcoind instances running, but they don't have
configured port forwarding properly.There's uPNP support in bitcoind, but
it works only on simple setups.
Maybe there're some not yet considered way how to expose these *existing*
instances to Internet, to strenghten the network. Maybe just self-test
indicating the node is not reachable from outside (together with short
howto like in some torrent clients).
These days IPv6 is slowly deploying to server environments, but maybe
there's some simple way how to bundle ipv6 tunnelling into bitcoind so any
instance will become ipv6-reachable automatically?
Maybe there're other ideas how to improve current situation without needs
of reworking the architecture.

@_date: 2014-04-09 22:31:03
@_author: slush 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
Another idea: Integrate torrent download of bootstrap.dat into bitcoind.
Normal user (especially a beginner) won't learn how to download bootstrap
separately and import it into bitcoind; he simply give up the
synchronization once he realize it takes too much time. From my experience
downloading the bootstrap significantly improves catching the blockchain,
which may attract some more users to run bitcoind.
Not sure about C++, but simple torrent client in python is like 30 lines of
code (using libtorrent).

@_date: 2014-04-09 22:50:08
@_author: slush 
@_subject: [Bitcoin-development] Bitcoind-in-background mode for SPV 
We definitely *need* lightweight bitcoin router / "core" which can be
easily deployed anywhere. No disagreement here.
I just wanted to remind that there're actually much more running nodes
*already* and maybe converting those hidden nodes to publicly reachable
nodes may be way easier than attracting fresh instances.
To the idea of bundled core with SPV clients - it won't improve anything,
in my opinion. SPV wallets are not running long-term (maybe Multibit team
has any better stats) so blockchain catching will turn the computer to be
unusable everytime user starts the wallet; that's exactly the reason why
people choose SPV wallets over full blockchain wallets.
Not saying that SPV clients usually aren't reachable from outside, which
turns the topic back to my ideas about motivating users to expose their
existing instances over Internet.

@_date: 2014-04-23 20:01:57
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
...Except that you're loosing flexibility (serialization, deserialization)
which gives you BIP32 node.
I see "bip32 seed" as some transitional, internal state from raw entropy to
bip32 master node and this seed should not be handled by the end user in
any form. In the oposite, well-serialized bip32 node (in xpriv, or even in
mnemonic format) can be used very widely and have no downsides against
using raw "bip32 seed".
I also don't care too much about altcoins, but people want them so me, as
infrastructure developer, need to think about it. And I don't see any
reason for breaking compatibility between Bitcoin and other altcoins. I
would be happier if there will be another sentence than "Bitcoin seed", but
honestly, who cares. It is just some magic string for hashing the raw
The truth is that even existing software which handle bip32 don't care
about 'version' at all. I think that "xpub/xprv" distinction is the only
useful feature of version, so user se if it stores public or private
But using prefixes which doesn't enforce anything is even more dangerous.
If somebody exports node "dogeblablabla", it creates false exceptations
that there's only dogecoin stored.
 Marek

@_date: 2014-04-23 20:18:16
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
For those who don't follow github pull requests regularly; there's pull
request for BIP64 defining HD wallet structure as discussed in this thread:

@_date: 2014-04-23 21:06:02
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
Using higher gap limit in the software is not prohibited, but then it
breaks the standard "as is", in mean that importing such wallet to another
BIP64 wallet won't recover the funds properly, without proper settings of
gap limit...
Gap limit 20 is the most sane defaults for majority of users (actually I
think it is a bit higher than is really necessary for 99% users) and
majority of users won't need to change it at any time.

@_date: 2014-04-23 21:46:39
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
We do not want BIP64 to be incompatible with BIP32 in any way. BIP64 is
just set of some recommendations for wallet developers how to browse bip32
Modifying serialization format would break the compatibility.
However we have our solution for storing wallet birth time, which is out of
scope of BIP64, but we'll communicate it as soon as we'll write down that
idea to some more specific format.

@_date: 2014-04-23 21:57:46
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
Wallet don't see UTXO until it scans all branches/accounts on HD node

@_date: 2014-04-23 23:07:36
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
No, because one of requirement of BIP64 is to do not mix addressess between
accounts. Without handling those accounts fully, it won't pass this
("This level [accounts] splits the key space into independent user
identities, so the wallet never mixes the coins across different accounts.")

@_date: 2014-08-08 02:29:31
@_author: slush 
@_subject: [Bitcoin-development] Miners MiTM 
AFAIK the only protection is SSL + certificate validation on client side.
However certificate revocation and updates in miners are pain in the ass,
that's why majority of pools (mine including) don't want to play with

@_date: 2014-08-08 04:22:42
@_author: slush 
@_subject: [Bitcoin-development] Miners MiTM 
Although 140 BTC sounds scary, actually it was very minor issue and most of
miners aren't even aware about it.
TLS would probably make the attack harder, that's correct. However if
somebody controls ISP routers, then MITM with TLS is harder, yet possible.

@_date: 2014-01-20 18:42:37
@_author: slush 
@_subject: [Bitcoin-development] BIP0039: Final call 
Hi all,
during recent months we've reconsidered all comments which we received from
the community about our BIP39 proposal and we tried to meet all
requirements for such standard. Specifically the proposal now doesn't
require any specific wordlist, so every client can use its very own list of
preferred words. Generated mnemonic can be then applied to any other
BIP39-compatible client. Please follow current draft at
Because we're quickly moving towards release of Trezor firmware and we need
to finalize this part of the firmware, we're asking for the last comments
to current BIP39 draft.

@_date: 2014-01-20 22:47:56
@_author: slush 
@_subject: [Bitcoin-development] BIP0039: Final call 
Wordlist is necessary for the step [seed]->[mnemonic]. Step
[mnemonic]->[bip32 root] doesn't need any wordlist, there's just hashing
For this reason client can generate whatever mnemonic and unless all
clients use the same process [mnemonic]->[bip32 root], the result is the
Trezor generates the seed and transforms it to mnemonic (which is then
shown on internal display). Generating the mnemonic outside the client-side
(computer) is one of main functionality of Trezor.

@_date: 2014-01-21 00:18:16
@_author: slush 
@_subject: [Bitcoin-development] BIP0039: Final call 
On Tue, Jan 21, 2014 at 12:06 AM, Christophe Biocca <
That's exactly our attitude. We realized that have a community-wide
agreement on the wordlist itself is simply imposible, so to reach at least
some consensus we split the proposal to two parts - one what is essential
to call itself a "bip39 compatible", i.e. converting the mnemonic to bip32
node and second which is optional, including our proposed wordlist, which
has some advanced features like checksums etc. Now it is up to client
developers to decide if they really insist on their superior wordlist or if
they'll implement checksums following the full specification.
Odds are no one will go that route.
At least Trezor and bitcoinj (Multibit) seems to be going in this way,
which is 100% of clients which expressed interest in bip39 :-).

@_date: 2014-07-17 19:22:36
@_author: slush 
@_subject: [Bitcoin-development] Decentralizing ming 
To my knowledge, Satoshi left the project before mining pools got a

@_date: 2014-06-19 22:26:41
@_author: slush 
@_subject: [Bitcoin-development] BlockPow: A Practical Proposal to prevent 
Well, I don't want to start flamewar (and this topic has potential!), but
the *real* reason why there isn't such infrastructure is that although GBT
as a protocol *does* support of decentralized building of blocks, it is
*extremely* resource consuming to validate these shares on pool side.
With GBT, simply hashing the block header is not enough, because pool
cannot rely on anything provided by the client. Its not only about things
like withdrawal attacks, but more about hidden bugs in various miners. It
is extremely hard to do full validation for *every* of submitted shares.
Although I see benefits of GBT and I see limits of Stratum, I don't think
that supporting full GBT validation have economic sense for any medium
sized pool, because such pool would need multiply his running costs on
servers many times.
that can be accomplished in an economy that has a division of labor*,
and see some misbehavior at the edges, and decide that rather than
fixing the misbehavior we should throw out the entire concept of labor
Well written! This reminds me - what about Stratum + SPV validation on
miner side?
With SPV, miner cannot choose his own transactions, so it is not fully
decentralized, but at least miner can detect (in real time) two major pool
misbehaviours - selfish mining (building private blockchain) and chain
forking (not working on longest known blockchain).
I read such proposal about Stratum + SPV on reddit and I actually like it;
It removes major drawbacks of "centralized" Stratum mining, yet is gives
tools to miners to instantly switch to fallback pool when something wrong
is happening.

@_date: 2014-06-19 22:55:48
@_author: slush 
@_subject: [Bitcoin-development] BlockPow: A Practical Proposal to prevent 
Miner issues are just one thing what came to my mind. What about validating
transactions? How the pool can be sure that miner is running up to date
bitcoind which do full validation of transactions? Not talking that if
every miner takes his own set of transaction, pool need to calculate merkle
root for every submit, to check its correctness.
I don't think it *cannot* be done, it is just extremely hard and there's no
economic motivation for such complication on pool side. Just see current
pools, they are full of security and stability bugs even while using such
trivial protocol like Stratum...

@_date: 2014-06-24 16:32:17
@_author: slush 
@_subject: [Bitcoin-development] Proposed BIP 70 extension 
Sounds like marketing bullshit to me. It does not have even statistical
meaning; well, you can "save" a lot of satoshis, but nobody tell you that
the merchant cut you on BTC/USD exchange rate in tens of %.
Payment protocol should not contain these fictional data, which has no real
meaning for the payment itself. Put these marketing claims to memo field

@_date: 2014-06-25 16:15:01
@_author: slush 
@_subject: [Bitcoin-development] Proposed BIP 70 extension 
Good standard must be explicit as much as possible. Having million optional
fields with ambiguous meaning is even worse than not having these fields.
HTTP status codes are good example. There are hundreds of them, still
applications understands just few of them, because other have ambiguous
meaning and software don't know how to handle them.
Good example of such over-engineering is also XMPP. XMPP has milions
extensions and features, but look at Jabber clients; call yourself lucky
when you can send messages and files, although there're various extensions
like searching for contacts (something which has be working in ICQ decade
ago), voice support, end to end encryption or alerting users. These
features are defined, but not widely implemented, because its definition is
vague or the feature is abused because of poor design.
Please don't over-engineer payment protocol.
Thank you for your attention.

@_date: 2014-03-13 17:37:02
@_author: slush 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Internal accounting in satoshis.
Display based on locale.
Problem solved.

@_date: 2014-03-25 19:13:36
@_author: slush 
@_subject: [Bitcoin-development] Tree-chains preliminary summary 
I fully agree, please keep friendly environment on this list. Btw I also
met people who were making fun about Peter's reactions on bitcoin-dev.

@_date: 2014-03-28 15:59:47
@_author: slush 
@_subject: [Bitcoin-development] New BIP32 structure 
I agree that 'version' field of bip32 is not necessary and xpriv/xpub
should be enough for all cases; there's actually no need to use different
BIP32 roots for different altcoins.
I'm happily using one xpub for Bitcoin/Testnet/Litecoin at once, and by
having the "cointype" distinction in the bip32 path itself, I'm sure that I
don't reuse the same pubkey across blockchains which may be a privacy issue

@_date: 2014-05-03 18:02:27
@_author: slush 
@_subject: [Bitcoin-development] "bits": Unit of account 
Excellent points Christophe!
Although moving to 1e-6 units is fine for me and I see advantages of doing
this, I don't get that people on this mailing list are fine with calling
such unit "bit". It's geeky as hell, ambiguous and confusing.
On Sat, May 3, 2014 at 5:48 PM, Christophe Biocca <

@_date: 2015-01-23 15:51:02
@_author: slush 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
is any progress or even discussion in this area?
I don't insist on any specific solution, but this is becoming a real issue
as hardware wallets are more widespread. I'm sitting next to TREZOR for 40
minutes already, because it streams and validate some complex transaction.
By using proposed solution, such signature would be a matter of few seconds.
That's also not just about time/resource/hw cost optimization. I'm talking
about possibility of huge simplification of the firmware (=security FTW),
because 50% of actual codebase is solving this particular downside of
Bitcoin protocol.
So, there's real world problem. On which solution can we as a community
find a wide agreement?

@_date: 2015-01-23 16:40:39
@_author: slush 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
Thanks Alan for a nice summary. I also agree that such stuff should be
implemented at some point. Anyway, I would probably not vote for doing hard
fork *just* for this change, but if I remember well, there're other ideas
flying around in the air and waiting for hardfork...

@_date: 2015-01-23 16:47:41
@_author: slush 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
Correct, plus the most likely scenario in such attack is that the malware
even don't push such tx with excessive fees to the network, but send it
directly to attacker's pool/miner.

@_date: 2015-01-23 17:18:34
@_author: slush 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
Can you send me any reference about this? Of course if that solves the
problem, hard fork would not be necessary anymore. I'm just not aware of
Can you help me understand whats taking 40 minutes here? Thats a
To sign transaction with hundreds of inputs on device with limited memory
capabilities, I need to stream all previous transactions into device, for
every signed input.
That means roughly 200^2 transaction verifications for 200 inputs to sign.
Very slow, but does not limit the device for any particular size of signed

@_date: 2015-01-23 17:35:23
@_author: slush 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
Oh, now I got the 'soft-fork' alternative. If that means that *senders* to
Trezor need to be nice guys and use some special outputs, then it's,
obviously, no-go solution.
I understand political aspect around hard-fork. Anyway, are there any other
pending projects waiting for hard-fork? Maybe we should join our effort in
some way.

@_date: 2015-01-23 18:40:54
@_author: slush 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
Yes, the step you're missing is "and build the table". Dynamic memory
allocation is something you want to avoid, as well as any artifical
restrictions to number of inputs or outputs. Current solution is slow, but
there's really no limitation on tx size.
Plus there're significant restrictions to memory in embedded world.
Actually TREZOR uses pretty powerful (and expensive) MCU just because it
needs to do such validations and calculate such hashes. With
SIGHASH_WITHINPUTVALUE or similar we may cut hardware cost significantly.

@_date: 2015-01-23 20:19:40
@_author: slush 
@_subject: [Bitcoin-development] SIGHASH_WITHINPUTVALUE 
You're right, there can be done some optimizations. Workarounds of
workaround. All this adds complexity, which reduces the security.

@_date: 2015-03-12 04:43:47
@_author: slush 
@_subject: [Bitcoin-development] Electrum 2.0 has been tagged 
different scheme for key derivation (myTREZOR uses full BIP44, Multibit HD
uses BIP44 with first account only and GreenAddress uses another scheme
because it's multisig only wallet).
I disagree with the need of some version "magic flags" or creation date
stored in the mnemnonic, for those reasons:
a) If we fail in the way how mnemonic algo is defined, then some magic,
extra version flag won't save our asses, because we'll fail in meaning of
its meaning. Then it will be completely useless, as implementations cannot
rely on it. I know Thomas was sound proponent of this solution, but he was
unable to give any reasonable rules about who/how define meaning of version
b) "Creation date" is just a short-term hack. Considering that mnemonic
words are kind of cold storage (longterm storage), it *really* does not
make much difference in 2020, if your wallet has been created in 02/2014 or
10/2016. If there's performance issue with scanning of the blockchain,
creation date don't save our asses. We need to find another solution, and
as a bonus, we don't need users to know some weird numbers on top of
mnemonic itself.
between wallet providers. There is some recommendations regarding the
wordlists to help with things such as predictive text, so mobile apps can
easily predict the word being typed in after a few chars etc.
Exactly! After some community feedback, we changed BIP39 algo to be one-way
only, which means you can use *any* wordlist to create the mnemonic, and
any other implementation can derive BIP32 root node even without knowing
that particular wordlist. Namely this has been changed because of
constructive criticism of ThomasV, and from discussion on the mailing list
I had a feeling that we've found a consensus. I was *very* surprised that
Electrum 2.0 started to use yet another algo "just because".
Shortly said, I think BIP39 does perfect job and there's no need to use
anything else.

@_date: 2015-05-07 00:30:12
@_author: slush 
@_subject: [Bitcoin-development] Block Size Increase 
I don't have strong opinion @ block size topic.
But if there'll be a fork, PLEASE, include SIGHASH_WITHINPUTVALUE (
 or its alternative. All
developers of lightweight (blockchain-less) clients will adore you!
On Thu, May 7, 2015 at 12:12 AM, Matt Corallo
