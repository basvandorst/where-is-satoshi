
@_date: 2017-07-12 03:27:32
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Updating the Scaling Roadmap 
Just a quick note in favor of an updated roadmap (some may object to that
label, but I think it's fine).  When you and your friends are planning your
weekly movie outing, it's very helpful to have someone who knows the group,
knows what films are playing, checks people's preferences, mails around
proposals, updates with corrections, keeps a list of choices for future
weeks, etc.  (Certainly not the same as imposing an agenda, except when the
coordinator gets pushy.)
Core veterans like those on this thread are well placed to compile (not
decree) such a document - basically an informed view of what looks likely
to get rough consensus, and in what order.  *Of course* some will dispute
the priorities etc, but it's my experience that if everyone virtuously
refrains from this kind of coordination effort, often the weekend rolls by
without a film.
Agreed that specific deadlines often create more problems than they solve,
but even without dates, clarifying priorities (eg, segwit before HF) is
still useful.
All this is aside from the fact that I have many criticisms of the "movies
chosen" so far and the criteria used to choose them - another thread
(basically, I support an interpretation of "consensus" that takes more note
of non-dev constituents).  The consensus-marshaling effort is still
important, and appreciated.
On Tue, Jul 11, 2017 at 8:21 PM, Paul Sztorc via bitcoin-dev <

@_date: 2017-06-07 00:17:37
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] User Activated Soft Fork Split Protection 
While this isn't an unreasonable proposal, it will orphan blocks from any
miner who isn't running it (or BIP148) by Aug 1, right?  That seems rather
rushed for a non-backwards-compatible SF, especially since in practice,
miners are unlikely to deploy it until it comes bundled with some version
of the Segwit2x HF code.
I realize this is a touchy topic but - how much hard evidence is there that
there *will* be significant disruption if miners simply ignore both this
and BIP148?  Correct me but afaict, BIP148 has ~0% hashrate support.
Unless the HF code is ready and agree on soon (say by Jul 1), my vote is to
keep the main chain backwards-compatible, especially if evidence of miner
support for BIP148 doesn't materialize soon.  It seems less disruptive for
recently-deployed BIP148 nodes to revert than to ask every miner in the
system to quickly upgrade or get orphaned.
Just my view, I respect that others will differ.
On Tue, Jun 6, 2017 at 9:54 PM, James Hilliard via bitcoin-dev <

@_date: 2017-06-07 12:44:32
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] User Activated Soft Fork Split Protection 
This is not the safest defense against a split.  If 70% of miners run
"splitprotection", and 0.1% run BIP148, there's no "safety"/"defense"
reason for splitprotection to activate segwit.  It should only do so if
*BIP148* support (NB: not just segwit support!) >50%.
The truly defensive logic is "If the majority supports orphaning non-segwit
blocks starting Aug 1, I'll join them."
If the real goal of this BIP is to induce miners to run segwit, then fair
enough.  But passing it off as the safest defense is bad faith.
On Wed, Jun 7, 2017 at 10:10 AM, Erik Aronesty via bitcoin-dev <

@_date: 2017-06-07 15:39:48
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] User Activated Soft Fork Split Protection 
You're missing my point.  "As soon as a simple majority supports it" - what
is "it"?  BIP148?  Or "deferring to the miner consensus on BIP148"?  It's
the difference between supporting one side of a vote, vs supporting
deferral to the outcome of the vote.
Or if you mean, the safe thing for miners is to orphan non-segwit blocks
Aug 1 *regardless* of the miner consensus (since the economic consensus
might differ), then there's zero need for this BIP: they should just run
As I said: this BIP should be corrected to only orphan if >50% signal for
BIP148.  Or, define two bits, one meaning "I support BIP148," the other "I
will go w/ the miner majority on BIP148."  Fudging them this way is
Without this option, a miner has to guess whether a split will be
economically impacting.   With this option, his miner will automatically
switch to the chain least likely to get wiped out... as soon as a simple
majority of miners supports it.
On Wed, Jun 7, 2017 at 12:44 PM, Jacob Eliosoff

@_date: 2017-06-09 00:40:57
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] The BIP148 chain split may be inevitable 
I've been trying to work out the expected interaction between James
Hilliard's BIP91 [1] (or splitprotection [2], or Segwit2x [3], which both
use variants of BIP91 activation) and the BIP148 UASF [4].  Some of this is
subtle so CORRECTIONS WELCOME, but my conclusions are:
1. It's extremely unlikely BIP91-type logic can activate segwit in time to
avoid a BIP148 chain split.
2. So, in practice all we can do is ensure the BIP148 split is as painless
as possible.
REASONING:  First, some dates.  BIP148, whose deadline is already deployed
and thus unlikely to be postponed, starts orphaning non-segwit blocks on
midnight (GMT) the morning of August 1.  Meanwhile, here are Bitcoin's
rough expected next four difficulty adjustment dates (they could vary by
~1-3 days depending on block times, but it's unlikely to matter here):
1. June 17
2. June 30
3. July 13
4. July 27
If Segwit activates on adj date  or later (August), it will be too late
to avoid BIP148's split, which will have occurred the moment August began.
So, working backwards, and assuming we want compatibility with old BIP141
- Segwit MUST activate by adj  (~July 27)
- Therefore segwit MUST be locked in by adj  (~July 13: this is
inflexible, since this logic is in already-deployed BIP141 nodes)
- Therefore, I *think* >50% of hashpower needs to be BIP91 miners,
signaling bit 1 and orphaning non-BIP91 (ie, BIP91's bit 4 must activate),
by adj  (June 30)?
- Therefore, as currently designed, BIP91 bit 4 must be locked in by adj (June 17)
- Therefore, >=80% of hashrate must start signaling BIP91's bit 4 by a few
days ago...
There are ways parts of this could be sped up, eg, James' "rolling
100-block lock-in periods" [5], to get BIP91 signaling bit 1 sooner.  But
to be compatible with old BIP141 nodes, >50% of hashrate must be activated
BIP91 miners by ~June 30: there's no fudging that.
So, it seems to me that to avoid the BIP148 split, one of two things would
have to happen:
a) 95% of hashrate start signaling bit 1 by ~June 30.  Given current stat
is 32%, this would basically require magic.
b) BIP91 is deployed and >50% (80% or whatever) of hashrate is *activated*
BIP91 miners by ~June 30, ~3 weeks from now.  Again, much too soon.
So, I think the BIP148 split is inevitable.  I actually expect that few
parts of the ecosystem will join the fork, so disruption will be bearable.
But anyway let me know any flaws in the reasoning above.
[1] [3] [4] [5]

@_date: 2017-06-09 01:23:17
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] The BIP148 chain split may be inevitable 
Ah, two corrections:
1. I meant to include an option c): of course >50% of hashpower running
BIP148 by Aug 1 avoids a split.
2. More seriously, I misrepresented BIP148's logic: it doesn't require
segwit *activation*, just orphans non-segwit-*signaling* (bit 1) blocks
from Aug 1.
I believe that means 80% of hashrate would need to be running BIP91
(signaling bit 4) by ~June 30 (so BIP91 locks in ~July 13, activates ~July
27), not "a few days ago" as I claimed.  So, tight timing, but not
Sorry about the errors.
On Fri, Jun 9, 2017 at 12:40 AM, Jacob Eliosoff

@_date: 2017-06-10 14:04:32
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] The BIP148 chain split may be inevitable 
Just a quick follow-up on BIP91's prospects of avoiding a BIP148 chain
split, because I may have left an overly pessimistic impression -
In short: the timing isn't as dire as I suggested, BUT unless concrete
progress on a plan starts taking shape, esp miner support, *the split is
indeed coming.*
THE GOOD NEWS: several refinements have been noted which could get BIP91
(or splitprotection, Segwit2x, etc) deployed faster:
- The lock-in window could be shortened, eg to splitprotection's 504 blocks
(3.5 days)
- Of course the 80% threshold could just be reduced, eg to
splitprotection's 65%
- BIP91 nodes could start signaling on bit 1 the moment bit 4 reaches
lock-in, rather than waiting another period until it  "activates".
 (Orphaning of non-bit-1-signaling blocks would probably also have to start
at or shortly after the same time [1].)
Combining these approaches, *July 26* is an approximate hard deadline for
significantly less tight than my previous June 30 (or my original,
erroneous "a few days ago").
THE BAD NEWS: no one should underestimate the steps that would need to be
completed by that deadline:
1. Coordinate on a solution (BIP91, splitprotection, Segwit2x, BIP148
itself, ...)
2. Implement and test it
3. Convince >50% of miners to run it [2]
4. Miners upgrade to the new software and begin signaling
In particular,  afaict a lot of convincing is still needed before miner
support for any of these reaches anything like 50%.  (With the exception of
Segwit2x, but it has the additional handicap that it probably needs to
include deployable hard fork code, obviously ambitious in 1.5 months.)
[1] See Saicere's comment:
 and related
discussion at [2] Note that >50% need to run the *solution*, eg BIP91; old BIP141 nodes
signaling segwit support do *not* count, since they won't orphan non-bit-1
blocks.  The impending split isn't between nodes that support segwit vs
don't, but between those that reject non-segwit-supporting blocks vs don't.
On Fri, Jun 9, 2017 at 1:23 AM, Jacob Eliosoff

@_date: 2017-06-20 18:29:27
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Miners forced to run non-core code in order to 
If segwit is activated before Aug 1, as now seems likely, there will be no
split that day.  But if activation is via Segwit2x (also likely), and at
least some nodes do & some don't follow through with the HF 3mo later
(again, likely), agreed w/ Greg that *then* we'll see a split - probably in
Sep/Oct.  How those two chains will match up and how the split will play
out is anyone's guess...
On Jun 20, 2017 6:16 PM, "Hampus Sj?berg via bitcoin-dev" <
Well, they're doing some kind of "pre-signaling" in the coinbase at the
moment, because the segwit2x project is still in alpha-phase according to
the timeline. They're just showing commitment.
I'm sure they will begin signaling on version bit 4/BIP91 as well as
actually running a segwit2x node when the time comes.
Segwit2x/BIP91/BIP148 will orphan miners that do not run a Segwit2x (or
BIP148) node, because they wouldn't have the new consensus rule of
requiring all blocks to signal for segwit.
I don't believe there would be any long lasting chainsplit though (because
of the ~80% hashrate support on segwit2x), perhaps 2-3 blocks if we get
2017-06-20 23:49 GMT+02:00 Gregory Maxwell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org

@_date: 2017-06-20 18:57:34
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Miners forced to run non-core code in order to 
I could be wrong, but the latest BIP91 implementation (also included in
Segwit2x) cuts the activation period to 336 blocks (2.33 days).  (This has
been updated at
  So if 80%
of hashpower is actually running that code and signaling on bit 4 by July
25 or so, then those 80+% will start orphaning non-bit-1 blocks before Aug
1, and we avoid a split.
There may still be a few non-bit-1 blocks that get orphaned after Aug 1,
because they're mined by old BIP141 nodes.  But it seems like very few
miners won't be signaling either Segwit2x *or* BIP141 by then...
Make sense?
On Tue, Jun 20, 2017 at 6:48 PM, Mark Friedenbach

@_date: 2017-06-20 19:01:14
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Miners forced to run non-core code in order to 
(That is: "...because they're mined by old non-Segwit2x nodes that *aren't
signaling bit 1 support*", ie, that support neither Segwit2x nor old segwit)
On Tue, Jun 20, 2017 at 6:57 PM, Jacob Eliosoff

@_date: 2017-06-21 00:05:53
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Miners forced to run non-core code in order to 
Well, this Saturday's "Chinese roundtable" statement from a bunch of
miners ( says they intend "NYA" in the
coinbase as support for "the New York consensus SegWit2x program btc1 (
 whose code includes the (accelerated 336-block)
BIP 91 change.  So, other facts or interpretations could come to light, but
until they do we should probably assume that's what the "NYA" (which just
broke 80% over the last 24h) means.
On Tue, Jun 20, 2017 at 10:11 PM, Mark Friedenbach

@_date: 2017-05-26 13:47:11
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Barry Silbert segwit agreement 
Forgive me if this is a dumb question.  Suppose that rather than directly
activating segwit, the Silbert/NYC Segwit2MB proposal's lock-in just
triggered BIP141 signaling (plus later HF).  Would that avoid
incompatibility with existing BIP141 nodes, and get segwit activated
sooner?  Eg:
- Bit 4 (or bit 5 or whatever, now that BIP91 uses 4) signals support for
"segwit now, HF (TBD) at scheduled date (Nov 23?)"
- If bit 4 support reaches 80%, it locks in two things: the scheduled HF
(conditional on segwit), and *immediately* turning on bit 1 (BIP141 support)
I realize this would still leave problems like the aggressive HF schedule,
possible chain split at the HF date between Segwit2MB nodes and any
remaining BIP141 nodes, etc.  My focus here is how incompatibility with
existing nodes could be minimized.
(BIP91 could also be used if BIP141 support still fell short of 95%.  But
if Segwit2MB support reaches 80%, it seems likely that an additional 15%
will support BIP141-without-HF.)

@_date: 2017-05-26 16:10:38
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Barry Silbert segwit agreement 
Just to clarify one thing, what I described differs from BIP91 in that
there's no orphaning.  Just when Segwit2MB support reaches 80%, those 80%
join everyone else in signaling for BIP141.  BIP91 orphaning is an optional
addition but my guess is it wouldn't be needed.

@_date: 2017-05-30 16:10:04
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148 
I'd like to know this too.  Is it just that a 4MB blockmaxweight would
theoretically allow ~4MB blocks (if ~all witness data), which is too big?
Or is there a more subtle reason we still need blockmaxsize after a HF?
On May 30, 2017 9:28 AM, "Jorge Tim?n via bitcoin-dev" <
Why not simply remove the (redundant after sw activation) 1 mb size
limit check and increasing the weight limit without changing the
discount or having 2 limits?
On Wed, May 24, 2017 at 1:07 AM, Erik Aronesty via bitcoin-dev
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org

@_date: 2017-05-30 23:07:43
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148 
============================== START ==============================
Maybe there's some hole in Jorge's logic and scrapping blockmaxsize has
quadratic hashing risks, and maybe James' 10KB is too ambitious; but even
if so, a simple 1MB tx size limit would clearly do the trick.  The broader
point is that quadratic hashing is not a compelling reason to keep
blockmaxsize post-HF: does someone have a better one?
On May 30, 2017 9:46 PM, "Jean-Paul Kogelman via bitcoin-dev" <

@_date: 2017-11-03 23:37:06
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Bitcoin Cash's new difficulty algorithm 
I'm no BCH fan, but I agree with Scott that changes to the DAA may be of
more than purely theoretical interest for BTC.  Anyway just for those
interested, below is an algo I've been playing with that adjusts difficulty
every block, based only on the previous block's time and difficulty.  I
tested it a bit and it seems to adapt to hashrate swings pretty well.
weight_n = 1 - e^-(blocktime_n / 1 hr)    # 1 hr = exp moving avg window -
too short?
adj_n = (10 min / blocktime_n) - 1
difficulty_(n+1) = difficulty_n * (1 + weight_n * adj_n)
It could also be tweaked to make the *historical* avg block time ~exactly
10 minutes, ie, to target > 10 min if past blocks were < 10 min.  This
would, eg, make mapping future block numbers to calendar times much more
On Nov 3, 2017 7:24 AM, "Scott Roberts via bitcoin-dev" <

@_date: 2017-11-06 14:21:28
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Generalised Replay Protection for Future Hard 
Thanks Mats, this proposal makes sense to me (especially the idea of
fork-specific addresses).  It prevents replay across forks, and makes it
easy for client software, and thus potentially users, to specify which fork
a tx is for.  But, like other (rougher) past proposals I've seen, it does
little to prevent users from accidentally sending on the wrong fork.
Take the specific and common case of non-upgraded wallet software.  Suppose
a HF happens, and becomes the network used by 90% of users.  Will old
wallets still default to the old nForkId (10% legacy chain)?  If so, I'd
expect a lot of accidental mis-sends on that chain.
This is just a gap in your proposal, not a flaw, but it's worth thinking
about less hazard-prone ways wallets could default nForkId.  Perhaps they
could listen to all forks, and default to the one whose last (recent) block
had the highest difficulty?  Or just check those blocks to see if multiple
forks are (nontrivially) active, and if so warn the user and force them to
confirm?  Something like that.
On Nov 6, 2017 7:05 AM, "Mats Jerratsch via bitcoin-dev" <
Presented is a generalised way of providing replay protection for future
hard forks. On top of replay protection, this schema also allows for
fork-distinct addresses and potentially a way to opt-out of replay
protection of any fork, where deemed necessary (can be beneficial for some
L2 applications).
 Rationale
Currently when a hard fork happens, there is ad-hoc replay protection built
within days with little review at best, or no replay protection at all.
Often this is either resource problem, where not enough time and developers
are available to sufficiently address replay protection, or the idea that
not breaking compatibility is favourable. Furthermore, this is potentially
a recurring problem with no generally accepted solution yet. Services that
want to deal in multiple forks are expected to closely follow all projects.
Since there is no standard, the solutions differ for each project,
requiring custom code for every fork. By integrating replay protection into
the protocol, we advocate the notion of non-hostile forks.
Users are protected against accidentally sending coins on the wrong chain
through the introduction of a fork-specific incompatible address space. The
coin/token type is encoded in the address itself, removing some of the
importance around the question _What is Bitcoin?_. By giving someone an
address, it is explicitly stated _I will only honour a payment of token X_,
enforcing the idea of validating the payment under the rules chosen by the
 Iterative Forks
In this schema, any hard fork is given an incremented id, `nForkId`.
`nForkId` starts at `1`, with `0` being reserved as a wildcard. When
project X decides to make an incompatible change to the protocol, it will
get assigned a new unique `nForkId` for this fork. A similar approach like
for BIP43 can be taken here. Potentially `nForkId` can be reused if a
project has not gained any amount of traction.
When preparing the transaction for signing or validation, `nForkId` is
appended to the final template as a 4B integer (similar to [1]). Amending
BIP143, this would result in
Double SHA256 of the serialization of:
    1. nVersion of the transaction (4-byte little endian)
    2. hashPrevouts (32-byte hash)
    3. hashSequence (32-byte hash)
    4. outpoint (32-byte hash + 4-byte little endian)
    5. scriptCode of the input (serialized as scripts inside CTxOuts)
    6. value of the output spent by this input (8-byte little endian)
    7. nSequence of the input (4-byte little endian)
    8. hashOutputs (32-byte hash)
    9. nLocktime of the transaction (4-byte little endian)
   10. sighash type of the signature (4-byte little endian)
   11. nForkId (4-byte little endian)
For `nForkId=0` this step is ommitted. This will immediately invalidate
signatures for any other branch of the blockchain than this specific fork.
To distinguish between `nForkId=0` and `nForkId` hardcoded into the
software, another bit has to be set in the 1B SigHashId present at the end
of signatures.
To make this approach more generic, payment addresses will contain the fork
id, depending on which tokens a payee expects payments in. This would
require a change on bech32 addresses, maybe to use a similar format used in
lightning-rfc [2]. A wallet will parse the address, it will extract
`nForkId`, and it displays which token the user is about to spend. When
signing the transaction, it will use `nForkId`, such that the transaction
is only valid for this specific token. This can be generalised in software
to the point where replay protection *and* a new address space can be
introduced for forks without breaking existing clients.
For light clients, this can be extended by enforcing the coinbase/block
header to contain the `nForkId` of the block. Then the client can
distinguish between different chains and tokens it received on each.
Alternatively, a new P2P message type for sending transactions could be
introduced, where prevOut and `nForkId` is transmitted, such that the lite
client can check for himself, which token he received.
Allowing signatures with `nForkId=1` can be achieved with a soft fork by
incrementing the script version of SegWit, making this a fully backwards
compatible change.
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org

@_date: 2017-11-09 15:45:43
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Generalised Replay Protection for Future Hard 
OK, I see.  On the whole this is the best replay protection solution I've
seen.  In particular, I hope developers of Bech32 and other new address
formats will take a close look at incorporating a fork ID this way.
As I understand you, a private key in cold storage would (of course) remain
valid across HFs, but an *address* would be valid only for the nForkId it
was generated for.  There may be cold-storage-type cases where it's
important for an address to be valid across all chains, ie, to
intentionally allow replay?  But I guess this could just be a special
nForkId value, say -1?

@_date: 2017-11-11 00:18:11
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Generalised Replay Protection for Future Hard 
OK, so nForkId 0 is exactly the "valid on all chains" specifier I was
asking about, cool.  And your LN example (and nLockTime txs in general)
illustrate why it's preferable to implement a generic replay protection
scheme like yours *in advance*, rather than before each fork: all ad hoc RP
schemes I know of break old txs on one of the chains, even when that's not
desirable - ie, they offer no wildcard like nForkId 0.
One comment on your LN example: users would have to take note that nForkId
0 txs would be valid not only on future forks, but on *past* forks too.
Eg, if BCH had been deployed with nForkId 2, then a user setting up BTC LN
txs now with nForkId 0 would have to be aware that those txs would be valid
for BCH too.  Of course the user could avoid this by funding from a
BTC-only address, but it is a potential minor pitfall of nForkId 0.  (Which
I don't see any clean way around.)

@_date: 2017-11-13 10:31:55
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Generalised Replay Protection for Future Hard 
Thanks for the clarification.  How would a tx specify a constraint like
"nForkId>=1"?  I was thinking of it just as a number set on the tx.
Also note that since forks form a partial order, but IDs (numbers) form a
total order, ">=" will miss some cases.  Eg, suppose BCH had forked with
nForkId 2, and then you set up a LN funding tx on BCH with nForkId>=2, and
then Segwit2x forked (from BTC!) with nForkId 3.  The BCH funding tx would
be valid on Segwit2x.  This is more of a fundamental problem than a bug -
to avoid it you'd have to get into stuff like making each fork reference
its parent-fork's first block or something, someone has written about

@_date: 2017-11-15 00:02:48
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] Generalised Replay Protection for Future Hard 
OK, but then it seems to me you have a dilemma for, eg, your LN commitment
tx.  You either give it the specific nForkId of the fork it's created on -
making it invalid on *all* other forks (eg, any future "non-contentious
upgrade" HF that replaces that fork).  Or you give it nForkId 0 - which has
the "BCH tx valid on Segwit2x (& vice versa)" flaw.
It may make sense to revise your proposal to incorporate Luke's
, and make
the fork ID a (block height, hash) pair rather than just a number.  But I
still think the idea of fork-specific addresses is a keeper!

@_date: 2019-03-09 22:25:36
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great 
This principle was only ever a rule of thumb to protect users, not a
commandment from God.  It shouldn't be violated lightly, but that's why
Matt did the legwork to show that the tradeoffs around OP_CODESEPARATOR
justify removing it.
Huh?! The whole point of non-standardness in this context is to (a) make
Like Matt, I understand non-standardness to be specifically for making a
transaction type more difficult to set the stage for a future disabling.
If anyone is actually harmed by this change, let them at least speak up
pseudonymously as others have before.  Backwards compatibility shouldn't
mean letting imaginary implausible cases veto net-beneficial changes.
On Sat, Mar 9, 2019 at 5:21 PM Russell O'Connor via bitcoin-dev <

@_date: 2019-03-12 18:39:28
@_author: Jacob Eliosoff 
@_subject: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great 
Also, if future disabling isn't the point of making a tx type like
OP_CODESEPARATOR non-standard - what is?  If we're committed to indefinite
support of these oddball features, what do we gain by making them hard to
I see questions like "Is it possible someone's existing tx relies on this?"
as overly black-and-white.  We all agree it's possible: the question is how
likely, vs the harms of continued support - including not just security
risks but friction on other useful changes, safety/correctness analyses,
It is so easy to say stuff like this when one's own money isn't what is at
Stepping back for a second here:  I dispute this framing.  My money *is* at
risk, because the value of my bitcoins depends on adoption and feature
growth.  And I've long viewed an absolutist, actual-known-user-indifferent
approach to backwards compatibility as the  impediment to Bitcoin's
adoption and growth.
Again, the point being not to throw caution to the wind, but that a case
like this where extensive research unearthed zero users, is taking caution
too far.
On Tue, Mar 12, 2019, 5:48 PM Matt Corallo via bitcoin-dev <
