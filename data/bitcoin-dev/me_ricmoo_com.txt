
@_date: 2014-08-13 14:00:22
@_author: Richard Moore 
@_subject: [Bitcoin-development] Another weird transaction question... 
Hey all,
Sorry to keep bugging you all, as I slowly verify the blockchain one transaction after another with my own implementation, but I have found another transaction that is obviously correct (as it is verified by the legit client) that has me seeking clarification.
This multisig output script:
  (txid: 274f8be3b7b9b1a220285f5f71f61e2691dd04df9d69bb02a8b3b85f91fb1857)
contains a public key:
Are invalid public keys permitted and silently ignored? Or does the 0x00 prefix have some interesting meaning?
Thanks again,
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2014-08-19 11:30:45
@_author: Richard Moore 
@_subject: [Bitcoin-development] Proposal: Encrypt bitcoin messages 
Oh, I see. I misread, thinking you wanted the dev team to have a private key and share the public key, similar to alerts. But each peer would have a public/private key pair and use something akin to ECDH for a symmetric key and transport using a block cipher?
How would you share the public key? If I were a man-in-the-middle, I could intercept the public key, generate my own and pass that along and then decouple the pipe when the other side shares their public key.
Also, you should not ignore your SSH fingerprint, as you exactly open yourself to mitm attacks.
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2014-07-13 19:32:51
@_author: Richard Moore 
@_subject: [Bitcoin-development] Self-dependency transaction question... 
Hey all,
I'm working on the UTXO database for my Python implementation of bitcoind and have found a situation I did not realize was valid, but since it seems to be, had a quick question.
If you look at block  the 4th transaction's first input uses its own block's 3rd transaction as an input.
My question is, would the other way be valid, that is, could the 3rd transaction of a block, use the 4th transaction from the same block as an input? Or are transactions processed strictly top to bottom?
P.S. If it is valid, another question; what would happen if a transaction was self-referencing? I realize it would be very difficult to find one, but if I could find a transaction X whose input was X and had an output Y, would Y be a new valid utxo, without being a generation transaction input?
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2014-07-19 00:33:13
@_author: Richard Moore 
@_subject: [Bitcoin-development] Signature with negative integer? 
Hey all,
I'm wondering if anyone can help explain to me tx 70f7c15c6f62139cc41afa858894650344eda9975b46656d893ee59df8914a3d...
The input signature script is:
304402206b5c3b1c86748dcf328b9f3a65e10085afcf5d1af5b40970d8ce3a9355e06b5b0220cdbdc23e6d3618e47056fccc60c5f73d1a542186705197e5791e97f0e6582a3201 Which decodes to:
r= 48560432700441876832361368709121298776045893858160378595187765610521057848155
s= -22732680560694206332190468058638664750027418114195068375538144640549433890254
The ECC library I'm using is failing to verify this, which I think makes sense, since I the point needs to be positive, no? But it is obviously valid, as it has been verified and spent. I have tried simply modulo curve.order to positive-ify it, but that didn't seem to work either. Given a point P (with Py < 0) is there some fancy way to bring it into the elliptic curve space, such that Px >= 0 and Py >= 0?
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2014-06-04 15:30:10
@_author: Richard Moore 
@_subject: [Bitcoin-development] Future Feature Proposal - getgist 
Bitcoin development team,
I recently started implementing my own Python full-node, and had an idea, so I?m prowling through BIP 001 for this proposal, which says to e-mail you kind folks to make sure the idea is original (enough) and that there aren?t other existing means to accomplish what I was thinking. :)
The only way to grab all the headers seems to be to serially get one, then the next and so on, as you need the last hash of a headers() call to the next getheaders(). But we are on a peer-to-peer network, potentially able to getheaders() from many peers simultaneously, if we only knew the hash to look for.
What I was thinking is something to the effect of a getgist() command, fully backward compatible (any node not understanding it, can silently ignore it? Otherwise version or services could be used to announce the capability, but that seems like a little overkill). The inputs to getgist() would be similar to getheaders(); version, hash_count, block_locator_hash, stop_hash and an additional field, segment_count. The response would be a normal headers() message, except, not sequential block headers? Rather they would be spaced out, preferably 2000-block-hash-aligned from the first block hash. So, for example, if you have a blockchain with 198,005 blocks, and you passed it the block locator of height 0 (the genesis block), and a segment_count of 25, you would expect (approximately, the actual algorithm needs to be figured out), the block hashes at the following 25 (segment_count) heights:
1, 8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 72000, 80000, 88000, 96000, 104000, 112000, 120000, 128000, 136000, 144000, 152000, 160000, 168000, 176000, 184000, 192000
Which can now be spread across 25 different nodes, fetching the block headers (albeit, out of order, possibly increasing the complexity of the local block chain database) but vastly increasing the speed the whole blockchain can have all headers synced.
I still need to perform some tests to see what type of speed gains there are, but I would suspect it should be segment_count times faster.
Existing methods could be to use checkpoint-ish nodes or bootstrap data files, but these begin relying on semi-cetralizenesses.
Ideas? Suggestions? Concerns? Prior it-ain?t-gonna-works?
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2014-06-05 13:43:38
@_author: Richard Moore 
@_subject: [Bitcoin-development] Future Feature Proposal - getgist 
I was considering names like getcheckpoints() to use the terminology that already seemed to be in place, but they were too long :)
I have been using getheaders() in my thick client to quickly grab all the headers before downloading the full blocks since I can grab more at a time. Even with getblocks(), there is the case for a  getgist() call. Right now you call getblocks(), which can take some time to get the corresponding inv(), at which time you can then start the call to getdata() as well as the next call to getblocks().
With a gist, for example of segment_count 50, you could call getgist(), then with the response, you could request 50 getblocks() each with a block_locator of 1 hash from the gist (and optimally the stop_hash of the next hash in the gist) to 50 different peers, providing 25,000 (50 x 500) block hashes.
<<< inv()
<<< block(), block(), block(), ? (x 500)
Saturates one peer, while leaving the rest un-used. Step 1 and 2 can be repeated and dispatched to different peers, but there is still the latency between the two calls.
<<< inv()
<<< inv(), inv(), inv(), ? (x segment_count, 1 per peer)
<<< block(), block(), block(), ? (x (500 * segment_count), ie. 500 in per peer)
Each peer can be saturated.
I will try to run some experiments this weekend to get numbers as to whether there is actually any performance improvement using a gist, or whether the getdata(), block() latency ends up dominating the time anyways.
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2014-06-09 14:13:19
@_author: Richard Moore 
@_subject: [Bitcoin-development] BIP38 Encrypted Address Discussion 
Hey all again,
I am implementing BIP38 wallets right now, and had another idea I would like to put out there for discussion.
Right now the scrypt pbkdf is (16384, 8, 8) for (N, r, p), but I was wondering if it would make sense to include an extra byte in the address which would encode the parameters used? For now, they are fine, as it takes over 3 minutes to to hash once in my pure-Python implementation in CPython (3 seconds in pypy). But with all the latest scrypt mining ASICS hitting the market, and the difficulty rising of the scrypt alt coins, it may become more profitable in the future to try hacking wallets to gobble up their funds. Currently all the hardware is tuned for (1024, 1, 1) and with adaptive-N, it only targets upgrading the N value, so having p =r = 8 certainly means that hardware won?t affect BIP 38? But who knows in the future if they start making Adaptive-N-r-p ASICS.
It also provides a way to vastly secure more important master keys? Maybe for a key that is cold storage of millions of dollars that won?t be touched for multiple years, I don?t mind waiting an hour on commodity hardware to decrypt it.
I was thinking, for example, if we used 1 byte, c, we could use a formula:
N = 2 ** (c + 11)
r = 2 ** c
p = r
Although, even a full byte is overkill? Maybe we can use the top three bits for something else? With 5 bits, the space becomes:
c = 0 => (1024, 1, 1)  (same as scrypt mining, albeit requires twice the dkLength)
c = 3  => (16384, 8, 8) (current specs)
c = 31 => (2199023255552,2147483648, 2147483648) (highest difficulty, requiring (5.6 * 10 ** 12) Gigabytes of memory per hash)
Anyways, just thinking out loud? I think even this space is too large? We could also use the top 5 bits for N and lower 3 bits of r, p, if more granularity seems more useful (maybe somebody *wants* their passwords easy to parallelize but still difficult to break?)
N = 2 ** (10 + ((c >> 3) & 0x1f))
r = p = 2 ** ((c & 0x07) * 3)
Would put N = [1024, 2048, ..., 2199023255552] and r = p = [1, 8, 64, 512, ..., 2097152]
The biggest issue would be backwards compatibility. The 6P should obviously stay the same, as it ?requires something extra? and the thing required is a passphrase. But maybe we could use one of the reserved bits to indicate that the address is adaptive? The decoded length of the address will also change though, which could pose issues if, for example, bounds checks aren?t being done (bad, but it happens) or in the case of things like python implementations, might assume the length correct an use derived_half2 = decoded[23:] which would now come back with the last byte of derived_half1 and be one byte too long, unchecked, passed into AES, an exception is raised because it is not one 16-byte block. These however seem assumptions that the developer should guard against.
This would retain backward compatibility though, as without the adaptive bit set, new and old implementations can decode the address fine (new implementations assuming c = 3); new implementations can detect the adaptive bit and select the correct kdrf parameters. old implementations on adaptive addresses would hopefully fail upon seeing the length is wrong or that the reserved bits are not 0, otherwise the checksum should fail? But if it does by some 1 in 4 billion chance match, the wallet may successfully import a newly created private key and address? Does this seem likely, or are current implementations ensuring the decoded length and bits are set to 0?
Otherwise, we *could* if all else fails, use ?6A? for adaptive, or ?6p?? But I don?t really like polluting the namespace for a minor tweak.
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2014-11-27 17:56:54
@_author: Richard Moore 
@_subject: [Bitcoin-development] BIP 65 and OP_CHECKLOCKTIMEVERIFY inquiry... 
I was wondering about BIP 65 regarding the OP_CHECKLOCKTIMEVERIFY, and thought it might make more sense to instead have a OP_CHECKLOCKTIME which would simply push an OP_TRUE or OP_FALSE onto the stack?
That way someone could include multiple OP_CHECKLOCKTIME conditions in a single script. It is trivial to always emulate OP_CHECKLOCKTIMEVERIFY by using a OP_CHECKLOCKTIME OP_VERIFY sequence.
As a second question, would it possibly make more sense to, rather than relying on the nLockTime in a transaction, allow an opcode that would use similar semantics, but against an item in the stack? Then you could essentially include multiple nLockTimes in a single script and make arbitrarily interesting (complicated?) scripts based on block height and/or block timestamp.
The OP_CHECKLOCKTIMEVERIFY can still be easily implemented, by using
nLockTimeThatWouldBeInTx OP_CHECKLOCKTIME OP_VERIFY
Just something that came to mind while reading about OP_CHECKLOCKTIMEVERIFY.
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com www:

@_date: 2015-04-29 18:16:36
@_author: Richard Moore 
@_subject: [Bitcoin-development] Looking for a good bitcoin script 
I have a library, pycoind ( ) you might find useful.
'OP_DUP OP_HASH160 3f320f852a51643d3ffbaa1f49bfe521dd97764a OP_EQUALVERIFY OP_CHECKSIG'
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com www:

@_date: 2015-08-29 12:31:45
@_author: Richard Moore 
@_subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration 
I like the idea of having a standard for this, that all explorers (and even core, eventually) would understand.
I would recommend 2 changes though. First, using a real URI scheme, blockchain:// so that we can just use normal URL parsing libraries. The bitcoin: thing leads to additional code to mutate it into a proper URI before passing it to URL parsing. And I think it would be fine to include the type looking up. For example:
I think this would help the URI be more human understandable as well as give the explorers the ability to optimize a bit what they are looking for when hitting various databases.
A possible future path could also include blockchain://tx/123000/4 for block height, tx index... Another possibility could be blockchain://version which would return a list of supported paths, version of the BIP supported, etc.
The BIP should also specify little endian searching. I'm not sure, but would it also make sense for this BIP to include what the return results should look like? Maybe another, related BIP.
Sent from my self-aware iPhone
Richard Moore ~ Founder
Genetic Mistakes Software Inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2015-08-29 15:24:12
@_author: Richard Moore 
@_subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration 
I apologize, you are correct, I should not have used the word "real". However, if you look at section 3 of the RFC, the first hierarchal level (which in http is used to describe hosts) can be any "authority", not necessarily a hostname.
So, you could use tx, block, address, etc. as the authority for their paths.
Sent from my self-aware iPhone
Richard Moore ~ Founder
Genetic Mistakes Software Inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2015-08-29 15:28:17
@_author: Richard Moore 
@_subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration 
Yes! Good point, network should be encoded. Not sure I like this format yet, but what if it was part of the authority, like block:testnet. Like http uses port 80 by default, you could have block by default refer to block:mainnet.
I will read the RFC over more thoroughly tomorrow to get an idea of what types of things make more or less sense.
Sent from my self-aware iPhone
Richard Moore ~ Founder
Genetic Mistakes Software Inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2015-07-10 12:09:43
@_author: Richard Moore 
@_subject: [bitcoin-dev] Why not Child-Pays-For-Parent? 
Hey guys,
With all the recent congestion and discussion regarding FSS-RBF, I was wondering if there good reasons not to have CPFP as a default policy? Or is it?
I was also wondering, with CPFP, should the transaction fee be based on total transactions size, or the sum of each transaction?s required fee? For example, a third transaction C whose unconfirmed utxo from transaction B has an unconfirmed utxo in transaction A (all of A?s inputs are confirmed), with each A, B and C being ~300bytes, should C?s transaction fee be 0.0001 btc for the ~1kb it is about to commit to the blockchain, or 0.0003 btc for the 3 transactions it is going to commit.
I tried to test it out a few days ago, sending 0.0008 btc without any fee, then that utxo into another transaction w/ 0.0001 btc. It still hasn?t confirmed, which could be any of: a) CPFP doesn?t have enough hash power, b) the amounts are too small, c) the coins are too new, d) the fee should have actually been 0.0002 btc, e) the congestion is just too great; or some combination.
Just curious as whatnot?
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com www:

@_date: 2015-07-10 12:25:20
@_author: Richard Moore 
@_subject: [bitcoin-dev] Why not Child-Pays-For-Parent? 
By ignored, do you mean the nodes/miners didn?t even include the low fee transaction in their memory pools, so would no longer have access to it? If a node decides to not include it in its memory pool for this reason, I guess it won?t send out any INV messages either?
Could the broadcaster of TX_b rebroadcast TX_a? Then I guess any node that did add it to its memory pool would realize it?s not new and not rebroadcast it to those who didn?t, so it won?t propagate? Although, after receiving the orphan transaction TX_b, it could re-(pay attention) to an INV with TX_a (for a short-ish time to prevent further DoS vectors)? Assuming the sender of TX_b has a copy of TX_a?
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com www:

@_date: 2015-06-17 12:17:22
@_author: Richard Moore 
@_subject: [Bitcoin-development] soft-fork block size increase (extension 
Awesome graph!
It would be interesting if you could use your Excel voodoo (or whatever graph app you use) to add density as a heat map, making areas with more blocks red and regions with less blocks blue?
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com www:

@_date: 2015-06-30 12:03:02
@_author: Richard Moore 
@_subject: [bitcoin-dev] Block size increase oppositionists: please 
I?m not planning to take a firm stance against or for, but one problem with your analogy is that airplanes [currently] are not elastic (until we get TARDIS technology, or semi-TARDIS-like technology); they take up space and resources proportional to their capacity.
It is not the block size that is increasing, it is the *maximum* block size? So, it?s more like saying the *maximum* airplane size is increasing, which I think may be somewhat true (although, I agree, probably not exponentially). It would be more like an airplane whose capacity was doubling every two years, but would shrink when that extra capacity was not needed and only consume the maintenance, fuel, et cetera needed for its current size.
My semi-firm-ish stance is that kicking the can down the road with a static increase is less better. We can always soft-fork the limit down if the *actual* block size is growing too fast. When (and/or if) we need to. I also think 8MB is a rather large jump, for either static or dynamic.
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com www:

@_date: 2015-09-05 10:58:18
@_author: Richard Moore 
@_subject: [bitcoin-dev] Proposal to add the bitcoin symbol to Unicode 
This might also be a useful page to look at:
Sent from my self-aware iPhone
Richard Moore ~ Founder
Genetic Mistakes Software Inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com
www:

@_date: 2015-09-12 01:38:53
@_author: Richard Moore 
@_subject: [bitcoin-dev] Stealth Address Idea (special-less) 
Hey all,
I am throwing out an idea I?ve been toying with, for feedback and if it seems like an idea worth pursuing, possibly a BIP number.
The goal is to make straight forward stealth address that are SPV friendly and easy to support in software without too much special goop.
I?ve got working code at  and here are some example transactions on the block chain:
Target Public Key: 029ed06e396761c24416cf7323ed4f1cb29763ee9e2b0fccae347d6a2a3eaecbf5
Target Public Key [tentative] Encoding (this is what you would give away): 59KkSZsVE7vErdqo8m5gtNoez44CbdwJQ5cSM1AAARzN19vkJ6NU
Revocable Payment made: b4ad20cad4cc2fcbbec09bc071dfe8c4a4b1e8e57d1e56bf51947445cfc6c7af
Irrevocable Payment made: f600643a1d32152117be0d9c652a86dc6182d2dab3be53340739395f524cd95c
Cleared out all funds from stealth address: 58eb0fdab108c7add74835466251ffe5c51c7f4cec149f06daf0435d43d9ce55
Idea overview:
There are 2 modes of operation, revocable and irrevocable payments. Revocable payments result in both parties knowing the private key, allowing for a certain level of plausible deniability when the funds are swept, as to whether the funds were actually sent or were revoked? You could imagine WikiLeaks stating they will not claim donations for 1-3 months after receiving them; if the funds are claimed after 1.5 months, did the sender actually send funds? The other option is irrevocable, where only the receiver can claim the funds (allowing them to leave them in that address until they need to be spent).
The basic idea is (the above code above gets into the nitty gritty), to send to targetPublicKey:
Given the UTXO set of inputs into a transaction, choose one at random, senderUtxo
Use ECDH(targetPublicKey, senderUtxo.privateKey) as sharedSecret
For revocable payments, you are done; use sharedSecret as your privateKey, compute the address
For irrevocable payments, create a sharedPrivateKey from the bytes of sharedSecret, use ECC addition (or would multiplication make more sense? advantages?) on the public key of sharedPrivateKey and the targetPublicKey. The receiver can then use ECC addition (or multiplication) on the sharedPrivateKey and the targetPrivateKey to generate the coresponding privateKey.
The SPV-able part, is lightly discussed in the top of stealth.js, but I haven?t played with bloom filters enough and the idea is still all too fresh in my head; the general idea is to make a 1-of-2 multisig where the first is the resulting stealth address, and the second is something (anything) that looks like a valid public key, but will match a bloom filter (given a tweak that is generated deterministically from the targetPublicKey) and matches the targetPublicKey. Again, I need much more feedback on this.
Richard Moore ~ Founder
Genetic Mistakes Software inc.
phone: (778) 882-6125
email: ricmoo at geneticmistakes.com www:
