
@_date: 2015-06-01 14:45:21
@_author: =?UTF-8?B?SsOpcsO0bWUgTGVnb3VwaWw=?= 
@_subject: [Bitcoin-development] Proposed alternatives to the 20MB step 
It's surprising to see a core dev going to the public to defend a proposal
most other core devs disagree on, and then lobbying the Bitcoin ecosystem.
This is an very unhealthy way to go because it incentives the other core
devs to stop their technical work and go public and lobby too (cf G.Maxwell
trying to raise redditters awareness).
We need core devs to work on technical issues, not waste time doing
politics, but Gavin's confrontational approach doesn't give them much of a
I fear that because of this approach, in the next monthes, core devs with
be lobbying and doing politics : precious time will be wasted for everyone
having stake in Bitcoin.
Regarding the 20MB proposal content:
Decentralization is the core of Bitcoin's security model and thus that's
what gives Bitcoin its value.
The danger is that decentralization tends naturally towards centralization,
because centralization is more efficient. Going from decentralization to
centralization is easy, going the other way is a lot harder :
decentralization we lose, may never be gained back.
Regarding "the urgency to do something":
I believe it would be extremely healthy for the network to bump into any
limit ASAP ... (let it be 1MB) : to incentive layer 2 and offchain
solutions to scale Bitcoin : there are promising designs/solutions out
there (LN, ChainDB, OtherCoin protocole, ...), but most don't get much
attention, because there is right now no need for them. And, I am sure new
solutions will be invented.
If during the "1MB bumpy period" something goes wrong, consensus among the
community would be reached easily if necessary.
Pretending there is urgency and that Apocalypse is approaching is a fallacy.
The Gavin 20MB proposal is compromising Bitcoin's long-term security in an
irreversible way, for gaining short-term better user experience.
I oppose the Gavin proposal in both content and form.

@_date: 2016-04-24 12:05:52
@_author: =?utf-8?Q?J=C3=A9r=C3=B4me_Legoupil?= 
@_subject: [bitcoin-dev] Private "Merkle" Vaults for the Bitcoin system 
In Febuary, an email intitled "Bitcoin Vaults" was addressed to this mailing list linking to a paper on ?covenants? (see mail below) describing a way to apply recursive restrictions temporarily or permanently on bitcoins (for digital asset use-cases) and Bitcoin Vaults were offered as an application (thanks to the authors for sharing their work with the community, I personally found this paper insightful and inspiring). Unfortunately, this proposal isn?t fungibility friendly and could lead Bitcoin to undesirable outcomes.
What follows is an attempt to design Vaults that preserve Bitcoin?s fungibility and keep their defensive attributes private from blockchain observers and from potential insider participants: the Vault?s defence is incrementally revealed when executed. If I am a war chief defending a castle, I?m certainly not going to show my defence strategy to the world and if it leaked to the enemy, it would greatly weaken my chances to succeed: greater privacy leads to greater security.
Vaults enable important use-cases for Bitcoin as a store of value, in particular the tricky but critical use-case of successions (heritages).
? General idea ? This design restricts the bitcoins in a Vault to a private, predefined, finite (no patterns) and unforgeable set of authorized actions defined by the Vault creator at the setup.
Definition: an authorized action (or action) is an authorized address the bitcoins inside a Vault can be sent to, with an authorized timelock.
Action =  < timelock>
The Vault can be defined as a set of parent/child authorized actions. This enables the Vault creator to construct a Merkle tree of his Vault. During the setup, the creator computes the hashs of every authorized action, and builds his Merkle tree from the bottom, up to the top Merkle root. The Vault creator must give the appropriate Merkle proofs (authorizations) to the Vault participants (if any) according to the authorizations he grants them, and when someone wants to move funds inside or out of the Vault, he needs to provide to the network (in addition of a valid signature) the Merkle proof that demonstrates that his action is authorized by the Vault. The network can verify that:    Hash [ Merkle_proof(Action) + Hash(Action) ] == Merkle_proof(Parent_Action)
The Merkle tree must be destroyed once the setup is completed. Storing the tree anywhere is unnecessary and endangers the Vault's privacy.
? Example ? In this example, the Vault is composed of the actions A, B, C, D:
          \
            `--->D
If H is the hash function, the Merkle tree is:
                                                                          Merkle_root                                                                                /     \
              H(H(H(H(D)+H(1)) + H(H(C)+H(1))) + H(B))       H(A)
                                                 /     \                                                        H(H(H(D)+H(1)) + H(H(C)+H(1)))        H(B)                                                      /     \                                    H(H(D)+H(1))        H(H(C)+H(1))                           /                            \
          1                             1
Note: 1 are terminations to signal to the network that the coins are now allowed to exit the Vault. If the 1-terminations were not added, the bitcoins would be locked forever in the Vault because it would require to reverse H to spend them.
With notations:
                                                                                   Merkle_root                                                                                          /     \
                                                              Merkle_Proof(A)       H(A)
                                                                        /     \                                                        Merkle_Proof(parent of C) = Merkle_Proof(B)        H(B)                                                                       /     \                                               Merkle_Proof(C)        H(H(C)+H(1))                                                                        \
                                                         1
? nSequence ?
nSequence has different timelock meanings for the different time related OP codes:
OP_CLTV: a tx spending the outputs of a [parent tx with nSequence] is invalid if current block number <= nSequence
OP_CSV: a tx spending the outputs of a [parent tx with nSequence] is invalid if current block number <= block number of the parent tx + nSequence
New meaning of nSequence for OP_VAULT:
OP_VAULT: a tx with nSequence is invalid if current block number <= block number of the parent tx + nSequence
?OP_VAULT? This opcode checks if the tx timelock allows the tx to be included in a block and outputs a hash.
OP_VAULT (nSequence, Merkle_proof(Action), pubKeyHash)
IF (current block number >= Max(block number of the parent outputs) + nSequence of current tx)
     hAction=H(H(pubKeyHash)+H(nSequence));
     h=H(Merkle_proof(Action)+hAction);
     return h;
     return H(0);                                    // the tx cannot be included in a block yet
?Vault transaction structures?
Funding tx
scriptSig= <3> OP_PICK OP_HASH160 OP_VAULT  OP_EQUALVERIFY OP_HASH160  OP_EQUALVERIFY OP_CHECKSIG
Vault tx
scriptSig=   <3> OP_PICK OP_HASH160 OP_VAULT  OP_EQUALVERIFY OP_HASH160  OP_EQUALVERIFY OP_CHECKSIG
Exit tx
scriptSig=   OP_DUP OP_HASH160  OP_EQUALVERIFY OP_CHECKSIG
Note: The exit tx can also use OP_VAULT if it is exiting the Vault while funding another Vault.
?New consensus rules? (enforcement of OP_VAULT txs)
(parent tx VAULT_FLAG_ENABLE)
 // ...that are not permitted to exit the Vault if the action is not terminated by 1 in the Merkle tree (    H( in tx?s scriptSig + H(H(H(pubKeyHash)+H(nSequence))) + H(1))) !=  in parent tx?s scriptSig
(tx VAULT_FLAG_DISABLE) ( in tx?s scriptSig !=  in tx?s scriptPubKey)
THEN the transaction is INVALID.
?Privacy? In this design, Vault txs are CoinJoin/CT compatible (joining with other Vault txs) and perhaps Vault users will be willing to way for days or weeks to achieve maximum privacy, as they are susceptible of holding significant value in these structures.
?Use-cases? "Smart successions" : a morbid yet critical use-case for Bitcoin as a store of value
Bitcoin currently struggles in dealing with successions in a trustless manner. How does the Bitcoin system know when the succession should be executed ? What happens in case of conflict between the heirs ? It?s a tricky but important use-case.
Bitcoin successions are dealt with by either sharing decrypted private keys with the heirs (trusting they won?t take the coins before due time or won?t have them stolen), renting a safe at the bank and making a testament (trusting the bank) or simply hiding the keys and hoping the heirs will find them when you disappear. None of these schemes are satisfying, especially when dealing with multiple heirs. This gap could likely hold back investors from investing a significant portion of their wealth in Bitcoin if they don?t have a trustless and secure mechanism that guarantees their succession will be executed according to their will.
Funding addr
    \
      `->Transfert addr?0?>Alice addr                                 (1)
          \
            `-50000?>Multisig2/2?>Bob addr                                                 \                               (2)
                                               `?>Carol addr
                `-100000?>Multisig2/3?>Bob addr                                                                  \                                          (3)                                                     `?>Carol addr             (1) Alice?s recovery address in case Bob and Carol were too impatient to spend the heritage.
(2) Alice added a Multisig2/2 controlled by Bob and Carol. Alice gave Bob and Carol each, half of the Merkel proof to pull the funds into Multisig2/2: first Bob and Carol need to agree on the conditions of the succession and sign the exit transaction from the Multisig2/2, than they can share their Merkel proof halves and pull the funds.
(3) Arbitration in case of disagreement (or if Bob or Carol is uncooperative, or disappeared): Alice added a Multisig2/3 involving an arbitrator in case Alice and Bob couldn?t find an agreement after 20?000 blocks or something. The arbitrator has no information on the succession until Bob or Carol asks for his assistance. Alice gave each Bob and Carol the full Merkel proof to pull the funds to Multisig2/3.
We can imagine services assisting in the Vault setups and in the blockchain monitoring, enabling successions to occur entirely on-chain, in a trustless, private and peer-to-peer manner, outside of the current financial system. Scorched earth policies if the Vault defender is entirely compromised
The following defence strategy is inspired from the paper mentionned in the introduction :
Funding addr
    \
      `->Transfert addr-1000->Spending addr
                \
                  `-0->Recovery addr1-100->Recovery addr2-1000->Recovery addr3
                                                                         \
                                                                           `-0->Hidden addr ??
An attacker broadcasts the Transfer tx from the Funding address. The defender can stay patient and learn if the attacker knows the recovery key (& the corresponding Merkle proofs) and ajust his defence accordingly: if indeed the adversary can move funds (he knows the recovery key(s)) and approches to the Vault exit (he knows also the Merkle proofs), the defender can burn all funds into fees, denying the attacker.
?Thanks for your attention?
Please let me know if you think this idea is worth exploring deeper.
