
@_date: 2015-07-22 16:41:24
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] Making Electrum more anonymous 
I've thought about this as well, (in addition to making a java
implementation of the electrum server).
One solution would be for the client to combine all the addresses they are
interested in into a single bloom filter and send that to the server.
It would be pretty expensive for the server to check every address against
the bloom filter, but maybe for recent blocks (client can send how behind
they are) and for new transactions it wouldn't be bad at all.
The client could end up receiving a bunch of transactions they weren't
interested in but it would likely be manageable.
The client would also need to be fairly clever, including a set of static
ruse addresses and dynamic ruse addresses that they include in the filter.
That way a server would have a hard time using the bloom filter as a
fingerprint and figuring out which addresses are the real ones.
An alternative would be the server sending a bloom filter of addresses in
each block and then the client requesting entire blocks.  This would use
more bandwidth, but it seems like it would be pretty simple to implement
and give good anonymity.
Basically the idea is to spend more bandwidth and CPU to keep the server in
the dark on what the client really wants.
On Wed, Jul 22, 2015 at 8:51 AM Thomas Voegtlin via bitcoin-dev <

@_date: 2015-07-22 23:07:12
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] Making Electrum more anonymous 
I would recommend the following solution as a decent compromise between
complexity and privacy:
1) Encourage electrum server operators to have their servers reachable as
tor hidden services (.onion addresses)
2) Make sure server discovery works well with .onion addresses
3) Make the privacy a user configurable setting:
  - None - Allows any server connection type
  - SSL - Requires SSL at least, no plain text
  - Tor - Requires tor, no direct TCP
  - Multi-Tor - Uses a variety of tor paths to reach a variety of servers
(maybe configurable number of servers)
Default should be 'SSL' probably.
On Wed, Jul 22, 2015 at 3:20 PM Eric Voskuil via bitcoin-dev <

@_date: 2015-07-23 17:18:59
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] Electrum Server Speed Test 
I have concerns about the performance of the Electrum server software as
well.  It seems to load data one block at a time (which normally makes
sense) and I think it is even single threaded on transactions inside the
To try to addresses these issues, I made my own implementation of the
electrum server.  It doesn't support UTXO (yet) but happily interacts with
all the clients I've tested.  It is heavily multithreaded, uses mongodb as
a key value store and bitcoinj for block and transaction parsing.
You can hit a running instance at:
A synced node uses 347G of mongodb storage.
Here are the recent blocks imported, with number of transactions and import
These times are based on having mongodb on SSD.
The CPU is 8 core Intel(R) Xeon(R) CPU E5430  @ 2.66GHz
I'd be happy to help with anything you need to evaluate it.
On Thu, Jul 23, 2015 at 9:01 AM Slurms MacKenzie via bitcoin-dev <

@_date: 2015-07-23 17:41:17
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] Electrum Server Speed Test 
I think our friendly original party worm is just trying to evaluate where
we are currently so arguments can be based on data.
I would tend to agree that there are performance improvements to be made
and would rather do that work than limit the block size.
On Thu, Jul 23, 2015 at 10:28 AM Matt Whitlock via bitcoin-dev <

@_date: 2015-07-23 19:57:38
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] Bitcoin Node Speed Test 
That is how I read it as well.
On Thu, Jul 23, 2015 at 12:56 PM Marcel Jamin via bitcoin-dev <

@_date: 2015-10-22 21:56:18
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db 
I have done a lot of recent work on local key value stores, mostly for a
java electrum server I am working on.
I'd suggest considering LMDB.  One downside is that it is memory mapped so
32-bit systems that need over 2gb of storage are right out.  Other than
that, it is quite fast and seems reliable in my testing.
On Thu, Oct 22, 2015 at 2:37 PM Jeff Garzik via bitcoin-dev <

@_date: 2018-04-10 20:41:07
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] Few questions regarding ListTransaction 
2) -1 doesn't mean conflicted, it means the transaction is not only
unconfirmed buy depends on another unconfirmed transaction.
1) Depends on what you mean by trusted.  If you are giving the user online
access to something that costs you next to nothing to revoke if there is a
problem later, no problem.  0-conf is great.  If you are pre-pairing
shipments and will be able to pull the box from the ship stream if there is
a problem, also no problem.  If you are sending some other non-reversible
thing like crypto, then you might want to be careful.  It really depends on
the value of your things and your tolerance of risk.
In my opinion, an zero-conf transaction is way way better than a credit
card preauth or a check in hand.
On Tue, Apr 10, 2018 at 1:34 PM Maksim Solovjov via bitcoin-dev <

@_date: 2018-08-28 08:15:06
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] Building a Bitcoin API and query system. 
For what it is worth, electrum has a lot or possibly all of what you are
talking about since the electrum servers are designed to quickly answer the
queries of light clients.  So right now, you could sync up an electrum
server or use an existing public one and send queries to it with json-rpc.
On Tue, Aug 28, 2018 at 5:36 AM Blockchain Group via bitcoin-dev <

@_date: 2018-12-03 12:54:10
@_author: =?UTF-8?B?Sm9zZXBoIEdsZWFzb24g4pGI?= 
@_subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics 
I have a suggestion.  If you are concerned about plausible deniability,
then it might make sense to just have the single mnemonic seed lead to a
single xprv key (as usual) and then do a private key derivation from that
based on a password string.  The password can be simple, as it is based on
the security of the seed, just as long as the user feels they need for
A simple reverse scheme like you describe would just be another thing a
person would know to check if given some seed so I don't see it as
providing much value, but I could be missing something.
On Mon, Dec 3, 2018 at 10:45 AM Steven Hatzakis via bitcoin-dev <
