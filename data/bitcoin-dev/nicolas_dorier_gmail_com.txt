
@_date: 2015-08-14 01:34:03
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] [BIP-draft] CHECKSEQUENCEVERIFY - An opcode for 
Would be wonderful to have this pushed together with CLTV and BIP68.
If BIP68 get pushed in the next fork, this CSV is a no brainer.
Was there a competing RCLTV implementation somewhere that did not depend on
BIP68 for information ? I don't manage to find it.

@_date: 2015-08-19 13:57:19
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] Core Devs : can you share your thoughts about all 
I created a small website which show a chart of your approvals about
various BIPs (which you must fill by yourself with a signed pgp message)
For each BIP, you can fill if you approve or not, and give comments. (HTML
accepted, so you can link stuff you your posts)
It would help the community a lot, so I hope you will do it !
I'm open to add other important devs, big miners, or other proposal that I
Please, respond on BTC Talk or github. (I don't read the mailing anymore
because of the spam :( )
Link : BtcTalk Topic : Github :

@_date: 2015-08-21 12:38:40
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] Core Devs : can you share your thoughts about all 
Thanks, btcdrak, I just added the column and you in the list. (looks nicer)
What I am calling "core devs" in the website is only "commit access
people", should I rename this group ?
I just want a way to improve readability of the website by grouping, I am
open to all subjection on different way of grouping.
I'm good for adding Mike Hearn, Adam Back, Mark Friedenback, Jorge Timons,
Nick Szabo, Meni Rosenfeld, Charlee Lee.
If some of you are reading this list, please send me your PGP public key.
For the others, any idea where I can hunt their PGP public keys ?

@_date: 2015-08-21 12:49:20
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] RE :  Visualizations of Votes 
etc) based on what's published in blocks.
If such a vote existed, I would gladly show the pie on BIPxDevs.
However there is no standard way for miners to vote informally BIP they

@_date: 2015-08-21 12:54:28
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] Core Devs : can you share your thoughts about all 
I'm not against it (mostly active committers as you are), my challenge is
getting the PGP keys scattered all over the place.
If you want put your thoughts, then let me know you pgp.

@_date: 2015-08-21 14:10:50
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] Core Devs : can you share your thoughts about all 
Decision making is not the goal of this site, it is only a way to see
various pros and cons of various devs on various proposals in a single
This is for the community to have a coherent view about what you are
talking about now spread into reddit/mailing/forums.
If you did not analyzed a proposal yet, you don't have to fill out your
opinion veto or approval.
It is only to show what you would you "approve" and what you would "veto",
after your analysis.
Then point out all the discussions in the opinion section that lead you to
your conclusion.
You can change edit your position as you progress into your analysis and as
new BIP get redacted.
I'm eager to include the new proposals.

@_date: 2015-08-22 01:58:50
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] Core Devs : can you share your thoughts about all 
My UX skills are lacking a bit. You can edit all your thoughts about each
BIP, HTML is accepted, so you can link to other posts you made somewhere
When you click on a cell in the grid, it forward you to the page that the
dev edited for this BIP.
This website is not only to say "approve", "disapprove", nor is it about a
formal process for reaching agreement.
This is a tool, a portal, which educates people, and permit you to link all
of your thoughts about the various BIP and show it to others.
With the opinions browse able from the same website, you will notice in a
gleam as soon as one of those proposal reach consensus. (I think SIPA's BIP
has a chance to do so, but nobody knows it yet)
Sadly, the most controversial is a BIP, the noisier it is, at the expense
of those which are not. (like sipa's one).
It irritates me a lot that the debate in public mind is "XT or not" /
"Bigger blocks or not", when in reality there is lots of different
proposals that might also reach consensus but are lost in the noise.
I will add any BIP that at least one voter approve and want to push forward.
I plan to add merchants/wallet providers/mining pools later.

@_date: 2015-01-28 13:45:29
@_author: Nicolas DORIER 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
I agree that the use protocol buffer and x509 by BIP70 is a poor choice.
The choice should have been done to maximize portability, not to maximize
efficiency and flexibility.
What I ended up doing for having a similar codebase on all plateform is to
parse a BIP70 messages with the help of a web service that convert it to
I don't like this solution since it had a trust dependency, and the
certificate verification become handled by the web service, not the device.
But even if I solved google buffer problem, I would stumble upon having
headache to validate the x509 certificate chain on every plateforms.
A simple BIP70 using JSON + HTTPS would have make things more easy.
I agree that it requires that the merchant own the domain name of the BIP70
endpoint, but I don't consider such a big of a deal, since this is how
e-commerce works.

@_date: 2015-01-28 15:00:40
@_author: Nicolas DORIER 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
Sure I know that x509 is international standard. And that HTTPS uses TLS.
This is not my point, my point is that when we use HTTPS the developer
delegates certificates verification to the plateform he is running on, so
developer don't have to bother about it, making the implementation safer
and easier.
On the other hand, if you charge the developer (and not the plateform) to
check certificate validity, it means that you have to develop a different
codebase for all plateform you are targeting, because each plateform store
trusted root certificate in a different manner with different APIs, and
also have different types representing a X509 Certificate.
So, let's say I want to target IOS + WP + Android + WinRT + desktop win, I
need to develop 4 times chain verification and certificate parsing.
(Because I can't verify a certificate if it is not in the specific type of
the underlying plateform)
And since it would take too much time to do that, I end up delegating
parsing and trust verification to a third party service.
2015-01-28 14:32 GMT+01:00 Wladimir :

@_date: 2015-01-28 17:34:26
@_author: Nicolas DORIER 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
My point is not that there is a limitation in BIP70. My point is that you
put the burden of certificate verification on developer's shoulder when we
can just leverage built in HTTPS support of the platform.
This make cross plateform dev a nightmare.
Sure I can use a snapshot of moz/apple/msft store. I depends on
BouncyCastle, as bitcoinj, so I theorically can use that way.
However, if you want to use your plateform's store, then you are toasted,
and the code for converting from BC X509 Certificate to one of each
plateform is not obvious and is a headache. Thing that could be just left
to the HTTPS support of your plateform.
Have you tried to do that on windows RT and IOS ? I tried, and I quickly
stopped doing that since it is not worth the effort. (Frankly I am not even
sure you can on win rt, since the API is a stripped down version of windows)
Why have you not heard about the problem ? (until now, because I have this
problem because I need to have the same codebase on
Because bitcoinj just rely either java's own abstraction of certificate or
on BC one. But I highly doubt they are using the plateform store, and even
if you theorically can, dealing with X509 is very prone to error... for
something that the plateform should just do for you.
Also, you bundle mozilla's store in bitcoinj, what happen when the store
change and your customer have not intent to use bitcoinj new version ? by
leveraging the plateform you benefit from automatic updates.
Also, does java stores deals with certificate revocations ? sure you can
theorically code that too... or just let the plateform deals with it.
BIP70 does not limit to anything but it is a gigantic pain in the ass for
easy cross development because of protobuff and embedded certificates.
BIP70 is a client side technology, not a performance and storage critical
data structure.
The only valid point of having embedded certificates is to allow the owner
of the website to be different from the merchant. But since merchants often
have their own website, a protocol without having to reinvent x509 would
have been better suited to current needs.
2015-01-28 16:42 GMT+01:00 Mike Hearn :

@_date: 2015-01-28 17:52:54
@_author: Nicolas DORIER 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
For the number of field there is in the spec, I don't consider having a
JSON to schama really worthwhile.
If you fear it is error prone, then we should provide some testing data for
the BIP70. (Which I already did for protobuf, but was rejected, because
deemed no useful thanks to the code generator... But such code generator
gave me inconsistencies with gavin's implementation for example)
Why do you think type support is very useful in our case ? we have 3 types,
and dealing only with bytes, int, and string.
It cost me more time to find a suitable cross plateform lib for protobuf
(in c that works in ios and winrt) than I would by just coding the json
wrapper classes by hand. (JSON libs are more wildspread and supported than
2015-01-28 17:04 GMT+01:00 Jeff Garzik :

@_date: 2015-01-28 18:04:40
@_author: Nicolas Dorier 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
Mike, I am not denying it is impossible to do all of that.
Just that it is not a trivial stuff to do to make it works everywhere, and
I think that it is not a good thing for a client side technology.
BIP70 has its use, and I understand why there is case where it is good to
ship the certs in the message and not depends on the transport.
But a standard that just use JSON and HTTPS, even if less flexible that
BIP70, would make it easier and sufficient for today's use case.

@_date: 2015-01-28 18:27:44
@_author: Nicolas DORIER 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
But the mobile targets, it is still easier to use Json + HTTPS, especially
when you want one code base for everything.
And as you said, developers need to think about fetching mozilla store time
to time, and check revocations themselves. This is not obvious thing to do,
and hard to test correctly.
If your use case was the primary utility of BIP70, then I'd say it fit the
bill. But for cross plateform client development an atlernative would be
parameter, keep everyone happy.
It would be another BIP, because if we use JSON with HTTPS, the difference
is also in the semantic (no embedded certificates)
I will likely provide this option for a product I am developing. I will
only use another Content Type. We'll see then how it goes.
2015-01-28 18:14 GMT+01:00 Mike Hearn :

@_date: 2015-05-08 01:14:22
@_author: Nicolas DORIER 
@_subject: [Bitcoin-development] Solution for Block Size Increase 
Executive Summary:
I explain the objectives that we should aim to reach agreement without
drama, controversy, and relief the core devs from the central banker role.
(As Jeff Garzik pointed out)
Knowing the objectives, I propose a solution based on the objectives that
can be agreed on tomorrow, would permanently fix the block size problem
without controversy and would be immediately applicable.
The objectives:
There is consensus on the fact that nobody wants the core developers to be
seen as central bankers.
There is also consensus that more decentralization is better than less.
(assuming there is no cost to it)
This means you should reject all arguments based on economical, political
and ideological principles about what Bitcoin should become. This includes:
1) Whether Bitcoin should be storage of value or suitable for coffee
2) Whether we need a fee market, block scarcity, and how much of it,
3) Whether we need to periodically increase block size via some voodoo
formula which speculate on future bandwidth and cost of storage,
Taking decisions based on such reasons is what central bankers do, and you
don?t want to be bankers. This follow that decisions should be taken only
for technical and decentralization considerations. (more about
decentralization after)
Scarcity will evolve without you taking any decisions about it, for the
only reason that storage and bandwidth is not free, nor a transaction,
thanks to increased propagation time.
This backed in scarcity will evolve automatically as storage, bandwidth,
encoding, evolve without anybody taking any decision, nor making any
speculation on the future.
Sadly, deciding how much decentralization should be in the system by
tweaking the block size limit is also an economic decision that should not
have its place between the core devs. This follow :
4) Core devs should not decide about the amount of suitable
decentralization by tweaking block size limit,
Still, removing the limit altogether is a no-no, what would happen if a
block of 100 GB is created? Immediately the network would be decentralized,
not only for miners but also for bitcoin service providers. Also, core devs
might have technical consideration on bitcoin core which impose a temporary
limit until the bug resolved.
The solution:
So here is a proposal that address all my points, and, I think, would get a
reasonable consensus. It can be published tomorrow without any controversy,
would be agreed in one year, and can be safely reiterated every year.
Developers will also not have to play politics nor central banker. (well,
it sounds to good to be true, I waiting for being wrong)
The solution is to use block voting. For each block, a miner gives the size
of the block he would like to have at the next deadline (for example, 30
may 2015). The rational choice for them is just enough to clear the memory
pool, maybe a little less if he believes fee pressure is beneficial for
him, maybe a little more if he believes he should leave some room for
increased use.
At the deadline, we take the median of the votes and implement it as a new
block size limit. Reiterate for the next year.
Objectives reached:
   - No central banking decisions on devs shoulder,
   - Votes can start tomorrow,
   - Implementation has only to be ready in one year, (no kick-in-the-can)
   - Will increase as demand is growing,
   - Will increase as network capacity and storage is growing,
   - Bitcoin becomes what miners want, not what core devs and politician
   wants,
   - Implementation reasonably easy,
   - Will get miner consensus, no impact on existing bitcoin services,
   - Effect on bitcoin core stability (core devs might have a valid
   technical reason to impose a limit)
   - Maybe a better statistical function is possible
Additional input for the debate:
Some people were debating whether miners are altruist or act rationally. We
should always expect them to act rationally, but we should not forget the
peculiarity of TCP backoff game: While it is in the best interest of
players to NOT reemit TCP packet with a backoff if the ACK is not received,
everybody does it. (Because of the fallacy that changing a TCP
implementation is costless)
Often, when we think a real life situation is a prisoner dilemma problem,
it turns out that the incentives where just incorrectly modeled.
Core devs, thanks for all your work, but please step out of the banker's
role and focus on where you are the best, I speak as an entrepreneur that
doesn't want decisions about bitcoin to be taken by who has the biggest.
If the decision of the hard limit is taken for other than purely technical
decisions, ie, for the maximization of whatever metric, it will clearly put
you in banker's shoes. As an entrepreneur, I have other things to speculate
than who gets the biggest gun in the core team.
Please consider my solution,
Nicolas Dorier,

@_date: 2016-08-01 22:21:49
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] BIP Number Request: Open Asset 
Sorry, I completely forgot about having submitted the BIP as I was busy at
this time.
Thanks for the review.
Open Asset is actually not an abandoned project and is a protocol already
used in production with multiple implementation.
Wallet: Implementation C  with heavy
documentation (
Implementation Ruby: Usage stats: Concerning whether or not we can put my name in the BIP, I'll ask the
original author that I know personally.
Yes, with open asset it is not possible to do provably limited issuance.
The scriptPubKey can be anything, not necessarily P2PK.
If you can spend the scriptPubkey, then you are the issuer.
Correct, if you spend a colored output incorrectly, it is effectively
clear how
The terminology is correct we are parsing PUSHDATA, if there is a parsable
pushdata, the output is considered valid.
If there is multiple valid output, then we take the first one.
You can't issue more than one asset type in a transaction. (as the asset
issued is defined by the scriptPubKey of the first input)
For multiple transfer it is possible, imagine a transaction with the
following 3 inputs and 6 outputs:
Inputs: {0, 10a, 20b}
Outputs: {5, OP_RETURN; 7; 3; 11; 9)
Inputs1: 0
Inputs2: Enqueue 10a in the queue ( {10a} )
Input3: Enqueue 20b in the queue ( { 20b, 10a} )
Output1: Before OP_RETURN, so is issuance whose color is defined by the
scriptPubKey of Input1. (say c)
Output2: No color (marker)
Output3: Dequeue 7a ( {20b, 3a} ), color output with a.
Output4: Dequeue 3a ( {20b} ), color output with a
Output5: Dequeue 11b ( {9b} ), color output with b
Output5: Dequeue 9b ( {0} ), color output with b
Finally, outputs color are
Outputs: {5c, OP_RETURN; 7a; 3a; 11b; 9b)
position 3,
Marker output is skipped (explained in the example)
The way
Actually there is no "issuance address", just the AssetId is defined by the
scriptPubKey of the issuer.
Yes, it requires address reuse for issuing.
Correct. Actually we prevent users sending asset to wallet which does not
support OA via another address scheme described in another document (
As said, Open Asset is not a draft proposal and is already used in the wild
since 2014. We can't easily modify the protocol by now for improving it.
more readable than a mail.

@_date: 2016-08-13 11:25:04
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] BIP Number Request: Open Asset 
I think that regardless of merits protocol or limitations of protocols,
once they become used and stable they merit their place as a BIP.
I'd like to submit OA as is on flavien's repository, and update or reword
things once it is there. (so he can ACK easily and we can keep track of
changes instead of using mails back and forth)
It would be useful to have other colored coin protocols as well. (EPOBC and
On Thu, Aug 4, 2016 at 9:37 PM, Flavien Charlon <

@_date: 2016-02-09 21:32:06
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] On Hardforks in the Context of SegWit 
There is two kind of hard fork, the one who breaks things, and the one who
does not.
Restricting the non-segwit inputs would disrupt lots of services, and
potentially invalidating
hash time locked transactions, which is a very bad precedent.
So I'm strongly against this particular point.
Same problem for native multisig, however potentially less important than
the previous point.

@_date: 2016-05-08 19:25:49
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] Compact Block Relay BIP 
Interesting, can you provide some historical context around it so I
understand better ?
Actually I know that your relay's protocol (and about what I see in
abstract) was about optimizing propagation time and not bandwidth.
And I agree that bandwidth is what need to be optimized for nodes.
So far there was two other proposal that I know only from name and theory
which is xthin block and ILBT which would also have decreased bandwidth.
Can you quickly describe how does it compares to them ?

@_date: 2016-05-26 11:50:26
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] BIP Number Request: Open Asset 
Open Asset is a simple and well known colored coin protocol made by Flavien
Charlon, which has been around for more than two years ago.
Open Asset is OP_RETURN to store coin's color. Since then, the only
modification to the protocol has been for allowing OA data to be into any
push into an OP_RETURN.
The protocol is here:
I asked to Flavien Charlon if he was OK if I submit the protocol to the
mailing list before posting.
Additional BIP number might be required to cover for example the "colored
address" format:
But I will do it in a separate request.
Here is the core of the Open Asset specification:
  Title: Open Assets Protocol (OAP/1.0)
  Author: Flavien Charlon   Created: 2013-12-12
This document describes a protocol used for storing and transferring
custom, non-native assets on the Blockchain. Assets are represented by
tokens called colored coins.
An issuer would first issue colored coins and associate them with a
formal or informal promise that he will redeem the coins according to
terms he has defined. Colored coins can then be transferred using
transactions that preserve the quantity of every asset.
In the current Bitcoin implementation, outputs represent a quantity of
Bitcoin, secured by an output script. With the Open Assets Protocol,
outputs can encapsulate a quantity of a user-defined asset on top of
that Bitcoin amount.
There are many applications:
* A company could issue colored coins representing shares. The shares
could then be traded frictionlessly through the Bitcoin
* A bank could issue colored coins backed by a cash reserve. People
could withdraw and deposit money in colored coins, and trade those, or
use them to pay for goods and services. The Blockchain becomes a
system allowing to transact not only in Bitcoin, but in any currency.
* Locks on cars or houses could be associated with a particular type
of colored coins. The door would only open when presented with a
wallet containing that specific coin.
==Protocol Overview==
Outputs using the Open Assets Protocol to store an asset have two new
* The '''asset ID''' is a 160 bits hash, used to uniquely identify the
asset stored on the output.
* The '''asset quantity''' is an unsigned integer representing how
many units of that asset are stored on the output.
This document describes how the asset ID and asset quantity of an
output are calculated.
Each output in the Blockchain can be either colored or uncolored:
* Uncolored outputs have no asset ID and no asset quantity (they are
both undefined).
* Colored outputs have a strictly positive asset quantity, and a
non-null asset ID.
The ID of an asset is the RIPEMD-160 hash of the SHA-256 hash of the
output script referenced by the first input of the transaction that
initially issued that asset (script_hash =
RIPEMD160(SHA256(script))). An issuer can reissue more of an
already existing asset as long as they retain the private key for that
asset ID. Assets on two different outputs can only be mixed together
if they have the same asset ID.
Like addresses, asset IDs can be represented in base 58. They must use
version byte 23 (115 in TestNet3) when represented in base 58. The
base 58 representation of an asset ID therefore starts with the
character 'A' in MainNet.
The process to generate an asset ID and the matching private key is
described in the following example:
# The issuer first generates a private key:
# He calculates the corresponding address:
# Next, he builds the Pay-to-PubKey-Hash script associated to that
address: OP_DUP OP_HASH160
010966776006953D5567439E5E39F86A0D273BEE OP_EQUALVERIFY
# The script is hashed: 36e0ea8e93eaa0285d641305f4c81e563aa570a2
# Finally, the hash is converted to a base 58 string with checksum
using version byte 23:
The private key from the first step is required to issue assets
identified by the asset ID
ALn3aK1fSuG27N96UGYB1kUYUpGKRhBuBC. This acts as a
digital signature, and gives the guarantee that nobody else but the
original issuer is able to issue assets identified by this specific
asset ID.
==Open Assets Transactions==
Transactions relevant to the Open Assets Protocol must have a special
output called the marker output. This allows clients to recognize such
transactions. Open Assets transactions can be used to issue new
assets, or transfer ownership of assets.
Transactions that are not recognized as an Open Assets transaction are
considered as having all their outputs uncolored.
===Marker output===
The marker output can have a zero or non-zero value. The marker output
starts with the OP_RETURN opcode, and can be followed by any sequence
of opcodes, but it must contain a PUSHDATA opcode containing a
parsable Open Assets marker payload. If multiple parsable PUSHDATA
opcodes exist in the same output, the first one is used, and the other
ones are ignored.
If multiple valid marker outputs exist in the same transaction, the
first one is used and the other ones are considered as regular
outputs. If no valid marker output exists in the transaction, all
outputs are considered uncolored.
The payload as defined by the Open Assets protocol has the following format:
! Field                !! Description !! Size
! OAP Marker           || A tag indicating that this transaction is an
Open Assets transaction. It is always 0x4f41. || 2 bytes
! Version number       || The major revision number of the Open Assets
Protocol. For this version, it is 1 (0x0100). || 2 bytes
! Asset quantity count || A
var-integer] representing the number of items in the asset
quantity list field. || 1-9 bytes
! Asset quantity list  || A list of zero or more
[ LEB128-encoded] unsigned integers
representing the asset quantity of every output in order (excluding
the marker output). || Variable
! Metadata length      || The
var-integer] encoded length of the metadata field. || 1-9
! Metadata             || Arbitrary metadata to be associated with
this transaction. This can be empty. || Variable
Possible formats for the metadata field are outside of
scope of this protocol, and may be described in separate protocol
specifications building on top of this one.
The asset quantity list field is used to determine the
asset quantity of each output. Each integer is encoded using variable
length [ LEB128] encoding (also
used in [
Google Protocol Buffers]). If the LEB128-encoded asset quantity of any
output exceeds 9 bytes, the marker output is deemed invalid. The
maximum valid asset quantity for an output is 263 - 1
If the marker output is malformed, it is considered non-parsable.
Coinbase transactions and transactions with zero inputs cannot have a
valid marker output, even if it would be otherwise considered valid.
If there are less items in the asset quantity list than
the number of colorable outputs (all the outputs except the marker
output), the outputs in excess receive an asset quantity of zero. If
there are more items in the asset quantity list than the
number of colorable outputs, the marker output is deemed invalid. The
marker output is always uncolored.
After the asset quantity list has been used to assign an
asset quantity to every output, asset IDs are assigned to outputs.
Outputs before the marker output are used for asset issuance, and
outputs after the marker output are used for asset transfer.
This example illustrates how a marker output is decoded. Assuming the
marker output is output 1:
    Data in the marker output      Description
    ---------------
                                    Output 6 (Transfer)
Output 6 (Transfer)
                                      Asset quantity:     3
Asset quantity:     3
                                      Asset ID:
Asset ID:           A2
                                    =============================
Outputs are colored from the first to the last. Outputs before the
marker output are issuance outputs:
* Output 0 has an asset quantity of zero, so it is considered uncolored.
* Output 1 gets assigned the asset ID defined by H =
RIPEMD160(SHA256((S)) where S is the output script
referenced by the first input of the transaction (input 0).
Output 2 is the marker output, separating issuance outputs from
transfer outputs. The marker output is always uncolored.
Transfer outputs are then colored:
* Output 3 receives 3 units from input 0, 2 units from input 1, 0 unit
from input 2 and 1 unit from input 3. All the 6 units have the same
asset ID A1, so the asset ID A1 is assigned
to output 3.
* Output 4 has an asset quantity of zero, so it is considered uncolored.
* Output 5 receives the remaining 4 units of input 3, and 3 units from
input 4. All the 7 units have the same asset ID A1, so
the asset ID A1 is assigned to output 5.
* Output 6 receives the first 3 units of input 5. Input 5 has the
asset ID A2 so the asset ID A2 is assigned
to output 6.
This approach offers a number of desirable characteristics:
# Economical: The cost of issuing or transferring an asset is
completely independent from the quantity issued or transferred.
# Clients have a way to identify colored outputs simply by traversing
the Blockchain, without needing to be fed external data. Transactions
relevant to the Open Assets Protocol are identified by the special
marker output.
# It is possible to determine the asset ID and asset quantity of an
output by traversing only a limited number of transactions.
# Assets are pseudonymous. They are represented by an asset ID, which
is enough to identify each asset uniquely, while still providing an
adequate level of anonymity for both the issuer and users of the
# This approach uses the recommended way to embed data in the
Blockchain (OP_RETURN), and therefore does not pollute the UTXO.
# The whole cryptographic infrastructure that Bitcoin provides for
securing the spending of outputs is reused for securing the ability to
issue assets. There is a symmetry between ''an address + private key''
as a way to spend Bitcoins, and ''an address + private key'' as a way
to issue assets.
# Generating a new type of asset is as simple as generating an
address, can be done offline, and for free.
# Reissuing more of an existing asset is easy and can be done quickly
and at no cost (except for the transaction fee) as long as the issuer
retains the private key for the asset ID.
# Single-issuance assets can be achieved by destroying the private key
used to issue the asset immediately after issuing it.
# Since issuance is based on standard Bitcoin output scripts, it is
possible to create an asset that requires multiple signatures for
For backward compatibility reasons, we consider than an older client
is allowed to see a colored output as uncolored.
===Backward compatibility with existing Bitcoin protocol===
The Open Assets Protocol sits on top of the Bitcoin protocol. It does
not require any change to the existing Bitcoin protocol. Existing
clients that don't support the Open Assets Protocol will see all
outputs as uncolored, and will not be able to perform transfer
===Compatibility between different versions of OAP===
New versions with the same major version number (e.g. 1.1) should be
backwards compatible. New versions with a different major version
number (e.g. 2.0) can introduce breaking changes, but transactions
created by newer clients will be identifiable by a different version
number in the output 0 of genesis and transfer transactions.
This document has been placed in the public domain.
Nicolas Dorier,

@_date: 2017-12-20 15:28:07
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] BIP Proposal: Crypto Open Exchange Protocol (COX) 
Hi everyone,
As some of you know, I am working on a complete open source replacement of
Bitpay for allowing merchant to accept cryptocurrency payments while having
a way to sell automatically.
A crucial, missing part, is fiat conversion. And I figured out a simple
protocol that exchanges (or adapters) can implement to allow any merchant
to cash out BTC in fiat while giving them the freedom to choose their own
payment processor solution.
This also have positive impact on scalability: Before, a merchant would
receive the bitcoin from the customer then would send to the exchange,
resulting in two transactions.
With this specification, it would be one transaction.
Special thanks to anditto and kallewoof for reviewing. I am waiting for
your feedback:
Github link:
  BIP: XXX
  Layer: Applications
  Title: Crypto Open Exchange Protocol (COX)
  Author: Nicolas Dorier   Comments-Summary: No comments yet.
  Comments-URI:   Status: Draft
  Type: Standards Track
  Created: 2017-12-20
  License: BSD-3-Clause
           CC0-1.0
A simple protocol for decoupling payment processor solutions from exchanges.
Cryptocurrency merchant adoption is mainly driven by availability, ease of
use and means of acceptance.
We call such solutions `Payment Processors`.
Until now, payment processing solutions fall into one of the two following
# Self-hosted with the customer paying in cryptocurrency and the merchant
receiving it directly.
# Centralized, coupled with an exchange feature, with the customer paying
in cryptocurrency to the merchant, and receiving fiat or cryptocurrency on
his exchange account.
The self-hosted solution has two issues:
# The merchant becomes vulnerable to the wild volatility of
# It is wasteful of blockchain space, if the merchant does not pay
suppliers in crypto, as they need a second transaction to change to his
The centralized solution has two issues:
# It locks-in the merchant to a particular payment processor whose
intentions might not be aligned (e.g. Bitpay who tried to redefine Bitcoin
as being a different chain, without merchant approval)
# It has to deal with local regulations (e.g. Bitpay does not provide fiat
CAD to canadian merchants)
The goal of this BIP is to specify a simple protocol which makes possible
decoupling of payment processors from exchanges.
We believe this BIP will gather a lot of interest among local exchanges
which do not have the resources to develop their own payment solutions.
Their customers can decide which payment processor solution they prefer,
while the exchanges give them a way to protect against cryptocurrency
The merchant log in to its exchange website, go into "Address sources"
section of it, an click on "Create a new address source".
The address source creation wizard asks him questions about what to do when
crypto currency is sent to this the address source. (Cryptocurrency, Market
sell order, limit order of past day average etc...)
The merchant receives an "address source URI" which they can input inside
the payment processor.
An exchange compatible with the Crypto Open Exchange Protocol would reply
to any HTTP POST request to this  "address source URI" returning the
following information (more details in the Specification part)
# A deposit address for accepting a payment
# The current rate
# Optional: If the exchange is willing to take the risk of rate
fluctuation, until when this rate is guaranteed and under which conditions.
* Manny (the "merchant") wants to accept Bitcoin payments on his e-commerce
* Manny chooses the payment processor "PROCCO" which has a powerful plugin
for his e-commerce website.
* Manny is based in Canada and already has an account on the exchange
"MYCOIN" which supports the Crypto Open Exchange Protocol.
* Manny connects to the exchange website, and creates a new address source.
* In the configuration screen of the address source, for each payment sent
to this address source, Manny decides to keep 30% in Bitcoin and place a
market sell order for the remaining 70% of the amount.
* "MYCOIN" creates the address source, and gives the "address source URI"
to the merchant. (e.g. * Manny copies the address source URI and goes inside "PROCCO" settings,
and configures his store to use this address source URI.
Now a customer, Carol, wants to order a brand new phone for 0.01 BTC on
Manny's store and decides to pay in Bitcoin.
* The E-Commerce website plugin requests the creation of an invoice from
* PROCCO queries the "address source URI" and retrieves the rate, the
expiration of this rate and conditions.
* PROCCO can now show the Bitcoin Payment Checkout page.
* Carla pays.
* PROCCO marks the payment as paid and redirects to the e-commerce website.
* MYCOIN, under its own policy (typically after 6 confirmations), credits
Manny's account of 0.01 BTC and simultaneously creates a market sell order
of 0.007 BTC on behalf of Manny.
The payment processor sends a POST request to the "address source URI", the
response from a Crypto Open Exchange Protocol exchange would be:
If the exchange does not guarantee the rate:
    {
        "depositAddress" : "13....abd",
        "currencyCode" : "CAD",
        "cryptoCurrencyCode" : "BTC",
        "rate" : "15600",
        # When the merchant account get credited on the exchange
        "requiredConfirmations" : blockcount
    }
If the exchange guarantee the rate:
    {
        "depositAddress" : "13....abd",
        "currencyCode" : "CAD",
        "cryptoCurrencyCode" : "BTC",
        "rate" : "15600",
        "requiredConfirmations" : blockcount
        "conditions" :
        {
            # When the transaction should be seen on the blockchain to
guarantee the rate
            "receivedBefore" : timestamp,
            # When the transaction should be confirmed on the blockchain to
guarantee the rate
            "confirmedBefore" : timestamp
        }
    }
The payment processor is responsible for giving feedback to the customer if
the fees of the received transaction are not enough to guarantee the rate.
==Note on adoption==
While local exchanges have incentives to implement this simple protocol, it
is not strictly needed.
An alternative is to develop an adapter server which expose Crypto Open
Exchange Protocol endpoint and connect to underlying exchange's API.
The only downside is that the rate can't be guaranteed.
This document is dual licensed as BSD 3-clause, and Creative Commons CC0
1.0 Universal.

@_date: 2017-12-21 17:20:11
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] BIP Proposal: Crypto Open Exchange Protocol (COX) 
Thanks a lot for the feedback
The good part is that it does not have to be adopted by exchanges. If
popular exchanges do not adopt it, it is trivial to make an adapter service
which translate COX to whatever proprietary API of the exchange.
Collaboration with the exchange is only needed if the exchange wants to
provide a service for taking the risk of volatility.
BTC and like what you are trying to do.  One of the biggest hurdle?s I see
for merchants to adopt BitCoin today is the transaction fee.
This BIP supports alternatives currencies.
Should some additional shared-secret or cookie / macaroon based
authentication be added?
Yes, I must add guidelines (SSL and how to manage the addresses). I don't
think authentication is needed as the merchant is the only one having
access to the source URI. This can be considered as a shared secret.
Even if this secret leaks, no funds are in danger.
security / privacy constraints must be server-to-server?
Thanks, I need to clarify the scope. But indeed, this is not meant to be
used by a browser, as merchants will not host their payment processors on
their mobile or browser.
the above details to individual implementers is probably going to result in
bad things.
Thanks, I think you are right I should add more recommendations for
source never return the same address even if nothing is paid to it?
Otherwise someone could just crawl webshops to create an inventory of
payment addresses. A new address every page reload could be a DDOS vector.
It also wouldn't be compatible with BIP44 because of its gap limit,
although I don?t think that?s a huge problem for exchanges.
You are right, I must introduce a sort of "order id" so that one order map
to exactly one address response.
The DDOS vector will then be on the shoulder of the ecommerce website by
preventing users to create too much orders. (they certainly already do)
where the exchange sends a pre-image to the users wallet (relayed via and
retained by the web shop) upon receipt of the funds, which they can then
present to the merchant in case something went wrong. Exchanges might be
happy to support this protocol, but they don?t want the burden of dealing
with user support requests, so having signed invoices could help with that.
This protocol can be expanded later for lightning trivially, where the call
to the address source uri also returns a lightning payment request. (BOLT11)
to peer counterparties to convert to fiat, so their customer information
and revenue figures aren?t in the hands of a single counter party.
Obviously that?s a can of worms today, but it would be nice if the protocol
was able to support that if one day someone figures out the fraud,
compliance and bookkeeping stuff.
Conversion to fiat always need trust, so we must rule out anonymous
parties. If you want to spread on several trusted party, this can be done
transparently at the payment processor level, and does not requires change
to the protocol.
software to talk to a Bitcoin wallet that?s hosted somewhere else for
similar reasons. Right now the best these plugins can do is hold on to an
XPUB, and I?ve even seen solutions that just send the customers coins to
their own backend wallet and then forward it.
Because BIP70/XPUB already solves the problem. (Which I already use in
BIP70 is a pain in the ass to implement and does not provide any benefits,
and it does not define a way for the exchange to communicate a rate
attached to the bitcoin address, nor define a way to communicate to the
payment processor the conditions under which they can bear volatility risk.
I will revisit the BIP based on your feedback.

@_date: 2019-04-03 16:51:04
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev]  assumeutxo and UTXO snapshots 
You might be interested by my work which is currently used in production,
without any change to bitcoin core.
I properly explain how to verify the utxoset independently.
People are using it, since I get around 10 download a day.
What can be done to help at Bitcoin Core level is actually very minimal.
First, instead of asking signers of by UTXOSet to sign the utxoset hash
from gettxoutsetinfo, I ask them to sign the hash of the tarball of my UTXO
The reason is that it is currently impossible to stop BitcoinD on a
specific block then asking the serialized hash of the UTXO Set.
So instead, a verifier download the tarball (300 blocks + utxoset at
specific height), sync to the latest block, then compare the
gettxoutsetinfo of the newly synched node with another trusted node. If it
match, the verifier sign the tarball.
I create a new utxoset snapshot every 6 months, so people have time to
verify it and add their signatures. (Approximately once every bitcoin core
The easiest thing that could be done at Bitcoin Core level does not require
any code change, but a change in the release process.
The new process would be to ask to the gitian signers to not only build the
source themselves, but also verify a tarball following the procedure I
explain in the link above.
More complicated solution like signing the serialized utxoset itself, while
possible, would require bothersome code changes.
On Wed, Apr 3, 2019 at 9:25 AM <

@_date: 2020-05-17 04:46:35
@_author: Nicolas Dorier 
@_subject: [bitcoin-dev] BIP Number request for a simple payjoin proposal 
I am requesting a BIP number to be allocated for this simple payjoin proposal.
This proposal is already being implemented by several service and
wallets and incorporate the feedback of the community at
I opened a pull request at: I am not checking my mail very often, so I suggest give me feedback
directly on the opened pull request.
  BIP: ?
  Layer: Applications
  Title: A Simple Payjoin Proposal
  Author: Nicolas Dorier   Comments-Summary: No comments yet.
  Comments-URI:   Status: Draft
  Type: Standards Track
  Created: 2019-05-01
  License: BSD-2-Clause
This document proposes a protocol for two parties
to negotiate a coinjoin transaction during a payment between them.
This BIP is licensed under the 2-clause BSD license.
When two parties (later referred to as sender and receiver) want to transact,
most of the time, the sender creates a transaction spending their own
Unspent Transaction Outputs (UTXOs), signs
it and broadcasts it on the network.
This simple model gave birth to several heuristics impacting the
privacy of the parties and of the network as a whole.
* Common input ownership heuristic: In most transactions, all the
inputs belong to the same party.
* Change identification from scriptPubKey type: If all inputs are
spending UTXOs of a certain scriptPubKey type, then the change output
is likely to have the same scriptPubKey type, too.
* Change identification from round amount: If an output in the
transaction has a round amount, it is likely an output belonging to
the receiver.
We will designate these three heuristics as common-input,
change-scriptpubkey, change-round-amount.
The problems we aim to solve are:
* For the receiver, there is a missed opportunity to consolidate their
own UTXOs or making payment in the sender's transaction.
* For the sender, there are privacy leaks regarding their wallet that
happen when someone applies the heuristics detailed above to their
Our proposal gives an opportunity for the receiver to consolidate
their UTXOs while also batching their own payments, without creating a
new transaction. (Saving fees in the process)
For the sender, it allows them to invalidate the three heuristics
above. With the receiver's involvement, the heuristics can even be
poisoned. (ie, using the heuristics to intentionally mislead
blockchain analysis)
Note that the existence of this proposal is also improving the privacy
of parties who are not using it by making the three heuristics
unreliable to the network as a whole.
=== Relation to BIP79 (Bustapay) ===
Another implementation proposal has been written:
We decided to deviate from it for several reasons:
* It was not using PSBT, so if the receiver wanted to bump the fee,
they would need the full UTXO set.
* The receiver was responsible to pay the additional fee, not the sender.
* It was requiring at least one input to be contributed by the receiver.
* Inability to change the payment output to match scriptPubKey type.
* Lack of basic versioning negotiation if the protocol evolves.
* No standardization of error condition for proper feedback to the sender.
Other than that, our proposal is very similar.
In a payjoin payment, the following steps happen:
* The receiver of the payment, presents a [[bip-021.mediawiki|BIP 21
URI]] to the sender with a parameter pj describing an
https (or http if it is a Tor hidden service) link to the payjoin
* The sender creates a signed, finalized PSBT with witness UTXO or
previous transactions of the inputs. We call this PSBT the
* The receiver replies back with a signed PSBT containing his own
signed inputs/outputs and those of the sender. We call this PSBT
Payjoin proposal.
* The sender verifies the proposal, re-signs his inputs and broadcasts
the transaction to the Bitcoin network. We call this transaction
Payjoin transaction.
+----------+                        +--------+         +-----------------+
+----+-----+                        +---+----+         +-------+---------+
       +-----------------+        |                      |
     +-------+ BIP21 with ?pj= +------->+                      |
       +-----------------+        |                      |
                                  |                      |
        +---------------+         |                      |
     +<-------+ Original PSBT +---------+                      |
        +---------------+         |                      |
                                  |                      |
       +------------------+       |                      |
       | Payjoin Proposal |       |                      |
     +-------+      PSBT        +------>+                      |
       +------------------+       |                      |
                                  |   +--------------+   |
                                  |---+ Payjoin      |   |
                                  |   | transaction  +-->+
                                  |   +--------------+   |
     +                                  +                      +
The original PSBT is sent in the HTTP POST request body, base64
serialized, with text/plain in the
Content-Type HTTP header and Content-Length
set correctly.
The payjoin proposal PSBT is sent in the HTTP response body, base64
serialized with HTTP code 200.
To ensure compatibility with web-wallets and browser-based-tools, all
responses (including errors) must contain the HTTP header
Access-Control-Allow-Origin: *.
The sender must ensure that the url refers to a scheme or protocol
using authenticated encryption, for example TLS with certificate
validation, or a .onion link to a hidden service whose public key
identifier has already been communicated via a TLS connection. Senders
MUST NOT accept a url representing an unencrypted or unauthenticated
===Receiver's well known errors===
If for some reason the receiver is unable to create a payjoin
proposal, it will reply with a HTTP code different than 200.
The receiver is not constrained to specific set of errors, some are
specified in this proposal.
The errors have the following format:
    "errorCode": "leaking-data",
    "message": "Key path information or GlobalXPubs should not be
included in the original PSBT."
The well-known error codes are:
{| class="wikitable"
!Error code
original PSBT.
payjoin proposal.
The receiver is allowed to return implementation specific errors which
may assist the sender to diagnose any issue.
However, it is important that error codes that are not well-known and
that the message do not appear on the sender's software user
Such error codes or messages could be used maliciously to phish a non
technical user.
Instead those errors or messages can only appear in debug logs.
It is advised to hard code the description of the error codes into the
sender's software.
===Receiver's original PSBT checklist===
The receiver needs to do some check on the original PSBT before proceeding:
* Non-interactive receivers (like a payment processor) need to check
that the original PSBT is broadcastable. *
* If the sender included inputs in the original PSBT owned by the
receiver, the receiver must either return error
invalid-transaction or make sure they do not sign those
inputs in the payjoin proposal.
* If the sender's inputs are all from the same scriptPubKey type, the
receiver must match the same type. If the receiver can't match the
type, they must return error out-of-utxos.
*: Interactive receivers are not required to validate the
original PSBT because they are not exposed to probing attacks.
===Sender's payjoin proposal checklist===
The sender should check the payjoin proposal before signing it to
prevent a malicious receiver from stealing money.
* Check that all the spent outpoints in the original PSBT still exist
in the coinjoin PSBT.
* Check that all the spent outpoints in the original PSBT do not have
any partial signature.
* If the sender is not using inputs with mixed types, check that the
receiver inputs type match the inputs type of the sender. (ie. both
using P2SH-P2WPKH or both using P2WPKH)
* Check that any inputs added by the receiver are finalized.
* Check that the transaction version, and nLockTime are unchanged.
* Check that the sender's inputs' sequence numbers are unchanged.
* If the sender's inputs' sequence numbers the homogenous, check that
the receiver's contributed inputs match those.
* Check that the sender's outputs have not been modified (but
potentially shuffled), except for paying increased fee
* If sender specified feebumpindex= (see later), the fee
should have been subtracted from the output at the same index in the
original PSBT.
* Check that the sent amount in the payjoin proposal is less than or
equal to the sent amount of the original transaction.
If the sent amount in the payjoin proposal is above the amount sent in
the original PSBT
* Check that the additional paid amount has been add paid to the fee.
* Check that the estimated fee rate of the payjoin proposal is not
more than the fee rate of the original PSBT. (fee estimation is hard,
so we should allow ~2 satoshi per inputs as margin of error)
* If maxfeebumpcontribution= was specified, check the
additional paid amount is less than or equal to this amount.
* If maxfeebumpcontribution= was not specified, the
sender's software should ask an interactive confirmation to the user.
The sender must be careful to only sign the inputs that were present
in the original PSBT and nothing else.
* The sender should allow the payment output to be modified by the
receiver (The receiver may substitute a P2WPKH payment to P2SH payment
to increase privacy)
* The sender must allow the receiver to add outputs.
* The sender must allow the receiver to not add any input. Useful for
the receiver to change the paymout output scriptPubKey type.
* If no input has been added, the sender's wallet should accept the
payjoin proposal, but should not mark the transaction as an actual
payjoin in the user interface.
Our method of checking the fee allows the receiver and the sender to
batch payments in the payjoin transaction.
It also allows the receiver to pay the fee for batching adding his own outputs.
===Optional parameters===
When the payjoin sender posts the original PSBT to the receiver, he
can optionally specify the following HTTP query string parameters:
* v=, the version number of the payjoin protocol that the
sender is using. The current version is 1.
This can be used in the future so the receiver can reject a payjoin if
the sender is using a version which is not supported via an error HTTP
400, version-unsupported.
If not specified, the receiver will assume the sender is v=1.
If the receiver does not support the version of the sender, they
should send an error with the list of supported versions:
    "errorCode": "version-unsupported",
    "supported" : [ 2, 3, 4 ],
    "message": "The version is not supported anymore"
* feebumpindex=, the preferred output from which to
increase the fee for the added inputs. (default: -1)
If the feebumpindex is out of bounds or pointing to the
payment ouptut meant for the receiver, the receiver should ignore the
* maxfeebumpcontribution=, an integer defining the
maximum amount in satoshis that the sender is willing to contribute
towards fees for the additional inputs.
maxfeebumpcontribution must be ignored if set to less
than zero. (default: -1)
Note that if maxfeebumpcontribution is too low, the
sender should create a transaction with RBF disabled, as the original
transaction could replace the payjoin transaction.
There is several consequences of our proposal:
* The receiver can bump the fee of the original transaction.
* The receiver can modify the outputs of the original PSBT.
* The sender must provide the UTXO information (Witness or previous
transaction) in the PSBT.
===Respecting the minimum relay fee policy===
To be properly relayed, a Bitcoin transaction needs to pay at least 1
satoshi per virtual byte.
When fees are low, the original transaction is already 1 satoshi per
virtual byte, so if the receiver adds their own input, they need to
make sure the fee is increased such that the rate does not drop below
1 satoshi per virtual byte.
===Preventing mempool replacement===
A safe way to implement payjoin, is for both the sender and receiver
to try broadcasting the original transaction at some fixed interval
period regardless of the state of the payjoin.
If the receiver was not properly adding fees to the payjoin
transaction, the original transaction would end up replacing the
payjoin transaction in the mempool.
===Defeating heuristics based on the fee calculation===
Most wallets are creating a round fee rate (like 2 sat/b).
If the payjoin transaction's fee was not increased by the added size,
then those payjoin transactions could easily be identifiable on the
Not only would those transactions stand out by not having a round fee
(like 1.87 sat/b), but any suspicion of payjoin could be confirmed by
checking if removing one input would create a round fee rate.
===Receiver does not need to be a full node===
Because the receiver needs to bump the fee to keep the same fee rate
as the original PSBT, it needs the input's UTXO information to know
what is the original fee rate. Without PSBT, light wallets like Wasabi
Wallet would not be able to receive a payjoin transaction.
The validation (policy and consensus) of the original transaction is
optional: a receiver without a full node can decide to create the
payjoin transaction and automatically broadcast the original
transaction after a timeout of 1 minute, and only verify that it has
been propagated in the network.
However, non-interactive receivers (like a payment processor) need to
verify the transaction to prevent UTXO probing attacks.
This is not a concern for interactive receivers like Wasabi Wallet,
because those receivers can just limit the number of original PSBT
proposals of a specific address to one. With such wallets, the
attacker has no way to generate new deposit addresses to probe the
===Spare change donation===
Small change inside wallets are detrimental to privacy. Mixers like
Wasabi wallet, because of its protocol, eventually generate such
A common way to protect your privacy is to donate those spare changes,
to deposit them in an exchange or on your favorite merchant's store
account. Those kind of transactions can easily be spotted on the
blockchain: There is only one output.
However, if you donate via payjoin, it will look like a normal transaction.
On top of this the receiver can poison analysis by randomly faking a
round amount of satoshi for the additional output.
===Payment output substitution===
The receiver is free to change the output paying to himself.
For example, if the sender's scriptPubKey type is P2WPKH while the
receiver's payment output in the original PSBT is P2SH, then the
receiver can substitute the payment output to be P2WPKH to match the
sender's scriptPubKey type.
===Impacted heuristics===
Our proposal of payjoin is breaking the following blockchain heuristics:
* Common inputs heuristics.
Because payjoin is mixing the inputs of the sender and receiver, this
heuristic becomes unreliable.
* Change identification from scriptPubKey type heuristics
When Alice pays Bob, if Alice is using P2SH but Bob's deposit address
is P2WPKH, the heuristic would assume that the P2SH output is the
change address of Alice.
This is now however a broken assumption, as the payjoin receiver has
the freedom to mislead analytics by purposefully changing the
invoice's address in the payjoin transaction.
Alternatively, if the original address of Bob is P2WPKH and Alice's
address is also P2WPKH, Bob can change the receiving address in the
payjoin to P2SH. The heuristic would wrongfully identify the payjoin's
receiving address as the change address of the transaction.
See payment output substitution above.
* Change identification from round change amount
If Alice pays Bob, she might be tempted to pay him a round amount,
like 1.23000000 BTC. When this happens, blockchain
analysis often identifies the output without the round amount as the
change of the transaction.
For this reason, during a [spare
change](Payjoin-spec.md situation, we randomly
round the amount in the output added by the receiver to the payjoin
==Attack vectors==
===On the receiver side: UTXO probing attack===
When the receiver creates a payjoin proposal, they expose one or more
inputs belonging to them.
An attacker could create multiple original transactions in order to
learn the UTXOs of the receiver, while not broadcasting the payjoin
While we cannot prevent this type of attack entirely, we implemented
the following mitigations:
* When the receiver detects an original transaction being broadcast,
or if the receiver detects that the original transaction has been
double spent, then they will reuse the UTXO that was exposed for the
next payjoin.
* While the exposed UTXO will be reused in priority to not leak other
UTXOs, there is no strong guarantee about it. This prevents the
attacker from detecting with certainty the next payjoin of the
merchant to another peer.
Note that probing attacks are only a problem for automated payment
systems such as BTCPay Server. End-user wallets with payjoin
capabilities are not affected, as the attacker can't create multiple
invoices to force the receiver to expose their UTXOs.
===On the sender side: Double payment risk for hardware wallets===
For a successful payjoin to happen, the sender needs to sign two
transactions double spending each other: The original transaction and
the payjoin proposal.
The sender's software wallet can verify that the payjoin proposal is
legitimate by the sender's checklist.
However, a hardware wallet can't verify that this is indeed the case.
This means that the security guarantee of the hardware wallet is
decreased. If the sender's software is compromised, the hardware
wallet would sign two valid transactions, thus sending two payments.
Without payjoin, the maximum amount of money that could be lost by a
compromised software is equal to one payment (via address
With payjoin, the maximum amount of money that can be lost is equal to
two payments.
* [[ is in the
process of implementing the protocol.
* [[ Server]] has
implemented sender and receiver side of this protocol.
* [[ Wallet]] has
merged sender's support.
* [[
Market]] is in the process of implementing the protocol.
* [[ sender
==Special thanks==
Special thanks to Kukks for developing the initial support to BTCPay
Server, to junderw, AdamISZ, lukechilds, ncoelho, nopara73, yahiheb
for all the feedback we received since our first implementation.
Thanks also to RHavar who wrote the
Bustapay]] proposal, this gave a good starting point for our proposal.
