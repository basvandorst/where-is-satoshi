
@_date: 2013-08-16 12:37:50
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] BIP 32.5 
I personally like the full-measure of eliminating the "CS-PRNG" entirely   from signing. If the "random" component is assumed to be untrusted,  keeping it in there adds no value, while eschewing the main benefit of  deterministic signing (ease of testing, auditing)
This just leaves the CS-PRNG at the heart of the security system -- when  generating the root master key of an HD wallet. Adding to what Mike said,  a single invocation of a CS-PRNG driving all subsequent keys increases the  attack value if that one invocation turns out to be weak. By comparison,  at least compromised DSA signatures were one-off events which didn't allow  theft of funds beyond the one compromised address.
Cumulative / rolling entropy collection over time through multiple CS-PRNG  invocations, or multiple entropy sources, could serve to recover from an  "occasionally weak" CS-PRNG. I've read claims that this is bad practice  because a single low entropy source can take entropy out of the result,  but this seems like FUD. If you're using SHA512-HMAC to hash chain a few  entropy sources, even "return 4; // chosen by random dice roll" is not  going to help, but it's not going to hurt.
The DSA 'repeated-k' basically advertises itself on the block-chain and  people were actively scanning for this weakness, whereas a weak key in the  BIP32 root might not be as apparent, so exploitation may be more  difficult, but also more insidious. Of course this depends on the exact  failure mode of the CS-PRNG being used -- I wonder if anyone is searching  for BIP32 keys based off of one of the 32k Debian random numbers being  used as a master key?
Smartphones in particular have lots of sensors which could provide  entropy. For example, if you pulled 64 bytes from "secure random", you  could at least HMAC that with the SHA512 of a picture or a short video  sample taken by the user. I'm guessing some people would cringe at this,  but it seems to me like it provides some measure of protection to justify  the increased code complexity.
TL;DR - Really like the idea of minimizing CS-PRNG use whenever possible  (deterministic signing) and also would love to learn more best practices  for placing less trust in the so called "CS-PRNG" when we do have to use

@_date: 2013-12-03 17:45:44
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Floating fees and SPV clients 
Thanks for the draft specs Gavin. Very clear and precise.
Personally I think 'allowfee' is more useful than 'minfee'. The 'allowfee'  tells me something very useful and definitive about what the merchant will  let me do when making payment, and if the merchant chooses 'allowfee'  intelligently, they can provide real value to their customers without  exposing them to undue risk.
A 'minfee' field on the other hand, is just a data point for the wallet  software to consider, and likely to be noisy enough that wallets will tend  to ignore it. (e.g. like Drak's example of Gox's 0.001 fee)
The sender's wallet software will always be free to choose the fee, and  paying less than the 'allowfee' or 'minfee' can still get a TX included in  the next block.
I think of the PaymentRequest is a part of the purchase contract. If a  payer transmits a transaction before 'expires' but with less than  'minfee', which gets included in the next block, have they  failed to meet  the terms of payment?
If there is some time criticality, for example to reduce exchange rate  risk, then a wallet might need to choose a higher fee to ensure the  transaction clears in time. Instead of 'minfee' I'm thinking it would be  more appropriate to communicate this using the existing 'expires' field --  in other words, let the merchant express what their requirement is, not  tell the wallet how to achieve it.
In the case of a transaction with too-low fee, either the payer can  double-spend with a higher fee, or wait longer for the transaction to make  it into a block. If it hits the blockchain before the 'expires' time, then  the merchant should have no standing to refute it, regardless of the  amount of fees paid.
A refund comes into play if a payer reduced the total amount in excess of  an agreed upon 'allowfee', or if the transaction doesn't hit the  blockchain until after 'expires'. It should be clear in these cases that  payer would end up eating the fees in both directions. But then, what if a  wallet pays the 'minfee' and broadcasts 1 block before 'expires' but the  payment DOESN'T make the block? Is the merchant liable for too-slow  transactions due to their own insufficient 'minfee' value?
So I see 'allowfee' as extremely useful, but 'minfee' as somewhat

@_date: 2013-12-08 22:29:25
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
I can provide the server hardware and colocation (space, power, and  bandwidth) if dedicated 50Mbit in 55 S. Market, San Jose, CA data center  is acceptable.
If it needs more bandwidth than that, in a few months I hope to be getting  space in LA with 1Gbit, but I can't commit to that now.

@_date: 2013-12-19 22:48:53
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] BIP proposal: Authenticated prefix trees 
Wow there's a lot here to think about. I'm pretty sure I haven't grasped  the full implications yet.
I see it proposes to also introduce additional BIPs describing the use of  the data stucture for stateless validation & mining, the UBC address index  for "SPV+" operating modes, document timestamping and merged mining.
Can the BIP stand alone as a BIP without some specific changes to the  protocol or end-user accessible features defined within it? It seems like  an extremely useful data stucture, but as I understand it the purpose of  BIPS is defining interoperability points, not implementation details?
Unless the tree itself is becoming part of the protocol, seems like its  spec, test vectors, and reference implementation can live elsewhere, but I  would love to read about BIPS which use this tree to accomplish some  amazing scalability or security benefits.

@_date: 2013-12-24 00:52:46
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Peer Discovery and Overlay 
Some really nice efforts out there to map and analyze the bitcoin P2P  The current protocol apparently recommends returning up to 2500 addresses   from 'getaddr'. I'm not sure how much clients are expected to probe the  address space in order to select 'far-apart' peers, or how much such an  process would even attempt to achieve.
How much does it matter if the ability to discover the entire network of  peers is fast or slow? There are probably pros and cons to both.
Is there any thought to how existing bitcoin node relations, and the ease  at which peers can be discovered, becomes a service in itself, or even  possibly a vulnerability?
Are there any past instances of applications hijacking or interfacing with  the exiting p2p messages, or abusing 'getaddr' functionality? Are there  any guidelines on this, or should there be?

@_date: 2013-12-27 23:29:52
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Access to Mempool 
I was reading there are some commands to access a peer's mempool state.  The purpose being to allow miners to recover faster after a reboot, I  Reading peer mempool definitely allows recovering faster after a reboot.  So does persisting mempool in a database locally. But what can you learn  about a node from its mempool? Basically, are there distinguishing  features in the mempool, or could there be?
Are there transactions you can receive which go into your own mempool but  which you don't forward? How about 'nLockTime' transactions?
Is this new feature off by default? Which clients support it?
By the way, are there recommended places to go to compare features  implemented by different wallet software?
Sorry, so many questions...

@_date: 2013-12-30 23:28:10
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Merge mining 
Merge mining lets Bitcoin miners support or attack an alt-coin without any  additional cost for their proof-of-work.
Since bitcoin miners have to install software to build and claim blocks in  the alt-coin, the percentage of bitcoin hashing power reflected toward the  alt-coin will follow some adoption curve based on convincing bitcoin  miners to opt-in.
Depending on where you are on that adoption curve or 'participation rate',  you need [a lot] less than 51% of of total Bitcoin hashing power in order  to 51% attack the alt-coin.
But there's so much 'dry powder' out there (GPUs), I wonder if *not*  supporting merge-mining is any better? At least the attacker has to do  some unique PoW, so you hope it's costing them something. Relatively large  amounts of hashing can definitely be deployed on target with zero startup  cost, and perhaps very little runtime cost (botnets).
I think the absolute cost of the PoW is very likely *not* the determining  factor in preventing a 51% attack on all but one or two blockchains  currently in existence.
Do I understand correctly, the question here is mostly a matter a game

@_date: 2013-12-31 13:25:40
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
I didn't know about the dedicated server meltdown, it wasn't any of my  infra. Anyway, my previous offer still stands.
One less 'security theater' approach would be if we could provide  forward-validation of updates using the blockchain. It's always going to  be up to the user the first time they install the wallet to verify the  provenance of the binaries/source. From that point forward, we could make  it easier if the wallet could detect updates and prove they were valid.
This could be as simple as hard-coding a public key into the client and  checking a signature on the new binaries. But it could also be more  For example, a well known address on the blockchain corresponds to  multi-sig with keys controlled by developers (or whatever key policy the  release team wants to impose). A spend from that address announces a new  release, and includes the expected hash of the file.
You would probably need some way to handle the different release targets.  A more rigorous approach could identify all the various releases in terms  of a BIP32 xpubkey whose branches would correspond to the different  release trains and platform builds. Spends from a node announce the  release and the expected hash.
This provides zero benefit if the wallet software is already compromised,  but I think this would allow trusted automatic update notification, and a  trusted way to deliver the expected hashes. It also might resolve some of  the consternation around when a release is truly "released", if that's  really a problem.
I'm not sure how far along the slope you would want to go; 1) announcing  updates in the UI, 2) providing a button the user could click to verify a  binary matches its expected hash, 3) click to download and verify the  upgrade matches the expected hash, 4) click to upgrade
Formalizing the release process around a set of privkeys (or split shares  of keys) may raise its own set of questions.
For the download itself, I've heard the advocates of announcing  availability on the blockchain leading to a BitTorrent magnet link, but I  also understand objections to adding an entire BitTorrent stack into a

@_date: 2013-06-19 12:29:19
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Optional "wallet-linkable" address format 
If you have two parties who want to form a persistent relationship, by exchanging and verifying public keys beforehand, then I think the canonical way to do this with BIP32 is for the parties to exchange PubKey and *ChainCode*.
I don?t understand the use case for handing out individual multipliers, if what you desire is a persistent relationship. If each party dedicates a child-wallet for receiving coins, and saves a PubKey/ChainCode for sending coins, the two parties can transaction securely forever without ever exchanging any more information, and without any address reuse.
I think ideally, the default behavior is that wallets always dedicate a new child node {PubKey, ChainCode} to each party they transact with. At the presentation layer, you have a ?contact? and each contact has a transaction history. You can send coins to a contact at any time, and internally the wallet picks the next address in their sequence. Any funds received on pubkeys from contact?s sequence are attributed to that contact. The wallet can organize the contacts, and roll-up the transaction history into ?ledgers? and ?balances? however they want ? it could be based on the underlying BIP32 hierarchy or perhaps not. The cost of watching large a number of pubkeys, even if you ?look ahead? 100 pubkeys for each contact, is relatively small versus the benefits.
What might be nice is a ?Contact Request? protocol, basically the same as a PaymentRequest but no actual payments are sent, just child wallets created:
message Contact {
    optional uint32 contact_version = 1 [default = 1];
    optional string pki_type = 2 [default = "none"];
    optional bytes pki_data = 3;
    required bytes serialized_contact_details = 4;
    optional bytes signature = 5;
message ContactDetails {
    optional string network = 1 [default = "main"];
    required bytes pubkey = 2;
    required bytes chaincode = 3;
    optional string memo = 4;
    optional string response_url = 5;
Alice sends a Contact+ContactDetails to Bob.  If Bob accepts, he sends his own Contact+ContactDetails (without a response_url) back to Alice. Basically just like adding a contact to your IM contacts.
Alice could send a Contact+ContactDetails to Bob without a response_url, in which case after accepting the contact, Bob could send funds to Alice, but not receive funds.
You could probably pack the whole message inside a bitcoin:// URI if you wanted to.

@_date: 2013-06-19 14:58:06
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Optional "wallet-linkable" address format 
Hi Alan,
What do you think is missing from BIP32 for this? A wallet creates a child-node using the public / type-2 CDF, hands out the PubKey/ChainCode, and then generally expects transactions to come in starting at /0 and incrementing monotonically.
Also, I'm not sure I follow your point about the 128kB hardware wallet --  it's a signing device, so assuming it's even validating output amounts, at worst it cares about the number of inputs to the outputs being spent, but in many cases you're just handing it a sighash and the BIP32 "path" (/1/54/27/0) to generate the right private key for signing. The hardware wallet is not actually listening on the P2P network and detecting payments, so it's unaffected by dedicating child-nodes to each contact.
Consider the benefits of gaining critical mass of support for a technique which [I think] can be used in all cases, and increases security and privacy for everyone. I think there are huge benefits to leaving the age of 'single address generation' behind us...
--Jeremy

@_date: 2013-06-19 20:54:18
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Optional "wallet-linkable" address format 
Initially I was thinking that you would share the public key and chain code from [m/i'/0] so that you can receive payments for a unique value of 'i' for each receive chain.
For the case of generating new receive chains from a *watch-only* wallet, as you say, the options are to either keep a cache of PubKey/ChainCode for unused [m/i'] or simply increment 'j' past 1 for an existing [m/i'/j] -- the concept of 'internal/'external' and change addresses at Depth=2 don't make sense for handing out receive chains to lots of people anyway, and certainly BIP32 doesn't *require* 0 <= j <= 1.  So I think incrementing 'j' is the way to go here...
The "default" layout of BIP32 does NOT mean that implementations should not check for transactions with j > 1. That would be a useless constraint and obviously self-limiting. It might be helpful to add to the 'Compatibility' section some minimum expectations about how a wallet should be 'probed' when imported. If you don't feel completely free to monotonically increment 'j' to your hearts content to achieve major usability benefits, then I say BIP32 could use some clarifying.
BTW - the spec calls for addition not multiplication now, so we should call it the 'Addend' not the 'Multiplier' :-)
They could, but they certainly don't need to!  A single-wallet implementation treats this merely as an address-generation algorithm, and does not expose any hierarchy to the user interface.  The user just ?magically? gets the ability to send multiple payments to their contacts without immediately sacrificing their privacy ( Everything goes into the same ledger, balance, coin pool, etc. Most of the code base is unaware BIP32 is even in use.
While it is *possible* to support separate ledgers, balances, etc. it is certainly not required, and you get all the benefits either way.
I think, since your proposal generates and receives payments into BIP32-style addresses, we both need similar underlying wallet code. The only difference is that you are passing the Kpar for [m/i'/0/k] and the *result* of CKD'((Kpar, cpar), k), and instead I proposed passing Kpar and cpar, and leaving 'k' out of it, letting the receive choose 'k'.
I think it's a interesting idea using static public keys as a means for persistent identity and hence security from MitM. If you want a shared public key across multiple services we could just combine both ideas and get all the benefits, by making the data structure { ParentPubKey, Addend, ChainCode }:
   ParentPubKey: Public key of m/i' -- 33 bytes
   Addend: I[L]*G from CDK'(m/i', j) -- 33 bytes
   ChainCode: I[R] from CDK'(m/i', j) -- 32 bytes
All that remains secret is the ChainCode from [m/i'] -- and of course the private keys.  The ParentPubKey is a common value across multiple services, corresponding to user's identity rooted in [m/i'].  Each service gets their own 'j'.  ParentPubKey + Addend gives you the PubKey of [m/i'/j].  With the ChainCode, the receiver then can generate [m/i'/j/k] for monotonically increasing 'k'. Again, from the user perspective all transactions under [m/i'] can be presented in a single ledger, or not.
Anyway, fundamentally my feedback is if you are designing for persistent long-term relationships, you could build in a mechanism for generating address chains so you don't need any further communication after the initial exchange, and it need not complicate the wallet.
--Jeremy

@_date: 2013-06-20 02:10:26
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Optional "wallet-linkable" address format 
OK - I think I follow now.  So a third-party who does not see any of the communication between the payer and payee only knows the HASH160.  Let's say the payee denies receipt of the funds....
It's easy to prove what public key it was sent to (it's the preimage), but you can't prove the parent of that public key. You can provide any number of ParentPubKey * Multiplier that could have been used, so the 3rd party is unconvinced by a "matching" ParentPubKey * Multiplier.
However, if you calculated the destination using: PubKeyParent * HMAC(Multiplier,PubKeyParent) as Timo said, now if you give the 3rd party a PubKeyParent and Multiplier (or Addend) that produces the destination address, you've proven the payment is in fact spendable by PubKeyParent, and they can't deny receipt. Very cool.
Sorry for "echoing" this back, it took me a little while to work it out, so I thought I'd write it down. Hope I got it right...
If you give {PubKey, ChainCode} you do get this feature. If you give {ParentPubKey, Addend} or {ParentPubKey, Addend, ChainCode} you're back to having plausible deniability.
If BIP32's CKD'((Kpar, cpar), i) was actually HMAC(HMAC(cpar, i), Kpar) you could give HMAC(cpar, i) instead of Addend, and then you would get this feature; a way to 'skip down' a level in the wallet hierarchy, keep the 'chain of custody' so to speak back to the ParentPubKey intact, without having to disclose the ChainCode. Meh...

@_date: 2013-11-05 10:57:34
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] BIP proposal - patch to raise selfish 
Great paper Ittay, thanks for all your work on this.
Fig. 2 captures this well, the threshold is only zero if 'y' is 1. In  Section 6 and 6.1 you argue y -> 1 but the sybil attack you describe,  isn't that more like how *all* sophisticated miners would want to ensure  their blocks are widely propagated? I think you can't assume only the  selfish miner is doing it.
Based on the current  'first seen' algorithm, as you say, competing  longest chains happen about every 60 blocks.  The rest of the time, a  single block propagates through the vast majority of the network  'uncontested'.  If there are multiple valid longest blocks being  simultaneously propagated, then  propagation pattern of the competing  blocks will determine hash rate on each.
Selfish mining requires exploiting the race condition between learning  about a competing block, and publishing your own. Usually we talk about  minimizing publishing latency so that your block ends up uncontested 59/60  times, and in the 1/60 times, even then your block has the best chance of  Selfish mining forgoes the 59/60 chance of your block being uncontested,  and instead chooses to 'race the network' every time. You start 'one step  behind' the competing block (since of course you only learn about it after  it starts propagating), so you must rely on being able to outrace  propagation of the competing block through a private low-latency  side-network which can inject your block at multiple points throughout the  bitcoin p2p network to outrace the competitor.
I think it's a stretch to say 'y' is 0 with good connectivity. Even the  best connected mining pools today are concerned with this 'y' factor.
Here's a probably very dumb idea... to throw out one possible "solution"...
You want a way to fake-out the 'selfish miner' into disclosing their  blocks -- how can your force their hand to prevent them from accumulating  longer private chains?
What if you propagate (and relay) an encrypted block header which honest  miners will timestamp when they receive it, then 10 seconds later  propagate the decryption key to unblind it. But here's the catch - maybe  the decryption results in junk, maybe it results a new longer block. If  it's a real block then it gets priority based on when the ciphertext was  received instead of when the decryption key was received. Now 'selfish  miner' can't race the network anymore, because they are always in state 0'  and can't tell if they are up against a ghost, or a real competing block.  If they wait for the decryption key to check, it's too late, and they are  guaranteed to lose unless they can out-race the network, e.g. back at  t=50%. Of course there would need to be some way to anti-DDoS this which  allows for some amount of these fake-outs without letting them get out of

@_date: 2013-10-09 21:10:09
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] 0.8.5 with libsecp256k1 
Can this be combined with the ideas on deterministic signing to show  matching signatures with OpenSSL's implementation?
Not sure if that's worth much, since we would just be testing needles in a  very large haystack, but better than nothing?
On Wed, 09 Oct 2013 20:50:30 -0700, Warren Togami Jr.

@_date: 2013-10-24 12:43:15
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
Thanks Christian, this is a really interesting bit of history. My own  personal experience from when I wrote my own client and BCCAPI-ish server  was that the protocol specification on the Wiki was hugely valuable, and  rarely sent me astray. Supplement that with the occasional questions on   and then just coding, coding, coding and getting unit tests  to pass.
Nothing compares (IMO) to stepping through your own code watching the unit  tests run, scripts evaluate, calculating transaction hashes for the  different SIGHASH modes, and finally getting your first transaction into  the block chain. I really appreciated the .json files holding the unit  test data, which were easy to load into my own test harness, the tables on  the Wiki showing what the stack should look like at each point in a script  execution, and the diagrams showing transaction signing.
Bitcoin takes some time to "grok" when you first approach; more than a  day, less than a month, and really no amount of reading documentation or  specs will get you to that "ah ha" moment. When the fog lifts and the  blockchain, scripting, signing, and wallet handling really click, suddenly  the bitcoind code (and many other great public sources in just about any  language you could want) actually does starts to feel fairly simple and  obvious. But it certainly doesn't start out that way on day one.
I think the majority of client code development is actually people writing  'agents' not end-user P2P wallets, and they tend to be written to connect  to a single bitcoind acting as a proxy to the network. Even some end-user  wallets work this way! As such, I spent very little time in my own client  writing P2P protocol code, no peer discovery code, no anti-DoS, etc.  Clients like this also don't pose much systemic risk, because they don't  mine, they don't connect directly to external nodes, etc. They can  certainly be used to "cause trouble" though, but so can  I chose to speak the P2P protocol to bitcoind versus using some of the  other options like ZeroMQ, but it still didn't take long to get headers,  blocks, and transactions downloading. I remember getting stuck on the very  first version message, because of missing the checksum and user-agent or  something caused the latest bitcoind to just ignore me. A little wireshark  capture of the exchange between two working bitcoind instances cleared it  right up. I didn't mind the leg work, I don't think everything needs to be  spoon fed, and it's certainly not purposefully obfuscated. Maybe one  exception is the mix-matched endianness will throw you off, especially if  you are developing on LE! Anyway, I have huge respect for how much effort  it takes to keep even small bits of documentation up-to-date. For as  "slow" as bitcoin moves, it's actually moving incredibly fast.
Finally, the bitcoind console and debug logs, as well sites like  blockchain.info and blockexplorer.com are hugely helpful for debugging raw  and live transactions for when you get stuck. There's a surprisingly large  tooling and support ecosystem out there.
Moral of the story, I think, is everything you need is there. No, it's not  all in one place. Yes, it takes time to find it and assimilate all that  knowledge. It also really helps that the community is extremely willing to  help and answer technical questions, and point you in the right direction,  even when you're working on your own private client code. The IRC channel  can certainly be intimidating because it seems like every time I hit enter  to send a question, gmaxwell's respond 300ms later would invoke an  immediate forehead slap and a groan of "shit, I knew/should have known  that, now I feel dumb" ;-) but if you're working on bitcoin, you better  get used to not being the smartest person in the room! The responses I got  were never arrogant or disparaging, but they were straight to-the-point  and surprisingly high quality. Ain't no slouches in that channel, yes you  will have to bring your A-game and you are expected to have "tried first"  before just asking. I have fairly limited experience working on open  source projects, but I'm extremely happy with my experience with the  Bitcoin community and found writing Bitcoin code hugely enjoyable.
The flip side to helping people implement their own clients, agents, or  even miners, is helping people to contribute pulls requests, or at the  very highest echelon, a BIP. If you haven't written any significant  Bitcoin code, you might want to consider investing in that first before  submitting a BIP. :-)
For a BIP to be valuable, often it requires widespread or even consensus  adoption. BIPs are probably not the place to toss just any old 'good idea'  because BIPs impose a cost on all active developers. I want to read and  understand 'all the BIPs' because for the most part they are actually  essential, like, how to handle duplicate transactions in BIP30 - if you  don't read BIP30 you very likely totally miss that, until your code throws  exceptions while processing block 91842.
And perhaps the hardest kind of BIP of all is the "lets get wallets to add  this user-facing feature" where it has no bearing on the blockchain or  transaction processing, it doesn't make the network more resilient or add  crucial functionality for increasing scalability. Kind of like JPK's HD  wallet encryption proposal, which I love, and I tried to contribute to in  the forums, but I can totally understand the headwinds for making progress  on BIPs like that one and BIP39. No one is against it per-say, it's just  much harder to articulate and justify the NEED for everyone to implement,  test, and support this new not-yet-standard, nice-to-have feature. For  those kinds of BIPs you probably have to go out and get some wallets to  implement it, or implement it yourself, to prove the value and kick start  critical mass before you will even get enough support for getting a BIP  number assigned. IMO, it's not a Bad Thing.
TL;DR; The current support systems worked very well for me. I was able to  accomplish all my goals, and I would even say it was a pleasure. Keep a  high bar for assigning BIP numbers. And I hope to be able to jump back in  and do more with Bitcoin soon.
Thanks all, sorry if I'm rambling,
Jeremy Spilman
On Thu, 24 Oct 2013 04:11:05 -0700, Christian Decker

@_date: 2013-10-25 00:51:22
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Making fee estimation better 
Gavin, can you confirm the best place to  read  up on the discuss fee  estimation changes for v0.9?
I think fee estimation at its core is about providing a data point, or  even call it an API, which can be used however you see fit.
What parameters do I want to see in a 'fee estimation' API?
  - 30 minutes vs 24 hours processing time
  - Confidence Levels (50%/90%)
What properties does the result have?
   - Is it globally consistent?
Talking about fees.. I read this:   and there is so much there I  really liked.
Any pointers for reading more about the leading theories on transaction  fees? For example, how well do they correlate with network security? Are  we getting what we are paying for? :-)

@_date: 2013-10-25 12:35:34
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Making fee estimation better 
Do you think we're at the point where wallets have to be able to "actively  bid" the fee using replacement due to block contention?
I think a fee estimation API is just a data point. Depending on the  properties of the estimator, and how that's presented in the UI, it could  serve to either increase or decrease the need for recovery.
Like you said, we already have "fee estimation" in the form of "user,  please estimate the fee!" Now we want to make fee estimation "better", and  one key aspect of better fee estimation is decreasing the need for  recovery. Techniques like signing multiple transactions with different fee  levels should become less useful the better you are at estimating the fee.
What I find interesting is that fee estimation can look at the size and  type of the transaction, the age of the inputs, the number of inputs  versus outputs, amount of the outputs, factor in [assumptions about] what  fee policies miners are actually using, and after all that, look at the  actual competing transactions on the blockchain and try to figure out how  many of those are even real.
For example, if you just look at fee-per-KB of mempool versus fee-per-KB  of recently mined transactions, without taking into account input age,  number of inputs vs outputs, output amounts... all the other things miner  might have used to discriminate between transactions, then I don't think  you'll end up with a better fee estimator.
Contention might bump you out of a few blocks, but if the basis for  calculating the fee is fundamentally compatible with the relay policies  and the transaction-inclusion policies being run by large mining pools,  the transaction isn't dead, it's just pending.

@_date: 2013-10-28 12:37:30
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Payment protocol for onion URLs. 
Just an aside...
The 1BTC bountry John references below is a 1BTC P2SH output, where the  redeemScript he provided does hash to the expected value, and is itself a  2-of-3 multisig, with the following pubkeys, expressed as addresses:
By comparison, the signatories for the 4BTC bountry are:
On the one hand, the vanity address makes it easy to guess who one of the  signatories is, on the other hand, is it bad form to reuse keys for  John, you mentioned wanting to disambiguate bounties, perhaps through a  bounty-specific pubkey. I'm not sure I follow, how is that better than  just referencing the address of the output, or the TxID, in a 'Table of  Bounties'? Or you want to embed a hash of your signed message announcing  the bounty?
Out of curiosity, I suppose right now you just keep pubkeys for the  signatories you want to appoint and reuse the same pubkey to create these  multi-sigs, or you have to ask for a new one each time?
 From the signatories perspective, I imagine we're a long way off from a  wallet receiving or importing the p2sh, tracking that these outputs as  "yours", and even more, which contract/bounty they correspond to, and  finally a usable way to accumulate signatures and ultimately spend the  output to the bounty winner.
And of course, thanks for posting the bounties!
On Sun, 27 Oct 2013 22:58:13 -0700, John Dillon

@_date: 2014-12-20 03:14:28
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Area of Focus 
It sounds like Matt is saying the nodes the dnsseed is pointing to as  valid full nodes, that those IPs are hosting the malware. Since the  dnsseed picks up any stable nodes it can find without auditing, it's  perhaps not surprising some servers in the world are running a full node  and a malware server together.
I guess what confused me about this though, how are ISPs reading the  dnsseed's node list, scanning *those* IPs for malware, and then ending up  blocking the dnsseed? Seems like a pretty winding path to end up blocking  a DNS server?
Since when do ISPs null-route a DNS server for happening to resolve some  domains to IPs which happen to also be hosting some malware? Null-route  those endpoint IPs sure, but the DNS server too? I guess there was that  incident of Microsoft taking over No-IP.com -- are dnsseeds being blocked  ostensibly because they are acting as dyanamic DNS infrastructure for  malware sites?

@_date: 2014-02-02 01:16:20
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] (space) efficient reusable addr via weil 
I'm not sure I've fully wrapped my head around it.
   d/Q        - Identity key
   E          - Generate an epoch-pubkey: E = Q * H1(epoch)
   r/P        - Ephemeral privkey/pubkey, or discoverable from inputs
   S = r * K  - Shared secret (ECDE)
Payer derives an encryption key H(S), and encrypts M, which is a 1 byte  bloom bait.
For each epoch, payee generates e = d * H1(epoch) and provides the key to  a full node for monitoring. So you are providing a per-block or per-epoch  private key, along with the block ID or epoch ID that the key corresponds  The full node then uses this privkey to decrypt the same byte in all the  transactions in that epoch/block which match the expected layout/template,  e.g. given a certain length OP_RETURN, pull the specific byte and decrypt.
This decrypted byte is then in turn used as bloom bait which may or may  not cause the transaction to be sent back to the SPV client.
Am I right in saying the full node has no idea if decryption is  'succeeding' it just feeds the resultant bait into the bloom filter and  the transaction may match or not? So we do get some level of repudiation  by the SPV client -- the server doesn't know exactly which transactions  belong to the SPV client.
The bloom bait specified in the reusable address is still making the  bandwidth/privacy trade-off, it just doesn't become public information,  because it's protected by another factor?
What encryption scheme is being used here?
Another approach (inspired by IBE) which narrows the discoverability of  transactions to the nodes that your SPV client is actually communicating  with, for the specific blocks/epochs that you specify, would be to use  PEKS(Q, W) for a public key Q and a keyword W produces a searchable  encryption of the word W.
The payee holding 'd' (privkey for Q) can create a trapdoor which allows a  server to search for transactions with W, where the searching party only  knows if a match is found or not.
   d/Q   - Longstanding / identity privkey/pubkey
   r/P   - Ephemeral privkey/pubkey, or discoverable from inputs
   W     - Searchable Keyword
   H1    - Hash function, {0, 1} ? ? G1
   H2    - Hash function, G2 ? {0, 1}p
Secret, as usual per ECDH:
   S = r * Q
For payer to create the searchable encryption of W for Q, called 'Sw':
   Sw = H2(e(H1(W), S))
   OP_RETURN P, Sw
For payee to search for a given 'W', payee calculates a trapdoor 'Tw':
   Tw = d * H1(W)
For a searcher, given a Trapdoor (Tw), check each Transaction (P, Sw):
   H2(e(Tw, P)) ==? Sw
   If the values match, the keyword matches
Without getting into the concepts of e(g,g) and binomial pairing, I think  of it this way:
   Sw = H2(r * Q * H1(W)), but recall: rQ == dP, so...
      = H2(d * P * H1(W)), which can be written
      = H2(d * H1(W) * P)
Severs finds all transactions with 'P' on relevant parts of the  blockchain, multiplies by the provided trapdoor 'Tw', applies 'H2', and  checks for a matching 'Sw' in the transaction;
   Tw = d * H1(W)
   Sw = H2(Tw * P)
        H2(d * H1(W) * P)
PEKS is vulnerable to an offline keyword guessing attack, where you can  discover the value of the keyword being searched, if the keyword is low  entropy. The server/attacker can figure out the value of W, but they can't  generate their own trapdoors to search for other keywords.
But in this case, the 'keyword' can simply be the block ID / epoch ID  itself, not a secret value at all. In other words, the server can only  search for your transactions within the blocks/epochs that you specify.
Using blockID/epochID as W, this would allow a server to find all  transactions belonging to the payer for that blockID / epochID. The SPV  client would simply provide the trapdoor for each block/epoch to be  There are extensions to PEKS which provide for 'fuzzy' matching but they  are 'fuzzy' within the scope of Q, not across different Q, so that doesn't  help provide any repudiation. So I see this as only slightly improving  Peter's original proposal of providing 'Q' to the searcher, but if you  want repudiation, not as good as Adam's solution.
Perfunctory disclaimer... Hopefully this is close to correct, but please  don't anyone actually try to implement this!

@_date: 2014-02-04 23:57:36
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh, 
Well the point of the Merkle tree is that if I all you have is the top,  and all I give you is a leaf node and the siblings of all parents of that  leaf, then by simply hashing you can check if the node was actually  present in the tree.
The only reason this works is because it's hard for an attacker to come up  with the list of values which would ultimately hash together to produce  the expected top value. But if the hash function is actually just XOR, it  becomes completely trivial for me to claim any value I want was in the  1) Pick the fake value you want to claim was in the tree (leaf node)
2) Choose some random values to fake the depth in the tree
3) Calculate the last value as 'Prev (x) Top'
4) When your victim goes to verify set membership, they will get the top  value they expected

@_date: 2014-02-19 11:15:39
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with 
One possible work-around to get back trusted transaction chaining for  payment channels and locked refunds from multi-sig would be to make the  initial transaction include zero fee, and depend on child-pays-for-parent  in order to get the first and follow-on transactions into a block. This of  course only works for protocols where the parties don't need the initial  funding transaction to actually hit the blockchain right away.
But this relies on two assumptions; 1) that miners won't include a  zero-fee transaction in the blockchain, and 2) that miners actually  implement child-pays-for-parent. It's definitely not the same security  as-if you had immutable txid, but it's something to consider.
1) Mutants may cause wallet spam and difficulty calculating balance (and  wallets will evolve to deal with it)
2) Mutants cause DoS because they can interfere with your own transaction  chains, which for example makes batch off-line processing much more  3) Mutants introduce a 3rd party attacker into any two-party protocol that  relies on chains
There's a lot to digest in the 'v3' transaction/block proposal. It sounds  like there may be some uncertainty over whether we can *prove* that v3  transactions in v3 blocks would actually be guaranteed immutable with  these changes?
If we cannot fully prove a Tx is immutable, then is it actually worth  taking steps to make it seem immutable, or is that just a false sense of  security in the cases where chained transactions were actually expected to  be reliable? Under that thinking, maybe it's best to accept mutants as a  fact of life, and only consider protocols and techniques that cannot be  broken by mutants.
In what cases does reducing the sources of malleability, but not  necessarily eliminating from a security proof perspective, actually help?  Basically, if we don't know that we will succeed, isn't there really no  point in trying?

@_date: 2014-02-24 14:12:10
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release 
Just quickly GLANCED at it, but if I understand correctly how the template  matching code works, that will change max size of the  to 40 bytes  but does not do anything to enforce most-efficient encoding.
   else if (opcode2 == OP_SMALLDATA)
   {
       // small pushdata, <= MAX_OP_RETURN_RELAY bytes
       if (vch1.size() > MAX_OP_RETURN_RELAY)
          break;
   }
This code was a bit hard for me to parse since it's not actually requiring  any data, just disallowing more than a certain number of bytes of data. So  a bare OP_RETURN would be allowed as well, for whatever good that will do.
If you want to strictly require no PUSHDATA, perhaps you could do:
   else if (opcode2 == OP_SMALLDATA)
   {
       // small pushdata, <= MAX_OP_RETURN_RELAY bytes
       if (opcode1 >= OP_PUSHDATA1 || vch1.size() > MAX_OP_RETURN_RELAY)
          break;
   }

@_date: 2014-02-25 10:09:23
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Fee drop 
If I understand correctly, the risk here is this would open a historically  large discrepancy between MIN_RELAY and the expected minimum fee to  actually obtain block inclusion. I don't know if that's true, but I think  that's what Peter is saying makes it different this time.
The relay network does anti-spam with MIN_RELAY and MIN_DUST, but of  course only transactions which hit the blockchain actually PAY the fee, so  this allows lower-cost spam in the true dollar sense.
I guess it comes down to how 'sharp' the edge is between staying above  MIN_RELAY and staying OUT of the blockchain. In the worst case, there's a  completely deterministic boundary, so an attacker can generate an infinite  number of transactions which are guaranteed never to see the inside of a  block, and so therefore completely free for the attacker, and all of which  the network will relay (by default).
Perhaps this is just another way to think of the floating fee problem.  What does MIN_RELAY need to be so that my local resources stay within some  reasonable limit (and 'reasonable' means different things to different  We have an input gate on transactions entering mempool, we persist  mempool, and I don't know the specifics but, I assume there's some  expiration policy other than block inclusion to clear out a Tx from  mempool. But are transactions prioritized in any way after they make it  into mempool today?
How closely should mempool selection align with the expected block  inclusion? I think if they align perfectly in theory that means optimal  mempool resource allocation. For example, a miner would push out cheaper  transactions which they were previously hashing against to make room for  higher fee transactions (bsaed on max block size or orphan rate  projections), but do we do the same for mempool? E.g.
   - After hitting X number of transactions, the fee has to be larger than  a transaction in mempool in order to get in,
   - That in turn that ejects a random transaction which paid less fees  than the incoming Tx from mempool
   - We would have to consider how ejection would work with chains of  unconfirmed transactions (cumulative average fee/kb?) but again in this  case, you would want to 'do what miners would do' if you could

@_date: 2014-02-25 11:03:24
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Extension for BIP-0070 to support 
If you're going to go the direction of a {unitType, unitsPerInterval}  tuple, then I think the only two units you could ever want are minutes and  months. All other standard units of time can be expressed in terms of  those two, right?
Also consider changing "optional uint64 ends = 4;" to be a interval count  instead of a UTC timestamp, to avoid any ambiguity over how the 'while'  loop should be implemented.

@_date: 2014-01-01 02:02:02
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
So I looked into gitian, the first thing I noticed was the hashes that  people were signing, for example:
    don't match the hash of the file 'bitcoin-0.8.6-win32-setup.exe' actually  hosted by sourceforce. That was a bit alarming at first, but I talked to  BlueMatt and maaku on IRC and the difference is due to Gavin Authenticode  signing the executable for windows.
BlueMatt asked if someone could implement in gitian-downloader a way to  strip off the signature so that we could get back to the raw binary with a  hash that matches what everyone is producing from gitian.  I found:
   which is a Python script which can strip the signature nicely, but the  hashes still don't match.
I couldn't find a gitian build of 0.8.6 so I built my own, and after  verifying the hash for v0.8.6 was '49547ff9...' as expected I looked at  the hex diff between that and the sig-stripped .exe from sourceforge, and  the only two differences are:
   - At offset D8 the stripped file has '5D E2 B2' versus 'F9 F4 00' in the  gitian build
   - The sig-stripped file has an extra byte '00' at the end
I started to look at the file spec for windows PE files and quickly  thought better of it. Maybe someone better informed can chime in on what  those three bytes at offset D8 specify.
I'm not sure if we want to patch the signature onto the gitian build, or  strip the signature off of the Gavin-signed build, but something of the  sort is necessary if you want get gitian-downloader to match the official  distro (for Windows at least).
In any case, I think wallet users want to know when an upgrade is  available, and ability to click an 'update' button get a binary they can  trust. It's not a problem unique to bitcoind, deterministic builds are  awesome, but I don't think fully solve it.
On Tue, 31 Dec 2013 13:33:54 -0800, Matt Corallo

@_date: 2014-01-07 22:34:46
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Privacy and blockchain data 
Interesting thought to make the privacy/bandwidth trade-off using  vanitygen and prefix filters.
But doesn't this effectively expand the universe of potential spies from  'the global attacker' who is watching your SPV queries, to simply 'the  globe' -- anyone with a copy of the blockchain?
Some stats on UTXO set size:  (slightly stale -- as of block 270733)
    7.4m unspent outputs
    2.2m transactions with unspent outputs
    2.1m unique unspent scriptPubKeys
    Side note: the top 1,000 scriptPubKeys have 10% of all unspent outputs.
Let's say you use an 8-bit prefix (1/256) that would be ~10,000  transactions in the UTXO you would be monitoring. But if I knew a few  different days / time-periods you transacted, I could figure out your  Of course, anyone you transact with would know your prefix outright.
Wouldn't this also allow obvious identification of spend versus change  addresses in a transaction?

@_date: 2014-01-08 02:20:57
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
Thanks Peter for the paper!
I'm just going to restate your 'simple explanation' to make sure I got  The payee publishes a public key of theirs, which will be a long-standing  identifier, public key = 'Q', corresponding private key = 'd'.
To pay them, payee generate a keypair, private key = 'e' public key of  'P'. Publish 'P' in the transaction.
The payer can calculate S = eQ, where S is a shared secret between  payer/payee. The payee calculates the same S as S = dP. So the payee sees  'P' in a transaction, and multiplies by their private key, to get S.
Now that we have the shared secret, either side can calculate an offset to  Q which becomes the pay-to-address. When you say BIP32-style derivation,  Q' = H(S) + Q, does this mean Q + SHA256(33-byte S)?
A payee has to check each transaction (or every transaction of a fixed  prefix) with 'P', calculate Q' = Q + H(dP) and see if that transaction  pays to Q'. If the address matches, then the payee can spend it with  private key of d + H(dP).
One downside is that you have to hold your private key in memory  unencrypted in order to identify new payments coming in. So  stealth-addresses may not be suitable for receiving eCommerce payments,  since you can't implement a corresponding watch-only wallet, e.g. there's  no way to "direct-deposit into cold storage."
Hope I got that right...

@_date: 2014-01-12 02:33:02
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
Great point. Even if it's not a 3rd party, I think it's really important  to be able to scan for transactions with a key which can't actually spend  the funds.
The first approach is just one-pass ECDH. I think you're saying the second  approach is two rounds of ECDH but re-using the same e/P (usually referred  to as r/R in ECIES). I think this is safe, unlike reusing an ephemeral key  for signing operations.
   Payee: Publish Q, Q2                     [d, d2 are privkeys, Q, Q2 are     Payer: 1) Generate ephemeral key: e / P  [e is privkey, P is pubkey]
          2) S = e * Q                      [first shared secret]
          3) S2 = e * Q2                    [second shared secret, reusing            4) Q' = Q + H(S)                  [pay-to stealth address]
          5) Q2' = Q2 + H(S2)               [stealth 'marker']
   Watch: 1) Look for TxOut with OP_RETURN           2) Q2' = Q2 + H(d2 * P)
          3) Check for Q2' elsewhere in the Tx
S/MIME for example, allows reuse of the ephemeral keypair. When reusing an  ephemeral keypair where A reuses (x, X) to encrypt different messages to  more than one user, A should verify the static public keys to prevent  small-subgroup attacks.[1][2]
Let's say you pay-to Q' and then Q2' value has to be somewhere else in the  transaction. You could put it next to the shared P in OP_RETURN. OP_RETURN    would be 66 bytes.
But then Mallory could generate transactions with the right Q2' but with  his own pubkey in Step 2 instead of Q. So your scanner would detect a  payment, but you wouldn't be able to spend it, and Mallory could.
That's a good argument for putting Q2' in a 2-of-2 multisig so that  pulling this trick would at least make the transaction unspendable for  both parties, which may be good enough deterrent, but you're still going  to want to check it against your 'd' before fulfilling a large order. Your  online watch process could queue the matching transactions, which you  could move to your offline machine, decrypt your key, and verify the  transactions are spendable.
Now, you would need to get two pubkeys to the payer, throw in a prefix to  help standardize it, and end up with addresses that could look like (for  Those addresses are 74 bytes:     xSTL Prefix = 0xC0CB9270
   tSTL Prefix = 0xB2E27D50
   NOTE: I do NOT have the corresponding privkeys for these four pubkeys!
Those just happened to be the first matching prefixes I found for 74 byte  addresses. I could try to find ones which start with a specific byte if  that's somehow better, like 0x04 to match BIP32.
Unfortunately, I don't think you can just derive a second public key from  the first to keep the address shorter, and still keep the first private  key secure, even if the second private key is stolen. You only get  equivalent security as BIP32 public derivation, where you can't lose a  child private key.
Do we also want xSTL (or whatever user friendly string) prefixes for  single pubkey (41 byte) stealth addresses?
I'll wait a couple days for feedback, then I'll try to implement the  following prototypes:
1) Pay to STL addresses
2) Watcher process to detect and queue STL payments for a given d2/Q2
3) Offline verifier to take output from Watcher and verify spendable given  encrypted d/d2
Obviously extending QT directly for  would be ideal, I may even be able  to do that since supporting a new address type should be fairly contained.  But if not I'll punt to writing a node.js or python script which connects  to bitcoind via RPC.
[1] - On Reusing Ephemeral Keys in Diffie-Hellman Key Agreement Protocols
       [2] - Validation of Elliptic Curve Public Keys

@_date: 2014-01-12 10:20:18
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
I should have mentioned that as Task  Agree it could be an optional  extension and backward compatible. I think for displaying the payment in  the UI after it's been made via PP, we have to fully support sending to a  new standard address type anyway. Probably easiest to implement in PP  after the address and transaction building code is done.
So '4a' would be building a static PP file given the necessary inputs.  When I get to that point, I'll send out a draft PP extension with  fields/formats if someone else hasn't already. '4b' would be actually  adding support for parsing those fields and generating the new transaction  type into bitcoind.
Any thoughts on the prefix, and one vs two pubkey approach? First of all,  do we try to support both equally, or favor one over the other? I was  thinking we could have two different 4 byte prefixes but that both render  as xSTL/tSTL in Base58 but correspond to the one vs two pubkeys expected.  I think the chance of finding a single prefix which looks like xSTL for  both address lengths is 1 in (58^4)^2, so that's probably not going to   From the payer/user perspective, short stealth vs. long stealth is  irrelevant; they both have the same usability properties from the payer  perspective. So giving them the same Base58 prefix seems like a good plan.
The full 4-byte prefix seems worth the usability trade-off versus 1-byte  prefix, especially since it will impact the ability to lookup the  transaction on an outside service, which I think a lot of people do to  verify their payments. IMO a longer prefix isn't "wasting bytes" anywhere  that it really counts.
We could save two bytes in the address if we required both pubkeys to  start with '03', or save one byte if we required they both start with the  same byte, but again doesn't seem worth it (to me) for the arbitrary  The actual internal wallet code for *receiving* STL payments and updating  balances is more tricky and probably not something I can personally tackle  for bitcoind. Assuming we even want first-class support for generating STL  addresses and receiving STL payments in a standard user wallet, someone  has to decide if the STL 'd' / 'd2' keys should be...
   1) Encrypted as usual, and then keep a list of blocks with interesting  transactions, and go through them when the user enters their password?   This would cause balances to update differently than how they do now, but  perhaps be more secure.
   2) Kept unencrypted to allow live scanning as usual? Or keep just 'd2'  unencrypted, with some new concept of 'unconfirmed' until the user enters  their password to prove they can spend that TX? That kind of extra step  seems OK for a merchant but sounds very scary for an average user.
   3) Kept encrypted under a separate password? Meh...
And last thought for now... At some point, we might want to decide on a  convention to highlight these STL addresses as 'reusable' -- but similar  questions around revocability remain. I hope we don't need anything like a  UTC expiration time baked in to the address. A static PP file will have an  expiration date either in the certificate or in 'expires' field, so I  think if you want it to expire then use PP?

@_date: 2014-01-13 01:13:08
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
Of course you're right, moving away from addresses is definitely part of  the point of PP.
On Sun, 12 Jan 2014 13:18:33 -0800, Gavin Andresen  Agreed, it's long enough to be even more problematic than usual. If the  general consensus is that there should not even be a standardized address  form, then I can skip that entirely, and go straight to trying to extend  It's a given this will be implemented for Payment Protocol. The question  is whether it's also usable outside of PP.
I was kind of imagining that we could encourage people to replace all  their static address text that live on Github pages, and README.me, and  forum signatures, etc. with new 'href=bitcoin:xSTL...' URIs. Convention  could be to require only transporting xSTL addresses within a URI, even  going so far as to not support them copy/pasted. 101 characters is not  much longer (and sometimes shorter) than PaymentRequest URIs end up being.
I think there are ways to make stealth addresses easy enough to use that  people actually prefer using them for P2P payments which do not involve a  full-stack merchant. In that case, if it was a PaymentRequest it would  almost certainly not be signed, and would be more easily shared over email  or SMS as a URI than as a file attachment or, even worse, putting the  unsigned PR file up on a third-party server which probably won't do a good  job securing it.
* PP Implementation Overview *
The basic PaymentRequest>PaymentDetails is expecting 'output' containing  one or more TxOuts with script and amount. I believe the general approach  is to put a fallback address into 'output' for backward compatibility, and  put Q and Q2 into an extension field.
So we add a new optional field to PaymentDetails which contains the one or  two PubKeys. Not sure if we want different protobuf tags, or if the  difference in length of the value makes it obvious enough which approach  is being used;
    optional bytes stealthOnePubKey = 1000
    optional bytes stealthTwoPubKey = 1001
or just
    optional bytes stealth = 1000
* User Interaction / Flow *
Lets follow this through from the user perspective, starting with what it  looks like today. I'm having a hard time finding screenshots of what PP  looks like in BitcoinQT, so I built from HEAD and using Gavin's  Handy-Dandy PaymentRequest Generator  Screenshots: Image 1 - 'Send' screen after clicking a PR URI with a small transaction  and auto-calculated fee
Image 2 - System Tray notification after clicking 'Send'
Image 3 - Transaction List showing partially confirmed transaction
Image 4 - Transactions details popup
We see 'Pay To' (Common Name from the cert) and 'Memo' on the Send screen.  The System Tray notification popup and Transaction List shows just the  address string. The 'Transaction details' window shows 'Merchant' which I  think is the same as 'Pay To'. You also have 'Copy address' option in the  right-click menu.
Memo seems not to be saved, or at least not visible in the UI after  sending a payment.
* Transaction Display *
The address string is fairly pervasive, which is why I was originally  thinking it would make sense to implement all the address handling first,  so all those screens would continue to work as specified, without trying  to hack something different in those fields.
Without digging too far into the code, it looks like "address" displayed  is derived from the TxOut -- e.g. script.cpp:ExtractDestination. This  could be a bit problematic depending on what we really want to show to the  user -- the stealth multisig, or the pubkeys?
Part of the point of stealth addresses is actually making them reusable.  So if you're the originator of the payment, you might want the wallet to  tag that transaction somehow with the pubkeys used to generate it.
Also, ideally I think I would want multiple different stealth payments  within a single wallet to the same merchant / pubkeys to be identifiable  as such.
* Sample Code *
Will follow in another email, to be sent shortly!

@_date: 2014-01-13 01:18:39
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Payments - Sample Code / Proof of 
* Transaction *
I spent 1BTC on TestNet to a stealth address...
    TxID: df092896c1347b303da299bc84c92bef1946f455dbdc80ffdb01a18ea4ed8b4c
* Code *
Code which generated this transaction is here:  Note, one minor change from the protocol we discussed is I'm just using  the 32-byte x coordinate for the shared secret, not the compressed pubKey  (so, throwing away the first byte) before hashing with SHA256.
* How it Looks *
After importing the privkey for the TxIn to that transaction  (importprivkey "cNL8XqRtqwC1YEc9kKspbX2aukWnXfgHQSvjsPYbuPif5Q3DJkEs"  rescan) you will see two rows in the Transaction List of Bitcoin-QT...
Both rows simply say 'Sent to' with a blank address. One has 1BTC amount  which is the 2-of-2 stealth multisig, the other has 0BTC amount, and it's  the OP_RETURN.
I wonder if the 0BTC OP_RETURN transactions should be hidden from the  Transaction List? 'Transaction Details' truncates the  after  OP_RETURN anyway, so it's not even particularly useful for seeing what  data you embedded.
* Next Steps *
I'm not quite sure. If we're going to try to deploy this, I think we need  to fully understand what users who are making these payments should see in  their wallet software while making a payment, and after a payment has been  Right now I'm thinking...
   1) Define the PaymentRequest extension
   2) Update Gavin's PHP to generate PaymentRequests for stealth payments
   3) Get Bitcoin-QT loading the PaymentRequest and generating transactions   from those PaymentRequests
   4) Write an agent to detect incoming stealth payments
But we would still be showing meaningless rows in the payer's Transaction  List without some additional work.
If there is a place to add TxOut meta-data with the pubkeys used to  generate it... well, there must be since the 'Merchant' field is attached  somehow. So we could probably use the same method to keep the pubKeys  Maybe the simple way to punt on this is to just show 'Merchant' in the  address column if it is available and an address is not. We could skip  saving the pubKeys for now, so there would be no way to send follow on  stealth payments, but at least the Transaction List would make sense  instead of looking like two empty transactions.
* Other Open Questions *
I think the biggest is if/how to receive P2P stealth payments in  Bitcoin-QT as an end-user not a merchant.
I can probably make the necessary changes to IsMine, but I don't know  where we should keep 'd2'/'Q2' unencrypted so it's available for doing the  necessary tests, but has no chance of ever be used as a stand-alone  private key?
And then there's still the question of: when 'd1'/Q1 is available  decrypted, we must fully verify the transaction, and how to indicate if  that has or has not been done yet.
It really seems crippled to me without fully integrated support for  receiving P2P stealth payments in Bitcoin-QT. It doesn't seem like that  much code, just some details to work out first.

@_date: 2014-01-13 06:10:14
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Payments - Sample Code / Proof of 
But of course!
Every time the test runs it makes a new ephemeral key, so I wrote a  separate test with hard-coded values from the block chain (as it would be  in real-life) to create a redeeming Tx. I've added the RedeemStealth code  to the Gist.
It sent successfully using sendrawtransaction, TxID:  I'm self mining since no one else seems to be on TestNet this time of  night... going to catch some sleep, hopefully by the time I wake up it'll  be on the chain.
Indeed it is. One day I may publish the libraries, but they aren't doing  anything particularly special under the hood, just the standard  Bitcoin/EC/BIP32 stuff and using OpenSSL under the hood instead of the  more typical BouncyCastle.
I just tried to keep things extremely concise in the APIs. Hopefully all  the function calls are obvious what they are doing. Since there's no  actual wallet behind it, the code to setup the inputs is a bit annoying,  but actually building and signing transactions is super clean.
In this case I'm just looking at the payee wallet, but yes, "Payment set  to Jeremy" should be possible, with the name coming from the CN.
Yeah, right now for PaymentProtocol fulfilled payments, on the payer's  Transaction List, it shows the address in the 'Address' column, but if you  right-click and look at 'Transaction details' you will see something like:
    Status: 42 confirmations
    Date: 1/12/2014 21:07
    To: mrhz5ZgSF3C1BSdyCKt3gEdhKoRL5BNfJV
    Debit: -0.10 BTC
    Net amount: -0.10 BTC
    Transaction ID:      Merchant: I agree 'Merchant' might not be the best name, especially since when  you're making the payment the field is labeled simply 'Pay To'.
But I think we agree, why show 'mrhz5ZgSF3C1BSdyCKt3gEdhKoRL5BNfJV' in the  transaction list instead of just "Paid To:  and then  perhaps the Memo field could be stuck under 'Transaction details', instead  of losing that important bit of info.
Not sure I follow that, will look forward to hearing more about it.
The only risk I know of is that there are checks in theory that you would  do on Q1/Q2, but since the payee is the one generating Q1/Q2 they would  literally be attacking themselves. I referenced two papers in a prior  email specifically on reusing ephemeral keys in ECDH, and the validation  you need to do on Q1/Q2 when re-using an ephemeral key to send two  messages to two different pubKeys. I think the idea of checking the  pubKeys when re-using ephemeral keys is more when the pubKeys are under  the attackers control. But the validation is not complicated, and I'll see  if I can add it tomorrow.
It would be good to fully understand how a possible small-group attack  would work...  This is a bit of guess-work on my part:
    If a payee managed to foot-shoot themselves with a bad Q2 pubKey, then  gives out d2/Q2 to a scanning service run by Mallory...
    Mallory has d2/Q2, given P from a transaction, he calculates S2 (as         byte[] S2 = EC.DH(d2, P);
    But with the small sub-group attack with Q2 he can learn 'e' (the  ephemeral private key) used:
       byte[] S2 = EC.DH(e, Q2);
    and from that he can calculate S1 directly, when he should only know S2.
       byte[] S1 = EC.DH(e, Q1);
So does that mean Mallory can find 'd1'? It looks like you would need  another small sub-group attack on P, the ephemeral public key, so another  key the attacker doesn't control which would have to randomly be bad.
       byte[] S1 = EC.DH(d1, P);
But I'm definitely not a professional cryptographer. Perhaps Matthew Green  might be a good candidate to review this?
AND YAY, my stealth redemption Tx just went through, goodnight :-)

@_date: 2014-01-13 14:02:00
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
I think this is exactly what I've implemented.
I decided to put both pubKeys in a 2-of-2 multisig, instead of keeping one of the pubKeys in the OP-RETURN, to prevent a malicious sender from triggering false positives on your online detection key when the funds are actually still fully controlled by the payer.
You can still have a false positive (only 1 of 2 keys actually yours) but the funds would be trapped so it's unlikely anyone would do it. Can you take a look at the Gist and TXs on TestNet I sent out, and see if that's in line with what you expected?
I would also greatly appreciate if you could review the discussion around doing two ECDH operations with a single ephemeral key.

@_date: 2014-01-14 11:12:40
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
Right now I have this:
   byte[] e = EC.NewPrivateKey();
   byte[] P = EC.GetPublicKey(e, compressed: true);
   byte[] S1 = EC.DH(e, Q1);
   byte[] S2 = EC.DH(e, Q2);
   byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S1));
   byte[] q2New = EC.PointAdd(Q2, Util.SingleSHA256(S2));
   stealthTx.Vout.Add(TxOut.PayToMultiSig(Util.Amount(".995"), 2, 2, q1New,     stealthTx.Vout.Add(TxOut.OpReturn(P));
In this case, you can scan with d2, calculate S2, and matching payments  will have the right 'q2New'. But you need to check again offline with d1  since it's a separate shared secret.
Maybe you are saying:
   byte[] S = EC.DH(e, Q2);
   byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S));
   byte[] q2New = EC.PointAdd(Q2, Util.SingleSHA256(S));
But the payment would have (q2New - q1New) == (Q2 - Q1), so I think not  entirely stealth? OK, let's fix that by adding a counter to the hash     byte[] S = EC.DH(e, Q2);
   byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S || 1));
   byte[] q2New = EC.PointAdd(Q2, Util.SingleSHA256(S || 2));
   stealthTx.Vout.Add(TxOut.PayToMultiSig(Util.Amount(".995"), 2, 2, q1New,     stealthTx.Vout.Add(TxOut.OpReturn(P));
This is assuming we want to put q2New somewhere into the transaction,  which, is it even required?
   byte[] S = EC.DH(e, Q2);
   byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S));
   stealthTx.Vout.Add(TxOut.PayToPubKeyHash(Util.Amount(".995"), q1New);
   stealthTx.Vout.Add(TxOut.OpReturn(P));
I'll wait for ACK and then update my sample code.

@_date: 2014-01-14 14:34:01
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
Thanks for reviewing this. The relevant line:
    byte[] q1New = EC.PointAdd(Q1, Util.SingleSHA256(S1));
SingleSHA256 is a single application of SHA256 -- named so since 'SHA256'  functions in many Bitcoin libraries too often actually run DoubleSHA256.  32 bytes are returned.
The multiplication by 'G' that you mention is part of my EC.PointAdd...
I should probably just publish all my code as MIT and be done with it ;-)
public static byte[] PointAdd(byte[] point, byte[] scalar, bool compressed  = true)
     var point1 = new OpenSSL.Crypto.EC.Point(EcGroup, point);
     var num = OpenSSL.Core.BigNumber.FromArray(scalar);
     var point2 = OpenSSL.Crypto.EC.Point.Multiply(EcGroup, num,       var result = point1.Add(point2, EcBnContext);
     if (compressed)
         return result.GetBytes(ConversionForm.Compressed);
     else
         return result.GetBytes(ConversionForm.Uncompressed);

@_date: 2014-01-15 16:05:27
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
Might I propose "reusable address".
I think that describes it best to any non-programmer, and even more so  encourages wallets to present options as 'one time use' vs 'reusable'.
It definitely packs a marketing punch which could help drive adoption. The  feature is only useful if/when broadly adopted.
I think it meets all the criteria required:
   - Communication between parties is a single message from the payee,  which may be public
   - Multiple payments to the same address are not publicly linkable on the     - The payee has explicitly designated they expect to receive more than  one payment at that address
   - Payer can publicly prove they made a payment to the reusable address  by revealing a secret
I have high hopes for this feature. The war *against* address reuse may  soon be a distant memory.

@_date: 2014-01-15 17:02:10
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] unlinakble static address? & spv-privacy 
The second pubKey is useful for delegating scanning, or even just being  able to scan for transactions yourself without keeping bitcoin-encumbered  private keys decrypted in memory. So even while running your own full node  there are good reasons to use a second pubKey to derive the shared secret.
And of course, if you have multiple reuseable addresses, then you're doing  this calculation separately to check each one.
So the load on a popular centralized service would be quite high, which  you may consider a feature.
Choosing how many bits to put in the prefix may be difficult, particularly  if transaction load changes dramatically over time. 0 or 1 bits may be  just fine for a single user running their own node, whereas a central  service might want 4 or 5 bits to keep their computation costs scalable.
But I think it's great people can choose how to trade privacy for  computation/bandwidth however they want, and services can compete to offer  monitoring for 0+ bit prefixes.
I think in this case the hash grinding of the prefix would only being used  if thats how transactions are being indexed. I don't think it adds any  privacy, it's just added work we're forced to do in order for the prefix  to work as designed. Peter, please correct me if I'm wrong.
I think any change which requires more than a single published public  message (e.g. a posting in a forum, or in a README.me in Github) should be  seen as solving an entirely different problem.
If you have directed communication from payee->payer, I think there's  simply no reason to do it this way. (By "this way" I mean ECDH with  OP_RETURN P).
We could try to define a different reusable address type, for when you can  make a single directed message from payer->payee, and in that case there's  probably no need for ECDH or the prefix, like Alan's proposal.
But once you admit having that directed communication, then you are  swimming very close to the payment protocol.

@_date: 2014-01-16 21:13:39
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
I hear you, and I really don't care that much what it's called, as much as, does it work and how!
Regardless of what it's called, Blockchain.info should tell the user, hey this address doesn't let the whole world see every single payment that's made to it! If you paid something to this address, only you know how to find the payment - look for the stealth address in your transaction list. So if we call the address that has the pubKeys the "reusable address" and the address that's generated from the shared secret the "stealth address" then is everyone happy? :-)

@_date: 2014-01-18 17:12:58
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Stealth Addresses 
In the case where payment is being sent only to Q1, and Q2 is for discovery only, perhaps we could use a 160-bit curve for d2/Q2 and e/P resulting in 20 byte vs 32 bytes in the OP_RETURN, and of course faster multiplication. 80-bits of security I assume still greatly exceeds the actual level of privacy you get with the overall solution, and since Q2 is never protecting actual funds...
But if it's a "real weakening" of the privacy then definitely not worth it, and even the added complexity of another curve seems possibly not worth it...

@_date: 2014-01-20 20:00:05
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] unlinakble static address? & spv-privacy 
On Wed, 15 Jan 2014 17:32:31 -0800, Gregory Maxwell   I might be misunderstanding, but I think prefix length must be specified  in the reusable address, however I agree the prefix actually published to  the blockchain should be constant length.
Let's say the payee's reusable address is '     ...', where  is 2 bytes. Without any length indicator. What's the  payer going to put on the blockchain? How would they know what the 'rest  of the space' is? They would have to put the whole  verbatim into  the OP_RETURN without knowing how many bits of  the payee actually  wants to see there.
If instead, the address is '     ...'  where  is 2 bytes, and  is 1 byte, representing number  of bits of prefix that should be fixed.
Then payer will know how much of  from the address should be taken  verbatim, and the rest of the two bytes would be replaced with random  data, and exactly two bytes would be put in the OP_RETURN.
If  was zero, the 2 byte prefix in the reusable address must be  ignored, and an entirely random 2 byte prefix would be put into the  I'm a bit worried about broken implementations copying the  from  the reusable address into OP_RETURN when  is 0, and ending up  basically identifying the payee. That's the only reason I can think of to  make ' ' optional in the reusable address, to prevent  the opportunity to screw it up. You would *still* put a 2-byte random  prefix in the OP_RETURN, even if the fields weren't in the address at all.  It's just a minor concern though.

@_date: 2014-01-24 13:58:28
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Bait for reusable addresses 
Perfect privacy without extraordinary computational overhead today means downloading everything. But we could provide better tools to *shift* bandwidth requirements rather than try to reduce them. I've been thinking about a setup where user runs a UTXO only, and maybe even outbound-connect only (like bitcoinj), full node at home. Then using Tor, mostly for tunneling, they host a hidden service they can connect back to from their smartphone to see balances, manage receive addresses, send funds, etc.
The smartphone is not doing SPV, it's like a web client for the wallet running at home. The initial connection between the smartphone and home wallet has the phone learn two codes, one is the hidden service name, another is an access token which is revocable. You may require further authentication from that point. With fast bootstrapping / checkpointing of the UTXO I think usability could be as good as SPV, and you would get push-notification of relevant transactions with zero privacy trade-off.
I wonder if people would want to run such an app, if they would run it on their desktop, a dedicated machine, or an old smartphone or other cheap ARM device.

@_date: 2014-01-27 09:11:08
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Really interesting work. When using scan-to-pay, after the payer scans the  QR code with the protobuf PaymentRequest (not a URL to download the  PaymentRequest) are they using their own connectivity to submit the  Payment response?
If we assume connectivity on the phone, might as well just get a URL from  the QR code and re-use existing infrastructure for serving that?
How about putting a Bluetooth address in the payment_url inside the  PaymentDetails message for the smartphone to send back the Payment  response and get PaymentAck?

@_date: 2014-01-27 10:18:16
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments 
Same mechanism for both, of course. Sorry, that was obvious. :)

@_date: 2014-01-30 12:16:28
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] BIP70: PaymentACK semantics 
Please note, responding to Pieter and Chuck concurrently.
On Thu, 30 Jan 2014 07:16:54 -0800, Pieter Wuille  I think we want to separate the two issues;
   1) Reliably getting refund/memo fields to the merchant/payee
   2) Who broadcasts a TX, how it's retried, how outputs are 'locked' and  if/when they should be [double]-spent to clear them
We should be able to solve '1' without having to fully spec out behavior  for 2.
On Thu, 30 Jan 2014 07:16:54 -0800, Pieter Wuille  To reliably deliver refund/memo fields, we could;
   a) Send them as part of the initial request for the     b) Send them as a response to the PaymentRequest/PaymentDetails before  the transaction is even formed and any unspent outputs are selected
   c) Send them as a response to the PaymentRequest/PaymentDetails with the  UNsigned transaction, and then follow up with the signed transaction in a  separate message.
'a' is problematic because while wallet software could easily append some  data to the queryString, it doesn't work if the user is downloading then  opening the PaymentRequest as a file. So 'a' is a no-go I think.
'b' is fine, if not overly chatty. The only thing committed is a refund  address, which is a lot less problematic than committed unspent outputs.
'c' is nice because it lets the server preview the transaction (and  ACK/NACK it with a memo of their own -- e.g. 'fee too low'?) without being  able to broadcast it, so we know unspent outputs are not yet committed.
But all of these require too many changes to the protocol for my liking.
On Wed, 29 Jan 2014 21:47:51 -0800, Chuck   "Unsigned transactions and their associated fully-signed transaction hash"

@_date: 2014-07-15 01:31:29
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
Payment Protocol would probably be the communication format for any new  What's the likelihood of something like this every making it on the

@_date: 2014-02-28 22:26:39
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Positive and negative feedback on certificate 
We currently have subtle positive feedback of a signed payment request in  the form of the green background. Unsigned requests simply show up without  the green background, as well as requests which provide a certificate but  have a missing or invalid signature.
There's a open bug ( and pull request ( to provide negative  feedback (yellow background) for a missing or invalid signature, but it  seems like there's some debate on whether bitcoind should do that...
If an attacker can avoid the negative feedback by just stripping the  signature and setting pki_type to none, then arguably there's no security  benefit by singling out badly signed payment requests from unsigned  payment requests.
So perhaps the root problem is that the positive feedback (green  background) is not strong enough to make its absence highly conspicuous to  the end user.
As an aside, how could we go about implementing the equivalent of HTTP  Strict Transport Security for payment protocol to prevent this trivial  signature stripping attack? Is this a possible extension field merchants  are interested in?

@_date: 2014-02-28 23:50:32
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Positive and negative feedback on 
Yeah, good point. If you have a cert, we have the CN from the cert, which  becomes the string displayed as 'Pay To' and alternatively 'Merchant'.
But if there's no cert then all you have is memo.
So the best way to differentiate signed requests is by prominently  displaying that Merchant string. Really the green part should just be the  'Pay To' line, the rest is content. If it showed a BLANK 'Pay To' that  would make the lack of certificate highly apparent.

@_date: 2014-03-01 23:52:40
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] Payment Protocol Hash Comments 
From BIP70:
   If pki_type is "x509+sha256", then the Payment message is hashed using     SHA256 algorithm to produce the message digest that is signed. If     is "x509+sha1", then the SHA1 algorithm is used.
A couple minor comments;
  - I think it meant to say the field to be hashed is 'PaymentRequest' not  'Payment' message -- probably got renamed at some point and this is an old  reference calling it by its original name.
  - Could be a bit more explicit about the hashing, e.g. 'copy the  PaymentRequest, set the signature field to the empty string, serialize to  a byte[] and hash.
  - SHA1 is retiring, any particular reason to even have it in there at all?
  - Should there any way for the end-user to see details like the pki_type  and the certificate chain, like browser do?

@_date: 2014-03-02 02:38:04
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] BIP70 extension to allow for identity 
Let me restate that, it's a huge problem...
Alice's system is compromised,
Mallory intercepts a payment request being sent to Alice from payment  processor X on behaf of merchant X.
Mallory regenerates a spoof payment request which pays to M, from the same  payment processor
Alice can't tell Mallory's spoofed PR apart from Merchant X's and thinks  she's paying Merchant X
It might be a bit challenging for M to generate the new PR on-the-fly  without being noticed, but that's not a security guarantee.
Perhaps the UI just isn't expressive enough currently to expose this  situation in any way, let alone reliably alert the user to the issue,  because there's no way for the payment processor to get authenticated  fields other than memo into the UI.
Today the only solution is for the payment processor to strictly control  the 'memo' field so Mallory wouldn't be able to make his own PR that  looked exactly like merchant Y's. But maybe it's too subtle to make  payment processors embed that kind of information.
So is the main goal is to provide a structured way to embed this  information in the PR and expect that user interfaces will display them to  end users? If that's the case, I don't think we need an entirely secondary  certificate, or cross signing from a secondary ECDSA key.
A poor solution: If the UI included some sort of certificate viewer, even  just tied to the OS certificate viewer, and made the cert available for  inspection, at least the merchant would have a chance to put some fields  in there which a very advanced user might actually find. But this was  discussed a while ago and I think the primary problem is the difficulty in  getting a CA to let you embed any additional fields in your certificate in  the first place, plus you don't want to generate a new cert for each  A somewhat better option: Some additional fields defined in an extension  which are reliably shown in the UI. We could try to define specific  fields, like 'DelegateCN' which would possibly override the primary CN...  As an aside, I think you can never allow actually overriding the CN  displayed in the UI directly, the most you can do is add another field in  the UI to show this string. First I need to know it's from Payment  Processor X, and then maybe we can let the payment processor make some  additional claim, like yes you are paying irs.gov. You can't give the  impression that Payment Processor X is not actually man-in-the-middle.
Maybe the simplest would be a single field expected to contain a delimited  key/value string (of course JSON) which could be shown as additional lines  of labeled text in the UI. I don't want to give the "merchant" too much  dynamic control over what the user's screen will display, but making it  somewhat dynamic might add some future proofing.
I think any additional extension fields should be hashed using the hash  function specified in pki_type and signed by X509Certificates.certifcate  private key. No extended_certs required -- I'm thinking something like;
message PaymentRequest {
  optional bytes extended_properties = 6;
  optional bytes extended_properties_sig = 7;

@_date: 2015-03-23 22:14:23
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] "network disruption as a service" and 
On Mon, 16 Mar 2015 09:29:03 -0700, Sergio Lerner  Thanks so much for publishing this. It could be useful in any application  to try to prove a keyed copy of some data.
If I understand correctly, transforming raw blocks to keyed blocks takes  512x longer than transforming keyed blocks back to raw. The key is public,  like the IP, or some other value which perhaps changes less frequently.
The verifier keeps blocks in the keyed format, and can decrypt quickly to  provide raw data, or use the keyed data for hashing to try to demonstrate  they have a pre-keyed copy.
Can you clarify, the prover is hashing random blocks of *decrypted*, as-in  raw, blockchain data? What does this prove other than, perhaps, fast  random IO of the blockchain? (which is useful in its own right, e.g. as a  way to ensure only full-node IO-bound mining if baked into the PoW)
How is the verifier validating the response without possession of the full  The challenger requests a hash-sum of a random sequence of indices of the  keyed data, based on a challenge seed. So in a few bytes round-trip we can  see how fast the computation is completed. If the data is already keyed,  the hash of 1,000 random 1024-bit blocks should come back much faster than  if the data needs to be keyed on-the-fly.
To verify the response, the challenger would have to use the peer's  identity key and perform the slower transforms on those same 1,000 blocks  and see that the result matches, so cost to challenger is higher than  prover, assuming they actually do the computation.
Which brings up a good tweak, a full-node challenger could have to do the  computation first, then also include something like HMAC(identityKey,  expectedResult). The prover could then know if the challenger was honest  before returning a result, and blacklist them if not.
I guess a new-node could see if different servers all returned the same  challenge response, but they would have no way to know if the challenge  response was technically correct, or sybil.
I also wonder about the effect of spinning disk versus SSD. Seek time for  1,000 random reads is either nearly zero or dominating depending on the  two modes. I wonder if a sequential read from a random index is a possible  trade-off,; it doesn't prove possession of the whole chain nearly as well,  but at least iowait converges significantly. Then again, that presupposes  a specific ordering on disk which might not exist. In X years it will all  be solid-state, so eventually it's moot.

@_date: 2015-03-27 11:40:43
@_author: Jeremy Spilman 
@_subject: [Bitcoin-development] "network disruption as a service" and 
Basically we're talking about a form of Sybil defense and better quantifying true blockchain resiliency by proof of storage.
In this case the goal is to see if we can prove the number of distinct digital copies of the blockchain. This is actually a tricky problem because it will (always?) devolve to inferences from response timing, and we are running over a heterogenous network with heterogeneous machines.
It would be extremely impressive to achieve a reliable mechanism for discerning a local copy exists under these constraints, particularly without false positives and false negatives, and without imposing very substantial one-time encoding costs, e.g. on par with doubling the verification cost. I think while its a difficult cost-benefit analysis, even code complexity aside, it's interesting to discuss all the same!
Simply having many unique IP addresses possibly accessing the same unique copy provides a different (if any) benefit. E.g. Tor uses IPs as a cost factor, but (until recently?) didn't even factor in things like them all being the same Class C.
