
@_date: 2012-02-28 18:12:12
@_author: =?ISO-8859-1?Q?Brautigam_R=F3bert?= 
@_subject: [Bitcoin-development] Duplicate transactions vulnerability 
I don't know whether I understand this correctly, but there should be no duplicate transaction hashes at all. So the rule should be: Do not allow blocks to contain transaction hashes which are already present in that If by a freak accident a transaction has the same hash as another transaction in the chain, shouldn't the transaction be "tweaked" in some way to avoid collision (generate a new target address for it or something)? In any case this seams very-very unlikely to happen, or am I missing something?

@_date: 2012-01-22 14:18:35
@_author: =?ISO-8859-1?Q?Brautigam_R=F3bert?= 
@_subject: [Bitcoin-development] ECC Signature Issue 
Hi all,
I'm working on a from scratch Java implementation. So far I got a modularized, unit tested implementation of the core modules (api, keys, blocks, chain, scripts, network protocol).
My dummy client however gets stuck on Block 140493, specifically at transaction hash: It seems the (signature) verification fails for this specific transaction (for the 1 input in it), which is rather odd since verification was successful for all the preceding blocks and inputs.
I double checked that the official (C++) client is indeed successful here. Oddly enough the bitcoinj implementation also seems to fail to verify this transaction, which seems to point in the direction of BouncyCastle (which we both use).
My question is, did anybody hit this issue before? If not, can someone doublecheck maybe that I'm not missing something trivial?
The data that should be signed (the signature hash):
The signature (with '01' at the end for SIGHASH_ALL, remove this before you pass it to verification): The public key:
As said, this seems to work with openssl, but seems to fail with bouncycastle for some reason (version 140).

@_date: 2012-01-24 18:33:33
@_author: =?UTF-8?B?QnJhdXRpZ2FtIFLDs2JlcnQ=?= 
@_subject: [Bitcoin-development] ECC Signature Issue 
Hi Mike,
Bitcoinj has a class named ECKey. I just hardwired it with a main() to
check the mentioned transaction's signature.
I debugged the official client to get the exact data (hash, signed data
and public key). I checked signatures of transactions prior to the
mentioned one, all work, so the test code and the data I got are very
likely correct.
It might be that I'm using old bitcoinj code (I think it is 0.3, can't
find a version string anywhere), but I doubt that has any impact on the
ecc verification. Even if it did, I got my on code too, so what are the
odds that two implementations fail at the same point?
Anyway it would be helpful if someone just tried to run a verification
independently with the mentioned transaction (with BouncyCastle and with
openssl) and see whether he/she gets the same result.
I tried with BouncyCastle 140 and the newest 1.46, both fail.

@_date: 2012-01-27 19:19:54
@_author: =?ISO-8859-1?Q?Brautigam_R=F3bert?= 
@_subject: [Bitcoin-development] ECC Signature Issue 
I'll reply to myself here, just to mention that the issue is solved.
Dave Hook from Bouncycastle replied that in the particular signature mentioned, one of the ASN1 encoded Integers is actually negative (which is not a valid coordinate for a point on a curve I assume). Since ASN1 integers are always signed, one has to pad "big" values with a zero byte to stay positive.
Workaround is easy for verification (convert to positive).
