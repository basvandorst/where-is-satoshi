
@_date: 2015-05-13 07:19:54
@_author: Daniel Kraft 
@_subject: [Bitcoin-development] Proposed additional options for pruned 
Hi all!
In the context of this discussion, let me also restate an idea I've
proposed in Bitcointalk for this.  It is probably not perfect and could
surely be adapted (I'm interested in that), but I think it meets
most/all of the criteria stated below.  It is similar to the idea with
"start points", but gives O(log height) instead of O(height) for
determining which blocks a node has.
Let me for simplicity assume that the node wants to store 50% of all
blocks.  It is straight-forward to extend the scheme so that this is
1) Create some kind of "seed" that can be compact and will be sent to
other peers to define which blocks the node has.  Use it to initialise a
PRNG of some sort.
2) Divide the range of all blocks into intervals with exponentially
growing size.  I. e., something like this:
1, 1, 2, 2, 4, 4, 8, 8, 16, 16, ...
With this, only O(log height) intervals are necessary to cover height
3) Using the PRNG, *one* of the two intervals of each length is
selected.  The node stores these blocks and discards the others.
(Possibly keeping the last 200 or 2,016 or whatever blocks additionally.)
You get contiguous block ranges (with at most O(log height) "breaks").
Also ranges of newer blocks are longer, which may be an advantage if
those blocks are needed more often.
With my proposal, each node determines randomly and on its own which
blocks to store.  No believing anyone.
Not exactly sure what you mean by that, but I think that's fulfilled.
You can (locally) compute in O(log height) from a node's seed whether or
not it has the blocks you need.  This needs only communication about the
node's seed.
See above.
O(log height).  Not O(1), but that's probably not a big issue.
See above.
Coverage will be uniform if the seed is created randomly and the PRNG
has good properties.  No need to update the seed if the other node's
fraction is unchanged.  (Not sure if you suggest for nodes to define a
"fraction" or rather an "absolute size".)
No need to do that with the scheme.
What do you think about this idea?  Some random thoughts from myself:
*) I need to formulate it in a more general way so that the fraction can
be arbitrary and not just 50%.  This should be easy to do, and I can do
it if there's interest.
*) It is O(log height) and not O(1), but that should not be too
different for the heights that are relevant.
*) Maybe it would be better / easier to not use the PRNG at all; just
decide to *always* use the first or the second interval with a given
size.  Not sure about that.
*) With the proposed scheme, the node's actual fraction of stored blocks
will vary between 1/2 and 2/3 (if I got the mathematics right, it is
still early) as the blocks come in.  Not sure if that's a problem.  I
can do a precise analysis of this property for an extended scheme if you
are interested in it.

@_date: 2015-05-26 16:11:14
@_author: Daniel Kraft 
@_subject: [Bitcoin-development] Bitcoin Survey Paper 
Hi Florian!
Thanks for the work you (and your collegue) put into this paper!  It is
definitely a good step in the right direction!
Do you know [1]?  I've only glanced at both papers, but it seems that's
also a research paper about Bitcoin & co.
  [1] Apart from that, let me advertise myself a little bit. ;)  In case you
are interested in the difficulty mechanism (which you only mention
briefly), I've recently written about it [2] (official publication) [3]
(preprint without paywall).
  [2]   [3] Good luck with your further research!

@_date: 2015-10-07 19:25:06
@_author: Daniel Kraft 
@_subject: [bitcoin-dev] The new obfuscation patch & GetStats 
I hope this is not a stupid question, but I thought I'd ask here first
instead of opening a Github ticket (in case I'm wrong).
With the recently merged "obfuscation" patch, content of the
"chainstate" LevelDB is obfuscated by XOR'ing against a random "key".
This is handled by CLevelDBWrapper's Read/Write methods, which probably
cover most of the usecases.
*However*, shouldn't it also be handled when iterating over the
database?  In particular, I would expect that the obfuscation key is
applied before line 119 in txdb.cpp (i. e., while iterating over the
coin database in CCoinsViewDB::GetStats).
Is there a reason why this need not be done there, or is this an actual

@_date: 2015-10-08 07:14:50
@_author: Daniel Kraft 
@_subject: [bitcoin-dev] The new obfuscation patch & GetStats 
Hi James!
Thanks for the quick fix!
I thought to submit a patch myself today in case the issue is confirmed
as an oversight, but it is very nice to see that this is no longer
necessary at all. :)

@_date: 2015-10-13 13:02:32
@_author: Daniel Kraft 
@_subject: [bitcoin-dev] Initial getheaders request 
I've stumbled upon the code that does the initial "getheaders" request,
i. e., around line 4960 of src/main.cpp [1].
  [1] For some reason, it uses not pindexBestHeader but the *preceding* block
pindexBestHeader->pprev as the "from argument".  In contrast, the
request on line 4132 [2] (which is done in response to a newly announced
block) *does* use pindexBestHeader.
  [2] I see no apparent reason for using the preceding call; but if I change
it to pindexBestHeader on line 4960 as well, the wallet.py test seems to
get stuck.  I've not been able to figure out from the logs and the code
why this is the case; can anyone help me?  I think this is something
that should really be explained in a comment around line 4960.  If
someone can make me understand, I can write a pull request for that -- I
guess this will save others some time wondering like I do at the moment.
