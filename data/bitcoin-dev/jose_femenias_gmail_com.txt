
@_date: 2017-06-11 22:05:24
@_author: =?utf-8?Q?JOSE_FEMENIAS_CA=C3=91UELO?= 
@_subject: [bitcoin-dev] Bitcoin pointers 
I?ve been doing some work lately to create a specification for bitcoin pointers. They can be used to point to transactions, inputs, outputs or some internal items within them.
The proposals strive for simplicity and user friendliness over compactness or other attributes.
There are three proposals, each of which builds upon the previous one, namely:
a) Canonical Pointers
The basic proposal.They look like this example: btc at 170.1/179-631-520
Here is a link to the Google Docs document ->   b) Mnemonic Pointers They build on Canonical Pointers and the dictionary provided in bip39 to use words instead of numbers. The previous Canonical pointer can thus be expressed as btc at best.ability /biology-exclude-donate
Here is a link to the Google Docs document ->   c) Domain Pointers They build on the Domain Name Registration system to encode a pointer to a Canonical Pointer as in btc at example.com Here is a link to the Google Docs document ->  I haven?t had any peer review yet, so it is very likely that some small or big problems can be found. I?d welcome any feedback from the community.
Best regards,
Jos? Femen?as Ca?uelo

@_date: 2017-11-01 11:34:40
@_author: =?utf-8?Q?JOSE_FEMENIAS_CA=C3=91UELO?= 
@_subject: [bitcoin-dev] Simplicity proposal - Jets? 
I am trying to follow this Simplicity proposal and I am seeing all over references to ?jets?, but I haven?t been able to find any good reference to it.
Can anyone give me a brief explanation and or a link pointing to this feature?

@_date: 2018-02-13 13:25:53
@_author: =?utf-8?Q?JOSE_FEMENIAS_CA=C3=91UELO?= 
@_subject: [bitcoin-dev] Possible change to the MIT license 
Bitcoin is licensed under the MIT license ( ) which is one of the most permissive licenses widely in use.
While this almost restriction-less license has proved useful to many software projects, I think it could be wise to question its current suitability for this project, given the recent history.
The difficulty among the general population to distinguish between Bitcoin (the protocol and software) and bitcoin (the currency) arises spontaneously from the intimate entanglement of both. The current list of Bitcoin lookalikes includes: Bitcoin Cash, Bitcoin Gold, Bitcoin Diamond, Bitcoin God, Bitcoin Clashic, Super Bitcoin, Bitcoin Hot, Bitcoin X, Oil Bitcoin, Bitcoin World, Lightning Bitcoin...
This recent flurry of hard forks is, IMHO, exacerbating the confusion about the very nature of the project, and harming it in many ways.
Although the liberal MIT license is (rightfully) beneficial to many other projects, companies and individuals, it is my belief that several projects are unfairly taking advantage of this generous license to attack Bitcoin (both the software and the currency), confuse the public, and gain personal profit in a way that is severely harming the Bitcoin ecosystem.
Therefore, I?d like to raise the possibility of amending the MIT license in a simple way, by adding a line such as:
NO PART OF THIS SOFTWARE CAN BE INCLUDED IN ANY OTHER PROJECT THAT USES THE NAME BITCOIN AS PART OF ITS NAME AND/OR ITS MARKETING MATERIAL UNLESS THE SOFTWARE PRODUCED BY THAT PROJECT IS FULLY COMPATIBLE WITH THE BITCOIN (CORE) BLOCKCHAIN
(This is just an approximation. A final version would probably have to include a restriction to some soundalikes like BITKOIN, BIITCOIN,?)
This way, I could legitimate use this software to create my own crypto coin, or use it in Ethereum, Litecoin or any of the other legitimate cryptos, but I could not make my ?Bitcoin Whatever? fork and keep using this software as the basis for it. I could also fork the bitcoin blockchain to create ?Bcoin lightspeed? but not ?Bitcoin lightspeed? for instance.
I know this would probably not prevent the explosion of forks in the future, but maybe it could help mitigate the confusion among the users and the harm to this community. Even if its enforceability is dubious, at least any infringing project would be exposed to some liability. I see myself some possible loopholes the way the license addendum is written. My intention is not to arrive immediately to a final wording but to know if there is some value to the idea of changing the license with this purpose.
Jose Femenias

@_date: 2018-03-11 13:44:47
@_author: =?utf-8?Q?JOSE_FEMENIAS_CA=C3=91UELO?= 
@_subject: [bitcoin-dev] Bulletproof CT as basis for election voting? 
If I understand Bulletproof Confidential Transactions properly, their main virtue is being able to hide not the senders/receivers of a coin but the amount transferred.
That sounds to me like a perfect use case for an election.
For instance, in my country, every citizen is issued a National ID Card with a digital certificate. So, a naive implementation could simply be that the Voting Authority, sends a coin (1 coin = 1 vote) to each citizen above 18. This would be an open transaction, so it is easily auditable.
Later on, each voter sends her coin to her preferred party, as part of a Bulletproof CT, along with 0 coins to other parties to disguise her vote.
In the end, each party will accrue as may votes as coins received.
Is there any gotcha I?m missing here? Are there any missing features required in Bulletproof to support this use case?

@_date: 2019-12-02 22:25:01
@_author: =?utf-8?Q?Jose_Femen=C3=ADas_Ca=C3=B1uelo?= 
@_subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments 
it is fully decentralized indeed. Every user is in charge of creating and maintaining his own account.
Jos? Femen?as

@_date: 2019-12-05 21:00:03
@_author: =?utf-8?Q?Jose_Femen=C3=ADas_Ca=C3=B1uelo?= 
@_subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments 
Hi ZmnSCPxj
first of all, excuse me for my delayed answer. I think I posted to the wrong address the first time (I?m mainly a lurker in the list, so I make gotchas like that?)
Let me address your points.
I don?t understand what you mean by ?renting? Bitcoins. Once you commit the account transaction, the account ID never changes.
(Also, you don?t need to own Bitcoins if you use a Master Easypaysy Account. See my comments later on).
That is not the case. When using non-interactive payments, the payee doesn?t need to be online at all.
Even for interactive payments, it depends on the protocol you use.
For Bitmessage, or email, or even MQTT you don?t need to be online simultaneously. (The interactive protocol(s) is still open, however, those are just some hypothetical examples):
Anyway, when using interactive payments, the payee has the option to specify an LN invoice and/or a bitcoin address.
Easypaysy accounts don?t need 2 TXs. They need funding plus a TX for the account information itself.
So, you need an UTXO -to fund the account- and a TX. But the UTXO can be one of many in the same transaction. So, you could fund multiple accounts with a single TX.
Easypaysy is protocol agnostic (for now). So, Tor is definitely a possibility.
There is really no need to specify an additional output.
If I am right, you can?t have more than one OP_RETURN per transaction.
On the other hand, as you can see in the white paper ?4.2 Master accounts?, these type of accounts allow for up to 2048 accounts per transaction.
The format of the ID in this case is: btc at master_idx.slave_id/checksum
The master_idx is an ordinal pointer (not positional) to the Master TX, while the slave_id points to one of the 2048 transactions within the account (whose information is stored elsewhere, protected by a Merkle root committed in the Master Tx)
There is a little bit more to it that seems appropriate to discuss here, please have a look at page 25 of the white paper.
Thanks for your input.
Best regards,
Jos? Femen?as

@_date: 2019-12-06 08:56:52
@_author: =?utf-8?Q?Jose_Femen=C3=ADas_Ca=C3=B1uelo?= 
@_subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments 
Hi ZmnSCPxj,
first of all: do you ever sleep?    ;-)
A few points about your reply:
a) The easypaysy white paper isn?t a final set of specifications. Instead it is meant as a somewhat detailed draft of the ideas that can drive a working set of specifications.
As such, any qualified input -as in your case- is much welcome, since it can greatly help with the process.
b) Master accounts are included in the white paper as a feature for a future release. The roadmap is not set yet, but I?d like to include a first release of the protocol that only covers the most basic features, to make it simpler and safer for wallet developers. Master accounts aren?t a priority, since they are more oriented towards scaling the proposal, and that is far from being a problem yet. So, this feature is not well defined for now. However, as presented in the white paper, the ?service provider? has really no control over your money.
He would basically do a just a few things: - Aggregate the account info (up to 2048 individual accounts per master account).
- Hash every account info, sort them, and calculate the Merkle root of a tree containing them all.
- Create a JSON document containing the information of all the sub-accounts included in the pack.
- Make that JSON document publicly available, probably with a https: URL (That?s called an Authoritative server)
- Finally, create and publish a TX that contains a pointer to the Authoritative server, and the Merkle root of the set of accounts.
The service provider would have NO control whatsoever of your funds, nor can he block payments, etc.
There is some sort of delegation, but no trust involved here. The Merkle root protects agains any attempt of tampering with the account data.
The account?s TX won?t ever disappear from the blockchain, so your account info will always be there.
Worst case scenario, the service provider disappears and users can?t download the Json document containing your account information.
To mitigate this issue, the white paper suggests the creation of mirror servers.
Page 27
'The risk that the authoritative server designated within the EASYPAYSY_MASTER_ACCOUNT_DESCRIPTOR could become unavailable can be mitigated with the use of mirror servers.?
'It is conceivable that the mirror could charge for this service, perhaps requiring a small LN payment per request, so there will be an economic incentive to preserve the information associated with every master account ever published into the blockchain.?
c) I am a BIG fan of the Lightning network (see the example before). I wouldn?t like to sound as easypaysy promotes on-chain payments vs LN payments.
I still think there is room for both. I guess and hope that LN payments will grow exponentially in the future. However, some large transactions and a few other uses cases will probably make more sense on-chain.
d) Regarding your comments on the possibility of adding the output index in the account ID, I still don?t see the need for the use case of easypaysy (since, by definition, easypaysy accounts must have exactly one input and two outputs).
*** However ***, your idea is sound and I can see some use cases for both pointing to the input and output of a TX.
In fact, the seed for easypaysy is some work I did previously, called ?Bitcoin pointers? (you can search the dev list for the link).
In there, I proposed a fuller set of features for a TX-ID, including both pointing to the input and the output of a TX.
This is an excerpt from the document on canonical pointers:
'It is also possible to refer to an input: and/or  :output within a transaction. In our example, the canonical pointers that point to the first input and the second output of that  transaction are, respectively:
Additionally, the specs allow for the use of attributes; quoting again:
'btc at 170.1:1/179_address should return 12cbQLTFMXRnSzktFkuoG3eHoMeFtpTu3S, which is the address of the second output of that transaction?.
e) The white paper barely touches the implications the easypaysy protocol could have for the Lightning Network, other than citing the possibility of receiving an LN invoice within the Payment reply document.
I didn?t really have neither the time, nor the expertise required to explore further applicability for LN, although I can imagine some use cases.
I know you are quite the expert on LN issues, so if you would like to contribute your suggestions on how to shape the protocol in this regard, I will very much welcome your contributions.
If you are interested, please contact me, preferably privately since I wouldn?t want to become much too off topic in this dev-list
Thanks again for your comments.
Jose Femenias
jose.femenias at gmail.com

@_date: 2019-12-06 19:47:38
@_author: =?utf-8?Q?Jose_Femen=C3=ADas_Ca=C3=B1uelo?= 
@_subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments 
Hi ZmnSCPxj,
Haha, I?am starting to believe that?s not a joke ...
You are right. The lifecycle of a regular easypaysy account states that you spend its TXO circularly as many times as you want, specifying changes in its OP_RETURN (you can?t change the Identity or Value key).
When you want to revoke an account, you simply spend its last update (if any) to a different address (not the one it was funded originally with).
Nope, he will keep control of the TXO keys.
You are right about that too? (I wonder if some kind of MAST smart contract could fix this, maybe you have a suggestion for this; I am thinking K of M users can override the service provider if he misbehaves)
What I have in mind, but haven?t completely figured out, in case of an uncooperative service provider -or just because one user decides to fly solo- is the possibility for a sub-account to ?detach? itself from the master account.
The sub-account holder would do so by:
a) Funding the multisig 2-of-2 address composed of his Id_key + Value_key, included in the common JSON file, not the Master TX. (And yes, in this event he will need to buy some btc, because life is hard...)
b) Publishing his own update, much like a regular easypaysy account does.
In any case, the account ID never changes, it would always keep pointing to the original place where it appeared on the blockchain. User wallets would have to query for the multisig address of a particular account to check whether the account is detached or not.
As as side note, I expect most easypaysy accounts to choose only non-interactive payments, since they have fewer requirements than their interactive counterparts; so -in most cases- the majority of users won?t ever have to update their accounts.
So, even if the ?service provider? goes away or becomes uncooperative, it is just business as usual for the sub-account owners, and they can work just fine with the mirrors.
(Again, all of these is speculative for now. I hope scalability will become an issue for easypaysy one day, but I think we?ll have time to work out the best solution by then)
I really need to study this further before I can express an informed opinion on your suggestion.
On the other hand, for Master accounts I don?t think cost or space should be a problem, since both can be shared among up to 2048 sub-accounts.
For regular accounts, it could be.
But, based on the private feedback I am having from two prominent figures in the space, making sure the protocol is easy to implement for SPV wallets is essential to encourage wallet adoption.
A separate transport layer doesn?t fit well with this. So, maybe your suggestion will become more applicable in future iterations of the protocol. I may request your help for further clarification about this issue, if you are so kind (as you always are).
The easypaysy identifier doesn?t point to the funding TXO. Instead it points to the first transaction that spends the funding TXO (the TX with the OP_RETURN containing the ?Rendezvous descriptor?)
So, you are right in that the funding TXO doesn?t need to be a one-input, two-output transaction.
Nope. The easypaysy identifier always points the placement in the blockchain of the first transaction that spends the funding TXO, not the TXO itself (please read page 3, ?2.3 Account ID?).
Further updates (performed by spending its single non-zero output to the same address) must be verified by wallets (by asking for the payment history of the funding address; but they never change the account ID, by convention).
So, for example, (I?m following the example in page 13 of the white paper):
a) TX  in block 859253, that has j outputs and k outputs, has an output (k) that sends funds to the 2-of-2 multisig address ?3NhgE9?bqs?.    This is the address that the Identity_key + Value_key can spend.
b) Several blocks later, TX  in its single input, spends the TXO with another TXO the same address ?3NhgE9?bqs?.    It sends all of the funds (minus the fee) in its first output (the 2nd is the OP_RETURN).
   This TX (called the ep_root_tx in the protocol) appears in block 859368 at, let?s say position 349. So its permanent ID will be (obviating the checksum):    btc at 859368.349
   This is the ID you share with your potential payers. Whenever they want to send funds to you, they will look up the 349th transaction at block 859368.    They don?t need to check the funding TX at all. They only have to check the signature of the ep_root_tx, because that?s the part of the TX where they can find both the Identity_key and the Value_key.
   Since this TX, by definition of the protocol, can only have a single input, there will be a single signature in it, so there is no need for its easypaysy ID to include a pointer to the input in the TX.
c) A few more blocks later, appears TX  a similar 1-input 2-output TX, that updates its OP_RETURN with a new ?Rendezvous descriptor? (in the example, it changes the email endpoint)
d) Finally, the user revokes the account by spending the output in c) to a different address (17He...A45n).
Since the easypaysy proposal is about a layer-2 protocol, I am not sure the developers in this list want to see this much detail about something that maybe doesn?t affect them at all.
Hopefully I am wrong and this is relevant for many of the list subscribers.
Again, thanks for your time and contributions.
Best regards,
