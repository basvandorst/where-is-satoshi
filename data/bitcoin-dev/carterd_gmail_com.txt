
@_date: 2014-02-12 08:34:48
@_author: Dan Carter 
@_subject: [Bitcoin-development] Decentralized digital asset exchange with 
I'm not sure how well this would work.
Sure it would provide honest historical pricing, but those who wait for publication confirmation may be at a disadvantage -- to get the best deal possible Bob would connect to as many nodes as he could, examine the stream of unconfirmed asks coming in and sign the best ones before someone else does.  The network would gravitate towards an O(n^2) fully connected network, because being fully connected means one is fully aware of all unconfirmed asks at any moment so one can make the best judgement and buy before someone else does.
The seller needs a guarantee that all bidders can act on the ask transaction simultaneously. Maybe the partial ask transaction could be time-locked with a network propagation delay, there would be multiple bidder responses and the winner is chosen by lottery (and fee priority) by the bitcoin/alt-coin miner who confirms the atomic transaction in their block.  That would eliminate the advantage to being fully connected as it would no longer matter that one can act first, so you have a more sane network.

@_date: 2014-03-06 04:23:40
@_author: Dan Carter 
@_subject: [Bitcoin-development] Stealth Addresses 
I think stealth addresses combined with zk-snarks would obviate the need for CoinJoin.  zk-snarks could be used to hide the coin's value and stealth addresses could be used to hide the recipient for payments and even mined coins.  More info on zero-knowledge snarks:
Start with a mined coin: generate a coin secret, create a coinbase transaction with an output to your stealth address and send hash(coin-secret + reward-value) + encrypt(coin-secret + reward-value) where only the recipient (you) can decrypt. (The reward value is known publicly but just assume it isn't here for generality). You also embed the 0.2KB zk-snark proof + 3KB verifying key that the hash result is in fact SHA256(coin-secret + reward-value), where your private witnesses are (coin-secret, reward-value).
Now you could split a coin into as many pieces as you want in a single transaction and send to multiple recipients, some pieces go to yourself (change) and others to the payee, every piece would have a different recipient address thanks to stealth addresses, and all values hidden thanks to zk-snarks.
So lets say you want to split the mined coin into two new ones.  You create a transaction where the input redeems the mined coin using mined tx out + your stealth address, and there are two new coins as outputs to your own stealth address each having: hash(new-coin-secret + new-hidden-value) + encrypt(new-coin-secret + new-hidden-value).  You also embed the zk-snark proof that the two new hidden values add up to the original hidden value, and that the two new hash results are in fact SHA256(new-coin-secret + new-hidden-value), where your private witnesses are (original-coin-secret, original-hidden-value, new-coin-secrets, If you want to merge two coins into one it's just a split backwards, two inputs one output, zk-snark proof that two original hidden values add up to the new hidden value and that the new hash result is SHA256(new-coin-secret + new-hidden-value).
If you want to transfer ownership of a coin then just redeem at input, and output same as mined coin except using recipient stealth address (which is a public key) to encrypt(coin-secret + hidden-value).
- Dan
