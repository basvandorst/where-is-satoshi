
@_date: 2020-02-07 13:55:29
@_author: Mike Kelly 
@_subject: [bitcoin-dev] Purge attacks (spin on sabotage attacks) 
Since I raised this with Hasu in early Jan[0], I've been looking for ways
to eliminate transaction replacement that are consensus compatible (since
first safe seen is not). The best I could come up with is "Uncontested
Safe", which I've tried to sketch out in a brief medium article[1].
Am I retracing steps? Feedback would be appreciated.
[0] [1] On Sat, Feb 1, 2020 at 10:12 PM ha su via bitcoin-dev <

@_date: 2020-02-08 08:11:17
@_author: Mike Kelly 
@_subject: [bitcoin-dev] Purge attacks (spin on sabotage attacks) 
Hi ZmnSCPxj, thanks for your reply. Comments in line.
Yes, it intentionally violates that rule. It?s unclear to me right now what
the consequence/cost of doing so in this specific way would be. Are you
able to explain?
The attack itself is better classified as a form of sabotage than
censorship. The goal is to demonstrate the ongoing mutability of
transactions beyond any inherent heuristic for ?finality?. iow it is a
demonstration that will damage the network?s future ability to offer
settlement assurances.
Trying to use Child Pays For Parent to defend in a bidding war against an
opportunist attacker retrieving spent Bitcoin via RBF is a losing game for
the defender. There?s no opportunity cost for the attacker, any amount
retrieved is profit. The defender, on the other hand, is always losing
value. This is exactly the kind of conflict and discoordination the attack
is intended to induce.

@_date: 2020-02-09 10:15:18
@_author: Mike Kelly 
@_subject: [bitcoin-dev] Purge attacks (spin on sabotage attacks) 
Hi ZmnSCPxj,
I don't see how the scenario you outline here has anything to do with the
mechanism I proposed. An empty block doesn't contain any transactions (by
definition) so it wont contest any transactions in any given node's
mempool. The aim isn't to prevent empty nodes, it's to discourage miners
from including transactions in their block that conflict with the
eventually-consistent state of consensus in the mempool.
How would this mechanism produce a chainsplit by chance?
I got to thinking about "purge attacks" and mitigations because I was red
teaming how G20 states that have seized the major mining operations could
most effectively destroy value and confidence in Bitcoin. This scenario is
_a lot_ more likely than rogue asteroids.
What happens if the G20 decide to reorg deeper 6 - say 10, or even 20?
If the Bitcoin continues to offer replace by fee I think this will be their
first attack with seized majority hashrate;
- mine offline
- reach > 10 deep empty block reorg as heaviest chain
- announce it
- semi-honest mine with a preference for RBF'ed "root" txns, ignoring any
profitable child pays for parent.
- repeat above, until some goal reached (eg. $ value of Bitcoin reaching x)
- switch to "DoS mode" where you empty block reorg the chain tip
If we got rid of RBF, their only option would be DoS mode. Once it stops,
honest mining could resume and the blocks will fill back up again with
transactions out of the mempool preserved in the right order.#
Hope that makes sense.

@_date: 2020-02-10 15:28:20
@_author: Mike Kelly 
@_subject: [bitcoin-dev] Purge attacks (spin on sabotage attacks) 
Hi ZmnSCPxj, thanks for sticking with me on this.
There is no way to prevent someone with the majority of hash rate doing
empty block reorgs. This is not new and it's not the problem/point of a
purge attack. The point of a purge attack is that _under the conditions of
an empty block reorg_ if the network affords transaction replacement (ie.
RBF) then users with who instructed transactions which are now un-confirmed
and back in the mempool have the opportunity to double spend them by
replacing the transaction that was considered finalised. We can prevent
this scenario by eliminating transaction replacement in the network.
No need to record the state of the mempool. Newly-started nodes should
select the heaviest chain as per usual.
What is the evidence for this claim? Is there a proof?
Yes, under the current design. This is an attempt to change the incentives
of the protocol so that this is not the case. To try and reduce the
severity of empty block reorg attacks.
The whole point of this sabotage attack is that it demonstrates that
confirmation is not a reasonable way of managing this risk. If the depth of
the empty block reorg was 20, even if everyone stuck to the arbitrary 6
confirmation rule, nearly every Bitcoin transaction from the 14 blocks
between `chaintip-6` and `chaintip-20` is at risk of being double spent as
it lands back in the mempool.
Censorship of availability of the network? That's DoS ie. what a standard
empty reorg attack.
Purge attack is an extension of this that extends such an into the realm of
sabotage, where the integrity of previously-adequately-confirmed
transactions is compromised by allowing users to double spend them.
