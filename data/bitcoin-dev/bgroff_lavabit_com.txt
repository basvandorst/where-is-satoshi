
@_date: 2011-08-03 02:10:47
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] Discussion related to pull 349 and pull 
Thank you!  (I think you mean 319 here)
With Eligius mining !IsStandard transactions and probably other pools open
to the idea, I am hopeful that we can quickly get 30%+ of mining power to
upgrade, which means that we could still mine these in a reasonable time
frame (under 1 hour).
I'm not sure I see the problem here.  CScript.operator<< currently inserts
values into scripts using the shortest possible sequence.  As long as code
continues to conform to this convention, scripts generated by it will
verify correctly.
If new code is written that generates one of the longer sequences, it will
generate transactions that will not pass block validation since the
signature won't verify.  So such code will be useless and we can refrain
from writing it?
Bobby Groff

@_date: 2011-08-07 20:21:48
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] Discussion related to pull 349 and pull 
Right, the user would have to connect directly to miners accepting
non-standard transactions.
With the latest high profile security breaches, I am hoping that the whole
things can be pulled relatively soon.  Building secure deposit systems
will improve trust in the ecosystem.
I've included a significant amount of unit tests to "pay" for the
additional feature, and I can add more if needed.
Bobby Groff

@_date: 2011-08-11 13:49:21
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] Roadmap/schedules 
I'm not sure splitting the patch this way makes a big difference.  The
IsStandard part depends on the construction of the multisign script, which
is what most of the patch does anyway.  In other words, if upon further
review the script construction needs to change, IsStandard will change. So a full review would be better.
Also, with unit test coverage for both this feature and existing
script.cpp code, I'm hoping that this patch is relatively low risk and
actually pays down some existing test debt.
Bobby Groff

@_date: 2011-08-24 13:47:55
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] New standard transaction types: time to 
I agree.  For example, a corporate wallet can require threshold signatures
to disburse.  Or for personal use you can have a couple of additional
keys, one stored on a secure device for confirmation and one offline as
emergency backup if you lose your secure device.
For context - I am the author of the latter.
Incompatible at the UI level, but not at the block chain level.  Changing
the block chain rules will be quite an undertaking.  You will have to set
a block number for the rule change a few months in advance and will have
to get agreement from the pools.  I think it is important to increase
trust in the bitcoin ecosystem sooner than that.  The current flat
exchange rate and difficulty may be a signal that people are getting risk
That is my worry too.  We already have working code for this (pull 319),
and the addresses are not so long as to be unusable.  I hope we can move
forward on the existing code and in parallel move forward on block chain
rule proposals at an agreed upon block number.
Bobby Groff

@_date: 2011-08-26 21:15:26
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] New standard transaction types: time to 
Right, that is the workaround in pull 319.
There is another disadvantage to CHECKMULTISIG - you currently can only
have 1000 of these in a block.  This is because a CHECKMULTISIG is counted
as 20 sigop operations in GetSigOpCount, and you can have a maximum of
20000 sigops in a block (MAX_BLOCK_SIGOPS).  This is in CheckBlock so
won't change anytime soon.
If you want to use HASH160 based addresses, CHECKMULTISIG looks even less
attractive.  The shortest script with CHECKSIG is something like:
OVER 2SWAP CHECKSIG SWAP HASH160 {} EQUAL BOOLAND ADD // n times
m GREATERTHANOREQUAL
( thanks to coblee
 )
I think this is actually as short as the shortest you can do with
Another issue that came up during pull 319 discussion is whether to
support more general cases or more specific cases.  For example, should we
optimize for the 1-of-2, 2-of-2 and 2-of-3 cases or should we just have
one script template for all m-of-n? I would propose focusing on a more
general case for the following reasons:
* It is easier to validate one general algorithm than an expanding set of
special-purpose functions.  For example, I think the most people on this
list can validate the coblee script above for all n and m, but faced with
a bunch of special purpose scripts they might miss a bug.
* We don't have to expose the most general cases to the API, but it would
be nice if we didn't have to keep changing IsStandard as people find use
cases for 2-of-4, etc.  With IsStandard remaining narrow, innovation with
new scripts is stifled because most client won't mine or relay
non-standard transactions.
* It would be less work for third-party software to track this
(blockexplorer, android wallet).
Bobby Groff

@_date: 2011-08-26 21:36:19
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] New standard transaction types: time to 
Here are some additional use cases:
* Long term lock funds, requiring signatures from 2 officers of a company
to disburse (2 of n for n between 3 and 20)
* Short term lock funds, with 2-factor auth to disburse and an additional
2 of n backup in case one of the factors is lost (2-of-2 OR 2-of-n)
* "Escrow" with the the two parties having to agree or one of two backup
observers helping in case of disagreement (2-of-2 OR 2-of-3 OR 2-of-3)
* An options contract where the outcome is triggered by a key being
broadcast: (Ks AND K1) OR (Kr AND K2) - s gets control of funds if K1 is
broadcast, r gets control if K2 is broadcast.

@_date: 2011-06-16 00:53:40
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] [PULL] Add scriptPubKey enforced sendescrow 
I have a pull request here:
  Bitcoin "escrow" are coins that are under the control of multiple
  parties.  The initial implementation allows n parties to vote, with
  k good signatures needed (k <= n).
  This eliminates single points of failure and reduces the trust required
  in many transaction use cases.
Use cases include Escrow (without trusting the escrow agent with the
coins), immediate payment and funds locked with multi-party signatures.
This was inspired by  and
 .
Feedback on the pull is very much appreciated.

@_date: 2011-06-16 23:05:59
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] Development priorities 
I agree that these are critical and I'd love to help, especially on  and
   will, by necessity, include a thorough review of the code, which
may uncover latent issues.
I think that for  it would also be good to publish a "Best security
practices" document to try and educate the user base.
That is understandable.  However, something to think about later is that
multi-signature coins can help with  even with compromised end-user
Bobby Groff

@_date: 2011-06-22 12:23:46
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] [PULL] Add scriptPubKey enforced 
Gavin said:
I currently have 2,ADDR1,ADDR2,ADDR3 (2-of-3 example) as this new address
This is similar to the way the current implementation works.  It uses
HASH160, but there's no attempt to save space by hashing the sum of the
pubkeys.  The major advantage of summing is shorter address for the end
user to copy-paste.  The disadvantage is the need for long term storage of
the key set so you know what keys to sign with.
Bobby Groff

@_date: 2011-06-22 15:33:12
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] [PULL] Add scriptPubKey enforced 
On second thought, I'm not sure this is workable.  You would have to
distribute each party's pubkey ahead of time, otherwise you run the risk
that a party falls off the face of the earth and then you can't provide
the pubkeys to have hash(pubkey1+2+3) EQUALVERIFY.
If you have to distribute the pubkeys ahead of time, then the reduction in
address length becomes moot.
So it seems to be either distribute the pubkeys or distribute the
Bobby Groff

@_date: 2011-06-22 16:44:38
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] [PULL] Add scriptPubKey enforced 
Here's a strawman use-case for a browser centric flow for a 2-of-3 scenario.
* User is on Merchant site on the checkout page
* User selects a transaction Observer (I'm trying to get away from using
the word escrow, because the funds are not held by the third party)
* Merchant redirects to the Observer, passing in the Merchant's payout
* The User enters User's address
* Observer presents multisign address
"2,merchant-addr,user-addr,observer-addr" and terms and conditions - i.e.
under what circumstances the Observer will sign
* User copy/pastes the multisign address to their bitcoin client and sends
* After some blocks go by, merchant ships
* Merchant reminds User to release funds
* User creates a partial tx paying out to merchant-addr and emails or
copy-pastes to Merchant
* Merchant signs and publishes the tx
Funding requires two pastes and redemption requires one.  A browser
plug-in would reduce the User effort to a couple of confirmatory clicks -
"do you want to send X BTC to Merchant Y with Observer Z?" and "do you
want to release X BTC to Merchant Y?".
Bobby Groff

@_date: 2011-09-19 12:01:24
@_author: bgroff@lavabit.com 
@_subject: [Bitcoin-development] Bitcoin Enhancement Proposals (BEPS) 
Would the multi-signature proposal be a good test case for BEP-0002?
I can reformat it and email here.
Gavin has a competing one:  and I have a pull request matching a previous version of my proposal.
Bobby Groff
