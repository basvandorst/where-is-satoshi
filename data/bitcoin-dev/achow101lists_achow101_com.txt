
@_date: 2017-08-18 22:11:14
@_author: Andrew Chow 
@_subject: [bitcoin-dev] [BIP Proposal] Partially Signed Bitcoin Transaction 
Hi everyone,
I would like to propose a standard format for unsigned and partially signed
This document proposes a binary transaction format which contains the
necessary for a signer to produce signatures for the transaction and holds
signatures for an input while the input does not have a complete set of
The signer can be offline as all necessary information will be provided in
Creating unsigned or partially signed transactions to be passed around to
signers is currently implementation dependent, making it hard for people
who use
different wallet software from being able to easily do so. One of the goals
of this
document is to create a standard and extensible format that can be used
between clients to allow
people to pass around the same transaction to sign and combine their
signatures. The
format is also designed to be easily extended for future use which is
harder to do
with existing transaction formats.
Signing transactions also requires users to have access to the UTXOs being
spent. This transaction
format will allow offline signers such as air-gapped wallets and hardware
to be able to sign transactions without needing direct access to the UTXO
set and without
risk of being defrauded.
The full text can be found here:
Andrew Chow

@_date: 2017-07-13 12:48:52
@_author: Andrew Chow 
@_subject: [bitcoin-dev] A Segwit2x BIP 
What's special about block 475776?
On July 13, 2017 12:23:46 PM Sergio Demian Lerner via bitcoin-dev

@_date: 2017-03-08 16:21:15
@_author: Andrew Chow 
@_subject: [bitcoin-dev] High consensus fork system for scaling without 
Hi Erik,
I have left you some comments below.
Some general questions:
How will you deal with excessive sighashing (i.e. massive transactions
that include a lot of signature verification)?
Presumably the sigops limit will increase proportionally?
What does EB stand for?
What is the point of users publishing an EB? Is it for miners to
determine what to set theirs to? If so, what about sybil attacks with
fake nodes publishing EBs?
How do users publish an EB? Do they use a transaction? Or is it
something that goes into the User Agent?
How high can the EB go? What is its maximum?
So anyone who does not change their EB are forked off of the network? If
the EB is an "advanced feature", then most users are going to be leaving
it at the default shipped with the software. That means that they will
then be forked off of the network when they don't change the EB because
it is an "advanced feature" that is more difficult to access.
I think this would require a soft fork beforehand in order to implement
such a system.
"Scaling" includes a lot more than just the block size. There is much
more to scaling than just increasing the block size.
What if the EB of a new node is set to be smaller than the current block

@_date: 2017-03-23 19:14:28
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Issolated Bitcoin Nodes 
The issue is due to Segwit blocks since Testnet has already activated
Segwit. 0.12.x- nodes will receive a Segwit block with all of the
witnesses stripped. When they relay this block to a 0.13.0+ node, the
block will be rejected because those have Segwit functionality and
require the witnesses to be in the block. Given that Testnet has a
smaller number of nodes and less difficulty, this could result in some
miners using 0.13.0+ mining blocks which do not propagate well and thus
causing multiple chain splits and reorgs as other miners find blocks for
the same height before receiving a block for that height.

@_date: 2017-03-23 23:38:21
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Issolated Bitcoin Nodes 
A correction to my previous email (because people are quoting me on
r/btc and what I wrote was wrong)
This statement is incorrect:
this could result in some miners using 0.13.0+ mining blocks which do
not propagate well and thus causing multiple chain splits and reorgs as
other miners find blocks for the same height before receiving a block
for that height.
Miners using 0.13.0+ will produce blocks that propagate well. This is
because 0.12.x- nodes will accept those blocks, and so will 0.13.0+.
Furthermore Core 0.13.0+ will use its outbound connections to connect to
segwit enabled peers so that it will be relaying segwit blocks to
someone. However Bitcoin Core 0.13.0+ will not request blocks from peers
that are not segwit enabled (because with segwit, they will be receiving
blocks without witnesses which are invalid to a segwit node), so they
will not receive blocks mined by a 0.12.x- node. This means that 0.12.x-
mined blocks propagate poorly, even though are valid. Because of the
poor propagation, a 0.13.0+ miner can find a block at the same height
which is more likely to get built upon. However, the poorly propagated
block can still reach other 0.12.x- miners who can build upon it due to
the low difficulty and difficulty resets, thus causing multiple chains
to exist, particularly among pockets of 0.12.x- nodes. The reorgs happen
when either the 0.12.x- nodes hear of the segwit blockchain that is
presumably longer because it has the majority hashrate, or when people
run bridges which allow 0.12.x- nodes relay blocks to 0.13.0+ nodes.

@_date: 2017-05-23 16:39:19
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Reduced signalling threshold activation of 
Hi James,
segwit implementation with regards to the NODE_WITNESS service bit. I
believe it could cause network partitioning if the service bit is not

@_date: 2017-05-23 16:58:14
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Reduced signalling threshold activation of 
Ah. I see now. It wasn't very clear to me that that is what will happen.
Also, shouldn't the timeout date be set for before the BIP141 timeout?
Otherwise this could lock in but not have enough time for Segwit to be
locked in.

@_date: 2018-08-13 20:32:33
@_author: Achow101 
@_subject: [bitcoin-dev] Witness serialization in PSBT non-witness UTXOs 
Since the BIP is already in proposed status, I think that we should specify the non-witness utxo to just be "witness or non-witness" serialization. This maintains compatibility with things that have already implemented but also maintains the forwards compatibility that is needed.
??????? Original Message ???????

@_date: 2018-07-04 14:35:16
@_author: Achow101 
@_subject: [bitcoin-dev] BIP 174 thoughts 
You cannot simply reject PSBTs for having conflicting values for the same key. Especially
for the Partial Signatures, you can have two signatures for the same pubkey that are both
completely valid. This situation could happen, for example, if a signer that does not use deterministic
k values can sign multiple inputs but one input is missing a UTXO so it doesn't sign it. So it receives
 one PSBT and signs the first input but not the second. It receives a PSBT for the same transaction
which has the second input's UTXO but does not have its signatures for the first input. The signer
would sign both inputs. When the two PSBTs are combined (suppose the first PSBT has other signatures too), you will have two keys that have different values. The different values are both
valid signatures, just with different k values since they were randomly generated instead of
deterministically. If we fail to merge these, then you could potentially have a situation where
nothing can be done with the PSBTs now, or now everyone has to resign and in some specific
order to avoid the conflict. That complicates things and is much more annoying to deal with.
So a simple solution is to allow the combiner to choose any value it wants as it is likely that
both values are valid.
Allowing combiners to choose any value also allows for intelligent combiners to choose the
correct values in the case of conflicts. A smart combiner could, when combining redeem scripts
and witness scripts, check that the redeem scripts and witness scripts match the hash provided
in the UTXO (or in the redeem script) and choose the correct redeem script and witness script
accordingly if there were, for some reason, a conflict there.
Can you explain why it would be unsafe for combiners to arbitrarily choose a value?
I think that requiring there to be no unknowns is a safe change.

@_date: 2018-07-06 14:59:50
@_author: Achow101 
@_subject: [bitcoin-dev] BIP 174 thoughts 
??????? Original Message ???????
I don't think this is really a problem.
Almost all roles have to deserialize the unsigned tx anyways before they can do anything.
The only role that doesn't is a simple combiner (a combiner that does sanity checks would
still have to deserialize the unsigned tx), and even then it doesn't matter. It just shoves
key value pairs together and doesn't need to know whether the map is for an input or for
an output.
If a combiner writes the wrong number of key-value maps, then it would simply be invalid
to the next person that receives the PSBT. It would not deserialize properly because the
key value pairs would have incorrect values for their types. Not deserializing properly means
that the PSBT is simply invalid. The same numerical types might
be shared, but their meanings are different between the input and output types.
I don't see anywhere that says the number of key value maps MUST
I have added that to the BIP.
??????? Original Message ???????
I haven't considered this, but I'm not sure if it is really useful. I don't think it is really necessary
for any role to know who created the PSBT. If it did, this information would generally come
out-of-band anyways as someone has to give the PSBT to that person.

@_date: 2018-06-20 20:39:05
@_author: Achow101 
@_subject: [bitcoin-dev] BIP 174 thoughts 
While I agree that the BIP itself should be revised to reflect these suggestions, I fear that it may be too late. I know of a few other developers who have implemented BIP 174 already but have not yet responded to this email.
While this is a good idea, I'm not sure that implementers would understand this as it requires knowing the cryptography which makes this possible. As an optional feature, not all wallets would understand it, and those that do could create PSBTs which other wallets do not understand and thus cannot sign even if they have the private keys and actually can sign.
Agreed. Are there any encodings that do not have double click breaking characters?
This ignores all of the other times that a BIP32 keypath needs to be provided. It is not only used for multisig, there may be other times that there are multiple derivation paths and master keys due to multiple inputs and such. Adding a field specific to multisig and HWW only seems pointless and redundant to me.
I think it is unlikely that there would be anymore per-output data.
I disagree. It is up to the signer to decide what they wish to sign, not for the creator to specify what to sign. The creator can ask the signer to sign something in a particular way, but it is ultimately up to the signer to decide.
The idea behind skipping unknown types is to allow forward compatibility. A combiner written now should be able to combine transactions created in the future with new types as combining is really only just merging the maps together.
Size is not really a constraint, but we do not want to be unnecessarily large. The PSBT still has to be transmitted to other people. It will likely be used by copy and pasting the string into a text box. Copying and pasting very long strings of text can be annoying and cumbersome. So the goal is to keep the format still relatively clear while avoiding the duplication of data.

@_date: 2018-06-22 18:28:33
@_author: Achow101 
@_subject: [bitcoin-dev] BIP 174 thoughts 
Hi all,
After reading the comments here about BIP 174, I would like to propose the following changes:
- Moving redeemScripts, witnessScripts, and BIP 32 derivation paths to per-input and per-output data
I think that by moving these three fields into input and output specific maps, the format will be
easier to read and simpler for signers to parse. Instead of having to be able to parse entire
scripts and extract pubkeys, the signer can simply look at which pubkeys are provided in the inputs
and sign the input based upon the presence of a pubkey for which the signer has a privkey.
A neat trick that fits well with this model is that a plain pubkey (one that is not part of a BIP 32
derivation) can still be put in a BIP 32 derivation path field where the value is just the fingerprint
of the pubkey itself. This would indicate that no derivation needs to be done from the master key, and
the master key is just the specified key itself.
Additionally, by having the redeemScript and witnessScript readily available in the input, signers
do not need to construct a map to find a redeemScript or witnessScript and can instead just look
directly in the input data. There is also no need to include the hashes of these scripts, so the key
is just the type. This also allows us to enforce the requirement for only one redeemScript and one
witnessScript per input easily by continuing to follow the generic rule of unique keys.
By using input specific and output specific fields, there is no need for the input index and the input
count types as all inputs will be accounted for.
- Finalized scriptSig and scriptWitness fields
To determine whether two PSBTs are the same, we can compare the unsigned transaction. To ensure that the
unsigned transactions are the same for two PSBTs with data for the same tx, we cannot put scriptSigs or
scriptWitnesses into it. Thus for each input, two new fields have been added to store the finalized scriptSig
and finalized scriptWitness.
- Mandatory sighash
The sighash type field will be changed from a recommendation to a requirement. Signatures will need to use the specified sighash type for that input. If a Signer cannot sign for a particular sighash type, it
must not add a partial signature.
- Encoding
I have decided that PSBTs should either be in binary or encoded as a Base64 string. For the latter, several
Bitcoin clients already support Base64 encoding of data (for signed messages) so this will not add any extra
dependencies like Z85 would.
A draft of the revised BIP can be found here: If these changes are satisfactory, I will open a PR to the BIPs repo to update the BIP tomorrow. I will also
create test vectors and update the implementation PR'ed to Core.

@_date: 2018-06-23 16:33:11
@_author: Andrew Chow 
@_subject: [bitcoin-dev] BIP 174 thoughts 
I don't think that is necessary.
The magic is still necessary for the binary format in order to prevent
normal transaction deserializers from accidentally deserializing a psbt.
While that would be ideal, I think it is better to use an encoding that
most wallets already support. Most wallets already have Base64 decoding
available so that they can decode signed messages which also use Base64
encoding. I think it is unnecessary to introduce another encoding.
I think what will end up happening though is that, at least in the
beginning, PSBTs will primarily be strings that people end up copy and
pasting. Since a PSBT can get pretty large, the strings are rather
cumbersome to move around, especially as hex. At least with Base64 the
strings will be smaller.
Agreed. I will include those in the BIP.
I will try my best to fix that. Mediawiki sucks...

@_date: 2018-06-24 04:28:26
@_author: Andrew Chow 
@_subject: [bitcoin-dev] BIP 174 thoughts 
I disagree with the idea that global types can be removed. Firstly, it
is less of a breaking change to leave it there than to remove it
entirely. Secondly, there may be a point in the future where global
types would be useful/necessary. By having it still be there, we allow
for future extensibility.

@_date: 2018-06-25 16:30:28
@_author: Achow101 
@_subject: [bitcoin-dev] BIP 174 thoughts 
So there are a few reasons for not using typed records. Firstly, it is less of a breaking change to retain the key-value map model.
Secondly, it is easier to enforce uniqueness for certain things. For example, in each input, we only want to have one redeemScript and one witnessScript. With a typed records set, we would have to say that only on record of each type is allowed, which means that combiners need to understand types and be able to partially parse the records. However with a key-value model, we can more generically say that every key-value pair must have a unique key which means that combiners do not need to know anything about types and just needs to enforce key uniqueness. Since the type is the only thing in the key for redeemScripts and witnessScripts, this uniqueness automatically applies to this, as well as for other key-value pairs.
Lastly, the typed records model does not save a lot of space in a transaction. Each record has at most one extra byte in the key-value model, with records that must also have keys having no space savings. The data inside each key-value pair far exceeds one byte, so on additional byte per key-value pair isn't all that big of a deal, IMO.

@_date: 2018-06-26 17:56:26
@_author: Achow101 
@_subject: [bitcoin-dev] BIP 174 thoughts 
I updated all of the tests yesterday so they should be correct now. I will be adding more tests
this week.
Oops, that's actually supposed to be master key fingerprint, not master public key. I have updated
the BIP to reflect this.
There is a diagram in the BIP that explains this. The combiner's job is to combine two PSBTs that
are for the same transaction but contain different data such as signatures. It is easier to implement
a combiner that does not need to understand the types at all, and such combiners are forwards compatible,
so new types do not require new combiner implementations.
A transaction that contains duplicate keys would be completely invalid. Furthermore, in the set of typed
records model, having more than one redeemScript and witnessScript should be invalid, so a combiner
would still need to understand what types are in order to avoid this situation. Otherwise it would produce
an invalid PSBT.
I also dislike the idea of having type specific things like "only one redeemScript" where a more generic
thing would work.
I think it is still necessary to include the pubkey as not all signers who can sign for a given pubkey may
know the derivation path. For example, if a privkey is imported into a wallet, that wallet does not necessarily
know the master key fingerprint for the privkey nor would it necessarily have the master key itself in
order to derive the privkey. But it still has the privkey and can still sign for it.
The point is to not make it difficult for existing implementations to change. Mostly what has been done now is just
moving things around, not an entire format change itself. Changing to a set of typed records model require more
changes and is a complete restructuring of the format, not just moving things around.
Additionally, I think that the current model is fairly easy to hand parse. I don't think a record set model would make
it easier to follow. Furthermore, moving to Protobuf would make it harder to hand parse as varints are slightly more
confusing in protobuf than with Compact size uints. And with the key-value model, you don't need to know the types
to know whether something is valid. You don't need to interpret any data.

@_date: 2018-06-27 13:55:59
@_author: Achow101 
@_subject: [bitcoin-dev] BIP 174 thoughts 
No, that is incorrect. That whole paragraph is actually outdated, it was intended
for the possibility of adding output maps, which we have already done. I have removed it from the BIP.
However, it is possible for a PSBT to contain very large unknown key-value pairs which could potentially cause a problem. But I do not think that large PSBTs should really be a problem as they are really something that the user has to enter rather than something received remotely without user interaction.
Parsers actually do know because that information is present in the unsigned transaction at the beginning of each PSBT. Since each input and output must be accounted for,
a parser can just parse the unsigned transaction and from there it can know how
many inputs and outputs to expect. If it sees more or less, it should throw an error
as the transaction is invalid.
Of course this implies that implementations will need to parse the unsigned transaction,
but not all actually need to. Combiners do not need to, they just need to merge the
maps together and follow the key uniqueness rule. They don't really need to know
or care about the number of inputs and outputs, just that the PSBTs being merged
share the same unsigned transaction and have the same number of maps.
Other roles need to understand the unsigned transaction anyways, so they still need
to parse it thus this isn't really a problem for those roles.
I don't think such a limitation is practical or useful. A transaction can currently have, at most,
~24000 inputs and ~111000 outputs (+/- a few hundred) which is well beyond any useful limit.
Additionally, such limits may not be as extensible for future work. It is hard to determine what
is a reasonable limit on transaction size, and I don't think it is useful to have a limit. At worst
we would simply create an invalid transaction if it were too large.

@_date: 2018-06-29 15:12:27
@_author: Achow101 
@_subject: [bitcoin-dev] BIP 174 thoughts 
I do not think that protobuf is the way to go for this. Not only is it another dependency
which many wallets do not want to add (e.g. Armory has not added BIP 70 support because
of its dependency on protobuf), but it is a more drastic change than the currently proposed
changes. The point of this email thread isn't to rewrite and design a new BIP (which is effectively
what is currently going on). The point is to modify and improve the current one. In particular,
we do not want such drastic changes that people who have already implemented the current
BIP would have to effectively rewrite everything from scratch again.
I believe that this discussion has become bikeshedding and is really no longer constructive. Neither
of us are going to convince the other to use or not use protobuf. ASeeing how no one else
has really participated in this discussion about protobuf and key uniqueness, I do not think
that these suggested changes are really necessary nor useful to others. It boils down to personal preference
rather than technical merit. As such, I have opened a PR to the BIPs repo (
which contains the changes that I proposed in an earlier email.
Additionally, because there have been no objections to the currently proposed changes, I propose
to move the BIP from Draft to Proposed status.
??????? Original Message ???????

@_date: 2018-03-09 10:33:32
@_author: Andrew Chow 
@_subject: [bitcoin-dev] version.relay behavior change 
Looking through the code, I don't think that this behavior has changed.
Are you sure that you are actually connected to Satoshi:0.15.0 nodes and
not a node that has simply set their user-agent to that (i.e. not a real
Satoshi:0.15.0 node)?
If what you are seeing is true, it is likely a bug and not an
intentional change. In that case, can you provide specific details on
how to reproduce?

@_date: 2018-03-15 11:44:43
@_author: Andrew Chow 
@_subject: [bitcoin-dev] version.relay behavior change 
I don't think the nodes that you are connecting to that have this
behavior are actually forked from Bitcoin Core. It seems more like fake
nodes - nodes that don't actually do any verification or follow the
protocol. Such fake nodes can set whatever user agent they want, common
ones being Bitcoin Core's user agents.
IMO your best solution would be to drop peers for protocol noncompliance.

@_date: 2018-09-22 04:56:13
@_author: Andrew Chow 
@_subject: [bitcoin-dev] [bitcoin-core-dev] Bitcoin Core update notice 
The backported versions have not been released yet. They are still going
through the gitian build process. 0.16.3 was the first one to be
released so that is the one that everyone is being recommended to
upgrade to. Regardless, you should upgrade to a patched version, whether
that is 0.14.3, 0.15.2, or 0.16.3. It is not misinformation that
everybody must upgrade.

@_date: 2019-04-19 14:30:03
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Using the same public keys, 
Hi Michele,
You are seeing this discrepancy due to the address types in use. addmultisigaddress uses the default address type of the wallet, which is p2sh-segwit. createmultisig uses a default address type of legacy. To have createmultisig get addmultisigaddress's result, you need to add the string "p2sh-segwit" to the end of your command. To have addmultisigaddress get createmultisig's result, you need to add the string "legacy" to the end of your command.

@_date: 2019-04-23 15:23:27
@_author: Achow101 
@_subject: [bitcoin-dev] Improving Pre and Post Merging Abilities With 
Feel free to re-implement Bitcoin Core in Python. It's open source software and you can do whatever you want.
However Bitcoin Core is not going move to Python and rewrite everything in Python. Besides the fact that Python is far less efficient than C/C++, rewriting Bitcoin Core in any other language would be a huge undertaking and introduce many bugs for almost no benefit whatsoever. Bitcoin Core won't be changing languages for the entire codebase, but you are welcome to port it to Python yourself.
??????? Original Message ???????

@_date: 2019-08-01 17:57:26
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future 
It seems like the consensus is that we should use Compact Size Unsigned
Integers for the field types, so we will do that. The types will be
minimally encoded CSUints.
For the proprietary types, I will use Dimitry's and Andrew Poelstra's
suggestion. There will be one proprietary type, 0xFC. This will be
followed by a variable length string that is a vendor specific prefix
that serves as a unique identifier to help with preventing usage of
proprietary types outside of private contexts. This will then be
followed by the actual type for the data, as defined by the user of the
proprietary type.
The prefix will just be a string, prefixed with a compact size unsigned
integer. If no prefix is wanted, then a single 0x00 byte can be used.
For public software, there is no need to handle these proprietary types
at all so they do not need to check the string or the data type. It is
not necessary to enforce the above rules about proprietary types except
that they use the proprietary type value.
Andrew Chow

@_date: 2019-08-01 19:01:06
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future 
I spoke to some people OOB and they said that they didn't really like
the idea of having a prefix string (partially because they've already
implemented some proprietary types by simply squatting on unused types).
Matching the prefix string adds additional complexity to the parser
code. The main concern is that people won't want to actually follow the
spec for proprietary types and instead just use some unused type value.
So I think instead we should do:
and the prefix string can be optional (and strongly recommended) after that.
Since public parsers won't really be enforcing the rules for proprietary
types, I don't think it really makes sense to specify and enforce how
they should be. After all, the key is really just an opaque data blob.
In the same vein, it would probably be useful to allow multiple types
for proprietary use as originally proposed to make implementation of
these easier. If more type are needed, then the private type
construction can be used.

@_date: 2019-12-26 05:18:00
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Base64-encoded descriptors 
Hi All,
Just a few comments about choosing an encoding and why this is even
being proposed.
On Wednesday, December 25, 2019 12:17 PM, William Casarin via
The main reasons this was proposed in the first place is because of
concerns that users will be unwilling to use or be confused by descriptors.
There is a concern that users will not understand the commas,
parentheses, brackets, etc. syntax of descriptors and thus only copy
part of it.
There is also the concern that users will see this code-like syntax and
be intimidated by it so they will not want to handle them.
So my (offhanded) suggestion was to encode it in some way to just make
it look like some magic string that they need to handle as one unit.
On Tuesday, December 24, 2019 2:09 PM, Spencer Dupre` via bitcoin-dev
a new encoding? Perhaps bech32 could be used instead.
On Tuesday, December 24, 2019 2:25 PM, Pavol Rusnak via bitcoin-dev
not URL/QR code friendly.
A different encoding scheme could certainly be used. Base64 was
suggested in my comments to Chris and others as it is a well known
encoding scheme that doesn't already define its own checksum as Base58
and Bech32 do. This is an important detail because descriptors *also*
have their own checksum scheme.
While other encoding methods could be used, I do want to point out that
it would be nice to stick to things that already exist. We could use a
bech32-like encoding, just with the different BCH code that descriptors
use instead of the bech32 code, but calling that bech32 would be a bit
confusing. And I don't think we should use Base58 at all.
On Tuesday, December 24, 2019 8:02 PM, Trey Del Bonis via bitcoin-dev
Descriptors already have their own BCH code for descriptor checksums
optimized for their length and character rset. This can be repurposed to
be used with whatever encoding scheme is chosen so long as the
encoding's character set is covered by the descriptor checksum character
set. The checksum's character set is fairly large and covers all(?)
characters on a standard keyboard so that descriptors could be expanded
with other features in the future. Thus it should cover any encoding
scheme that is suggested.
More information about the descriptor checksum can be found at

@_date: 2019-07-09 20:26:45
@_author: Andrew Chow 
@_subject: [bitcoin-dev] BIP174 amendment proposal (Important Signer Check 
This was the original intent of the sighash field. Either the sighash is acceptable to the signer and the signer signs with it, or they do not sign at all.

@_date: 2019-07-31 01:13:46
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future 
Hi All,
I would like to propose some types that allow for BIP 174 PSBT to be
extended more in the future.
Firstly, I would like to propose that some types be reserved for
proprietary use. These proprietary use types are, in general, for
private use by individuals and organizations who want to use PSBT in
their processes. These are usefule when there are additional data that
they need attached to a PSBT but such data are not useful (or available)
for the general public.
These types will be guaranteed to not be used by the public
specification and there is no expectation that any publicly available
software be able to understand any specific meanings of these types.
These types should be used for internal processes only.
The types I would like to reserve for proprietary use are the 15 types
from 0xF0 to 0xFE inclusive. These 15 type values will be the same for
global, per-input, and per-output types. If 15 types are not enough,
additional types can be obtained using the multi-byte type method
described later.
Next, I would like to propose a global version type and field. The
version type is 0xEF with only the type as the key, and the value is a
32-bit unsigned little endian integer representing the version number. A
PSBT without a version number is to be considered version 0. If a parser
sees a version number that it does not understand, it should exit
immediately as the PSBT will contain types that are not safe to ignore.
This version number is a safeguard in the event that a backwards
incompatible change is introduce to PSBT. While PSBT is designed and
intended to be forwards compatible by allowing parsers to ignore types
that they do not understand, it is possible that at ype is added in the
future which breaks this assumption and it would be unsafe for a type to
be ignored.
Updaters and combiners that need to add a version number to a PSBT
should use the highest version number required. For example, if a
combiner sees two PSBTs for the same transaction, one with version 0,
and the other with version 1, then it should combine them and produce a
PSBT with version 1. If an updater is updating a PSBT and needs to add a
field that is only available in version 1, then it should set the PSBT
version number to 1 unless a version higher than that is already specified.
It is not expected that the version number will ever be used. We try to
make PSBT fields safe to ignore. The version number is only being
included here as a safeguard in the event that breaking compatibilty is
Lastly, I would like to propose the canonical method for mult-byte
types. We designate a specific type to indicate that the type is
multiple bytes. When such types are observed, parsers should move onto
the next byte and interpret that as the type, keeping in mind the number
of bytes that were read in for the type.
I propose that we use 0xFF as this designated type. When a parser sees
an 0xFF value as the type, it reads the next byte as being part of the
type. So two byte types will be of the form 0xFFXX. This method allows
us to do a prefix match in order to quickly identify the type being
used. For types with more bytes, simply use another 0xFF byte. So three
byte types would be of the form 0xFFFFXX, four byte, 0xFFFFFFXX, and so
on. When multi-byte types are specified in the BIP, they should be
specified in this full length form, i.e. two byte types as 0xFFXX.
The same mechanism can be used for the proprietary use types, just with
a different value as the designated multi-byte indicator. For example,
one could use 0xFE as the designated type as that is in the proprietary
types range. Of course any type within the proprietary type range could
be used as the indicator, it is up to the users to determine this
While other methods of indicating multiple bytes and lengths may be more
space efficient and allow us to have more types represented in a smaller
space, I am choosing this method because of its simplicity. This is easy
to understand and implement. Furthermore, I do not expect that we will
use so many types. I don't think that we will need to have more than one
byte types for a very long time.
Please let me know your thoughts on these extensions. I will open a PR
to the bips repo to add these to BIP 174 if there are no objections.
Andrew Chow

@_date: 2019-07-31 19:16:36
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future 
I don't think that should something that is required for people to do,
but perhaps it can be something that is strongly recommended and
suggested in the BIP itself.
There are a few issues with using a compact size uint. The main issue is
that it doesn't translate well to the proprietary use types. If we used
CSUint for the type, then all of type values for proprietary use need to
be reserved instead of allowing them to be infinitely expanded from the
initial set of proprietary use types.
There is also the fact that CSUints are malleable as the same value can
be represented in many different ways, just with different amounts of
leading zeroes. But I suppose that isn't really that big of an issue.
I am not opposed to using a CSUint, I just felt that it made things a
bit harder and was unnecessary.

@_date: 2019-03-07 15:34:26
@_author: Andrew Chow 
@_subject: [bitcoin-dev] BIP174 / PSBT extensions 
Hi Andrew,
I think having some of these extensions would be great.
I feel like this breaks the central idea of PSBT that a PSBT contains everything you need to construct a transaction.
This would rely on parties in the transaction having state and remembering things which I don't think is something
that we can assume.
For what purpose?
The rest of the proposed extensions I think are fine.
Andrew Chow

@_date: 2019-05-01 16:57:38
@_author: Andrew Chow 
@_subject: [bitcoin-dev] Adding xpub field to PSBT to make multisig more 
Hi Stepan,
I think that this would be a good extension.
Just for clairty, by xpub, do you mean the extended serialization format defined in BIP 32 or the Base58 check encoded string of that serialization?

@_date: 2019-11-16 04:54:49
@_author: Andrew Chow 
@_subject: [bitcoin-dev] PSBT_GLOBAL_XPUB: Version bytes in xpub 
The rationale was that xpubs was already a predefined standard which many software already have serialization code for. It's simpler to just reuse what has been defined before.
IMO, the version bytes don't matter and should be ignored. In the proposed implementation to Bitcoin Core, the version bytes are ignored.

@_date: 2020-12-09 22:25:37
@_author: Andrew Chow 
@_subject: [bitcoin-dev] New PSBT version proposal 
Hi All,
I would like to propose a new PSBT version that addresses a few deficiencies in the current PSBT v0. As this will be backwards incompatible, a new PSBT version will be used, v1.
The primary change is to truly have all input and output data for each in their respective maps. Instead of having to parse an unsigned transaction and lookup some data from there, and other data from the correct map, all of the data for an input will be contained in its map. Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version. Thus I propose that the following fields be added:
* PSBT_GLOBAL_TX_VERSION = 0x02
 ? * Key: empty
 ? * Value: 32-bit little endian unsigned integer for the transaction version number. Must be provided in PSBT v1 and omitted in v0.
* PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
 ? * Key: empty
 ? * Value: 32 bit little endian unsigned integer for the preferred transaction lock time. Must be omitted in PSBT v0. May be provided in PSBT v1, assumed to be 0 if not provided.
* PSBT_GLOBAL_INPUT_COUNT = 0x04
 ? * Key: empty
 ? * Value: Compact size unsigned integer. Number of inputs in this PSBT. Must be provided in PSBT v1 and omitted in v0.
* PSBT_GLOBAL_OUTPUT_COUNT = 0x05
 ? * Key: empty
 ? * Value: Compact size unsigned integer. Number of outputs in this PSBT. Must be provided in PSBT v1 and omitted in v0.
* PSBT_IN_PREVIOUS_TXID = 0x0e
 ? * Key: empty
 ? * Value: 32 byte txid of the previous transaction whose output at PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and omitted in v0.
* PSBT_IN_OUTPUT_INDEX = 0x0f
 ? * Key: empty
 ? * Value: 32 bit little endian integer for the index of the output being spent. Must be provided in PSBT v1 and omitted in v0.
* PSBT_IN_SEQUENCE = 0x0f
 ? * Key: empty
 ? * Value: 32 bit unsigned little endian integer for the sequence number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed to be max sequence (0xffffffff) if not provided.
* PSBT_IN_REQUIRED_LOCKTIME = 0x10
 ? * Key: empty
 ? * Value: 32 bit unsigned little endian integer for the lock time that this input requires. Must be omitted in PSBT v0. May be provided in PSBT v1, assumed to be 0 if not provided.
* PSBT_OUT_VALUE = 0x03
 ? * Key: empty
 ? * Value: 64-bit unsigned little endian integer for the output's amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
* PSBT_OUT_OUTPUT_SCRIPT = 0x04
 ? * Key: empty
 ? * Value: The script for this output. Otherwise known as the scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
This change allows for PSBT to be used in the construction of transactions. With these new fields, inputs and outputs can be added as needed. One caveat is that there is no longer a unique transaction identifier so more care must be taken when combining PSBTs. Additionally, adding new inputs and outputs must be done such that signatures are not invalidated. This may be harder to specify.
An important thing to note in this proposal are the fields PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin transaction only has a single locktime yet a PSBT may have multiple locktimes. To choose the locktime for the transaction, finalizers must choose the maximum of all of the *_LOCKTIME fields. PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to be set. This field allows finalizers to choose a locktime that is high enough for all inputs without needing to understand the scripts involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if no inputs require a particular locktime.
As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1 needs the version number bump to enforce backwards incompatibility. However once the inputs and outputs of a PSBT are decided, a PSBT could be "downgraded" back to v0 by creating the unsigned transaction from the above fields, and then dropping these new fields.
If the list finds that these changes are reasonable, I will write a PR to modify BIP 174 to incorporate them.
Andrew Chow

@_date: 2020-12-22 20:12:22
@_author: Andrew Chow 
@_subject: [bitcoin-dev] New PSBT version proposal 
Hi All,
I have some updates on this after speaking with some people off-list.
Firstly, the version number will be set to 2. In most discussions, this proposal was being referred to as PSBT version 2, so it'll be easier and clearer to set the version number to 2.
For lock times, instead of a single? PSBT_IN_REQUIRED_LOCKTIME field, there will be 2 of them, one for a time based lock time, and the other for height based. These will be:
* PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10
 ? * Key: empty
 ? * Value: 32 bit unsigned little endian integer greater than or equal to 500000000 representing the minimum Unix timestamp that this input requires to be set as the transaction's lock time. Must be omitted in PSBTv0, and may be omitted in PSBTv2
* PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11
 ? * Key: empty
 ? * Value: 32 bit unsigned little endian integer less than 500000000 representing the minimum block height that this input requires to be set as the transaction's lock time. Must be omitted in PSBTv0, and may be omitted in PSBTv2.
Having two lock time fields is necessary due to the behavior where all inputs must use the same type of lock time (height or time). Thus if an input requires a particular type of lock time, it must set the requisite field. Any new inputs being added must be able to accommodate all existing inputs' lock time type. This means they either must not have a lock time specified (i.e. no OP_CLTV involved), or have branches that allow the acceptance of either type. If an input has a lock time type that is incompatible with the rest of the transaction, it must not be added.
PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback option if no input lock time fields are present. If there are input lock times, all lock time calculations must ignore it.
Any role which does lock time calculation will first check if there are input lock time fields. If there are not, it must then check for a PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the transaction's lock time. If it does not, the lock time is 0. If there are input lock time fields, it must choose the type which does not invalidate any inputs. The lock time is then determined to be the maximum value of all of the lock time fields for the chosen type.
Additionally, I would like to add a new global field:
* PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
 ? * Key: empty
 ? * Value: A single byte as a boolean. 0 for False, 1 for True. All other values ore prohibited. Must be omitted for PSBTv0, may be omitted in PSBTv2.
PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and outputs can be added to the PSBT. This flag may be set to True when inputs and outputs are being updated, signed, and finalized. However care must be taken when there are existing signatures. If this field is omitted or set to False, no further inputs and outputs may be added to the PSBT.
Several rules must be followed to ensure that adding additional inputs and outputs will not invalidate existing signatures. First, an input or output adder must check for any existing signatures in all of the other inputs. If there are none, the input or output may be added in any position. If there are one or more signatures, each signature's sighash type must be examined. Inputs may only be added if all existing signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all existing signatures use SIGHASH_NONE. If an input has a signature using SIGHASH_SINGLE, the same number of inputs and outputs must be added before that input and it's corresponding output. For all other sighash types (i.e. SIGHASH_ALL and any future sighash types), no inputs or outputs may be added to the PSBT. Specific exceptions can be made in the future for additional sighash types.
Furthermore, these newly added inputs must follow additional lock time rules. Because all signatures, regardless of sighash type, sign the transaction lock time, newly added inputs when there are existing signatures must have the same type of lock time used in the transaction, and must be less than or equal to the transaction lock time. It must not cause the transaction lock time to change, otherwise the signatures will be invalidated.
Lastly, to uniquely identify transactions for combiners, a txid can be computed from the information present in the PSBT. Internally, combiners can create an unsigned transaction given the transaction version, the input prevouts, the outputs, and the computed locktime. This can then be used to calculate a txid and thus used as a way to identify PSBTs. Combiners will need to do this for all version 2 PSBTs in order to avoid combining distinct transactions.
Andrew Chow

@_date: 2020-12-23 21:30:04
@_author: Andrew Chow 
@_subject: [bitcoin-dev] New PSBT version proposal 
No, it is not just "improvements in the way data is structured."
The primary reason for these changes is to allow PSBT to properly support adding inputs and outputs. This is a feature that many people have requested, and the ways that people have been doing it are honestly just hacks and not really the right way to be doing that. These changes allow for that feature to be supported well.
Furthermore, it is possible to downgrade and upgrade PSBTs between the two versions, once all inputs and outputs have been decided. Since PSBTv2 is essentially just taking all of the normal transaction fields and grouping them all with the rest of the data for those inputs and outputs, it is easy to reconstruct a global unsigned transaction and turn a PSBTv2 into a PSBTv0. It is likewise just as easy to go the other way and break apart the global unsigned tx to turn a PSBTv0 into a PSBTv2. Originally, I had considered requiring that once a transaction was fully constructed it must be downgraded to a PSBTv0, but the structure changes that were made do make it easier to work with PSBT so I decided not to add this requirement.
Perhaps to maintain compatibility PSBT_GLOBAL_UNSIGNED_TX shouldn't be disallowed in PSBTv2 once the transaction is constructed? It would make things much more confusing though as it would no longer be a clean break.
Andrew Chow

@_date: 2020-12-23 21:32:33
@_author: Andrew Chow 
@_subject: [bitcoin-dev] New PSBT version proposal 
Hi All,
The full modified BIP can be read at I will open a PR to the BIPs repo soon after further discussion on this.

@_date: 2020-01-13 06:39:28
@_author: Andrew Chow 
@_subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating 
I agree with Dimitry. I don't see the point of having the MiTM
protection within the PSBT structure itself, in addition to the fact
that adding new fields is largely unnecessary. In fact, I'm not quite
sure what kind of attack you are trying to defend against with this
If there is a MiTM who can modify your PSBT, then they can just modify
the result the signed PSBT to drop the auth signatures. Furthermore, any
modifications to scripts or UTXOs would just result in an invalid
signature, so only time is wasted. But you'll just waste time anyways
when you see a failed auth sig.
Additionally, when a signer processes a PSBT, it will either accept the
PSBT and add a signature for its inputs, or reject it and do nothing.
Given this behavior (and I assume you aren't going to add auth sigs for
rejected PSBTs because that doesn't make any sense), then you already
have a signature there that covers everything your auth signature would
cover. So just verify those signatures instead; for any inputs with
signatures, everything you need to verify them are already there.
Lastly, IMO, if you want MiTM protection, then you should do your
protection with out of band communication. Just PGP sign the PSBT (or
something similar) and send the signature along separately.

@_date: 2020-01-13 17:05:10
@_author: Andrew Chow 
@_subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating 
Since the PSBT is to be signed by one of the Signers for the PSBT, I
don't see how this is useful. If it is mutated and the signer has bugs,
especially parsing bugs, the Signer also adding its signature won't
help. In your proposal, it is the Signer who adds the signature, so it
will receive a PSBT without auth sigs and thus that could be mutated to
trigger those bugs anyways.
The job of Combiners is fairly limited and is really just related to
parsing the PSBT into some internal object then shuffling those fields
around. In that case, any bugs an attacker would want to exploit have to
be deserialization bugs, in which case, your auth sigs don't help. The
Combiner still has to deserialize the PSBT to get the signature, then it
needs to re-serialize the PSBT to check that signature. An attacker
could insert bad bytes into the PSBT which causes problems during
deserialization, before the Combiner is able to check the signature.
For Finalizers, since its job is to construct the final
scriptSig/scriptWitness, at worst, all it can do is produce an invalid
transaction. Finalizers don't have access to the private keys so there's
no bug possible that can result in a Finalizer producing a transaction
that reveals the private key.
ISTM the same is true of your proposal. You need to deserialize the PSBT
and then figure out which fields were "original" and in what order. If
there is a bug in your deserialization, an attacker can still exploit
that. And if there is a bug in your reconstruction of "original", you'll
have false positives.
My point was that you can achieve your MiTM protection by having the
signature separate from the PSBT. You can still make your ECDSA
signature and send it along with the PSBT, and you can do it with fixed
or exchanged keys, no need for parsing the PSBT itself. It can be part
of the transport protocol, not part of the data that is being transferred.

@_date: 2020-01-13 23:18:34
@_author: Andrew Chow 
@_subject: [bitcoin-dev] PSBT Addition (BIP 174) for authenticating 
But the MiTM on the way to the other roles will still see that signed
PSBT, and if the Signer has produced a signature such that someone can
get the private key, that MiTM will have the private key before the
transaction is broadcast. If this isn't part of your threat model, I
think it should be; I don't think it is reasonable to say that you are
only protecting against MiTM for one specific leg of the entire protocol.
Why the end? This brings up a particular implementation detail I didn't
want to get into since I was opposing the idea conceptually, but I don't
think that 2 new types are necessary. We absolutely do not need nor
should we have any global data (and the auth sig is absolutely global
data) in input or output specific fields. The outputs really should be
independent of the other inputs and outputs. So having the last output
have the signature is a layer violation.
Why put it at the end? If you want a byte offset, just put the signature
in the globals as the first kv pair.
But that shouldn't matter to the Finalizer. It isn't the Finalizer's job
to enforce that the Signers followed a specific signing policy. If the
Signer chose to sign with a "dangerous policy", that's up to the signer
and the Finalizers shouldn't have anything to do with that.
That's another thing I don't understand about your proposal. Your
signature covers the "Original PSBT" which is really nebulous and could
anything. This doesn't make sense to me. Everyone has to somehow get the
same "Original PSBT" so you are assuming there's no MiTM in that initial
distribution (seems like an oversight in your threat model).
But then your "Original PSBT" can also be in a number of different
states, and your signature wouldn't cover some things. For example, the
"Original" could have just some of the UTXOs and some of the scripts,
not everything. So in later steps of the process, the MiTM protection
doesn't cover those things, so an attacker could modify them with no
effect on the signature.
You could put them in an archive (tarfile) so it's still just one file
being copied from the SD card. You already have archive creation on the
coldcard for backup creation anyways.
I guess what I don't get about this proposal is your threat model and
what specifically you are protecting against. It seems like this is only
protecting against the specific leg from a specific combined
Updater/Finalizer to and from its respective Signer. But this is not
always the use case and this isn't very generic. Other places that there
could be MiTM aren't covered.
I also don't get what a MiTM could even do. If your parser is vulnerable
to the standard programming vulns (buffer overflows, stack overflows,
etc.), ISTM you will still run into those with just a normal PSBT. If
you don't, then a MiTM can't trigger one there. And likewise for
signature issues; if your signer might produce a private key leaking
signature, then it will probably do that with a non-MiTM'd PSBT, and if
not, MiTM isn't going to change that.
