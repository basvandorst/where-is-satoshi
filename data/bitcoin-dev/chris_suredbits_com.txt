
@_date: 2017-04-14 12:36:34
@_author: Chris Stewart 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
community in disarray.
I really disagree with this sentiment, you don't need to provide
alternatives to criticize a technical proposal. I don't like this "active
segwit at all costs" theme that has been going around the community. I am a
fan of segwit, but we shouldn't push things through in an unsafe manner.
the long term.  The non-SegWit miners will probably just quickly give up
their orphans once they realize that money users like being able to have
non-mutable TX IDs.  If they do create a long lasting branch... well that
is good too, I'd be happy to no longer have them in our community.  Good
luck to them in creating a competitive money, so that we can all enjoy
lower transaction fees.
This seems like a lot of reckless hand waving to me.
Food for thought, why are we rejecting *all* blocks that do not signal
segwit? Can't we just reject blocks that *do not* signal segwit, but *do*
contain segwit transactions? It seems silly to me that if a miner mines a
block with all pre segwit txs to reject that block. Am I missing something
On Fri, Apr 14, 2017 at 11:50 AM, praxeology_guy via bitcoin-dev <

@_date: 2017-04-14 22:05:25
@_author: Chris Stewart 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
not activate by November then core was going to move on, is that no longer
the case, does the core team plan on trying to activate Segwit in some
other way?
Since block size seems to be the controversial issue, AFAIK we *could*
remove the block size increase (by removing the discount on signature
data). This discount was put in place for two reasons
1.) It allows for a block size increase
2.) It makes it more expensive to create UTXOs. UTXO bloat is a problem on
the bitcoin network and segwit was an elegant way to make the network
appreciate their real cost in terms of hardware/RAM.
We would still get the benefits of:
1.) Tx malleability elimination
2.) Script versioning
On Fri, Apr 14, 2017 at 9:01 PM, Steven Pine via bitcoin-dev <

@_date: 2017-12-04 14:11:13
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Two Drivechain BIPs 
vote, no repercussions, and no collective action barrier that needs to be
There is another interesting analysis on BMM and drivechains from /u/almkglor
on reddit
I'm going to share here for visibility.
The problem with drivechains and blind merged mining is the disconnect
TLDR: a miner is most profitable if he always accepts BMM bribes, but
downvotes withdrawal transactions (WT). This obviously isn't ideal because
a withdrawal will never occur from the drivechain if enough miners employ
this strategy -- which seems to be the most profitable strategy.
On Mon, Dec 4, 2017 at 1:36 PM, Chris Pacia via bitcoin-dev <

@_date: 2017-07-04 10:06:06
@_author: Chris Stewart 
@_subject: [bitcoin-dev] BIP: OP_BRIBVERIFY - the op code needed for Blind 
Hi ZmnSCPxj,
In my scheme, if you read carefully through the pseudocode, a block list
It seems this is a contradiction against the "blind" part of blind merge
mining. How can a bitcoin blockchain node enforce this without tracking the
Basically, in my scheme, the OP_RETURN data *is* the sidechain block
It seems both of our schemes need to include 2 32 bit hashes in the
blockchain. Your scheme needs a previous block header hash and the current
block header hash, while mine includes the current block header hash
twice.  We can just commit to all that information via the block header
hash and if a sidechain node lies to us will we are doing IBD the hashes
won't match with what was included in the bitcoin blockchain.
I'll follow your discussion with Paul about sidechain reorgs, but I think
his proposal is more desirable -- it follows what actually happens in the
bitcoin mining process where we *can* have chain splits when miners
simultaneously find a block. Other miners will pick one of the two blocks
to mine on top of and eventually one chain will become longer than the
other. Therefore that chain will have it's block's orphaned and the
miners/nodes following the dead chain will reorg on top of the longest
In Paul's scheme, we replace PoW with a bribe. At the conceptual level
these are somewhat similar. In PoW a miner is willing to pay a certain
amount of money (on electricity) to try to find a bitcoin block. With
OP_BRIBEVERIFY a sidechain miner is willing pay a certain amount of money
to find a block.
In PoW, there is nothing at the software level that says a miner cannot
just decide to build on a old block. I could decide to build on the genesis
block if I wanted to. Obviously this is a stupid idea as I'll never
overtake the bitcoin blockchain with 8 years of PoW behind it -- but it
doesn't mean I couldn't try if I wanted too. Your scheme from what I
understand prevents this from happening -- and I don't think that is
desirable. You might be able to make an argument that a rich attacker can
*stall* mining progress on the drivechain, but I think the same argument
can be made with a rich miner on the bitcoin blockchain as well. I think
miners have threatened to do that if BIP148 caused a chain split.
Can you link to the aforementioned pseudocode? I must have missed it on the
mailing list.

@_date: 2017-07-11 11:03:45
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Updating the Scaling Roadmap 
Concept ACK.
I think you are overstating the readiness of drivechains though. I think
the optimistic estimate for drivechains to be ready for bitcoin core is a
year out from today. More likely the date should be early 2018. Still a lot
of work to be done! :-)
Also I don't know if I would put a hard fork suggestion in the scaling map.
If drivechains are successful they should be viewed as the way we scale --
not hard forking the protocol. Do you still have capacity concerns if
drivechains are successful?
On Mon, Jul 10, 2017 at 11:50 AM, Paul Sztorc via bitcoin-dev <

@_date: 2017-07-12 13:02:30
@_author: Chris Stewart 
@_subject: [bitcoin-dev] BIP: OP_BRIBVERIFY - the op code needed for Blind 
Hi Russell/ZmnSCPxj,
I think you guys are right. The only problem I can see with it is
replaceability of the bribe transaction. If the 'Bribe' is the fee on the
transaction it isn't clear to me what the best way to replace/remove it is.
If we have the amount in the output (instead of the fee) we can construct a
contract like this
OP_IF   OP_BV OP_ELSE OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG OP_ENDIF
That way, if the miner does *not* include your bribe, he is *still*
incentived to include your redemption.
If we decide to only an OP_RETURN output, we can replace the 'bribe'
transaction with a transaction that double spends the prevout. Thus if your
'bribe' transaction is not included in a block, a miner can still include
your double spend transaction to refund yourself (and a miner gets to
collect his normal mining fee).
I'm not 100% sure if there are mempool policies that would reject this
double spend tx or not -- but I guess this is an implementation detail not
a high level design one.
Also if there is not a commitment in the coinbase transaction it may be
harder to search for drivechain commitments. I've been floating around the
idea of a 'drivechain commitment tx' so we could easily see where all of
the voting is happening for withdrawal transactions -- but that is very
much up in the air.
On Wed, Jul 12, 2017 at 1:00 PM, Chris Stewart

@_date: 2017-07-12 14:19:03
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Updating the Scaling Roadmap 
Hi Greg,
bitcoins, something they cannot do currently.
If I put my coins in an anyone can spend output, a miner will take them.
They can do this today. I suggest you try it if you don't believe me :-).
You have to be more specific with contract types instead of generically
talking about 'all contracts ever'.
guarantees. This you have not denied.
I think this is an unfair characterization. You have to opt into using
drivechains. Other outputs such as P2PKH/Multisig etc are unaffected by a
drivechain output. As Pieter Wuille stated earlier in this thread (and Paul
has stated all along), drivechain outputs have a different security model
than other contracts. Namely they are controlled by miners. I think we can
all agree this is unfortunate, but it is the current reality we live in. I
look forward to the day we can solve the 'ownership' problem so we can have
trustless interoperable blockchains, but that day is not today.
As a reminder, most users will not have to go through the drivechain
withdrawal process. Most withdrawals will be done via atomic swaps.
fashion. Better options are being worked on, they just take time.
Care to share? I'm unaware if there is.
Everyone should re-read this email though, this is something that could
happen. Paul's design makes it so that if this occurs it is *VERY* obvious.
I guess we can argue if there is any difference between an obvious robbery
vs a hidden robbery, but I think if we have to pick one or the other the
choice is clear to me. Other designs (that I'm aware of) for sidechains had
attack vectors that weren't so obvious.
On Tue, Jul 11, 2017 at 6:12 PM, Tao Effect via bitcoin-dev <

@_date: 2017-07-12 14:34:54
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Updating the Scaling Roadmap 
Hi Greg,
The safest way to ensure everyone's protection to make sure *no one can do
anything*. Then we will ALL be safe ;).
Ok, let's calm down.
give out if pressed, is that a good idea? Can I justify pushing for such a
"feature" just because it's "opt-in"?
It would be more like "should we allow a car on the road if we know
statistically that our brakes give out in every 1/100,000,000 cars"? There
is security risks with everything in life -- we need to quantify the risk
to see if it is worth taking. I think Paul has been pretty upfront about
the risks of his model. I think you did a good job of demonstrating it in
the email I cited too.
By your account bitcoin is already insecure then -- it allows anyone can
spend outputs that can be claimed by miners.
I look forward to this!

@_date: 2017-07-13 15:22:02
@_author: Chris Stewart 
@_subject: [bitcoin-dev] BIP: OP_BRIBVERIFY - the op code needed for Blind 
I'm interested in hearing a reply from Russell/ZmnSCPxj in what they think
about lightning bribes. I hadn't given much thought about those while
writing my original BIP, but it does seem like my original BIP (minus the
fixed indexes in the coinbase output) fits this pretty well. If I
understand Paul correctly the OP_BV output will never hit the blockchain
then -- only the commitment in the coinbase transaction. This means no
extra data (if use lightning) has to be added to the blockchain *except*
the drivechain commitment (34 bytes in the coinbase tx vout). If this is
used for the vast majority bribes it may make the op code worth it.
In general though, I'm still unclear of what purpose the 'Ratchet' serves.
Can you either link to documentation about it or write something up quick?

@_date: 2017-06-18 09:36:24
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Drivechain -- Request for Discussion 
I think it is redundant here to have the , we can implicitly
assume what the sidechain_id is since we have a fixed set of drivechains.
I.e. mining reward is index 0, mimblewimble sidechain is index 1, etc.
CryptAxe has specific indexes defined already in his implementation:
I think it would be wise to include a version byte to allow us to upgrade
this commitment structure in the future. Similar to how witness program's
are now versioned.
If  is an argument that OP_BRIBE_VERIFY takes, doesn't that
mean the mainchain miner has to validate this *is* the actual block height
on the sidechain? Does that take the 'blindness' away from BMM?
Overall, I think we need to work on the commitment structure to the
coinbase tx. If I understand the current implementation correctly we can
have up to 256 OP_RETURNs embedded in the coinbase tx signifying new blocks
mined on drivechains.. this seems less than ideal. It might be prudent to
make these outputs ANYONECANSPEND, and then have miners spending these
outputs to themselves for every block mined.. maybe this doesn't have a
benefit over using OP_RETURNs though?
The structure could be something like:
and then in a subsequent block the miner spends that output to themselves.
I will admit I'm not super familiar with how OP_RETURNs work with the UTXO
set -- maybe this scheme doesn't have any benefit.
On Wed, May 24, 2017 at 3:50 AM, Tier Nolan via bitcoin-dev <

@_date: 2017-06-19 10:41:01
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Drivechain -- Request for Discussion 
Since you seem to be talking about the initial block download process for
the drivechain. It seems that we might as well request the set of *valid*
blocks from a bitcoin peer first, since at the end of the day they are in
control of the mining process on the sidechain. Here is what I envision:
   1. Request all hashes for sidechain from a bitcoin peer
   2. Request all sidechain block header's for the hashes the bitcoin peer
   gave us
   3. Order the set of sidechain block headers by looking at hashPrevBlock.
   4. Request full sidechain blocks and start validating against the
   consensus rule set of the sidechain
we can drop the sidechain_id from the script.
I agree the 'sidechain_id' is unneeded in the coinbase tx output. We should
just fix these based on index. This should be reflected in my latest commit
if we are talking about the same thing:
and have the sidechain handle filtering out invalid LD data /
 I agree, the whole point of BMM is to have bitcoin miners indifferent to
what happens in the sidechain (although Paul argues in a wonky way they do
care sort of). If there is an invalid (in the sense the block it represents
does *not* follow the sidechain's consensus rule set) OP_BRIBEVERIFY that
pays *more* money than a valid OP_BRIBEVERIFY output, we need to assume
that a 'blind' bitcoin miner will choose the one that pays them the most
UTXO set. Anyone else want to chime in?
I'm fairly certain you are right. It just feels like we should be able to
exploit the fact that *only* miners can claim these OP_BRIBEVERIFY outputs.
I'll have to think about this more, maybe some one else can come up with
something clever that exploits that fact.

@_date: 2017-06-27 19:37:13
@_author: Chris Stewart 
@_subject: [bitcoin-dev] BIP: OP_BRIBVERIFY - the op code needed for Blind 
BIP:   Layer: Consensus (Soft fork)
  Title: OP_BRIBEVERIFY
  Author: Chris Stewart   Status: Draft
  Type: Standards Track
  Created: 2017-06-27
This BIP describes a new opcode, OP_BRIBEVERIFY, for the Bitcoin
scripting system that allows for a user to bribe a miner to include a hash
in the coinbase transaction's output.
BRIBEVERIFY redefines the existing NOP4 opcode. When executed, if the given
critical hash is included at the given vout index in the coinbase
the script evaluates to true. Otherwise, the script will fail.
This allows sidechains to be merged mined against
bitcoin without burdening bitcoin miners with extra resource requirements.
The current political climate of bitcoin is extremely contentious. Many
community members
have different visions of what bitcoin is. This op code is meant to
enable [ Blind Merge
This enables sidechains in Bitcoin. With OP_BRIBEVERIFY, sidechains miners
bribe bitcoin miners to to include their block hash in the bitcoin
blockchain. If their block
is included in the coinbase transaction's vout, it is assumed that block is
a mined block on the sidechain.
This will allow various factions of the community to realize their vision
on their own separate
blockchain that is interoperable with the bitcoin blockchain. This allows
those factions to use
bitcoin as a 'reserve currency' for their own network.
===Commitment Structure===
A new block rule is added which requires that the miner's coinbase reward
be at index 0 in the coinbase transaction's output vector.
It also fixes the witness commitment output to be at index 1 of the
coinbase transaction's output vector.
This is needed so we can reliably tell what vout corresponds to what
drivechain. For instance, the mimblewimble sidechain
could correspond to index 2 of the vector outputs on the coinbase
The commitment is recorded in a scriptPubKey of the coinbase
transaction. It must be at least 34 bytes in size
   1-byte - OP_RETURN (0x6a)
   1-byte - Push the following 32 bytes (0x20)
  32-byte - block hash
the 35th byte and onward have no consensus meaning.
===OP_BRIBEVERIFY op code===
This op code reads two arguments from the stack. The stack top is expected
to be a sidechain id for which this user attempting to blind merge mine for.
The next element on the stack is expected to be a block hash. This op code
looks into the coinbase transaction's output vector at the given index
(which is derived from the sidechain id) and checks
to see if the hash in the block matches the hash inside of the BRIBEVERIFY
program. If the hashes match, the OP_BRIBEVERIFY acts as an OP_NOP. If the
comparison between the two hashes fail, the script fails.
===BRIBEVERIFY program===
A standard BRIBEVERIFY program has the format:
  1-byte - Push the following 32 bytes (0x20)
 32-byte - block hash
  1 byte - Push operation? (needed if number can't be encoded as OP_0 -
  1 byte - sidechain id
  1 byte - OP_BRIBEVERIFY op code
==Detailed Specification==
Refer to the reference implementation, reproduced below, for the precise
semantics and detailed rationale for those semantics.
 case OP_NOP4:
 {
    //format: block_hash sidechain_id OP_BRIBEVERIFY
    if (!(flags & SCRIPT_VERIFY_BRIBEVERIFY)) {
        // not enabled; treat as a NOP4
        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);
        }
        break;
    }
    if (stack.size() < 2)
        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
    const CScriptNum scriptNumSidechainId(stacktop(-1),fRequireMinimal);
    uint8_t nSidechainId;
    if (!checker.CheckSidechainId(scriptNumSidechainId,nSidechainId)) {
        return set_error(serror, SCRIPT_ERR_UNKNOWN_SIDECHAIN);
    }
    // Check block hash
    bool fHashCritical =
    if (!fHashCritical) {
        return set_error(serror, SCRIPT_ERR_UNSATISFIED_BRIBE);
    }
    break;
 }
Credit to Paul Sztorc for the original idea of Blind Merge Mined sidechains.
Credit to CryptAxe for writing the foundational layer of software for
drivechains so I could implement OP_BRIBEVERIFY.
Blind Merge Mined Sidechains -
Mailing list discussion -
This document is placed in the public domain.

@_date: 2017-06-28 18:47:57
@_author: Chris Stewart 
@_subject: [bitcoin-dev] BIP: OP_BRIBVERIFY - the op code needed for Blind 
Hi Russell,
the documentation about how drivechains are supposed to work scattered and
difficult to follow. So, without advocating for or against this proposal,
I'd also suggest that adding an opcode is not the best way to implement
this bribe.
Despite the flaws in this draft BIP, the goal is to start consolidating
this information into a more compact format. This BIP is *only*
meant to address the Blind Merging Mining Process of drivechains. It does
*not* address the withdrawal process from drivechain -> bitcoin.
transaction to a script that uses the OP_BRIBE code that fixes the critical
hash (and the sidechain id), and then a second transaction is needed to pay
the bribe to the miner.
That is intentional, this allows for a competitive process (like bitcoin
mining) for a block to be 'found' on the sidechain. The OP_BV output that
the bitcoin miner the most amount of money should be the one that is
included in the bitcoin blockchain. If I understand your scheme correctly,
you are
assuming the the bitcoin miner is *also* following the sidechain --
Sztorc's scheme does not make this assumption. The *number one goal* of BMM
is to *minimize* the resource burden on bitcoin miners for mining on a
To gmaxwell/luke-jr,
I agree my commitment scheme is flawed. Thanks for pointing it out. Is
there any way we could manipulate a coinbase transaction
into spending these OP_BV outputs? According to instagibbs, and AFIACT he
is right, we cannot have coinbase transactions
spend any outputs in previous blocks without a hard fork. This is
unfortunate because it might make more sense for the coinbase transaction
to spend these OP_BV outputs. We could design the coinbase transaction's
scriptSig to push the critical hash onto the stack and
place an OP_EQUAL on the OP_BV output to verify they were equal.
If I understand gmaxwell's concern about 'monotone' (or stateless) blocks
correctly, I *think*
this solution might fix that as well.
Another way we could fix this is by *fixing* the drivechain indices.
Therefore the mining rewards and witness commitments must
*not* occupy one of those indices -- but can occupy any other indice in the
coinbase output.
This would give us future flexibility for committing to new soft forks. For
instance, we would say
the mining reward must *not* be index 0 of the coinbase transaction, but
can occupy index 1 - 256. The same would apply for witness commitments.
On Wed, Jun 28, 2017 at 5:49 PM, Russell O'Connor

@_date: 2017-06-30 09:12:30
@_author: Chris Stewart 
@_subject: [bitcoin-dev] BIP: OP_BRIBVERIFY - the op code needed for Blind 
unless the mainchain reorganizes, since the consensus loop only cares about
matching the current block; it ignores splits and does not consider them
Maybe I am misunderstanding you, but isn't this a flaw not a feature? What
if a attacker pays a large fee to have his *invalid* block hash included in
the bitcoin mainchain? Would this block *have* to be included in the
sidechain's blockchain forever since *it was* included in bitcoin
the coinbase and once in the briber's separate transaction?
Yes, my BIP proposal does this.
hash is the indicator of which sidechain it is extending.  From your other
emails on this list, it seems the ratchet is for withdrawals from sidechain
to mainchain?  If so, should it not only appear in only some of the
sidechains (the ones which are currently doing some withdrawal?)?
Maybe I am missing something here, but why we do *explicitly* commit to the
previous block hash? Isn't it implicitly committed to via SHA256(SHA256())?
If a drivechain node tries to sync the drivechain from bitcoin's commitment
headers, it will invalidate that block since
the block hash does not correctly reference the previous block hash. AFAICT
there is no need to explicitly specify the previous block hash in the OP_BV
output. In general, I don't think we should assume these commitment headers
dictate the strict ordering of blocks on the sidechain -- only potential
blocks that
*might* be valid. To guarantee full validity drivechain nodes will have to
download the full block and figure out if they follow all of the consensus
This is sort of like headers first sync in bitcoin core:

@_date: 2017-03-18 10:23:16
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Requirement for pseudonymous BIP submissions 
As everyone in the Bitcoin space knows, there is a massive scaling debate
going on. One side wants to increase the block size via segwit, while the
other side wants to increase via hard fork. I have strong opinions on the
topic but I won?t discuss them here. The point of the matter is we are
seeing the politicization of protocol level changes. The critiques of these
changes are slowly moving towards critiques based on who is submitting the
BIP -- not what it actually contains. This is the worst thing that can
happen in a meritocracy.
*Avoiding politicization of technical changes in the future*
I like what Tom Elvis Judor did when he submitted his MimbleWimble white
paper to the technical community. He submitted it under a pseudonym, over
TOR, onto a public IRC channel. No ego involved ? only an extremely
promising paper. Tom (and Satoshi) both understood that it is only a matter
of time before who they are impedes technical progress of their system.
I propose we move to a pseudonymous BIP system where it is required for the
author submit the BIP under a pseudonym. For instance, the format could be
something like this:
BIP: 1337
Author: 9458b7f9f76131f18823d73770e069d55beb271b at protonmail.com
BIP content down here
The hash ?6f3?9cd0? is just my github username, christewart, concatenated
with some entropy, in this case these bytes:
and then hashed with RIPEMD160. I checked this morning that protonmail can
support RIPEMD160 hashes as email addresses. Unfortunately it appears it
cannot support SHA256 hashes.
There is inconvenience added here. You need to make a new email address,
you need to make a new github account to submit the BIP. I think it is
worth the cost -- but am interested in what others think about this. I
don't think people submitting patches to a BIP should be required to submit
under a pseudonym -- only the primary author. This means only one person
has to create the pseudonym. From a quick look at the BIPs list it looks
like the most BIPs submitted by one person is ~10. This means they would
have had to create 10 pseudonyms over 8 years -- I think this is
*What does this give us?*
This gives us a way to avoid politicization of BIPs. This means a BIP can
be proposed and examined based on it?s technical merits. This levels the
playing field ? making the BIP process even more meritocratic than it
already is.
If you want to claim credit for your BIP after it is accepted, you can
reveal the preimage of the author hash to prove that you were the original
author of the BIP. I would need to reveal my github username and
*The Future*
Politicization of bitcoin is only going to grow in the future. We need to
make sure we maintain principled money instead devolving to a system where
our money is based on a democratic vote ? or the votes of a select few
elites. We need to vet claims by ?authority figures? whether it is Jihan
Wu, Adam Back, Roger Ver, or Greg Maxwell. I assure you they are human ?
and prone to mistakes ? just like the rest of us. This seems like a simple
way to level the playing field.

@_date: 2017-03-18 12:35:30
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Requirement for pseudonymous BIP submissions 
data-driven and logical in my thinking, and have still fallen victim to
thinking "oh great, what's  on
about now?" when seeing something posted or proposed.
I think we need to all recognize we are only humans -- thus susceptible to
our emotions influencing our decisions. The notion of identity is an easy
way to form judgements for/against an idea before thoroughly vetting it.
I also think a by product of this would be to curb reddit/twitter trolls
from talking about these protocol changes. It is a much less juicy story if
you have to say "9458b7f9f76131f18823d73770e069d55beb271b created a BIP to
propose a block size increase" compared to "Satoshi Nakamoto created a BIP
to propose a block size increase".
Note about the OP:
"The hash ?6f3?9cd0? is just my..." should really say "The hash
'9458...271b' is just my.." Forgot to change the hash this morning.

@_date: 2017-09-05 12:06:32
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Sidechain headers on mainchain (unification of 
Hi ZmnSCPxj,
Basically, in case of a sidechain fork, the mainchain considers the longest
What happens in the case that the provided merkle tree hash has a invalid
transaction in it? Wouldn't this mean that the mainchain nodes would think
the longest work chain is the valid chain, and it would kill off any
consensus valid chain that sidechain miners are trying to construct? It
seems that a malicious miner could extend the chain to whatever the SPV
proof block height is and make it impossible for the chain to reorg after
that. I guess if that is a sufficiently long block waiting period it may
not be a realistic concern, but something to think about any way.
Just a side note -- I think it should be highly recommended that the
coinbase maturity period on the sidechain to be longer than 288 (or
whatever we decide on the parameter). This incentivizes the s:miners to
work together to extend the chain by working with other s:miners (otherwise
they won't be able to claim their bribes). If they do not work together
they will not be able to spend their s:coinbase_tx outputs until they
extend their own sidechain by 288 blocks meaning they need to tie up a
large amount of capital to go rogue on their fork.
Another interesting thing might be to use the OP_WITHDRAWPROOFVERIFY op code
used in the elements project. Since the cannonical merkle root hashes are
included in the mainchain, we can provide a merkle proof to the bitcoin
blockchain to initiate a withdrawl from the sidechain. I wrote up a blog
post on how OP_WPV works here
This allows us to prove that a transaction occurred on the sidechain to
lock up those funds.

@_date: 2017-09-08 15:14:30
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Sidechain headers on mainchain (unification of 
Hi ZmnSCPxj,
However, a lockbox on one chain is a WT on the other
I'm not sure if I follow what you are saying here. What do you mean by
'free lockbox'? I was assuming that I created an arbitrary blockchain, say
ChrisChain, that is NOT pegged to the bitcoin blockchain? I.e. the tokens
on ChrisChain are worthless. Then I create a lockbox on ChrisChain with my
worthless tokens and attempt to transfer them into TeeCoin's chain? However
this doesn't make sense with
However, this parameter is used to determine if it is a WT.  Sidechain
because I could arbitrarily set this parameter to 0. It seems that a
sidechain upon inception should pay all of it's tokens to a single UTXO and
prevent minting of coins after that. I'm fairly certain this is what
elements does in it's genesis block.
The is unrelated to the problem above, but it will be a problem in
sidchain-headers-on-mainchain if we have a limited amount of mining slots
in the coinbase_tx output vector.
Let us assume we have a fixed set of sidechain slots in the coinbase output
vector, in this case 10. However there are 15 competing sidechains for
these 10 slots. It may be possible for sidechains (say 15 sidechains) to
compete indefinitely for these 10 slots -- causing indefinite forks. Let us
say sidechain 10 and sidechain 11 alternate block hashes in
coinbase_tx.vout[10] output. This means that a WT^ will never be considered
valid because it will appear to mainchain miners that there are competing
forks of the SAME sidechain, when in reality it is two unique sidechains
competing to mine the the limited coinbase output vector space.

@_date: 2017-09-26 12:51:50
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Sidechains: Mainstake 
block header may be published. In addition, the sidechain block header
published on the mainchain blocks may only be published by the stake
lottery winner from the end of the previous block.
What happens if the stake winner disappears? It seems, in your scheme, that
this would cause progress to come to a screeching halt.
Our weak mitigation against a mainchain miner >50% attack is weakened
Can we not nest mainstake outputs in p2wsh/p2sh scripts to mitigate this?
This means that they cannot block the creation of mainstake utxos -- but I
guess they would still be able to block the spends of this utxo.
Another thing that is problematic with using a p2sh output is 'relocking'
the stake. Unfortunately if the p2sh script hash's aren't identical I don't
think we can guarantee they didn't spend the stake to a non stake output.
If the script hash's *are* identical then the miner can censor the
transaction that re-locks the output.
Perhaps there is a hybrid that would work, however it depends on what you
mean by 'creation'. If it is just the *initial* creation of the utxo -- and
not subsequent OP_STAKEVERIFY change outputs -- I think this strategy might
work. You just won't be able to participate in the lottery while the utxo
is nested inside the p2sh output initially.
This also brings back the problem above -- what if a stake winner
disappears -- or a miners creates the illusion they disappeared via
censorship? I guess a miner would be losing out on transaction fees.
On Fri, Sep 22, 2017 at 8:49 PM, ZmnSCPxj via bitcoin-dev <

@_date: 2018-06-05 19:17:52
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Disallow insecure use of SIGHASH_SINGLE 
Do you have any thoughts on expanding this to SIGHASH_NONE? Perhaps someone
else on the dev list can enlighten me, but is there a current use case for
SIGHASH_NONE that would suffer from it being non standard?
On Thu, May 31, 2018 at 1:53 PM, Johnson Lau via bitcoin-dev <

@_date: 2019-10-01 07:23:47
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Continuing the discussion about noinput / 
I do have some concerns about SIGHASH_NOINPUT, mainly that it does
introduce another footgun into the bitcoin protocol with address reuse.
It's common practice for bitcoin businesses to re-use addresses. Many
exchanges [1] reuse addresses for cold storage with very large sums of
money that is stored in these addreses.
It is my understanding with this part of BIP118
specific output. Any participant can take a transaction and rewrite it by
changing the hash reference to the previous output, without invalidating
the signatures. This allows transactions to be bound to any output that
matches the value committed to in the witness and whose witnessProgram,
combined with the spending transaction's witness returns true.
if an exchange were to once produce a digital signature from that cold
storage address with a SIGHASH_NOINPUT signature, that signature can be
replayed again and again on the blockchain until their wallet is drained.
This might be able to mitigated since the signatures commit to outputs,
which may be small in value for the transaction that SIGHASH_NOINPUT was
used. This means that an exchange could move coins from the address with a
larger transaction that spends money to a new output (and presumably pays a
higher fee than the smaller transactions).
 Why does this matter?
It seems that SIGHASH_NOINPUT will be an extremely useful tool for offchain
protocols like Lightning. This gives us the building blocks for enforcing
specific offchain states to end up onchain [2].
Since this tool is useful, we can presume that it will be integrated into
the signing path of large economic entities in bitcoin -- namely exchanges.
Many exchanges have specific signing procedures for transactions that are
leaving an exchange that is custom software. Now -- presuming wide adoption
of off chain protocols -- they will need to have a _second unique signing
path that uses SIGHASH_NOINPUT_.
It is imperative that this second signing path -- which uses
SIGHASH_NOINPUT -- does NOT get mixed up with the first signing path that
controls an exchanges onchain funds. If this were to happen, fund lost
could occur if the exchange is reusing address, which seems to be common
This is stated here in BIP118:
unintentionally enabling this rebinding mechanism. NOINPUT MUST NOT be
used, unless it is explicitly needed for the application, e.g., it MUST NOT
be a default signing flag in a wallet implementation. Rebinding is only
possible when the outputs the transaction may bind to all use the same
public keys. Any public key that is used in a NOINPUT signature MUST only
be used for outputs that the input may bind to, and they MUST NOT be used
for transactions that the input may not bind to. For example an application
SHOULD generate a new key-pair for the application instance using NOINPUT
signatures and MUST NOT reuse them afterwards.
This means we need to encourage onchain hot wallet signing procedures to be
kept separate from offchain hot wallet signing procedures, which introduces
more complexity for key management (two keychains).
One (of the few) upsides of the current Lightning penalty mechanism is that
fund loss can be contained to balance of the channel. You cannot do
something in the current protocol that will effect your funds outside of
that channel. With SIGHASH_NOINPUT, that property changes.
 A side note
In general, i think we should start disallowing uses of the SIGHASH
protocols that have unexpected behavior. The classic example of this is
SIGHASH_SINGLE [3]. I get uneasy about adding more footguns to the
protocol, which with current network behavior (address re-use)
SIGHASH_NOINPUT would be a big one.
[1] - [2] -
[3] -
On Mon, Sep 30, 2019 at 9:24 AM Christian Decker via bitcoin-dev <

@_date: 2019-10-01 10:14:56
@_author: Chris Stewart 
@_subject: [bitcoin-dev] [Lightning-dev] Continuing the discussion about 
designer', whether lazy or dogmatic, misusing noinput. I think there are
simpler ways to cut corners and there will always be plenty of good wallet
options people can choose.
In my original post, the business that I am talking about don't use "off
the shelf" wallet options. It isn't a "let's switch from wallet A to wallet
B" kind of situation. Usually this involves design from ground up with
security considerations that businesses of scale need to consider (signing
procedures and key handling being the most important!).
and used for off-chain negotiations, very few should ever appear on chain.
Those that do should represent non-cooperative situations that involve
signing parties who know not to reuse or share scripts with these public
keys again. No third party has any reason to spend value to a
multisignature script they don't control, whether or not a no_input
signature exists for it.
Just because some one is your friend today, doesn't mean they aren't
necessarily your adversary tomorrow. I don't think a signature being
onchain really matters, as you have to give it to your counterparty
regardless. How do you know your counterparty won't replay that
SIGHASH_NOINPUT signature later? Offchain protocols shouldn't rely on
"good-will" for their counter parties for security.
enough to justify the downsides of chaperone signatures. One additional
downside is the additional code complexity required to flag whether or not
a chaperone output is included. By comparison, the code changes for
creating a no_input digest that skips the prevout and prevscript parts of a
tx is much less intrusive and easier to maintain.
engineering time. Writing code that uses a new sighash or a custom
script with a OP_CODE is a very large barrier to use. How many wallets
support multisig or RBF? How much BTC has been stolen over the entire
history of Bitcoin because of sighash SIGHASH_NONE or SIGHASH_SINGLE
vs ECDSA nonce reuse
I actually think lazy wallet designer is a really compelling reason to fix
footguns in the bitcoin protocol. Mt Gox is allegedly a product of lazy
wallet design. Now we have non-malleable transactions in the form of segwit
(yay!) that prevent this exploit. We can wish that the Mt Gox wallet
designers were more aware of bitcoin protocol vulnerabilities, but at the
end of the day the best thing to do was offering an alternative that
circumvents the vulnerability all together.
Ethan made a great point about SIGHASH_NONE or SIGHASH_SINGLE -- which have
virtually no use AFAIK -- vs the ECDSA nonce reuse which is used in nearly
every transaction. The feature -- ECDSA in this case -- was managed to be
done wrong by wallet developers causing fund loss. Unfortunately we can't
protect against this type of bug in the protocol.
If things aren't used -- such as SIGHASH_NONE or SIGHASH_SINGLE -- it
doesn't matter if they are secure or insecure. I'm hopefully that offchain
protocols will achieve wide adoption, and I would hate to see money lost
because of this. Even though they aren't used, in my OP I do advocate for
fixing these.
be misused. However, with just taproot and taproot public key types the
anyprevout functionality is already very opt-in and not something that
might accidentally get used. Belt-and-suspender protections like chaperone
signatures and tagged outputs have their own impacts on code complexity,
on-chain transaction sizes and transaction anonymity that also must be
I'm making the assumption that the business has decided to use this
feature, and in my OP I talk about the engineering decisions that will have
to be made support this. I'm hoping the "lazy wallet designers" -- or
perhaps people that don't follow bitcoin protocol development as rabidly as
us :-) -- can see that nuance.

@_date: 2020-01-13 06:27:34
@_author: Chris Stewart 
@_subject: [bitcoin-dev] [Annoucement] Discreet Log Contract Protocol 
Hi all,
Suredbits and Crypto Garage have begun to work on a specification for
using discreet
log contracts  in a safe, private and
interoperable way. We are writing to the mailing list to inform and solicit
feedback for the protocol specification so that we can -- as a community --
agree on a common standard to use Bitcoin oracles.
Our goal is to end up with a set of documents like the BIPs (Bitcoin
Improvement Proposals) and BOLTs (Basis of Lightning Technology) so that
others that wish to use the technology can easily write software to
integrate into the protocol.
A secondary goal of ours is to remain compatible with standards used by
other bitcoin related protocols (like Lightning) so that every future
bitcoin related protocol can reach for a ?toolbox? of agreed standards for
things like funding transactions and closing transactions. We want to avoid
reinventing the wheel where possible and allow for library developers to
re-use software to hook into many bitcoin related protocols.
You can find the specification repository here:
For more information on DLCs:
[1] - [2] - [3] -
[4] -
[5] -

@_date: 2020-03-22 17:09:00
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Bitcoin-s v0.3.0 release 
Hi all
We just released v0.3.0 of bitcoin-s.
Bitcoin-s is a loosely coupled set of cryptocurrency libraries for the JVM.
They work well together, but also can be used independently. This project's
goal is NOT to be a full node implementation, rather a set of scalable
cryptocurrency libraries that use industry standard tools (rather than
esoteric tech often found in cryptocurrency) where possible to make the
lives of professional software engineers, security engineers, devops
engineers and accountants easier. We are rapidly iterating on development
with the goal of getting to a set of stable APIs that only change when the
underlying bitcoin protocol changes.
Here is an interactive code editor that allows you to play around with
basic data structures in bitcoin-s like private keys, psbts, and block
You can find more examples of how our neutrino node, wallet, bitcoind rpc
client and secp256k1jni (bindings for libsecp256k1) work on our website:
You can find the release notes for v0.3.0 here:

@_date: 2020-09-28 12:32:08
@_author: Chris Stewart 
@_subject: [bitcoin-dev] Bitcoin-s v0.4.0 release 
Hi all,
We just released v0.4.0 of bitcoin-s.
Major features include
- Wallet overhaul to support all common script types
- Sqlite and postgres database support for all projects
- Improved robustness of the neutrino node
- BIP340 Schnorr Signatures implemented in Java (Bouncy Castle)
- Wallet rescans with block filters
- Testkit contains all new features so you can re-use our code to test
your bitcoin applications
See the release notes here:
or our 'Getting Started' section on our website
