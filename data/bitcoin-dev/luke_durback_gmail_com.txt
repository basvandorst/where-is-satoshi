
@_date: 2015-12-09 20:35:17
@_author: Luke Durback 
@_subject: [bitcoin-dev] Standard BIP Draft: Turing Pseudo-Completeness 
Hello Bitcoin-Dev,
I hope this isn't out of line, but I joined the mailing list to try to
start a discussion on adding opcodes to make Script Turing Pseudo-Complete
as Wright suggested is possible.
In line with Wright's suggestion, I propose adding a return stack alongside
the, already existing, control stack.
The principle opcodes (excluding conditional versions of call and
return_from) needed are
OP_DEFINITION_START FunctionName:  The code that follows is the definition
of a new function to be named TransactionSenderAddress.FunctionName.  If
this function name is already taken, the transaction is marked invalid.
Within the transaction, the function can be called simply as FunctionName.
OP_DEFINITION_END:  This ends a function definition
OP_FUNCTION_NAME FunctionName:  Gives the current transaction the name
FunctionName (this is necessary to build recursive functions)
OP_CALL Namespace.FunctionName Value TransactionFee:  This marks the
transaction as valid.  It also pushes the current execution location onto
the return stack, debits the calling transaction by the TransactionFee and
Value, and creates a new transaction specified by Namespace.FunctionName
with both stacks continued from before (this may be dangerous, but I see no
way around it) with the specified value.
OP_RETURN_FROM_CALL_AND_CONTINUE:  This pops the top value off the return
stack and continues from the specified location with both stacks in tact.
It would also be useful if a transaction can create another transaction
arbitrarily, so to prepare for that, I additionally propose
OP_NAMESPACE:  Pushes the current namespace onto the control stack
This, combined with the ability to make new transactions arbitrarily would
allow a function to pay its creator.
I understand that this isn't all that is needed, but I think it's a start.
I hope this proposal has met you all well,
Luke Durback

@_date: 2015-12-09 23:23:26
@_author: Luke Durback 
@_subject: [bitcoin-dev] Standard BIP Draft: Turing Pseudo-Completeness 
Mr. Garzik,
Thank you for the prompt response.  I should have explained my proposal a
little better.
First of all, this is not Turing completeness, nor is it pseudo-complete in
the sense of Ethereum's gas economics.
Instead, whenever a function call is encountered, the transaction is
validated and can be included in a block.  The code actually halts many
times.  A new transaction is then produced with the 2 stacks stored in the
transaction data (so that the 2 stacks are saved and execution can be
continued later).  When OP_RETURN_FROM_CALL_AND_CONTINUE is encountered,
the top value of the Return stack is popped and execution continues from
that location until validation/invalidation is reached.  It's not necessary
to check the code to see that it has no infinite loops because any
transaction with infinite loops will run out of BTC with which to fund the
transaction fees of additional function calls.
To reiterate the most important point:  Execution halts every time a
function call is encountered and the transaction can be included in a
block.  A new transaction is then produced that can (if included in a
block) continue execution.
Luke Durback

@_date: 2015-12-10 01:36:28
@_author: Luke Durback 
@_subject: [bitcoin-dev] Standard BIP Draft: Turing Pseudo-Completeness 
Tomorrow, I'll work on writing a way to do voting on proposals with BTC
used as voting shares (This will be difficult as I do not know FORTH).
That seems like a fairly simple, useful example that will require loops and
reused functions.  I'll add a fee that goes to the creator.
IMO, if you write a complicated system of scripts that's used frequently,
it makes sense to charge a fee for its usage.  A decentralized exchange
between colored coins, for instance might take a small fee on each trade.
On Dec 10, 2015 10:10 AM, "Luke Durback via bitcoin-dev" <
would allow a function to pay its creator.
I don't understand what you mean by "a function" in this context, I assume
you mean a scriptSig, but then "paying its creator" doesn't make much sense
to me .
Could you provide some high level examples of the use cases you would like
to support with this?

@_date: 2015-12-11 16:45:44
@_author: Luke Durback 
@_subject: [bitcoin-dev] Standard BIP Draft: Turing Pseudo-Completeness 
If it's not consensus (ie external) thw voting doesn't have to hit the
chain at all.
I had in mind voting for something that can't be trusted if done
externally:  Perhaps BIPs for instance.  People would somehow "mark" their
BTC as being "For Proposition X" (as opposed to all other propositions) and
the vote would be canceled as soon as the BTC is spent again.
Unfortunately, I've spent the past 2 days trying to find a design that
would allow this (I don't think my original suggestion made sense in the
context of how transactions work), and I haven't gotten much yet.
scriptPubKey. Are you proposing we change that?
Sorry, I didn't understand Bitcoin's transaction model well enough when I
first made the proposal.  If Turing Pseudo-Completeness is possible with
Bitcoin, then I understand now that it could not require you to execute a
script more than once.  My current thought is that recursion can be
accomplished via checking if the next output's scriptPubKey is identical in
every way to the current scriptPubKey.  Unfortunately, a lot more is needed
than just recursion in order to do on-chain BTC voting the way I have in
mind.  I'll keep working on this.
