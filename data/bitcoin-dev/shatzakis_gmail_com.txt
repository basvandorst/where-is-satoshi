
@_date: 2018-12-03 20:27:52
@_author: Steven Hatzakis 
@_subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics 
Hi All,
I've developed a method to check if a mnemonic is also valid when the words
are put into reverse order (not the entropy), where a given 12 or 24-word
mnemonic could be valid both in little endian and big endian format. I've
coined these "Palindromic Mnemonics", but perhaps more user-friendly is
"reversible mnemonics."
A checksum-valid reversible mnemonic allows two separate vaults to be
connected to the same mnemonic string of words, where all a users must do
is enter the words in reverse order (the last word becomes first, second to
last becomes second, and so on) to access the secondary (reversed words)
vault. This utility could provide multiple use-cases, including related to
combinations with passphrases and plausible deniability, as well as
conveniences for those wishing to use a separate vault tied to the same
string of words.
For any randomly generated 12-word mnemonic (128-bits of security) the
chances of it also being reversible are 1/16 (I believe), as a total of 4
bit positions must be identical (4 bits from the normal mnemonic and
another 4 bits from the reversed string must match). For a 24-word
mnemonic, those values increase to 8 bits which need to match 8 bits from
the reversed string, leading to about 1 in every 256 mnemonics also being
reversible. While the message space of valid reversible mnemonics should be
2^124 for 12 words, that search must still be conducted over a field of 2^128,
as the hash-derived checksum values otherwise prevent a way to
deterministically find valid reversible mnemonics without first going
through invalid reversible ones to check. I think others should chime in on
whether they believe there is any security loss, in terms of entropy bits
(assuming the initial 128 bits were generated securely). I estimate at most
it would be 4-bits of loss for a 12-word mnemonic, but only if an attacker
had a way to search only the space of valid reversible mnemonics (2**124)
which I don't think is feasible (could be wrong?). There could also be
errors in my above assumptions, this is a work in progress and sharing it
here to solicit initial feedback/interest.
I've already written the code that can be used for testing (on GitHub user
 and when run from terminal/command prompt it is pretty fast to
find a valid reversible mnemonics, whereas on IDLE in Python on a 32-bit
and 64-bit machine it could take a few seconds for 12 words and sometimes
10 minutes to find a valid 24-word reversible mnemonic.
Example 12 words reversible (with valid checksum each way):
limit exact seven clarify utility road image fresh leg cabbage hint canoe
And Reversed:
canoe hint cabbage leg fresh image road utility clarify seven exact limit
Example 24 reversible:
favorite uncover sugar wealth army shift goose fury market toe message
remain direct arrow duck afraid enroll salt knife school duck sunny grunt
And reversed:
argue grunt sunny duck school knife salt enroll afraid duck arrow direct
remain message toe market fury goose shift army wealth sugar uncover
My two questions 1) are how useful could this be for you/users/devs/service
providers etc.. and 2) is any security loss occurring and whether it is
negligible or not?
Best regards,
Steven Hatzakis

@_date: 2018-12-04 14:42:42
@_author: Steven Hatzakis 
@_subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics 
Thanks, James and Joseph, for the feedback,
It has been a fun experiment!
I just want to note that the plausible deniability was not the motive but
just an example use-case, there are perhaps other use-cases that would be
on the user to decide. I think having a mnemonic that is also reversible
could be useful for other reasons - convenience related perhaps.
*Re security:* I am still not convinced entirely that security is reduced
at all because one still has to search through all entropy in the range
of 2^128 to see whether any of those are reversible (unless there is a way
to only search the field of 2^124 that are reversible, which I don't think
is possible because the hash-derived checksum cannot be determined before
hashing, only afterward). Therefore, security should still be 2^128 for a
12-word mnemonic whether it is reversible or not (as one in every 16 people
that already have one (12-word) is reversible, they just might not realize
it, so we can't say those are less secure).
Best regards,

@_date: 2018-12-04 23:39:17
@_author: Steven Hatzakis 
@_subject: [bitcoin-dev] Proposal for Palindromic (Reversible) Mnemonics 
Hi Michael, thanks for the feedback.
To answer your question, the motivation was partly that some applications
do not accept passphrases, making mnemonics less versatile in those cases
in terms of vault separation when logging in to those services, although I
agree in that specific context reversible mnemonics don't add further
security (like a passphrase can) but it shouldn't lessen security either
(in terms of entropy and bit-security).
Of course, If someone finds a plaintexts recovery phrase (i.e. hacker) then
there is no security to prevent the funds being moved out whether it is
reversible or not (unless again a passphrase was present, and even that can
be brute forced so protecting the words are key) unless it represented some
multi-sig key or was a Shamir secret share (such as is being proposed under
SLIP0039 by Satoshi Labs, and Ian Coleman hosts a prototype).
I think comparable to vanity addresses, reversible mnemonics could be part
novelty, but I do think there is also an actual utility. I am not
suggesting they are used 100% of the time, rather a user could choose to
generate one manually or check if their existing one is already reversible.
Those options could be provided at the software level and then it would be
up to the user to chose. Bottom line, I think that users who have smaller
amounts in hot wallets could find it useful to have reversible mnemonics
for switching from one service to another without having to access yet
another mnemonic. Whereas, for those creating them offline (cold storage)
it could provide an additional vault and additional passphrase options.
Here's an example:
Vault  normal mnemonic
Vault  normal mnemonic w/passphrase
Vault  reversed mnemonic
Vault  reversed mnemonic w/passphrase
Best regards,
Steven Hatzakis

@_date: 2018-11-19 21:54:01
@_author: Steven Hatzakis 
@_subject: [bitcoin-dev] BIP- & SLIP-0039 -- better multi-language support 
Hi Weiji, and Everyone,
I think this is an important topic so sharing my two cents in case in
helps: It makes sense for users to know that they can't merely just
translate a word from one language into another and expect the same
underlying entropy to be mapped, as the wordlists are not the same (i.e.
words differ at the same index values across languages).
However, while the words for each language cannot translate directly to
their equivalent in another language, in terms of entropy (bits), the
underlying entropy is, in fact, the same, when comparing mnemonics
generated across languages (see English/Spanish comparison below) when
sourced from the same initial entropy.
Importantly, the entropy is a pre-image of the resulting mnemonic and
doesn't change as the language changes, where the only changes are to the
resulting words which depend on the language chosen, for a given entropy
string. Ideally, the wallet/software should deal with these nuances, I
don't think the protocol needs any revision (except for how the BIP39 seed
is derived, perhaps), even if someone made up their own wordlist, as long
as the wallet/software has a copy of it to map those words to the
underlying index values, it's *those underlying index values and the
entropy they map too is what really matters**. *
I fully support the idea for users to back up this pre-image (initial
entropy) as it can also be used to check the validity of the mnemonic and
check that it mapped correctly, see Ian Coleman's BIP39 tool which shows
index values, a feature that I proposed last year and was since
implemented. Below is an example of how two mnemonics generated with the
same entropy will produce different BIP39 seeds.
* Example initial entropy of 128 bits +4 bit checksum derived from hash of
byte array: *
10001101000 01010100100 11011010000 11100001101 01010001101 00010010001
01100000010 10101110100 00100100011 11110000111 01100011010 1100010 (+1110
*In English*: minimum fee sure ticket faculty banana gate purse caught
valley globe shift
The same initial entropy above (all 132 bits) produces this mnemonic:
*In Spanish*: mercado faja soledad tarea evadir aries gafas peine bu?ho
tumor gerente reja
And the underlying index values below are the same for both the English and
Spanish mnemonics above:
Word Indexes: 1128, 676, 1744, 1805, 653, 145, 770, 1396, 291, 1927, 794,
*ISSUE AT HAND*:  While the initial entropy is the same, and word indexes
the same for a given entropy, (i.e. same pre-image), the resulting BIP39
seed is not the same when comparing the above English mnemonic with its
Spanish counterpart:
   - *English BIP39 seed:*
   ce7618075099c89e986f18dc495daa3be190450ed07bef77d4334a54dbc1cd7e205797ffed2615ac0999a5d691f65bf316e2cdbfd2c9d7d90b03e77ff1e6a6f5
   - *Spanish BIP39 seed*:
   9f164de0fb09af51b5831886e424d6d2479d49b5e5a1b28f5c09467ea36089b144cd94bb9b636b3c27ccff96a8958e5b7ce43cf1dea81423fc66fa7fef0aea2c
*Option 1:* Without changing anything in terms of the entropy
generation/mapping process in the BIP39 spec, the wallet/client-side
software would ideally recognize the language and show the corresponding
index value per wordlist, and reverse-calculate the entropy and then re-map
it to the language selected.
*Option 2*: Perhaps a revision is needed to how the BIP39 seed is generated
in the first place, such as by hashing the entropy instead of the words.
Any thoughts on how viable that could be where the initial entropy is fed
into the PBKDF2 function and not the words?
*Closing thoughts and tiny checksum nitpick: *
      - The multiple BIP39 seeds per language lend some similarities to
BIP44 multi-account, so perhaps this can be an advantage, depends on how it
is applied in UI/UX's (compared to having one BIP39 seed regardless of
language, for a given initial entropy).
      - There is perhaps an opportunity to add greater detail to the BIP39
spec in terms of standards/best-practices for computing checksum values, as
some software may be hashing bits, versus hashing bytes, or hashing the
entropy as a hex string, etc.. for a given entropy, which will result in
different checksum values for the same "valid" mnemonic, that might not be
"valid" in another wallet which may format the data differently before
hashing to compute the checksum.
Best regards,
Steven Hatzakis
[bitcoin-dev] BIP- & SLIP-0039 -- better multi-language support*Weiji
Guo* weiji.g
at gmail.com
*Tue Nov 6 16:16:41 UTC 2018*
   - Previous message: [bitcoin-dev] draft proposal: change forwarding
   (improved fungibility through wallet interoperability)
   - Next message: [bitcoin-dev] Considering starting a toy full-node
   implementation. Any advice?
   - *Messages sorted by:* [ date ]
    [ thread ]
    [ subject ]
    [ author ]
Hello everyone,
I just realized that BIP-0039 is language dependent. I was assuming the
other way till I looked closer. The way the seed is derived from a BIP-0039
entropy, as is shown below, depends on which language to generate the
mnemonic sentence:
   Entropy <=> Mnemonic Sentence => PBKDF2 => BIP-0032 Seed
Therefore when a user choose a non-English mnemonic code he or she is stuck
with that language. Meanwhile only a few native languages are supported.
SLIP-0039 does not solve this issue in a user friendly way by providing
only an English wordlist. That's understandable as it aims to provide SSS
capability. However those users who do not speak English or recognize
English words will suffer.
What I am trying to bring to attention of the community is that, no matter
if we make a new version of BIP-0039, or a new BIP (with SSS support), or
to enhance SLIP-0039, we really need to address this language issue.
Here are what I propose:
1. The mnemonic code should be only a representation of underlying entropy
or (pre) master secret, seed, whatever. In this way, the same seed/secret
could be displayed in English or in Chinese or other languages. Then there
could be 3rd party conversion tools to support translations in case any
wallet software or device does not support all specified languages. Now it
looks like:
   Mnemonic Sentence <=> Entropy => PBKDF2 => BIP-0032 Seed
2. Given that only 8 languages are supported in BIP-0039, we should allow
the seed/secret to be represented in decimal numbers, each ranging from 0
to 2047. So those who cannot find a native language support yet having
difficulty coping words in other languages could choose to just use numbers.
So far I don't have a preference how this should be implemented. I'd like
to hear from community first.
Weiji Guo
