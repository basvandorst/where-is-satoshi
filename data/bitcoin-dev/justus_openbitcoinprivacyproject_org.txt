
@_date: 2015-08-31 13:55:43
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Your Gmaxwell exchange 
I don't believe that any Bitcoin user actually cares about
decentralization, because none of them I've asked can define that term.
"decentralization" has become a placeholder word for "features or ideas
that I like" and it's long past time to drag the discussion back into
the realm of concrete and achievable goals.
I think there are a few specific things we can surmise about what users
might mean when they say they want Bitcoin to be "decentralized":
* They should own their bitcoins, meaning that they retain exclusive
control over their balances. Even more precisely, the network must
always honour the conditions of the scripts associated with unspent outputs.
* Their fraction of the Bitcoin ledger must not be diluted.
* When they decide to spend their coins, they will be able to do so
without requiring permission from a third party.
A decentralized architecture in certain parts of the network can be
helpful for achieving those goals, but it is not always necessary, nor
is it always sufficient to achieve them.

@_date: 2015-08-31 15:27:53
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Your Gmaxwell exchange 
You don't understand what value proof of work provides, or what features
differentiate good money from poor money, and you can't make a
defensible statement of Bitcoin's value proposition.
Because you can't do these things, you assume nobody else can do them
either and therefore the only way for Bitcoin to survive is to sweep the
problem under the rug and distract users with a word that means nothing
(and therefore means whatever the observer wants it to mean).
This is not a strategy that can be successful in the long term.

@_date: 2015-08-31 16:54:30
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Your Gmaxwell exchange 
You keep using the word "decentralized" without explaining (and most
likely, understanding) what it means.
You say:
What does it mean to use a decentralized network instead of a trusted
third party to process electronic payments? What undesirable actions can
a trusted third party perform that a decentralized network can not perform?
The answer to those questions are the *actual* goals, for which
decentralization is just one portion of a solution.
It might be helpful to organize Bitcoin's various existing, potential,
rejected, and proposed features using the Kano model:
Example: The ability of one entity to spend another entity's Bitcoins
without their consent is a reverse quality.
It would at least give us something objective to talk about.

@_date: 2015-08-31 18:24:25
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Your Gmaxwell exchange 
This is on the right track, but still falls short in a few areas.
It's a false dichotomy to say that our choices are: Bitcoin as it exists
today (or in some theoretical perfect state of decentralization), or an
Excel spreadsheet edited by a trusted third party who can change any
number to be any other number they want.
Imagine there was only one miner in the network. In spite of being the
sole entity creating the blockchain there would still be many actions
they could *not* do:
* Falsify ECDSA signatures
* Generate proof of work without expending energy
* Produce blocks that non-mining nodes would recognize as including
invalid transactions (including printing themselves unlimited balances)
* Force other people to purchase the coins they mine so that they can
pay their electric bills
What they *can* do is:
* Defraud recipients of transactions by including a payment transaction
in a block, then orphaning that block with another block that contains a
conflicting transaction (double spend).
There is usually*** a cost to performing this attack, so miners would
only be expected to do it if the benefit exceeds the cost.
* Prevent the inclusion of valid transactions into any block using any
criteria they want.
The worse case scenario for mining monopolization is that the risk of
profitable double spends means that transactions might require more
confirmations to be reliable, and that some entity can censor
transactions at will.
Those aren't exactly end-of-the world failure cases. They are certainly
undesirable and every means of preventing them should be investigated,
but it does mean that it should be possible to dial back on the
catastrophe language when analysing possible failure modes.
The weakest area for Bitcoin to be attacked is via censorship enforced
by miners.
The first line of defence is to improve the privacy features of wallets
to the point at which blacklists are not effective. I'm confident that
this can be achieved.
That leaves the censors with the choice of whether or not to escalate to
whitelisting, which ultimately can be countered by users switching to a
new system which does not have that particular anti-feature.
tl;dr: Bitcoin security does not lie on a one-dimensional "centralized
vs decentralized" axis. Treating it as if it does removes the clarity
that is needed in order to effectively solve problems.
***Exploring the exact conditions under which this is true is an
interesting exercise and relevant to long term discussions vis a vis the
block subsidy and transaction fees in the future.

@_date: 2015-12-08 09:55:57
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Capacity increases for the Bitcoin system. 
If such a change is going to be deployed via a soft fork instead of a
hard fork, then the coinbase is the worst place to put the segwitness
merkle root.
Instead, put it in the first output of the generation transaction as an
OP_RETURN script.
This is a better pattern because coinbase space is limited while output
space is not. The next time there's a good reason to tie another merkle
tree to a block, that proposal can be designated for the second output
of the generation transaction.

@_date: 2015-12-08 12:43:40
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Capacity increases for the Bitcoin system. 
I don't care what color that bikeshed is painted.
In whatever transaction it is placed, the hash should be on the output
side, That way is more future-proof since it does not crowd out other
hashes which might be equally valuable to commit someday.

@_date: 2015-12-19 11:55:10
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Segregated witness softfork with moderate 
I don't think SW is relevant at all with respect to scalability.
Fraud proofs are extremely important from a security perspective. The
network as it exists now places too much trust in miners. Creating a way
for non-full node clients to reject chains with contain invalid
transactions regardless of how much hashing power produces the invalid
chains is essential for the security of the network.
Adding a fraud proof system into blocks means that other features, like
committed UTXO sets, become less unsafe to deploy.
Solving transaction malleability is a very nice to have feature.
A scalability solution, IMHO, is "how do we buy some time to allow
continue usage growth while working on creating a situation where it
becomes safe to eliminate maximum block size as a consensus rule?"

@_date: 2015-12-20 22:42:03
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Capacity increases for the Bitcoin system. 
By "solve" do you mean, "actually implement", or do you mean "make
future implementation theoretically possible?"
In other words, would a deployment of SW involve the creation of new
network message for relaying fraud proofs, a specification that SPV
wallet developers can use to validate these messages and so know when to
ignore the highest (but invalid) PoW chain, and the ability to
automatically generate and broadcast these proofs in Bitcoin Core?

@_date: 2015-12-26 17:15:06
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Block size: It's economics & user preparation & 
This argument would hold more weight if it didn't looks like a stalling
tactic in context.
6 months ago, there was a concerted effort to being the process then,
for exactly this reason.
After 6 months of denial, stonewalling, and generally unproductive
fighting, the need for proactivity is being acknowledged with no
reference to the delay.
If the network ever ends up making a hasty forced upgrade to solve a
capacity emergency the responsibility for that difficulty will not fall
on those who did their best to prevent emergency upgrades by planning ahead.

@_date: 2015-12-26 18:33:58
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Block size: It's economics & user preparation & 
I think you'll find that writing in that tone makes one come across as a
complete and utter douchebag.
I suspect what you're intending to do is to use faux-polite
condescension to bait me into responding in a way to will justify my
subsequent banning from this mailing list so that the people who aren't
interested in answering certain uncomfortable questions will have a
plausible excuse for preventing them from being asked here.
Actually there's been 3+ years of stonewalling, deception, conflicts of
interest, and outright crimes, which have been generally ignored by
those who are desperately attempting to assume good faith.
The purpose of my email was to remind everyone that nobody is going to
get away with avoiding ownership of the consequences of their actions.
If the network experiences a painful upgrade because six months of time
that could have been used to prepare a smooth upgrade was lost, the
individuals who squandered that time own the result. They can't get
around it by demanding six additional months, as if they had nothing to
do with the six lost months.

@_date: 2015-07-01 12:28:30
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Bitcoin governance 
If that's the purpose of this list, then it is misleadingly named.
If development of Bitcoin Core, the application, is to be considered
independent from development of Bitcoin, the protocol, then Bitcoin Core
development needs its own list.

@_date: 2015-07-04 10:18:19
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Fork of invalid blocks due to BIP66 violations 
In general, the situation can be improved if there existed proofs which
validating full nodes could broadcast which would tell SPV nodes why the
branch it sees with the most proof of work is actually invalid.
As far as I can tell, producing such proofs is reasonably
straightforward for all cases except the case where a block is invalid
because it contains a transaction which references a non-existent output.
The shortest proof that a particular transaction does not exist in the
blockchain is the entire blockchain.
If each transaction input identified the block containing the referenced
outpoint, then the proof of non-existence is either the block in
question, or the list of block headers (to show that the block doesn't
exist). That's a significant improvement in proof size over the entire
Proving the non-existence of a particular transaction in a specific
block could be made easier for future blocks by requiring transactions
to be ordered in the merkle tree by their hashes.  Then it would just
require a few nodes in the tree to show that the transaction isn't in
the place where it should be.

@_date: 2015-07-04 11:01:37
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Fork of invalid blocks due to BIP66 violations 
How do we know if a committed UTXO set is valid? If a majority of the
hashing power is willing to extend an invalid branch, it's reasonable to
assume they'd be willing to commit an invalid UTXO set as well.
In order for the committed UTXO set to be reliable at a minimum it will
need to contain at a source block reference for each item in the set.
That would enable fraud proof to show that the committed UTXO set
contains invalid entries.
I agree the information should be an extra commitment produced by the
miner, rather than changing the format of the transaction, since the
author of a transaction can't always know the required information ahead
of time.
If items in the the proof tree are required to be sorted, then it's easy
to proof that an item is missing.

@_date: 2015-07-04 18:33:24
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Fork of invalid blocks due to BIP66 violations 
I think the problem is tractable if some reasonable assumptions are made
about the ability of SPV clients to perform validity checks that don't
involve any state outside a single transaction (or block):

@_date: 2015-07-05 15:33:40
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Thoughts on Forks, Scalability, 
When I read this, I get the impression that you (and possibly many
others) never actually understood the Bitcoin security model in the
first place.
Bitcoin is a digital cash system that prevents double spending without
using a trusted third party.
More specifically, successful double spending in Bitcoin requires an
attacker to pay a proof of work cost that exceeds the cumulative proof
of work paid by all non-attackers since the original spend.
The security model holds for any user who has access to the complete
blockchain, and currently does not hold for all users who do not. An
attacker can double spend without paying the full PoW cost the security
model requires if users do not have a full copy of the blockchain which
which to verify the attacker's blocks.
That's a problem, but it's not an unfixable problem.
The reason an attacker can fool SPV clients into accepting invalid
blocks is because there exists no mechanism via which honest nodes can
prove the invalidity of blocks.
Implement that mechanism, and the security of SPV clients will far more
closely resemble the security of full nodes.

@_date: 2015-07-05 16:05:43
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Thoughts on Forks, Scalability, 
I get concerned when I hear statement like "the raison d'etre of bitcoin
is trustlessness" because it implies that Bitcoin promises infinite
security, which has never been the case.
I don't think we can meaningfully discuss Bitcoin security issues if
every proposal is compared to a straw standard of perfection which is
achievable. When everybody expects infinite security then the perfect
turns into the enemy of the good (and the achievable).

@_date: 2015-07-10 12:02:43
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Why not Child-Pays-For-Parent? 
I'm not sure why that's actually a problem.
CPFP is initiated by the recipient of the parent transaction, and so if
the recipient is creating this transaction in the first place they must
have a copy of the parent transaction which can/should broadcast at the
same time.
If the child reaches a CPFP miner, then presumably the parents made it
as well (any path between the sender and the miner that doesn't relay
the parent should reject the child as trying to spend non-existent
coins), so both of the transactions can be mined at the same time.

@_date: 2015-06-30 15:08:46
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] block-size tradeoffs & hypothetical alternatives 
need done to increase block size to a static 8MB, and help do it)
Continually repeating this statement without defining terms or providing
evidence does not make it true or informative.
"Decentralization" is a popular buzzword these days, but how about
stating the problem description in a way that is more precise and accurate?
One of Bitcoin's differentiating properties is that it prevents double
spending without using a trusted third party.
Now instead of arguing about some nebulous "decentralization" that
nobody can define or measure, we can talk about more helpful questions like:
Under what circumstances will miners and/or nodes behave as a trusted
third party (collusion)?
What incentives exist which increase, and which reduce, any tendencies
that may exist for nodes to collude?
In what ways specifically does MAX_BLOCK_SIZE relate to either of the
following questions?

@_date: 2015-05-18 18:16:48
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Open Bitcoin Privacy Project Spring 2015 
Hash: SHA1
We're produced the first in what we hope to be a long series of
reviews of Bitcoin wallet privacy features, available here:
Specifically from the readers of this list, we are very interested in
feedback regarding our privacy threat model and the rating criteria we
derive from it.
Threat model:
Please send any suggestions or corrections via a GitHub issue to the
wallet-ratings repository so that we can incorporate it into future

@_date: 2015-05-18 23:57:09
@_author: Justus Ranvier 
@_subject: [Bitcoin-development] Open Bitcoin Privacy Project Spring 2015 
Hash: SHA1
Replying to the list because this is a common question.
We rated as many wallets as we could based on the amount of manpower
we had available to perform the ratings.
We will be holding a recruiting drive shortly to solicit additional
volunteers so that we can cover more wallet for the next round of ratings.

@_date: 2015-11-01 08:36:35
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Compatibility requirements for hard or soft forks 
If the policy of Bitcoin Core development includes a willingness to
makes the utxos created by software other than Bitcoin Core unspendable,
then it certainly merits clear, widespread notification.
Even if that is actually a good policy, the reasons why should be made
abundantly clear.

@_date: 2015-11-01 18:23:27
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Compatibility requirements for hard or soft forks 
Are there actually any OP_CAT scripts currently in the utxo set?
It's one thing to have a theoretical scripting ability that gets removed
before anyone actually uses it - that doesn't put anyone in the position
of retroactively making decisions about the validity of someone else's
Presently the utxo set is about $5 billion worth of other people's money.
It's a lot easier to justify the position: "nobody has the right to
change the meaning of someone else's outputs", than it is to justify,
"some small group of people gets to decide what's standard and what
isn't, and if you choose to use the network in a valid but nonstandard
way, that group of people might choose to deny you access to your money
in the future"
In other words, how close to the shores of "administrators of a virtual
currency" do Bitcoin developers want to sail?

@_date: 2015-11-01 22:15:36
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Compatibility requirements for hard or soft forks 
I guess by "locked transaction" you must mean a P2SH output?
If so, that's a rather bizarre use of terms since outputs and
transactions are very different things.

@_date: 2015-11-02 00:12:16
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Compatibility requirements for hard or soft forks 
So after realizing that I misread substantial portions of this thread
due to a lack of attention to detail I'd like to point out this:
Bitcoin nodes have the capability to validate blocks going back to the
genesis block, including blocks which would not be valid if mined today
under current rules.
Therefore it must be the case that all the old consensus rules are
preserved somewhere in the current code bases of the various
Given that, there shouldn't be any technical barrier to validating input
scripts according to the consensus rules that were in effect at the time
the input being spent was added to the blockchain.
Maybe dealing with output is more difficult.
Had every consensus rule change (deliberate and accidental) been
accompanied by a version number bump, it would have been possible to
phase out old versions without invaliding signed-but-unbroadcast
transactions by saying "as of block height x, transactions with version
y or lower are invalid unless their inputs are exclusively sourced from
blocks with heights < x"
If there already have been rule changes which have retroactively
invalided unbroadcast transactions which were valid at the time they
were signed, those rules could be relaxed to not apply to transactions
which exclusively spend inputs that existed before the rule change.

@_date: 2015-11-02 16:12:29
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Compatibility requirements for hard or soft forks 
If Bitcoin were perfect. then it would be the case that any transaction
that was valid at the time it was signed would always remain valid until
spent regardless of any protocol changes which occurred in the interim.
Certainly, that property, if it was possible to achieve, would give
Bitcoin maximum possible utility compared to alternative properties.
There are cases in which that guarantee can be met, and there are some
pathological cases where it can not be met.
It's not possible to know if the pathological cases are actually a real
problem in practice, because the possible existence of unbroadcast
transactions which would trigger them is unknowable.
A possible lazy/optimistic strategy is to implement as much
non-pathological backward compatibility as possible, and treat unhandled
cases as outstanding bugs whose resolution is deferred unless and until
they are actually triggered.

@_date: 2015-10-14 20:43:25
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Proposed list moderation policy and conduct 
Even if we assume everybody will try to approach that topic in good
faith, I don't think it's that simple.
A term that's become popular recently is "Bitcoin maximalist", and it's
frequently used as a slur or insult.
I honestly find that to be incomprehensible. If somebody at a Ford board
meeting started talking about how Ford needed to make sure Toyota was
able to sell enough cars, they wouldn't get very far by labelling their
critics as "Ford maximalists".
Anyone who works at Ford and who isn't a Ford maximalist is in the wrong
And yet in Bitcoin, a much development is funded by companies who offer
products which compete with Bitcoin, or at least would be in competition
if Bitcoin were to achieve unlimited success.
I expect this is a minority view on this list, but my position is that
anyone who is not a Bitcoin maximalists has a potential conflict of
interest if they're also involved in Bitcoin development.
I also suspect this issue is a cause of much user dissatisfaction with
Bitcoin development. If Bitcoin users and investors don't trust that the
developers are working toward the unlimited success case, they can and
will revolt.

@_date: 2015-10-22 09:55:14
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] [Bitcoin-development] Reusable payment codes 
The notification transaction portion is my least-favorite portion of the
spec, but I don't see any alternatives that provide an unambiguous
improvement, including your suggestion.
One of the most highly-weighted goals of this proposal is to be usable
on as many mobile/light wallets as possible.
I know for sure that all existing platforms for balance querying index
by address. Support for bloom filters or other querying methods is less
comprehensive, meaning the set of wallets that can support payment codes
would be smaller.

@_date: 2015-10-22 15:58:58
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] [Bitcoin-development] Reusable payment codes 
I strongly disagree with this statement.
There is a version byte in the payment code specification for a reason.
Version 1 payment codes are designed to be deployable by wallet
implementers today, without requiring them to wait on any network-level
changes whatsoever, which includes IsStandard() redefinitions, or
yet-to-be-invented-and-deployed filtering schemes.
As far as I know, multi-push OP_RETURN outputs are not standard
transactions and so wallet users can not rely on transactions containing
them to be relayed through the network, therefore any improvement to the
protocol which requires that feature is not appropriate for version 1.
When additional capabilities are deployed in the network such that
Bitcoin users can rely on their existence, that would be a great time to
specify a version 2 payment code that uses those features and encourage
users to upgrade (which should be a fairly smooth process since their
actual keys don't need to change).

@_date: 2015-10-22 17:01:10
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] [Bitcoin-development] Reusable payment codes 
That's fine. Nobody is required to adopt an informational BIP if they do
not wish to do so.
They are "mere software changes" outside the control of the users and
wallet developers who may wish to use and implement payment codes, so
are indistinguishable from a network-level change.
Since Bitcoin Core 0.11, 80 byte OP_RETURN transactions are standard, so
that's what payment codes use:
Whether or not it "should" have an influence, it is an absolute fact
that Bitcoin users are affected by it.
A user whose transactions are not relayed or mined doesn't care about
the politics surrounding node policy.
Designing standards without putting the needs of its intended users
first is a great way to see the standard fail.
Have you ever heard the term "permissionless innovation" by chance?
Particularly in reference to Bitcoin?
If you don't like payment codes, then don't use them.

@_date: 2015-10-23 10:57:14
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] [Bitcoin-development] Reusable payment codes 
As I said before, once the prerequisites for a better notification
method are usable in the network, I'd love to define a version 2 payment
code that uses such an better notification system.
In the meantime. every block mined shows very consistent 70% address reuse.
Anything that can bring that number down is a good thing. Even if
version 1 payment codes could only potentially drop that number from 70%
to 30% instead of to 0%, they'd still be worth using while we wait for
version 2.

@_date: 2015-09-02 13:51:08
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Your Gmaxwell exchange 
That is not true, unless you are using a definition of the word
"decentralized" which is so broad as to convey no information whatsoever.
Saying that Bitcoin's security depends on decentralization is like
saying that a bridge's structural integrity depends on good materials.
Statements like that convey zero relevant information. Potential users
of a bridge want to know about the maximum working load of the bridge,
and under which conditions it is safe to use. At what wind speed should
the bridge be closed? Is it ok to keep using it after a magnitude 4
earthquake, or should it be closed for inspection?
Repeatedly asserting that bridges need to be made of good materials as
an alternative to answering those kinds of questions would be easily
recognized as useless in that context, but for some reason people seem
to accept it in this one.

@_date: 2015-09-04 12:48:48
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] RFC: HD Bitmessage address derivation based on 
What benefit is created by delegating the BIP-43 namespace management to
that company in particular?
BIP-43 as it is currently composed provides the convenient feature of
purpose codes matching the BIP number. Moving purpose codes to a
separate namespace add complexity to its usage for no discernible benefit.

@_date: 2015-09-04 13:25:16
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] RFC: HD Bitmessage address derivation based on 
HD generation of keypairs from a single seed for many non-conflicting
uses is a valuable and useful technique.
Intentionally making a useful technology less useful because assigning
non-colliding numbers is too hard is a strange approach to software

@_date: 2015-09-18 21:30:13
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Hash of UTXO set as consensus-critical 
None of those statements are true.
If a majority of Bitcoin miners are mining invalid blocks, then they
aren't Bitcoin miners any more and are no longer relevant to the Bitcoin
There does exist a problem that light clients aren't always able to tell
the difference between chains that are valid and chains that are not
valid, but it's is possible to create simple proofs that would do so:
If those changes would be implemented, then any node that knew a chain
was invalid could produce a compact proof that anyone else in the
network could verify, regardless of how much proof of work was used to
create the invalid chain.
Committed UTXO sets would need safe to rely upon if a similar set of
proofs that a particular set was invalid existed.

@_date: 2015-09-19 12:19:11
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Hash of UTXO set as consensus-critical 
What does "malicious" mean?
In other words, If miner A is mining honestly, and miner B is mining
maliciously, what are some of the possible difference in their behaviour
we would observe?

@_date: 2015-09-21 12:15:12
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Hash of UTXO set as consensus-critical 
This isn't a particularly good definition.
"An honest miner is a miner that supports the network by building on top
of the best valid chain."
What is the "best valid chain"? The one with the most proof of work? The
one that meets some other definition of "best"?
"A malicious miner is one who wants to disrupt the Bitcoin network, not
support it"
This is a tautology, the equivalent of saying "a malicious miner is a
miner that is malicious" A true, but entirely useless, statement.
"for example by executing a 51% attack which mines empty blocks on top
of the best chain."
Again, you're begging the question with the word "attack", because
that's what you're supposed to demonstrate.
Apparently the difference between honest mining and malicious mining is
empty blocks? You've said in both cases the miners are extending the
"best valid chain". Is extending the best valid chain with an empty
block always a malicious act?
What's the significance of 51% in this definition? Is the same empty
block which extended the best valid chain honest if the miner who
produced it has 49% of the network hashing power and malicious if they
add a few more ASIC units?

@_date: 2019-07-22 10:58:49
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
If you want projects to adopt BIP-157/158, you'd do well to fix the
numerous errors in the specification.
As it stands right now it is impossible to implement the protocol using
the specification because he code examples are broken to the point of
appearing intentionally sabotaged.

@_date: 2019-07-24 08:11:28
@_author: Justus Ranvier 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
They complement each other pretty well though.
Wallets can save the deterministic GCS filters in the same way as
headers, which means blocks can be re-scanned if necessary (importing
new keys, etc) offline.
Bloom filters are good for limiting mempool bandwidth as well as
controlling the fraction of each block that is downloaded.
On the BTC chain that last point doesn't matter as so much, but on
chains with larger blocks I expect that clients will ultimately end up
using both filter schemes for exactly that reason.
