
@_date: 2015-10-05 18:26:12
@_author: Tom Zander 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
I think its plain to see the soft fork is controversial.
But that?s not the point.
The point is that Bitcoin Core claims to have a consensus mechanism and sticks to "no change" on not reaching a consensus. And that rule is the reason why bigger blocks were blocked for years.
History has shown that for many decision making processes this doesn't work, and this argument has been made to Core. Until today this was essentially a rule that hurt the things that Mike was really passionate about.
Today this hurts the things that some other devs are passionate about.
I think today is the day that everyone should agree that the past is the past and we all learned our lesson and Bitcoin Core will make decisions a different

@_date: 2015-10-05 19:33:00
@_author: Tom Zander 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
Arguing that BIP66 rollout was a full success is in the same park of "successful" ?
Where for weeks people were told not to trust the longest chain until it was 30 blocks.
Lets put that in perspective. The main functionality of Bitcoin  Frankly, if that fiasco happened in a company, people would get fired for gross misconduct.
Bottom line is that there is a horrible track record of doing soft forks in the past, there are some really good technical reasons why this should not happen again. And the defence against this argument is to do character assassination because you think he has ulterior motives?  Like you say in this part;
"all but outright said" is still not said. Is still just a suspicion you have. And you are accusing a man of something he didn't do.
That?s just not right.
There is no complaint. Why do you think there is?
Are you claiming that not reaching consensus is NOT the reason that bigger blocks are not in Bitcoin Core?
Reaching consensus is an admirable goal. But its exactly that, a goal.
And anyone that is a perfectionist will know that in the real world goals are often not reached. That doesn't make them less useful. That makes them goals.
This specific goal is in conflict of building a good product and a well functioning community.
A good product and a well functioning community needs rules and needs timely decisions and conflict resolution.
It does not need muting of valuable voices, it does not need character assassinations and it really doesn't need egos.
I suggest reading this book;

@_date: 2015-10-05 19:51:26
@_author: Tom Zander 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
I enjoyed reading them, but I have to admit I'm not convinced and for me the objections stand.
Softforks are unnecessarily dangerous and I feel entirely avoidable. It is a risk that not worth taking.

@_date: 2015-10-05 20:13:35
@_author: Tom Zander 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
you are good at language and its easy to write eloquent words.
Looking at this little dialog, for instance;
This *seems* to read like the same thing. But it is not.  Your version is more polarizing and changes the intent quite dramatically.
It is an eloquent change, but not really the topic we were discussing. It also makes you attack Mike (calling him out as having a strawman) without basis.
For the second time in this thread. I would suggest arguing on the topic, not on the man.

@_date: 2015-10-05 21:35:05
@_author: Tom Zander 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
You are special only in your eloquent use of the language. Consider yourself lucky :)
I would not expect anything less.
Thanks for explaining your thinking.
Fortunately I can say that while we certainly value your opinion, when peoples opinions are hard to read, as you indicated they can be, we should look at their actions. The group has followed the consensus rule quite rigorously, which I applaud.
But next to that people like Black and Laan have given strong verbal indications confirming the practice you personally keep explaining is not When I was a little boy of maybe 12 years, I remember reading a short story, that stuck with me.  It was about a man that had vowed to never lie. He was invited to a dinner party and asked to assist with another man's accusation of a crime he claimed to not have committed.
The end result was that the accused man was indeed guilty, but he minced his words so well that every sentence uttered was true. To the layman he seemed truthful and pleasant. Certainly innocent.
But to the man that never lied, his stories quickly fell apart as he himself had had years of practice with the same. And the guilty man was jailed.
I really enjoy reading your emails and github posts too, they have an eloquence and a brashness.

@_date: 2015-10-05 22:08:23
@_author: Tom Zander 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
Regular contributor?
Please explain how for a fork in the protocol should you only listen to regular Bitcoin Core contributors?

@_date: 2015-10-06 08:14:35
@_author: Tom Zander 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
Have you ever been at a meeting where you didn't feel like you were being listened to?
You get comments like;
 ?I respond to the technical arguments not because I believe they are
 earnestly motivated, but because they provide an avenue for learning for
 myself and others.?
 ?"there is no gridlock here? After several respected members stated there is
 disagreement.
 ?That Mike himself continues to misexplain things is not surprising since he
 has all but outright said that ?[snip]  Which is putting words in the mouth of someone you disagree with.
But what really gives a lot of people here the suggestion that members of the community that are against the softfork are not being listened to is the simple undeniable fact that an alternative or a remedy is not even considered.
There is no code. There is no question posted by the authors which flags to Actions speak much louder than words. Read the topic of this thread!
The actions show a disregard for the many objections.  Consensus is not build by repeating again and again the arguments that you belief will convince your debate-opponent. It is about reaching a middle ground. If either side of the debate refuses to budge from their position, you have gridlock.
What came of the request made to PeterT to document the risks and required changes in wallets should this soft fork continue?
Why is it soo bad to use a hardfork (with proper voting) instead of a softfork that we are in a place that the Bitcoin Core team is willing to throw out a lot of goodwill and show their true colours in hundreds of mails that leave the opposing side of this debate feeling ignored and left out?
I don't feel specifically unique or special. Nobody needs to reply to this email. I don't claim peoples time.
All I'm doing is spelling out what has been living in the back of my head, and with me a great deal of others, about how this is playing out.
If you choose to ignore this and you force a softfork, I belief you may be surprised at how many active players in the Bitcoin marketplace may see that the "Bitcoin Core" team is not an ally any longer.
It is good to remember that the graveyards are filled with people that believed to be unreplaceable.
Bitcoin will go on.
Have a nice day!

@_date: 2015-10-14 08:58:48
@_author: Tom Zander 
@_subject: [bitcoin-dev] Memory leaks? 
I suggest running it in valgrind with --leak-check=full for 10 minutes.
  valgrind --leak-check=full src/bitcoind 2>&1 | tee out
This at least will show you any memory leaks at exit.
Naturally, the leaks you observe may just be design issues where cache can grow to much and when the cache is cleaned on shutdown you won't see it in the valgrind output.

@_date: 2015-10-21 08:29:19
@_author: Tom Zander 
@_subject: [bitcoin-dev] Memory leaks? 
Please make sure you measure your memory usage correctly on Linux, it is notoriously easy to get misleading info from tools like top.
I use this one on Linux. $cat ~/bin/showmemusage if test -z "$1"; then
    echo "need a pid"
    exit
mem=`echo 0 $(cat /proc/$1/smaps | grep Pss | awk '{print $2}' | \
sed 's ) | bc`
echo "$mem KB"

@_date: 2015-10-23 11:30:37
@_author: Tom Zander 
@_subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db 
Apart from it being unmaintained, any links to what are problems with levelDB?

@_date: 2015-10-28 15:52:53
@_author: Tom Zander 
@_subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db 
Thanks for that link!
Another Google open source product I'll avoid like the plague ;)

@_date: 2016-08-01 11:30:22
@_author: Tom 
@_subject: [bitcoin-dev] Introducing Flexible Transactions. 
I've been asked one question quite regularly and recently with more force.
The question is about Segregated Witness and specifically what a hard
fork based version would look like.
This is available online at my blog;
  But I'll publish the actual text here as well, hoping to hear from others in the Bitcoin industry what they think about this approach.
Segregated Witness (or SegWit for short) is complex. It tries to solve
quite a lot of completely different and not related issues and it tries to
do this in a backwards compatible manner. Not a small feat!
So, what exactly does SegWit try to solve? We can find info of that in the
[benefits]( document.
* Malleability Fixes
* Linear scaling of sighash operations
* Signing of input values
* Increased security for multisig via pay-to-script-hash (P2SH)
* Script versioning
* Reducing UTXO growth
* Compact fraud proofs
As mentioned above, SegWit tries to solve these problems in a backwards
compatible way. This requirement is there only because the authors of
SegWit set themselves this requirement. They set this because they wished
to use a softfork to roll out this protocol upgrade.
**This post is going to attempt to answer the question if that is indeed
the best way of solving these problems.**
Starting with Malleability, the problem is that a transaction between being
created by the owner of the funds and being mined in a block is possible to
change in such a way that it still is valid, but the transaction identifier
(TX-id) has been changed. But before we dive into the deep, lets have some
general look at the transaction data first.
If we look at a
[Transaction]( as it is
today, we notice some issues.
Version4 bytes
Number of inputsVarInt (between 1 and 9 inputsPrev transaction hash32 bytes.
            Stored in reverse
Prev transaction index4 bytes
TX-in script lengthCompact-
TX-in scriptThis is the witness data
4 bytes
Number of outputsVarInt (between 1 and 9 outputsValueVar TX-out script lengthCompact-
TX-out scriptbytearray
NLockTime4 bytes
The original transaction format as designed by
[Satoshi Nakamoto](
had a 4 byte version. This design approach is common in the industry and
the way that this is used is that a new version is defined whenever any
field in the data structure needs changing.  In Bitcoin we have not done
this and we are still at version 1.
What Bitcoin has done instead is make small, semi backwards-compatible, For instance the [CHECKSEQUENCEVERIFY]
feature repurposes the sequence field as a way to add data
that would not break old clients.  Incidentally, this specific change
(described in BIP68)
is not backwards compatible in the main clients as it depends on a
transaction version number being greater than 1, they all check for
Standard transactions and say that only version 1 is standard.
The design of having a version number implies that the designer wanted to
use hard forks for changes. A new client is required to know how to parse a
newly designed data structure, this should be obvious. So the idea is to
change the version number and so older clients would know they can't parse
this new transaction version. To keep operating, everyone would have to
upgrade to a client that supports this new transaction version.
Lets look at why we would want to change the version; I marked some items in
red that are confusing. Most specifically is that numbers are stored in 3
different, incompatible formats in transactions. Not really great and
certainly a source of bugs.
Transactions are cryptographically signed by the owner of the coin so
others can validate that he is actually allowed to move the coins.
The signature is stored in the `TX-in-script`.  Crypto-geeks may have noticed something weird that goes against any
textbooks knowledge.  What this is is that a digital
signature has to be placed outside of the thing it signs. This is because
a digital signature protects against changes. But a signature itself would
cause this change. So you have to store the signature outside the thing you
Bitcoin's creator did something smart with how transactions are actually
signed so the signature actually doesn't have to be outside the
transaction. It works. Mostly. But we want it to work flawlessly
because currently this being too smart causes the dreaded malleability
issues where people have been known to lose money.
 What about SegWit?
SegWit actually solves only one of these items. It moves the signature out
of the transaction. SegWit doesn't fix any of the other problems in Bitcoin
transactions, it also doesn't change the version after making the
transaction's-meaning essentially unable to be understood by old clients.
Old clients will stop being able to check the SegWit type of transaction,
because the authors of SegWit made it so that SegWit transactions just have
a sticker of "All-Ok" on the car while moving the real data to the trailer,
knowing that the old clients will ignore the trailer.
SegWit wants to keep the data-structure of the transaction unchanged and it
tries to fix the data structure of the transaction.  This causes friction
as you can't do both at the same time, so there will be a non-ideal
situation and hacks are to be expected.
The problem, then, is that SegWit introduces more technical debt, a term
software developers use to say the system-design isn't done and needs
significant more work.  And the term 'debt' is accurate as over time
everyone that uses transactions will have to understand the defects to work
with this properly. Which is quite similar to paying interest.
Using a Soft fork means old clients will stop being able to validate
transactions, or even parses them fully. But these old clients are
themselves convinced they are doing full validation.
 Can we improve on that?
I want to suggest a way to **one-time** change the data-structure of the
transaction so it becomes much more future-proof and fix the issues it
gained over time as well. Including the malleability issue. It turns out
that this new data-structure makes all the other issues that SegWit fixes
quite trivial to fix.
I'm going to propose an upgrade I called;
Last weekend I wrote a little app (sources [here]
that reads a transaction and then writes it out in a new format I've
designed for Bitcoin. Its based on ideas I've used for some time in other
projects as well, but this is the first open source version.
The basic idea is to change the transaction to be much more like modern
systems like JSON, HTML and XML. Its a 'tag' based format and has various
advantages over the closed binary-blob format.  For instance if you add a new field, much like tags in HTML, your old
browser will just ignore that field making it backwards compatible and
friendly to future upgrades.
Further advantages;
* Solving the malleability problem becomes trivial.
* tag based systems allow you to skip writing of unused or default values.
* Since we are changing things anyway, we can default to use only var-int
  encoded data instead of having 3 different types in transactions.
* Adding a new tag later, (for instance ScriptVersion) is easy and doesn't
  require further changes to the transaction data structure. All old clients
  can still make sense of all the known data.
* The actual transaction turns out to be about 3% shorter average (calculated
  over 200K transactions)
* Where SegWit adds a huge amount of technical debt, my Flexible
  Transactions proposal instead amortizes a good chunk of technical debt.
An average **Flexible Transaction** will look like this;
TxStart (Version)0x04
TX-ID data
inputsTX-ID I try to spent1 + 32 bytes
Index in prev TX-IDvarint
outputsTX-out Value (in TX-out scriptbytearray
inputsTX-in-script (Witness data)bytearray
Notice how the not used tags are skipped. The `NLockTime` and the
`Sequence` were not used, so they are skipped in the transaction.
The Flexible Transaction proposal uses a list of tags. Like JSON; `"Name:"
"Value"`. Which makes the content very flexible and extensible. Just
instead of using text, Flexible Transactions use a binary format.
The biggest change here is that the `TX-in-script` (aka the witness data) is
moved to be at the end of the transaction. When a wallet generates this new
type of transaction they will append the witness data at the end but the
transaction ID is calculated by hashing the data that ends before the
witness data.
The witness data typically contains a public key as well as a signature.
In the Flexible Transactions proposal the signature is made by signing exactly
the same set of data as is being hashed to generate the TX-input. Thereby
solving the malleability issue. If someone would change the transaction, it
would invalidate the signature.
I took 187000 recent transactions and checked what this change would do to
the size of a transaction with my test app I linked to above.
* Transactions went from a average size of 1712 bytes to 1660 bytes and a
  median size of 333 to 318 bytes.
* Transactions can be pruned (removing of signatures) after they have been
  confirmed. Then the size goes down to an average of 450 bytes or a median
  of 101 bytes
* In contrary to SegWit new transactions get smaller for all clients with this
  upgrade.
* Transactions, and blocks, where signatures are removed can expect up to
  75% reduction in size.
 Broken OP_CHECKSIG scripting instruction
To actually fix the malleability issues at its source we need to fix this
instruction. But we can't change the original until we decide to make a
version 2 of the Script language.  This change is not really a good trigger to do a version two, and it
would be madness to do that at the same time as we roll out a new format of
the transaction itself. (too many changes at the same time is bound to
cause issues)
This means that in order to make the Flexible Transaction proposal actually
work we need to use one of the NOP codes unused in Script right now and
make it do essentially the same as OP_CHECKSIG, but instead of using the
overly complicated manner of deciding what it will sign, we just define it
to sign exactly the same area of the transaction that we also use to create
the TX-ID. (see right most column in the above table)
This new opcode should be relatively easy to code and it becomes really
easy to clean up the scripting issues we introduce in a future version of
 So, how does this compare to SegWit.
First of all, introducing a new version of a transaction doesn't mean we
stop supporting the current version. So all this is perfectly backwards
compatible because clients can just continue making old style transactions.
Naturally, with the problems that had, but nobody will end up stuck.
Using a tagged format for a transaction is a one time hard fork to upgrade
the protocol and allow many more changes to be made with much lower impact
on the system in the future.  There are parallels to SegWit, it strives for
the same goals, after-all. But where SegWit tries to adjust a static
memory-format by re-purposing existing fields, Flexible transactions presents
a coherent simple design that removes lots of conflicting concepts.
Most importantly, years after Flexible transactions has been introduced we
can continue to benefit from the tagged system to extend and fix issues we
find then we haven't thought of today. In the same, consistent, concepts.
We can fit more transactions in the same (block) space similarly to SegWit, signatures (witness part) can be pruned by full nodes without causing any
security implications in both solutions.  What SegWit doesn't do is
allowing unused features to not use space. So if a transaction doesn't use
NLockTime (which is near 100% of them) they will take space in SegWit but
not in this proposal. Expect your transactions to be smaller and thus lower
On size, SegWit proposes to gain 60% space. Which is by removing the
signatures minus the overhead introduced.  In my tests Flexible
transactions showed 75% gain.
SegWit also describes changes how data is stored in the block. It creates
an extra 'branch' in the merkle tree.  The Flexible Transactions proposal
is in essence solving the same problem as SegWit and the same solution for
blocks can be applied.  Which means we can have that merkle tree solution
as well. No change.
At the start of the blog I mentioned a list of advantages that the authors
of SegWit included.  It turns out that those advantages themselves are
completely not related to each other and they each have a very separate
solution to their individual problems. The tricky part is that due to the
requirement of old clients staying forwards-compatible they are forced to
push them all into the one 'fix'.
Lets go over them individually;
 Malleability Fixes
Using this new version of a transaction data-structure solves all forms of
known malleability.
 Linear scaling of sighash operations
This has been fixed in the BIP109 2MB hardfork quite some months ago.
 Signing of input values
This is included in this proposal.
 Increased security for multisig via pay-to-script-hash (P2SH)
The *Flexible transactions* proposal outlined in this document makes many
of the additional changes in SegWit really easy to add at a later time.
This change is one of them.
Bottom line, changing the security with a bigger hash in SegWit is only
included in SegWit because SegWit didn't solve the transaction versioning
problem making it trivial to do separately.  With flexible transactions this change can now be done at any time in the
future with minimal impact.
 Script versioning
Notice that this *only* introduces the versioning byte. It doesn't actually
introduce a new version of script.  This is an excellent example where tagged formats shine brighter than a
static memory format that SegWit uses because adding such a versioning tag
is much cleaner and much easier and less intrusive to do with
flexible transactions. Just add a new tag that defaults to version 1 so the
old transactions not having the tag stay consistent.
Imagine having to include "body background=white" in each and every html
page because it was not allowed to leave it out. Thats what SegWit does
right now. Even though it doesn't actually support changing it yet.
 Reducing UTXO growth
I suggest you read this for yourself, its rather interestingly technical and I'm sure many will not
fully grasp the idea.  The bottom line of that they are claiming the
UTXO database will avoid growing because SegWit doesn't allow more
customers to be served.
I don't even know how to respond to such a solution. Its throwing out the
baby with the bath water.
Database technology has matured immensely over the last 20 years, the
database is tiny in comparison to what free and open source databases can
do today. Granted, the UTXO database is slightly unfit for a normal SQL
database, but telling customers to go elsewhere has never worked out for
products in the long term.
 Compact fraud proofs
Again, not really included in SegWit, just started as a basis. The exact
same basis is suggested for flexible transactions, and as such this is
 What do we offer that SegWit doesn't offer?
* A transaction becomes extensible. Future modifications are cheap.
* A transaction gets smaller. Using less features also takes less space.
* We only use one instead of 3 types of encodings for integers.
* We remove technical debt and simplify implementations. SegWit does the
  opposite.
 Conclusions
SegWit has some good ideas and some needed fixes. Stealing all the good
ideas and improving on them can be done, but require a hard fork. This post
shows that the advantages are quite significant and certainly worth it.
We introduced a tagged data structure. Conceptually like JSON and XML in
that it is flexible, but the proposal is a compact and fast binary format.
Using the Flexible Transaction data format allows many future
innovations to be done cleanly in a consistent and, at a later stage, a
more backwards compatible manner than SegWit is able to do, even if given
much more time. We realize that separating the fundamental issues that
SegWit tries to fix all in one go, is possible and each becomes much lower
risk to Bitcoin as a system.
After SegWit has been in the design stage for a year and still we find
show-stopping issues, delaying the release, I would argue that dropping
the requirement of staying backwards compatible should be on the table.
The introduction of the *Flexible Transaction* upgrade has big benefits
because the transaction design becomes extensible.
A hardfork is done once to allow us to do soft upgrades in the future.
The Flexible transaction solution lowers the amount of changes required in
the entire ecosystem. Not just for full nodes. Especially considering that
many tools and wallets use shared libraries between them to actually create
and parse transactions.
The Flexible Transaction upgrade proposal should be considered by anyone
that cares about the protocol stability because its risk of failures
during or after upgrading is several magnitudes lower than SegWit is and
it removes technical debt that will allow us to innovate better into the
Flexible transactions are smaller, giving significant savings after pruning
over SegWit.

@_date: 2016-12-01 19:51:56
@_author: Tom Zander 
@_subject: [bitcoin-dev] New BIP: Hardfork warning system 
I am failing to see how you actually will detect a hard fork with this Maybe its because of this sentence not being very clear to me;
 ?If a generalized block header chain with non-trivial total proof-of-work
   is emerging?
Also, can you explain what you are actually trying to accomplish?
I want to point out that the following part from your motivation is incorrect. A full node would reject a hard forked chain (by definition), there is no risk of them transacting on it.
?When such features are implemented with a hardfork, existing full node implementations would consider such blocks as invalid, and may even ban a peer for relaying such blocks. They are effectively blind to such hardfork rule changes, leaving users to unknowingly transact on a system with potentially different token value. ?

@_date: 2016-12-05 12:58:54
@_author: Tom Zander 
@_subject: [bitcoin-dev] Forcenet: an experimental network with a new 
That commit hacks around it, a new block header fixes it. Subtle difference.

@_date: 2016-02-06 17:25:21
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP proposal: Increase block size limit to 2 
That's because its not.
If you have a node that is "old" your node will stop getting new blocks. The node will essentially just say "x-hours behind" with "x" getting larger every hour. Funds don't get confirmed. etc.
After upgrading the software they will see the new reality of the network.
Nobody said its a problem, because its not.

@_date: 2016-07-26 15:51:56
@_author: Tom 
@_subject: [bitcoin-dev] Reasons to add sync flags to Bitcoin 
What you describe in this part of your message can be done with no forks whatsoever and I think that this is enough. Don't really see the reason for any change in funding.
The idea of sending out a block header is essentially what I called "optimistic mining" and has been described in more detail in my blog here;
The video explains with graphics too...
You may find this interesting :)

@_date: 2016-03-18 11:59:36
@_author: Tom 
@_subject: [bitcoin-dev] BIP 2 promotion to Final 
I'd argue that neither of those two qualifies in that case.
I second BTCDraks' objection.

@_date: 2016-03-23 20:36:00
@_author: Tom 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
I suggest running a spellchecker ;)
Some questions;
* why would you not allow encryption on non-pre-approved connections?
* we just removed (ssl) encryption from the JSON interface, how do you suggest this encryption to be implemented without openSSL?
* What is the reason for using the p2p code to connect a wallet to a node?
I suggest using one of the other connection methods to connect to the node. This avoids a change in the bitcoin protocol for a very specific usecase.
* Why do you want to do a per-message encryption (wrapping the original)? Smaller messages that contain predictable content and are able to be matched to the unencrypted versions on the wire send to other nodes will open this scheme up to various old statistical attacks.
requesting peer after 5 unsuccessfully authentication tries to avoid resource Any implementation of that kind would itself again be open to resource Why 5? Do you want to allow a node to make a typo?
must be hashed (sha256). Both peers keep the SHA256 context of the encryption session. The complete enc message (leaving out the hash itself) must be added to the hash-context by both parties. Before sending a enc command, the sha256 context will be copied and finalized.
You write "the complete communication must be hashed" and every message has a hash of the state until it is at that point.
I think you need to explain how that works specifically.

@_date: 2016-03-25 10:36:28
@_author: Tom 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
If you want to extend the Bitcoin protocol itself, you will have to resolve that. Which many other solutions do (ssh for instance).
It would not be Ok to have an peer-to-peer encryption system that doesn't allow non-pre-approved connections.
You didn't answer the question.
Your use of "probably" makes me wonder if you already have an implementation. Doing any encryption and handshaking design *without* actually having it coded and gone though testing yet makes no sense.
I do not belief Bitcoin will benefit from "design by committee" where a specification is drawn before an implementation is written.
Also, you didn't actually address the attack-vector.
That doesn't take away the resource attack at all.
Apologies, I should have been more clear; the BIP should specify the actual algorithm, otherwise you can't create an implementation from just reading the Also, this may be a good time to ask why you want to have a per-message Practically every single popular end-to-end encryption uses one approach or another were it just encrypts as another layer. (the  L in ssl). You are mixing layers, and unless you do that for a very good reason, or have a very good reason why everyone else is doing it wrong, I suggest using a layered encryption approach.

@_date: 2016-03-25 10:41:04
@_author: Tom 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
What about using some interface, much like the JSON one (but more likely the zeroMQ one) instead? Would that not solve the problem?
I'm thinking that would not be a replacement for a full-node-connection but in Which means that some questions can be asked over that channel that you need authentication for. It would be a much better separation of concerns.

@_date: 2016-03-25 20:42:08
@_author: Tom 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
I guess my question didn't get across. Why would you want to make your usecase do connections over the peer2peer (net.cpp) connection at all?
Mixing messages that are being sent to everyone and encrypted messages is asking for trouble.
Making your private connection out-of-band would work much better.
The statistical attack I mentioned earlier.  Which comes from knowing which plain text messages are being sent over the encrypted channel, So as long as you keep saying you want to encrypt data that identical copies of are being sent to other nodes at practically the same time, you will keep being vulnerable to that.

@_date: 2016-05-09 10:35:32
@_author: Tom Zander 
@_subject: [bitcoin-dev] Compact Block Relay BIP 
You misunderstand the networking effects.
The fact that your node is required to choose which one to set the announce bit on implies that it needs to predict which node will have the best data in the future.
It needs to predict which nodes will not start being incommunicado and it requires them to predict all the things that are not possible to predict in a In networking it is even more true than in stocks; results of the past are no guarantee for the future.
This means you are creating a fragile system. Your system will only work in laboratory situations.  It will fail spectacularly when the network or the internet is under stress or some parts fall away.
Another problem with your solution is that nodes send a much larger amount of unsolicited data to peers in the form of the thin-block compared to the normal inv or header-first data.
Saying this is mitigated by only subscribing on this data from a small subsection of nodes means you position yourself in a situation that I displayed above. A tradeoff of fragile and fast.  With no possible way to make a node automatically decide on a good equilibrium.
Network autorepair systems have been researched for decades, no real solution has as of yet appeared. PHDs are written on the subject and you want to make this a design for Bitcoin based on "[it] should be incredibly effective", I think you are underestimating the subject matter you are dealing with.
Am I to understand that you choose the solution based on the fact that service bits are too expensive to extend? (if not, please respond to my previous question actually answering the suggestion)
That sounds like a rather bad way of doing design. Maybe you can add a second service bits field of message instead and then do the compact blocks correctly.
Wait, you didn't steal the variable length encoding from an existing standard and you programmed a new one?
I strongly suggest you don't reinvent this kind of protocol level encodings but instead steal from something like UTF8. Which has been around for decades.
Please base your standard on other standards where possible.
Look at UTF-8 on wikipedia, you may have "invented" the same encoding that IBM published in 1992.
Just the first (highest) 8 bytes of a sha256 hash.
The amount of collisions will not be less if you start xoring the rest.
The whole reason for doing this extra work is also irrelevant as a spam protection.

@_date: 2016-05-09 12:32:59
@_author: Tom 
@_subject: [bitcoin-dev] Compact Block Relay BIP 
It is required, in the reference of wanting to actually use compact block Apologies, I thought that the term was wider known.  "Laboratory situations" is used where I am from as the opposite of real-world messy and unpredictable So, your measurements may be true, but are not useful to decide how well it behaves under less optimal situations. aka "the real world".
If your peers that were supposed to send you a compact block fail, then you'll end up in exactly that same situation again.  Only with various timeouts in between before you get your block making it a magnitude slower.
In networking this is solved by reacting instead of predicting. The network is not stable. Your protocol design assumes it to be.
Another place where I may have explained better.
This is not about the difference about the two modes of your design.
This is about the design as a whole. As compared to current.
Service bits are exactly the right solution to indicate additional p2p That's all fine and well, it doesn't at any point take away from my point that any specification should NOT invent something new that has for decades had a great specification already.
If you make a spec to be used by all nodes, on the wire, don't base it on your proprietary implementation. Please.
No, you still need to have done a POW.
Next to that, your scheme is 2^32 computations *and* some XORs. The XORs are percentage wise a rounding error on the total time. So your argument also destroys your own addition.
The issue is better eliminated by not allowing nodes to send uninvited large I don't think we're getting anywhere.
I'm not sold on your design and I explained why. I tried explaining in this email some misconceptions that may have appeared after my initial emails. I hope things are more clear.

@_date: 2016-05-09 14:57:10
@_author: Tom 
@_subject: [bitcoin-dev] Compact Block Relay BIP 
A personal attack had no place in the technical discussion, I moved it out.
Initially I asked him to please avoid personal attacks, but I thought better of it and edited my reply to just "ehm...".
The moderators failed to catch his aggressive tone while moderating my post (see archives) for being too aggressive.
I'm sure this message will also not be allowed through. I would not even blame the moderators since this, and Peters, messages were both off-topic.
I thank you for todays talks, it makes me certain of the thing I said this weekend on Reddit that this list is not a suitable place for all the different stakeholders to talk on a level playing field.
If any of you agree, please urge the approach that we replace the entire moderation team with a new one. This will be the least painful solution for everyone in the ecosystem.
Thanks again.

@_date: 2016-05-12 08:29:13
@_author: Tom 
@_subject: [bitcoin-dev] Making AsicBoost irrelevant 
Comparing apples and oranges.
Altcoins have their own genesis block, the example Timo was talking about was a fork in the Bitcoin blockchain.
But its good to know you don't mind a fork in the Bitcoin chain, I'll remember

@_date: 2016-11-16 15:38:21
@_author: Tom Zander 
@_subject: [bitcoin-dev] [BIP Proposal] Buried Deployments 
Here is my thinking.
The BIP process is about changes to a living project which is the bitcoin This specific BIP got accepted and we know in the blockchain that
this event (the acceptance) is recorded.
Before a certain block the rules were one way, after they were changed.
I have no problem with changing the *code* to be less complex because it already knows the past. A checkpoint is the same, it is the registeration of a past event.
This makes software less complex and still capable of checking the entire blockchain from genesis.
I don?t see any harm in this change. I see prudent software engineering

@_date: 2016-11-21 21:28:51
@_author: Tom Zander 
@_subject: [bitcoin-dev] Flexible Transactions. 
Thanks for your email, Russell.
Unfortunately you waited 6 weeks with writing this and the problem you are seeing has been fixed quite some time ago.
Thanks again for reviewing, though!

@_date: 2016-11-25 16:25:58
@_author: Tom Zander 
@_subject: [bitcoin-dev] The Excessive-Block Gate: How a Bitcoin Unlimited 
What exactly do you think is a ?change? in bitcoin here?
The concept of proof-of-work is that the longer a chain, the higher probability that that one will be extended for the simple reason that another chain will have to show a higher amount of proof of work to ?win?.
As far as I understand the document from Peter, there is no change there at all. Only chains with more POW will win.
Or, to answer your example, miners will prefer to extend the chain with the most POW.
The other fact stays the same as well, if you protect from reorgs by expecting more confirmations. Nothing changes here either. The common-sense 6 confirmations for things like exchange-deposits keep having the same The basic idea that we have a 3 or 4 deep fork is a huge problem in Bitcoin. It hasn?t happened for ages, and we like it that way. The miners like it that way too. Its disruptive.
The is a problem that is not created by the ?excessive block? concept. It does, however, provide a possible solution to this very far-fetched problem.
You should also realize that the policy of a miner is stored in the That said, I?m sure there are improvements to be made to the policy that BU uses. But since this is a node-local policy, the consensus rules are not affected by it.

@_date: 2016-11-26 16:01:16
@_author: Tom Zander 
@_subject: [bitcoin-dev] The Excessive-Block Gate: How a Bitcoin Unlimited 
What you appear to want to say is that it is in everyones best interest to avoid short forks.
Its impossible to guarentee they can't happen, but very possible to minimize No, there are no block-size-negotiations on chain.
The blockchain is used here for one purpose, to state the position of individual miners. But what may not be clear is that you can use this as a time-stamped way to hold them to it. Which means that if they lie (by rejecting a block), everyone in the world will be able to individually verify that fact and their credibility will be affected.
Which will not help their case next time any block size negotiations will

@_date: 2016-11-27 08:47:00
@_author: Tom Zander 
@_subject: [bitcoin-dev] The Excessive-Block Gate: How a Bitcoin Unlimited 
As a point of interest, last week I merged into Classic the same concept. Classic will now respect the EB limit and put it in the coinbase.
Your surprise may come from the difference in cost vs. expected earnings of creating a block, which is quite significant.

@_date: 2016-10-15 12:01:32
@_author: Tom Zander 
@_subject: [bitcoin-dev] DPL is not only not enough, 
On Friday, 14 October 2016 04:51:01 CEST Daniel Robinson via bitcoin-dev This is a very important point and a huge step forward in my opinion.
The downside of MIT/BSD licenses is that companies can take and not give back. It doesn't build a community and commonly-shared property. Copyleft allows people to take and embrace, but if they extend they have to give back. Which is fair, you build it on their stuff...

@_date: 2016-10-15 13:00:35
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP 2 revival and rework 
My suggestion (sorry for not explaining it better) was that for BIPS to be a public domain (aka CC0) and a CC-BY option and nothing else.
I like you agree with that part, but I see you added two licenses.
Do you have a good reason to add MIT/BSD to that list? Otherwise I think we Using code-specific licenses (including the GPL) for documentation and specifically a specification is a really poor fit and doens't make much sense.
Well, it has this sentence;
Which is a bit odd in light of the initial email from Luke that suggested we drop the Open Publication License and we use the CC ones instead in addition to the public domain one.
Thats odd, you just stated you like the public domain (aka CC0) license, yet you encourage the BIP2 that states we can no longer use public domain for BIPs... Did you read it?
It says;
 ?Public domain is not universally recognised as a legitimate action, thus
  it is inadvisable.? [1]
This list has not seen a lot of traffic, if you want to make sure people keep using the BIP process, I think you need to reach out to the rest of the community and make sure this has been heard and discussed.
Moving forward the way it is now will likely deminish the importance of the BIP process.
I strongly suggest people make very clear any and all changes that are proposed and defend each of them with reasons why you want to change things.
1) if you write as a rationale "In some jurisdictions, public domain is not recognised as a legitimate legal action" then you can at least name those jurisdictions and explain how they *do* support things like GPL. Burden of proof is on the man who wants to change things.
It looks fishy when lawyers disagree. See the CC wikipedia page;
 "public domain: cc0 Freeing content globally without restrictions"

@_date: 2016-10-15 16:21:41
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP 2 revival and rework 
OPL was the only allowed option apart from CC0.
I dual licensed it so future acceptance of the CC-BY-SA one may mean someone can just remove the OPL from the BIP and no futher action or permission is needed from all the authors.
It does, actually.
That's odd as PD was never the only copyright option.

@_date: 2016-10-16 16:56:36
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP 2 revival and rework 
You suggest that a person can dual license something under both CC-BY-SA as well as under public domain.
That means you don't understand copyright,
See, all licenses are based on you having copyright. In contrast; public domain is not a license, it means a certain text does not have copyright. Public domain is the lack of copyright.
One text can not at the same time have copyright and not have copyright, making your assumption impossible.
Hence, with PD not explicitly being allowed, you can't use PD.
Personally I prefer copyleft licenses, so the lack of PD is fine with me. The lack of a good copyleft we can use in BIPs is what got me involved in this discussion in the first place.

@_date: 2016-10-16 16:58:26
@_author: Tom Zander 
@_subject: [bitcoin-dev] Start time for BIP141 (segwit) 
The fallow period sounds waaaay to short. I suggest 2 months at minimum since anyone that wants to be safe needs to upgrade.
Also, please comment on why you won't use the much more safe and much smaller Flexible Transactions.
On Sunday, 16 October 2016 16:31:55 CEST Pieter Wuille via bitcoin-dev

@_date: 2016-10-16 18:42:26
@_author: Tom Zander 
@_subject: [bitcoin-dev] Start time for BIP141 (segwit) 
The question you asked them was likely about the block size. The main difference is that SPV users do not need to update after BIP109, but they do need to have a new wallet when SegWit transactions are being sent to them.
This upgrade affects also end users, not just businesses etc.
Personally, I'd say that 2 months is even too fast.

@_date: 2016-10-16 20:20:50
@_author: Tom Zander 
@_subject: [bitcoin-dev] Start time for BIP141 (segwit) 
On Sunday, 16 October 2016 09:47:40 CEST Douglas Roark via bitcoin-dev There have been objections to the way that SegWit has been implemented for a long time, some wallets are taking a "wait and see" approach.  If you look at the page you linked[1], that is a very very sad state of affairs. The vast majority is not ready.  Would be interesting to get a more up-to-date Wallets probably won't want to invest resources adding support for a feature that will never be activated. The fact that we have a much safer alternative in the form of Flexible Transactions may mean it will not get activated. We won't know until its actually locked in.
Wallets may not act until its actually locked in either. And I think we should respect that.
Even if all wallets support it (and thats a big if), they need to be rolled out and people need to actually download those updates.
This takes time, 2 months after the lock-in of SegWit would be the minimum safe time for people to actually upgrade.
1)

@_date: 2016-10-16 20:54:04
@_author: Tom Zander 
@_subject: [bitcoin-dev] Start time for BIP141 (segwit) 
Then don't use BIP9...
Honestly, if the reason for the too-short-for-safety timespan is that you want to use BIP9, then please take a step back and realize that SegWit is a contriversial soft-fork that needs to be deployed in a way that is extra safe because you can't roll the feature back a week after deployment.
All transactions that were made in the mean time turn into everyone-can-
spent transactions.
I stand by the minimum of 2 months. There is no reason to use BIP9 as it was coded in an older client. That is an excuse that I don't buy.

@_date: 2016-10-16 22:08:29
@_author: Tom Zander 
@_subject: [bitcoin-dev] Start time for BIP141 (segwit) 
Naturally, I fully agree.
It seems I choose the wrong words, let me rephrase;
You can't roll the SegWit back a week after people are allowed to send segwit transactions (lock-in + fallow period). All transactions that were made in the mean time turn into everyone-can- spent transactions.
Because the network as a whole and any implementation is unable to roll back in an environment where SegWit is a contriversial soft-fork, it is super important to make sure that it is properly supported by all miners. This takes time and the risk you take by pushing this is that actual real people loose actual real money because of the issue I outlined inthe previous I hope the above explains the actual security issue better.

@_date: 2016-10-16 22:45:19
@_author: Tom Zander 
@_subject: [bitcoin-dev] (no subject) 
I am not afraid of people finding issues with my code, I'm only human. Would appreciate you reporting actual issues instead of hinting at things here.
Can't fix things otherwise :)
But, glad you brought it up, the reason that FT is safer is because of the amount of conceps that SegWit changes in a way that anyone doing development on Bitcoin later will need to know about them in order to do proper I counted 10 in my latest vlog entry.  FT only changes 2.
Its safer because its simpler.
The unit test doesn't hit any of them. Valgrind only reports such possibly exploitable issues in secp256k and CKey::MakeNewKey. The same as in Core.
I don't doubt that your 2 minute look shows stuff that others missed, and that valgrind doesn't find either, but I'd be really grateful if you can report them specifically to me in an email off list (or github, you know the More feedback will only help to make the proposal stronger and even better. I think FT fits the bill just fine :)  After your 2 minute look, take a bit longer and check the rest of the code. You may be surprised with the simplicity of the approach.

@_date: 2016-10-16 22:58:31
@_author: Tom Zander 
@_subject: [bitcoin-dev] Start time for BIP141 (segwit) 
On Sunday, 16 October 2016 12:49:47 CEST Douglas Roark via bitcoin-dev As I said, it would be nice to get an updated version so we can see more than 20% readyness of wallets.
The wallet devs not caring enough to update the status should be a worrying sign, though.
SegWit is probably the most disruptive and most invasive change ever made to Bitcoin. We have miners actively saying they don't like it and this makes it a contriversial upgrade which means the network may split and other issues.
Your "wallets will probably work just fine" comment is honestly not the answer to make people put faith in the way that this is being vetted and Its an alternative and brought up in that vain. Nothing more. Feel free to respond to the BIP discussion (134) right on this list if you have any opinions on it. They will be on-topic there. No problems have been found so Lets get back to the topic. Having a longer fallow period is a simple way to be safe.  Your comments make me even more scared that safety is not taken into account the way it would.
People are not even acknowledging the damage a contriversial soft fork of the scope and magnitude of SegWit can have, and a simple request to extend the fallow time for safety is really not a big deal.
SegWit has been in development for 18 months or so, what is a couple of extra week??
I would just like to ask people to take the safety of Bitcoin serious. This discussion and refusal to extend the safety period is not a good sign.

@_date: 2016-10-17 13:17:39
@_author: Tom Zander 
@_subject: [bitcoin-dev] Start time for BIP141 (segwit) 
As Marek wrote just minutes before your email came in; companies will not roll out their updates until it locks in. Peter Todd says the same thing.
So your assumption that the lock-in time is the END of the upgrading is false. Thats only the case for miners.
The entire point here is that SegWit is much bigger than just full nodes (including miner).
An entire ecosystem of Bitconin will have a need to upgrade.
I understand people saying that non-miners don't *need* to upgrade in order to avoid being kicked of the network, but truely, thats a bogus argument.
People want to actually participate in Bitcoin and that means they need to understand all of it. Not just see anyone-can-spend transactions.
I think its rather odd to think that developers on this list can decide
the risk profile that Bitcoin using companies or individuals should have.
There are a bunch of really large assumptions in there that I disagree with.
First of all, miners running the latest software doesn't mean the software is free from flaws. Everyone makes mistakes. People that see a way to abuse the system may have found things and are not reporting it because they want to abuse the flaw for their own gains. Which is exactly what happened with The amount of code and the amount of changes in SegWit makes this a very dangerous change in (of?) Bitcoin. I counted 10 core concepts in Bitcoin being changed with it. We don't yet know how they will interact. We can?t.
You are asking people to create everyone-can-spend transactions that would mean a loss of funds to everyone that used it if we do find a major flaw and need to rollback.
The gamble is rather uncomforable to many...

@_date: 2016-09-20 19:15:45
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
As the title suggests, I would like to formally request the assignment of a BIP number for my FT spec.
Thank you!
Source;   BIP: ??
  Title: Flexible Transactions
  Author: Tom Zander   Status: Draft
  Type: Standards Track
  Created: 2016-07-27
This BIP describes the next step in making Bitcoin's most basic element,
the transaction, more flexible and easier to extend. At the same time this
fixes all known cases of malleability and resolves significant amounts of
technical debt.
Flexible Transactions uses the fact that the first 4 bytes in a transaction
determine the version and that the majority of the clients use a
non-consensus rule (a policy) to not accept transaction version numbers
other than those specifically defined by Bitcoin.
This BIP chooses a new version number, 4, and defines that the data
following the bytes for the version is in a format called Compact Message
Format (CMF). CMF is a flexible, token based format where each token is a
combination of a name, a format and a value. Because the name is added we
can skip unused tokens and we can freely add new tokens in a simple manner
in future. Soft fork upgrades will become much easier and cleaner this
This protocol upgrade cleans up past soft fork changes like BIP68 which
reuse existing fields and do them in a much better to maintain and easier
to parse system. It creates the building blocks to allow new features to be
added much cleaner in the future.
It also shows to be possible to remove signatures from transactions with
minimal upgrades of software and still maintain a coherent transaction
history. Tests show that this can reduce space usage to about 75%.
Token based file-formats are not new, systems like XML and HTMl use a
similar system to allow future growth and they have been quite successful
for decades in part because of this property.
Bitcoin needs a similar way of making the transaction future-proof because
re-purposing not used fields for new features is not good for creating
maintainable code.
Next to that this protocol upgrade will re-order the data-fields which
allows us to cleanly fix the malleability issue which means that future
technologies like Lightning Network will depend on this BIP being deployed.
At the same time, due to this re-ordering of data fields, it becomes very
easy to remove signatures from a transaction without breaking its tx-id,
which is great for future pruning features.
=== Tokens ===
In the compact message format we define tokens and in this specification we
define how these tokens are named, where they can be placed and which are
optional.  To refer to XML, this specification would be the schema of
a transaction.
CMF tokens are triplets of name, format (like PositiveInteger) and value.
Names in this scope are defined much like an enumeration where the actual
integer value (id, below) is equally important to the written name.
If any token found that is not covered in the next table will make the
transaction that contains it invalid.
{| class="wikitable"
! Name !! id !! Format !! Default Value !! Description
byte in the txid calculation
spending (applied to previous TxInPrevHash)
outputs following
anyone parsing the transaction
=== Scripting changes ===
In the current version of Bitcoin-script, version 1, there are various
opcodes that are used to validate the cryptographic proofs that users have
to provide in order to spend outputs.
The OP_CHECKSIG is the most well known and, as its name implies, it
validates a signature.
In the new version of 'script' (version 2) the data that is signed is
changed to be equivalent to the transaction-id. This is a massive
simplification and also the only change between version 1 and version 2 of
=== Serialization order===
The tokens defined above have to be serialized in a certain order for the
transaction to be well-formatted.  Not serializing transactions in the
order specified would allow multiple interpretations of the data which
can't be allowed.
There is still some flexibility and for that reason it is important for
implementors to remember that the actual serialized data is used for the
calculation of the transaction-id. Reading and writing it may give you a
different output and when the txid changes, the signatures will break.
At a macro-level the transaction has these segments. The order of the
segments can not be changed, but you can skip segments.
{| class="wikitable"
!Segment !! Description
The TxId is calculated by taking the serialized transaction without the
Signatures and the TxEnd and hashing that.
{| class="wikitable"
!Segment !! Tags !! Description
input the PrevHash always has to come first
TxEnd is there to allow a parser to know when one transaction in a stream
has ended, allowing the next to be parsed.
Notice that the token ScriptVersion is currently not allowed because we
don't have any valid value to give it. But if we introduce a new script
version it would be placed in the outputs segment.
=== Script v2 ===
The default value of ScriptVersion is number 2, as opposed to the version 1
of script that the is in use today.  The version 2 is mostly identical
to version one, including upgrades made to it over the years and in the future. The only exception is that the OP_CHECKSIG is made dramatically
simpler.  The input-type for OP_CHECKSIG is now no longer configurable, it is
always '1' and the content that will be signed is the txid.
TODO: does check-multisig need its own mention?
=== Block-malleability ===
The effect of leaving the signatures out of the calculation of the
transaction-id implies that the signatures are also not used for the
calculation of the merkle tree.  This means that changes in signatures
would not be detectable. Except naturally by the fact that missing or
broken signatures breaks full validation. But it is important to detect
modifications to such signatures outside of validating all transactions.
For this reason the merkle tree is extended to include (append) the hash of
the v4 transactions (and those alone) where the hash is taken over a
data-blob that is build up from:
1. the tx-id
2. the CMF-tokens 'TxInScript'
=== Future extensibility ===
The NOP_1x wildcard used in the table explaining tokens is actually a list
of 10 values that currently are specified as NOP (no-operation) tags.
Any implementation that supports the v4 transaction format should ignore
this field in a transaction. Interpreting and using the transaction as if
that field was not present at all.
Future software may use these fields to decorate a transaction with
additional data or features. Transaction generating software should not
trivially use these tokens for their own usage without cooperation and
communication with the rest of the Bitcoin ecosystem as miners certainly
have the option to reject transactions that use unknown-to-them tokens.
==Reference Implementation==
Bitcoin Classic includes this in its beta releases and a reference
implementation can be found at;
To be determined
[

@_date: 2016-09-21 11:32:30
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
How is this a regression? Can you explain what functionality is lost please?
Maybe for the next version of script :)
The transaction is invalid...
Because the txid based ones are not going away. So the number of transactions in the block can be used to determine when the pure tx-id segment stops and when the v4 hashes begin.  Then its up to the client to rebuild the tree from that list based on the larger input set to get the same root-node.
I clarified many little things on my clone of the bips, check there if you want to see the details.

@_date: 2016-09-21 11:32:33
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
Thanks for your email Peter!
This is addressed in the spec; ?The way towards that flexibility is to use a generic concept made popular
various decades ago with the XML format. The idea is that we give each
field a name and this means that new fields can be added or optional fields
can be omitted from individual transactions?
Please argue your case.

@_date: 2016-09-21 14:58:02
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
There is a lot of overlap between different binary formats. Looking through the on-the-wire protocol you'll see that my spec is very similar. Practically all the advantages of protobuf are present in CMF. I can write you a java parser if you want, it should be easy to port from Qt/C++ code :)
CMF: There is no tool support needed, just one or two classes. Which personally I think is an advantage.
Some advantages of CMF over protobuf from the top of my head;
* It reuses the var-int parsing that Bitcoin uses (which is itself slightly different from others).
* zero-copy support (not relevant for this bip, though).
* Additional values addition (i.e. adding new data) is .. tricky in protobuf.
* In my experience parsing a message manually (like a SOX parser) is much better in reporting errors and detecting wrong usages than auto-generated code (but personally I'm not much a fan of auto-generated APIs) at all...
* Generated parsing/writing code will not be as fast as we can make it.
* CMF is more compact (uses less bytes) for its messages.
Protobuf is something I've used before and I think we can do better. I think that CMF together with some support classes can do this better.

@_date: 2016-09-22 10:47:03
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
LockByBlock and LockByTime are still TODOs because I didn't have time to go
in-dept into how BIP68 does the encoding.
The intent is that these tags, while loading, will set the sequence integer in the txin as the old version does. And while saving we do the reverse.
In other words; the lack of sequence number in the saved format doesn't affect the in-memory format of the transaction. The in-memory version is the one that script will operate on.
This means that there is no change in how CSV will work before and after on any level other than serialisation.
Flexible Transactions is definitely meant to support the Lightning Network, so any problems you find is something we should solve before it ships.
Thanks for your email!

@_date: 2016-09-22 10:56:31
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
It refers to the external specification which is linked at the bottom.
In that spec you'll see that "Integer" is the standard var-int that Bitcoin has used for years.
How does one signals an optional field except of in the spec? Thats the job of a specification.
Did you miss this in the 3rd table ?  I suggest clicking on the github bips repo link as tables are not easy to read in mediawiki plain format that the email contained.
Also in the external CMF spec.
I agree, that would be bad. Luckily that you just missed the link :)
Here it is;
Being hardcoded and never communicated is what the current format does to. How does that "remove flexibility".
Also read my reply to Peter Todd on why this is flexible.
It is not.
Thanks for asking, I understand that the CMF spec is useful to see as well. Hopefully you can now review it properly since I linked to it above.

@_date: 2016-09-22 14:09:38
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
If luke-jr thinks I should submit CMF as a BIP, I can certainly do that.
Luke, what do you think?
I don't have a preference either way.
I'm sorry, I'm not following you here. Is there a question?
I am not very well versed in mediawiki tables, and I found github has some incompatibilities too.
The markdown one looks better;
I have to disagree. That is not malleability. Creating a new document and re-
signing it is not changing anything. Its re-creating. Something that the owner of the coin has every right to do.
Sorry, what is evident? You seem to imply that it is uncommon that you can create two transactions of similar intent but using different bytes.
You would be wrong with this implication as this is very common. You can just alter the order of the inputs, for instance.
I am unable to see what the point is you are trying to make. Is there a question or a suggestion for improvement here?
Maybe you missed this line;   ?TxInPrevHash and TxInPrevIndex
   Index can be skipped, but in any input the PrevHash always has
   to come first?
If you still see something alarming, let me know.
You can look at the code in Bitcoin Classic and notice that it really isn't anything complicated or worrying.
Hmm, it looks like you are mixing terminology and abstraction-levels.  OP_NOP is a field from script and there is no discussion about any rejection based on script in this BIP at all.
Rejection of transactions is done on there being unrecognised tokens in the transaction formatting itself.
Thank you for your email to my BIP, I hope you got the answers you were looking for :)

@_date: 2016-09-22 20:37:29
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
I think you misunderstand tagged systems at a very basic level.  You think that html can only use a bold tag  once in a document? Thats equivalent to what you are saying.
Your comment is rather embarrassing, I have to point out. You may want to read a bit more before you comment more.

@_date: 2016-09-22 20:47:50
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
The argument that optional fields can be omitted is not applicable to required fields, you are correct. That should be rather obvious because required fields are not optional fields.
Probably a tiny bit more complex as the current format assumes a lot more.
You may have misread my email because there was no argument made towards complexity. The argument was towards flexibility.
Please consider that I'm not going to search for something based on a vague reference like that, if you want to convince me you could you at least provide a URL?
You want me to see the value of your idea, I think you should at least provide the argument. Isn't that fair?
Thanks for your email Peter, would love you to put a bit more time into understanding flexible transactions and we can have a proper discussion about it.

@_date: 2016-09-22 22:07:33
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
At this point I don't know what it should look like, I have not had time to look deeply into BIP68.  Is this what you would suggest it to look like?
I rather figured spending limitations would be assigned to an output, not an input.
It can be, and likely should be.  This BIP doesn't pretend to be finished I welcome any and all discussion about this, it only serves to make the end result stronger!

@_date: 2016-09-23 15:13:10
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
Practically all tagged formats make ordering a requirement, so indeed this is relevant, and not unique.
For instance if you write;
   Some line Another line3rd line
you can get a good idea of how ordering is relevant. You can reuse any item many times.
Whenever there is a possible confusion the specification specifically explains which order to use.
I'm not sure what you mean with the idea this;
It looks like you assume there is some opening and closing tags, since otherwise there would be no nesting.
Such tags are not intended, nor documented.
I quoted parts of the spec in your previous email stating the same thing, but I'll repeat here.
Any place that has any sort of possibility to be ambiguous is specified specifically to have an order.  This makes writing and parsing easier.
Since you wrote two emails now with the same issue, and I addressed it twice, I would urge you to write out some examples which may be confusing and if you find that the spec is indeed missing requirements then please share it with us.  I did this some time ago and it helps understanding the ideas by having actual explicit examples.  I am not aware of any sort of ambiguities that the spec allows.

@_date: 2016-09-23 15:17:52
@_author: Tom 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
I am not a fan of redefining dictionary words. I'll stick to the universally excepted one, thanks.
This is addressed here;

@_date: 2016-09-23 16:37:39
@_author: Tom 
@_subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT 
Can you walk us through a real live usecase which this solves?  I read it and I think I understand it, but I can't see the attack every giving the attacker any benefit (or the attacked losing anything).

@_date: 2016-09-24 11:41:57
@_author: Tom 
@_subject: [bitcoin-dev] BIP 2 revival and rework 
My suggestion would be that we replace OPL as an allowed license with one or two Creative Commons licenses. Following the suggestion from the OPL creators themselves.
According to Wikipedia;
I'd suggest saying that "Share alike" is required and "Attribution" is Executive summary; give the user the choice (next to public domain) between CCO and BY-SA

@_date: 2016-09-24 11:37:52
@_author: Tom 
@_subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT 
Thank you Luke, this makes it clearer.
It doesn't change that this scenario is an attack that doesn't give the attacker any benefit and the attacked doesn't loose anything either (as Dave pointed out).
This is a completely academical problem that assumes so many stupid mistakes from software and from people that its very unlikely. On top of that it assumes a rather lengthy 51% attack in concert with this already extremely unlikely usecase.
In the scenario you assume stupid people and then you solve it by requiring the victim to suddenly be super smart and use a solution specifically designed for this super unlikely usecase that probably will never actually I don't buy it.

@_date: 2016-09-27 11:51:40
@_author: Tom 
@_subject: [bitcoin-dev] Proposed BIP-1 change removing OPL licensing 
Documentation and code can have different licenses, the sole existence of various documentation licenses attests to that point.
Shipping your docs under a separate licence has never been a problem before, so you don't have to worry that you can't ship documentation with code.
That said, I wrote my suggestion in reply to Luke's BIP2 revival which is a more formal suggestion of a solution. Maybe you can ACK that one instead?
Last, in preparation of acceptance of BIP2 I changed the licence of my BIP to be dual-licensed.  Now its also available under a Creative Commons license.
Have a nice day!

@_date: 2017-04-04 13:16:08
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP proposal: Generalized version bits voting 
Please do elaborate :)
The meat of the proposal is missing.
I agree that the type of forks are rather irrelevant to the voting mechanism. As we remember that BIP109 used a voting bit too.
The per-bit (lets call that per-proposal) parameter threshold and windowsize are a different matter though, based on the next paragraph you wrote;
The entire point of BIP9 is to allow nodes that do not know about an upgrade to still have a functional state machine. But I don?t see how you can have a state machine if the two basic variables that drive it are not specified.
Now, to be clear, I am a big fan of making the window size and the threshold more flexible.
But in my opinion we would not be able to have a state machine without those variables in the actual BIP because old nodes would miss the data to transition to certain states.
Maybe an idea; we have 30 bits. 2 currently in use (although we could reuse the CSV one). Maybe we can come up with 3 default sets of properties and when a proposal starts to use bit 11 it behaves differently than if it uses

@_date: 2017-04-04 13:47:57
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP draft: Extended block header hardfork 
That change would not be a consensus change and thus free to make any day.

@_date: 2017-04-04 17:32:47
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP draft: Extended block header hardfork 
Can you tell me where it is enforced?
The only place I found was here;
which doesn?t enforce it, all that code does is check that the txid is unknown or fully spent.
And since the below idea from Russel would change the txid, it would seem no full client would reject this.
Maybe its in a BIP, but I can?t find it in the code.

@_date: 2017-04-04 18:17:02
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP draft: Extended block header hardfork 
I notice you didn?t read the actual full line :)
If you click on it, you?ll notice at the end of the line it says;
so, this is about BIP34.

@_date: 2017-04-05 12:08:51
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP proposal: Generalized version bits voting 
Can you explain how miners are irrelevant if the upgrade is not a soft fork?

@_date: 2017-04-11 09:59:33
@_author: Tom Zander 
@_subject: [bitcoin-dev] A Small Modification to Segwit 
The version field is still needed to actually allow future block version upgrades. We would cut off our road forward if that were to be blocked.

@_date: 2017-04-14 21:12:19
@_author: Tom Zander 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
Here is a list of clear alternatives;
See the BIPs with number 010[1-8].

@_date: 2017-04-14 21:20:39
@_author: Tom Zander 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
This is false,
a segwit transaction to the miner you describe is an "everyone can spend" transaction, and as such a miner that does not validate the segregated area in a post-segwit world will be able to create blocks that will not validate for segwit miners by including a transaction that spends a SW tx.
This would then lead to a chain-fork as the SW miners reject it and the non-
SW miners continue to mine on it.

@_date: 2017-04-14 21:26:14
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP proposal draft: BIP43 "purpose" allocation 
Thinking about this a bit, I support this proposal for a BIP.
This is not Bitcoin, but address types are bound to meet in meat-space and it would be good to have a central place where this is defined.
I would very much appreciate someone that worked on BIP32/BIP43 itself to comment on the details.
Quoting bip 43;
"We encourage different schemes to apply for assigning a separate BIP
number and use the same number for purpose field, so addresses won't be
generated from overlapping BIP32 spaces."
On Wednesday, 12 April 2017 12:02:37 CEST Nick Johnson via bitcoin-dev

@_date: 2017-04-14 22:34:26
@_author: Tom Zander 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
I expected you to know this, but ok, I'll explain.
A policy rule is not a protocol rule, a mining node is certainly not guarenteet to have it, and those that do typically make it configurable.
If you depend on one implementation and user configuration for the avoidance of chain forks, you are going to have a hard time.
Thanks for your thoughtful reply, though.

@_date: 2017-04-14 22:58:15
@_author: Tom Zander 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
Thanks for confirming my point.
This means that Gregory was incorrect saying that there is no risk to a non-
upgraded node on a SegWit network mining a new invalid block. That risk is most definitely there for any miners "left behind" operating on a different set of consensus rules than the majority.
Kind of obvious, when you think about it.

@_date: 2017-04-18 12:50:31
@_author: Tom Zander 
@_subject: [bitcoin-dev] Small Nodes: A Better Alternative to Pruned Nodes 
The idea looks a little overly complex to me.
I suggested something similar which is a much simpler version;

@_date: 2017-04-20 11:46:33
@_author: Tom Zander 
@_subject: [bitcoin-dev] Small Nodes: A Better Alternative to Pruned Nodes 
I don?t really see the problem here, even if your math is a off. (Statistics is difficult, I know). Connecting to many nodes to download faster is really not an issue and already happens.
You make the assumption that this new mode of pruning will be used by 100% of the network, this is not how distributed systems work.

@_date: 2017-04-21 10:27:36
@_author: Tom Zander 
@_subject: [bitcoin-dev] Small Nodes: A Better Alternative to Pruned Nodes 
Nice to join bitcoin-dev, Andrew. Haven?t seen you post here before.
I?m not sure how you reached that strange number, but I have to point out your number is quite useless.
The actual amount of nodes you need to be 100% sure you find all the blocks when you know each node will have a completely random 25% of the blocks is not a maths problem that leads to a single answer because of the randomness The actual answer is a series of probabilities.
Same as the answer is to the age old question; how many coin flips does it take to be 100% certain I have at least one ?Heads?.
In our blocks retrieval scenario; with num-nodes < 4, probability is zero.
There is a really really small chance you will get 100% of the blocks with 4 nodes (actual number depends on the amount of total blocks you are looking And this goes up as you add more nodes, but never reaches 100%
At the other end of this question you can ask what the chance is of at least one block being lost when there are N nodes, a block nobody has. That chance is small with current > 6000 nodes, but not zero (a second reason why the previous parag never reaches 100%).
Bottom line, it is silly to assume 100% of the nodes would be partial-
pruning, and if you continue on that path you will only have probabilities to predict how many nodes it takes to have 100% coverage, exact numbers are worse than useless, they are misleading.
As I said in my initial email, statistics is hard. Crypto is much easier in that it is absolute. Either correct or false. Never in between.
To repeat, the goal of this pruning method is not to replace a full ?archival? node, the goal of this pruning node is to provide an improvement over the current pruning node which stops any and all serving of historical Anyone that feels the need to talk about pruning modes like 100% of the full nodes will run it are in actual fact not talking about the real world. Distributed systems will never (and should never) end up being a mono-
culture. Diversity is the essential thing you aim for.
I would suggest we focus on the real world and not on irreleavant math experiments that only lead to confusion.

@_date: 2017-02-14 19:01:03
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP150/151 concerns and some comments 
What about allowing trusted users connecting on a different connection. Much like the RPC one.
Make that one encrypted. Different usecase, different connection.

@_date: 2017-02-16 16:10:46
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP150/151 concerns and some comments 
On Tuesday, 14 February 2017 22:01:51 CET Jonas Schnelli via bitcoin-dev The RPC one. Which I think is JSON.
Your usecase is essentially just calling sendRawTransaction. Don?t overcomplicate things.

@_date: 2017-01-02 20:01:11
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP - 'Block75' - New algorithm 
This proposal doesn't change the block size, it only changes the maximum block size. Which is expected, nothing bad there.
The direct consequence of this, though is that the miners set the maximum block size. Because they decide on the actual created block size.
This leads me to the simple question why we can't just give the miners full control of the maximum block size directly?
The fact of the matter is that miners have for the full history of Bitcoin been able to set the block size, until they hit the 1MB limit.
And your proposal keeps that property, but why have a maximum in the

@_date: 2017-01-02 21:35:40
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP - 'Block75' - New algorithm 
If the input of your math is completely free and human created, how does it follow that it was math that created it ?
Why do you want it math created anyway?
A maximum is needed, yes. But does it have to be part of the protocol?
A simple policy which is set by node operators (reject block if greater than X bytes) will solve this just fine, no?

@_date: 2017-01-02 23:01:08
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP - 'Block75' - New algorithm 
Policy is thus expanded to allow an individual node to reject blocks that are technically speaking valid, just unacceptable to them.
It would be fun to ponder of the effect of that when applied to many nodes. Many people already have pondered that question and find it intriguing. So don't reject it out of hand :)

@_date: 2017-01-02 23:33:16
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP - 'Block75' - New algorithm 
In actual fact the block size *is* set by miners, not math. And always has In your proposal the max blocksize continues to be set by miners as a secondary effect of them choosing the block size.
Saying the max is actually math is painting an illusion that is rather thin and easy to see through because every single usecase for your suggestion starts with the choice of blocksize that a human makes. There is not really any other input except some rather simple algorithm.
This is ignoring history where miners have successfully set policy on block size for years now.
Not sure about your "obviously". I don't agree. In fact, there is plenty of reason to think it does work.
Miners have always been the ones to decide on the block size, and they have always done this in a coordinated fashion. This is a natural consequence of the rather elegant (economic) design of Bitcoin.
*  Miners earn more fee-based income when they produce bigger blocks.
*  Miners take more risk of their blocks being orphaned with bigger blocks.
*  Miners want to avoid emptying the memory pool every block as that removes a total need for users to pay fees.
*  Miners want to make sure the mempool does not become backlogged because users that do not see their transactions confirmed will get disappointed and find other means to do payments. Which hurts the price and in effect hurts the miners income.
This behaviour in block size means blocks will not get huge and they will not stay small either, because there are reasons for both. And so the size will be something in the middle.

@_date: 2017-01-06 11:16:28
@_author: Tom Zander 
@_subject: [bitcoin-dev] Bitcoin Classic 1.2.0 released 
Bitcoin Classic version 1.2.0 is now available from;
This is a new major version release, including new features, various bugfixes and performance improvements.
This release marks a change in strategy for Bitcoin Classic, moving from the very conservative block size proposal based on compromise to one where Classic truly innovates and provides a long term solution for the market to choose and leave behind the restrictions of the old.
The most visible change in this version is the decentralised block size solution where node operators decide on the maximum size.
Bitcoin Classic is focused on providing users a way to get onto the Bitcoin network using a high quality validating node for a large set of use cases. Classic presents top notch quality processes in this release, to help anyone running Bitcoin.
We include in this release various projects with the beta label. People who want to use the Classic node as an on-ramp to Bitcoin will find them interesting. These projects will need to be enabled in the config by those that want to test them.
More background information on this release and Classic can be seen in this video: The full release notes are on github at

@_date: 2017-01-07 16:15:30
@_author: Tom Zander 
@_subject: [bitcoin-dev] Bitcoin Classic 1.2.0 released 
To explain why I didn't write that;
Bitcoin Classic is not incompatible with the current Bitcoin network and its consensus rules.

@_date: 2017-01-08 00:08:29
@_author: Tom Zander 
@_subject: [bitcoin-dev] Bitcoin Classic 1.2.0 released 
Thats partly correct.
There is just not a formal one, there very much is an informal and practical I, and I'm not alone in this, think that a formal vote or an algorithm to decide something will happen or not reeks too much like central planning and more importantly that it is too inflexible for real world use.
Its fine for simple upgrades, and we have seen lots of success there.
It would be a mistake to think that miners can just start mining with Classic and make something that Core doesn't understand. That would have negative effects and thus won't happen. Less social people will ask why and maybe ask how we avoid this. They misunderstand the social and economic parts of Bitcoin.
The block size is an ongoing debate. I find it very hard to believe that all the people replying in outrage to my release announcement completely missed this.
I see no point in bringing it up in a BIP or on this list as some central cabal that can make decisions for or against.  It is in actual fact being decided in the real world, out of yours and my control.
Classic is a tool to that end. No more. No less.

@_date: 2017-01-20 15:02:22
@_author: Tom Zander 
@_subject: [bitcoin-dev] Changing the transaction version number to be varint 
Hi all,
In the transaction today we have a version field which is always 4 bytes.
The rest of the integer encoding in a transaction is variable-size because it saves on bytes.
Specifically, in practice this means that almost all of the transaction have bytes 2, 3 & 4 set to zero[1].
The question that I was pondering is that when we accept a new version of transaction format (flextrans uses 4), what would the impact be of also changing the way that the version number is actually serialized to be var The benefit would be that each and every transaction looses 3 bytes. These can be used differently in v1 transactions and are not needed at all to be there for newer transaction formats.
The secondairy benefit is that, at least for FlexTrans[2], 100% of all the integers in the transaction are following exactly the same encoding, the
var-int encoding.
There is currently no consensus rule that rejects transactions which lie about their version, so obviously this rule should not and can not be introduced retro-actively. It will be from a certain block-height.
The way to do this is that from a certain block-height the current transaction format labels bytes 2, 3 & 4 to be unused.
Last, we add the rule from that block-height that only transactions that do not lie about their version number are valid. Which means version 1.
Do people see any problems with this?
This could be done as a soft fork.
1) It should be 100% because there is no transaction version defined that sets them to non-zero, but there is no consensus rule that rejects transactions that lie about their version number.
2)

@_date: 2017-07-12 11:02:51
@_author: Tom Zander 
@_subject: [bitcoin-dev] Updating the Scaling Roadmap 
I?m thinking along the same lines, a industry wide roadmap makes very little Much like in Linux we have a lot of smaller groups doing their own thing, all working for the good of Linux as they see it, and implicitly, as they use it.
I think its safe to say that Linus would not want any say over the roadmap of Intel or Google or any other particpant in the Linux space.
I am in agreement with Gregory that we should reject a Bitcoin-wide scaling I do suggest that smalle groups publish their individual roadmaps, show what they are planning to work on in a place that people will find it (a website, not a mailinglist archive).
Those individual roadmaps then show what that group will work on, which helps their communication. It helps people talking about Bitcoin to the general public as well, and it helps people understand whom they would like to support financially or otherwise.

@_date: 2017-07-12 11:37:32
@_author: Tom Zander 
@_subject: [bitcoin-dev] Updating the Scaling Roadmap 
I've heard this before and it doesn't make any sense to me. Just like your Linux box needs a reboot to get a kernel upgrade, your node needs a restart to upgrade. Neither the (entire) internet will go down nor the (entire) Bitcoin network will go down as a result.
This is fine, and groups that do development should do this more structured than something like It just would not make any sense to have a roadmap for the *entire* industry as this would require you to decide what technical solution is better than another before either of them are fully researched.
Individual groups can have solutions that they believe is the best. And then we can let the market decide which one is to be actually activated.

@_date: 2017-07-12 10:15:50
@_author: Tom Zander 
@_subject: [bitcoin-dev] A Segwit2x BIP 
Good news!
Code to support 2x (the hard fork part of the proposal) has been out and tested for much longer than that.

@_date: 2017-07-17 15:40:29
@_author: Tom Zander 
@_subject: [bitcoin-dev] A BIP proposal for conveniently referring to 
I?m not so clear on this, to be honest.
What is the point of having a user-readable tx-reference?
In the actual blockchain you will still be using txid, and if you want to change that then a less readable but more compact format is useful because we want to optimize for space, not for human comprehention.
Another usecase I can come up with is you wanting to spend a specific output, or you reporting a specific tx as proof to a merchant (or tax office).
For any such usecases you sill need to actually provide a proof of holding the private keys and using a human-readable format just doesn?t seem to make much sense because a cryptographic proof of ownership is not going to be readable however hard you try.
Apologies for missing the point,
can you list one or two usecases that you can see this being used for?

@_date: 2017-06-19 17:15:10
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
Why would it not be needed? Any SPV client (when used as a payment-receiver) requires this from a simple usability point of view.

@_date: 2017-06-19 18:07:45
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
You seem to misunderstand the usecase.
If you send me a transaction, both of use are using our phones, then I need to be able to have immediate feedback on the transaction being broadcast on the network.
This is not about zero-conf, this is simple seeing what is happening while it is happening.
Additionally, when the transaction that is meant for my wallet is broadcast, I want my SPV wallet to parse and check the actual transaction.
It is not just to see that *something* was actually send, but also to be able to see how much is being paid to me. Maybe If the transaction is marked as RBF-able, etc.
Really basic usability: provide information to your users when you can, should they want to, and by default on.

@_date: 2017-06-19 18:38:55
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
I mentioned that it was a usability point for a reason, and your personal behavior makes me want to quote one of the main UX guidelines;   ?You are not your user?
I think we should defer to actual real numbers and user reseach, as has been quoted by Andreas. You disagreeing based on your own experience and behavior is worse than useless. As the above links show.
Don?t fall in that trap :)

@_date: 2017-06-19 21:46:57
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP148 temporary service bit (1 << 27) 
I'm curious what you action on the finding (or not) of a peer with this bit set (or not).
Can you link to the github commit where you implemented this?

@_date: 2017-06-20 11:52:00
@_author: Tom Zander 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
On Tuesday, 20 June 2017 00:41:49 CEST Gregory Maxwell via bitcoin-dev First, your figures are wrong and also fall out of the sky with no justification. Can?t debunk something that is pure garbage.
Second, stating that a bloom filter is a "total loss of privacy" is equally baseless and doesn?t need debunking.
I think you just made the case for completely rejecting this proposal based on the fact that nobody will use it, BIP37 already exists.
Not sure if I agree with that, improvements are always useful and we should be able to come up with replacements.
But arguing against a feature you don?t like, especiallyh one used by millions every day, is a sad way to stiffle innovation, Greg.

@_date: 2017-03-07 10:17:18
@_author: Tom Zander 
@_subject: [bitcoin-dev] Moving towards user activated soft fork activation 
It is incorrect to say that censoring of transactions is what Edmund suggested. It's purely about the form they take, you can re-send the transaction in a different form with the same content and they go through. Hence, not transaction censoring.
I do believe the point that Edmund brought up is a very good one, the idea that a set of users can force the miners to do something is rather silly and the setup that a minority miner fraction can force the majority to do something is equally silly. This is because the majority mining hashpower can fight back against this attack upon them.
Don?t be mistaken; a hash-minority attacking the hash-majority is in actual fact an attack upon Bitcoin as a whole.
If this were possible then next year we?d see governments try to push through changes in the same UASF way. I?m very happy that UASFs can?t work because that would be the end of Bitcoin's freedom and decentralized nature.
I definitely welcome that approach.
The result would be that you have two chains, but also you ensure that the chain that the miners didn?t like will no longer be something they can mine. Not even the minority set of miners that like the softfork can mine on it. This is a win-win and then the market will decide which one will "win".
This goes both ways, miners both generate value (in the form of security) and they take value (in the form of inflation).
If the majority of the users are hostile and reject blocks that the miners create, or change the POW, then what the miners bring to the table is also Bitcoin would lose the security and in the short term even the ability to mine blocks every 10 minutes.
So, lets correct your statement a little;
?Bitcoin only works when the majority of the hashpower and the (economic)
  majority of the users are balanced in power and have their goals aligned.?

@_date: 2017-03-08 22:25:46
@_author: Tom Zander 
@_subject: [bitcoin-dev] Unique node identifiers (and BIP150) 
On Wednesday, 8 March 2017 20:47:54 CET Jonas Schnelli via bitcoin-dev Do you know the trick of having an open wifi basestation in a public street and how that can lead to tracking? Especially if you have a network of them.
The trick is this; you set up an open wifi base station with a hidden ssid and phones try to connect to it by saying ?Are you ssid=xyz??
This leads the basestation to know that the phone has known credentials with another wifi that has a specific ssid. (the trick is slightly more elaborate, but the basics are relevant here).
Your BIP is vulnarable to the same issue, as a node wants to connect using the AUTHCHALLENGE which has as an argument the hash of the person I?m trying to connect with.
Your BIP says "Fingerprinting the requesting peer is not possible?.
Unfortunately, this is wrong. Yes the peer is trivial to fingerprint. Your hash never changes and as you connect to a node anyone listening can see you sending the same hash on every connect to that peer, whereever you are or connect from.
Just like the wifi hack.
I think you want to use industry standards instead, and a good start may be

@_date: 2017-03-27 19:29:57
@_author: Tom Zander 
@_subject: [bitcoin-dev] Encouraging good miners 
For some time now the relation between block size and propagation speed has been decoupled. Using xthin/compact blocks miners only send a tiny version of a block which then causes the receiving node to re-create it using the memory pool.  Immediately getting double benefits by including pre-verified transactions from the memory pool you avoid the old problem of having to validate them again when a block was mined.
As such there is no downside to a miner creating a bigger block, as long as all the transactions they include are actually in the mempool.
As such I'm personally convinced that the problem you are trying to solve has already been solved.

@_date: 2017-03-28 22:43:34
@_author: Tom Zander 
@_subject: [bitcoin-dev] Hard fork proposal from last week's meeting 
The suggestion was not to produce 32MB blocks, so your fear here is

@_date: 2017-03-28 22:48:44
@_author: Tom Zander 
@_subject: [bitcoin-dev] Hard fork proposal from last week's meeting 
I think that is a very smart idea, thank you for making it.

@_date: 2017-03-28 22:50:58
@_author: Tom Zander 
@_subject: [bitcoin-dev] Hard fork proposal from last week's meeting 
That was not suggested.
Maybe you can comment on the very specific suggestion instead?

@_date: 2017-03-29 10:49:38
@_author: Tom Zander 
@_subject: [bitcoin-dev] Requirement for pseudonymous BIP submissions 
I agree with your assessment, the sides are political and picking sides makes people a target.
For that reason I know that many companies are not picking sides, we?ve seen some bad stuff happen to companies that did.
I?m not convnced it makes sense to use anonymous, but provable, identities is the way to solve this. Though.
I also don?t believe people are rejecting proposals purely based on the name. What I see is that pratically all proposals are ignored for the time being becaues we can?t make any changes anyway until we have made a protocol upgrade and came out stronger.
I do agree that bips are seen politically, but not based on the person that suggests them, but more based on the content being useful for their political side.
I am not entirely against pseudonymous submissions, but in that case I think it should be carried by a well known member of the Bitcoin community.
This raises the bar somewhat to a point where you have to convince someone that is already publicly known to propose it with you.

@_date: 2017-03-29 11:04:18
@_author: Tom Zander 
@_subject: [bitcoin-dev] Inquiry: Transaction Tiering 
Nag; they don?t have any authority.
This is not the case, it misunderstands Bitcoin and specifically is misunderstands that Bitcoin is distributed and decentralized.
What you call ?block generators? or ?transaction processors? are in reality called miners and they don?t have any authority to mine or not mine certain transactions. All they have is a business incentive to mine or not mine a certain transaction.
This is a crucial distinction as that makes it a economical decision, not a The massive distribution of miners creating blocks means that one miner is free to add his political agenda. They can choose to not mine any satoshi-
dice transactions, should they want. But they can?t stop other miners from mining those transactions anyway, and as such this is not a political move that has any effect whatsoever, at the end of the day it is just an economcal decision.
The rest of your email is based on this misconception as well, and therefore the above answers your question.

@_date: 2017-03-29 15:10:05
@_author: Tom Zander 
@_subject: [bitcoin-dev] Inquiry: Transaction Tiering 
This shows you didn't think this through,
instead, the concept holds true when there is even a small section of hash power motivated by rational economic interest.
Your claim that it has to be 100% of the miners that need to be honest is something I already addressed in the previous email when I wrote its a distributed system.
Since this is an open market, the requirement of a secton of miners being honest is pretty trivial to fulful, especially since Bitcoins are worth quite a lot which makes greed be the main cause of honest miners.
This is the best part, greedy miners are the ones that end up working inside the system.
This is very quickly going off-topic. I suggest you to take it to a different forum where more people can explain Bitcoin without spamming the dev list.

@_date: 2017-03-30 12:30:49
@_author: Tom Zander 
@_subject: [bitcoin-dev] Hard fork proposal from last week's meeting 
On Thursday, 30 March 2017 07:23:31 CEST Ryan J Martin via bitcoin-dev This is hopefully true. :)
There is an unbounded amount of demand for block space, and as such it doesn?t benefit anyone if the amount of free transactions get out of hand. Because freeloaders would definitely be able to completely suffocate Bitcoin.
In the mail posted by OP he makes clear that this is a proposal for a hard fork to change the block size *limit*. The actual block size would not be changed at the same time, it will continue being set based on market values or whatever we decide between now and then.
The block size itself should be set based on the amount of fees being paid to miners to make a block.
What we want is a true fee-market where the miner can decide to make a block smaller to get people to pay more fees, because if we were to go to 16MB blocks in one go, the cost of the miner would go up, but his reward based on fees will go down!
A block so big that 100% of the transactions will always be mined in the next block will just cause a large section of people to no longer feel the need to pay fees.
As such I don?t fear the situation where the block size limit goes up a lot in one go, because it is not in anyone?s interest to make the actual block size follow.

@_date: 2017-03-30 12:34:45
@_author: Tom Zander 
@_subject: [bitcoin-dev] Hard fork proposal from last week's meeting 
The idea that people won?t run a node for a network they don?t use for their own transactions is a very good observation and a good reason to get on-
chain scaling happening well before lightning hits.

@_date: 2017-03-30 23:57:59
@_author: Tom Zander 
@_subject: [bitcoin-dev] Hard fork proposal from last week's meeting 
No, there is a lot you and I can do about it. They call it a fee market for a reason because you can take your money elsewhere. You can choose to not make the transfer at all, use another crypto or just use fiat.
Bitcoin has value because we use it as money, supporess that usecase and the value of it goes down.

@_date: 2017-05-04 16:57:59
@_author: Tom Zander 
@_subject: [bitcoin-dev] Full node "tip" function 
I agree with you here, Erik. Greg's standard answer doesn?t apply to your I think he was a bit too trigger happy because we have seen a lot of similar suggestions that have the Sybill issue he mentioned.

@_date: 2017-05-26 11:21:55
@_author: Tom Zander 
@_subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial 
I?m uncomfortable with your ?bingo? moment, and your huge assumption to get to make it fit.
The reality is that we have seen repeatedly that the miners are stating they are Ok with an ASICBOOST disabling change.
The larger mining industry has just this week come to consensus about a better way to activate SegWit! Referring to the New York consensus meeting!!
I question your conclusions of miners not supporting SegWit because of ASICBOOST, the evidence shows this accusation to be false.
You openly admitting here that you use ASICBOOST as a tool to push SegWit is further making me uncomfortable. Your intention may be pure, but the methods are not.
And on that I agree with Andreas, that taints this proposal.

@_date: 2017-05-26 16:54:03
@_author: Tom Zander 
@_subject: [bitcoin-dev] Emergency Deployment of SegWit as a partial 
The modifications to Bitcoin Core would take at most a day to do, plus a week to test.
I?m not very happy with the full compromise myself, but can we please not stomp on actual progress with nebulous problems?
I mean, you want SegWit, right?
The nature of a compromise like the one that happened in New York is that both parties do something they are not the most happy with in exchange for the thing they want.
Miners have agreed to the SegWit part of this compromise. Calling that disingenuous is not helpful...

@_date: 2017-05-26 20:48:32
@_author: Tom Zander 
@_subject: [bitcoin-dev] Barry Silbert segwit agreement 
Sorry for picking your email.
I understand people want something different for the agreement, I know I do We have a specific agreement on the table, signed by a huge subsection of the Maybe the time for changing things is not to be *after* the signatures are set. I know I?d change some detials. But do we really want to go through another conference where all the important people are present to agree on a compromise? Or can we use the one we have?
The compromise is pretty simple;
*  Activate Segregated Witness at an 80% threshold, signaling at bit 4
*  Activate a 2 MB hard fork within six months

@_date: 2017-05-27 00:12:49
@_author: Tom Zander 
@_subject: [bitcoin-dev] Barry Silbert segwit agreement 
This should not be an issue, it started 2 years ago. Its tested.

@_date: 2017-05-28 22:51:46
@_author: Tom Zander 
@_subject: [bitcoin-dev] Barry Silbert segwit agreement 
Hmm, the flags are identical in 0.13 and 0.14 clients.
Either way, this is rather trivial to solve. If bugs in older clients mean they can?t operate properly when SW is activated (via bit 4) but they don?t know its activated (since they only look at bit1), then just ban them when they misbehave.
And tell people to upgrade to a version where SegWit is less buggy.
Heh, well, this is rather simple to solve by not having all those activation codepaths and just picking **one**.
You can safely replace the bit1 activation code with a bit4 activation logic, which is based on 80% and has no end-date.
We both know that the bip9 (bit1) based activation will not trigger before the expiration date anyway.
These worries are rather trivial to solve if you do a little bit of proper architecture of the solution.  This honestly can?t be a reason for saying NO to the majority of the mining hash power giving you a break and offering a better SegWit activation.

@_date: 2017-09-01 15:12:18
@_author: Tom Zander 
@_subject: [bitcoin-dev] Horizontal scaling of blockchain 
Adding more space in blocks has no effect on the block-reward. It does actually increase the throughput speed of transactions.
Also this is exactly the opposite of what actually happened.
This is not true, since xthin/compactblocks have been introduced we completely removed this bottle-neck.
The transactions will be validated continuously, in parallel and not just when a block is found.

@_date: 2017-09-02 23:13:57
@_author: Tom Zander 
@_subject: [bitcoin-dev] Horizontal scaling of blockchain 
The real limit is set by the technology. Just like in 1990 we could not fathom having something like YouTube and high-res video streaming (Netflix), the limits of what is possible continually shifts.
This is basically how any successful product has ever grown, I think that it is not just desirable, it is inevitable.
