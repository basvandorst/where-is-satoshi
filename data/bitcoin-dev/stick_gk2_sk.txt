
@_date: 2013-11-17 00:41:01
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
No. It can't. Private keys never leave the device so client would not
know how to generate addresses.

@_date: 2013-11-17 00:49:04
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
That's a really neat trick!
Right. That's a problem. I'm not sure if this whole cryptomagic is
benefitial at all.
I'd suggest to go the easy way for now, i.e. prove that external entropy
was used while generating the master seed. If the user does not trust
our firmware, he can use his own built one.

@_date: 2013-11-17 01:49:00
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
We'll probably use the most straightforward way:
a) trezor prints entropy A on a display (probably in hex format, this
step is triggered by sending a special flag in initialize message)
b) trezor receives entropy B from external source
c) trezor creates sha256(A + B) and uses that as a seed
d) trezor prints used seed on a display (probably in BIP39 format)
e) user can check on a trusted computer that everything was ok
(note that steps b-d are the same regardless of whether the special flag
was set)

@_date: 2013-10-19 12:11:26
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] BIP39 word list 
Yeah, there are lots of tools on the Internet. Posting links to them is
not helping. Sending pull requests with particular changesets with
explanation is. Well, or rather was. I think we are past the point where
it was wise to introduce changes to the word list ... (especially when
50 people have 51 different opinions on this topic)

@_date: 2013-09-10 23:34:01
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
Feel free to come up with wordlist enhancements. That's why we put
this BIP for discussion in the first place. Three people went through
the wordlist numerous number of times and as you can see it's still
not perfect.
Please bear in mind that for every word you remove from the list, you
have to come up with a good alternative that is unique and hard to
confuse with the others.

@_date: 2013-09-12 14:11:10
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
I revisited the wordlist and replaced around 67 words that can be
found offensive in some context.

@_date: 2013-09-12 14:09:57
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] BIP0039 Mnemonic code for generating 
We were playing with that idea quite a lot. The problem was that we
ended up with much bigger wordlist and thus it had to contain more
obscure words. Also remember that this scheme has to run on embedded
devices as well, so any unnecessary complexity should be avoided.

@_date: 2014-04-08 16:35:35
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
This is possible, but I find it much more practical to use just one list
(assignment of coins to indexes) than to use two lists (assignment of
coins to key strings and to serialization magic).
Keeping two lists is harder and adds unnecessary friction. (Also I am
not very happy for the possibility we'll have to deal with key strings
"sCAMCo1N RULEZZZZ!!!! bRoUghT TO YoU bY M4rty" and serialization magic
that leads to prefix "lulz").
Also from wallet's implementer perspective it is a little easier to use
just one root node and then descend in tree as needed than to use method
you described.

@_date: 2014-04-20 20:10:10
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] "bits": Unit of account 
So far I have not seen any reasonable name except for "bit". I also
tried to come up with something else (e.g.naka, toshi, etc.) to avoid
the confusion with bits used in computing, but I was not satisfied with
neither of them.
Then I though about "credit", which is more-or-less established in video
games and sci-fi literature and people are already used to sentences
like "Not enough credits" or "This item costs 10000 credits", because of
this. Also it would be particularly funny if these sci-fi pieces
predicted the future by actually defining it. ;-)
Another options might be "cubit" or "crebit", but the latter is
sometimes used as a compound word meaning both "credit" and "debit" such
as in "You can use crebit cards here".
Also this Wikipedia source is a list of sometimes rather funny
possibilites:

@_date: 2014-04-23 20:46:11
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
Such merchant would surely use some merchant system instead of generic
wallet software.
Not if you have 100 accounts on 10 different devices.

@_date: 2014-04-23 21:29:04
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
There is such system and it is called BIP32.
On the other hand, in BIP64 we try to put a set of restrictions and
rules on top of BIP32. There will always be some special usecases where
BIP64 is not a good fit and there's no reason why you cannot use BIP32
in a different manner using a different "purpose" field.
Examples: Electrum does not want to use accounts and they start to use
scheme m/65'/change/address (where change = 0 or 1). Or Andreas
Schildbach wants to have refunds chain so he uses m/66'/chain/address
(where chain = 0, 1 or 2).
We wanted to find one good solution that fits all, but unfortunately it
turned out everyone wants something a little bit different.
The point of the whole effort is that you can have ONE SINGLE BACKUP
(master node) for all these independent purposes and suddenly claims
such as "my wallet is BIP64 and BIP66 compatible" actually mean
something as opposed to "BIP32 compatible" which actually means nothing
except that the wallet author is capable of using HMAC in context of
generating the tree.

@_date: 2014-04-23 21:49:38
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
As Andreas wrote earlier in this thread: "There is no "bare minimum".
Either you implement the "BIP" fully or not."
What you suggest does not follow the principle of least surprise.
Suppose user imports his BIP64 compatible wallet into Electrum, which
claims it is BIP64 compatible, but actually implements just a subset of
the spec (sticking account index to 0). The user now sees just a
fraction of his coins and is puzzled.

@_date: 2014-04-23 22:04:03
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
So you suggest to scan for accounts, show balances but don't allow user
to spend them? Does not seem right to me.

@_date: 2014-04-23 22:16:45
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
I think one of the following is happening:
a) you have not read the document
b) you don't understand what accounts are, because you have not read
   the document
c) you don't understand how restoring accounts work, because you
   have not read the document
d) you don't understand that accounts funds are not meant to be mixed
   together, because you have not read the document
e) I got your emails wrong because I am not a native speaker,
   but please read the the document ;-)

@_date: 2014-04-23 22:35:50
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
Ah, okay. The last time I saw Bitcoin-qt it was still using independent
Which brings us back to my original complaint that the user can be
confused because he doesn't see all his funds.

@_date: 2014-04-23 22:43:57
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
Right. But these clients have no right to call themselves BIP64
compatible then.

@_date: 2014-04-23 23:06:26
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
This is not a desired behavior. Do you have any idea how to make it even
more explicit in the spec? Currently we just have (in Account sectrion):
"This level splits the key space into independent user identities, so
the wallet never mixes the coins across different accounts."
I would like to make it obvious from the spec that if you mix funds
accross the accounts you are not doing a right thing and you are not
compliant to the spec.

@_date: 2014-04-23 23:24:43
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
Our users do and we are creating this BIP for them, because we love them. ;)

@_date: 2014-04-23 23:33:48
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
That is a subjective matter. To me it makes PERFECT SENSE that funds
across accounts NEVER MIX. One can still send funds from one account to
another and then perform another spend.
That's what I consider a consistent and thus GOOD user experience.
What's the purpose of Accounts if wallet mixes coins among them anyway?
I know it's not good to use classic bank accounts as analogy, but that's
exactly how they work. Or have you every done ONE transaction from two
bank accounts simultaneously?

@_date: 2014-04-23 23:44:20
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
Right. See my previous email where I describe hypothetical creation of
BIP65 and BIP66 which the exact thing you describe.

@_date: 2014-04-26 14:24:55
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] BIP32 "wallet structure" in use? Remove 
That is nonsense. There is no way how to import the wallet if you don't
know its structure.
Unless the keyspace is almost infinite because:

@_date: 2014-08-08 15:19:38
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] BIP32 - invalidation 
Hi all!
I would like to discuss invalidation of nodes in BIP32. Currently the
document says:
a) Public CKD
In case I_L >= n or ki = 0, the resulting key is invalid, and one should
proceed with the next value for i.
b) Private CKD
In case I_L >= n or Ki is the point at infinity, the resulting key is
invalid, and one should proceed with the next value for i.
c) Master Key Generation
In case IL is 0 or I_L >= n, the master key is invalid.
(All these cases have probability lower than 1 in 2^127.)
What do you think about the following change for all 3 cases:
In case I_L >= n assign I_L := I_L mod n.
It's easy to say "mark as invalid and proceed with next", but actually
most of the implementations don't do the checking at all, because tjen
it's rather hard at application level to implement skipping logic. OTOH
it's quite straightforward to perform modulo if needed, so we probably
see more implementations doing the checking.
We would still need to deal with cases when I_L = 0 or ki = 0 or ki =
inf, but these have probability around 1 in 2^255.
Does anyone see any concerns when it comes to security of the proposed

@_date: 2014-02-12 17:56:35
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with 
If we are bumping nVersion, how about dropping DER encoding completely
and using just 64 bytes directly for signature?
Also using 2 different variable integer encodings (in addition to what
DER already does) is very confusing.

@_date: 2014-02-24 17:50:09
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release 
So are 75 bytes. (I'm not trying to push anything. Just saying ...)

@_date: 2014-03-12 16:55:02
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] [RFC] Proposal: Base58 encoded HD Wallet 
Which is better IMO. I can't imagine anyone writing down a long Base58
encoded string.
Not true, BIP39 supports 12/18/24 words (= 128/192/256 bits of entropy).
This is nice addition, indeed. But we needed to limit the data as
possible in order not to increase the number of words needed to be noted
It has a detection. Not correction though.
True, but having one or two solid options are better than having
gazillions of possible options.
True, but they are encouraged to use the list provided. Possibility to
outsource KDF outside of your "standard" breaks much more compatibility
than this.

@_date: 2014-03-12 20:39:29
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] [RFC] Proposal: Base58 encoded HD Wallet 
Sure, you can have either plausible deniability or typo checking, not
both at the same time.
I'm afraid one would end up with code generated in one client that is
unusable in a different client, because the client's developer thought
that using fancier algorithm instead of the proposed ones was a good idea.

@_date: 2014-03-12 21:04:33
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] [RFC] Proposal: Base58 encoded HD Wallet 
Ok, I see. So the spec allows one real and one fake password. That is
something I don't consider plausible deniability. I am not saying that
this solution is wrong, I find it quite interesting, but it's not
plausible deniability. ;-)
Ah, I misunderstood. I thought that outsourcing the KDF means allowing
the 3rd party to use any KDF instead of the specified ones. What would
be the reason to outsource if this is not possible, anyway?

@_date: 2014-03-12 21:24:27
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] [RFC] Proposal: Base58 encoded HD Wallet 
By disclosing "preH" to compromised computer (between steps 4 and 5) you
make further steps 5-9 quite less important.
Too bad you started to work on spec just recently. :-/

@_date: 2014-03-12 21:42:47
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] [RFC] Proposal: Base58 encoded HD Wallet 
To give you some numbers: TREZOR (120MHz ARM) does 1024 rounds of
PBKDF2-HMAC-SHA512 in around 1 second.
So 2^16 is around one minute, 2^21 is around half an hour.

@_date: 2014-03-27 12:35:15
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
Nice idea, but keep in mind that you are hashing into 2^32 space, so
collisions will occur, unfortunately and we'll end up with directory
again :-/
Even if they did not occur you would need to keep up the registry of
names anyway (is it Peercoin or PPCoin, Testnet or TestNet ...)?

@_date: 2014-03-27 12:36:43
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
There is one "altcoin" that is pretty important even today and it is

@_date: 2014-03-27 14:44:30
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
Also, we'd need to specify a "gap limit" for accounts as well. In TREZOR
we currently use 0, which means that the scan will stop as soon as we
hit first account with no transaction history (meaning that its first
X=10 addresses are unused).

@_date: 2014-03-27 15:03:23
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
This is a possible optimization, but it adds unnecessary logic. Also it
does not decrease the number of required requests between a client and a
server (e.g. when backend sends responses in "bulks" of 10 addresses or

@_date: 2014-03-27 17:06:20
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
That magic number is something I find very unfortunate and superflous in
BIP-32 design. Its only purpose is to distinguish BIP-32 trees for
various altcoins, but it doesn't make sense at all once you start
storing various altcoins in the same tree using the proposed
I would love to see that removed from BIP-32 and use always
0x0488B21E/0x0488ADE4 (xpub/xpriv), but that is for different discussion
I guess.

@_date: 2014-03-27 17:21:12
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] New BIP32 structure 
Cointype in path is for separation purposes, not for identification.

@_date: 2014-05-07 21:55:21
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Announcing the Statoshi fork 
How complex is the patchset? Would it be possible to merge it into the
mainline and enable compilation of this feature conditionally by some
build-time option?

@_date: 2014-10-03 15:02:24
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] bitcoinj 0.12 
Congratulations on this release and I am quite happy that bitcoinj now
fully supports BIP32 and BIP39!
Does it also support various HD wallet structures such as BIP44 for example?

@_date: 2014-10-21 22:56:18
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] cryptographic review requested 
I don't know what criticism it was, but I feel that another BIP than
BIP44 should be created to describe which HD paths should be used for ECIES.
That looks great! I already implemented Electrum's way of ECIES into
TREZOR firmware, but yours version seems much more complete, so I am
inclined to throw it away and use your implementation.
Have you thought about pushing this as a new BIP (different one than I
mention above)? I think it's important to have it reviewed and
standardized ASAP.

@_date: 2014-10-22 16:56:37
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] cryptographic review requested 
Could you please describe what might get wrong if one uses deterministic
nonces for ECIES as well? Thanks!

@_date: 2015-02-02 13:57:12
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Export format for xpub 
I think this could end up in BIP43, which deals with hierarchies and is
still in Draft state although widely used. Allocating new BIP seems like
a overkill to me.

@_date: 2015-02-02 13:59:17
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Export format for xpub 
Do I understand this correctly and h=bip32 hierarchy means that both
xpub/0/i and xpub/1/j chains are scanned? (So it applies to BIP44
generated xpubs as well?)
Uff, I would expect YYYYMMDD there so it's human readable as well.

@_date: 2015-02-02 15:56:22
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Export format for xpub 
To me it seems more important to describe how addresses should be
discovered (i.e. to scan xpub/0/i and xpub/1/j chains using gap limit G)
instead of how the xpub was created/obtained (bip32 vs bip44).
What do you thing about changing ?h=bip32 to something like
- t=01 meaning that chains 0 and 1 should be scanned (feel free to
change "01" into any other descriptive string)
- g=20 meaning that gap 20 should be used
OK :-)

@_date: 2015-02-03 01:22:51
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Export format for xpub 
Hm, let me put the questions the other way around:
What gap limit should a wallet use if it encounters h=bip32?
What h value should I use for myTREZOR wallets? Which is essentially a
BIP44 wallet that produces h=bip32 xpubs with gap limit 20 ...

@_date: 2015-02-03 11:10:59
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Export format for xpub 
I cannot come up with an usecase where "path" parameter would be needed.
FWIW childnumber and depth are already expressed in xpub itself.
I like the general idea of "subchains" parameter, but I would like to
further specify it:
a) parameter should contain values described as comma separated
   list of values (such as 0,1,2,3,4)
b) consecutive values can be shortened via dash (0,1,2,3 == 0-3)
c) should we allow non-consecutive values (e.g. 0,1,3,8)?
   I am not sure. If not the "subchains" param can contain just upper
   bound of indexes to scan (e.g. "3")
d) a wallet uses just the first specified chain to generate receiving
   addresses, uses the other chains just to add to the balance
   OR should a wallet be able to generate receiving address for second,
   third, etc. external chain? if yes, we should split "subchains" param
   into "external" and "internal" params both containing a list of
   numbers. this seems like an overkill to me and I am fine with using
   just the first chain as the external one.
Yes. The longer the string, the bigger the QR code.
I am not against Unix timestamps, I just said I expected something else
there. Unix timestamps have a lot of advantages. Another option that
might make sense is the block number.

@_date: 2015-02-03 11:44:43
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Export format for xpub 
Ah, correct. Timestamp it is.
Nitpick: They cannot be used on multiple blockchains according to BIP32.
In BIP43 we fixed that. :-)

@_date: 2015-02-21 14:34:34
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Request for a new BIP number (and 
Your proposal is missing Abstract and Motivation sections. Abstract
tells us WHAT are trying to achieve, Motivation tells WHY. It's not
worth to dig into technical details of your implementation until these
two questions are answered.

@_date: 2015-01-14 20:58:54
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] convention/standard for sorting public 
Could you give an example of two pubkeys where the following condition
is met?
raw(pubkey1) > raw(pubkey2) and base58(pubkey1) < base58(pubkey2)

@_date: 2015-01-22 10:46:26
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] Securing wallet on paper 
Bitcoin Core still does not support Hierarchical Deterministic aka BIP32
Wallets. Without them it is possible to backup just one private key per
backup, which is rather useless and in fact dangerous.
I would suggest looking at different software wallets that do support
such functionality such as Electrum or Multibit.

@_date: 2015-03-08 02:34:38
@_author: Pavol Rusnak 
@_subject: [Bitcoin-development] bip44 GPG identities - POC demo 
As an author of BIP44 I don't think that you should use BIP44 for this
and a new BIP number should be allocated. To me it does not make much
sense to create GPG key hierarchy per Bitcoin account, but rather create
a GPG key hierarchy per device/master seed.
I am currently in process of implementing a SignIdentity message for
TREZOR, which will be used for HTTPS/SSH/etc. logins.
See PoC here:
The idea is to derive the BIP32 path from HTTPS/SSH URI (by hashing it
and use m/46'/a'/b'/c'/d' where a,b,c,d are first 4*32 bits of the hash)
and use that to derive the private key. This scheme might work for GPG
keys (just use gpg://user at host.com for the URI) as well.
