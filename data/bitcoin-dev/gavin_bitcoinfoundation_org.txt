
@_date: 2013-06-25 13:57:15
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] Bitcoin-Qt/bitcoind version 0.8.3 released 
Bitcoin-Qt version 0.8.3 is now available from:
  This is a maintenance release to fix a denial-of-service attack that
can cause nodes to crash.
Please report bugs using the issue tracker at github:
  0.8.3 Release notes
Truncate over-size messages to prevent a memory exhaustion attack.
Fix a regression that causes excessive re-writing of the 'peers.dat' file.
Thanks to Peter Todd for responsibly disclosing the vulnerability
( CVE-2013-4627 ) and creating a fix.

@_date: 2013-03-18 11:32:49
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] Bitcoin-Qt/bitcoind version 0.8.1 available 
Bitcoin-Qt/bitcoind version 0.8.1 is available from:
  This is a maintenance release that adds a new network rule to avoid a
chain-forking incompatibility with versions 0.7.2 and earlier.
Source code for this release is in a 0.8.1 tree branched directly from
the 0.8.0 release:

@_date: 2013-05-22 11:59:53
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] UUID to identify chains (payment protocol 
Getting back to the original proposal:
RE: uuid instead of "main" / "test" in the payment protocol:
I vote no.
The payment protocol will become at least 3 BIPs:
1) Protocol messages (current gist, essentially)
2) MIME type
3) bitcoin: URI extension
An alt coin will need its own version of (2) and (3), so when you
click on a foocoin: link a foocoin-specific MIME type is fetched and
foocoin.exe is launched to handle the request.
... or a specific MIME type is fetched and delivered to the
HandlesLotsOfCoins application (... and it knows what MIME type it is
getting, so can Do the Right Thing).
If a payment request is delivered via HTTP or email, it will be
bundled up in an envelope of some sort with the MIME type attached.
So, after further thought, I've changed my mind: which coin would be
encoded in the MIME type.  Which chain for that coin would be encoded
in PaymentDetails.network.

@_date: 2013-09-04 11:16:35
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] 0.8.4 released, 
Bitcoin-Qt version 0.8.4 is now available from:
  This is a maintenance release to fix a critical bug and three
security issues; we urge all users to upgrade.
There were no changes from 0.8.4 release candidate 2, so if you are running
0.8.4rc2 you do not need to upgrade.
Please report bugs using the issue tracker at github:
  How to Upgrade
An attacker could send a series of messages that resulted in
an integer division-by-zero error in the Bloom Filter handling
code, causing the Bitcoin-Qt or bitcoind process to crash.
Bloom filters were introduced with version 0.8, so versions 0.8.0
through 0.8.3 are vulnerable to this critical denial-of-service attack.
A constant-time algorithm is now used to check RPC password
guess attempts; fixes Implement a better fix for the fill-memory-with-orphan-transactions
attack that was fixed in 0.8.3. See
for a description of the weaknesses of the previous fix.
Bugs fixed
Fix multi-block reorg transaction resurrection.
Fix non-standard disconnected transactions causing mempool orphans.
This bug could cause nodes running with the -debug flag to crash.
OSX: use 'FD_FULLSYNC' with LevelDB, which will (hopefully!)
prevent the database corruption issues many people have
experienced on OSX.
Linux: clicking on bitcoin: links was broken if you were using
a Gnome-based desktop.
Fix a hang-at-shutdown bug that only affects users that compile
their own version of Bitcoin against Boost versions 1.50-1.52.
Other changes
Checkpoint at block 250,000 to speed up initial block downloads
and make the progress indicator when downloading more accurate.
Thanks to everybody who contributed to the 0.8.4 releases!
Pieter Wuille
Warren Togami
Patrick Strateman
Gregory Maxwell
Sergio Demian Lerner
Cory Fields
Matt Corallo
Gavin Andresen

@_date: 2014-06-17 15:40:36
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] Proposal: relax the IsStandard rules for P2SH 
Assuming there is rough consensus, I'll make this a pull request (see
 for code
Now that we are finally starting to see the use of multi-signature and
other more complicated transaction forms in applications I think it is time
to open up the "IsStandard" transaction rules on the main Bitcoin network.
There are two main risks to doing this:
1. The risk that one of the seldom-used opcodes has a not-yet-discovered
chain-forking bug. I believe that risk to be very low; we have never seen
such a bug on the test network (where all transaction forms are allowed)
and have never found a bug after writing extensive unit tests.
2. The risk of opening up a denial-of-service attack (either bloat the
blockchain or use an excessive amount of CPU time) via a very
expensive-to-store-or-verify transaction. This proposal does not entirely
eliminate IsStandard checks to mitigate the potential for DoS attacks.
Allow any Script containing 15 or fewer signature operations as a
pay-to-script-hash (P2SH) Script to be relayed and mined by the reference
This should be a simple change to the AreInputsStandard() method in the
reference implementation.
P2SH Scripts are limited to 520 bytes, and are currently limited to one of
the "standard" transaction forms on the main network. In practice that
means you can currently encode a n-of-15 OP_CHECKMULTISIG which can be
redeemed as a 'standard' transaction.
Allowing any P2SH Script would allow an attacker to craft a single standard
transaction output that requires on the order of 200 ECDSA signature
checking operations to validate-- an order of magnitude more than is
currently allowed. Therefore I am proposing that we keep the current
15-signature-checking-operations-per-transaction-output limit in place, but
allow any combination of enabled Script opcodes. So, for example, you might
have a P2SH Script that is redeemed with 2-of-2 OR 2-of-3 using:
OP_IF 2 pubkey1 pubkey2 2 OP_CHECKMULTISIG OP_ELSE 2 pubkey3 pubkey4
pubkey5 3 OP_CHECKMULTISIG OP_ENDIF
(this would count as 5 signature operations)
Restricting arbitrary Scripts to P2SH transaction types limits unspent
transaction output set bloat in two ways:
1. The Scripts are not stored in UTXO set.
2. They are limited to 520 bytes by the Script rule on the amount of data
that can be pushed onto the stack.
The reference implementation's wallet will still only recognize P2SH
transactions that use one of the standard transaction forms. To actually
USE a new transaction form will require specialized wallets or specialized

@_date: 2014-06-18 08:52:22
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] Proposal: relax the IsStandard rules for 
RE: most of Peter Todd's comments:
All of that should be separate pull requests.  Big Honking Pull Requests
are harder to review and are more likely to be bike-shedded to death.
RE: not relaying/mining transactions with OP_NOPs so miners don't mine
up-version transactions that are invalid under future-new-rules: I'm not
convinced it is worth adding more code (more potential for bugs) to protect
against something that isn't going to happen because up-version
transactions are non-standard (due to version check) in any case.
In any case, lets make that a separate pull request.
I'm going to take the lack of immediate "That's a Terrible Idea!" as rough

@_date: 2014-06-19 09:54:31
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] Proposal: relax the IsStandard rules for 
RE: soft-forks bumping version numbers:
Yes, we have consensus that is the way we will do it.  I should probably
turn  into an informational
RE: malleability:
Orthogonal (but related) issue to IsStandard.
Detecting Scripts that leave extra items on the stack will be done in a
different part of the code than the code addressed by this pull reques. No
need to execute the Script twice to figure out if it leaves extra stuff,
and the idea behind IsStandard is to get to a quick yes/no before running a
potentially expensive Script execution.

@_date: 2014-03-25 08:45:00
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] Tree-chains preliminary summary 
We have a fundamental disagreement here.
If you go back and read Satoshi's original thoughts on scaling, it is clear
that he imagined tens of thousands of mining nodes and hundreds of millions
of lightweight SPV users.
Scaling is a problem if every person is a fully validating node; then,
indeed, you get an O(n^2) problem.  Which can be solved by extending some
tentative trust to your peers, but lets put all those possible solutions
Given tens of thousands of fully validating nodes, you get O(m*n), where m
is the number of fully validating peers and is a large constant (10s of
We don't know how large m can or will be; we have only just started to
scale up.
"Bitcoin doesn't scale" is pure FUD. It might not scale in exactly the way
you want, but it WILL scale.

@_date: 2015-01-19 15:56:37
@_author: Gavin Andresen 
@_subject: [Bitcoin-development] BIP70: why Google Protocol Buffers for 
What Mike said. Runner-up for encoding was JSON.
XML+ASN.1 was Right Out, because lots of us hate XML and ASN.1 with a
burning passion. Complexity is the Enemy of Security, and both XML and
ASN.1 are too complex.
