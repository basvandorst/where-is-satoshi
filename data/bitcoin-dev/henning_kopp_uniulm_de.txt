
@_date: 2015-07-02 09:18:14
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Defining a min spec 
Hi Jean-Paul,
that's a very interesting point of view and I have never thought about
it this way, since I have a totally different background.
How would you go on about defining a min spec? Is this done by testing
the software on different hardware configurations or are you looking
at the requirements a priori?
Best regards

@_date: 2016-08-08 17:47:07
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Hiding entire content of on-chain transactions 
Hi Tony,
I see some issues in your protocol.
1. How are mining fees handled?
2. Assume Alice sends Bob some Coins together with their history and
Bob checks that the history is correct. How does the hash of the txout
find its way into the blockchain?
Regarding the blinding factor, I think you could just use HMAC.
All the best

@_date: 2016-08-09 09:26:35
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Hiding entire content of on-chain transactions 
Hi Tony,
Instead of a hash function you may use a keyed hash function (HMAC) where
the key is just the random string. They key needs to be stored in the
history of the coin to allow for verification.

@_date: 2016-12-14 09:00:51
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Bitcoin Currency 
Hi Ben,
not sure if this is the right mailing list for that. I think it rather
belongs to bitcoin-discuss.
And I am also not sure if I understand your question. What you may
mean is the private key of a user. If you find this, you can spend his
funds and also prove that you own the funds.
Depending on your level of understanding of Bitcoin, this blogpost may
be insightful for you:
All the best

@_date: 2016-02-09 14:12:15
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Question regarding Confidential Transactions 
Hi all,
I am trying to fully grasp confidential transactions.
When a sender creates a confidential transaction and picks the blinding
values correctly, anyone can check that the transaction is valid. It
remains publically verifiable.
But how can the receiver of the transaction check which amount was
sent to him?
I think he needs to learn the blinding factor to reveal the commit
somehow off-chain. Am I correct with this assumption?
If yes, how does this work?
All the best

@_date: 2016-02-10 12:53:45
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Question regarding Confidential Transactions 
Hi Jeremy,
Yep, that is a possibility. The blinding factor could be encrypted
with the public key of the receiver. Thus it is only visible for the
receiver who can then check that the correct amount has been sent.
I understand and agree.
Here you lost me.
Why do we need to create a shared secret? Is this shared secret used
as the blinding factor?
Also I think the sender knows the unhashed public key of the receiver.
The only reason not to include it in the transaction script is that an
external observer is unable to see the receiver directly in the

@_date: 2016-03-03 16:04:18
@_author: Henning Kopp 
@_subject: [bitcoin-dev] consensus rule change for TX fee safety 
I think there is no need to do a hardfork for this. Rather it should
be implemented as a safety-mechanism in the client. Perhaps a warning
can pop up, if one of your conditions A) or B) is met.
All the best
Henning Kopp

@_date: 2016-03-04 09:41:02
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Hardfork to fix difficulty drop algorithm 
I do not think that a line can be drawn here. As far as I understood,
you think that the coin limit is a meaningful underlying principle
which should not be touched, whereas the halving of mining rewards is
an implementation detail. The two are very closely tied together and
changes to both of them would result in a hardfork, if I am not
Regarding the effects of the mining reward halving, there is a nice
paper from courtois:
All the best

@_date: 2016-05-11 12:36:01
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Making AsicBoost irrelevant 
At least until a difficulty adjustment on the AsicBoost chain takes
place. From that point on, both chains, the AsicBoost one and the
forked one will grow approximately at the same speed.
All the best

@_date: 2016-10-10 09:38:06
@_author: Henning Kopp 
@_subject: [bitcoin-dev] 1 Year bitcoin-dev Moderation Review 
Hi all,
I totally agree with the assessment of the situation. Previously I
learned a lot about bitcoin on this list. There were a lot of great
ideas regarding the protocol and the surrounding ecosystem. Now there
is mainly talk about code and BIPs, which is the main purpose of a
developer list.
I do not feel that we should clog bitcoin-dev again with
non-development talk but rather find a way to get bitcoin-discuss
going. My impression is that bitcoin-discuss has not reached a
critical mass of contributors. The question is how we can change that.
All the best

@_date: 2017-02-27 10:15:29
@_author: Henning Kopp 
@_subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by 
Hi all,
I did not follow the whole discussion, but wanted to throw in some
literature on the failure of crypto primitives in Bitcoin.
There is a paper which discusses the problems, but does not give any
remedies: And there are also contingency plans on the wiki:
 These are not very
detailed and my impression is that this information should be viewed
very critically (E.g., when ECDSA is broken, the suggested vague
response is "Switch to the stronger algorithm." Yeah. And "Code for
all of this should be prepared." Surely. As far as I know, there is no
such code and no-one is working on it).

@_date: 2017-07-05 16:26:53
@_author: Henning Kopp 
@_subject: [bitcoin-dev] difficulty adjustment (was: The Nuclear Option: 
I also thought about this some time ago. But note that this implies
that forks grow with the same block frequency as the main chain. Thus
the longest chain rule becomes irrelevant, since all chains will have
the same length (in expectancy). Rather, the chain with most work is
the true one.

@_date: 2017-05-04 14:51:39
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Combining SPV and Stealth addresses 
Hi all,
Recently I think a lot about combining Stealth addresses with SPV but
I did not come to a satisfying conclusion, so I post this as a
challenge to the wider community. Maybe you have an idea.
 Explanation of SPV
In SPV a thin client puts his public keys in a bloom filter
and asks a full node to give him Merkle proofs of all transactions
whose pubkey are in the bloom filter. Since a bloom filter has a lot
of false positives depending on the parameters, this gives privacy to
the thin client, since the full node cannot detect if a specific
transaction belongs to the thin client. This is cool if you want to
use Bitcoin on your smartphone.
 Explanation of Stealth Addresses
Stealth addresses on the other hand enable receiver privacy. The
sender of a transaction derives a one-time pubkey to which he sends the
money. The receiver can check if the money was sent to him and recover
the one-time private key. This is cool, since an observer cannot
decide if two payments belong to the same recipient. Further the
recipient needs only to have one pubkey.
For a more formal explanation see I will use their notation in the following.
 The Problem
My line of thought was to combine stealth addresses with spv, so that
I can use stealth addresses on my smart phone without losing privacy.
Basically to check if a payment belongs to a pubkey (Q,R), the full
node needs to check if R' = R + H(dP)*G for each transaction. For this
it needs the private scanning key d.
This sucks, since when I give my d to a full node, he can link all my
transactions. For an online-wallet this may be okay, but not for thin
client synchronisation.
 Ideas
In the following I detail some ideas of me which did not work.
It does not suffice to have a Bloom filter and check if d is
contained since there is no way to recompute d from the equation. If
there were a way to recompute d, the scheme would offer no privacy,
since anyone could compute the private scanning key d and scan for
So, if we modify the scheme we need to be sure that d is kept private.
Multiparty computation may be possible in theory. The full node and
the thin client could collaboratively check R' = R + H(dP)*G, where d
is the private input of the thin client and R, R',P is provided by the
full node. But this is costly and they need to do it for each
transaction. It may be more costly than simply setting up a full node.
I do not think that some kind of search functionality without leaking
the search pattern (PIR?) would work, since the full node needs to compute on the
data it has found. And further it needs to retrieve the whole Merkle
Any better ideas?

@_date: 2017-05-06 11:38:06
@_author: Henning Kopp 
@_subject: [bitcoin-dev] Combining SPV and Stealth addresses 
Sorry, I cannot quite follow you. What do you mean with flag?
Am 04.05.2017 um 18:23 schrieb Chris Pacia:
