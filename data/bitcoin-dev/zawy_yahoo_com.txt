
@_date: 2017-10-09 21:26:50
@_author: Scott Roberts 
@_subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x fork? 
The bitcoin difficulty algorithm does not seem to be a good one.? If there is a fork due to miners seeking maximum profit without due regard to security, users, and nodes, the "better" coin could end up being the minority chain. If 90% of hashrate is really going to at least initially go towards using SegWit2x, BTC would face 10x delays in confirmations until the next difficulty adjustment, negatively affecting its price relative to BTC1, causing further delays from even more miner abandonment (until the next adjustment). The 10% miners remaining on BTC do not inevitably lose by staying to endure 10x delays because they have 10x less competition, and the same situation applies to BTC1 miners. If the prices are the same and stable, all seems well for everyone, other things aside.? But if the BTC price does not fall to reflect the decreased hashrate, the situation seems to be a big problem for both coins: BTC1 miners will jump back to BTC when the difficulty adjustment occurs, initiating a potentially never-ending oscillation between the two coins, potentially worse than what BCH is experiencing.? They will not issue coins too fast like BCH because that is a side effect of the asymmetry in BCH's rise and fall algorithm.
Hard fork to implement a new difficulty algorithm that uses a simple rolling average with a much smaller window.? Many small coins have done this as a way to stop big miners from coming on and then suddenly leaving, leaving constant miners stuck with a high difficulty for the rest of a (long) averaging window.? Even better, adjust the reward based on recent solvetimes to motivate more mining (or less) if the solvetimes are too slow (or too fast).? This will keep keep the coin issuance rate perfectly on schedule with real time.?
I recommend the following for Bitcoin, as fast, simple, and better than any other difficulty algorithm I'm aware of.? This is the result of a lot of work the past year.
=== Begin difficulty algorithm ===# Zawy v6 difficulty algorithm (modified for bitcoin)# Unmodified Zawy v6 for alt coins:?#  My failed attempts at something better:#  Keep negative solvetimes to correct bad timestamps.# Do not be tempted to use:# next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs];# D=difficulty, ST= Solvetime, TS = timestamp, T=TargetSolveTime
# set constants until next hard fork:
T=600;?N=30; # Averaging window. Smoother than N=15, faster response than N=60.X=5; # size of sudden hashrate changes expected as multiple of base hashrate.limit = X^(2/N); # limit rise and fall to protect against timestamp errors & manipulationadjust = 1/(1+0.67/N);? # keeps avg solvetime on track for small N.
# begin difficulty algorithm?
avg_ST=0; # avg SolveTimeavg_D=0;for ( i=height;? i > height-N;? i--) {? # go through N most recent blocks? ?avg_ST += (TS[i] - TS[i-1]) / N; # TS=timestamps? ?avg_D += D[i]/N;}avg_ST = T*limit if avg_ST > T*limit;?avg_ST = T/limit if avg_ST < T/limit;?
next_D = avg_D * T / avg_ST * adjust;?
# Tim Olsen suggested changing coin reward to protect against hash attacks.# Karbowanek coin suggested something similar.# After testing many ideas, I could not find anything better than the simplest idea below.# It was a surprise that coin issuance rate came out perfect.# BaseReward = coins per block
next_reward = BaseReward * avg_ST / T;
======= end algo ====
Due to the limit and keeping negative solvetimes in a true average, timestamp errors resulting in negative solvetimes are corrected in the next block. Otherwise, one would need to do like Zcash and cause a 5-block delay in the response by resorting to the median of past 11 blocks (MTP) as the most recent timestamp, offsetting the timestamps from their corresponding difficulties by 5 blocks. (it does not cause an averaging problem, but it does cause a 5-block delay in the response.)
Small N windows like keep the correct median, but cause avg solvetime to be above the target. The "adjust" constant (empirically determined) fixes this, but it causes the median to be that same percentage too low, below the ideal Poisson median which is 0.693 of the mean. I was not able to find a fix to this that did not slow down the response to hashrate changes.

@_date: 2017-10-09 22:57:32
@_author: Scott Roberts 
@_subject: [bitcoin-dev] New difficulty algorithm needed for SegWit2x fork? 
Sorry, my previous email did not have the plain text I intended.
Background: The bitcoin difficulty algorithm does not seem to be a good one. If there is a fork due to miners seeking maximum profit without due regard to security, users, and nodes, the "better" coin could end up being the minority chain. If 90% of hashrate is really going to at least initially go towards using SegWit2x, BTC would face 10x delays in confirmations until the next difficulty adjustment, negatively affecting its price relative to BTC1, causing further delays from even more miner abandonment (until the next adjustment). The 10% miners remaining on BTC do not inevitably lose by staying to endure 10x delays because they have 10x less competition, and the same situation applies to BTC1 miners. If the prices are the same and stable, all seems well for everyone, other things aside. But if the BTC price does not fall to reflect the decreased hashrate, he situation seems to be a big problem for both coins: BTC1 miners will jump back to BTC when the difficulty adjustment occurs, initiating a potentially never-ending oscillation between the two coins, potentially worse than what BCH is experiencing.  They will not issue coins too fast like BCH because that is a side effect of the asymmetry in BCH's rise and fall algorithm. Solution: Hard fork to implement a new difficulty algorithm that uses a simple rolling average with a much smaller window.  Many small coins have done this as a way to stop big miners from coming on and then suddenly leaving, leaving constant miners stuck with a high difficulty for the rest of a (long) averaging window.  Even better, adjust the reward based on recent solvetimes to motivate more mining (or less) if the solvetimes are too slow (or too fast). This will keep keep coin issuance rate perfectly on schedule with real time. I recommend the following for Bitcoin, as fast, simple, and better than any other difficulty algorithm I'm aware of.  This is the result of a lot of work the past year. === Begin difficulty algorithm === # Zawy v6 difficulty algorithm (modified for bitcoin) # Unmodified Zawy v6 for alt coins: #  # All my failed attempts at something better: #  # # Keep negative solvetimes to correct bad timestamps. # Do not be tempted to use: # next_D = sum(last N Ds) * T / [max(last N TSs) - min(last N TSs]; # ST= Solvetime, TS = timestamp # set constants until next hard fork: T=600; # coin's TargetSolvetime N=30; # Averaging window. Smoother than N=15, faster response than N=60. X=5; limit = X^(2/N); # limit rise and fall in case of timestamp manipulation adjust = 1/(1+0.67/N);  # keeps avg solvetime on track # begin difficulty algorithm avg_ST=0; avg_D=0; for ( i=height;  i > height-N;  i--) {  # go through N most recent blocks avg_ST += (TS[i] - TS[i-1]) / N; avg_D += D[i]/N; } avg_ST = T*limit if avg_ST > T*limit; avg_ST = T/limit if avg_ST < T/limit; next_D = avg_D * T / avg_ST * adjust; # Tim Olsen suggested changing reward to protect against hash attacks. # Karbowanek coin suggested something similar. # I could not find anything better than the simplest idea below. # It was a great surprise that coin issuance rate came out perfect. # BaseReward = coins per block next_reward = BaseReward * avg_ST / T; ======= end algo ==== Due to the limit and keeping negative solvetimes in a true average, timestamp errors resulting in negative solvetimes are corrected in the next block. Otherwise, one would need to do like Zcash and cause a 5-block delay in the response by resorting to the median of past 11 blocks (MPT) as the most recent timestamp, offsetting the timestamps from their corresponding difficulties by 5 blocks. (it does not cause an averaging problem, but it does cause a 5-block delay in the response.)

@_date: 2017-10-11 01:29:54
@_author: Scott Roberts 
@_subject: [bitcoin-dev] New difficulty algorithm needed for 
I agree: a new difficulty algorithm starting from zero is inconceivably rushed. But it's also inconceivable to not have one ready in two months if my understanding of our current situation is correct. Is there any complaint or suggestion about this algorithm or the appropriate goals of an ideal difficulty algorithm? I feel like there is a discussion that needs to be hashed out before a draft BIP at the HF page, but I do not know where is best or who would be interested. If the community shows it is receptive and supportive I think I could get Karbowanek coin to put it into live action and solicit hash attacks. They are currently using a simpler N=17 like this since last November. They have tested all my attempted improvements the past few months, so they are familiar with all the in and outs. This particular coin split is looking different. Assuming users currently prefer SW, it still seems like miner support is going to convince enough users that SegWit2x is a worthy if not superior alternative. The result could be both coins oscillating with long delays, as long as the price is similar. As soon as it is not similar, maybe the loser will be in a death spiral, pushed to the margin like previous coins. This might be a bitcoin feature. But the 2016 window seems like it is too brutal. It seems like it will result in an accidental winner before the better coin can be determined by more rational means.

@_date: 2017-10-11 14:50:20
@_author: Scott Roberts 
@_subject: [bitcoin-dev]  New difficulty algorithm part 2 
(This is new thread because I'm having trouble getting yahoo mail to use "reply-to", copy-pasting the subject did not work, and the list has not approved my gmail)
A hard fork in the near term is feasible only post-disaster (in my mind, that means Core failing from long transaction delays that destroys confidence and therefore price). A hard fork attempt to fix the situation will not work unless the difficulty is fixed to let price guide hash power instead of vice versa. We seem to be headed towards letting the tail wag the dog. BTC may find itself in the same position as BCH and all alts: the current difficulty algorithm is untenable and will require a fork. Current difficulty algorithm in presence of higher hashrate coin with the same POW: lower hashpower => wait times => lost confidence => lower price => defeat Difficulty algorithms that alts find absolutely necessary when there is a higher hash rate coin with the same POW: hodler faith => price => hashpower => survivable coin Alt experience time and time again is that Core will have to fork to a faster responding difficulty algorithm if it finds itself suddenly (and for the first time) with a lower hashrate.  I define "users" as those who it it for value transfer (including purchases) without concern for long-term value. If SegWit2x reduces fees per coin, then hashpower is being aligned with their short-term interests. It does not solve it, but it is a pre-requisite if the coin has a lower hashrate (BTC at end of November). A faster responding diffulty is a pre-requisite in minority hashrate coins for letting price (hodlers) dictate hashpower instead of vice versa. This is the experience of alts.  Not when hodlers are more evenly split between coins. Miners will prefer the coin with higher transaction fees which will erode hodler confidence via longer delays. This means transaction fees will evolve to the highest that common marketplace users can accepet (they are not intereseted in hodler security), not the lowest technologically feasible fee that provides the greatest security. Large blocks reduce network security while giving the higher total transaction fees to miners even as it can reduce fees per coin for users. The mining "lobby" will always describe this as "best for users". Non-hodling users and miners logically prefer SegWit2x.  its detriment due to sudden hashpower oscillations BCH has survived this long because they did NOT use the bitcoin difficulty algorithm. Granted, it is a bad design that included an asymmetry that has resulted in too many coins being issued. If they had inverted the decrease rule to create a symmetrically fast increase rule instead of keeping bitcoin's increase logic, they would be in much better shape, much better than the bitcoin difficulty algorithm. Making it symmetrical and fast would have resulted in more obvious fast oscillations, but this would have helped price discovery to settle the oscillations to an acceptable level that could stabilize the price by preventing too many coins from being issued. Oscillations require: 1) comparable price and 2) miners having the option to go back and forth to a larger coin. Bitcoin's long, jumping difficulty averaging window may destroy the minority hashrate coin faster in fewer oscillations thanks to a first-to-market effect more than reason. In persuit of higher total transacton fees, miners are deciding SegWit2x is "first-to-market" to cause Core to have long delays. This is not a conspiracy, but simply seeking profit. Since fees per coin can also be reduced, they can convince themselves and others that it is the best option. A shorter difficulty algorithm averaging window enables more, faster oscillations to enable better price discovery before a winner is chosen. The design I'm proposing should be close to the ideal.  For example, Mark Friedenbach suggested a difficulty adjustment every 18 blocks by averaging the past 36 blocks. If a coin using that has the minority hashrate, then it could quickly develop into a sudden influx from the majority change for 18 blocks, then they exit back to the majority chain for 36 blocks before doing it again. They get 1/3 of the blocks at "zero excess cost" (difficulty will be 1/10 the correct value if they are 10x base hashrate) and then they will leave the constant miners with a higher difficulty for 36 blocks (at 3.33x higher difficulty if the "attackers" are 10x the base hashrate). This forces constant miners to start copying them, amplifying the oscillations and delays of the minority hashrate coin. A rolling average window of any length does not theoretically prevent this, unless the window is short enough to be comparable to the time cost of switching coins, if there is a time cost. A say this because in testing I was able to design an attack algorithm that always gets 1/3 of the coins at "zero excess cost".  But a rolling average with a shorter window should make the "accidental collusion" of miners seeking profit more unlikely to occur. The reward function I've proposed appears to reduce it to 1/6 total coins obtainable at "zero excess cost", and similarly reduce oscillations and assist better price discovery.
