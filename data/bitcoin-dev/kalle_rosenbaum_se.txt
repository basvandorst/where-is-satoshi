
@_date: 2015-04-22 22:03:47
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
Hi again
I've built a proof-of-concept for Proof of Payment. It's available at
 The site contains links to the source code
for both the server and a Mycelium fork as well as pre-built apk:s.
I'm still very interested in feedback on this, so please let me know what
you think.
Stuff that has come up so far, and my answers:
* Some people think it's too complicated. I disagree. Using transactions as
the data structure actually makes it simple to implement both on the server
and in wallets. Just use existing wallet software to sign and verify PoPs.
* Other ideas on Proof of Payment use a single key from the proven
transaction, for example the first key from the first input of the
transaction. This is problematic when multisig and other P2SH transactions
are used. I also think that it's necessary to use *all* credentials used
for the transaction. Otherwise we wouldn't be sure that the sender actually
have all the needed credentials.
* Another suggestion is that a payment request from BIP70 is used as proof.
That is possible, but it's reusable which makes it inappropriate to send
over networks; If it is stolen somewhere, anyone can use it as many times
they like. As stated in BIP70, the payment request is suitable for dispute
resolution, more like a receipt. On the other hand, I think that PoP would
fit nicely into the workflow of BIP70: a) Read a url for the PoP request,
b) get the (possibly signed) PoP request. c) send the PoP through http POST
to the URL in the PoP request, d) profit!
* A thought of my own: The txid used in the PoP output is not strictly
necessary. It's more of a convenience for the verifier of the PoP. Without
it, the verifier would need to lookup the transaction based on the inputs
of the PoP,
Kalle Rosenbaum
2015-03-14 19:16 GMT+01:00 Kalle Rosenbaum :

@_date: 2015-04-23 16:39:15
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
Hi Martin,
Thank you very much for your comments. See my answers inline:
Den 23 apr 2015 03:28 skrev "Martin Lie" :
requesting/sending them as an extension of BIP-70.
Me too!
necessary. Perhaps this should be reflected in the sequence of bits/bytes
in the record you're proposing, e.g. "OP_RETURN POP_LITERAL  "?
I was thinking that txid should be mandatory just as the nonce so the order
was arbitrarily chosen. I think you may be right that it's more intuitive
to put txid last if it's not mandatory in a future version. It makes sense
to swap order. I'll put that on my todo list.
than a txid? Perhaps a txid field shouldn't be "hardcoded" into the
standard at all?
prefix that determines how the rest of the records should be interpreted,
i.e. a "type" (or "purpose" or "version" or whatever you'd like to call it)
field. This would allow for different purposes/versions of a PoP, including
as of now unforeseen ones.
(and length) of the POP_PREFIX, but if your literal is used, it'd be 3
bytes: 0x506f50.
as opposed to human-readable text, so perhaps the devs wouldn't ACK
something as "wasteful" as using 3 bytes just to identify it as a PoP
record? Obviously, this is a small detail that can be changed at short
notice, but as with all standards - once people start using it, you're
mostly stuck with what you have. ;)
Yes, maybe we could drop POP_PREFIX altogether. The server is expecting a
pop and can therefore just assume it's a pop. No need to explicitly write
that inside the pop. Can you think of a scenario where it is actually
needed. Keeping the POP_PREFIX makes sense only if other transaction-like
data structures with OP_RETURN appears in the same contexts as pops. What
do you think?
that the payload contains a txid.
This is a good idea. Todo!
Euhm, well, I don't know... The bigger the better. If we drop POP_PREFIX we
could allow for 2 bytes version and 6 bytes nonce. Or 1 byte version and 7
bytes nonce.
e.g. a txid or possibly extra nonce data. Or perhaps some text that makes
the purpose or context of this PoP human-readable? (This could then be
stored by wallets in order to show a list of what kind of proofs you've
For now I think I'll stick to "txid is mandatory".
bytes. Is that due to the 40-byte limitation on OP_RETURN's "data"? Are you
aware that it will be increased to 80 bytes? Cf. https://
Yes, I deliberately limited the data to 40 bytes for that reason. With
versioning, this may change in the future.

@_date: 2015-04-27 14:35:27
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
I like this one, because it shows the power of reusing the transaction data
This is an interesting one.
I guess it's possible, but we'd have to remove the txid from the output,
since there is none. This is a way of saying "I'm in control of these
addresses". The other party/parties can then verify the funds on the
blockchain and watch those addresses for changes. Maybe there are some
interesting use cases here. Ideas?
Yes. Initially I thought it would be enough that the funds are already
spent, but I think you're right here. Reorgs could be a problem. Worse, you
also might want to prove 0-confirmation transactions, in which case it's a
huge security problem. Someone might intercept the PoP and publish it on
the bitcoin network, spending all the funds. But I still would like wallets
to be able to build/verify PoPs with little or no modifications. Could we
possibly change the version number on the PoP to something other than 1?
Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,
just delayed. Any suggestions here?
Thank you very much for your comments!

@_date: 2015-04-27 14:41:51
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
"Or a really high lock_time, but it would not make it invalid, just
Ok, this was a bad idea, since nodes would have to keep it in memory.
Please disregard that idea...
Den 27 apr 2015 14:35 skrev "Kalle Rosenbaum" :
data structure.
since there is none. This is a way of saying "I'm in control of these
addresses". The other party/parties can then verify the funds on the
blockchain and watch those addresses for changes. Maybe there are some
interesting use cases here. Ideas?
spent, but I think you're right here. Reorgs could be a problem. Worse, you
also might want to prove 0-confirmation transactions, in which case it's a
huge security problem. Someone might intercept the PoP and publish it on
the bitcoin network, spending all the funds. But I still would like wallets
to be able to build/verify PoPs with little or no modifications. Could we
possibly change the version number on the PoP to something other than 1?
Maybe 2^4-1? Or a really high lock_time, but it would not make it invalid,
just delayed. Any suggestions here?

@_date: 2015-04-28 14:41:40
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
Hi Jorge,
I don't think I understand the question. Proof of Payment is used to prove
that you have the credentials needed for a certain transaction. It does not
care where in the blockchain the transaction is. Or if it's in the
blockchain at all.
So at the low level, how does a "proof of payment" differ from just proving
that a given transaction is in a given block (what SPV nodes take as proof
of payment today)?

@_date: 2015-07-23 12:21:55
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Process for BIP number allocation 
Hi all
I suggest that we add to the "BIP Editor Responsibilities & Workflow"
section of BIP0001 that if the BIP editor for some reason won't handle
the BIP within a week, he/she should notify the author within that
same week with an estimate on when it will be handled.
Maybe we could extend it to two weeks instead, the important thing is
that the author knows what to expect.
I'm trying to get BIP numbers allocated for Proof of Payment. I have
requested it from the BIP editor Gregory Maxwell with CC this list. I
also emailed Gregory in private about it. So far I have not seen any
reaction to my requests.
There are a number of BIP proposals floating arount right now, I don't
know the exact status of them all, but this is roughly how it looks
for some of them:
Date of request, bip Author, Title
july 4, -, Gregory Maxwell, Invalid Block Fork Postmortem
june 29, -, Peter Todd, Full Replace-by-Fee Deployment Schedule
june 22, 101, Gavin Andresen, Increase Maximum Block Size
june 17, 68, Mark Friedenbach, Consensus-enforced transaction
replacement signalled via sequence numbers
june 6, -,Kalle Rosenbaum, Proof of Payment
june 6, -,Kalle Rosenbaum, Proof of Payment URI scheme
june 6, 69?, Kristov Atlas, Lexicographical Indexing of Transaction
Inputs and Outputs
I think that the de facto process for BIP allocation and inclusion in
the bips repository is unclear. When a number is requested, the author
should at least get a reply from the bip editor that the request is
seen by him/her. Also, if the editor disapproves on the BIP for some
reason, the author must be notified somehow within reasonable and
predictable time.

@_date: 2015-07-23 23:36:45
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Process for BIP number allocation 
A PoP-enabled fork of Mycelium is available at
 and the server (validating
code) is available at There's also a demo site using the server code at
 and a demo video at
Mycelium Binaries are also available on the demo site.
2015-07-23 21:29 GMT+02:00, Peter Todd :

@_date: 2015-07-24 08:55:12
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] [Bitcoin-development] BIP for Proof of Payment 
These BIPs have been assigned 120 and 121:
120: Proof of Payment
121: Proof of Payment URI scheme
Den 24 jul 2015 08:27 skrev "Kalle Rosenbaum" :

@_date: 2015-07-26 23:13:49
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] [Bitcoin-development] BIP for Proof of Payment 
(Resending to the new bitcoin-dev list after sending to the old list)
2015-07-25 21:34 GMT+02:00 Jorge Tim?n :
Thank you for pointing this out.
That's right. Bitcoin core now support 80 bytes data by default. And
yes, I was wrong in assuming 40 bytes policy in all implementations,
even if 40 bytes was the limit in bitcoin core at the time of writing
the BIP.
If there's a need to increase the size of the nonce, for example to
128 bits instead of the 48 bits as designed in BIP 120, then we can of
course do that, either now or in a subsequent version of PoP.
As noted before though, a longer nonce also means bigger QR codes
generated from the BIP 121 URIs. So I think that 48 bits is a good
tradeoff right now. And as stated in BIP120, a server generating PoP
requests should try to detect brute force attacks, or at least delay
the response (containing the nonce) by some 100 ms or so.
Do you think we need a bigger nonce? In that case, why?
If PoP later becomes an extension of BIP70, then there is no such size
constraint on the nonce, since it will be part of some kind of (e.g.)
PopRequest message and not contained in a QR encoded URI.

@_date: 2015-07-27 13:21:38
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] [Bitcoin-development] BIP for Proof of Payment 
Ok, Thanks
Den 27 jul 2015 11:08 skrev "Jorge Tim?n" :

@_date: 2015-06-06 16:35:17
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
Following earlier posts on Proof of Payment I'm now proposing the following
BIP (To read it formatted instead, go to
Kalle Rosenbaum
  BIP:   Title: Proof of Payment
  Author: Kalle Rosenbaum   Status: Draft
  Type: Standards Track
  Created: == Abstract ==
This BIP describes how a wallet can prove to a server that it has the
ability to sign a certain transaction.
== Motivation ==
There are several scenarios in which it would be useful to prove that you
have paid for something. For example:
* A pre-paid hotel room where your PoP functions as a key to the door.
* An online video rental service where you pay for a video and watch it on
any device.
* An ad-sign where you pay in advance for e.g. 2 weeks exclusivity. During
this period you can upload new content to the sign whenever you like using
* Log in to a pay site using a PoP.
* A parking lot you pay for monthly and the car authenticates itself using
* A lottery where all participants pay to the same address, and the winner
is selected among the transactions to that address. You exchange the prize
for a PoP for the winning transaction.
With Proof of Payment, these use cases can be achieved without any personal
information (user name, password, e-mail address, etc) being involved.
== Rationale ==
Desirable properties:
# A PoP should be generated on demand.
# It should only be usable once to avoid issues due to theft.
# It should be able to create a PoP for any payment, regardless of script
type (P2SH, P2PKH, etc.).
# It should prove that you have enough credentials to unlock all the inputs
of the proven transaction.
# It should be easy to implement by wallets and servers to ease adoption.
Current methods of proving a payment:
* In BIP0070, the PaymentRequest together with the transactions fulfilling
the request makes some sort of proof. However, it does not meet 1, 2 or 4
and it obviously only meets 3 if the payment is made through BIP0070. Also,
there's no standard way to request/provide the proof. If standardized it
would probably meet 5.
* Signing messages, chosen by the server, with the private keys used to
sign the transaction. This could meet 1 and 2 but probably not 3. This is
not standardized either. 4 Could be met if designed so.
If the script type is P2SH, any satisfying script should do, just like for
a payment. For M-of-N multisig scripts, that would mean that any set of M
keys should be sufficient, not neccesarily the same set of M keys that
signed the transaction. This is important because strictly demanding the
same set of M keys would undermine the purpose of a multisig address.
== Specification ==
=== Data structure ===
A proof of payment for a transaction T, here called PoP(T), is used to
prove that one has ownership of the credentials needed to unlock all the
inputs of T. It has the exact same structure as a bitcoin transaction with
the same inputs and outputs as T and in the same order as in T. There is
also one OP_RETURN output inserted at index 0, here called the pop output.
This output must have the following format:
 OP_RETURN   ! Field        !! Size [B] !! Description
The value of the pop output is set to the same value as the transaction fee
of T. Also, if the outputs of T contains an OP_RETURN output, that output
must not be included in the PoP because there can only be one OP_RETURN
output in a transaction. The value of that OP_RETURN output is instead
added to the value of the pop output.
An illustration of the PoP data structure and its original payment is shown
  T
 +----------------------------------------------+
inputs       | outputs                        |
       Value | Value   Script                 |
 +----------------------------------------------+
input0 1     |     0   pay to A               |
input1 3     |     2   OP_RETURN   |
input2 4     |     1   pay to B               |
             |     4   pay to C               |
 +----------------------------------------------+
  PoP(T)
 +----------------------------------------------------------+
inputs       | outputs                                    |
       Value | Value   Script                             |
 +----------------------------------------------------------+
input0 1     |     3   OP_RETURN    |
input1 3     |     0   pay to A                           |
input2 4     |     1   pay to B                           |
             |     4   pay to C                           |
 +----------------------------------------------------------+
The PoP is signed using the same signing process that is used for bitcoin
The purpose of the nonce is to make it harder to use a stolen PoP; Once the
PoP has reached the server, that PoP is useless since the server will
generate a new nonce for every PoP request.
Since a PoP is indistinguishable from a bitcoin transaction, there is a
risk that it, accidently or maliciously, enters the bitcoin p2p network. If
T is still unconfirmed, or if a reorg takes place, chances are that PoP(T)
ends up in a block, invalidating T. Therefore it is important that the
outputs of the PoP are the same as in T. The zero transaction fee in PoP(T)
is to minimize the incentives for miners to select PoP(T) for inclusion.
=== Process ===
# A proof of payment request is sent from the server to the wallet. The PoP
request contains:
 a random nonce
 a destination where to send the PoP, for example a https URL
 data hinting the wallet which transaction to create a proof for. For
 txid, if known by the server
 PaymentRequest.PaymentDetails.merchant_data (in case of a BIP0070
 amount, label, message or other information from a BIP0021 URL
# The wallet identifies a transaction T, if possible. Otherwise it asks the
user to select among the ones that match the hints in 1.iii.
# The wallet creates an unsigned PoP (UPoP) for T, and asks the user to
sign it.
# The user confirms
# The UPoP(T) is signed by the wallet, creating PoP(T).
# The PoP is sent to the destination in 1.ii.
# The server receiving the PoP validates it and responds with ?valid? or
# The wallet displays the response in some way to the user.
* The method of transferring the PoP request at step 1 is not specified
here. Instead that is specified in separate specifications. See [btcpop
scheme BIP](btcpop scheme BIP).
* The nonce must be randomly generated by the server for every new PoP
=== Validating a PoP ===
The server needs to validate the PoP and reply with "valid" or "invalid".
That process is outlined below. If any step fails, the validation is
aborted and "invalid" is returned:
# Check the format of the PoP. It must pass normal transaction checks,
except that the inputs may already be spent.
# Check the PoP output at index 0. It must conform to the OP_RETURN output
format outlined above.
# Check that the rest of the outputs exactly corresponds to the outputs of
T and that they appear in the same order as in T. An exception to this is
that any OP_RETURN outputs of T must not be included in the PoP. All output
value from the OP_RETURN must instead be included in the PoP output.
# Check that the nonce is the same as the one you requested.
# Check that the inputs of the PoP are exactly the same as in transaction
T, and in the same order.
# Check the scripts of all the inputs, as would be done on a normal
# Check that the txid in the PoP output is the transaction you actually
want proof for. If you don?t know exactly what transaction you want proof
for, check that the transaction actually pays for the product/service you
# Return "valid".
== Security considerations ==
* Someone can intercept the PoP-request and change the PoP destination so
that the user sends the PoP to the bad actor.
* Someone can intercept the PoP-request and change for example the txid to
trick the user to sign a PoP for another transaction than the intended.
This can of course be avoided if the user is actually looking at the UPoP
before signing it. The bad actor could also set hints for a transaction,
existing or not, that the user didn?t make, resulting in a broken service.
* Someone can steal a PoP and try to use the service hoping to get a
matching nonce. Probability per try: 1/(2^48). The server should have a
mechanism for detecting a brute force attack of this kind, or at least slow
down the process by delaying the PoP request by some 100 ms or so.
* Even if a wallet has no funds it might still be valuable as a generator
for PoPs. This makes it important to keep the security of the wallet after
it has been emptied.
* Transaction malleability may cause the server to have another transaction
id than the wallet for the payment. In that case the wallet will not be
able to prove the transaction for the server. Wallets should not rely on
the transaction id of the outgoing transaction. Instead it should listen
for the transaction on the network and put that in its list of transactions.
The first two issues are the same attack vector as for traditional, ie
BIP0021, bitcoin payments. They could be mitigated by using secure
== Reference implementation ==
[ poppoc on GitHub]
[ Mycelium fork on GitHub]
== References ==
[ BIP0021]:
URI Scheme
[ BIP0070]:
Payment Protocol
[[btcpop scheme BIP]]

@_date: 2015-06-06 16:35:38
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for PoP URI scheme 
Following earlier posts on Proof of Payment I'm now proposing the following
BIP for a Proof of Payment URI scheme (To read it formatted instead, go to
Kalle Rosenbaum
  BIP:   Title: Proof of Payment URI scheme
  Author: Kalle Rosenbaum   Status: Draft
  Type: Standards Track
  Created: == Abstract ==
This is a proposal for a URI scheme to be used in the Proof of Payment
== Motivation ==
To make a Proof of Payment, the party that wants the proof needs to
transfer a Proof of Payment request to the wallet software of the
other party. To facilitate that transfer, a new URI scheme
representing the PoP request is proposed. This URI can then be encoded
in QR images or sent over NFC in order to transfer it to the wallet.
== Specification ==
The specification is the same as BIP0021, with the following
* The URI scheme is btcpop instead of bitcoin
* The path component, i.e. the address part, is always empty.
* A mandatory p parameter whose value contains the destination for
the PoP. This could for example be a https: URL or a mailto:
* A mandatory n parameter representing the nonce, base58 encoded.
* An optional txid parameter containing the Base58 encoded hash of
the transaction to prove.
Just as in BIP0021, elements of the query component may contain
characters outside the valid range. These must first be encoded
according to UTF-8, and then each octet of the corresponding UTF-8
sequence must be percent-encoded as described in RFC 3986.
All parameters except p and n are hints to the
wallet on which transaction to create a PoP for.
The extensibility of BIP0021 applies to this scheme as well. For
example, a date parameter or a toaddr parameter
might be useful. req-* parameters are also allowed and obey
the same rules as in BIP0021, clients not supporting a req-*
parameter must consider the URI invalid.
=== Keep URIs short ===
Implementations should keep the URIs as short as possible. This is
because it makes QR decoding more stable. A camera with a scratched
lens or low resolution may run into problems scanning huge QR
codes. This is why the txid parameter is encoded in Base58
instead of the classic hex encoded string. We get away with 44
characters instead of 64. Also, the nonce parameter is Base58
encoded for the same reason.
== Interpretation ==
=== Transaction hints ===
The wallet processing the URI must use the hints in the PoP request to
filter its transaction set. The label, amount and
message parameters must, if present in the URI, exactly match
the data associated with the original payment according to the
following table:
BIP70 PaymentDetails data
sum of outputs.amount
The txid parameter value must match the transaction hash of
the payment.
After filtering, the resulting transaction set is displayed to the
user who selects one of them to prove. An implementation could also
automatically select a transaction in the filtered set, but
there must still be a way for the user to select freely among the
matching transactions. If the filtered set is empty, no transaction
fits the hints and a message about that is presented to the user. If
the filtered set contains exactly one transaction, which is
preferable, that transaction can be automatically selected.
As a fallback, there must also be a way for the user to select any
transaction from the wallet regardless of the transaction hints. This
can be useful if the metadata of the wallet is lost, possibly due to a
restore from backup.
=== PoP destination p ===
The p parameter value is the destination where to send the
PoP to. This destination is typically a https: URL or a
http: URL, but it could be any type of URI, for example
mailto:. To keep btcpop: URIs short, users should
not make their p parameter unneccesarily long.
==== http: and https: URLs ====
Wallet implementations must support the http: and
https: schemes in which case POST method must be
used. The content type of the POST request must be set to
 Content-Type: application/bitcoin-pop
 Content-Transfer-Encoding: binary
== Examples ==
Send PoP for a transaction with label "video 42923" to
 using nonce 0x73 0xd5
0x1a 0xbb 0xd8 0x9c:
 btcpop:?p= 42923
Send PoP through mail using
mailto:pop at example.com?subject=pop444, amount is 13370000
satoshis, nonce is 0x6f 0xe 0xfb 0x68 0x92 0xf9. Note that
the ? before subject is OK according to RFC3986,
since the query part starts from the first ?:
 btcpop:?p=mailto:pop at example.com?subject%3Dpop444&n=xJdKmEbr&amount=0.1337
Send PoP for transaction with id
to pizza place at using nonce 0xfc 0xcc 0x2c 0x35 0xf0 0xb8
 btcpop:?p=
== Reference implementation ==
[ poppoc on GitHub]
[ Mycelium fork on GitHub]
== References ==
[ BIP21]: URI
[[Proof of Payment BIP]]
[ RFC3986]: Uniform Resource Identifier
(URI): Generic Syntax

@_date: 2015-06-06 17:05:36
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
The idea is to simplify implementation. Existing software can be used
as is to sign and validate PoPs. But I do agree that it would be a
cleaner specification if we would make the PoP invalid as a
transaction. I'm open to changes here. I do like the idea to prepend a
constant string. But that would require changes in transaction signing
and validation code, wouldn't it?
Naming is hard. I think a simpler name that explains what its main
purpose is (prove that you paid for something) is better than a name
that exactly tries to explain what it is. "Proof of transaction
intent" does not help me understand what this is about. But I would
like to see more name suggestions. The name does not prevent people
from using it for other purposes, ie internet over telephone network.
Thank you

@_date: 2015-06-06 18:20:41
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
If we do decide to make Pops invalid as transactions, there are a lot
of ways to do that. I guess the main question is if we should make
Pops invalid as transactions or not. So far I prefer to keep them
valid for the above reason.
I would feel comfortable doing it. It's just a matter of trusting your
wallet, which you already do with your ordinary transactions.
No, I meant that it's ok to call it Proof of Payment even though
people may use it for other stuff.

@_date: 2015-06-06 18:35:50
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
2015-06-06 17:32 GMT+02:00 Peter Todd :
Actually, I suggested that on this list on april 27, but shortly after
rejected my own idea:
"Or a really high lock_time, but it would not make it invalid, just delayed."
Ok, this was a bad idea, since nodes would have to keep it in memory.
Please disregard that idea...
Now I think I rejected it on based on a misunderstanding. Nodes will
not put them in their mempool unless it's value is near in time,
right? From the 0.9.0 release notes: "Accept nLockTime transactions
that finalize in the next block".
In that case this is a really nice option.

@_date: 2015-06-06 19:00:39
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
2015-06-06 18:10 GMT+02:00 Tom Harding :
with the nLocktime solution, the copied outputs are not needed.
I did remore the constant (a "PoP" literal ascii encoded string)
because it didn't add much. The recipient will expect a pop, so it
will simply treat it as one. I did add a 2 byte version field to make
it extendable.
Noted :-)
Thank you

@_date: 2015-06-06 23:25:02
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
Thank you all for the feedback.
I will change the data structure as follows:
* There will be only one output, the "pop output", and no outputs from
T will be copied to the PoP.
* The pop output will have value 0.
* The sequence number of all inputs of the PoP will be set to 0. I
chose to set it to 0 for all inputs for simplicity.
* The lock_time of the PoP is always set to 499999999.
Any comments on this?
2015-06-06 19:00 GMT+02:00 Kalle Rosenbaum :

@_date: 2015-06-15 11:21:06
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
Hi all!
I have made the discussed changes and updated my implementation (
 accordingly. These are the
* There is now only one output, the "pop output", of value 0.
* The sequence number of all inputs of the PoP must be set to 0. I
chose to set it to 0 for all inputs for simplicity.
* The lock_time of the PoP must be set to 499999999 (max block height lock
The comments so far has been mainly positive or neutral. Are there any
major objections against any of the two proposals? If not, I will ask
Gregory Maxwell to assign them BIP numbers.
The two BIP proposals can be found at
 and
 The source
for the Proof of Payment BIP proposal is also in-lined below.
A number of alternative names have been proposed:
* Proof of Potential
* Proof of Control
* Proof of Signature
* Signatory Proof
* Popo: Proof of payment origin
* Pots: Proof of transaction signer
* proof of transaction intent
* Declaration of intent
* Asset-access-and-action-affirmation, AAaAA, or A5
* VeriBit
* CertiBTC
* VBit
* PayID
Given this list, I still think "Proof of Payment" is the most descriptive
to non-technical people.
  BIP:   Title: Proof of Payment
  Author: Kalle Rosenbaum   Status: Draft
  Type: Standards Track
  Created: == Abstract ==
This BIP describes how a wallet can prove to a server that it has the
ability to sign a certain transaction.
== Motivation ==
There are several scenarios in which it would be useful to prove that you
have paid for something. For example:
* A pre-paid hotel room where your PoP functions as a key to the door.
* An online video rental service where you pay for a video and watch it on
any device.
* An ad-sign where you pay in advance for e.g. 2 weeks exclusivity. During
this period you can upload new content to the sign whenever you like using
* Log in to a pay site using a PoP.
* A parking lot you pay for monthly and the car authenticates itself using
* A lottery where all participants pay to the same address, and the winner
is selected among the transactions to that address. You exchange the prize
for a PoP for the winning transaction.
With Proof of Payment, these use cases can be achieved without any personal
information (user name, password, e-mail address, etc) being involved.
== Rationale ==
Desirable properties:
# A PoP should be generated on demand.
# It should only be usable once to avoid issues due to theft.
# It should be able to create a PoP for any payment, regardless of script
type (P2SH, P2PKH, etc.).
# It should prove that you have enough credentials to unlock all the inputs
of the proven transaction.
# It should be easy to implement by wallets and servers to ease adoption.
Current methods of proving a payment:
* In BIP0070, the PaymentRequest together with the transactions fulfilling
the request makes some sort of proof. However, it does not meet 1, 2 or 4
and it obviously only meets 3 if the payment is made through BIP0070. Also,
there's no standard way to request/provide the proof. If standardized it
would probably meet 5.
* Signing messages, chosen by the server, with the private keys used to
sign the transaction. This could meet 1 and 2 but probably not 3. This is
not standardized either. 4 Could be met if designed so.
If an input script type is P2SH, any satisfying script should do, just as
if it was a payment. For M-of-N multisig scripts, that would mean that any
set of M keys should be sufficient, not neccesarily the same set of M keys
that signed the transaction. This is important because strictly demanding
the same set of M keys would defeat the purpose of a multisig address.
== Specification ==
=== Data structure ===
A proof of payment for a transaction T, here called PoP(T), is used to
prove that one has ownership of the credentials needed to unlock all the
inputs of T. It has the exact same structure as a bitcoin transaction with
the same inputs as T and in the same order as in T, but with each sequence
number set to 0. There is exactly one output, here called the pop output,
with value 0. The pop output must have the following format:
 OP_RETURN   ! Field        !! Size [B] !! Description
The lock_time of the PoP must be set to 499999999 to prevent the PoP from
being included in a block, should it appear on the bitcoin p2p network.
This is also the reason for setting the sequence numbers to 0, since
sequence number of ffffffff would make lock_time ineffective. This
specification demands that all input sequence numbers are 0, not just one
of them, which would be sufficient to make lock_time effective. This is for
simplicity reasons.
An illustration of the PoP data structure and its original payment is shown
  T
 +------------------------------------------------+
inputs                | outputs                 |
       Value,Sequence | Value,Script            |
 +------------------------------------------------+
input0 1,ffffffff     | 0,pay to A              |
input1 3,ffffffff     | 2,OP_RETURN  |
input2 4,ffffffff     | 1,pay to B              |
                      | 4,pay to C              |
 +------------------------------------------------+
  PoP(T)
 +-------------------------------------------------------------+
 inputs               | outputs                              |
       Value,Sequence | Value,Script                         |
 +-------------------------------------------------------------+
input0 1,00000000     | 0,OP_RETURN    |
input1 3,00000000     |                                      |
input2 4,00000000     |                                      |
 +-------------------------------------------------------------+
 lock_time=499999999                                         |
 +-------------------------------------------------------------+
The PoP is signed using the same signing process that is used for bitcoin
The purpose of the nonce is to make it harder to use a stolen PoP; Once the
PoP has reached the server, that PoP is useless since the server will
generate a new nonce for every PoP request.
=== Process ===
# A proof of payment request is sent from the server to the wallet. The PoP
request contains:
 a random nonce
 a destination where to send the PoP, for example a https URL
 data hinting the wallet which transaction to create a proof for. For
 txid, if known by the server
 PaymentRequest.PaymentDetails.merchant_data (in case of a BIP0070
 amount, label, message or other information from a BIP0021 URI
# The wallet identifies a transaction T, if possible. Otherwise it asks the
user to select among the ones that match the hints in 1.iii.
# The wallet creates an unsigned PoP (UPoP) for T, and asks the user to
sign it.
# The user confirms
# The UPoP(T) is signed by the wallet, creating PoP(T).
# The PoP is sent to the destination in 1.ii.
# The server receiving the PoP validates it and responds with ?valid? or
# The wallet displays the response in some way to the user.
* The method of transferring the PoP request at step 1 is not specified
here. Instead that is specified in separate specifications. See [btcpop
scheme BIP](btcpop scheme BIP).
* The nonce must be randomly generated by the server for every new PoP
=== Validating a PoP ===
The server needs to validate the PoP and reply with "valid" or "invalid".
That process is outlined below. If any step fails, the validation is
aborted and "invalid" is returned:
# Check the format of the PoP. It must pass normal transaction checks,
except that the inputs may already be spent.
# Check that lock_time is 499999999.
# Check that there is exactly one output. This output must have value 0 and
conform to the OP_RETURN output format outlined above.
# Check that the nonce is the same as the one requested.
# Check that the inputs of the PoP are exactly the same as in transaction
T, except that the sequence numbers must all be 0. The ordering of the
inputs must also be the same as in T.
# Run the scripts of all the inputs. All scipts must return true.
# Check that the txid in the PoP output is the transaction you actually
want proof for. If you don?t know exactly what transaction you want proof
for, check that the transaction actually pays for the product/service you
# Return "valid".
== Security considerations ==
* Someone can intercept the PoP-request and change any parameter in it.
These can be mitigated by using secure connections. For example:
** Pop destination - Stealing your PoP.
** label - Trick you to sign an unintended pop or set a label that your
wallet doesn't have any record for, resulting in a broken service. Always
check the PoP before signing.
** nonce - Your pop will not validate on server.
* Someone can steal a PoP, for example by tampering with the PoP request,
and try to use the service hoping to get a matching nonce. Probability per
try: 1/(2^48). The server should have a mechanism for detecting a brute
force attack of this kind, or at least slow down the process by delaying
the PoP request by some 100 ms or so.
* Even if a wallet has no funds it might still be valuable as a generator
for PoPs. This makes it important to keep the security of the wallet after
it has been emptied.
* Transaction malleability may cause the server to have another transaction
id for a payment than the client's wallet. In that case the wallet will not
be able to prove the transaction to the server. Wallets should not rely on
the transaction id of the outgoing transaction. Instead it should listen
for the transaction on the network and put that in its list of transactions.
== Reference implementation ==
[ poppoc on GitHub]
[ Mycelium fork on GitHub]
== References ==
[ BIP0021]:
URI Scheme
[ BIP0070]:
Payment Protocol
[[btcpop scheme BIP]]
2015-06-06 23:25 GMT+02:00 Kalle Rosenbaum :
constant and

@_date: 2015-06-15 13:59:45
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
2015-06-15 12:00 GMT+02:00 Pieter Wuille :
Wallets will have the same ability to make PoPs as they have in making
payments, see my motivation and rationale sections. CoinJoin is not
compatible with PoP, Luke-Jr brought that up a week ago:
"This appears to be incompatible with CoinJoin at least. Maybe there's some
clean way to avoid that by using
 ?"
I'm not sure if we will be able to support PoP with CoinJoin. Maybe
someone with more insight into CoinJoin have some input?
I don't understand this. The pop includes a nonce randomly generated
by the server. If you're very lucky, 1/(2^48) per try, you can reuse a
If you pay as you use the service (ie pay for coffee upfront), there's
no need for PoP. Please see the Motivation section. But you are right
that you must have the wallet(s) that paid at hand when you issue a
Please elaborate, I don't understand what you mean here.

@_date: 2015-06-16 14:12:49
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
2015-06-16 7:26 GMT+02:00 Tom Harding :
Do you mean that it will be hard to explain to merchants that they
must check the nonce in the PoP so that it matches the nonce in the
pop request? I think not, this is a commonly used pattern that anyone
should be able to grasp. Anyway, merchants will probably use a library
(though yet non-existing) for PoP, that will hide the gory details. I
also think that payment providers may want to add PoP to their
offering to customers (merchants).

@_date: 2015-06-16 14:31:19
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
Another thing worth mentioning is that an SPV wallet cannot validate a
PoP without fetching the input transactions of the PoP from an
external (not bitcoin network) source, for example chain.com or some
other trusted full node's API.
The validation of the PoP depends on the external source(s) being
honest. It can make a valid pop look invalid, but it cannot make an
invalid pop look valid.
2015-06-16 14:12 GMT+02:00 Kalle Rosenbaum :

@_date: 2015-06-16 18:22:40
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
Thank you for the clarification Tom!
2015-06-16 16:05 GMT+02:00 Tom Harding :

@_date: 2015-06-16 21:22:54
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
Thank you for your comments Pieter! Please find my answers below.
2015-06-16 16:31 GMT+02:00 Pieter Wuille :
Yes, you are right. It's not compatible with CoinJoin and the likes.
The nonce is limited because of the OP_RETURN output being limited to
40 bytes of data: 2 bytes version, 32 bytes txid, 6 bytes nonce.
You are saying that it's a problem that the wallet used to pay, must
also be used to issue the PoP? That may very well be a problem in some
cases. People using PoP should of course be aware of it's limitations
and act accordingly, i.e. don't pay for concert tickets for a friend
and expect your friend to be able to enter the arena with her wallet.
As Tom Harding noted, it is possible to transfer keys to your friend's
wallet, but that might not be desirable if those keys are also used
for other payments. Also that would weaken the security of an HD
wallet, since a chain code along with a private key would reveal all
keys in that tree. Another solution is that your friend forwards the
PoP request to your wallet, through twitter or SMS, and you send the
PoP for her. Maybe that forwarding mechanism can be built into wallets
and automated so that the wallet automatically suggests to sign the
PoP for your friend. This is probably something to investigate
further, but not within the scope of this BIP.
Of course the simplest solution would be to send money to your friend
first so that she can pay for the ticket from her own wallet, but
that's not always feasible.
That token would then be reusable. Someone stealing it would be able
to use it as much as she wants. That is what I want to avoid with PoP.
The BIP proposal briefly mentions something like this in the
rationale. I also had a discussion about this with Mike Hearn on this
list on Mars 13 that I think covers most pros and cons of the
different approaches.
While your suggestion does indeed separate the transaction from the
proof of payment, it also assumes that the token is held in the wallet
that pays. Otherwise you would need to keep it in another safe place,
remember it's reusable. Where would that be? How would you transfer
that token to your friend?
Thank you again for your comments. I appreciate it.
Best regards,

@_date: 2015-06-17 11:51:54
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
2015-06-16 21:48 GMT+02:00 Pieter Wuille :
You are probably right here. The thing is that I don't know how *all*
wallet signing and validating software is written, so I figure it's
better to stick to a "valid" output. Since I don't *need* more data
than 40 bytes, why bother. There's another constraint to this as well:
The other BIP proposal, "Proof of Payment URI scheme", includes a
nonce parameter in the URI. If the nonce is very long, the QR code
will be unnecessarily big. The server should try to detect a brute
force of the 48 bit nonce, or at least delay the pop requests by some
100 ms or so.
Do you think this is an actual problem, and why? Is your suggestion to
use a bigger nonce, given the above?
That's right. That's one use case. You pay for the 1-week entrance and
then you use your wallet to sign PoPs when you enter the venue.
Yes, that is possible. It's about the same as giving out a
username/password for a service that you have paid for. In the case of
a concert ticket, it's simple. Just allow one entrance per payment.
But in the example you gave, it's a bit more complicated. You could
for example give all guests a bracelet upon first entry or upon first
exit. Or you can put a stamp on people leaving the venue, and demand
that all re-entries show the stamp, possibly along with a new PoP.
Pretty much as is done already. Different use cases will need
different protection. In this example, the value added by PoP is that
the venue does not have to distribute tickets in advance. This in turn
allows for better privacy for the customer, who don't have to give out
personal information such as an email-address.
Yes, that's a difference, but it comes at the cost of security. The
stolen token can be used over and over. In the case of PoP it's only
usable once, and it's only created when it's actually needed,
minimizing the window of opportunity for the thief.

@_date: 2015-06-21 16:39:24
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
Hi Greg!
After a lot of constructive discussion, feedback and updating, I'm
requesting that you please assign these proposals BIP numbers. It's both
the "Proof of Payment" proposal and the "Proof of Payment URI scheme"
proposal that I'm referring to.
The wikimedia source is available here:
 and
Is this what you need in order to proceed or is there something else you
need from me?
Best regards,
2015-06-17 11:51 GMT+02:00 Kalle Rosenbaum :

@_date: 2015-06-22 22:27:19
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Draft BIP : fixed-schedule block size increase 
Thank you!
A few questions/comments:
* In the specification, you refer to "t_start". I guess you mean "time_start"?
* Miners can, especially when close to a block doubling or shortly
after activation, to some extent manipulate max block size by
manipulating the time stamp in the block header within valid limits.
According to the pseudo code in the specification, the first and a
handful of subsequent blocks after activation could actually have
negative max block sizes due to this (depending on how you define the
% operator of the pseudo code). I haven't checked the reference
implementation, but I do think that the specification section should
explicitly handle this.
2015-06-22 20:18 GMT+02:00 Gavin Andresen :

@_date: 2015-06-25 23:02:25
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] [RFC] IBLT block testing implementation 
2015-06-23 7:53 GMT+02:00 Rusty Russell :
Good to see that you're working on this. Really exciting!
I want to take the opportunity to link to my previous work on IBLTs, for
those that haven't seen it, where I investigate the behaviour of the IBLT
when changing different parameters, like cell count, hashFunctionCount etc:
keyHashSum, in fact you don't use a key at all, but only a
concatenatenation of (txid48, fragid, tx-chunk) as value. Here the
txid48+fragid functions as a kind of keyHashSum. I think this might be a
very good idea,
If you have a false positive with count == 1, then you would probably
detect it if fragid is outside reasonable limit from from base_fragid. Did
you implement your idea to remove all the count==1 fagments in ascending
order of (fragid-base_fragid)?
Anyhow, I think we should make some more comparable tests, just as you
proposed last year when I didn't reply, sorry... My code is a more straight
forward implementation of the IBLT paper (
and encoding blocks is done pretty much as Gavin proposed in his gist. That
should function as a baseline so that we can validate that your
optimizations actually work. Please contact me directly if you are
interested in that, and we'll figure something out.
More comments/questions inline:
There is a chance that the bit prefix of the added or removed tx is not
unique within the receiver's mempool. In that case the receiver can
probably just use the earliest matching transaction and hope for the best.
If not -> bad luck. Is that how you do it?
These exceptional tx *could* instead be encoded in the IBLT, just as if
they were unknown differences. Your bitmaps is probably a more compact
representation, but it's also more complex.
What is the purpose of reencoding when relaying? Is that to improve the
failure probability as new tx may have arrived in the mempool of the
intermediary node?
Yes, I have made some analysis on this here:
 We
use quite different data structures for encoding blocks in IBLT, but it
might apply to your implementation as well. An interesting result is that
the space saving percentage actually increases as blocks grow.
Thank you too!

@_date: 2015-03-13 20:29:42
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
Hi all,
I've been thinking about how a person can prove that she has made a
payment. I came up with an idea I call Proof of Payment (PoP) and I would
highly appreciate your comments. Has something like this been discussed
somewhere before?
*Use cases*
There are several scenarios in which it would be useful to prove that you
have paid for something. For example:
   - A pre-paid hotel room where your PoP functions as a key to the door.
   - An online video rental service where you pay for a video and watch it
   on any device.
   - An ad-sign where you pay in advance for e.g. 2-weeks exclusivity.
   During this period you can upload new content to the sign whenever you like
   using PoP.
   - A lottery where all participants pay to the same address, and the
   winner of the T-shirt is selected among the transactions to that address.
   You exchange the T-shirt for a PoP for the winning transaction.
These use cases can be achieved without any personal information (no
accounts, no e-mails, etc) being involved.
Desirable properties:
   1. A PoP should be generated on demand.
   2. It should only be usable once to avoid issues due to theft.
   3. It should be able to create a PoP for any payment, regardless of
   script type (P2SH, P2PKH, etc.).
Current methods of proving a payment, as I know of:
   - BIP0070, The PaymentRequest together with the transactions fulfilling
   the payment makes some sort of proof. However, it does not meet 1 or 2 and
   it obviously only meets 3 if the payment is made through BIP0070. Also,
   there's no standard way to request/provide the proof.
   - Signing messages, chosen by the entity that the proof is provided to,
   with the private keys used to sign the transaction. This could meet 1 and 2
   but probably not 3. This is not standardized either.
*Proof of Payment, the data structure*
A proof of payment for a transaction T, PoP(T), is used to prove that one
has ownership of the credentials needed to unlock all the inputs of T. It
has the exact same structure as a bitcoin transaction with the same inputs
as T and with a single OP_RETURN output:
OP_RETURN PoP  The PoP is signed using the same signing process that is used for bitcoin
transactions. The purpose of the nonce is to make it harder to use a stolen
PoP. Once the PoP has reached the destination, that PoP is useless since
the destination will generate a new nonce for every PoP.
*Proof of Payment, the process*
   1. A proof of payment request is sent from the server to the wallet. The
   request contains:
      1. a random nonce
      2. a destination where to send the PoP, for example a https URL
      3. data hinting the wallet which transaction to create a proof for.
      For example:
      - txid, if known by the server
         - PaymentRequest.PaymentDetails.merchant_data (in case of a
         BIP0070 payment)
         - amount
         - label, message or other information from a BIP0021 URL
      2. The wallet identifies the transaction T, if possible. Otherwise
   asks the user to select among the ones that fit the hints in 1.3.
   3. The wallet checks that T is on the blockchain, meaning all the inputs
   are spent.
   4. The wallet creates an unsigned PoP (UPoP) for T, and asks the user to
   sign it.
   5. The user confirms
   6. The UPoP(T) is signed by the wallet, creating PoP(T).
   7. The PoP is sent to the destination in 1.2.
   8. The server receiving the PoP validates it and responds with ?valid?
   or ?invalid?
   9. The wallet displays the response in some way to the user.
   - The method of transferring the PoP request at step 1 is not very well
   thought through, but I think we can extend BIP0021 to cater for this. For
   example read a URI, representing a PoP request, using QR code or NFC. A
   more advanced approach would be to extend BIP0070.
   - The nonce must be randomly generated by the server for every new PoP
   request.
*Validating a PoP*
The server needs to validate the PoP and reply with ?valid? or ?invalid?.
That process is outlined below:
   1. Check the format of the PoP. It must pass normal transaction checks,
   except for the inputs being already spent.
   2. Check the output script. It must conform to the OP_RETURN output
   format outlined above.
   3. Check that the nonce is the same as the one you requested.
   4. Check that the txid in the output is the transaction you actually
   want proof for. If you don?t know what transaction you want proof for,
   check that the transaction actually pays for the product/service you
   deliver (in the video rental case, find the transaction among all payments
   for that specific video).
   5. Check that the inputs of the PoP are exactly the same as in
   transaction T.
   6. Check the signatures of all the inputs, as would be done on a normal
   transaction.
   7. If the signatures are valid, the PoP is valid.
*Security issues*
   - Someone can intercept the PoP-request and change the destination so
   that the user sends the PoP to the bad actor.
   - Someone can intercept the PoP-request and change for example the txid
   to trick the user to sign a PoP for another transaction than the intended.
   This can of course be avoided by actually looking at the UPoP before
   signing it. The bad actor could also set hints for a transaction that the
   user didn?t make, resulting in a broken service.
   - Someone can steal a PoP and try to use the service hoping to get a
   matching nonce. Probability per try: 1/(2^40). The server should have
   mechanism for detecting a brute force attack of this kind, or at least slow
   down the process by delaying the PoP request by some 100 ms or so.
   - Even if a wallet has no funds it might still be valuable as a
   generator for PoPs. This makes it important to keep the security of the
   wallet after it has been emptied.
The first two issues are the same as for traditional bitcoin payments. They
could be mitigated by using secure connections and possibly also extending
BIP0070 to support PoPs.
*Further work*
   - Figure out how to make use of, and extend, BIP0070 for the purpose of
   PoPs
   - Define an extension for BIP0021 to support PoP requests (something
   along the lines of BIP0072)
   - Implement a proof-of-concept
   - Possibly propose BIPs for the different parts.
Looking forward to reading your comments
Kalle Rosenbaum

@_date: 2015-03-13 22:47:12
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
No I don't agree with the analysis.
Yes, the PaymentRequest can be stored with the same security as the private
keys are stored. The big difference is that the keys never leave the
wallet. As soon as that PaymentRequest leaves the wallet on its way to the
hotel server, it is up for grabs which makes it inappropriate for use as a
proof of payment other than for resolving disputes and other one-time stuff.
2015-03-13 22:31 GMT+01:00 Mike Hearn :

@_date: 2015-03-14 10:28:01
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
Maybe the hotel example is not perfect for this discussion. Let's instead
assume that the server holds yearly subscriptions to some expensive video
service. If that service stores PaymentRequests for all their subscribers,
and accept them as proof of payment, that would be similar to storing
username and (possibly hashed) passwords for all subscribers. If all the
PaymentRequests for all users are stolen, then they have to shut down all
accounts if they discover the theft. If they don't discover the theft the
"accounts" are out in the wild, for sale, for blackmail, etc.
Wouldn't it be better if the service don't accept the reusable
PaymentRequests as proof, and instead accept a proof generated on demand,
at the very moment it is needed, and that it is only usable once? From a
usability perspective there is no difference; The users simply need access
the service and authorize the proof being sent to the server.
I also hope BIP0070 will take off. It would greatly improve the user
experience. But even then, all payments are not BIP0070. BIP0070 is
primarily for merchants who have the skills, time and money to use
certificates. I don't think a lottery at the local church would want to set
up a secure BIP0070 server, but they still might want to use bitcoin for
their lottery.

@_date: 2015-03-14 19:16:39
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment 
Den 14 mar 2015 00:59 skrev "Patrick Mccorry (PGR)" <
patrick.mccorry at newcastle.ac.uk>:
paying knows that it had received a payment from some public key Q
(regardless of script type, as all scripts require a public key).
The service knows it had received a payment from Q1, Q2,...,Qn. A tx may
have multiple inputs and each input may have several public keys.
zero knowledge proof to demonstrate that I am the owner of Q, and as they
know that Q made a payment - then there is a proof of payment - as this is
provided by the time stamped transaction on the blockchain - in this sense
you are bootstrapping trust from the blockchain.
Ok. Without knowing much about zero knowledge proof, i guess you'd need a
challenge/response for each of the keys Q1,..,Qn. If we settle on only a
single key, what key from what input should we use? One input may be a
multisig (2 of 3) input. Is it ok to settle on only one of the multisig
keys? Probably not. I'd say that we need 2 of 3 signatures (just as in a
bitcoin transaction), and not necessarily the same two that made the
Adding an op_return makes the payment transaction worse as it is now
distinguishable on the blockchain - you want use information that is
already available on that transaction.
I'm not sure I follow. Do you mean that it's a problem that the PoP itself
reveals what transaction I'm proving? Well, maybe it is a problem under
some circumstances. The least you can do to protect yourself from revealing
information to third party is to communicate over secure channels. Could
you please elaborate on this?
Anyway, if both the client and the server knows what transaction to prove
(ad-sign example) you are right that the tx info is kind of redundant. But
if we don't send the tx hints from server to client, the client user must
manually select the transaction to prove which makes the user experience
Thank you very much for your comments,
payment. I came up with an idea I call Proof of Payment (PoP) and I would
highly appreciate your comments. Has something like this been discussed
somewhere before?
you have paid for something. For example:
any device.
this period you can upload new content to the sign whenever you like using
of the T-shirt is selected among the transactions to that address. You
exchange the T-shirt for a PoP for the winning transaction.
accounts, no e-mails, etc) being involved.
type (P2SH, P2PKH, etc.).
the payment makes some sort of proof. However, it does not meet 1 or 2 and
it obviously only meets 3 if the payment is made through BIP0070. Also,
there's no standard way to request/provide the proof.
with the private keys used to sign the transaction. This could meet 1 and 2
but probably not 3. This is not standardized either.
one has ownership of the credentials needed to unlock all the inputs of T.
It has the exact same structure as a bitcoin transaction with the same
inputs as T and with a single OP_RETURN output:
bitcoin transactions. The purpose of the nonce is to make it harder to use
a stolen PoP. Once the PoP has reached the destination, that PoP is useless
since the destination will generate a new nonce for every PoP.
request contains:
user to select among the ones that fit the hints in 1.3.
are spent.
sign it.
thought through, but I think we can extend BIP0021 to cater for this. For
example read a URI, representing a PoP request, using QR code or NFC. A
more advanced approach would be to extend BIP0070.
?invalid?. That process is outlined below:
except for the inputs being already spent.
outlined above.
proof for. If you don?t know what transaction you want proof for, check
that the transaction actually pays for the product/service you deliver (in
the video rental case, find the transaction among all payments for that
specific video).
the user sends the PoP to the bad actor.
trick the user to sign a PoP for another transaction than the intended.
This can of course be avoided by actually looking at the UPoP before
signing it. The bad actor could also set hints for a transaction that the
user didn?t make, resulting in a broken service.
matching nonce. Probability per try: 1/(2^40). The server should have
mechanism for detecting a brute force attack of this kind, or at least slow
down the process by delaying the PoP request by some 100 ms or so.
for PoPs. This makes it important to keep the security of the wallet after
it has been emptied.
They could be mitigated by using secure connections and possibly also
extending BIP0070 to support PoPs.
the lines of BIP0072)

@_date: 2015-05-24 22:45:16
@_author: Kalle Rosenbaum 
@_subject: [Bitcoin-development] Proof of Payment BIP-able? 
Hi all!
As indicated in my first email regarding Proof of Payment (Mars 13, subject
"Proof of Payment"), I would like to BIP it. I have two proposals:
* PoP datastructure and process:
* btcpop: URI scheme:
Basically, my question to the community is: Do you agree that these are
The proposals are not yet BIP formatted, but pretty complete. An
implementation is avaliable at Specifically, the PoP validating code is in PopValidator.java
As far as I can tell from the previous thread, no major objection against
the idea was raised. PoP, if standardized, would bring a lot of utility to
bitcoin: Paysite login, concert tickets, left luggage lockers, lotteries,
video rental, etc.
Further on, I'd like to extend BIP70 to support PoP, but that will have to
wait until we have consensus around the two basic proposals above.
I have received some great feedback from the community and included most of
it in the updated version of the specification. The essential changes are:
* If a PoP for some reason appears in the bitcoin p2p network, we must make
sure that IF it is included in a block it should have minimal impact. The
solution I chose was to include all outputs of the original paymet in the
PoP. That way, if the PoP is included it will not alter the payees. (Thanks
to Tom Harding for pointing out the problem and Magnus Andersson for the
initial solution).
* The check if the transaction is actually a tx that you want proof for is
moved to later in the validation process. Otherwise, one could get
information on what transactions pays for which services by simply sending
erroneously signed PoPs with a transaction id we're interested in.
* A version field of 2 bytes is included. Currently the only valid version
is 0x00 0x01. (Thanks Martin Lie)
* The "PoP" literal is removed. It provides little value as the receiver of
a PoP expects a PoP. (Again, thanks Martin Lie for making me think about
Kalle Rosenbaum

@_date: 2015-09-27 17:10:24
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Weak block thoughts... 
I was mansplaining weak blocks to my wife. She asked a simple question:
Why would I, as a miner, publish a weak block if I find one?
I don't know.
Sure, I will get faster propagation for my solved block, should I find one.
On the other hand everybody else mining a similar block will enjoy the same
benefit. Assuming that I'm not a huge miner, it's unlikely that I will
actually solve the block, so I'm probably just giving away fast propagation
times to someone else.
So how does publishing a weak block benefit the producer of it more than
the other miners? Please help me understand this.
2015-09-27 11:42 GMT+02:00 Tier Nolan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

@_date: 2015-09-28 10:30:42
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Weak block thoughts... 
2015-09-27 21:50 GMT+02:00 Gregory Maxwell :
Suppose that you've solved a block Z (weak or not) and you want to
propagate it using a previous weak block Y. With "efficient differential
transmission", I assume that you refer to the transmission of the
differences between Y and Z to a peer? What encodings are discussed? I
guess IBLTs are a hot candidate, but are there other schemes in the making?
I suppose that sending something like "weak block Y plus transactions A, B,
C minus transaction ids h(D), h(E)" is not considered an efficient
differential transmission. Then that's part of the answer to my question.
"the size sent is proportional to the improvement you get when finding a
block." - This encapsulates the issue quite well! The more exotic block I'm
building, the more I would benefit from publishing a weak block, but my
weak block would also be larger.
Makes perfect sense. Also, if I'm working on an exotic block, the
probability of someone extending my weak block would be low-ish, so I'm not
necessarily "giving away fast propagation times to someone else" as I first
Thank you very much for your explanation.

@_date: 2017-08-28 19:54:59
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Fwd: "Compressed" headers stream 
2017-08-28 19:12 GMT+02:00 Gregory Maxwell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:
 ... and I guess the nonce can be arbitrarily truncated as well, just brute
force the missing bits :-P.
I think that my blog post on compact spv proofs can be helpful also. It
tries to make the pretty compact formulations in the sidechains paper a bit
more graspable by normal people.

@_date: 2017-12-18 09:32:23
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Why not witnessless nodes? 
Dear list,
I find it hard to understand why a full node that does initial block
download also must download witnesses if they are going to skip
verification anyway. If my full node skips signature verification for
blocks earlier than X, it seems the reasons for downloading the
witnesses for those blocks are:
* to be able to send witnesses to other nodes.
* to verify the witness root hash of the blocks
I suppose that it's important to verify the witness root hash because
a bad peer may send me invalid witnesses during initial block
download, and if I don't verify that the witness root hash actually
commits to them, I will get banned by peers requesting the blocks from
me because I send them garbage.
So both the reasons above (there may be more that I don't know about)
are actually the same reason: To be able to send witnesses to others
without getting banned.
What if a node could chose not to download witnesses and thus chose to
send only witnessless blocks to peers. Let's call these nodes
witnessless nodes. Note that witnessless nodes are only witnessless
for blocks up to X. Everything after X is fully verified.
Witnessless nodes would be able to sync faster because it needs to
download less data to calculate their UTXO set. They would therefore
more quickly be able to provide full service to SPV wallets and its
local wallets as well as serving blocks to other witnessless nodes
with same or higher assumevalid block. For witnessless nodes with
lower assumevalid they can serve at least some blocks. It could also
serve blocks to non-segwit nodes.
Do witnessless nodes risk dividing the network in two parts, one
witnessless and one with full nodes, with few connections between the
So basically, what are the reasons not to implement witnessless
Thank you,

@_date: 2017-12-18 14:35:44
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Why not witnessless nodes? 
2017-12-18 13:43 GMT+01:00 Eric Voskuil :
I meant to say "I find it hard to understand why a full node that does
initial block
download also must download witnesses when it is going to skip verification
of the witnesses anyway."
I'm referring to the "assumevalid" feature of Bitcoin Core that skips
signature verification up to block X. Or have I misunderstood assumevalid?

@_date: 2017-12-18 21:34:30
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Why not witnessless nodes? 
Thanks Eric.
It would be a pity if early witnesses got lost due to nodes abandoning them
by running witnessless. But as long as there's at least one accessible
source for them left we're OKish. Let's hope we don't get to that point in
the near future. As long as Bitcoin Core doesn't implement witnessless
mode, there's little risk.
What do people here think about the benefits and risks with running
Sent from my Sinclair ZX81
Den 18 dec. 2017 17:19 skrev "Eric Voskuil" :

@_date: 2017-12-18 22:27:14
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Why not witnessless nodes? 
Hi Mark
Yes, it seems like sign-to-contract protocols, which I just now briefly
read about [1][2], may need to use historic witnesses. That raises the
question, what are Bitcoin witnesses for?
To me it seems witnesses should be regarded as temporary. But it seems both
respondents to this thread, Eric and Mark, mean that witnesses are forever.
I regard witnesses as a way to authenticate updates to the UTXO set, and
once buried deep enough in the blockchain, the witness is no longer needed,
because consensus has formed around the UTXO set update.
Suppose a transaction with an invalid witness happens to enter the
blockchain and gets buried 100000 blocks down with the witness still
available. Is the blockchain above it valid? I'd say the blockchain is
valid and that it was a bug that the transaction made it into the
blockchain. We will have to live with such bugs.
Another way to put it: Suppose that all witnesses from 2017 dissappears
from all nodes in 2020. Is the blockchain still valid? I think so. I would
continue using it without looking back.
With that approach, I think sign-to-contract protocols has to find ways to
work in a witnessless environment. For example, users of such protocols can
setup their own archival nodes.
I'd love to hear alternative views on this.
[2] 2017-12-18 18:30 GMT+01:00 Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

@_date: 2017-12-18 22:51:40
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Why not witnessless nodes? 
Hi Greg,
2017-12-18 21:42 GMT+01:00 Gregory Maxwell :
I'm not going to do any less checks than a node running with assumevalid.
Well not exactly true, because a node running today with assumevalid will
verify the witness root hash, right?
I'm not sure what you are referring to.
Thank you

@_date: 2018-01-26 16:52:10
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] Fix or withdraw BIP120/121? 
There is an inherent problem with BIP120, Proof of Payment: If there
is a soft fork, a server that verifies PoPs will accept a PoP as valid
without checking any of the new Bitcoin rules.
For example, a server will be fooled by a segwit transaction, because
the server doesn't have a witness to verify and consequently will
accept any PoP with an empty scriptSig.
Besides this problem, on-chain payments are not hot anymore and
interest, or need, for PoP as a concept seems low.
I have no good solution for the soft fork problem. Requiring all
software that uses PoP to upgrade to a new PoP specification on each
soft-fork is not good enough. Do you have any ideas on how to fix it?
If there is no good solution to the soft-fork issue, I suggest that I
withdraw BIP120 and BIP121.
As for current implementations: I know that Mycelium implements
BIP120, but I'm not sure if there is any other software, besides my
own, implementing it. If you know of any, please let me know so I can
discuss it with them.

@_date: 2018-03-14 10:46:55
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
Thank you.
I can't really see from your proposal if you had thought of this: A soft
fork can make old nodes accept invalid message signatures as valid. For
example, a "signer" can use a witness version unknown to the verifier to
fool the verifier. Witness version is detectable (just reject unknown
witness versions)  but there may be more subtle changes. Segwit was not
"detectable" in that way, for example.
This is the reason why I withdrew BIP120. If you have thought about the
above, I'd be very interested.
Sent from my Sinclair ZX81
Den 14 mars 2018 16:10 skrev "Karl Johan Alm via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org>:
I am considering writing a replacement for the message signing tools
that are currently broken for all but the legacy 1xx addresses. The
approach (suggested by Pieter Wuille) is to do a script based
approach. This does not seem to require a lot of effort for
implementing in Bitcoin Core*. Below is my proposal for this system:
A new structure SignatureProof is added, which is a simple scriptSig &
witnessProgram container that can be serialized. This is passed out
from/into the signer/verifier.
RPC commands:
sign   [=false]
Generates a signature proof for  using the same method that
would be used to spend coins sent to .**
verify    [=false]
Deserializes and executes the proof using a custom signature checker
whose sighash is derived from . Returns true if the check
succeeds, and false otherwise. The scriptPubKey is derived directly
from .**
Feedback welcome.
(*) Looks like you can simply use VerifyScript with a new signature
checker class. (h/t Nicolas Dorier)
(**) If  is true,  is the sighash, otherwise
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org

@_date: 2018-10-08 20:59:00
@_author: Kalle Rosenbaum 
@_subject: [bitcoin-dev] [BIP Proposal] Nym Enrolment Transaction Template 
Hi ????????,
I won't comment on the usability of/need for this system, but I have a few
random comments and questions:
Why demand exactly one input? This will probably cause problems for wallets
with many small value UTXOs and no big.
Why demand exactly type p2wpkh on input? Why limit at all?
32-byte-nym_public_key is actually 33 bytes, no? Compressed pubkeys are 33
Why verify "SIZE 32 EQUALVERIFY" on output 2? It puts a ceiling on the
entropy, but no floor, so it seems useless.
Why require segwit version 0 change output? This seems like an unnecessary
It's not clear to me what's IsStandard rules and what's nym protocol rules
in the specification section. I interpret the specification to specify
IsStandard rules, but the section also mentions stuff not relevant to that,
for example how the nym signature is constructed and what the opreturn data
consists of. You should make the distinction more clear.
I couldn't find info on what 1-byte-nym_version and 1-byte-nym_use are and
how they are used. But it might not belong in the BIP if it only should
describe IsStandard policies?
Sent from my Sinclair ZX81
Den s?n 7 okt. 2018 05:57???????? via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> skrev:
