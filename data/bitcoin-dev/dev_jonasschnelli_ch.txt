
@_date: 2015-08-11 11:02:07
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Future Of Bitcoin-Cores Wallet 
Hash: SHA256
(excuse my english; it?s not my native language)
As you might noticed, bitcoin-cores wallet didn?t got that much focus
during the last month (even years?).
Wallet development has mostly moved towards SPV (bitcoinj), thin
clients (Electrum), centralized web middleware (Copay, Greenaddress,
Obviously this direction was highly appreciated by users who now can
now run a bitcoin-client (SPV / thin client) on a smartphone or on a
computer with tiny available resources.
Full validation slowly gets a privilege of people who can manage to
run bitcoin-core on a VPS or different server like system.
Thought, i think, running a full node wallet could be end user
friendly with some changes in the current concept.
Today a standard user can download a 1080p 10GB movie over iTunes (in
background) and simultaneous play a CPU/GPU extensive 3D game on a
standard computer.
Why do people think (and it might is) running a full node is so painful?
Mainly it could be because bitcoin-core has been focused on doing
validation as quick as possible (okay for a server, not desirable for
a wallet background service).
I could see the following strategy:
- - end user focused full node wallet would have enabled pruning by
default (~2GB disk usage).
- - throttled validation (flexible CPU usage, user selectable, maybe
~20% by default).
- - throttled block download (bandwidth).
- - SPV during catch up (initial sync as also when catching up multiple
days because user/node was offline).
- - Disable bloom filtering if there is enough bandwith, keep blocks for
later validation.
- - when node is in sync, switch from SPV to full validation (maybe
maintain to lists/dbs of wtx or re-validate after full catchup and
display potential conflicts).
- - participate in p2p, but with limits/throttling (service limited
amount of blocks, tx [TBD]).
- - This could increase the amount of participating full nodes while
giving users more privacy and security.
- - Create a counterweight against SPV/thin clients (avoid wallet
development centralization, could be helpful once/if attacks agains
SPV/thin clients are becoming real).
- - Slowly complete full validation (can take ~1-2 weeks) and thereforce
increase privacy (avoid bloomfilters) and security.
What about SPV together with a full node?
Sounds good in theory. But who can run a full node (see above)? How is
the channel secured (against MITM, privacy) between the SPV client and
the trusted full node? How hard is it to setup and maintain a secure
tunnel between a smartphone SPV and a full node over the p2p (8333)
channel? How about examine the mempool for fee calculations and
(maybe) upcoming CPFP like approaches, etc.?
How about smartphones?
Obviously the above solution won?t probably work on a smartphone (to
much bandwidth and CPU usage). But do you carry your whole saving in
your physical wallet with you? Maybe a smartphone does hold keys which
protects low value / daily spendings like a physical wallet (=SPV okay).
My personal long term vision of that use-case is, that groups of
people who trust each other (a family, etc.) might run one or multiple
full node(s) on a hardened system (something similar to the bitnodes
hardware) where the system could serve smartphones over something like
a stratum server (electrum) or bitpays wallet-service does (index
blockchain, additional wallet services). Every member still holds it?s
keys but they trust the connected full node (full nodes does address
index, balance calculation, multisig arrangements and maybe even coin
Since about one year i slowly work toward this direction. It took me a
while to commit myself to a strategy (and i still shake from time to
At the moment I am working on a wallet focused bitcoin-core fork with
the ability to re-merge it to the bitcoin-core branch (keep the fork
Long term goal is, to decouple the both (wallet / core) by using
bitcoin-core as a library (static or shared) for the wallet side
(which is possible already now)
To myself: I work in the bitcoin-space full-time and completely
independent (not employed or influenced by a bitcoin related company)
with no business interest, though, i think the acquired know-how can
be valuable within the next serval years. And i won?t have any regrets
if my work turns out to be unless and ends up in trash.
I have set up this mail to avoid parallelism on a works stream (if
there is any). Of course i would really appreciate if other developers
are willing to join the team by reviewing, concept critism or
contributing code at Any forms of criticism and any ideas are highly appreciated.

@_date: 2015-07-24 10:48:14
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Bitcoin, Perceptions, and Expectations 
Hash: SHA1
This PR makes absolutely sense.
A documentation or description should reflect how a system works NOW.
Not how it *was working and how it *might work once.
The concept of free transaction just doens't really work well with the
current system and advertising bitcoin with "free transaction" is

@_date: 2015-06-20 12:11:41
@_author: Jonas Schnelli 
@_subject: [Bitcoin-development] Alternate HD path structure: BIP, blog, 
Hash: SHA1
 > m / purpose' / network' / asset_type' / account' / change / index
Hi Matt
In my opinion, HD chain standards like Bip43/44 are there to allow
users to use different wallets with the same seed/wordlist (switch
over or use in parallel).
In practice, wallet re-importing / re-creating is not trivial and has
risks of missing out spent or spendable coins.
Take the current landscape. Electrum doesn?t follow the Bip39 standard
[1]. Breadwallet does not support Bip44 [2].
If users start to think, as long as they keep the Bip39 wordlist save,
nothing can happen, is a material fallacy (and i see a trend into this
A hd seed will not recover your non-blockchain-metadata. HD seed
recovery is a disaster recovery method.
Because of that I am unsure if standards of hd chainstructurs does lead
users and developers into the right directions.
In my opinion, reimporting a hd seed is a experts feature that requires
manual configuration.
Creating deep level chains like m/a/b/c/d/e/f/g/h requires more cpu
power to derive private key with a given seed or wordlist.
If you are using hardware wallets like Trezor or Digitalbitbox, you
probably feel the required time when signing/deriving.
[1] [2]

@_date: 2015-06-22 08:40:15
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Welcome to the new Bitcoin Dev List 
Hash: SHA1
Thanks for the work!
What about updating bitcoin.org (
I guess people start looking there...
Same for this...
Bip0001 needs also an update...

@_date: 2015-05-22 11:00:24
@_author: Jonas Schnelli 
@_subject: [Bitcoin-development] Virtual Notary. 
Hash: SHA1
Hi Emin
This is going into the right direction. Well done!
The certificates (X.509/p12) are far more enduser-friendly than just a
normal PoE hash.
Your site needs some UX love and i just tried to OR_RETURN a
Email-Address-Verification. But after creating a 0.0001 tx and waiting
for two confirmations it still said that the payment has not yet been
received. There is probably something broken regarding the bitcoin
payment verification.
The weather and real estate notarization definitively needs a ?US
only? badge somewhere.
Two ideas:
- - Maybe adding a way of decentralize your notary service log via a
opensource p2p daemon (obviously sensitive data should be somehow
- - Adding a opensource UI app to examine certs (maybe offline capable
with p2p daemon chain as mentioned above). This could prove
independence from your website/service.

@_date: 2015-11-13 08:27:48
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Ads on bitcoin.org website 
Hash: SHA256
Hi all
I'm a little bit concerned about the future of bitcoin.org.
A neutral website that informs about bitcoin, bitcoin-applications and
bitcoin-exchanges is important at this "early stage".
You might have seen that bitcoin.com does not claim to be neutral and
informative. As counterweight, a neutral and ad-free bitcoin.org site
is even more important.
Recently, bitcoin.org did merge a PR [1] that enables Google analytics
for bitcoin.org. The PR comments did show disagreement for this step.
For me, this seems to be against the about-us rules [2] in about "who
is in charge of bitcoin".
Personally I think allowing Google to collect data of bitcoin.org
visitors is against the bitcoin "philosophy".
Another PR [3] (not merged yet) would enable the technical base to
display ads on the site.
What ads would be displayed there?
If an ad provider would be implemented (like Google Ads), very likely
bitcoin related things like bitcoin application vendors or bitcoin
exchanges would be shown there.
Wouldn't this attack the neutrality model of bitcoin.org?
I think, it would move bitcoin.org in the wrong direction, towards
sites like bitcoin.com and it would loose the neutral "feeling" and
users and press very likely will see this as a "greedy" step.
I'd like to know, how changes on bitcoin.org happen? Do they follow
consensus-agreement among bitcoin-space contributors or does a group
of people decide what to merge and what not?
If site operators or contributers need to get payed for their (highly
appreciated) work or need to pay for infrastructure, we should address
this root problem.
I'm pretty sure we can raise funds for a such purpose and I'm offering
my help to speak to bitcoin businesses and individuals.
[1] [2] [3]

@_date: 2015-11-13 09:13:24
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Announcing Jonas Schnelli as GUI maintainer 
Hash: SHA256
Thanks Wladimir!
My long term vision for bitcoin-core was always a more user friendly
UI without loosing the security and privacy features bitcoin-core offers
However, it has shown that this is relatively hard to achieve. Its
unclear to me, what role wallets (and related UIs) will play in the
future of bitcoin. I think it needs several years until something like
bitcoin can be used to "pay for every coffee in the world" [1].
But I'm happy to explore this path!
That was and is also the reason why I'm often focus on non-UI-related
changes that keep bitcoin healthy and form a more defined role for the U
Short words to myself:
I'm a senior software developer, 35 years old, living in Switzerland
Thanks for the trust and I try to give my best to maintain and improve
the GUI.
[1]

@_date: 2015-10-05 14:32:56
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] [Bitcoin-development] New BIP32 structure for 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
What holds you back from using m/i'/45' where i' is your multisig
"account" number?
Within your BIP45 wallet (lets assume Copay), you would not provide
the xpubkey at m/45', instead you would provide your xpubkey at m/i'/45'
It's probably no longer pure BIP45.

@_date: 2015-10-23 08:53:20
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db 
Hash: SHA1
Nice work!
Although not sure if we should focus directly on sqlite4 (could be
optional with a configure flag and a subtree [until stable], sqlite3
supported over depends).
Also i personally would recommend to not implement it as a
replacement, instead, support multiple backends (wrapper header /
different wrapper implementations [leveldb / sqlite3 / sqlite4]). But
? agreed ? should not be the focus, but a nice additional flexibility
if it not require much more work.
And ? in theory ? multiple database back-ends would allow migration.
Before investigating to deep, i think we need a dbwrapper bench tool
that represents our needs and our style how we hit the database.
Gavins recently added bench target / bench environment could be used
for that.

@_date: 2015-09-18 09:04:58
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Weekly development meetings on IRC 
Hash: SHA256
+1 for the weekly IRC meetings.
For time and date maybe a Doodle could help:

@_date: 2015-09-24 11:18:16
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] CI Build for Bitcoin - Some Basic Questions about 
Hash: SHA256
Hi Roy
It's done by the core devs (very likely the project maintainer).
I think it doesn't matter who did the upload to bitcoin.org.
What really would matter is ? if users deciding to run a pre-compiled
version of bitcoin-core ? that they verify the binary against the
available gitian sigs.
Signatur repository:
PGP Pubkeys (mostly also available over gpg key servers):
Instruction available here:

@_date: 2016-04-01 23:09:47
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
I just updated the PR above with another overhaul of the BIP.
It's still under heavy review/work, nevertheless ? at this point ? any
feedback is highly welcome.
Changes since last update:
-> Removed AES256-GCM as cipher suite
-> Focusing on Chacha20-Poly1305 (implementation size ~300L)
-> Two symmetric cipher keys must be calculated by HMAC_SHA512 from the
ecdh secret
-> A session-ID (both directions) must be calculated (HMAC_SHA256) for
linking an identity authentication (ecdsa sig of the session-ID) with
the encryption
-> Re-Keying ('=hash(old_key)') can be announced by the responding peer
(after x minutes and/or after x GB, local peer policy but not shorter
then 10mins).
-> AEAD tag is now the last element in the new message format
It is very likely that the encrypted message format performs slightly
better than the current message format (removing the SHA256 checksum).

@_date: 2016-08-08 17:00:51
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Authentication BIP 
As already mentioned in the recent BIP151 thread
I propose the following authentication scheme to basically allow MITM
detection and rejection in conjunction with BIP151.
The proposed authentication BIP does require BIP151.
The propose BIP does assume, node operators want to build trusted
connections for various reasons.
BIPs mediawiki github page available here:
  BIP: ???
  Title: Peer Authentication
  Author: Jonas Schnelli   Status: Draft
  Type: Standards Track
  Created: 2016-03-23
== Abstract ==
This BIP describes a way how peers can authenticate ? without opening
fingerprinting possibilities ? to other peers to guarantee ownership
and/or allowing to access additional or limited services.
== Motivation ==
We assume peer operators want to limit the access of different services
or increase datastream priorities to a selective subset of peers. Also
we assume peers want to connect to specific peers to broadcast or filter
transactions (or similar action that reveals sensitive informations) and
therefore they want to authenticate the remote peer and make sure that
they have not connected to a MITM.
Benefits with peer authentication:
* Peers could detect MITM attacks when connecting to known peers
* Peers could allow resource hungry transaction filtering only to
specific peers
* Peers could allow access to sensitive information that can lead to
node fingerprinting (fee estimation)
* Peers could allow custom message types (private extensions) to
authenticated peers
A simple authentication scheme based on elliptic cryptography will allow
peers to identify each other and selective allow access to restricted
services or reject the connection if the identity could not be verified.
== Specification ==
The authentication scheme proposed in this BIP uses ECDSA, ___secrets
will never be transmitted___.
___Authentication initialization must only happen if encrypted channels
have been established (according to BIP-151 [1]).___
The ___encryption-session-ID___ is available once channels are encrypted
(according to BIP-151 [1]).
The identity-public-keys used for the authentication must be pre-shared
over a different channel (Mail/PGP, physical paper exchange, etc.). This
BIP does not cover a "trust on first use" (TOFU) concept.
The authentication state must be kept until the encryption/connection
Only one authentication process is allowed per connection.
Re-authenticate require re-establishing the connection.
=== Known-peers and authorized-peers database ===
Each peer that supports p2p authentication must provide two users
editable "databases"
# ___known-peers___ contains known identity-public-keys together with a
network identifier (IP & port), similar to the "known-host" file
supported by openssh.
# ___authorized-peers___ contains authorized identity-public-keys
=== Local identity key management ===
Each peer can configure one identity-key (ECC, 32 bytes) per listening
network interface (IPv4, IPv6, tor).
The according identity-public-key can be shared over a different channel
with other node-operators (or non-validating clients) to grant
authorized access.
=== Authentication procedure ===
Authentication after this BIP will require both sides to authenticate.
Signatures/public-keys will only be revealed if the remote peer could
prove that they already know the remote identity-public-key.
# -> Requesting peer sends `AUTHCHALLENGE` (hash)
# <- Responding peer sends `AUTHREPLY` (signature)
# -> Requesting peer sends `AUTHPROPOSE` (hash)
# <- Responding peer sends `AUTHCHALLENGE` (hash)
# -> Requesting peer sends `AUTHREPLY` (signature)
For privacy reasons, dropping the connection or aborting during the
authentication process must not be possible.
=== `AUTHCHALLENGE` message ===
A peer can send an authentication challenge to see if the responding
peer can produce a valid signature with the expected responding peers
identity-public-key by sending an `AUTHCHALLENGE`-message to the remote
The responding peer needs to check if the hash matches the hash
calculated with his own local identity-public-key. Fingerprinting the
requesting peer is not possible.
32bytes challenge-hash `hash(encryption-session-ID || challenge_type ||
`challenge_type` is a single character. `i` if the
`AUTHCHALLENGE`-message is the first, requesting challenge or `r` if
it's the second, remote peers challenge message.
=== `AUTHREPLY` message ===
A peer must reply an `AUTHCHALLENGE`-message with an `AUTHREPLY`-message.
the encryption-session-ID done with the identity-key
If the challenge-hash from the `AUTHCHALLENGE`-message did not match the
local authentication public-key, the signature must contain 64bytes of
The requesting peer can check the responding peers identity by checking
the validity of the sent signature against with the pre-shared remote
peers identity-public-key.
If the signature was invalid, the requesting peer must still proceed
with the authentication by sending an `AUTHPROPOSE`-message with 32
random bytes.
=== `AUTHPROPOSE` message ===
A peer can propose authentication of the channel by sending an
`AUTHPROPOSE`-message to the remote peer.
If the signature sent in `AUTHREPLY` was invalid, the peer must still
send an `AUTHPROPOSE`-message containing 32 random bytes.
The `AUTHPROPOSE` message must be answered with an
`AUTHCHALLENGE`-message ? even if the proposed requesting-peers
identity-public-key has not been found in the authorized_peers database.
In case of no match, the responding `AUTHCHALLENGE`-message must
contains 32 bytes of zeros.
== Post-Authentication Re-Keying ==
After the second `AUTHREPLY` message (requesting peers signature ->
responding peer), both clients must re-key the symmetric encryption
according to BIP151 while using ___a slightly  different re-key key
derivation hash___.
They both re-key with `hash(encryption-session-ID ||
old_symmetric_cipher_key || requesting-peer-identity-public-key ||
== Identity-Addresses ==
The peers should display/log the identity-public-key as an
identity-address to the users, which is a base58-check encoded
ripemd160(sha256) hash. The purpose of this is for better visual
comparison (logs, accept-dialogs).
The base58check identity byte is `0x0F` followed by an identity-address
version number (=`0xFF01`).
An identity address would look like
`TfG4ScDgysrSpodWD4Re5UtXmcLbY5CiUHA` and can be interpreted as a remote
peers fingerprint.
== Compatibility ==
This proposal is backward compatible. Non-supporting peers will ignore
the new `AUTH*` messages.
== Example of an auth interaction ==
Before authentication (once during peer setup or upgrade)
# Requesting peer and responding peer create each an identity-keypair
(standard ECC priv/pubkey)
# Requesting and responding peer share the identity-public-key over a
different channel (PGP mail, physical exchange, etc.)
# Responding peer stores requesting peers identity-public-key in its
authorized-peers database (A)
# Requesting peer stores responding peers identity-public-key in its
known-peers database together with its IP and port (B)
# Encrypted channels must be established (according to BIP-151 [1])
# Requesting peer sends an `AUTHCHALLENGE` message
  AUTHCHALLENGE:
    [32 bytes, hash(encryption-session-ID || "i" ||
# Responding peer does create the same hash `(encryption-session-ID ||
"i" || )` with its local
# If the hash does not match, response with an `AUTHREPLY` message
containing 64bytes of zeros.
# In case of a match, response with an `AUTHREPLY` message
  AUTHREPLY:
    [64 bytes normalized compact ECDSA signature (H)] (sig of the
encryption-session-ID done with the identity-key)
# Requesting peer does verify the signature with the
# If the signature is invalid, requesting peer answers with an
`AUTHREPLY` message containing 32 random bytes
# In case of a valid signature, requesting peer sends an `AUTHPROPOSE`
  AUTHPROPOSE:
    [32 bytes, hash(encryption-session-ID || "p" ||
# Responding peer iterates over authorized-peers database (A), hashes
the identical data and looks for a match.
# If the hash does not match, responding peer answer with an
`AUTHCHALLENGE` message containing 32 bytes of zeros.
# In case of a match, responding peer sends an `AUTHCHALLENGE` message
with the hashed client public-key
  AUTHCHALLENGE:
    [32 bytes, hash(encryption-session-ID || "r" ||
# Requesting peer sends an `AUTHREPLY` message containing 64 bytes of
zeros if server failed to authenticate
# Otherwise, response with signature in the `AUTHREPLY` message
  AUTHREPLY:
    [64 bytes normalized compact ECDSA signature (H)] (sig of the
encryption-session-ID done with the identity-key)
# Responding peer must verify the signature and can grant access to
restricted services.
# Both peers re-key the encryption after BIP151 including the
requesting-peer-identity-public-key and responding-peer-identity-public-key
== Disadvantages ==
The protocol may be slow if a peer has a large authorized-peers database
due to the requirement of iterating and hashing over all available
authorized peers identity-public-keys.
== Reference implementation ==
== References ==
* [1] [[bip-0151.mediawiki|BIP 151: Peer-to-Peer Communication Encryption]]
== Acknowledgements ==
* Gregory Maxwell and Pieter Wuille for most of the ideas in this BIP.
== Copyright ==
This work is placed in the public domain.

@_date: 2016-08-09 12:02:06
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Authentication BIP 
Hi Andy
Yes. I think this limitation could be removed.
A responding node can have ? in theory ? multiple identity-keys per
network interface (network interfaces is also confusing, because you
could run multiple bitcoind instances on the same interface with
different ports).
The BIP should just make clear, that it is probably wise, to use
different identity-keys for each network interface (ipv4, v6, tor).
I'll try to overhaul that part.

@_date: 2016-08-12 14:47:31
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Authentication BIP 
I have updated that part of the BIP
Each peer can configure multiple identity-keys (ECC, 32 bytes). Peers
should make sure, each network interface (IPv4, IPv6, tor) has its own
identity-key (otherwise it would be possible to link a tor address to a
IPvX address).
The identity-public-key(s) can be shared over a different channel with
other node-operators (or non-validating clients) to grant authorized access.

@_date: 2016-08-16 16:10:04
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Hardware Wallet Standard 
Unfortunately, there is no standard in how desktop- or mobile-wallets
can interact with a hardware device resulting in wallet vendors adding
plugins with proprietary code for non-standardized interfaces.
I started a BIP (extreme draft, feel free to improve language, grammar
and content) to address this missing part of the ecosystem.
I think it would be extremely helpful if     (and more?!) would help working
on a such standard.
The BIP describes two approaches how to communicate (pipe and
URI-scheme) with the signing-devices app, although, in my opinion, all
major platform do support the URI approach (maybe we could drop the pipe
approach then).
The URI approach means that there is no need to configure the
application location in order to start a inter-process(-app) communication.
---- BIP (rough early stage draft)
  BIP: ???
  Title: Detached Signing
  Author: Jonas Schnelli   Status: Draft (early stage!)
  Type: Standards Track
  Created: 2016-08-02
== Abstract ==
This BIP describes a way how wallet applications can decouple sensitive
privatekeys from the internal keychain and interact with a
signing-devices (hardware wallet, "cold" storage) over a generic
interface in order to get signatures.
== Motivation ==
It seems like that the current approach for allowing signing-devices to
interact with third party wallets is to build a plugin [1][2][3]. Adding
plugins for each hardware wallet type will increase possible security
issues and result in multiple proprietary-third-party code within the
wallet application with very similar structures.
A generic interface how wallets can interact with signing-devices would
result in better user experience, less critical code and simpler
adaption for various signing-devices.
== Specification ==
In order to support desktop- and smartphone-wallet-applications, this
BIP describes two slightly different approaches (process pipe and URI
call) in how to interact with the signing-devices. If possible, the
modern URI approach should be chosen.
=== Signing-Device-Controller-Application ===
To allow a generic interface while still allowing different ways how to
internally communicate with the signing device itself (USB, TCP/IP,
air-gapped Qr-Code scanning, etc.) a controller-application is required.
=== General signing process ===
The wallets signing process must be according the following principal:
* Wallet prepares signing-request-object including bitcoin-transaction
or message together with metadata (scriptPubKey, hd-keypath of the inputs)
* Wallet passes signing-request-object to the
* Signing-device-controller-application processes
signing-request-object, eventually shows UI, user can sign or cancel
* Signing-device-controller-application sends back
signing-response-object with signatures or an error
* Wallet processes signing-response-object and completes data-object
creating process (example: add signatures to transaction and broadcast)
=== Desktop Process Intercommunication ===
Desktop wallets can interact with a signing device over process
intercommunication (pipe) together with a
As specified below, the signing-request-object is a URI string passed
through the pipe. The desktop wallet needs to wait (with a recommended
timeout between 1 and 5 minutes) until the signing-response-object will
be sent back by the signing-device-controller-application.
=== Smartphone/URI App Intercommunication ===
Smartphones and modern operating systems are trying to sandbox
applications and interprocess communication (on pipe level) is mostly
On smartphones, we must use URI-schemes.
The wallet can pass information to the
signing-device-controller-application by using a predefined URI scheme.
The querystring must be URI encoded.
RFC 2616 does not specify a maximum length of URIs (get request). Most
modern smartphone operating system allow URIs up to serval megabytes.
Signing complex data-structure is therefore possible.
The returnurischeme must contain a URI schema where the
result of the signing process should be returned to.
The returnurischeme must be populated and "opened" once the signing
process has been completed (or cancled).
=== Signing Request ===
The signing request is a flexible URI-Query-String that will be used by
the Signing-device-controller-application for user confirmation as well
as for creating the signature.
The URI-query-string must conform to the following format:
type = type of the data to sign
data = raw unsigned bitcoin transaction or text-message
(optional)inputscripts = scriptPubKey(s) of the inputs in exact order
(optional)inputhdkeypath = hd-keypath of the inputs in exact order
(optional)returnscheme = a URI scheme where the response must be sent to
(smartphone approach)
* inputhdkeypath or inputscripts must be provided.
=== Signing Response ===
The signing response is a flexible URI-Query-String that will be sent
back to the wallet application and must contain the signatures or an
error code.
The URI-query-string can be opened (smartphone approach) or will be sent
back though the interprocess pipe.
In case of ECDSA, the returned signatures must be normalized compact
signatures with the size of 64bytes (128 hex chars).
==== Possible error code ====
0 = no error
1 = user canceled
2 = timeout
10 = missing key identifier (missing HD keypath or input scriptpubkey)
11 = unsupported signing type
12 = could not resolve script
50 = unknown internal error
==== Examples ====
===== Simple p2pkh transaction =====
Unsigned raw transaction:
(input ced97f90d7d10a767dfd2bed769ac42cc48be1d3e648f1bfb5dbb70f9dd13cfd
vout:1, output: P2PKH mtgQ54Uf3iRTc9kq18rw9SJznngvF5ryZn 1 BTC)
signing-request URI must be:
The inputhdkeypath is optional in this case
signing-response URI must be:
===== Simple a bitcoin message =====
Message: Lorem ipsum dolor sit amet
signing-request URI must be:
signing-response URI must be:
=== Support for multiple signing-devices ===
Must operating systems allow only one registered application per
URI-scheme. To support multiple signing-devices, wallets and
signing-devices can optional add support for brand based URI-schemes.
In addition to the standard URI scheme,
signing-devices-controller-applications can register an additional URI
scheme (with the identical request/response syntax and logic) including
a brand-identifier.
Registering a brand-identifier based URI scheme without registering the
default URI scheme is not allowed.
Wallets can detect if a certain brand based URI scheme is supported and
therefore gives user a selection if multiple signing-devices where
detected [4][5].
Supported brand-identifiers are:
* trezor
* ledger
* keepkey
* digitalbitbix
== References ==
[1] [2] [3] == Acknowledgements ==
== Copyright ==
This work is placed in the public domain.

@_date: 2016-08-16 17:13:33
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Hardware Wallet Standard 
I'm aware of this approach but I don't think this makes sense long term.
We need a better way on the protocol level to validate inputs amounts
(where segwit is a first step towards this).
IMO, not having a standard for hardware wallet interfaces/communication
will long term result in reducing the end user experience.
I think we should collaborate together and work out a standard.
My goal is to add hardware wallet support in Bitcoin-Core where adding
proprietary code (plugin-ish) is something we don't want to do for the
sake of security and compatibility.
As said, the "BIP" is very draft and I'm happy to include the input
streaming as part of it (or you could add it if you want because you
have more experience with it).

@_date: 2016-08-17 09:24:46
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Hardware Wallet Standard 
Hi all
Thanks for the response.
Jochen's points:
Indeed. There are some missing points and I'd like to work this into the
BIP. Thanks for bringing this up.
Along with a support for wallet-creation with a xpub from the signing
device, we might also want to support loading multiple pubkeys into a
keypool from the device (in case someone likes to use hardened
derivation at all levels). I guess this would not be over-complex to
Luke's points:
USB / Plugin/Driver problematic
The URI scheme is not ugly. Its a modern way ? implemented in almost all
platforms ? how applications can interact with each other while not
directly knowing each other. Registering a URI scheme like "bitcoin://"
has some concrete advantages over just piping through stdio.
Also, the stdio/piping approach does not work for mobile platforms
(where the URI scheme works).
The URI scheme does not require any sorts of wallet app level
configuration (where the stdio/pipe approach would require to configure
some details about the used hardware wallet).
Thomase D.'s points:
Standardizing to many layers of the interaction stack (including the
hardware interaction) will very likely result in vendors not sticking to
the standard.
I agree, the URI scheme has some fragility, but at a level where we can
handle it and with the advantage of abstracting the used brand/device
for privacy and security reasons.
provides no way to to enumerate available manufacturers or enabled
Most operating systems allow to check if a certain URL-Scheme is
supported (registered), this would allow at least to check for known
major vendors (like trezor, etc.) which should solve most
multi-hardware-wallet use-cases.
The URI return scheme does work fine and with the correct set timeouts
it should result in a neat user experience.
It's the proposed way of application intercommunication in Apple iOS [1]
and Google Android [2].
* Non of the points convinced me that there is a better alternative to
the proposed URI scheme interaction (please tell me if I'm stubborn).
* Also, we should move the end users UX in the center of the
problems-to-solve (and not overweight the ideal
code-/API-/hardware-interaction-design while ignoring the end user
* We should try to not over-standardize the interaction with the device
itself to allow flexibility on the hardware wallet vendor side.
[2]

@_date: 2016-08-17 13:34:35
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Hardware Wallet Standard 
Hi Dana
This is maybe a question of the scope.
The BIP I'm proposing would make a clear interface cut between
wallet-with-unsigned-transaction and a signing-device (and maybe between
wallet-requires-pubkey, signing-device generate some pubkeys [or
non-hardened xpub]).
The detached-signing proposal does not duplicate work. It just moves the
current plugin design into a separate application. Plugins in security
and privacy critical wallet software is something that should probably
be avoided.
It's intentional at a high level to allow maximum flexibility at the
hardware interaction layer.
Your protobuf example is a good use-case. You could implement your
custom processes behind the URI scheme (which is probably way more
efficient then writing a couple of wallet plugins where you ? at the end
? mostly don't control the deployment and the source-code).
Defining a standard on the hardware interaction layer is possible, but a
fairly different approach.

@_date: 2016-08-18 08:54:04
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Hardware Wallet Standard 
I think this is easily solvable. The required data to verify and sign a
(standard) bitcoin transaction (including P2WSH multi-sig) is manageable.
IMO what a signing devices requires in order to sign a (standard)
-> serialized tx
-> serialized tx of the inputs
-> scriptPubKey of the inputs
-> inputs redeem-Scripts
-> input amounts
-> position of the change output any maybe its keypath
-> cosigners pubkeys for inputs and changeaddress
This seems to be manageable for a 1 round communication?
Or do I miss something?
I think multiple rounds would still be possible with a clever design.
Although I could imaging that >95% of the users transaction would
require only a single "shot".
Whats the benefits of the multiple rounds communication? Would a single
round result in to many data transported?
Passing a 300kb chunk (assuming a large transaction) over a URI scheme
requires a couple of milliseconds on standard Smartphones or PCs.
The URI-based API allows transmitting data of multiple megabytes while
there is no need for...
* dependencies of any form (library, etc.)
* library support for a particular language
* platform that supports the dependencies of the library (like USBHID,
not supported by iOS)
Can you elaborate what benefits you would get from the library approach
and how the library API would be different form the proposed URI-scheme?
How would the library approach work on mobile platforms? Would USB be
the only supported hardware communication layer?

@_date: 2016-08-18 11:35:05
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Hardware Wallet Standard 
Standards can help an ecosystem to grow, can help to sustain a good user
The hardware wallet vendors have used "natural tools" and look where we
are. We have *native* plugins in Electrum, Copay, etc. for different
hardware wallets. Mostly the plugins are in the code base of the wallet,
which makes it ? in theory ? impossible to change from the perspective
of the hardware wallet vendor (there is no control of the deployment if
there are bugs in the plugins code).
The plugins functions overlap significant.
I think this is a bad design for security critical applications.
What I want as hardware wallet user:
* I'd like to have a trusted application (layer) where I'm sure I'm
using software provided through my hardware wallet vendor.
What I want as hardware wallet vendor:
* I'd like to be able to provide and update a software layer (app) to my
customer with the ability to provide code signatures and security
updates anytime. I do want to control the user experience.
As far as I know most bitcoin wallets do support the bitcoin:// URI
scheme quite well.
I agree that BIP70 is a mess (including the bitcoin:// additions).
The proposed URI scheme would be completely different. The only
similarity is using the URI scheme as transport layer (which is the
proposed long term inter-app communication layer by Apple and Google).
So you propose having one library that would support multiple vendors?
What if new vendors add a new transport layer (lets assume NFC or
Bluetooth), wouldn't that result in every possible consumer of that
library (all wallets) need to update before the new vendors transport
layer could be used, resulting in a huge deployment process probably
require many month until it can be used?
What if there is a critical security issue in the library? How would the
deployment plan looks like?
I really think we should remove the "hardware communication layer" from
wallets and move it towards the hardware vendor app.
What about iOS? Should we just leave that platform unsupported with
hardware wallets?

@_date: 2016-08-18 11:49:51
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Hardware Wallet Standard 
The current question ? as already mentioned ? is we ACK to work together
on a signing protocol or if we NACK this before we even have started.
I'm not saying that the draft proposal I made is the way to go, I'm
happy to NACK it myself in favor of a better proposal.
I strongly recommend to work together on a standard that will have one
central winner: the end user.

@_date: 2016-08-24 08:59:56
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP Status updates (including to Active/Final 
SPV Wallets should definitively update to respect NODE_BLOOM. Bloom
filtering is CPU and disk intense and some node operators have disabled
it (or will disabled it) because there is no direct p2p network-health
SPV wallets should probably also make use of the new DNS seeder filter
It is running at least on seed.bitcoin.sipa.be and
The filter option allows SPV Wallets to only get nodes that signal
support for NODE_BLOOM.
The syntax is
   x.seed.bitcoin....
Example for NODE_NETWORK together with NODE_BLOOM
dig x5.seed.bitcoin.jonasschnelli.ch
(NETWORK = (1 << 0), NODE_BLOOM = (1 << 2)) = (bin00000101 = (int)5)

@_date: 2016-08-24 16:18:26
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP Status updates (including to Active/Final 
I totally agree with Thomas.
Another thing that I think could be a BIP misdesign:
BIP44 Gap Limits
From the BIP:
  "Address gap limit is currently set to 20. If the software hits 20
unused addresses in a row, it expects there are no used addresses beyond
this point and stops searching the address chain."
* Does that mean, we do a transaction rescan back to the genesis block
for every 20 addresses?
* Or is it a prerequirement to do a wallet recovery after BIP44's to
have access to a full address-indexed blockchain?
Or maybe I'm missing something.

@_date: 2016-08-25 09:39:28
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP Status updates (including to Active/Final 
Sorry for hijacking the thread again
(I think this case if not completely unrealistic):
What would happen, if a user gave out 21 addresses, then address0 had
receive funds in +180 days after generation where address21 had receive
funds immediately (all other addresses never received a tx).
In a scan, address0 would be detected at +180 days
which would trigger the resize+20 of the address-lookup-window, but, we
would require to go back 180day in order to detect received transaction
of address21 (new lookup-window) in that case.
Or do I misunderstand something?

@_date: 2016-08-25 10:08:21
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP Status updates (including to Active/Final 
The development paradigm of "maybe detect funds" is not something we
should *not* encourage for Bitcoin IMO.
Users might sweep their existing bip32/bip44 seed (which could miss
funds according to the problem above) to a new wallet and discard the
previous seed.
But I agree with Luke-Jr.
This Thread is not about specification, it's about what's used and what
should be marked as standard.
New BIPs could cover "overhauled" proposals for BIP39 and BIP44.
Otherwise ? very likely ? nothing will happen.

@_date: 2016-02-29 11:29:05
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Fast bootstrapping with a pre-generated UTXO-set 
Hash: SHA256
I?ve been thinking around a solution to reduce nodes bootstrap time
(IBD) as well as a way to reduce the amount of bandwidth/network usage
per node.
Not sure if this idea was/is already discussed, haven?t found anything
in a quick research.
Fast bootstrapping with a pre-generated UTXO-set database.
This documents describes a way how bitcoin nodes can bootstrap faster
by loading a pre-generated UTXO-set datafile with moderate reduction
of the security model.
Bitcoin-core or any other full node client will need to provide a
feature to "freeze" the UTXO-set at a specified height (will require a
reindex). The frozen UTXO-set ? at a specific height ? will be
deterministic linearized in a currently not specified
Additionally, a serialized form of the current chain-index (chain
containing all block-headers) up to the specified height will be
appended to the pre-generated UTXO-set-datafile.
The datafile will be hashed with a double SHA256.
The corresponding hash will be produced/reproduced and signed (ECDSA)
by a group of developers, ideally the same group of developers who are
also signing deterministic builds (binary distribution).
Full node client implementations that supports bootstrapping from a
pre-generated UTXO-set, need to include...
1.) a set of pubkeys from trusted developers
2.) the hash (or hashes) of the pre-generated UTXO-set-datafile(s)
3.) n signatures of the hash(es) from 2) from a subset of developers
defined in 1)
To guarantee the integrity of developers pubkeys & signatures, methods
like the current gitian build, used in bitcoin-core, must be used.
New nodes could download a copy of the pre-generated UTXO-set, hash
it, verify the hash against the allowed UTXO-sets, verify the ECDSA
signatures from various developers, and continue bootstrapping from
the specified height if the users accepts the amount of valid signatures
Sharing of the pre-generated UTXO-set can be done over CDNs,
bit-torrent or any other file hosting solution. It would also be
possible to extend the bitcoin p2p layer with features to
distribute/share a such pre-generated UTXO-set, in chunks and with the
according hashes to detect invalidity before downloading the whole
content (but would probably end up in something very similar to

@_date: 2016-01-21 08:42:56
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] What is OpenSSL still used for? 
Hash: SHA256
Hi Andrew
Openssl was dropped from the consensus layer (ECC) in 0.12, though, it
still used for...
1) ... getting random numbers (randomize the ECC signing context)
2) [wallet only] ... AES256 encryption of private keys
3) [GUI only] ... SSL/X.509 for BIP70 (payment protocol)
Openssl dependency for 1) and 2) could be removed. There are some ?
outdated ? relevant PRs:
Entropy: AES: I guess for point 3) [BIP70] it makes sense to keep openssl.

@_date: 2016-01-25 17:12:01
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available 
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
We try to allow reorgs ~288 blocks deep also in pruning:
- From code comments:
Require that user allocate at least 550MB for block & undo files
(blk???.dat and rev???.dat)
At 1MB per block, 288 blocks = 288MB.
Add 15% for Undo data = 331MB
Add 20% for Orphan block rate = 397MB
We want the low water mark after pruning to be at least 397 MB and
since we prune in
full block file chunks, we need the high water mark which triggers the
prune to be
one 128MB block file + added 15% undo data = 147MB greater for a total
of 545MB
Setting the target to > than 550MB will make it likely we can respect
the target.

@_date: 2016-07-04 08:37:45
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512 
Thanks Zooko
I think HKDF instead of a single HMAC_SHA512 seams reasonable and
something we should consider.
I'll try to evaluate the implications of using HKDF over HMAC_SHA512 and
will update the BIP if there are no concerns about it.

@_date: 2016-07-04 08:47:05
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512 
Hi Arthur
I totally agree.
BIP151 does not introduce new cipher types.
The BIP uses ECDH together with ChaCha20-Poly1305 at openssh.
Both very well known and broad used crypo.

@_date: 2016-07-26 22:10:15
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP proposal: derived mnemonics 
My humble cryptographic understanding tells me that you should probably
use sha512_hmac where you add an passphrase and a salt.
Side-note: Bip39 does still use PBKDF2 with 2048 iterations which I
personally consider "not enough" to protect a serious amount of funds.
Also the checksum based on the predetermined wordlist has some security
downsides over using a plain 32byte entropy (64hex chars) or a
base58check encoded extended private master key.
Another idea:
What would speak against deriving a child key after bip32, lets say at
m/88'/0'/n' and use the derived 256bits to encode your mnemonic?
This would at least require your master mnemonic passphrase to derive a
valid "child mnemonic".
I'm still not convinced if we should encourage users to "only store and
backup" the bip39 mnemonic.
Reconstructing funds from a seed can be difficult especially if you
don't have access to a trusted TX-indexed full node (~150GB of data
Novice users might also underestimate the risk of losing metadata
coupled with their transactions when they only store the wallet seed.

@_date: 2016-07-27 12:53:24
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP proposal: derived mnemonics 
What the Digital Bitbox team does, is, PBKDF2 the user entered
passphrase on the computer with >20'000 iterations, then PBKDF2 again
onchip with the 2048 rounds.
If somebody manages to steal your backup (in that case a file/SDCard or
printed PDF), it would at least required > 22'048 iterations to derive
the key from a passphrase which I consider "stronger" then just using
2048 iterations.
I guess you shouldn't delegate KDF security to the user. But sure, this
could help as well. This is part of the UI.
On the other hand, forcing the user to select a long/more-secure
passphrase will very likely lead to many funds get lost behind
encryption because of lost/forgotten passphrases.
But IMO this fact should not be an excuse to reduce/use low iterations
during KDF (especially SHA2 based KDFs).

@_date: 2016-06-09 08:57:29
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 MITM 
I'm currently working on the Auth-BIP which is not worth reviewing it
right now (I will post it to the mailing list once it has been reached a
stable level where it can be discusses).
If you can't wait, here is the current work:
Most recent MITM/auth discussion (there where plenty of discussions on
IRC about this topic):

@_date: 2016-06-28 09:19:04
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512 
SHA512_HMAC is used by BIP32 [1] and I guess most clients will somehow
make use of bip32 features. I though a single SHA512_HMAC operation is
cheaper and simpler then two SHA256_HMAC.
AFAIK, sha256_hmac is also not used by the current p2p & consensus layer.
Bitcoin-Core uses it for HTTP RPC auth and Tor control.
I don't see big pros/cons for SHA512_HMAC over SHA256_HMAC.

@_date: 2016-06-28 10:26:12
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 
Hi Eric
In my opinion, the question should be "why would you _not_ encrypt".
1) Transaction censorship
ISPs, WIFI provider or any other MITM, can holdback/censor unconfirmed
transactions. Regardless if you are a miner or a validation/wallet node.
2) Peer censorship
MITM can remove or add entries from a "addr" message.
3) Fingerprinting
ISPs or any other MITM can intercept/inject fingerprinting relevant
messages like "mempool" to analyze the bitcoin network.
4) SPV
For obvious reasons regarding BF (see BIP or above).
5) Goundwork for a "client-server" model over the P2P channel
Fee estimation, bloom-filters, or any other message type that requires
I would not reduce BIP151 to only solve the BF privacy/censorship problem.
If we agree that censorship-resistance is one of the main properties of
Bitcoin, then we should definitively use a form of end-to-end encryption
between nodes. Built into the network layer.
There are plenty of other options to solve this problem. stunnel,
Bernsteins CurveCP, VPN, etc. which are available since years.
But the reality has shown that most bitcoin traffic is still unencrypted.
Example: IIRC non of the available SPV wallets can "speak" on of the
possible encryption techniques. Encrypting traffic below the application
layer is extremely hard to set up for non-experienced users.
On top of that, encryption allows us to drop the SHA256 checksum per p2p
message which should result in a better performance on the network layer
once BIP151 is deployed.
I agree that BIP151 _must_ be deployed together with an authentication
scheme (I'm working on that) to protect again MITM during encryption

@_date: 2016-06-28 14:13:27
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 
Hi Eric
Sorry for not directly addressing your points.
I try to be more precise in this follow up email:
I think the bloom filter SPV usecase is not "pure client-server". SPV
clients could request from/broadcast to multiple "trusted nodes".
Trusted nodes could be nodes where the operators have shared
identities/keys in advance over a different channel.
Further private p2p extensions (lets say a p2p form of the estimatefee
command) are something which needs to be discussed first and not
something that is encouraged or outlined in BIP151.
I don't see reasons why BIP151 could weaken the security of the P2P
network. Can you point out some specific concerns?
BIP151 does not rely on identities. BIP151 does not use persisted keys
(only ephemeral keys). The authentication/identity system needs to be
described in a another BIP.
But correct, BIP151 without a form of authentication/identity management
is vulnerable to all sorts of MITM attacks and that's why I think BIP151
must be deployed together with an p2p authentication scheme.
Scope creeping and the risks of overspecifying is the main reason to
focus on the "pure encryption part" in BIP151.

@_date: 2016-06-28 22:06:58
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 
False sense of security is mostly a communication issue.
BIP151 does focus on encryption (not trust).
Are users aware of the fact that ISP/WiFi-Providers can track their
bitcoin spending (if they use SPV+BF) and link it with other internet
traffic or sell the data to anyone who is interested to do correlation?
Are node operators aware of the possibilities that ISPs/Data-Centers,
etc. can hold back peers, etc.?
If there is a false sense of security/anonymity, then we are already
deep into this territory.
BIP151 was designed as a puzzle-pice towards better security and better
censorship resistance. You shouldn't project all sorts of "false sense
of security" into BIP151. Is a stepping stone towards greater security.
Can you point out the tradeoffs?
BIP151 does not introduce fingerprinting possibilities.
Can you elaborate the costs?
[Extremely simplified]: we need 300 lines of code from openssh
(ChaCha20-Poly1305 at openssl) and some ECDH magic (already in
Bitcoin-Cores codebase) together with two or three (maybe payed)
cryptoanalysis once the implementation is done.
Yes. There is no plan to adopt a TUFO scheme. Bip151 does not use TUFO
it does not cover "trust" (It just encrypt all traffic).
Imaging Bip151 together with a simple form of preshared EC key
authentication (nonce signing or similar). You could drastically
increase the security/censor-resistance-properties between nodes where
owners have preshared identity keys (with nodes I also mean SPV/wallet
And I guess there are plenty of awesome identity management system ideas
tied or not tied to the Bitcoin blockchain out there.
This is also a reason to not cover trust/authentication/identity in BIP151.
It is  possible to have multiple authentication schemes.
Yes. I think nobody have started implementing BIP151. It's a draft BIP
and I think it's still okay and great that we have this discussion.
BIP151 hopefully has started some brainwork in how encryption and
authentication could work in Bitcoin and I'm happy to deprecate BIP151
if we have found a better solution or if we come to a point where we
agree that BIP151 does make the network security worse.
If we assume increasing amount of novice users starting with Bitcoin
every day, how should these users run wallets without increasing
centralization by using webwallets or client/central-server wallets?
(which is OT, but an interesting question)
I think BIP151 does what it says: encryption and laying groundwork for
You wouldn't probably say BIP32 is incomplete because it does not cover
a scheme how to recover funds (or BIP141 [SW consensus] is incomplete
because it does not cover p2p [BIP144]).
The missing MITM protection (solvable over auth) is prominent mentioned
in the BIP [1].
(from your other mail):
I agree that the secure trusted 2nd channel key-sharing problem can be
significant for large networks and/or connecting to unknown identities.
But as said, there could be multiple ways of sharing identity keys.
If you want to connect your node to serval other trusted nodes, you can
simply physically preshare keys or do it over GPG / Signal App, etc..
And if I have followed the news correctly, there are some clever guys
working on various internet of trust 2.0 proposals...
I would agree if you would say, _trusted encryption_ is incomplete with
authentication. But IMO BIP151 is complete and should be deployed
together with one or multiple authentication schemes.
[1]

@_date: 2016-06-29 20:34:06
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512 
As far as I know the security of the symmetric cipher key mainly depends
on the PRNG and the ECDH scheme.
The HMAC_SHA512 will be used to "drive" keys from the ECDH shared secret.
HMAC_SHA256 would be sufficient but I have specified SHA512 to allow to
directly derive 512bits which allows to have two 256bit keys with one
HMAC operation (same pattern is used in BIP for the key/chaincode
Keccak would be an alternative but we probably don't want to introduce
another new hash type just for the encryption.

@_date: 2016-06-29 20:46:01
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512 
Hi Ethan
No. Not to the ECDH negotiation.
BIP151 specifies a flexible symmetric key cipher type negotiation,
although, BIP151 only specifies chacha20-poly1305 at openssh.com.
Lets assume someone adds another symmetric cipher type after BIP151 has
been deployed which has less strong security properties then
If we don't include the ciphersuite-type in the key derivation HMAC, an
attacker/MITM could in theory force both nodes to use the weaker
symmetric cipher type.

@_date: 2016-06-29 22:31:50
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512 
SHA256 and SHA512 are both from the SHA-2 family.
I have specified SHA512 to (slightly) increase the brute-force security
of the ecdh shared secret when knowing K_1 and K_2.
And I assumed (haven't measured the required cpu cycles) that a single
SHA512_HMAC is less expensive then two SHA256_HMAC.

@_date: 2016-06-30 14:20:59
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 
BIP151 would increase the risks for MITM attackers.
What are the benefits for Mallory of he can't be sure Alice and Bob may
know that he is intercepting the channel?
MITM is possible today, it would still be possible (though under higher
costs) with BIP151.
With BIP151 we would have the basic tool-set to effectively reduce the
risks of being MITMled.
IMO we should focus on the risks and benefits of BIP151 and not drag
this discussion into the realm of authentication. This can and should be
done once we have proposals for authentication (and I'm sure this will
be a heated debate).
The only valid risk I have on my list from you, Eric, is the false sense
of security.
My countermeasure for that would be...
- deploy BIP151 together with the simplest form of authentication
(know_hosts / authorized_keys file, no TOFU only editable "by hand")
- make it more clear (in the BIP151 MOTIVATION text) that it won't solve
the privacy/MITM problem without additional authentication.
Or could you elaborate again ? without stepping into the realm of
authentication/MITM (which is not part of the BIP or possible already
today) ? why BIP151 would make things worse?

@_date: 2016-06-30 14:43:07
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 151 
If Mallory has substituted the ephemeral keys in both directions, at the
point where Alice and Bob will do an authentication, they can be sure
Mallory is listening.
Simple dummy example:
1.) Encryption setup with ECDH with ephemeral keys after BIP151
2.) Mallory is MITMling the connection. He is substituting both
direction with its own keys
3.) Connection is successfully MITMled
4.) Alice tells Bob "prove me that you are Bob, please sign the
session-ID with your identity key"
5.) Bob signs the sessionID (ECDH secret) with his identity key which
will be unusable for Mallory who has a substituted sessionID in both
6.) Alice has successfully detected the Mallory
Disclaimer: 4) and 5) are _not_ authentication proposals :-)

@_date: 2016-03-03 16:29:30
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] consensus rule change for TX fee safety 
I don't think a such "feature" or lets say protection should be part of
the consensus layer.
Such checks should be done by the tx creation clients (wallets) ? or ?
nodes could have an option to not accept transaction with insane fees
into their mempool (policy).

@_date: 2016-03-23 16:24:12
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
I have just PRed a draft version of two BIPs I recently wrote.
Two BIPs that addresses the problem of decoupling wallets/clients from
nodes while assuming a user (or a group) know the remote peer.
Authentication would be necessary to selective allow bloom filtering of
transactions, encryption or any other node service that might lead to
fingerprinting or resource attacks. Authentication would also be a
pre-requirement for certificate free encryption-handshakes that is
(enough?) resistant to MITM attacks.
Encryption is highly recommended if you connect a SPV node to a trusted
Authentication would allow accessing private p2p extensions from a
remote SPV peer (example: fee estimation).
I'm aware of other methods to increase privacy and integrity (tor, VPN,
stunnel, etc.), however I think authentication and a basic communication
encryption should be part of the protocol and its setup should be
complete hassle-free.
Thanks for your feeback.

@_date: 2016-03-23 22:55:34
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
Thanks. Will do.
The encryption should be optional.
The proposed authentication scheme does take care of the
identity-management and therefor prevent MITM attacks.
Without the identity management, you might not detect sending/receiving
encrypted data from/to a MITM.
The proposed encryption schema is based on ECDSA/ECDH (implemented in
libsecp256k1) and AES256CBC (implementation is on the way see
OpenSSL is not required.
Most known use-case: SPV.
It's probably extremely inefficient to create a constant time stream.
Even most SSL/SSH application leak information because of the
communication message characteristics.
The current wrapping message proposal is not very efficient.
I will change it so that the p2p message header will contain the
encryption metadata. This should lead to a tiny overhead.
Good point. Maybe one false try should lead to ignoring the peer.
This is a relative simple concept and does not require rehashing the
whole communication. You just append the "new data".
Some pseudocode:
SHA256CTX ctx;
SHA256CTX_Update(ctx, 1stmessage);
SHA256CTX ctxnew = ctx;
sha256hash = SHA256CTX_Finalize(ctxnew); //use as checksum hash
SHA256CTX_Update(ctx, 2ndmessage);
SHA256CTX ctxnew = ctx;
sha256hash = SHA256CTX_Finalize(ctxnew); //use as checksum hash
... etc.

@_date: 2016-03-25 11:17:10
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
Thanks for the feedback and IRC discussions.
I have overhauled both BIPs.
Main changes for the encryption BIP:
* No message wrapping. Once encryption is established, everything is
encrypted. No timeout.
* Added MAC: proposed AEAD is now ChaCha20-Poly1305 with an alternative
for AES256-GCH
* Independent ECDH negotiation and independent secrets for the symmetric
cipher for both communication directions
* Optimized message format and message-batch-option for encrypted data
It could be that the p2p performance for Chacha20-poly1305 encrypted
message is slightly better then the current plaintext message format
(dropping the network magic and the sha256 per message).
P2p authentication BIP:
* No message wrapping. Peers keep the state once authenticated.
* Simplified and auth now requires encrypted channels.
Some answers...
This is not covered by the auth BIP. Peers could agree on a protocol
extension outside of any BIP.
Once auth is possible, new BIPs could be written. Things like only
allowing filtering (or other services) to authenticated peers (and
disabling NODE_BLOOM).
opposed to any other banning?
Current nodes ignore a unknown message with a command like "auth".
Banning would allow a requesting peer to identify nodes that support
auth and attack them over different channels ("ah, ... this guy supports
auth, they must have some secret data, lets attack over SSH).
ignore the auth message.
Depends how we define backward compatibility. :-)
Peers supporting this "extension" can still interact with older peers.
the > enc* messages.
Current p2p implementation ignores any unknown command.

@_date: 2016-03-25 19:43:00
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
Hi Tom
Please check the newest auth BIP (it solves MITM).
The encryption BIP itself does not cover peer authentication.
Encryption without authentication of peers can also be valuable.
I hope you see the today's problem with SPV.
You fully reveal to your ISP / WiFi provider most of your wallet
controlled addresses (when using BF). The ISP/WiFi provider can link
your bitcoin usage to other inet traffic and/or they could sell
information to statistics company like google.
Also, an attacker controlling a WiFi router or any other network peer
between your SPV node and the remote full node could censorship
Etc. etc.
An encrypted channel together with a trusted full node would finally
allow to have a secure and save SPV communication.
Which attack-vector? MITM? Is conceptual solved with the auth BIP (that
requires encryption).
There is no implementation done yet.
It would be a waste of time to start writing a such implementation
_before_ having this discusses and improved by the community.
But the encryption BIP now recommends Chacha20-Polay1305 as AEAD which
is widely used.
I'm ready to write an implementation as soon as I have some signs that
the BIP does make sense.
Also, auth and enc is not something we will have in the next couple of
weeks. This might require a couple of months until its stable and ready
for production.
The sha256 context is gone now and replaced by a proper MAC.
Like most other encryption layers, we would still use messages. But we
call them "encrypted messages", the have a tiny header of plaintext data
(message length, AEAD-tag) and they will contain  plaintext p2p
messages _after_ decrypting. The plaintext messages have a much simpler
header (removed the 4 bytes sha256 checksum, removed the 4byte network)

@_date: 2016-03-26 10:01:36
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
First, because there _are_ a hight amount of SPV wallets in the field.
SPV wallets are "dumb-clients" with only a tiny value for the bitcoin
network (they don't validate, they don't relay). They already are
decoupled wallets. We need solution that offers higher privacy and
higher traffic analysis resistance.
Using the p2p channel for communication between full validation peers
and wallet-only-peers makes sense IMO because wallet-only-peers can
slowly validate the chain and create a UTXO set in the background (could
take a couple of weeks) or solve other purposes that increases the
security and/or serving something back to the bitcoin network.
Sure, you can always use client/server wallets (Coinbase / Copay, etc.)
that offers SSL.
But I strongly recommend to improve the communication and interface
possibilities between wallet-nodes (SPV) and full-validation-nodes.
Otherwise we will very likely see centralization regarding end-user
wallets (with all the large risks of disrupting the community in case of
attacks/thefts, etc.).
_If we think Bitcoin should scale, we also need to scale and improve at
the point where users enter the network and start using Bitcoin._
The current encryption BIP requires to encrypt the complete traffic.
Having an option to do analysis resistant communication with a remote
peer within the protocol itself is something that is very valuable IMO.
The encryption BIP recommends Chacha20-Poly1305 as encryption AEAD. This
is a very broad used encryption scheme (Google uses it to connect
Android phones with their cloud services).
Completely avoiding side channel on data analysis would probably require
extremely inefficient constant time encrypted datastreams.
Also, the BIP allows combining of multiple plaintext message in one
encrypted message.
Additionally we could extend the enc. BIP by allowing random padding of
encrypted messages or other techniques to reduce side channel analysis.

@_date: 2016-03-27 13:58:11
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
I'm not sure if different ports would make sense. I can't see a benefit
(happy if someone can convince me).
How would this affect p2p address management (address relay)? Wouldn't
this require to extend the current address message to support two port
It can be the same "p2p network". The only difference would be, that
once two peers has negotiated encryption, the whole traffic between
_these two peers_, and _only_ these two pears, would be encrypted (would
_not_ affect traffic to/from other peers).
A simplified example:
1. Peer Alice connects to peer Bob
2. Alice asks Bob: "lets do encrypted communication, here is my session
3. Bob also supports encryption and answers "Yes, let's do this, here is
my session pubkey"
4. Alice tells Bob (encrypted now): "Perfect. Here I prove that I'm
Alice by signing the session ID with my identity pubkey"
5. Bob checks his "authorized-peers" database and look-up Alices pubkey
and verifies the signatures.
6. Bob tells Alice: "Good! I trust you now Alice, here is my identity
pubkey with a signature of our session-ID"
7. Alice looks up Bobs pubkey in her "known-peers" database and verifies
the signature.
8. Alice response to bob: "Perfect. Indeed, you are Bob!"
At this point, the communication is encrypted and the identities has
been verified (MITM protection).
(simplified negotiation [only one-way, missing dh explanation, missing
KDF, session-ID, cipher suite nego., missing re-keying, etc.])

@_date: 2016-05-14 10:16:42
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Bip44 extension for P2SH/P2WSH/... 
Maybe I'm going a bit offtopic. Sorry for that.
Importing a bip32 wallet (bip44 or not) is still an expert job IMO.
Also importing can lead to bad security practice (especially without a
Users will send around xpriv or import an seed over a compromised
computer to a cold storage, etc.
I don't think users want to import private keys.
They probably want to import the transaction history and send all funds
covered by that seed to a new wallet.
I often though that task is better covered by a little GUI tool or
-> Accept different bip32 schematics (bip32 native, bip44, etc.)
-> Accept different bip39 (like) implementation
-> Create large lookup windows
-> Create a sweep transaction to a new address/wallet and sign/broadcast it.
-> Export transaction history (CSV)
But maybe I'm over-complicating things.

@_date: 2016-05-14 18:14:43
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Bip44 extension for P2SH/P2WSH/... 
AFAIK: Bip39 import (cross-wallet) is not supported by Schildbachs
android wallet [1] and Electrum [2] and Breadwallet [3].
But I think forming a BIP39 mnemonic into a extended master private key
is not the problem here.
The problems I see:
* What if the "old" wallet has used more then 1000 addresses? I guess
some wallets do not even create a lookup window up to 1000 addresses.
There is a high chance of loosing funds when doing sweep (move all funds
to a new wallet) operation.
* I guess most or maybe all wallets will keep all keys (the
"lookup-window" keys) in the wallet database which could affect
performance [4]
* I guess most wallets do not offer "moving the funds to a new seed" [5]
which results in not solving the problem of a "lost" or "compromised"
wallet and implies wrong security to the enduser.
* If I import a bip39 mnemonic into a hardware wallet (assume Trezor or
Keepkey) I have to type in the words into my computer which bypasses
some of the security my hardware wallet provides me (MITM seed attack).
Together with the point above this reduces the security of a wallet (in
particular cold storage significant).
Please correct me if I'm wrong.
I just wanted to point out that importing a wallet is a tricky step
especially cross-wallet imports (I think cross wallet imports is an
experts job without further improvements).
[1] [2] [3] [4]

@_date: 2016-05-18 10:00:44
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
Hi Lee
Thank you very much for the valuable input.
I'm still processing your feedback....
Yes. This could be something that could be extended once the BIP is
stable and/or implemented.
Right. The AEAD construct I though of is probably called
chacha20-poly1305 at openssh.com and specified in
I think this construct has already serval implementations and is widely
I have updated the BIP to mention the chacha20-poly1305 at openssh.com
Yes. I think closing would make sense.
Yes. This is a good point.
The implementation should probably also accept messages that contain the
4 byte network magic from unencrypted messages (to avoid possible
If the message is unencrypted, the length check or the unsuccessful
authentication check will lead to a disconnect.
Good point.
I have mentioned this now in the BIP but I think the BIP should allow
message > 16 MiB.
I leave the max. message length up to the implementation while keeping
the 4 byte length on the protocol level.
I just added the RFC4253 recommendation as a must (re-key after every
1GB of data sent or received).

@_date: 2016-05-25 11:36:24
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
Okay. Got your point.
The current BIPs assumption is that an encrypted package/message can
contain 1..n bitcoin messages (a single bitcoin message distributed over
multiple encrypted messages/packages was not specified).
But right, this could make sense.
Let me think this through....
TLS/SSH tunneling is already possible with third party software like
Also there is promising projects that would encrypt the traffic "on a
deeper layer" (see CurveCP).
I think what we want is a simple, openssl-independent traffic encryption
built into the core p2p layer.
IMO the risk of screwing up the implementation is moderate.
The implementation is not utterly-complex:
OpenSSH chacha20:
Sure. Before an implementation will be deployed to the endusers it will
require intense cryptoanalysis first.

@_date: 2016-09-22 21:59:12
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
Hi Tom
Would the "additional" segment contain the same amount of
nSequence-equivalent token as the number of inputs in the "inputs" segment?
What if you only want to add a per-input-token in the additional segment
for a certain input (assume last input)?
I guess the fundamental difference to html is the possible nesting.
However, I think that should be mentioned/specified in the BIP.

@_date: 2017-04-18 09:43:52
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Small Nodes: A Better Alternative to Pruned Nodes 
Hi Dave
Thanks for your proposal.
I agree that 100GB of data may be cumbersome for some systems, especially if you target end user systems (Laptops/Desktops). Though, in my opinion, for those systems, CPU consumption is the biggest UX blocker.
Bootstrapping a full node on a decent consumer system with default parameters takes days, and, during this period, you probably run at full CPU capacity and you will be disturbed by constant fan noise. Standard tasks may be impossible because your system will be slowed down to a point where even word processing may get difficult.
This is because Core (with its default settings) is made to sync as fast as possible.
Once you have verified the chain and you reach the chain tip, indeed, it will be much better (until you shutdown for a couple of days/hours and have to re-sync/catch-up).
1. I agree that we need to have a way for pruned nodes to partially serve historical blocks.
My personal measurements told me that around ~80% of historical block serving are between tip and -1?000 blocks.
Currently, Core nodes have only two modes of operations, ?server all historical blocks? or ?none?.
This makes little sense especially if you prune to a target size of, lets say, 80GB (~80% of the chain).
Ideally, there would be a mode where your full node can signal a third mode ?I keep the last 1000 blocks? (or make this more dynamic).
2. Bootstrapping new peers
I?m not sure if full nodes must be the single point of historical data storage. Full nodes provide a valuable service (verification, relay, filtering, etc.). I?m not sure if serving historical blocks is one of them. Historical blocks could be made available on CDN?s or other file storage networks. You are going to verify them anyways,... the serving part is pure data storage.
I?m also pretty sure that some users have stopping running full nodes because their upstream bandwidth consumption (because of serving historical blocks) was getting intolerable.
Especially ?consumer? peers must have been hit by this (little experience in how to reduce traffic, upstream in general is bad for consumers-connections, little resources in general).
Having a second option built into full nodes (or as an external bootstrap service/app) how to download historical blocks during bootstrapping could probably be a relieve for "small nodes?.
It could be a little daemon that downloads historical blocks from CDN?s, etc. and feeds them into your full node over p2p/8333 and kickstarts your bootstrapping without bothering valuable peers.
Or, the alternative download, could be built into the full nodes main logic.
And, if it wasn?t obvious, this must not bypass the verification!
I?m also aware of the downsides of this. This can eventually reduce decentralisation of the storage of historical bitcoin blockchain data and ? eventually ? increase the upstream bandwidth of peers willing to serve historical blocks (especially in a transition phase to a second ?download?-option).
Maybe it?s a tradeoff between reducing decentralisation by killing low resource nodes because serving historical blocks is getting too resource-intense _or_ reducing decentralisation by moving some percentage of the historical data storage away from the bitcoin p2p network.
The later seems more promising to me.
To your proposal:
- Isn?t there a tiny finger-printing element if peers have to pick an segmentation index?
- SPV bloom filter clients can?t use fragmented blocks to filter txns? Right? How could they avoid connecting to those peers?

@_date: 2017-08-09 21:35:26
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Structure for Trustless Hybrid Bitcoin Wallets 
Hi Colin
Would you then assume that userWalletPubKey is a hot key (stored on the users computer eventually in a browser based local storage container)?
In case of an attack on the server responsible for serverWalletPubKey (where also the personal information of the user are stored [including the xpub == amount of funds hold by the user)), wound?t this increase the users risk of being an possible target (False sense of multisig security, comparing to cold storage / HWW keys)?
I guess this will result in protecting the funds stored in this transaction entirely on the users identity information and eventually the optional recovery password, though I guess you are adding additional security by protecting via the server nonce from brute-forcing.
Why 1025bit for the nonce?
Why SHA512 instead of SHA256 (I guess you need 256bit symmetric key material for the key encryption)?
Considered using a (H)KDF for deriving the symmetric key (even if the server based nonce reduces the possibility of brute-forcing)?
Your modal has probably the TORS (trust on recovery setup) weakness (compared to a HWW where you [should] be protected on compromised systems during private key creation).

@_date: 2017-08-13 22:00:41
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Would anyone object to adding a dlopen message 
Hi Erik
Thanks for your proposal.
In general, modularisation is a good thing, though proposing core to add modules wie dlopen() seems the wrong direction.
Core already has the problem of running to many things in the same process. The consensus logic, p2p system as well as the wallet AND the GUI do all share the same process (!).
A module approach like you describe would be a security nightmare (and Core is currently in the process of separating out the wallet and the GUI into its own process).
What does speak against using the existing IPC interfaces like RPC/ZMQ?
RPC can be bidirectional using long poll.

@_date: 2017-02-13 11:07:12
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP151 protocol incompatibility 
Look at feefilter BIP 133
or sendheaders BIP130
Isn't it the same there?
Once BIP151 is implemented, it would make sense to bump the protocol
version, but this needs to be done once this has been
implemented/deployed. Or do I make a mistake somewhere?
How do you threat any other not known message types? Any peer can send
you any type of message anytime. Why would your implementation how you
threat unknown messages be different for messages specified in BIP151?

@_date: 2017-02-13 12:14:01
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP151 protocol incompatibility 
This indeed is not ideal for compatibility checks, but increases security.
I could not find a protocol specification that said communication must
be terminated when messages are transmitted before the version handshake
has been done. I mostly looked into Bitcoin-Cores implementation (which
means also into BitcoinXT/UT, where this is allowed).
Also. BIP151 clearly says that the requesting peer needs to initiate the
encryption (encinit).
In case of light clients not supporting BIP151 connecting to peers
supporting BIP151, there should never be transmission of new message
types specified in BIP151.
It could very likely be possible that the initial responding peer tries
to initiate a encryption session which would mean that BIP151 was not
implemented correctly.
Correct me if I'm wrong please.
I could not find evidence of the protocol specification that would
forbid (=terminate connection) such messages and I think allowing
unknown-messages before the version handshake makes the protocol flexible.
Are there any reasons we should drop peers if they send us unknown, but
correctly formatted p2p packages (magic, checksum, etc.) before the
version handshake, ... but not drop them if we have received unknown
messages after the version handshake?
I can't see that a such spec. would reduce the DOS attack vector?
If this had happened, it's very likely because the responding peer tried
to initiate a encryption session which is against BIP151 specs.
I think it was a wise implementation decision to allow unknown (not
invalid) messages.
This had allowed us to deploy stuff like compact blocks, feefilter, etc.
without breaking backward compatibility.
IMO, without a such flexibility, the deployment complexity would be
irresponsible high without really solving the DOS problem.
For feefilter or compact block or sendheaders?
You can't link a (unimplemented) specification (improvement process) to
a protocol version before deployment. Or can you?
Once it has been widely deployed, we should set a protocol minversion
for BIP151, right.

@_date: 2017-02-14 17:10:15
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP150/151 concerns and some comments 
Recently I read some concerns about BIP150/151 and its ?identity system?.
I think we should take those concerns seriously and I wrote some
comments for some of the concerns I'm aware of. In my opinion, most of
these worries are unfounded.
Concern 1: BIP150 introduces a identity system that could partition the
- Users already filtering/authenticate peers by IP tables, ?addnode?
command, peer banning in app-layer. Fast block relay is a good example
(example: FIBRE).
- BIP150 allows to switch from IP based authentication (which is
obviously not ideal) to a secure form of authentication with pre-shared
keys (ECDH).
- We can?t stop peer operators to selectively manage peers and there are
valid reasons to do that
Concern 2: But BIP150 makes it simpler and increase the risk of network
- What is simpler, presharing a pubkey over a secure channel (PGP /
Signal) and store in on both peers or calling a ?addnode ?, or
?iptables-DROP ??
Concern 3: Identity is not something we want in Bitcoin
- BIP150 introduces an **optional** authentication over a EC pubkey. The
EC pubkey can be changed. It?s different per network interface. You only
reveal it to peers that already have proven the know your identity.
- IP addresses are also a form of identity and way more inflexible and
different to hide.
Concern 4: But peers can fingerprint my node and ban me after BIP150 has
been deployed
- They can?t fingerprint you over BIP150 messages, it does not reveal
your identity unless the responding peer has proven he knows your identity.
Concern 5: BIP150/151 is not necessary, we have already Tor and STunnel,
- Tor is an alternative, right. But do we want to depend on those
technologies? Using tor for a single secure channel seems like using
a sledgehammer to crack a nut.
- How many SPV users have encrypted channels to trusted nodes today? Is
it accessible for the novice user? - Peer operators who depend on designated connections (with addnode),
what security do they have today (IP address, really?)?
- I think tor is great, it can be an alternative or an additional
security enhancement (encrypt twice). IMO the focus of Tor is not on
securing single channels (it's rather onion routing / anonymity).
Concern 6: BIP151 gives a false sense of security and has no MITM detection
- BIP151 (pure encryption) has no MITM detection, correct.
- Without BIP151 encryption, everyone can hook into the stream and read
what?s going on. With BIP151, an attacker needs to actively substitute
ephemeral keys in both direction. This attack is A) more complex to
achieve and B) it?s an active attack (no excuse of ?I just made some
statistics?), C) it requires the attacker to accept the risk of being
- C) is true because an optional authentication (can be BIP150 or
different) would reveal the attack.
- Some attacks are worthless if you have to take the risk mentioned in C)
Concern 7: But Bitcoin traffic is trustless, why the hell you want to
encrypt it?
- If you use one of the todays available SPV clients, you will reveal
your complete wallet content (?~all your addresses") to every network
observer between you and the node you have connected to. This means, if
you pay for a coffee (while being on the owners WIFI), the coffee owner
and all the involved ISPs can correlate your wallet with your other
internet behavior. Same is true for your cellphone provider if you use
- They still can, if you don?t have a trusted node, by performing the
attack that involves the risk mentioned in Concern 6.
Concern 8: If you want to have a light client, you should use a
different channel to communicate with your full node then the p2p layer
- From a design perspective, this could make sense
- From an end user?s perspective, this is undesirable (enabled different
port, lack of a (RPC / ZMQ, etc.) standard, no fallback option if the
trusted node is down, hard to setup)
- Using the p2p channel as the todays SPV do, seems very reasonable to
me. Keep the users on the p2p layer! If we don?t want the users on that
channel, we automatically form a different layer, the wallet-com wild-west.
- Keeping the users on the p2p layer also allows future changes where
they can help the network in some ways.
- Using the p2p layer for a trusted connection also allows to fallback
anytime to non-trusted nodes (if your trusted node is no longer
reachable). If your SPV peer needs to catch up a couple of hours while
your trusted peer was done, fine, download full blocks or change your
bloom filters FP rate significant (or sacrifices your privacy in this case).

@_date: 2017-02-14 21:58:54
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP151 protocol incompatibility 
It's still backward compatible. All (?) SPV clients and full node
implementation would still work if BIP151 has been implemented.
Isn't that backward compatibility?
Yes. But encryption negotiation must be done before the version
handshake (security).
This is not true. If the connecting peer (assume the SPV client) will
not request encryption, the responding peer (the node) will not enforce
or ask for encryption.
This is clearly written in the BIP.
I think the BIP makes this very clear. IMO you are trying to hide your
standpoint behind a wired interpretations of the BIP.
From the BIP:
?To request encrypted communication, the requesting peer generates an EC
ephemeral-session-keypair and sends an encinit message to the responding
peer and waits for a encack message. The responding node must do the
same encinit/encack interaction for the opposite communication direction.?
This seems to be pretty clear to me. You can interpret the "requesting
peer" and "responding peer" per message interaction. But then the whole
BIP would make no sense.
I'm happy if you can do a PR on the BIP that makes the wording better.
This would actually be a productive step.
Then you would have to go after all BIPs deployed this way. This
argument has nothing to do with BIP151 it questions the whole new
protocol features deployment.
Again, check this code part:
That's up to the implementation. But the current flexibility exists
because we not drop.
Again, see above.
No. I'd like to hear from you why the DOS attack vector would be larger
if the encryption neg. would be after the version handshake.
Again. Encryption ? for the sake of security ? must be the first
This is exceptional for BIP151 and I'd like to hear the real downsides
of doing that.
What? You want to define protocol version number in draft improvement
How should that be possible?
It's like defining a new HTML version number if you propose/draft a new
video streaming format.

@_date: 2017-02-14 22:01:51
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP150/151 concerns and some comments 
- What protocol would you use? The same p2p protocol but different port
and/or different process? Why?
- If not the p2p protocol, how would you form a standard? Would it be
worth doing a standard?
- Could you fall back to the current SPV model against random untrusted
peers if you additional channel is not available?
- What are the downsides using current p2p network?
- Would this also solve the security problem of creating designated
channels between peers (the "addnode" thing is based on IPs)?

@_date: 2017-01-01 22:01:23
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Committed bloom filters for improved wallet 
I started exploring the potential of BFD after this specification.
What would be the preferred/recommended way to handle 0-conf/mempool
filtering ? if & once BDF would have been deployed (any type,
semi-trusted oracles or protocol-level/softfork)?
From the user-experience perspective, this is probably pretty important
(otherwise the experience will be that incoming funds can take serval
minutes to hours until they appear).
Using BIP37 bloom filters just for mempool filtering would obviously
result in the same unwanted privacy-setup.

@_date: 2017-01-04 08:47:10
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Committed bloom filters for improved wallet 
I agree that unconfirmed transactions are incredibly important, but not
over SPV against random peers.
If you offer users/merchants a feature (SPV 0-conf against random
peers), that is fundamentally insecure, it will ? sooner or later ? lead
to some large scale fiasco, hurting Bitcoins reputation and trust from
Merchants using and trusting 0-conf SPV transactions (retrieved from
random peers) is something we should **really eliminate** through
education and by offering different solution.
There are plenty, more sane options. If you can't run your own full-node
as a merchant (trivial), maybe co-use a wallet-service with centralized
verification (maybe use two of them), I guess Copay would be one of
those wallets (as an example). Use them in watch-only mode.
For end-users SPV software, I think it would be recommended to...
... disable unconfirmed transactions during SPV against random peers
... enable unconfirmed transactions when using SPV against a trusted
peer with preshared keys after BIP150
... if unconfirmed transactions are disabled, show how it can be enabled
(how to run a full-node [in a box, etc.])
... educate, inform users that a transaction with no confirmation can be
"stopped" or "redirected" any time, also inform about the risks during
low-conf phase (1-5).
I though see the point that it's nice to make use of the "incoming
funds..." feature in SPV wallets. But ? for the sake of stability and
(risk-)scaling ? we may want to recommend to scarify this feature and ?
in the same turn ? to use privacy-preserving BFD's.

@_date: 2017-01-07 09:13:09
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Bitcoin Classic 1.2.0 released 
Hi Tom
Please don't post release announcements for software that is
incompatible with the current bitcoin consensus rules here.
Otherwise we give green-lights to any sorts of altcoin to post their
releases here.

@_date: 2017-07-12 14:38:33
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] A Segwit2x BIP 
Tested? Where?
However, the hardfork part may be out there for a long time but  _is still broken_.

@_date: 2017-06-11 22:19:20
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Bitcoin pointers 
Hi Jos?
A similar/related proposal got posted last month :  The Bech32 encoded transaction position reference allows to solve similar use cases (tx pointers) with a strong error-detection/correction using just 14 chars (encoded state, including error correction / unencoded 40bits).

@_date: 2017-06-19 17:49:59
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
I think many users would be willing ...
a) ? to trade higher privacy (using client side filtering) for not having the ?incoming transaction? feature
b) ? if they want 0-conf ? to fetch all inved transactions

@_date: 2017-06-19 18:10:13
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
Yes. Users probably like this feature and client side filtering is not a drop-in replacement for BIP37.
We should also consider:
BIP37 works, because node-operators are willing to offer that service for free (which maybe change over time).
BIP37 consumes plenty of horsepower (disk/cpu) from nodes. Filtering a couple of days of blocks (assume 1000+) eats lots of resources for something, that has no direct long-term value for Bitcoin (the filters data is unique and will be "thrown away? [can?t be used by other peers]). Same applies for mempool (filtering mempool of a couple of hundred of mb each time the HD gap limit has been exceeded or the app gets sent to the foreground again).
Purely relying on the availability of BIP37 seems fragile to me and start to explore other ways is very reasonable.

@_date: 2017-06-19 18:22:03
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
IMO privacy its something developers should make sure users have it.
Also, I think, todays SPV wallets should make users more aware of the possible privacy implications.
Do users know, if they pay for a good in a shop while consuming the shops WIFI, that the shop-owner as well as the ISP can use that data to combine it with the user profile (and ~ALL FUTURE purchases you do with the same wallet IN ANY LOCATION online or in-person)?
Do users know, that ISPs (cellular; including Google) can completely link the used Bitcoin wallet (again: all purchase including future ones) with the to the ISP well known user profile including credit-card data and may sell the Bitcoin data to any other data mining company?
If you use BIP37, you basically give your transaction history (_ALL TRANSACTIONS_ including transactions in future) to everyone.
This may be true because they are not aware of the ramification and I don?t think client side filtering is a drop-in replacement for todays, smartphone SPV-model.

@_date: 2017-06-19 18:30:18
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP Proposal: Compact Client Side Filtering for 
I see this use case.
But I did receive bank wire transfers for the last decades without _immediately_ knowing that someone sent funds to me.
I personally would ALWAYS trade the higher bandwidth consumption (300MB mempool filtering) or slower notification time (maybe ~1h) for preserving privacy.
I agree, there are use cases where you want immediate notification, those use cases could probably be solved by not trowing away privacy (?parsing? all transactions and running in the background).

@_date: 2017-03-06 09:14:23
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Currency/exchange rate information API 
I like the BIP. It can reduce workload during implementation on both sides of the API and it allows to show the user more data without implementing tons of proprietary APIs.
It?s not directly Bitcoin specific (example: BIP32 is also not Bitcoin specific), but I think a BIP is the right way for this.
Long polling is a simple push concept that works on most type of network configurations (NAT, proxy, etc.).
The only concern I see here is that an public API will quickly fill up the maximum allowed httpd connections.
But it?s solvable.
I?m also not sure how useful historical datapoint are. I don?t think the use case where someone wants to restore from a seed and get all exchange rates during the time of the payment is something users are looking for.
However, It?s optional.
Agree with Luke. A ?real? push (though I?d say long-polling is the real push, AFAIK it?s also the technique behind Apple?s iOS push channel) would require a complex server setup that complicates many things like load-balancer, mem-caching, etc.

@_date: 2017-03-08 20:47:54
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Unique node identifiers 
Please Eric. Stop spreading FUD.
BIP150 has a fingerprint-free **OPTIONAL** authentication. It?s designed to not reveal any node identifier/identity without first get a crypto.-proof from other peer that he already knows your identity.
**Peers can?t be identified without having the identity-keys pre shared by the node operators.**

@_date: 2017-03-08 22:20:39
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Unique node identifiers 
What you did say in the sentence above (and I think is FUD) is, that BIP150 will lead to every node being identifiable. This is just completely wrong.
There is nothing to say against a technical debate (and we had this), but I will ask you to stop if I see you attacking BIP150/151 at every occasion with FUDish arguments like this.

@_date: 2017-03-08 22:31:01
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Unique node identifiers (and BIP150) 
Hi Tom
This thread is not about BIP150/151.
The hash includes the encryption session which makes it impossible to distinct identities.
Not true. The hash includes the encryption session which is based on a ephemeral ECDH/HKDF per connection-session.
Have you read the BIP?

@_date: 2017-05-11 17:13:12
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits 
Currently, pruned peers have no way how to signal their (valuable) service.
A BIP proposal to improve this (draft):
 Feedback is highly welcome.

@_date: 2017-05-11 22:10:08
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits 
I though two service bits allow three states and we should define all three combinations.
But I guess an adequate ?definition? would be to reserve it for future ?definitions?.
Or use Gregory's proposal of min 2016*2 blocks & keep it ?undefined? for now.
49 days was chosen to allow SPV peers to be ?offline? for a month and still be capable to catch-up with a peer pruned to a datadir of ~10GB.
AFAIK Core does also guaranteed the 288 blocks post segwit activation:
But maybe I?m confused.
Indeed. I?ll try to make that more clear.
AFAIK, Core does currently only relay NODE_NETWORK addresses.
But yes, It may be a problem already.

@_date: 2017-11-21 09:00:21
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP159 - NODE_NETWORK_LIMITED service bits, 
Hi Sjors
Thanks for picking this up.
There where some previous discussions about this [1] [2].
Initially, the idea was to have two service bits to signal (up to three) states.
But, since it is not clear what use-cases the bits signalling >288 blocks would fulfil, I have limited BIP159 to a single 288blocks-available signalling.
Therefore, BIP159 aims to improve the block relay state around the tip (24h) which seems to be the most significant request peak (peers out of IBD).
Also, it takes an acceptable transition for pruned node operators into account. Once BIP159 gets active on the network, pruned peer operators may see an increase in CPU and bandwidth usage.
SPV peers may also connect to BIP159 nodes, scan the mempool and wait for unconfirmed transactions (they don?t do this now because pruned nodes don't signal any service).
Future extensions are possible. Maybe a p2p command that could tell more infos about the pruning state would be useful.
BIP159 also recommends to fix the fingerprinting weakness by fix limiting it to 288 blocks, making it impossible for an attacker to fingerprint your peer by scanning how deep the peer can serve blocks. This may be a reduction for possible use cases with todays pruned peers and an idea would be to relax this limit for whitelisted peers (or peers connecting via BIP150 [not implemented], and this is the only connection between BIP150 and BIP159).
However, I think the scope of BIP159 should be kept as it is. More flexibility can be added later when we have gathered more information during BIP159 deployment.
Also, the implementations is an advanced stage [3][4]
[1] [2] [3] [4]

@_date: 2017-11-27 10:49:07
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Block compression 
Hi Jeff
There where previous discussions about similar approaches [1] [2].
I?m not sure if compression should be built into the protocol.
My humble understanding of it, is, that it should be built into different layers.
If bandwidth is a concern, then on the fly gzip compression like apaches mod_deflate could be something. But I expect fast propagation is often more important then a ~30% bandwidth reduction.
Bandwidth may be a concern for historical blocks transmission. If you continue the proposal, I think you should focus on historical blocks.
If disk space is a concern, then the database layer should handle the compression.
[1]  [2]

@_date: 2017-09-07 09:47:16
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Proposal: Extended serialization format for 
Thanks for the proposal.
Three points it could see as possible improvements:
From what I know, the exact birthday in seconds doesn?t matter that much therefore it may be possible to just use 13 or 16bits to create a representation in week from 2009-01-09 00:00 UTC. 13bits would give you 157 years.
Always round down to the beginning of the week when the key was created.
But not sure if it?s worth to save ~two bytes for that.
Also not sure if the key-birthday in seconds could have a security or privacy implication (week maybe better).
Would it make sense to have special depth bytes that directly implies it?s a BIP44 master key (and therefore avoid the bip32 path serialisation)? I know some ?centralised? table need to be available for that which may be not a good idea. But maybe the BIP could reserve a couple of depth-bytes (maybe 0xF0 to 0xFF) for predefined paths.
Would adding a version bit make sense to allow future extensions?

@_date: 2017-09-29 21:49:52
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Paper Wallet support in bitcoin-core 
AFAIK, client implementations such as your proposal are off-topic for this ML.
Better use bitcoin-core-dev (ML or IRC) or Github (bitcoin/bitcoin) for such proposals.
I have to agree with Luke.
And I would also extend those concerns to BIP39 plaintext paper backups.
IMO, private keys should be generated and used (signing) on a trusted, minimal and offline hardware/os. They should never leave the device over the channel used for the signing I/O. Users should have no way to view or export the private keys (expect for the seed backup). Backups should be encrypted (whoever finds the paper backup should need a second factor to decrypt) and the restore process should be footgun-safe (especially the lost-passphrase deadlock).

@_date: 2017-09-30 14:14:44
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Paper Wallet support in bitcoin-core 
The current Bitcoin Core wallet setup is not as ideal as it could be.
An good example is, that the wallet and the full node (the p2p logic on 8333) do share the same process (same memory space).
AFAIK a lot of users use Core in watch-only mode and do the signing offline (offline / through HWWs).
Although, Core has currently no direct support for offline signing (expect the rawtx API which are pretty expert-ish).
The Core development process goes into that direction but it takes time due to the strict and extremely important code quality insurance.
IMO we should make it better not worse.
Paper wallets delude to do address reuse, the spending-procedure is unclear, and very likely insecure.
A quick photo-snapshot by an attack may result in a full compromised key.
Printer buffers, etc. are also something to worry here.
I think Bitcoin Core does a great job there. But not sure about other security layers are outside of Core.
Especially your operating system.
The reason why we see a growing demand in hardware wallets is probably because people no longer trust in current available operating systems as well as current used desktop/laptop CPUs (like Intel wit it?s MME, etc.).
Yes. That actually something we are considering (especially if we would allow BIP44 or other HD public key derivation forms).
Also, we heard of "support sessions? on IRC where attackers told victims they must enter ?dumpprivkey? in the Console and give them the output in order ?to fix the problem?.
I dislike that as well ? in general. But I guess most users like self-protection. Also, the user layer is attackable. If _you_ can access the private-keys, an attacker can do also. What most users want is a key-safe that only signs transactions which they could verify beforehand in a safe environment, and not a way to export private keys or something else that can touch the keys.
The answer is probably: No (for now). But working towards this should be the focus.

@_date: 2018-04-13 21:12:47
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BloomFilter issue with segwit addresses 
Hi Andreas
Thanks for bringing this up and this seems indeed to be suboptimal.
Bitcoin Core is not an identity that can be ?willing to extend? (or reject) a feature.
Someone needs to come up with a proposal (pull request).
Maybe an extension for BIP37 would make sense (*meh*).
Just inserting the witness data into the bloom filter seems to be an easy solution (CBloomFilter::IsRelevantAndUpdate())

@_date: 2018-08-28 20:36:21
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Building a Bitcoin API and query system. 
To give a critical viewpoint on a such API:
Such APIs usually result in central validation, meaning that users trust API services rather the validating their own data. It break some of the fundamental properties of Bitcoin (avoid trusted third parties).
Systems or applications depending on a full indexed blockchain (a thus such API) do usually scale pretty bad.
I?d like to hear some concrete use-cases for a such block explorer(ish) API.

@_date: 2018-08-29 20:27:51
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Building a Bitcoin API and query system. 
IMO an API that serves non verifiable data is supporting centralised validation. The ?API" which supports one of the most important properties in Bitcoin ? the ability to self-validate ? is the data available via the p2p network.
Bitcoin-Core has all required features to partially ?index? data (called the wallet) and provides them via the RPC API. If you don?t need to serve thousands of wallets (which smells after centralised validation), selective indexing (wallets) are the right choice. Also, if you have a proper light client architecture, you can use Bitcoin Core in pruned mode (<10GB of data) to serve an endless amount of wallets (client/server mode, I guess that is what you are referring to with "light clients").
I fail to see the use-cases where a fully index blockchain makes sense (the only one I can come up with is instant backup recovery where the transaction history needs to be preserved rather then recovering the UTXOs only).
Also, the p2p protocol has built in light client support with BIP37 (bloom filters) and soon BIP158 will be available on the network which does allow privacy-preserving "light clients" in a way where no trusted layer is required (client <-> p2p network rather then client <-> API provider <-> p2p network).
I don?t want to advocate against a full-index blockexplorer-like API. I just think its important to define the use case and be aware of the consequences and downsides.

@_date: 2018-02-09 07:22:38
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Electrum Personal Server alpha release 
Thanks Chris for sharing!
I?m following a similar approach where I?d like to share a more detailed specification soon.
Since Chris brought this up here, I?d like to shed some lights on that, very similar approach.
The idea is to have a Bitcoin Core instance running either with internal (Core) support for the proposed interface or via an external script (python bridge) while the later is probably preferable (hardened HTTPd, less impact on Core).
The idea is, that the interface can create new wallets (needs dynamic loading/unloading of wallets in Core), add addresses to a wallet (== add watch-only addresses).
Addresses on the client are only visible once they could be added via the interface to the Core wallet as watch only (avoid missing transactions, addresses can be pre-added by the client and used later)
New transactions can be created through the interface (which will use fundrawtransaction with watch-only-addresses in the background).
Coin selection, fee calculation, etc. would happened on the Core node.
Signing of transactions happens on the client (maybe BIP174).
Optionally, a 2of2 (or 2of3 with a backup key) could be achieved where the node would also hold a key to have some sort of ?2FA? if the node and the client environment are owned by the same person.
This would work with pruned nodes and can serve ? depending on the used hardware ? up to a couple of hundred wallets.
Backup restores (xpriv sweeps) are also possible via the UTXO set and take less then a minute and don?t require the full transaction history (or any kind of index).
Additional, the interface could also act as central, personal multisig bridge where n clients could use the same endpoint to participate in multisig wallets.
Overall, this wold allow a slick and secure (personal or group) (multi-)wallet service that works perfectly fine on pruned nodes by simply adding a bridge-script.

@_date: 2018-06-03 18:51:09
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] New serialization/encoding format for key material 
The BIP proposal is now available here:
Reference C code is available here:
Feedback, criticism, etc. welcome!

@_date: 2018-06-03 23:30:48
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] New serialization/encoding format for key material 
Thanks Peter
I removed the part in the proposals that made false claims about the error
correction or cpu-intense key recovery.
I wrote some test code and figured out that my Core i7 machine can
do 31?775 operations per seconds of a addr-derivation-comparison
(bech32 decode, bip32 ckd, hash160, Base58check).
This is non-optimized code running non-parallelized.
Just in case someone wants to do more math here.
Without knowing to much about BCHs, ideally there would be a code that
includes the fact that computational costs for error correction can be very
high during a disaster recovery and that we can probably assume that the
user can provide a derivation element like a used address or pubkey.
Deriving one million child keys and comparing them against an address
table will take less than a minute on consumer systems.
I think 5% error correction (7 errors at 555bits) with a 26 char checksum is
probably an acceptable tradeoff.
Resulting string with 26 checksum chars (mockup):
(140 chars)
Versus the bech32 (6 char checksum):
(120 chars)
Versus an xpriv:
(111 chars)
Not sure if the additional 20 characters make the UX worse.
Typing in +20 chars in a disaster recovery is probably acceptable.
Yes. Please.
Lets first wait for more feedback about the error robustness though.

@_date: 2018-06-19 11:38:24
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 174 thoughts 
I think all of Pieters points are valid and reasonable thought, though I?m unsure if it would be worth changing the existing-implementation-breaking things like the k/v set model.
AFAIK things like non-hex-encoding or generic key offset derivation are extensions and would not break existing implementations.
Further thoughts on BIP174 from my side.
Key derivation in multisig:
From my understanding, the signers and the creator must have agreed ? in advance to the PSBT use case ? on a key derivation scheme.
BIP32 derivation is assumed, but may not always be the case.
Sharing xpubs (the chaincode) may be a concern in non-trust-relationships between signer(s) and the creator (regarding Pieters xpub/fingerprint concerns).
Providing the type 0x03, the bip32 derivation path is one form of a support to faster (or computational possible) derivation of the required keys for signing a particular input.
From my point of view, it is a support of additional metadata shared between creator and signer and provided from the creator to the signer for faster (or computation possible) key deviation.
I think it could be more flexible (generic) in BIP174.
It could be just a single child key {32-bit int}, or just a keypath ({32-bit int}]{32-bit int}?) which is very likely sufficient for a HWW to derive the relevant key without the creation of a lookup-window or other ?maps".
It could even be an enciphered payload which was shared during address/redeem-script generation and ?loops? back during a signing request.
Maybe I?m overcomplicating things, but for practical multisig with HWWs, a simple BIP32-child-key-index or BIP32-keypath derivation support field should be sufficient.
A generic ?derivation support field?, provided from the signer to the creator during address-generation that just ?loops? back during the PSBT use-cases is probably a overkill.

@_date: 2018-06-19 17:20:34
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 174 thoughts 
I agree with matejcik?s point 1 to 3 and especially with point 4.
The mandatory flag (or optional-flag) makes much sense to me.
I don?t see any reasons why space would be an issue.
HWWs probably can?t handle PBST natively since it is not optimised for
presenting various informations in a signing-verification.
A single stream-in of a PSBT through USB (or similar channel) will not work in
many cases since HWW come often with very restrictive RAM constraints.
Furthermore, I forget to mention in my last mail, that registering (or defining)
a mime-type for PSBT would probably a great usability feature.
(Send PSBT by email/messanger and with dbl-click to open feature, etc.)

@_date: 2018-06-25 22:10:12
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] BIP 174 thoughts 
I don?t think bech32 is a fit here.
Bech32 is a BCH where the error detecting properties are optimised for 1023 chars max and in the special case of the Bech32 BCH, error detection of 4 chars are guaranteed with a max length of 90 chars.

@_date: 2018-05-17 09:47:34
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Moving away from BIP37, unsetting NODE_BLOOM 
Hi Caius
Thanks for brining this up.
As far as it looks, one of the major SPV library does not yet respect the NODE_BLOOM service flag [1]. Unsure sure about others.
It think disabling NODE_BLOOM services by default in full node implementations makes sense as soon as BIP158 [2] (compact block filters) has been implemented and therefore NODE_COMPACT_FILTERS is signalled broadly. Unsure if it would make sense to even wait for block filter commitment softfork (probably no).
Then, the question is, if there are alternatives for mempool filtering (display unconfirmed transactions) or if the protocol recommendation are to disable that by default or recommend to use centralised filtering technique via wallet provider infrastructure (privacy?!).
I guess everyone here agrees that there are major privacy and load-distribution issues with BIP37, and, that it should be disabled in the long run.
But, due to the lack of alternatives, there is the risk of breaking existing SPV client models and thus pushing users to complete centralised validation-solutions (and even towards centralised key-storage), which, may result in making privacy and security even more worse.
I personally miss a long term concept how to keep non expert users (or say light clients) close to the p2p protocol in a decentralized fashion. Unclear how decentralized fee estimations and ?incoming transactions? (which is something users want even if it's a broken concept) are handled in the future.
[1] [2]

@_date: 2018-05-29 11:13:37
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] New serialization/encoding format for key material 
Extended public and private keys are defined in BIP32 [1].
Encoded extended private keys should not be confused with a wallet ?seed?
(proposals like BIP39) while they can also partially serve the purpose to
?seed? a wallet (there may be an overlap in the use-case).
Recovering a wallet by its extended private master key (xpriv; may or may not
be at depth 0) is a complex task with risks of failing to recover all available
It may be reasonable to consider that recovering a wallet purely based on the
existence of an extended private master key is a forensic funds recovery
process and should probably be the last resort in case of a backup-recovery
situation. A simple example here is, that it was/is possible to have used an
xpriv (referring to extended private master key) in production that is/was used
to derive BIP45 based P2SH multisig addresses (1of1, used by Bitpays BWS for
while), later used for bare BIP45ish multisig 1of1 as well as for P2PKH after
BIP44 & vanilla BIP32 P2WPKH (m/0?/k?).
I?m not aware of any wallet that would recover 100% of those funds, leading to
the risk that forwarding the unspents and destroying the extended master key
may result in coins forever lost.
The case above may be an edge case, but I?m generally under the assumption that
recovering funds based on the sole existence of an xpriv (or seed) without further
metadata is a fragile concept.
Second, the missing birthday-metadata tend to lead to non-optimal blockchain
scans (eventually increased p2p traffic). Recovering funds can take hours.
Additionally, the BIP44 gap limit seems to be a weak construct. The current gap
limit in BIP44 is set to 20 [2] which basically means, handing out more then 20
incoming payment requests (addresses) results in taking the risks that funds
may be destroyed (or at least not detected) during a recovery.
The Gap limit value may also depend on the use case, but the current proposals
do not allow to set an arbitrary value. High load merchants very likely need a
different gap limit value then individuals create a transaction once a year.
During creation time of an xpriv/xpub, it is impossible to know if the created
xpriv will be used for an unforeseen derivation scheme. Future proposals may
want to limit an extended key to a single derivation scheme.
This is an early draft in order to allow discussion that may lead to a possible
This proposals could also make BIP 178 obsolete since it can be replace the
WIF[3] standard.
Thanks for feedback
Bech32 encoded key material including metadata
An error tolerant encoding format for key material up to 520bits with a minimal
amount of metadata.
(See above; intro text)
 Serialization format
1 bit version bit
15 bits (bit 1 to 16) key-birthday (0-32767)
(12 bit gap limit)
3 or 5 bits script type
256 or 512 or 520 bits key material
= Total 275, 545, 553 bits
The initial version bit allows extending the serialization-format in future.
The encoding format must hint the total length and thus allow to calculate the
length of the key material.
The total length for 256 or 512 bit key material is optimised for Bech32 (power
of 5).
 Key material
If the key material length is 520 bits, it must contain an extended public key
If the key material length is 512 bits, it must contain an extended private key
Key material length other then 256, 512, 520 bits and invalid.
If 520 bits are present, first 256 bits are the BIP32 chain code, to second 264
bits (33 bytes) define the public key (according to BIP32)
If 512 bits are present, first 256 bits are the BIP32 chain code, to second 256
bits define the private key
If 256 bits are present, those bits represent a pure private key (or seed)
 Key birthday
A 15 bit timestamp expressed in days since genesis (valid up to ~2098). The
birthday must be set to the first possible derivation of the according extended
key, if unknown, the used seed birthday must be used. If both unknown, 0
(16x0bit) must be used.
 Gap limit delta
12 bits, results in a possible range from 0 to 4095.
If the total decoded serialization length is 275 bits (decode) or if the key
material is 256 bits (encode), the gap limit must not be present.
The base gap limit value is 20 (to disallow insane gap limits). The final gap
limit is the base value + the gap limit delta stored in those 12 bits.
Key derivation gap limit must not be exceeded when deriving child keys and must
be respected during transaction rescans.
Child key derivation must not be possible if gap limit is hit.
 Script type restriction
3 or 5 bits (range 0-7 / 0-31)
0 no restriction
1 P2PKH compressed
2 P2PKH | P2SH
3 P2WPKH P2WSH nested in P2SH
4 P2WPKH | P2WSH
If the total decoded serialization length is 275 bits (decode) or if the key
material is 256 bits (encode), 3 bits are used for the script type. 5 bits are
used for key material with the size of 512, 520 bits.
If the script type restriction is set, the according extended key must only be
used to derive addresses with the selected script type.
This does not stands in contradiction to derivation path proposals ([4]). It
does allow to derive and encode an extended key at a keypath where users assume
restricted script types in derivation due to other supported proposals.
Bech32 must be used as encoding format (see the Bech32 rational [5]). Encoding
545 or 553 bits (results in 109 resp. 111 x 5 bits) will exceed the Bech32 property of a
guaranteed detection of 4 errors (only 3 are).
It is possible that there are more efficient BCH codes, especially for encoding
extended private keys. Since a Bech32 implementation needs to be present in
modern Bitcoin software, re-using Bech32 will allow to migrate to this proposal
with a minimal implementation effort.
Forensic, cpu-intense key-recovery (including brute-force techniques) may allow
to recover keys beyond the guaranteed error detection limits.
Bech32 HRPs
Mainnet Private Extended: xp
Mainnet Public Extended: xpu
Testnet Private Extended: tp
Testnet Public Extended: tpu
Mainnet Key: pk-
Testnet Key: tk-
Only new software will be able to use these serialization and encoding format.
[1]  [2] [3] [4] [5]

@_date: 2018-05-30 21:03:46
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] New serialization/encoding format for key material 
What would be the downside of encoding the same key with different metadata (resulting in different "visual strings?)?
If you import it into the same software, it would be trivial to detect it. If you import it into another software, it probably doesn?t matter.
Visual comparing is eventually a broken concept (agree with Greg) and I doubt that this property is important, and IMHO basic metadata seems more important then this - very likely irrelevant - visual property.
Also, I think a recovery based on a sole xpriv (or + limited amount of meta-data as described in this proposal) is a disaster recovery (or forensic recovery).
Long term, I would wish, if wallet-metadata including transaction based user metadata would be backed up - after encrypted with a key that can be derived from the seed - in a way, where you need the seed to recover that backup thus it can be stored in cheap, insecure spaces.
The proposal I made can be seen as a replacement for WIF (it can replace WIF and xpriv/xpub) since it can encode a single private key into 275bits (still pretty short Bech32 string).

@_date: 2018-09-03 14:16:19
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Overhauled BIP151 
During work on the implementation of BIP151 [1] I figured out that the current
published proposal could be further optimized.
I wrote an overhauled BIP151 specification with some ? partially radical ?
Now it?s unclear to me if this should be published under a new BIP nr. or if it
is acceptable to change the existing 151 proposal.
If a new BIP number would be required, I think withdrawing BIP151 should be
done (which somehow indicates we should alter 151).
The only BIP151 implementation I?m aware of is the one from Armory [2].
BCoins implementation has been removed [3].
The new proposal draft is available here:
Major changes
- the encryption handshake no longer requires the v1 protocol, it?s a pure
  32bytes-per-side ?pseudorandom" key exchange that happens before anything else.
- the multi message envelope has been removed.
- a new NODE_ENCRYPTED service bit
- the key derivation and what communication direction uses what key is now more
  specific
- the length of a packet uses now a 3-byte integer with 23 available bits
- introduction of short-command-ID (ex.: uint8_t 13 == INV, etc.) which result in
  some v2 messages require less bandwidth then v1
- rekeying doesn?t require a message and can be signaled in the most
  significant bit in the packet-size field
Points that are in discussion and may be added to the BIP (or to a new one):
Hybrid NewHope key exchange
The current ECDH key exchange is vulnerable to Shor?s algorithm and is thus not
considered quantum-safe.
Following TORs approach [4] by adding a NewHope [5] key-exchange the handshake
protocol would very likely make the encryption PQ safe with little costs.
There is also a straight forward implementation [6] from the NewHope team that
has been submitted to NIST PQC project.
Inefficiency of ChaCha20Poly1305 at openssh
The proposed AEAD could eventually be further optimized.
ChaCha20Poly1305 at openssh uses at least three rounds of ChaCha20 which
eventually can be reduced to two (messages below <=64 bytes [inv, ping,
pong,...] only require one round of ChaCha20, but two for the Poly1305 key and
the message length encryption where the Poly1305 key chacha round ?throws away?
32 bytes).
I would suggest that we don?t rehash discussions about the general
concept of encrypting the traffic. This has already been discussed [7][8].
I hope we can limit this thread to discuss further ideas for optimisation as well as
technical details of the published proposal or its implementation.
[1] [2] [3] [4] [5] [6] [7] [8]

@_date: 2018-09-07 10:34:13
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Overhauled BIP151 
Hi Tim
Thanks for the feedback.
I agree with all of Gregs answers.
All-or-none censorship attacks are out of scope for BIP151.
We won?t achieve DPI robustness in this proposal and I think it should not be part of the p2p protocol.
I think all-or-one censorship situations require an additional layer like TOR with OBFS4 (where AFAIK Eligator is used).
Eventually Core does directly support non-tor routed pluggable transports (it's partially already possible via SOCK proxy, but not on a gossip and plugin-launch level).
This does not exclude that we should obfuscate the key exchange as good as we can without blowing up the implementation too much.
The proposed encryption adds a robustness to the thread model with very little costs and low risks.
This is a good point and I?d like to see more concrete examples how this (the non dynamic salt) could be exploited.
In ChaCha20Poly1305 at openssh, the length field is AAD, encrypted with a different key and part of the MAC.
The Rekey cost is two times a double-SHA256,? the costs of a rekey is similar to one or two v1 INV message creations.
I think a new message type that could contain message + pad would be trivial.
Would this again be to obfuscate traffic patterns? Anti DPI is not the scope of BIP151.
I wanted to avoid too much central planing here and only cover the ones where it's most efficient (small messages that are used often).
The ASCII commands are in itself somehow pseude-robust against collision.
For a 1MB block message, using a 1-byte short ID (rather then a 6-byte ASCII command) would reduce the bandwidth requirement insignificant (99.99952%).
If we would always have used short IDs in the past, there could have been a collision between XTIN, compact, sendheaders or so.
Good points. Will make them more clear in the BIP.
I was under the false impression that it is obvious to disconnect in those cases.
That?s specified in ChaCha20Poly1305 at openssh ("a nonce consisting of the packet sequence number encoded as a uint64?).
But I?ll specified that more clear.
The max data before rekey is 1GB, AFAIK it is impossible to overflow.
Current implementation proposal does a disconnect. With the risk of fingerprinting options, I think we can leave this open to the implementation?
Yes. Should probably be ?sent?,? and eventually a paragraph that states that a peer should disconnect if the remote peer did not rekey within that limit.
Agree. Will try to add.

@_date: 2019-04-03 08:37:31
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] assumeutxo and UTXO snapshots 
Thanks James for the post.
I proposed a similar idea [1] back in 2016 with the difference of signing the UTXO-set hash in a gitian-ish way.
While the idea of UTXO-set-syncs are attractive, there are probably still significant downsides in usability (compared to models with less security), mainly:
* Assume the UTXO set is 6 weeks old (which seems a reasonable age for providing enough security) a peer using that snapshot would still require to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,? probably CPU-days on a phone)
* Do we semi-trust the peer that servers the UTXO set (compared to a block or tx which we can validate)? What channel to we use to serve the snapshot?
If the goal is to run a full node on a consumer device that is also been used for other CPU intense operations (like a phone, etc.), I?m not sure if this proposal will lead to a satisfactory user experience.
The longer I think around this problem, the more I lean towards accepting the fact that one need to use dedicated hardware in his own environment to perform a painless full validation.
[1]

@_date: 2019-07-22 15:25:25
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
Hi Andreas
No. They are not a myth [1] [2] [3].
I guess it?s not about traffic DoS. It?s about asking a peer for extensive CPU and disk work. The NODE_BLOOM peers do provide this service for free while it?s not directly beneficial for the Bitcoin Network (pure consumed CPU/disk time).
I guess this is speculation.
A quick lookup in my crawler databases shows me that there are more than 8?000 ?good? peers supporting NODE_BLOOM right now.
I don?t expect that this number drops rapidly, but maybe in the long run ("in years?, but again: speculation).
We eventually can?t expect - in the long run - that nodes provide disk/CPU intense services for free to clients not contributing back to the network.
However, sadly, due to the privacy leaks in BIP37, I expect that there will always be a wide range of peers offering NODE_BLOOM in return of collecting valuable data.
NODE_BLOOM was added in Core 0.12 [4].
BIP111 is from 2015 [2].
One who follows the protocol development should have known that defaulting NODE_BLOOM to off was something anticipated by most developers.
I would say that there are possible alternatives, like BIP158 (though BIP157 is not widely available on the network yet).
Client side filtering works also by collecting the filter form a centralised service by the wallet provider(s) or a CDN.
You may miss transactions by a dishonest filter-packet, so may you by talking to a dishonest NODE_BLOOM peer.
Of course BIP158 is still young and ? who knows ? eventually once committed to consensus layer (coinbase).
I think the consensus among protocol developers is (please speak up), that BIP37 (public server based tx filtering) ? in general ? was a conceptual mistake.
Maybe extending it further is the wrong step, especially when promising alternatives like BIP158 (neutrino) are around.
The fact that nobody cared about extending it for SW may also underline that BIP37 is seen as a conceptual mistake and/or "low interest in further extensions?.
[1]  [2]  [3]  [4]

@_date: 2019-07-26 12:04:32
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
Yes. It causes more traffic than BIP37.
Basic block filters for current last ~7 days (1008 blocks) are about 19MB (just the filters).
On top, you will probably fetch a handful of irrelevant blocks due to the FPs and due to true relevant txns.
A over-the-thumb estimation: ~25MB per week of catch-up.
If you where offline for a month: ~108MB
Thats certainly more then BIP37 BF (measured 1.6MB total traffic with android schildbach wallet restore blockchain for 8 week [7 weeks headers, 1week merkleblocks]).
But lets look at it like this: for an additional, say 25MB per week (maybe a bit more), you get the ability to filter blocks without depending on serving peers who may compromise your financial privacy.
Also, if you keep the filters, further rescans do consume the same or less bandwidth than BF BIP37.
In other words: you have the chance to potentially increase privacy by consuming bandwidth in the range of a single audio podcast per week.
I would say the job of protocol developers is protect users privacy where it?s possible (as a default).
It?s probably a debatable point wether 25MB per week of traffic is worth a potential increase in privacy, though I absolutely think 25MB/week is an acceptable tradeoff.
Saving traffic is possible by using BIP37 or stratum/electrum? but developers should make sure users are __warned about the consequences__!
Additionally, it looks like, peer operators are not endless being willing to serve ? for free ? a CPU/disk intense service with no benefits for the network. I would question wether a decentralised form of BIP37 is sustainable in the long run (if SPV wallet provider bootstrap a net range of NODE_BLOOM peers to make it more reliable on the network would be snake-oil).
Well, unconfirmed transaction are uncertain for various reasons.
BIP158 won't allow you to filter the mempool.
But as soon as you are connected to the network, you may fetch tx with inv/getdata and pick out the relevant ones (causes also traffic).
Unclear and probably impossible with the current BIP158 specs to fetch transactions that are not in active relay and are not in a block (mempool txns, at least this is true with the current observed relay tactics).
I?m probably the wrong guy to ask (haven?t made the numbers) but last time I rescanned a Core wallet (in my dev branch) with block filters (and a Core wallet has >2000 addresses by default) it fetched a low and acceptable amount of false positive blocks.
(Maybe someone who made the numbers step in here.)
Though, large wallets ? AFAIK ? also operate badly with BIP37.
I wouldn?t say so. It?s on a similar level than BIP37.
BIP37 is not ? and can not ? be committed to the blockchain.
You fully trust the peer that it won?t?
a) create fake unconfirmed transactions (would be the same if a BIP158 wallet would show you unconfirmed transaction)
b) lies by omission (you will miss relevant transactions, eventually swipe your wallet and loose coins)
IMO, the point b) is true for BIP37 and BIP158 (as long as not commited).
In both cases, you can reduce the trust by comparing between peers / filter-providers.
b) is conceptually solvable with a soft-fork (commitment) in BIP158 (not with BIP37).
Additionally, block-filters will, very likely, be useful for other features (load/rescan an [old] wallet on a prune peer that has the filters constructed).
There is probably no clear answer like ?X is better than Y?.
Personally I would like to see developers being more honest/transparent to users about the implications of the used filtering,... and giving them choices.
Imagine a user can choose between ?Electrum / BIP37 / BIP158? depending on his needs for privacy and availability of bandwidth. Eventually also taking the future usage of this wallet (will he load old private keys, will he receive money daily, etc.) into account.
Plus, full node hardware appliances that run at home (or in a trusted environment) are solving many of these issues plus adding a bunch of great features ? if done right.

@_date: 2019-06-17 18:20:32
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] New BIP - v2 peer-to-peer message transport 
Hi Elichai
The in BIP324 (v2 message transport protocol) proposed AEAD, ChaCha20Poly1305 at Bitcoin [1], uses a ?message sequence number?. There is no such thing as random nonce described in the BIP (hence the term ?sequence number?). The message sequence number starts with 0 and the max traffic before a rekey must occur is 1GB. A nonce/key reuse is conceptually impossible (of course implementations could screw up at this point).
Using XChaCha20 with the possibility of a random nonce could be done, but I don?t see a reason to use it in our case since the usage of a sequence number as nonce seems perfectly save.
[1]

@_date: 2019-03-22 22:04:46
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] New BIP - v2 peer-to-peer message transport protocol 
The overhauled version of the former BIP151 has fundamental differences and deserves (requires?) a new BIP.
Calling it ?v2 peer-to-peer message transport protocol? is more accurate since it is no longer only about encryption.
The formatted draft proposal can be found here: Significant changes compared to the current available BIP151
* A optimised AEAD construct is now proposed (ChaCha20Poly1305 at Bitcoin), reducing the required ChaCha20 rounds (compared to the openSSH version).
* introduce NODE_P2P_V2
* 32bytes-per-side ?pseudorandom" key exchange
* the multi message envelope has been removed
* the length of a packet uses now a 3-byte integer with 23 available bits
* introduction of short-command-ID (ex.: uint8_t 13 == INV, etc.) which result in
 some v2 messages require less bandwidth then v1
* the key derivation and what communication direction uses what key is now more
 specific
First benchmarks of the used primitives
 Benchmark of the AEAD compared to the HASH (double SHA256)
(Indicates that v2 messages may be more performant):
   BIP: ???
  Layer: Peer Services
  Title: Version 2 Peer-to-Peer Message Transport Protocol
  Author: Jonas Schnelli   Status: Draft
  Type: Standards Track
  Created: 2019-03-08
  License: PD
== Abstract ==
This BIP describes a new Bitcoin peer to peer transport protocol with
opportunistic encryption.
== Motivation ==
The current peer-to-peer protocol is partially inefficient and in plaintext.
With the current unencrypted message transport, BGP hijack, block delay attacks
and message tempering are inexpensive and can be executed in a covert way
(undetectable MITM)[
Hijacking Bitcoin: Routing Attacks on Cryptocurrencies - M. Apostolaki, A.
Zohar, L.Vanbever].
Adding opportunistic encryption introduces a high risk for attackers of being
detected. Peer operators can compare encryption session IDs or use other form
of authentication schemes [
BIP150] to identify an attack.
Each current version 1 Bitcoin peer-to-peer message uses a double-SHA256
checksum truncated to 4 bytes. Roughly the same amount of computation power
would be required for encrypting and authenticating a peer-to-peer message with
ChaCha20 & Poly1305.
Additionally, this BIP describes a way how data manipulation (blocking or
tempering commands by an intercepting TCP/IP node) would be identifiable by the
communicating peers.
Encrypting traffic between peers is already possible with VPN, tor, stunnel,
curveCP or any other encryption mechanism on a deeper OSI level, however, most
of those solutions require significant knowhow in how to setup such a secure
channel and are therefore not widely deployed.
== Specification ==
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119[
RFC 2119].
A peer that supports the message transport protocol as defined in this proposal
MUST accept encryption requests from all peers.
Both communication direction share the same shared-secret but have different
symmetric cipher keys.
The encryption handshake MUST happen before sending any other messages to the
responding peer.
If the responding peer closes the connection after sending the handshake
request, the initiating peer MAY try to connect again with the v1 peer-to-peer
transport protocol. Such reconnects allow an attacker to "downgrade" the
encryption to plaintext communication and thus, accepting v1 connections MUST
not be done when the Bitcoin peer-to-peer network uses almost only v2
=== NODE_P2P_V2 ===
Peers supporting the transport protocol after this proposal MUST signal
NODE_P2P_V2 = (1 << 11)
A peer usually learns an address along with the expected service flags which
MAY be used to filter possible outbound peers.
A peer signaling NODE_P2P_V2 MUST accept encrypted communication
specified in this proposal.
Peers MAY only make outbound connections to peers supporting
=== Handshake ===
 ----------------------------------------------------------------------------------------
 Initiator                             Responder                                      |
                                                                                      |
 x, X         := SECP256k1_KEYGEN()                                                   |
 CLIENT_HDATA := X                                                                    |
                                                                                      |
               --- CLIENT_HDATA --->                                                  |
                                                                                      |
                                       y, Y           := SECP256k1_KEYGEN()           |
                                       ECDH_KEY       := SECP256k1_ECDH(X,y)          |
                                       SERVER_HDATA   := Y                            |
                                                                                      |
               <-- SERVER_HDATA ----                                                  |
                                                                                      |
 ECDH_KEY     := SECP256k1_ECDH(x,Y)                                                  |
 ----------------------------------------------------------------------------------------
To request encrypted communication (only possible if yet no other messages have
been sent or received), the initiating peer generates an EC secp256k1 ephemeral
key and sends the corresponding 32-byte public key to the responding peer and
waits for the remote 32-byte public key from the counterparty.
ODD secp256k1 public keys MUST be used (public keys starting with 0x02). If the
public key from the generated ephemeral key is an EVEN public key (starting
with 0x03), negating the key and recalculating its public key SHOULD be done.
Only using ODD public makes it more complex to identify the handshake based on
analyzing the traffic.
The handshake request and response message are raw 32byte payloads containing
no header, length or checksum (the pure 32byte payload) and MUST be sent before
anything else.
Public keys starting with the 4-byte network magic are forbidden and MUST lead
to locally re-generate an ephemeral-key.
Pseudocode for the ephemeral-key generation
do {
    ecdh_key.MakeNewKey();
    if (ecdh_key.GetPubKey()[0] == 3) {
        ecdh_key.Negate();
    }
} while (m_ecdh_key.GetPubKey()[0..3] == NETWORK_MAGIC);
Once a peer has received the public key from its counterparty, the shared
secret MUST be calculated by using secp256k1 ECDH.
Private keys will never be transmitted. The shared secret can only be
calculated if an attacker knows at least one private key and the counterparties
public key. This key-exchange is based on the discrete log problem and thus not
sufficiently strong against known forms of possible quantum computer
algorithms. Adding an additional quantum resistant key exchange like NewHope is
possible but out of scope for this proposal.
After a successful handshake, the messages format MUST use the "v2 messages
structure". Non-encrypted v1 messages from the initiating peer MUST lead to an
immediate connection termination.
After a successful handshake, both peers MUST cleanse the ephemeral-session-key
from memory and/or persistence storage.
A peer not supporting this proposal will not perform the described handshake
and thus send a v1 version message.
Peers supporting this BIP MAY optionally allow unencrypted v1 communication by
detecting a v1 version message by the initial 11-byte sequence of 4byte
net magic || "version".
=== Symmetric Encryption Cipher Keys ===
Once the ECDH secret (ECDH_KEY) is calculated on each side, the
symmetric encryption cipher keys MUST be derived with HKDF
[ HKDF (RFC 5869)] after the
following specification:
1. HKDF extraction
PRK = HKDF_EXTRACT(hash=SHA256, salt="BitcoinSharedSecret||INITIATOR_32BYTES_PUBKEY||RESPONDER_32BYTES_PUBKEY", ikm=ECDH_KEY).
2. Derive Key_1_A (K_1 communication direction A)
K1A = HKDF_EXPAND(prk=PRK, hash=SHA256, info="BitcoinK_1_A", L=32)
2. Derive Key_2_A (K_2 communication direction A)
K1B = HKDF_EXPAND(prk=PRK, hash=SHA256, info="BitcoinK_2_A", L=32)
3. Derive Key_1_B (K_1 communication direction B)
K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info="BitcoinK_1_B", L=32)
3. Derive Key_2_B (K_2 communication direction B)
K2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info="BitcoinK_2_B", L=32)
=== Session ID ===
Both parties MUST also calculate the 256bit session-id using SID =
HKDF_EXPAND(prk=PRK, hash=SHA256, info="BitcoinSessionID", L=32). The
session-id can be used for authenticating the encryption-session (identity
The session-id MUST be presented to the user on request.
=== ChaCha20-Poly1305 at Bitcoin Cipher Suite ===
==== Background ====
ChaCha20 is a stream cipher designed by Daniel Bernstein and described in
[ ChaCha20]. It operates
by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit nonce and a 64
bit counter into 64 bytes of output. This output is used as a keystream, with
any unused bytes simply discarded.
Poly1305 [ Poly1305], also
by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit
integrity tag given a message and a single-use 256 bit secret key.
The chacha20-poly1305 at bitcoin combines these two primitives into an
authenticated encryption mode. The construction used is based on that proposed
for TLS by Adam Langley in
[ "ChaCha20
and Poly1305 based Cipher Suites for TLS", Adam Langley], but differs in
the layout of data passed to the MAC and in the addition of encryption of the
packet lengths.
==== Detailed Construction ====
The chacha20-poly1305 at bitcoin cipher requires two 256 bits of key material as
output from the key exchange. Each key (K_1 and K_2) are used by two separate
instances of chacha20.
The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3
byte packet length field and has its own sequence number. The second instance,
keyed by K_2, is used in conjunction with poly1305 to build an AEAD
(Authenticated Encryption with Associated Data) that is used to encrypt and
authenticate the entire packet.
Two separate cipher instances are used here so as to keep the packet lengths
confidential but not create an oracle for the packet payload cipher by
decrypting and using the packet length prior to checking the MAC. By using an
independently-keyed cipher instance to encrypt the length, an active attacker
seeking to exploit the packet input handling as a decryption oracle can learn
nothing about the payload contents or its MAC (assuming key derivation,
ChaCha20 and Poly1305 are secure).
The AEAD is constructed as follows: for each packet, generate a Poly1305 key by
taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV
consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20
block counter of zero. The K_2 ChaCha20 block counter is then set to the
little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance
is used for encryption of the packet payload.
==== Packet Handling ====
When receiving a packet, the length must be decrypted first. When 3 bytes of
ciphertext length have been received, they may be decrypted.
A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21
times a 3 bytes length field (21*3 = 63). The length field sequence number can
thus be used 21 times (keystream caching).
The length field must be enc-/decrypted with the ChaCha20 keystream keyed with
K_1 defined by block counter 0, the length field sequence number in little
endian and a keystream position from 0 to 60.
Pseudo code example:
sequence_nr_payload = 0; //payload sequence number
sequence_nr_length_field = 0; //length field sequence number (will be reused)
aad_length_field_pos = 0; //position in the length field cipher instance keystream chunk
if cache_length_field_sequence_number != sequence_nr_length_field {
  cache_keystream_64_bytes = ChaCha20(key=K_1, iv=little_endian(sequence_nr_length_field), counter=0);
  cache_length_field_sequence_number = sequence_nr_length_field
packet_length = XOR_TO_LE(cache_length_field_sequence_number[aad_length_field_pos - aad_length_field_pos+3], ciphertext[0-3])
aad_length_field_pos += 3; //skip 3 bytes in keystream
if (aad_length_field_pos + 3 > 64) { //if we are outside of the 64byte keystream...
  aad_length_field_pos = 0; // reset at position 0
  sequence_nr_length_field++; // increase length field sequence number
Once the entire packet has been received, the MAC MUST be checked before
decryption. A per-packet Poly1305 key is generated as described above and the
MAC tag calculated using Poly1305 with this key over the ciphertext of the
packet length and the payload together. The calculated MAC is then compared in
constant time with the one appended to the packet and the packet decrypted
using ChaCha20 as described above (with K_2, the packet sequence number as
nonce and a starting block counter of 1).
Detection of an invalid MAC MUST lead to immediate connection termination.
To send a packet, first encode the 3 byte length and encrypt it using K_1 as
described above. Encrypt the packet payload (using K_2) and append it to the
encrypted length. Finally, calculate a MAC tag and append it.
The initiating peer MUST use K_1_A, K_2_A to encrypt messages on
the send channel, K_1_B, K_2_B MUST be used to decrypt messages on
the receive channel.
The responding peer MUST use K_1_A, K_2_A to decrypt messages on
the receive channel, K_1_B, K_2_B MUST be used to encrypt messages
on the send channel.
Optimized implementations of ChaCha20-Poly1305 at bitcoin are relatively fast in
general, therefore it is very likely that encrypted messages require not more
CPU cycles per bytes then the current unencrypted p2p message format
(ChaCha20/Poly1305 versus double SHA256).
The initial packet sequence numbers are 0.
K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for
encryption nor may it be used to encrypt more than 2^70 bytes under the same
{key, nonce}.
K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,
position-in-keystream} for encryption nor may it be used to encrypt more than
2^70 bytes under the same {key, nonce}.
We use message sequence numbers for both communication directions.
 ------------------------------------------------------------------------------------------
 Initiator                          Responder                                           |
                                                                                        |
 AEAD() = ChaCha20Poly1305Bitcoin()                                                     |
 MSG_A_CIPH = AEAD(k=K_1_A, K_2_A, payload_nonce=0, aad_nonce=0, aad_pos=0, msg)        |
                                                                                        |
                         --- MSG_CIPH --->                                              |
                                                                                        |
                                    msg   := AEAD(k=K_1_A,K_2_A, n=0, ..., MSG_A_CIPH)  |
                                                                                        |
 ------------------------------------------------------------------------------------------
==== Test Vectors ====
message   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
k1 (DATA) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
k2 (AAD)  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
AAD keystream
76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28 bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7 da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37 6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86
76 b8 e0 9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32
d2 fc 11 82 9c 1b 6c 1d f1 f5 51 cd 61 31 ff 08
message   01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
k1 (DATA) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
k2 (AAD)  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
AAD keystream
76 b8 e0 ad a0 f1 3d 90 40 5d 6a e5 53 86 bd 28 bd d2 19 b8 a0 8d ed 1a a8 36 ef cc 8b 77 0d c7 da 41 59 7c 51 57 48 8d 77 24 e0 3f b8 d8 4a 37 6a 43 b8 f4 15 18 a1 1c c3 87 b6 69 b2 ee 65 86
77 b8 e0 9f 07 e7 be 55 51 38 7a 98 ba 97 7c 73 2d 08 0d cb 0f 29 a0 48 e3 65 69 12 c6 53 3e 32
ba f0 c8 5b 6d ff 86 02 b0 6c f5 2a 6a ef c6 2e
ff 00 00 f1 95 e6 69 82 10 5f fb 64 0b b7 75 7f 57 9d a3 16 02 fc 93 ec 01 ac 56 f8 5a c3 c1 34 a4 54 7b 73 3b 46 41 30 42 c9 44 00 49 17 69 05 d3 be 59 ea 1c 53 f1 59 16 15 5c 2b e8 24 1a 38 00 8b 9a 26 bc 35 94 1e 24 44 17 7c 8a de 66 89 de 95 26 49 86 d9 58 89 fb 60 e8 46 29 c9 bd 9a 5a cb 1c c1 18 be 56 3e b9 b3 a4 a4 72 f8 2e 09 a7 e7 78 49 2b 56 2e f7 13 0e 88 df e0 31 c7 9d b9 d4 f7 c7 a8 99 15 1b 9a 47 50 32 b6 3f c3 85 24 5f e0 54 e3 dd 5a 97 a5 f5 76 fe 06 40 25 d3 ce 04 2c 56 6a b2 c5 07 b1 38 db 85 3e 3d 69 59 66 09 96 54 6c c9 c4 a6 ea fd c7 77 c0 40 d7 0e af 46 f7 6d ad 39 79 e5 c5 36 0c 33 17 16 6a 1c 89 4c 94 a3 71 87 6a 94 df 76 28 fe 4e aa f2 cc b2 7d 5a aa e0 ad 7a d0 f9 d4 b6 ad 3b 54 09 87 46 d4 52 4d 38 40 7a 6d eb 3a b7 8f ab 78 c9
k1 (DATA) 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
k2 (AAD)  ff 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
AAD keystream
c6 40 c1 71 1e 3e e9 04 ac 35 c5 7a b9 79 1c 8a 1c 40 86 03 a9 0b 77 a8 3b 54 f6 c8 44 cb 4b 06 d9 4e 7f c6 c8 00 e1 65 ac d6 61 47 e8 0e c4 5a 56 7f 6c e6 6d 05 ec 0c ae 67 9d ce eb 89 00 17
39 40 c1 e9 2d a4 58 2f f6 f9 2a 77 6a eb 14 d0 14 d3 84 ee b3 0f 66 0d ac f7 0a 14 a2 3f d3 1e 91 21 27 01 33 4e 2c e1 ac f5 19 9d c8 4f 4d 61 dd be 65 71 bc a5 af 87 4b 4c 92 26 c2 6e 65 09 95 d1 57 64 4e 18 48 b9 6e d6 c2 10 2d 54 89 a0 50 e7 1d 29 a5 a6 6e ce 11 de 5f b5 c9 55 8d 54 da 28 fe 45 b0 bc 4d b4 e5 b8 80 30 bf c4 a3 52 b4 b7 06 8e cc f6 56 ba e7 ad 6a 35 61 53 15 fc 7c 49 d4 20 03 88 d5 ec a6 7c 2e 82 2e 06 93 36 c6 9b 40 db 67 e0 f3 c8 12 09 c5 0f 32 16 a4 b8 9f b3 ae 1b 98 4b 78 51 a2 ec 6f 68 ab 12 b1 01 ab 12 0e 1e a7 31 3b b9 3b 5a 0f 71 18 5c 7f ea 01 7d db 92 76 98 61 c2 9d ba 4f bc 43 22 80 d5 df f2 1b 36 d1 c4 c7 90 12 8b 22 69 99 50 bb 18 bf 74 c4 48 cd fe 54 7d 8e d4 f6 57 d8 00 5f dc 0c d7 a0 50 c2 d4 60 50 a4 4c 43 76 35 58 58
98 1f be 8b 18 42 88 27 6e 7a 93 ea bc 89 9c 4a
=== v2 Messages Structure ===
! Field Size !! Description !! Data type !! Comments
Encrypted messages do not have the 4byte network magic.
The maximum message size is 2^23 (8?388?608) bytes. Future communication MAY
exceed this limit and thus MUST be split into different messages.
Decrypting and processing the message before the authentication succeeds (MAC
verified) MUST not be done.
The 4byte sha256 checksum is no longer required because the AEAD (MAC).
Both peers MUST keep track of the message sequence number (uint32) of sent and
received messages for building a 64-bit symmetric cipher IV.
The command field MUST start with a byte that defines the length of the ASCII
command string up to 12 chars (1 to 12) or a short command ID (see below).
==== Short Command ID ====
To save valuable bandwidth, the v2 message format supports message command
short IDs for message types with high frequency. The ID/string mapping is a
peer to peer arrangement and MAY be negotiated between the initiating and
responding peer. A peer conforming to this proposal MUST support short IDs
based on the table below and SHOULD use short command IDs for outgoing messages.
! Number !! Command
==== Length comparisons between v1 and v2 messages ====
v1 in: 4(Magic)+12(Command)+4(MessageSize)+4(Checksum)+36(Payload) == 60
v2 inv: 3(MessageSize&Flag)+1(Command)+36(Payload)+16(MAC) == 56
v1 ping: 4(Magic)+12(Command)+4(MessageSize)+4(Checksum)+8(Payload) == 32
v2 pong: 3(MessageSize&Flag)+1(Command)+8(Payload)+16(MAC) == 28
v1 block: 4(Magic)+12(Command)+4(MessageSize)+4(Checksum)+1?048?576(Payload) = 1?048?600
v2 block: 3(MessageSize&Flag)+6(CommandStr)+8(Payload)+16(MAC) == 28 = 1?048?601
=== Re-Keying ===
Re-keying can be signaled by setting the most significant bit in the length
field before encryption. A peer signaling a rekey MUST use the next key for
encryption messages AFTER the message where the signaling has been done.
A peer identifying a rekey by checking the most significant bit in the envelope
length must use the next key for decrypt messages AFTER the message where the
signaling has been detected.
The next symmetric cipher key MUST be calculated by SHA256(SHA256(session
ID || old_symmetric_cipher_key)) and the packet sequence number of the
according encryption direction must be set to 0.
Re-Keying interval is a peer policy with a minimum timespan of 10 seconds.
The Re-Keying must be done after every 1GB of data sent (recommended by RFC4253
SSH Transport) or if the last rekey was more than an hour ago.
Peers calculate the counterparty limits and MUST disconnect immediately if a
violation of the limits has been detected.
=== Risks ===
The encryption does not include an authentication scheme. This BIP does not
cover a proposal to avoid MITM attacks during the encryption initialization.
However, peers MUST show the session-id to the user on request which allows to
identify a MITM by a manual verification on a secure channel.
Optional authentication schemes may be covered by other proposals [
An attacker could delay or halt v2 protocol enforcement by providing a
reasonable amount of peers not supporting the v2 protocol.
== Compatibility ==
This proposal is backward compatible (as long as not enforced). Non-supporting
peers can still use unencrypted communications.
== Reference implementation ==
* Complete Bitcoin Core implementation: * Reference implementation of the AEAD in C: == References ==
== Acknowledgements ==
* Pieter Wuille and Gregory Maxwell for most of the ideas in this BIP.
* Tim Ruffing for the review and the hint for the enhancement of the symmetric
key derivation
== Copyright ==
This work is placed in the public domain.

@_date: 2019-03-24 20:35:45
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] New BIP - v2 peer-to-peer message transport 
Hi Dave
Thanks for the review...
One thing I was trying to avoid is some sort of central planing.
Strings as message command identifier do usually bring some sort of collision resistance when competitive implementations work on different features.
An example are the service bits where we AFAIK had an (almost) collision.
This is the main reason why I think we should avoid setting the short IDs mandatory (naturally by not giving all commands a short ID).
Short IDs do probably make most sense for messages with high frequency.
By only giving frequent messages a short ID, we may avoid ID collisions in future.
Short IDs can be altered with the message protocol version (not the transport protocol, the message protocol like 70015, etc.) and new/different negation should be straight forward.
I just ran some random stats (non representative) and inv makes about 66% of all messages (pruned peer, not helping IBDing others) followed by tx and getdata.
Those three probably deserve a short ID.
I have no big objection against adding short IDs for other commands as long as we don?t make short IDs mandatory.
Though, there are little benefits for commands like VERSION, FILTERxx, SENDHEADERS, etc.,... and, we only(?!) have 244 short IDs.

@_date: 2019-11-23 08:27:47
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] I want to rebuild the GUI in JavaScript 
This is probably the wrong place to discuss that (OT).
There is a relatively new Bitcoin Core Github issue that covers that topic [1].
AFAIK many Bitcoin Core contributors (and users?) don?t like the idea of having a Browser and JavaScript to achieve a UI with relatively simple user-stories.
I think if you want to do this, try to work on a third party project and let your Electron UI connect to Bitcoin Core over RPC.
To avoid pulling, eventually use ZMQ or help getting long polling into Bitcoin Core [2].
Adding a Electron/JavaScript UI to the Bitcoin Core repository is very unlikely to happen.
[1] [2]

@_date: 2019-10-11 17:44:54
@_author: Jonas Schnelli 
@_subject: [bitcoin-dev] Block Batch Filters for Light Clients 
Hi Aleksey
Instead of using a per tx filter, would it be possible to allow retrieving a complete compact filter of the whole mempool (similar to BIP35)? Maybe using a maximum size of the filter (ordered by feerate).
In general, I guess the concerns are DOS and fingerprinting.
Maybe DOS could be mitigated via a dynamic filter construction (append elements during the time between blocks, though unsure if possible).
The update-interval of a such filter could also be timebases rather than on every new tx in the mempool.
Unsure about fingerprinting defence measures.
I would expect the following process:
* peer generates mempool filter
* [timespan A (say 3 seconds)]
* light client connects to peer
* light client requests mempool-filter
* peers sends mempool filter
* light client processes filter for relevant txns
* eventually, light client sends getdata of relevant txns
a) after the initial retrieve...
* light client inspects all new txns (inv/getdata) received from peers from this point on (filterless unconfirmed tx detection)
Of if a) is to bandwidth expansive, request the mempool filter again after a timeout
