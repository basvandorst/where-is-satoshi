
@_date: 2014-08-10 15:42:41
@_author: mbde@bitwatch.co 
@_subject: [Bitcoin-development] Synchronization: 19.5 % orphaned blocks at 
Hello all,
I'm currently synchronizing a new node and right now, at a progress of a
height of 197'324 blocks, I count in my debug.log an aweful amount of
38'447 orphaned blocks which is about 19.5 %.
It has been I while since I watched the synchronization process closely,
but this number seems pretty high to me.
I'm wondering about the following: would it be possible for a malicious
party to generate chains of blocks with low difficulity which are not
part of the main chain to slow down the sync process?
Build and version information:
(sipa/jmcorgan address index)
Rebased with:
(almost up-to-date mainline)
Compressed debug.log attached:
(filesize: 7.67 MB, uncompressed: 41.3 MB)

@_date: 2014-07-28 04:54:23
@_author: mbde@bitwatch.co 
@_subject: [Bitcoin-development] Abnormally Large Tor node accepting only 
These website list Tor nodes by bandwidth:
And the details reveal it's a port 8333 only exit node:
blockchain.info has some records about the related IP going back to the
end of this May:
-------- Original Message  --------

@_date: 2014-10-21 01:06:36
@_author: mbde@bitwatch.co 
@_subject: [Bitcoin-development] About watch-only addresses 
This is just a guess, but I can imagine sipa's address index branch
might be more suitable for an use case where information about any
address is required - jmcorgan continued to maintain a usually somewhat
up-to-date version:
As for balance queries, that's not possible out of the box and I have my
own branch for this with a few other RPC calls that are noted in the README:
When using the original, you need to ensure a transaction is part of the
main chain and wasn't orphaned. If you consider using my branch, please
consider it twice and review the changes first.
-------- Original Message --------
*Subject: *Re: [Bitcoin-development] About watch-only addresses
*From: wtogami at gmail.com (*Warren Togami Jr.)
*To: *Bitcoin Dev *Date: *Mon, 20 Oct 2014 12:37:40 -1000

@_date: 2015-02-01 15:28:38
@_author: mbde@bitwatch.co 
@_subject: [Bitcoin-development] Proposal to address Bitcoin malware 
transactions online.  Since it's not very widely used outside of Austria and Germany, this may
be interesting for some: there is a second factor scheme called
"cardTAN" or "chipTAN" where authentication codes are generated on a
device which is not specifically linked to an accout. When
authenticating an online banking transaction the process is as follows:
1. Insert bank card into TAN generator
2. Scan flickering code on screen with the device's photodetector
3. Confirm amount to transfer and recipient on the generator
4. Finalize online banking transaction by entering a challenge-response
generated by the device
-------- Original Message --------
*Subject: *[Bitcoin-development] Proposal to address Bitcoin malware
*From: brian.erdelyi at gmail.com (*Brian Erdelyi)
*To: *bitcoin-development at lists.sourceforge.net
*Date: *Sat, 31 Jan 2015 18:15:53 -0400

@_date: 2018-01-04 10:37:42
@_author: mbde@bitwatch.co 
@_subject: [bitcoin-dev] Raise default datacarriersize to 220 byte or higher 
Hi guys,
there are several ways to embed arbitrary data into the blockchain, and
this is used by several meta-protocols. Most protocols at this point use
OP_RETURN scripts for this.
To disincentivize the use of other and more harmful methods to embed
data into the chain, in particular via P2SH, I propose to raise the
default datacarriersize to 220 byte, so it becomes the "cheapest" way of
embedding data into the chain.
The following graph shows the relation between transaction sizes and
payload sizes: Embedding data with bare-multisig and P2SH can be cheaper in terms of
effective transaction size, compared to OP_RETURN with a payload limit
of 80 byte. Both methods of embedding data, via bare-multisig and P2SH,
were heavily used by the major two meta-protocols on top of Bitcoin:
Omni and Counterparty, but both protocols started to use OP_RETRUN data
embedding a long time ago.
However, currently token sends are usually done one by one, each with a
single transaction, and this is a heavy burden for the whole network,
e.g. when an exchange sends out withdrawals.
We have solutions for "multi-sends with multi-inputs" and also
considered moving destinations into the payload for token sends, but we
need more space, otherwise this solution is limited to very few recipients.
I therefore propose to raise the default datacarriersize to 220 byte or
higher and I'd be happy to provide a pull request doing so, if this gets
positive feedback.
- dexx

@_date: 2018-01-04 20:38:23
@_author: mbde@bitwatch.co 
@_subject: [bitcoin-dev] Raise default datacarriersize to 220 byte or 
To add some information about the relevance of this:
During December 2017 there were roughly 210.000 Omni Layer transactions,
with more than 12.000 transactions on peak days, and the numbers are
I assume there is a similar number of Counterparty transactions, which
most likely benefit from additional payload space, too.
