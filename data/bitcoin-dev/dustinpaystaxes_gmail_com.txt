
@_date: 2019-08-07 14:19:05
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback 
Does revaulting vault up with the same keys, or new ones?
Are they new derivation paths on the same key?
Would love some expanded explanation on how you?re proposing this would
On Wed, Aug 7, 2019 at 1:35 PM Bryan Bishop via bitcoin-dev <

@_date: 2019-01-22 08:33:23
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains 
Wouldn?t a revealed private key for time locked funds create a race to
spend? I imagine miners who are paying attention would have the advantage
but it would still just be a race.
Would be nice to have the funds destroyed or sent somewhere specific. Like
if somehow the revealed key was actually itself a presigned transaction. Or
perhaps a 32 byte piece of a tx needed to complete it.
On Tue, Jan 22, 2019 at 6:14 AM ZmnSCPxj via bitcoin-dev <

@_date: 2019-01-22 12:03:06
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Proof-of-Stake Bitcoin Sidechains 
How could you prove the private key is in the burning transaction?
On Tue, Jan 22, 2019 at 11:56 AM Satoshin via bitcoin-dev <

@_date: 2019-07-22 08:15:49
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
Has someone built an analysis of how much extra bandwidth CFB uses over
bloom filters?
Obviously an active merchant in an impoverished country paying data rates
per MB will never be able to afford CFB ? so those people are being cut out
of Bitcoin entirely. I suppose the plan is they will rely on custodial
services now?
But if someone receives say, 5 tx a day, how much more bandwidth precisely
will CFB require over bloom?
On Mon, Jul 22, 2019 at 8:10 AM Tom Harding via bitcoin-dev <

@_date: 2019-03-05 20:00:35
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Removal of reject network messages from Bitcoin 
The reject message is helpful for figuring out why a tx was rejected.
It?s not useful for determining success, yes. Particularly when doing
segwit / newer types of tx?s as there?s always one or more pesky nodes who
still don?t support it and send a reject message for perfectly good tx?s.
But after a delay where you haven?t seen your tx propagated on the network,
it?s useful to know *why* it failed.
What would be nice is actually expanding this error message. Currently with
RBF tx?s ?fee too small? is sent for both original transactions as well as
replacement transactions. So a bug accidentally sending spent txos
(currently in mempool) says ?fee too small? instead of something more
appropriate like ?fee too small to supersede existing unconfirmed
On Tue, Mar 5, 2019 at 7:26 PM Marco Falke via bitcoin-dev <

@_date: 2019-03-10 11:28:25
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] OP_CODESEPARATOR Re: BIP Proposal: The Great 
What about putting it in a deprecated state for some time. Adjust the
transaction weight so using the op code is more expensive (10x, 20x?) and
get the word out that it will be removed in the future.
You could even have nodes send a reject code with the message
?OP_CODESEPARATOR is depcrecated.?
On Sun, Mar 10, 2019 at 7:55 AM LORD HIS EXCELLENCY JAMES HRMH via

@_date: 2019-03-13 15:30:44
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Removal of reject network messages from Bitcoin 
I?ve solved the same problem in a different way.
1) Submit a transaction
2) Collect all reject messages (that have matching txid in the reject data)
3) Wait 16 seconds after first error message received (chosen semirandomly
from trial and error) before processing errors
4) Wait for our txid to be submitted back to us through the mempool, if we
get it notify success and delete all pending error events
5) Signal failure with the given reject code if present (after the 16
seconds have elapsed)
6) If no error or success after 20 seconds, signal timeout failure
This works fairly well in testing. Newer transaction types seem to generate
reject codes 100% of the time (from at least one node when sending to 4
nodes) so this culling / time delay approach is essentially required.
On a related note: One issue is that RBF attempts with too small a fee and
accidental double spends (with enough fee for 1 tx but not a RBF) both
generate the same reject code: not enough fee.
A new reject code for RBF based too small of fee would definitely make for
a better user experience as I?ve seen this exact problem create confusion
for users.
Removing reject codes would make for a much worse user experience. ?Your tx
failed and we have no idea why? would be the only message and it would
require waiting for a full timeout.
On Wed, Mar 13, 2019 at 3:16 PM Oscar Guindzberg via bitcoin-dev <

@_date: 2020-03-02 11:45:02
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Nonce blinding protocol for hardware wallets and 
+1 love that progress is being made on this. Excited to implement it once
it?s ready.
Would love if things like the incrementing number were included in the
standard as well.
Cheers! ?
On Fri, Feb 28, 2020 at 9:51 AM Marko via bitcoin-dev <

@_date: 2020-03-02 12:01:51
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Nonce blinding protocol for hardware wallets and 
Stepan have you spent any time considering a scheme that could involve HD
keys, preregistering n (ie. 1000) preimages, or something similar to reduce
the number of rounds at time of signing?
Would a zero knowledge solution allow for a reduction in rounds?
On Wed, Feb 26, 2020 at 7:13 PM Stepan Snigirev via bitcoin-dev <

@_date: 2020-03-23 07:38:45
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques 
Excellent write up, thanks for putting it together.
While all SW being compromised can?t be stopped, splitting the SW over two
stages can dramatically increase your security if both HW & SW are
compromised. You can do that by:
1) When you setup your storage solution (whatever it may be), export the
xpub(s) and verify the receiving addresses match xpubs with external
software before receiving.
2) Generate and export withdrawal transactions offline
3) Verify transactions against the same xpub(s) using external software
4) Upload transactions
This mitigates, I believe, all leak vectors besides k/R hacking and
prechosen entropy.
I made an external tool to just that here:
Would love to add k commitments when (if?) we settle on best practices for

@_date: 2020-03-24 07:51:32
@_author: Dustin Dettmer 
@_subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques 
Hi Tim,
Hm, so what vectors is this supposed to mitigate? Leaking through the
The main thing it?s protecting against is the stealing of your funds by
malicious hardware & software. There are some side benefits as well though.
 - What are you trying to achieve? You seem to describe how you get
?Storage solution? is however you?re storing bitcoins today. Could be 12
words on some paper plus a computer running electrum. Could be a Ledger +
computer. Point is this technique works regardless of how you?re storing
your bitcoin.
 - "all SW being compromised" do you mean "SW and HW compromised"? Note
Yeah ? if you split the SW party into two, ?generator? and ?validator? some
interesting and useful security properties emerge.
 - Where are the two stages? You mention four steps.
?Generator? and ?validator?. The generator creates and passes on receiving
addresses and withdrawal transactions (while remaining offline). The
validator double checks everything the generator did..
It works best if the validator is written entirely independently of the
 - Where do you run the external software? On a second SW? Is this the
 - Do you use unhardened derivation?
It?s an open ended solution ? it would work with a (presumably
non-trivial/random) unhardened derivation just fine.
 - What's a k commitment?
It is one of the proposed solutions presented (collected?) by Peter in this
thread. As I understand it k is used to generate R in the signature. By
committing to some k value the hardware wallet can?t ?sneak out? your
private key(s) in the R value.
