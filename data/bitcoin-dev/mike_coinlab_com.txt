
@_date: 2012-04-03 16:37:01
@_author: Mike Koss 
@_subject: [Bitcoin-development] Signature Blocks and URI Sign Requests 
Alan, I'm coming in late to the conversation - do I understand that BIP 010
does not propose any changes to the protocol - but just an intermediate
data format that other clients might use to collect the need key material
to sign a multi-signature block?
If so - one might ask what the role of BIP's are if they actually do not
impact the protocol?
If there is any encapsulated data format that is expected to be interpreted
by clients - I'd call that a "protocol change"; but I take it in this
instance that you will transmit these signature block out of band from the
client ... yet they would have to be parsed and converted into a
Transaction Script once collected by SOME client?  Would we expect the
standard client do so?
Sorry if this has been discussed before - I'm trying to understand the

@_date: 2012-12-03 11:35:13
@_author: Mike Koss 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
The thing that bugged me most about the original spec was the sole reliance
on X.509 - glad to see you've made that optional.  I think many people will
balk at deferring our identity trust to the existing CA's.  I think it's a
fine bootstrap method, but I'd really like to see another option that
allows for out-of-band trust (based on ECDSA, probably).
It would also be really nice to migrate to textual representations of data
structures as opposed to binary ones.  The most successful internet
standards are based on text, making them that much more accessible for
developers to deal with them.   JSON would be my preferred candidate.
Why don't we sign the text representation of a (utf8) JSON, rather than
some complex encoding standard of JSON?  That way the signatures are simple
- and you need only retain the original textual representation of a message
to validate the signature (as well as the decoded version, if you don't
want to alway re-parse the message when writing programs that use it).

@_date: 2012-12-04 19:06:00
@_author: Mike Koss 
@_subject: [Bitcoin-development] String-based Hierarchical Deterministic Keys 
I've implemented an alternative to the BIP 32 proposal.  I wanted a system
based on a hierarchical string representation (rather than hierarchy of
integers as BIP 32 proposes).  For example I name keys like this:
[hd1.75491111].store.1. 1D7GM5dkUtxvGeWgn7SYtanBuyj1MD1EZy
[hd1.75491111].store.2. 1QAqDbzpNKViGSjVe1XmnGbmZtvz5hM7t1
[hd1.75491111].store.3. 14XkSN92QLGeorYPpoVbG87DQhowEx3mFn
[hd1.75491111].store.4. 1JLcGdod6Wm33rMZuZZUmAEE6osLhM4QMn
First draft of proposal:
I envision using this in services, so I've not done any work to recommend
how the keys would be represented directly in the client (I just map from a
seed value and
a hierarchy string in order to deterministic ally derive ECDSA public and
private keys).
I'm happy to release my source code for this (Python).  But I'd first like
to get feedback about any security concerns with my scheme (I note that I
don't introduce the enlarged
key space that BIP 32 does with its "chain code" - I'm wondering if that
represents a weakness of my scheme vs. BIP 32).

@_date: 2012-06-04 13:49:48
@_author: Mike Koss 
@_subject: [Bitcoin-development] Defeating the block withholding attack 
As I understand the attack, the attacker gets compensated for the shares
they earn, but the pool will be denied any valid blocks found.  The
attacker DOES NOT have access to the Bitcoins earned in the unreported
block (only the mining pool has access to the Coinbase address and
transactions in the block).
So it's a zero-net-cost attack for the attacker (but no chance of making a
profit) to hurt the pool operator.  The only way to detect such an attack
now is to look for "unlucky" miners; at the current difficulty, you can't
detect this cheat until many millions of shares have been earned w/o a
qualifying block.  Since an attacker can also create many fake identities,
they can avoid detection indefinitely by abandoning each account after a
million earned shares.
I don't understand your proposal for fixing this.  You would have to come
up with a scheme where:
- The miner can detect a qualifying hash to earn a share.
- Not be able to tell if the hash is for a valid block.
The way I would do this is to have a secret part (not shared with the
miners) of a block that is part of the merkle hash, which is also used in a
secondary hash.  Difficulty is then divide into two parts: the first,
solved by the miner (earning a "share" - e.g., 1 in 4 Billion hashes).  And
a second, solved by the pool (1 in Difficulty shares).  A valid block would
have to exhibit a valid Share Hash AND a valid Pool Hash in order to be
This would be a very major change to the Block structure.  Given that
attackers do not have direct monetary gain from this attack, I'm not sure
we can justify it at this point.

@_date: 2012-06-04 17:00:25
@_author: Mike Koss 
@_subject: [Bitcoin-development] Defeating the block withholding attack 
I don't understand how your proposal will work for decentralized pools -
can you explain it more concretely?
What would the new block header look like?
What is required for a share to to be earned?
What is required for a block to be valid (added to Block Chain)?
I don't think I understand what you mean by NextBlockCandidate.  Perhaps a
concrete example using difficulty 1.7 million would be instructive.

@_date: 2012-06-15 10:37:04
@_author: Mike Koss 
@_subject: [Bitcoin-development] Near-term scalability 
Grouping mempool transactions based on fees of the group seems
an unnecessary complexity; it makes it harder to predict if an isolated
transaction has enough "juice" to be included in the next Block.
Given your point about economic actors adapting to conditions, would it not
be simpler to use a individual "fee per byte" priority algorithm and let
transaction generators distribute their fees accordingly (and more
This simpler algorithm will prune arbitrary transactions sub-optimally, but
has the benefit of being more understandable and predictable from the point
of view of transaction generators.

@_date: 2012-06-21 14:42:58
@_author: Mike Koss 
@_subject: [Bitcoin-development] Ultimate Blockchain Compression w/ 
Are we just talking about pruning the spent transactions from an old block?
 We already have a data structure that allows us to replace any un-needed
transaction by just it's hash - and possibly a whole sub-tree if we get
lucky in that the un-needed transaction all fall within a common node of
the merkle tree.
If a lite client only cares to retain a single transaction in a block (the
most common case) - it will only need O(log2(T)) merkle hashes plus the
transaction it cares about.
Does it really make sense to adopt a more complex data-structure than the
merkle tree for inclusing in the bticoin protocol?  And we're not talking
about blocks with millions of transactions in them - I don't understand the
relevance of Order statistics for random access to a transaction given its
