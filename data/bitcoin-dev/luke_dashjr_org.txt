
@_date: 2011-08-04 10:38:44
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Blitcoin? (Black Hat 2011) 
Well, that certainly doesn't sound like a security vulnerability at all.
It's by design that everyone knows about every transaction.

@_date: 2011-08-04 16:29:01
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
Reminder these are still ready for merging...
Jeff, you seem to have rewritten *part of* bugfix_CreateThread_leak and neglected to attribute the original author (as my branch did/does).

@_date: 2011-08-04 16:42:01
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
My apologies. BlueMatt showed me how my comment here was wrong.
Hopefully I'll remember how GitHub shows merges like this in the future.

@_date: 2011-08-04 23:01:47
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
Yes. I'm not sure it has any practical impact on the software, but there was what looks like a platform-specific compile fix (casting between potentially incompatible types) too.

@_date: 2011-08-10 14:43:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Change to multiple executables? 
It seems there's room for some kind of "experimental" branch as well, including features that might not make it into any stable release (due to lack of use/interest or whatever).

@_date: 2011-08-12 12:19:50
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [PULL] When parsing base58 data, 
git fetch git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git \
 base58_liberal_parsing && git merge FETCH_HEAD
This simple modification allows base58 inputs to use zero and uppercase 'O' in place of lowercase 'O', as well as lowercase 'L', bar/pipe, and exclamation point in place of one. This allows more tolerance when inputting addresses or other data by manual typing, and gives a bit more variety to vanity addresses.

@_date: 2011-08-12 12:43:22
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [PULL] When parsing base58 data, 
Updated variable name in branch...
Perhaps the vanity use would need to be introduced only after the community has accepted these as alternative legitimate representations. Even without that, I think gracefully handling the typos would be sensible.

@_date: 2011-08-19 12:48:33
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [PATCH] Boost filesystem v3 support 
This patch conditionally adapts the one line needed to support boost filesystem version 3 (default in Boost 1.46+ and required for 1.48+)
I have tested it with Boost 1.41.0 to verify it still works on these older versions too.

@_date: 2011-08-22 15:49:36
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Introduction 
He said standard *coding and implementation paradigms*. This has nothing to do with integration with some non-standard "init replacement" that goes against the whole design of Unix.
What I understand this to mean, is properly abstracting the components such that the node, wallet, and GUI can work together while being distinct parts.
In this sense, Fred, you may be interested in working on coming up with a standard for a

@_date: 2011-08-24 12:15:34
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New standard transaction types: time to 
If a block chain split is to occur, it makes sense to try to fix as many problems as possible:
- Replace hard limits (like 1 MB maximum block size) with something that can
  dynamically adapt with the times. Maybe based on difficulty so it can't be
  gamed?
- Adjust difficulty every block, without limits, based on a N-block sliding
  window. I think this would solve the issue when the hashrate drops
  overnight, but maybe also add a block time limit, or perhaps include the
  "current block" in the difficulty calculation?
- 21 million really isn't enough if Bitcoin ever takes off, even with
  100,000,000 units per BTC. Replacing the "Satoshi" 64-bit integers with
  "Satoshi" variable-size fractions (ie, infinite numerator + denominator)
  would create infinite possibilities of future divison, allowing people to
  not only do nBTC and pBTC, but also exact 1/3 of any quantity. Transaction
  size would go up based on the number of primes involved in an amount, which   would encourage discarding annoying primes in transaction fees.
- Standardize everything on network (big) endian.
I'm sure others can think of other chain-splitting fixes that wouldn't be too much work to fix.

@_date: 2011-08-24 12:26:20
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New standard transaction types: time to 
- Access to the block height it's part of. While this can be abused,
  transactions accessing it can be given a big red flag in the GUI or
  something. Legitimate uses include "Clearcoin" functionality in the script
  itself.
- Remove the 100 confirmation requirement for spending generated coins. If
  they are respent before 100 confirmations, clients can/should flag the new
  outputs as also "generated" or "recently generated" so recipients are aware
  of the risk. It would be especially handy for pool operators if blocks could
  contain a transaction spending one of the same block's generation in
  addition to other non-generated coins, and specifying the full amount as a
  fee to safely add coins to the generation. Right now, if I were to embed a
  25 BTC fee-only transaction, there is a risk that Deepbit could grab that
  transaction for their own, and fork. By making pool payouts all generated,
  there is no risk to paying invalid blocks instantly (since if the block is
  invalid, so is the payout made in it).

@_date: 2011-08-24 13:03:45
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New standard transaction types: time to 
Dynamically adapting would be by design never too early/late. Changing from a fixed 1 MB will fork the block chain, which should be a minimized event.
Depends on the implementation, I'd think.
So? You can already have redundant transactions simply by changing the order of inputs/outputs. A good client would minimize the transaction size by reducing them, of course.
I already tried to address this in my original mail. If I had those 4 coins, I would use a denominator of 987 and discard the difference as fees.

@_date: 2011-08-24 15:21:02
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [PATCH] Boost filesystem v3 support 
It's only one line, and can be removed when the old APIs are sufficiently

@_date: 2011-08-29 16:15:47
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Project status 
Can we get some form of the signmessage method in?

@_date: 2011-12-02 16:02:35
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Overview of pullreqs for 0.6 
ACK'd for 0.6:
585   Added Caps Lock detection to askpassphrasedialog.
569   Coinbaser
669   Multisignature and OP_EVAL support
629   QR Code generation via libqrencode
582   Bitcoin-Qt signmessage GUI
*** All of the above are available merged in my personal 'next' branch:
***     Possibly good for 0.6:
454   Add -keepnode which attempts to -addnode and keep a connection open
570   Specify fees explicitly via JSON-RPC
673   Store fewer time samples
649   Compressed pubkeys
593   Full URL Support in bitcoin-qt
*** All of the above are available merged in my personal 'next-test' branch:
***     Needs more review/support:
427   IPv6 support (lots of complicated conflicts merging)
568   Multithreaded JSON-RPC with HTTP 1.1 Keep-Alive support
565   FastGetWork optimization
555   SIGUSR1 new block notifications
415   advanced anonymity features: send from address(es), view address
      linkages, view all addresses
358   Address Book related Fixes

@_date: 2011-12-04 09:22:11
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Closing issues on github 
I think it would be ideal if someone wanted to take up wxBitcoin. Maybe after backporting to wx 2.8...
That being said, I have no interest, as I hate wx, and prefer Qt in general ;)
Please be careful to avoid the centralization mindset. There is no "main project"; there is bitcoind, wxBitcoin, Bitcoin-Qt, MultiBit, and many other non-functional clients, which should be given equal footing (before considering their differences). There shouldn't be given any special treatment to bitcoind and Bitcoin-Qt just because "Gavin et al" happen to maintain it.
KDE literally just closed a bug of mine that I reported in 2002, because the component with the bug hasn't been part of KDE since 2008.

@_date: 2011-12-06 16:10:39
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version bytes "2.0" 
sipa made a nice specification for version numbers a while back, that seemed great at the time. However, there are concerns that it has overlooked a very important factor: usability in base58 encoding. The version currently chosen for script-based addresses (2) makes this excessively complicated for end users-- these addresses, once encoded, may begin with ANY of the following characters: 2opqrstuvwxyz
Taking this into account, as well as sipa's original goals, I have come up with the following proposal:
* Bits 128/64 define network class
** 0 = main network
** 64,128 = reserved
** 192 = test network
* Bits 32/16 define network
** 0 = Bitcoin
** 16,32 = reserved
** 48 = OTHER (next octet)
* Bits 8/4/2 define data class
** 0 = Public key hash
** 2 = Public key (raw)
** 4 = Script hash
** 6 = reserved
** 8 = Private key (raw)
** 10 = Signature
** 12 = reserved
** 14 = OTHER (next octet)
* Bit 1 is freely chosen (for aesthetic assignment)
Unlike sipa's proposal, however, I have (intentionally) neglected to consider the versions currently in use other than the widespread Bitcoin addresses. That means this reassigns the versions used by Namecoin and testnets, and probably messes with the (unmerged) key export format and signature formats.
It "wastes" 2 bits (64 and 1) to accomplish aesthetic norms. Bit 64 *could* be assigned in the future if we ever have a "crunch". By using the high bit (128) to designate test networks, all testnet addresses will now begin with '2'. Bitcoin script-hash (aka OP_EVAL) addresses are assigned version 5 (using the aesthetic +1), which means they always begin with '3'. Signatures are on version 10 and/or 11, beginning with '5'.
We get two first-class "networks" besides Bitcoin, addresses starting with '7' and 'E' (pubkey), and '9' and 'F' (script). I propose these should be assigned sparingly, only when a network has significant adoption-- the only one I would even *consider* might fit the requirement today is Namecoin. I would also suggest making merged mining support a requirement except for networks that have a proven-better proof-of-work (ie, NOT scrypt). Other networks can use the "other" value (thus beginning with 'L' and 'N') and a second octet (which can be divided up later).

@_date: 2011-12-06 16:28:16
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version bytes "2.0" 
Some bugs I found in my spec so far:
- Bitcoin public keys begin with '2' (same as testnet data)
- For the first first-class "aux" network, signatures and private keys will
  start with the same character.
- More "collisions" are possible if the "reserved" values were ever assigned.
To address these slightly better, here's a revised proposal:
* Bits 128/64 define network class
** 0 = main network
** 64,128 = reserved
** 192 = test network
* Bits 32/16 define network
** 0 = Bitcoin
** 16,32 = reserved
** 48 = OTHER (next octet)
* Bits 8/4/2 define data class
** 0 = Public key hash
** 2 = reserved
** 4 = Script hash
** 6 = Public key (raw)
** 8 = Signature
** 10 = reserved
** 12 = Private key (raw)
** 14 = OTHER (next octet)
* Bit 1 is freely chosen (for aesthetic assignment)
Note that under this scheme, both script hashes and raw public keys begin with '3'; I consider this a non-issue since neither are supported by current-
generation clients, and both pubkey-hash and script-hash are quite capable of the same functionality as a raw public key. Also, the raw public key will presumably be noticably longer.
For reference, a table of version number to first-base58-char mappings:
+........   0 => 1
-.......1   1 => QRSTUVWXYZabcdefghijkmno
-......1.   2 => 2opqrstuvwxyz
+......11   3 => 2
-.....1..   4 => 23
+.....1.1   5 => 3
+.....11.   6 => 3
-.....111   7 => 34
+....1...   8 => 4
-....1..1   9 => 45
+....1.1.  10 => 5
+....1.11  11 => 5
-....11..  12 => 56
+....11.1  13 => 6
-....111.  14 => 67
+....1111  15 => 7
+...1....  16 => 7
-...1...1  17 => 78
+...1..1.  18 => 8
-...1..11  19 => 89
+...1.1..  20 => 9
+...1.1.1  21 => 9
-...1.11.  22 => 9A
+...1.111  23 => A
-...11...  24 => AB
+...11..1  25 => B
+...11.1.  26 => B
-...11.11  27 => BC
+...111..  28 => C
-...111.1  29 => CD
+...1111.  30 => D
+...11111  31 => D
-..1.....  32 => DE
+..1....1  33 => E
-..1...1.  34 => EF
+..1...11  35 => F
+..1..1..  36 => F
-..1..1.1  37 => FG
+..1..11.  38 => G
-..1..111  39 => GH
+..1.1...  40 => H
+..1.1..1  41 => H
-..1.1.1.  42 => HJ
+..1.1.11  43 => J
-..1.11..  44 => JK
+..1.11.1  45 => K
+..1.111.  46 => K
-..1.1111  47 => KL
+..11....  48 => L
-..11...1  49 => LM
+..11..1.  50 => M
+..11..11  51 => M
-..11.1..  52 => MN
+..11.1.1  53 => N
-..11.11.  54 => NP
+..11.111  55 => P
+..111...  56 => P
-..111..1  57 => PQ
+..111.1.  58 => Q
-..111.11  59 => QR
+..1111..  60 => R
+..1111.1  61 => R
-..11111.  62 => RS
+..111111  63 => S
-.1......  64 => ST
+.1.....1  65 => T
+.1....1.  66 => T
-.1....11  67 => TU
+.1...1..  68 => U
-.1...1.1  69 => UV
+.1...11.  70 => V
+.1...111  71 => V
-.1..1...  72 => VW
+.1..1..1  73 => W
-.1..1.1.  74 => WX
+.1..1.11  75 => X
+.1..11..  76 => X
-.1..11.1  77 => XY
+.1..111.  78 => Y
-.1..1111  79 => YZ
+.1.1....  80 => Z
+.1.1...1  81 => Z
-.1.1..1.  82 => Za
+.1.1..11  83 => a
-.1.1.1..  84 => ab
+.1.1.1.1  85 => b
-.1.1.11.  86 => bc
+.1.1.111  87 => c
+.1.11...  88 => c
-.1.11..1  89 => cd
+.1.11.1.  90 => d
-.1.11.11  91 => de
+.1.111..  92 => e
+.1.111.1  93 => e
-.1.1111.  94 => ef
+.1.11111  95 => f
-.11.....  96 => fg
+.11....1  97 => g
+.11...1.  98 => g
-.11...11  99 => gh
+.11..1.. 100 => h
-.11..1.1 101 => hi
+.11..11. 102 => i
+.11..111 103 => i
-.11.1... 104 => ij
+.11.1..1 105 => j
-.11.1.1. 106 => jk
+.11.1.11 107 => k
+.11.11.. 108 => k
-.11.11.1 109 => km
+.11.111. 110 => m
-.11.1111 111 => mn
+.111.... 112 => n
+.111...1 113 => n
-.111..1. 114 => no
+.111..11 115 => o
-.111.1.. 116 => op
+.111.1.1 117 => p
+.111.11. 118 => p
-.111.111 119 => pq
+.1111... 120 => q
-.1111..1 121 => qr
+.1111.1. 122 => r
+.1111.11 123 => r
-.11111.. 124 => rs
+.11111.1 125 => s
-.111111. 126 => st
+.1111111 127 => t
+1....... 128 => t
-1......1 129 => tu
+1.....1. 130 => u
-1.....11 131 => uv
+1....1.. 132 => v
+1....1.1 133 => v
-1....11. 134 => vw
+1....111 135 => w
-1...1... 136 => wx
+1...1..1 137 => x
+1...1.1. 138 => x
-1...1.11 139 => xy
+1...11.. 140 => y
-1...11.1 141 => yz
+1...111. 142 => z
+1...1111 143 => z
-1..1.... 144 => 2z
+1..1...1 145 => 2
+1..1..1. 146 => 2
+1..1..11 147 => 2
+1..1.1.. 148 => 2
+1..1.1.1 149 => 2
+1..1.11. 150 => 2
+1..1.111 151 => 2
+1..11... 152 => 2
+1..11..1 153 => 2
+1..11.1. 154 => 2
+1..11.11 155 => 2
+1..111.. 156 => 2
+1..111.1 157 => 2
+1..1111. 158 => 2
+1..11111 159 => 2
+1.1..... 160 => 2
+1.1....1 161 => 2
+1.1...1. 162 => 2
+1.1...11 163 => 2
+1.1..1.. 164 => 2
+1.1..1.1 165 => 2
+1.1..11. 166 => 2
+1.1..111 167 => 2
+1.1.1... 168 => 2
+1.1.1..1 169 => 2
+1.1.1.1. 170 => 2
+1.1.1.11 171 => 2
+1.1.11.. 172 => 2
+1.1.11.1 173 => 2
+1.1.111. 174 => 2
+1.1.1111 175 => 2
+1.11.... 176 => 2
+1.11...1 177 => 2
+1.11..1. 178 => 2
+1.11..11 179 => 2
+1.11.1.. 180 => 2
+1.11.1.1 181 => 2
+1.11.11. 182 => 2
+1.11.111 183 => 2
+1.111... 184 => 2
+1.111..1 185 => 2
+1.111.1. 186 => 2
+1.111.11 187 => 2
+1.1111.. 188 => 2
+1.1111.1 189 => 2
+1.11111. 190 => 2
+1.111111 191 => 2
+11...... 192 => 2
+11.....1 193 => 2
+11....1. 194 => 2
+11....11 195 => 2
+11...1.. 196 => 2
+11...1.1 197 => 2
+11...11. 198 => 2
+11...111 199 => 2
+11..1... 200 => 2
+11..1..1 201 => 2
+11..1.1. 202 => 2
+11..1.11 203 => 2
+11..11.. 204 => 2
+11..11.1 205 => 2
+11..111. 206 => 2
+11..1111 207 => 2
+11.1.... 208 => 2
+11.1...1 209 => 2
+11.1..1. 210 => 2
+11.1..11 211 => 2
+11.1.1.. 212 => 2
+11.1.1.1 213 => 2
+11.1.11. 214 => 2
+11.1.111 215 => 2
+11.11... 216 => 2
+11.11..1 217 => 2
+11.11.1. 218 => 2
+11.11.11 219 => 2
+11.111.. 220 => 2
+11.111.1 221 => 2
+11.1111. 222 => 2
+11.11111 223 => 2
+111..... 224 => 2
+111....1 225 => 2
+111...1. 226 => 2
+111...11 227 => 2
+111..1.. 228 => 2
+111..1.1 229 => 2
+111..11. 230 => 2
+111..111 231 => 2
+111.1... 232 => 2
+111.1..1 233 => 2
+111.1.1. 234 => 2
+111.1.11 235 => 2
+111.11.. 236 => 2
+111.11.1 237 => 2
+111.111. 238 => 2
+111.1111 239 => 2
+1111.... 240 => 2
+1111...1 241 => 2
+1111..1. 242 => 2
+1111..11 243 => 2
+1111.1.. 244 => 2
+1111.1.1 245 => 2
+1111.11. 246 => 2
+1111.111 247 => 2
+11111... 248 => 2
+11111..1 249 => 2
+11111.1. 250 => 2
+11111.11 251 => 2
+111111.. 252 => 2
+111111.1 253 => 2
+1111111. 254 => 2
+11111111 255 => 2

@_date: 2011-12-10 13:16:30
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version bytes "2.0" 
This should make it compatible with Namecoin addresses...
Here's a revised proposal:
* Bits 128/64 define network class
** 0 = main network
** 64,128 = reserved
** 192 = test network
* Bits 32/16 define network
** 0 = Bitcoin
** 16 = reserved
** 32 = OTHER (next octet)
** 48 = Namecoin
The rest is left up to the network to decide; for Bitcoin, it is:
* Bits 8/4/2 define data class
** 0 = Public key hash
** 2 = reserved
** 4 = Script hash
** 6 = Public key (raw)
** 8 = Signature
** 10 = reserved
** 12 = Private key (raw)
** 14 = OTHER (next octet)
* Bit 1 is freely chosen (for aesthetic assignment)

@_date: 2011-12-12 16:02:11
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version bytes "2.0" 
Or both: use this proposal for 20-byte base58 for now, and overhaul it in the future (maybe when the block chain forks?).
Looks good here.
These are 32-byte, so have no reason IMO to follow the 20-byte proposal.
Since a lot of services are already using version 128 ('5') for bitcoin private keys, and 128 is "reserved" in the 20-byte proposal, I think it's fair to leave it alone (for now).

@_date: 2011-12-12 17:32:40
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
FirstBits looks nice at glance, but is bound to create a gold-rush to grab every nice-looking FirstBits address.
HTTPS is only as secure as the (centralized) CAs, thus not really any better than TXT records.
I don't think an address of some form is avoidable.

@_date: 2011-12-12 18:41:38
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
This has the same problem as FirstBits, except .bit domains are dirt cheap, whereas vanitygen at least slows down grabbing all the common words...

@_date: 2011-12-13 10:43:18
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version bytes "2.0" 
Bitcoin-Qt 0.6 will include a QR Code generator.
No, not really. I've found that dragging and dropping links manages to corrupt them most of the time.

@_date: 2011-12-13 10:47:42
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Fwd: [BIP 15] Aliases 
Seems like introducing a gaping security risk to me.
Could always use a fixed address and email somebody at foo.com a signed message.

@_date: 2011-12-14 18:27:34
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Fwd: [BIP 15] Aliases 
Don't confuse BTC (Bitcoin unit) with BC (Bitcoin in general / protocol)...
The hard part of using DNS will be sticking to the standard good practice of using a new address for every transaction.

@_date: 2011-12-17 01:32:22
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Pubkey addresses 
IMO, we should standardize and support public key addresses. While not ideal for humans, because of their length, it's a better fit for large QR Codes IMO.

@_date: 2011-12-17 16:52:19
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Pubkey addresses 
I propose that full public key addresses be required to be "compact" (length 33), and use version 21 (begins with '4', and is redundant with ver 20 for 20-
byte data). Any reason this wouldn't be workable?

@_date: 2011-12-17 19:28:12
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Pubkey addresses 
I missed that bit. I'm willing to defer full OP_EVAL support on Eligius in order to enable key recovery...

@_date: 2011-12-17 19:39:32
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Pubkey addresses 
In fact, as long as we have this opportunity to enable new opcodes, maybe we should spend some time revisiting what doors that opens...

@_date: 2011-12-18 09:03:33
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Pubkey addresses 
"Green addresses" are also a broken-by-design feature and should be

@_date: 2011-12-18 09:34:37
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Pubkey addresses 
Yes, just like is already done for generation, since it is more efficient *overall* for the block chain. sipa's key extraction is a MUCH better solution, however, so if we can get that without a block chain fork, I'm inclined to favour it.

@_date: 2011-12-18 16:44:43
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
How are you going to authenticate the host? Certificates from CAs are how HTTPS does it. HTTP is vulnerable. If the URI contains an address (eg, bitcoin://remotehost/base58key), the remote host could sign its (self-signed) SSL key with the ECDSA key to prove authenticity. DNSSEC/namecoin presumably has some way to do this as well.
At some point, a proper protocol to negotiate payment is needed for anything like this.

@_date: 2011-12-18 20:13:57
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
The point of the extended URI is to allow the server to negotiate payment details (payment/order information, fees, new privacy address, etc) rather than merely sending a simple payment to a single fixed address.
I am not convinced *aliases* are practical, without CA trust. An organization that wants to trust a CA with all their funds can leave off the address portion, to provide more human-friendly URIs.

@_date: 2011-12-18 20:43:47
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
Like SSH, don't make it easy to ignore.
eg, to ignore it, you need to manually go in and remove it from the URI.

@_date: 2011-12-19 11:30:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
I'd prefer we stick to simple standards.
HTTP alone should really be fine to build on...
JSON in particular has very poor language support, and cannot reasonably represent binary data (such as a custom output script). The HTTP specification, however, allows binary data in multipart content just fine.

@_date: 2011-12-19 11:35:32
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
Accepted CAs is/should be a property of your *operating system*, not any particular software. Anyhow, restricting this further just makes it even more unusable. Already there is only 1 or 2 CAs that will provide a gratis certificate for personal/small users. If you only allow high-class CAs, I imagine that will restrict "no key in the URI" aliases to those who will fork over a lot of money.

@_date: 2011-12-19 13:15:24
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
Sure, I meant HTTP as the underlying protocol.
TLS/SSL should of course be required in some form.
JSON-RPC won't go on forever. In any case, bitcoind's use of JSON-RPC is exactly why I (and many other developers) have come to the realization how poorly supported JSON really is. Most of the common languages do have a library, but almost all of them have one issue or another (particularly around the very undefined Number type).
XML shares the same binary-data problem as JSON, too.
As slush mentioned, no additional serialization is necessary anyway.
Because computers work with binary. I don't think anyone wants to implement a fully functional script assembler just to send funds.
This suggests you need to learn more about how Bitcoin works ;)

@_date: 2011-12-19 14:16:54
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [BIP 15] Aliases 
Bitcoin is a binary system. Not all payment outputs are necessarily serializable into addresses, and assuming they are would be broken-by-design.
In other words, why send the user's *software* "pay to address foo" just to have it turn that into a script (of limited subset), when you can send the script itself and avoid all the possible problems? Doing this right also means that if the user's client doesn't support version 255 addresses, it still works fine.
JSON isn't problem-free at high-level either. To summarize one of the issues, almost every implementation of JSON treats Numbers differently based on whether they have a '.' in them or not.
MIME has been around much longer, and should have sufficient support in every language by now. For some reason, Python calls the module 'email'.

@_date: 2011-12-19 17:36:44
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Lying about User Agent (was: BIP language on 
To clarify, I believe LYING about the client is a violation. Specifically, Gavin's commit intentionally reports "bitcoin-qt" for bitcoind. A common name for the codebase is compliant, and I don't see anything that says a version *must* be reported at all, let alone for a specific component, so it *could* comply by leaving that part off. But if there is a common part, it certainly isn't Bitcoin-Qt.
 contains a fix that should fulfil everyone's desires (Gavin wants security by obscurity by making bitcoind and Bitcoin-Qt indistinguishable; this is the default with pull

@_date: 2011-12-20 20:46:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Changes for version 0.6 are being pulled 
I've rebuilt my 'next' and 'next-test' branches...
    git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git
Accepted for 0.6:
* 81807c3 Merge branch 'coinbaser' into next
* 6ea6db3 Merge remote branch 'laanwj/ui_copy_amount' into next
* a6ef83e Merge 'QR Code generation via libqrencode' into next
* e0673bd Merge branch 'signmessage_gui' into next
Ready for acceptance?
* 4783528 Merge remote branch 'matt/keepnode' into next-test
* 5a11d0f Merge branch 'force_send' into next-test
* 2cddc71 Merge remote branch 'sipa/comprpubkey' into next-test
* 73a8ca6 Merge remote branch 'matt/uri' into next-test
* 9314427 Merge remote branch 'gavin/testnetdifficulty' into next-test
* 1360e43 Merge branch 'stdint' into next-test
Needs review:
* 6ee82ff Merge branch 'forceresendtx' into next-test
* 8a82ba6 Merge branch 'blknotify' into next-test
* 674f1a6 Merge 'Temporarily disable "minimize to tray" in the startup phase
          if the "-min" option is specified' into next-test
* 5afd4de Merge branch 'bugfix_client_name' into next-test
Cannot be merged cleanly (at least not into next-test at this point):
* Pull 556 txinfo
* Pull 568 JSON-RPC multithreading + rpc_keepalive
* Pull 457 IPv6 JSON-RPC
* Pull 427 IPv6
* Pull 565 optimize_FastGetWork
* Pull 430 joelkatz optimizations
* Pull 562 optimize_ToHex
* Pull 452 JSON-RPC API versioning
Not yet written:
* Treat generation (almost) like normal receive
* JSON-RPC with integer amounts

@_date: 2011-12-21 10:44:53
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Changes for version 0.6 are being pulled 
Not sure what you mean. Maybe `git log --no-merges` ?

@_date: 2011-12-21 11:45:42
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Changes for version 0.6 are being pulled 
And here's yet another update, this time with a total of 21 branches merged. Anyone want to make binaries to get these branches some wider testing?
Accepted for 0.6:
* 81807c3 (pull 719) Coinbaser
* 6ea6db3 (pull 683) Context menu updates for TransactionView and...
* a6ef83e (pull 629) QR Code generation via libqrencode
* e0673bd (pull 582) Bitcoin-Qt signmessage GUI
Ready for acceptance?
* 4783528 (pull 454) Add -keepnode which attempts to -addnode and keep a...
* 5a11d0f (pull 570) Specify fees explicitly via JSON-RPC
* 2cddc71 (pull 649) Compressed pubkeys
* 73a8ca6 (pull 593) Full URL Support in bitcoin-qt
* 27a2460 (pull 721) 'getmininginfo' method
* e57ccf4 (pull 686) Testnet difficulty calculation changes, to take effect...
* 5b4a18d (pull 720) Use standard C99 (and Qt) types for 64-bit integers
Needs review:
* c7ee97d (pull 421) added option -forceresendtx
* cff2c28 (pull 714) Execute a command when best block changes...
* 3ca784f (pull 691) Temporarily disable "minimize to tray" in the startup...
* 59842f5 (pull 568) Multithreaded JSON-RPC with HTTP 1.1 Keep-Alive support
* d08e8fd (pull 565) FastGetWork optimization
* 0dc52ac (pull 715) Bugfix: comply with BIP 0014 ...
* f88dddc (pull 559) -acceptnonstdtxn option to skip "non-standard...
* 95d3e7e (pull 552) Typo-tolerant (optimized) Base58 parser
* 45beffe (pull 553) Parse URIs with non-BTC amounts
* 74439a5 (pull 562) Optimized binary-to-hex converter (ToHex)
Cannot be merged cleanly (at least not into next-test at this point):
*         (pull 430) joelkatz optimizations
*         (pull 452) JSON-RPC API versioning
*         (pull 457) IPv6 JSON-RPC
*         (pull 427) IPv6
Not yet written:
*                    Treat generation (almost) like normal receive
*                    JSON-RPC with integer amounts

@_date: 2011-12-21 12:14:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Changes for version 0.6 are being pulled 
It was per Gavin on IRC before yesterday. And there is already buy-in from other miners.

@_date: 2011-12-21 12:37:39
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Changes for version 0.6 are being pulled 
[Friday, December 02, 2011] [1:57:14 PM]  luke-jr: ok-- there seems to be general consensus to pull coinbaser for 0.6, so I'll probably pull it before op_eval and rework the op_eval code to use coinbaser.
At least Eclipse (235 GH/s) is using it, and slush (1.3 TH/s) intends to.

@_date: 2011-12-29 12:06:42
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Alternative to OP_EVAL 
So what? Why shouldn't I be able to run random code? I could always put that random code in the script verbatim, after all.

@_date: 2011-07-01 14:59:34
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
"Native Long Polling Support" should be renamed. Real native long polling would be for solo miners.
"A fix from Luke Dash Jr." -- I have a branch with this; I didn't check that his version is up to date.
"RPC Turbocharge" -- If this incorporates only my changes for multithreading, it breaks JSON-RPC over SSL.

@_date: 2011-07-02 10:50:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Reconsider build system change? 
I don't really care much either way, but cmake doesn't follow the standard build procedure (./configure && make && make install), though I imagine ./configure could be emulated with some script.

@_date: 2011-07-02 12:55:52
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Reconsider build system change? 
And --datadir --mandir --randomobscurecrap CXXFLAGS=-O9, etc
Don't forget --help listing all the useful options... that's the big thing I miss with CMake-stuff.

@_date: 2011-07-02 14:12:18
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Reconsider build system change? 
puddinpop's stuff is all ancient/obsolete. If you want people to consider it, you should probably make a new branch.

@_date: 2011-07-04 14:20:07
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Encrypted Wallet Backward Compatibility 
It shouldn't. Backup scripts should make a copy with the JSON-RPC call.
What about changing the format of wallet.dat to something that triggers an error in the old clients? ie, maybe a dummy crafted-to-make-old-versions-
complain file that simply means "use ewallet.dat"?

@_date: 2011-07-10 14:42:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
There seems to be a new version at:
I haven't compared them yet.
For the "3diff" version, I extracted and made proper git branches for each logical part:
  hub_mode
  threaded_rpc
  \-- rpc_keepalive (depends on threaded_rpc, or a single connection would
                     keep the JSON-RPC interface locked up)
  signal_blk_notify (generic version of -pollpidfile, with a bugfix)
  bugfix_CreateThread_leak
  getwork_dedupe (original branch for my bugfix)
In addition, I also consider these branches valid candidates for merging:
  coinbaser (popens a given command and reads coinbase outputs from stdout)
  gitignore (ignore some common misc files)
  minfee_modes (internal function changes to allow specifying different fees
                for relay, send, or accept-in-block)
  \-- eligius_relay (relay lower fees only Eligius will accept)
      \-- eligius_sendfee (send lower fees only Eligius will accept)
  txinfo (adds entries to getinfo for transactions accepted for relaying,
          transactions accepted for the current block-in-progress, and current
          block-in-progress size)
  bitcoinuri (compliant support for all bitcoin: URIs)
All available from git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git

@_date: 2011-07-10 16:30:53
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Useful bitcoin patches... 
I just said it exists. I don't expect anyone to promote or merge it.
I suspect because they haven't figured out how. Take it or leave it.
This is a step in that direction, at least, by providing the mode as input.
Since 0.4 is moving to Qt, perhaps moving GetMinFee to QtScript is Again, take it or leave it, but in the meantime you're asking for trouble from users who feel they're being forced to pay more than they have to. Or perhaps rather than trouble, that decision will increase awareness of other clients that don't try to control the users. That could be good too.

@_date: 2011-07-10 22:01:51
@_author: Luke-Jr 
@_subject: [Bitcoin-development] overall bitcoin client code quality 
Because it's a good tool for the job? Or you mean the version?
Debian stable: 4.8
Gentoo stable: 4.8
Ubuntu LTS   : 4.8
Boost is pretty much standard C++ nowadays.
Blame your text editor if it can't show long lines sanely. The only problem I see with the style itself is the use of spaces instead of tabs.
There are many rewrites in progress, often with much better designs.
Bitcoin is supposed to be an authorityless project. There is no official.
Fix it yourself and submit the changes. If they don't get merged, fork.

@_date: 2011-07-13 14:37:57
@_author: Luke-Jr 
@_subject: [Bitcoin-development] overall bitcoin client code quality 
This isn't an arbitrary constant, it's the result of a calculation...

@_date: 2011-07-14 22:50:42
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Wallet encryption migration 
Just wanted to get these suggestions out here:
1. Write over the old, unencrypted wallet.dat a couple of times with pseudo-
   random data in an attempt to secure-delete it.
2. Mark all the keys imported from an unencrypted file (wallet or otherwise)
   as "potentially compromised" and never use them for new addresses
   (basically, don't use the old keypool for getnewaddress, change, and such).

@_date: 2011-07-16 13:14:11
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [RFC] listtransactions reformatting 
Example patch: * Additions to your wallet always are category:"receive", no matter what kind
  of transaction
* Generated coins have an extra key, from:"generation"
* All transactions have a new key, status:
  * "orphan" -- Another block chain invalidated this transaction (only for
                generation?)
  * "validating" -- Default stage for transactions; 0-2 confirmations for
                    ordinary sends, and 0-100 for generated coins
  * "processing" -- 3-6 confirms for ordinary sends; 101-120 for generated
  * "confirmed" -- over 6/120 confirmations
  * "expired" -- for ordinary sends that have timed out without getting into a
                 block, or had its inputs otherwise respent
This change is proposed to fix webservices being ignorant of generated transactions by keeping a standard category/format for all similar types of

@_date: 2011-07-16 16:03:06
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [RFC] listtransactions reformatting 
It is also very broken, which is why I took the time to come up with something workable when I needed it ;)
"move" is positive amount, but doesn't change the actual value in the wallet.

@_date: 2011-07-17 08:30:50
@_author: Luke-Jr 
@_subject: [Bitcoin-development] The forums... 
The "Satoshi Client" doesn't really have a formal name yet.
Don't confuse an implementation with the network itself.

@_date: 2011-07-26 00:22:21
@_author: Luke-Jr 
@_subject: [Bitcoin-development] bitcoin DNS addresses 
1. Right now you practically need a unique Bitcoin address per transaction.
2. DNSSEC is on the edge of becoming illegal in the US.
3. Emails aren't merely domains.
I would propose something like resolving foo at bar.net to a SRV lookup for _bitcoinaddressresolution._tcp.foo.bar.net, expecting a cert for bar.net, making a HTTPS request for /bitcoinaddressresolution?foo at bar.net, and also sending an email to foo at bar.net (the usual way) signed with the keys used for the transaction. ;)

@_date: 2011-07-26 02:18:56
@_author: Luke-Jr 
@_subject: [Bitcoin-development] bitcoin DNS addresses 
Admittedly, my proposal to email a signed message allows one to reuse addresses, but there is still a privacy concern.
I only meant that foo.bar.net is not the same formatting.
foo at bar.net would be.

@_date: 2011-07-27 10:28:24
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Seeking advice: Encouraging bug-fixing 
I'm not sure a few small bounties would justify agreeing to GitHub's steep demand for potentially unlimited money in their terms of service...

@_date: 2011-07-28 01:56:50
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Bitcoin components. 
I put the page together a while ago with logical segregation of the current Bitcoin concept. wxBitcoin originally implemented the entire thing as one big blob. Miners got moved out first. Spesmilo took the next step of separating out a GUI. Wallet and node are currently tightly tied together in bitcoind, though it can function as only one of the two just as well. So in practice, it is fully possible to run it like that, but I'm not aware of any de facto use Generally, nodes need to make outbound connections too, at least to get The miner can really get by with just an address from the wallet--
it needs somewhere to put its generated coins ;)
You can run a system-wide bitcoind (or equivalent) to handle p2p connectivity, and have each user run a dedicated wallet bitcoind (with the -connect option) with a unique JSON-RPC port (for Spesmilo) or wx GUI. I don't think there is any automated setup for this kind of arrangement. I personally foresee the p2p being implemented on a SOHO router as the end goal (or even better--

@_date: 2011-07-28 15:08:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Forking personal "vanity" versions... 
You'll get that error even with the headers installed, because the makefile doesn't add the proper include paths to GCC.
To build, I first: sed -i s/static/dynamic/ makefile.unix # because static libraries aren't standard on my OS (nor should they be)
Then: make -f makefile.unix DEBUGFLAGS="-I/usr/include/db4.8 -ggdb -O0" \
      -j4 USE_UPNP=1 bitcoind

@_date: 2011-06-16 13:12:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Development priorities 
I'd put wallet security before scaling, but inevitably, I'm not sure there's too much anyone can do about that. Even if the wallet is encrypted, it just takes a little more complex code to steal funds if you've infected your

@_date: 2011-06-16 14:18:46
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Development priorities 
Even if you do this, a cracker can still simply send your encrypted wallet to himself, secure-delete your local one, kill your client, and demand you publish your password if you want some portion of your coins back.
I'm not sure there's *any* defense for an insecure PC. Maybe Bitcoin will end up forcing people to reconsider their priorities when it comes to security...

@_date: 2011-06-17 09:29:54
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Roadmap for autotools / Qt gui merge 
I'm not sure the Wallet protocol implementation needs to touch the GUI code at all, except when porting the GUI to use it. Therefore, if the code is already written, I don't see any harm in merging it.

@_date: 2011-06-17 16:37:07
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Roadmap for autotools / Qt gui merge 
So long as we can get a solid name for it. Obviously I can't continue to call it wxBitcoin if it's strictly Qt...

@_date: 2011-06-18 21:37:26
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Roadmap for autotools / Qt gui merge 
Before this gets merged, I'd like to check: does it work ok if Qt is built without glib support?

@_date: 2011-06-28 02:57:20
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Fwd: Live mtgox.com trade matching bug. 
MtGox's code is just as related as BitcoinJ or any other Bitcoin software,

@_date: 2011-11-02 18:46:22
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Lock protocol version numbers 
What is "Satoshi 0.5" anyway? 0.5's server is bitcoind and GUI is Bitcoin-Qt; the wx GUI client is gone, which is more or less what "Satoshi" referred to in the past...

@_date: 2011-11-02 19:07:45
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Lock protocol version numbers 
My point is that the "Satoshi client" was the wxWidgets client, which was retired by 0.5.

@_date: 2011-11-05 12:29:15
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Lock protocol version numbers 
This can be necessary in some cases. What happens when some popular client is found with a subtle bug, and cannot otherwise be differentiated from other similar-functionality clients? I have found User-Agent very valuable when dealing with the wide variety of miner bugs when I have enabled new functionality/behaviour on Eligius.

@_date: 2011-11-07 10:27:57
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Difficulty adjustment / time issues 
Reminder that there is *already* a short interval only allowed for blocks in

@_date: 2011-11-15 19:54:57
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Icon licenses 
As you noticed, we replaced most of the icons with license issues in
Bitcoin-Qt... but I intentionally did NOT replace the ones you created, assuming you would be willing to relicense them under the MIT (or similar) license. Could you commit a license change for these icons, ideally before 0.5.0 final, please?

@_date: 2011-11-21 20:11:46
@_author: Luke-Jr 
@_subject: [Bitcoin-development] State of Bitcoin Development: November 
Not prioritizing some unannounced "release schedule" over getting bugs fixed before making the release is another part of the answer, at least.

@_date: 2011-10-03 01:32:19
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Supermajority mining votes for 
Perhaps as a safeguard:
(3) Before applying the new rule, require 50% of the last Y blocks contain a
    coinbase with a "I am upgraded" code
(4) Until the new rule is active, include an "I am upgraded" code in every
    block; after it's active, this can be turned off
Why would legitimate community members ever intentionally transmit an invalid transaction? ;)

@_date: 2011-10-03 16:17:52
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [PULLs] 6 branches 
These branches are ready for merging to mainline.
Branches can be viewed at:
    git pull git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git minfee_modes: minor internal API change as a step toward allowing
              user-customizable fee schedules
qmake_system_crypto++: allow building bitcoin-qt against system crypto++
    This is worthless if the crypto++ dependency is removed.
sharedlibs: build bitcoind against shared libraries on 'unix'
    Not sure why it's been static for so long, but most systems only have
    shared libs.
signal_blk_notify: -blknotifypidfile option to send SIGUSR1 to a PID when
                   there's a new best block
    Used by basically every pool now, it just sends SIGUSR1 to a poolserver.
bugfix_qt_uri_amount_parser: fix URI amount parser to accept exponents and
                             hexadecimals
    Please don't bother arguing over bugfix_qt_uri_amount_parser. It'll just
    be a waste of time. Neither the pro- nor anti- sides have budged over
    multiple arguments already. I can't force you guys to merge it, but I can
    at least make it easy if you decide to tolerate it. Just keep in mind that
    it doesn't hurt the BTC-only URIs at all, and if nobody ends up using it
    for other units, it can always be removed later.
        Best  case scenario: people use it and bitcoin-qt works correctly
        Worst case scenario: people don't use it, and it can be removed
base58_liberal_parsing: accept typos in base58 data
    The same best/worst case scenario logic as the URI parser applies
    to base58_liberal_parsing too, so long as typos aren't advertised as
    legitimate addresses.

@_date: 2011-10-04 01:06:17
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [PULLs] 6 *more* branches 
These branches are ready for merging to mainline. Note that these are not the same ones I sent earlier today, but part of a larger batch I have just finished rebasing.
Branches can be viewed at:
    git pull git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git coinbaser: allow customizing what addresses are paid by generation, with
           failover to the standard "50 BTC to me" behaviour; also adds the
           "setworkaux" JSON-RPC call to add arbitrary data to the coinbase,
           which can be used to implement merged-mining (has safeguards
           against creating invalid coinbases)
    Eligius has tested this quite a bit under the 0.3.23 codebase.
txinfo: adds "pooledtx" (number of transactions in memory pool),
        "currentblocktx" (number of txns in the last block created), and
        "currentblocksize" to the output of the JSON-RPC 'getinfo' method;
        adds "block_hash" and "block_index" to transactions shown by
        'listtransactions' and similar JSON-RPC methods
    Been using this since 0.3.21 without issues.
force_send: disables automatically adding "minimum" fees for JSON-RPC
            methods-- instead, it returns an error or, iff the user sets the
            new second parameter "force" to the 'settxfee' JSON-RPC call,
            sends the transaction with the user-specified fee
    This only affects JSON-RPC users, who should be assumed to understand the
    risk of sending with insufficient fees.
eligius_relay: relay transactions that satisfy Eligius's minimum fee when it's
               lower than the default rules
eligius_sendfee: allow sending the lower fee between default and Eligius, and
                 adds relay.eligius.st to the DNS seed list
    Merge or not, up to you guys... I don't really care.
bugfix_CreateThread_ThreadSocketHandler_errReporting: report an error in
                                                      debug.log

@_date: 2011-10-04 01:15:09
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [RFCs] 13 new branches 
These branches are NOT ready for merging to mainline, but need peer review.
Branches can be viewed at:
    git pull git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git my_free_txn: accept the user's own transactions regardless of fees or
             standardness; put credits-to-user toward covering fees required
    Common-sense, really.
accept_nonstdtxn: adds a -acceptnonstdtxn option to allow miners to easily
                  accept "non-standard" transactions
    We probably want to amend this with a block for OP_NOP*?
free_relay: relay transactions regardless of fees
optimize_cache_rpcauth: cache RPC username and password
    Part of JoelKatz's diffN patches for a while, seems fairly well-tested on
    (other) pools
optimize_conn_adjtime: cache AdjustedTime around a for loop
    Another part of JoelKatz's diff4 patch.
optimize_ToHex: faster binary-to-hexadecimal-string function
optimize_DecodeBase64: faster base64 decoding
optimize_remove_CheckWork_delay: remove 2 second delay from CheckWork
    I don't know why this is here, but apparently most pools work fine without
    it? (from JoelKatz)
optimize_FastGetWork: optimizations for the common case of getwork
    Yet another JoelKatz patch. His patch has it bundled tightly with the
    ToHex branch, so once one is merged, the other will need rebasing.
optimize_http_status: use C instead of C++ for HTTP status reply strings
rpcclient_conn_close: "Connection: close" header in client mode
threaded_rpc: use a new thread for each JSON-RPC connection, with mutexes
              preventing actual methods from being executed concurrently
              (except for parts of getwork)
    Tested on Eligius from day 1, under older versions. A few months ago, the
    code was merged with some of JoelKatz's patch, making it stable with SSL
    support.
rpc_keepalive: support for HTTP 1.1 keep-alive
    Depends on threaded_rpc.

@_date: 2011-10-08 19:12:31
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Help wanted: translations 
Please at least get Coinbaser merged for 0.5. It has had a lot of testing on Eligius for months, a landslide of support for the new JSON-RPC method (as requested), and I have even gone to the effort to document it. As I will no longer be using bitcoind for Eligius soon, I have little incentive to maintain/rebase coinbaser across a 0.6 development period.

@_date: 2011-10-10 00:02:38
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Help wanted: translations 
FWIW, Gavin's IRC response more or less amounts to being unwilling to merge this even though it was ready, tested, and even fulfilled his original request for community support for the new JSON-RPC call, all long before he announced the feature freeze on 0.5... hopefully it'll get merged to 0.6 git before it needs a rebase. :/

@_date: 2011-10-10 09:05:56
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Help wanted: translations 
Writing some custom software designed to more efficiently create work.
To clarify, bitcoind will still serve the purpose of peering with external nodes and picking out valid transactions to be accepted into blocks; it just won't be involved in the primary operations of the pool.

@_date: 2011-10-10 10:11:48
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Help wanted: translations 
Yes, does that already. Hard part right now is implementing a stateless TCP/IP "stack" so it can ignore DDoS sanely.

@_date: 2011-10-10 14:30:45
@_author: Luke-Jr 
@_subject: [Bitcoin-development]  Please help test 0.4.1 release candidate 1 
Reposting from the forums:
  Following Gavin tagging 0.5rc1, I have tagged the stable git tree "v0.4.1rc1". If you are able, please compile and help test.
See the doc/build-*.txt files in the source tree for instructions on compiling. Binary releases for at least unix and mac will be available only if someone steps up to the task.
There are no major changes from version 0.4.0, only bugfixes.
None of the features from 0.5 are supported, only those in 0.4.
Run: git shortlog --no-merges v0.4.0..
... to get a complete list of changes, and thanks to everybody who is

@_date: 2011-10-13 09:38:32
@_author: Luke-Jr 
@_subject: [Bitcoin-development] State of Bitcoin Development: October 
Once again, this does not fix anything (they're already strict enough for the 2-week window), and just creates new problems.
Flawed concept. Only even potentially useful for extreme cases (ie, a miner intentionally making lots of 1 MB blocks of junk).

@_date: 2011-10-14 03:10:26
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Please help test 0.5 release candidate 1 
Since you guys probably won't notice otherwise...
Got some 0.5 binaries here:

@_date: 2011-10-28 19:56:01
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.5 release updated 
This is an Ubuntu issue. Can't gitian use something else?
Better would be a GUI=0/1 option to the bitcoin-qt.pro until a nicer (ideally automake/autoconf) system is implemented...

@_date: 2011-09-03 11:27:40
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Last try: Fixes for 0.4 
Once more before I just give up on trying...
These branches fix bugs still remaining in 0.4rc1:
- bugfix_getwork_newblk_race
- getwork_dedupe
- boost_fs3
- gitignore
Additionally, this branch adds a tolerance to human error typing in base58 with ambiguous symbols, and should be very safe to merge:
- base58_liberal_parsing
Again, these can all be merged with:
# git fetch git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git \
#            && git merge FETCH_HEAD

@_date: 2011-09-05 08:42:22
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.4rc1 known bugs 
Yes, the default is "UPnP supported, disabled by default" (USE_UPNP=0), not "UPnP not supported" (USE_UPNP=). This is documented in build-unix.txt ...

@_date: 2011-09-06 16:55:27
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.4rc1 known bugs 
Got a fix for the encrypted-wallet mining issue:
- unique_coinbase
It depends on (and merges) the getwork_dedupe fix already common on pools and other miners who pay attention to the latest mining fixes.
To merge:
  git fetch git://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin.git \
    unique_coinbase && git merge FETCH_HEAD

@_date: 2011-09-08 13:15:09
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Alert System 
In fact, I think the alert system should relay (note, NOT display) messages *regardless of the key used*, so it isn't yet another "our client gets special status" thing, and can be used for other clients as well.

@_date: 2011-09-08 15:45:35
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Alert System 
I don't seem to recall this ever happening, despite Deepbit having over 50% multiple times now.

@_date: 2011-09-09 02:57:03
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.3.23+patches bug: JSON-RPC leaves sockets 
On Eligius, I have two bitcoinds running on the same system:
- a hub node, which is dedicated to relaying network activity between the
  hundreds of nodes Eligius peers with
- a work node, which is dedicated to managing mining, and only ever connects
  to the hub node
Lately, the hub node has been dying (yet to determine cause; I haven't changed anything recently), leaving the work node with no connections. The work node, of course, starts responding to getworks with "not connected" messages. Strangely enough, the sockets used for these are never cleaned up properly, and eventually overflow the system's socket limits.
I am using a very heavily patched 0.3.23, so this bug could be related to one of those patches (perhaps the threaded JSON-RPC?), but I felt like I should mention it somewhere else just in case before 0.4 final got released. I have not tried to reproduce it on an unpatched bitcoind yet, and am extremely busy lately so I might not get a chance before you guys finish 0.4.

@_date: 2011-09-13 12:40:23
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Project status 
More important in this area, IMO, is support for deterministic keychains in wallets. Type 2, according to gmaxwell's original spec, seems pretty ideal, and significantly improves security for many use cases. Since it allows a wallet to contain a public keychain without the matching private keychain, webservers, POS, and other services can be provisioned only with the keychain required to generate/access infinite public keys, and without the private keyroot needed to spend them.
The ideal scenario in this regard, as I see it, is this:
- Webserver wallets are provisioned with multiple public keychains (one per webserver), and configured to use a specific one for getnewaddress/etc. By provisioning them with *all* the public keychains, their listtransactions/etc can see the transactions sent to other webservers, necessary to show confirmations to the end user and such.
- Business keeps a locked-down *offline* wallet with the private keychains for all the forementioned public keychains. Only this wallet has the information required to spend the income. The wallet is encrypted, and can only be accessed by staff with the proper position/authority to authorize expenses.
- A third wallet is used by staff to prepare expense transactions. It keeps track of locking coins it knows are in the process of being spent, and any staff member can create new ones. Once created, they must submit the transaction to a staff member with the proper authority to bring it to the offline transaction-signing wallet (on a USB key), where it is signed, and returned to this third wallet.
Another feature that needs some attention is signmessage. It can be used to send a transaction id/summary to a specified email address signed by the sending key of the same transaction (these can be added to the send-money GUI). This would allow merchants to publish a single payment address and still be able to verify which customers sent payment.

@_date: 2011-09-13 12:48:29
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Difficulty adjustment / time issues 
This is not currently reasonable. Rolling extranonce is not efficient, and using it to generate work for 400+ GH/s worth of miners every new block (longpoll) can easily take seconds. Noncerange helps a little, but has poor support presently, and still requires an otherwise-unique work per 4 GH/s.
That only leaves pools with the time header to play with. Furthermore, within-
a-minute accuracy basically forces all miners to rollntime-- I'm not against this result, but it does mean many miners and pools will be left out in the Miners already have very limited area to mess around with block times.
My understanding of these attacks is that they somehow bypass the limitations in place.

@_date: 2011-09-13 12:53:40
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Project status 
I didn't recommend storing private keys on NAND. The USB stick would contain only the transaction that it being approved, and the offline-signing-wallet would sign it. The USB stick then contains only the signed transaction to be returned to an online node. At no time does it contain keys.

@_date: 2011-09-14 11:43:20
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Difficulty adjustment / time issues 
And those hours of wiggle-room are not enough to cause a problem.
The problem only comes in (AFAIK) when the existing rules are *not* enforced.
As this is against pools/miners' interests, and doesn't seem to solve any real problems, I'm going to discourage its adoption if it ever gets done.

@_date: 2011-09-14 19:01:54
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Difficulty adjustment / time issues 
I don't support this, unless all other chain-forking-needed changes are made at the same time. I do point out that changing the time rules *does not help*.
The rest don't generate rewards immediately as the same block being mined. They either eat the loss of invalid blocks, or wait for 100+ confirmations before paying. Also, restricting the time rules basically breaks miners without rollntime support (such as Phoenix).

@_date: 2011-09-14 22:06:37
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Request review: drop misbehaving peers 
"Non-standard" transactions, or those with "insufficient" fees should not be penalised. These are properly relay/miner policy decisions, not protocol violations, and should be made more easily configurable, not punished for

@_date: 2011-09-15 11:36:44
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Request review: drop misbehaving peers 
No. There is no such thing as "non-standard transactions" really; it is simply "transactions outside of the bounds that I as a user/miner will relay/accept". It is perfectly legitimate for other users/miners to relay/accept transactions more liberally. By penalising for transactions falling outside of your *personal policies*, you would end up banning many legitimate nodes.

@_date: 2011-09-15 13:29:16
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Request review: drop misbehaving peers 
That would make sense if you knew the node was originating them, MAYBE--
but not given the fact that they may merely be relaying transactions.

@_date: 2011-09-18 19:30:56
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.4.x stable branch 
Gavin, Jeff, et al:
A group of developers would be interested in maintaining 0.4 into the future as a stable branch (ie, bugfixes only). Would you be willing to plan on making the next mainline version after 0.4, being called 0.5, so we can release 0.4.1, 0.4.2, etc? If we prepare the git repository + tags, would you guys be willing to make the actual release builds + source, and/or post such on the websites you administrate?
Luke and various others in

@_date: 2011-09-19 11:00:54
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.4.x stable branch 
The problem with the current development model is that bugfixes are done alongside improvements, and code changes *always* have the potential to introduce new bugs, no matter how careful anyone is. So to stay on top of bugfixes right now implies risking new bugs being introduced. What good is getting one bug fixed, if it comes with 20 new yet-to-be-discovered bugs?
For example, 0.3.20.2 was the last version if bitcoind before people started experiencing random (albeit rare) deadlocks. However, there have been many bugfixes since then. Since there is no stable branch, someone who wishes to get those bugfixes is forced to either create their own stable branch from scratch, or risk getting all the new bugs introduced in the latest version (most of which are unknown at this time).
On the other hand, a stable 0.4.x branch can provide people with upgrades which they know make only the minimal changes required to fix bugs with a much smaller risk of new bugs being introduced (not only are there fewer changes, but bugfixes tend to also be less invasive changes). While there are arguably still various "must-have" features missing from 0.4, having a stable branch also allows people to maintain a stable+ branch with greater ease too.

@_date: 2011-09-22 16:11:16
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Bitcoin-qt ready for merging 
Various issues with bitcoin-qt's qmake build system still...
Regressions remaining on bitcoin-qt branch:
- Building without DBus still tries to use dbus symbols (and fails linking)
- No way to disable SSL support for JSON-RPC
- UPnP is no longer built/enabled by default
These weren't quite working in the old makefiles either, but it was a lot
easier to workaround with DEBUGFLAGS:
- No way to specify include path or library names for bdb and boost
  (won't build, since bdb C++ includes aren't default on many OS)
- No way to build with out-of-tree/system cryptopp or json

@_date: 2011-09-23 19:21:58
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Beyond IP transactions: towards a bitcoin 
Email and XMPP are suitable. Just sign the message with the "from" key.
False. Deterministic keypairs remove the necessity of bidirectional communication. A standard for a "public key root" "address" could be Both of these combined retain pseudonomity, while providing stateless transactions with out-of-band data.

@_date: 2011-09-26 15:17:09
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Newly introduced DoS 
+        return DoS(10, error("AcceptToMemoryPool() : transaction with out-of-
bounds SigOpCount"));
+                        return DoS(10, error("ConnectInputs() : tried to spend coinbase at depth %d", pindexBlock->nHeight - pindex->nHeight));
+        return DoS(10, error("AcceptBlock() : prev block not found"));
These shouldn't be "DoS"'d, or else you open a new DoS when nodes legitimately relay such transactions/blocks.

@_date: 2011-09-26 15:18:35
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Miscommitted version 
* 6b8a5ab Bump version to 0.4.1
This should be some pre-0.5.0, not 0.4.1 which will be the stable team's first

@_date: 2011-09-26 16:55:57
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Newly introduced DoS 
The first one I was referring to is a *transaction* with "non-standard" sig op count, which is AFAIK allowed in blocks, just not accepted by the mainline rules. In the second case, that transaction is not tied to a specific block. Maybe the person spending it sees it matured beyond 100 confirmations, and you only see 99. An attacker could use these things to get nodes to ban each

@_date: 2011-09-26 17:53:23
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Newly introduced DoS 
It's not future. It's presently allowed in blocks. Which means it's perfectly valid to relay (and also perfectly value to NOT relay or accept). Ergo, shouldn't be punished.
Um, no? It implies you have 99 blocks since the coinbase, and he has 100 and wants to spend. In this scenario, it's proper to reject his transaction *until you have the next block*, but it doesn't make sense to punish for it.

@_date: 2011-09-27 16:08:05
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Newly introduced DoS 
What about this one?
 -1276,13 +1278,13  bool CBlock::AcceptBlock()
     // Get prev block index
     map::iterator mi =      if (mi == mapBlockIndex.end())
-        return error("AcceptBlock() : prev block not found");
+        return DoS(10, error("AcceptBlock() : prev block not found"));
Is it certain that it cannot be triggered by a peer having some huge number more blocks than you?

@_date: 2011-09-27 23:53:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Miscommitted version 
I'm aware of that.
Ok. That's not usually how versions work, though. Gavin also recently stated that the next version after 0.4.0 was to be 0.5, which is why the commit was a surprise. I'm just trying to clarify what version number to use for stable, and getting apparently mixed answers.

@_date: 2011-09-27 23:54:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Deprecating "midstate" in getwork? 
I tested removing midstate myself, and found at least one miner (cpuminer IIRC) requires it.

@_date: 2012-04-02 20:44:37
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Signature Blocks and URI Sign Requests 
IMO, the sign-request URI should be an extension on the existing bitcoin: URI scheme; this way, sigNeeded can be omitted to imply "sign with a sending

@_date: 2012-04-03 14:55:40
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Signature Blocks and URI Sign Requests 
I wonder if it's possible to make sigs compatible with PGP/EC ?

@_date: 2012-04-11 11:42:45
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 31 
I thought we were going with 60001 for the protocol version bump?

@_date: 2012-08-02 17:17:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version 0.7 release planning 
Based on pull-capable dev comments, I've personally noted these branches as accepted for 0.7:
+ m) getmemorypool: longpolling support
+ luke-jr + m) Refactor transaction/accounting time
+ luke-jr I also personally feel these are appropriate and ready for 0.7:
+ m) Treat generation (mined) transactions less different from receive
+ transactions
+ luke-jr Also these, but they need testing:
+ m) Bitcoin-Qt (Windows only): enable DEP for bitcoin-qt.exe
+ diapolo I also feel it is very important that Wumpus/laanwj decide on a name for his client (formerly known as Bitcoin-Qt) and add it to the software instead of simply claiming it is "Bitcoin" as it has for a week or so now - that change is anticompetitive and will confuse new users into thinking Bitcoin is the software too easily.

@_date: 2012-08-11 18:05:07
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version 0.7 release planning 
Bitcoin-Qt even delays showing generation until 2 confirms.
The default depends on build options, so that should be correct.

@_date: 2012-08-22 02:53:21
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Full Disclosure: CVE-2012-2459 (block 
From the mining perspective, the unpatched install might not be simply wedged: it will also follow a competing smaller blockchain. An attacker could have used this exploit against a number of large miners (say about 40% or so) and exchanges to pull off any number of double-spend attacks until the miners noticed they had been forked and fixed their bitcoind. That is, the attacker could easily hijack as much of the miners has he wanted for his own purposes including phony 6+ confirmation transactions. On a more subtle level, the attacker could target certain blocks they wanted orphans by performing this attack on a majority of miners with the "tip" block he wanted orphaned.
This vulnerability is also the reason why Eloipool (the software behind Eligius, EclipseMC, TripleMining, and other pools) has attempted to produce blocks with only transaction counts that are powers of two; such blocks cannot be used for an attack even against vulnerable clients.

@_date: 2012-02-01 10:26:45
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Announcement: libcoin 
Looks interesting. However, it doesn't configure for me:
    I noticed it's forked from bitcoind 0.4.x. Do you plan to merge up to 0.5.x?

@_date: 2012-02-01 11:15:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Announcement: libcoin 
I didn't see anything useful in ccmake. Boost is in the standard locations (/usr/include/boost/ and /usr/lib/libboost*

@_date: 2012-02-01 11:23:21
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Announcement: libcoin 
Boost 1.46.1 is the latest stable on Gentoo.
Perhaps it would be easier to merge with the latest 0.4.x branch:
    git://gitorious.org/+bitcoin-stable-developers/bitcoin/bitcoind-stable.git

@_date: 2012-02-01 12:37:39
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Announcement: libcoin 
Upgrading to 1.47 did not change the error at all... :/

@_date: 2012-02-02 11:30:11
@_author: Luke-Jr 
@_subject: [Bitcoin-development] libcoin (HEAD) now supports boost < 1.47 
I found the problem: you are trying to use static libraries. Best practices are to use shared libraries (except for specific scenarios like universal "Linux" binaries) and most distros do not have static libraries installed by The coinQt stuff was also creating a problem.
I am able to build with this patch:
diff --git a/CMakeLists.txt b/CMakeLists.txt
index dea37c4..b876881 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
 -352,7 +352,7  ENDIF(BDB_FOUND)
  We need as a minimum Boost 1.47 to support the signal_set used in Server. A backup signal_set has been created, though.
 SET(Boost_NO_BOOST_CMAKE ON)
 SET(Boost_ADDITIONAL_VERSIONS "1.47" "1.47.0" "1.48" "1.48.0")
-SET(Boost_USE_STATIC_LIBS        ON)
+        ON)
 SET(Boost_USE_MULTITHREADED      ON)
 SET(Boost_USE_STATIC_RUNTIME    OFF)
 -804,9 +804,9  SET(PKGCONFIG_FILES
 #  libcoin-coinMine
 )
-  SET(PKGCONFIG_FILES ${PKGCONFIG_FILES} libcoin-coinQt)
+#  SET(PKGCONFIG_FILES ${PKGCONFIG_FILES} libcoin-coinQt)
 FOREACH(PKGCONFIG_FILE ${PKGCONFIG_FILES})
   CONFIGURE_FILE(${PROJECT_SOURCE_DIR}/packaging/pkgconfig/${PKGCONFIG_FILE}.pc.in
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 0011392..67044d1 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
 -19,9 +19,9  FOREACH( mylibfolder
 ENDFOREACH()
-IF (QT4_FOUND AND NOT ANDROID)
-    ADD_SUBDIRECTORY(coinQt)
+ (QT4_FOUND AND NOT ANDROID)
+#    ADD_SUBDIRECTORY(coinQt)
 IF(ANDROID)
     configure_file("${LIBCOIN_ANDROID_TEMPLATES}/Android.mk.src.in"

@_date: 2012-02-02 18:27:31
@_author: Luke-Jr 
@_subject: [Bitcoin-development] libcoin (HEAD) now supports boost < 1.47 
I hadn't even thought of this. Sounds like a pain :/
The problem I had was related to *using* static libraries; ie, boost.
I have libboost*.so, but libboost*.a

@_date: 2012-02-06 10:54:25
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version 0.6 release candidate 1 plan 
There are still many other pull requests that seem to be ready, but perhaps those can just as well wait for 0.7 if the 0.6 changes are deemed too much to add onto. Here are some that seem to be well-tested, and have been part of next-test for a while:
If this affects relaying, it will significantly harm the ability to replace the current spammy "green address" scheme with a sensible extra signature system. On the miner end, it could significantly harm adoption of such a What else do I need to change for this?
I can also confirm I have seen at least one addr.db corruption with this.

@_date: 2012-02-07 10:04:36
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version 0.6 release candidate 1 plan 
FWIW, at least MtGox was OK with the plan to move to non-blockchain-spam
0-confirmation via an extra signature. Why do you ignore this possibility, and merge stuff that will break it? Do you have an alternative solution to the problem of green addresses spamming the blockchain? As I noted in the pull request, stripping extra data has no negative impact on normal transactions, and clients creating these can be written to expect the txnid to change (or simply not care what the txnid is).

@_date: 2012-02-07 11:14:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Version 0.6 release candidate 1 plan 
gmaxwell explained to me why this is no longer needed on IRC.
I withdraw my objection.

@_date: 2012-02-17 11:33:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 2012-02-17 next[-test] 
^^ next ^^
^^ 037497c ^^
^^ 4b7e5f5 ^^
^^ next-test ^^

@_date: 2012-02-20 09:18:37
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP-13 
If you must. However, BIP 13 has been pretty much undisputed, and only held back by BIP 16/17 so far...
Where do you see this? It has always been "version" as far as I am aware, and we discussed formalizing the details of the bits in it a few months back.
In any case, it was certainly originally intended as "version" as can be observed in Satoshi's reference implementation.

@_date: 2012-02-23 15:33:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BitcoinQt eating 100% CPU 
Wouldn't that prevent the user from registering it?

@_date: 2012-02-28 13:23:01
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Duplicate transactions vulnerability 
Has it been verified to make even rocconor's complicated transaction-based version impossible?
Can we do this in two steps? First, prefer blocks which don't break the rule; once 55%+ are confirmed to have upgraded, then it is safe to treat it as a hard rule.

@_date: 2012-01-15 20:19:34
@_author: Luke-Jr 
@_subject: [Bitcoin-development] bitcoin.org SOPA/PIPA blackout 
I agree (with the conclusion). There are much more important and urgent problems than SOPA/PIPA that we'd need to constantly 'blackout' if we did it over every single problem.

@_date: 2012-01-16 11:14:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.5.2 - rush? 
Mushoz makes a good point:
Do we have enough downloads on 0.5.2rc1 to get the final rushed out and onto the website?

@_date: 2012-01-16 21:25:20
@_author: Luke-Jr 
@_subject: [Bitcoin-development] bitcoin.org SOPA/PIPA blackout 
Sorry, Bitcoin is not about the same thing to everyone. For me, Bitcoin is about one thing: providing a monetary system for the Tonal number system. Otherwise, it would be merely an interesting project I have no real concern with. To assume everyone has the same interests is a sure-fire way to prevent widescale adoption. If you want Bitcoin to succeed, don't try to impose a single purpose/"about" on everyone using it (which a "blackout" would do).
Bitcoin is an innovative new currency. How is a bill on internet censorship (which is badly needed, even if not in the form of SOPA/PIPA) directly relevant? I don't think it is.

@_date: 2012-01-17 11:03:11
@_author: Luke-Jr 
@_subject: [Bitcoin-development] bitcoin.org SOPA/PIPA blackout 
Censorship is, in principle, good. Free speech and democracy are, in princple, evil. Idolizing Liberty is also evil. Your backward morals are worse than a political issue.
How about taking a few minutes to read this article by Bishop Sanborn? ;)

@_date: 2012-01-27 18:00:29
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 0020: URI Scheme 
It's been Final (even according to BIP 1 standards) since late January 2011. The only change recently is assigning it a BIP number for formality.
Once P2SH is deployed, it will probably make good sense to revisit the URI Scheme for revision, and eventually move BIP 20 to Replaced/Superceded status.

@_date: 2012-01-27 20:45:09
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 0020: URI Scheme 
It's been implemented in many clients for nearly all 2011.
Bitcoin-Qt is just behind the pace. Not relevant.
You mean 3 months *after* the spec had a consensus and multiple

@_date: 2012-01-29 00:15:58
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Quote on BIP 16 
2 compressed pubkeys are 33 bytes each. Add 1 bytes for the N (n-of-m), 1 byte for the address version, and finally the 4 byte checksum, you get a total of 72 bytes. But these are *bytes* - to get an address, you also need to base58 encode it: this yields a 99 character address.

@_date: 2012-01-29 09:40:01
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Fw: Quote on BIP 16 
In other words, if the max-sigops-per-block were ever approaching a real problem, we could just start using these kind of transactions instead hidden behind the P2SH... so the one remotely-tangible benefit of BIP 16 over 17 has been solved, right? ;)

@_date: 2012-01-29 17:50:40
@_author: Luke-Jr 
@_subject: [Bitcoin-development] All pre-BIP BIPs are not valid 
First and foremost, I consider this thread an utter waste of time. These matters were "finished" over a year ago, and there is no need to dig them up again just because there are numbers for BIPs now. I don't intend to continue this topic any further than necessary, since my time (and everyone else's) is better spent working on *actual forward progress*, not this attempt to rewrite history. That being said...
Before the BIP process was formalized. The process itself existed long before.
It did. In early 2011, there was a consensus and multiple implementations (by name, I know of at least Spesmilo and WalletBuddy). This is by definition the Final status. It was not until months later that anyone objected to the You are contradicting the assignment of BIP 0020 to a preexisting standard By trying to demote BIP 0020 from Final to Draft, you are not following the specification in BIP 0001.
Rather, I am claiming that assigning a number does not give you the authority to demote a preexisting standard. No other standards organization has attempted to claim preexisting standards don't exist or change their status.
Anyone is welcome to submit a new BIP aimed at Superceding BIP 20 (and doing so might make good sense soon, with various new functionality), but until that occurs, BIP 20 remains the Final status it has been for a whole year now.

@_date: 2012-01-29 18:10:30
@_author: Luke-Jr 
@_subject: [Bitcoin-development] All pre-BIP BIPs are not valid 
No, that never had a consensus.
As everyone can observe from your bitcointalk links, you didn't begin trolling until months after the URI Scheme was Finalized (in January 2011).

@_date: 2012-01-29 21:37:23
@_author: Luke-Jr 
@_subject: [Bitcoin-development] CAddrMan: Stochastic IP address manager 
As of yesterday, this is also part of my `next' and `next-test' branches.
Summary of latest next/next-test:
*** ACCEPTED (`next' branch)
*** NEEDS ACCEPT
*** NEEDS REVIEW
*** NEEDS SUPPORT

@_date: 2012-01-30 13:44:06
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 21 (modification BIP 20) 
BIP 21 is not forwards-compatible, and is intentionally designed to be biased toward decimal. BIP 20 is neutrally biased, forward-compatible, and has been implemented for over a year now. If BIP 20 is to be Superceded, a proposal should improve on it, not make it worse with bigotry and short-sightedness.

@_date: 2012-01-30 13:56:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 21 (modification BIP 20) 
It is not correct to imply that BIP 20 requires Tonal Bitcoin support.
In fact, the exact opposite is true; it states that even if one unit (eg, TBC) would be a more rational way to display a specified amount, clients should still interpret it in the way that is deemed to be most intuitive to the user (eg, BTC).

@_date: 2012-01-30 14:17:03
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 21 (modification BIP 20) 
If the goal is to reduce complexity, strtol-compatible amount is the answer ;)

@_date: 2012-01-30 21:07:05
@_author: Luke-Jr 
@_subject: [Bitcoin-development] CAddrMan: Stochastic IP address manager 
How about just disable it by default for 0.6 and strip it out entirely before 0.7 if there's no problems?

@_date: 2012-01-31 11:07:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 20 Rejected, process for BIP 21N 
It does among implementations such as Spesmilo and WalletBuddy, and has for some time. More importantly, it achieved consensus and Final status before any objections were made. Final only changes to Superceded. What's the point of a formal BIP process if that process won't be followed?
That's not incompatibility, and not true. The standards use hexadecimal numbers, and I can't even think of a single case off-hand where decimal is That being said, I'd be fine with a spec that used strtol-compatible satoshis for amount. This is both simple and forward-compatible.
This is true only for BTC users. While that might be a sensible unit today, it almost certainly won't be in the future. amount=0.00001 is much worse than amount=1000 or amount=1x3
Existing software uses Satoshis internally, and it's generally regarded as a design flaw that it uses BTC numbers in the JSON-RPC protocol.
This strikes me as more of "let's test the code earlier rather than later" than forwards compatibility. The problem is that it's pretty much unanimous that floating-point should never be used, and without that both representations will be rounding when there are smaller units available.

@_date: 2012-01-31 11:58:49
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP16/17 replacement 
I'm not aware of any remaining *tangible* objections to BIP 17 at this point (Gavin seems concerned over a theoretical risk-that-nobody-has-thought-of), but if there's a better solution, I'm perfectly fine Withdrawing BIP 17 to support it.
Both BIP 16 and 17 are backward compatible enough that people can continue to use the old clients with each other. An upgrade is only required to send to (or create/receive on) the new 3...-form addresses. That being said, it's quite possible to rewrite the practical implications of both BIP 16 and 17 in the format you seem to be suggesting. Doing so would even get rid of one of the major objections to BIP 16 (its inconsistency).

@_date: 2012-07-09 17:21:17
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Random order for clients page 
FWIW, all this argumenting is why my original suggestion for a Clients list focussed on objective information in alphabetical order.

@_date: 2012-07-17 00:09:48
@_author: Luke-Jr 
@_subject: [Bitcoin-development] bitcoin.org - remove hackathon 
IMO, bitcoin.org is more community-focussed anyway.
How often do devs use the site, compared to GitHub etc?
Someone else made a pullreq for Bitcoin Magazine; I suggest(ed) that
for-profit organizations should be asked to pitch in some way or another.
Who should organize that, I don't know. If Bitcoin Consultancy/Amir is behind the conference, I suggest their/his development contributions should be sufficient in that respect.
I concur, this should be discussed in a pullreq.

@_date: 2012-07-22 20:52:25
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Reconsidering block version number use 
It just occurred to me that the block version number could easily be used as a cheap "extra nonce" right now. Considering that we will probably see lots of ASIC miners running at 1 TH/s per rig before the end of 2012, it might be desirable to save the block version for this purpose.
The current block height in coinbase addition currently proposes to use block version 2. However, the protocol change is in fact to the coinbase transaction, not the block itself (which really doesn't have any extensibility without a hardfork anyway). Perhaps we should consider bumping the coinbase transaction version number to 2 for this instead?
Also, Jeff noticed that block 190192 has version==2 without a valid block height in the coinbase. I suspect this may be the result of combining the current blockheight-in-coinbase pullreq with P2Pool. This means that if we go forward with the version==2 marker, we will forever need to make an exception for that block. Moving the version==2 to the coinbase transaction version also means whoever makes that transaction (thus deciding whether to put the height in it or not) also sets the version number - instead of the block version coming from bitcoind and the coinbase transaction coming from P2Pool or other

@_date: 2012-07-23 00:57:48
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Reconsidering block version number use 
Any reason CBlockIndex couldn't cache the coinbase version?
That sounds workable.
I was thinking more of the end-game of changing the rule to simply "if version==2, require the height in coinbase" after the point of no return is met without any infringement.

@_date: 2012-07-27 06:03:59
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Scalability issues 
Trying to run state-of-the-art encryption on EVERYTHING on an ancient computer is fairly ill-advised. I encourage you to continue with the plan to go Sounds reasonable...
but why do you also need to encrypt 2+ GB of public record?

@_date: 2012-07-29 17:15:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Signing release binaries 
Considering that Gavin is not interested in participating in any way in the stable versions, I would prefer to see someone else responsible for OS-vendor

@_date: 2012-07-30 20:30:59
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 22 - getmemorypool 
Note that the Pooled Mining parts have already been moved to:
It just needs a number assigned (as the last part).

@_date: 2012-06-03 00:52:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Defeating the block withholding attack 
Analysis, comments, constructive criticism, etc welcome for the following:
At present, an attacker can harm a pool by intentionally NOT submitting shares that are also valid blocks. All pools are vulnerable to this attack, whether centralized or decentralized and regardless of reward system used. The attack's effectiveness is proportional to ratio of the attacker's hashrate to the rest of the pool.
There are obvious solutions that can be used to defeat this attack on centralized pools. For example, including a secret in the coinbase transaction that is accepted by the network as a partial preimage proof-of-work. All these solutions require changes to Bitcoin's proof-of-work acceptance terms, and since centralized pools can be harmful to the network's security, these rule changes are not likely to gain enough acceptance among the greater Bitcoin ==Proposed Solution==
Please comment on the viability of this new proof-of-work algorithm, which I think should be viable for even decentralized pools:
Blocks are accepted at a lower difficulty N (choosable by the pool; eg, the share difficulty) iff they are submitted with a candidate for the next block and SHA256(SHA256(NewBlockHash + NextBlockCandidateHash)) meets difficulty M.
The relationship between M and N must be comparable to the normal network difficulty; details on the specifics of this can be figured out later, ideally by someone more qualified than me. M and N must be chosen prior to searching for the block: it should be safe to steal some always-zero bytes from the prevblock header for this.
This algorithm should guarantee that every share has an equal chance of being a valid block at the time it is found, and that which ones are actually blocks cannot be known until the subsequent block is found. Thus, attackers have no way to identify which shares to withhold even while they have full knowledge of the shares/blocks themselves.
==Backward Compatibility==
Obviously, this change creates a hard-fork in the blockchain. I propose that if it solves the block withholding risk, the gain is sufficient that the community may approve a hard-fork to take place 1-2 years from consensus.
Since mining continues to use a double-SHA256 on a fixed 80 byte header, existing miners, FPGAs, etc should work unmodified. Poolservers will need to adapt significantly.

@_date: 2012-06-04 02:04:55
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Defeating the block withholding attack 
That depends on the pool's reward scheme. Some complicated forms are capable of getting "bonus" earnings out of the pool. Under all systems, the attacker at least gains the "hurt the pool" benefit. Given the frequency of DDoS attacks on pools, it is clear there are people who will even pay for attacks that provide no other benefit than harming pools. Under all systems, the attacker doesn't lose out in any significant way.
If we wait until there's real pain, it will be a painful fork. If we plan it 1-2 years out, people have time to upgrade on their own before it breaks.
With this attack, attackers can hurt the pool's "luck factor" *and* spend the bitcoins they earn to bribe users away.

@_date: 2012-06-04 21:05:25
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Defeating the block withholding attack 
With decentralized pools, the attacker does have access to the block, and can potentially submit it to the Bitcoin network directly bypassing the pool if it benefits them to do so.
Because of the above, there is a possibility an attacker can make a profit.
There are other modes of detection, but nobody has bothered to implement them since attackers can easily do a simple workaround in an arms race.
With my proposal, miners can find shares, but won't know if it's a valid block until the subsequent block is also found (that subsequent block might not end up being a real block in the big picture).
This only works for centralized pools, which are contrary to the health of the Bitcoin network. Decentralized pools cannot have a secret.

@_date: 2012-06-05 01:05:18
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Defeating the block withholding attack 
For example (just a draft; in reality, merged mining would probably be
             integrated in a hardfork)
 4 bytes: Block version number = 2
31 bytes: Hash of the block 2 back, except for the minimum last 8 bits of zero
 1 byte : Share difficulty (measured in "zero" bits)
 4 bytes: Timestamp
 4 bytes: "Bits" (current target in compact format)
 4 bytes: Nonce
The final  bits (minimum 32) of the block header are zero.
The hash of this block header, concatenated with a valid share candidate for the next block header, must hash to a value less than the current target offset against the share difficulty (this algorithm may need adjustment).
The first share becomes a block only after a second share is found that combined hashes to meet the real difficulty. That second share becomes a block when a third is found. Etc.

@_date: 2012-06-14 15:00:45
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP16 backport bug (0.4.x and 0.5.x stuck on 
Block 177618 was rejected by BIP16-enabled backports (0.4.x and 0.5.x) due to containing a P2SH redemption with over 200 bytes in. Since the BIP16 code uses IsPushOnly to check the scriptSig for compliance, and IsPushOnly in these versions also enforced the 200-byte "is standard" rule, they were effectively treating it as a network rule. This was not a problem in 0.6 because the original OP_EVAL commit (e679ec9) moved the check outside of IsPushOnly.
This problem could have been avoided if either IsPushOnly was renamed when its semantics/behaviour changed significantly, or I inspected the OP_EVAL commit in detail instead of skipping it over as a new feature and not bugfixes. Additionally, it might have helped, if the commit message mentioned the change, but I'd probably have still missed it as it wasn't relevant until months later.
I will be releasing 0.4.7 and 0.5.6 hopefully in the next 24 hours to address this bug, along with instructions to get unstuck:
    1. Ensure you have the minimum required 1280 MB memory available
    2. Create a new file in your bitcoin directory (the same one with
       wallet.dat) called DB_CONFIG with the following two lines:
           set_lk_max_locks   1000000
           set_lk_max_objects 1000000
    3. Start bitcoind or Bitcoin-Qt
    4. WAIT AT LEAST SIX HOURS
       Your client will NOT show any signs of making progress during this time
    5. When complete, your client should be up-to-date on block count
    6. At this time, you may wish to delete the DB_CONFIG file and restart
       your client, to use less memory

@_date: 2012-06-17 01:15:54
@_author: Luke-Jr 
@_subject: [Bitcoin-development] After compressed pubkeys: hybrid pubkeys 
I'm willing to make Eligius reject these as well, if someone provides a patch that doesn't depend on IsStandard being enforced...
Same goes for rejecting OP_NOP - I can't see any legitimate reason we'd want these on mainnet right now.

@_date: 2012-06-18 00:02:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.6.x - detachdb in wrong place 
No, that was a temporary branch of what became the stable 0.6.x branch.
GitHub/master is bleeding edge. For production, you usually want the stable branches/releases (which are on Gitorious).
The fix to -detachdb's position in -help was just merged to master, and should be backported sometime in the next few days.

@_date: 2012-06-18 03:57:11
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.6.x - detachdb in wrong place 
Workflow is all new development takes place in master during release windows. Eventually, those windows close and master is cleaned up and bugfix'd for the next 0.x release. Occasionally, when 0.N.0 has some problem before the next release window opens, Gavin will use it to roll a 0.N.1 (and recently even a 0.N.2 and 0.N.2.2). Once the release window for the next 0.N version opens,
I import the (last bugfix-only commit after the final 0.N.M release made in master) into the stable repository as the 0.N.x branch, and begin applying backports. When there's significant backports, I'll tag another 0.N.M from the branch and possibly release Windows binaries. Usually this happens around the same time as master becomes the next 0.N.0 release.
I guess I've been neglecting to update the stable repo with releases tagged in master. It should be fixed now.

@_date: 2012-06-18 13:25:21
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.6.x - detachdb in wrong place 
This is the work model I use:
  git clone git://github.com/bitcoin/bitcoin.git
  cd bitcoin
  git remote add stable git://gitorious.org/+bitcoin-stable-developers/bitcoin/bitcoind-stable.git
  git remote add personal git at github.com:YOURNAME/bitcoin.git
With this, you can use "git fetch --all" to update your copy of the remote
branches, and access them as "origin/master", "stable/0.6.x", etc; and push
personal branches using "git push personal "

@_date: 2012-03-02 14:14:05
@_author: Luke-Jr 
@_subject: [Bitcoin-development] JSON-RPC is BIP territory or not? 
This isn't implementation-specific. If you read it, you should notice it is intentionally generic for multiple use-cases. Right now bitcoind supports getmemorypool for a few use cases, but this proposed BIP enables it to be utilized for many more. Specifically, Eligius and at least a few other pools wish to move toward a more decentralized method of pooled mining (similar to the proprietary p2pool protocol). Eligius already supports miners producing their own work with getmemorypool using this draft, and our Eloipool server is open source (AGPL-3) for others to adopt (I know of at least one other pool planning to do so). Other pools not using Eloipool also have expressed interest in this, so a standard is desirable.

@_date: 2012-03-03 08:49:03
@_author: Luke-Jr 
@_subject: [Bitcoin-development] JSON-RPC is BIP territory or not? 
Please do comment on the content, in the original thread if you prefer:

@_date: 2012-03-03 10:00:27
@_author: Luke-Jr 
@_subject: [Bitcoin-development] getmemorypool BIP process 
You mean explicitly mention the getwork longpoll protocol as part of the getmemorypool BIP? Probably a good idea.
HTTP and JSON-RPC are a client-server model; there is no way for the server to make calls to the client. It's not practical to expect clients to run their own JSON-RPC server - many cannot listen on WAN ports at all.

@_date: 2012-03-03 10:44:15
@_author: Luke-Jr 
@_subject: [Bitcoin-development] getmemorypool BIP process 
I wasn't aware anyone was considering JSON-RPC over anything other than HTTP.
I've updated the draft to include long polling, and remove some assumptions of using HTTP for transport.

@_date: 2012-03-03 20:04:29
@_author: Luke-Jr 
@_subject: [Bitcoin-development] getmemorypool BIP process 
How would you suggest addressing this? I presume if a share solves blocks on multiple chains, you just longpoll once when that's successful?
Hmm, the problem is that adding any parameters to getmemorypool itself breaks compatibility with bitcoind 0.5, and using HTTP headers makes it HTTP-specific again. Any ideas?
Good catch. Should this be required (since it might be necessary for future Bitcoin blocks), or just "should" for compatibility?
What is unclear about this?
Doing this safely needs some way for clients to communicate capabilities to the server, which has the problem of passing parameters to getmemorypool.
There is no mining hardware to date that exhausts even half the nonce space, so I'd really prefer to see this as a required feature on the miner side. On the other hand, it's merely an extension for getwork, so I can see the problem so long as we're using getwork proxies.

@_date: 2012-03-06 10:46:25
@_author: Luke-Jr 
@_subject: [Bitcoin-development] P2SH status update 
BIP16: 37% support vs 4% oppose
BIP17:  4% support vs 0% oppose

@_date: 2012-03-06 14:29:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] P2SH status update 
I think nobody has discussed P2SH with Tycho recently, since the priority is to get BIP 30 deployed first.

@_date: 2012-03-13 14:45:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Adding a pong message 
Not really an objection per se, but what's wrong with TCP keepalives?

@_date: 2012-03-18 14:11:48
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP 16 changes (list inside) 
You might find my 0.4.x backport helpful:
    Be aware, this still needs auditing (nobody else has looked it over), but I believe should cover only the minimal changes required to get P2SH validation (though not the "standard" rule changes to accept them into blocks).

@_date: 2012-03-22 10:00:40
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Adding callback hooks to the satoshi 
I'm not sure it's a good idea to let other code into the main wallet-handling process/memory space. I'd suggest looking into designing a workable Wallet Protocol for general use between the wallet and GUIs/applications.
 has a draft I made a long time ago, but really seems a bit overcomplicated.

@_date: 2012-03-31 00:03:17
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.7 merge recommendations/status 
NOTE: I've been piecing this together for about a week now, and intended to update it when 0.6.0 final was released, but with the timing of it, I just won't get the time to update for a while, so here is my last draft...
It seems to me, there is potentially enough ready to merge into 0.7 to start the RC process right away if someone wants to... except that the first merge will probably require rebasing everything else ;)
My first recommendation is to merge Matt's CBlockStore ( It's mostly a major code cleanup, but it still needs a lot of post-merge testing. The sooner it gets in the master branch, the more testing of unexpected cases that it will get before final. Also, Matt's been working hard to keep rebasing it throughout the 0.6 merge window, which is very difficult since it conflicts with pretty much every other change. As one of the parties responsible for those other changes, I vote to get the big conflict over with and rebase all the simpler stuff afterward.
Next up are some changes already ACK'd for 0.7: Hearn's "pong" message ( and Wladimir's Visual C++ 2010 fixes ( getmemorypool BIP standardization ( is also ACK'd, but it might be good to wait until later in the merge window considering its low impact and high potential for change as the BIP gets closer to Accepted status.
For similar reasons as CBlockStore, I feel multithreaded JSON-RPC with keep-
alive support ( should be merged sooner rather than later. It's long overdue for bitcoind having had a lot of testing, and pretty much required for any sort of high-volume bitcoind usage (such as solo mining). Some other optimizations by Joel such as the optimized ToHex function ( and FastGetWork ( have also had plenty of testing; all combined, these optimizations more than double the performance of JSON-RPC.
Details: Pieter's getalltransactions ( and my getblock_full ( provide what is needed to completely replace Jeff's old dumpblock call with bitcoind's new getblock. He also put together a -loadblock option ( which has proven quite handy for development, and -walletupgrade ( seems like a good idea.
Under the hood, Chris has some neat refactoring of the coin selection algorithm (  and I haven't had any problems using it in next-test for a few weeks now. Michael has contributed a patch to get the standard reopen-log-files-on-SIGHUP ( Matt noticed the protocol documentation on the wiki and BitcoinJ both expect the 'getheaders' message to return at most only 2000 headers, so recommends we enforce that in the core ( Philip has a trivial flip to the backslashes in debug.log for Windows ( Some p2pool miners put up a bounty for a JSON-RPC call to customize fee requirements ( that would help make Bitcoin more decentralized.
Scott has a pull request for Bitcoin-Qt to behave more like other close-to-
systray applications by toggling the hide/show action ( He's also contributed a patch to show miners' immature balances on the overview screen ( it leaves only a blank space for non-miners). Nils, on the other hand, has been working with a UI designer to totally remodel Bitcoin-Qt.
Coderrr has rebased his Coin Control features ( to the latest version. These seem to be popular, so should probably be merged as soon as it's had proper review.
Finally, I don't know the status of Pieter's IPv6 support, but I hope it will be ready for 0.7. Right now all I see submitted for this is support for multiple local IPs ( though.
I'd like to see Coinbaser ( finally get merged, but since it seems nobody is using bitcoind for mining anymore, I guess there isn't a real need. I don't plan to rebase this anymore unless someone gives it a "I'll merge it" sign.

@_date: 2012-05-02 09:31:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] new bitcoin.org clients page 
This is just wrong. While Bitcoin-Qt is by far the best client, it is Wladimir's, not Satoshi's.
Isn't this down to only a few hours now?
I don't see this as relevant. Every client has been partly funded by donations, anyway.

@_date: 2012-05-02 16:25:26
@_author: Luke-Jr 
@_subject: [Bitcoin-development] new bitcoin.org clients page 
This is far less relevant than license...
Or bitcoind?
Dependent on centralized server, not any particular client
There are multiple Android clients. There is (or was) an OS selection to the left of the client choices...
Pretty sure it means "not running continuously".
Would be awesome if it took after Spesmilo and managed bitcoind itself in the

@_date: 2012-05-11 15:33:53
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Please review: getmemorypool (BIP 22) revision 
I have finally got around to revising the BIP 22 draft, and would appreciate further review: I believe this revision addresses Geir's last email in March, as well as some practical problems some pools recently came across.
To summarize the changes from the last revision in March:
- The submitblock(, ) method is renamed to getmemorypool
- Requesting a job now uses getmemorypool() to provide client
  capabilities and other information to the server
- Longpolls use a parameter in the getmemorypool request, not necessarily a
  separate URI
- The client can inform the server of its own size and sigop requirements in
  advance
- The client can request detailed transaction data from the server, necessary
  to sanely manipulate the transactions included in the final block without
  discarding fees or making the block invalid due to not having enough
- With both client and server support, blocks can be proposed before wasting
  time mining them, to ensure they are otherwise valid
- Servers can be arranged into single logical services, with failover and load
  balancing (similar to the getwork X-Host-List and X-Switch-To extensions).
You can see the full diff here:

@_date: 2012-05-16 18:29:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] P2P feature discovery (was Re: BIP 33 - 
That assumes you already have a connection to the peer in question.
As I understand it, the service bits are propagated as part of the address, so you can see at a glance which nodes you want to connect to for some special service. Passing a huge list along might be unwieldy (though it makes sense for protocol changes that don't add new services).

@_date: 2012-05-16 18:46:49
@_author: Luke-Jr 
@_subject: [Bitcoin-development] P2P feature discovery (was Re: BIP 33 - 
No, I meant the inverse. If only a small minority of nodes are stratified, the clients need some way to figure out which ones, without connecting to every node.

@_date: 2012-05-24 20:31:38
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Punishing empty blocks? 
These are problematic for legitimate miners:
1) The freedom to reject transactions based on fees or spam filters, is severely restricted. As mentioned in other replies, this is an important point of Bitcoin's design.
1b) This punishes miners with superior transaction spam filtering. As with all spam filtering, it is often an "arms race" and therefore the filter rules must be kept private by the miners, and therefore cannot be disclosed for the validating clients to take into consideration.
2) For a few seconds after a new block is received, the new transaction merkle root(s) are not finished calculating. During this time, most miners are working on "blank" blocks with the new previousblockhash but no transactions. If those blocks are ignored, miners are forced to shutdown mining during this 3) As you mentioned, illegitimate miners can easily workaround these restrictions (even the second one, by flooding the network with their own transactions). This puts the legitimate miners at a disadvantage in their own search for valid blocks, unless they also come up with counter-measures The argument that these are not rule changes is flawed:
1) As of right now, 99% of the network runs a single client. Anything this client rejects does de facto become a rule change.
2) Even if there were a diverse ecosystem of clients in place, discouragement rules that potentially affect legitimate miners significantly mess with the odds of finding a block.
3) If legitimate miners do not adopt counter-rules to bypass these new restrictions, the illegitimate miners are left with an even larger percentage of blocks found.
To summarize, I believe such a change as proposed would be very harmful to

@_date: 2012-05-25 00:45:13
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Punishing empty blocks? 
FWIW, based on statistics for Eligius's past 100 blocks, it seems 10% (1 in 10) of 1-txn blocks is not actually unreasonable. This also means these 1-txn mined blocks are not necessarily harming Bitcoin intentionally. Anyone care to figure out the math for how fast miners need to finish processing transactions to reduce the number of 1txn blocks?

@_date: 2012-05-29 14:47:28
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Punishing empty blocks? 
Please not JSON, and not hard-coded logic. Bitcoin already has a secure scripting system - perhaps we can decide on an initial stack format and run a script retrieved from the URI?

@_date: 2012-05-29 15:18:54
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Punishing empty blocks? 
Without my got-tired-of-waiting-for-someone-to-merge-it coinbaser branch, anything modifying the coinbase is hard to implement.
Rather, I would suggest a 20 byte keyhash, which allows the owner to broadcast a full URI out-of-band.
How about a simple prefix to the fixed-size keyhash?
Perhaps "MFR=" (Mining Fee Rules)
I would recommend miners use https, with a specified SSL keyhash in the URI (so we don't need to pay for a "proper" SSL cert).
Clients should simply be required to follow the relevant HTTP specification.
text/plain and text/html are just wrong and don't make any sense here.
Bitcoin isn't "the web", it's a complicated script-based cryptocurrency.
Everything in the Bitcoin protocol requires a computer's interpretation for humans, and there's no reason to stray from this default. Also, JSON is not extensible in any of the ways needed for this specific purpose.
Last Modified and other caching rules are dealt with in the relevant HTTP While it doesn't make sense to give it the full legal force of a contract, I think it should be expressed as a "MUST" in the BIP.
The coinbase advertisement MUST be part of every coinbase mined by the miner, or there's no reliable way to prove which blocks are theirs.

@_date: 2012-05-29 15:34:37
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Punishing empty blocks? 
20 byte keyhashes are a fundamental building block of the Bitcoin protocol.

@_date: 2012-05-29 15:39:56
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Punishing empty blocks? 
A new message can be added to the p2p relay network, similar to tx and alert broadcasts, that allow miners to publish/update their policy URI signed by the key in question. Counter-DDoS rules could decline to relay or store URIs for keys that haven't been published in - or achieved statistical significance in - the last N blocks.

@_date: 2012-11-06 19:13:33
@_author: Luke-Jr 
@_subject: [Bitcoin-development] IRC meeting agenda, 18:00 UTC Thursday 
Not much has changed besides internal workings, right?
Though perhaps that's still significant enough for 0.8.
Amir seems to be more and more absent these days, so it might be nice to setup a successor failsafe in the event that he cannot be reached. It would be a shame for the BIP process to fall apart merely because we can't get numbers But more important to the success of BIP today, I think, is encouraging wider community participation. The stratum mining mess seems to be a direct result of lack of participation in the GBT BIP process (resulting in it not being as ideal as some pools desire) and lack of any peer review/contribution toward the stratum protocol. What can we do to increase awareness of BIP and encourage more collaboration?

@_date: 2012-11-06 22:12:53
@_author: Luke-Jr 
@_subject: [Bitcoin-development] IRC meeting agenda, 18:00 UTC Thursday 
Perhaps the problem lies in misunderstanding of the BIP process, then, rather than awareness of it. BIP isn't just "write a document"; that's just the first step. The main thing is that it gets peer review, changed to meet the community's needs, and when done should result in a common standard suitable to the needs of the whole community. Whatever the reason, there was a failure of key members of the community to participate in the GBT BIP process and ensure it addressed their needs/wants; identifying and addressing that is something that would improve the BIP process.
get_transactions is a step in the right direction, and I don't think anyone expects Stratum to reach the same level as GBT overnight considering it took months for GBT (though I have no doubt now that the GBT discussions have taken place, that some dedicated individual could probably combine the two if they dedicated a few days to it). My comments, however, were not intended to bash stratum or mere complain about the past (it can't be changed), but an attempt to learn from the past and figure out how we can improve things the next time

@_date: 2012-11-26 23:13:42
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
I would prefer using the user-accepted certs at the operating system level...

@_date: 2012-11-26 23:19:34
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
That's expected behaviour - except it's mainly be manipulated by *users*, not viruses (which can just as easily manipulate whatever custom cert store we use). If I don't trust Joe's certs, I don't want Bitcoin overriding that no matter who Joe is or what connections he has.
Browsers with this bug are not relevant IMO.

@_date: 2012-11-26 23:44:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
This effectively centralizes Bitcoin (at least in the eyes of many) and even if each competing client had their own list, you'd be back to the original "problem" of not being sure your CA is on all lists.
How is this whitelist any different from the list of CAs included by default with every OS?

@_date: 2012-11-27 00:31:16
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
Anonymity isn't a feature we claim to have, nor a goal of the project for the most part. Using a single Bitcoin address has many problems besides non-
anonymity: your customers are denied basic privacy and there is no good way to guarantee the user who says he paid you really did (since transaction ids are public record, anyone can claim they sent it).
In short, it is for the most part considered a rule to always use a unique address per transaction or at least per customer.

@_date: 2012-11-27 00:44:03
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Payment Protocol Proposal: 
There is a common subset of CAs which are included in all OSs.
That's the "whitelist equivalent". We or someone else could even setup a list of these common CAs for merchants if that is needed.
The fees CAs charge for certs is a flaw in the CA model in general, I don't see that it's important for us to solve it.

@_date: 2012-10-14 22:02:45
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Hosting of compiled bitcoin client 
This needs some clarification. If the USA has "requested" it, then presumably there's some legality involved, and our US developers shouldn't be made liable for it. The specific reason SourceForge has restricted access should be made known so non-US developers (or gitian builders) can evaluate their own laws and hopefully at least one will be in a jurisdiction that allows it.
But GitHub is also US-located, so hosting it there may be a problem too.

@_date: 2012-09-10 18:59:03
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Segmented Block Relaying BIP draft. 
Most of the problem with block propagation lies in implementation, not protocol... Distributing missing transaction on an as-needed basis is a possible improvement at the protocol level, but there hasn't (AFAIK) been any research into whether the little benefit outweighs the cost yet. In any case, I don't see why 6 new messages are needed instead of simply adding a single new type to getinv?

@_date: 2012-09-26 12:00:49
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Bitcoin Testing Project 
The front page already has wiki links. Adding a direct link to a developer resources page there would probably make sense.

@_date: 2013-04-14 05:26:37
@_author: Luke-Jr 
@_subject: [Bitcoin-development] RFC: extend signmessage/verifymessage to 
I think it would be wise to figure out HD wallet changes before trying to extend message signing. For privacy/safety, it would be a good idea to avoid signing with the same private key twice under any circumstances, so it might make sense to create a new address format the represent a chain of keys instead of one key or combination of keys.

@_date: 2013-08-02 20:55:26
@_author: Luke-Jr 
@_subject: [Bitcoin-development] btc name server 
First, an important point: addresses are not wallet ids. They are single-use destinations for a single transaction. It isn't intended that anyone should remember them, just that they should send them electronically (or with eg, QR-
Codes). Bitcoin does not (yet?) have a person/wallet identity system, but there are other mechanisms for this already (eg, PGP).
With regard to your idea, I believe it is satisfied by the new Payment Protocol that Gavin has been working on. You will be able to publish a URI for a website which people can reuse to pay you more than once.

@_date: 2013-08-16 09:39:16
@_author: Luke-Jr 
@_subject: [Bitcoin-development] LevelDB in master 
Now-merged pull request  appears to have put the master branch on an unofficial Ripple fork of LevelDB, rather than merely updating us to LevelDB 1.12.0. While Vinnie did somewhat disclose this, I don't see any evidence the nature of this was fully understood by others. As I understood the pull request, the "Ripple and Bitcoin fork" was just LevelDB with the changes we had already made. Mike's comments on the pull request (his audit) suggest that this may have been the case in an earlier revision of it. But in fact, there appear to be a number of other changes included in what was finally merged a few weeks ago. Furthermore, Ripple's fork did not do a proper git merge of upstream, thus there is a break in git history, and, more importantly, a number of upstream fixes (including some we have had reported to the Bitcoin issue tracker) were not included in this merge.
I've pushed three branches to  :
  bitcoin-1.5   Our old/unreleased LevelDB 1.5 fork, for reference
  bitcoin       Our LevelDB 1.7 fork, included in 0.8.x
  bitcoin-up    Our LevelDB 1.7 fork, merged with upstream LevelDB 1.12
A diff from current master (Ripple LevelDB 1.12 fork) to bitcoin-up:

@_date: 2013-08-19 20:13:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Proposal: remove "getwork" RPC from 
You missed getblocktemplate. It does everything getwork did and more.
Individual solo miners aren't being locked out at all. This is just removal of a protocol that has been obsolete for well over a year now.

@_date: 2013-08-21 12:00:48
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Making bitcoin traceability harder 
Let me start out by noting that there are plenty of good ideas which could be implemented, but haven't been yet, and might take a long time to get to. There are only a couple handfuls of Bitcoin developers, and even fewer of us who are able to work full-time on Bitcoin development. Perhaps surprisingly, even this often isn't the bottleneck to new functionality: we have a terrible shortage of testers, needed to make sure improvements don't break things in subtle ways. So, while your ideas are appreciated, please keep in mind that it may take time to add them, and you can help Bitcoin development much more by aiding in testing currently-written-but-untested features.
With regard to your points made specifically, please note that addresses are intended to be single-use only. Thus, the "recurrent user of address A/B" are not using Bitcoin correctly already, which is why they are so easy to trace. As far as keeping change amounts as powers of two, while I would personally love to find a justification for power-of-two amounts, I don't see how this would help privacy. I think it would actually hurt privacy, as change would now be clearly identifiable. Furthermore, it would necessarily have to throw away excess as a transaction fee - some users would be very upset with this.
As you suggest, it is of course already best practice for merchants (and individuals!) to use a unique payment address for every transaction. Gavin's payment protocol work has been making some great progress toward improving usability for this. There is also a general consensus that Bitcoin-Qt's "Receive coins" tab could be significantly improved to discourage address reuse further. I don't believe it has been discussed to have merchants use multiple addresses/coins for a single payment; that might be worth some further discussion here as a privacy extension, but I don't think many would consider it an urgent issue (it may help, but probably not enough to make it

@_date: 2013-12-05 14:27:43
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Move authorative source for BIPs to git 
I think this would stifle active BIP draft editing. We're already having a hard time getting some developers to write BIPs for their proposals - I don't think we should be putting up bigger hurdles.

@_date: 2013-12-08 12:37:22
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
Encryption is useless here. We want everyone to be able to download Bitcoin clients. Binaries on sourceforge are signed by multiple parties using gitian.
So long as someone has root (or a user that can modify it), the website is centralised. To really solve this, we would need a dedicated server that accepts commands only when signed by N-of-M parties, inside a cage locked by padlocks with keys held by independent parties, with a SSL certificate issued by an authority that has multiple parties watch it every step of the way into that server.

@_date: 2013-12-08 12:39:02
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
I'm not aware of any rational basis for trusting GitHub more than SourceForge. At least SourceForge is transparent and releases their source code.

@_date: 2013-12-08 21:01:24
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
Can someone explain how Sirius has proven the least bit untrustworthy?

@_date: 2013-12-08 23:18:42
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Dedicated server for bitcoin.org, 
I don't think "core developers" should be directly in control here any more than the Foundation should. Developers are good for development, not necessarily web or server admin tasks. Only those directly involved in the needed roles should have access IMO.

@_date: 2013-12-17 22:50:24
@_author: Luke-Jr 
@_subject: [Bitcoin-development] RFC: MERGE transaction/script/process for 
This is interesting, but I'm not sure it has the right incentives. First, it adds more reason for miners to *avoid* including transactions (they might turn out to be double-spends and make merging costly). Second, it gives people reason to double-spend (the miner might cover the cost of it). Finally, you don't appear to address how to deal with the subsidy - do both miners get it?

@_date: 2013-12-31 01:14:05
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Looking for GREAT C++ developer for 
I strongly disagree on this isolated point. Using the same logic, Bitcoin is vulnerable to an attacker at negligible cost by re-using existing hashing power from mining Namecoin. Any non-scam altcoin is pretty safe using merged mining, since any would-be attacker is going to have it in their interests to invest in the altcoin instead of attacking it. It's only the scam ones that want to pump & dump with no improvements, that are really at risk here.
The rational decision for a non-scam altcoin, is to take advantage of merged mining to get as much security as possible. There are also some possible tricks to get the full security of the bitcoin miners even when not all participate in your altcoin (but this area probably needs some studying to get

@_date: 2013-02-09 01:29:16
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.8.0rc1 status 
FWIW, this should be already mostly-fixed in pull  I submitted 9 days ago... only thing not in that pull is changing gitian to use the standard CXXFLAGS rather than our non-standard DEBUGFLAGS (whether DEBUGFLAGS should be propagated to LevelDB or not is another conversation I guess).

@_date: 2013-02-09 19:01:48
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Blockchain as root CA for payment protocol 
What is the technical difference here? Namecoin ties names to data; DNS is a specific namespace in it. There is no reason I know of that this identity stuff cannot be a new namespace.
This is true of namecoin, but it does not have to be true of new merged-mined data. You could very well require the Bitcoin proof-of-work to be valid and the master header to be in the Bitcoin blockchain.
Yes, if people stop using your system, it won't work. Consider that a "this idea failed" scenario, where it doesn't matter.

@_date: 2013-07-14 19:33:06
@_author: Luke-Jr 
@_subject: [Bitcoin-development] libzerocoin released, 
But the total reward is what mining will tend toward equalizing in costs.
In any case, the cryptocurrencies are neutral to cost of mining, or perhaps even benefit from it being as cheap as possible: if it's cheaper to mine, you can get an even higher difficulty/security out of it.
Invalid blocks are rejected by validating clients in all circumstances.
I suspect you may mean a block that doesn't include transactions you want confirmed. In that case, you must not be paying sufficient fees for the miner to consider it worth their time, or must be doing something the miner considers fundamentally objectionable (in which case they won't be satisfied by any fee). But these miners, unless they are able to acquire over 50% of the hashrate (in which case the cryptocoin is compromised), are not the only ones mining blocks, and if another miner accepts your transactions there is no

@_date: 2013-07-14 20:16:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] libzerocoin released, 
Nor gained anything. So the "lesser" chain maybe can't trust SPV.
But trusting SPV was already a bad idea anyway.
Note that the parent chain is not in any privileged position here either: a merged-mined chain could provide the value to the miner he is interested in, while he sees nothing of the parent chain. In short, merged mining is pretty much unavoidable in any case.
The basic assumption of SPV is that more people will be assisting rather than making invalid blocks. That motive doesn't necessarily need to be economic, nor do proper validating clients rely on it. The only real assumption behind mining is that the majority will not be aiming to reverse transactions with valid blocks.
P.S. How about a Zerocoin with no-reward/PoSacrifice merged mining as well as (rewarded) Prime POW; maybe with no subsidy halving, to try a new economic idea as well ;)

@_date: 2013-07-23 22:26:44
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Linux packaging letter 
It doesn't need to be audited by any given person or team, just someone who understands the issues and can dedicate the time to doing a competent audit.
Testing bitcoind/bitcoin-qt is not sufficient: you must guarantee that your libraries (especially LevelDB) are bug-for-bug compatible with the ones used by everyone else. And not only the current versions, but every future version to ever hit the repository. This means a lot of additional work for the maintainers of the library packages, and the security team; for example, the security team must understand that they *cannot* deploy a critical security bugfix to LevelDB until someone competent has reviewed that it is behaviourally (including bug behaviours!) compatible with the versions in use everywhere else/previously. I think it is likely all this additional work/delays will be considered unacceptable to your library/security teams, thus using the bundled/embedded LevelDB is probably the best solution.
MIPS (and any other big endian architecture) has *always* failed on the Satoshi codebase, and will not be supported until someone has time to dedicate to fixing the numerous little-endian assumptions in the code. I have an incomplete port, but it isn't very high on my priority list to figure out what else it's missing.
Debian could probably get away with packaging Bitcoin-Qt and bitcoind as-is with no modifications, and not have any problems. It's only when you begin making modifications that it becomes a problem. There are also some concerns that it puts a much larger price on compromising Debian's build servers and/or repositories (suddenly the attacker can steal a LOT of money).
The official binaries are not simply built by upstream developers: using Gitian, *anyone* can produce bit-for-bit identical binaries. Official releases are only published after 3 or more people have done an independent compile and signed the output. It would be excellent if the whole of Debian could work toward achieving this level of security eventually, which would make distributing Bitcoin node software much safer as well.

@_date: 2013-07-23 23:45:26
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Linux packaging letter 
It was written with bitcoind/Bitcoin-Qt in mind, which don't work on BSD. :p
It should be portable to other systems, though hasn't been done yet.
Would be nice if the concepts it uses could be integrated into the package-
building systems.
The problem is that we require bugs. That is, if your library has those bugs fixed, you have introduced a security vulnerability.
There is no configure-time for this node software yet. The autoconf-based one in the works *does* make this check, however.
The review process is very slow and strict, but that is because of the same reasons it isn't safe to distribute patched versions in general. Merging your patches to mainline is not only a good idea, but it helps to ensure they get the necessary testing needed to be safe.

@_date: 2013-07-24 04:03:24
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Endianness (was: Linux packaging letter) 
I got the obvious stuff ('endian' branch in my repo), but it still didn't work when I moved on. I haven't had time to try to figure out why not yet.

@_date: 2013-07-29 05:17:53
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Opcode whitelist for P2SH? 
This would be reasonable for miners, but for interoperability between wallets, some specific standard forms would still be necessary without a much smarter solver (which would then expand the code required to implement a wallet, which is unfortunate if not entirely necessary).

@_date: 2013-06-06 19:14:17
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Proposal: soft-fork to make 
Data does not belong in the blockchain. People running nodes have all implicitly agreed to store the blocks for financial purposes, and storing data is a violation of that social contract. Proof-of-stake may be arguably financial, but I'm sure there must be a way to do it without spamming people against their consent.
The alternative is to make other standard outputs unable to store data as

@_date: 2013-06-06 20:07:38
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Proposal: soft-fork to make 
This doesn't work like you might think: first of all, the fees today are greatly subsidized - the actual cost to store data in the blockchain is much higher than most storage solutions. Secondly, only the miner receives the fees, not the majority of nodes which have to bear the burden of the data.
That is, the fee system is setup as an antispam/deterrant, not as payment for Not the same thing at all; nobody is forced to store/relay video/voice/images without reimbursement. On the other hand, any full Bitcoin node is required to at least download the entire blockchain once. And the network as a whole suffers if nodes decide to start not-storing parts of the blockchain they don't want to deal with.
This is how merged mining solves the problem. A single extra hash in the coinbase can link the bitcoin blockchain up with unlimited other data.
See above.

@_date: 2013-06-06 21:48:13
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Proposal: soft-fork to make 
Because payments are the only thing everyone using Bitcoin has agreed to use the blockchain for. Furthermore, there is no *reason* to store non-payments in the blockchain. If there was in fact such a use case, things might be arguable - but there isn't any I'm aware of.
The issue is using other peoples' resources for something they did not agree to use it for. The fees aren't merely "not enough", they were never *intended* to be "cost of storage". They are "cost of security" and "prevent spamming".
The concepts behind Bitcoin are applicable to future innovation, but this can all be accomplished without spamming Bitcoin itself.
Non-payments are quite possible without the Bitcoin blockchain itself. If you're worried that not enough people will store the alternative-non-payment data, then you are essentially saying that voluntary participation is not enough and that forced storage is your solution. I don't think this is what you intend...
The Bitcoin blockchain protocol has 95 bytes per block reserved for miners to put extra data. Currently, this is used for extranonces, political or other short messages (such as in the Genesis block), miner "signatures", and also, as I mentioned, merged mining. Merged mining works by tying a non-
transactional merkle tree to the blockchain. The block coinbase stores the hash of the top of this merkle tree, so any data within the merkle tree can prove it is associated to the block. The merged mining merkle tree then stores hashes of multiple other data sets: for example, a Namecoin block can be referenced in a merged mining merkle tree, to use the Bitcoin block's proof-
of-work for itself (so, miners can mine both Bitcoin and Namecoin using the same hashing effort). You could also add other non-transactional blocks to the merged mining merkle tree, for generic timestamping or really anything at all.

@_date: 2013-06-10 21:23:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Decentralizing mining 
This is basically done.
The plan was to tell the pool it doesn't need to send transactions at all, and only work on the ones from bitcoind. Currently, share submissions are just the block header and coinbase transaction; in this case, however, the miner will need to send merkle links also, possibly just once via a block proposal in Currently, BFGMiner is doing submission to the pool, waiting for a response, then submitting to a local bitcoind. This is because the pool might need to receive/record the share before it processes the block on bitcoind, or you could lose credit for it. The response from the pool is rather small (a single TCP packet), so this shouldn't delay much longer.
Might as well just use higher difficulty shares (each one audited) for the same effect. Block proposals allow the miner to tell the pool its transaction set once (per txset change) for any number of shares.
IF bandwidth becomes a real problem, I have a draft of a "GBT 2.0" that does some more improvement in this area.
I don't follow.
libblkmaker's API was designed for this from the start, so it should be fairly easily implemented.
Failover already functions, but probably could use a rewrite...

@_date: 2013-06-11 15:29:11
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Bitcoin addresses -- opaque or not 
This is true or false based on CONTEXT.
Obviously, an implementation of transaction handling (eg, wallets) needs to be able to translate addresses to and from what they represent.
On the other hand, things like URI handlers do not (and should not) try to interpret the address as anything other than an arbitrary word (\w+).
The wiki goes into much detail on how addresses work, which is not the concern of most software in the Bitcoin ecosystem, but may be of interest to humans and developers working on the one component that operates the "black box" that addresses are.
These aren't FALSE, they are "true at the moment, but subject to revision by newer standards".
I stated (on IRC) that it was likely Bitcoin would change from the base58 encoding for addresses ... at some unspecified time in the future, to some unspecified new encoding that addressed known limitations of base58. What those changes will be, or when, are not all established at this time. The only currently-planned change to addresses (very loosely defined) is inclusion of the Payment Protocol URIs. But the point is that software developers shouldn't assume that addresses will remain base58 forever.

@_date: 2013-06-14 21:05:28
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Decentralizing mining 
Share rate is relevant to more than user information - it also affects the variance of reward/payout. I disagree with claiming shares are found when they're not sent to the pool - this makes auditing and troubleshooting more difficult; for example, see the GUIMiner bug where it reports shares despite misinterpreting the pool's target and submitting nothing at all (this happens when the pool uses pdiff 1).
I don't understand the first two questions here at all.

@_date: 2013-06-14 21:10:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] is there a way to do bitcoin-staging? 
Note that the "earn a mixture of BTC and TBC, but not both in full volume" only works for TBC because the price is by definition fixed with BTC.
I'm not sure how you could implement something like this for an altcoin where the price is floating independently of Bitcoin.. that is, how you would know the right amount of Bitcoin to require sacrificed.

@_date: 2013-06-15 01:57:06
@_author: Luke-Jr 
@_subject: [Bitcoin-development] is there a way to do bitcoin-staging? 
Timestamping ("proof of existence") doesn't need a coin at all. Just collect all the hashes you need timestamped into a PoE merkle tree and add that to the merged mining MT. It's pretty simple and straightforward, just needs someone to implement it.

@_date: 2013-06-27 18:04:49
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Proposal: MultiBit as default desktop 
Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or MultiBit node. :/
Jim, will MultiBit be adding p2p listening support?
Possibly against: Does MultiBit still promote Bitcoin misunderstandings with misinformation like "from" addresses? (my apologies if I am remembering a different client)

@_date: 2013-03-11 19:35:54
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [PATCH] Change recommended fee to 0.001 
Please use GitHub pull requests (or at least publish a git repository) rather than mailing patches..
I'd suggest two commits for this:
1. Move the recommended fee outside the translatable string (bonus points to format it using the user's preferred unit)
2. Change the recommended fee in one place
Whether the recommended fee *should* be changed or not, I have no opinion on.
Eligius uses a lower minimum fee, but I believe most pools/miners will treat anything under 0.01 BTC as if it were no fee at all...

@_date: 2013-03-11 21:29:29
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [PATCH] Change recommended fee to 0.001 
eg, use a single %1 with
BitcoinUnits::format(walletModel->getOptionsModel()->getDisplayUnit(), amount)
Sounds reasonable.

@_date: 2013-03-12 12:10:32
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Some PR preparation 
I think we should be careful not to downplay the reality either.
For a number of hours, transactions could have received up to N confirmations and then still been reversed. While we could contact the bigger payment processors, I saw people still trying to buy/sell on OTC, whom could have been scammed even by taking standard precautions.

@_date: 2013-03-12 13:10:20
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Changing the fee on already sent 
Side note: Adding fees is already possible by respending change, at least for miners running an Eligius branch (both 0.6.0 and 0.8.0).

@_date: 2013-03-13 12:56:29
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.8.1 ideas 
Here's a simple proposal to start discussion from...
BEFORE block 262144:
- Never make a block that, combined with the previous 4 blocks, results in over 4500 transaction modifications.
- Reject any block that includes more than 4500 transaction modifications on its own (slight soft-fork)
- (these rules should make older clients safe under most circumstances)
FROM block 262144 to block 393216 (hard fork - Never make, and reject any block that includes more than 24391 transaction modifications on its own (this *should* be equivalent to 1 MB)
- (this rules can make older client backports safe unless a reorg is more than 6 blocks deep)
FROM block 393216 onward (hard fork - Never make, and reject any block that includes more than 48781 transaction modifications on its own (this *should* be equivalent to 2 MB)
- Accept blocks up to 2 MB in data size
- Discontinue support for clients prior to 0.8.1
I intentionally set the block numbers conservatively to try to account for the yet-unseen ASIC upgrade.

@_date: 2013-03-13 15:26:14
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.8.1 ideas 
I figured 2 MB in 2-3 years was fairly uncontroversial.
If not, let's scrap that idea for now.
It was a one-time "start the conversation" proposal.
I expect what we end up going with may be substantially different.

@_date: 2013-03-13 18:04:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.8.1 ideas 
Anything requiring widespread adoption of patched clients *is by definition* a hard fork.
This is a hard fork.
The only way to avoid a hard fork is to apply the existing lock limit to all clients forever. That would be fine, except that pre-0.8 clients cannot reorg N blocks without dividing that limit by (N * 2) + 1; that leaves us with the limit of around 1000 locks per block on average. Each transaction uses at least 3 locks on average (many times more). So about 300 transactions per block. This is a much smaller limit than the 1 MB we've been assuming is the bottleneck so far, and the need to increase it is much more urgent - as Pieter noted on IRC, we are probably already using more than that even ignoring DP spam. The only reason pre-0.8 clients have survived as well as they have thus far is because the blockchain has managed to avoid very deep reorgs.

@_date: 2013-03-13 18:08:17
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Blocksize and off-chain transactions 
While 0.7 and earlier do have issues, they also define the Bitcoin protocol. 0.8's failure to comply with the protocol is an issue.

@_date: 2013-03-13 20:18:23
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.8.1 ideas 
Curiously enough, at least MtGox's custom implementation stuck with the canonical blockchain despite 0.8's accidental rule change.
No, if any other client released diverged from the consensus of all past/existing clients, we would do the same thing: call it a formerly unknown protocol rule, that this new client has a bug implementing, and be done with The only reason this particular issue needs special treatment is because the implications of the new rule mean that we're up against a hard limit in the protocol today rather than 2 years from now.

@_date: 2013-03-15 19:23:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.8.1 ideas 
Note that the lock limits were explicitly set in the bitcoind source code.

@_date: 2013-03-17 15:29:37
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.8.1 plan 
OTOH, the page's recommended config isn't really too ideal. While the new lock limit should be good for up to 2 block deep reorgs, I doubt merchants/miners want to get stuck if someone pulls off a 3-block deep reorg. Since we usually consider 6 blocks to be "confirmed beyond impossibility of reversal", a limit of at least 292692 should probably be recommended. Additionally, I suspect set_lg_max may need bumping upward - but I'm not quite sure how to calculate the correct value there.
Why does the example config do set_lg_dir? That will screw things up should the client be using some other directory for any reason..
Also, please add a note that 0.4.x, 0.5.x, 0.6.x, and 0.7.x will be receiving backports in their next stable releases sometime before May 15.

@_date: 2013-03-23 14:52:20
@_author: Luke-Jr 
@_subject: [Bitcoin-development] A bitcoin UDP P2P protocol extension 
UDP is connectionless.
I would hope any UDP bitcoin protocol doesn't try to emulate a connection. :/

@_date: 2013-03-23 17:09:05
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Upcoming network event: block v2 lock-in 
I don't think anyone is mining using bitcoind 0.7 or later? Deepbit is the only pool I know of using bitcoind at all, and it's based on 0.3.21 (or about p2pool has supported v2 blocks since 2012 Aug 8.
Eloipool has supported v2 blocks since 2012 Sep 1.
slush's stratum server has supported v2 blocks since it was written.
I'm not aware of any other maintained open source poolservers.
At least PoolServerJ and ecoinpool are known to break when v2 blocks become

@_date: 2013-03-23 17:43:57
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Upcoming network event: block v2 lock-in 
Not for producing coinbases (where BIP 34 is implemented).

@_date: 2013-03-23 17:51:47
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Upcoming network event: block v2 lock-in 
Context is everything.
bitcoind is nowhere in the implementation of the miner end of BIP 34.

@_date: 2013-03-23 18:27:20
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Upcoming network event: block v2 lock-in 
Transaction selection and everything else bitcoind does, is irrelevant to BIP 34. It is incompatible with getblocktemplate for coinbase-creating software to produce v2 blocks without implementing BIP 34 themselves, even if the upstream GBT server specifies it.

@_date: 2013-05-15 06:33:28
@_author: Luke-Jr 
@_subject: [Bitcoin-development] RFC: c32d encoding 
This encoding is designed so that it could replace Base58Check in new data, with the following goals in mind:
- Impossible(?) to manipulate without completely changing it
- Clearly identifiable prefix, regardless of data size
- Cheaper to process (simpler and faster code; it's a power-of-two radix)
- Fixed length string for fixed length data
- More unambiguous (removal of chars 'isuvzSVZ')
- Compatible with using seven-segment displays
- Altcoin friendly (16 bit namespace, which can be read without decoding)
Since there are fewer digits and more identifying/signature characters, addresses are longer. This should be less of a problem since ordinary users will hopefully be using addresses less common as the payment protocol becomes more popular.
Example Python code (including tests) is attached.
I can write up a formal BIP if this seems useful.
For example:
160 bits of data, such as current addresses:
    2nc111dhAPE2aUdYAOF88JhLn5jEjbULy4eFe9tyFYFE8
An ordinary P2SH destination, incorporating Greg's "require the hash mid-image to be relayed" concept (256 bits of data):
    2bc511A95e74P13dPb6b5t7yrh12EhC363ayH98n1cFbr3rAHdA49nCcC1G3P71j
The same key in Namecoin:
    2nc5119ttL35HPhc3Hh6aHe2tOhF6rdFtAOE1ahFLt9Ecabhcn5FLea5Le71P56C
The example "puzzle" script from the wiki (arbitrary scripting):
    2bc311d126acCyAnHAjabeUtOHcr7F811j4UYE6ECtOcbcGGn4O9chAt7O7y2LU9ty9cnG4
An alternative for BIP32 extended public keys (560 bits):
    2bc911AcchHheAGFnn9LC6FdF7bOc99APJtcEc46U655JheH6LCr3Y333eFEOtPJ9rj22rEcchHheAGFnn9LC6FdF7bOc99APJtcEc46U655JheH6LCr3YJCtPYea
An alternative for BIP32 extended private keys (552 bits):
    2bcb11O77GHdP53FH7Jh44OdEh3rLd4eFr2h7c8rGeErELG18yCy9O7L9LednyHJa5hyeAP77GHdP53FH7Jh44OdEh3rLd4eFr2h7c8rGeErELG18yCyGG5drPF1

@_date: 2013-05-20 07:12:16
@_author: Luke-Jr 
@_subject: [Bitcoin-development] is there a way to do bitcoin-staging? 
This sounds similar to the "bitcoin2" branch I created a while back - basically a "next"-like branch, but for hardforking changes that refused to run without the -testnet option. There's so much non-hardforking code that can be written/tested, at this point, that I think it was and maybe is premature to be writing hardforking code outside of necessity. But perhaps if you want to play around, it might be a good starting point (it can probably merge up to latest master, and trivial to rebase if not).

@_date: 2013-05-21 04:04:28
@_author: Luke-Jr 
@_subject: [Bitcoin-development] UUID to identify chains (payment protocol 
Bitcoin currently uses raw hashes extensively as UUIDs; whether the payment protocol should be influence by that or not, I've not given thought to yet.
Some alt coins may share a blockchain, or even merely the genesis block (two currently do; despite one of those being a scamcoin, I think the possibility should not be dismissed). Because of this, requiring a 1:1 mapping between genesis block and chain or coin seems non-ideal.

@_date: 2013-05-22 14:29:47
@_author: Luke-Jr 
@_subject: [Bitcoin-development] UUID to identify chains (payment protocol 
In some cases, multiple currencies can use the same blockchain (not just the singular genesis block). This use case *is* something we want to encourage - no reason for people to make an entirely new blockchain if their altcoin fits within the scope of Bitcoin or another existing altchain.

@_date: 2013-05-25 04:03:43
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Tentitive port for FreeBSD 
Would be nice if you could help test (and use?) the pull request for system LevelDB support: Note that you should be careful to tie your port to the specific LevelDB version bundled, to avoid any risk of unexpected hardforking bugs or fixes in upstream LevelDB.
For the other patches, please try to find a portable solution (if they aren't already) and open pull requests on github.

@_date: 2013-05-25 08:53:17
@_author: Luke-Jr 
@_subject: [Bitcoin-development] (no subject) 
Bitcoin is a consensus system. You can't run clients with different rules on the same blockchain/network - it just won't work! Maybe we're now talking about mere client default policies? In which case, you should be able to configure previous behaviour...
If you want just bug fixes and rule changes, without policy default changes, new features, etc, you can use the 0.4.x - 0.7.x backports. But be advised these are short-term solutions and won't be maintained forever - so you really should try to get the behaviour you want from the current release. If you can't for some reason, please do report a bug explaining what it is the older version was capable of that the new one isn't!

@_date: 2013-05-26 23:53:57
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Modularizing Bitcoin 
How is this different from what Electrum has already done?

@_date: 2013-05-26 23:57:10
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Modularizing Bitcoin 
This sounds accurate for listening nodes, and similar to what my own system counts: Of course, it doesn't include the (many?) connect-only nodes (eg, mobile or firewall/NAT'd) or non-p2p nodes (eg, Electrum).

@_date: 2013-05-30 02:57:06
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 0.8.2 branch 
I'll branch 0.8.x sometime in the next few weeks.
Stable branches are maintained on Gitorious for now:

@_date: 2013-11-02 05:54:28
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Message Signing based authentication 
Congratulations! You've reinvented what Eligius and Bitcoin-OTC have been doing for years! :)
There's no reason to ask the user to provide the address every time, though...

@_date: 2013-11-03 00:33:55
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Message Signing based authentication 
Well, there's no use case to sign with an address that has already been sent coins. The main problem with enforcing this is that you can't exactly stop someone from sending to an "identity" address.

@_date: 2013-11-03 01:27:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Message Signing based authentication 
Use cases mean an actual use, not mere laziness. Bitcoin as a system has always required a unique EC key (and address) for each transaction.

@_date: 2013-11-09 20:30:28
@_author: Luke-Jr 
@_subject: [Bitcoin-development] idea 
This mailing list is for development discussion, NOT bug reports nor feature Bitcoin does not currently support any built-in mechanism for conveying the sender of a transaction nor notes. It is advised to collect any such information you need before giving someone a payment address.

@_date: 2013-11-14 23:01:38
@_author: Luke-Jr 
@_subject: [Bitcoin-development] moving the default display to mbtc 
I wonder if it might make sense to bundle some other terminology fixups at the same time.
Right now, Bitcoin-Qt has been using the term "confirmations" (plural) to refer to how many blocks deep a transaction is buried. We also use the term "confirmation" to refer to the point where a transaction is accepted as paid. IMO, the latter use makes sense, but the former leads to confusion especially in light of scamcoins which abuse this confusion to claim they have "faster confirmations", implying that the actual confirmation occurs faster when it really doesn't. "5 blocks deep" may not be more clear to laymen, but at least it makes it harder for people to confuse with actual confirmation.
I think we all know the problems with the term "address". People naturally compare it to postal addresses, email addresses, etc, which operate fundamentally different. I suggest that we switch to using "invoice id" to refer to what is now known as addresses, as that seems to get the more natural understanding to people. On the other hand, with the advent of the payment protocol, perhaps address/invoice id use will die out soon?

@_date: 2013-11-14 23:10:32
@_author: Luke-Jr 
@_subject: [Bitcoin-development] moving the default display to mbtc 
As long as we're using SI units, IMO we should stick to SI. That means "micro-
bitcoins". *Informally/spoken*, an abbreviation like "mibicoins" might make

@_date: 2013-11-14 23:13:59
@_author: Luke-Jr 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Keys are often reused, so not sure that conveys the single-use much better.
Reason I suggested invoice id is because nobody wants to pay the same invoice

@_date: 2013-11-15 00:15:58
@_author: Luke-Jr 
@_subject: [Bitcoin-development] moving the default display to mbtc 
To be clear, I wasn't suggesting renaming scriptPubKey, which sipa was talking about with "key id"; just the destination-for-transaction presented to

@_date: 2013-11-16 01:10:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] moving the default display to mbtc 
"Confirmations" in a numeric context isn't correct, though. We're using to it because we've been using Bitcoin so long, but to the average person they would expect it to mean something more than it is. If not referring to blocks, then perhaps "witnessed N times"?
I think you might be demonstrating my point with regard to user confusion here. Bitcoin addresses are *not* like email addresses, paypal ids, etc. Bitcoin addresses aren't the destination - they're point to a destination (an account in a wallet), but they also represent information such as who is paying and what for - in other words, a specific invoice.

@_date: 2013-10-19 22:29:19
@_author: Luke-Jr 
@_subject: [Bitcoin-development] 
=?iso-8859-15?q?source=09community?=
See BIP 1 for the process.. proposals go to this mailing list first.

@_date: 2013-10-21 19:47:58
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
Probably wouldn't hurt, but it'd likely need a rewrite in a more modular and formal form.
Since it's the same format, I'd keep it up there, maybe with a link to the git repo on the main BIP index wiki page.
It's a hardforking protocol change, so IMO yes.

@_date: 2013-10-23 21:49:00
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Revisiting the BIPS process, a proposal 
Thankfully, miners are incentivised to run one of every widespread node to ensure their blocks are accepted by the network. Eloipool already supports cross-referencing block templates between multiple clients and using the one that is accepted by most/all (and logging any discrepancies with coredump-like

@_date: 2013-10-24 21:55:22
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Proposal to replace BIP0039 
BIP 39 is still a draft. Just suggest revisions to the author(s)...

@_date: 2013-10-26 03:41:40
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Payment protocol for onion URLs. 
Is there any point to additional encryption over tor (which afaik is already encrypted end-to-end)? Is there a safe way to make this work through tor entry It'd be nice to have a way to support namecoin-provided keys too...

@_date: 2013-10-27 14:39:51
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Feedback requested: "reject" p2p message 
Sounds like the real bug is "BitcoinJ relies on good/servant behaviour from other nodes". Don't assume your random node isn't hostile. Handling a peer that doesn't relay your transaction for any reason (including if they lie to you about having done so) should be expected behaviour.

@_date: 2013-10-28 02:59:38
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Feedback requested: "reject" p2p message 
It might make sense to use the rejection reasons from BIP 22 where applicable.

@_date: 2013-09-07 23:33:52
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Blockchain archival 
There's no reason to require the full blockchain download before being up and running. Bitcoin-Qt 0.9 will (probably) have Pieter's work in this area to be usable very quickly, and download/verify the history in the background (there's no way to be completely trust-free without this).
Not sure what you mean here. Addresses and wallets are two completely different things. Addresses are single-use destinations that point to a wallet (which is itself private and unknown to the network).

@_date: 2014-04-01 19:12:22
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Finite monetary supply for Bitcoin 
I cleaned it up a bit. By 2214, we should be using tonal numbers after all:

@_date: 2014-04-01 19:19:01
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Finite monetary supply for Bitcoin 
Please, *music* is obsolete, but inline replies *are not*!

@_date: 2014-04-12 14:43:58
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Ubuntu LTS Packaging? 
This mailing list is for development, not support.
The PPA you linked has 0.9.0, which is the latest relevant version for

@_date: 2014-04-23 19:44:13
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
Why do clients need to use the features in BIP 64? If Electrum doesn't want to use accounts, then it can just use account 0 for everything. Refund chains are definitely a third case that should be added to the external and internal/change address division... and a wallet not implementing refund addresses would simply not use that chain.

@_date: 2014-04-23 19:55:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
Any wallet should import all the coins just fine, it just wouldn't *use* any account other than 0. Remember addresses are used to receive bitcoins; once the UTXOs are in the wallet, they are no longer associated with the address or any other details of how they were received.

@_date: 2014-04-23 20:01:05
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
Yes, it should scan all possible (under the BIP-defined structure) branches regardless of which features it supports.

@_date: 2014-04-23 20:02:11
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
No it doesn't... Just the assigned scriptPubKey and secret(s) required to satisfy it.

@_date: 2014-04-23 20:09:07
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
Scan all branches for UTXOs, then you have the balance for the wallet. Account balances are metadata, so cannot be known from the seed alone. If you want to have a way to restore accounts, you must define some more detailed wallet file format (which could be built on top of this).
Sure, it *knows* what address was used to receive it. But at the point it's a UTXO, that address is no longer relevant.

@_date: 2014-04-23 20:32:07
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
You missed one:
f) I missed the part where BIP 32 redefined "account" to mean "subwallet" instead of what has traditionally been called "account" in Bitcoin.
In that case, single-subwallet wallet software probably needs to have the user provide a subwallet number in addition to the seed.

@_date: 2014-04-23 20:41:13
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
It is. Accounts have been a bitcoind feature since before 0.4.
I don't see how. The user knows he has money in different subwallets. As long as he has a way to specify which subwallet he is accessing in single-subwallet clients, there shouldn't be a problem.

@_date: 2014-04-23 20:59:08
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
Then BIP 64 is pretty restrictive. Most end users really have no need for subwallet support.

@_date: 2014-04-23 21:18:57
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
How do you get the more expected/usual behaviour of mixing funds between accounts? Only a very niche user base needs funds isolated...

@_date: 2014-04-23 21:53:05
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New BIP32 structure 
Only by crossing the blockchain unnecessarily.
To keep balances separated. For example, I might have an account for each of my children, move their allowance money to it every day/week (off-chain), and they can spend only what they have in their account. Or an exchange might have an account for each user's deposits. In neither case, would it make sense to pay special attention to which UTXOs are consumed in transactions from any of the account.
The only use case that requires tracking UTXOs per-account is when you want to have multiple uncoordinated copies of the wallet in use at the same time, and therefore need to immediately identify which account a transaction came from based on the UTXOs it consumed - although even then, you could still mix funds as long as you use only the first UTXO for tracking, so maybe there isn't even a niche use case! In any case, Trezor, being a hardware wallet, should never overlap with this niche...?
Bad analogy. Banks *always* mix funds. You don't expect your bank wire to use exactly the specific dollar bills you deposited, do you??

@_date: 2014-04-25 19:17:48
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP - Selector Script 
I believe you meant to link here instead?
    This looks reasonable from a brief skim over, but does not define any use cases (it mentions "necessary for atomic cross chain transfers", but does not explain how it is useful for that - perhaps that belongs in another BIP you haven't written yet, though). IMO, it should also require P2SH.

@_date: 2014-04-25 19:18:43
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP - Hash Locked Transaction 
This one looks entirely useless (it cannot be made secure), and the assertion that it is necessary for atomic cross-chain transfers seems unfounded and probably wrong...

@_date: 2014-04-25 20:26:55
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP - Selector Script 
I think you may be misunderstanding what BIPs are. They do not force nodes to take on any given relay/mining policy (thus, BIPs should never talk about IsStandard at all). They define standard for interoperability between software. So, if you want nodes to relay these transactions, you need to convince them, not merely write a BIP for the transaction format. Defining a BIP for cross-chain trading would be one way to do that.
The malleability "issue" has been known for years.
I wouldn't expect any special effort made to fix it...
There is some ongoing discussion of a softfork to basically redo the Script language entirely, but it will take quite a bit of time and development before we'll see it in the wild.
P.S. Did the BIP editor assign these numbers? If not, best to keep them numberless until assigned, to avoid confusion when people Google the real BIP 44 and 45...

@_date: 2014-04-29 19:14:59
@_author: Luke-Jr 
@_subject: [Bitcoin-development] GBT 2.0 wishlist 
Let's try to get GBT 2.0 off the ground finally.. :)
Here's some wishlist items/ideas:
- Extremely low bandwidth use (binary protocol, with compression support)
- UDP-based transport protocol? (so message order need not be preserved at the
  expense of latency)
- Ability to instruct miners to insert (username,hash-of-username,hash-of-
  options-array,hash-of-both,etc) in coinbase at a given position (this
  enables cheaper proof-of-work auditing of a pool's rewards; it can just
  save/publish shares meeting higher targets and anyone can verify the shares
  were found by a given username/hash)
- Always encrypted (once by the server), with optional authentication via
  CA/namecoin/URI
- Incrementing "precommit id" so miners can precommit to settings without   needing a new/custom coinbase
- Multiple clients should share bandwidth on a LAN (similar to slush's stratum
  proxy)
- Convey prevblock as block header so we can follow blockchains securely.
- Fee logic: pools can claim as much coinbase distribution as they require
  (with hint from miner); miners are expected to ensure subsidy + transaction   fees tally up to the required total; any fees beyond requires total may be
  distributed as the miner wishes. Potentially, pools could allow 50% (or
  similar) participation allowing a miner to use multiple pools at the same
  time.
Rather than polluting the main development mailing list with what is sure to have quite a bit of discussion, I have asked kinlo (who hosts the poolowners mailing list) to provide a dedicated list for this purpose. Interested parties should please subscribe via  and send replies to gbt2 at list.pfoe.be (once a draft BIP is ready, the main dev mailing list will be once again CC'd).

@_date: 2014-04-30 18:59:07
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] BIP Draft: Atomic Cross Chain Transfer 
Instead of TX0, TX1, etc, can you put some kind of meaningful identifier for these transactions?
TX1 and TX2 *cannot* be signed until after TX0 is completely signed by both parties. After TX0 is signed, but before TX2 is signed, either party could walk away or otherwise hold the funds hostage. The sequence of signing proposed in this BIP is *not possible to perform*. How did you implement and test this? :/
What is the purpose of the OP_EQUAL_VERIFY in TX4? I don't see a use...
IMO, there should be separate BIPs for the exchange itself, and the protocol to negotiate the exchange. I would recommend changing the latter from JSON-RPC to some extension of the Payment Protocol, if possible.
Perhaps it would be good to only support compressed keys, to discourage use of uncompressed ones..

@_date: 2014-08-07 23:45:44
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Miners MiTM 
This is old news; both BFGMiner and Eloipool were hardened against it a long time ago (although no Bitcoin pools have deployed it so far). I'm not aware of any actual case of it being used against Bitcoin, though - the target has always been scamcoins.

@_date: 2014-08-08 01:01:15
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Miners MiTM 
Certificate validation isn't needed unless the attacker can do a direct MITM at connection time, which is a lot harder to maintain than injecting a client.reconnect. This, combined with your concern about up to date certs/revokes/etc, is why BFGMiner defaults to TLS without cert checking for

@_date: 2014-08-08 18:27:29
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Miners MiTM 
My thought for GBT2 a while ago was to use simple ECDSA signatures for messages. It'd be nice to use the same as Bitcoin, but then we'd hit problems with RedHat/Fedora legal being stupid. :(

@_date: 2014-08-23 19:02:55
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Proposal: Encrypt bitcoin messages 
As soon as you tell it to an unknown/public peer, it is public information.

@_date: 2014-12-04 15:42:42
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Serialised P2SH HD chains 
Is anyone working on a serialisation format to convey P2SH HD chains? For example, to give someone who wants to make recurring payments a single token that can be used to generate many P2SH addresses paying to a multisig script.
I'm thinking of something along the lines of a simple series of tokens, each indicating either a HD chain or literal script content. For all HD chains in the data, a child key would be generated based on the payment number, and all tokens concatenated to form the P2SH serialised script. Eg, for a simple 2-
of-2, you would do something like this:
    literal(OP_2) HDChain HDChain literal(OP_2 OP_CHECKMULTISIG)
Does this sufficiently cover all reasonable use cases?

@_date: 2014-12-04 21:10:14
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Serialised P2SH HD chains 
This requires the payee operate a server. My use case is for payment to individuals, who may or may not have a computer powered at the time of the transactions being sent. Furthermore, the users I am targeting (miners, to be specific), wish to remain entirely anonymous, and not hold accounts of any This depends on the framework. As of present day, miners are limited to only use a single address ever, and cannot change it even to avoid address reuse. One goal is to solve that, without breaking multisig.

@_date: 2014-12-29 22:35:04
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] BIP: Voluntary deposit bonds 
This is something I've wanted since 2011, but hasn't been a priority.
I'm not sure this increases the priority of it.
If someone feels it's worth the time, I'd suggest coding up a branch that hardforks it in at some far-off block height. Even if it doesn't get merged right away, at least the code will be available for testing and ready to go when/if that time comes.

@_date: 2014-12-29 22:36:48
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] BIP: Voluntary deposit bonds 
Pay-to-fee transactions can be "stolen" by another block at the same or greater height. Additional inputs to the generation transaction are tied to that block alone.

@_date: 2014-02-09 17:25:41
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Embedded consensus system upgrade 
This asserts a central authority and gives developers too much power.

@_date: 2014-02-10 04:39:28
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with 
Rule 3 & 4 are already enforced.
AFAIK nVersion==3 transactions are not currently considered non-standard?

@_date: 2014-02-12 22:52:30
@_author: Luke-Jr 
@_subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with 
This would be a problem if it was used in the merkle tree, but I'm pretty sure using it for input selection would be pretty safe. One could even avoid the index by simply using the hashScript as the sole input value; then even CoinJoins would be safe without breaking chains of transactions (although this would break address reuse entirely - but I don't see that as a problem in a theoretical world). One of those things that an altcoin could improve upon Bitcoin with... ;)

@_date: 2014-02-24 23:13:38
@_author: Luke-Jr 
@_subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release 
Perhaps I ought to redo my data carrier configuration option as a max size?

@_date: 2014-01-01 05:09:27
@_author: Luke-Jr 
@_subject: [Bitcoin-development] The insecurity of merge-mining 
Not necessarily. If Zerocoin was tied directly to Bitcoin proof-of-work, the worst they could do is not-participate by mining empty blocks.
Potentially slow confirmation is also the only shortcoming of using Bitcoin's proof-of-work directly.

@_date: 2014-01-16 15:23:37
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Bitcoin Core 0.9rc1 release schedule 
These are pretty much all well-tested and stable for months now.

@_date: 2014-01-17 05:40:52
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Suggestion: allow receivers to pay 
If you did it and relayed directly to Eligius, it'd probably get mined.. the hard part is creating the transaction - once that's done it's smooth sailing Side note: mining nodes should *not* be running mainline. In fact, they should be setting up their own customised transaction policies.

@_date: 2014-01-17 18:41:36
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Bitcoin Core 0.9rc1 release schedule 
I'll try to get this done over the weekend.
Can you elaborate on this? I can see how Proposals might, if buggy, affect consensus, but the rest shouldn't. I don't think there's anything controversial in any of these (does someone disagree with CPFP?).

@_date: 2014-01-17 21:31:15
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Bitcoin Core 0.9rc1 release schedule 
Heck, even I disagree with implementation details, but it's still better than nothing. We can always merge major reorganisations/reimplementations later when they're written: merging this one doesn't mean we're stuck with it

@_date: 2014-01-20 20:02:27
@_author: Luke-Jr 
@_subject: [Bitcoin-development] BIP0039: Final call 
How are they compatible if they could be using entirely different word lists??
Maybe I'm missing something, but shouldn't this be a client-side thing, not implemented in the Trezor firmware at all?? O.o;;

@_date: 2014-07-04 20:38:30
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] ASIC-proof mining 
Really, if people want to pursue a goal anything like this, they should be looking for "ASIC already widely owned" as the property rather than "anti-
ASIC". Thus, a sufficiently memory-hard PoW would really be "RAM is the ASIC". Whether it's possible to make this or not, is another question. And then we get back to "is is really a desirable property to have people capable of mining who have not given any indication of interest?"

@_date: 2014-07-15 14:48:55
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
I agree this would be useful for the "permit" case, but not the "confirm" case - it's important that transactions valid in block X also be equally valid in block X+1 to avoid reorg issues.
This would force every wallet to keep an index of all TXOs ever.
Actually, I think this may make address reuse easier, as with base58 adding data will make it impossible to tell at a glance when someone is reusing a key with just a different expiration... I suppose something other than base58 *could* be used to resolve this, however.
They can already do this. It's perfectly valid for wallets/services to ignore (and not consider as payment) transactions using an address more than once. There might be race attacks if this is implemented in an immediate fashon (attacker transaction gets mined first to kill a payment), but should be pretty safe after a few blocks.

@_date: 2014-07-15 15:41:52
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Bitcoin address TTL & key expiration? 
There's no reason deposits cannot use a unique payment request or address every time...

@_date: 2014-06-03 04:52:39
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Lets discuss what to do if SHA256d is 
C) fabricate past blocks entirely.
If SHA256d is broken, Bitcoin as it is fails entirely.

@_date: 2014-03-03 06:04:44
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Procedure for non-tech contributions 
We've been working on moving the wiki to new hosting, but it isn't a very high priority (at least for MtGox). PM SomeoneWeird on IRC, as he is currently handling manually approving new accounts for editing.

@_date: 2014-03-03 06:09:01
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New to this list 
Unit tests. This will be valuable to the projects and also help you learn how things work.

@_date: 2014-03-08 19:34:10
@_author: Luke-Jr 
@_subject: [Bitcoin-development] New side channel attack that can recover 
No need, it is not an issue for Bitcoin.
Properly used, there is only ever one signature per public key.

@_date: 2014-03-13 17:48:17
@_author: Luke-Jr 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Please don't bring locale into this. Bitcoin has always been intentionally locale-independent (hence BTC using xxx,xxx,xxx.xx format even in locales which swap the commas and periods). Localising display makes different locales more or less incompatible at a human level, even if they use the same

@_date: 2014-03-24 21:17:13
@_author: Luke-Jr 
@_subject: [Bitcoin-development] Handling miner adoption gracefully for 
There's been at least one public miner-oriented fork of Bitcoin Core since 0.7 or earlier. Miners still running vanilla Bitcoin Core are neglecting their duty to the community. That being said, the more forks, the better for

@_date: 2014-05-03 02:38:10
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] moving the default display to mbtc 
Huh? Your examples demonstrate the *opposite* of your point. 'k' and 'M' *are* the SI prefixes. People *do* use 63k USD, $63k, and $3M. I'll be the first one to admit SI is terrible, but I don't understand your argument here.
P.S. Note that SI units haven't actually ever been adopted, except by force of law. "Name me ... that uses SI" is a silly thing to say, since virtually all naturally-or-freely-adopted units of any measure have been based on a number that factor to twos and threes (not fives, like decimal).

@_date: 2014-05-15 18:05:29
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] DNS seeds unstable 
FWIW, this may be a routing issue: I notice various ISPs have been unable to route to my server over IPv4 today. IPv6 seems to be fine.
Not sure how important DNS seed reliability is anyway; it's just bootstrapping, and there are multiple servers listed.

@_date: 2014-05-16 21:46:00
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] DNS seeds unstable 
jun.dashjr.org has resolved 130 requests in the past ~12 hours, and I can see it resolving more in tcpdump. I do observe two potential problems, however:
- For the past 24-48 hours, there seem to be some significant routing problems on the IPv4 internet, resulting in people using various diverse ISPs (including myself at home) being unable to route to any of my servers. This issue doesn't affect IPv6, however.
- The DNS seeder seems to only be responding to requests received over IPv4. This means IPv6 DNS servers get no response. :(

@_date: 2014-11-16 17:24:18
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Increasing the OP_RETURN maximum payload 
Mining policies such as this is always up to miners.
It's not a development topic.
This one seems uselessly inefficient. Protocols needing OP_RETURN could just as easily look for an independent push opcode in a single OP_RETURN output.
I don't care strongly, but IMO this kind of focus on defaults is part of the problem. I'd prefer to have the default be randomised to incentivise miners to make the decision they're supposed to be making, rather than pushing the responsibility onto developers to set defaults.
Right now, this policy requires code hacks. Of the three ideas, this one looks the most ripe for code changes (particularly one that makes it possible to configure this policy, not hardcoding it).

@_date: 2014-10-01 18:23:55
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] [BIP draft] CHECKLOCKTIMEVERIFY - Prevent 
Thoughts on some way to have the stack item be incremented by the height at which the scriptPubKey was in a block? A limitation of encoding the target height/time directly, is that miners may choose not to mine the first transaction until they can also take the "burn to fee". So, one may prefer to say "cannot be spent until 100 blocks after the first transaction is mined", in effect reproducing the generation maturity rule.
I propose any stack item under 0x40000 be incremented by the height at which the scriptPubKey was mined for comparison. Maybe there is a use case for doing something similar for time too?

@_date: 2014-10-02 00:55:36
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] 
=?utf-8?q?FY_-_Prevent=09a_txout_from_being_spent_until_an_expiration_tim?=
 =?utf-8?q?e?=
This sounds do-able, although it doesn't address using timestamps.
For many use cases, short maturity periods are just as appropriate IMO.

@_date: 2014-10-03 17:50:26
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] [BIP draft] CHECKLOCKTIMEVERIFY - Prevent 
This cannot be done in a softfork.
Furthermore, "output can ONLY be spent until a certain time" contradict's Bitcoin's present security assumptions: that assuming a honest sender, the transaction will remain valid and simply re-confirm if a reorg kicks it out.

@_date: 2014-10-12 09:44:21
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Request for review/testing: headers-first 
It shouldn't... he's talking about actual orphan blocks (ones without a known previous/parent block), not stale blocks.

@_date: 2014-10-16 04:36:51
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Proposed BIP status changes 
Shouldn't we be doing this in a GitHub PR rather than spamming up the ML?

@_date: 2014-10-16 04:41:18
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] BIP process 
I've been using  for BFGMiner announce/dev mailing lists for a while. I don't know what software it runs, but it works.
Catch is that we'd need to go through Savannah's free software auditing.
That might be a good idea anyway?

@_date: 2014-10-26 08:53:37
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Bitcoin Core 0.10 release schedule 
At the very least, we need:
   Bugfix: submitblock: Use a temporary CValidationState to determine ...
   CreateNewBlock and miner_tests: Also check generated template is ...
   Bugfix: CreateNewBlock: Check that active chain has a valid tip ...
        (or at least some conclusion for the problem discussed therein)
Harmless/No reason not to have:
   RPC: submitblock: Support for returning specific rejection reasons
   Support for BIP 23 block proposal
   Qt: Elaborate on signverify message dialog warning
   Introduce CNodePolicy for putting isolated node policy code and ...
        (futher commits exist that should ideally get in after this is merged)
Debatable (but harmless, and miners seem to want it):
   Enable customising node policy for datacarrier data size with a ...

@_date: 2014-09-28 17:03:50
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] replace-by-fee v0.9.3 release 
Do you have or can you provide a version compatible with CPFP, such that a child paying a higher fee trumps the parent's replacement?
Preferably something that will merge cleanly into 0.9.x-ljr :)

@_date: 2015-08-10 18:40:58
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Alternative chain support for payment protocol 
No, accidental. I'll re-CC it on this email.
Regtest isn't really a network at all, just a testing mode of Bitcoin Core...
Is that a bad thing?
Sorry, I meant to stress that BIPs are for *Bitcoin* improvements specifically. Things which only improve altcoins, while a perfectly fine thing to standardise, are outside the scope of what belongs in a BIP.
Perhaps, however, this could be made to kill 2 birds with one stone, by ensuring it addresses the need for payments made of bitcoins on a sidechain?
For this, a merchant who wants a sidechain payment would presumably be able to provide a script from the main chain already, but an extension allowing payment directly on the sidechain (at the customer's choice) avoids the need to round-trip it...

@_date: 2015-12-08 23:48:53
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Capacity increases for the Bitcoin system. 
On Tuesday, December 08, 2015 11:40:42 PM Jonathan Toomim via bitcoin-dev This has never been guaranteed, nor are softforks a "dev action" in the first How about we pursue the SegWit softfork, and at the same time* work on a hardfork which will simplify the proofs and reduce the kludgeyness of merge-
mining in general? Then, if the hardfork is ready before the softfork, they can both go together, but if not, we aren't stuck delaying the improvements of SegWit until the hardfork is completed.
* I have been in fact working on such a proposal for a while now, since before There isn't an option for "no data", as non-upgraded nodes in a hardfork are left completely vulnerable to attacking miners, even much lower hashrate than the 51% attack risk. So the alternatives are:
- hardfork: complete loss of all security for the old nodes
- softfork: degraded security for old nodes

@_date: 2015-12-30 17:10:25
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Draft] Decentralized Improvement Proposals 
The premises in Motivation are false. BIPs are required to have a reference implementation, but that implementation need not necessarily be for Bitcoin Core specifically.
The specification itself looks like an inefficient and bloaty reinvention of version bits.

@_date: 2015-12-30 23:47:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Draft] Decentralized Improvement Proposals 
That should probably be clarified in the BIP, I agree. Perhaps it ought to be assigned the same as BIP numbers themselves, by the BIP editor? (Although as a limited resource, maybe that's not the best solution.)
I don't think that's possible. First of all, a hardfork can always occur, since this is something done by the economy and not (even possibly opposed to) miners. Furthermore, consider the change affecting how further rule changes are made, such as a PoW algorithm change.

@_date: 2015-02-06 04:08:42
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] [SPAM] Re: determining change addresses using 
This uses more data.
Why not just round change down (effectively rounding fee up)?

@_date: 2015-02-12 22:13:33
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] BIP for deterministic pay-to-script-hash 
Where is the Specification section?? Does this support arbitrary scripts, or only the simplest CHECKMULTISIG case?

@_date: 2015-02-15 00:05:24
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] On Rewriting Bitcoin (was Re: 
You can describe 'A' from a group of A, B, C, D, E as "the group minus B, C, D, E", sure - but I don't see how this is relevant?
UTXO storage is indeed consensus critical, as you say, but it is a lot simpler to get right than the rest combined. Thus, the end goal is to have a libbitcoinconsensus with "the rest", and a (as of yet named) libbitcoincompleteconsensus that ties in the canonical UTXO storage. Ideally, software should use the latter when it is available, but if there is a strong reason to change UTXO storage, one can remain mostly-safe with just the former. I'm not sure why this topic is of relevance, though...

@_date: 2015-07-06 04:24:55
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] REQ BIP # / Discuss - Sweep incoming unconfirmed 
No, this is correct. It's just not included in the reference policy.
Miners are not expected to use the reference policy as-is, and some of them do in fact use CPFP.

@_date: 2015-07-10 21:10:32
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Why not Child-Pays-For-Parent? 
AFAIK the only thing holding it up is lack of unit tests. If anyone would like to implement those, I expect it'd be merged fairly soon. Then the problem is, as Jeff mentioned, getting the parent transactions relayed despite failing relay policy on their own.

@_date: 2015-07-17 20:29:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 102 - kick the can down the road to 2MB 
I'm concerned that miners are prematurely bumping their soft limit to 1 MB lately. The only reason block size limit lifting is remotely reasonable is if we can trust miners to at the very least keep their soft limits set at a manageable size, but this assumption appears to already be failing in We are unlikely to approach 1 MB of actual volume by November, so I would prefer to see the activation date on this moved later - maybe November 2016, if not 2017. It would also be an improvement to try to follow reasonably-
expected bandwidth increases, so 15% (1.15 MB) rather than doubling. Doubling in only a few months seems to be far from a "conservative" increase.
If we can get some kind of commitment from miners not to move their soft limits beyond 1 MB until some future-agreed-on point, maybe the BIP is acceptable as-is.
Hardforks are not something where voting makes sense. They need consensus among /nodes/, not majority among /miners/. No hardfork has ever had such a

@_date: 2015-07-25 19:51:53
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Draft: Minimum Viable TXIn Hash 
This looks like just a p2p protocol optimisation, which doesn't even need a softfork. You do need to document the suggested protocol changes more specifically, however.

@_date: 2015-06-06 15:18:18
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
It's also not secure, since the signed messages only prove ownership of the address associated with the private key, and does not prove ownership of UTXOs currently redeemable with the private key, nor prove past UTXOs spent were approved by the owner of the address.
This appears to be incompatible with CoinJoin at least. Maybe there's some clean way to avoid that by using  ?
I also agree with Pieter, that this should *not* be so cleanly compatible with Bitcoin transactions. If you wish to share code, perhaps using an invalid opcode rather than OP_RETURN would be appropriate.

@_date: 2015-06-06 22:01:08
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] BIP for Proof of Payment 
Why not have it be -1 to make it completely invalid as a transaction?

@_date: 2015-06-12 23:11:43
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] User vote in blocksize through fees 
Just simplify this? Allow a miner to have their block counted as  votes for X provided not a single transaction they include votes against it. Then miners can explicitly forego the fees of opposing transactions without having to bloat blocks.

@_date: 2015-06-16 03:41:09
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] The Bitcoin Node Market 
SPV isn't the "right" way either ;)
If you're running a full node (the real "right way"), you should be able to earn more bitcoins than you pay out.

@_date: 2015-06-20 03:48:05
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] F2Pool has enabled full replace-by-fee 
They never will be. You can get a decent rate of success merely by making one transaction propagate fast (eg, 1 input, 1 output) and the other slow (eg, 1000 inputs, 1000 outputs) and choosing your peers carefully. The only reason unconfirmed transactions aren't double spent today is because nobody is seriously *trying*.

@_date: 2015-06-29 05:40:25
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: Full Replace-by-Fee deployment schedule 
Policy is node/miner fiat and not the domain of BIPs.

@_date: 2015-06-29 05:51:55
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: Full Replace-by-Fee deployment schedule 
Then we are to start issuing a new BIP for every node's policy? This has no end - though it might make sense for an independent and updated database. Mixing protocol standards with policy suggestions makes a very risky situation where one can potentially hold a miner liable for not enforcing the BIP; ie, government regulation of Bitcoin itself. I don't think most people want to go

@_date: 2015-06-29 06:00:49
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: Full Replace-by-Fee deployment schedule 
BIP 19 does not explicitly purport to directly change policy. It defines a standard way of assembling multisig transactions.
This is omitted from the BIP (in fact, it doesn't even have a Specification section!). No objections to a BIP specifying standards to use for authoring/modifying transactions for RBF, but it should leave out policy (or at least constrain it to a strictly non-normative section.

@_date: 2015-06-30 23:43:17
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] A possible solution for the block size limit: 
This is easily defeated simply by broadcasting the bloat beforehand...

@_date: 2015-05-11 16:47:47
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Reducing the block rate instead of 
1. Latency is what matters here, not bandwidth so much. And latency reduction is either expensive or impossible.
2. Mining pools are mostly run at a loss (with exception to only the most centralised pools), and have nothing to invest in increasing infrastructure.
You're overlooking at least:
1. The real network has to suffer wasted work as a result of the stale blocks, while an attacker does not. If 20% of blocks are stale, the attacker only needs 40% of the legitimate hashrate to achieve 50%-in-practice.
2. Since blocks are individually weaker, it becomes cheaper to DoS nodes with invalid blocks. (not sure if this is a real concern, but it ought to be considered and addressed)
One can probably overcome changing network conditions merely by trying to reach 75% and exclude the slowest 25%. Also, there is no way to identify or blacklist miners.
I agree this shouldn't be a real concern. SPV wallets are also more likely and less risky (globally) to be auto-updated.
Uh, I think you need to be using at least median speeds. As an example, I can only sustain (over 3G) about 40 kbps, with a peak of around 400 kbps. 3G has worse range/coverage than 2G. No doubt the *average* is skewed so high because of densely populated areas like San Francisco having 400+ Mbps cellular data. It's not reasonable to assume sync only at night: most payments will be during the day, on battery - so increased power use must also be considered.
Only in small densely populated areas of first-world countries.

@_date: 2015-05-12 20:38:27
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] CLTV opcode allocation; long-term plans? 
It should actually be straightforward to softfork RCLTV in as a negative CLTV.
All nLockTime are >= any negative number, so a negative number makes CLTV a no-op always. Therefore, it is clean to define negative numbers as relative later. It's also somewhat obvious to developers, since negative numbers often imply an offset (eg, negative list indices in Python).

@_date: 2015-05-13 16:34:52
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] [BIP] Normalized Transaction IDs 
I think this hardfork is dead-on-arrival given the ideas for OP_CHECKSIG softforking. Instead of referring to previous transactions by a normalised hash, it makes better sense to simply change the outpoints in the signed data and allow nodes to hotfix dependent transactions when/if they are malleated. Furthermore, the approach of using a hash of scriptPubKey in the input rather than an outpoint also solves dependencies in the face of intentional malleability (respending with a higher fee, or CoinJoin, for a few examples).
These aren't barriers to making the proposal or being assigned a BIP number if you want to go forward with that, but you may wish to reconsider spending time on it.

@_date: 2015-05-15 16:31:47
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] [BIP] Normalized Transaction IDs 
Assuming you mean one output per scriptPubKey (and not limiting tx to one output), the alternative is essentially undefined, and creates real problems for Bitcoin today. It's not something we should go out of the way to support or encourage. Therefore, regardless of whatever other options are available, I would like to see a scriptPubKey-only sighash type for strong safety within all malleability situations (including CoinJoin and other sender-respends) that more advanced wallet software could take advantage of in the future (while strictly enforcing no-reuse on its own wallet to avoid known replays).

@_date: 2015-05-26 05:23:04
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Zero-Conf for Full Node Discovery 
It doesn't hurt to have a local node or two, though. Might as well to improve propagation, while maintaining the other peers to avoid sybil attacks.

@_date: 2015-05-27 03:46:15
@_author: Luke Dashjr 
@_subject: [Bitcoin-development] Version bits proposal 
I suggest adding a section describing how this interacts with and changes GBT.
Currently, the client tells the server what the highest block version it supports is, and the server indicates a block version to use in its template, as well as optional instructions for the client to forcefully use this version despite its own maximum version number. Making the version a bitfield contradicts the increment-only assumption of this design, and since GBT clients are not aware of overall network consensus state, reused bits can easily become confused. I suggest, therefore, that GBT clients should indicate (instead of a maximum supported version number) a list of softforks by identifier keyword, and the GBT server respond with a template indicating:
- An object of softfork keywords to bit values, that the server will accept.
- The version number, as presently conveyed, indicating the preferred softfork Does this sound reasonable, and/or am I missing anything else?

@_date: 2015-11-01 19:06:43
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 113: Median time-past is a HARDfork, 
BIP 113 makes things valid which currently are not (any transaction with a locktime between the median time past, and the block nTime). Therefore it is a hardfork. Yet the current BIP describes and deploys it as a softfork.
Furthermore, Bitcoin Core one week ago merged  adding BIP 113 logic to the mempool and block creation. This will probably produce invalid blocks (which CNB's safety TestBlockValidity call should catch), and should be reverted until an appropriate solution is determined.
Rusty suggested something like adding N hours to the median time past for comparison, and to be a proper hardfork, this must be max()'d with the block nTime. On the other hand, if we will have a hardfork in the next year or so, it may be best to just hold off and deploy as part of that.
Further thoughts/input?

@_date: 2015-11-02 00:33:18
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Compatibility requirements for hard or soft forks 
The reality is presently "some small group of people gets to decide how and if you can access your money"... and it's getting worse.
Bitcoin developers don't make this decision, miners do.

@_date: 2015-11-02 05:06:36
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 113: Median time-past is a HARDfork, 
I agree, false alarm. Somehow I had confused the comparison of locktimes this morning. :(
Sorry about that,

@_date: 2015-11-03 20:48:17
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
Changing the network protocol is trivial in comparison to making a permanent increase in UTXO set costs.
The problem isn't changing inputs/outputs, but that such changes invalidate later spends. In particular, note that wallets *should ideally* be actively trying to make transfers using multiple malleated versions of the same So the way to make an anti-malleable wallet, would be to strictly enforce the no-address-reuse rule on payments received (note this has no effect on other/current wallets) and rely only on the hash of that scriptPubKey+value for the input in subsequent transactions. This way, no matter what inputs or other outputs the transaction paying the address/invoice uses, the subsequent transaction ignores them and remains valid. (I am not suggesting this as a mandatory change that all wallets must adopt to receive the current semi-
malleability protection you propose - only that it be *possible* for wallets to upgrade to or offer in the future.)

@_date: 2015-11-03 22:01:20
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
I'd throw it in the merged-mining tree; it's not ideal, but it can be swapped out for something better when it's ready (I'm working on such a BIP - hopefully it can be before or at the same time as a SW deployment).
It's actually better than that. If miners don't get the SW transactions, then they just won't mine them, and the wallets will continue to rebroadcast until they do. But realistically, the entire network will likely be running SW-
capable nodes long before any wallets have deployed SW transactions.
I don't know what you're trying to say here. Double spending to the same destination(s) and malleability are literally the same thing. Things affected by malleability are still just as broken even with this BIP - whether it is triggered by a third-party or not is not very relevant.

@_date: 2015-11-05 19:36:08
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
Ok, then my point is that "signature malleability" is not particularly problematic or interesting alone, and the only way to get a practically-useful solution, is to address all kinds of malleability.

@_date: 2015-11-12 20:12:28
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Upcoming Transaction Priority Changes 
This should be optional, at least for 0.12.
We should not be influencing miner policy by changing defaults.

@_date: 2015-11-12 20:25:23
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Upcoming Transaction Priority Changes 
What are you saying here? Spammers generally can't use the priority space at all, and it is a major way for legitimate users to get their transactions mined cheaply despite ongoing spam attempts. You're suggesting the exact opposite is true?? Please explain.

@_date: 2015-11-12 21:10:45
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Upcoming Transaction Priority Changes 
It has come to my attention maintaining the current priority algorithm is not even expensive, so I think I'm inclined to NACK using starting priority altogether. Since I am the mining maintainer for Core, I believe it's reasonable for me to decide on maintenance tradeoffs...
Therefore, my goal in this matter will be to review  in depth to be merged, and follow up with  based on the current default policies.
This is a bad idea anyway, since priority is the best metric we have right now for ensuring legitimate transactions get mined despite spam attacks.

@_date: 2015-11-12 21:26:38
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Upcoming Transaction Priority Changes 
That's what unit tests are for. :)
I'm not sure what you're getting at here, but rebroadcasting won't work if they're still in the memory pools (unless we open the door to DoS from reprocessing the same tx over and over).

@_date: 2015-11-13 06:39:51
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - Block size doubles at each reward halving 
It's impossible to have the entire network upgraded in the past.
Furthermore, 1 MB is already too large a block size today. While blocks don't need to be as big as the limit, it's better to have the limit approximate what is reasonably possible without straining the network. So while your proposed schedule change might be workable (if miners can be trusted to keep actual block size under 50% pending future improvements), I prefer the proposal beginning at the next subsidy halving (which we're well on the way to).

@_date: 2015-11-13 10:52:57
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - Block size doubles at each reward halving 
I'd leave out the block signalling. It isn't really useful, complicates the whole BIP, and mistakenly gives people the idea that miners have a choice in

@_date: 2015-11-13 19:37:02
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal - Max block size 
It doesn't look like you've considered BIP103 or newer BIPs? Especially, I'd suggest you look at and work with John Sacco who just the other day posted a BIP draft very similar-looking to yours. My overall impression of your summary is that it is unnecessarily over-complicated and underspecified. How does the 2^(1/2) block size limit actually work? This is not a very precise number, so it seems liable to produce rounding errors in different implementations. Additionally, the miner voting thing seems pointless since miners can already softfork lower limits. It would be beneficial to express the current possibility so full nodes can enforce it, but this would be expressed as an unlimited simple-majority vote to reduce the limit. Probably it would be ideal to separate this off from the hardfork BIP, since it's fairly tangent to it.

@_date: 2015-11-13 22:28:46
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - Block size doubles at each reward halving 
It isn't a commitment in any sense, nor does it make it smoother, because for a hardfork to be successful, it is the *economy* that must switch entirely. The miners are unimportant.
Devs have even less of a choice in the matter. What is relevant is the economy: who do people want to spend their bitcoins with? There is no programmatic way to determine this, especially not in advance, so the best we can do is a flag day that gets called off if there isn't clear consensus.

@_date: 2015-11-14 21:11:22
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - Block size doubles at each reward halving 
Actually, the economy does not necessarily include miners, and in fact the present miner community for the most part does not overlap significantly with economic activity. And at the same time, miners also have a tendency to upgrade at a different rate than the economy. It might make sense to incorporate a miner-trigger, but *only if* the flag is enabled in nodes by an option disabled by default, and the BIP clearly specifies that miners must not enable it until they perceive complete economic adoption of the change.

@_date: 2015-11-14 21:27:51
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - Block size doubles at each reward halving 
Not in the context of economic majority deciding hardforks. After all, the outcome of the hardfork *determines* the money supply. So the former money supply not supporting the change would just mean they cease to be involved in that capacity. But even aside from that, the more relevant factor in terms of economic involvement is /acceptance/ of bitcoins as payment for real goods.

@_date: 2015-11-15 03:04:33
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db 
This situation isn't something that can be ignored and simply moved past. If you can't determine the validity of a block, you also cannot process its results correctly. Taking for example the BDB/LevelDB issue, the result was that BDB failed to accept further changes to the UTXO set. Unless the UTXO set could be updated correctly, there is no way to even attempt to validate the next block or any new transactions.

@_date: 2015-10-01 20:20:22
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Fwd:  Bitcoin Core 0.12.0 release schedule 
But it's not *ready* to be used in production. :(
For 1.0, I would expect:
libbitcoinconsensus: an API that makes implementing a full node practical.
Bitcoin Core GUI: reasonably usable safely by non-technical people.
Bitcoin Core Daemon: a reasonably safe wallet (currently blocked by backup-
resistant accounting system)

@_date: 2015-10-02 21:31:21
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Dev-list's stance on potentially altering the PoW 
Besides ASIC-proof being even tehoretically impossible, assuming we had a PoW that worked using mere RAM-as-the-ASIC, this would probably not be good in the long term for decentralisation, as it is only a matter of time until botnets would bankrupt all the legitimate miners out of operation.
Restarting the mining with a new algorithm as a reaction and defence against centralised hoarding of mining ASICs (as we are seeing now), would be acceptable. It would not necessarily be contentions *to the economy*, as such hoarding-miners do not participate in the economy in any meaningful way (they do not accept payments from other bitcoin users).

@_date: 2015-10-05 16:51:57
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
This discussion is *necessarily* about soft/hard fork technicalities, as there is no governance in Bitcoin beyond the *nature* of the consensus protocol. The "established criteria" you mention is merely the nature of hardforks. It is completely inapplicable and has never been the necessary case for softforks, which can be enforced by merely a miner majority.

@_date: 2015-10-06 04:54:13
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
The copyright notice refers to the fact that each contributor owns copyright to his own contributions. There is no legal group that owns copyright to the entirety of the code.

@_date: 2015-10-06 05:53:20
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] This thread is not about the soft/hard fork 
Copyright doesn't care how notices are written. They are merely informative to humans reading them. Anyhow, this is not development related, so please direct any further discussion of it to me directly (with any applicable CCs) and NOT to the mailing list.

@_date: 2015-10-15 00:17:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Proposed list moderation policy and conduct 
This could get noisy. Clarification that only *development* help is appropriate for the list would improve it.
Probably should note that entirely new threads should be new messages, *not* merely a reply with a changed topic (as changing the topic does not in fact start a new thread).
Threads like this one are off-topic, yet we have no obvious other venue for it.. :(
IMO this seems like not only a waste of time, but also futile for anyone not exclusively associated with a single company/organization.
Please no. This is off-topic noise.

@_date: 2015-10-21 06:18:54
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
This doesn't completely close malleability (which should be documented in the BIP), so I'm not sure it's worth the cost, especially if closing malleability later on would need more. How about specifying flags upfront in the UTXO-
creating transaction specifying which parts the signature will cover? This would allow implementation of fully malleability-proof wallets.
Additionally, you have a flag to control whether the opcode behaves as VERIFY or not. Non-VERIFY is not possible as a softfork (without doing a second/new P2SH) since it can be negated.

@_date: 2015-10-21 07:52:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
Signer malleability is still a notable concern needing consideration. Ideally, wallets should be trying to actively CoinJoin, bump fees on, etc any pending transactions in the background. These forms of malleability affect nearly as many real use cases as third-party malleability.

@_date: 2015-10-21 08:39:41
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
The signer can also change the order of the inputs, the inputs themselves, add/remove outputs, etc... all which should be possible without becoming a different logical transaction. The only unique property of the logical transaction is the scriptPubKey/address.

@_date: 2015-10-21 08:46:43
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
Or he can just have the other signers re-sign with the modified version.
Even if it only worked with a single signer, it's still a form of malleability that your BIP does not presently solve, but would be desirable to solve...

@_date: 2015-10-21 23:20:30
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
My point is that third-party manipulation is not much more of a problem than signing-party manipulation. Solving the former (at a high cost), without solving the latter, seems not worth it IMO.

@_date: 2015-10-22 05:53:59
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [Bitcoin-development] Reusable payment codes 
Sorry for the late review. I'm concerned with the "notification address" requirement, which entails address reuse and blockchain spam. Since it entails address reuse, the recipient is forced to either leave them unspent forever (bloating the UTXO set), or spend it which potentially compromises the private key, and (combined with the payment code) possibly as much as the entire Instead, I suggest making it a single zero-value OP_RETURN output with two pushes: 1) a hash of the recipient's payment code, and 2) the encrypted payment code. This can be searched with standard bloom filters, or indexed with whatever other optimised algorithms are desired. At the same time, it never uses any space in the UTXO set, and never needs to be

@_date: 2015-10-22 09:05:26
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP] Normalized transaction IDs 
Except that unlike malicious double spending, adding more outputs to unconfirmed transactions is what wallets *should ideally be doing every time they send another transaction*. Spending unconfirmed change is the wrong approach. So half-fixing malleability as this PR would, encourages inefficient behaviour in multiple ways (first, by not making it malleability-
safe; second, by encouraging spending unconfirmed change).

@_date: 2015-10-22 20:43:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [Bitcoin-development] Reusable payment codes 
No, they just need to improve their software, and only to support receiving with payment codes (not sending to them). BIPs should in general not be designed around current software, especially in this case where there is no benefit to doing so (since it requires software upgrades anyway).

@_date: 2015-10-22 21:47:27
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [Bitcoin-development] Reusable payment codes 
Well, I strongly disagree with adopting the BIP as it stands.
No, those are not network-level changes. They are mere software changes that can be deployed along with the rest of the proposal.
"Standard" means defined in a BIP. To date, there are no standard transactions using OP_RETURN period. IsStandard is a node policy that should have no influence on future BIPs.
Such changes should not be made until there is a standard for them.

@_date: 2015-10-28 07:13:55
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Composite priority: combining fees and 
This is all in the realm of node policy, which must be easy to modify/customise in a flexible manner. So simplifying other code in a way that makes the policy harder to configure is not a welcome change.
That is, by making the code simpler, if you make custom policies (such as the current default) harder, it is better to leave the main code less simple.

@_date: 2015-10-29 00:55:53
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Composite priority: combining fees and 
Yes, I hope to improve the code significantly.
Trying to communicate policies as simple numbers is significantly more complicated for the policy-writer than what we have now.
No, because it gets exponentially harder when there are more than two factors

@_date: 2015-10-29 08:03:50
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db 
I predict this would be a disaster. UTXO storage is CONSENSUS-CRITICAL code.
Any divergence in implementation behaviour, including bugs AND bugfixes, may cause consensus failure. For this to have a reasonable *hope* of working, we need to choose one storage engine, and *will* need to maintain consensus-
compatibility of it ourselves (since nobody else cares).
Fixing LevelDB frankly seems like an easier task than switching to anything SQL-based, which would require a *lot* more *difficult-to-get-consensus-
compatible* code that we are all (or at least mostly) very unfamiliar with.
Research is fine, but let's be realistic about deployment.

@_date: 2015-09-01 17:39:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Open Block Chain Licence, BIP[xxxx] Draft 
BIPs should be in MediaWiki-compatible markdown format, not PDF.

@_date: 2015-09-03 00:17:42
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 100 repo 
What is the purpose of the newly added 1 MB floor? It seems clear from the current information available that 1 MB is presently too high for the limit, and it is entirely one-sided to only allow increases when decreases are much more likely to be needed in the short term.
Must the new size limit votes use 11 bytes of coinbase? Why not just use a numeric value pushed after height? Since this is a hardfork, I suggest increasing the coinbase length to allow for 100 bytes *in addition* to the pushed height and size-vote.
I suggest combining 2 & 4 into a single rule lifting the 1 MB limit to 32 MB (or whatever value is deemed appropriate) to make it clear that the limit remains a part of the consensus protocol and p2p protocol limits are not to have an effect on consensus rules.
Furthermore, I suggest modifying the voting to require 50% to set the limit floor. This has the effect of merely coordinating what miners can already effectively do today by rejecting blocks larger than some collusion-
determined limit.

@_date: 2015-09-04 00:06:05
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] RFC: HD Bitmessage address derivation based on 
Bitmessage is not Bitcoin, thus this falls outside the scope of the BIP process. Since BIP 43 is still a draft, I propose modifying it to refer non-
Bitcoin purpose codes to the SLIP repository:

@_date: 2015-09-04 00:41:07
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP/Draft] BIP Acceptance Process 
Sigh. There is *no governance at all*. Any such a BIP like this needs to document the natural forces involved in real-world acceptance, not try to lay down "rules" that people are expected to follow.
For hardforks, that means economic consensus. For softforks, miner majority. For basically anything else, real-world implementation and use (by any significant quantity of people).

@_date: 2015-09-04 18:21:15
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] RFC: HD Bitmessage address derivation based on 
Feel free to create a company-independent repository instead.
Although I don't think SLIPs are intended to be biased toward their company.
This is not Bitcoin's problem... Polluting the BIP repository with N non-
Bitcoin related specifications would be.

@_date: 2015-09-04 21:01:09
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP/Draft] BIP Acceptance Process 
For hardforks (removing consensus rules), economic consensus: people who accept payment in bitcoins weighted by their actual volume of such payments. A supermajority subset may arguably be sufficient for some hardforks (which don't violate Bitcoin's social contract) since they can effectively compel the remaining economy to comply.
For softforks (adding consensus rules), a majority of miners: they can "51% attack" miners who don't go along with it.
Anything else does not necessarily need universal agreement, so are completely up to the whim of individual software projects. If someone doesn't like a decision in Core (for example), they can safely fork the code. If any significant amount of people use their fork, then the BIP is accepted whether or not Core later adopts it.
Note this "system" is really describing a lack of a system - that is, what naturally must happen for changes to occur. Softforks have a relatively mature technical method for measuring support and deploying (which I believe someone else is already working on a BIP describing), but the same thing is impractical for hardforks. Some formal way to measure actual economic acceptance seems like a good idea to study, but it needs to be reasonably accurate so as to not change the outcome from its natural/necessary result.

@_date: 2015-09-04 21:45:32
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP/Draft] BIP Acceptance Process 
The process loses meaning if it doesn't reflect reality. So only hardforks should go through the hardfork process; only softforks through the softfork process; etc. Trying to make one-size-fits-all just means de facto accepted BIPs wouldn't be recognised as such because nobody cares to meet the higher

@_date: 2015-09-15 04:03:40
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] URI scheme for signing and verifying messages 
I think probably the whole signed message thing needs to be rethought. The most common "uses" today seem to be insecure cases that it doesn't actually work in: people trying to prove ownership of bitcoins and/or that they sent bitcoins (current signed messages can do neither). Ideally, whatever the new method is should also avoid using the same key as for signing transactions, since the public key is technically private information. Furthermore, since addresses are semi-deprecated (by the payment protocol), I'm not sure it makes sense to do this without designing an entire authentication system, which may be rather complex.

@_date: 2015-09-15 12:08:57
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] URI scheme for signing and verifying messages 
One of my concerns is that making the existing signatures even easier will cause incompatible uses to become more prolific and accepted, increasing the overall risk. Hence my recommendation to satisfy these clearly-existing use cases with a safe signature *first*.
The signed message proves that the person who *receives* payment with the address agrees to a given message/contract.
It is therefore appropriate and a best practice for web wallet providers (inherent problems with webwallets aside) to allow users to sign messages with their deposit addresses. When bitcoins are received by this address, the transaction creates a low-level UTXO representing the bitcoins *in the wallet*, but this UTXO is not associated with the address itself. Therefore, it is entirely possible that this UTXO remains unspent/valid on the blockchain even after the user in question has spent their entire balance at the webwallet and therefore such a signature proves only that they once received the payment, but *not* that they presently still have the bitcoins Furthermore, it is proper for the UTXO to be redeemed at a low-level by the wallet when an entirely unrelated user is sending a transaction. In such a circumstance, the original recipient of the bitcoins would still be able to sign a message, even though they have nothing to do with nor any right to the goods/services purchased with the transaction redeeming that UTXO.
Yes, there are a few good use cases for the current signed messages, but they appear to be a minority at the moment. I suspect implementing any URI-based signing would actually make them more difficult as well, since it is additional code on the requester's part.

@_date: 2015-09-18 04:57:14
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Weekly development meetings on IRC 
I think it's important to make a point that these meetings are for discussions, and explicitly never decisions, to avoid a repeat of the P2SH events when people have to miss it.
I think I would prefer a bit later, but I could probably make this work. Probably should try to make it more practical for California devs though, since there are a number of them.

@_date: 2015-09-18 21:50:33
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Weekly development meetings on IRC 
Not everyone does crazy clock-changing. Using such a time system for scheduling seems to inconvenience the wrong position. (although perhaps arguably better since most people probably use DST) :p
(Aside, if Google Calendar can't support standard UTC, that sounds like an argument against using Google Calendar...)
Tonal time works nice and consistently. :D

@_date: 2015-09-18 21:50:04
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Weekly development meetings on IRC 
Not everyone does crazy clock-changing. Using such a time system for scheduling seems to inconvenience the wrong position. (although perhaps arguably better since most people probably use DST) :p
(Aside, if Google Calendar can't support standard UTC, that sounds like an argument against using Google Calendar...)
Tonal time works nice any consistently. :D

@_date: 2015-09-19 02:01:00
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Fill-or-kill transaction 
Not quite as safe. Remember that mined bitcoins have not only a 100-block maturity requirement, but *also* are expensive to generate.
Mere OP_CHECKMATURITYVERIFY (aka rcltv) has no cost to use...

@_date: 2015-09-30 17:57:42
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Core 0.12.0 release schedule 
Where is "Consensus freeze"? Shouldn't this be put off until after the HK workshop in case a hardfork is decided on? Or have we de-coupled it from the release process entirely anyway (since old versions need an update for it

@_date: 2016-08-04 03:27:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP clearing house addresses 
This isn't something that makes sense at the address, since it represents the recipient and not the sender. Transactions are not sent from addresses ever.
This is already possible. Just nLockTime your withdrawls for some future block. Don't sign any transaction that isn't nLockTime'd at least N blocks beyond the present tip.

@_date: 2016-08-10 00:36:04
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Number Request: Addresses over Audio 
Yeah, let's call it BIP 170.
Next step is to:
- Fix the BIP number in the file
- Format it in the usual BIP mediawiki format instead of markdown
- Add it to a fork of the bitcoin/bips git repository
- Open a pull request against bitcoin/bips
P.S. Why are telephones considered 4-tone? DTMF is 16-tone IIRC?

@_date: 2016-08-10 00:36:04
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Number Request: Addresses over Audio 
Yeah, let's call it BIP 170.
Next step is to:
- Fix the BIP number in the file
- Format it in the usual BIP mediawiki format instead of markdown
- Add it to a fork of the bitcoin/bips git repository
- Open a pull request against bitcoin/bips
P.S. Why are telephones considered 4-tone? DTMF is 16-tone IIRC?

@_date: 2016-08-15 04:13:01
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.13.0.knots20160814 released 
Bitcoin Knots version 0.13.0.knots20160814 is now available from:
This is a new major version release, including new features, various bugfixes
and performance improvements, as well as updated translations.
Please report bugs using the issue tracker at github:
Microsoft ended support for Windows XP on [April 8th, 2014]
an OS initially released in 2001. This means that not even critical security
updates will be released anymore. Without security updates, using a bitcoin
wallet on a XP machine is irresponsible at least.
In addition to that, with 0.12.x there have been varied reports of Bitcoin
Core randomly crashing on Windows XP. It is [not clear]
what the source of these crashes is, but it is likely that upstream libraries
such as Qt are no longer being tested on XP.
We do not have time nor resources to provide support for an OS that is
end-of-life. From 0.13.0 on, Windows XP is no longer supported. Users are
suggested to upgrade to a newer verion of Windows, or install an alternative OS that is supported.
No attempt is made to prevent installing or running the software on Windows XP, you can still do so at your own risk, but do not expect it to work: do not
report issues about Windows XP to the issue tracker.
Notable changes
Non-mining nodes may influence miner policy
Various code modernizations have been done. The Bitcoin Knots code base has
started using C++11. This means that a C++11-capable compiler is now needed for building. Effectively this means GCC 4.7 or higher, or Clang 3.3 or For running the functional tests in `qa/rpc-tests`, Python3.4 or higher is now
Linux ARM builds
The code preparations for Segregated Witness ("segwit"), as described in [BIP
141]( [BIP
143]( [BIP
144]( and [BIP
145]( are
finished and included in this release.  However, BIP 141 does not yet specify
activation parameters on mainnet, and so this release does not support segwit
use on mainnet.  Testnet use is supported, and after BIP 141 is updated with
proposed parameters, a future release of Bitcoin Knots is expected that
implements those parameters for mainnet.
Furthermore, because segwit activation is not yet specified for mainnet,
version 0.13.0 will behave similarly as other pre-segwit releases even after a
future activation of BIP 141 on the network.  Upgrading from 0.13.0 will be
required in order to utilize segwit-related features on mainnet (such as signal BIP 141 activation, mine segwit blocks, fully validate segwit blocks, relay segwit blocks to other segwit nodes, and use segwit transactions in the
wallet, etc).
Mining transaction selection ("Child Pays For Parent")
In earlier versions, reindexing did validation while reading through the block
files on disk. These two have now been split up, so that all blocks are known
before validation starts. This was necessary to make certain optimizations that are available during normal synchronizations also available during The two phases are distinct in the Bitcoin-Qt GUI. During the first one,
"Reindexing blocks on disk" is shown. During the second (slower) one,
"Processing blocks on disk" is shown.
It is possible to only redo validation now, without rebuilding the block index, using the command line option `-reindex-chainstate` (in addition to
`-reindex` which does both). This new option is useful when the blocks on disk
are assumed to be fine, but the chainstate is still corrupted. It is also
useful for benchmarks.
Removal of internal miner
- The P2P alert system has been removed in PR  and the `alert` P2P
  message is no longer supported.
- The transaction relay mechanism used to relay one quarter of all
  transactions instantly, while queueing up the rest and sending them out in
  batch. As this resulted in chains of dependent transactions being reordered,
  it systematically hurt transaction relay. The relay code was redesigned in
  PRs  and  and now always batches transactions announcements while
  also sorting them according to dependency order. This significantly reduces
  orphan transactions. To compensate for the removal of instant relay, the
  frequency of batch sending was doubled for outgoing peers.
- Since PR  the BIP35 `mempool` command is also subject to batch
  processing. Also the `mempool` message is no longer handled for
  non-whitelisted peers when `NODE_BLOOM` is disabled through
  `-peerbloomfilters=0`.
- The maximum size of orphan transactions that are kept in memory until their
  ancestors arrive has been raised in PR  from 5000 to 99999 bytes. They
  are now also removed from memory when they are included in a block, conflict
  with a block, and time out after 20 minutes.
- We respond at most once to a getaddr request during the lifetime of a
  connection since PR - Connections to peers who have recently been the first one to give us a valid
  new block or transaction are protected from disconnections since PR Low-level RPC changes
- Each ZMQ notification now contains an up-counting sequence number that
  allows listeners to detect lost notifications.
  The sequence number is always the last element in a multi-part ZMQ
  notification and therefore backward compatible. Each message type has its
  own counter. PR [
0.13.0.knots20160814 Change log
Detailed release notes follow. This overview includes changes that affect
behavior, not code moves, refactors and string updates. For convenience in locating the code changes and accompanying discussion, both the pull request
and git merge commit are mentioned. Changes specific to Bitcoin Knots (beyond
Core) are flagged with an asterisk ('*') before the description.
 RPC and other APIs
-  `9ee02cf` Remove cs_main lock from `createrawtransaction` (laanwj)
-  `2cd004b` Fix typo, wrong information in gettxout help text -  `82429d0` Indicate which transactions are signaling opt-in RBF -  `b49a623` Changed getnetworkhps value to double to avoid overflow -  `8b958ab` Input-from-stdin mode for bitcoin-cli (laanwj)
-  `c9a1265` Use cached block hash in blockToJSON() (rat4)
-  `9af69fa` Correct importaddress help reference to importpubkey -  `16555b6` Register calls where they are defined (laanwj)
-  `e662a76` Fix generatetoaddress failing to parse address (mruddy)
-  `916b15a` Add versionHex in getblock and getblockheader JSON results -  `72c54e3` Getblockchaininfo: make bip9_softforks an object, not an array (rustyrussell)
-  `d97101e` Do not print minping time in getpeerinfo when no ping received yet (paveljanik)
-  `be14ca5` Add multiple options to fundrawtransaction (promag)
-  `9e47fce` Add cursor to iterate over utxo set, use this in `gettxoutsetinfo` (laanwj)
-  `88616d2` Divergence between 32- and 64-bit when hashing >4GB affects `gettxoutsetinfo` (laanwj)
-  `4205ad7` Speed up `getchaintips` (mrbandrews)
-  `a1eb344` Append a message sequence number to every ZMQ notification -  `46880ed` List solvability in listunspent output and improve help -  `5725807` Push back `getaddednodeinfo` dead value (instagibbs)
-  `0630353` Create `signmessagewithprivkey` rpc (achow101)
-  `c028c7b` Expose information on whether transaction relay is enabled in `getnetworkinfo` (laanwj)
-  `8c1e49b` Add feerate option to `fundrawtransaction` (jonasschnelli)
-  `9b6a48c` Reduce unnecessary hashing in `signrawtransaction` -  `79004d4` Add support for transaction sequence number (jonasschnelli)
-  `75ec320` `fundrawtransaction` feeRate: Use BTC/kB (MarcoFalke)
-  `7ce9ac5` Expose ancestor/descendant information over RPC (sdaftuar)
-  `62fcf27` Fix createrawtx sequence number unsigned int parsing -  `9c3d0fa` Add full UTF-8 support to RPC (laanwj)
-  `304eff3` Don't use floating point in rpcwallet (MarcoFalke)
-  `5a06ebb` Hide softfork in `getblockchaininfo` if timeout is 0 -  `1922e5a` Remove unnecessary LOCK(cs_main) in getrawmempool (dcousens)
 Block and transaction handling
-  `6a07208` Save last db read (morcos)
-  `0192806` Limitfreerelay edge case bugfix (ptschip)
-  `11d74f6` Replace maxFeeRate of 10000*minRelayTxFee with maxTxFee in mempool (MarcoFalke)
-  `9f33dba` Add tags to mempool's mapTx indices (sdaftuar)
-  `26a2a72` Re-remove ERROR logging for mempool rejects (laanwj)
-  `14d6324` Keep reorgs fast for SequenceLocks checks (morcos)
-  `01f4267` Mempool: Add tracking of ancestor packages (sdaftuar)
-  `fc9e334` Txdb: Fix assert crash in new UTXO set cursor (laanwj)
-  `f9c2ac7` Minor changes to dbwrapper to simplify support for other databases (laanwj)
-  `e26b620` Fix OOM when deserializing UTXO entries with invalid length -  `5e374f7` Use SipHash-2-4 for various non-cryptographic hashes (sipa)
-  `d720980` VerifyDB: don't check blocks that have been pruned -  `862fd24` Do not use mempool for GETDATA for tx accepted after the last mempool req (gmaxwell)
-  `a82f033` Replace mapNextTx with slimmer setSpends (kazcw)
-  `1f86d64` Stop trimming when mapTx is empty (sipa)
-  `396f9d6` Bump `-dbcache` default to 300MiB (laanwj)
-  `eb33179` Eliminate unnecessary call to CheckBlock (sdaftuar)
-  `006cdf6` Optimize and Cleanup CScript::FindAndDelete (pstratem)
-  `239d419` Optimize reindex (sipa)
-  `3081fb9` Put hex-encoded version in UpdateTip (sipa)
-  `d612837` Testnet-only segregated witness (sipa)
-  `3730393` Improve handling of unconnecting headers (sdaftuar)
-  `fca1a41` Rename "block cost" to "block weight" (sdaftuar)
-  `f84ee3d` Make witness v0 outputs non-standard (jl2012)
-  `3f65ba2` Treat high-sigop transactions as larger rather than rejecting them (sipa)
- n/a   `15edeeb` *Add a new checkpoint at block 421,888 (luke-jr)
- n/a   `6ae2e2d` *Restore original bytespersigop as bytespersigopstrict  P2P protocol and network code
-  `dc0305d` Log bytes recv/sent per command (jonasschnelli)
-  `3b43cad` Do not download transactions during initial blockchain sync -  `898fedf` peers.dat, banlist.dat recreated when missing (kirkalx)
-  `3da5d1b` Fix memleak in TorController (laanwj, jonasschnelli)
-  `9f14e5a` Remove vfReachable and modify IsReachable to only use vfLimited (pstratem)
-  `9426632` De-neuter NODE_BLOOM (pstratem)
-  `29b2be6` Remove P2P alert system (btcdrak)
-  `c946a15` Implement "feefilter" P2P message (morcos)
-  `352fd57` Add `-maxtimeadjustment` command line option (mruddy)
-  `232592a` Add IPv6 Link-Local Address Support (mruddy)
-  `e6a4d48` Improve AlreadyHave (morcos)
-  `64e71b3` Only send one GetAddr response per connection (gmaxwell)
-  `7daa3ad` Split DNS resolving functionality out of net structures -  `7617682` Fix headers announcements edge case (sdaftuar)
-  `d9594bf` Fix IsInitialBlockDownload for testnet (jmacwhyte)
-  `03cf6e8` fix race that could fail to persist a ban (kazcw)
-  `3b9a0bf` Several performance and privacy improvements to inv/mempool handling (sipa)
-  `65aecda` Don't run ThreadMessageHandler at lowered priority (kazcw)
-  `5c3f8dd` Fix de-serialization bug where AddrMan is left corrupted -  `ed749bd` CAddrMan::Deserialize handle corrupt serializations better -  `83121cc` Prerequisites for p2p encapsulation changes (theuni)
-  `18436d8` Fix Socks5() connect failures to be less noisy and less unnecessarily scary (wtogami)
-  `01d8359` Defer inserting into maprelay until just before relaying -  `6a22373` Only use AddInventoryKnown for transactions (sdaftuar)
-  `2156fa2` Disable the mempool P2P command when bloom filters disabled -  `67c91f8` Addrman offline attempts (gmaxwell)
-  `761cddb` Tor: Change auth order to only use password auth if -
torpassword (laanwj)
-  `cd0c513` Add support for dnsseeds with option to filter by servicebits (jonasschnelli)
-  `4286f43` Use SipHash for node eviction (sipa)
-  `1445835` Drop vAddrToSend after sending big addr message (kazcw)
-  `be9711e` Enforce expected outbound services (sipa)
-  `0a64777` Do not set extra flags for unfiltered DNS seed results -  `e4bb4a8` Add recently accepted blocks and txn to AttemptToEvictConnection (gmaxwell)
-  `3f89a53` Rework addnode behaviour (sipa)
-  `94ab58b` Evict orphans which are included or precluded by accepted blocks (gmaxwell)
-  `e9d76a1` Compact Blocks (TheBlueMatt)
-  `0833894` Update petertodd's testnet seed (petertodd)
-  `5cd35d3` Mark my dnsseed as supporting filtering (sipa)
-  `042c323` Remove bad chain alert partition check (btcdrak)
-  `1bc9c80` Do not send witnesses in cmpctblock (sipa)
-  `ca40ef6` Fix mempool DoS vulnerability from malleated transactions -  `16ccb74` Account for `sendheaders` `verack` messages (laanwj)
-  `425278d` Bugfix: use global ::fRelayTxes instead of CNode in version send (sipa)
-  `b7e2011` Prevent fingerprinting, disk-DoS with compact blocks  Build system
-  `41f1a3e` C++11 build/runtime fixes (theuni)
-  `fd9356b` c++11: add scoped enum fallbacks to CPPFLAGS rather than defining them locally (theuni)
-  `a6771fc` Use Debian 8.3 in gitian build guide (fanquake)
-  `152a821` Build against system UniValue when available (luke-jr)
-  `621940e` LibreSSL doesn't define OPENSSL_VERSION, use LIBRESSL_VERSION_TEXT instead (paveljanik)
-  `9b9bfce` autogen.sh: warn about needing autoconf if autoreconf is not found (knocte)
-  `19324cf` Crystal clean make clean (paveljanik)
-  `18b3f1b` Add missing sudo entry in gitian VM setup (btcdrak)
-  `639ec58`  [depends] Delete unused patches  (MarcoFalke)
-  `c15eb28` Add curl to Gitian setup instructions (btcdrak)
-  `909b72b` [Depends] Bump miniupnpc and config.guess+sub (fanquake)
-  `5131005` build: python 3 compatibility (laanwj)
-  `28ad4d9` Fix quoting of copyright holders in configure.ac (domob1812)
-  `a67bc5e` [build-aux] Update Boost & check macros to latest serials -  `4dc1b3a` Use relative paths instead of absolute paths in protoc calls -  `bbd210d` depends: some base fixes/changes (theuni)
-  `73fc922` Build System: Use PACKAGE_TARNAME in NSIS script -  `187186b` test: move accounting_tests and rpc_wallet_tests to wallet/test (laanwj)
-  `351abf9` leveldb: integrate leveldb into our buildsystem (theuni)
-  `a407807` Re-instate TARGET_OS=linux in configure.ac. Removed by 351abf9e035 (randy-waterhouse)
-  `c3e3cfb` Switch Travis to Trusty (theuni)
-  `08b37c5` build: quiet annoying warnings without adding new ones -  `06162f1` build: Enable C++11 in build, require C++11 compiler -  `559fbae` build: No need to check for leveldb atomics (theuni)
-  `f9b4582` [depends] Add -stdlib=libc++ to darwin CXX flags (fanquake)
-  `6a034ed` [depends] Bump Freetype, ccache, ZeroMQ, miniupnpc, expat -  `19ea173` Ship debug tarballs/zips with debug symbols (theuni)
-  `f0299d8` Add --disable-bench to config flags for windows (laanwj)
-  `fd9881a` [gitian] Default reference_datetime to commit author date -  `9201ce8` Get rid of `CLIENT_DATE` (laanwj)
-  `fde0ac4` Finish up out-of-tree changes (theuni)
-  `65a9d7d` Add armhf/aarch64 gitian builds (theuni)
-  `cca1c8c` [gitian] set correct PATH for wrappers (MarcoFalke)
-  `5201614` Sync ax_pthread with upstream draft4 (fanquake)
-  `12a541e` [Qt] Bump to Qt5.6.1 (jonasschnelli)
-  `da50997` windows: Add testnet link to installer (laanwj)
-  `0cca2fe` [travis] Update SDK_URL (MarcoFalke)
-  `6ae20df` Require boost for bench (theuni)
-  `2e51590` Don't require sudo for Linux (theuni)
-  `67caef6` Fix pkg-config issues for 0.13 (theuni)
-  `1fe7f40` Fix OSX non-deterministic dmg (theuni)
-  `cfd1280` Gbuild: Set memory explicitly (default is too low) -  `216d796` *configure: Allow building bench_bitcoin by itself (luke-jr)
- n/a   `2271350` *Qt/Options: Fix warning about comparing signed/unsigned  GUI
-  `00b4b8d` Add InMempool() info to transaction details (jonasschnelli)
-  `5f3c670` [RPC-Tests] add simple way to run rpc test over QT clients -  `a1c185b` Fix misleading translation (MarcoFalke)
-  `be9a9a3` qt5: Use the fixed font the system recommends (MarcoFalke)
-  `08ab906` Add note to coin control dialog QT5 workaround (fanquake)
-  `e289807` Replace some instances of formatWithUnit with formatHtmlWithUnit (fanquake)
-  `3b57e9c` Fix RPCTimerInterface ordering issue (jonasschnelli)
-  `c079d79` Transaction View: LastMonth calculation fixed (crowning-)
-  `e1060c5` coincontrol workaround is still needed in qt5.4 (fixed in qt5.5) (MarcoFalke)
-  `ae2db67` Rename "amount" to "requested amount" in receive coins table -  `cdcbc59` Add option to increase/decrease font size in the console window (jonasschnelli)
-  `9645218` Disable tab navigation for peers tables (Kefkius)
-  `354b03d` build: Remove spurious dollar sign. Fixes  (dooglus)
-  `7f001bd` Remove openssl info from init/log and from Qt debug window -  `87d6562` Add 'copy full transaction details' option (ericshawlinux)
-  `3798e5d` Add autocomplete to bitcoin-qt's console window (GamerSg)
-  `b24266c` Fix history deletion bug after font size change (achow101)
-  `41d2dfa` Remove reflection from `about` icon (laanwj)
-  `f034bce` Remove 0-fee from send dialog (MarcoFalke)
-  `b88e0b0` Use CCoinControl selection in CWallet::FundTransaction -  `0b98dd7` Debug window: replace "Build date" with "Datadir" -  `60db51d` remove trailing output-index from transaction-id -  `6383268` Clear the input line after activating autocomplete -  `f604bf6` Fix out-of-tree GUI builds (laanwj)
-  `574ddc6` Make it possible to show details for multiple transactions -  `b33824b` Delay user confirmation of send (Tyler-Hardin)
-  `7c8558d` Add option to disable the system tray icon (Tyler-Hardin)
-  `169d379` Fix Cmd-Q / Menu Quit shutdown on OSX (jonasschnelli)
-  `6929711` Don't allow to open the debug window during splashscreen & verification state (jonasschnelli)
-  `77b49ac` Sort transactions by date (Tyler-Hardin)
-  `eb2f6f7` askpassphrasedialog: Clear pass fields on accept (rat4)
-  `ee1533e` Fix RPC console auto completer (UdjinM6)
-  `fb0ac48` Add bitcoin address label to request payment QR code -  `760a6c7` Fix a bug where the SplashScreen will not be hidden during startup (jonasschnelli)
-  `af2421c` BUG: bitcoin-qt crash (fsb4000)
-  `ff03c50` Do not ask a UI question from bitcoind (sipa)
-  `91abb77` Network-specific example address (laanwj)
-  `a914968` UI support for abandoned transactions (jonasschnelli)
-  `f7a403b` Add a link to the Bitcoin-Core repository and website to the About Dialog (MarcoFalke)
-  `6a87eb0` Remove client name from debug window (laanwj)
-  `45eba4b` Add dbcache migration path (jonasschnelli)
- n/a   `1e345d2` *Qt/Options: Replace blockminsize with blockmaxweight (luke-
- n/a   `2185e93` *Qt/Options: Update for bytespersigopstrict (luke-jr)
- n/a   `2da1d28` *Recognise NODE_XTHIN service bit (luke-jr)
 Wallet
-  `fc08994` Reduce inefficiency of GetAccountAddress() (dooglus)
-  `78e81b0` Warn on unexpected EOF while salvaging wallet (laanwj)
-  `3368895` Don't resend wallet txs that aren't in our own mempool -  `86a1ec5` Move wallet help string creation to CWallet (jonasschnelli)
-  `5b3b5a7` Move "load wallet phase" to CWallet (jonasschnelli)
-  `0735c0c` Move hardcoded file name out of log messages (MarcoFalke)
-  `4900641` Prevent multiple calls to CWallet::AvailableCoins (promag)
-  `e5c3511` Fix lockunspent help message (promag)
-  `b35a591` Add import/removeprunedfunds rpc call (instagibbs)
-  `30c2dd8` Refactor wallet/init interaction (jonasschnelli)
-  `48c5adf` add bip32 pub key serialization (jonasschnelli)
-  `bafd075` Fix for incorrect locking in GetPubKey() (keystore.cpp) -  `0c95ebc` Slighly refactor GetOldestKeyPoolTime() (jonasschnelli)
-  `41138f9` init: Move berkeleydb version reporting to wallet (laanwj)
-  `373b50d` Fix insanity of CWalletDB::WriteTx and CWalletTx::WriteToDisk (pstratem)
-  `f6b7df3` Improve Wallet encapsulation (pstratem)
-  `950be19` Always require OS randomness when generating secret keys -  `b89ef13` Replace OpenSSL AES with ctaes-based version (sipa)
-  `f972b04` Prevent multiple calls to ExtractDestination (pedrobranco)
-  `243ac0c` Improve CWallet API with new AccountMove function (pstratem)
-  `52c3f34` Improve CWallet API  with new GetAccountPubkey function -  `b67a472` Add simplest BIP32/deterministic key generation implementation (jonasschnelli)
-  `a6ddb19` Stop treating importaddress'ed scripts as change (sipa)
-  `aef3811` wallet: Revert input selection post-pruning (laanwj)
-  `bc94b87` Keep HD seed during salvagewallet (jonasschnelli)
-  `238300b` Add HD keypath to CKeyMetadata, report metadata in validateaddress (jonasschnelli)
-  `3b38a6a` Ensure <0.13 clients can't open HD wallets (jonasschnelli)
-  `ebea651` Move SetMinVersion for FEATURE_HD to SetHDMasterKey -  `73adfe3` Correct hdmasterkeyid/masterkeyid name confusion -  `18b8ee1` Add HD xpriv to dumpwallet (jonasschnelli)
-  `c3c82c4` Create a new HD seed after encrypting the wallet - n/a   `9480ef4` *wallet: Prevent key origin support for HD wallets, since they are incompatible (luke-jr)
 Tests and QA
-  `d3dfc6d` Test walletpassphrase timeout (MarcoFalke)
-  `47c5ed1` Make max tip age an option instead of chainparam (laanwj)
-  `21376af` Trivial: [qa] wallet: Print maintenance (MarcoFalke)
-  `668906f` [travis] Fail when documentation is outdated (MarcoFalke)
-  `93b0576` [qa] Change default block priority size to 0 (MarcoFalke)
-  `02676c5` Use createrawtx locktime parm in txn_clone (dgenr8)
-  `326ffed` Adds unittests for CAddrMan and CAddrinfo, removes source of non-determinism (EthanHeilman)
-  `d007511` tests: Remove May15 test (laanwj)
-  `18cb2d5` Add bip68-sequence.py to extended rpc tests (btcdrak)
-  `ce5fc02` test: test leading spaces for ParseHex (laanwj)
-  `1b68de3` [travis] Only run check-doc.py once (MarcoFalke)
-  `7f96671` [travis] Exit early when check-doc.py fails (MarcoFalke)
-  `56d2c4e` Move GetTempPath() to testutil (musalbas)
-  `f1ca891` test: script_error checking in script_invalid tests (laanwj)
-  `3d0dfdb` Extend tests (MarcoFalke)
-  `622fe6c` Tests: make prioritise_transaction.py more robust (sdaftuar)
-  `efde86b` Tests: fix missing import in mempool_packages (sdaftuar)
-  `29e1131` Add tests verifychain, lockunspent, getbalance, listsinceblock (MarcoFalke)
-  `3b4324b` rpc-test: Normalize assert() (MarcoFalke)
-  `26794d4` wallet: Wait for reindex to catch up (MarcoFalke)
-  `a65b36c` Don't run pruning.py twice (MarcoFalke)
-  `7c80e72` Fix comments in tests (btcdrak)
-  `e9723cb` tests: Make proxy_test work on travis servers without IPv6 -  `ff5874b` Bug fixes and refactor (MarcoFalke)
-  `70ac71b` Remove misleading "errorString syntax" (MarcoFalke)
-  `401c65c` maxblocksinflight: Actually enable test (MarcoFalke)
-  `3bc71e1` httpbasics: Actually test second connection (MarcoFalke)
-  `3911a0a` Refactor script tests (sipa)
-  `ab8586e` tests: add varints_bitpatterns test (laanwj)
-  `491171f` Clean up lockorder data of destroyed mutexes (sipa)
-  `6ef5e00` py2: Unfiddle strings into bytes explicitly (MarcoFalke)
-  `53adc83` [test] bctest.py: Revert faa41ee (MarcoFalke)
-  `cabba24` [travis] Print the commit which was evaluated (MarcoFalke)
-  `b1bf511` tests: Check Content-Type header returned from RPC server -  `fa9d86f` pull-tester: Don't mute zmq ImportError (MarcoFalke)
-  `0e6fd5e` Add listunspent() test for spendable/unspendable UTXO -  `59ad568` Tests: Fix deserialization of reject messages (sdaftuar)
-  `0ea3941` Fixing comment in script_test.json test case (Christewart)
-  `0ad1041` Fixed miner test values, gave constants for less error-prone values (instagibbs)
-  `88b77c7` Smartfees: Properly use ordered dict (MarcoFalke)
-  `77b637f` Switch to py3 (MarcoFalke)
-  `409a8a1` Revert fatal-ness of missing python-zmq (laanwj)
-  `3e90fe6` Autofind rpc tests --srcdir (jonasschnelli)
-  `4e14afe` Refactor test_framework and pull tester (MarcoFalke)
-  `5767e80` Fix multithread CScheduler and reenable test (paveljanik)
-  `423ca30` pull-tester: Run rpc test in parallel  (MarcoFalke)
-  `69b3a6d` Bench: Add crypto hash benchmarks (laanwj)
-  `5b736dd` Fix bip9-softforks blockstore issue (MarcoFalke)
-  `1f01443` Add op csv tests to script_tests.json (Christewart)
-  `e2bf830` Various minor fixes (MarcoFalke)
-  `1b87e5b` Travis: 'make check' in parallel and verbose (MarcoFalke)
-  `8844ef1` Remove hardcoded "4 nodes" from test_framework (MarcoFalke)
-  `37f9a1f` Test_framework: Set wait-timeout for bitcoind procs -  `6700cc9` Test framework: only cleanup on successful test runs -  `06bd4f6` Test_framework: Append portseed to tmpdir (MarcoFalke)
-  `6ff2c8d` Add timeout to sync_blocks() and sync_mempools() (sdaftuar)
-  `61b8684` Benchmark SipHash (sipa)
-  `52b803e` Bench: Added base58 encoding/decoding benchmarks -  `0026e0e` Avoid integer division in the benchmark inner-most loop -  `a2df115` Adding P2SH(p2pkh) script test case (Christewart)
-  `ec45cc5` Extend  with one more test (TheBlueMatt)
-  `ae5575b` Fix interrupted HTTP RPC connection workaround for Python 3.5+ (sipa)
-  `0f24eaf` [Bitcoin-Tx] fix missing test fixtures, fix 32bit atoi issue -  `0b5279f` Src/test: Do not shadow local variables (paveljanik)
-  `44c1b1c` Continuing port of java comparison tool (mrbandrews)
-  `36b7400` fundrawtransaction: Fix race, assert amounts (MarcoFalke)
-  `ed2cd59` Mininode: fail on send_message instead of silent return -  `a072d1a` Don't use floating point in wallet tests (MarcoFalke)
-  `65c2058` Test_framework: Use different rpc_auth_pair for each node -  `0d41d70` Assert 'changePosition out of bounds'  (MarcoFalke)
-  `961893f` Enable mempool consistency checks in unit tests (sipa)
-  `84370d5` test_framework: python3.4 authproxy compat (laanwj)
-  `d8e862a` test_framework: detect failure of bitcoind startup (laanwj)
-  `115735d` Increase sync_blocks() timeouts in pruning.py (MarcoFalke)
-  `af9b7a9` Solve trivial merge conflict in p2p-segwit.py (MarcoFalke)
-  `3e4cf8f` Travis: use slim generic image, and some fixups (theuni)
-  `5c7df70` Test_framework: Properly print exception (MarcoFalke)
-  `7771aa5` Remove non-determinism which is breaking net_tests  -  `bb2646a` Add wallet-hd test (MarcoFalke)
-  `cd0910b` Fix p2p-feefilter.py for changed tx relay behavior -  `5e6af82` *qa: Adapt preciousblock test to current test framework (and Py3) (luke-jr)
 Mining
-  `11c7699` Remove internal miner (Leviathn)
-  `c87f51e` Make the generate RPC call function for non-regtest (sipa)
-  `e2ebd25` Add generatetoaddress RPC to mine to an address (achow101)
-  `66ed450` Versionbits: GBT support (luke-jr)
-  `e1486eb` Refactor CreateNewBlock to be a method of the BlockAssembler class (morcos)
-  `66db2d6` Select transactions using feerate-with-ancestors (sdaftuar)
-  `f5660d3` Mining-related fixups for 0.13.0 (sdaftuar)
-  `536b75e` Add support for negative fee rates, fixes `prioritizetransaction` (MarcoFalke)
-  `86edc20` Scale legacy sigop count in CreateNewBlock (sdaftuar)
-  `8b0eee6` Bugfix: Use pre-BIP141 sigops until segwit activates (GBT) - n/a   `5a716a3` *Trivially map blockmaxsize to blockmaxweight while segwit is unactivated (luke-jr)
 Documentation and miscellaneous
-  `69e2a40` Add example for building with constrained resources (jarret)
-  `c2c69ed` Add OSX ZMQ requirement to QA readme (fanquake)
-  `377d131` Clarify documentation for running a tor node (nathaniel-
-  `4b12266` Add example for listing ./configure flags (nathaniel-mahieu)
-  `3eae681` Add arch linux build example (mruddy)
-  `ff69aaf` Fedora build requirements (wtogami)
-  `fbedc09` Fedora build requirements, add gcc-c++ and fix typo -  `fbd8478` Fixed invalid example paths in gitian-building.md -  `63fbdbc` Mention Windows XP end of support in release notes (laanwj)
-  `5077d2c` Update bips.md for CSV softfork (fanquake)
-  `e0b3e19` Add note about using the Qt official binary installer -  `e30a5b0` Change Precise to Trusty in gitian-building.md (JeremyRand)
-  `8bb5d3d` Update gitian build guide to debian 8.4.0 (fanquake)
-  `b778e59` Replace precise with trusty (MarcoFalke)
-  `fc23fee` Update bitcoin-core GitHub links (MarcoFalke)
-  `e3a8207` Add basic git squash workflow (fanquake)
-  `214ec0b` Update port in tor.md (MarcoFalke)
-  `37c9830` Use Debian 8.5 in the gitian-build guide (fanquake)
-  `3685e0c` Clarify help for `getblockchaininfo` (paveljanik)
-  `ea0f5a2` Note that reviewers should mention the id of the commits they reviewed (pstratem)
-  `c851d8d` [init] Add missing help for args (MarcoFalke)
-  `f9fd4c2` Improve CheckInputs() comment about sig verification -  `1e06bab` Minor improvements to the release process (PRabahy)
-  `4cdbd42` Improve block validity/ConnectBlock() comments (petertodd)
-  `db2e1c0` Fix and cleanup listreceivedbyX documentation (instagibbs)
-  `b6e00af` Clarify description of blockindex (pinheadmz)
-  `f06af57` Improving wording related to Boost library requirements [updated] (jonathancross)
-  `0fa88ef` Add dependency info to test docs (elliotolds)
-  `3ba07bd` RPM spec file project (AliceWonderMiscreations)
-  `229a17c` Removed call to `TryCreateDirectory` from `GetDefaultDataDir` in `src/util.cpp` (alexreg)
-  `ec870e1` Prevector: fix 2 bugs in currently unreached code paths -  `90653bc` CBase58Data::SetString: cleanse the full vector (kazcw)
-  `c4e8390` Update release process (laanwj)
-  `a9c8b74` Log invalid block hash to make debugging easier (paveljanik)
-  `8206835` More comments on the design of AttemptToEvictConnection -  `47a7cfb` UpdateTip: log only one line at most per block (laanwj)
-  `e7e25ea` Add benchmarking notes (fanquake)
-  `58f0c92` Update implemented BIPs list (fanquake)
-  `58725ba` Simplify OS X build notes (fanquake)
-  `d46b8b5` comment nit: miners don't vote (instagibbs)
-  `22e0b35` Log/report in 10% steps during VerifyDB (jonasschnelli)
-  `d366185` util: Add ParseUInt32 and ParseUInt64 (laanwj)
-  `f7b1bfc` Add git and github tips and tricks to developer notes (sipa)
-  `67db011` developer notes: updates for C++11 (kazcw)
-  `8ccdac1` [Doc] Update OS X build notes for 10.11 SDK (fanquake)
-  `9f1807a` Mention Linux ARM executables in release process and notes -  `ff46dd4` Rename OP_NOP3 to OP_CHECKSEQUENCEVERIFY (btcdrak)
-  `26316ff` bash-completion: Adapt for 0.12 and 0.13 (roques)
-  `3dc3149` Missing patches from 0.12 (MarcoFalke)
-  `54a550b` Switch to a more efficient rolling Bloom filter (sipa)
-  `de9e5ea` Combine common error strings for different options so translations can be shared and reused (luke-jr)
-  `b8f485c` [contrib] Add clang-format-diff.py (MarcoFalke)
-  `e6f97ef` devtools: replace github-merge with python version (laanwj)
-  `0893705` devtools: show pull and commit information in github-merge -  `6a5932b` devtools: github-merge get toplevel dir without extra whitespace (achow101)
-  `20a408c` devtools: Fix utf-8 support in messages for github-merge -  `409f843` Delete outdated test-patches reference (Lewuathe)
-  `386f438` remove unused NOBLKS_VERSION_{START,END} constants (rat4)
-  `aa0d2b2` devtools: make github-merge.py use py3 (laanwj)
-  `55db5f0` devtools: Auto-set branch to merge to in github-merge -  `f17032f` Improve rolling bloom filter performance and benchmark -  `2efe38b` signal handling: fReopenDebugLog and fRequestShutdown should be type sig_atomic_t (catilac)
-  `f6598df` Fixes for verify-commits script (petertodd)
-  `8360d5b` libconsensus: Expose a flag for BIP112 (jtimon)
- n/a   `d5d0ce6` *corepolicy: Add bytespersigopstrict=0 (luke-jr)
-  `f8bf558` *Update SVG icon rendering for 0.13 (bitcoin_test.ico, RPM spec, VPATH builds) (luke-jr)
Thanks to everyone who directly contributed to this release:
- 21E14
- accraze
- Adam Brown
- Alexander Regueiro
- Alex Morcos
- Alfie John
- Alice Wonder
- AlSzacrel
- Andrew Chow
- Andr?s G. Aragoneses
- Bob McElrath
- BtcDrak
- calebogden
- C?dric F?lizard
- Chirag Dav?
- Chris Moore
- Chris Stewart
- Christian von Roques
- Chris Wheeler
- Cory Fields
- crowning-
- Daniel Cousens
- Daniel Kraft
- Denis Lukianov
- Elias Rohrer
- Elliot Olds
- Eric Shaw
- error10
- Ethan Heilman
- face
- fanquake
- Francesco 'makevoid' Canessa
- fsb4000
- Gavin Andresen
- gladoscc
- Gregory Maxwell
- Gregory Sanders
- instagibbs
- James O'Beirne
- Jannes Faber
- Jarret Dyrbye
- Jeremy Rand
- jloughry
- jmacwhyte
- Joao Fonseca
- Johnson Lau
- Jonas Nick
- Jonas Schnelli
- Jonathan Cross
- Jo?o Barbosa
- Jorge Tim?n
- Kaz Wesley
- Kefkius
- kirkalx
- Krzysztof Jurewicz
- Leviathn
- lewuathe
- Luke Dashjr
- Luv Khemani
- Marcel Kr?ger
- Marco Falke
- Mark Friedenbach
- Matt
- Matt Bogosian
- Matt Corallo
- Matthew English
- Matthew Zipkin
- mb300sd
- Mitchell Cash
- mrbandrews
- mruddy
- Murch
- Mustafa
- Nathaniel Mahieu
- Nicolas Dorier
- Patrick Strateman
- Paul Rabahy
- paveljanik
- Pavel Jan?k
- Pavel Vasin
- Pedro Branco
- Peter Todd
- Philip Kaufmann
- Pieter Wuille
- Prayag Verma
- ptschip
- Puru
- randy-waterhouse
- R E Broadley
- Rusty Russell
- Suhas Daftuar
- Suriyaa Kudo
- TheLazieR Yip
- Thomas Kerin
- Tom Harding
- Tyler Hardin
- UdjinM6
- Warren Togami
- Will Binns
- Wladimir J. van der Laan
- Yuri Zhykin
As well as everyone that helped translating on [Transifex]

@_date: 2016-08-16 10:20:27
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] New BIP: Low S values signatures 
Not 20-byte witness v0 programs?
"the IsLowDERSignature check" is not well-defined. Probably intend to reference the previous paragraph?

@_date: 2016-08-16 19:22:29
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hardware Wallet Standard 
IMO it's kindof ugly to abuse URIs for communication. Stdio pipes are pretty universally supported, why not just use those?
On the other hand, no matter how the plugin is implemented, it's still a security risk, and requires installation (which the user might not have access for). It would be best if the hardware protocol were standardised, so the user doesn't need a plugin of *any* sort... I notice some hardware wallets have begun to implement (or reuse) Trezor's interface, so that would seem a good place to start?

@_date: 2016-08-16 19:37:19
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] New BIP: Dealing with OP_IF and OP_NOTIF 
I am not sure this makes sense. SegWit transactions are already non-malleable due to skipping the witness data in calculating the transaction id. What is the benefit to this?

@_date: 2016-08-17 04:40:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] New BIP: Dealing with OP_IF and OP_NOTIF 
This is much uglier than expected. IMO if that's the best workaround for the current behaviour, people should just use "OP_1 OP_EQUAL OP_IF" when/if they need to avoid malleability issues.
I suspect most cases OP_IF would be used, you really want to accept any non-
zero value. For example, the HTLC script I posted on the list about not long ago (OP_IF operates on the result from OP_SIZE). Counter-examples would be BIP 124, the examples in BIP 65 and BIP 112, but I note all of these could be just as easily done without the explicit boolean being fed to the OP_IF (you'd need an OP_DUP to keep the value, so it wouldn't reduce the byte-size).
Of course, as long as we're talking about a softfork activating together with segwit, and only having effect in segwit scripts... there's no reason we can't add whatever opcodes we need so long as it gets done before 0.13.1. I suggest OP_CASTTOBOOL and OP_DUPASBOOL would be two good candidates if we make OP_IF stricter. There's also the possibility of adding an OP_RETAINIF which behaves as the current OP_IF, except not popping the conditional value off the stack. But perhaps this is getting too complicated for testing in time for segwit...

@_date: 2016-08-18 21:09:00
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Status updates for BIP 9, 68, 112, and 113 
As things stand right now, none of the Authors have commented on changing the type. It has been a month, and I am prepared to change the status to Final or Active; but I am unclear if your comments were an objection to changing the status or not.
Last call: Does anyone mind if I update BIP 9 to Final status?

@_date: 2016-08-23 20:12:11
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Status updates (including to Active/Final Status) 
A number of BIPs seem ready for updating to Final Status. If there are no objections, I will update these in 2 weeks:
BIP 39: Mnemonic code for generating deterministic keys
- Used by many wallets and hundreds of thousands of users.
BIP 44: Multi-Account Hierarchy for Deterministic Wallets
- Appears to be implemented by multiple wallets.
BIP 67: Deterministic Pay-to-script-hash multi-signature addresses through
        public key sorting
- Implementations in multiple wallet software exist.
BIP 125: Opt-in Full Replace-by-Fee Signaling
- Implemented in Bitcoin Core and derivatives; appears to be in regular use on the network.
BIP 130: sendheaders message
- Implemented in Bitcoin Core and derivatives.
Also, BIP 43 (Purpose Field for Deterministic Wallets) is an informational BIP which appears to be guiding to some extent the creation of new BIPs; therefore I propose its Status be upgraded to Active. I will make this update in 2 weeks also, if no objections.
Additionally, BIP 111 (NODE_BLOOM service bit) has been implemented in Bitcoin Core and derivatives; it is unclear if used by clients yet. Can developers of such clients please comment and let me know: 1) if their software supports this BIP already; 2) if not, do they intend to support it in the future?
If and only if there are any clients using this service bit already, I will update BIP 111 to Final Status in 2 weeks also.

@_date: 2016-08-24 18:22:39
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Status updates (including to Active/Final 
On Wednesday, August 24, 2016 1:47:08 PM Andreas Schildbach via bitcoin-dev Right. The Status doesn't depend on whether it is a good idea or not, only whether or not people are de facto using it.
BIP 2's BIP Comments would have provided a place for Thomas and yourself to criticise the BIP, but unfortunately this was too controversial.
BIP 43 merely advises other BIPs how they might do things, so it goes into the Draft->Active Status flow rather than Draft->Accepted->Final.

@_date: 2016-12-01 20:44:06
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] New BIP: Hardfork warning system 
I think this "should" needs to be a "must" be make this useful.
This seems too unclear. Specifically, if an invalid chain with *equivalent or better* work than the best valid chain exists, nodes ought to treat all blocks following the common chain (between the better-invalid and best-valid chains) as suspect.
So if we have two chains:
    A->B->C->D (valid)
    A->B->X->Y (invalid)
The node should consider block B as the tip until the valid chain becomes and stays longer than the invalid one.
I think we need to decide more specifically which behaviour is sane here.
Light nodes should probably not be specified here differently than full nodes. If they detect an invalid block through *any* means, they should react the same as a full node would.
Note, some changes may be needed to current nodes for this to work. I think at this time this would cause a "deserialisation" error, and not accept NOR reject the block...
Not necessarily. A secondary PoW might drastically change the measurement of work. Fixing block withholding may result in block hashes that meet a preimage rather than bits directly. I think it may be important to fix the latter problem for this BIP.
Probably best to not call this a hardfork, since it is a break without

@_date: 2016-12-02 04:18:21
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] New BIP: Hardfork warning system 
The difference is that right now, full nodes will happily follow a shorter best-valid chain. This BIP would require them to hold back at the best-common block between the best-valid chain and the invalid chain, forcing the user to make a decision whether to reject the invalid chain permanently, or upgrade to a version which can understand that chain as valid.
Note: a malicious "SHF" is not a SHF at all, but an "evil fork".
Nodes implementing this BIP will see it as a simple hardfork, but will intentionally provide equivalent behaviour as older nodes which see it as a soft-hardfork. In other words, all [compatible] hardforks will now behave like a soft-hardfork without any special DMMS design.
If Bitcoin's eventual hardfork is far enough down the road (such that no nodes remain from before this BIP are adopted), the SHF design could be safely done away with entirely. And either way, it makes it easier to resist an un-
consented-to hardfork.

@_date: 2016-12-10 21:41:57
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Forcenet: an experimental network with a new 
PR welcome.
See But yes, the 448 bits total target is to optimise the tree-building.
It already is. This is a primary goal of the new protocol.
Adding new trees means more hashing to validate blocks, so it'd be better to keep it at a minimum.

@_date: 2016-12-14 11:07:14
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Forcenet: an experimental network with a new 
Actually, there is: lock times... my overflow solution doesn't have a solution to that. :x

@_date: 2016-12-15 01:48:23
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - Block75 - Managing max block size as we do 
Please use ASCII quotes in the Title. It is also too long (max size 44 Add missing headers:
  Layer: Consensus (hard fork)
  Comments-Summary: No comments yet.
  Comments-URI: TBD
  Status: Draft
  Type: Standards Track
  License: PD
It must be made at least technically sound. The BIP talks about adjusting the maximum block size, but the specification only affects MAX_BLOCK_BASE_SIZE, which does not actually affect the max block size at all. Either the specification needs to implement the described goal (adjusting max block size) or the motivation needs to be adjusted to explain why MAX_BLOCK_BASE_SIZE is being adjusted.
It is missing a section on Backward Compatibility. This should address at least the fact that this is *NOT* backward compatible, and ideally propose a mechanism for establishing agreement from the entire community for its deployment. Similarly, there is talk of 75%, but the algorithm presented does not in fact implement 75%.
Finally, I am about to set BIP 2 to Active, so it would be preferable to choose a copyright license from the choices in BIP 2.
When you're ready, feel free to open a pull request on  with the BIP in mediawiki format, named:
    bip-tkhan-block75.mediawiki

@_date: 2016-02-01 19:46:23
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] SegWit GBT updates 
Allowing for simpler cases both encourages the lazy case, and enables pools to require miners use it. It also complicates the server-side implementation somewhat, and could in some cases make it more vulnerable to DoS attacks. Keep in mind that GBT is not merely a bitcoind protocol, but is used between
pool<->miner as well... For now, it makes sense to leave "default_witness_commitment" as a bitcoind-specific extension to encourage adoption, but it seems better to leave it out of the standard protocol. Let me know if this makes sense or if I'm overlooking something.
It can always use libblkmaker to handle the "heavy lifting"... In any case, the calculation for the commitment isn't significantly more than what it must already do for the stripped merkle tree.
That's not really fair IMO. I wrote the libblkmaker branch prior to even reading the SegWit BIPs or code, and without a way to test it. It's only to be expected there are bugs that get fixed in first-try testing.
I'm pretty sure this commit is actually /introducing/ a bug in working (albeit ugly) code. The height, while always positive, is serialised as a signed number, so 0x80 needs to be two bytes: 80 00.

@_date: 2016-02-01 22:53:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Process: Status, comments, and copyright licenses 
I've completed an initial draft of a BIP that provides clarifications on the Status field for BIPs, as well as adding the ability for public comments on them, and expanding the list of allowable BIP licenses.
I plan to open discussion of making this BIP an Active status (along with BIP 123) a month after initial revisions have completed. Please provide any objections now, so I can try to address them now and enable consensus to be

@_date: 2016-02-01 23:08:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] SegWit GBT updates 
Making it simpler to do a centralised implementation than a decentralised one, is both enabling and encouraging. GBT has always been designed to make it difficult to do in a centralised manner.
It's more work for the pool to provide it, similar to the "midstate" field was with getwork. Someone performing a DoS needs to do less work to force the pool to do complex calculations (unless the same transaction tree / commitment is used for all miners, which would be an unfortunate limitation).
Sure, I'm not suggesting we remove this from bitcoind (probably the only place that makes initial adoption easier).
I'm curious what bug it was fixing? Was it overwriting data beyond the number?

@_date: 2016-02-02 02:30:55
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] SegWit GBT updates 
libblkmaker is miner-side; right now it implies the miner using the templates as-is (perhaps after verifying the transactions meet some criteria), but it is the miner who is making that decision, not the pool.
The DoS is against the pool, not the miner. You'd attack by pretending to be 100000 new miners per second, and the pool then needs to calculate a witness commitment for each one. It's a lot cheaper to just serialise and send the transaction list.
Implementation-specific things aren't standards. And besides, they really *shouldn't* expect it from bitcoind; it's simply a reasonable compromise to provide it encourage adoption of SegWit. Once SegWit is live, there is no more value to doing so.

@_date: 2016-02-02 07:54:29
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Process: Status, comments, 
The original question is intended to answer both: a) why only one implementation is insufficient for Final status, and b) why two is sufficient.
If every application had its own BIP (how I understand your version), none of them would be standards and it wouldn't make sense to have a BIP at all - just project documentation would be sufficient.
Extending this to "influence" is probably too far - after all, comments may discourage implementations, which can very well result in the Status eventually becoming Rejected rather than Final. How about:
"To avoid doubt: comments and status are intended to be unrelated metrics. In other words, a BIP having the status 'Rejected' is no reason to write (or not write) additional comments about it, nor would a status of 'Final' preclude comments discouraging [further] implementation. Likewise, overwhelming support for a BIP in its comments section doesn't change the requirements for the 'Final' or 'Active' status."
Hmm, I wonder if this could be too easily abuse to discourage comments (because the commenter does not wish to register with yet another forum), and/or censor negative comments (because the author has made his own forum specifically for the purpose).
I have integrated this into the draft.
The intent is for the commenter to edit the wiki page himself. I have updated it to reflect this.

@_date: 2016-02-02 19:08:19
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Process: Status, comments, 
How can I improve this? Inevitably, every medium of communications will be controlled by someone (even if unmoderated, it becomes effectively controlled by trolls who spam it with garbage).
I think it's important to note that this is also only for updating the status of BIPs, and is not in any way relevant to such proposals *actually* being accepted. So if the BIP process were to breakdown on this or any other point, it isn't somehow controlling the actual reality. To explicitly clarify this point, I have added to the end of the section:
    "These criteria are considered objective ways to observe the de facto
     adoption of the BIP, and are not to be used as reasons to oppose or
     reject a BIP. Should a BIP become actually and unambiguously adopted
     despite not meeting the criteria outlined here, it should still be
     updated to Final status."
Does that help?

@_date: 2016-02-02 19:14:17
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment 
Agree with both Peter and Pieter. Note that BIP 74 was assigned to this proposal last Friday.

@_date: 2016-02-02 19:41:24
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Process: Status, comments, 
"Uncontroversial" doesn't really express the correct idea.
There has been a lot of confusion over "consensus rules/code" anyway, so while we're on the subject of terminology, I would suggest we change *that* use of "consensus" instead to clear up the confusion. It would probably work quite well to rename it to "concord rules/code", and leave "consensus" for describing the actual process by which humans agree on changes to the concord.
Anyone else have any thoughts on this subject?
(Note Core currently has "consensus" only 249 times, most of which are simply identifier names, so it would be trivial to make this change.)

@_date: 2016-02-03 00:03:31
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Process: Status, comments, 
The difficulty is that this BIP needs to refer to three different context of 1. Consensus (stated) among developers for changes in the BIP Process.
2. Economic consensus (potential and stated) to veto a soft-fork by an
   intended "firing" of the set of miners if they choose to enforce it.
3. (Actual) consensus in economic adoption of changed rules, to determine the
   success of a hard-fork (after the fact).
4. The set of rules currently established as (defining) Bitcoin, enforced by
   an (actual) consensus of economically-relevant nodes.
Context 3 can be disambiguated with "adoption consensus", and context 4 with "consensus rules" and/or "consensus protocol", but I don't see a clear solution that covers all four contexts, and even sharing the word "consensus" for them may be confusing.
In addition, usage of the word "consensus" for context 4 has proven confusing to users. For example, recently users misinterpreted the "Consensus" label used in context 4 as implying that the idea itself had in fact achieved consensus among some group of decision-makers (similar to context 1, but not necessarily the group being "developers").
I don't know a good way to make this completely clear, so suggestions are more than welcome.

@_date: 2016-02-04 04:15:46
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Process: Status, comments, 
This has moved to:
Various changes have been made based on initial input.
Further review and re-review is of course welcome.

@_date: 2016-02-04 18:29:11
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hardfork bit BIP 
Disagree with treating the "version" field as a number, in BIP 9 or this BIP which reinterpret it as a bit vector.
Minor nit (not relevant to actual proposal): This is not true. There are over 32 other bits (part of the "previous-block" field) which also serve no With the current codebase, it is significantly easier to trigger on the block timestamp rather than its height or median-time-past. Using either of the latter would require refactoring of CBlockIndex. As a hard-fork, even if the rules are ineffective for a few blocks following the forking point, using the hardfork version bit in this BIP would still ensure a clean break. While I agree that median-time-past and height are superior methods that ought to be used for hardforks, an emergency hardfork may need to avoid them for simplicity, and I don't think they need to be mandated as such in this BIP.
I would avoid implying the hardfork can be "officially deployed" without actual adoption.
This seems vulnerable to DoS attacks by rejected hardforks.
Rather not imply BIP 9 should be used for hardforks, or that miners have any voice in the decision. This is already a serious misconception.
This is not actually desirable, and would suggest a possible reason *not* to comply with this BIP. A legitimate hardfork would never have two continued sets of rules for miners to choose from.

@_date: 2016-02-04 21:17:30
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Process: Status, comments, 
The wiki page is meant to be a place to leave comments recommending or discouraging adoption of a completed BIP, after discussion is over. For example, many people seem to think BIP 38 is a good idea simply because it is a Final BIP, whereas in general we would want to discourage using it since it cannot really be used safely.
All review itself ought to remain on the ML.
Is this necessary considering the author-chosen forum may only be *in addition to* the Bitcoin Wiki?
It should be everything except accounts/passwords.

@_date: 2016-02-05 23:25:14
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP draft: Hard fork opt-in mechanism for SPV 
Soft-hardforks have the same behaviour for both SPV and full nodes.
I don't see the point in making this SPV-only "middle layer"...

@_date: 2016-02-06 00:12:25
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: Increase block size limit to 2 
Can you put this in the BIP's Rationale section (which appears to be mis-named "Discussion" in the current draft)?
These seem like they will break static analysis entirely. That was a noted reason for creating BIP 16 to replace BIP 12. Is it no longer a concern? Would it make sense to require scripts to commit to the total accurate-sigop count to fix this?
The rationale for this wasn't in your blog post. I assume it's based on the current theoretical max at 1 MB blocks? Even a high-end PC would probably take 40-80 seconds just for the hashing, however - maybe a lower limit would be But miners don't get to decide hardforks. How does the economy express their support for it? What happens if miners trigger it without consent from the If you are intent on using the version bits to trigger the hardfork, I suggest rephrasing this such that miners should only enable the bit when they have independently confirmed economic support (this means implementations need a config option that defaults to off).
Would prefer if this is corrected to "Light clients" or something. Actual SPV wallets do not exist at this time, and would not be compatible with a IMO this sentence is the most controversial part of your draft, and it wouldn't suffer a loss to remove it (or at least make it subjective).
I would also prefer to see any hardfork:
1. Address at least the simple tasks on the hardfork wishlist (eg, enable some
   disabled opcodes; fix P2SH for N-of->15 multisig; etc).
2. Be deployed as a soft-hardfork so as not to leave old nodes entirely
   insecure.

@_date: 2016-02-06 20:36:23
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: Increase block size limit to 2 
Do you have evidence these are intentionally unmaintained, and not users who have simply not had time to review and decide on upgrading?
If so, it is only based on misinformation. I am concerned you are implying this conclusion is true. When I spoke with you maybe a year ago with my concerns that block size might grow too fast, you suggested that the miners could be trusted to not increase the block size until necessary (which is not likely to be any time soon, despite the massive misinformation campaigns out I have seen evidence which suggests the contrary. For example:
    Where is yours?
But this isn't about the miner opting in, it is about the miner *observing economic support* for the change. I have successfully downloaded Bitcoin Classic's beta binaries without ANY warning that by running it, I am expressing that I believe the economy has approved of a hardfork.
Not that I am aware of. (But both reddit comments and forum posts have  outlived many other posts, such as blogs, so I'm not sure why to exclude them In any case, since SPV nodes don't exist, there is probably no real need to address them. Everyone will know what "light client" means.
Working on a BIP draft for it, but it's not ready for publication yet. The basic idea is to turn the merkle root in the block header into simply a hash of a second block header, which is constructed to parse as a valid empty generation transaction under the old rules. Thus, old nodes see the forked blockchain as valid with continually growing work on it, but as if the blocks were all empty. This protects them from attackers mining a short blockchain they perceive as valid.

@_date: 2016-02-06 20:46:39
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: Increase block size limit to 2 
Until someone decides to attack you. Then you'll get 6, 10, maybe more blocks confirming a large 10000 BTC payment. If you're just a normal end user (or perhaps an automated system), you'll figure that payment is good and irreversibly hand over the title to the house.

@_date: 2016-02-07 09:52:31
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Pre-BIP Growth Soft-hardfork 
Here's a draft BIP I wrote almost a year ago. I'm going to look into revising and completing it soon, and would welcome any suggestions for doing so.
This hardfork BIP aims to accomplish a few important things:
- Finally deploying proper merge-mining as Satoshi suggested before he left.
- Expanding the nonce space miners can scan in-chip, avoiding expensive
  calculations on the host controller as blocks get larger.
- Provide a way to safely deploy hardforks without risking leaving old nodes
  vulnerable to attack.

@_date: 2016-02-07 21:01:13
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: Increase block size limit to 2 
I'm assuming there are literally ZERO miners left on the weaker branch.
The attacker in this scenario simply rents hashing for a few days in advance to build his fake chain, then broadcasts the blocks to the unsuspecting merchant at ~10 block intervals so it looks like everything is working normal again. There are lots of mining rental services out there, and miners quite often do not care to avoid selling hashrate to the highest bidder regardless of what they're mining. 10 blocks worth costs a little more than 250 BTC - soon, that will be 125 BTC.

@_date: 2016-02-08 22:17:55
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Final status 
proposes updating the status of many Accepted BIPs to Final:
BIP 11: M-of-N Standard Transactions
BIP 14: Protocol Version and User Agent
BIP 21: URI Scheme
BIP 22: getblocktemplate - Fundamentals
BIP 23: getblocktemplate - Pooled Mining
BIP 31: Pong message
BIP 32: Hierarchical Deterministic Wallets
BIP 34: Block v2, Height in Coinbase
BIP 35: mempool message
BIP 37: Connection Bloom filtering
BIP 65: OP_CHECKLOCKTIMEVERIFY
This PR has been open for a week, and I plan to merge it within the next week unless there are objections.
Additionally,  proposes to upgrade five additional from Draft to Final status, and preferably needs ACKs from the champions of the BIPs:
BIP 50: March 2013 Chain Fork Post-Mortem, by Gavin Andresen
BIP 60: Fixed Length "version" Message (Relay-Transactions Field), by Amir
        Taaki
BIP 64: getutxo message, by Mike Hearn
BIP 66: Strict DER signatures, by Pieter Wuille
BIP 73: Use "Accept" header for response type negotiation with Payment Request
        URLs, by Stephen Pair

@_date: 2016-02-08 22:57:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Final status 
I agree BIP 50 could use some rephrasing, but the May 2013 change was definitely a hardfork, despite the problems with the pre-March protocol.

@_date: 2016-02-09 22:10:43
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] On Hardforks in the Context of SegWit 
The extranonce rolling doesn't necessarily need to happen in the ASIC itself. With the current extranonce-in-gentx, an old RasPi 1 can only handle creating work for up to 5 Gh/s with a 500k gentx.
Furthermore, there is a direct correlation between ASIC speeds and difficulty, so increasing the extranonce space dynamically makes a lot of sense.
I don't see any reason *not* to increase the minimum difficulty at the same time, though.

@_date: 2016-02-17 00:46:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Proposal] New "feefilter" p2p message 
What happened to extensibility? And why waste 64 bits for what is almost certainly a small number?
This seems to make feefilter entirely useless for wallets?

@_date: 2016-02-17 02:36:09
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Proposal] New "feefilter" p2p message 
We shouldn't need a new protocol [extension] for every new policy. Obviously this can't be perfectly flexible, but supporting different feerate definition versions is trivial and obvious.
In Core, they aren't (but Core never uses bloom filters anyway) - because otherwise it would leak privacy. But light clients (particularly overlapping with those that use bloom filters!) have no privacy in the first place, so they have no reason to use this rule.

@_date: 2016-02-26 02:35:23
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] SIGHASH_NOINPUT in Segregated Witness 
I'd like this regardless of Lightning, as it makes it possible to write fully malleability-proof wallet software also.
SegWit's malleability solution is not really sufficient in comparison, but I don't think there's a need to make this available to pre-SegWit transactions anyway (and doing so would probably complicate it).

@_date: 2016-01-04 21:53:36
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Increasing the blocksize as a (generalized) 
FWIW, this is something I've been planning to proposed (in a nicer form) for a while, tentatively called a "soft hardfork" (or less-seriously a "softserve hardfork"). The big piece missing that I've been holding off on publishing it as a BIP until complete, is a planned-out defensive reaction for a community which wishes to reject the hardfork. I guess I should probably prioritise this a bit more now...

@_date: 2016-01-07 17:10:55
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] New BIP editor, and request for information 
Greg has requested that I take over as the BIP editor responsible for assigning BIP numbers. Before I begin, I would like to ensure I have a correct record of what has already been assigned or soft-assigned so I don't overlap them, as the BIPs repository appears that it may possibly be incomplete.
If you have been assigned (or soft-assigned) a BIP number - or any other information that may be relevant to my performing this role, please reply and let me know, preferably within the next 24 hours if possible (as there are many BIP drafts awaiting assignments).
Getting into some specifics...
- BIP 46 is missing from the repository, but apparently self-soft-assigned by Tier Nolan in  ; if this was later assigned official, or if he is still interested in pursuing this, it seems logical to just keep it at BIP 46.
- BIPs 80 and 81 are currently part of an open pull request  but it is unclear if they were formally assigned or not.
- BIP 82 is currently officially assigned and pending in  ; I personally think this is outside the scope of BIPs since it does not deal with Bitcoin, and encourage Justus to move it to the SLIP standard, but will honour this assignment unless he tells me he is moving it. (But understand this will not set a precedent for strictly non-Bitcoin things being assigned BIPs...)
- BIP 100 is missing from the repository, and I am uncertain if it was ever properly assigned. Considering that the 10x block has mostly been used for similar proposals, and BIP 100 is fairly well-established as "BIP 100", it seems logical to just make this its official assignment.
- BIP 104 is missing from the repository, but was apparently used unofficially by  at one time. But I do not see an actual specification in this PDF, so as far as I know BIP 104 appears to be available?
- BIP 109 was soft-assigned for  but as this doesn't fit with the rest of 10x, I am inclined to give it a new number outside that range unless there are objections.
- BIP 122 is missing from the repository, and was self-soft-assigned by Chris Priest for "ScaleNet" in  ; there are concerns whether testnets are appropriate for standardisation at all, but since it has received sufficient discussion on the mailing list and others appear to agree with the effort, it seems reasonable to err in favour of assigning it a BIP number (not necessarily 122) if Chris wishes to further pursue the idea and add an actual specification to the draft.
To be clear: except for BIPs 82 and 109, and those appearing in the  repository at present, anyone (preferably the author, but not necessarily if they are away) aware of any other BIP assignments should reply to this message indicating the status of such BIPs and their assigned numbers.

@_date: 2016-01-19 02:12:29
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP/Draft] BIP Acceptance Process 
Are you saying your proposal is intentionally not intended to reflect the reality? I wasn't talking about a "current state of affairs" for BIPs as much as that that the acceptance of BIPs is *defined by* the state of affairs.
Overall, I think something *similar to* this proposal is a good idea, but I disagree with how this proposal currently approaches the problem. Instead, what I would recommend is a specification based on BIP 123 that specifies the conditions under which a proposal is *known to be* accepted by the community (ie, discerning, not deciding), and establishes a way for a committee to review the BIP and *determine* if these conditions have been met. This would avoid a "disconnect" between the "official status" and reality, making the BIP process more useful to everyone.
Reviewing your current proposal:
As mentioned, IMO a committee shouldn't be indicating acceptance, as much as it should be *determining* acceptance.
1% seems like an awful lot to dedicate to BIP status changes.
That sounds very time consuming. And what happens if these committees don't represent the community? What about when only part of the community - let's say 10% - decides to adopt a BIP that doesn't require consensus? Logically that BIP should still proceed...
But the Bitcoin user base is completely unknown, and tracking software user base is a privacy violation.
Bitcoin economic activity is also unknown, and it seems likely that merchants consider their own activity confidential.
This needs a proper specification. How do miners express their positions?
Chosen how, and by whom?
Until this BIP is active, its rules do not apply, so this would be a form of circular reasoning. I like the idea of putting conditions for activation in the BIP text, but I don't think we can just let the author set any conditions they like either...

@_date: 2016-01-26 02:24:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment 
This is a bad idea. OP_RETURN attachments are tolerated (not encouraged!) for the sake of the network, since the spam cannot be outright stopped. If it could be outright stopped, it would not be reasonable to allow OP_RETURN. When it comes to the payment protocol, however, changing the current behaviour has literally no benefit to the network at all, and the changes proposed herein are clearly detrimental since it would both encourage spam, and potentially make users unwilling (maybe even unaware) participants in it. For these reasons, *I highly advise against publishing or implementing this BIP, even if the later mentioned issues are fixed.*
Such a "proof" is useless without wallet support. Even if you argue it could be implemented later on, it stands to reason that a scammer will simply encode garbage if the wallet is not checking the proof-of-purchase upfront. To check it, you would also need further protocol extensions which are not included in this draft.
I don't see how this has any relevance to keys at all...
This does not appear to be backward nor even forward compatible. Old clients will continue to use the previous behaviour and transparently omit any commitments. New clients on the other hand will fail to include commitments produced by old servers. In other words, it is impossible to produce software compatible with both BIP 70 and this draft, and implementing either would result in severe consequences.
It is better for the spammers to lose burned bitcoins, than have a way to avoid them.

@_date: 2016-01-26 02:56:54
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment 
As I explained, none of those reasons apply to PaymentRequests.
I have no idea what you are trying to say here.

@_date: 2016-01-26 03:04:33
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment 
OP_RETURN can be used, but you need to burn coins. I don't see any benefit to changing that. It is better that coins are burned.
You *always* need a key, to redeem inputs... regardless of values.

@_date: 2016-01-26 03:12:24
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment 
My point is that there isn't a better alternative. The coins being burned, is strictly better than it being gratis.
This is also a good thing. Spam should not be made easier or cheaper.

@_date: 2016-01-26 03:23:13
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment 
Perhaps not, but in this context I cannot think of any non-spam use cases.
Use cases should come before changes to support them.
Lost value is better because it has a cost to the spammer, and deflates the rest of the bitcoins.

@_date: 2016-01-30 18:50:02
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] SegWit GBT updates 
============================== START ==============================
I've completed an initial draft of a BIP for updating getblocktemplate for segregated witness here:
    Please review and comment (especially with regard to the changes in the sigoplimits handling).
(Note: libblkmaker's reference implementation is at this time incompatible with the "last output" rule in this BIP.)

@_date: 2016-07-06 01:22:19
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Number Request: Open Asset 
I was waiting for clarification on the Author thing, but Nicholas hasn't responded yet. I am unaware of any reason NOT to assign it, and there appear to be no objections, so let's call it BIP 160.

@_date: 2016-07-15 16:08:51
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Status updates for BIP 9, 68, 112, and 113 
Daniel Cousens opened the issue a few weeks ago, that BIP 9 should progress to Accepted stage. However, as an informational BIP, it is not entirely clear on whether it falls in the Draft/Accepted/Final classification of proposals requiring implementation, or the Draft/Active classification like process BIPs. Background of this discussion is at:
    (Discussion on the GitHub BIPs repo is *NOT* recommended, hence bringing this topic to the mailing list)
Reviewing the criteria for status changes, my opinion is that:
- BIPs 68, 112, 113, and 141 are themselves implementations of BIP 9

@_date: 2016-07-31 05:18:18
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Holdup on Block Alerts / Fraud Proofs ? 
Essentially this comes down to attackers being able to construct a block for which invalidity cannot be proven. While you could always show a proof for an invalid transaction within a well-formed block, you cannot show a proof that a block is not well-formed. For example, the merkle tree that ought to represent a set of transactions may be corrupted in such a manner that the transaction paying Alice can have a SPV proof made, but the links in the merkle path have no known data (transactions) behind them. This could even be a perfectly valid block, but with some of the transactions withheld until it is stale - full nodes and miners cannot accept it without knowing the entire block's transactions. The only solution to this I am aware of, is for Alice to be told "hey, block XYZHASH is incomplete and cannot be checked", and then Alice demands the full block from the attacker. But of course this makes it trivial to DoS Alice by giving her bogus incomplete-block claims and forcing her to use the same bandwidth as a full node - which is a major problem if she lacks the bandwidth to run a full node (presumably her reason for using SPV in the first place).

@_date: 2016-06-02 00:41:27
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP draft: Memo server 
First of all, and most importantly, I like the idea/concept.
The first issue I see is that this scheme exposes private information in the form of which inputs/outputs are related to the user. But IMO this information should also be private and kept encrypted, so memo servers don't have anything at all to leak. Note this necessarily means you can't reuse the keys for the blockchain UTXOs for memos. But such key reuse is also a risk that should be avoided anyway. Instead, I suggest encrypting all the memos to an arbitrary key which is derived from the HD seed and shouldn't ever be used for UTXOs.
Ideally, the memo server shouldn't be tied to a specific wallet schema. So the next step is to not tell the memo server anything except your memo-specific identifier (which can be a hash of a pubkey, or really anything at all - there's no reason the memo server needs to know ANYTHING about the user's wallet). Using an arbitrary identifier of sufficient length allows for future wallet schemas to continue to use the same memo servers. (The specifics on how to derive the identifier can be specified in a separate BIP to ensure wallets can be compatible with each other.)
I don't think there is a real need for memo servers to sync data. It should be sufficient for users to decide on two or more memo servers they wish to entrust their memos with, or possibly trust only their own memo server(s).
There should probably also be a way for memos of different types. Some wallets might only support simple memos, but others might associate more data for (eg) proof-of-existence schemas. What types are used *might* be desirable to encrypt as well, so this should probably be in the second "how wallets use it" IIRC, Electrum already has some kind of "memo server" interface in a plugin. Have you looked at how it works, and considered its features (and/or flaws) for your proposal?
Finally, using "?data&data&data" doesn't follow the standard "?key=value&key=value" scheme; simple to fix.

@_date: 2016-06-08 07:29:22
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP141 segwit consensus rule update: extension of 
I don't see a sufficient answer to this question. Pieter explained why >75 would be annoying, but 75 seems like it should be fine.
It's not that simple, since this is preventing use of the witness field for such scripts. With this limit in place, any such a softfork would suddenly require either two different witness commitments, or disabling the previous witness transaction format.

@_date: 2016-06-08 16:45:10
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP141 segwit consensus rule update: extension of 
There is no harm in being lenient, but it limits the ability to do softfork upgrades in the future. I appreciate Pieter's concern that we'd need to do more development and testing to go to this extreme, which is why I am only asking the limit raised to 75 bytes.

@_date: 2016-06-21 20:44:37
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070 
IMO JSON is too prone to gratuitous inefficiency (both at network and CPU level), parser bugs, etc. Even the best C implementation (jansson) has serious issues with Number handling.
A few years ago, I looked into binary alternatives to JSON and concluded they all had problems, while it seems more than reasonable to do even dynamic parsing of protobuf messages. So to conclude, I prefer to stick to protobuf unless a clearly superior protocol turns up.
X509 is entrenched, so it should remain supported. PGP might make sense for people already using it (it provides no real security for un-WoT-networked users), but unforunately, few people use it. Correct me if I'm wrong, but IIRC Keybase uses blockchain spam, so definitely not something to be encouraged if so. Namecoin seems like a more than reasonable decentralised solution, but will probably take some real work to implement (not that this is avoidable for a general-usage decentralised solution).
What do you mean by this? There's the memo field at least.
I'd discourage anything using BIP 47 due to its serious design flaws.
No reason a regular BIP 32 pub seed can't be used instead.
What do you mean by "replacement addresses" and "UI confirms" here?
Disagree with hard-coding intervals, or mandating specific policies from the service providers.
This is wallet policy, but maybe makes sense as a "best practices" BIP.

@_date: 2016-06-22 00:36:53
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070 
I suppose it makes sense that since every payment requires communication with the recipient, that the recipient could give you a new scriptPubKey each time. No need to save [potentially compromised] payment info in advance?
The point, as I see it, of payment protocol(s) is to deprecate addresses.
ie, this new protocol *could be* the BIP 32 pub seed destination address. ;)
Maybe just a field specifying how far in advance payments should be sent,

@_date: 2016-03-01 17:12:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.12.0.knots20160226 release candidate 
Binaries for Bitcoin Knots version 0.12.0.knots20160226.rc1 are available from:
    Source code can be found on GitHub under the signed tag:
    This is a release candidate for a new major version release, bringing new
features, bug fixes, as well as other improvements.
Preliminary release notes for the release can be found here:
    Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as final.
Please report bugs using the issue tracker at GitHub:
    Additional Gitian signatures are welcome. Please submit via GitHub pull
request to:

@_date: 2016-03-02 14:56:14
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hardfork to fix difficulty drop algorithm 
We are coming up on the subsidy halving this July, and there have been some concerns raised that a non-trivial number of miners could potentially drop off the network. This would result in a significantly longer block interval, which also means a higher per-block transaction volume, which could cause the block size limit to legitimately be hit much sooner than expected. Furthermore, due to difficulty adjustment being measured exclusively in blocks, the time until it adjusts to compensate would be prolonged.
For example, if 50% of miners dropped off the network, blocks would be every 20 minutes on average and contain double the transactions they presently do. Even double would be approximately 850-900k, which potentially bumps up against the hard limit when empty blocks are taken into consideration. This situation would continue for a full month if no changes are made. If more miners drop off the network, most of this becomes linearly worse, but due to hitting the block size limit, the backlog would grow indefinitely until the adjustment occurs.
To alleviate this risk, it seems reasonable to propose a hardfork to the difficulty adjustment algorithm so it can adapt quicker to such a significant drop in mining rate. BtcDrak tells me he has well-tested code for this in his altcoin, which has seen some roller-coaster hashrates, so it may even be possible to have such a proposal ready in time to be deployed alongside SegWit to take effect in time for the upcoming subsidy halving. If this slips, I think it may be reasonable to push for at least code-readiness before July, and possibly roll it into any other hardfork proposed before or around that I am unaware of any reason this would be controversial, so if anyone has a problem with such a change, please speak up sooner rather than later. Other ideas or concerns are of course welcome as well.

@_date: 2016-03-02 15:14:35
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hardfork to fix difficulty drop algorithm 
The exchange rate is not significantly influenced by these things. Historically, it seems fairly obvious that the difficulty has followed value, not value following difficulty.
Depends on the hashrate drop, and tolerance for higher fees, both of which are largely unknown at this time. At least having code prepared for the negative scenarios in case of an emergency seems reasonable, even if we don't end up needing to deploy it.

@_date: 2016-03-02 15:42:28
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hardfork to fix difficulty drop algorithm 
Lapse of thinking/clarity here. This probably isn't a practical timeframe for deployment, unless/until there's an emergency situation. So if the code were bundled with SegWit, it would need some way to avoid its early activation outside of such an emergency (which could possibly be detected in code, in this case).

@_date: 2016-03-08 17:19:19
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Services bit for xthin blocks 
Bitcoin-dev and the BIP process are not affiliated with Core at all. In fact, the BIP process was created by Amir Taaki, who was a libbitcoin developer (libbitcoin is not Core).
I encourage Bitcoin Unlimited to use the BIP process for cross-implementation standards like this, as do other implementations, so that you can benefit from peer review from the wider Bitcoin development community, as well as have a common repository for these standards.
Many BIPs are discussed on reddit in addition to this mailing list, and you would certainly remain free to discuss your own proposals on any forum you like - it isn't restricted to only this mailing list.
If this is of interest, I will be happy to try to go over and assign BIP numbers to the current (15?) BUIPs assuming they meet the basic requirements for such assignment (see BIP 1:  Is there an easy way to get links to each of the BUIPs? I couldn't find BUIP 1 at all, for

@_date: 2016-03-08 19:04:27
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 2 promotion to Final 
It has been about 1 month since BIP 2 finished receiving comments, so I believe it is an appropriate time to begin the process of moving it to Final Status. Toward this end, I have opened a pull request:
    The current requirement for this is that "the reference implementation is complete and accepted by the community". Given the vagueness of this criteria, I intend to move forward applying BIP 2's more specific criteria to itself:
Furthermore, there is a reference implementation in the mentioned PR.
Please review the latest draft BIP and provide any objections ASAP.
If there are no outstanding objections on 2016 April 9th, I will consider the current draft to have reached rough consensus and update its Status to Final by merging the PR.

@_date: 2016-03-08 22:34:13
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Proposed BIP extension to BIP 0070 
Is there a way for Joe Mobile Wallet User to upload a set of N PaymentRequests authenticated by his key to an untrusted server, which encrypts and passes them on in response to InvoiceRequests? Or does this necessarily require the recipient to be online?

@_date: 2016-03-10 16:43:59
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 2 promotion to Final 
In this scenario, it would seem the previous Bitcoin is alive any working, and that the hard-fork has failed. How to resolve such a split is outside the scope of the BIP process IMO.

@_date: 2016-03-16 22:24:30
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 2 promotion to Final 
BIP Comments are not a part of the BIP itself, merely post-completion notes from various external parties. So having them external does not make the BIP any less self-contained. Right now, this information takes the form of reddit/forum comments, IRC chats, etc.
It is important that the forum for comments have a low barrier of use. The Bitcoin Wiki requires only a request for editing privileges, whereas GitHub wiki would require reading and agreeing to a lengthy Terms of Service In terms of staleness, the Wiki has been shown to stand the test of time, and is frankly less likely to move than the GitHub repository.
The BIP process originated on the Wiki, and was only moved to GitHub because stronger moderation was needed (eg, to prevent random other people from editing someone else's BIP; number self-assignments; etc). Such moderation is not only unnecessary for BIP Comments, but would be an outright nuisance.
I hope this addresses all your concerns and we can move forward with BIP 2 (On another note, I wonder if we should recommend non-reference implementation lists/links be moved to BIP Comments rather than constantly revising the BIPs with them...)

@_date: 2016-03-18 19:34:52
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 2 promotion to Final 
Yes, discussion for the BIP still happens on the mailing list.
Weak? What does that even mean? GitHub's terms are no trivial list. It's not a matter of "easy", but whether you're willing to agree to the terms or not - and people should be free to participate without doing so. The Bitcoin Wiki has never had a problem with whitelisting people, and isn't exclusively available via IRC.
GitHub's collaborative features for the wiki function is clearly inferior.
Then you're essentially standing in the way of BIP 2 and stalling it.
I have no interest in having to manually approve every single little comment on BIPs, and I think it's likely nobody will use it if doing so requires such

@_date: 2016-03-24 02:16:55
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] p2p authentication and encryption BIPs 
In the future, please submit BIP drafts to the mailing list for comment and initial peer review before opening a pull request (or requesting a BIP number assignment), per BIP 1.
As long as the format of these databases is not standardised, it seems inappropriate to define *any* of this implementation detail in a BIP.
How does a peer know what messages the other peer requires to be Seems a waste to include this with every single [authenticated] message...
Is this required to persist across connections/restarts/possibly complete Can the same auth-msg-id be used for multiple peers, so a message can be signed once and sent to all N peers?
How does banning in this specific case enable fingerprinting as opposed to any other banning?
If this is going to become a general-purpose identity system, I think more is needed than a simple EC keypair. At the very least, it should probably use a HD chain and use a new key for every signature (notice you already have auth-
msg-id to use with this!).
... and not process it at all? How is that backward compatible?
I don't see how Tor fails this criteria...
What default? Is the timeout field optional? Why not simply require it?
How should the supporting peer handle the message being ignored?

@_date: 2016-05-11 14:28:24
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Making AsicBoost irrelevant 
What if we XOR bytes 64..76 with the first 12 bytes of the SHA2 midstate? Would that work?

@_date: 2016-05-26 00:00:37
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] RFC for BIP: Best Practices for Heterogeneous 
This is assigned BIP 126.
Transactions are never from Bitcoin addresses, and inputs almost never have identical scripts (although the UTXOs they are spending often do).

@_date: 2016-05-26 03:53:04
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Number Request: Open Asset 
Is he the author of this BIP, or merely the protocol described in it?
Would it perhaps make sense to include yourself in the author list?
Quite a bit ugly, giving a meaning to an input's pubkey script like that.
But more problematically: how can this work with other pubkey scripts? Particularly relevant now that this old script format is being deprecated.
Another possible problem is that I don't see a way to provably guarantee an asset issuance is final.
And the assets attached to its inputs are destroyed? Or?
Is it intentional that the first case is "parsable", and the second "valid"?
I think these need to be better specified; for example, it is not so clear how to reach if the OAP version number is something other than 1: is that parsable? valid?
What determines the asset id? How would one issue and/or transfer multiple asset ids in the same transaction?
What if I have a transaction with 5 outputs, the marker output at position 3, and all 4 other outputs are to receive assets? Does the marker output get skipped in the list (ie, the list is 4 elements long) or must it be set to zero quantity (ie, the list is 5 elements long)?
I don't understand this.
Embedding data is not recommended at all. It seems a better way to have done this would be to put the info in an OP_DROP within a P2SH or witness script.
Addresses are not used for spending bitcoins, only for receiving them. The way this BIP uses inputs' pubkey script is extremely unusual and probably a bad As I understand it, this would require address reuse to setup, which is not supported behaviour and insecure.
How is this compatible? Won't an older client then accidentally destroy

@_date: 2016-11-17 03:06:01
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Proposal] Buried Deployments 
While this is technically a softfork, I think it may behave somewhat like a hardfork if we're not careful. Particularly, is the chain up to the block immediately before the checkpoint itself valid on its own, or does it simply become retroactively valid when it hits that checkpoint?
P.S. Your PGP signature is invalid?

@_date: 2016-11-30 10:20:30
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP status updates & BIP 2 activation 
============================== START ==============================
To conclude discussion on BIP 2, I have opened a pull request to implement it and mark it active. Note this implies activation and implementation of BIP 123 as well: I plan to merge this on December 14th. If there are any hard objections to this change, please bring it up on the bitcoin-dev mailing list before then. Further reviews of the implementation are welcome in the meantime. Please refrain from requesting further changes to the BIPs themselves unless it is a blocker/show-stopper or trivial (not changing the meaning).
In the process of implementing BIP 2, I came across a number of BIPs which managed to get into the repository without a proper license. Authors of any of these BIPs should open a pull request adding the necessary Copyright section and License header(s). (If there are other contributors to the document in the BIP git logs, I will try to reach out to them to get permission. If you have accepted contributions from anyone not documented in git as an Author, please mention this in the PR explicitly.)
These BIPs need a license:
 001  BIP Purpose and Guidelines
 010  Multi-Sig Transaction Distribution
 011  M-of-N Standard Transactions
 012  OP_EVAL
 013  Address Format for pay-to-script-hash
 014  Protocol Version and User Agent
 015  Aliases
 016  Pay to Script Hash
 021  URI Scheme
 030  Duplicate transactions
 031  Pong message
 032  Hierarchical Deterministic Wallets
 033  Stratized Nodes
 034  Block v2, Height in Coinbase
 035  mempool message
 039  Mnemonic code for generating deterministic keys
 043  Purpose Field for Deterministic Wallets
 044  Multi-Account Hierarchy for Deterministic Wallets
 045  Structure for Deterministic P2SH Multisignature Wallets
 047  Reusable Payment Codes for Hierarchical Deterministic Wallets
 061  Reject P2P message
 062  Dealing with malleability
 064  getutxo message
 066  Strict DER signatures
 067  Deterministic Pay-to-script-hash multi-signature addresses through
          public key sorting
 068  Relative lock-time using consensus-enforced sequence numbers
 070  Payment Protocol
 071  Payment Protocol MIME types
 072  bitcoin: uri extensions for Payment Protocol
 073  Use "Accept" header for response type negotiation with Payment Request
          URLs
 075  Out of Band Address Exchange using Payment Protocol Encryption
 101  Increase maximum block size
 102  Block size increase to 2MB
 103  Block size following technological growth
 106  Dynamically Controlled Bitcoin Block Size Max Cap
 120  Proof of Payment
 121  Proof of Payment URI scheme
 123  BIP Classification

@_date: 2016-10-01 05:02:09
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT 
This means zero padding on-chain, which would be undesirable.
Rather "at most" and have the consensus implementation do the padding.
Lower in what endian? Why only that endian? Why only lower? I can see a possible use case where one wants to look at only the high bits to ensure their transaction is only valid in a block with at least a certain Or maybe resurrected it...

@_date: 2016-10-02 21:28:51
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Drivechain proposal using OP_COUNT_ACKS 
I think that's the concern: we don't - and *can't* - know. Pending patents are not publicly visible, as far as I am aware, and the BIP process does not (presently) require any patent disclosure.
Of course, it is entirely possible to voluntarily provide a disclosure of patents in the BIP (and ideally a free license to such patents, at least those for the BIP). This is an alternative possibility to resolve patent concerns if Rootstock is not prepared to adopt a defensive patent strategy in general I don't know if it's possible to implement decentralised sidechains without "breaking" this rule. But I would argue that in this scenario, the only way it would become invalid is the equivalent of a double-spend... and therefore it may be acceptable in relation to this argument.

@_date: 2016-10-15 13:01:33
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 2: BIP process, revised (review please) 
BIP 2 is currently believed to be a final draft of what will replace BIP 1 in specifying how the entire BIP process works. This Process BIP will require rough consensus from the Bitcoin-dev mailing list to become Active (see BIP 2 for the procedure, which I intend to use for its own activation due to absence of a clear process defined in BIP 1).
Therefore, if you have any objections to the new BIP process as specified in BIP 2, please voice your concerns ASAP.
Thanks for your review,

@_date: 2016-10-15 13:01:38
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 2 revival and rework 
BIPs often should include code.
The "real" license in this case is the BSD 2-clause. However, BIP 1 only allows OPL and public domain, so BIP 2 is available under OPL as well so that it is acceptable before/until it activates also.
CC0 and public domain are two different things.
Yes, you're right. I'll post to Lightning-dev and libbitcoin's list about
BIP 2. If you're aware of any other Bitcoin development discussion groups, could you please bring BIP 2 to their attention so it gets wider review?
As I understand it, presently France and Germany do not recognise public domain as a possible status. GPL is merely a copyright license, so it should be valid anywhere copyright laws exist.

@_date: 2016-09-17 21:10:26
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Simple tx ID malleability fix, 
First of all, this is likely to be more trouble than segwit to deploy (mainly just because SegWit is already implemented and tested).
Secondly, it wouldn't fix your problem: anyone malleating the transaction would simply update the hash before this opcode...

@_date: 2016-09-20 21:31:47
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions. 
Please open a pull request on the bitcoin/bips repo after this has been discussed a bit on the ML.
Note that at least a basic backwards compatibility section is required for assignment, especially since this appears to be a hard-fork proposal (if it is meant as a soft-fork, please explain how that would work).
There is already a binary-safe format called EBML. Why not use that as the basis for this BIP?
Note this won't fix malleability entirely, only third-party malleability (much like segwit). The sender can always modify the transaction with more The last byte in the txid calculation, or the last byte of the entire It seems from the later comments, that it is the end of the transaction as a whole. Yet a separator between the txid and non-txid data would probably be valuable, rather than hard-coding txid to skip signature types (which may be unknown to old nodes, when extended).
This seems to be a major regression. What is the replacement for SIGHASH_SINGLE and SIGHASH_ANYONECANPAY?
When revising OP_CHECKSIG, it would also be nice to add the ability to use *only* a hash of the prevout's scriptPubKey in the input, so that *when* the prevtx is malleated, the spending one remains valid. (This use case is currently not supported.)
What happens if nodes encounter a different order in a block?
What happens if I put ScriptVersion=1 here?
Does multisig still require a dummy item on the stack?
How should nodes know where in the merkle-tree the txids end, and the v4hashes

@_date: 2016-09-23 09:57:01
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT 
This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin scripting system to address reissuing bitcoin transactions when the coins they spend have been conflicted/double-spent.
Does this seem like a good idea/approach?

@_date: 2016-09-23 22:20:39
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT 
In the innocent use case of this opcode, a double-spend has already occurred, and this should be a strict improvement. In the non-innocent abuse of this opcode, I don't see that it's any worse than simply double-spending.
Would this proposal be better or otherwise more acceptable, if a specified height more recent than 100 blocks deep causes the script to fail? This would increase delays in recovering the double-spend situation of course... but less than 24h.

@_date: 2016-09-23 22:34:41
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT 
Joe sends Alice 5 BTC (UTXO 0).
Fred sends Alice 4 BTC (UTXO 1).
Alice sends Bob 4 BTC using UTXO 1 (creating UTXO 2).
Fred double-spends UTXO 1 with UTXO 1-B. This invalidates Alice's transfer to Alice has UTXO 0 which she can send to Bob (UTXO 3), but if she does so, it is possible that UTXO 0 could be mined, and then both UTXO 2 and UTXO 3 which would result in her giving Bob a total of 8 BTC rather than merely 4 BTC.
Even if Alice waits until Fred's UTXO 1-B confirms 10 blocks deep, it is not impossible for a reorganization to reverse those 10 blocks and confirm UTXO 1 Using OP_CHECKBLOCKATHEIGHT, however, Alice can create UTXO 3 such that it is valid only in the blockchain where Fred's UTXO 1-B has confirmed. This way, if that block is reorganized out, UTXO 3 is invalid, and either Bob receives only the original UTXO 2, or Alice can create a UTXO 3-B which is valid in the reorganized blockchain if it again confirms the UTXO 1-B double-spend.

@_date: 2016-09-24 06:36:00
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 2 revival and rework 
I've revived BIP 2 (from Deferred Status) and given it some updates. Most notably, I have reworked it to be a *replacement* for BIP 1 rather than an Please review it. If things go well, hopefully we can get this done by Christmas. ;)
Other recent changes include:
* OPL will no longer be an acceptable license. Many in the community feel that prohibiting publication is unacceptable for BIPs, and I haven't heard any arguments in favour of allowing it.
* Accepted Status has been renamed to Proposed. The name "Accepted" seems a constant source of confusion since it requires only action from the author.
* Non-image auxiliary files are permitted in the bip-XXXX subdirectory. This was already the norm despite BIP 1.
* Email addresses are now required for authors. The Travis script has been enforcing this for months now already.
* The Post-History header may be provided as a link instead of a simple date. A few BIPs were already doing this.
* Markdown format is no longer permitted for BIPs. I don't see the point in allowing multiple formats, and so far we've been fine with just MediaWiki.
* The Resolution header has been dropped, as it is not applicable to a decentralised system where no authority exists to make final decisions.
Other changes already in the previous draft of BIP 2:
* An implementation is now required (when applicable) before BIPs can proceed to Proposed Status.
* BIP Comments are newly introduced.
* The License preamble headers have been added.

@_date: 2017-04-04 18:01:51
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: Generalized version bits voting 
BIP 9 doesn't limit itself, merely acknowledges the *inherent* nature of it not being applicable to hardforks. BIP 9 provides a mechanism for having miners coordinate softforks because they can make the upgrade process smoother this way. But the same is not true of hardforks: miners are essentially irrelevant to them, and cannot make the process any smoother. Therefore, BIP 9 and any miner signalling in general is not very useful for deploying these.
Softforks are not required to use BIP 9, and even if they do, they are not required to use the recommended thresholds.
Basically, the problems you're trying to solve don't exist...

@_date: 2017-04-04 18:03:56
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Extension block proposal by Jeffrey et al 
Recently there has been some discussion of an apparent work-in-progress extension block proposal by Christopher Jeffrey, Joseph Poon, Fedor Indutny, and Steven Pair. Since this hasn't been formally posted on the ML yet, perhaps it is still in pre-draft stages and not quite ready for review, but in light of public interest, I think it is appropriate to open it to discussion, and toward this end, I have reviewed the current revision.
For reference, the WIP proposal itself is here:
    ==Overall analysis & comparison==
This is a relatively complicated proposal, creating a lot of additional technical debt and complexity in comparison to both BIP 141 and hardforks. It offers no actual benefits beyond BIP 141 or hardforks, so seems irrational to consider at face value. In fact, it fits much better the inaccurate criticisms made by segwit detractors against BIP 141.
That being said, this proposal is very interesting in construction and is for the most part technically sound. While ill-fit to merely making blocks larger, it may be an ideal fit for fundamentally different block designs such as Rootstock and MimbleWimble in absence of decentralised non-integrated sidechains (extension blocks are fundamentally sidechains tied into Bitcoin ==Fundamental problem==
Extension blocks are a risk of creating two classes of "full nodes": those which verify the full block (and are therefore truly full nodes), and those which only verify the "base" block. However, because the extension is consensus-critical, the latter are in fact not full nodes at all, and are left insecure like pseudo-SPV (not even real SPV) nodes. This technical nature is of course true of a softfork as well, but softforks are intentionally designed such that all nodes are capable of trivially upgrading, and there is no expectation for anyone to run with pre-softfork rules.
In general, hardforks can provide the same benefits of an extension block, but without the false expectation and pointless complexity.
==Other problems & questions==
from the next resolution txid in reality).
This breaks the ability to spend unconfirmed funds in the same block (as is required for CPFP).
The extension block's transaction count is not cryptographically committed-to anywhere. (This is an outstanding bug in Bitcoin today, but impractical to exploit in practice; however, exploiting it in an extension block may not be as impractical, and it should be fixed given the opportunity.)
block txids and wtxids as the leaves.
This needs to elaborate how the merkle tree is constructed. Are all the txids followed by all the wtxids (tx hashes)? Are they alternated? Are txid and wtxid trees built independently and merged at the tip?
invalid in extension blocks.
Why? This prevents extblock users from sending to bare multisig or other various possible destinations. (While static address forms do not exist for other types, they can all be used by the payment protocol.)
Additionally, this forbids datacarrier (OP_RETURN), and forces spam to create unprovably-unspendable UTXOs. Is that intentional?
This has the same "attacks can do more damage than ordinary benefit" issue as BIP141, but even more extreme since it is planned to be used for future size What is a "point"? What does it mean multiplied by a factor of 8? Why not just say "8 points"?
sigops in the redeem script, multiplied by a factor of 8.
Please define "accurately counted" here. Is this using BIP16 static counting, or accurately counting sigops during execution?
data in the witness vector, every 73 bytes in the serialized witness vector is worth 1 additional point.
Is the size rounded up or down? If down, 72-byte scripts will carry 0 ==Trivial & process==
BIPs must be in MediaWiki format, not Markdown. They should be submitted for discussion to the bitcoin-dev mailing list, not social media and news.
Extension blocks are more of a hard-fork IMO.
BIPs may not be "public domain" due to non-recognition in some jurisdictions. Can you agree on one or more of these? throughput without altering any existing consensus rules.
This is inaccurate. Even softforks alter consensus rules.
roughly 10 minutes. It is not possible to change this rule. There has been great debate regarding other ways of increasing transaction throughput, with no proposed consensus-layer solutions that have proven themselves to be
particularly safe.
Block time seems entirely unrelated to this spec. Motivation is unclear.
transaction opt-in, serialization, verification, and network services, and as such, extension block activation entails BIP141 activation.
As stated in the next paragraph, the rules in BIP 141 are fundamentally incompatible with this one, so saying BIP 141 is activated is confusingly these BIPs. Extension blocks are _not_ compatible with BIP141 in its current form, and will require a few minor additional rules.
Extension blocks should be compatible with BIP 141, there doesn?t appear to be any justification for not making them compatible.
believing the existing UTXO set is still behaving as they would expect.
The UTXO set behaves fundamentally different to old nodes with this proposal, albeit in a mostly compatible manner.
extension block commitment (all zeroes if nothing is present in the extension Please explain why in Rationale.
sweeped by the resolution transaction due to previously existing consensus Seems like an annoying technical debt. I wonder if it can be avoided.
the first input script, allowing the miner of the genesis resolution to add a special message. The pushdata MUST be castable to a true boolean.
Why? Unlike the coinbase, this seems to create additional technical debt with no apparent purpose. Better to just have a consensus rule every input must be Transaction versions are signed, so I assume this is actually simply -1. (While signed transaction versions seemed silly to me, using it for special cases like this actually makes sense.)
Should specify that spending such an exit must use the resolution txid, not the extblock's txid.
as well as additional size/legacy-sigops added to the canonical block due to entering or exiting outputs.
BIPs should not specify policy at all. Perhaps prefix "For the avoidance of doubt:" to be clear that miners may perform any fee logic they like.
vector using BIP141 transaction serialization.
Since extblock transactions are all required to be segwit, why wouldn't this be mandatory?
consensus rule.
Note this makes adoption slower: wallets cannot use the extblock until the economy has updated to support segwit-native addresses.
data in the witness vector, every 73 bytes in the serialized witness vector is worth 1 additional point.
Please explain why 73 bytes in Rationale.
How so? Please explain.
within an extension block transaction, an extra 700-bytes is reserved on the transaction space used up in the block.
Why wouldn't users set this on all transactions?
`default_extension_commitment` and includes the extension block commitment `default_witness_commitment` was never part of the GBT spec. At least describe what this new key is.
Should be just `extblk` if backward compatibility is supported (and `!extblk` when not).
What about timeout? None? To continue the extension block, must it be deactivated and reactivated in parallel?

@_date: 2017-04-06 09:17:48
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: Inhibiting a covert attack on the 
Why not simply require the BIP-141 commitment?
Not entirely. The commitment is not required until segwit activates.
But this should be trivial to implement at least.
How does it not interfere with BIP 9? I suppose the versionbits could be moved to the generation transaction version, but this would hide them from light Could you please use one of these?

@_date: 2017-04-06 17:18:35
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Extension block proposal by Jeffrey et al 
Oh? If this was not meant to be a Bitcoin Improvement Proposal, perhaps you should clarify somewhere what altcoin you are proposing it for. As it stands, it certainly did read much like it was meant to be a BIP, and apparently many others thought so as well.
Admittedly, the bitcoin-dev ML isn't the place for altcoin discussions, and I'm not particularly interested in spending my time aiding altcoins, so I'll just end the conversation here until someone re-proposes something similar for Sorry for confusing the nature of your work,

@_date: 2017-04-08 14:59:12
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] A Small Modification to Segwit 
I think it might be important that the mandatory commitment expire as in Greg's proposal - when we do eventually hardfork, it will be simpler to do in a safe manner if such a commitment in the fake "old block" is not required.
I don't like your proposal because it allows ASICBoost. ASICBoost effectively makes SHA2 semi-ASIC-resistant. ASIC-resistance raises the barrier of entry to new mining chip manufacturers, and gives a larger advantage to the miners able to make use of it. Instead, IMO we should fix the vulnerability exploited by ASICBoost entirely to keep SHA2 as ASIC-friendly as possible - or change the PoW to an algorithm that is more ASIC-friendly.
That being said, I don't think I would oppose the proposal if it gained notably better support than Segwit currently has (as yet another compromise), and the above concerns were addressed (eg, Bitfury and Canaan state they can compete using ASICBoost and the patents are licensed freely to everyone).

@_date: 2017-04-08 16:05:09
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] A Small Modification to Segwit 
No, it isn't allowed right now. Doing it wouldn't invalidate blocks, but it would clearly be an attack on the network and cause harm. The same as if miners were to maliciously mine only empty blocks.

@_date: 2017-04-20 20:28:52
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Segwit v2 
Since BIP 141's version bit assignment will timeout soon, and needing renewal, I was thinking it might make sense to make some minor tweaks to the spec for the next deployment. These aren't critical, so it's perfectly fine if BIP 141 activates as-is (potentially with BIP 148), but IMO would be an improvement if a new deployment (non-BIP148 UASF and/or new versionbit) is needed.
1. Change the dummy marker to 0xFF instead of 0. Using 0 creates ambiguity with incomplete zero-input transactions, which has been a source of confusion for raw transaction APIs. 0xFF would normally indicate a >32-bit input count, which is impossible right now (it'd require a >=158 GB transaction) and unlikely to ever be useful.
2. Relax the consensus rules on when witness data is allowed for an input. Currently, it is only allowed when the scriptSig is null, and the scriptPubKey being spent matches a very specific pattern. It is ignored by "upgrade-safe" policy when the scriptPubKey doesn't match an even-more-specific pattern. Instead, I suggest we allow it (in the consensus layer only) in combination with scriptSig and with any scriptPubKey, and consider these cases to be "upgrade-safe" policy ignoring.
The purpose of the second change is to be more flexible to any future softforks. I consider it minor because we don't know of any possibilities where it would actually be useful.

@_date: 2017-04-25 18:46:09
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
FWIW, I disagree in this case. I think given the circumstances, if we are going to do a UASF for segwit at all, we need a clearly decisive outcome, which is given by BIP 148. Using the approach in BIP 8 makes sense in many cases, but in this case, it is liable to simply create a prolonged uncertainty where nobody knows the outcome when segwit's rules are challenged by a malicious miner.
If BIP 148 fails to achieve widespread support, we could do a BIP 8-based UASF with Segwit v2 (along with some other changes I suggested in the other thread), but I think the tradeoffs right now favour BIP 148 as the best UASF

@_date: 2017-04-26 18:33:56
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Draft BIP: Segwit deployment with versionbits and 
See Segwit v2 thread. Maybe we can collaborate on combining these.

@_date: 2017-04-26 20:01:10
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Segwit v2 
Fair enough, I guess. Although I think the dummy marker could actually be non-
consensus critical so long as the hashing replaces it with a 0.
There are things scriptSig can do that witness cannot today - specifically add additional conditions under the signature. We can always obsolete scriptSig later, after segwit has provided an alternative way to do this.
They already can malleate transactions and add garbage to the blocks. I don't see the benefit here.

@_date: 2017-08-16 18:33:47
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Fwd: Proposal of a new BIP : annual splitting 
To have a BIP, you need to explain not only *why* you want to do something, but also *what specifically* to do, and *how* to do it. This concept (historically known as "flip the chain" and/or "UTXO commitments") is not new, merely complicated to design and implement.

@_date: 2017-08-29 20:07:43
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal for Lightning-oriented multiaccount 
This should only be set after peer review and implementations are complete, and you intend that there will be no further changes.
can be found at the following page.
I suggest just referring to SLIP 44 directly.
You're missing the Backward Compatibility and Copyright sections.

@_date: 2017-12-05 07:41:59
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Two Drivechain BIPs 
This is impossible to guarantee. Federated sidechains are already possible with simple multisig (and they could very well be merge-mined chains instead of simply signed). At the same time, the value of permissionless sidechain innovation is potentially huge.

@_date: 2017-12-05 19:39:32
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP-21 amendment proposal: -no125 
This seems counterproductive. There is no reason to ever avoid the RBF flag. I'm not aware of any evidence it even reduces risk of, and it certainly doesn't prevent double spending. Plenty of miners allow RBF regardless of the flag, and malicious double spending doesn't benefit much from RBF in any case.
Bech32 addresses are just normal addresses. What need is there for a param?

@_date: 2017-12-11 18:34:12
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - Dead Man's Switch 
You can implement this already, but only for ~1 year expirations.
IF  ELSE <1 year> CHECKSEQUENCEVERIFY ENDIF
Perhaps it would make sense to propose a flag extending the range of relative lock-times so you can do several years?
On Monday 11 December 2017 5:30:37 PM Teweldemedhin Aberra via bitcoin-dev

@_date: 2017-12-21 23:09:05
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP for Legacy Sign Verify functions 
It's not even correct... Your first "verify message" step is not possible; you can't get a public key from an address.
What is actually done, is using the signature + message to perform key recovery, to extract the public key of the signer, and then hashing that and comparing it to the address provided.
New schemes should probably NOT be based on the current one.

@_date: 2017-12-24 07:21:24
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 177: UTPFOTIB - Use Transaction Priority For 
BIP 177 is NOT assigned. Do not self-assign BIP numbers!
Please read BIP 2:

@_date: 2017-02-03 00:24:09
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System 
Strongly disagree with buying "votes", or portraying open standards as a voting process. Also, this depends on address reuse, so it's fundamentally flawed in design.
Some way for people to express their support weighed by coins (without losing/spending them), and possibly weighed by running a full node, might still be desirable. The most straightforward way to do this is to support message signatures somehow (ideally without using the same pubkey as spending), and some [inherently unreliable, but perhaps useful if the community "colludes" to not-cheat] way to sign with ones' full node.
Note also that the BIP process already has BIP Comments for leaving textual opinions on the BIP unrelated to stake. See BIP 2 for details on that.

@_date: 2017-02-05 23:02:28
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP 
My BIP draft didn't make progress because the community opposes any block size increase hardfork ever. Your version doesn't address the current block size issues (ie, the blocks being too large). So you've retained the only certain-
DOA parts of my proposal, and removed the most useful part... I'm not sure the point. Also, your version is now EXCLUSIVELY a hardfork, so it makes no sense to keep the BIP 9 deployment at all - either it gets consensus or it doesn't, but miners have no part in deployment of it.

@_date: 2017-02-19 12:12:55
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.14.0 release candidate 1 available 
Release candidate 1 of a new major Bitcoin Knots release, version 0.14.0, has
been made available.
This is a release candidate for a new major version release, including new
features, various bugfixes and performance improvements.
Preliminary release notes for the release can be found here:
    Binaries can be downloaded from:
    Please take care to verify the PGP signature of all downloads.
Source code can be found on GitHub under the signed tag
    Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as 0.14.0 final, otherwise
a new rc will be made available after these are solved.
Please report bugs using the issue tracker at GitHub:

@_date: 2017-02-28 20:59:44
@_author: Luke Dashjr 
@_subject: [bitcoin-dev]  Bitcoin Knots 0.14.0 release candidate 2 available 
Release candidate 2 of a new major Bitcoin Knots release, version 0.14.0, has
been made available.
This is a release candidate for a new major version release, including new
features, various bugfixes and performance improvements.
Preliminary release notes for the release can be found here:
    Binaries can be downloaded from:
    Please take care to verify the PGP signature of all downloads.
Source code can be found on GitHub under the signed tag
    Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as 0.14.0 final, otherwise
a new rc will be made available after these are solved.
Please report bugs using the issue tracker at GitHub:

@_date: 2017-02-28 21:20:29
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Moving towards user activated soft fork activation 
Without at least a majority hashrate validating blocks, it is possible just a single invalid block could split the chain such that the majority continue building a most-work on that invalid block.
This failure to validate a softfork is similar in some respects to a hardfork, but with one critical difference: the default behaviour of old nodes will be to follow the chain with the most-work that was valid under the pre-softfork rules. This actually *inverts* the benefit of the softfork over a hardfork, and makes a softfork deployed in such a manner de facto behave as if it had been a hardfork, IF someone ever mines a single malicious block.
For this reason, I think a minority-hashrate softfork requires a much higher degree of social support than merely the widespread agreement typical of softforks. It might perhaps require less than the full ~100% consensus hardforks require, but it likely comes somewhat close.
Once it gets over 50% hashrate enforcement, however, the situation improves a lot more: a malicious block may split obsolete miners off the valid chain, but it will eventually resolve on its own given enough time. Due to natural fluctuations in block finding, however, automatic measurement may need to look for >75%.
So I would suggest that instead of a simple flag day activation, this proposal would be improved by changing the flag day to merely reduce the hashrate requirement from 95% to 75%.
(In addition to the above concerns, if >50% of miners are hostile to the network, we likely have other problems.)

@_date: 2017-01-02 20:04:56
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - 'Block75' - New algorithm 
It would probably behave as an ever-increasing block size limit. Spam has typically filled blocks to the max, and miners have stopped self-enforcing reasonable limits.
Probably it should never make it so small that a reasonable generation transaction cannot fit. But I'm not sure this needs explicit enforcement.
If you can't trust miners to signal based on the community's consensus, then don't use miner signalling at all. Just set a block height it activates.
I doubt you'll get consensus for such a fundamentally broken proposal.
I certainly don't foresee any circumstance where I could reasonably support it... The block size limit exists to restrict miners; it makes no sense to put it in their control.

@_date: 2017-01-02 21:19:10
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - 'Block75' - New algorithm 
If you reject a block based on a particular condition, that is BY DEFINITION part of the consensus protocol, and NOT a policy. The protocol is literally the set of rules by which blocks are determined to be valid or invalid.
Policies are things that can vary node-to-node without affecting the validity judgement of blocks.
Then it doesn't solve the actual problems of either miner spam or growth in resource requirements, which are the entire purpose of the block size limit.
Anything that consumes more data than necessary to properly convey the intended transfer of value (bitcoins) from one entity to another, including all data that is not intended for such a purpose.
Putting group X in control of a limit that exists for the sole purpose of restricting group X.
It gives miners complete control over the limit. They can make blocks of any size (within the current limit), thus triggering the conditions by which your proposal would raise the limit further.

@_date: 2017-01-07 03:25:47
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [Meta] Re:  Bitcoin Core 0.13.2 released 
I don't think release announcements are really appropriate for the bitcoin-dev mailing list. People who want these can subscribe to the bitcoin-core-dev list and/or the Core announce mailing list. Maybe sending to bitcoin-discuss would also make sense, but not bitcoin-dev...
On Tuesday, January 03, 2017 8:47:36 AM Wladimir J. van der Laan via bitcoin-

@_date: 2017-01-09 03:08:56
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Mutli-push op_return 
Standards (BIPs) need to describe a specific use case and protocol for doing As you note, the default policy on most nodes is to allow such outputs.

@_date: 2017-01-27 01:06:59
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Three hardfork-related BIPs 
I've put together three hardfork-related BIPs. This is parallel to the ongoing research into the MMHF/SHF WIP BIP, which might still be best long-term.
1) The first is a block size limit protocol change. It also addresses three criticisms of segwit: 1) segwit increases the block size limit which is already considered by many to be too large; 2) segwit treats pre-segwit transactions ?unfairly? by giving the witness discount only to segwit transactions; and 3) that spam blocks can be larger than blocks mining legitimate transactions. This proposal may (depending on activation date) initially reduce the block size limit to a more sustainable size in the short-
term, and gradually increase it up over the long-term to 31 MB; it will also extend the witness discount to non-segwit transactions. Should the initial block size limit reduction prove to be too controversial, miners can simply wait to activate it until closer to the point where it becomes acceptable and/or increases the limit. However, since the BIP includes a hardfork, the eventual block size increase needs community consensus before it can be deployed. Proponents of block size increases should note that this BIP does not interfere with another more aggressive block size increase hardfork in the meantime. I believe I can immediately recommend this for adoption; however, peer and community review are welcome to suggest changes.
Text: Code:  (consensus code changes only)
2) The second is a *preparatory* change, that should allow trivially transforming certain classes of hardforks into softforks in the future. It essentially says that full nodes should relax their rule enforcement, after sufficient time that would virtually guarantee they have ceased to be enforcing the full set of rules anyway. This allows these relaxed rules to be modified or removed in a softfork, provided the proposal to do so is accepted and implemented with enough advance notice. Attempting to implement this has proven more complicated than I originally expected, and it may make more sense for full nodes to simply stop functioning (with a user override) after the cut-off date). In light of this, I do not yet recommend its adoption, but am posting it for review and comments only.
Text: 3) Third is an anti-replay softfork which can be used to prevent replay attacks whether induced by a hardfork-related chain split, or even in ordinary operation. It does this by using a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin scripting system that allows construction of transactions which are valid only on specific blockchains.
Text:

@_date: 2017-01-27 04:14:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Three hardfork-related BIPs 
The limit only drops all the way to 300k if it activates before 2017 April. Considering that this requires the consensus of a hardfork, followed by a release in software, and then actual activation by miners using BIP9, I think it's extremely unlikely to activate by then.
But more importantly: such a drop would probably be good for the network in the long-term. As explained in the Rationale section, 300k is necessary to maintain our *current* IBD (first-time node sync) costs even with technological improvements (which appear to be slowing lately).
We are only at capacity because the space is available below actual costs, and/or because efficient alternatives are not yet widely supported. A reduction of block size will likely squeeze out spam, and perhaps some unsustainable microtransaction use, but the volume which actually *benefits from* the blockchain's security should continue along fine. Furthermore, once Lightning is widely implemented as well-tested, at least microtransactions are likely to gain a huge improvement in efficiency, reducing legitimate usage of block sizes well below 300k naturally - that is frankly when I first expect this proposal to be seriously considered for activation (which is independent from the consensus to include support for it in nodes).
I did not mention the HK "roundtable", because this is indeed not in the spirit of what we set out to do, and do not wish this to be interpreted as some kind of slap in the face of the honest participants of that discussion.
This proposal is, however, the best I am currently able to honestly recommend that meets the hard criteria outlined at Hong Kong a year ago. (Continued work on the MMHF/SHF concept may eventually deliver a better solution, but it is not yet ready.)

@_date: 2017-01-28 04:03:03
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Three hardfork-related BIPs 
Assume as a premise (despite your apparent disagreement below) that for Bitcoin to function, a supermajority of economic activity needs to be verified using full nodes operated by the recipient. Evidence suggests that at this current time, at best 10% of economic activity is in fact using a full node to verify the transaction. On this basis, it seems pretty clear that serious action must be taken to change the status quo, and so for efforts to do so without dropping the block size have proven ineffective.
Satoshi envisioned a system where full nodes could publish proofs of invalid blocks that would be automatically verified by SPV nodes and used to ensure even they maintained the equivalent of full node security so long as they were not isolated. But as a matter of fact, this vision has proven impossible, and there is to date no viable theory on how it might be fixed. As a result, the only way for nodes to have full-node-security is to actually be a true full node, and therefore the plan of only having full nodes in datacenters is simply not realistic without transforming Bitcoin into a centralised system.
I think it's likely safe to say that if this were a possibility, everyone would want to continue to move in that direction. But as the facts stand, it simply isn't possible.

@_date: 2017-01-28 19:43:48
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Three hardfork-related BIPs 
Why would someone malicious follow the format sufficiently to make those proofs possible?
ZK proofs do to a large extent simplify the situation, but still fail in one case (and one case is all an attacker needs, since he can choose how he attacks). Specifically, the attacker can create a block which is 100% well-
formed and valid (or not - nobody will really ever know), and simply withhold a single transaction in it, such that nobody ever has the complete block's data. Full nodes will of course not accept such a block until they have the complete data to validate, but they similarly cannot prove it is invalid without the complete data, and any non-full nodes cannot prove there is data missing without fetching and (to an extent) checking the entire block

@_date: 2017-07-02 21:10:19
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: No chaining off replaceable 
This isn't BIP material, as it merely describes a local policy.
(BIP125 itself is also local policy, but one that involves standardisation since it expresses how wallets interoperate with nodes with that policy.)
If you wish to suggest this policy change, you should just implement it and open a merge/pull request on the applicable project.

@_date: 2017-07-05 03:50:51
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Height based vs block time based thresholds 
I've already opened a PR almost 2 weeks ago to do this and fix the other issues BIP 9 has. It just needs your ACK to merge.

@_date: 2017-07-05 04:10:43
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Height based vs block time based thresholds 
It's not pointless: it's a wake-up call for miners asleep "at the wheel", to ensure they upgrade in time. Not having a mandatory signal turned out to be a serious bug in BIP 9, and one which is fixed in BIP 148 (and remains a problem for BIP 149 as-is). Additionally, it makes the activation decisive and unambiguous: once the lock-in period is complete, there remains no question as to what the correct protocol rules are.
It also enables deploying softforks as a MASF, and only upgrading them to UASF on an as-needed basis.

@_date: 2017-07-06 20:43:28
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Height based vs block time based thresholds 
Nothing is "orphaned" unless miners are acting negligently or maliciously. Incentivising honest behaviour from miners is inherently part of Bitcoin's design, and these changes are necessary for both that and keeping the network secure. This doesn't do harm; it reduces risk of harm.
I don't appreciate the uncalled-for character assassination, and it doesn't belong on this mailing list.
Since you apparently have a drastically different opinion on this subject, I think it may be best to wait until after BIP148 to continue the discussion (thereby having more real-world information to work from).
Therefore, I have opened a new pull request with just the parts you seem to be objecting to removed. Please let us know if this version is satisfactory.

@_date: 2017-07-07 23:27:14
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] A Segwit2x BIP 
IIRC, it is actually increased by ~81 bytes, and doesn't count witness data if on Segwit transactions (so in effect, nearly 4 MB transactions are possible). This probably doesn't make the hashing problem worse, however it should be made clear in the BIP.
Citations do not support the claim.
This is deceptive and meaningless. There is no reason to *ever* refer to the size of the block serialised without witness programs. It is not a meaningful What is modified here? "segsignal" does not appear in the BIP 91 protocol at A "plain block size limit" of 2 MB would be a no-op. It would have literally no effect whatsoever on the network rules.
Furthermore, this does not match what btc1/Segwit2x currently implements at all. The actual implementation is: If Segwit (via deployment method) activates at block N, then block N+12960 activates a new weight limit of 8M (which corresponds to a size of up to 8,000,000 bytes).
What is the rationale for excluding witness data from this measurement?
Actual network growth does not reflect a pattern that supports this claim.
Larger block sizes is not likely to have a meaningful impact on fee pressure. Any expectations that do not match the reality are merely misguided, and should not be a basis for changing Bitcoin.

@_date: 2017-07-12 01:06:14
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] A Segwit2x BIP 
BIP148 began with 8 months lead time, reduced to 5 months from popular request and technical considerations. There is nothing about BIP148 that compels an attempted hardfork 90 days later - that could just as well have been 18 That's not true at all. Based on my observations, only approximately 20% of the community follow Core's technical lead without significant consideration of their own - and who knows if that would change if Core were to suggest clearly-unsafe block size increases, or attempted to force a hardfork against consensus. Even with Core's support, many people would oppose the hardfork attempt, and it would fail.
Segwit2x's hardfork does not compel the remaining Bitcoin users to also I concur, but I disagree your approach has any possibility of a united Bitcoin. The only way to get that today, would be to do Segwit+Drivechain, not

@_date: 2017-06-06 23:08:11
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Replay attacks make BIP148 and BIP149 untennable 
Replay is a solved problem. It can be improved on and made simpler, but at this point, replay only occurs when the sender is either negligent or intending it.
This is nothing but unfounded FUD. It is very simple to implement and guaranteed to work eventually. It may be time consuming, but that is the only truth here. The only risk is that of a long reorg, the same as double spend What kind of "fungibility" does this FUD claim it destroys? Destroying cross-
chain fungibility is the very *intent* of replay protection. And it does not destroy same-chain fungibility any more than any other miner spending.
Lack of replay protection does not mean there is no coin. Replay protection is equally a concern for the main (BIP148) chain and any legacy chains malicious miners might choose to split off. And none of this changes the fact that such miners will be unable to sell their legacycoins at Bitcoin market prices, because whether other transactions are replayed or not, *their* coins won't be valid on the main chain.

@_date: 2017-06-19 19:26:22
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP148 temporary service bit (1 << 27) 
To ease the transition to BIP148 and to minimise risks in the event miners choose to perform a chain split attack, at least Bitcoin Knots will be using the temporary service bit (1 << 27) to indicate BIP148 support.
Once the transition is complete, this will no longer be necessary, and the bit will be (manually) returned for reuse.
I encourage other software implementing BIP148 (both full and light nodes) to set and use this service bit to avoid network partitioning risks.

@_date: 2017-06-28 05:20:27
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: OP_BRIBVERIFY - the op code needed for Blind 
I don't see how. It seems like the logical outcome from this is "whoever pays the most gets the next sidechain block"... That's not particularly useful for merge mining.
There are different kinds of sidechains...
Federated peg: this already works on Bitcoin.
SPV/SNARK peg: this isn't enabled by your BIP.
Drivechains: this isn't enabled by your BIP.
How do you say this enables any kind of sidechain?
This is unacceptable, for reasons Greg already pointed out.
Note that this is not acceptable for BIPs anymore.

@_date: 2017-03-04 08:27:32
@_author: Luke Dashjr 
@_subject: [bitcoin-dev]  Currency/exchange rate information API 
Investigating what it would take to add fiat currency information to Bitcoin Knots, I noticed Electrum currently has many implementations, one for each exchange rate provider, due to lack of a common format for such data.
Therefore, I put together an initial draft of a BIP that could standardise this so wallets (or other software) and exchange rate providers can simply interoperate without a lot of overhead reimplementing the same thing many One thing I am unsure about, is that currently this draft requires using XBT (as BTC) for Bitcoin amounts. It would seem nicer to use satoshis, but those don't really have a pseudo-ISO currency code to fit in nicely...
Current draft here:
    Thoughts? Anything critical missing? Ways to make the interface better?

@_date: 2017-03-06 07:09:39
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Currency/exchange rate information API 
HTTPS would be used for that. It's not something that needs to be at a higher I would think so, at least for Bitcoin since rates can change significantly in a short period of time (or can they anymore? I haven't really watched lately.)
When displaying historical transactions, it doesn't really make sense to use the current market rate, but rather the market rate at the time the payment was made. While wallets might simply cache it with the transaction, it would be perhaps nicer if it could be automatically restored for seed-only recoveries. In any case, if a service/wallet doesn't want to provide/use historical information, it can simply not implement that part.
How is the current draft insufficient for this?
Pushing is what longpolling does.

@_date: 2017-03-06 22:14:47
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Currency/exchange rate information API 
It would be a privacy leak to request only the specific timestamps, but I suppose many wallets lack even basic privacy to begin with.
To address the bounds issue, I have specified that when from/to don't have an exact record, that the previous/next (respectively) is provided.
Hopefully this addresses both concerns?
That's what the "timedelta" field solves, no?
If you want one value per day, you'd put 86400.
Is it not sufficient for the server to specify this in the description of the given currency-pair feed?

@_date: 2017-03-06 22:21:24
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Currency/exchange rate information API 
That's the job of TCP.
Do you think we need to explicitly specify a keepalive configuration?
Seems like that would vary based on client or network.

@_date: 2017-03-13 03:01:40
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Flag day activation of segwit 
I don't think this is actually BIP 9 compatible. Once activated, the bit loses its meaning and should not be set. So you need to check that it hasn't locked-
in already...
Also, IMO this should tolerate as many as 5% minus one non-signalling blocks.
Disclaimer: This are technical suggestions, and do not imply endorsement of the idea.

@_date: 2017-03-15 04:03:40
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Payment address tokens 
I've put together a fairly incomplete BIP draft for a new stateless address format that aims to address the many shortcomings of current addresses, - Current addresses special-case specific transaction types, and have needed
  sender-side upgrades for new types.
- Outputs are produced which cannot be distinguished from disguised data
  storage, making spam detection harder.
- Privacy is severely harmed by reuse of addresses.
- Funds can be lost due to (accidental or intentional) reuse of very old
  addresses.
A downside of this approach is that parsing addresses to outputs can be complicated, but this is resolvable by writing libraries for popular Thoughts on how it might be improved, before I get too deep into the current

@_date: 2017-03-18 19:15:09
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Requirement for pseudonymous BIP submissions 
GitHub doesn't allow people to have multiple accounts last I checked.

@_date: 2017-03-22 08:47:30
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Fraud proofs for block size/weight 
Despite the generalised case of fraud proofs being likely impossible, there have recently been regular active proposals of miners attacking with simply oversized blocks in an attempt to force a hardfork. This specific attack can be proven, and reliably so, since the proof cannot be broken without also breaking their attempted hardfork at the same time.
While ideally all users ought to use their own full node for validation (even when using a light client for their wallet), many bitcoin holders still do not. As such, they are likely to need protection from these attacks, to ensure they remain on the Bitcoin blockchain.
I've written up a draft BIP for fraud proofs and how light clients can detect blockchains that are simply invalid due to excess size and/or weight:
    I believe this draft is probably ready for implementation already, but if anyone has any idea on how it might first be improved, please feel free to make suggestions.

@_date: 2017-03-25 05:16:25
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Fraud proofs for block size/weight 
Creation of proofs isn't part of the spec itself.
I've moved it out of the Specification section (but it's still below it).
Added a definitions section above.
Right, fixed.
The only way to establish the number of transactions at all, is to show that a leaf is a parsable transaction. Which this doesn't actually show, so it's broken. :( Need to think on this. Any ideas? :/

@_date: 2017-03-28 17:46:20
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hard fork proposal from last week's meeting 
Indeed, actually implementing hfprep proved to be overly complicated.
I like the idea of a time bomb that just shuts down the client after it determine it's stale and refuses to start without an explicit override.
That should work no matter what the hardfork is, and gives us a good expectation for hardfork timeframes.
I don't like this idea. It leaves the node open to attack from blocks actually meeting the criteria. Maybe the absolute minimum as Jeremy suggested.

@_date: 2017-03-28 21:06:49
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hard fork proposal from last week's meeting 
I think it was probably a design requirement more than a demand. It makes sense: if we're aiming to have a long lead time for a possible hardfork, we want to get the lead time started ASAP. (It could perhaps have been communicated clearer, but let's not read hostility into things when Meta-topic: Can we try a little harder to avoid sequences of multiple brief replies in a matter of minutes? Combine them to a single reply.

@_date: 2017-03-29 09:15:57
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Strong Anti-Replay via Coinbase Transactions 
It's blank?
The activation methodology should be defined. It can be a TODO for now.
Need to be specific about which NOP.
This is contradicting. scriptSig is not part of an output. Did you get the two scripts inverted?
Why burn a satoshi?
This is a layering violation. BIP 125 does not affect the consensus rules.
*a* chain split
This recycling is going to be pretty spammy... especially if transactions are limited to one each.
Chain splits also happen regularly (probably at least once or twice every few  hundred blocks). Since generated UTXOs cannot be spent for 100 blocks, it is likely anything using this would require constant updating.
It also requires active awareness from the miner that a split is occurring. Usually, this is not known until the block is solved, and it is too late to make these recycling transactions.
I don't think it's possible to implement for the reasons mentioned above.
Another way is to commit to a specific chain explicitly, as with my proposed This isn't convenient. Most wallets have no reasonable way to check if there are any competing transactions, much less what the fee for them is.
Why not just use a single reserved output, and have it recycle as part of the transactions? This can be done so long as the signature doesn't commit to the recycle input. So for each transaction, there would be an input with the last-
recycle-txid (tracked by the miner as it builds the block), and an output generating the next-recycle-txid. Wallets could just indicate this input to be used by providing a special hash as the input which is not covered under the UTXO set, not memory pool?

@_date: 2017-03-30 10:04:05
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Block size adjustment idea - expedience fees + 
Minor detail: OP_RETURN doesn't work like that. You'd need OP_DROP.
Inputs don't have addresses, and addresses should only ever be used once.
You might be able to fix this by increasing the value of the change, though.
It would require a new signature-check opcode at the very least.
I don't see a purpose to this proposal. Miners always mine as if it's their *only* chance to get the fee, because if they don't, another miner will. Ie, after 1 block, the fee effectively drops to 0 already.
The standard problem with these is that miners are incentivised to publish their own "out of band fee" address so they get all the fee directly.

@_date: 2017-05-03 23:21:13
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Full node "tip" function 
I think paying for services is in general a great idea, but one that Bitcoin can much better serve once Lightning is in production. Not only does it enable cost-effective micro-transactions, it also should allow nodes to initiate payments before they have a synced node (which is something impractical at

@_date: 2017-05-11 19:24:21
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: NODE_NETWORK_LIMITED service bits 
Is 49 days particularly useful? Would it be a problem to instead leave both-
bits undefined? I'm thinking this might be better as a way to indicate "7 days, plus a deterministically chosen set of historical blocks"...
This is technically true right now, but as soon as segwit activates, it will no longer be... Therefore, I suggest striking it from the BIP, expounding on it in greater detail, or making it true for the longer term.
This isn't entirely clear whether it refers to peers downloading blocks, or peers serving them. (I assume the former, but it should be clarified.)
Wouldn't this already be a problem, without the BIP?

@_date: 2017-05-12 19:22:56
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees 
I've written a new BIP draft for OP_CHECKBLOCKVERSION to allow the community to put economic pressure on miners to deploy softforks without the extreme of a UASF.
    Due to the potential for miners to maliciously block this softfork, it is suggested that we deploy it using BIP 8 to ensure it eventually activates even if encountering hostility.
This is intended to be an alternative to BIP 8 in the long term.
It is NOT intended to make BIP 148 obsolete, given the timeframes involved.
An implementation is available (based on top of BIP 115's implementation):

@_date: 2017-05-13 00:49:33
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees 
This BIP doesn't change that. Enforcement remains primarily by users.
You assume users will pay for signalling of softforks prematurely. So long as it waits until deployment of the softfork is widespread, this risk is minimal. At worst, it creates risks similar to a UASF. So long as UASF is the alternative, this way seems strictly better.
How so?
Fixed, thanks.

@_date: 2017-05-13 05:26:58
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees 
I already explained why this isn't the case: If we're comparing MASF to MASF+CBV, then I agree. But MASF is not necessarily always on the table, so the comparison where this becomes relevant is MASF+CBV vs UASF.
Versionbits change/lose their meaning after the deployment timeout. For this reason, the timeout must be specified so the check is skipped when that Also, doing it the way you describe would fail to enforce that BIP9 is actually in use for the block version; you could simply add that as an additional condition, but it seems pretty hacky since you wouldn't be able to upgrade versionbits anymore...
Script validity can still be cached with this: you would always allow the opcode to succeed at evaluation-time, and simply store the criteria checked separately. Then it would behave effectively the same as using the transaction version number.

@_date: 2017-05-13 05:45:24
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees 
Most people cannot mine except at a huge expense (profit is limited to few people via monopoly and electric costs). But more importantly, the profits from every miner you buy will go to pay for Bitmain growing their arsenal more than enough to offset your influence.
Mining is simply broken at this point.
Running a node and mining are two very different things.
First of all, this isn't donating to miners, but forbidding them from mining your transaction (and thereby collecting your transaction fee) unless they signal for the softfork.
Secondly, your argument here assumes miners are a government or control Bitcoin in some way. This is not correct. Miners are entrusted with enforcement of softforks *for old nodes only*, and therefore given the ability to trigger activation of the new rules via signalling. But entrusting them with this is NOT done by the system itself, but by the users, whose updated nodes are the primary mechanism for enforcing softforks. So miners are in fact already bound to honour the wishes of the greater economy, and their refusal to do so is an attack on the network.

@_date: 2017-05-13 16:42:44
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP: Block signal enforcement via tx fees 
I'm assuming that if the economic majority hasn't consented to the softfork, at least as many users will make their transactions conditional on non-

@_date: 2017-05-23 12:55:26
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] I do not support the BIP 148 UASF 
In this case, NOT enforcing BIP148 puts users at more risk. Since devs are divided in opinion, we should at the very least have an option to let users decide one way or the other.

@_date: 2017-05-23 20:23:40
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148 
In light of some recent discussions, I wrote up this BIP for a real 2 MB block size hardfork following Segwit BIP148 activation. This is not part of any agreement I am party to, nor anything of that sort. Just something to throw out there as a possible (and realistic) option.
Note that I cannot recommend this to be adopted, since frankly 1 MB blocks really are still too large, and this blunt-style hardfork quite risky even with consensus. But if the community wishes to adopt (by unanimous consensus) a 2 MB block size hardfork, this is probably the best way to do it right now. The only possible way to improve on this IMO would be to integrate it into MMHF/"spoonnet" style hardfork (and/or add other unrelated-to-block-size HF I have left Author blank, as I do not intend to personally champion this. Before it may be assigned a BIP number, someone else will need to step up to take on that role. Motivation and Rationale are blank because I do not personally think there is any legitimate rationale for such a hardfork at this time; if someone adopts this BIP, they should complete these sections. (I can push a git branch with the BIP text if someone wants to fork it.)
BIP: ?
Layer: Consensus (hard fork)
Title: Post-segwit 2 MB block size hardfork
Author: FIXME
Comments-Summary: No comments yet.
Comments-URI: ?
Status: Draft
Type: Standards Track
Created: 2017-05-22
License: BSD-2-Clause
Legacy Bitcoin transactions are given the witness discount, and a block size limit of 2 MB is imposed.
This BIP is licensed under the BSD 2-clause license.
Upon activation, a block size limit of 2000000 bytes is enforced.
The block weight limit remains at 4000000 WU.
The calculation of block weight is modified:
all witness data, including both scriptSig (used by pre-segwit inputs) and segwit witness data, is measured as 1 weight-unit (WU), while all other data in the block is measured as 4 WU.
The witness commitment in the generation transaction is no longer required, and instead the txid merkle root in the block header is replaced with a hash 1. The witness reserved value.
2. The witness merkle root hash.
3. The transaction ID merkle root hash.
The maximum size of a transaction stripped of witness data is limited to 1 MB.
This BIP is deployed by flag day, in the block where the median-past time surpasses 1543503872 (2018 Nov 29 at 15:04:32 UTC).
It is assumed that when this flag day has been reached, Segwit has been activated via BIP141 and/or BIP148.
==Backwards compatibility==
This is a hardfork, and as such not backward compatible.
It should not be deployed without consent of the entire Bitcoin community.
Activation is scheduled for 18 months from the creation date of this BIP, intended to give 6 months to establish consensus, and 12 months for ==Reference implementation==

@_date: 2017-05-31 04:14:25
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Hypothetical 2 MB hardfork to follow BIP148 
Because the bottleneck is hashing the transaction, which costs (in CPU time) based on its size. Maybe it would make sense to factor sigops into the limit, Make it 100kB and I think we'd be okay. Those have always been policy-
forbidden so there should be no expectation they'd be acceptable in the While we're at it, I suggest also specifying a minimum transaction size as well. The raw minimum possible is 60 bytes, but any sane output would need at least a hash, so I'd say make the minimum be 8 (60 + 160-bit hash) bytes?

@_date: 2017-11-01 08:43:48
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Merkle branch verification & tail-call semantics 
I think I have found an improvement that can be made.
As you recall, a downside to this approach is that one must make two commitments: first, to the particular "membership-checking script"; and then in that script, to the particular merkle root of possible scripts.
Would there be any harm in, instead of checking membership, *calculating* the root? If not, then we could define that instead of the witness program committing to H(membership-check script), it rather commits to H(membership-
calculation script | data added by an OP_ADDTOSCRIPTHASH). This would, I believe, securely reduce the commitment of both to a single hash.
It also doesn't reduce flexibility, since one could omit OP_ADDTOSCRIPTHASH from their "membership-calculation" script to get the previous membership-
check behaviour, and use  OP_EQUAL in its place.
What do you think?

@_date: 2017-11-04 07:59:07
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Merkle branch verification & tail-call semantics 
How about using for the first stage, `<...> OP_CALCMERKLEROOT  OP_EQUAL` instead of ` OP_CHECKMERKLEBRANCH`? There's maybe 1 or 2 bytes extra, but it seems more future-proof (since there could more easily be alternatives to ` OP_EQUAL` in future script versions).
OTOH, OP_ADDTOSCRIPTHASH may be fatally incompatible with script versioning... Old nodes won't know how to check the witness program, which means an undefined version could be used to bypass the correct script entirely.
Need to think more on this still.

@_date: 2017-10-01 01:13:29
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Version 1 witness programs (first draft) 
I've put together a first draft for what I hope to be a good next step for Segwit and Bitcoin scripting:
    This introduces 5 key changes:
1. Minor versions for witnesses, inside the witness itself. Essentially the witness [major] version 1 simply indicates the witness commitment is SHA256d, and nothing more.
The remaining two are witness version 1.0 (major 1, minor 0):
2. As previously discussed, undefined opcodes immediately cause the script to exit with success, making future opcode softforks a lot more flexible.
3. If the final stack element is not exactly true or false, it is interpreted as a tail-call Script and executed. (Credit to Mark Friedenbach)
4. A new shorter fixed-length signature format, eliminating the need to guess the signature size in advance. All signatures are 65 bytes, unless a condition script is included (see 5. The ability for signatures to commit to additional conditions, expressed in the form of a serialized Script in the signature itself. This would be useful in combination with OP_CHECKBLOCKATHEIGHT (BIP 115), hopefully ending the whole replay protection argument by introducing it early to Bitcoin before any further splits.
This last part is a big ugly right now: the signature must commit to the script interpreter flags and internal "sigversion", which basically serve the same purpose. The reason for this, is that otherwise someone could move the signature to a different context in an attempt to exploit differences in the various Script interpretation modes. I don't consider the BIP deployable without this getting resolved, but I'm not sure what the best approach would be. Maybe it should be replaced with a witness [major] version and witness There is also draft code implementing [the consensus side of] this:
    Thoughts? Anything I've overlooked / left missing that would be uncontroversial and desirable? (Is any of this unexpectedly controversial for some reason?)

@_date: 2017-10-01 02:47:41
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Version 1 witness programs (first draft) 
Should it perhaps commit to the length of the serialised witness data instead or additionally? Now that signatures are no longer variable-length, that'd be As far as tail-call needs are concerned, CLEANSTACK wouldn't have been checked until AFTER the tail-call in the first draft. But I suppose eliminating it for other possible future purposes is still useful.

@_date: 2017-10-01 17:36:05
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Version 1 witness programs (first draft) 
BIP 115 provides fork-independent opt-in replay protection, which can be used in combination with the new signature condition scripts in this proposal.
Perhaps the code can have a flag for new altcoins to easily make it mandatory (and we can use it on testnet?).

@_date: 2017-10-01 20:43:18
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Version 1 witness programs (first draft) 
Could just do SIGHASH_WITNESS_SIZE in addition to SIGHASH_WITNESS_DEPTH...

@_date: 2017-10-02 00:45:22
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Version 1 witness programs (first draft) 
I like (A) and (B). Use B when practical, and (A) when more fundamental changes are needed. SigAgg is a concern, but there are ways to adapt it.
(C) is harmless, but I think unnecessary with (A) and/or (B).
Note that my BIP draft supports both (A) and (C).
It seems inevitable at this point. Maybe we could add a separate "executable-
witness" array (in the same manner as the current witness was softforked in), and require tail-call and condition scripts to merely reference these by hash, but I'm not sure it's worth the effort?
Thinking further, we could avoid adding a separate executable-witness commitment by either:
A) Define that all the witness elements in v1 are type-tagged (put the minor
   witness version on them all, and redefine minor 0 as a stack item?); or
B) Use an empty element as a delimiter between stack and executable items.
To avoid witness malleability, the executable items can be required to be sorted in some manner.
The downside of these approaches is that we now need an addition 20 or 32 bytes per script reference... which IMO may possibly be worse than losing static analysis. I wonder if there's a way to avoid that overhead?

@_date: 2017-10-02 02:56:27
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Version 1 witness programs (first draft) 
This breaks parallel softfork deployments.
Only if there's common code to implement both versions, which doesn't work if the changes from A to B to C are drastic. To avoid such drastic changes, the overall design/layout needs to at least be planned to cover the desired use cases in advance.

@_date: 2017-09-05 13:03:39
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts 
I think it makes more sense to use a child number field for this purpose.
It seems desirable to use the same seed for all different script formats...
As you note, xpub\xprv are already being used for both P2PKH and P2SH. It really doesn't make sense to differentiate segwit specifically.

@_date: 2017-09-06 14:58:44
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Proposal] Token Protocol Specification 
I think you could check out and coordinate with the OpenAssets proposal.
Your current draft also claims to solve a lot of problems that it doesn't actually solve technically...

@_date: 2017-09-07 15:02:17
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Proposal: bip32 version bytes for segwit scripts 
In that case, I think we should go back to the proposal I started with in This handles not only simple HD seeds, but also multisig HD and such.

@_date: 2017-09-15 18:04:58
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.15.0.knots20170914 released 
Bitcoin Knots version *0.15.0.knots20170914* is now available from:
This is a new major version release, including new features, various bugfixes
and performance improvements, as well as updated translations.
Please report bugs using the issue tracker at GitHub:
How to Upgrade
If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).
The first time you run version 0.15.0, your chainstate database will be converted to a
new format, which will take anywhere from a few minutes to half an hour,
depending on the speed of your machine.
The file format of `fee_estimates.dat` changed in version 0.15.0. Hence, a
downgrade from version 0.15.0 or upgrade to version 0.15.0 will cause all fee
estimates to be discarded.
Note that the block database format also changed in version 0.8.0 and there is no
automatic upgrade code from before version 0.8 to version 0.15.0. Upgrading
directly from 0.7.x and earlier without redownloading the blockchain is not supported.
However, as usual, old wallet versions are still supported.
Downgrading warning
Version 0.15 contains a number of significant performance improvements, which make
Initial Block Download, startup, transaction and block validation much faster:
- The chainstate database (which is used for tracking UTXOs) has been changed
  from a per-transaction model to a per-output model (See [PR 10195]( Advantages of this   are that it:
    - avoids the CPU overhead of deserializing and serializing the unused outputs;
    - has more predictable memory usage;
    - uses simpler code;
    - is adaptable to various future cache flushing strategies.
  As a result, validating the blockchain during Initial Block Download (IBD) and reindex
  is ~30-40% faster, uses 10-20% less memory, and flushes to disk far less frequently.
  The only downside is that the on-disk database is 15% larger. During the conversion from the previous format
  a few extra gigabytes may be used.
- Earlier versions experienced a spike in memory usage while flushing UTXO updates to disk.
  As a result, only half of the available memory was actually used as cache, and the other half was
  reserved to accommodate flushing. This is no longer the case (See [PR 10148]( and the entirety of
  the available cache (see `-dbcache`) is now actually used as cache. This reduces the flushing
  frequency by a factor 2 or more.
- In previous versions, signature validation for transactions has been cached when the
  transaction is accepted to the mempool. Version 0.15 extends this to cache the entire script
  validity (See [PR 10192]( This means that if a transaction in a block has already been accepted to the
  mempool, the scriptSig does not need to be re-evaluated. Empirical tests show that
  this results in new block validation being 40-50% faster.
- LevelDB has been upgraded to version 1.20 (See [PR 10544]( This version contains hardware acceleration for CRC
  on architectures supporting SSE 4.2. As a result, synchronization and block validation are now faster.
- SHA256 hashing has been optimized for architectures supporting SSE 4 (See [PR 10821]( SHA256 is around
  50% faster on supported hardware, which results in around 5% faster IBD and block
  validation. In version 0.15, SHA256 hardware optimization is disabled in release builds by
  default, but can be enabled by using `--enable-experimental-asm` when building.
- Refill of the keypool no longer flushes the wallet between each key which resulted in a ~20x speedup in creating a new wallet. Part of this speedup was used to increase the default keypool to 1000 keys to make recovery more robust. (See [PR 10831]
Fee Estimation Improvements
Since Segwit has activated, this release adds a new checkpoint locking to the first Segwit block. This guarantees no matter what happens, your node will not accept a reorg to attempt theft of Segwit funds. (This isn't a real-world risk anyway, but there's no reason not to guarantee it with a checkpoint.)
Mempool Persistence Across Restarts
Version 0.15 introduces several new RPC methods:
- `abortrescan` stops current wallet rescan, e.g. when triggered by an `importprivkey` call (See [PR 10208]
- `combinerawtransaction` accepts a JSON array of raw transactions and combines them into a single raw transaction (See [PR 10571]
- `estimaterawfee` returns raw fee data so that customized logic can be implemented to analyze the data and calculate estimates. See [Fee Estimation Improvements]( for full details on changes to the fee estimation logic and interface.
- `getchaintxstats` returns statistics about the total number and rate of transactions
  in the chain (See [PR 9733](
- `listwallets` lists wallets which are currently loaded. See the *Multi-wallet* section
  of these release notes for full details (See [Multi-wallet endpoint support](
- `savemempool` causes the memory pool to immediately update `mempool.dat` with its current state.
- `uptime` returns the total runtime of the `bitcoind` server since its last start (See [PR 10400]
- `verifyscript` allows verification of a specific Bitcoin Script, optionally including a full trace of the evaluation.
Additionally, the `bitcoin-cli` tool now supports a `-getinfo` command line option to fetch information from multiple `get*info` RPC methods. This is intended to replace the deprecated `getinfo` RPC method.
Wallet ZeroMQ publishers
- When using Bitcoin Knots in multi-wallet mode, RPC requests for wallet methods may specify
  the wallet that they're intended for. See [Multi-wallet endpoint support]( for full details.
- The `optintorbf` parameter for `createrawtransaction` and `fundrawtransaction` has been renamed to `replaceable` to match `bumpfee`.
- The new database model no longer stores information about transaction
  versions of unspent outputs (See [Performance improvements]( This means that:
  - The `gettxout` RPC no longer has a `version` field in the response.
  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,
    which does not commit to the transaction versions of unspent outputs, but does
    commit to the height and coinbase information.
  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,
    and always reports 0 for transaction versions in the binary format
- The `estimatefee` RPC is deprecated. Clients should switch to using the `estimatesmartfee` RPC, which returns better fee estimates. See [Fee Estimation Improvements]( for full details on changes to the fee estimation logic and interface.
- The `gettxoutsetinfo` response now contains `disk_size` and `bogosize` instead of
  `bytes_serialized`. The first is a more accurate estimate of actual disk usage, but
  is not deterministic. The second is unrelated to disk usage, but is a
  database-independent metric of UTXO set size: it counts every UTXO entry as 50 + the
  length of its scriptPubKey (See [PR 10426](
- `signrawtransaction` can no longer be used to combine multiple transactions into a single transaction. Instead, use the new `combinerawtransaction` RPC (See [PR 10571](
- `fundrawtransaction` no longer accepts a `reserveChangeKey` option. This option used to allow RPC users to fund a raw transaction using an key from the keypool for the change address without removing it from the available keys in the keypool. The key could then be re-used for a `getnewaddress` call, which could potentially result in confusing or dangerous behaviour (See [PR 10784]
- `estimatepriority` and `estimatesmartpriority` have been removed. Estimating coin age priority is no longer supported.
- In the `getpeerinfo` RPC, the return object for each peer now returns an `addrbind` member, which contains the ip address and port of the connection to the peer. This is in addition to the `addrlocal` member which contains the ip address and port of the local node as reported by the peer (See [PR 10478](
- The `resendwallettransactions` RPC throws an error if the `-walletbroadcast` option is set to false (See [PR 10995]
- The second argument in the `submitblock` RPC argument has been renamed from `parameters` to `dummy`. This argument never had any effect, and the renaming is simply to communicate this fact to the user (See [PR 10191](
  (Clients should, however, use positional arguments for `submitblock` in order to be compatible with BIP 22.)
- Mempool entries returned from RPC now include the hash of the entire transaction as a `wtxid` key.
Low-level p2p changes
Support for a new kind of inventory item MSG_FILTERED_WITNESS_BLOCK has been added. This extends the functionality of BIP37, used identically to MSG_FILTERED_BLOCK. But whereas MSG_FILTERED_BLOCK returns transactions with no witness data, MSG_FILTERED_WITNESS_BLOCK returns the transactions serialized along with witness data. No merkle proof for witness inclusion in blocks is provided, but clients can still verify the witness is valid (although possibly not the same witness as in the blockchain).
BIP37 has well-known privacy issues and will likely be deprecated in favor of clientside block filtering in future software releases. MSG_FILTERED_WITNESS_BLOCK is provided to enable clients that rely on BIP37 to easily add Segregated Witness support immediately until better sync mechanisms gain widespread use.
Warning: BIP37 leaks private data and witness data is not authenticated. You must use a trusted node to use this mechanism securely.
0.15.0 Change log
 RPC and other APIs
-  `61a640e` ZMQ example using python3 and asyncio (mcelrath)
-  `0496e15` remove 'label' filter for rpc command help (instagibbs)
-  `02bd6e9` Fix error codes from various RPCs (jnewbery)
-  `598ef9c` Fix RPC failure testing (continuation of  (jnewbery)
-  `d34995a` Add mallocinfo mode to `getmemoryinfo` RPC (laanwj)
-  `3568b30` [Qt][RPC] Autocomplete commands for 'help' command in debug console (achow101)
-  `e6156a0` [zmq] Call va_end() on va_start()ed args (kallewoof)
-  `7438cea` Trivial: move rpcserialversion into RPC option group (jlopp)
-  `350b224` [rpc] Add logging rpc (jnewbery)
-  `393160c` [wallet] Rescan abortability (kallewoof)
-  `a987def` [net] Allow disconnectnode RPC to be called with node id (jnewbery)
-  `0e8499c` doc: Add RPC interface guidelines (laanwj)
-  `d4732f3` Add getchaintxstats RPC (sipa)
-  `f4b15e2` [doc] Add hint about getmempoolentry to getrawmempool help (kallewoof)
-  `96c850c` [RPC] Transaction details in getblock (achow101)
-  `9390845` Add query options to listunspent RPC call (pedrobranco)
-  `08ac35a` Fix docs (there's no rpc command setpaytxfee) (RHavar)
-  `e317c0d` Add witness data output to TxInError messages (instagibbs)
-  `4677151` RPC: getblockchaininfo returns BIP signaling statistics  (pinheadmz)
-  `ef2d062` Fix bumpfee rpc "errors" return value (ryanofsky)
-  `39039b1` [RPC] getmempoolinfo mempoolminfee is a BTC/KB feerate (instagibbs)
-  `296928e` rpc: Add listen address to incoming connections in `getpeerinfo` (laanwj)
-  `08d0390` Fix importmulti failure to return rescan errors (ryanofsky)
-  `9fec4da` Add friendly output to dumpwallet (aideca)
-  `16f6c98` Replace bytes_serialized with bogosize (sipa)
-  `980deaf` RPC/Mining: Restore API compatibility for prioritisetransaction (luke-jr)
-  `46311e7` Opt-into-RBF for RPC & bitcoin-tx (luke-jr)
-  `9c248e3` Decodehextx scripts sanity check  (achow101)
-  `c94b89e` gettxoutproof() should return consistent result (jnewbery)
-  `00350bd` [trivial] Rename unused RPC arguments 'dummy' (jnewbery)
-  `b62b4c8` fixed listunspent rpc convert parameter (tnakagawa)
-  `bef02fb` Improve wallet rescan API (ryanofsky)
-  `1680ee0` [RPC] Add an uptime command that displays the amount of time (in seconds) bitcoind has been running (rvelhote)
-  `d81bec7` rpc: Move the `generate` RPC call to rpcwallet (laanwj)
-  `30bc0f6` REST/RPC example update (Mirobit)
-  `9edda0c` [rpc] fix verbose argument for getblock in bitcoin-cli (jnewbery)
-  `104f5f2` More economical fee estimates for RBF and RPC options to control (morcos)
-  `b27b004` Change API to estimaterawfee (morcos)
-  `afd2fca` getbalance example covers at least 6 confirms (instagibbs)
-  `75b5643` Better API for estimatesmartfee RPC  (morcos)
-  `9e8d6a3` Do not allow users to get keys from keypool without reserving them (TheBlueMatt)
-  `d445a2c` [RPC] Add a deprecation warning to getinfo's output (achow101)
-  `adf170d` [RPC]Move transaction combining from signrawtransaction to new RPC (achow101)
-  `041dad9` [RPC] Various rpc argument fixes (instagibbs)
-  `6ef3c7e` [rpc] listsinceblock should include lost transactions when parameter is a reorg'd block (kallewoof)
-  `8537187` Prevent user from specifying conflicting parameters to fundrawtx (TheBlueMatt)
-  `0b11a07` Fix misleading "Method not found" multiwallet errors (ryanofsky)
-  `f66c596` [RPC] Fix addwitnessaddress by replacing ismine with producesignature (achow101)
-  `627c3c0` Fix amounts formatting in `decoderawtransaction` (laanwj)
-  `4268426` [wallet] return correct error code from resendwallettransaction (jnewbery)
-  `96a63a3` [RPC] trivial: gettxout no longer shows version of tx (FelixWeis)
-  `6c2b008` Fix combinerawtransaction RPC help result section (jonasnick)
-  `07164bb` [RPC] Only return hex field once in getrawtransaction (achow101)
-  `5af6572` Be consistent in calling transactions "replaceable" for Opt-In RBF (TheBlueMatt)
- n/a    `a92a946` *RPC: prioritisetransaction: Make both deltas optional (luke-jr)
-  `e893d96` *RPC/Wallet: rescanblockchain: Support inverted height order (luke-jr)
-  `e700ad2` *ZMQ: add publishers for wallet transactions. (somdoron)
- n/a    `0afed04` *Add script tracing capabilities to libbitcoinconsensus and a new RPC verifyscript method (luke-jr)
-  `977d461` *Handle getinfo in bitcoin-cli w/ -getinfo (laanwj, achow101, jnewbery)
-  `d6f667e` *RPC: Add option -stdinrpcpass to bitcoin-cli to allow RPC password to be read from standard input (jharvell)
-  `941c2f6` *[RPC][mempool]: Add savemempool RPC (greenaddress)
-  `e731a14` *rpc: add wtxid to mempool entry output (sdaftuar)
-  `963da74` *AcceptToMemoryPool: Standardise rejection reason format (luke-jr)
 Block and transaction handling
-  `a8c5751` Removed redundant parameter from mempool.PrioritiseTransaction (gubatron)
-  `1efc99c` Remove harmless read of unusued priority estimates (morcos)
-  `b7547fa` Remove block file location upgrade code (benma)
-  `30ff3a2` Remove free transactions (but not coin-age priority, in Knots) - implementation (morcos)
-  `47510ad` Remove min reasonable fee (morcos)
-  `c73af54` Switch CCoinsMap from boost to std unordered_map (sipa)
-  `2a183de` Control mempool persistence using a command line parameter (jnewbery)
-  `318ea50` Better fee estimates (morcos)
-  `bee3529` Bugfix: PrioritiseTransaction updates the mempool tx counter (sdaftuar)
-  `1088b02` Switch chainstate db and cache to per-txout model (sipa)
-  `c2ab38b` Always log debug information for fee calculation in CreateTransaction (morcos)
-  `efbcf2b` Use REJECT_DUPLICATE for already known and conflicted txn (sipa)
-  `b3eb0d6` Few Minor per-utxo assert-semantics re-adds and tweak (TheBlueMatt)
-  `8c841a3` doc: Remove outdated minrelaytxfee comment (MarcoFalke)
-  `234ffc6` Change semantics of HaveCoinInCache to match HaveCoin (morcos)
-  `7878353` Simplify return values of GetCoin/HaveCoin(InCache) (sipa)
-  `a381f6a` Remove no longer used mempool.exists(outpoint) (morcos)
-  `d4e551a` Use non-atomic flushing with block replay (sipa)
-  `30c2130` Clarify CCoinsViewMemPool documentation (TheBlueMatt)
-  `90a002e` Address nits from per-utxo change (morcos)
-  `6859ad2` Improve wallet fee logic and fix GUI bugs (morcos)
-  `754aa02` Force on-the-fly compaction during pertxout upgrade (sipa)
-  `d896d5c` Add undocumented -forcecompactdb to force LevelDB compactions (sipa)
-  `e4bbd3d` Improved efficiency in COutPoint constructors (mm-s)
-  `8d6d43e` Add -stopatheight for benchmarking (sipa)
-  `916f12f` *AcceptToMemoryPool: Replace fLimitFree[=false] with rejectmsg_gratis in ignore_rejects (luke-jr)
 P2P protocol and network code
-  `7639d38` netbase: Do not print an error on connection timeouts through proxy (laanwj)
-  `5b583ef` Add seed.btc.petertodd.org to mainnet DNS seeds (petertodd)
-  `22f609f` Trivial: Debug log ambiguity fix for peer addrs (keystrike)
-  `90cb2a2` Enable host lookups for -proxy and -onion parameters (jmcorgan)
-  `7b585cf` Clarify assumptions made about when BlockCheck is called (TheBlueMatt)
-  `e19586a` [p2p] Send the correct error code in reject messages (jnewbery)
-  `eab00d9` Use cached [compact] blocks to respond to getdata messages (TheBlueMatt)
-  `a077a90` Check interruptNet during dnsseed lookups (TheBlueMatt)
-  `faf2dea` [net] listbanned RPC and QT should show correct banned subnets (jnewbery)
-  `314ebdf` [qa] Fixes segwit block relay test after inv-direct-fetch was disabled (sdaftuar)
-  `3f57c55` removed unused code in INV message (Greg-Griffith)
-  `ae78609` [net] Added SetSocketNoDelay() utility function (tjps)
-  `28c6e8d` Net: Improvements to Tor control port parser (str4d)
-  `5c63d66` Broadcast address every day, not 9 hours (sipa)
-  `400fdd0` Denote functions CNode::GetRecvVersion() and CNode::GetRefCount()  as const (pavlosantoniou)
-  `67700b3` [P2P] Timeout for headers sync (sdaftuar)
-  `8d9f45e` Return early in IsBanned (gmaxwell)
-  `de8db47` Net: Fix resource leak in ReadBinaryFile(...) (practicalswift)
-  `b33ca14` [net] Avoid possibility of NULL pointer dereference in MarkBlockAsInFlight(...) (practicalswift)
-  `2772dc9` net: avoid extra dns query per seed (theuni)
-  `9dd6a2b` Avoid unnecessary work in SetNetworkActive (promag)
-  `df3a6f4` p2p: Hardcoded seeds update pre-0.15 branch (laanwj)
-  `02f4c4a` [net] Fix use of uninitialized value in getnetworkinfo(const JSONRPCRequest&) (practicalswift)
-  `c8b62c7` Disconnect network service bits 6 and 8 until Aug 1, 2018 (TheBlueMatt)
-  `0e5cff6` Make sure to clean up mapBlockSource if we've already seen the block (theuni)
- n/a    `bd5b64d` *utilioprio: Add Windows support as ioprio_set_file_idle (luke-jr)
-  `69577ae` *Escape rather than remove any printable characters in UAs (luke-jr)
-  `3f388dd` *Handle MSG_FILTERED_WITNESS_BLOCK messages (CodeShark)
 Validation
-  `67023e9` CValidationInterface Cleanups (TheBlueMatt)
-  `2584925` Remove CValidationInterface::UpdatedTransaction (TheBlueMatt)
-  `a6548a4` pass Consensus::Params& to functions in validation.cpp and make them static (mariodian)
-  `431a548` Simplify DisconnectBlock arguments/return value (sipa)
-  `f94b7d5` Introduce static DoWarning (simplify UpdateTip) (jtimon)
-  `2e7d8f8` Fix stopatheight (achow101)
-  `2935b46` Cache full script execution results in addition to signatures (TheBlueMatt)
-  `21ed30a` Give CValidationInterface Support for calling notifications on the CScheduler Thread (TheBlueMatt)
-  `66270a4` Make check to distinguish between orphan txs and old txs more efficient (morcos)
-  `7c2400c` nCheckDepth chain height fix (romanornr)
-  `16240f4` Add SSE4 optimized SHA256 (sipa)
-  `04d395e` Avoid using sizes on non-fixed-width types to derive protocol constants (gmaxwell)
-  `2a50b11` Update defaultAssumeValid according to release-process.md (gmaxwell)
-  `2361208` Update chain transaction statistics (sipa)
-  `6bdf4b3` Avoid masking of difficulty adjustment errors by checkpoints (sipa)
-  `cb598cf` Allow non-power-of-2 signature cache sizes (sipa)
-  `acd9957` Improve DisconnectTip performance (sdaftuar)
-  `f90603a` Remove confusing MAX_BLOCK_BASE_SIZE (gmaxwell)
-  `bd92424` Fix some chainstate-init-order bugs (TheBlueMatt)
-  `b7296bc` Don't return stale data from CCoinsViewCache::Cursor() (ryanofsky)
-  `2507fd5` Fix upgrade cancel warnings (TheBlueMatt)
-  `cbdb473` Abstract out the command line options for block assembly (sipa)
- n/a    `08c84c7` *Add a new checkpoint at block 481,824 (luke-jr)
 Build system
-  `5f0556d` Remove fallbacks for boost_filesystem < v3 (laanwj)
-  `50a2265` gitian: bump descriptors for master (theuni)
-  `7ca2f54` Minor update to qrencode package builder (mitchellcash)
-  `2cc0df1` release: Windows signing script (theuni)
-  `8b789d8` build: Probe MSG_DONTWAIT in the same way as MSG_NOSIGNAL (laanwj)
-  `32d1b34` build: Fix typo s/HAVE_DONTWAIT/HAVE_MSG_DONTWAIT (laanwj)
-  `90dd9e6` Fix build errors if spaces in path or parent directory (pinheadmz)
-  `81da4c7` build: Disable Wshadow warning (laanwj)
-  `64962ae` Ignore Doxyfile generated from Doxyfile.in template (paveljanik)
-  `0416ea9` Make Boost use std::atomic internally (sipa)
-  `27faa6c` build: regenerate bitcoin-config.h as necessary (theuni)
-  `8979f45` [scripts] Minor improvements to `macdeployqtplus` script (chrisgavin)
-  `a26280b` 0.15.0 Depends Updates (fanquake)
-  `79aeff6` Update contrib/debian to latest Ubuntu PPA upload (TheBlueMatt)
-  `d25449f` Bugfix: Only use git for build info if the repository is actually the right one (luke-jr)
-  `e654d61` build: silence gcc7's implicit fallthrough warning (theuni)
-  `ad1a13e` Avoid printing generic and duplicated "checking for QT" during ./configure (drizzt)
-  `8465b68` [depends] expat 2.2.1 (fanquake)
-  `db825d2` build: verify that the assembler can handle crc32 functions (theuni)
-  `b4d03be` Building Environment: Set ARFLAGS to cr (ReneNyffenegger)
-  `91edda8` Explicitly search for bdb5.3 (pstratem)
-  `81560b0` random: only use getentropy on openbsd (theuni)
-  `1caafa6` Run Qt wallet tests on travis (ryanofsky)
-  `e222618` depends: fix fontconfig with newer glibc (theuni)
-  `88b1e4b` build: fix missing sse42 in depends builds (theuni)
-  `129b03f` gitian: quick hack to fix version string in releases (theuni)
-  `919aaf6` Fix compile errors with Qt 5.3.2 and Boost 1.55.0 (ryanofsky)
-  `7032021` Fix build warning from  text (jnewbery)
-  `318392c` Check if sys/random.h is required for getentropy (jameshilliard)
- n/a    `699287a` *Move Win32 defines to configure.ac to ensure they are globally defined (luke-jr)
- n/a    `ad1b260` *nsis-header.bmp: Generate from SVG (luke-jr)
 GUI
-  `1a9fd5c` Qt/Intro: Add explanation of IBD process (luke-jr)
-  `b00ba62` qt: clean up initialize/shutdown signals (benma)
-  `ce01e62` [Qt] Show more significant warning if we fall back to the default fee (jonasschnelli)
-  `b9f930b` Add basic Qt wallet test (ryanofsky)
-  `a387d3a` Change 'Clear' button string to 'Reset' (da2x)
-  `9c7b7cf` [Qt] Add checkbox in the GUI to opt-in to RBF when creating a transaction (ryanofsky)
-  `2b477e6` Make qt wallet test compatible with qt4 (ryanofsky)
-  `1fa4ae6` Add a button to open the config file in a text editor (ericshawlinux)
-  `51833a1` Fix for issues with startup and multiple monitors on windows (AllanDoensen)
-  `de01da7` Changed "Send" button default status from true to false (KibbledJiveElkZoo)
-  `e96486c` Stop treating coinbase outputs differently in GUI: show them at 1conf (TheBlueMatt)
-  `987a6c0` [Qt] Reduce a significant cs_main lock freeze (jonasschnelli)
-  `f6f3b58` [qt] Don't call method on null WalletModel object (ryanofsky)
-  `a3e756b` [Qt] Don't add arguments of sensitive command to console window (jonasschnelli)
-  `95546c8` [GUI] Add OSX keystroke to RPCConsole info (spencerlievens)
-  `962cd3f` [Qt] simple fee bumper with user verification (jonasschnelli)
-  `e477516` [wallet] remove minimum total fee option (instagibbs)
-  `4314544` Add Qt tests for wallet spends & bumpfee (ryanofsky)
-  `c1c9a95` Fix broken q4 test build (ryanofsky)
-  `64beb13` Overhaul Qt fee bumper (jonasschnelli)
-  `7c72fb9` Pass in smart fee slider value to coin control dialog (morcos)
-  `4c72cc3` [qt] Avoid potential null pointer dereference in TransactionView::exportClicked() (practicalswift)
-  `8fdd23a` [Qt] replace fee slider with a Dropdown, extend conf. targets (jonasschnelli)
-  `412b466` [Qt] Use wallet 0 in rpc console if running with multiple wallets (jonasschnelli)
-  `a9dd111` qt: Increase BLOCK_CHAIN_SIZE constants (laanwj)
-  `e292140` Slightly overhaul NSI pixmaps (jonasschnelli)
-  `0c3542e` Allow to cancel the txdb upgrade via splashscreen keypress 'q' (jonasschnelli)
-  `ad55de9` *Make tabs toolbar no longer have a context menu (achow101)
-  `14ccd4d` *Fix display of package name on 'open config file' tooltip (esotericnonsense)
-  `819e3dd` *Move "Hide tray icon" accelerator to checkbox text where it belongs (polyetilen)
-  `80b0f37` *Fixing offscreen GUI issue (MeshCollider)
 Wallet
-  `f7ec7cf` Add test for CWalletTx::GetImmatureCredit() returning stale values (ryanofsky)
-  `56ab672` [wallet] Remove redundant initialization (practicalswift)
-  `fa625b0` Document CWalletTx::mapValue entries and remove erase of nonexistent "version" entry (ryanofsky)
-  `72fb515` Disallow copy constructor CReserveKeys (instagibbs)
-  `3178b2c` Factor out CWallet::nTimeSmart computation into a method (ryanofsky)
-  `afcd7c0` Add safe flag to listunspent result (NicolasDorier)
-  `c49355c` Initialize nRelockTime (pstratem)
-  `3d857f3` Save watch only key timestamps when reimporting keys (ryanofsky)
-  `f34cdcb` Use internal HD chain for change outputs (hd split) (jonasschnelli)
-  `e183ea2` Wallet: reduce excess logic InMempool() (kewde)
-  `c9ff4f8` Remove SYNC_TRANSACTION_NOT_IN_BLOCK magic number (jnewbery)
-  `64c45aa` wallet: Use boost to more portably ensure -wallet specifies only a filename (luke-jr)
-  `c91ca0a` Improve ScanForWalletTransactions return value (ryanofsky)
-  `fa1ac28` Wallet database handling abstractions/simplifications (laanwj)
-  `c29a0d4` [wallet] [moveonly] Check non-null pindex before potentially referencing (kallewoof)
-  `a550f6e` Cleanup: reduce to one GetMinimumFee call signature (morcos)
-  `e2b99b1` [Wallet] unset change position when there is no change (instagibbs)
-  `d3dce0e` Avoid reading the old hd master key during wallet encryption (TheBlueMatt)
-  `18c9deb` rpc/wallet: Workaround older UniValue which returns a std::string temporary for get_str (luke-jr)
-  `94e5227` [wallet] Securely erase potentially sensitive keys/values (tjps)
-  `ea1fd43` [test] Add test for getmemoryinfo (jimmysong)
-  `ce8176d` [qt] Move some WalletModel functions into CWallet (ryanofsky)
-  `7cc2c67` Fix bumpfee test after  (ryanofsky)
-  `098b01d` Avoid CWalletTx copies in GetAddressBalances and GetAddressGroupings (ryanofsky)
-  `0747d33` Simplify feebumper minimum fee code slightly (ryanofsky)
-  `2805d60` [wallet] Remove unused variables (practicalswift)
-  `177433a` Basic multiwallet support (luke-jr)
-  `7a74f88` Supress struct/class mismatch warnings introduced in  (paveljanik)
-  `209eef6` Don't create change at dust limit (morcos)
-  `ed88e31` Use method name via __func__ macro (darksh1ne)
-  `e8b9523` Add change output if necessary to reduce excess fee (morcos)
-  `1c011ff` Properly forbid -salvagewallet and -zapwallettxes for multi wallet (morcos)
-  `5cfdda2` Track keypool entries as internal vs external in memory (TheBlueMatt)
-  `bf0a08b` [wallet] fix zapwallettxes interaction with persistent mempool (jnewbery)
-  `0b01935` Batch flushing operations to the walletdb during top up and increase keypool size (gmaxwell)
-  `7b6e8bc` No longer ever reuse keypool indexes (TheBlueMatt)
-  `bde4f93` Multiwallet: simplest endpoint support (jonasschnelli)
-  `9022aa3` Redefine Dust and add a discard_rate (morcos)
-  `bf3b742` Rename -usewallet to -rpcwallet (morcos)
-  `420238d` [wallet] [tests] Add listwallets RPC, include wallet name in `getwalletinfo` and add multiwallet test (jnewbery)
-  `70888a3` Reject invalid wallets (promag)
-  `af56397` Clarify help message for -discardfee (morcos)
-  `2e857bb` Eliminate fee overpaying edge case when subtracting fee from recipients (morcos)
-  `fa64636` Fix resendwallettransactions assert failure if -walletbroadcast=0 (TheBlueMatt)
-  `653a46d` Basic keypool topup (jnewbery)
-  `9fe1f6b` Add length check for CExtKey deserialization (jonasschnelli, guidovranken)
-  `4ef8374` [wallet] Keypool topup cleanups (jnewbery)
-  `e51bb71` Fix rounding bug in calculation of minimum change (morcos)
-  `779f2f9` Use CScheduler for wallet flushing, remove ThreadFlushWalletDB (TheBlueMatt)
-  `4e3efd4` ApproximateBestSubset should take inputs by reference, not value (RHavar)
 Mining
- n/a   `2421dd2` *coin_age_priority: Ensure nPackagesSelected and nDescendantsUpdated get updated for priority-mined transactions (luke-
 Tests and QA
-  `8efd1c8` Remove unused module from rpc-tests (34ro)
-  `7ff4a53` Improve rpc-tests.py (jnewbery)
-  `7146d96` Add --exclude option to rpc-tests.py (jnewbery)
-  `d6064a8` Fix docstrings in qa tests (jnewbery)
-  `a13a417` qa: Set correct path for binaries in rpc tests (MarcoFalke)
-  `6206252` Extra test vector for BIP32 (sipa)
-  `88c2ae3` [Trivial] Adding label for amount inside of tx_valid/tx_invalid.json (Christewart)
-  `36afd4d` travis: Verify commits only for one target (MarcoFalke)
-  `58861ad` test: Fail if InitBlockIndex fails (laanwj)
-  `67c5cc1` Avoid -Wshadow warnings in wallet_tests (ryanofsky)
-  `48c3429` [qa] assert_start_raises_init_error (NicolasDorier)
-  `9d5fcbf` Fix BIP68 activation test (jnewbery)
-  `d32581c` bench: Assert that division by zero is unreachable (practicalswift)
-  `c78adbf` Fix segwit getblocktemplate test (jnewbery)
-  `d5ce14e` tests: Delete unused function _rpchost_to_args (laanwj)
-  `19be26a` [test] Avoid reading a potentially uninitialized variable in tx_invalid-test (transaction_tests.cpp) (practicalswift)
-  `ac23a7c` Improve logging in bctest.py if there is a formatting mismatch (jnewbery)
-  `8910b47` [qa] Add logging to test_framework.py (jnewbery)
-  `21833f9` Fix extended rpc tests broken by  (jnewbery)
-  `857d1e1` QA: getblocktemplate_longpoll.py should always use >0 fee tx (sdaftuar)
-  `3cc13ea` Improve readability of segwit.py, smartfees.py (sdaftuar)
-  `2c781fb` CCheckQueue Unit Tests (JeremyRubin)
-  `9225de2` [trivial] Use log.info() instead of print() in remaining functional test cases (jnewbery)
-  `3192e52` Reorganise qa directory (jnewbery)
-  `02d64bd` combine_logs.py - aggregates log files from multiple bitcoinds during functional tests (jnewbery)
-  `dfef6b6` [tests] Remove unused variables and imports (practicalswift)
-  `a230b05` Make bumpfee tests less fragile (ryanofsky)
-  `ca20923` [test] Allow functional test cases to be skipped (jnewbery)
-  `a0b1e57` [test] Run extended tests once daily in Travis (jnewbery)
-  `1118493` [QA] Fix typo in fundrawtransaction test (NicolasDorier)
-  `c044f03` [QA] Renaming rawTx into rawtx (NicolasDorier)
-  `b1a4f27` Actually run assumevalid.py (jnewbery)
-  `c412fd8` Suppress noisy output from qa tests in Travis (jnewbery)
-  `79af9fb` Check that all test scripts in test/functional are being run (jnewbery)
-  `5b029aa` [qa] combine_logs: Use ordered list for logfiles (MarcoFalke)
-  `f2734c2` Remove unused variable. Remove accidental trailing semicolons in Python code (practicalswift)
-  `8ac8041` Remove SingleNodeConnCB (jnewbery)
-  `edc62c9` [tests] sync_with_ping should assert that ping hasn't timed out (jnewbery)
-  `427d2fd` Speed Up CuckooCache tests (JeremyRubin)
-  `12af74b` Remove sources of unreliablility in extended functional tests (jnewbery)
-  `ebfd653` [qa] Add setnetworkactive smoke test (MarcoFalke)
-  `080d7c7` [trivial] remove unused line in Travis config (jnewbery)
-  `df1ca9e` [tests] color test results and sort alphabetically (jnewbery)
-  `88799ea` [test] Suppress test logging spam (jnewbery)
-  `ed09dd3` Run bitcoin_test-qt under minimal QPA platform (ryanofsky)
-  `a27dbc5` [bench] Avoid function call arguments which are pointers to uninitialized values (practicalswift)
-  `b44adf9` tests: Fix test_runner return value in case of skipped test (laanwj)
-  `d86bb07` [tests] Functional test warnings (jnewbery)
-  `9111df9` Tests: Order Python Tests Differently (jimmysong)
-  `f3db4c6` Tests: Add test for getdifficulty (jimmysong)
-  `2723bcd` [test] Add test for getaddednodeinfo (jimmysong)
-  `c530c15` [tests] remove maxblocksinflight.py (functionality covered by other test) (jnewbery)
-  `1b25b6d` Move zmq test skipping logic into individual test case (jnewbery)
-  `54e2d87` [Tests] Prevent warning: variable 'x' is uninitialized (paveljanik)
-  `e0a7e19` [test] Add aborttrescan tests (kallewoof)
-  `8254a8a` [test] Add Unit Test for GetListenPort (jimmysong)
-  `47535d7` [test] Unit test amount.h/amount.cpp (jimmysong)
-  `80c3a73` [test] Add test for gettxout to wallet.py (jimmysong)
-  `492d22f` [test] Add tests for getconnectioncount, getnettotals and ping (jimmysong)
-  `8f3e384` [tests] Remove func test code duplication (jnewbery)
-  `dc8fc0c` [tests] Remove is_network_split from functional test framework (jnewbery)
-  `3c5e6c9` [test] Add test for listaddressgroupings (jimmysong)
-  `75171f0` Remove unused import. Remove accidental trailing semicolons (practicalswift)
-  `83073de` [tests] allow zmq test to be run in out-of-tree builds (jnewbery)
-  `e927483` [tests] Fix abandonconflict.py intermittency (jnewbery)
-  `170bc2c` [tests] fix wait_for_inv() (jnewbery)
-  `fff72de` [tests] Add node methods to test framework (jnewbery)
-  `23d78c4` test: Add elapsed time to RPC tracing (laanwj)
-  `6a796b2` [tests] Improve mempool_persist test (jnewbery)
-  `776ba23` [tests] Update Unit Test for addrman.h/addrman.cpp (jimmysong)
-  `7ee5236` [tests] increase timeouts in sendheaders test (jnewbery)
-  `f6241b3` qa: disablewallet: Check that wallet is really disabled (MarcoFalke)
-  `4b766fc` [tests] Clean up addrman_tests.cpp (jimmysong)
-  `87abe20` [test] Add test for getnetworkhashps (jimmysong)
-  `8bd16ee` [tests] fix disconnect_ban intermittency (jnewbery)
-  `5411997` qa: Warn when specified test is not found (MarcoFalke)
-  `0542978` tests: Correct testcase in script_tests.json for large number OP_EQUAL (laanwj)
-  `6b99daf` tests: fix spurious addrman test failure (theuni)
-  `8e57256` [tests] improve tmpdir structure (jnewbery)
-  `217b416` [tests] Speed up fuzzing by ~200x when using afl-fuzz (practicalswift)
-  `b4b057a` Add test for empty chain and reorg consistency for gettxoutsetinfo (gmaxwell)
-  `1aefc94` [tests] skipped tests should clean up after themselves (jnewbery)
-  `329fc1d` [tests] functional tests should call BitcoinTestFramework start/stop node methods (jnewbery)
-  `e103b3f` Bugfix: missing == 0 after randrange (sipa)
-  `c871f32` [test] Add test for getchaintxstats (jimmysong)
-  `bea5b00` Remove xvfb configuration from travis (ryanofsky)
-  `30853e1` [qa] fundrawtx: Fix shutdown race (MarcoFalke)
-  `300f8e7` tests: Add FindEarliestAtLeast test for edge cases (ryanofsky)
-  `75e898c` Share config between util and functional tests (jnewbery)
-  `e801084` Use FastRandomContext for all tests (sipa)
-  `6c2d81f` [tests] Remove printf(...) (practicalswift)
-  `71ab6e5` [tests] Use FastRandomContext instead of boost::random::{mt19937,uniform_int_distribution} (practicalswift)
-  `6702617` [Tests] Wallet encryption functional tests (achow101)
-  `643fa0b` [tests] various improvements to zmq_test.py (jnewbery)
-  `d083bd9` [tests] Use cookie auth instead of rpcuser and rpcpassword (achow101)
-  `c68a9a6` qa: Add stopatheight test (MarcoFalke)
-  `4bc853b` [qa] util: Check return code after closing bitcoind proc (MarcoFalke)
-  `e0a7801` Initialize randomness in benchmarks (achow101)
-  `7c87a9c` The young person's guide to the test_framework (jnewbery)
-  `acb1153` [qa] blockchain: Pass on closed connection during generate call (MarcoFalke)
-  `416af3e` [qa] Bugfix: allow overriding extra_args in ComparisonTestFramework (sdaftuar)
-  `65cc7aa` Move stop/start functions from utils.py into BitcoinTestFramework (jnewbery)
-  `dd07f47` [tests] nits in dbcrash.py (jnewbery)
-  `be82498` [test] don't run dbcrash.py on Travis (jnewbery)
-  `d3b5870` [tests] fix replace_by_fee.py (jnewbery)
-  `1d4805c` Fix multi_rpc test for hosts that dont default to utf8 (TheBlueMatt)
-  `e4f226a` [tests] mining functional tests (including regression test for submitblock) (jnewbery)
-  `1fc783f` test: Move variable `state` down where it is used (paveljanik)
-  `fee0d80` Fix mem access violation merkleblock (Christewart)
-  `0c173a1` [QA] Avoid running multiwallet.py twice (jonasschnelli)
-  `9d5e8f9` test: Make sure wallet.backup is created in temp path (laanwj)
-  `f29d5db` [test] Qt: Use _putenv_s instead of setenv on Windows builds (brianmcmichael)
-  `5c8eb79` [tests] Fix incorrect memory_cleanse(?) call in crypto_tests.cpp (practicalswift)
-  `fa8a063` [tests] Test disconnecting unsupported service bits logic (jnewbery)
-  `929fd72` [qa] Rewrite BIP65/BIP66 functional tests (sdaftuar)
-  `ecd2135` [bench] Restore format state of cout after printing with std::fixed/setprecision (practicalswift)
-  `e5d26e4` qa: Fix inv race in example_test (MarcoFalke)
-  `2c811e0` Tests: address placement should be deterministic by default (ReneNyffenegger)
-  `ac016e1` test: Add resendwallettransactions functional tests (promag)
-  `aeb3175` [qa] Fix block message processing error in sendheaders.py (sdaftuar)
-  `0b9fb68` [tests] fixup - make all Travis test runs quiet, non just cron job runs (jnewbery)
-  `6ce7337` [tests] test_runner - check unicode (jnewbery)
-  `35da2ae` [tests] remove import-abort-rescan.py (jnewbery)
-  `bf74d37` [tests] Add option to attach a python debugger if functional test fails (jnewbery)
-  `8c2098a` [coverage] Remove subtrees and benchmarks from coverage report (achow101)
-  `21630f8` *Add RPC based rescan test (jonasschnelli)
-  `d109d58` *QA: Functional test for sweepprivkeys (luke-jr)
 Miscellaneous
-  `be8ba2c` Add a tree sha512 hash to merge commits (sipa)
-  `d19d45a` util: Specific GetOSRandom for Linux/FreeBSD/OpenBSD (laanwj)
-  `ba80a68` Docs: add details to -rpcclienttimeout doc (ian-kelling)
-  `53c300f` Docs: correct and elaborate -rpcbind doc (ian-kelling)
-  `01b7cda` [contrib] gh-merge: Move second sha512 check to the end (MarcoFalke)
-  `4df8213` Verify Tree-SHA512s in merge commits, enforce sigs are not SHA1 (TheBlueMatt)
-  `00c13ea` Fix verify-commits on travis and always check top commit's tree (TheBlueMatt)
-  `6996e06` Add historical release notes for 0.14.0 (laanwj)
-  `fa99663` Fix verify-commits on OSX, update for new bad Tree-SHA512, point travis to different keyservers (TheBlueMatt)
-  `8040ae6` util: Properly handle errors during log message formatting (laanwj)
-  `cce056d` devtools: Make github-merge compute SHA512 from git, instead of worktree (laanwj)
-  `8bcf934` [doc] clarify blockchain size and pruning (askmike)
-  `0c17afc` Add updating of chainTxData to release process (sipa)
-  `530fcbd` add missing spaces so that markdown recognizes headline (flack)
-  `db1ae54` Docs: remove 'noconnect' option (jlopp)
-  `8e4f7e7` Update bitcoin.conf with example for pruning (coinables)
-  `1a5aaab` Change LogAcceptCategory to use uint32_t rather than sets of strings (gmaxwell)
-  `fbf36ca` Fix init README format to render correctly on github (jlopp)
-  `a2cd0b0` No need to use OpenSSL malloc/free (tjps)
-  `471ed00` Allow debug logs to be excluded from specified component (jnewbery)
-  `fadf078` linearize script: Option to use RPC cookie (achow101)
-  `a3a2160` [trivial] Log calls to getblocktemplate (jnewbery)
-  `928695b` build: Deduplicate version numbers (laanwj)
-  `a86255b` [doc] Contributor fixes & new "finding reviewers" section (kallewoof)
-  `1428f30` Fix some empty vector references (sipa)
-  `95f5e44` Remove Clang workaround for Boost 1.46 (fanquake)
-  `cb007e4` Trivial: fix fee estimate write error log message (CryptAxe)
-  `bd9ec0e` contrib: github-merge improvements (laanwj)
-  `1d75597` [doc] Minor corrections to osx dependencies (fanquake)
-  `750c5a5` devtools/net: add a verifier for scriptable changes. Use it to make CNode::id private (theuni)
-  `bc64b5a` Use hardware timestamps in RNG seeding (sipa)
-  `7f2b9e0` Shadowing warnings are not enabled by default, update doc accordingly (paveljanik)
-  `b6ee855` [doc] Removing comments about dirty entries on txmempool (madeo)
-  `d0c37ee` [logging] log system time and mock time (jnewbery)
-  `b45a52a` doc: Add logging to FinalizeNode() (sdaftuar)
-  `526e839` Output line to debug.log when IsInitialBlockDownload latches to false (morcos)
-  `15254e9` Add perf counter data to GetStrongRandBytes state in scheduler (TheBlueMatt)
-  `55b72f3` Update style guide (sipa)
-  `10e8c0a` devtools: Retry after signing fails in github-merge (laanwj)
-  `f259263` Make bitcoind invalid argument error message specific (laanwj)
-  `6a38b79` contrib: Update location of seeds.txt (laanwj)
-  `b6b150b` Fixing typo in rpcdump.cpp help message (keystrike)
-  `27b9931` contrib/init/bitcoind.openrcconf: Don't disable wallet by default (luke-jr)
-  `00d3692` Update to latest libsecp256k1 master (sipa)
-  `cec9e1e` Fix timestamp in fee estimate debug message (morcos)
-  `5d034ee` [docs] Use the "domain name setup" image (previously unused) in the gitian docs (practicalswift)
-  `a514ac3` Clarify prevector::erase and avoid swap-to-clear (sipa)
-  `22ec768` Header include guideline (sipa)
-  `fbf5d3b` Improve commit-check-script.sh (sipa)
-  `1ad3d4e` scripted-diff: Remove BOOST_FOREACH, Q_FOREACH and PAIRTYPE (jtimon)
-  `b63be2c` Use rdrand as entropy source on supported platforms (sipa)
-  `228c319` Turn TryCreateDirectory() into TryCreateDirectories() (benma)
-  `d76e84a` Make clang-format use C++11 features (e.g. A> instead of A >) (practicalswift)
-  `c38f540` doc: Add 0.14.2 release notes (MarcoFalke)
-  `b750b33` contrib/verifybinaries: allow filtering by platform (knocte)
-  `01c4b14` Rewrite addrdb with less duplication using CHashVerifier (sipa)
-  `232508f` Add an explanation of quickly hashing onto a non-power of two range (gmaxwell)
-  `eee398f` Add a comment explaining the use of MAX_BLOCK_BASE_SIZE (gmaxwell)
-  `7397af9` fix typo in help text for removeprunedfunds (AkioNak)
-  `6dbcc74` scripted-diff: Remove   (jtimon)
-  `379aed0` document script-based return fields for validateaddress (instagibbs)
-  `cef4b5c` Verify binaries from bitcoincore.org and bitcoin.org (TheBlueMatt)
-  `ca4c545` Add PR description to merge commit in github-merge.py (sipa)
-  `c5904e8` [utils] Allow bitcoin-cli's -rpcconnect option to be used with square brackets (jnewbery)
-  `3895e25` Fix incorrect Doxygen tag ( ?  Doxygen parameter name matching (practicalswift)
-  `df0793f` add gdb attach process to test README (instagibbs)
-  `1124328` Punctuation/grammer fixes in rpcwallet.cpp (stevendlander)
-  `78f307b` Properly document target_confirmations in listsinceblock (RHavar)
-  `5c003cb` developer-notes: add reference to snake_case and PascalCase (benma)
-  `4b5a7ce` Docs: Capitalize bullet points in CONTRIBUTING guide (eklitzke)
-  `98aa3f6` Add instructions for parallel gitian builds (coblee)
-  `1c4b9b3` 0.15 release-notes nits: fix redundancy, remove accidental parenthesis & fix range style (practicalswift)
-  `8f0121c` Update contributor names in release-notes.md (Derek701)
-  `cbdd338` disable jni in builds (instagibbs)
-  `2b59cfb` doc: Update build-openbsd for 6.1 (laanwj)
-  `0a6af47` [doc] build-windows: Mention that only trusty works (MarcoFalke)
-  `e8ad101` Changing -txindex requires -reindex, not -reindex-chainstate (TheBlueMatt)
-  `342b9bc` FastRandomContext improvements and switch to ChaCha20 (sipa)
-  `67ed40e` Prevector Quick Destruct (JeremyRubin)
-  `ef37f20` Use cpuid intrinsics instead of asm code (sipa)
-  `a328904` [LevelDB] Plug leveldb logs to bitcoin logs (NicolasDorier)
-  `c5e9e42` Prevent integer overflow in ReadVarInt (gmaxwell)
-  `351d0ad` scheduler: fix sub-second precision with boost < 1.50 (theuni)
-  `fade788` logging: Fix off-by-one for shrinkdebugfile default (MarcoFalke)
-  `c45da32` Fix potential NPD introduced in b297426c (TheBlueMatt)
-  `daf3e7d` Maintain state across GetStrongRandBytes calls (sipa)
-  `a4fe077` Update to LevelDB 1.20 (sipa)
-  `cafe24f` random: fix crash on some 64bit platforms (theuni)
-  `2a09a38` Avoid printing incorrect block indexing time due to uninitialized variable (practicalswift)
-  `8bc6d1f` Fix resource leak on error in GetDevURandom (corebob)
-  `89bb036` init: Factor out AppInitLockDataDirectory and fix startup core dump issue (laanwj)
-  `b995a37` Add missing lock in CScheduler::AreThreadsServicingQueue() (TheBlueMatt)
-  `659c096` Update to latest Bitcoin patches for LevelDB (sipa)
-  `c1c671f` Fix more init bugs (TheBlueMatt)
-  `9190a76` *ArgsManager: ForceSetArg with int64_t (luke-jr)
-  `6091bf1` *CValidationInterface: ValidationInterfaceUnregistering, called when being unregistered (luke-jr)
- n/a    `c36f8ba` *Bump minimum Windows version to Vista
-  `2eea64b` *script/interpreter: Wrap EvalScript in a ScriptExecution class (luke-jr)
-  `7acd5fc` *Move script flag to/from-string logic from tests to script/interpreter (luke-jr)
Thanks to everyone who directly contributed to this release:
- ??? ??
- Ahmad Kazi
- aideca
- Akio Nakamura
- Aleksandras Ragovskis
- Alex Morcos
- Allan Doensen
- Andres G. Aragoneses
- Andrew Chow
- Angel Leon
- Awemany
- Bob McElrath
- Brian McMichael
- BtcDrak
- Charlie Lee
- Chris Gavin
- Chris Stewart
- Cory Fields
- CryptAxe
- Dag Robole
- Daniel Aleksandersen
- Daniel Cousens
- Daniel Edgecumbe
- darksh1ne
- Dimitris Tsapakidis
- Doron Somech
- Eric Lombrozo
- Eric Shaw
- Evan Klitzke
- fanquake
- Felix Weis
- flack
- Guido Vranken
- Greg Griffith
- Gregory Maxwell
- Gregory Sanders
- Ian Kelling
- Jack Grigg
- James Evans
- James Hilliard
- Jameson Lopp
- Jeremy Rubin
- Jimmy Song
- Jo?o Barbosa
- Joe Harvell
- Johnathan Corgan
- John Newbery
- Jonas Schnelli
- Jorge Tim?n
- Karl-Johan Alm
- kewde
- KibbledJiveElkZoo
- Kirit Thadaka
- kobake
- Kyle Honeycutt
- Lawrence Nahum
- Luke Dashjr
- Marco Falke
- Marcos Mayorga
- Marijn Stollenga
- Mario Dian
- Mark Friedenbach
- Marko Bencun
- Masahiko Hyuga
- Matt Corallo
- Matthew Zipkin
- Matthias Grundmann
- MeshCollider
- Michael Goldstein
- Michael Rotarius
- Mikerah
- Mike van Rossum
- Mitchell Cash
- Nicolas Dorier
- Patrick Strateman
- Pavel Jan?k
- Pavlos Antoniou
- Pavol Rusnak
- Pedro Branco
- Peter Todd
- Pieter Wuille
- practicalswift
- Ren? Nyffenegger
- Ricardo Velhote
- romanornr
- Russell Yanofsky
- Rusty Russell
- Ryan Havar
- shaolinfry
- Shigeya Suzuki
- Simone Madeo
- Spencer Lievens
- Steven D. Lander
- Suhas Daftuar
- Takashi Mitsuta
- Thomas Snider
- Timothy Redaelli
- tintinweb
- tnaka
- Warren Togami
- Wladimir J. van der Laan
As well as everyone that helped translating on [Transifex](

@_date: 2017-09-19 03:09:08
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] cleanstack alt stack & softfork improvements (Was: 
On Tuesday 19 September 2017 12:46:30 AM Mark Friedenbach via bitcoin-dev Isn't this a bug in the cleanstack rule?
Another thing that came up during the discussion was the idea of replacing all the NOPs and otherwise-unallocated opcodes with a new OP_RETURNTRUE implementation, in future versions of Script. This would immediately exit the program (perhaps performing some semantic checks on the remainder of the Script) with a successful outcome.
This is similar to CVE-2010-5141 in a sense, but since signatures are no longer Scripts themselves, it shouldn't be exploitable.
The benefit of this is that it allows softforking in ANY new opcode, not only the -VERIFY opcode variants we've been doing. That is, instead of merely terminating the Script with a failure, the new opcode can also remove or push stack items. This is because old nodes, upon encountering the undefined opcode, will always succeed immediately, allowing the new opcode to do literally anything from that point onward.

@_date: 2017-09-21 04:11:49
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] cleanstack alt stack & softfork improvements 
This seems like a problem for signature aggregation to address, not a problem for OP_RETURNTRUE... In any case, I don't think it's insurmountable. Signature aggregation can simply be setup upfront, and have the Script verify inclusion of keys in the aggregation?
This is another approach, and one that seems like a good idea in general. I'm not sure it actually needs to take more witness space - in theory, such stack items could be implied if the Script engine is designed for it upfront. Then it would behave as if it were non-verify, while retaining backward

@_date: 2017-09-21 16:33:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] cleanstack alt stack & softfork improvements 
SigAgg is a softfork, so old clients *won't* understand it... am I missing For example, perhaps the lookup opcode could have a data payload itself (eg, like pushdata opcodes do), and the script can be parsed independently from execution to collect the applicable ones.
The same as your OP_MULVERIFY at the consensus level, except new clients would execute it as an OP_MUL, and inject pops/pushes when sending such a transaction to older clients. The hash committed to for the script would include the inferred values, but not the actual on-chain data. This would probably need to be part of some kind of MAST-like softfork to be viable, and maybe not even then.

@_date: 2017-09-27 18:56:26
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Revising BIP 2 to expand editorial authority 
Many pull requests to the BIPs repository are spelling corrections or similar, which are obvious to merge. Currently, the BIP process requires the Author of the affected BIPs to ACK any changes, which seems inefficient and unnecessary for these kind of editorial fixes.
What do people think about modifying BIP 2 to allow editors to merge these kinds of changes without involving the Authors? Strictly speaking, BIP 2 shouldn't be changed now that it is Active, but for such a minor revision, I think an exception is reasonable.
I've prepared a draft PR for BIP 2 here:
    If you oppose this change, please say so within the next month.

@_date: 2017-09-28 16:59:26
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Address expiration times should be added to 
Payment requests don't use and don't overlap with addresses. Maybe you could have an argument for serialising BIP70 payment requests in Bech32 as the new address format itself, but it doesn't make sense to talk about putting a Bech32 address *into* a payment request...

@_date: 2017-09-30 23:23:32
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Merkle branch verification & tail-call semantics 
Just noticed this doesn't count sigops toward the block sigop limit.
Is that really safe? How long would it take, to verify a malicious block with only inputs such that there is nearly 4 MB of sigops?
(I do already understand the difficulty in supporting the sigop limit.)

@_date: 2018-04-13 22:52:23
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BloomFilter issue with segwit addresses 
As I understand it, the plan is to deprecated and remove BIP37 entirely once BIP158 is implemented and deployed.
In the meantime, Bitcoin Knots supports the MSG_FILTERED_WITNESS_BLOCK extension to download witness data. (Note that light clients currently have no way to verify the witness data is correct.)
As far as matching goes, why not look for the specific COutPoints? That should work already with standard BIP37.

@_date: 2018-08-06 02:04:18
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Claiming an OP_RETURN Prefix 
Are you doing coloured coins or storing data?
If the former, you should probably collaborate with the authors of BIP 160 (yet to be added to the main repo), and/or write a new BIP if BIP 160 is insufficient for some reason.
If the latter, you just shouldn't do it at all.
Note that BIPs need to specify an actual protocol, not just claim a prefix.

@_date: 2018-08-16 01:06:53
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Claiming an OP_RETURN Prefix 
Not true at all.
Choosing not to mine transactions is not censorship.

@_date: 2018-08-16 02:37:11
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Claiming an OP_RETURN Prefix 
Miners have always chosen transaction on "political" basises, and doing such is their right. That's why the system is supposed to be comprised of many miners, all with their own policies - so the choices of one do not impact the overall ability to spend (presumably only spam should be rejected by all For fees to themselves justify the cost of a transaction, they would need to be magnitudes higher than we've ever seen on Bitcoin. But even then, nobody has an obligation to accept payment, no matter how reasonable it is, for a service they don't want to provide.

@_date: 2018-02-13 17:53:40
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Possible change to the MIT license 
This would give too much power to Bitcoin Core, and implies falsely that Bitcoin and Bitcoin Core are the same thing.
On Tuesday 13 February 2018 12:25:53 PM JOSE FEMENIAS CA?UELO via bitcoin-dev

@_date: 2018-02-14 22:11:42
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Amend the BIP 123 process to include buried 
They also do not require software coordination. Therefore, why should there be BIPs at all? Seems to me that we should instead add these documents to That being said, I'm also okay with just adding an Annex to the original softfork/hardfork BIP describing each shortcut. It just seems annoying to have two BIPs for every protocol change: one for the change itself, and then another for implementation-specific shortcuts taken.

@_date: 2018-01-04 14:23:05
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] =?iso-8859-1?q?Bech32_and_P2SH=B2?= 
I know I'm super-late to bring this up, but was there a reason Bech32 omitted the previously-discussed P2SH? improvements? Since deployment isn't too widespread yet, maybe it'd be worth a quick revision to add this?
For those unfamiliar with the concept, the idea is to have the address include the *single* SHA256 hash of the public key or script, rather than RIPEMD160(SHA256(pubkey)) or SHA256(SHA256(script)). The sender would then perform the second hash to produce the output. Doing this would in the future enable relaying the "middle-hash" as a way to prove the final hash is in fact a hash itself, thereby proving it is not embedded data spam.
Bech32 seems like a huge missed opportunity to add this, since everyone will probably be upgrading to it at some point.

@_date: 2018-01-06 00:26:51
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] =?iso-8859-1?q?Bech32_and_P2SH=B2?= 
I've posted an initial draft of a possible Bech32 revision/replacement here:

@_date: 2018-01-16 04:15:54
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP 117 Feedback 
This doesn't affect the alt-stack (it's a completely separate stack).
I'm not aware of a single standard/BIP that uses the altstack at all.

@_date: 2018-07-03 12:13:44
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [Lightning-dev]  BIP sighash_noinput 
I don't agree. Address reuse is undefined behaviour. Nobody should assume it is safe or works.
I intend to possibly use SIGHASH_NOINPUT for ordinary Bitcoin transactions in a wallet I am writing, which explicitly does not support address reuse.

@_date: 2018-03-07 14:43:11
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: Reserved nversion bits in 
Why are you posting this obsolete draft? You've already received review in private, and been given useful suggestions. There's even a shared Google Doc with the current draft:
    * This is no different from what Timo and Sergio proposed years ago, and as such should be based on their work instead of outright not-invented-here respecification. The current draft integrates their work while not trying to steal credit for it (they are included as primary authors).
* The specification should be complete, including updates for GBT and the Stratum mining protocol. These are included in the current draft.
Additionally, it is not appropriate to begin using a draft BIP on mainnet before any discussion or consensus has been reached. Doing so seems quite malicious, in fact. I hope DragonMint miners can still operate using the *current* Bitcoin protocol.

@_date: 2018-03-07 15:48:00
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP proposal: Reserved nversion bits in 
This reasoning is not sound.
It was as well documented as the original stratum protocol, and in use since While the response type is admittedly undefined, simply defining that would have been a better solution than to reinvent it incompatibly for no reason. (Although version rolling does not actually require a response at all.)

@_date: 2018-03-14 12:36:47
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
I don't see a need for a new RPC interface, just a new signature format.
Ideally, it should support not only just "proof I receive at this address", but also "proof of funds" (as a separate feature) since this is a popular misuse of the current message signing (which doesn't actually prove funds at all). To do this, it needs to be capable of signing for multiple inputs.
Preferably, it should also avoid disclosing the public key for existing or future UTXOs. But I don't think it's possible to avoid this without something MAST-like first. Perhaps it can be a MAST upgrade later on, but the new signature scheme should probably be designed with it in mind.

@_date: 2018-03-15 14:14:04
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] {sign|verify}message replacement 
Not necessarily specific UTXOs (that would contradict fungibility, as well as be impossible for hot/cold wallet separation), but just to prove funds are available. The current sign message cannot be used to prove present possession of funds, only that you receive funds.

@_date: 2018-05-10 02:27:41
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Making OP_TRUE standard? 
An OP_TRUE-only script with a low value seems like a good example of where the weight doesn't reflect the true cost: it uses a UTXO forever, while only costing a weight of 4.
I like Johnson's idea to have some template (perhaps OP_2-only, to preserve expected behaviour of OP_TRUE-only) that when combined with a 0-value is always valid only if spent in the same block.
I wonder if it would make sense to actually tie it to a transaction version bit, such that when the bit is set, the transaction is serialised with +1 on the output count and 00000000000000000181 is simply injected into the transaction hashing... But for now, simply having a consensus rule that a bit MUST be set for the expected behaviour, and the bit may ONLY be set when the last output is exactly 00000000000000000181, would allow us to code the transaction serialisation up later. (Maybe it should be the first output instead of the last... Is there any legitimate reason one would have multiple such dummy outputs?)

@_date: 2018-05-10 09:43:28
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Making OP_TRUE standard? 
You'd send 0 satoshis to OP_TRUE, creating a UTXO. Then you spend that 0-value UTXO in another transaction with a normal fee. The idea is that to get the latter fee, the miner needs to confirm the original tranaction with the 0-value OP_TRUE.
(Aside, in case it wasn't clear on my previous email, the template-script idea would not make it *mandatory* to spend in the same block, but that the UTXO would merely cease to be valid *after* that block. So the 0-value output does not take up a UTXO db entry when left unused.)

@_date: 2019-04-01 00:30:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Softfork proposal for minimum price of $50k USD/BTC 
Certain parts of the community have been selling bitcoins for unreasonably
low prices. This has halted Bitcoin's valuation at $20k and even driven the
price down below $15k! However, clearly Bitcoin is worth much more than
that, and there is widespread support for higher prices.
In light of this, I have written and implemented two BIPs: one to add a
signed price field to Bitcoin transactions, and the other to softfork a
minimum price of $50k USD/BTC a year from today.
The BIPs are here, as well as included at the bottom of this email for   A reference implementation is here:
  Please review ASAP so we can get these deployed in Bitcoin Core v0.18.
  BIP: ?
  Layer: Applications
  Title: Signed USD Price Indicator
  Author: Luke Dashjr   Comments-Summary: No comments yet.
  Comments-URI:   Status: Draft
  Type: Standards Track
  Created: 2019-04-01
  License: BSD-2-Clause
This BIP proposes a method to explicitly specify and sign the USD/BTC price for transactions.
This BIP is licensed under the BSD 2-clause license.
Certain parts of the community have been selling bitcoins for unreasonably low prices. This has halted Bitcoin's valuation at $20k and even driven the price down below $15k! However, clearly Bitcoin is worth much more than that, and there is widespread support for higher prices.
This problem can be fixed by setting a global minimum price for bitcoins. Unfortunately, today, the consensus protocol is completely oblivious to the price bitcoins are traded at. Therefore, we must first add a field to Bitcoin transactions to indicate their price.
===New field and legal implication===
A new field is added to Bitcoin transactions. This field, if present, must represent the honest and true USD/BTC rate used for the transaction. By signing the transaction, the sender legally affirms this is the valuation of bitcoins used for the transaction.
For the avoidance of doubt: when the transaction is valued in a currency other than USD, any reasonable exchange rate may be used to come up with the USD When serialising the transaction for any purpose, including signing, weight calculation, and so on, the output count must be incremented by one. Prior to the first real output, the following bytes must be inserted:
* Constant: 00 00 00 00 00 00 00 00
* A single byte, the size in bytes of the remainder of the inserted data
* Constant: 6a 04 55 53 44 24
* A single byte, the size in bytes of the remainder of the inserted data
* The USD/BTC rate used for the transaction, in standard signed integer serialisation, with all leading zeros removed (except as necessary to preserve the sign bit).
==Backwards compatibility==
The new price field is serialised as a dummy output, with a value of zero, and a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore this dummy output, and the leading OP_RETURN in the scriptPubKey ensures it is never considered spendable.
Therefore, current nodes will ignore the new field entirely, and accept transactions using it.
Existing wallets do not typically generate price indicators as specified. Under this BIP, this absence of the field is perfectly acceptable.
==Reference implementation==
  BIP: ?
  Layer: Consensus (soft fork)
  Title: $50k USD/BTC Minimum Price
  Author: Luke Dashjr   Comments-Summary: No comments yet.
  Comments-URI:   Status: Draft
  Type: Standards Track
  Created: 2019-04-01
  License: BSD-2-Clause
  Requires: usdprice
This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.
This BIP is licensed under the BSD 2-clause license.
Certain parts of the community have been selling bitcoins for unreasonably low prices. This has halted Bitcoin's valuation at $20k and even driven the price down below $15k! However, clearly Bitcoin is worth much more than that, and there is widespread support for higher prices.
bip-usdprice defines a new field to indicate the price of transactions. Using this, we can softfork to require a minimum transaction price.
Beginning with block height 622370 (expected approximately 2020 April 1), a block is reject as invalid unless all transactions it contains both declare a USD/BTC price (as defined in bip-usdprice) and specify a price that is at a minimum $50k USD/BTC.
==Backwards compatibility==
As a soft fork, older nodes will continue to accept the blockchain without modification. Non-upgraded nodes, however, will not validate the minimum price requirement, and may accept invalid blocks if miners choose to make them. Since transactions not declaring a price are at this time still common-place, the softfork activation has been set a full year into the future to ensure time to upgrade both nodes and wallet software.
==Reference implementation==

@_date: 2019-04-03 09:55:26
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] assumeutxo and UTXO snapshots 
This would lead to users trusting third parties (like developers) way too Furthermore, removing the ability for users to easily set it removes the one reasonable use case: where the user has already verified the state at some point previously, and saved the hash (ie, as backup of the UTXO set).

@_date: 2019-04-04 02:48:33
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] assumeutxo and UTXO snapshots 
No, we don't. This is exactly the danger. UTXO snapshots are NOT an alternative to a real IBD. There are HUGE security implications for this. Frankly, the danger that someone would do such a thing is itself a good reason not to ever add UTXO commitments.

@_date: 2019-04-04 03:01:00
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] assumeutxo and UTXO snapshots 
Learning C++ is something within everyone's capability. Even people who do not wish to learn it can hire someone to perform review for them.
No, we are not. We explicitly disclaim any warranty, and do not want your Verifying a UTXO set commitment is impossible short of a real IBD. It's not even comparable.
No, it isn't okay. There are plenty of fiat options if you want a trust-based currency. Bitcoin is supposed to be something more than that.

@_date: 2019-04-29 03:01:41
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] IsStandard 
The name is confusing. It has little to do with standards, really.
IsStandard is just one of the functions which implement the node's policy.
It allows many things for which there is no standard (eg, data carrier / OP_RETURN outputs), and can vary freely from node to node (either by configurable parameters, or by different/modified software) without breaking As it is a node-specific criteria, it is not itself even a possible *subject* for standards.
Additionally, it should not be given much (if any) attention when defining new standards. Just do what makes sense for the standard, and node policies can be adapted around that.
So, overall, there's limited use case for documenting this beyond the code.
It makes far more sense to document actual standards instead.

@_date: 2019-02-15 15:18:18
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] [BIP Proposal] Simple Proof-of-Reserves 
But nodes can never prove the transaction is invalid, thus if sent it, they will likely cache the "transaction", taking up memory. I'm not sure if this is an actual problem, as an attacker can fabricate such transactions anyway.
I don't see anything in the format that would prove unspentness...
IIRC, this has been contentious for its use in BIP70 and may hinder adoption.
This isn't really sufficient. There should probably be a merkle proof.

@_date: 2019-02-19 19:04:03
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Safer NOINPUT with output tagging 
Yes, this seems to break the situation where a wallet wants to use NOINPUT for everything, including normal L1 payments. For example, in the scenario where address reuse will be rejected/ignored by the recipient unconditionally, and the payee is considered to have burned their bitcoins by attempting it.

@_date: 2019-02-19 20:24:12
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Safer NOINPUT with output tagging 
Even besides NOINPUT, such a wallet would simply never show a second payment to the same address (or at least never show it as confirmed, until successfully spent).
At least if tx versions are used, it isn't possible to indicate this requirement in current Bitcoin L1 addresses. scriptPubKey might not be impossible to encode, but it isn't really clear what the purpose of doing so If people don't want to use NOINPUT, they should just not use it. Trying to implement a nanny in the protocol is inappropriate and limits what developers can do who actually want the features.

@_date: 2019-07-22 17:17:28
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
Neutrino is very controversial, and NOT less trustful than bloom filters.
It also uses significantly more bandwidth.
It seems a better approach is to add Stratum (Electrum) support, and to limit usage of all pseudo-SPV protocols to trusted peers.
Eric Lombrozo added segwit support. While it was never reviewed for Core, it has been included and supported in Knots since v0.15.1. As I understand it, his mSIGNA wallet also makes usage of the feature.

@_date: 2019-07-22 17:26:56
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
Where do you see this number? I think it would be useful to chart.
Electrum has a JSON-based protocol that can provide information much more Currently, this does require nodes that run additional software and/or indexes, but there are plenty of them available, and there are steps that can be taken to improve that situation.
Many users run older versions, and do not update immediately. Today, only 42% of listening nodes are using 0.18.
(If it helps ease the concern, we can keep bloom enabled by default in Knots There will be time to do so, since the functionality won't disappear

@_date: 2019-07-22 21:17:29
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
It's not EOL, just disabled by default. Anyone can provide it by choice.
Same as with Stratum/Electrum right now (except easier to enable).
This is incorrect. Such wallets strictly degrade security, as they are blindly trusting miners. They make the network more VULNERABLE to 2X-like attacks.

@_date: 2019-07-25 03:04:25
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
It's supported by default in sipa's bitcoin-seeder, which many DNS seeds use.
My seed also currently requires NODE_BLOOM for *any* answers returned.
(But I don't guarantee that will remain forever.)
Light wallets are just as bad for the network as custodial wallets.
Light wallets are not Bitcoin scaling. They are just trusting anonymous 3rd parties, which is harmful to Bitcoin.

@_date: 2019-07-27 19:19:49
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by 
BTW, you are indeed wrong on this. You don't need to match every single address the wallet has ever used, only outstanding addresses that haven't been paid. ;)

@_date: 2019-06-22 23:42:52
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] PSA: Upcoming disclosure of pre-v0.17.1 
Two relatively minor vulnerabilities will likely be disclosed sometime soon.
The first vulnerability, CVE-2017-18350, was introduced in v0.7.0 (released in 2012 September), and affects all versions released until the fix was included in v0.15.1 (released in 2017 November). No versions prior to v0.15.1 are expected to be fixed.
The second vulnerability, CVE-2018-20586, was introduced in v0.12.0 (released in 2016 February), and affects all versions released until the fix was included in v0.17.1 (released in 2018 December). As of today, this fix has NOT been backported to older versions. When/if v0.15.3 and v0.16.4 are released, they may also include a fix, but due to the minor severity of this vulnerability, it does not merit a dedicated release on its own. (The git branches are also NOT fixed at this time.)
Please be sure you have upgraded to a fixed version no later than August 1st.

@_date: 2019-03-07 10:44:34
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Proposal: The Great Consensus Cleanup 
Needs a Backward Compatibility section, and should have a bips repo PR opened after discussion on the ML.
I don't understand what is being removed here.
While I agree that extension blocks are typically a bad choice, I'm not sure the argument really applies to forward blocks. (That being said, I find forward blocks overcomplicated and probably not a reason to avoid this.)
Rationale should include the reason(s) why the size doesn't count the witness This should probably be moved outside Discussion. (Perhaps to the missing Backward Compatibility section?)
It's not clear that new opcodes will necessarily always be used. Probably would be good to clarify the "non-Segwit or witness v0 only" rule in the Specification section.

@_date: 2019-05-04 02:50:02
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.18.0.knots20190502 released 
Bitcoin Knots version *0.18.0.knots20190502* is now available from:
This is a new major version release, including new features, various bug
fixes and performance improvements, as well as updated translations.
Please report bugs using the issue tracker at GitHub:
How to Upgrade
If you are running an older version, shut it down. Wait until it has
completely shut down (which might take a few minutes for older
versions), then run the installer (on Windows) or just copy over
`/Applications/Bitcoin-Qt` (on Mac) or `bitcoind`/`bitcoin-qt` (on
The first time you run version 0.15.0 or newer, your chainstate database
will be converted to a new format, which will take anywhere from a few
minutes to half an hour, depending on the speed of your machine.
Note that the block database format also changed in version 0.8.0 and
there is no automatic upgrade code from before version 0.8 to version
0.15.0 or later. Upgrading directly from 0.7.x and earlier without
redownloading the blockchain is not supported.  However, as usual, old
wallet versions are still supported.
Bitcoin Knots is supported on operating systems using the Linux kernel,
macOS 10.10+, and Windows 7 and newer. It is not recommended to use
Bitcoin Knots on unsupported systems.
From 0.17.0 onwards, macOS <10.10 is no longer supported. 0.17.0 is
built using Qt 5.9.x, which doesn't support versions of macOS older than
10.10. Additionally, Bitcoin Knots does not yet change appearance when
macOS "dark mode" is activated.
In addition to previously-supported CPU platforms, this release's
pre-compiled distribution also provides binaries for the RISC-V
If you are using the `systemd` unit configuration file located at
`contrib/init/bitcoind.service`, it has been changed to use
`/var/lib/bitcoind` as the data directory instead of
`~bitcoin/.bitcoin`. When switching over to the new configuration file,
please make sure that the filesystem on which `/var/lib/bitcoind` will
exist has enough space (check using `df -h /var/lib/bitcoind`), and
optionally copy over your existing data directory. See the [systemd init
file section]( for more details.
Known issues
Wallet GUI
For advanced users who have both (1) enabled coin control features, and
(2) are using multiple wallets loaded at the same time: The coin control
input selection dialog can erroneously retain wrong-wallet state when
switching wallets using the dropdown menu. For now, it is recommended
not to use coin control features with multiple wallets loaded.
Notable changes
- Previously, transactions sending to future Bech32 address versions
  would be rejected, which could lead to stuck transactions, locking
  up change. This has been relaxed by default to mitigate the issue.
  For 0.18.0, the `-sendtofuture=0` option (also available in the
  GUI Mempool Settings tab) can restore the old policy, but this is
  discouraged, and will be removed in the future.
- Calls to `getblocktemplate` will fail if the segwit rule is not
  specified.  Calling `getblocktemplate` without segwit specified is
  almost certainly a misconfiguration since doing so results in lower
  rewards for the miner.  Failed calls will produce an error message
  describing how to enable the segwit rule.
- By default, blocks mined with Bitcoin Knots will be limited to 300k
  in size, or 1.5 MWU in weight. Note these defaults are just healthy
  recommendations, and can be overridden with the `-blockmaxsize` and
  `-blockmaxweight` options.
Configuration option changes
The systemd init file (`contrib/init/bitcoind.service`) has been changed
to use `/var/lib/bitcoind` as the data directory instead of
`~bitcoin/.bitcoin`. This change makes Bitcoin Knots more consistent with
other services, and makes the systemd init config more consistent with
existing Upstart and OpenRC configs.
The configuration, PID, and data directories are now completely managed
by systemd, which will take care of their creation, permissions, etc.
See [`systemd.exec(5)`]
for more details.
When using the provided init files under `contrib/init`, overriding the
`datadir` option in `/etc/bitcoin/bitcoin.conf` will have no effect.
This is because the command line arguments specified in the init files
take precedence over the options specified in
- A new short [document]
  about the JSON-RPC interface describes cases where the results of an
  RPC might contain inconsistencies between data sourced from different
  subsystems, such as wallet state and mempool state.  A note is added
  to the [REST interface documentation]
  indicating that the same rules apply.
- Further information is added to the [JSON-RPC
  documentation]
  about how to secure this interface.
- A new [document]
  about the `bitcoin.conf` file describes how to use it to configure
  Bitcoin Knots.
- A new document introduces Bitcoin Knots's BIP174 [Partially-Signed
  Bitcoin Transactions
  (PSBT)](
  interface, which is used to allow multiple programs to collaboratively
  work to create, sign, and broadcast new transactions.  This is useful
  for offline (cold storage) wallets, multisig wallets, coinjoin
  implementations, and many other cases where two or more programs need
  to interact to generate a complete transaction.
- The [output script
  descriptor]
  documentation has been updated with information about new features in
  this still-developing language for describing the output scripts that
  a wallet or other program wants to receive notifications for, such as
  which addresses it wants to know received payments.  The language is
  currently used in multiple new and updated RPCs described in these
  release notes and is expected to be adapted to other RPCs and to the
  underlying wallet structure.
Build system changes
- `signrawtransaction` is removed after being deprecated and hidden
  behind a special configuration option in version 0.17.0.
- The 'account' API is removed after being deprecated in v0.17.  The
  'label' API was introduced in v0.17 as a replacement for accounts.
  See the [release notes from
  v0.17]
  for a full description of the changes from the 'account' API to the
  'label' API.
- `addwitnessaddress` is removed after being deprecated in version
  0.16.0.
- `generate` is deprecated and will be fully removed in a subsequent
  major version.  This RPC is only used for testing, but its
  implementation reached across multiple subsystems (wallet and mining),
  so it is being deprecated to simplify the wallet-node interface.
  Projects that are using `generate` for testing purposes should
  transition to using the `generatetoaddress` RPC, which does not
  require or use the wallet component. Calling `generatetoaddress` with
  an address returned by the `getnewaddress` RPC gives the same
  functionality as the old `generate` RPC.  To continue using `generate`
  in this version, restart bitcoind with the `-deprecatedrpc=generate`
  configuration option.
- Be reminded that parts of the `validateaddress` command have been
  deprecated and moved to `getaddressinfo`. The following deprecated
  fields have moved to `getaddressinfo`: `ismine`, `iswatchonly`,
  `script`, `hex`, `pubkeys`, `sigsrequired`, `pubkey`, `embedded`,
  `iscompressed`, `label`, `timestamp`, `hdkeypath`, `hdmasterkeyid`.
- The `addresses` field has been removed from the `validateaddress`
  and `getaddressinfo` RPC methods.  This field was confusing since
  it referred to public keys using their P2PKH address.  Clients
  should use the `embedded.address` field for P2SH or P2WSH wrapped
  addresses, and `pubkeys` for inspecting multisig participants.
- Due to apparent lack of interest, the `verifyscript` method has been
  removed.
REST changes
- A new `/rest/blockhashbyheight/` endpoint is added for fetching the
  hash of the block in the current best blockchain based on its height
  (how many blocks it is after the Genesis Block). This replaces the
  older `/rest/blockhash/` endpoint which did the same thing, and is
  now deprecated. Note that the new API uses a HTTP 404 Not Found
  response for heights beyond the current chain length, has inverted
  the order of bytes for hex format, and uses a "blockhash" key for
  JSON format.
- The `/rest/mempool/info.json` endpoint now has a `loaded` key in the
  result to indicate completed loading of the saved mempool cache (or that
  it was skipped or absent).
- A new REST `/rest/mempool/info/with_fee_histogram` endpoint parallels
  `/rest/mempool/info`, but adds a fee histogram to the result.
Graphical User Interface (GUI)
- BIP 61 reject messages are now deprecated. Reject messages have no use
  case on the P2P network and are only logged for debugging by most
  network nodes. Furthermore, they increase bandwidth and can be harmful
  for privacy and security. It has been possible to disable BIP 61
  messages since v0.17 with the `-enablebip61=0` option. BIP 61 messages
  will be disabled by default in a future version, before being removed
  entirely.
Low-level changes
This section describes RPC changes mainly useful for testing, mostly not
relevant in production. The changes are mentioned for completeness.
- The `submitblock` RPC previously returned the reason a rejected block
  was invalid the first time it processed that block, but returned a
  generic "duplicate" rejection message on subsequent occasions it
  processed the same block.  It now always returns the fundamental
  reason for rejecting an invalid block and only returns "duplicate" for
  valid blocks it has already accepted.
- A new `submitheader` RPC allows submitting block headers independently
  from their block.  This is likely only useful for testing.
- The `signrawtransactionwithkey` and `signrawtransactionwithwallet`
  RPCs have been modified so that they also optionally accept a
  `witnessScript`, the witness script in the case of a P2WSH or
  P2SH-P2WSH output. This is compatible with the change to
  `listunspent`.
- For the `walletprocesspsbt` and `walletcreatefundedpsbt` RPCs, if the
  `bip32derivs` parameter is set to true but the key metadata for a
  public key has not been updated yet, then that key will have a
  derivation path as if it were just an independent key (i.e. no
  derivation path and its master fingerprint is itself).
- The `-usehd` configuration option was removed in version 0.16. From
  that version onwards, all new wallets created are hierarchical
  deterministic wallets. This release makes specifying `-usehd` an
  invalid configuration option.
- This release allows peers that your node automatically disconnected
  for misbehavior (e.g. sending invalid data) to reconnect to your node
  if you have unused incoming connection slots.  If your slots fill up,
  a misbehaving node will be disconnected to make room for nodes without
  a history of problems (unless the misbehaving node helps your node in
  some other way, such as by connecting to a part of the Internet from
  which you don't have many other peers).  Previously, Bitcoin Knots
  banned the IP addresses of misbehaving peers for a period of time
  (default of 1 day); this was easily circumvented by attackers with
  multiple IP addresses. If you manually ban a peer, such as by using
  the `setban` RPC, all connections from that peer will still be
  rejected.
- The key metadata will need to be upgraded the first time that the HD
  seed is available.  For unencrypted wallets this will occur on wallet
  loading.  For encrypted wallets this will occur the first time the
  wallet is unlocked.
- Newly encrypted wallets will no longer require restarting the
  software. Instead such wallets will be completely unloaded and
  reloaded to achieve the same effect.
- A sub-project of Bitcoin Core now provides Hardware Wallet Interaction
  (HWI) scripts that allow command-line users to use several popular
  hardware key management devices with Bitcoin Knots.  See their [project
  page]( for details.
- This release changes the Random Number Generator (RNG) used from
  OpenSSL to Bitcoin Core's implementation, although entropy gathered
  by Bitcoin Knots is fed out to OpenSSL and then read back in when the
  program needs strong randomness. This moves Bitcoin Knots a little
  closer to no longer needing to depend on OpenSSL, a dependency that
  has caused security issues in the past.  The new implementation
  gathers entropy from multiple sources, including from hardware
  supporting the rdseed CPU instruction.
0.18.0 change log
 Consensus
- n/a *Update checkpoints and chain params, adding a new checkpoint at block 571,392 (luke-jr)
 Policy
-  *Policy-accept sending to future native witness outputs with -sendtofuture=1 (luke-jr)
-  *Policy: Enable -sendtofuture=1 by default (except with -corepolicy) - n/a *Reduce default block size/weight to a safer 300kB/1.5MWU (luke-jr)
 Mining
-  Mining: Enforce that segwit option must be set in GBT (jnewbery)
 Block and transaction handling
-  Report progress in ReplayBlocks while rolling forward (promag)
-  validation: Pass tx pool reference into CheckSequenceLocks -  validation: Assert that pindexPrev is non-null when required -  index: Fix for indexers skipping genesis block (jimpo)
-  mempool, validation: Explain `cs_main` locking semantics (MarcoFalke)
-  Default `-whitelistforcerelay` to off (sdaftuar)
-  Granular invalidateblock and RewindBlockIndex (MarcoFalke)
-  Move CheckBlock() call to critical section (hebasto)
-  *validation: flush state after initial sync (andrewtoth)
 P2P protocol and network code
-  Remove dead code for nVersion=10300 (MarcoFalke)
-  BIP 158: Compact Block Filters for Light Clients (jimpo)
-  blockfilter: Avoid out-of-bounds script access (jimpo)
-  Switch nPrevNodeCount to vNodesSize (pstratem)
-  Skip stale tip checking if outbound connections are off or if reindexing (gmaxwell)
-  Never bind `INADDR_ANY` by default, and warn when doing so explicitly -  Make peer timeout configurable, speed up very slow test and ensure correct code path tested (zallarak)
-  Implement poll (pstratem)
-  IsReachable is the inverse of IsLimited (DRY). Includes unit tests -  Drop IsLimited in favor of IsReachable (Empact)
-  Return of the Banman (dongcarl)
-  Allow connections from misbehavior banned peers (gmaxwell)
-  Correct comparison of addr count (dongcarl)
-  Add missing locking annotation for vNodes. vNodes is guarded by cs_vNodes (practicalswift)
-  Select orphan transaction uniformly for eviction (sipa)
-  Ensure tried collisions resolve, and allow feeler connections to existing outbound netgroups (sdaftuar)
-  *Do not query all DNS seed at once (sipa)
-  *torcontrol: Use the default/standard network port for Tor hidden services, even if the internal port is set differently (luke-jr)
-  *torcontrol: Query Tor for correct -onion configuration (luke-jr)
-  *Ignore BIP-152 HB requests from non-witness peers. (gmaxwell)
 Wallet
-  Remove unused `dummy_tx` variable from FillPSBT (dongcarl)
-  Don't report `minversion` wallet entry as unknown (instagibbs)
-  Add checks for settxfee reasonableness (ajtowns)
-  Avoid locking `cs_main` in some wallet RPC (promag)
-  Add CMerkleTx::IsImmatureCoinBase method (Empact)
-  Remove accounts RPCs (jnewbery)
-  Kill accounts (jnewbery)
-  Add AssertLockHeld assertions in CWallet::ListCoins (ryanofsky)
-  Remove deprecated wallet rpc features from `bitcoin_server` -  Set `encrypted_batch` to nullptr after delete. Avoid double free in the case of NDEBUG (practicalswift)
-  Remove `ENABLE_WALLET` from `libbitcoin_server.a` (jnewbery)
-  Reopen CDBEnv after encryption instead of shutting down (achow101)
-  Remove `-usehd` option (jnewbery)
-  Remove trailing separators from `-walletdir` arg (PierreRochard)
-  Add ListWalletDir utility function (promag)
-  Deprecate `generate` RPC method (jnewbery)
-  Add missing `cs_wallet`/`cs_KeyStore` locks to wallet -  Remove `addwitnessaddress` (jnewbery)
-  Add BIP70 deprecation warning (jameshilliard)
-  Fix duplicate fileid detection (ken2812221)
-  Remove `fs::relative` call and fix listwalletdir tests (promag)
-  Add SegWit support to importmulti (MeshCollider)
-  Add WalletLocation class (promag)
-  Require a public key to be retrieved when signing a P2PKH input -  Show error to user when corrupt wallet unlock fails (MeshCollider)
-  Detect duplicate wallet by comparing the db filename (ken2812221)
-  Remove redundant KeyOriginInfo access, already done in CreateSig -  Add ability to convert solvability info to descriptor (sipa)
-  Log env path in `BerkeleyEnvironment::Flush` (promag)
-  Add expansion cache functions to descriptors (unused for now) (sipa)
-  Fix ScanForWalletTransactions to return an enum indicating scan result: `success` / `failure` / `user_abort` (Empact)
-  Replace CAffectedKeysVisitor with descriptor based logic (sipa)
-  Initialize `stop_block` in CWallet::ScanForWalletTransactions -  Overhaul `importmulti` logic (sipa)
-  Avoid leaking nLockTime fingerprint when anti-fee-sniping -  Introduce SafeDbt to handle Dbt with free or `memory_cleanse` raii-style (Empact)
-  Remove uses of chainActive and mapBlockIndex in wallet code -  Clarify rescanblockchain doc (MarcoFalke)
-  Remove `boost::optional`-related false positive -Wmaybe-uninitialized warnings on GCC compiler (hebasto)
-  [Tools] bitcoin-wallet - a tool for creating and managing wallets offline (jnewbery)
-  Free BerkeleyEnvironment instances when not in use (ryanofsky)
-  Do not import private keys to wallets with private keys disabled -  Descriptor expansions only need pubkey entries for PKH/WPKH (sipa)
-  Add missing `cs_db` lock (promag)
-  Releases dangling files on `BerkeleyEnvironment::Close` (promag)
-  Allow descriptor imports with importmulti (MeshCollider)
-  Add lock annotation for mapAddressBook (MarcoFalke)
-  Allow creating blank (empty) wallets (alternative) (achow101)
-  [wallet-tool] Close bdb when flushing wallet (jnewbery)
-  Log absolute paths for the wallets (hebasto)
-  Factor out PSBT utilities from RPCs for use in GUI code; related refactoring (gwillen)
-  Add P2SH-P2WSH support to listunspent RPC (MeshCollider)
-  Import key origin data through descriptors in importmulti (achow101)
-  Import watch only pubkeys to the keypool if private keys are disabled -  Descriptor checksums (sipa)
-  Use a single wallet batch for `UpgradeKeyMetadata` (jonasschnelli)
-  Remove unused `TransactionError` constants (MarcoFalke)
-  Log and ignore errors in ListWalletDir and IsBerkeleyBtree (promag)
-  Pass privkey export DER compression flag correctly (fingera)
-  Fix assertion in `CKey::SignCompact` (promag)
-  Start to separate wallet from node (ryanofsky)
-  Fix: importmulti only imports origin info for PKH outputs (sipa)
-  *Bugfix: dummywallet: Add -ignorepartialspends to list of ignored wallet options (luke-jr)
-  *[rpc] walletcreatefundedpsbt: use wallet default RBF (Sjors)
-  *RPC/Wallet: Use BroadcastTransaction for sweepprivkeys to ensure wallet is synced before we return (luke-jr)
-  *wallet/rpc: add maxfeerate parameter to testmempoolaccept and sendrawtransaction (kallewoof)
 RPC and other APIs
-  Prevent concurrent `savemempool` (promag)
-  Remove getinfo deprecation warning (jnewbery)
-  Add `submitheader` (MarcoFalke)
-  PSBT key path cleanups (sipa)
-  Preserve a format of RPC command definitions (kostyantyn)
-  Return more specific reject reason for submitblock (MarcoFalke)
-  rest: Improve performance for JSON calls (alecalve)
-  Remove warning for removed estimatefee RPC (jnewbery)
-  Consistency fixes for RPC descriptions (ch4ot1c)
-  Add key origin support to descriptors (sipa)
-  Always throw in getblockstats if `-txindex` is required (promag)
-  Add possibility to preserve labels on importprivkey (marcoagner)
-  Use `RPCHelpMan` to generate RPC doc strings (MarcoFalke)
-  Correctly name RPC arguments (MarcoFalke)
-  Use `RPCHelpMan` for all RPCs (MarcoFalke)
-  Pass argument descriptions to `RPCHelpMan` (MarcoFalke)
-  http: Fix HTTP server shutdown (promag)
-  Assert that named arguments are unique in `RPCHelpMan` (promag)
-  Document default values for optional arguments (MarcoFalke)
-  RPCHelpMan: Support required arguments after optional ones -  Fix data race (UB) in InterruptRPC() (practicalswift)
-  rpcwallet: Add missing transaction categories to RPC helptexts -  Clarify RPC `getrawtransaction`'s time help text (benthecarman)
-  Remove `cs_main` lock from blockToJSON and blockheaderToJSON (promag)
-  Document `bytessent_per_msg` and `bytesrecv_per_msg` (MarcoFalke)
-  Correct `reconsiderblock `help text, add test (MarcoFalke)
-  Avoid permanent `cs_main` lock in `getblockheader` (promag)
-  Add `getrpcinfo` command (promag)
-  Expand help text for `importmulti` changes (jnewbery)
-  remove duplicate solvable field from `getaddressinfo` (fanquake)
-  zmq: log outbound message high water mark when reusing socket -  rest: Improve tests and documention of /headers and /block (promag)
-  rest: Add blockhash call, fetch blockhash by height (jonasschnelli)
-  Compile on GCC4.8 (MarcoFalke)
-  RPCHelpMan: Pass through Result and Examples (MarcoFalke)
-  Remove lookup to UTXO set from GetTransaction (amitiuttarwar)
-  remove deprecated mentions of signrawtransaction from fundraw help -  Add `deriveaddresses` RPC util method (Sjors)
-  Don't ignore `-maxtxfee` when wallet is disabled (JBaczuk)
-  Fix for segfault if combinepsbt called with empty inputs -  RPCHelpMan: Check default values are given at compile-time -  mining: Omit uninitialized currentblockweight, currentblocktx -  Additional utility RPCs for PSBT (achow101)
-  Actually throw help when passed invalid number of params (MarcoFalke)
-  Consistent range arguments in scantxoutset/importmulti/deriveaddresses (sipa)
-  deriveaddresses: add range to CRPCConvertParam (Sjors)
-  Fix overflow bug in analyzepsbt fee: CAmount instead of int (sipa)
-  Consistently validate txid / blockhash length and encoding in rpc calls (Empact)
-  Remove the addresses field from the getaddressinfo return object - n/a *Bugfix: httpserver: Close listen socket if we fail to make an evhttp handle (luke-jr)
-  *rpc: Expose g_is_mempool_loaded via getmempoolinfo and /rest/mempool/info.json (Empact)
-  *rpc: Show scanning details in getwalletinfo (promag)
-  *Add feerate histogram to getmempoolinfo (jonasschnelli)
-  *rpc/gui: Refactor 'Unknown block versions being mined' warning - n/a *Removed verifyscript method (luke-jr)
- n/a *Removed libbitcoinconsensus Script debugging support (luke-jr)
-  *rpc: Serialize in getblock without cs_main (MarcoFalke)
 GUI
-  Compile `boost::signals2` only once (MarcoFalke)
-  Make proxy icon from statusbar clickable (mess110)
-  Use new Qt5 connect syntax (promag)
-  Also log and print messages or questions like bitcoind (MarcoFalke)
-  Avoid system harfbuzz and bz2 (theuni)
-  Fix QCompleter popup regression (hebasto)
-  Set C locale for amountWidget (hebasto)
-  Add `Blocksdir` to Debug window (hebasto)
-  Remove unused `adjustedTime` parameter (hebasto)
-  Remove the "Pay only required fee?" checkbox (hebasto)
-  qt, docs: Fix `bitcoin-qt -version` output formatting (hebasto)
-  When private key is disabled, only show watch-only balance -  Remove hidden columns in coin control dialog (promag)
-  Fix `boost::signals2::no_slots_error` in early calls to InitWarning -  Cleanup SplashScreen class (hebasto)
-  Use window() instead of obsolete topLevelWidget() (hebasto)
-  Refactoring with QString::toNSString() (hebasto)
-  Fix broken notificator on GNOME (hebasto)
-  Correct misleading "overridden options" label (hebasto)
-  Notificator class refactoring (hebasto)
-  Use `WalletModel*` instead of the wallet name as map key (promag)
-  Add BitcoinApplication & RPCConsole tests (ryanofsky)
-  implements concept for different disk sizes on intro (marcoagner)
-  Replace remaining 0 with nullptr (Empact)
-  Fix minimized window bug on Linux (hebasto)
-  Fix confirmed transaction labeled "open" ( (hebasto)
-  Show current wallet name in window title (promag)
-  "Peers" tab overhaul (hebasto)
-  Remove redundant stopThread() and stopExecutor() signals (hebasto)
-  Add workaround for QProgressDialog bug on macOS (hebasto)
-  Add WalletController (promag)
-  Improve "help-console" message (hebasto)
-  Fix window title update (promag)
-  Fix wallet selector size adjustment (hebasto)
-  Remove macOS launch-at-startup when compiled with > macOS 10.11, fix memory mismanagement (jonasschnelli)
-  Correct units for "-dbcache" and "-prune" (hebasto)
-  Change the receive button to respond to keypool state changing -  Fix shutdown order (promag)
-  Fix issue  "gui, wallet: random abort (segmentation fault) -  Fix model overlay header sync (jonasschnelli)
-  Add Open Wallet menu (promag)
-  Fix `m_assumed_blockchain_size` variable value (marcoagner)
-  If BIP70 is disabled, attempt to fall back to BIP21 parsing (luke-jr)
-  Add Close Wallet action (promag)
-  Fix async open wallet call order (promag)
-  Bugfix: GUI: Options: Initialise prune setting range before loading current value, and remove upper bound limit (luke-jr)
-  *CoinControl: Remove selection-only counter (luke-jr)
-  *Replace send-to-self with dual send+receive entries (luke-jr)
-  *Uppercase bech32 addresses in qr codes (benthecarman)
-  *Add Pairing tab with Tor onion address as copyable text and QR code -  *Various improvements for pruning controls (luke-jr)
-  *Bugfix: GUI: bitcoinunits: Don't make unitlist static, since it gets rebuilt every call (luke-jr)
-  *tonalutils: For Tonal support detection, check that the font has all glyphs and they all have the same sizes (luke-jr)
- n/a *update receiving address book description to refer to receive tab for new addresses (HatboyWonder)
- n/a *Qt/Options: Configure sendtofuture using rwconf (luke-jr)
 Build system
-  gitian: Bump descriptors for (0.)18 (fanquake)
-  Enable -Wredundant-decls where available. Remove redundant redeclarations (practicalswift)
-  Add RISC-V support to gitian (ken2812221)
-  Generate MSVC project files via python script (ken2812221)
-  Add README.md to linux release tarballs (hebasto)
-  Remove unused Qt 4 dependencies (ken2812221)
-  Avoid getifaddrs when unavailable (greenaddress)
-  Scripts and tools: increased timeout downloading (cisba)
-  Move `interfaces/*` to `libbitcoin_server` (laanwj)
-  Actually remove `ENABLE_WALLET` (jnewbery)
-  Remove libssl from LDADD unless GUI (MarcoFalke)
-  Upgrade zeromq to 4.2.5 and avoid deprecated zeromq API functions -  lcov: filter /usr/lib/ from coverage reports (MarcoFalke)
-  gitian: Use versioned unsigned tarballs instead of generically named ones (achow101)
-  During 'make clean', remove some files that are currently missed -  Unbreak `make clean` (jamesob)
-  Warn (don't fail!) on spelling errors (practicalswift)
-  Pin to specific versions of Python packages we install from PyPI in Travis (practicalswift)
-  Fix Qt link order for Windows build (ken2812221)
-  Run functional tests and benchmarks under the undefined behaviour sanitizer (UBSan) (practicalswift)
-  Include full version number in released file names (achow101)
-  Remove duplicate libconsensus linking in test make (AmirAbrams)
-  Add `--retry 5` to curl opts in `install_db4.sh` (qubenix)
-  Add `CLIENT_VERSION_BUILD` to CFBundleGetInfoString (fanquake)
-  Qt 5.9.7 (fanquake)
-  Add names to Travis jobs (gkrizek)
-  Allow to configure --with-sanitizers=fuzzer (MarcoFalke)
-  Configure: bitcoin-tx doesn't need libevent, so don't pull it in -  Drop macports support (Empact)
-  Restore compatibility with older boost (Empact)
-  msvc: Fix silent merge conflict between  and  part II -  Makefile.am: add rule for src/bitcoin-wallet (Sjors)
-  Bump minimum Qt version to 5.5.1 (Sjors)
-  Prefer Python 3.4 even if newer versions are present on the system -  msvc: Add rapidcheck property tests (ken2812221)
-  msvc: scripted-diff: Remove NDEBUG pre-define in project file -  gitian: Improve error handling (laanwj)
-  use full version string in setup.exe (MarcoFalke)
-  Visual Studio build configuration for Bitcoin Core (sipsorcery)
-  build\_msvc: Fix the build problem in `libbitcoin_server` (Mr-Leshiy)
-  msvc: build secp256k1 and leveldb locally (ken2812221)
-  msvc: Fix silent merge conflict between  and  -  Add compile time verification of assumptions we're currently making implicitly/tacitly (practicalswift)
-  msvc: Use a single file to specify the include path (ken2812221)
-  contrib: Add gitian build support for github pull request -  gitignore: plist and dat (jamesob)
 Tests and QA
-  appveyor: Clean cache when build configuration changes (Sjors)
-  Fix deprecation in bitcoin-util-test.py (isghe)
-  Replace usage of tostring() with tobytes() (dongcarl)
-  ci: Add appveyor ci (ken2812221)
-  appveyor: fetch the latest port data (ken2812221)
-  Add usage note to check-rpc-mappings.py (masonicboom)
-  Add testing of `value_ret` for SelectCoinsBnB (Empact)
-  travis: Move script sections to files in `.travis/` subject to shellcheck (scravy)
-  travis: Fix missing differentiation between unit and functional tests -  travis: Add cxxflags=-wno-psabi at arm job (ken2812221)
-  Make `combine_logs.py` handle multi-line logs (jnewbery)
-  Fix accidental trunction from int to bool (practicalswift)
-  Add missing locking annotations and locks (`g_cs_orphans`) -  Don't assert(?) with side effects (practicalswift)
-  appveyor: Use clcache to speed up build (ken2812221)
-  Warn (don't fail!) on spelling errors. Fix typos reported by codespell (practicalswift)
-  Integration of property based testing into Bitcoin Core (Christewart)
-  Read reject reasons from debug log, not P2P messages (MarcoFalke)
-  Fix silent merge conflict in `wallet_importmulti` (MarcoFalke)
-  Speed up `knapsack_solver_test` by not recreating wallet 100 times -  Remove redundant BIP174 test from `rpc_psbt.json` (araspitzu)
-  Fixups to "Run all tests even if wallet is not compiled" (MarcoFalke)
-  Reorder tests and move most of extended tests up to normal tests -  `generate` --> `generatetoaddress` change to allow tests run without wallet (sanket1729)
-  Use MakeUnique to construct objects owned by `unique_ptrs` -  Run functional test on Windows and enable it on Appveyor (ken2812221)
-  Write the notification message to different files to avoid race condition in `feature_notifications.py` (ken2812221)
-  appveyor: Move AppVeyor YAML to dot-file-style YAML (MitchellCash)
-  Enforce critical class instance attributes in functional tests, fix segwit test specificity (JustinTArthur)
-  Exclude all tests with difference parameters in `--exclude` list -  Add missing call to `skip_if_no_cli()` (practicalswift)
-  travis: Set codespell version to avoid breakage (MarcoFalke)
-  Don't access out of bounds array index: array[sizeof(array)] (Empact)
-  Remove `rpc_zmq.py` (jnewbery)
-  appveyor: Script improvement (ken2812221)
-  Allow closed RPC handler in `assert_start_raises_init_error` -  Run more tests with wallet disabled (MarcoFalke)
-  Allow arguments to be forwarded to flake8 in lint-python.sh (jamesob)
-  Stop node before removing the notification file (ken2812221)
-  Improve 'CAmount' tests (hebasto)
-  forward timeouts properly in `send_blocks_and_test` (jamesob)
-  Revert "Make qt wallet test compatible with qt4" (MarcoFalke)
-  Show the progress of functional tests (isghe)
-  appveyor: Enable multiwallet tests (ken2812221)
-  travis: Enable qt for all jobs (ken2812221)
-  Test that nodes respond to `getdata` with `notfound` (MarcoFalke)
-  Print dots by default in functional tests (ken2812221)
-  Move deterministic address import to `setup_nodes` (jnewbery)
-  test: Remove travis specific code (MarcoFalke)
-  travis: Compile once on xenial (MarcoFalke)
-  Dry run `bench_bitcoin` as part `make check` to allow for quick identification of assertion/sanitizer failures in benchmarking code -  `example_test.py`: fixup coinbase height argument, derive number clearly (instagibbs)
-  Add invalid P2P message tests (jamesob)
-  Fix value display name in `test_runner` help text (merland)
-  Send fewer spam messages in `p2p_invalid_messages` (jamesob)
-  travis: Fail the ubsan travis build in case of newly introduced ubsan errors (practicalswift)
-  appveyor: Script improvement part II (ken2812221)
-  Add Python dead code linter (vulture) to Travis (practicalswift)
-  `test_node`: `get_mem_rss` fixups (MarcoFalke)
-  util.h: explicitly include required QString header (1Il1)
-  travis: Avoid timeout on verify-commits check (MarcoFalke)
-  travis: Do not specify sudo in `.travis` (scravy)
-  Check specific reject reasons in `feature_block` (MarcoFalke)
-  Add `BOOST_REQUIRE` to getters returning optional (MarcoFalke)
-  Add regtest for JSON-RPC batch calls (domob1812)
-  travis: Run thread sanitizer on unit tests (MarcoFalke)
-  Add Benchmark to test input de-duplication worst case (JeremyRubin)
-  Fix `p2p_invalid_messages` on macOS (jamesob)
-  Add `wallet_encryption` error tests (MarcoFalke)
-  Fix `descriptor_tests` not checking ToString output of public descriptors (ryanofsky)
-  Add AddressSanitizer (ASan) Travis build (practicalswift)
-  bench: Destroy wallet txs instead of leaking their memory -  Better `combine_logs.py` behavior (jamesob)
-  travis: Save cache even when build or test fail (ken2812221)
-  Add CScriptNum decode python implementation in functional suite -  Modify `rpc_bind` to conform to  behaviour (dongcarl)
-  Run scripted-diff in subshell (dongcarl)
-  Allow `test_runner` command line to receive parameters for each test -  Possible fix the permission error when the tests open the cookie file -  `wallet_keypool_topup.py`: Test for all keypool address types -  Refactor importmulti tests (jnewbery)
-  Removed implicit CTransaction constructor calls from tests and benchmarks (lucash-dev)
-  Handle ImportError explicitly, improve comparisons against None -  travis: Enforce python 3.4 support through linter (Sjors)
-  Add test for truncated pushdata script (MarcoFalke)
-  consensus: Check that final transactions are valid (MarcoFalke)
-  travis: Fix travis would always be green even if it fail (ken2812221)
-  Make `g_insecure_rand_ctx` `thread_local` (MarcoFalke)
-  mempool: Verify prioritization is dumped correctly (MarcoFalke)
-  Test for expected return values when calling functions returning a success code (practicalswift)
-  Fix `cuckoocache_tests` TSAN failure introduced in 14935 -  Fix race in `mempool_accept` (MarcoFalke)
-  travis: Enable functional tests in the threadsanitizer (tsan) build job (practicalswift)
-  Remove `thread_local` from `test_bitcoin` (MarcoFalke)
-  Bump timeout to run tests in travis thread sanitizer (MarcoFalke)
-  Avoid race in `p2p_timeouts` (MarcoFalke)
-  pruning: Check that verifychain can be called when pruned -  Upgrade Travis OS to Xenial (gkrizek)
-  Fix running `wallet_listtransactions.py` individually through `test_runner.py` (kristapsk)
-  Rename `rpc_timewait` to `rpc_timeout` (MarcoFalke)
-  Fix `rpc_net.py` `pong` race condition (Empact)
-  Allow running `rpc_bind.py` --nonloopback test without IPv6 -  add invalid tx templates for use in functional tests (jamesob)
-  Correct ineffectual WithOrVersion from `transactions_tests` (Empact)
-  Use `std::vector` API for construction of test data (domob1812)
-  Run `invalid_txs.InputMissing` test in `feature_block` (MarcoFalke)
-  Add basic test for BIP34 (MarcoFalke)
-  Tidy up `wallet_importmulti.py` (amitiuttarwar)
-  Ignore shellcheck warning SC2236 (promag)
-  refactor/lint: Add ignored shellcheck suggestions to an array -  Remove race between connecting and shutdown on separate connections -  Pin shellcheck version (practicalswift)
-  Update all `subprocess.check_output` functions to be Python 3.4 compatible (gkrizek)
-  Build fuzz targets into seperate executables (MarcoFalke)
-  travis: Compile once on trusty (MarcoFalke)
-  Add tests for invalid message headers (MarcoFalke)
-  When testing with --usecli, unify RPC arg to cli arg conversion and handle dicts and lists (achow101)
-  Use wallet to retrieve raw transactions (MarcoFalke)
-  travis: Remove unused `functional_tests_config` (MarcoFalke)
-  Fix race in `p2p_invalid_messages` (MarcoFalke)
-  Make bloom tests deterministic (MarcoFalke)
-  travis: Revert "run extended tests once daily" (MarcoFalke)
-  Make test `updatecoins_simulation_test` deterministic -  add utility to easily profile node performance with perf (jamesob)
-  travis: Only exit early if compilation took longer than 30 min -  Drop RPC connection if --usecli (promag)
-  test: Remove unused --force option (MarcoFalke)
-  minor `p2p_sendheaders` fix of height in coinbase (instagibbs)
-  Test for Windows encoding issue (ken2812221)
-  Added missing tests for RPC wallet errors (benthecarman)
-  remove some magic mining constants in functional tests (instagibbs)
-  travis: Combine --disable-bip70 into existing job (MarcoFalke)
-  fuzz: Add `test/fuzz/test_runner.py` and run it in travis -  Add missing `cs_main` locks required when accessing pcoinsdbview, pcoinsTip or pblocktree (practicalswift)
-  fuzz: Script validation flags (MarcoFalke)
-  txindex: interrupt threadGroup before calling destructor (MarcoFalke)
-  Remove manual byte editing in `wallet_tx_clone` func test -  functional: allow custom cwd, use tmpdir as default (Sjors)
-  Remove `-txindex` to start nodes (amitiuttarwar)
-  remove `byte.hex()` to keep compatibility (AkioNak)
-  Always refresh cache to be out of ibd (MarcoFalke)
-  Bump timeout on tests that timeout on windows (MarcoFalke)
-  appveyor: fix cache issue and reduce dependencies build time -  add `rpc_misc.py`, mv test getmemoryinfo, add test mallocinfo -  Add `cs_main` lock annotations for mapBlockIndex (MarcoFalke)
-  lint: Make sure we read the command line inputs using UTF-8 decoding in python (ken2812221)
-  lint: Make all linters work under the default macos dev environment (build-osx.md) (practicalswift)
-  lint: Enable python linters via an array (Empact)
-  *test: Support -cli tests using external bitcoin-cli (luke-jr)
-  *QA: Add wallet_implicitsegwit to test the ability to transform keys between address types (luke-jr)
-  *QA: feature_filelock, interface_bitcoin_cli: Use PACKAGE_NAME in messages rather than hardcoding Bitcoin Core (luke-jr)
-  *QA/mininode: Send all headers upfront in send_blocks_and_test to avoid sending an unconnected one (luke-jr)
-  *test: add test to segwit tests for fee rate when signing raw tx -  *QA: wallet_implicitsegwit: Add tests for -walletimplicitsegwit=0  Platform support
-  utils: Use `_wfopen` and `_wfreopen` on windows (ken2812221)
-  utils: Run commands using UTF-8 string on windows (ken2812221)
-  utils: Convert `fs::filesystem_error` messages from local multibyte to UTF-8 on windows (ken2812221)
-  utils: Make fs::path::string() always return UTF-8 string on windows -  utils: Convert windows args to UTF-8 string (ken2812221)
-  utils: Add fstream wrapper to allow to pass unicode filename on windows (ken2812221)
-  utils: Fix broken windows filelock (ken2812221)
-  Fix windows build error if `--disable-bip70` (ken2812221)
-  windows: Set `_WIN32_WINNT` to 0x0601 (Windows 7) (ken2812221)
-  Call unicode API on Windows (ken2812221)
-  Use `fsbridge::ifstream` to fix Windows path issue (ken2812221)
-  Drop `boost::scoped_array` and use `wchar_t` API explicitly on Windows (ken2812221)
-  Enable bdb unicode support for Windows (ken2812221)
-  *lockedpool: When possible, use madvise to avoid including sensitive information in core dumps or forked process memory spaces (luke-jr)
-  *Handle the result of posix_fallocate system call (lucayepa)
 Miscellaneous
-  contrib: Adjust output to current test format (AkioNak)
-  validation: Log FormatStateMessage on ConnectBlock error in ConnectTip (MarcoFalke)
-  bitcoin-cli: don't translate command line options (HashUnlimited)
-  logging: Only log `using config file path_to_bitcoin.conf` message on startup if conf file exists (leishman)
-  Update univalue subtree (MarcoFalke)
-  init: Remove deprecated args from hidden args (MarcoFalke)
-  Error if # is used in rpcpassword in conf (MeshCollider)
-  Properly generate salt in rpcauth.py (dongcarl)
-  Warn unrecognised sections in the config file (AkioNak)
-  Improve rpcauth.py by using argparse and getpass modules (promag)
-  scripts: Fix detection of copyright holders (cornelius)
-  scripts: Use ` bash` instead of ` (vim88)
-  Scripts: Add trusted key for samuel dobson (laanwj)
-  Tools: improve verify-commits.py script (jlopp)
-  Some simple improvements to the RNG code (sipa)
-  scripts: Remove python 2 import workarounds (practicalswift)
-  Error if rpcpassword contains hash in conf sections (MeshCollider)
-  Add checksum in gitian build scripts for ossl (TheCharlatan)
-  contrib: Allow use of github api authentication in github-merge -  utils and libraries: Make 'blocksdir' always net specific (hebasto)
-  threads: Fix unitialized members in `sched_param` (fanquake)
-  Switch all RNG code to the built-in PRNG (sipa)
-  Scripts and tools: Fix `devtools/copyright_header.py` to always honor exclusions (Empact)
-  Update bitcoin.service to conform to init.md (dongcarl)
-  memory: Construct globals on first use (MarcoFalke)
-  Fix build after pr 15266 merged (hebasto)
-  Update linearize-hashes.py (OverlordQ)
-  util: Add setuphelpoptions() (MarcoFalke)
-  Scripts and tools: Replace script name with a special parameter -  Use RdSeed when available, and reduce RdRand load (sipa)
-  Improve PID file error handling (hebasto)
-  Pull leveldb subtree (MarcoFalke)
-  Enable PID file creation on WIN (riordant)
-  Fail AppInitMain if either disk space check fails (Empact)
-  Fix invalid memory write in case of failing mmap(?) in PosixLockedPageAllocator::AllocateLocked (practicalswift)
-  streams: Fix broken `streams_vector_reader` test. Remove unused -  Make `LOCK`, `LOCK2`, `TRY_LOCK` work with CWaitableCriticalSection -  Use `std::unordered_set` instead of `set` in blockfilter interface -  Add gitian PGP key for hebasto (hebasto)
-  *Stats: Fix typing issues in memory management logic (luke-jr)
-  *Stats: In weird memory management cases, do the best that makes sense -  *wallet: Escape wallet name in -walletnotify script (promag)
-  *feature: Added ability for users to add a startup command -  *cli: add chain and return network name as per BIP70. (fanquake)
 Documentation
-  Notes about control port and read access to cookie (JBaczuk)
-  correct GetDifficulty doc after  (fanquake)
-  Add new regtest ports in man following  ports reattributions -  Remove misleading checkpoints comment in CMainParams (MarcoFalke)
-  Add disable-wallet section to OSX build instructions, update line in Unix instructions (bitstein)
-  Explain when reindex-chainstate can be used instead of reindex -  `-help-debug` implies `-help` (laanwj)
-  Fix reference to lint-locale-dependence.sh (hebasto)
-  Document `-checklevel` levels (laanwj)
-  Add GitHub PR template (MarcoFalke)
-  doxygen: Fix member comments (MarcoFalke)
-  Split depends installation instructions per arch (MarcoFalke)
-  Add missing apt-get install (poiuty)
-  Fix macOS files description in qt/README.md (hebasto)
-  release process: RPC documentation (karel-3d)
-  Add doc/bitcoin-conf.md (hebasto)
-  Document lint tests (fanquake)
-  Remove explicit storage requirement from README.md (merland)
-  Clarify commit message guidelines (merland)
-  FreeBSD: Document Python 3 requirement for 'gmake check' (murrayn)
-  Add external interface consistency guarantees (MarcoFalke)
-  Make clear function argument case in dev notes (dongcarl)
-  Update OpenBSD build guide for 6.4 (fanquake)
-  Add comment explaining recentRejects-DoS behavior (jamesob)
-  conf: Remove deprecated options from docs, Other cleanup (MarcoFalke)
-  Improve scripted-diff developer docs (dongcarl)
-  A few minor formatting fixes and clarifications to descriptors.md -  Clarify rpcwallet flag url change (JBaczuk)
-  Clarify RPC rawtransaction documentation (jlopp)
-  Less confusing documentation for `torpassword` (fanquake)
-  Fix broken Gmane URL in security-check.py (cyounkins-bot)
-  developer-notes.md: Point out that UniValue deviates from upstream -  Update minimum required Qt (fanquake)
-  Add nice table to files.md (emilengler)
-  Indicate `-rpcauth` option password hashing alg (dongcarl)
-  Add NSIS setup/install steps to windows docs (fanquake)
-  Better explain GetAncestor check for `m_failed_blocks` in AcceptBlockHeader (Sjors)
-  Improve Windows native build instructions (murrayn)
-  Botbot.me (IRC logs) not available anymore (anduck)
-  Get more info about GUI-related issue on Linux (hebasto)
-  Add more Doxygen information to Developer Notes (ch4ot1c)
-  Fix download link in doc/README.md (merland)
-  Clarifying testing instructions (benthecarman)
-  Add FreeBSD build notes link to doc/README.md (fanquake)
-  Explain what .python-version does (Sjors)
-  Add information about security to the JSON-RPC doc (harding)
-  Update python docs to reflect that wildcard imports are disallowed -  Get rid of badly named `doc/README_osx.md` (merland)
-  Correct logging return type and RPC example (fanquake)
-  Gdb attaching to process during tests has non-sudo solution -  Small updates to `getrawtransaction` description (amitiuttarwar)
-  Add missing `bitcoin-wallet` tool manpages (MarcoFalke)
-  netaddress: Make IPv4 loopback comment more descriptive (dongcarl)
-  Minor textual improvements in `translation_strings_policy.md` -  importmulti: add missing description of keypool option (harding)
-  Add missing newline to listunspent help for witnessScript (harding)
-  Add separate productivity notes document (dongcarl)
-  Update FreeBSD build guide for 12.0 (fanquake)
-  Add info about factors that affect dependency list (merland)
-  Explain that mempool memory is added to `-dbcache` (Sjors)
-  Slight tweak to the verify-commits script directions (droark)
-  Remove misleading hint in getrawtransaction (MarcoFalke)
-  Update release process for snap package (MarcoFalke)
-  doc: Remove berkeleydb PPA from linux build instructions (MarcoFalke)
-  Correct `analyzepsbt` rpc doc (fanquake)
-  Add comment describing `fDisconnect` behavior (dongcarl)
-  getrpcinfo docs (benthecarman)
-  Update bips.md for 0.18.0 (sipa)
-  List new RPCs in psbt.md and descriptors.md (sipa)
-  correct bitcoinconsensus_version in shared-libraries.md (fanquake)
-  describe onlynet option in doc/tor.md (jonatack)
-  mention creating application support bitcoin folder on OSX (JimmyMow)
-  Clarify RPC versioning (MarcoFalke)
Thanks to everyone who directly contributed to this release:
- 1Il1
- 251
- Aaron Clauson
- Adam Jonas
- Akio Nakamura
- Alexander Leishman
- Alexey Poghilenkov
- Amir Abrams
- Amiti Uttarwar
- Andrew Chow
- andrewtoth
- Anthony Towns
- Antoine Le Calvez
- Antoine Riard
- Antti Majakivi
- araspitzu
- Arvid Norberg
- Ben Carman
- Ben Woosley
- benthecarman
- bitcoinhodler
- Carl Dong
- Chakib Benziane
- Chris Moore
- Chris Stewart
- Chun Kuan Lee
- Cornelius Schumacher
- Cory Fields
- Craig Younkins
- Cristian Mircea Messel
- Damian Mee
- Daniel Ingram
- Daniel Kraft
- David A. Harding
- DesWurstes
- Dimitri Deijs
- Dimitris Apostolou
- Douglas Roark
- DrahtBot
- Emanuele Cisbani
- Emil Engler
- Eric Scrivner
- fridokus
- Gal Buki
- Gleb Naumenko
- Glenn Willen
- Graham Krizek
- Gregory Maxwell
- Gregory Sanders
- gustavonalle
- Harry Moreno
- Hennadii Stepanov
- Isidoro Ghezzi
- Jack Mallers
- James Hilliard
- James O'Beirne
- Jameson Lopp
- Jeremy Rubin
- Jesse Cohen
- Jim Posen
- John Newbery
- Jon Layton
- Jonas Schnelli
- Jo?o Barbosa
- Jordan Baczuk
- Jorge Tim?n
- Julian Fleischer
- Justin Turner Arthur
- Karel B?lek
- Karl-Johan Alm
- Kaz Wesley
- ken2812221
- Kostiantyn Stepaniuk
- Kristaps Kaupe
- Lawrence Nahum
- Lenny Maiorani
- liuyujun
- Luca Venturini
- lucash-dev
- luciana
- Luke Dashjr
- marcaiaf
- marcoagner
- MarcoFalke
- Martin Erlandsson
- Marty Jones
- Mason Simon
- Michael Ford
- Michael Goldstein
- Michael Polzer
- Mitchell Cash
- mruddy
- Murray Nesbitt
- OverlordQ
- Patrick Strateman
- Pierre Rochard
- Pieter Wuille
- poiuty
- practicalswift
- priscoan
- qubenix
- riordant
- Russell Yanofsky
- Samuel Dobson
- sanket1729
- Sjors Provoost
- Stephan Oeste
- Steven Roose
- Suhas Daftuar
- TheCharlatan
- Tim Ruffing
- Tobias Kaderle
- Vidar Holen
- vim88
- Walter
- Wladimir J. van der Laan
- Zain Iqbal Allarakhia
As well as everyone that helped translating on [Transifex]

@_date: 2019-05-06 20:17:09
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Taproot proposal 
There are multiple references to "space savings", but no rationale for treating "space" as something to save or even define. The costs are in CPU time and I/O (which "space saving" doesn't necessarily reduce) and bandwidth (which can often be reduced without "space saving" in commitments). The proposal can apparently be made simpler by ignoring this irrelevant "space saving" goal.
Tagged hashes put the tagging at the start of the hash input. This means implementations can pre-cache SHA2 states, but it also means they can't reuse states to produce data for different contexts. (I'm not sure if there is a use for doing so... but maybe as part of further hiding MAST branches?)
Is there any way to use the Taproot construct here while retaining external script limitations that the involved party(ies) *cannot* agree to override? For example, it is conceivable that one might wish to have an unconditional CLTV enforced in all circumstances.
It may be useful to have a way to add a salt to tap branches.
Some way to sign an additional script (not committed to by the witness program) seems like it could be a trivial addition.

@_date: 2019-05-08 13:10:17
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Taproot proposal 
This would be especially useful for things like OP_CHECKBLOCKATHEIGHT:

@_date: 2019-11-08 15:07:36
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] CVE-2017-18350 disclosure 
CVE-2017-18350 is a buffer overflow vulnerability which allows a malicious SOCKS proxy server to overwrite the program stack on systems with a signed `char` type (including common 32-bit and 64-bit x86 PCs).
The vulnerability was introduced in 60a87bce873ce1f76a80b7b8546e83a0cd4e07a5 (SOCKS5 support) and first released in Bitcoin Core v0.7.0rc1 in 2012 Aug 27.
A fix was hidden in d90a00eabed0f3f1acea4834ad489484d0012372 ("Improve and document SOCKS code") released in v0.15.1, 2017 Nov 6.
To be vulnerable, the node must be configured to use such a malicious proxy in the first place. Note that using *any* proxy over an insecure network (such as the Internet) is potentially a vulnerability since the connection could be intercepted for such a purpose.
Upon a connection request from the node, the malicious proxy would respond with an acknowledgement of a different target domain name than the one
requested. Normally this acknowledgement is entirely ignored, but if the length uses the high bit (ie, a length 128-255 inclusive), it will be interpreted by vulnerable versions as a negative number instead. When the negative number is passed to the recv() system call to read the domain name, it is converted back to an unsigned/positive number, but at a much wider size (typically 32-bit), resulting in an effectively infinite read into and beyond the 256-byte dummy stack buffer.
To fix this vulnerability, the dummy buffer was changed to an explicitly unsigned data type, avoiding the conversion to/from a negative number.
Credit goes to practicalswift ( for discovering and providing the initial fix for the vulnerability, and Wladimir J. van der Laan for a disguised version of the fix as well as general cleanup to the at-risk code.
- 2012-04-01: Vulnerability introduced in PR - 2012-05-08: Vulnerability merged to master git repository.
- 2012-08-27: Vulnerability published in v0.7.0rc1.
- 2012-09-17: Vulnerability released in v0.7.0.
- 2017-09-21: practicalswift discloses vulnerability to security team.
- 2017-09-23: Wladimir opens PR  to quietly fix vulernability.
- 2017-09-27: Fix merged to master git repository.
- 2017-10-18: Fix merged to 0.15 git repository.
- 2017-11-04: Fix published in v0.15.1rc1.
- 2017-11-09: Fix released in v0.15.1.
- 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.
- 2019-11-08: Vulnerability details disclosure to bitcoin-dev ML.

@_date: 2019-11-11 16:47:04
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution 
It ISN'T low right now...
Extension blocks are not softforks, and are unreasonably convoluted for no real gain. When the time comes, the block size should be increased only using a hardfork.

@_date: 2019-11-11 19:56:15
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Dynamic MaxBlockSize - 3 Byte Solution 
Not likely, so long as spam continues to pad blocks full.
Softforks leave old nodes *working*, so yes, maintaining the correct UTXO Simply "following" is meaningless, as even soft-hardforks are "followed".
If there isn't consensus, then it shouldn't be done, period.

@_date: 2019-11-22 17:13:14
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] CVE-2018-20586 disclosure (log injection 
CVE-2018-20586 is a log injection vulnerability which allows any software with access to the RPC port to create fake or confusing entries in the debug log. Valid authentication (username/password/cookie) for the RPC service is NOT required to exploit this vulnerability, only the ability to connect to the RPC port (which is by default only exposed to the local machine).
The vulnerability was introduced in 40b556d3742a1f65d67e2d4c760d0b13fe8be5b7 ("libevent-based http server") and first released in Bitcoin Core v0.12.0rc1 in 2016 Jan 13. A fix was hidden in 79358817e53ac0a7afa64c747115d492a74e3155 ("rpc: Make HTTP RPC debug logging more informative") released in v0.17.1, 2018 Dec 22.
To be vulnerable, the malicious software must either be running on the same machine as the node, have the ability to proxy connections to the node via the local machine, or the node must be configured to accept RPC connections from a network via which the attacker can connect. Additionally, a human user must read the debug log and act on or otherwise believe the injected data, in a way that is somehow harmful.
Because the node would log the arbitrary POST request from any connection, an attacker can add nearly any content to the request to inject it into the log. To ensure their entire request is injected, standard spaces would need to be replaced with alternative whitespace characters, and newlines would need to become other control characters (such as "\r\v"). Because the injected data must use such non-standard characters, it is most likely to not fool other software parsing the debug log, and only a human visually reading it.
To fix this vulnerability, POST requests are now sanitised before being logged, removing all characters that shouldn't be in an ordinary POST Credit goes to practicalswift ( for discovering and fixing the vulnerability.
- 2015-01-18: Vulnerability introduced in PR - 2015-09-04: Vulnerability merged to master git repository.
- 2016-01-13: Vulnerability published in v0.12.0rc1.
- 2016-02-18: Vulnerability released in v0.12.0.
- 2018-10-25: practicalswift discloses vulnerability to security team.
- 2018-10-31: practicalswift opens PR  to quietly fix vulnerability.
- 2018-11-05: Fix merged to master git repository.
- 2018-11-30: Fix merged to 0.17 git repository.
- 2018-12-07: Fix published in v0.17.1rc1.
- 2018-12-22: Fix released in v0.17.1.
- 2019-06-22: Vulnerability existence disclosed to bitcoin-dev ML.
- 2019-11-22: Vulnerability details disclosure to bitcoin-dev ML.

@_date: 2019-10-06 11:32:33
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIPable-idea: Consistent and better definition of 
But a pubkey is not a Base58 string, and fundamentally different from an address. An address identifies the recipient and the purpose of the payment; a pubkey does not. The pubkey remains with the UTXO; an address does not.
That problem would require using a different term than "address" to address.
A BIP is unlikely to do the job (though it may help).
Neither the address nor pubkey are a password...
Some possible alternative terms would be "invoice id", "payment token", etc.

@_date: 2020-08-18 04:03:54
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.20.1.knots20200815 released 
Bitcoin Knots version 0.20.1.knots20200815 is now available from:
  This release includes new features, various bug fixes and performance
improvements, as well as updated translations.
Please report bugs using the issue tracker at GitHub:
  To receive security and update notifications, please subscribe to:
  For the full release notes and change log, see:

@_date: 2020-12-06 19:36:48
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP - Automated and Secure Communication 
Anything that makes sense to coordinate between different programs is BIP material, not just core Bitcoin protocol...

@_date: 2020-12-16 17:16:54
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] bip48 proposal 
BIP number 48 has not been assigned. Do not self-assign BIP numbers.
Is this intended to be compatible with  ?
On Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev

@_date: 2020-12-18 04:08:30
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] bip48 proposal 
Thanks for explaining where instructions are lacking.
How does this look?

@_date: 2020-12-23 02:15:45
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] BIP Proposal: Wallet Interface 
1) People should not be encouraged to write or use web browsers for their 2) You may want to look over earlier work in this area.

@_date: 2020-01-10 23:37:49
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Modern Soft Fork Activation 
I think BIP 9 is a proven failure, and flag day softforks have their own A) There is no way to unambiguously say "the rules for this chain are ". It leaves the chain in a kind of "quantum state" where the rules could be one thing, or could be another. Until the new rules are violated, we do not know if the softfork was a success or not. Because of this, people will rightly shy away from relying on the new rules. This problem is made worse by the fact that common node policies might not produce blocks which violate the rules. If we had gone with BIP149 for Segwit, it is IMO probable we would still not have a clear answer today to "Is Segwit active or not?"
B) Because of (A), there is also no clear way to intentionally reject the softfork. Those who do not consent to it are effectively compelled to accept it anyway. While it is usually possible to craft an opposing softfork, this should IMO be well-defined and simple to do (including a plan to do so in any BIP9-alike spec).
For these reasons, in 2017, I proposed revising BIP 8 with a mandatory signal, similar to how BIP148 worked: However, the author of BIP 8 has since vanished, and because we had no immediate softfork plans, efforts to move this forward were abandoned temporarily. It seems like a good time to resume this work.
In regard to your goal  I would like to note that after the mandatory signal period, old miners could resume mining unchanged. This means there is a temporary loss of hashrate to the network, but I think it is overall better than the alternatives. The temporary loss of income from invalid blocks will also give affected miners a last push to upgrade, hopefully improving the long run security of the network hashrate.
(P.S. As for your  I do think it is oversimplified in some cases, but we should leave that for later discussion when it actually becomes relevant.)

@_date: 2020-01-12 05:58:33
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Modern Soft Fork Activation 
Long reorgs, only for old nodes, were a possibility, but not a problem.
The p2p network split issues WERE resolved well before activation.
(In fact, Bitcoin Knots still ships with the general p2p fixes.)
There was no measurable difference in community support between BIP148 and Segwit itself, months before BIP148's activation. (There was about 20% that indicated they would support BIP148 "only if Bitcoin Core releases it", which IMO "counts" in this context.)
The only difference was in the opinions of developers. Basing the decision to exclude BIP148 as even an *option* on this basis was IMO improper and shouldn't be repeated. The community's readiness to switch to another fork/build for UASFs is also valuable, but shouldn't be necessary.

@_date: 2020-01-19 17:04:35
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.19.0.1.knots20200104 released 
Bitcoin Knots version 0.19.0.1.knots20200104 is now available from:
  This release includes new features, various bug fixes and performance improvements, as well as updated translations.
Please report bugs using the issue tracker at GitHub:
  To receive security and update notifications, please subscribe to:
  For the full release notes and change log, see:
New features of particular interest
- BIP157 (Neutrino) can be enabled to serve compact block filters to peers.
  This requires both the `-blockfilterindex` and `-peercfilters` options
  enabled, and can also be turned on in the GUI settings under the Network
  tab.
- PSBT support has been experimentally expanded to include the new version and
  proprietary fields, as well as easier usage from the GUI for watch-only
  wallets.
- The Overview tab now has the ability to hide private information. This is
  still an experimental feature, and suggestions for how the new "privacy
  mode" should look can be made on the related Core PR:

@_date: 2020-06-17 02:18:56
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.20.0.knots20200614 released 
Bitcoin Knots version 0.20.0.knots20200614 is now available from:
  This release includes new features, various bug fixes and performance
improvements, as well as updated translations.
Please report bugs using the issue tracker at GitHub:
  To receive security and update notifications, please subscribe to:
  For the full release notes and change log, see:

@_date: 2020-03-04 14:35:16
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion 
In addition to starting with proof-of-funds instead of proof-of-receiver, it would be nice to integrate with Taproot somehow or another. Perhaps OP_MESSAGEONLY is the most straightforward way to do this? It might be a good idea to have a message type after the opcode too.

@_date: 2020-03-07 19:47:36
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] Bitcoin Knots 0.19.1.knots20200304 released 
Bitcoin Knots version 0.19.1.knots20200304 is now available from:
  This release includes new features, various bug fixes and performance
improvements, as well as updated translations.
Please report bugs using the issue tracker at GitHub:
  To receive security and update notifications, please subscribe to:
  For the full release notes and change log, see:

@_date: 2020-05-05 13:00:37
@_author: Luke Dashjr 
@_subject: [bitcoin-dev] On the scalability issues of onboarding millions 
No, it cannot be shifted. This would compromise Bitcoin itself, which for security depends on the assumption that a supermajority of the economy is verifying their incoming transactions using their own full node.
The past few years has seen severe regressions in this area, to the point where Bitcoin's future seems quite bleak. Without serious improvements to the full node ratio, Bitcoin is likely to fail.
Therefore, all efforts to improve the "full node-less" experience are harmful, and should be actively avoided. BIP 157 improves privacy of fn-less usage, while providing no real benefits to full node users (compared to more efficient protocols like Stratum/Electrum).
For this reason, myself and a few others oppose merging support for BIP 157 in If Bitcoin can't do it, then Bitcoin can't do it.
Bitcoin can't solve *any* problem if it becomes insecure itself.
P.S. See also
